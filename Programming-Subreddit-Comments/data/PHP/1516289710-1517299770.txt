I would honestly just look at a new host. Too many good, cheap options out there to be stuck with ancient tech.
you're already leaps and bounds ahead of most of the devs I know.
Almost all programs I know use a combination of PHPUnit and some static analysis tool (CodeClimate, etc). This is just a shameless "we've made something better, let's write some words about it".
How or what for would you use Redis in this scenario?
What frameworks/CMSs do you use know? If you don't, I would suggest Symfony or Laravel (frameworks) and Drupal 8 or WordPress(CMSs). PHPing is my job and all my work is in one of those four buckets. It's not conceptual but being well versed in one or two of these is going to go a long way.
Who is your hosting provider? More than likely they're not going to upgrade their server to because there are a lot of people on it that rely on the versions they have. However, you can probably get them to move you to a newer server that has it. If they can't move you to a server with php 7.x then I would suggest getting a new hosting provider.
I honestly suggest a VPS like DO. Great community and pricing.
I don't think there is any reason in 2018 to have a shared host. You can deploy almost anything with Heroku.
Giving the option is easy, yes. However, many hosting providers prefer to do that on newly provisioned servers rather than ones that are very old where changing settings could break people's sites.
I make some concurrency comparison between uwsgi and nginx-unit. The result is good. Link here -&gt; https://medium.com/@thegavrikstory/performance-comparison-between-nginx-unit-and-uwsgi-python3-4511fc172a4c
UI/UX. As a person who regularly hires web developers it amazes me how they can sometimes be so smart with the backend but produce an application that sucks for the user. Take the time to review every screen from user's perspective - does it have all the expected navigation? Check both desktop and mobile. Find some cool widgets that will make you look like a star to your client/boss.
Is the data all database? If so, why not replication?
Bluehost does 7.0 now, they were extremely slow getting there though. Would recommend 7.1 if you can get it -- there are a handful of improvements that would be nice to have for someone refactoring code. Edit: was off by 0.1
Learn about scaling - you will thank me later.
If A cannot add its own messages to the queue, i dont see the point of having it in the mix. If A is adding its own messages than yes its the ideal way to do this
How to get along with your coworkers. Then teach me (rather: reprogram my brain).
Would that be the only con in the current scenario? So, A can't now, but, at some point, it will be able to broadcast in some way that it has updates. Sorry if it wasn't clear. I'm gonna have to find out if it would just rest POSTs, ability to add to queue, etc.. but regardless, a queue layers makes sense in this scenario certainly.
It is through our ISP, technically a third party. I'm not going to name names since I'm not trying to throw anyone under the bus. It is a major American ISP though. The whole website was already installed/coded before I took it over. I do remember years ago getting them to bump me from 5.2 to 5.4, so I was hoping that this time around would be simpler. I wasn't expecting them to have 7.1, although that is what I would've wanted, but I didn't think 5.6 would've been off the table. It is moot at this point. I just left a meeting with my boss who has given me a green light to select a new host that does what I want.
I have a feeling this is the reason my host isn't with the times. They haven't deployed new servers with newer versions of PHP yet.
Na
I have 7.2.1 and am able to choose between 5.6, 7.0, 7.1and 7.2 Germany all-inkl.com 
Shared hosting, emphasis on shared. Other deployments on that server may not be 7 ready. I‚Äôd stop using shared hosting, personally. Takes minutes to get a server going in AWS etc
Usually what they‚Äôll do is add on a new version and you have to configure your site to point to whatever PHP version they have by setting the file handler. ü§∑üèº‚Äç‚ôÇÔ∏è
apart from being assholes to their customers who point out clear flaws in their products? don't know. haven't used them since.
aws is too expensive when compared to vps/cloud providers.
Agreed. They just announced new pricing. 4 GB ram and 2 cpus for $20 per month is hard to ignore. 
Hosters very often build their own packages (or are paying for maintenance) of key packages.
Just move to a new host.
Could you elaborate? I am currently looking at using them for some low cost deployments (e.g. watchdogs) instead of DO, and it sounds like you have a story.
env files have one thing going for them though: At least it's not yaml
Hostgator can be upgraded through CPanel or even their jail SSH that you can access as even a hatchling plan. That said, hostgator sucks still and is super overpriced and my contract is just now expiring so I'll be moving my domain away. I'm pretty sure they gave me free domain privacy on my first year and now want to charge me $14.95 and I already have to pay a transfer fee to get it out too.
Don't worry, the author also involves Yaml here. ;-)
A hosts data by timestamp, that means you can take B down at any time. What is the difference with a queue? 
Switch hosts. 
I highly recommend VentraIP. They let you choose your PHP version and any C extensions you want installed. They often get new PHP releases before distros like Arch do. EDIT: they also give you shell access, which is just amazing
Maybe in chaturbate
But there's such a thing as doing too much testing, or writing tests that hold the project back and are coupled to implementation specifics, and at the same time fail to detect many real regressions and bugs, even with 100% coverage. Everything in moderation, kids.
I got my job as PHP developer by making a recipe cookbook with database connection, user login. Have ingredients that can be linked to recipes etc. Something like that should do the trick. Check my latest post on some tips on courses etc. Good luck! Once you get started you'll get there in no time :) One more thing, at my company we have a couple of kids 16-18 yr that are still studying. With the shortages at the moment you should not shy away from applying to part time jobs programming. That experience is great and you'll get paid for learning! Oh and don't forget to upload it to github (without database info ofc).
Talking to people. Digging into their problems, try their job out for half an hour and thinking about how to make their lives easier. UI, UX in the context of how these people do their jobs, what they do and why they do it and what the business end result should be, and how to make it better for everyone. You're aiming for win-win-win. Honest to god, everything else should come after this. It shouldn't be compromised on, but sometimes it just has to be. There is no point making a secure, easy to maintain, standards-compliant system that doesn't make peoples lives easier whilst improving the business process. Get it right for the user and the business need, then build a maintainable, secure and beautiful chunk of code that you're proud of. The business is the god, and the users are it's worshippers. You, my friend, are the architect of the church.
Can someone tell me if PHP curl/guzzle can utilize HTTP/2 multiplexing? Or how can I check that by myself? Reason why I'm not sure, is because it's in section "Desired API" on [Guzzle HTTP/2 support page](https://github.com/guzzle/guzzle/issues/1249) This is very important to know, because same page also says that for single HTTP request is HTTP/2 actually slower than HTTP/1.1, so there is really no point in using HTTP/2 if that is the case.
Since OP may not know, DO = [Digital Ocean](https://www.digitalocean.com) ^^Also ^^OP ^^= ^^original ^^poster ^^;)
Laravel has a way built in, `env()` for deal with env variables. I am sure most frameworks have something to deal with variables. I am confused as to what exactly the issue is and what is being solved and what that solution is. What I feel here is that we are over complicating something that doesn't need to be. Maybe I am wrong. 
Depending on the shared host, sometimes it‚Äôs possible to compile PHP/fast_cgi yourself via SSH. It was the recommended route when I used Dreamhost back in the day. They had a tutorial online for how to do it. It wasn‚Äôt exactly the easy route though.
Having political views is one thing. Claiming that you "lost respect" for someone who has opposing views as if yours is the "correct" one is another. *That's* the problem.
I‚Äôm confused... where is the visual management?
whats wrong with yaml?
Yeah. See, I'm fine with opposing political (or other) views. There are benefits and drawbacks to every approach. As an engineer to an engineer, we understand the nature of problems and their alternate solutions, even if we might not immediately recognize the benefits of each from our point of view. But we're not talking about just two potentially equally good opposing views here. We're talking about Trump. We've received a shockingly huge amount of evidence to make a judgment against. Those still in favor definitely deserve to have their intelligence, knowledge and sanity put under suspicion. Also, everyone is free to "lose respect" of someone else. We're not talking about violence here, we're not even talking about raising our voices. /u/The_Ringmaster lost respect of Cal Evans, because Cal is reportedly having startlingly dim views about important developments in the world around us. That's fine. Respect should be earned, not given away.
 If you want one book gauranteed to "level up" your programming its this one: [Higher Order Perl](https://hop.perl.plover.com/book/) and its **completely free** while written for Perl its equally applicable to PHP since the inclusion of lambda and closures in 5.3. This book explains how to apply functional programming concepts to create extremely powerful solutions and explains it in a very simple and clear way. These concepts are oft ignored and widely misunderstood especially in the OOP world. functional programming is one of the most powerful and productive techniques a developer can add to his arsenal but its rarely studied and even more rarely taught.
book list i suggest to almost all devs who have asked * code complete * pragmatic programmer * design patterns * clean code
Well said. You articulated exactly what I was thinking. 
In today's world most major PHP applications are written within some kind of framework or application platform (CMS like wordpress, drupal ,etc..) In the cases i have been hired on to "legacy apps" it was usually part of the job to migrate to a framework. I would be concerned hiring someone without any framework experience. Generally if you had experience in Zend or Symfony i'd say those skills translate enough that i really dont care. I would be a little leery of hiring a laravel developer to work on Symfony or vice versa just becaue the architectural philosophies of those 2 frameworks in particular are extremely different and it will take at least a few weeks to understand them.
You should be using a framework of some kind, but you should also know what's going on behind the scenes. 
You are right, however the Laravel function helps with reading environment variables in the context of your app. Also true is that my choice of words in the post may be confusing. I wanted to, without using an entire framework, read and update remote .env files from projects on multiple servers in a single ‚Äúinterface‚Äù. So while I‚Äôm not fixing any problem, it‚Äôs a tool that someone else may use or build on. It is an entirely unnecessary tool.
I associated visual with ‚Äúweb interface‚Äù . Poor choice of wording I suppose.
Well that would certainly make it simpler. Writing the data into the array is likely the same amount of work as accessing the web interface and filling the form.
Everyone's free to respect whomever they'd like. Everyone is also entitled to his or her own views I just find odd and counterproductive for someone to get so caught up in politics that you lose respect for someone. Or likely, I assume to pretty much only surround yourselves with people who share your views. Are politics really that important that it's the deciding factor to respect someone? There's so much more to life than that. Like I said, I don't care about politics, but I do get slightly annoyed hearing condescending remarks regarding all Trump supporters. Especially a comment like this is absurd. &gt; But to still support Trump in 2018 does speak poorly, in my eyes, of someone's overall intelligence, knowledge and overall aptitude Some of the smartest, genuinely most thoughtful people I've met in my life are very big supporters of Trump. Did you think maybe someone could have a tough stance on immigration support lower taxes, support Israel, be fed up with the media lying, limit unnecessary gov't spendings, not want to be taken advantage of by other countries? Or are you somehow more superior to these people because of their political beliefs?
sure
I am in the pov of somebody who knows php but doesnt have experience yet. I was wondering if it was advantageous for me to create my first web app with only php or with framework and how would a hiring manager think about that
Great advice. Thank you!
You cannot simply replace all white-space with one space; this alters strings. Ex: `var javascript = "Hello world! Why are there so many spaces in this string? It doesn't make sense but they could be legitimately needed.";` Instead you should just use gzip compression which will handle that.
You beat me to it, same with CSS. .some-class :before { content: 'Hello: World!'; } You can have strings with a colon (or semicolon) in here which should retain the space after it.
I forgot that case.. I'll fix it soon. Thanks for the response!
The code is really opinionated. There's even a hard coded check against fontawesome in there. By not creating a composer package and then not documenting how to use the code, it's really hard to set up. Then your minifiers do next to no minification, compared to other packages out there and to top it off you suggest doing this in realtime on each request, rather than providing a system to build your static assets before putting them into production, or during deployments. Add to this the PHP 5.3 basic support and the Java like naming convention for interfaces, I've got to abstain from using this package. Why, in 2018, are we writing software that better supports PHP 5.3, which has not been officially supported for years, than for PHP 7.2, which is current?
For one, it's very slow to parse compared to other formats.
DO recently doubled specs and Linode, Vultr and DO have same pricing. I personally use Vultr and have several months worth credit from a bug bounty. Vultr is pretty good though. Support tickets are answered in 20-30 minutes, and their DNS servers are super fast , supports DNSSEC, CAA records, and snapshots are currently free. https://www.vultr.com/?ref=6885051 is my affiliate URL. You and I both get $10 credit. 
Do both, if you so please. You're not limited to just the one project when showing off your portfolio.
They look like a small but good company. This is the first host with PHP 7.2 support I came across. 
I understand that it should be forward compatible, but with support that low, I wouldn't even be able to confidently do local development against such a code base. It's not like there's any CI set up so that you can validate contributions are fully backwards compatible. How are you testing this yourself? Are there Docker containers out there that ship such old versions? Are you using a virtual machine? Or are you using some form of CI that isn't made obvious from the configuration of your repository? What's the reason behind supporting PHP versions that old?
This would totally never happen if CubeCart were written in something other than PHP.
I think it also depends on the position and tasks he need to fulfill. Should he create a whole new system? Then both is important.. he need to take important choices about which systems he will use and which parts will be from frameworks and which are coded self. Do you have already an own framework? Then knowing Symfony or Laravel is nice to know about some best practices, but won't help for the framework (like the framework we use for a specific area here is so old and "not optimal" that the knowledge of best-practices is more dangerous than good). So knowing "raw" PHP is better at this point. If you have like Symfony, someone with Symfony experience will obviously kick in very good. But the best deal is most times "the more, the better". One of the reasons I loved to go Full Stack rather than sticking to PHP only.. It's wondering me when our senior frontend/backend coders struggle with their respective otherside even if it's easy tasks. Well, I think you have to get interest for that kind of things.. I mean I also struggle at some languages, because I don't care about them. 
"Eyes." Saved you a click. ^(ok, I didn't actually read it at all)
Yes for some projects I have to use it. It is an additional step, like compiling a bunch of source files, before deployment. Every Dev needs a license...
What the fuck is this shitty code ... in 2018 seriously ?
No you can prevent unlicensed use of your software: from time based license to MAC based license... It increases your workload, you will become a license manager for your clients.
But don't most systems that use yaml cache it in the database or redis? So who cares how slow it is? And in the mean time you have a config file format that is quite intuitive and actually designed for the purpose
If you're not using framework, you're a bad developer. It means you stick to underperforming design patterns and solutions. I've seen CTO keep writing mysql queries without ORM in 2017. Don't do this please. You end up being one of the guys who built this: https://www.reddit.com/r/PHP/comments/7rbnoa/cubecart_admin_authentication_bypass/ However truly mastering a framework will require a perfect knowledge of what's going on. You need to be able to read and understand the framework and third party libraries source code if you're ever to debug them, tweak them, and be able to pick the right library for the right task. It's important to constantly explore new solutions, new framework, new third party library, new database, new design pattern. Because every 3 months there's usually something worth implementing in your stack to keep your productivity level high.
api platform definitely is a great project but, https://api-platform.com/docs/core/content-negotiation#header Support for other formats (such as JSONAPI) can be added by creating and registering appropriate encoders and, sometimes, normalizers. According to the doc it does NOT natively support json api, even the title says it: REST and GraphQL framework to build modern API-driven projects So imho you just commented to attack jade and advertise your own project which is not really the open source spirit Or maybe I'm wrong and you're just being supportive ;)
&gt; If you're not using framework, you're a bad developer. It means you stick to underperforming design patterns and solutions. &gt; That's nonsense, for starters, there are times when it's perfectly reasonable not to use a framework. Not every job requires that kind of overhead. Also, you still need to know design patterns and good practice when using a framework, they don't magically build apps for you, so if you're a "bad developer" without a framework, you're probably a bad one with a framework as well. &gt; I've seen CTO keep writing mysql queries without ORM in 2017. Don't do this please. Again this is nonsense, there are plenty of use cases where an ORM is overkill, and there are plenty of use cases where writing SQL queries is more efficient. In fact, if you're building big, complex applications and using an ORM for every query, then THAT makes you a "bad developer" more than anything. &gt; Most companies will expect you to be able to code a react app nowadays Most dead end "full stack" company jobs maybe. 
I don't understand. What is difficult about just using vi/vim/nano/notepad/whatever to edit them? If you have remote access to the machines anyway, that would be much easier.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You are absolutely right. There really isn‚Äôt a reason why you shouldn‚Äôt just ssh and vi.
Yeah, because SQL injection is totally unique to PHP. It's not like [books in other programming languages](https://twitter.com/parimalkumar/status/954259184832466944) teach insecure concepts. /s
Too bad it's EOL :(
This is exactly why I prefer to work with a framework I wrote by myself.
You should start looking for a new hosting provider for your PHP app. Stay away from shared hosting, especially EIG. Go for Linode or DigitalOcean instead. If you find it difficult to setup vps and manage them, then use tools like Ansible for server provisioning or Cloudways like platform for managed [PHP hosting](https://www.cloudways.com/en/php-cloud-hosting.php).
That's a very bad argument. You could have something like this in your code, but will never notice it.
&gt; And in the mean time you have a config file format that is quite intuitive and actually designed for the purpose hahahahahahah
Words can't describe the cringe I experience when I see another one of those "ph" word puns.
Maybe. I‚Äôll do something small after this. Maybe a ‚Äúto do‚Äù web app just for the heck of having experience in php without any framework help. 
No, I am going to write code like this. What's wrong with writing a prepared SQL statement instead on relying on some ORM?
It has in 2.2 (but indeed it's not the one we promote on the front page): https://github.com/api-platform/core/tree/master/src/JsonApi
This is true. That‚Äôs why I don‚Äôt just paste and forget. When I see some example on a board, K usually fiddle around the example to see what comes up
http://forge.laravel.com/ works fantastically, even for non-Laravel projects. 
Can you explain to me how am I going to have this vulnerability when using a prepared SQL statement? This vulnerability existed because every layer of the code was throwing the responsibility on the layer below as if the risk will somehow disappears. When you examine the code it is clear that relaying on an ORM and/or some query builder blinded the developer from seeing this vulnerability.
Agreed, they do have a saas solution but I need to host my own still
There are ways around prepared statements as well, and other indirect attack vectors you wouldn't be aware of. The only reason you've not been hacked yet is because it's also a game of numbers.
Thanks for your answer. Would you please give a practical example.
Its all in good phun
Yes I do. You said that I "might have vulnerabilities" in my code "because only [I] look at [my] code". As if my code is self-aware that it is being watched and it won't reveal the vulnerabilities unless the conscious observer collapses the wave function by looking at the entangled code, which is the "battle-tested framework[,] Symfony".
You really over-estimate your own abilities as a developer.
CQRS + ES is not an intermediate level task... oh boy people are gonna be in for a whirl of hurt.
I don't see any profit from this. But if you will provide composable queries, which allows you to build larger queries from smaller parts, then this could be useful. Right now I found that using just json for queries is pretty much cover all use cases (even with composition).
Not without looking at your codebase. Your argument that this Cubecart Vulnerability vindicates you writing your own framework is where the issue lies. If you use Laravel, Symfony or Zend, then out of the box you get parameterized queries by default. A framework as large as those will have had more experienced people in specific areas dealing with specific things. Like are you sure all your content being rendered on the page is escaped? or do you have to remember to do it? I.E Laravel Blade escapes content by default, and you have to explicitly tell it to not escape content. Similarly, these frameworks will tend to have had security issues in the past, but will have been patched fairly quickly by others and if you subscribe to the appropriate areas, you'll also get a notification of when these pop up. Now what I will say is that you can write your own framework, but, in my opinion, providing you utilise components from other libraries instead of deciding to rewrite something yourself, especially where they deal with a specific thing much better than you could write yourself. E.G Instead of writing your own database driver for models, use Laravel's Eloquent, or pull in Doctrine2, instead of writing a request handler use Symfony's Request Handler, and instead of using `shell_exec` or anything that runs CLI commands within the app use the Symfony Process component, and instead of trying to write your own console use Symfony's Console component. Using some of these may net you benefits in security being applied in areas in which you don't know about, and some are just about not rewriting code that's already out there for you to use. Hopefully that makes sense.
Does your code rewrite itself every year?
Wait. PHP code runs synchronously. Would it be possible to use this to prevent I/O blocking? In my case I've got a program (bot) which runs in a loop. It makes API calls, however those API calls blocks the main thread. How would I prevent this using just PHP? 
One thing I really like about Silex is that it makes it easy to start writing a new project in just one file. I sometimes start something by just writing all my logic into a single file, just to get a deeper feel into what I'm trying to do and how I want to accomplish it. Any semblance of well-organized code structure will come later, if I don't decide to throw it all away (which 9/10 times I do). With Silex this is very simple since I can define a custom Application class and service providers, work with the app instance / container, and define controllers via closures, all in one place. I think Slim might meet this need, if I can get Symfony's psr-7 bridge working in it as a middleware so I don't have to deal directly with PSR-7 requests and responses.
Exactly. Amp is a non-blocking concurrency framework for PHP. In your case take a look at Artax package https://amphp.org/artax/ I think it is exactly what you need.
This is the dumbest thing I've read on reddit today and I just got through reading a guy telling a Venezuelan to just mine bitcoins. The answer is NO btw, unless you have a slave that's also a PHP programmer
In applications that are required to be responsible, and not to freeze on long-running tasks or blocking operations such as network and filesystem I/O or database queries. The idea is to run such operations in background (asynchronously) thus hiding the latency which they bring. So, an application stays *responsive* because it continues with other work, for example, it can return the flow to UI or respond to other events. When running something asynchronously it means a non-blocking execution without waiting for completion.
What about the other comment?
You are talking about parallelism, not asynchronous. Asynchronous and parallelism is not the same thing. Concurrency is NOT a simultaneous execution of multiple things. It is a composition of independently executing things. In asynchronous code we are *dealing* with a lot of different things at once. Parallelism is *doing* a lot of things at once. It looks like the same but these are actually different ideas. Concurrency is about structure, while parallelism is about execution. Asynchronous code mostly deals with time (order of events). And parallel execution often requires more resources so it mostly depends on hardware.
I agree with you in that any one developer reinventing the wheel then he will be in a situation of high probability to code any sort of vulnerability in his code base in the contrary to using a "battle-tested framework". As to your question of how to make sure that for example data being escaped before rendering, to answer this I need to clarify that I will be using a "battle-tested" templating engine which will escape content by default like "Twig". My approach is to take care when I interface with the database by not relying on an ORM because I am aware of the business problem I am here to solve and I know how to get the information I need from the database in a way that will minimize any potential SQL injunction attack. I understand your point of view and I see where are you coming from. However I am from the school of doing what I do best by myself and let others do what they do best. I don't mind using already well made components and packages, but when it comes to the business logic I am working on then it needs to be me (my team) who makes sure it is running as it is supposed to be. All the code I write will be reviewed and penetration tested of course.
Do you mean that the linked solutions don't work?
Depends who's teaching and what they're teaching. CQRS + ES is simple, until you force it to be complicated.
I provided concrete political facts why people support Trump. The fact that you completely ignored them shows that you live in blissful ignorance and really don't understand politics at all. If you want to be taken seriously in political discussions, try actually discussing politics.
You: &gt; I tend to lose respect for people who unnecessarily bring up politics (this is a coding subreddit btw) with holier-than-thou views Also you: &gt; If you want to be taken seriously in political discussions, try actually discussing politics. I said several times this isn't about politics. I could address your points, but see, I actually haven't forgotten which subreddit I'm in, unlike you. Start taking your own advice? And another reason I don't want to continue this conversation is that you've revealed enough about yourself that to talk to you feels like trying to play chess with a pigeon. No matter what I say, you'll poop on the chessboard and declare victory. So have at it. 
&gt; That‚Äôs why you have to think beyond the framework. Don‚Äôt build your application so dependent on it. That's kind of the *point* of a framework. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'm curious. I see people claim that ORMs are inefficient quite often. Which part of the process do you think is inefficient?
Or just use Forge, and manage your .env file easily from the dashboard.
You might read Implementing Domain Driven Design. The java (and php) OOP paradigms make much more sense in the context of aggregate roots and entities. You might also look at some CQRS / Event Sourcing libraries, and a framework (like Laravel). I assume you are wanting to get comfortable with composing larger, more nuanced web applications?
OP wants to convert an EXE into a PHP app. The linked "solution" (singular) is this: php-script-into-a-stand-alone-windows-executable So to follow the trend, you also went with poor reading comprehension? 
I write a lot of libraries, which are mostly standalone tools that do something security-related. Occasionally I'll build something in a framework such as Slim.
Neat, the exact opposite of what OP asked for.
You are the core definition of an asshole that makes this community toxic and disgusting. Shame on you.
Why so aggressive, particularly when responding to someone trying to help? Also, it's not so obvious the OP wants to convert from EXE to PHP; the title is "Php to executable" and says in the description he wants to "convert to executable". It's poorly worded, regardless, so even if it were ultimately misunderstood, I don't see getting huffy about it.
thanks..
Oh no it's not...
No single developer is perfect. Having an open-source codebase with an active community means thousands of developers, many of whom may be aware of vulnerabilities the primary author may not be, have a better chance of finding and fixing them. I mean, this is *literally* an example of another developer helping someone fix a vulnerability that would have likely gone unfnoticed until actively exploited.
PHP comes with [stream_select] (http://php.net/manual/en/function.stream-select.php). This function blocks until either a stream is accessible without blocking or until the timer reaches 0. That allows you to implement non.-blocking IO and timers. There's also [socket_select] (http://php.net/manual/en/function.socket-select.php), but I think stream sockets are used. 
In case you are still confused see the video by [krakjoe](/u/krakjoe): https://www.youtube.com/watch?time_continue=83&amp;v=HAZfDy6HTos
Depends on the ORM and what you‚Äôre doing, but a typical example would be object hydration. Also ORM are generally bad at generating large complex queries, say for reporting, and they end up being inefficient.
A lot of the boring stuff is already done for you. A lot of stuff is baked right in and made available through simplified helper methods. Odds are that any issue you have has already been solved by the frameworks community and documented. Most importantly, you never have to reinvent the wheel. 
From a standpoint of maintainability and security, it would be irresponsible not to use a framework if it's for anyone but yourself.
Of course there are cons that popup from time to time. The biggest one is "Magic". You put something in the box and it turns it into something else, but you haven't a clue how it did it and how to prevent it from doing unneeded stuff. So sometimes, it over complicates things. Of course then you have frameworks that claim to be frameworks, but there more like a bunch of libraries. But I do support the use of some sort of starter (Framework, set of libraries, boiler plates). 
Oh, I agree but from my personal opinion, the benefits of magic outweigh the cons simply because ‚Äúit just works‚Äù. 
Oh, I agree but from my personal opinion, the benefits of magic outweigh the cons simply because ‚Äúit just works‚Äù. 
Both of these answers are correct, and the solution to "magic" is to read and understand the framework/libraries you're using. The best cure for magic is understanding.
It depends on what you're building. Most business applications benefit from a framework for the reasons the other posters listed. For some situations (e.g. authentication required / not particularly data-oriented) a framework could be overhead. Try to read a bit about the problems being solved by frameworks. They are like glasses, you know it when you need them.
A little magic is ok. But, I like to have some control (oh at least think I do).
It‚Äôs clearly sarcasm. But at the same time I don‚Äôt see what the point of the comment is, nobody said this was PHP‚Äôs fault. It‚Äôs the fault of a shitty developer. 
&gt; poor reading comprehension &gt; **convert to executable** an application written in php lol it‚Äôs not perfect grammar but if you read all the words it‚Äôs clear they want to make an exe from a php script
All of the functions in a framework are tested and tested and have bug reports sent in on them, how tested are your roll-your-own solutions? Frameworks often come with integration already built-in for third party libraries and if you see MVC in other applications written for that framework that you can grab it and add to your own application with relative ease. Frameworks allow you to focus on the business that you know (or that your customer knows) while effectively "outsourcing" everything that you don't.
Here's one for you, I see more and more jobs perfering someone with experience in Laravel, Symfony, etc
Because you are not a programming god, other people are better at designing/implementing things then you, and you likely should be trying to stand on their shoulders instead of kicking at their ankles.
Such uplifting and positive words!
all the boilerplate code (90% of your app) is already done and unit tested. would you rather spend more time debugging your template system , home rolled ORM or your critical business logic code
Nice write up. FTP servers are horrible things.
I always use this when someone counters with the "don't use a framework, you'll get boxed in" way of thinking. It's loads easier to bring someone familiar with Laravel or Symfony up to speed than have them try and reason about a roll your own solution. 
The ignorance (and irony) here is simply astounding. Not using a framework says nothing about the design patterns being implemented, and, frankly, has very little to do with design patterns in general. You are confusing a framework with a library. The former being more of an opinion about what conventions to follow when building an application (contollers are kept "here" and named like "this") than any specific design pattern, and the latter a way to not reinvent the wheel. Both have their pros and cons as well. Frameworks allow groups of developers to have a shared approach at the cost of some possible flexibility, and libraries can bring pre-made solutions to your stack while (generally) increasing entropy. Not using any external libraries seems like a stronger signal for under-performing design patterns than lack of a framework. And to be frank, even with many of the popular frameworks out there expressing their opinions in regard to the MVC (an architectural pattern), creating your own routing and action invocation can be dead simple if you decide to bypass things sub-routing (wildcards, re-mapping, using params, etc.) which isn't necessary like 99.9% of the time. I can totally understand not utilizing a framework on a production application that is well-managed with an experienced team that understands how to build a traditional 3-(or 4) layer application. There is no framework that is going to build your domain model and enforce your business rules (the single most important part of any application anyway). And to your point on ORMs... dear god are you misinformed. An ORM is only useful to abstract the absolute simplest of CRUD applications. The moment anything starts to become even remotely complicated (read: deep aggregate roots, bi-directional relationships, models that don't match the schema), the performance becomes totally unacceptable to the point where you essentially have to write SQL anyway. ORMs are a great idea in theory, but impedance mismatch is the Vietnam of programming. With experienced guidance and a small amount of discipline, it is entirely possible to a create rich, consistent, and performant domain model with nothing more than some factories, repositories, and (you guessed it) raw SQL. The majority of your comment wreaks of inexperience, but your last sentence nailed it. 
Imagine you want to write a story. Do you want to start by inventing the language, alphabet, grammar, and syntax? Or do you think it's kinda nice that you can build upon the efforts of everybody else and adopt a common set of assumptions that your readers are already familiar with? :) 
Tell me about it. When I initially started working on Flysystem it was because I was annoyed by working with filesystems. At that time it was mostly for FTP. I thought I'd just do it right once and be done with it. Well I can tell you it doesn't work that way if your project gains popularity. You'll be doing it always üòÇ Very much a "first world problems" and a "boohoo I've got a popular project" kind of thing, I get that. But hey, I'm a dev so I need to complain about something, right?
Hey @MaxGhost I was able to get Alpine Linux with a basic PHP with MySQL support (no openssl) right at 6.1 MB. The downside is, no openssl and no zlib means no composer :-( 
Hey scootstah well for starters, there's a bunch of config files and the CGI Fixpath was in 2 separate config files. This allowed wrong URI endings to access an endpoint it shouldn't have. Secondly, the system didn't support PHP-FPM communicating on sockets. It supported TCP. At the time, that was a major headache. Now, I'm using TCP, because I think it's better. But, not working with sockets rubbed me the wrong way. Lastly, I remember his package needing some lib hash, but, we had our own hashing library and there was a conflict. Which further necessitated having to figure out how to compile PHP so we could tell PHP which hashing library to use. Also, the size of the OS after installing all the packages was just huge. I remember thinking it was intrusive to have to install 159MB of libraries just to run an API that accepts a bunch of text, and spits out a bunch of text
Closed project for what you are looking is: https://www.peachpie.io/ PHP -&gt; .Net Core. That means you can have executable on Windows, Linux, Mac. And the performance advantages are very clear: http://www.peachpie.io/benchmarks
From my experience trying to get someone from Laravel/Symfony to understand JWTs is like trying to get a 5 year old to understand driving a manual transmission car. Sure, they get it eventually, but, it just takes way too much time. On the other hand, the people who roll their own auth systems, seem to get it in 5 minutes
Normally I'd agree with you, but, I remember this one time this guy was trying to upload about 750MB of zipped pictures to a website. And our site kept on crashing. We couldn't figure out why. We were able to get it fixed by essentially changing the controller and reading the body in a different way, but then we had to start maintaining that code base, which sucked.
Personally, I'd trust PDO + my SQL query and prepared data over an ORM any day.
Except, PHP is the language. You don't have to invent anything. The framework is more like writing a story from a Mad-Libs book with maybe a place to add a location, weather, and a dessert menu
So, currently, PHP is 46MB, but that's with everything installed to run a basic Laravel application: ReadLine for Tinker, OpenSSL for composer, LibXML, zLib, libxml2, PostgreSQL. But, compiled without extensions (--disable-all), it's 20MB. So, as you can see, our images are still going to be &gt; 20MB no matter what we do. I'm just trying to figure out how to get it as small as possible
I honestly expected this project to taper off and die already, so kudos to them for perseverance. With that said, are they getting some sort of financial support for creating this?
It turns PHP code into .Net executable. When you write C# or F# in .Net, that code get compiled into interop code, what then in turn gets used in a JIT fashion ( like Java ). This project takes that same step, transforming the PHP code into interop is understandable for the .net Roslyn compiler. So it does not transform the PHP code into C# or F#, it skips that entire process. Think of it like a valid programming language on top of .net, just like C#, F#, ... So what you get is a pure .net application, but written in PHP.
I do something similar. I am working on a deployment project for designers/non-devs that deploys to standard shared LAMP accounts, and I auto-detect FTP/SFTP/SSH. I could mock out these things, but what I want to know is, do real servers work? I've therefore created a "test box" in Docker, and boot it up in my integration tests using Docker Compose. What I'd really like is a test box with an API that says "start the FTP service, create these users, turn off SSH, create an Apache vhost for this user, etc". A bit like cPanel with an API in a single Docker container. That would make for a nice way to turn things on and off to ensure apps that connect via these transports work as well as can be expected. 
&gt; You're a bit of a conundrum. ... You're not using this word correctly. You're not using a lot of words correctly. Stop clinging onto my leg like a puppy desperate for attention and let go, I won't engage further.
They were all so busy trying to figure out if they _could_, they never stopped to think if they _should_.
But docker only needs to download that stuff when it doesn't exist in cache already.
HAHAHAHAHAHA you are too much for me. Thank you so much for the laughs, I honestly haven't laughed this hard in a while. I see you actually have **ZERO** understanding politics, and are proving my point that you are yet another social justice warrior claiming that everyone who supports Trump is evil and stupid apparently. It's clear you aren't a very logical person (how are you a programmer? probably not a good one) and any reasonable person can deduce that. You have done nothing here other than prove how condescending you are to people who don't share your views. The best part by far is how complacent you are, yet as soon as someone debates you logically, you act like child with your ad hominems. Maybe you'll look back on your comments are realize how much of fool you look like. Maybe not
Is your code fully test covered, stress tested, peer reviewed and fully documented? Is anyone that is going to start working with you instantly going to be familiar with the router, db abstraction, view rendering, dependency injection container, service registration, session integration and form handler? I'm guessing no, and that's reason enough to use a framework. When you start a new project do you have all those features completed by just pressing enter because you used a framework?
Workshop attendees were quite happy with it, and many of them were not even PHP devs...
Glad they found it useful! It's a tough subject to get right. Many many ways to do it wrong.
Looks like they're looking: https://twitter.com/pchpcompiler/status/935131346598551552 I think this may be part of a PHD thesis?
Why does everybody have to be so damn condescending about everything. If you don't want to use it then don't, but you have some serious issues when your first and only reaction is to literally shit on someone for doing something that you don't personally approve of. You sir, are the kind of person that makes this sub toxic.
The #1 resource would be [PHP The Right Way](http://www.phptherightway.com/). It provides a ton of info and advice about modern PHP development. In terms of trying to pick it up and learn it, two tools I've found useful for that are the interactive console (`php -a`) and [3v4l.org](https://3v4l.org) which both let you execute php snippets to ensure they behave the way you expect them to. (3v4l has the bonus of being able to run the snippet against a swath of PHP versions, to ensure it behaves consistently on the expected versions.)
Sigh. */me starts cleaning the poop from the chess board*
So I see you're starting to cultivate some sort of obsession with me. How adorable.
Question: Are you already familiar with web-based work in Java and python? One important difference in PHP is that you don't have threads, and your whole program generally starts and ends within the duration of an HTTP request. This makes certain tasks easier, and certain tasks harder.
Why PHP? Why not just go to something like https://readthedocs.org
OK thanks. That convinces me that `NumberFormatter` is advantageous. But I'm trying to insert your example into my code and it is returning an error: PHP Fatal error: Uncaught Error: Class 'NumberFormatter' not found Do I need to include some library, or have something specific installed on my server? Am I misunderstanding something?
You need to install `intl` extension for PHP (see very first section here: http://php.net/numberformatter)
Ah OK. I want to say you mentioned that in your original comment, then removed it--is that true? For some reason I remember *someone* mentioning that I needed to install a package or something. Installing something onto my server *might* prove to be difficult right now, as we're having issues with our server admin. I'll check though. Thanks again.
Amazingly my server admin installed the extension in a few minutes, and I've got it working now. Thanks for that.' I now have one (hopefully) final follow-up. I have a number with two places after the decimal: 1,234.56. I would like to format this as USD currency. I've done so via the code: $formatter = new NumberFormatter('en_US', NumberFormatter::CURRENCY); echo $formatter-&gt;formatCurrency(1234.56, 'USD'); This prints `$1,234.56` to the screen as expected. But what is the proper method of ensuring it prints the integer representation of this number, i.e. the number with no places after the decimal? Is there a particular method of `NumberFormatter` that I can use to do this? I tried first passing the number into `number_format()` but that returned a string, which `formatCurrency` would not accept. I guess I could try parsing that back into a number, but it seems like a roundabout way of doing this.
This is the one I use for static websites and documentation: https://zeroconfig.github.io/Preacher/
None, because blogs are verbal diarrhoea.
It might seem weird, but using an IDE like PHPStorm can be helpful due to auto completion, code templating, and error highlighting. I found my skill level growing much more rapidly than when using notepad++. 
Hmmm... thanks for the idea - I'll consider it.
Thanks - I'll check it out.
Probably for the laravelers is Taylor Otwell and for the Symfonians is Fabien Potentencier, what is funny if you think frameworks are maintained and updated by thousands of people, Taylor and Fabien are just the public images of these projects, sure they created the project at the begin (symfony 0.1 was crap check the source code) and then was improved thanks other developers. In my opinion they are just good with marketing good developers are rarely known, normal people consider Steve Jobs and Bill Gates programmers which might or not be true but they haven't created microsoft, well they could but just a crappy version.
Combination of Reddit and Twitter where people share excellent posts. I follow murze.be since Freek share other people's posts. My biggest advice is follow a couple of people on Twitter and start increasing the number as you learn of more people. So many tips are shared there
You are preaching stuff to Java developer. Not still-in-procedural-world old phper. And it matter not if company isn't using those.
Implicit type coercion. That's biggest difference between Java/Python and PHP. E.g. while 10 == "10" is true, 010 == "010" is false. PHP have boatload of such nuances. Watch out for special language constructs too. E.g. "empty()" is not a function! So best resource for you will be your colleagues at your company. Don't hesitate to ask. Unlike other languages, it may not be your fault but actual PHP mental ilness.
You don't get out much do you? Lightening routinely strikes certain areas not only twice but multiple times.
I'm sorry I haven't been struck by as much lightening as you clearly have.
Jeff Atwood, codinghorror.com
- Freek Van der Herten, developer at Spatie ‚Äî https://murze.be - Phil Sturgeon, Platform Engineer @ WeWork who talks about APIs a lot. Programming Polyglot, Pragmatist, Centerist and Sarcasist. Ex-The League of Extraordinary Packages, PHP The Right Way, Ex-PHP-FIG, Ex-CodeIgniter, Ex-FuelPHP, Ex-PyroCMS ‚Äî https://philsturgeon.uk
I felt blessed the day Phil Sturgeon himself responded to a comment I made here.
Ircmaxell used to be a core PHP developer iirc, definitely knows his stuff https://blog.ircmaxell.com/
Why, would you like to see it die? :( nah, we ain't going anywhere.
What are the downsides? 
Ann Denise.
I've found that following the right people - typically those that have a specific shared niche acts sort if like a good lunch and learn. A good example of this is Alan Storm in the Magento community. He's always uncovering neat things about the library in the ecosystem he works in and so it's always a good read
Marco (ocramius) teaches that topic really well. He did workshop on that topic with when he was consulting at the company that I work at. It was great (we now use both CQRS and ES in our code). Which reminds me, I need to write a blog post about that experience :)
https://ocramius.github.io/ http://verraes.net/ Both those gentlemen should blog more, but they have some really good posts on their sites.
&gt; Why, would you like to see it die? No, I'm just aware of the incredible amount of work it takes to build an interpreter or compiler for such an absurd language.
Lightning strikes in the same place all the time, that's why churches have lightning conductors.
Discourse is a really great PHP app!
Yeah. Probably, this is because the Discourse is written in Ruby?
Similar: https://github.com/madewithlove/elasticsearcher
Well done that's the Jeff Atwood joke.
Yeah it's taking a while; hopefully it will prove useful to some people.
I did manage to make a working website with python using django so I guess I am somewhat familiar with web-base work. I do agree that the hardest thing for me to recognize is "best practice." When I was learning django, I often refer to "two scoops of django" as most django developers seem to recognize it as the de facto best practice guide. I am wondering if php community has a similar guide.
LOL This too funny! You've really taken complacency to a whole new level. All you've done is given emotional responses claiming why any supporter of Trump is stupid and that politics is not about politics. I have provided factual evidence for specific policies, actions and events that have occurred during the Trump administration that his supporters like. Yet you have not responded, because you don't know politics (by your own admission). Somehow you're so smug, that you've convinced yourself you've presented logical arguments, when all you've done is prove that you're a social justice warrior who is extremely ignorant about politics. I'm just glad that Trump will likely continue to improve this country, while also trolling people like you. I'm glad that the SWJ in you is extremely butthurt that he's doing well in his first year and that he'll be the president for the rest of his term (probably feels like an eternity for you hahahaha). The best part is that if he keeps this up, he'll get re-elected too, therefore pissing you off even more :)
I stopped following what he was saying as soon as it turned out he was in the white supremacist bucket.
Not really their blogs, but half the reason I even go to Twitter these days is to read what these people have to say https://twitter.com/CiPHPerCoder https://twitter.com/taylorotwell https://twitter.com/SaraMG https://twitter.com/Ocramius
iircmaxwell
When? I missed something?
https://twitter.com/codinghorror/status/916425704081723394 on top of my head; There was a couple more tweets that happened that were much more brutal and I stopped following him after that. I'm not sure if he kept them or deleted them though
nice list, I stopped following tyler though. too many random rants over the years for my liking.
That's literally your entire previous comment, restated in slightly different words. Are you OK, buddy?
I mostly follow just for the random Laravel tips/news/previews, I just ignore the rants usually.
Seems necessary for someone of your level of intellect and smugness, which I'm deducing from your responses.
Following specific developers leads to tunnel vision and bias, I find. I'd recommend you stick to aggregate sources, so you can see more points of view and make your conclusions. Likewise for PHP developers vs. developers. PHP is a fine script language these days, but the community is lacking in many ways. Aside from the trash blog posts and answers that peddle outdated and insecure PHP4 practices, even the better respected PHP developers are often 5 to 10 years in terms of industry knowledge behind their colleagues working on other mainstream platforms (C#, Java, C++, Node, Python etc.). So, again, love PHP and so on, but always take advice from PHP devs with a grain of salt. Regarding what I follow. I like watching and reading [infoq.com](http://infoq.com), it has a good selection of topics and guest presenters/writers.
&gt; Seems necessary for someone of your level of intellect and smugness, which any impartial person can deduce from your responses. Tell me more.
I find that in twitter people don't really discuss matters in depth. Good list though, I was following everyone already except for Scott Arciszewski.
Makes sense but I have to disagree on the 5 to 10 years industry knowledge gap. Different languages are used for different things so PHP developers are probably better at making websites than java developers who make only desktop apps. Arguably Java programmers making complex Desktop apps are better programmers because they might be dealing with harder problems to solve and bigger applications. But when it comes to application design, testing, continuous delivery and so on, I don't think the PHP developers are lacking behind at all, they might be writing less challenging software though in some cases. Why do you think there is such a large gap? There are some big applications written in PHP now a days such as Facebook or frameworks such as Magento2.
nikic and ircmaxwell both have a lot of good postings about the PHP internals at the C-language level.
&gt; Did you mean to link something else? Probably not.
Thank you! Any arbitrary is a pretty strong expression; we're done with WordPress and about 99% through with MediaWiki, so if we are only talking about pure frameworks or CMSs without any customizations or plugins, we're not all that far away. But it's hard to say whether there will ever be a time when any arbitrary project can run - maybe if the community gets large enough.
Framework, they could get the project off the ground in less time then some one who doesn‚Äôt. How ever, if you have a legacy system and it‚Äôs written in raw, then you‚Äôd want some one more knowledgeable in raw then framework based. Then again if you know framework you know php (generally) It‚Äôs all about the mindset and the project at hand.
You're full of shit. 
I see where you are coming from and I agree that PHP has copied a lot from Java, PHP didn't support OOP until relatively recently so it wasn't even a language you could use to write big, maintainable applications with in my opinion. But I think that was because Java was used for enterprise apps from much earlier, so the Java community solved those problems before the PHP community even had to think about them. All in all I think PHP community is caching up quickly as it is being used to write some big projects, in fact i heard that Magento 2 was written by Java engineers so I think people designing this big projects are just software engineers that don't care about the language being used. But yeah, personally I edited my question earlier adding "Not necessarily PHP developers" precisely because I don't want to discriminate developers because of the language they use, as long as the are influential in the world of software development in general, so I don't want to miss out on some good blogs just because the blogger is a Java developer instead of a PHP one :) Regarding Objective-C and Swift though, I think the successes are directly related to the fact that those languages are the ones needed to make apps for Apple products. I am not saying they are bad because I have never used them but I think even if they were terrible, they would still be super successful if apple forced people to use them to write apps. 
&gt; All in all I think PHP community is caching up quickly as it is being used to write some big projects, in fact i heard that Magento 2 was written by Java engineers You know, it shows in a way. Magento 2 is written in a way that entirely ignores PHP's strengths as a dynamically typed, interpreted scripting language. I don't want to pile on it, but others will say much worse about it. That's the other side of the coin of what I said: you may inform yourself from Java etc. sources, but you still need to understand when you apply that knowledge that PHP is a language with a different shape. They have some overlap, say in the OOP area as you noted. PHP5 OOP was modeled explicitly after Java. But also PHP has smooth sides where Java has corners, and it has corners where Java has smooth sides. They're different enough to consider the differences. And this is why varied sources of learning helps. When you have a bouquet of flavours to base your solutions on, you're much more likely to write PHP like PHP, than write PHP like Java, because you understand how PHP is similar or different than everything else in the industry. &gt; Regarding Objective-C and Swift though, I think the successes are directly related to the fact that those languages are the ones needed to make apps for Apple products. Absolutely, but also at the same time you never hear about Objective-C and Swift projects becoming the kind of nightmares that proponents of "dependency injection containers" scare you about, despite they don't use any. Truth is we believe lots of software myths and legends that aren't true, and the more tunnel our vision is (focusing on specific language or platform), the higher the likelihood we'll fall for those myths and legends.
How come it feels like the only place trying to sell me on docker is /r/php?
No I don't really want to dig into his timeline or another website timeline in case he deleted his tweet to try to convince you. I don't care. Just follow him if you want to (I did as well) and unfollow if you find something offensive and call him out if you feel like you need to. 
Use habitat, with it you can export your application as a package that can be executed on a command line environment under Linux, Mac, it windows. Your package can export any number of php scripts as commands, each using whatever exact version of the PHP interpreter you like, even compiled with your own options and extensions if you need. Your package can also make use of any other commands bundled with habitat, marking each as a distinct dependency and optionally specifying a specific version, community build, or custom build 
Just wait till you let him almost get you killed in NYC. What a great night that was. 
When it comes to users of a web application, the level of detail you could record _is_ finite. At the most, you could record every request and it's payload/timestamp. That can completely represent every action taken by the user in full detail, and doing so has a lot of benefits. Mistakes in your application or data can be fixed and the state retroactively replayed, as long as you can decide the best thing to do with every given request.
I usually don't follow anyone on Twitter who tweets about politics. I don't live in the U.S.
&gt; When it comes to users of a web application, the level of detail you could record is finite. At the most, you could record every request and it's payload/timestamp. That's absolutely false. You need just 30 minutes experience with advanced analytics applications to realize how much information there is to record. Say as just one example to prove you wrong, ever heard of web page hot maps? Some record the literal motion of the mouse cursor, keyboard and mouse clicks of their users, and determine which parts of a page are scrolled to, which buttons are clicked. This is *widely* used. Additionally recording a request/response doesn't tell you much about the internal workings of the app that built this response. Internal API requests, data pathways, stack traces, logs. I mean are you kidding me, there is *tons* of information you can't derive just from the request and response. And my examples are barely scratching the surface here. Data is infinite. The only thing that is finite, is your imagination.
All the UI interactions might be interesting from an analytics perspective, but as far as things that could impact the persistent state of your application goes, there are _a lot_ of cases where recording all requests as events gets you 100% resolution on user input
To the point of there being an infinite amount of potential data to capture, compete requests is a concrete upper bound in normal cases for meaningful information that a user chose to share with your application
I don't agree with Atwood when it comes to some of his opinions, but this really isn't proof of anything. In fact, you're kinda proving his point here.
The ability to come up with examples of where it's a bad idea is irrelevant, that doesn't make it less useful as a strategy in every other case. There's a huge surface area of simpler applications out there already and that need to exist at the human scale. Many of these need to be built cheaply and iterated on quickly. Using event sourcing with the strategy of storing all the detail you can is a great strategy to start with until you actually run into reasons to cut it back. Think about gradebooks, on-the-ground workflow tools, small business operations, etc. Not everyone is building a virustotal.com
Yeah there is. Wasn't sure if you want the rounding or just strip off the decimal part, so I've included both in the example here: https://3v4l.org/nitOT
PHP isn't a main focus, but [Dries Buytaert](https://dri.es/) (Drupal) probably counts.
**Linus's Law** Linus's Law is a claim about software development, named in honor of Linus Torvalds and formulated by Eric S. Raymond in his essay and book The Cathedral and the Bazaar (1999). The law states that "given enough eyeballs, all bugs are shallow"; or more formally: "Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone." Presenting the code to multiple developers with the purpose of reaching consensus about its acceptance is a simple form of software reviewing. Researchers and practitioners have repeatedly shown the effectiveness of various types of reviewing process in finding bugs and security issues, and also that code reviews may be more efficient than testing. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Thanks for the mention, but I'm hardly influential. :)
I mean, I literally work in security software and mainly work with PHP, so there's not many other people who are vocal about that specifically other than you, so it's worth a mention IMO.
Other than who mentioned so far (Ocramius, Nikic, ircmaxell, SaraMG): - Paul M Jones - Sammy K powers (videos too). - Niklas Keller - Cal Evans - The guy behind opulance php (his Twitter account is opulancephp). - Larry Garfield. One of my earliest follows. - Randy Fay (Drupal). - Jeffrey from laracasts. - Jordi "composer" Boggiano. - Sebastian "phpunit" Bergman (surprisingly easy to follow phpunit talks). I'm sure there are many but above is a quick Twitter feed list. 
Do you REALLY want to write a request router?
+1 for Ocramius Saw both of his talks at Confoo Montreal 2017, both very instructive. His blog is pretty nice too.
Agree. Some Real World busy small teams have to take care of their code changes, test for themselves and let their users notify them if they screw up something critical. Anyway they'll notice in matter of minutes if they are really using your app on a daily basis.
I can send you some Magento stickers. And maybe a few ^thousand that I‚Äôve collected at conferences over the past few years...
Thank you :) 
http://devstickers.com
Ah OK. I see now--my mistake for missing all of those predefined constants. I tried your code, and it does indeed work as expected for `$currency='USD'`. But my currency is Thai baht (`THB`). If I switch to `USD` to `THB`, the decimal places are added back in. Thoughts on that? Maybe I should try to strip off the decimal places before passing it to `NumberFormatter`? 
in what year was it ok to be oblivious to SQL injections?
@SaraMG on twitter.
&gt; OP, never assume anything like that on PHP. It depends on the era/conventions of the codebase. The difference between a crufty 2008 codebase and a best-practices one is night-and-day. (PHP-7 return type hints, `strict_types` for runtime checks, commit-hooks to ensure docblocks, a good IDE, and a team who uses `@var`...)
Yeeeeaaahh. I just did the same. Thanks OP for reminding me about it by asking. 
&gt; &gt; Do you know, for example, that in the Objective-C and Swift community almost no one is using or has even heard of "dependency injection containers"? &gt; I posit that almost no one is using these languages to write web applications and web sites. You posit well, but "dependency injection containers" started from Java applications (and no, I don't mean *web* applications, just applications in general, including general-purpose services and desktop apps), not from PHP web sites, so your remark is not relevant. There's no relation whatsoever between DI containers and how "web site" the thing you're writing is. 
So instead of being too narrow and following the people who know what they are doing, we should follow *everyone*? Oh dear, now I'm following a tonne of people who don't know what they are doing...
Lightning quite often strikes the same places. That's the nature of structures that stand tall above others around them.
Somehow you read what I said and understood the exact opposite of what I said. I find that curious. What I said is there are healthy communities of respected professionals from *all* platforms to share knowledge and experiences (and I have an example of one such community: InfoQ), and that PHP developers on *average* are much less skilled, and often peddle ideas which have been long rejected by the wider community. If you don't care about what I'm saying, keep doing what you're doing. I just hope when you follow those people you want to follow, you're better at understanding what they write than you've demonstrated with me.
http://ocramius.github.io/blog/eliminating-visual-debt/ This was very entertaining
Hey guys, I thought it would be good to share this here. I am a PHP software developer and I am starting to document my experience of joining a new team who are adopting agile. I think there is a lot you can pick up from my experience. I will be sharing the usual, what I did well, what I did not do well and any comments. I have been positing tutorials here for over 1 and a half years and you guys seem to love them. So I thought this is something you might like too. IF YOU FEEL LIKE THIS SHOULD NOT BE HERE, MODS PLEASE REMOVE THIS POST.
You know, I think the reason I asked the original question of "Who are the most influential PHP developers in the world whose blogs you follow?" was because as you said, I feel like everyone is talking about the same stuff and I wanted to know if I was missing something, or if there are other sources where you can get more up to date information and learn new things. It makes sense now that other communities are years ahead of PHP so I'd like to learn from them. I wanted to ask you, which communities do you think is leading in terms of software design innovations from which PHP developers could learn? Do you think is the Java community or maybe some of the new programming languages such as Rust or Go?
infoq.com looks great actually, thanks for the suggestion.
What exactly is wrong with autowiring?
It operates on rules that emulate singleton/global registry architectures: there's one instance (or one factory producing same-configured instances) of every type, and everyone can get access to it. The result is inflexible, highly-coupled spaghetti architectures, where components have limited to no re-usability across projects. A good dependency management is about controlling who has access to what, and not placing arbitrary restrictions such as "one instance/factory for Foo" where different components, or even the same component, may call for different instances with different configuration.
Hey there, just wanted to let you know that the video content was good. It will be interesting to see what you continue to discuss as the series continues. A recommendation I have is to manually focus the camera since you aren't moving front-to-back too much. The auto-focus was distracting as you moved your hands or your body by a small amount. The idea of recording yourself with the movements that you make is still nice and personal, so I wouldn't want to see that changed.
If you are able to understand a lot of frameworks, then you are just as able to write a micro framework, that suits the task you need to be done. People at times do not learn PHP anymore but just the frameworks APIs and then run into problem. The complain to the developers on Github filling bugs or have major data leaks because they are running code they do not understand or do not update. Applies to every non-PHP frameworks. Angular -&gt; TypeScript -&gt; And finally you get to Javascript. Too many layers.
Thanks for the feedback. I will change that for sure. There are so many times where I feel like I have a lot to talk about. Self evaluating is also something everyone should do. So I hope this helps me as well as you guys.
You want to impress girls with this? Or attract geeks? 
It's also way to expensive when paying per user and having a 100+ dev team where of 90% only once per few months need to install a PHP project.
Great topic and well presented :) What I am still curious about; how does one prevent the two generals problem in a setup like this when working with projectors? Let's say I have an event and want to send an email and update elasticsearch then any of those could fail... the only way I see to do this properly is to only let the main app produce (store) your event in the event store and have consumers (workers) which handle the events asynchronous... what's your view on this?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
asdf
https://laracasts.com/ While the site focuses on Laravel (PHP Framework), it has a lot of videos on php in general that are usually free.
are you sure?
This isn't how behat scenarios should look like. Please read [Introducing Modelling by Example](http://stakeholderwhisperer.com/posts/2014/10/introducing-modelling-by-example). 
So what the point it there are already documentation which covers that?
Try it and let me know how it compares :)
Thank you 
Thank you
oh wow - I love the look of this. Thanks - I think i'll give it a go (as my docs will be public - so it looks like it'll be free).
YAGNI. If one day you do indeed add App C/D/E/... then you are correct. The right decision is to do the minimum amount of work, and add the minimum complexity to the system to get the functionality you need. If there is any way to get App A to publish directly, then do that, otherwise KISS.
Stop clinging onto my leg like a puppy desperate for attention and let go, I won't engage further. Keep your malfunctions to yourself.
Phase III: The smug, politically-ignorant SJW doesn't understand the concept of "Practice what you preach". In his supercilious mind, he's created many curious delusions, such as thinking that politics is about social justice, **not** policy, believing that throwing ad hominems around like a 5th grader in political debates means that he's won and arrogantly convincing himself he is somehow more superior to someone in every aspect, strictly due to supporting a particular political candidate. Stay tuned next week for new episodes of *I'm morally superior to you* as ImSuperObjective2 goes on Reddit and other social media platforms "educating" people how much better he is than anyone who *doesn't* denounce Trump, in terms knowledge, aptitude, intelligence and morality. The virtue signaling continues this week (no actual policy per usual)! 
Hah, there we go, you're fired up again, talking about SJWs! &gt; I'm Morally Superior to You I've no idea about morally, but intellectually - I can call that with 100% certainty by now. I'm ready to bet money on it. I'm ready to bet 7 figures.
I feel really bad for you that you are clearly suffering from superiority complex. Maybe as a kid you were teased a lot. In any case, it's pretty easy to almost objective tell that someone has self-esteem issues if he gets so angry that he lost a political debate, that he acts like a little kid saying "YOU'RE STUPID! YOU'RE STUPID! YOU'RE STUPID". I hope you find the help you need. Good day, sir.
I don't think I'm superior to most people, I think I'm average, maybe even below average. It's just that I see you're dumb.
Your first statement is still a childish insult, and I would love to hear your justification for it. But your second statement shows that there is another, adult side to you and I wholeheartedly commend you for it. You're right, and I'm sure we have a lot of things in common and would get along. This is also why I feel like politics is the worst. I've seen it break apart so many friendships and I think life would so much better without it. Anyway, thanks again for the mature response :)
&gt; air on the side of caution [Err on the side of caution](http://idioms.thefreedictionary.com/err+on+the+side+of+caution)
As an aside sounds like you could use Saltstack or some other form of configuration management. Very awesome family of tools but a bit of a learning curve. Depends if you feel like a few days effort is worth it.
Thank you for advice!
FYI, Codeception also runs Ghurkin feature tests.
Going to read this and subscribe purely because of the authors name. 
More on your company. If you only hire interns who ‚Äúwant to learn more‚Äù, then your company might become a training ground. How is the turnover rate in your company? My company culture loves this types so they hire fresh grads, employees here usually last just 1 to 2 years.
This is the first time its been explained in a way that makes me see value in the project. At first I was very sceptical. And I really thought you were just trans-piling into C#. Now I think MS would be crazy not to fund you guys. 
Hi all. I'm using the [`NumberFormatter` class](http://php.net/numberformatter) for the first time, to format currency. But I cannot get the proper currency symbol to display. The currency is Thai baht. My code is: $formatter = new NumberFormatter('th_TH', NumberFormatter::CURRENCY); $formatter-&gt;setAttribute(NumberFormatter::FRACTION_DIGITS, 0); echo $formatter-&gt;formatCurrency(1234.56, 'THB') . PHP_EOL; This prints `THB1,235` ([see code here](https://3v4l.org/MNBll)). How can I print the Thai baht symbol (‡∏ø) instead of `THB`? Thanks in advance.
Maybe let him read the blogpost? Or even beter, let him watch Kevlin Henney's video: https://www.youtube.com/watch?v=ZsHMHukIlJY
Plan on having him read this, my coworkers have also talked with me about how hard it is to read our cod.
I always used https://github.com/ruflin/Elastica. Not the client but its query abstraction. Gave me all the conposability I needed. 
So almost like PSR, but not completely? Doing a lot of C# and the { for control statements on a new line is so ffing annoying in that code style, because I barely fit any code on my 1920x1200 screen due to all the extra lines it takes up. It doesn't add to readability if you nest things anyway, so you might as well put the { as PSR recommends, behind the ). 
Like...no indentation at all? If someone needs convincing that‚Äôs a bad idea, you‚Äôre better off just quitting. 
Good luck!
That is too irrational for comfort, it's probably not the only thing wrong there. A unified codestyle helps making code easier to grasp and to maintain. Indentation levels can be indicators of code that needs refactoring (nested ifs or iterations). Naming things can help forming and conveying the right mental model, the right abstractions and the intent of the author. If you're in a scenario in which you can afford it, inform your team and boss on how to improve the development experience and software quality before everyone decides to leave. To me, these would be unacceptable working conditions.
What‚Äôs your stance on code folding to solve that issue? I was very skeptical ar first, but must say I love it now üòÄ
Thanks for the mention!
&gt; but a typical example would be object hydration How would you manage this in raw mysql ? You would do the same, but a bit less optimized, cached, and bug prone. I will never understand people dismissing ORM because they can't wrap their head around how they work. There's also no such 'too complex query' that an ORM would not be able to generate and handle correctly. It's just called bad database design at the end of the day. While it's true you will get less memory and CPU usage on the first call before the cache kicks in, the cost is close to 0 once you start having some traffic. I don't have anything against developers who prefer to go raw instead of using powerful tools. It just depends on the size and the scope of the project. But I've seen way too many developers writing raw queries in doctrine in my life. And this needs to stop. These guys just leave the company and let another develop handle their shitty code. Adding business logic on top of this is what turns a refactoring into a costly full rewrite.
 ) { Like this?
Yes, the brace on the next line. But I'd put it like this: ...arg) {
Dead right. Scrolling vertically is not a hard task.
There are two possible approaches: * tracking process managers (they consume the event store and perform/retry I/O) * command bus that performs commands and retry, and I/O is part of the command execution Lately I'm aiming at moving my code to the first approach, but it's not gonna work until I migrate all my stuff to `prooph/micro` or re-implement stuff myself. One good example is at http://blog.akii.de/posts/2017-06-04-eventsourcing-in-haskell.html - pure domain logic and aggregates, while any interaction with the outside world would be performed by secondary processes calling the aggregate only to notify it of results of "outside world" I/O
Thanks for your reply! I see option 1 as the only reliable method since with option 2 you can not have an endless retry when the client is waiting for a response. The blog post sounds interesting, will read!
Try /r/PHPhelp 
If you look at my README file, the package is built on top of https://github.com/digiaonline/lumen-elasticsearch which allow you do basically everything with ElasticSearch. Disclaimer I'm also a contributor of that package.
Found a related comment regarding your issue in the comment section of the official docs for [NumberFormatter::formatCurrency](http://php.net/manual/de/numberformatter.formatcurrency.php#120956). Changing the code accordingly does not seem to yield the expected results though ([see code here](https://3v4l.org/pkfXe)). I suspect that it has to do with the installed locales (eg see how when executed on HHVM it displays the correct symbol) though I'm not sure on that. Alternatively you can find some userland implementations, eg [this gist here](https://gist.github.com/neo22s/9621415).
But it's not a 1:1 match. Codeception has problems with Regular expression backreferences and non-capturing groups. Multiline steps within you PHP Doc is not parsed as a normal annotation, therefore watch with code reformat if your line is too long. Codeception has _before|afterSuite and _before|afterStep just like Behat. But no before|after Feature|Scenario. Codeception has a huge improvement over Behat based on these features: * Interactive console. * Commands. * WebKit over Mink. * Cept, Cest and features.
One would argue that consistency in short cases would dictate placing { after ) and not alone in a separate line. So either (my favorite): public function f( int $param1 bool $param2 ) { if ($param2) { //code } } or (IMHO code gets too lengthy) public function f( int $param1 bool $param2 ) { if ($param2) { //code } } 
XXX XXXXXXX X XXXX X vs XXX XXXXXXX X XXXX X Is very small issue. However what about this: XXX XXXXXXXXX XXXXXXXXX XXXXXX XXXX X Where ends list of instructions concerning data flow, and where starts code block?
To start with, I've not dismissed an ORM, I use them daily, I've just dismissed your comment about them. &gt; How would you manage this in raw mysql ? You would do the same, but a bit less optimized, cached, and bug prone Not necessarily, I could use Doctrines in built mapper to map to a custom, lightweight, entity or entities for example. Your assertion is just an assumption on your part, and I imagine a projection of your own abilities, and I'm going to make the assumption that you have never worked on truly complex systems, with complex database operations on sizable datasets, because if you had, you would know what you're saying is false. For starters, you can't always rely on caching. What if your system is dynamic, or reactive to events for example? Also using Doctrine as an example, I know from experience that whilst it may well be able to build a functional complex query, it's also true that I could look at that query and cut it down in complexity and greatly reduce execution in raw SQL for complex queries. Doctrine is a piece of software that has been coded to produce queries for GENERAL use, not for complex operations. 
Thanks for the reply. I did indeed see that comment on the `NumberFormatter` man page, and also noted that changing to `zh_Hans` inserts the correct symbol, but in-turn breaks the decimal formatting. That's too bad. &gt; Alternatively you can find some userland implementations, eg this gist here. I think in the interest of time, I'll just hard code the currency symbol in this case. But I'll keep your suggestion in mind for the future.
&gt; and why they are rounded down when converted? According to the docs the float is just truncated, removing the part after the dot. &gt; Floats are also cast to integers, which means that the fractional part will be truncated. E.g. the key 8.7 will actually be stored under 8. 
This is explained in [the manual](http://php.net/manual/en/language.types.array.php): &gt; Floats are also cast to integers, which means that the fractional part will be truncated. E.g. the key *8.7* will actually be stored under *8*.
Thanks for your reply. I had not seen that floats get truncated when they're converted. That makes a lot of sense. 
Keys can either be integers or strings, I guess it's because a hashtable is used to store arrays and only support integers and strings as well. Automatically casting floats, bools and nulls to ints or strings is weird, Hack does not do that by example. It's maybe still here for compatibility.
Because there might be issues with floating point precision. For example there could be such issue: $key = 0.1; $a[$key] = '0.1'; $key += 0.2; $a[$key] = '0.3'; echo $a[0.3]; // probably it would throw undefined offset, as 0.1 + 0.2 !== 0.3
lol that was fun to read, all though scary for first minute of reading...
I will take option 2 every day.
I've used unixstickers.com in the past.
I just realized I may have introduced a bug in this application I worked on 5 years ago.
oh no man :( I hope you can fix it without much hassle. 
https://symfony.com/blog/the-end-of-the-symfony-standard-edition good riddance btw
I left from there a few years ago :(
It's somebody else's problem now haha xD
&gt; https://symfony.com/blog/the-end-of-the-symfony-standard-edition &gt; &gt; good riddance &gt; &gt; Still you're following the path of zend... trolls gonna troll
[removed]
Very long-winded article, I'm afraid, let me summarize it for your: 1. *I don't like the new `object` type-hint, it's too broad, don't use it.* 2. *I don't like argument widening in sub-types. That's confusing and harmful!* On the first point, the `object` type hint isn't here to replace specific class/interface type-hints, it's here when you *can't* use class/interface type-hints. This happens because you're just *any* object to process in a general-purpose way (say to serialize or dump to display for debug purposes etc.), or when you're accept one of 2-3 object types and PHP doesn't yet support union types to express this (in your PHPDoc, however it'd look like: `Foo|Bar|Baz`). In this case `object` is *way more narrow* than no typehint at all. So the author saying "don't use it as it's very broad" is to miss the entire point of introducing it. On the second point, the author is basically complaining about PHP implementing sound type theory that the entire industry has accepted and proven as correct, but the author personally feels is wrong. That's out of ignorance, I'm afraid. There's nothing wrong with parameter type widening.
I have a follow up question: If array keys only support non-numeric strings and integers, then why aren't floats cast as strings?
The sooner you stop feeling the need to shit in the comments any time you see a post mentioning Symfony, the sooner I'll leave you alone.
Good question. When I was testing this. I did cast the array keys to strings and then back to floats when I retrieved the values. Why could the array just not do this at runtime? 
you guys might not like it, cool, to each his own, downvote me down to oblivion, but for me it just does not make sense to open and close brackets in different positions of indentation... 2 is a lot easier to follow. and I know yada yada IDE's yada yada... still. Love the fact that I don't have to go around looking for an opening bracket. If you love brackets in the same line then I would like to hear your reasoning as why you don't use the closing brackets on the same line as your last instruction.
Doesn't look like that :D commenting since two hours in reddit, looser. the true is you don't have a fucking clue
sorry for the insults. Just got mad lol. 
This is you right now. https://media2.giphy.com/media/Qa6aPhf1gD4Bi/giphy.gif Stop flinging shit at people on reddit, it's so counterproductive.
&gt; Doesn't look like that :D commenting since two hours in reddit, looser. the true is you don't have a fucking clue &gt; sorry for the insults. Just got mad lol. You want to apologize? Look up a couple replies and consider my suggestion.
The short answer: Floating point precision Example: https://3v4l.org/idA1N PHP thinks that 1.6 (coming from a difference) is not equal to 1.6. To make it work, use round() var_dump(round($x, 2) == round($y, 2)); // this is true This happens probably because $x is not really 1.6, but 1.599999.. and var_dump shows it to you as being 1.6. That's why you cannot use float as an array index, because float is not a reliable array index.
That's blackmailing 
That's interesting. Thank you for providing those examples. That really answers it to be honest. 
my experience, agile is like communism, lots of big promises made, but usually it all ends in tears and the proponents just tell you "agile is great its just not been implemented correctly"
the main thing you will have problem with is the dynamic recasting with the == vs === operator and non-strict "type hinting" of primitvies (it causes an auto recast if strict mode is disabled). also you would be wise to learn the difference between isset() vs empty() vs is_null() that can even jam up the experienced. aside from that you will probably be fine , php is gonna feel more like python than java but bring your java sensibilites to it and you will do well. just rtfm
Does he have you coding exclusively in vim?
This is why we have PSR-2. Use it and move on.
Floats are imprecise (at least the way people expect they'd be, preserving decimal digits) and so they make awful keys for a dictionary, which requires exact values. They're converted to integers because in PHP dictionaries (assoc. arrays) can have integer or string keys. Thing is, in many operations you just think "number in - number out" and you don't realize what you're working with is a float, for example you just said "rounded", let's try this: var_dump(round(1.23)); // float 1 Many people expect the round/ceil/floor functions produce integers, because they produce "whole" values. But those are still floats. If you use them as keys, PHP is attempting to take your intent into consideration. Now, that said, sometimes your intent is to actually store some float value as a key... for whatever reason. To do this, cast the key to a string: var_dump([(string) 1.23 =&gt; 4]); array(1) { ["1.23"]=&gt; int(4) } The key contents are preserved, well, according to your PHP.ini's display precision (used to convert float to string). If you need to differentiate different types of values as keys, I'd propose a simple "prefix" format, where the first letter is the type (i.e. o = object; b = bool; s = string; i = int; f = float; r = resource, n = null, etc.) and the rest is the value. In that case the resulting array would be able to store `(int) 10` and `(float) 10` as two distinct string keys, i.e. `"i10"` and `"f10"` respectively.
I can't abide by this, curly at the end always for me. I want as much of the code comfortably visible on the screen at one time. Having all sorts of extra lines means a lot more scrolling up and down to follow through the code, which is for me harder to read.
Yep, no indentation at all. But I love my job so not planning on quitting on something as minimal as code style.
My boss is the lead developer that wrote the original website, we're more of a startup company and it's a team of 5 with him included. My IDE has the option of formatting so have thought of doing that. Maybe I've gotten used to it :)
What is this for? React JS? React PHP? If its for JS, just use a js build system, why use a php one? Im lost here.
&gt; To me this makes the previous line look like a function call with a missing semicolon That's a very interesting argument! In my opinion, consistency is a big, BIG, factor in all this. That's why I argue at the end of the blogpost that I'd also opt for putting curly braces on a new line for control statements and not just functions. We're already doing this for classes btw, without a real valid reason - except consistency. But nevertheless, it's an interesting point you make. Though from my experience, I never felt confusion about it, because functions definitions are prepended by the `function` keyword, and function calls are not. So to me, those important visual clues at the left side make it clear. 
Sorry about any confusion, we are definitely not transpiling. But hey, if you know someone at MS, tell them to fund us ;) they do help a decent amount though.
no perl? :(
It's mostly focused on applications using the HTTP kernel from Symfony. So it seems you missed something. Check out the GitHub page linked at the bottom of the article to read more about what it supports.
Some languages are more prone to confusion than others regarding this. Take these examples: function myFunc() { ... } With this your argument stands that a person reading from left to right an not skimming the right side of the code would see the word function. However, here's a different example: const myVariable = function(param, param2) { ... } With this the reader has to find the word function. It's less easy to see this as a function definition and not a function call. Now another: const myVariable = function someGoodName(param, param2) { ... } The word function is now buried within a bunch of other words and now it's harder for the reader to make sure it's a function definition. Finally, what about this? const myVariable = (param, param2) =&gt; { ... } That's a little better but if someone were to change the format for the other function definitions where the word is buried then it reasons that they should use the same style for this as well. That's why I would argue for this structure: function myFunc (param, param2) { ... } const myVariable = function(param, param2) { ... } const myVariable = function someGoodName(param, param2){ ... } const myVariable = (param, param2) =&gt; { ... }
Because no one does that ever. Do you expect a real response to that? It's not a matter of personal opinion. It's the PSR standard. It's just code and it doesn't matter where the brace is as long as it's in the same spot every time. 
It's a build tool written in PHP. Although for assets I'd resort to using Nose.js, building PHARs is a great use case. In the past I used to have unit tests run through grunt and later people even made packages for that, but I'd prefer having a PHP solution for that. Makes your backend development completely agnostic of a separate language for a build system. I can also see this work for feed based data distribution, where you could have uploaded feeds be processed as soon as data transfers finish. This reduces waiting time for systems that would otherwise rely on crontab or the likes. The package has real benefits IMHO.
This causes a lot of problems. If you add another parameter whose type name is longer than the current parameters then you have to change every line. This complicates your diffs and makes it more difficult to see what changes were made. Did you only add a parameter or did you change another parameter? Did you change an assignment or only add another? Why do you align your assignments in the body but not the definition? It's inconsistent. That makes it difficult for other developers to maintain a consistent style when working in the same project. 
That is because when doing so, there is still information lost in its precision. That is due to the nature of floating point precision.
They aren't PHP developers but their contributions definitely apply here: - Martin Fowler - Bob Martin 
No, the framework will not enforce your business rules. If your framework is coupled to your business rules you're a bad developer. That is one of the core principles of creating maintainable software. You can and should be able to implement the entire domain and, afterwards, be able to wire it up to the framework. I'll take a developer that can solve complex business problems without ever touching a framework over someone who who depends on it for even basic things.
Allman ftw However, a lot of new programmers learn with JS and Allman is almost never used. So they arent familiar with it. I'm from early clang days, where it was everywhere. I believe as a result of BSD coding standards at some point.
You mean PSR-2 where opening brackets are in the next line on their own example? http://www.php-fig.org/psr/psr-2/ My grievance (meanwhile apparently some people upvoted my comment) with being downvoted was exactly because I am using PSR-2, people who downvoted me apparently aren't. 
Just use multiple files and include a "top.php". My apprentices love doing that.
If you're passing more than 3 or 4 arguments, you're doing it wrong. The page width on that site isn't even half the width of a full screen IDE, so a lot of his arguments about scrolling are invalid.
I have found that if your team is unwilling to adopt then Agile is not going to make much of a difference. Did you team adopt it with open arms?
exactly my point , didnt work? you must have done it wrong...the ideology is unquestionable.
Huh... fuck
&gt; Why do you align your assignments in the body but not the definition? I do align there as well, especially when the is a lot of parameters with default assignments. &gt; This causes a lot of problems. If you add another parameter whose type name is longer than the current parameters then you have to change every line. I guess its the old dilemma, to choose between readability or diff consistency. I choose realign the parameters/assignments for better code readability. And now a days tools for viewing diffs shows clearly what has change, highlighting only added characters, so one can see the parameters has not changed, only spaces were added.
&gt;When the argument list is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Perhaps I missed the example you're talking about for multi line definitions, but it clearly stafes that it goes on the same line. Either way, you asked why closing braces don't go on the same line as the last instruction. That was what my response was to.
Or you can just typehint the parameter on the controller as per naming on the routing file. Or get it from the request object. 
This is that method in my IDE: https://i.imgur.com/I5RKUDh.png, without vertical spacing. Yes it fits on the screen, and I literally have to move my head from left to right. The point I tried to make was not about it not fitting on the screen, that was merely the start of the argument. Furthermore: I prefer multiple constructor arguments, together with proper dependency injection, over a service locator pattern. So I feel that there are valid use cases for longer argument lists. You're right that if the argument list is growing too long; it often indicated something wrong with the design, though you cannot simply state it's always plain wrong. PS: notice those two thin grey vertical rulers in the screenshot? Those are the 80 and 120 column markers. There's a reason books etc. keep to smaller widths, because it's much easier to read. The same goes for code. I try to keep my code smaller than the 80 column marker, unless I have to do very exotic things to be so. In that case, the 120 column marker is a sane standard to keep.
&gt;increase productivity up to 15 times Interesting, how was that measured?
Some great points and 100% agree with the position of brackets. It‚Äôs worth noting that such a large number of params is a sign of a class doing too much. I also feel that if statements with multiple conditions could be better abstracted to smaller functions. It also increases readability. E.g if ($this-&gt;isGreaterThan(0)). Thoughts?
It's a valid point. And the JavaScript examples especially prove it. I of course don't just write PHP; and must say that this JS example is one of the pain points I experience very often. My only argument "against" - and this is very subjective - is that I'll avoid closure assignment to variables at all times. $myClosure = function(param, param2) { ... }; In 5 years of writing PHP applications, I've only written the above maybe a handful of times. And if I do, as I did above, I also write the curly bracket on the same line. But that's because of PSR-2, and not because I personally find it more readable. I also personally like: $this-&gt;handleThing(function () { }); Compared to $this-&gt;handleThing(function () { }); It feels strange, but I can't really give an argument against it besides that "I'm used to the first way". I like that we're able to think about this, one of the main goals of my post was to discover other people opinions, but also to put into question what we take for granted "just because".
Absolutely yes on the abstraction of conditionals into separate statements or variables! I'm a bit more divided by the argument list length. You're definitely right that a class should have minimal dependencies. But if it needs them, I prefer proper dependency injection over a service locator pattern any time. Furthermore, you have to keep in mind that the example I gave in the blogpost is one of the real "endpoints" of the application. It has to come together somewhere. I could extract things further into separate classes, but than I'd have to rely on some sort of command bus and listeners to tie it all together. Also not optimal. The source code of this example is on GitHub btw, if you're interested in some more context: https://github.com/pageon/stitcher-core/blob/develop/src/Stitcher/Task/AbstractParse.php
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pageon/stitcher-core/.../**AbstractParse.php** (develop ‚Üí c97b432)](https://github.com/pageon/stitcher-core/blob/c97b4328bb69a84f5a170b1bb3883151d151abc8/src/Stitcher/Task/AbstractParse.php) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dt2w39m.)
You makes good point about it coming together somewhere. I do think you‚Äôre right and there‚Äôs an element of common sense in there. There‚Äôs nothing worse than having to look through a load of files with very few methods just to figure out what it‚Äôs doing. So I‚Äôm with you on that. Cheers for replying. 
&gt; Your boss shouldn't have influence on the code style of the codebase Absolutely he should. As long as there's a standard. Otherwise if you let the developers set the standard, you will get into all sorts of religious wars.
You're so good at this ^/s , you don't even realize the feature is nullable types via `?`, period, not nullable return types via `:?`. Are you aware this is basically the most desirable solution for it, C# recently uprooted their entire type system to go from implicitly nullable (like Java, which is hated for it) to explicitly nullable with `?` as PHP does. Swift, a widely respected new language from Apple, also goes for explicit optional types via `?`.
He's talking about container parameters, not request parameters. 
if your friend jumped off a bridge you would jump off too? ;)
Your lead developer should be in charge of your coding standard. A non-coding boss should have no say. The lead developer can survey their developers if they want to find the right mix of options, or they can outright insist on a PSR or some other coding guideline, as long as they come to a conclusion that everyone can stick to.
Hello! I've created an online tool for nginx: https://nginxconfig.io GitHub: https://github.com/valentinxxx/nginxconfig.io **Features** * HTTPS (with Let's Encrypt, Mozilla SSL Configuration Generator) * HTTP2 * CDN * www / non-www * PHP (TCP, 5.x FPM, 7.0 FPM, 7.1 FPM, 7.2 FPM) * WordPress security essentials * pass requests to index.php * Laravel * Lumen * Symfony * Zend * CodeIgniter * Yii * CakePHP * Slim * ‚Ä¶ * pass requests to index.html * Angular * React * Vue.js * Ember.js * ‚Ä¶ * unified (nginx.conf) / separated file structure (ideal for multi-domain environment) * security headers * worker_processes * user * pid * access_log * error_log * gzip * server_tokens * log_not_found * rate limiting (limit_req) * expiration by file types (expires)
I don't think there are curated lists of minimal or one file libraries. But there probably should be. As someone who enjoys minimal stuff I have a couple of minimal libsraries at https://github.com/samayo
FUnit, or "FU" for short.
It's just that I use assertions on mocked objects way too much to not use PHPUnit, but otherwise I'd agree with you, although I'd have to evaluate if the tests are still readable without all the convenience methods testing suites supply.
I almost never use mocks, because instead I have general purpose test doubles, which are more flexible, and are written once for every component (and reused) rather than re-made for every test. For example, let's say I have a repository for User entities. I write myself a quick general-purpose TempRepository that is constructed with an array of users, say from an array: $repo = new TempRepository([ ['name' =&gt; '...', 'email' =&gt; '...', ...], ['name' =&gt; '...', 'email' =&gt; '...', ...], ['name' =&gt; '...', 'email' =&gt; '...', ...], ]);
Yeah, i mean, what is a good combo if i am using PHP for the backend? Should i just pick the coolest frontend framework/library? Or is there a specific stack that is used by a lot of PHP developers when they go full stack?
The LAMP stack.
I don't know. I literally wouldn't be able to read code without indentation. I'd probably look for some solution where the editor indents the file on opening, and flattens it on save. But this is a huge red flag, because it shows your boss is basically on an island by himself, separated from the industry. There's no way he'd promote that if he had the slightest clue about industry practices.
Isnt the LAMP stack a backend stack? I am searching for a good full stack that uses PHP for the backend.
I use an "Outline" panel that shows the function/classes/interfaces in the file and their methods/properties. Code folding is to me an awkward attempt to combine the full editor with the Outline view, and it just doesn't work right. It leads to fiddling with the [+] and [-] widgets all the time. My eyes can move much faster between the Editor and the Outline, than my mouse can move and click those widgets.
Code coverage is provided by PHP extensions like Xdebug and Xhprof. PHPUnit merely takes their data and shows it. So I use Xdebug for this. That said, code coverage can be misleading, because a test touching a line of code doesn't mean it's testing all (or even *any*) of the branches and edge cases that will occur in your code. The best way to properly covering your component's *holistic functionality* is for the guy writing the tests to be very familiar with the component behavior, API, and which aspects of them have a high risk of developing problems. And of course, every bug report should result in new test(s) added, where possible.
Nice!
For generic php application servers you're likely looking at one of: * Slim * Laravel / Lumen * Symfony * Zend Expressive There are some specialist frameworks like: * Phalcon for performance * ReactPHP or Amp for non blocking async concurrency * Yii for RAD * WordPress or Drupal for quick content management and RAD (very popular) * Magento for Ecommerce (very popular) Check out all the awesome stuff at https://github.com/ziadoz/awesome-php for more popular PHP libs and frameworks. On to frontends, for SPAs I would look at one of the following setups: * Angular + Typescript + Angular CLI * React + FlowType + Redux + Webpack * Vue + Webpack Or If your feeling adventurous (not common): * Dart + Angular Dart * Elm * ReasonML + Reason React If it's just a marketing site or something small, you could use the trusty old boys: * jQuery * Backbone * Fetch * Vanilla.js Check out all the awesome stuff at https://github.com/sorrycc/awesome-javascript for more popular JS frameworks and libs On to database you have the regular relational: * MySQL * PostgreSQL * SQL Server Then the "others" I just like to class as non-relational: * MongoDB for loose schema document store (some people find this is good for prototyping, you could argue that you pay for it in the long run though) * Elasticsearch for a search database (great full text indexes) * Neo4j for a graph DB (uncommon) * Redis for key value or time series (great for a cache) * Orient DB seems to do everything (uncommon) * Riak DB for key value or time series (uncommon) Messaging: * RabbitMQ solid async message broker but has it's limits * Kafka high throughput async message broker, arguably a real time pipeline rather than a just a broker * HTTP the trusty, ubiquitous and very debugable synchronous messaging protocol * Redis has a publish subscribe feature (great for your first message queue, very popular) * GRPC runs over http2 but mostly just synchronous messaging with more structure and speed * ZMQ is a fast, low level protocol/library great for "build your own" messaging systems 
The "front end stack" is always Javascript, CSS and HTML. I guess that is why a "stack" doesn't specify frontend technologies. For the backend stack Linux is a must, Apache server is open source and very common. Same goes for MySQL. Basically LAMP and LEMP are the main stacks for PHP development. What you really want to know is what frameworks to use. I recommend Bootstrap and Larvel.
Lol you don't need all that bloated mess.
Looks pretty standard for a properly configured server. I'm not sure you know what you're talking about.
I'm curious to read some feedback about how popular Middleware is *today*. I don't mean just *any* custom-built chain of custom handlers, but the idea of standardized vendor-provided handlers serving as the backbone of our applications. I feel as if the idea peaked a year or two ago, at least. 
Zend Framework may be embracing middleware, but the question is who is embracing Zend Framework. The answer is, not that many. Usually the underdogs try to gain prominence by going for the most standard solution to gain a leg up on the perceived ubiquity of their platform. Symfony and Laravel feel no such need, as they're popular enough. There's a bridge, of course, but using Symfony and then bridging for a couple of middleware is not really having a middleware-based application.
Laravel / Vue.js is pretty common. Lots of tutorials on it over at https://laracasts.com if you're interested.
This is a fantastic starting point and I wish it had been available when I started building my site. However, the buffer sizes that get configured look massive compared to the defaults, beware memory exhaustion! `client_body_buffer_size` of 128k will reduce the number of syscalls made to write buffers to disk, but limit you to 8,192 incoming requests per gigabyte of RAM, compared to 131,072 for the default of 8k. `fastcgi_buffer_size` is set to 128k, which is ridiculous as this buffer is only used to hold the response headers sent by fastcgi. Headers are not that large, for example the headers sent by nginxconfig.io only amount to around 480 bytes. The default size for this buffer is 4k. 
My own personal opinion is that monolithic frameworks like Symfony and Laravel are going to lose ground in the long term. It's hard to judge the adoption of people that are choosing "no framework" but my own feeling is that it's growing. Of course there will always be organizations that choose frameworks because they include the kitchen sink and centralized documentation, however I see more and more teams that are focusing on choosing packages over frameworks. The trade off is that you get the best possible dependencies and ultimate flexibility on architecture. An interesting thing about interoperability is that it doesn't just make it easier to switch from framework to framework, but that the framework itself becomes less important. Once we adopt PSR-7, we no longer need to worry about differences in HTTP packages. What used to be a core difference between frameworks simply disappears. Once we adopt PSR-15, we no longer need to worry about HTTP request/response processing (at least the details like CORS, routing, caching, etc) nearly as much. I think we're going to start seeing the ecosystem become more focused on specific needs and less on the kitchen sink. Instead of picking a framework based on the functionality it provides, we can start to pick a framework based on the needed tooling and style. And switch more easily when it doesn't work out.
&gt; My own personal opinion is that monolithic frameworks like Symfony and Laravel are going to lose ground in the long term. I don't think this will happen. I *wish* it would happen, because I feel architecturally a "do-it-all" framework is highly restrictive, evolves slowly and performs poorly. But I also understand the incredible appeal of a simple all-in-one, out-of-the-box experience, and giving someone a giant catalog of car parts saying "assemble your car" will never be as attractive as driving away in a new shiny directly from the auto dealership. Also, middleware as a response to monolithic frameworks is just the pendulum swinging to the other extreme. Middleware is both too naively simplistic, and *way* too granular. We're literally in Node.JS "left pad" territory with most of those middleware packages, it's ridiculous, I feel. &gt; Once we adopt PSR-7, we no longer need to worry about differences in HTTP packages. What used to be a core difference between frameworks simply disappears. Once we adopt PSR-15, we no longer need to worry about HTTP request/response processing (at least the details like CORS, routing, caching, etc) nearly as much. Or the alternative is don't adopt PSR-7, just build a bridge, and stop worrying. That was the original goal of PSR-7. It's still in its documentation, quoting: &gt; It should be noted that the goal of this proposal is not to obsolete the current interfaces utilized by existing PHP libraries. This proposal is aimed at interoperability between PHP packages for the purpose of describing HTTP messages. Somewhere along the way, it seems we forgot why PSR-7 exists, and decide all must "adopt" it, as in, throw away their native HTTP libraries and start using PSR-7 implementations. That's counter-productive to me. Say I'm using a home-built HTTP library with a strong focus on HTTP/2 compatibility and modern async workflows (where I need them). By that measure PSR-7 is already heavily outdated and rudimentary for my needs. But do I worry? Nope, I made a bridge and I don't worry. I'm interoperable with PSR-7, but I'm not chained to it. And it's how it's supposed to be.
Look, I really appreciate you chewing out good lessons in testing code, for the greater good and all, but your replies come across as if you need to educate me somehow. I'd focus that on someone that actually needs it. I'm not sure how you think I've evoked you in making me your pupil, but it makes me come across like I'm Jon Snow and a big jerk for having to stop you from sitting in the teacher bench. You're not telling me something I don't know and aren't teaching to my juniors myself. The point I was trying to get across was about reinventing the wheel and throwing good tools out of the door, that have great miles on them. I know the code coverage drivers of PHPUnit don't look like much, but there's a lot of little caveats you keep running into when you're not really deeply familiar with code coverage extensions. There are cases where looking at solutions too simplistic can be really harmful. Even if you actually really don't, your responses make it come across like simple subject matter, which can be dangerous to the reader.
I wonder how this would perform using swoole instead of reactphp, since swoole seems to perform much better.
Well, if you think PHPUnit gives you a lot of value through its mileage, fine. I've used it. And I stopped using it, because I could do things much simpler, much better. If you think that's "dangerous", that's unfortunate. We shouldn't be a slave to whatever is popular and feels comfortable because it aligns with popular opinion. We should be free to explore and challenge our assumptions. That's why I'm saying what I'm saying. I'm sure you knew a lot of what I said, but I didn't know which part you know, exactly, because your questions do make it seem like you don't know some of it. If you know code coverage is not that important and it's provided by Xdebug, then asking me how I do code coverage without PHPUnit makes no sense, does it?
I don't think that what you're actually doing is dangerous. Just how you make it come across. I've also not asked you how you do code coverage. Only if you're doing it, followed by that I wouldn't want to reinvent that. Also, you're now mixing statements within questions, thus setting me up for failure. I know something crawled up my ass and died, which makes me return less than productive responses, but I'm also not inclined to further engage in traps.
What would you remove? It looks pretty clean to me. 
Clean and secure by default. I love this tool, good work! 
I have an app with 4k unit tests, slow 4 core CPU and it takes only a dozen seconds with phpunit while running sequential. Are you sure you have _unit_ tests and not functional tests?
I want to use Laravel. But is there a frontend framework that is being used as well? Some companies use 2 frameworks, example: Django/React. 1 for backend and 1 for frontend. And yeah, Bootstrap is always used, no matter which kind of framework.
Thank you guys! https://github.com/valentinxxx/nginxconfig.io/commit/89022f522b7117a22cd8e26f7e7787b2d4ac9ccb
Great information..
Thank you for the feedback! What values do you recommend? 
Can you correct the link please? Seems like it‚Äòs dead.
You could rely on those common question-answers lists, eg: [25 PHP Interview Questions and Answers](https://www.codementor.io/blog/php-interview-questions-sample-answers-du1080ext) [10 PHP interview questions and answers](https://www.upwork.com/i/interview-questions/php/) [PHP Interview Questions](https://phpinterviewquestions.co.in/)
Vue isn't that new, I discovered it in 2015 (wow such hipster) but it's popularity is more recent than the other two. The reason why I recommend it with Laravel is because the Laravel community and it's benevolent dictator Otwell like it, support it, integrate with it and there's plenty of guides using the two together. Your Vue figures look a bit lower than I expected. This medium post (eugh such hipster) has some charts https://medium.com/unicorn-supplies/angular-vs-react-vs-vue-a-2017-comparison-c5c52d620176 so I would say all three have a heavy community and usage, but if you know where the jobs are in your area then that's useful data to use. That said, right now my day to day is Laravel + Angular.
That's reallly interesting, thanks for this. &gt; Are we talking here about little children learning to program, or about adults? If it's about adults, maybe they can use restraint, intelligence and experience to decide when to use what. Even for adults programming is hard. That's why bugs exist and we unit test our own code. I still believe that those object / nullable typehing can be wrongly interpreted. I don't believe developers do mistake on purpose. I am trying to warn about wrong uses of those new functionalities. Now I agree I may not doing it well. &gt; I mean, the rule is simple enough: specify the type as narrowly as allowed by the language. I totally agree on that and it was somehow the goal of my article. Now I understand that it's lacking some nuances and use cases where object type / argument type widening would be useful. I will try to modify my article in that sense, even if I don't see a lot of use cases for those. I think about refactoring (creating contract when you don't know what the implementation use as arguement / return type), that's all. I don't believe that using `stdClass` is a good thing. Wrapping it around an object (even if it's only a value object) would be better IMO. I don't think the example used in the RFC (https://wiki.php.net/rfc/object-typehint) are good neither. When you see the vote, not everybody agree neither (10 against 20 for object typehint). I don't think the all industry agree on it. If you have more examples, I would be happy to learn about it. &gt; Java doesn't support contravariant arguments, because it also supports method overloading. That's really interesting. I didn't do enough Java / C++ to know that. Thanks. &gt; You'll never see anyone with a clue argue that argument contravariance and return value covariance is somehow a LSP violation or "bad" for your code. Well it can be if it's used badly. As a lot of things, I agree, but still it's always good to warn about bad practices (aka using object / type widening if you can use more precise typehint). Last thing: it would have been nice to have this conversation on the article themselve. It's good to have multiple point of view for the readers.
Do you have any relevant programming background? 
&gt; tcp_nodelay on; What is the rationale behind this? 7d caching and no access logs for assets seems quite aggressive for general purpose. 
&gt; You can and should be able to implement the entire domain and, afterwards, be able to wire it up to the framework. That's a recipe for disaster IMHO. I've seen this approach fail in my past experiences. I'm glad it's working for you. What is your favorite solution then ? Go 100% without framework, or build your business logic outside a framework and bind it into it, in this case, which framework is your favorite ? What kind of web app do you typically work on ?
I haven't dabbled in the Js frameworks, so can't advise there. Hopefully what you are asking will be a bit more clear to other readers. Also, Bootstrap is a framework :) 
I try to differentiate a little more. Frontend: * For a Website and "[ROCA](http://roca-style.org/) style" web applications Bootstrap and jQuery works fine. * Vue.js is more optimized for SPA (fat web client). Backend * LAMP (Linux, Apache, MySQL/MariaDB, PHP 7+) PHP Framework * Laravel (for small to medium sites, web apps) * Symfonx Flex (for enterprise web apps) * Slim Framework (micro framework) for RESTful API's, Websites and web apps
A company looking for a full stack developer, from my experience, is looking for a general 'tech' guy, who can handle everything from their server management to their CSS (with some printer troubleshooting in between). It can also be synonymous with "DevOp", although is not true "DevOps", which would be a methodology rather than a role. A good developer should be able to work independent of any specific framework, either by reading and learning on the fly or already knowing how to get by in things.
Laravel is a good choice. For adding different settings you will have to create interfaces, Laravel provides a lot of settings. 
Kudos for the awesome feedback.
These parameters are pretty workload specific, so I wouldn't change them from the defaults in a generic config. Maybe `fastcgi_buffer_size` can be set to 8k to support large response headers from some crazy framework-or-other (since if the response headers exceed this size, the client gets a 502 response, which is bad). I notice that you also have this in the SSL config: ``` ssl_session_cache shared:SSL:50m; ``` This is setting aside 50MB of memory just for caching SSL sessions, which is 200,000 sessions [according to the manual](http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_cache) (4,000 sessions per megabyte). 50MB is a huge portion of the memory of a small VPS, and 200,000 is a gigantic number of sessions to cache. 10MB seems like a more sane default. 
[@pmjones's latest tweet](https://i.imgur.com/V2VhJrb.jpg) [@pmjones on Twitter](https://twitter.com/pmjones) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
It seems like quite a lot of people in the PHP community have a lack of knowledge / understanding of type theory. Here's my response: https://blog.kelunik.com/2018/01/23/parameter-type-widening.html
&gt; Good architecture? Hell no. You just haven't figure out how to deal with such abstractions yet. Why would you need to pass `$options` as method parameter and not constructor?
You don't *need* to implement that interface in your controllers. You wouldn't gain anything by that. Those interfaces are useful for frameworks and generic reusable middlewares or other HTTP components.
50MB is from https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=nginx-1.10.3&amp;openssl=1.1.0g&amp;hsts=yes&amp;profile=intermediate Do you have information about is it an allocated memory even if the cache is empty? (anyway ssl_session_timeout will flush it, am I right?)
As far as I can see from reading Nginx source code, it is all allocated as a shared memory segment as soon as the configuration is loaded. ssl_session_timeout doesn't shrink the allocation.
You're right, the point of post was in binding though. Even if you'd named the parameter, you'd still have to do it for every services manually = hell
&gt; You just haven't figure out how to deal with such abstractions yet. Why would you need to pass $options as method parameter and not constructor? I get where you're coming from, the "options" name suggests I'm configuring the handler for the duration of its lifetime, but that's not the use case I was trying to give an example of. The constructor and the handle() method are different moments of the lifetime of the handler (constructor = handler lifetime; handle() = request lifetime). Long story short: you can abuse the handle() method to pass what should be in the constructor (what you think I'm doing), but you can't abuse the constructor to pass per-request information. So those are distinct needs, and there's a real loss of flexibility here as the latter case is not addressable when you lock down the handle method. For example, one thing my handlers commonly accept is an authorization object containing all relevant user data (i.e. user IP address, application token, user token, session start, etc.). This authorization object is specific to the request, and it's produced at the top of the pipeline, and received by all handlers, so essentially that my method signature: [$request, $response] = $handler-&gt;handle($auth, $request, $response); So let's say I have to get PSR-15 compliant. Let's ignore the other differences, where does the $auth object go? It's an object, with a tight, safe API that I use everywhere. It has nowhere to go but the request attributes, ending up with precisely the problem I explained at length in my previous comments. The request/response headers and the request attributes become a $GLOBALS analog where you throw everything that one handler might produce and another might need to access. If you think I haven't "figured it out", please share your superior solution.
&gt; Nope it doesn't look like that. Since my methods do one thing, it returns one thing. Not three or five. Since there is no method overloading, there is place for convenience methods so your usages are simpler, for example: /** * @param HttpFoundationRequest | PsrRequest $someRequest */ public function doStuffWithRequest(object $someRequest) { if ($someRequest instanceof HttpFoundationRequest) { $someRequest = PsrSymfonyAdapter($someRequest); } // this is a simple example, just to illustrate a point $this-&gt;middleware-&gt;doStuffWithPsrRequest($someRequest); } The method still does only one thing, but does this well for a variety of inputs. 
a controller with a single action is a better idea regardless
&gt; My own personal opinion is that monolithic frameworks like Symfony and Laravel are going to lose ground in the long term. nah, they'll adapt (and already are) Zend is already as close to dead as it can be though...
If you have Xdebug installed you can use it to give you information on memory usage in function calls: https://xdebug.org/docs/execution_trace if you don't have Xdebug installed there is a function called [memory_get_usage](http://www.php.net/memory_get_usage) That could be a long process if you're stepping through code though. Best of luck.
User is special case imo, because it depends on data provided by request and creates context for multiple use cases and lots of repetition can be avoided if handled in controller layer. That's why authentication (and related stuff) is common case for middleware, but requires imperfect solution - the cost of kicking it out of each use case composition: * Indirect one way access to shared state - one middleware authenticates, bussiness logic/another mid. has access to its side effects. * Pretending user object is natural part of the request and passing it futher inside one. Don't like the latter, although it's easy to grasp. Making this concept a "good practice" would lead to "snowball requests" you've mentioned, effectively making them stateful service locators.
That's true. If you want to process a bunch of objects whatever there types the new object typehing may be useful. 
Well in this case we agree, the PSR-15 is highly restrictive and leading to "snowball requests" as you call them. Authorization objects are a special case, but it's a special case not addressed by PSR-15. And there are, frankly, many other things that a *particular* app may need parsed out of a request, and passed to handlers. Say what about parsing the request body to objects and passing *those* to handlers. One could say "well this is no longer a handler if you pass parsed data and not the request" but that's a self-fulfilling prophecy: the request handlers are designed not to support custom input, therefore if they support it they're not request handlers. One thing I've learned the hard way over the years is "never run away from manually wiring things". Wiring things together seems like unimportant boilerplate to some, but those are the points of your application where components interface with each other, where the architecture of the app is born, and where opportunities for configurability, flexibility and reusability occur. This is why I'll never be a fan of sticking to PSR-15 for an entire HTTP pipeline. If it's one line of code either way (i.e. whether to append a middleware to a pipeline, or manually invoke a handler), I'd prefer to write the line of code giving me control and flexibility - manual wiring. And manual wiring needs no standard `handle()` interface.
Cachegrind
https://blackfire.io/ is free to use the basic, is easy to set-up and has a nice UI
It's worth it in the end, however I don't want to over-egg the testing before it can be commercially justified (which is, sadly, "not yet"). However, I have heard of Salt, so I will take a peek at that, thanks - it may percolate through to some real action in the future! 
&gt; I still believe that those object / nullable typehing can be wrongly interpreted. Everything can be wrongly implemented. If we remove everything that could go wrong in the hands of a beginner, we'll have nothing to work with. Imagine someone took away drills, saws, and other power tools from professionals, because amateurs can hurt themselves with them. Professional programming requires professional attitude and professional skills. And if someone is doing it just for fun, then... well then it doesn't matter what code they write. &gt; I don't believe that using stdClass is a good thing. Wrapping it around an object (even if it's only a value object) would be better IMO. `stdClass` and `object` are different things. `stdClass` is a specific class (that has no predefined methods or properties), and `object` means "object of any class". When you use `object` you're probably not expecting `stdClass` or you would've written `stdClass` in your typehint. &gt; When you see the vote, not everybody agree neither (10 against 20 for object typehint). I don't think the all industry agree on it. Almost every language allows you to annotate an argument as some generic "object" type or a base class (which is typically called "Object"). It's not considered a *good practice to do it for no reason, or a lot*, but there are cases where it's necessary and I mentioned some. Say you write an enhanced `var_dump()` for objects, called `object_dump()` using the Reflection API to show advanced information for object of any class. How'd you typehint it? Before `object` you can't. Yet you expect an object, not an array or a scalar. So now you can typehint it - with `object`. As for the vote, that's almost always the situation with the core developers. There are those who want to make the language more expressive and those who feel making it more expressive in certain ways encourages "bad code" like your article talks about. The short array syntax `[1, 2, 3]`
Fantastic idea! Will keep an eye on this. 
[removed]
Pretty cool.
What's your average test time? Do you have some that are just taking a lot of time?
&gt; As Symfony HTTPKernel moves towards compatibility with the PSR-7 Bridge Component. Not so sure about this. PSR-7 was accepted roughly three years ago closely followed by the Symfony bridge. Since then I have seen almost no activity in the Symfony community. Maybe a couple of "how to" blogs but nothing that shows any serious integrations. No relevant changes at all in the Symfony kernel. Still all event based.
phordijk's law: &gt; As an online discussion grows longer, the probability of somebody telling OP to use Laravel (whether justified or not) approaches 1
remember to disable that or it will eat you hard drive 
Ross Tuck covers some good myths and falsehoods about command busses and CQRS here, but the conclusion, I feel, is not supported by the rest of the article. He says: &gt; ‚ÄúSo‚Ä¶should I be returning stuff or not?‚Äù &gt; In a non-CQRS app? Do whatever the heck you want. &gt; In a CQRS app? Probably not, depending on how you‚Äôve wired it up. But remember, the point isn‚Äôt to cargo-cult about return values, it‚Äôs to understand the constraints and decisions that lead to that tactical choice. Yeah the point isn't cargo-culting about return values, but understanding why they're wanted or unwanted in certain architectures. The question is, if you don't assume your commands leave your app to go over, say, TCP, to another service, why are you using "command buses" at all? He says earlier "command buses are entirely unimportant". Well, if you don't need them they're entirely unimportant (and most people who use one don't need it, BTW). But if you do need them, do you even know why? A command bus is a preparation for process independence and service orientation. To design service communication in a *synchronous* way would be a pretty good way to shoot your entire app performance in the foot. You can't return results, because you can't hang around waiting milliseconds, second, or potentially hours and days for the command to get processed. It *has* to be async. Even putting CQRS aside. Now, PHP is mostly synchronous, and you might say "well this fits the workflow of PHP, I just have a couple of commands to send, so it doesn't hurt". Yes, but again, then **why are you using command buses at all**? You just like to write more code? You're paid by the line or by file? It just doesn't make sense.
i‚Äôm wondering if this would be helpful on a shared server, or does the host ALWAYS control nginx for shared setups?
No
Simon Holywell: https://www.simonholywell.com/
[removed]
Whoops I fucked up...I meant vi lol.
&gt; if you don't have Xdebug installed there is a function called: [memory_get_usage](http://www.php.net/memory_get_usage) &gt; &gt; That could be a long process if you're stepping through code though. https://github.com/iFixit/memlog slightly automates that.
Thanks for this.
when agile invariably (or at least, frequently) fails to deliver on promised benefits (and thats usually a best case outcome), the proponents of agile never question the methodology itself. They never question the fact that its not actually based on any kind of objective evidence or science, they never question whether agile really can be applied in any organization or to any problem. The only answer they give is "if agile failed you must not have done agile right". It's a cargo cult, its magical thinking, whatever you want to call it. Like I said, think of it like communism. Despite the fact that communism has been implemented in myriad countries and cultures and has never succeeded in delivering the promised prosperity of a workers paradise, instead it has delivered poverty and misery. Yet all over the world there are millions of ardent communists who, when questioned, will claim with great conviction that Lenin, Stalin, Mao, Kim, Pot, Castro and so on were not *real* communists, if they had been it would have worked, and certainly will work, if only communism would be implemented correctly. The parallels are both obvious and frightening.
I'm certainly not arguing against utilizing a web framework, so I'm not entirely sure why you are positioning my argument as such. I am simply pointing out whether to use a framework or not is not as black and white as you are making it. Your arguments are all naively based around this idea that a framework will make things so much easier and developers so much more productive. I honestly can't tell if you are intentionally being disingenuous or have never worked on a project that is non-trivial. "Framework code", that is, code that will be invoked by your web framework (see modules above) is such a small piece of a non-trivial application that it is essentially immaterial in terms of "productivity". In many cases, such as caching (as well as authentication and authorization), it can be accomplished through configuration alone requiring a one-time investment of time. That isn't to say it isn't important (of course any part of an application's infrastructure is immensely important), but making a new "SomeProductController" with a "list" action takes under a minute of work (that's your framework code). It is the *behavior* of such an action where productivity comes into play. That behavior is outside of your framework and inside your domain. The *vast* majority of time spent on any non-trivial application is spent defining, re-defining, modelling, testing, and re-factoring behavior. Symphony, Laravel, Doctrine, Propel, etc. don't do any of this for you. If you are working on a project without many business rules and a simple DB schema these frameworks will be more useful to you. I'll give you an example. At my job, I'm currently assigned to re-building our entire subscription model to better integrate with a 3rd party service that handles our transactions and add some new features. The namespace I'm currently working in has upwards of 60 classes that comprise the behavior and management of a handful of services whose surfaces will be the API for this new model. Not even ONE single line of code I have written is in any way "framework-aware" or has anything at all to do with "see modules above". This model does not care about MVC or how it is persisted/retrieved. It is *pure* business. I can operate our subscription service from the command line and every single business rule will be enforced in exactly the same way as if it were requested over HTTP. This is just one small piece of a MUCH larger domain model where not a single line of code is "framework-aware". It is this model that is the cornerstone of our business and includes many the "mission-critical" modules and behaviors that create value. As such, it is imperative that any developer who is allowed to touch this code base has a fundamental understanding of domain modelling and application architecture. It is simply not possible to lean on a framework to model our domain. Our domain is unique to our business (like every other businesses domain) so how could a skeleton already exist? The junior developers are left to the task of creating the presentation layer (which does rely on an MVC implementation). Do you see where I'm coming from here? Our application is very data-intensive with an incredibly mature (and sometimes less than perfect) DB schema. We have 25+ databases each with 100+ tables. The "CUD" in "CRUD" is simply a minuscule share of our DB load and many of our Reads are complex with many joins, correlated sub-queries, partitioning, etc. It is simply untenable to rely on an ORM to efficiently create queries. At best we would be left using some ridiculous "query language" imposed by the framework to essentially write SQL anyway (cough leaky abstraction cough). This situation is NOT unique. The vast majority of businesses that have been around for even a small amount of time have evolved a less-than-perfect Entity Relational Model and/or have found the need for complex queries. An ORM just gets in the way. 
That actually makes a lot of sense. TIL. Thanks.
I don't particularly care for them but I work primarily with Laravel and Magento. As far as the scope/size of the Laravel applications - it's varied and complicated to explain. The largest is an Laravel ecommerce application of sorts that handles a lot of internal operations for one of our subsidiaries. We have many small or medium applications used for internal operations aside from this. I'm not sure how to answer your first question other than "it depends". If it's a tiny one off thing then I don't really put much thought into it. For larger applications it depends on the schedule. There's no room for zealotry when due dates are involved. Also, I'm not saying that you should write code that way. I'm saying that you should be able to. A framework doesn't fix bad implementations, but it can make them worse. 
The [$controller, 'action'] callable can be injected in a request handler and executed in its handle method.
Could you explain why exactly it would eat your hard drive?
*Your hard drive space. These memory dumps are heavy. Funny story, I forgot to disable it after debugging an application and these dumps were creating each time I ran xdebug in phpstorm, a day computer stop working and the error was disk drive was full. So I ran an utility to locate where the disk usage was and it were in the dump folder that I used. 
In the PHP ecosystem we see more and more PHP native webserver implementations like [aerys](https://github.com/amphp/aerys), [swoole](https://github.com/swoole/swoole-src), etc. I think with the current middleware style aka "fn (req) : res" it is really difficult to move those projecst to PSR-15 especially if you want to stream a response since the middleware needs to create the response by itself. I think this is a huge design disadvantage. It would be much better if the standard would have used the normal "fn (req, res)" middleware style. So that the middleware does not need to create a response object, then we would also probably not need a [http factory](https://github.com/php-fig/fig-standards/blob/master/proposed/http-factory/http-factory.md) spec. But we will see how things evolve.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig/fig-standards/.../**http-factory.md** (master ‚Üí de189e8)](https://github.com/php-fig/fig-standards/blob/de189e864044ce726f7e75b7d17ac98ea049f45c/proposed/http-factory/http-factory.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dt4hkxn.)
`json_decode()` /r/phphelp
"Fearless"...
thank you!
thanks!
You've given the parser a compound expression with ambiguous associativity. Add some clarifying parentheses and it works just fine. What do we get over a function? Readability. Just FYI; You're going to counter that &lt;=&gt; is less readable in your opinion. I'm going to recounter that opinions are like trash cans*. Everyone has one and they all stink. Save us both some time. * I'm not really going to reference trash cans.
How would that work for parameter in config.yml?
Having anything to do with .net.
&gt; I am mostly interested in site speed and wondering what's more performant way to do it. What is less to download, a JSON payload with a list of results, or your entire site theme with those results wrapped with HTML tags?
If you do there is an r/saltstack which can be helpful to answer questions.
Single responsibility is always viewed as better if you can do it. 
I think yes, the hosting provider manages the nginx config. A VPS could be a solution.
Of course! Just send me your details.
Over the past year, I've been working on porting gson to php. https://github.com/tebru/gson-php This is a similar library to what you made. It serializes generic PHP objects to json as well as maps json back to objects. It's pretty feature compatible with JMS Serializer, but requires fewer annotations to make it work, and it's easier to implement custom serializations. The docs do a pretty good job explaining what it's capable of, but I'm working on a blog post as well.
A thing I did was custom error responses when `Accept` request header is not for HTML but JSON.
Will use frequently for sure, nice work!
NikkoTheGreeko, good point, This applies for "second" searches. When user made one search, page is loaded, and than he is doing another one, or filtering, etc. Is situation is the same for the first search? When he is just visiting domain.com/s/?date_from=2018-01-24&amp;date_to=2018-01-25 url or going to domain.com and we can read his history from cookie on the back end.
I would build it to load the results in an ajax request either way. #1 you only have to build the page to work one way, all the time. The other reason is the user can see a fully rendered theme, header, footer, navigation, etc and in (hopefully) a short amount of time, the results display.
Thanks NikkoTheGreeko, it makes sense. The reason i am asking i see lots of examples of different strategy for leaders in travel ecommerce, so i guess they know what they are doing, but strategies are very different: [booking.com](https://www.booking.com/searchresults.html?label=gen173nr-1DCAEoggJCAlhYSDNYBHIFdXNfbnmIAQGYATHCAQp3aW5kb3dzIDEwyAEP2AED6AEB-AECkgIBeagCAw;sid=139dc7b3c7afcb70faf5378b37550b47;age=1&amp;checkin_month=1&amp;checkin_monthday=24&amp;checkin_year=2018&amp;checkout_month=1&amp;checkout_monthday=27&amp;checkout_year=2018&amp;class_interval=1&amp;dest_id=20079110&amp;dest_type=city&amp;dtdisc=0&amp;from_sf=1&amp;group_adults=3&amp;group_children=1&amp;inac=0&amp;index_postcard=0&amp;label_click=undef&amp;no_rooms=1&amp;offset=0&amp;postcard=0&amp;raw_dest_type=city&amp;room1=A%2CA%2CA%2C1&amp;sb_price_type=total&amp;src=index&amp;src_elem=sb&amp;ss=Las%20Vegas&amp;ss_all=0&amp;ssb=empty&amp;sshis=0&amp;ssne=Las%20Vegas&amp;ssne_untouched=Las%20Vegas&amp;) generates everything on backend for first and second searching/filtering [getyourguide.com](https://www.getyourguide.com/s/?q=New%20Orleans&amp;date_from=2018-01-26&amp;date_to=2018-01-29&amp;customerSearch=1&amp;searchSource=2) fetch everything from front end for first and second searching/filtering [airnbbn.com](https://www.airbnb.com/s/homes?refinement_paths%5B%5D=%2Fhomes&amp;allow_override%5B%5D=&amp;checkin=2018-01-25&amp;checkout=2018-01-31&amp;s_tag=8TJQMWg1) generate back end on first search and use front end for additional searches/filtering So i was trying to understand what was better :)
&gt; - referral &gt; - referral &gt; - referral &gt; - referral Hah. Neat ;-) 
&gt; Which broke my unit test where I was checking that memory_get_usage() was identical before and after a test O_o And I thought I'm the crazy one. I'm often also doing stuff like counting SQL statements via ORM to figure our if any `n+1` problems crept in. Anyway: did you stuck with it, the memory comparison? If not, did you abandon it or any other plans to keep an eye on this during tests?
i guess...i cant say ive ever used a dataprovider and ive been using phpunit since it came out
i suppose you could drop in Mockery or Prophet but yeah i hear you, id have to assume most people are pretty heavily invested in phpunit at this point, and its such a robust system, i cant imagine bailing on it over syntactical quibbles
can you explain what you mean here? are you actually writing a new class that mirrors every class you write just to avoid doing mocks? whhat does it gain you?
how is that any harder to do in phpunit in relatively the same way? of course they provide an annotation as a convenience but you can just use a try catch to do the same thing
this was my thought that seem very slow
It provides code coverage line by line, and my point is that's not enough to cover all cases.
I'm not demonstrating the utility of copy-pasting `try...catch` everywhere in your code. I'm demonstrating an ability to package such functionality in a reusable tool, so you **don't have to type it every time**, using no special APIs or annotations, just basic closures. PHPUnit provides you with annotations, but how easy it is to add your own annotations? How easy it is to have your IDE support those custom annotations? In my actual code, this `throws()` function is implemented once as a static method, and then everywhere in my code I can just do this: $ts-&gt;add('Test name', Utils::throws(function () { ... }); Look, no `try...catch` here! *And yet*, I didn't rely on vendor-specific functionality or patching someone else's library to get there. I just wrote a simple method for reuse: class Utils { static function throws($class, $f) { return function (...$a) { try { $f(...$a); } catch (Throwable $e) { assert($e instanceof $class); return; } // Didn't throw. assert(false); }; } }
Maybe tinker with both along with your result set and see which provides the best user experience. We generally try to defer reports and search results to AJAX requests. Good luck.
Thanks a bunch, I'll send you an email :)
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/PHPhelp: Post specific problems or questions you have about PHP or your code. Hopefully someone will be able to help you out! If you got something out of here, please contribute back and help others :) --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)
You can't decorate a method like I just decorated that test function above.
thanks you, your replies helped me a lot!
If you're not already familiar with it, you may find [Action Domain Responder](http://github.com/pmjones/adr) interesting.
I don't like this idea. /r/PHPHelp is great for questions, of which the language raises a lot. /r/php is better for news, updates, and articles. Subjectively I like the separation. 
Seeing as how it's from the guy who wrote PHP I'm not even mad. 
Sure, why be mad. I‚Äôm impressed ;)
You need to fix your Apache/Nginx vhost config, or hire a developer to fix this for you.
noobs asking dumb questions? no offense, there is absolutely nothing wrong with being ignorant, we all are to some extent.
I'll second this recommendation for single-action controllers in a big way. Multiple actions on a single controller usually leads to dependency bloat, which is a major code smell telling you that it's taking on too many responsibilities. I've seen others recommend [ADR](http://pmjones.io/adr/) here, and I'll do the same.
Very interesting! Did you try the full Kubernetes integration on other projects? If so, are you satisfied? We are exploring that option lately.
No referral here, I am in love with servercheap .net though.
This is really useful. Thanks Rasmus!! 
Wow, thanks for that! Great article.
Here it is https://www.goetas.com/blog/modular-application-architecture-static-assets/ "how to handle static files when building plugin based architectures"
&gt; Though Behat is very powerful and flexible, it isn‚Äôt always the right choice. If you need to get a little lower down into the detail, not going through the UI and instead interfacing directly with integrated services, then you may want to consider a different toolset. For example phpunit is ideal to get unit test coverage of your functional code. For what it's worth, I'm using Behat to test my services (repositories, etc.) directly rather than testing the UI. We have a few core domain elements that we need to get right, and also communicate with stakeholders on, so it's useful to have natural-language tests that they can understand. The UI is changing rapidly, and acts as mostly a thin wrapper around the domain core, so we settled on testing the core directly. It also makes tests run faster and with less infrastructure (like headless browsers) installed :) This is similar to the article that /u/fesor posted which described it way better than I can.
Thanks for the clarity.
I think you could first pull new docker image, start new container and then stop and remove old one to minimize downtime. Also if you'd be deploying prod alongside staging then you could use gitlab ci [templating feature](https://docs.gitlab.com/ce/ci/yaml/README.html) so you'd reuse most of the script.
Excellent advices! I was not aware of the templating feature of Gitlab CI. Thanks a lot for the tip. I'll update the article in the coming days when I've had a chance to test this.
IMO one of the greatest advantages of Make is that you define a relationship between input (prerequisites) and output (targets). Make understands this, and will only execute a recipe if the target is out of date with its prerequisites. When using Make for compiled languages, this ensure that a source file will only be compiled if it is newer then the compiled binary, or if the compiled binary is missing. However, this feature can also be used for PHP. When defining a `composer` target as a phony target, you're missing out on this. The composer recipe will be executed every time, even if no changes are made in the `composer.json`. I use the following recipe in my Makefiles: ``` vendor: composer.json composer.lock composer install ``` This will compare the timestamp of the `vendor` directory with those of `composer.json` and `composer.lock`, and will only execute the recipe if either of the composer files is newer than the vendor directory, or if the vendor directory is missing. If you are interested in the rest of my Makefile, you can find it [here](https://github.com/nicwortel/symfony-skeleton/blob/master/Makefile).
Wow, that is great, let me update my post and my template!
Your first one resolves to `A\B`, as it should.
Middleware in itself is a request handler. I don't see why the MiddlewareInterface has to receive a RequestHandler as parameter. The SessionContainerMiddleware will use a SessionContainerRequestHandler? Really? The middleware problem was solved almost 2 years ago https://blog.ircmaxell.com/2016/05/all-about-middleware.html Let it go!
I use DigitalOcean, Vultr and OVH. 1) DO is great. Good speed/uptime/support/floating ips, teams, backups, snapshots, object storage, additional disks CONS - none 2) Vultr is similar and used to be cheaper, up until a week ago when DO changed it's pricing plans. PROS - cheap, lots of locations to choose from, good speed CONS - doesn't have Object Storage, Load Balancing 3) OVH is using an old interface, but the servers/VPS are quite good. They increased the pricing plan three months ago because they offer DDOS protection for free, so this "free" added a price increase. PROS - tripe data replication due to the CEPH arhitecture, lots of services such as load balancing, floating ips, cdn, backup space, object space, backups, snapshots.. the support is quite good CONS - just a few locations to choose from (canada, france, uk, recently US, but they don't offer all their services in there (yet)), old interface Normally I will choose OVH, but because DO offers more locations to chose from, almost the same services and a much better user interface, my bet is for DO. And of course, the new pricing plans are a winning for DO.
They all resolve to something logic. It's just weird to use `::class` to get the fully qualifed name of a constant, or to be able to get the fully qualified name of a string.
I don't see the point of learning with Nova Framework. From what I see it's a fork of Laravel 4.2 and its goal is primarily to keep updating older projects that were built with laravel 4.2 and don't want to migrate to Laravel 5. I think right now the obvious choices for a full framework is between Symfony 4 and Laravel 5. Zend 3 is probably good to, but you'll probably find less help as it's a little less popular.
&gt; OVH is using "fast hard drives" for the VPS Cloud services. OVH is using SSDs for all their current VPS offers, and nvme SSDs for the Cloud VPS.
I've always used `vendor/composer/installed.json: composer.json composer.lock`. Can't believe I didn't think of just putting `vendor` as the target name...!
&gt; They all resolve to something logic. It's just weird to use ::class to get the fully qualifed name of a constant There we go, I fixed it: class PHP_VERSION {} In PHP you can have a class, a function, and a constant with the same name. PHP doesn't know what you have and what you don't have. "::class" doesn't look for any class, it just resolves the name you pass to it to a string of the fully qualified name of a *hypothetical* class you'd mention in that place of your code, depending on your current 1) namespace 2) use alias statements. In a way "::class" is a misnomer. I originally proposed that the construct would be this: namespace Foo; $foo = nameof Bar; // $foo = "Foo\Bar" However this was rejected because it'd be a new keyword. And this: Bar::name ... was rejected because it'd collide with existing constants on people's classes (probably). The syntax "::class" was elected because class is already a reserved word, so you can't have a constant name "class", and there is some precedent in Java and other language to accessing the class in a similar way. But basically it's not about classes at all. It's about resolving *potentially relative name identifiers of ANYTHING* to their *fully qualified string names*. So think about it as "nameof" and it all clicks.
I've never heard of Nova, but as someone has already pointed out, it looks like it's just a means to keep an unsupported codebase alive, so I would avoid it like the plague. Zend 2 is a good shout as there is plenty of help for that, and it is a solid framework. It has a STEEP learning curve, but if you are willing to ride that curve it will teach you a lot of advanced programming techniques. Zend 3 the same, but with a little less help out there as it is relatively new. Symfony 3 and 4 (or even 2) are also solid frameworks that will help teach you advanced programming techniques, but with a little bit of help built in to the mix to lessen the learning curve. Last of the big 3 is Laravel 5. This is a great framework but includes a liberal dose of magic built in that can lead to less experienced developers to create poor code that quickly becomes a maintenance nightmare down the road. If you can master Zend or Symfony first, then you can switch to Laravel and build well-crafted applications, usually in less time than with the other two. In terms of future career, Symfony and Zend are again the main choices. I'm a contract developer, and these are the two that come up most often, and pay the most money, whilst Laravel jobs tend to be for mid-sized code houses and agencies.
Wouldn't it be better to benchmark something that is exclusively php, ie, doesn't involve mysql?
&gt; However this was rejected It was put to a vote?
Derick Rethans gave a talk at [PHPNW17](https://conference.phpnw.org.uk/phpnw17/) called [Debugging Your Set-Up](https://derickrethans.nl/talks/debug-setup-phpnw17). He demonstrated how to investigate odd PHP behaviour using system/C debugging utils. Well worth a look!
Maybe I said it wrong. I'm not checking for closed streams, I'm checking for streams that still have object data to flush. So, I'm calling "resume()" every futureTick since I can't call stream_select(). Resume used to send all object data at once, but that didn't really allow for true async. So, I pump one file object per resume down the chain of pipes. If all streams are closed, then the futureTick handler doesn't re-add itself to the loop and the loop exists.
&gt; do not directly instantiate a response in your middleware, &gt; but instead use a prototype or a factory that is provided during instantiation. To be honest, I haven't quite understood that sentence yet. * What do they mean with "prototype" in the context of PHP? * How and where should I create such a "prototype"? &gt; or a factory that is provided during instantiation When, where and how do you pass the response object of the middleware / middleware dispatcher?
It's essentially gulp re-written in PHP. Live reload, less / sass compilation, phar/tar/zip archiving... I like gulp, but sometimes when I'm on a fresh machine and I just need to compile some less I'd rather d/l one phar file like I do with composer and PHPunit than apt/yum install node ... have it be out of date ... npm install 100s of Mb of dependencies and GCC, encounter permission errors because I did or did not use -g in the right place one time. If you're not fully into Node JS development - if you're just using it for grunt/gulp JS uglification - sometimes the setup cost doesn't feel worth it .
The idea that standardizing something as simple as middleware will lead to being able to "compose applications out of commodity, reusable middleware" sounds incredibly naive to me. I don't know if MWOP has done significant work building business applications recently but they aren't, and couldn't be, composed out of "reusable middleware". The amount of valuable business logic that exists in middleware is microscopic.
&gt; Now that Uncle Bob is speaking at Laracon Nice achievement. Congrats. Now I don't think "dynamic languages are the future" honestly. I think the future is languages that support both. Type-safety would be juuuuust fine in PHP if PHP had the robust, flexible system that allows us to express our intent. Take TypeScript for example. That's a static type system laid on top of a dynamic language, and oh boy what a type system it is: it can cover every quirk of every JS library out there, no matter how dynamic. And because TypeScript's types are structural, it also will support every type of proxy/delegate that I know you like in your designs. So I think type-safety is nice, but it should *never ever ever* be at any cost. If PHP's type system is still rudimentary and crude for a given API, it's better to go somewhat dynamic, than to make everything a Kafkaesque nightmare for the API users!
If you put business logic in middlewares you are doing it wrong. HTTP middlewares are suitable for taking care of "infrastructure" concerns, things such as authentication, rate limiting or exception handling. And this kind of components can indeed be made reusable.
&gt; The idea that standardizing something as simple as middleware will lead to being able to "compose applications out of commodity, reusable middleware" sounds incredibly naive to me. Bingo. &gt; The amount of valuable business logic that exists in middleware is microscopic. Jackpot.
I get a lot of "class RangeException not found" warnings and the build fails with a weird error code. Oh well. https://gist.github.com/paragonie-scott/87cd39d21301ac0658027b822ab53c32
The first thing I always do with PHP benchmarks is to Ctrl+F for "opcache". I would be good to explicitly point out whether or not opcache is enabled.
That's pretty much a busy wait. `futureTick()` will immediately be scheduled and the next tick will immediately execute, it won't wait "until the next other event happens", but a watcher of that kind might be useful.
`::class` is very much about classes. Something like `::name` or `nameof` cannot work on a technical level, because the same name can resolve to different symbols depending on the symbol type. To make it patently obvious, what does this code do? use Foo as X; use function bar as X; use constant BAZ as X; var_dump(nameof X); I'm sure that keyword considerations played a role in the choice of the `::class` syntax, but the more important constraint is that the symbol type (class, function or constant) must be known to perform the resolution.
It just doesn't work without combined symbol tables. It only works if we forbid constants and function names being the same as class names, and only if we require those to be loaded when `::class` / `::name` is used. Consider the following example: https://3v4l.org/MhF4Z
&gt; ::class is very much about classes. ... and traits and interfaces. &gt; Something like ::name or nameof cannot work on a technical level, because the same name can resolve to different symbols depending on the symbol type. Ah yes, I agree. To be fair, `use function` and `use constant` were added after `::class`, and is anyone using those even? I've completely blanked my mind about them. But a valid point. Of course, when you don't have aliases, the symbols would resolve the same (when you're just in a namespace). But with aliases they won't. Namespaces in PHP... were not designed well. But that's in the past now.
Yeah, I basically agree with what you're saying here.
MySQLi class vs. functions: it literally doesn't matter. They're aliases for each other. You can even mix both, but I don't recommend that. Pick one. PDO vs. MySQLi: MySQLi contains some more specific features for MySQL that PDO doesn't support. PDO supports more databases than MySQL. Choose according to your needs. Both are fine.
Fixed. Thanks!
Honestly glad Flex doesn't use make anymore. Going to bookmark this because I'll probably need it down the line.
PDO are not included with PHP like MySQL? 
Really cool. Nice work
I was wondering the same thing. From tutorials I've seen them do things like this: ``` $conn = mysqli_connect(DB_HOST, DB_USER, DB_PASS, DB_NAME); ``` Where as in the PHP docs it's essentially something like this: ``` $conn = new mysqli_connect(DB_HOST, DB_USER, DB_PASS, DB_NAME); ``` I'm not sure if these are essentially the same. I guess I need to experiment a little bit to see. 
Exactly. If you put heavy logic in middleware you are doing it wrong, which is why it was **already** trivial to shim middlewares for other frameworks without a PSR-15 "standard" being written. That being said, I don't want to totally bash PSR-15. I don't like to bash people releasing anything. With FIG it is a little different since they like to advocate them as "standards" which IMO invites a little more critique and inspection. If people want to use this, more power to them, I just disagree with the notion that it makes "composing applications out of resusable" middleware something that can reasonably be done. I can't slap together Laravel Forge out of reusable middleware for example, or Envoyer, or Horizon, or Spark, etc.
The way to fix this is also not introducing middleware abstraction at all, because it's leaky (parameter reveals implementation), and `RequestHandlerInterface` can act the same as middleware just fine.
and they are testing php on windows. who is mad enough to use windows servers for php?
You may authenticate user separately, but it will be useless if it doesn't provide context for other "separate" parts of application. You can do all ACLs in single middleware, but it will still make context boundry very narrow, because things as common as passing username into view would require another, bussiness specific implementation (at least untill we get to PSR-117 UserInterface:)
&gt; I don't understand why people insist on putting so much type-safe baggage on a language that you don't even compile. Because the long term goal IS to compile.
They are the same. One is a procedural version, one is an object version. I'd suggest using the object version just as a matter of course.
Ok, thanks for the valuable input. 
Do you have a source for that?
yuuuuuge settings.
https://wiki.php.net/rfc/phpng#impact_on_a_future_jit_implementation 
Very valid point. To be frank, we actually thought opcache was enabled by default - are we wrong? If so, we'll edit the article to reflect this. Thanks for the input.
OPcache, FPM and an event-based web server. Not Apache using mpm_prefork and mod_php.
Opcache is enabled by default *if the module is enabled*. Check with `phpinfo()`.
Ive been a full time php web dev since 2006 and have no clue what this is about. Im not proud of my ignorance but just wondering how many different dev worlds there are. Ive looked up continuous integration but still dont see how it applies to what I do. If it helps, i primarily develop in a homegrown mvc, code igniter, and drupal. Eli5? 
Use PDO but go one step further by installing the [Doctrine Database Abstract Layer (DBAL)](http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/) wrapper. This thin wrapper gives you a number of useful convenience functions many of which you would end up writing anyways.
thanks, it is only the beginning though
Rly? Sometimes mysqli error procedual work and orientes object not
You just confused something. The proper syntax probably. Either way as a newbie [you should use PDO, which is much simpler to use](https://phpdelusions.net/top#mysqli_vs_pdo).
No way. Things I'm actually interested in will be buried behind "halp y loop no work" posts which I have to energy to tutor.
Absolutely - and rightly so! That is pretty much the entire purpose of the lock file, in fact. The lock file, checked in to SCM, ensures that everyone is using the exact same set of deps, tested to work properly with your codebase. Updating the deps should be a deliberate action, done in the knowledge that you are no longer running the same code as everyone else, and that you will have to thoroughly test the integration. So it's right that the default recipe for building the project is `composer install` rather than `composer update`.
I wonder how graogQL without json would look
No thank you. I don't need any phphelp and I don't want to read about it. I want to see interesting new frameworks and developments to the language. One thing I hate about some programming subreddits is that all the posts are people asking trivial questions.
I think the key compromise is to change the paradigm from "how can I prevent all runtime errors" to "how can I design this so that errors surface as soon as possible at a consistent point." If you're lucky that point can be "as the developer types it", but that isn't always feasible. 
I've used Behat to test Laravel REST APIs before with Browserkit. That generally results in less verbose tests than in PHPUnit, but as fast as more conventional integration tests.
hopefully more DI containers will adopt this as an option. Using league/container now and it would be nice to be able to compile it.
We've just started implementing this in an enterprise PHP project at work, and it's such a useful tool. Performance improvements are always appreciated, but for anyone interested in it, PHP-DI 5 is still excellent at reducing complexity, and giving you options you hadn't previously considered when designing code.
You might be interested in Blackfire's testing support. https://blackfire.io/docs/cookbooks/tests
Thanks. I hesitated providing something akin to that but I don't think it's actually helpful. In the end you just need to build the container (`$containerBuilder-&gt;build()`) and that's it. If you already have a `bin/console` file (or whatever the name) just call `bin/console --version` in your deploy script and that's enough. This will boot the container and compile it, no need to do anything special. For example on externals.io I do exactly that: https://github.com/mnapoli/externals/blob/2b84986dbd4c896ebe5677a4e3db24eb3bdf9f72/Makefile#L15-L19 `make cache` runs `./console list` which simply show the list of commands. This does nothing, but it compiles the container before deploying. Or if you don't have a `console` script file then just write a `bin/compile` file that includes the code that configures the container (e.g. `require 'bootstrap.php'`) and that's it.
as far as ci goes, definitely. but developers just have to make sure they remember to run composer update every time they make changes, and in my experience people forget to do this more than you'd expect them to (even when accounting for an expectation of forgetfulness). I know I've done this multiple times. I just prefer to have more of a fail-safe method.
fyi that blog post was actually heavily influential in how PSR-15 has been developed, as documented in the PSR meta document.
it was marked abandoned because since it was proposed the FIG changed structure and it now needs a new Working Group, which will likely be composed of mostly the same people who worked on PSR-15. Still, TBD.
Are you confused by the JSON API reference? That is a [specific standard](http://jsonapi.org/).
Makefile is just a way to collect commands under an alias. That way you can run `make test` in any project and don't have to remember that one project needs some special flags. Because thst is all checked into Git with the rest of your codebase. This also helps when you are more than one person on a project, since a tweak to the build process will be immediately used by everyone. It doesn't need to be Make, there are other similar tools (Composer have the ability to define aliases in the "script" section; some shops use Gulp or Grunt). Continuous integration is an entire development process so I think it would be better if you just read up on that subject yourself. 
Symfony 3.4 (LTS) would be my choice
I am not confused about anything good sir, just trying to make a joke.
I was just imagining what graphql with XML would look. just a dumb joke.
.
You have a good point there. I literally never thought about it that way before.
This is not dependency injection, it's the service locator (anti-)pattern. If you want to use it, please read up on why it's an antipattern and not recommended.
&gt; 'foo'::class &gt; resolves to 'foo', which is‚Ä¶ huh? ü§® You can name a class by a string. You can also do this: $foo = "stdClass"; $bar = new $foo; `$foo` is the fully-qualified name of the class here. Since `::class` gets you the fully-qualified name, `$someString::class` will give you `$someString` right back to you. Remember that `::class` doesn't care if there is a class (yet?) with a given name. It just tells you what the fully-qualified version of the name would be.
You might be looking for https://github.com/johnkary/phpunit-speedtrap to identify slow tests. 
I'm tempted to try to get this working as a replacement for Laravel's container, but it seems like it might be impossible considering it's basically the core of the application and other parts of the framework code have hard-coded references to `Illuminate\Container\Container`. I think if I wrote an class that transformed and proxied calls to PHP-DI to be compatible, *and* gave it the same class name as Laravel's container, I could coax composer into autoloading it instead of Laravel's but that's probably too much of a hack to bother with. Alas everything I'm doing at work right now revolves around legacy code where the concept of DI is impossible to apply, and Laravel.
Hey, thanks for your reply. I totally agree with you and this lib is not going and was not designed to replace any standard arra_filter, array_walk, etc. It aims to combine multiply tasks and routine operations into one instrument that you may use. For instance filtering AND replacing filtered values with another ones may be cumbersome in classical syntax. Another case, is when you have 10 items in array and you need to pick exactly 1st, 3rd, 7th and 9th elements. Look, how you can archive it here: $result = $list[[false, true, false, true, false, false, false, true, false, true, false]] Thanks to boolean masking =)
laravel's DI is kinda sucky....but swapping out a service locator is an even worse idea. thats probably the worst aspect of symfony , the service container and i think they finally got rid of it
Codeigniter is fine. Read this for security tips: http://www.phptherightway.com/#security
&gt; a framework for all my future web projects Don't do that. People that know one language and one framework are the worst. Learn multiple PHP frameworks. Play with different PHP libraries and build your own framework. Learn other languages. Try picking up Go and Node. Do some iOS development with Swift. Learn some front end technologies like React. Go back and redo your iOS apps in React Native. Learn some devops. Play with Ansible, Docker. Deploy some stuff to Kubernetes. Write some testable code. Write some units and integration tests. Run your code through some Continuous Integration system. After you do that you have a wide knowledge of so many languages and technologies. You will be super marketable and always have the right tool for the job. It will help you grow your career and be able to adapt when new technologies are created. Or you could just stick with one framework and language. Good luck when you apply for your next job and you realize there are so few options that you are a fit for.
Since I personally found this somewhat annoying I have ended up using [autodiscovering factories](https://github.com/tuupola/http-factory) which as the name suggest detects which PSR-7 implementation you have installed and automatically creates an instance. No need to pass implementation specific factories nor "prototypes" around.
What is sucky about it?
It's always good to see developers learning from things they're using. However Laravel's IOC container I don't think is complicated and to pull in an extra dependencies rather than learning to use the native framework's functionality will get you into a lot of trouble down the road.
&gt; Codeigniter is ~~fine~~ antiquated 
Your opinion is antiquated
I think you're preaching to the choir here with arrow functions... we all (with few exceptions) want it desperately. They've really been a huge plus in javascript, and helped a lot with the readability of stuff like long promise chains. On a related note, I'd really also like to see [function referencing](https://wiki.php.net/rfc/function_referencing) reconsidered.
CodeIgniter 3 is pretty outdated and lends itself to many practices that are no longer considered the best. I wouldn't recommend starting with it, especially as part of a learning process. That said, it's not insecure by default and still receives occasional bugfixes and security patches.
This is essentially spam.
Thanks for all those explanation. I modified my article to be more nuanced, trying to emphasis the fact that "yes it's useful but be sure to know what you are doing". It's still far from perfect on a lot of points but well I'll do better next time...
Thank you for being open to feedback and productive discussion. I wish you success with your site and work!
I agree with you but with that I meant only php projects. Actually I have multiple test projects with the MEAN stack. A few other in Java, c++, python, c#. It's not like I'm going to learn only php but because if my limited time I can't learn everything. I still need time for my friends, family and so on and that's why I'm only going to learn only 1 php framework which is still better than nothing. But anyway, thanks for your tip :) I appreciate it. 
I used to work on zf2 and that was a pain, i quit and change my job because of this framework, i now use Symfony and that a dream
Why did you change? 
Some alternative framework your recommend which is more best practice?
Thank you for your comment. I guess i'll go with zend first but also check out the other 2.
Manly because superior doesn't want to evolve, everyone on the team already used Symfony, we all suggested to use it on the new project but that was declined because that a new framework with no feedback... That was my 1st job, we was on sf2.1 or something like that, we cannot update the framework and as a beginner when turning page or chapter on the documentation i seen so many 404 not found, and without doc that was the painful experience, even on IRC i got any help As dev we was also customer service, there days i was on phone the all days and do not code at all, all of this maybe contribute of my negative review about Zend framework but yeah, Symfony or Laravel is very friendly for me Also we cannot use Gitlab or Slack or anything that common nowaday,
If its Just a fork of something else than I could Just go with the original. Nova looked nice but now if I think about it.. 
That's pretty neat.
Great presentation. Thanks!
So, have you checked the phpinfo() output? Is the opcache enabled?
You've done a good job implementing this, I never used numpy, so I don't know how similar it is. I'm sorry if I sounded like your library is not useful, I just wanted to point out that loops and ifs are not all that's available out of the box in PHP.
Talking about arrow functions every opportunity I get is the only way I can tolerate not having it yet, maybe someone with more influence than me will wake up in a good day, see my stupid comments and do something about it. Who knows
Exactly. As a matter of fact, the `vendor` target could have just `composer.lock` as prerequisite. However, I prefer to have both `composer.json` and `composer.lock` as prerequisites, just to be sure.
sure, no problem! =) This lib is not only about for and ifs replacement. This lib is for wide range of features within one object.
My startup runs php on windows on iis. It works great! Its one of the biggest strengths about php. It works everywhere and you can develop php everywhere!. Try developing rails on a windows machine. 
until you need to scale it out an pay a license for every server. also, as a developer, moving away from windows has been the best move I have ever dont imo. better than any other tool switch I've done: IDE, source control, ....
Thank you for your feedback! Of course, the list contains only plugins I use, some of the plugins might not be useful for everyone. The intersection of all lists titled *Essential PhpStorm plugins* is probably empty, but that wouldn‚Äôt make for a good post. The post initially used to be a Gist that I happily shared with developers new to PhpStorm. A lot of people don‚Äôt use PhpStorm, or are even unaware that its functionality can be extended with plugins. Additionally, before writing this post, I wasn‚Äôt aware of most of the authors of the plugins, and this post also gives credit to them, as well as encourages to recognize and reward the efforts the authors put into building them. Personally, I have paid subscriptions to those who offer it, as the plugins make my daily work so much easier. 
The license fees are not or ever will be an issue. We have calculated this and the money we would save are minimal compared to developers and migration costs. 
[removed]
&gt;ParaTest call for free specialist labour
ParaTest has been built on lots of free labor, and has helped a lot of people. It has always been done for free and given away for free. If you aren't interested in helping - it might be best to just not respond. No one but the PHP community stands to benefit from time spent :)
If you wanted to do it badly couldn't you just inject the existing container and resolve them from that? It's the same thing.
&gt; Now that Uncle Bob is speaking at Laracon Cool! US or EU? 
I'm sure you're totally right. Good luck splitting your time between whatever you're doing now and all the requests that come pouring in.
Saltub is a troll (of the unfunny variety, to boot).
i agree 100% problem is if you give someone a tool they will use it whether they "should " or not, no better example than a laravel app, you can write laravel apps according to generally good practice, but hardly anyone does.
Fake test is a really dumb label. We are interested in comparing on Windows, not Linux. If you want to perform those benchmarks, go ahead.
I agree, most of them wont provide any real help
Hello üëã This is an article about easily managing multiple versions of PHP on Mac using Homebrew. I hope it will be useful if you want to use a specific or old version of PHP on your Mac without using any VM or any container.
I‚Äôve used this approach in the past, but you need to switch back and forth a lot if you work on projects with different PHP versions. Have you even tried using different docker containers?
For rendering Markdown I'd recommend [gfm](https://plugins.jetbrains.com/plugin/7701-gfm) over anything else. Almost renders it out exactly like GitHub does.
Can you run more than one version of MAMP?
maybe it could auto-display comments with preference for comments that relate to a particular php version. That way, comments written before the version in question came out can be pushed down so they don't appear first. It wouldn't always work out well, but it's a thought.
If kept separate, people can look at one, the other, or both. Remember, `https://www.reddit.com/r/PHP+PHPhelp/` is a thing.
That would be a good start - useful documentation that isn't contradictory is pretty much a given in other language communities. As is a runtime that passes its tests, but I've consistently had &gt; 5 broken tests when I go to compile the PHP interpreter for years now. Never had that happen with Perl, or Ruby, or Python, or Node... and if it did I'd investigate why. With PHP it's just par for the course.
Yes definitely... while there is some good information there, a lot of it is more than 10+ years old. 
Makefiles are not compatible cross-platform, and should be avoided in build systems that target multiple platforms. That applies to most all PHP code.
Well there are up/down votes there, so maybe a combination of age and down-votes beyond a certain threshold would make it a bit easier to prune the really bad examples/advice.
So first off, before I start explaining the criticisms, know that these issues are inherently nit-picky, the service locator pattern is frowned upon not because it doesn't work (it does), but because it's considered a generally bad practice that has better alternatives. **Issue #1: It reduces the need to think hard about the dependencies between your components** When you can willy-nilly grab whatever you want from a container from within a class, it reduces the need to think about the public interfaces and how your application components interact with each other, and what is dependent on what. This system level thinking is important and if your constructor starts getting really long because you're injecting 50 million things, it's an easy warning that your class might be trying to do too much. Handing a service locator to a class is like handing over the master key to access and do anything. Can this work ok if done carefully? Absolutely. However, it increases the risk of your app turning into spaghetti code with stuff done in nonsensical places and so is considered bad practice. **Issue #2: It opens the door for hidden dependencies.** If you are a single developer, you can make sure your only grab what you need out of the container and always do so in the constructor. However, what about when you are working in a team and that clueless junior developer decides to keep a copy of the container on-hand within the class and pulls stuff out in random places - thus creating hidden dependencies... Like most things when it comes to the Service Locator pattern, this can be avoided, but the argument is why even open the door to this possibility in the first place? **Issue #3: It creates a dependency on the container.** When you inject dependency X, Y, and Z into a class, obviously you are creating a dependency on those resources and can easily swap them out for testing and whatnot. When you inject a container and grab the resources out of it, now in-addition to X, Y, and Z, the class is dependent on the Container. So you've added another dependency. Big deal? Not really. But it's a minor thing people don't like about the Service Locator pattern. **Issue #4: The class signature no longer tells you anything useful.** The following tells you something about the object and what it depends on: $object = new Example($x, $y, $z); The following tells you nothing: $object = new Example($container); This is not a huge deal in the PHP world because it's an interpreted language where you can easily read the source code, however in the world of compiled languages you won't always be able to see the implementation. In C++ for example, you may be able to see the signature of a 3rd party library, but not the implementation. For this reason and others, signatures should be meaningful and tell you exactly what is required to use it. **Issue #5: It limits your application by creating hard dependencies and/or forcing you to put logic in the wrong place** Let's say your class takes some sort of database access object as a dependency. Let's also say for some reason your app needs to be able to use multiple different databases. If you pass in the dependency, you can give it the right type of DB object to use as determined by appropriate higher level code. If you pass in a container and grab the DB object out of it, how do you know which type of DB object to grab? Should you grab that MongoDB adaptor or the MySQL one? All the sudden you either have to pass an additional parameter to tell which resource to grab out of the container, or you have to put logic (which doesn't belong there) in the constructor to determine this, or you have to redefine the resource for a database object in the container before you create the object, etc. By passing in the dependency, your class can depend on an abstraction and not be tied to a hard dependency. I'll send you a PM with a link to an article I wrote on the subject.
You don‚Äôt need to, as mamp can run multiple PHP versions by itself out of the box. 
A common use scenario with a CI server is to trigger it to run on a post-commit hook with Git. The CI server works much like a task runner, for example Phing, Gulp, and Grunt. There are three popular CI servers that I've used a good bit - a stand-alone server (Jenkins) that is Java-based, and runs on your local machine or network, and SaaS servers (Travis and Appveyor). I have my local development environment configured with a file watcher, so that whenever I change a file, unit tests and the linter is run on that file. There are other actions I'd like to take on my code before I deploy it to production, but I don't because it is too expensive in terms of bogging down my workstation. So I move those tasks to the CI server (to run once on commits). I also run the full test suit and lint all of the files on the CI server, where I do it only with changed files locally to cut down on disk access. There's a popular "[PHP template](http://jenkins-php.org/)" for Jenkins that is pre-configured for a number of popular activities on PHP projects to do in the CI: * Checkstyle (for processing PHP_CodeSniffer logfiles in Checkstyle format) * Clover PHP (for processing PHPUnit's Clover XML logfile) * Crap4J (for processing PHPUnit's Crap4J XML logfile) * DRY (for processing phpcpd logfiles in PMD-CPD format) * HTML Publisher (for publishing documentation generated by phpDox, for instance) * JDepend (for processing PHP_Depend logfiles in JDepend format) * Plot (for processing phploc CSV output) * PMD (for processing PHPMD logfiles in PMD format) * Violations (for processing various logfiles) * Warnings (for processing PHP compiler warnings in the console log) * xUnit (for processing PHPUnit's JUnit XML logfile) My build workflow with Javascript is more complex. Also, the CI server is a good place to move building documentation from PHPDoc / JSDoc comments, create archives from your build files, compile for different platforms if that applies (comes up with Node.js tooling that supports front-end development), optimize image assets, etc. The way I have my CI workflow set-up is with a regular traffic stoplight, and Jenkins running on a small embedded controller. Whenever something breaks the build, the stoplight goes from green to red. Since it might be a couple of minutes after I push a commit to the point where the build process breaks, this way I get feedback that there's a problem but I'm not twiddling my thumbs waiting for it to all process. The SaaS CI products are designed to (among other things) tie into a GitHub workflow. When people push a PR to a repository I have with Travis and Appveyor set up for the project, the CI is automatically ran against the patch and a pass / fail flag added to the PR. Travis is Linux-based, and Appveyor runs on Windows Server, so I can test cross-platform by using both. I like to run other code quality checks in CI, including [`danger`](https://www.npmjs.com/package/danger) for consistent code review, and [`retext`](https://www.npmjs.com/package/retext) to make sure no profanity and grammatical errors creep into documentation.
It's probably not possible for past comments, but it would be nice to be able to filter the comments by version, similar to how google play store does it.
Or just collapse them after five years and delete/expire after seven. Collapsing will encourage newer versions of the comment to be posted without removing information for someone desperately searching for it. After seven years though the information should either be integrated into the documentation itself or at least have a reasonably current comment.
Could match up the latest version of PHP at the time the comment was made and make a "probable version" mark?
&gt; The php.net documentation is pretty great, until you get some horrendous advice in the comments that is often a decade old. Perhaps it would be good to prune the comments from php.net. You're right. It'd be good. Thanks for volunteering to do that. ;-)
I have never seen documentation that had user comments.
As I pointed out in the blog post, I acknowledge both the lack of portability as well as that similar results can be achieved with `composer` scripts. In regard to portability, while I have been using DOS and Windows for more than 20 years, I have turned my back on it, and I don't care about Windows at all. When working on projects where other developers - whatever their reasons are - are working with Windows, I fall back to providing (and maintaining) a `Makefile` and `composer` scripts. Nonetheless, while the post deals with `Makefile`s specifically, the point is to have a simple, one-step solution to building a project locally.
PHP is a multi-billion dollar industry. There should be people working full time on the documentation. That includes cleaning up nine year-old comments that were sometimes wrong to begin with.
US
Yes. I have a bunch of projects using API Platform and Sonata, it‚Äôs straightforward. You can manage the same entities with both tools.
It can inject primitives, and what do you mean by "custom factory". Finally, all *real* dependency injection containers that I interacted with in .NET had auto-writing. In fact, **that was the entire point of using them**. It's always a little funny to me when PHP developers note that as a bad thing and it was literally the main reason for its existence in other ecosystems, heh.
Kind of like Amazon reviews, "this response was for an older version of php and is outdated"
Who would pay these people?
Mexico
And if Mexico refuses the entire PHP community will strike until they do.
Anyone can feel free to benchmark on Linux. Opcache was definitely *not* disabled manually on purpose in order to skew results. However, caching mechanisms and such have not yet been implemented at all, so we'll see soon for the next ones. Keep in mind, it's Peachpie 0.9 vs. PHP 7.2. And again, feel free to benchmark this anyway you want, the more the merrier.
PHP has some of the best documentation in the industry though.
Facebook, Wikipedia, Wordpress.com...basically anyone who makes money off of PHP should think about how to fund it. Open source languages‚Äîlike [Python](https://www.python.org/psf/), [Perl](http://www.perlfoundation.org/), [D](https://dlang.org/foundation.html), [F#](http://foundation.fsharp.org/), etc‚Äîand other software systems‚Äîlike [Django](https://www.djangoproject.com/foundation/), [Blender](https://www.blender.org/foundation/), [GNOME](https://www.gnome.org/foundation/), [Open Street Map](https://wiki.osmfoundation.org/wiki/Main_Page), etc‚Äîhave foundations that support their development and documentation with paid (sometimes full-time) workers. Some of these foundations have 7-figure budgets. They are non-profit 501(c)(3) organizations, and they get their money from donations from companies that make money off of their product and from individuals who want to support the cause. It would be great if PHP had that too. I nominate you folks to set it all up.
Thanks for the detailed reply! Do you work on a codebase that you share with a team? Is that what makes CI and this level of dev-ops useful? There's so many parts here that I'm missing. I don't have a CS degree or understand testing, tbh. I write code on a development server, write in some debug code like var_dump, print_r, etc when needed, refresh the page, look for errors or at my data, and proceed as necessary. When my feature is completed, I'll merge my branch into development, then merge development to master for a release and pull to master to deploy. I have a basic understanding that git hooks can automate some of this, but I've never really needed it. I def kind of feel stupid, as dev-ops has totally passed me by over the years, but I've never worked at a place that uses modern dev ops so idk. Just being honest so I can try to learn what I'm missing. 
ah it looks like these were corrected in a more recent version than i am dealing with, i stand corrected! my apologies
Honestly, at this point I'd say just get rid of comments all together. There's better venues (Stack Overflow, etc) for most of the info. While it's nice that language quirks are often covered, those things would be better off in the actual documentation itself.
&gt; Facebook Facebook were so disgusted at the thought of contributing to PHP they literally reimplemented it from scratch for themselves. So don't put them in that list. 
&gt; I nominate you folks to set it all up. Thanks! You heard him, folks, start sending me money.
Why did I read this in Trump's voice? No, PHP doesn't have "some of the best documentation in the industry". It has good documentation. It's OK.
Well done. Starred the repo.
Does anybody who participates in maintaining the site visit this subreddit?
I don't know. It would be nice if there were a good way to contact them.
The new doc site used by MS has user comments. I haven't checked if there is any kind of moderation though.
&gt; Edit: Just realized php-fpm isn't available on Windows. Damn, really? :/
It's PascalCase when the first letter is capitalized, camelCase when not. ;) `PascalCase` and `camelCase`
But they already have competent developers. They don't need to finance incompetents who can't differentiate between a good and bad comment to save their careers.
I'm not too particular, but some good choices are: - [Symfony](https://symfony.com/) - [Laravel](https://laravel.com/) - [Slim](https://www.slimframework.com/) - [Lumen](https://lumen.laravel.com/) - [CakePHP](https://cakephp.org/) - [Zend Framework](https://framework.zend.com/) - [Opulence](https://www.opulencephp.com/) Laravel or CakePHP are probably the best for someone new!
PHP‚Äôs core documentation is absolutely fantastic; in my experience, only MDN comes close for overall quality. The fact that you need it all the time... well, standard library naming has been discussed to death. But it‚Äôs easy to read, easy to search and navigate, and pretty consistently has useful, accurate, real-world examples. Agreed that the extension docs are less reliable. 
Oh, man, I'm so glad it's been useful to you. Thanks for the praise :-)
&gt; Facebook were **so disgusted** at the thought of contributing to PHP they literally reimplemented it from scratch for themselves. Somehow I believe these are your words and interpretations.
https://en.wikipedia.org/wiki/HHVM php 7.x can thank the hhvm project
**HHVM** HipHop Virtual Machine (HHVM) is an open-source virtual machine based on just-in-time (JIT) compilation that serves as an execution engine for the PHP and Hack programming language. By using the principle of JIT compilation, executed PHP or Hack code is first transformed into intermediate HipHop bytecode (HHBC), which is then dynamically translated into x86-64 machine code, optimized, and natively executed. This contrasts with PHP's usual interpreted execution, in which the Zend Engine transforms PHP source code into opcodes that serve as a form of bytecode, and executes the opcodes directly on the Zend Engine's virtual CPU. HHVM is developed by Facebook, with the project's source code hosted on GitHub; it is licensed under the terms of the PHP License and Zend License. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
because `strpos` has changed so much. if it ain't Baroque...
Wait, Stack Overflow isn‚Äôt PHP‚Äôs documentation? 
PHP 7 can thank HHVM for the motivation to compete and improve themselves, but just imagine where PHP would be, if all this effort to *rewrite PHP* by Facebook... went into *improving the existing PHP*. Today we'd be where probably PHP 10 or 11 will be one day.
what?
I suggest to take a look at *the* wiki: http://wiki.c2.com/?CamelCase. By the way, it‚Äôs generally an excellent resource!
If I ever forgot how to install PHP with Homebrew, I always refer to Justin Hileman‚Äôs article: * http://justinhileman.info/article/reinstalling-php-on-mac-os-x/ Alternatively, I have found Andy Miller‚Äôs article for working with, and switching between different PHP versions on macOS very useful: * https://getgrav.org/blog/macos-sierra-apache-multiple-php-versions
If anyone suggests to inject a service locator into a service, I save myself some time by referring to * https://qafoo.com/blog/057_containeraware_considered_harmful.html 
&gt; handing over the master key to access and do anything Isn't this the 'Laravel way' though? You can and are encouraged to access Request and everything else at anyplace anytime, eg like this `Request::input('blah');`.
The time spent writing this post would have been better used by contributing to PHP docs.
Wall.. Street.
I think both of you are correct. Camel-case is the technique of making something more readable by capitalizing individual words in a name, Pascal-Case is specifically when the first word is capitalized too. This is what I learned a long time ago though, and I may very much be wrong about this. But I always thought that camel-case was the general name. Whenever I did `$variableName` or `ClassName` I always assumed they both to be camel-case.
Php isn't an industry
Sorry but if thats a manual job then someones screwed up. The comments are presumably dated and in a db somewhere, just stick a tabbed UI on it showing 'recent comments' and 'archived comments', with a warning on the archived comments section. It's not difficult and doesn't have to be.
Presuming a comment is worse than another because it's older is not a very smart policy.
What documentation do you compare it to? Ruby? Rust? .NET? Python? C? When you say "in my experience" it matters a lot what "your experience" is. The PHP docs are OK. The parts that are documented are usually up to date and correct, and the articles describing concepts are often pedagogically written towards a novice audience. But you are making a statement that this meets the bar for "some of the best in the industry", and in *my* experience that is far from the truth. The PHP docs does not include much expert advice, user comments and examples are not complete and often of low quality, the search engine is bad, and some things are just not documented at all. [This is not very helpful](https://secure.php.net/manual/en/imagick.filter.php), just as one example. Have you even seen MSDN? They have material for all audiences. It's more than just a library reference, it is a never-ending resource of knowledge.
It doesn't make it worse, it makes it dated. A comment on PHP .net made years ago might be fantastic advice for someone running PHP 5.3, but terrible for someone running 7.2. Labelling them as 'old comments, use with caution' isn't really a problem IMO. It's infinitely better than what PHP.net currently has, and is the easiest option if nobody is able to dedicate time to a better solution.
&gt; A comment on PHP .net made years ago might be fantastic advice for someone running PHP 5.3, but terrible for someone running 7.2. The point I'm making is the odds of "might be fantastic" vs. "might be terrible". PHP 7.2 has a lot more features than 5.0, but it's 99.9% compatible and follows the same philosophy PHP 5.0 did. There weren't any sharp moves ever since the upgrade from 4 to 5. So to automatically downgrade or reduce the visibility of a comment just on this basis wouldn't be a smart policy. If anything, it'd just discourage people from spending the time to write useful comments. Why spend time writing useful comments if they'd constantly rot there based on the date/version alone, with zero intelligent input from people who know what they're doing? On top of that we already have a voting system for those comments, and for the most part, the votes seem fair. Shit gets downvoted, good stuff gets upvoted. If downvoted comments should be collapsed by default, I'm fine with that. Currently they're just grayed out. We're almost there.
So to clarify, your view is that theres absolutely nothing wrong with the comment system currently in place, correct?
No, that's not my view. My view is there's always place for improvement. But hastily thought out change is worse than doing nothing: https://pics.onsizzle.com/different-i-want-things-to-be-different-oh-no-web-6297463.png
You're having this discussion in the wrong place then. This is a public forum for opinion - it's kinda where people come for 'hastily thought out change', not deep and thoroughly researched change. We're not making a decision that'll actually happen here, OP asked for opinions, I gave mine. Its no more or less valid than yours. You disagree with my opinion, I disagree with yours - move on.
&gt; You're having this discussion in the wrong place then. This is a public forum for opinion - it's kinda where people come for 'hastily thought out change', not deep and thoroughly researched change. That doesn't make sense. You want me to withhold feedback, because the ideas we're supposed to share here should be superficial and worthless? That's not how public forums work. &gt; OP asked for opinions, I gave mine. Its no more or less valid than yours. You disagree with my opinion, I disagree with yours - move on. That's... precisely what I did. Yet despite my opinion is "no more or less valid" you think I'm "having this discussion in the wrong place"? Yep, doesn't make sense. But... moving on.
I agree 100% with you
We'd probably still be arguing about whether that would be the right way forward for PHP.
Frankly, if the syntax and semantics of Hack became PHP tomorrow, I'd wholeheartedly accept it. The type system is good, the APIs are good, everything is good... except the state of the VM (poor cross-platform compat, difficult to work with, bad performance considering it's JIT), and the IP owners (Facebook). If we could have Hack tomorrow running on the Zend Engine, the world would absolutely be a better place.
&gt; [...] what makes CI [...] this level of dev-ops useful? There's overlap between what a CI server and an IDE can do, in terms of automating linting and testing (among other things) so you don't have to run them from the command line. There's also overlap between a CI server and having build scripts that you run from the command line. The advantage of a CI server is that you can maintain it all in one place and run it (for example) on every commit. One scenario where CI is very handy is in multi-developer teams. Another scenario is for working in multiple languages often, and having a central place to maintain that configuration and not have to think about it. PHP has simple build workflows, but Javascript (with Webpack, Babel, Flow/Typescript, and other transpilation/bundling steps) and C++ both have much more complex build workflows to set up on every project. I use both fairly often (working mostly in Node with C++ native modules, and React/redux front-ends). XDebug is the only widely-used debugging tool in the PHP ecosystem. If you haven't used a full debugger, you should try. They do essentially what you have been doing with `print_r` statements, via `watch` statements. The advantage of a debugger is that you don't have to insert guard code around the sites in your code you want to print variables (i.e. `if (debug) ...`) or remember to remove all of that from your production code. You can also create watch lists with a debugger, which is a file that has all the line numbers in your code to print tokens (variables) at and which variables to print. This way you can swap sets of variables to watch very simply. Also, you can see everything that's in scope at a breakpoint you set - the debugger runs the program up to that line number, and then dumps every variable it can see. If you don't unit test, I'd highly encourage you to start. It's not an all-or-nothing kind of thing, you can start small and learn to test over time. The idea is really simple. Usually you will write one test suite per class or module (file). Each function usually has several tests applied to it. Each test has *expectations* - expressions that you assert should be true, such as `isFalse(false)`. The first step in testing is to figure out how to isolate the piece of code you're testing from everything it depends on. This is why dependency injection is important in PHP - there's no easy way for a testing framework to take over PHP's internal `include` function, and control what dependencies are loaded into a module. Testing Javascript is a lot easier, because it's all done in Node.js, and you can monkey-patch Node's `import` statement. Once you can control the dependencies your code under test will get, you can fake those dependencies to suit your needs. A stub is just a dummy function you give your code. It might return a preset array no matter what your function does when calling it, so you can test how your code under test transforms the data. A spy is a dummy function that you can check (assert against) after your code runs, and it will tell you things like how many times it was called or what parameters it was called against. A mock is the most complex because it is (a) a stub, and can return data; (b) a spy, and can tell you afterwards how your code interacted with it; and (c) you write it, so you can add some logic to it if you need to (stubs are simple no-logic functions, and spies extend a base class for their functionality). Test suites are usually named after the code under test. Tests are usually named descriptively: "It errors when the user enters illegal characters". Tests normally have one assertion per test, but can have additional assertions if necessary. An example is an assertion to make sure two assertions are called, and then the real assertion following. This way you get an error in the test if the real assertion is never called (useful for Javascript asynchronous code). You can assert that a function returns an object that is an instance of some class. You can assert that it handles a variety of input correctly. You can assert that it throws an error correctly. The simpler assertions are the ones that end up being most useful to me - is this method returning an array like I expect it to? Good luck! 
&gt; Presuming a comment is worse than another because it's older is not a very smart policy. I agree!!, there are a ton of great comments that are soo old but still super relevant. for example: - http://php.net/manual/en/function.scandir.php The top comment (6 years ago) provides a super short answer, I always reference this when using this function. I prefer it over the "array_slice" comment 3 years ago because on Mac you often need to add ".DS_Store" and you can easily add more folders/exceptions to it, unlike the 3 year ago answer. Sometimes old comments are awesome :)
would be good, sounds like a monstrous job though...
You could. I just never loved the idea of constantly change the state of my machine
Or you could use MacPorts since it's arguably a better package manager than Homebrew. There's no need to switch between multiple PHP versions when you can run them all in parallel. Besides switching between major language versions you can also set the preferred minor version. I've only done this with Python but it should be the same with PHP: * `port select --set python2 python27` * `port select --set python3 python36`
Check out publish/subscribe pattern. I don't think that checking database is the socket server's job at all.
I made a library with a similar sort of goal a while back: https://github.com/JordanRL/Fermat It also does statistics functions and works with numbers of basically any size and precision. :) 
Delete the comments entirely, they cannot possibly serve as a reliable resource as even if the people contributing were doing so from a position of expertise, the language and its best practices are constantly evolving. There's nothing wrong with having commentary on the documentation but it should not be the responsibility of the official website to deliver this.
Thank you for the recommendation! Installed it, and added it to the list. Should be in production in a minute or two.
&gt;man... I can do PHP so much better Sounds like a form of "not invented here" and tons of money to burn. Huge companies get into projects like these all the time.
Industry is not documented 
&gt; This is not very helpful, just as one example. What makes that one unhelpful? Some languages have worse documentation. For example [os.path.walk](https://docs.python.org/2/library/os.path.html#os.path.walk) in Python is... horribly documented. Someone actually spent time to re-do documentation for just that function in a more helpful way: http://cryto.net/~joepie91/walk.html Which one looks more like PHP's documentation? Granted, there's better documentation in other languages (MSDN's documentation is almost always amazing (except when they leave old documentation pages up that have horrific examples on crypto!)), but on the scale of things, PHP's documentation is at worst mid-pack.
PHP has a $14 trillion trade deficit just use that 
They have a lot of money they can try lots of things only some of them have to be successful 
This is how companies go bankrupt - when they start thinking they have enough money to waste. Most of the effort spent on HHVM was absolutely pointless, and it's currently slower than PHP 7. They also had a wide range of languages that absolutely destroy both HHVM and PHP in terms of performance (if that's what they wanted). Truth is yes, they got success, and yes, they have some leeway to try things. But they have no idea what they were doing with their platforms, and this was mostly a wasted effort. 
PHP will have merged into JavaScript long before that
Where a comment fills in a "missing gap" in the documentation, then perhaps that gap needs filling. Where people paste their own functions for doing something, which is often wrong in some way, too specific to their use case, or just out of date, then that should go somewhere else. Maybe a gist or a blog or something. So yeah, lots of trimming needed imo. I nearly always find the examples flawed and get code from SO instead.
Yup, just in time when also Java would have merged with JavaScript, Apple would have merged with Microsoft, and Heaven would have merged with Hell.
Java, Apple and Heaven have their own free will. On the other hand PHP sure wants to become JavaScript ... - https://wiki.php.net/rfc/combined-comparison-operator - https://wiki.php.net/rfc/short_closures - https://wiki.php.net/rfc/arrow_functions 
Yep ;) And I know I'm not the only one. I personally spent good 15-20 hours cleaning up the comments (or user notes, as php.net calls them) and removing literally thousands of them. There's just too many of them for one person to review, though.
Feel free to contact php-webmasters mailing list. http://php.net/mailing-lists.php
Yes, correctly. Some PHP.net contributors (myself included) spent a good time cleaning up the comments section of the obvious garbage
Congratz! You just got the idea of abstractions in software engineering. "In software engineering and computer science, abstraction is a technique for arranging complexity of computer systems. It works by establishing a level of simplicity on which a person interacts with the system, suppressing the more complex details below the current level. The programmer works with an idealized interface (usually well defined) and can add additional levels of functionality that would otherwise be too complex to handle."
Yup i source compile Nginx, GCC/Clang and PHP-FPM for my LEMP stack alot ! And like you found high cpu clocks and number of cpu cores make a difference. DigitalOcean's newer Optimised Droplets with Intel Xeon Scalable 8168 are definitely a step up from their old aging std droplet hardware. But DO use to have high cpu droplets which now rolled into Optimised Droplet range and then they had 2 types of cpu models on offer, Intel Xeon E5-2697Av4 and Intel Xeon Platinum 8168 where the later would generally be newer and faster. So wonder if their Optimised droplets also have other cpus other than Platinum 8168 ? But which is faster Intel Xeon E5-2697Av4 or Intel Xeon Platinum 8168, depends on the work loads as you have to be aware of Intel Xeon Platinums have different cpu turbo frequencies depending on normal work loads, AVX2 and AVX-512 based work loads where AVX-512 due to power requirements is clocked much lower cpu wise and for some that means lower performance than older Xeon E5-26xx v4 Broadwell family. So to figure out your best choice, it's best to what Ramus did, test them for your specific workloads :) FYI, I use DigitalOcean, Vultr, Linode, and OVH regularly as well and benchmark all of them most of the times when they have new offerings. For example testing Vultr bare metal right now so next up DO new plans/optimised droplets. FYI #2, Hetzner Cloud just was released too for Germany location and they sport the new Intel Xeon Scalable cpus too but clocked lower at 2.1Ghz base.
I think it is cool to make a point about how much code is needed in the user space to accomplish bigger things. That is the interface part of an abstraction that you claim to know.
was good work sir. it's things like this that make me feel old, then I realise I've been developing in PHP for over 10 years...
PHP on windows with no opcache. Delet this.
Interesting idea. However your lib requires php 7+, so not sure I can add it as require lib. But still idea is interesting and I'll try to get some time discovering it
Agree with maadinsh though, it's silly.
Is there a way to add a "mark for review" button to the comments, and then you can focus on the ones that have the most marks?
Nice addition, thanks.
You could use Docker?
There's already a utility to handle the switching, and update the apache module link too.. `brew install brew-php-switcher`
A few months ago 1 person was asking for feedback.
If you do a recent filter YouTube search for php non English videos dominate the results. I really wish they would improve the translations. There doesn't seem to be any Indian language translations at all but it appears Indians are making the most recent videos.
Hashtags aren't a thing on reddit.
The list of languages I'm comparing PHP to include (at least): Swift, Rust, Python, Ruby, Objective-C, Typescript, Javascript, and whatever the heck Arduino qualifies as (C? A C library? a dialect? A language that's just very syntactically similar?). There's probably one or two others that I'm forgetting. And for what it's worth, I'm not calling any of those out as bad. Regardless, you raise a good point and I'll take it a step further: what _I_ consider to be good documentation isn't necessarily what others care about. My original post indicated most of what I value in language docs, but I recognize those things are not important to everyone.
im really confused, how two users can have chat using pub/sub ? 
Along that line, the comments could have tagging to a specific version (similar to StackOverflow, etc). Then people reading it could filter comments on the version they're looking for? Comments which pertain to multiple versions could have the tags updated by the user community as new versions are released.
User space, lol
You can use the SCL to install both php7.0 and php7.1 which would be the preferred way to install them.
Red Hat runs php 5.6, 7.0, and 7.1
My biggest gripe with php7 is that it is too backwards compatible. There is some shit design that just needs to be sunset. 
Well 5.6 is only receiving security updates now, and only until the end of the year. Libraries especially should be moving to 7+.
Copy and paste is a thing on my computer.
Many of the best English speaking developers in the west will never learn another language no matter how hard they try. What if some Chinese or Bulgarian tech company invents the next game changing technology? You and your neighbours who know the language will have a huge advantage. Other people who already live in a multilingual environment will have an easier time learning Bulgarian. The vast majority of English speaking Americans will be shit out of luck. People who have already proven themselves to be smart developers in English won't be able to achieve the same quality of work in the new technology because of the language barrier. Just because someone does not speak English cannot be used as proof that they would never be a good developer. That is a disgusting way to think in my opinion.
Sponsored by protection ring layer names.
The "recommended" way that i'm aware of is for it to be injected in the constructor of the controller, and referenced as a variable `$this-&gt;request-&gt;input(...)` not as a static method, though both are available.
Or if you don't want to subscribe to a mailing list, anyone can send an email to php-webmaster@lists.php.net to start a discussion thread (note: *all* mails to that address are public).
&gt; Frankly, I think the best thing to do with the unpopular translations is just to remove them. The thought has crossed my mind. As much as having the documentation translated across dozens of languages is a great idea, the fact of the matter is that most of the translations struggle to keep pace with the changes to the English documentation.
I've never used Laravel, but I'm positive you should be able to use its Service Locator without implementing the Service Locator Pattern (which are two different things and the source of some confusion). There's more to this topic than I care to go into detail on using reddit, but what you're alluding to is the seeming contradiction between the criticisms of the Service Locator Pattern, and the use of a DI Container / Service Locator as provided by libraries such as Pimple or the Laravel Framework. Using a Service Locator (which I prefer to call a DI Container to avoid confusion) is fine. Implementing the Service Locator Pattern is not. What's the difference? It's all in how you use the Container. Let's take a step back and think about Dependency Injection for a minute ... what's the point of DI? It's to free our classes from the hard coded dependencies caused by using the "new" operator. Instead we pass in the required resources which allows us to make the class dependent on abstractions (such as an interface) rather than concrete types (this is the "D" in the SOLID acronym). However, can we fully implement DI throughout our codebase and never use the "new" operator? No, of course not! At some point, the buck stops and somebody has to actually create the classes you need to use. The question is, who's job is it to create objects? Who should be the one using the "new" operator? The exact answer to that question depends on your philosophy about Controllers and how much separation you need between your framework and your domain logic, but I'll give you an example of one way it could be handled (which is probably how most people do it, but I could be wrong on that point): One way to do it is to use Controller methods as the creation origination point (which may or may not mean the "new" operator is directly in the Controller - but read on). Under this philosophy in a Web App, user actions on a web page trigger HTTP requests to a server, some level of routing takes place, and the end-result is the invocation of a method within a Controller. From here, you [1] read any needed user input, [2] create domain level objects and make function calls as necessary, and then [3] return some output to the user. Within step [2], that may involve creating new objects using the "new" operator. However, because we want our domain level classes to all benefit from dependency injection, that means that any dependencies also need to be created in the controller. It might look like this: ``` $dbAdaptor = new \something\something\DbAdaptor(); $mailer = new \something\something\Mailer(); $logger = new \something\something\Logger(); $example = new Example($dbAdaptor, $mailer, $logger); ``` As hopefully this example demonstrates, when dependencies are involved, this can quickly get tedious. There's two ways to really solve this, either you create separate Factories for each type of object (which adds a lot of extra classes to your project), or you use a DI Container of some sort. If you go the Factory route, you'll need a "DbAdaptorFactory" for creating DbAdaptors, and similarly Mailer and Logger factories. Then when you create ExampleFactory, it might look something like this: ``` class ExampleFactory { public static function make() { $dbAdaptor = \Factories\DbAdaptor::make(); $mailer = \Factories\Mailer::make(); $logger = \Factories\Logger::make(); return new Example($dbAdaptor, $mailer, $logger); } } ``` Then if you ever need to change the dependencies of a class, you just modify the factory and don't have to scour your code to update all the invocations separately. However, creating a million factories can also be it's own type of annoyance, which is where DI Containers can help. Using a DI Container, the logic for how to create the various classes needed by your app is stored in a single place, rather than separate Factory files. When asked, this Container can create and give you back objects and will handle the injection of dependencies for you. This achieves the same result as a Factory based system, but with less file system clutter. So to answer your original question, there's nothing wrong with Service Locators / DI Containers. You just have to make sure you're using them in the right way. 
Also, it looks like 3v4l has already been enabling PHP7 mode for a while, e.g. https://3v4l.org/rTZPj 
WOW you missed a main piece of laravel's architecture by a long shot. you basically rebuilt the [service container](https://laravel.com/docs/5.5/container), but implemented it in an anti-pattern manner as pointed out by /u/Jake_Jeremy. please read and understand the documentation, and do not try to work outside of the framework. use the framework, don't fight it.
I've no idea whatsoever what your logic is here. Software developers must know English or they will suck. Every curious person communicating internationally uses English. English is not my native tongue. Maybe it is or it isn't yours. We're talking in English, anyway. If you want to access your country, you use your local language. That's necessary for reaching end user etc. But if you want to access the international community of professionals, you use English. Period. &gt; That is a disgusting way to think in my opinion. This is not about yours or anyone else's wishy-washy feelings. It's informed, well calculated pragmatism. If you're a developer and you don't know English, you're a shitty developer. You can't read the latest manuals, the latest articles, the latest books, you can't see the latest presentations, you can't talk with the people that push this industry. All the terminology is in English, so you can't even use the terminology correctly if you don't know English. All the keywords, APIs, syntax of every computer language - in English. But anyway if you think my way of thinking is disgusting, then put your money where you mouth is, learn Bulgarian and then we'll continue talking in Bulgarian. –î–æ—Ç–æ–≥–∞–≤–∞ –Ω—è–º–∞ –∑–∞ –∫–∞–∫–≤–æ –¥–∞ –≥–æ–≤–æ—Ä–∏–º. –ê–π–¥–µ –∑–∞–ª—è–≥–∞–π –Ω–∞–¥ —É—á–µ–±–Ω–∏—Ü–∏—Ç–µ –∏ –ø–æ—á–≤–∞–π –¥–∞ —É—á–∏—à –¥–∞ —Å—Ä–∏—á–∞—à!
JavaScript has no combined comparison operator, and short closure syntax existed in many other languages long before it came to JavaScript...
Silver lining? &gt; even languages with a declining market share can still have a growing user base. Here is the same data for these languages when we don't normalize by the number of active users http://www.benfrederickson.com/images/github/language-popularity/oldthing_u.svg 
That's a strange graph. Literally every language features is a dead or dead-to-be language. Perl? Nobody uses that. CoffeeScript? Yesterday's news - everyone's on TypeScript. Objective-C? People are moving to Swift (which oddly isn't on this graph). Ruby peaked long time ago, because people realized RoR has no clothes. For PHP to look good in that graph doesn't mean much. 
One thing to note about these comparisons ‚Äì they will naturally skew towards languages that people learn to code in, because students frequently create public GH repos with their code. It'd be interesting to see a comparison that uses some sort of quality metric to ignore beginner repos.
Fake test is a very apt label. Nobody is running their production server on a windows laptop.
Back in 2006 I worked a job where Perl was king and PHP was a joke. Since they couldn't find any Perl devs and it was a junior position my person was deemed a good enough fit. The company sent us to YAPC. I saw Larry Wall talk about Perl 6. It was just around the corner... Today I'm still a PHP dev and I find it deeply satisfying that they are now both jokes. :winking face emoji:
I don't think many people run production php code on windows.
I'd like to see the CoffeeScript-&gt;TypeScript chart for PHP; what are people jumping ship to?
I don't think Github is a fair representation nowadays. Last few companies I've worked for were all using Bitbucket and obviously all had private repos. Data like this should be taken with a very large grain of salt.
I'm not really modelling transitions here - just observing correlations, and just superficially looking at it and there isn't anything obvious. There are some people that are explicitly looking at transitions. Erik Bernhardsson queried google for blog posts of moving from language x -&gt; y and wrote up this about it: https://erikbern.com/2017/03/15/the-eigenvector-of-why-we-moved-from-language-x-to-language-y.html . Likewise source{d} did the same for users on GitHub here: https://blog.sourced.tech/post/language_migrations/ . If I'm reading their results correctly, the answer in both cases seems be that PHP developers jump ship for Java. Who knew?
Totally agree - out of the 75 million repo's in this dataset, something like 1 million had a name like 'hello-world'. 
3 examples of which only 1 has been accepted.
Probably Python and Go. I have programmed professionally in all three and I wouldn't use PHP to build anything more complex than simple mvc websites.
That and most people don't use windows laptops for their production environments. 
&gt; people realized RoR has no clothes Sounds pretty hot to me.
Yes, it's so hot I need to pay $130 thousand in hush money just to keep story under wraps.
Maybe, but some frameworks like Laravel make the most of it 
Yeah, I'm probably being a tad pedantic but I think the clarification is necessary for when you want to explain what you want someone to do. Otherwise, it's not a huge deal to me. 
Is HHVM relevant now that PHP 7.x is released and widespread?
&gt; If I'm reading their results correctly, the answer in both cases seems be that PHP developers jump ship for Java. Who knew? It would make sense, most PHP developer are back-end web developers, and they are moving to making Android apps in addition to websites. If you're a web developer and know PHP there's very little incentive to learn Python, Ruby or C#, as they don't really bring anything more (they're probably just as good as PHP, but not really better to make websites).
Not even a little bit.
Here is my take on these "promising languages according to Github": People use public repo to advertise their skills and find customers/jobs. I'm just thinking PHP people are too busy supporting one third of the internet and don't have the time/need to create these dummy projects.
There are some important differences though: A company is less likely to veto having a public repository of their JavaScript code than their back-end code, simply because the former is usually quasi-public anyway.
maybe not pruned, but by default they should hide comments that were written for a different major version (i.e. currently it would hide everything written for php 5.x and earlier) and you can select a dropdown to show older comments
Just how sponsored is this article, exactly?
With all due respect, if you believe my article has been sponsored, then you are probably not using PhpStorm. 
By all means insert a massive box shot into your article of your own free will.
I don‚Äôt care what you think. 
Exactly, came here to say something similar. I would want to see the age of the repo factored in. Also, my company has its own repo server with Gitlab as I'm sure that many companies and agencies do (as well as the many that have private Github and other solutions). We just started PHP three years ago when classic ASP came to end-of-life and now we're replacing our Crystal Reports with it as well.
Eh. My father is in his 60s and has done perl and only perl... His house is quite nice. It has an elevator. Theres a lot of money being a big fish in a small pond. Perl isnt going away... But Perl programmers are, driving wages for Perl programmers through the roof. 
Python is great data manipulation, so machine learning, transformation, math related services, etc. Go is good for speed and concurrency. So large data migrations, backend micro services, anything that ports to c libraries like images, videos... Etc. I would use Java to handle money transactions and complex business logics and maybe misc things like testing framework. I would use PHP/js to serve front end data, so it might talk to Go or Python services and serves the result through dynamic templating or restful calls.
&gt; a very large grain of salt At what point do we start calling it a crystal?
When PHP becomes Perl
Agreed. PHP tends to have older programmers (like me) who don't care about the social profile of my works. I've been using version control forever but have never pushed anything to github.
Also github suits very well for open source front-end libraries, javascript's dominance. Companies don't need github for their inhouse backend libraries.
&gt; Go Exactly the same projects I'd use PHP for except if you truely need an ORM for the sheer complexity or size of the project. When you need an ORM I actually _tend to_ Java (hibernate).
Good to know. I don't have a need for Go yet, but I've been considering finding a project to build with it so I can learn it.
Example privileges it's unfortunate fit multiple reasons. New interface lies about it's capabilities "add" can also be used to "update". Additionally persistance is example of totally generic activity. For all possible types supported by persistence, code to persist it's the same. (There maybe be hidden differences but code paths will still look take same). So authors unnecessary specialize generic case. Now. If it was prelude to planned change or known in advance requirements, then it's good middle step. Better examples would be reads from repositories, as those are entity specific. Out maybe code that support state machines (e.g. email unverified, invalid, verified)
But every subreddit encompasses a community by being a subreddit. Redundant naming. /r/php is a community for PHP. Likewise /r/phphelp is a community for people seeking out help for something related to PHP.
Did not tried, but in 2018, if a framework still using arrays, I can easily say no need to try. You should use classes for config parsing, and getter/setter methods for it. 
Configuration is simple flat array, and the class finds and loads it, sets it as local member "config", it can easily be converted to an object by casting it if need be.
I just attended a talk of Sara Golemon (PHP dev) at PHPBenelux. She explained how PHP7 is at least as fast (depending on the benchmark sometimes even faster) as HHVM due to a series of optimizations in the engine, whereas HHVM uses a JIT compiler. Well guess what? Bringing JIT compilation to PHP is next on the list. They're not quite there yet but it promises to be a hell of a lot faster than HHVM then. So yeah the only real reason to use HHVM is now to use hack. 
Will get on tests now, and make necessary changes
It requires PHP 7, but doesn't use scalar types but this instead? if(!is_numeric($user_id)) { return null; }
It requires PHP 7, but doesn't use scalar types but this instead? if(!is_numeric($user_id)) { return null; }
I know I can convert it to object but it should be default. Like Symfony parameter bag. Most of advanced frameworks doing it that way and developers are used to it. 
And sure enough, a friggin hello world benchmark done on the index of one micro framework versus something that barely registers as a framework. Please don't call your framework "modern" if it fits in no modern workflow out there. A framework that isn't tested, doesn't properly leverage features of the language version it praises to be built on and has no real world example or use case to have a good understanding as to why one would choose this over the meriad more mature options out there. Please try again and let us know when you've got something to share again.
Sheesh, tough crowd. Congratulations on the work so far, but there appears to be a lot still to do. Curious to see how this progresses.
Thanks, feel free to star on GitHub and if you notice any issues or have any ideas to implement I‚Äôd love to know them and make it possible.
I was looking for a fresh PHP 7.1 micro-framework, and I was excited to see this. Readme looks very promising. I'm willing to contribute if it helps. - Embrace composer. It makes things _much_ easier to use. Because you don't appear to have a god class (which is a good thing!), you can even split the framework to smaller parts (csrf, template, http, etc). Then, make the make project a standard composer `project` and users can decide if certain sub components are needed or not. - Tests. As others have said, tests are vital. It can help if you can provide helper methods to bootstrap the framework and perhaps mockup helpers too. - Although the Readme says PHP 7.1, this looks PHP 5-ish without [short array syntax](https://github.com/luminancephp/framework/blob/321658f9c8c346d12db0ad43233155a56a31afc2/vendor/Luminance/Database/Table.php#L89), [unnecessary type checking](https://github.com/luminancephp/framework/blob/master/vendor/Luminance/Configuration/Loader.php#L58), [not using](https://github.com/luminancephp/framework/blob/321658f9c8c346d12db0ad43233155a56a31afc2/vendor/Luminance/Security/Csrf.php#L39) PHP 7 new features (`random_bytes()`), and a few more. - Ideally, it would be awesome if we could have a nice IoC container. Because we already have classes to handle database and CSRF features, an IoC container can help users to swap out those components with whatever they prefer. - I'd also avoid using static class variables as they are a nightmare when writing tests. That all said, I really like the framework so far. Documentation looks pretty neat and code is simple and easy to digest. If you do plan to use Composer and perhaps tests too, I'll try to help from my side with PRs/issue queues. Good luck!
You‚Äôre right I should do that! And I do! I have some project using Docker and others using Vagrant. I really like Docker and I use it a lot. But I have some (old) projects that didn‚Äôt use Docker and I just wanted a simple way to use an old php version :)
I'm in the process of converting it to use Composer currently, I'd love PRs/issue queues. My long-term goal is to have everything able to be it's own "part" if you want to strip things out of the core. I'm writing a test class currently for the specific reason of tests, and will hopefully have some more helpers. Would love the help! Thanks, feel free to send me a message if you want to help maintain the project with me.
Nice! I don‚Äôt know phpbrew but I will give it a try üòä Thanks!
Thank you for these useful links üëç
I don‚Äôt know that! Thank you I will have a look üòä
I‚Äôm not sure where I stand on this, I personally prefer an array, but if the vast majority prefers objects I can default it as an object. 
I don't get this. The author seems to suggest we pointlessly fragment our interfaces, so we can have, say, 10 interfaces mentioned in 10 places each, instead of 1 interface mentioned in 100 places. That's a very arbitrary goal. If this is in misguided attempt to reduce the number of options and flags on an object/method, pre-emptively fragmenting your interfaces gunshot style is absolutely not the way to do it.
&gt; New interface lies about it's capabilities "add" can also be used to "update". I also caught that. This adapter example was severely under-implemented. Leaks like hell.
You can currently get a far greater degree of type-safety with HHVM than you can get with PHP 7.
"Parse a website in 10 lines of python" vibes.
i may sound rude but I really don't see the point of yet another PHP frameworks when there's alright big mature players such as Symfony &amp; Laravel. Besides that: - no dependency in composer.json, first bad smell: like do you really think I'll trust your packages for cross-platform issues over Symfony for the HTTP/CLI for example? - no tests: that's already a big no-no. Sure you're thinking about adding some, but the fact that you wrote all of that without any tests is already a deal-breaker IMO And to be honest, I don't see anything other frameworks don't already provide. Your branding looks good, but that's the only selling point tbh. That said, if it's to try things and for learning stuff I'm +1 on it. The best way to learn a framework is to write your own.
Good to know thanks!
All comments are so valueable. If you applies all of this idea, it will be the mordern one we actually can accept.
Did you have to reinstall? You know memcache has no persistence?
Yes i did have to reinstall Memcache. Which wqs really odd to me. Never seen this type of bug before. Once i re installed and restarted apache, php saw the class and it was all good. Just having Memcache disappear is the worrisome part
Investigate the logs, that should give you an idea. Maybe you didn't persist the image or loaded it from a previous version by accident?
Your concluded quite quickly, mostly because you enjoyed it. Some drawbacks: * currently limited language support * lock-in. no easy way to make a service public (think REST) Some questions * how to transition datatypes gently? (i.e. 2 services are not guaranteed to have the same format at the same time) * how to debug arbitratry messages? * Is there some kind of reflection? * how is error handling? i.e. do I get meaningful results for wrong types or even wrong endpoints?
You can probably shorten that server code significantly. * Instantiate your service class early * Have an array as whitelist for methods allowed (so you can disable some on the fly) * Check if the method is in your whitelist with `in_array` (probably more efficient if the array stores the methods as keys for O(1) lookups, using `isset` instead), otherwise `404` * Call `method_exists` on the service class, otherwise `404` * Create your request object dynamically based on the method name with `ucfirst` on the method, appending with `Request`. You can namespace to the class based on the URL, i.e. `/calculator/{method}` service vs another service * Call the method like this: `$service-&gt;$method($request);` * The rest of the code for each method is the same, so you can factor out the switch statement
Fiber seems useful enough, but I'm not clear why it's not simply done in userspace as a composer package.
What makes it being "designed for high-performance web applications"?
Hi, Excellent questions. &gt; currently limited language support Protobuf itself has pretty good language support (at least for me). gRPC's language support is not as good. There are definitely some limitations, i.e. PHP does not support proto2 syntax so you can't use it to write a compiler plugin. &gt; lock-in. no easy way to make a service public (think REST) Protobuf supports a JSON format so you can use that from the client side if you like. You lose the forwards/backwards compatibility benefits of protobuf though. there is a [javascript implementation](https://github.com/dcodeIO/ProtoBuf.js) that is supposedly quite fast and works in the browser. gRPC is not usable from the browser so you would either need to use a RPC framework that is accessible over HTTP 1.1 like [twirp](https://github.com/twitchtv/twirp) or use the [gRPC gateway](https://github.com/grpc-ecosystem/grpc-gateway). &gt; how to transition datatypes gently? (i.e. 2 services are not guaranteed to have the same format at the same time) The protobuf format is designed around this. Every field has a default value and you aren't allowed to make anything required anymore. This makes it possible to decode a proto that is missing values the client doesn't no about. The id tag assigned to every field allows you to deprecate a field (mark it reserved) and make a new one with the same name if you need to change it. You can also pass [self describing messages](https://developers.google.com/protocol-buffers/docs/techniques#self-description) but that doesn't seem to be very common. &gt; how to debug arbitratry messages? protoc can encode and decode from binary to the text format for you. Using the example from the article, you could call the server like this: echo 'x:9,y:2' | protoc --encode=yuloh.math.SubtractRequest ./proto/math.proto | curl -sS -X POST --data-binary @- 'localhost:8000/subtract' | protoc --decode=yuloh.math.SubtractReply ./proto/math.proto &gt; Is there some kind of reflection? For protobuf there is a proto describing proto files. That is what the compiler plugins use. gRPC supports [server reflection](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md). &gt; how is error handling? i.e. do I get meaningful results for wrong types or even wrong endpoints? This depends on the RPC framework you use. gRPC uses [google's error protos](https://github.com/googleapis/googleapis/tree/master/google/rpc), docs are [here](https://github.com/grpc/grpc/blob/master/doc/statuscodes.md). In languages similar to PHP you can throw a `RpcException` with a status and it will be rethrown on the client side.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [grpc/grpc/.../**statuscodes.md** (master ‚Üí 123547c)](https://github.com/grpc/grpc/blob/123547c9625c56fdf5cb4ddd1df55ae0c785fa60/doc/statuscodes.md) * [googleapis/googleapis/.../**rpc** (master ‚Üí bbb219f)](https://github.com/googleapis/googleapis/tree/bbb219f871ceed63948448db9155f1ac575a9b49/google/rpc) * [grpc/grpc/.../**server-reflection.md** (master ‚Üí 123547c)](https://github.com/grpc/grpc/blob/123547c9625c56fdf5cb4ddd1df55ae0c785fa60/doc/server-reflection.md) ---- 
Nice that most stuff pointed out by me can be addressed.
Great suggestion. Another tip is to run the suite with junit log output, then check the log. It should automatically give you the durations of each test so you can find the slow points. Also watch out for: using sleep or usleep anywhere, functions that call out externally (http, sockets) with a timeout, not mocking enough dependencies out (usually happens with tightly coupled code). 
If using paratest try --runner=WrapperRunner as well.
https://github.com/msgphp/msgphp MsgPHP is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated. Build: passing ;-)
Hi, The server code could definitely be shortened. I tried to keep it simple for the tutorial. The only issue I see with your suggestion is that the request is not guaranteed to be named similarly to the service method although it is in this example. It might not even be in the same namespace, which is why the generated service uses the fully qualified name. I definitely agree about the C++ library being massive and slow to compile. I have only compiled it on mac but it was not fun getting it working. I have looked at json-rpc but I really like having code generation and type definitions and I really dislike having to envelope my messages. I imagine you could get pretty far with json-rpc and json-schema. If you are doing C++ have you looked into cap'n proto or flat buffers? PHP's JSON support was added pretty recently. It seems like it still has quite a few bugs. My coworker ran into the lack of custom options too. When we first started looking into protobuf at work it was missing a lot of features in PHP but they have made a lot of progress. The developers working on PHP support are also easy to work with and responsive in my experience. It definitely seems like PHP is the most immature language in the protobuf ecosystem. I would guess lack of gRPC server support has something to do with it.
Yeah I looked at cap'n proto but it doesn't have PHP support. Flatbuffers isn't stable yet so I think it's too early to use. They don't really solve my problems with this stuff though which is that they just end up being way more complicated to use and integrate compared to the benefits they would provide.
I think it is because a fork relies on not completing to indicate a failure, but an exec function gives a return value whether the program has failed or not, so it does not allow a fork to carry out a purpose. Not sure tho.
I don't understand your question, could you clarify what exactly isn't possible? Also, this is the wrong sub-reddit to ask.
`exec` is runs a program, captures the output and continues the PHP program afterwards. `pcntl_exec` replaces the PHP program in the current process with another program. It's a complete different thing.
&gt; Also, this is the wrong sub-reddit to ask. Why?
The official documentation is pretty good. 
define your goals. If you just want to learn phpunit - it's documentation is a good place to start. In fact, it gives you some introduction for testing. But if you are new in test automation things, then you can't simply read few articles. PhpUnit can be used in various of ways, including both isolated (unit) testing and acceptance or integrated testing. Learn about [test pyramid](https://martinfowler.com/bliki/TestPyramid.html). Also [this book](https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627) can be useful. I think best place to start is acceptance tests. Testing application as a whole from user perspective (via http requests). Then you could move forward to integrated tests on smaller scale. Isolated or unit tests are a different story since it more about design of your system. Basically, if your application has high coupling, then maintains of isolated tests would be much more a pain. In fact you could use it as a detector of bad design decisions. Also, all tutorials which you could find only covers basics (like testing method or objects without dependencies). And when you will have object with dependencies, then you will need to learn what fake objects are (stubs, mocks and so on), difference between, why you should use as few mocks as possible and it's ok to use stubs... And the most hard part is how to test side effects of your code in isolation. You could try to read something like this: [Back to Basics: Why Unit Testing is Hard](https://simpleprogrammer.com/2010/12/12/back-to-basics-why-unit-testing-is-hard/). There are also other posts on how to reduce coupling and what can be done in order to increase testability.
Chris Hartjes is an awesome teacher for this stuff. Take a look at https://leanpub.com/minimumviabletests and see if that‚Äôs the level you‚Äôre looking for. I think that‚Äôs probably the one he‚Äôd recommend diving into first.
Thanks for this, I've been doing php for like 4 or so years now but I'm completely new to any automated test so I'm glad that you said that reading articles isnt going to help (it hasnt helped so far, hella confused still) Thank you for the recommendations, I'll definitely look into them!
yet another book on how to test FuzzBuzz?
**N O H E L P P O S T S**
Also look into Behat and BDD. Consider phpspec as well. There's a lot of great stuff out there.
Try this. First three episodes https://laracasts.com/series/phpunit-testing-in-laravel/episodes/1
As a former framework maintainer I can only encourage people to write a framework. Write one alone, write one with a group and write one again. It's a very valuable experience. I also really recommend "dogfooding" (https://en.wikipedia.org/wiki/Eating_your_own_dog_food) it in personal projects. I would highly recommend not using it for professional project. The major frameworks have all had major security flaws that were uncovered mainly because of the size of their user-base. Many eyes see more problems. Also, when you use your own framework for personal projects you can compare it to what you use professionally, it'll give perspective. From a business side it's better (at least at the start of a new framework) not to use it professionally. If you need help on the project or want to find a replacement to work on it, having a more popular (standard) framework helps a lot. A point of advice. From looking at your code, I highly recommend digging into dependency injection. Find out what tight coupling is and how it effects code in the long term. Lastly I hope you have a lot of fun exploring the language this way. I've learned a ton from working on a framework. Learned about git, php, security, databases, quirky language features, the whole lot. It's knowledge you can bring with you your entire career.
Could have had this same mentality years ago: we have big players like Zend and Codeigniter, what's the point of anything else?
OIGA NO ME DIGA
I start old project with docker all the time. It usally take 1 or 2 minutes.
True. The Argument from Abundance is not at all convincing. That said, so is premature launching. This framework lacks proper docs, examples, tutorials, tests, and more. It also fails to make the case for why it should be chosen over the competition. If it's not solving a problem, it'll be a hard sell.
Everything about this tutorial is terrible and should not be used in a modern web application 
Thanks 
Hello, I'd like to share a library we extracted from one of our projects. It helps our team reuse PHP code inside a Golang queue manager. The library is universal and can be used as a backend for a REST API or as a PSR-7 server. I would love to hear your feedback or criticism of the approach we took. Couple benchmarks on empty PHP projects: PHP-PM: https://prnt.sc/hcyju4 (8K requests per second) RR (fasthttp): https://prnt.sc/hcyk9j (21K requests per second) RR (fasthttp + keep alive): https://prnt.sc/hrp4k8 (80K requests per second) Thank you
Silex is dying, it's not a good choice. But Symfony 4 is built as micro-framework if you want, so it's a good alternative.
I would like sonw further explanation of what it does. maybe some use case examples.
Almost everything you can do in Ruby can also be easily implemented in PHP as well. I played with Ruby on Rails but I found Laravel/Symfony to be better. You should also notice that these PHP frameworks inspired from RoR a few years ago.
&gt; PHP does not support proto2 syntax so you can't use it to write a compiler plugin What do you mean exactly? I had a problem I couldn't generate PHP classes with `protoc` but the problem was I had version 3.x. Downgrading to 2.6.0 helped and then everything worked!
Correct question is... can we always apply open/close principle without any violations? And how to knew future to predict all needed extension points for your application without any unused one.
Fiber seems useful enough, but I'm not clear why it's not simply done in userspace as a composer package. Fiber (aka cooperative green thread) can't be done in PHP userspace because it need delimited continuation primitives. The extensions as added 3 important pieces : - 1 new opcode used as a marker in the opcode stack - 1 function that store the current opcode stack and capture the range from the function call position until the new opcode type is found - 1 function that switch the current executed opcode stack with a stored opcode stack &gt; Fiber seems useful enough I think it give the userspace base to solve asyncio once and for all. With all the craze around microservices and network calls it is probably a good thing to have to keep PHP relevant. I don't know how much endevours it is to add into the PHP vm though, with all the c code to fix. &gt; but I'm not clear why it's not simply done in userspace as a composer package Currently the same outcome could be done with yield(yield from) it's like fiber but manually done by the programmer. Its mains problems are : - The yield should be put at every callsite increasing verbosity. - Old code should be rewrite with yield put everywhere. - One single missing yield could make break the yield chain making the async call a sync call. This could be hard to detected without thorough testing. 
So what's up with [externals.io](https://externals.io)? I'm not seeing any new updates since more than a week ago. Has anyone else noticed? On the other hand http://news.php.net/php.internals seem alive and prosperous.
I'd even say that factories are the place for it.
Alternatively, the factory could have an addStrategy() method that would accept an string (the format) and an implementation of the FormatStrategy interface. This way you would just: $factory-&gt;addStrategy('csv', new CsvFormatStrategy()); This exact problem (and the above solution) is discussed in Matthias Noback's book Principles of Package Design.
&gt; According to Open-Closed Principle the ‚Äúcorrect‚Äù solution would be to create a new factory with the same interface. But that means you'll have to change the controller (to use the new implementation), which again violates the open-closed principle. So to prevent that, you would need to inject the factory into the controller. Once you are injecting the factory, you have the ability to configure the factory before injecting it. And if you can configure the factory, the [option posted by Jautenim](https://www.reddit.com/r/PHP/comments/7tqk25/does_static_factory_violate_openclosed_principle/dtemjup/?st=jd02ye9l&amp;sh=1c830f9d) makes much more sense than creating a new implementation of the factory interface.
it would be useful for me to implement linspace method similar to this: https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html
Ignore Saltub - he/she is a known troll on this subreddit, judging by the post history they really dont understand reddit at all.
Nice to see a fresh thing. After reading all comments, just want to say: even though the public is a tough crowd, you need public. Learn from the comments ;-) BTW: was looking for the way you renderen templates, or how to use twig, without looking at code, and I think the documentation could need some magic too. Anyways: good job so far
I would share PSR-7 server (it's separate project) with it's benchmarks a bit later, currently it's internal dev build only: it works by mapping fasthttp request to JSON payload identical to PSR-7 request, then uwraps it into PSR-7 request on application end and passing it to primary dispatcher/middleware. Right now we are working on file upload support. However, you can check how scripts are structured inside `/test` directory, or `go test -bench=.` to run benchmark on your machine without HTTP stack.
Because &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, 
And also it's fine to start new things to strive for innovation. But we got a lot of new frameworks lately and apart for some PSR-7 compatibility "novelty" there was nothing new. For example when Laravel came out, you could argue there was already enough of big players, yet Taylor showed that one could still have a very different approach and philosophy (than the existing PHP frameworks) on how a framework should be. I'm not saying he invented fire, but he did create a big framework which stands differently to Symfony, Zend or CI. So I'm all up for trying and see innovation, but a premature framework that offers nothing new, is a one-man job, without docs, that don't leverage Composer and re-invent the wheel completely is just a big no no (unless for educational purposes).
It's a "principle", not are rule. Unfortunately, people obsessed with all these principles don't understand that. So they often sacrifice simplicity and readability for hypothetical "extension" that will never be useful. PHP isn't even good at encapsulation to begin with, classes or functions can't be private to a namespace, which makes actual refactoring tedious.
Why are there only 3 on the medium article, and then a link to an obscure website to "continue reading", looks like a cheap attempt at bringing traffic...
https://github.com/salesagility/SuiteCRM
Wordpress
Why do you need the mobile version on a separate sub domain? Why not do a responsive site?
&gt; Everything about this tutorial is terrible and should not be used in a ~~modern~~ web application Fixed that for you ;-)
This is not my choice unfortunately, so I have to do it this way. Any suggestion about my question ? Thank you.
In that case go for an api with some sort of authentication. 
I was being generous
The title is misleading, nowhere two different websites can be seen in this setup. So the most obvious solution would be the [Responsive design](https://en.wikipedia.org/wiki/Responsive_web_design). Or, if you don't have enough skill to create one, you can create two (or more) different templates for the different devices and choose among them based on the user agent/user choice. Either way, it must be just a single server with a single codebase, so there is no such thing like duplication at all
**Responsive web design** Responsive web design (RWD) is an approach to web design which makes web pages render well on a variety of devices and window or screen sizes. Recent work also considers the viewer proximity as part of the viewing context as an extension for RWD. Content, design and performance are necessary across all devices to ensure usability and satisfaction. A site designed with RWD adapts the layout to the viewing environment by using fluid, proportion-based grids, flexible images, and CSS3 media queries, an extension of the @media rule, in the following ways: The fluid grid concept calls for page element sizing to be in relative units like percentages, rather than absolute units like pixels or points. Flexible images are also sized in relative units, so as to prevent them from displaying outside their containing element. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
So it's like a shit version of FPM and RabbitMQ rolled into one?
Coming up: "Does classes setting up strategies for Static Factories Violate Open/Closed Principle?"
Huh, that is weird. I'm talking about [this issue](https://github.com/google/protobuf/issues/3623). Were you using a third party PHP plugin like [drslump/Protobuf-PHP](https://github.com/drslump/Protobuf-PHP)? According to the release notes PHP support wasn't added to protoc until 3.1.0 and it has only ever supported proto3 syntax. If you try to compile a proto2 file with `--php_out` you will get an error like '--php_out: math.proto: Can only generate PHP code for proto3 .proto files.'.
Yeah, factory is clean now. I was referring to upper layer class that sets the strategies. Of course we'll get to very crowdy global namespace this way.
That's a weird fetish.
Oscommerce 
Depending on the setup you are using I'd suggest a second environment that is accessed through the second domain. For Symfony, all you need to is is able to access a different app.php (app_mobile.php). This way you can change up the configuration / theming etc. while maintaining the same code base.
IMO, the most straightforward way to do this is two small steps: 1. Have a web server listening to both host names pointing at the same codebase 2. Put some small bit of switching logic early in your code to detect the `Host` header to determine which one was requested, and format accordingly. It‚Äôs not what I would consider ideal by any means, but it‚Äôs not too complex and works well on the single-server environment you described, only requiring a single codebase and deployment. 
&gt; PHP isn't even good at encapsulation to begin with, classes or functions can't be private to a namespace, which makes actual refactoring tedious. Do you mean IDE support or something else? IDE support for refactoring in PHP is indeed limited, but one can go far with careful use of regex (*and* the existing refactoring tools in something like PhpStorm). BTW you can sort-of-have private classes by having a static factory return instances of anonymous classes.
Older versions of phpipam were riddled with security vulnerabilities. Their old code base is still available on sourceforge: https://sourceforge.net/p/phpipam/code/568/log/?path= 
joomla 1.5
Oh god, that's one ugly codebase.
That'd be an unrelated problem :) But you don't necessarily have to pollute the global namespace (for instance, if the project architecture embraces dependency injection).
You, sir, just made my day!
Impossible 
Programmer's BDSM
Why?
WordPress doesn't want to be saved
OpenCart
No PSR-7... oh boy.
Well, some years ago i was forced to make an analisis of a terrible CMS called https://xomXXXol.net/ renogve the three XXX, in the lowest part of the page is the download link. By the way is one of the worst horros i see in the world of software, and use regulraly to see myself busy in the office. Is garabage but foix parts is easy,and is a good surprise check what bad can be the code. 
ZenCart
the software i say before, is a cheap clone of oscommerce, bTW
Type Safe errors should pop up in local dev anyway; idk why we need to type-hint all the things.
&gt; /me waits for "super objective zen idiot with opinion brings the tanks" to bring up Encapsulated Context No I won't bring it up. But what I'll bring up is whether you pass something to the constructor or a method depends on how the lifetime of the object is aligned to the lifetime of the larger application context. Therefore as an absolute advice "pass it to the constructor" doesn't mean anything. In general I write my applications so once I instantiate a configured object like an HTTP application, template engine, then I can use it for processing multiple requests, but this is because I support running the application persistently, i.e. I run it from CLI, and then it processes many requests (either as a persistent HTTP server or through a persistent FastCGI connection). If one doesn't have such a distinction or such a deployment target in their app, and without any other concrete considerations or knowledge of the object, pretending the choice between constructor and method is meaningful is a pure cargo cult.
You could teach a master class in worst practices with using just WordPress
Just join any project. They will refactor everything, all the time. Try to integrate as many new shiny libraries you can /s
pick any codeigniter app. 
Thanks for your response. I did not even think about a static factory in this way: that actually it is not an object, but a set of statements, procedural code written with class-syntax. So, there is no reason to apply OCP on it, as procedural code has nothing to do with SOLID principles.
If you want to refactor some real old school code, try b2. It's the original code from which WordPress forked. Pretty simple code, but full of problems. I'd be interested to see someone fix all the problems with it while refactoring it *and* keeping the simple templating. Source: I wrote b2 when I started learning PHP.
But then it's not PHP anymore, right?
Thanks for this. What an amazing piece of utter garbage Xomol is. I love that it's apparently named after an antipsychotic drug.
Have you tried searching Google? This question has been answered a million times before in many websites. 
Another answer reminded me, the worst codebase I ever saw was a Joomla plugin called Mosets Hot Property.
PHPNuke - https://github.com/rotvulpix/php-nuke/tree/master/html. Not sure if this is the original code base - don't remember now unfortunately. It looks like it could be. This was the first site I ever had that got 'hacked'. 
Oktober or Asgard cms 
https://www.codeigniter.com/user_guide/general/routing.html
October, you won't regret it
Personally I cut my teeth with [phpBB](https://www.phpbb.com/). phpBB2 to be specific, but although their website and [Github](https://github.com/phpbb/phpbb) say they have been updated recently, phpBB 3.0 released in 2007 and sadly development seemed to stall sometime after that. I stopped following phpBB not long after 3.0 launched so I don't know what happened, but the fact they have not released a major version since suggests not a lot of work has been done and a quick glance at the source code looks familiar in style to how it was back in 2007. It (was) a widely used and open source forum about 10 years ago and though I have fond memories of it, it was not the most elegantly written software even at the time.
In all honesty, grab an older version of PHPBB or SMF.
You can set up an htaccess rule
It wants to but it puts backwards compatibility over anything else. However, it does a fair amount of refactoring with every major release and more and more components are being modernized.
here's something pretty outdated that could use a lot of help... http://www.mytinytodo.net/
Is that any different to PHP in general though?
Bolt.cm is also a good choice especially for content types, template editor, role management.
Any reason you chose to start using Codeigniter? 
If you are looking for the worst project with a lot of legacy code...my current client is looking for developers :o)
If you are looking for the worst project with a lot of legacy code...my current client is looking for developers :o)
If you are going to change things up to use composer's autoloader, why wouldn't you use it for Classmap or File autoloading?
Not really, I suppose. Just that WP get shit on a lot and it doesn't really deserve it. You're always going to be balancing how approachable the code is, how extensible it is, how modern it is, how secure it is, etc. You're going to be hard pressed to find find a code base that's easy for developers to use but also follows the latest coding methodologies. Basically, I think WP gets compared to frameworks when they're not same things. 
Someone gave me a drupal site asking if I could edit it as a favour to them and I had absolutely 0 clue how to do anything. WordPress is way more intuitive. I'll have to look into OctoberCMS since it appears to be pretty popular. I would go with WordPress if you are the most familiar with it; it does everything you are looking for, including the things that your designers don't like about it - you can actually change in settings how it re-scales images.
Framework isn't going to change anything. So pick any you like (knew). But from hiring perspective it's better to have more popular tools like laravel or symfony for example.
&gt; why not build your own? because costs would be much larger than any benefits for commercial system. 5 years ago, maybe there would be some kind of benefits, but today you have highly modular frameworks (symfony or zend), which allows you to mix different components and doesn't introduce much overhead. If we are talking about performance - maybe you just need to use different platform/language. For example - nodejs + aws as platform + lambda + dynamodb + other services will allow you to have very scalable (depending on your use cases) system with less efforts and with much lower payments for infrastructure (first 1 000 000 requests are free, next will be something like $0.2) If you have much free time to build your own framework - consider to switch technology stack which enforces you for such decisions.
It doesn't enforce my decision, but I like building frameworks haha I find it fun and they're not used professionally (or at least in my main job), but this is about learning frameworks not using professionally
[Fork CMS](https://github.com/forkcms/forkcms) is pretty good if you have some basic Symfony knowledge. Includes a media library module. It's up to the developer to choose how the module is built: can be created with some basic php code with twig and raw queries in the Model (see e.g. Blog module), or you choose to go full Doctrine/Symfony Forms/Twig/DDD/Command bus pattern (see Content Blocks, MediaLibrary, ...), depends on the developer. Focus of this CMS is mostly on custom module/theme development (whereas wordpress has a large collection of plugins and themes) but I build all my websites with it without too much effort.
Maybe it's fun, but I don't think that repeat something existing really allows you to get more experience. Most of the time such learning strategy just a way to cargo cult. Also it's very inefficient from education point of view. 
shit, phpBB was da bomb.
&gt;What kind of framework would be best for a website like {insert project name here} Any. Symfony, Laravel, CI, Yii, etc. No framework has bounds on what you can do with your imagination. They all offer the ability to do any feature you can think of. For example - the start of Uber was developed with CodeIgniter2. Does that mean if you want to build the next ride-sharing platform you should also use Uber? Nope. At the end of the day the question is "what framework suits my programming design methodology". If you are comfortable with Framework X - then just use that. If you want to try Framework Y because you heard some cool things about it - then give it a go.
phpBB Dev here. We didn't release a major version because... I don't actually know, the decision was made before I was in the team. phpBB 3.1 should've been called 4.0 actually because of the major changes (we switched to Symfony). Since then we include more and more Symfony components and have a much more object-oriented codebase, even though we're still not done refactoring everything. The code has changed by a lot since 3.0
If in 2018 you define object properties by using `var`, then you deserve all the shit that gets thrown at you. It's literally PHP 4 code. PHP 4 reached EOL 10 years ago. WordPress is written in a way that it should run on a PHP version that's been dead for 10 years. Let that sink in.
Yet. The dev for WP is on the committee for PSR.
+1 to drupal or wordpress
Are you serving your site with Apache2 or Nginx? If you're using Apache2 read up on Mod Rewrite. You'll probably need to add something similar to the following to your .htaccess or Apache2 configuration file: RewriteEngine on RewriteCond $1 !^(index\.php) RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)$ index.php/$1 [L,QSA] 
It wouldn‚Äôt be hard to find a job at a company with crumby software, potent with that legacy smell you crave. At least get paid for this time.
A project I work on https://github.com/librenms/librenms Several globals, file includes used like functions, very little classes, no namespace, no tests, odd mysql shim, unused code. Forked from another project that closed its source. At least that is where it was 1-2 years ago. It is still pretty messy, but I've been slowly working on modernizing it. We just recently finally dropped php 5.3 support and I'm looking to wedge Laravel into the project. Refactoring is a slow moving project. The project itself gets quite a few contributers every month. 
Great input. The biggest reason I suppose I was wondering is because I have heard a lot of talk that CI is dead and you would be a fool to start any sort of large-scale project (this is hopefully going to be very large-scale). Others say that CI is alive again under the new ownership, is faster, and more versatile; that Laravel is bloated, loads more slowly, and isn't good for high traffic sites. I'll probably go with CI since I'm familiar with and really like it..... and because Uber uses it ;P hahaha that is awesome and encouraging though, I had no idea.
I don't want to re-invent the wheel here ;P What I have planned is going to be FAR to big to do all on my own.
&gt; from hiring perspective Good advice
It's certainly an interesting solution
Unrelated? Maybe on internet advisory level, because in practise it's the **direct result** of seeing OCP violation in factory as a problem and fixing it. &gt;...if the project architecture embraces dependency injection If I hadn't seen it so many times I'd think you're doing it intentionally. I'll ask anyway. Where does DI start?
Looking through the source but can't see any import support ( Wordpress or XML / CSV ). Does it have such a feature?
Magento would be another good one to look into.
Huzzah, I can retire my "download the beta" script :)
Well we have a team so thats not much of an issue. We are looking for somethere where we can minimize the work we have to do using add ons, but for aby funtionailty we're missing we want something thats quick to learn to develop on. 
Try b2/cafelog. The official site (http://cafelog.com) is down. Remember it's 2002 we are talking about. Git was released in 2005, GitHub in 2008. This project is probably too old for you to start or even run in the first place. B2evolution was a thing from my early web dev days. That's probably a better start for you. Heck, a 2018 WordPress release is practically legacy compared to Symfony/Laravel. 
You know WP so I will talk about the others. **OctoberCMS** : Built on laravel but isn't really a laravel experience. They have a very unique style that will feel similar to Vue or React but in PHP (mixing template and code in same file). This is good for feeling modular but bad for general good programming (separation of concerns). Its flexible in utility but you have to do things their way. Addon availability is average. Nowhere near WP but they do exist. I find October is good for sites with a lot of custom and specialized content. **Drupal** : A beast of a system, you will feel like you are steering the Titanic. You will be in Drupal world and will need to do things the Drupal way. The main advantage is the huge number of Addons similar to WP coupled with a better architecture than WP. The community is great, but it needs to be because the learning curve is higher than it should be. I find Drupal good for sites that need a lot of third party integrations that Drupal specifically has addons for. Its also good for big organisations with complex permission structures, or that simply like the piece of mind of an "enterprise" cms that is well supported by the industry.. **Pyro** : If you want custom development Pyro is the way to go. Its built on Laravel and unlike October it actually feels like laravel. Basically if you know laravel you can find your way around Pyro. Developing addons is just like developing on laravel. So its great. Biggest disadvantage is the lack of addons. The community just hasn't done the work to create a decent marketplace. There are almost no themes at all. You will be developing most things yourself. There are a lot of features built in, and you will find that for most of what you've mentioned you will be able to do it without plugins at all. And they have some paid plugins that seem decent. But most things like third party integrations you will have to build in house. If I need a CMS but know I have a lot of dev work to do on it I will use Pyro.
You can find hundreds of legacy projects here: https://www.softaculous.com/softaculous/apps
&gt; Heck, a 2018 WordPress release is practically legacy compared to Symfony/Laravel. Yep. Alot of the folks here don't know, or forget that WordPress pre-dates practically every modern web development practice by years. 
I'm not familiar with Mockery, but .. &gt; If we had something like &lt;?= $invoice['something_else'] ?&gt; in the script, the test would fail. Why? I'm not able to tell from the article how that is being tested. That warrants a little explaining.
PhpList
The author has stubbed the response from `Billing::prepareInvoices` to return a fixed array. `something_else` is not defined in the returned array. If you were testing the view layer and had typed `&lt;li&gt;&lt;?= $invoice['total'] ?&gt;&lt;/li&gt;` to `&lt;li&gt;&lt;?= $invoice['something_else'] ?&gt;&lt;/li&gt;` you'd see an error.
That depends on how it was "locked". I guess those php files can still be executed so I guess it's obfuscated. If that's the case it highly depends on how it was obfuscated if it can be undone. You can PM me an example php file (take the shortest one) and I take a look if it's possible to "unlock"
Xdebug: https://www.patreon.com/derickr
PhpUnit: https://www.patreon.com/s_bergmann
PHP-CS-Fixer: - https://www.patreon.com/keradus
im surprised it takes 13 lines of code to return a static resolver in GraphQL.
PHP 4 is a bit harder to find these days, but early PHP 5 projects are just as bad. Look at any old CMS/forum/webshop - Mambo/Joomla, WordPress, SMF, MyBB, OpenCart, they are all awful even if they do use some classes. If they support plugins, jackpot, because their quality is even worse. I once had the misfortune of integrating a paid Magento extension that had [security holes up the wazoo](https://github.com/DCoderLT/insecure-pdc) and still charged 1000$ per copy. But there's no public source to point at. I remember old versions of MediaWiki also being obsessed with global variables, but that may have been cleaned up lately. Searching GitHub for cryptocurrency-related projects will yield some ~~interesting~~atrocious solutions like https://github.com/wlox/wlox (random example I found on the first page of Google results). If you get tired of those and want something even weirder‚Ä¶ Look at specialized libraries. For example, TCPDF is a clusterfuck - a single class spanning 25k lines, and the largest method has 1455 lines and NPath complexity ‚â• 2^128. On the bright side, it can confidently claim it has zero SQL injection vulnerabilities. /s Or observe Mark Karpeles demonstrating the _"when all you have is ~~a hammer~~PHP, everything is ~~a nail~~a PHP script"_ principle by writing shit like BitTorrent clients in PHP: https://github.com/MagicalTux?utf8=%E2%9C%93&amp;tab=repositories&amp;q=&amp;type=&amp;language=php
Phpbb Checkout their github 
Not specifically for Wordpress but you could easily build your own: http://octobercms.com/docs/backend/import-export
PHP on IIS with FastCGI works perfectly well in enterprise deployments. 
https://www.patreon.com/ciphpercoder - /u/sarciszewski makes PHP safer https//www.patreon.com/sgolemon - /u/SaraMG makes PHP https://www.patreon.com/phpstan - /u/ondrejmirtes makes PHPStan
Yii Framework - Alexander Makarov: https://www.patreon.com/samdark
Vladimir Reznichenko, Php Inspections (EA Extended): https://patreon.com/kalessil 
Worth adding CraftCMS into research as well: https://github.com/craftcms. Good codebase quality (Yii2 if to mention frameworks), great community and they have plugins marketplace as far as I remember.
It's not about how many lines of code you have. It's about how you handle complexity in your code. And that's something that OOP is better at than procedural code. Procedural can be fine for very small scripts, but anything larger than that you will benefit from using an OOP approach. You write more lines of code, but the code is much easier to maintain and you will end up saving a lot of time in the process. Optimize your code for reading, not writing.
OOP is great for dealing with complex problems, but OOP makes all problems appear complex.
If you're already familiar with WordPress maybe sticking to it and including more functionality is possibly the way to go? Have a look at Themosis (http://framework.themosis.com/) &amp; TypeRocket (https://typerocket.com), if you're familiar with Laravel they can greatly increase what you can build whilst still retaining what WordPress offers.
If you feel that small donations don't make a difference, talk to your boss about donating to open source. Your companies can probably afford to donate to the software the company use. Together, they would give these people enough gratification for the work they did, maybe for several years, and that allowed the community and the industry to grow as a whole. That being said... also small donations are nice. 
ircmaxell - php core contributor and blogger https://www.patreon.com/ircmaxell
You can simplify the installation process if you register your skeleton on [Packagist](https://packagist.org). For example, see [`localheinz/repository`](https://github.com/localheinz/repository). The creation of a new project can then become as simple as running ``` $ composer create-project localheinz/repository ~/Sites/foo/bar dev-php-library ``` You can even manage ‚Äì and continually update ‚Äì multiple branches for different project styles. 