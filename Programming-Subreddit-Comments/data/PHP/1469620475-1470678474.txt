Yep, this is one valid part where I use traits excessively and it makes my life easier. A lot.
So basically you said "There are really few examples of good trait usage, because I don't like `$obj-&gt;setFoo('bar');`. There are a lot of good use cases for traits. And there are a lot of bad ones. Used correctly, they make the life of every developer easier. Also, if you have setter-injection, they can also make _your_ life easier (as said, just use them correctly). Taking your example below, imagine something like trait EmitterTrait { private $emitter = null; /** * Notice, using things like Symfony + JMS Di Extra Bundle * would allow DI with annotations at exactly * this point */ public function setEmitter(Emitter $emitter) { $this-&gt;emitter = $emitter; return $this; } public function emit($event, array $args = null) { //May or may not be omitted if (!$this-&gt;emitter) throw new RuntimeException('...'); return $this-&gt;emitter-&gt;emit($event, $args); } } Notice that you can end up with `$this-&gt;emitter` being null in `emit` if the trait is used wrong (no way to enforce the setting), but it would also be an error that a developer can easily see and fix. An example implementation would look like //Example impl. class Connector { use EmitterTrait; //DI via constructor possible, but not required as long as you use //setter injection when not public function __construct(Emitter $emitter) { $this-&gt;emitter = $emitter; } //Done. } You can also take the lazy-loading approach falling back to a default implementation, DI optionally possible. trait EmitterTrait { private $emitter = null; public function setEmitter(Emitter $emitter = null) { $this-&gt;emitter = $emitter; return $this; } public function getEmitter() { if (!$this-&gt;emitter) $this-&gt;emitter = new DefaultEmitter(); return $this-&gt;emitter; } public function emit($event, array $args = null) { return $this-&gt;getEmitter()-&gt;emit($event, $args); } } Even this one is possible trait EmitterTrait { abstract public function getEmitter(); public function emit($event, array $args = null) { return $this-&gt;getEmitter()-&gt;emit($event, $args); } } and works flawlessly, especially with return-type-hinting. Now add a bunch of utility methods for event-emitting in that and you know why traits make sense. In any case it makes more sense than using an abstract class.
Finished really functional color manipulation and comparison utilities. Can parse and manipulate any kind of color format you can think of, supports like 740 inbuilt colors, can generate color schemes just like all of those color-palette-websites (kuler, paletton etc.) Supports RGB, RGBA, HSL, HSLA, HSV, HSVA, CIE XYZ and CIE L\*a\*b\*, compares colors with CIEDE2000. https://github.com/Talesoft/phim Will be a full image manipulation library with GD and Imagick, the color manipulation is already finished and works. Looking for feedback.
On and off I've been working on a json serializer: https://bitbucket.org/1of0/json At the core it uses `json_encode()` and `json_decode()`, but does some pre-/post-processing to add features like type converters and inclusion mapping. It's not very different from [jms/serializer](http://jmsyst.com/libs/serializer), and honestly at this stage I would probably recommend this library over mine. But if you're feeling adventurous, go give it a try. I'm happy with any feedback.
There is a use case for both `Application-level Middleware` and `Integration-level Middleware`, maybe gloss over the fact PHP Middleware is not Integration-level (used to join disparate systems), but Application level (used to augment an existing application by adding code that does not alter existing route-action level logic). It's more monolithic from an overall application point of view, which has benefits and drawbacks. That really could take 30 minutes. From a high-level, all middleware is about extending functionality (where I'd view communication and translation as functionality also). From a high-level it's all about keeping something as it is, whilst adding new features. Talk about black-box modelling of architecture and the move towards micro-services, and talk about shared application code and Application-level middleware as a common code-fabric to define protocols (on top of http), common behaviours that really have no place in the core application, but are necessary to facilitate communication, or an upgrade / feature path. It's a beefy subject for sure, good luck, I'd love to see a video
I have mostly moved away from PHP but I have to do some admin and light dev on a drupal site still. Now I largely write javascript or java. The most important things I learned were how to stop writing code that has side-effects and to write smaller, more easily testable and readable code. It's actually much harder to side-effect things when writing in a functional language. They also tend to favor things like tail recursion instead of for loops. I also started to see where functional language concepts were sneaking into more modern languages.
I'm glad to hear that! A digital (DRM free) subscription is $49/annually which breaks down to about $4 per issue.
&gt; As a general rule, you should work on no more than one or two short tasks at once. Over the years, I've worked with a lot of developers that refuse to accept this general rule. I guess they liked to think they were special? Anecdote: I spent the past two weeks designing a novel cryptography protocol (which I will be publishing after I hear back from a few experts on whether or not they can attack it easily) for usable multi-device key management. In the meantime, I've not touched most of the other projects I maintain (and the ones I have, only sparingly). As far as I can tell, the world hasn't caught fire. In my humble opinion, multi-tasking is overrated.
Sorry didn't mean SO is necessarily bad. In fact, I am one of the mods at a Stack Exchange site. SO contains a lot f terrible answers as well. More often there are lots of things to learn about. As long as you don't blindly copy paste everything and are willing to see through everything, w3s is a reasonably good resource. May be not for PHP, but the css3 examples are quite good. 
&gt; In my humble opinion, multi-tasking is overrated. Hear, hear. There is no such thing as "multi-tasking." There is only "attention-switching."
The longer I have been working in this field the more I have come to realize that using off-the-shelf solutions on the micro-level (e.g. library level) works great, but at the macro-level (e.g. Magento or Presto) not as much. I have found that the reason for this is often the requirements will change so much on the scale of a couple of years that the original off-the-shelf macro solution won't work anymore. However, at the micro-level it is easier to swap out the Lego blocks or use different Legos to make whatever I am making. 
We're just now wrapping one up, and I agree almost entirely.
Yep. You have to appreciate it, warts and all. It's a massive undertaking to support as much of the web as it does, while still being mostly secure, and still being accessible to non-devs.
haha, now if we can only convenience crap-tier managers of this fact, we can all be more productive.
&gt; ZF1 modules confirmed.
Genuine interest, what did they move on too in your opinion?
Wow. Interesting stuff. I'm definitely going to dive into this.
Hosted solutions or non-ecommerce work. 
Yeah I had a similar experience trying to use PSR7. After not being able to write to the request body without a stream factory (this was before the recent psrs, thanks shadowhand!) I just gave up and went back to HTTP foundation. I know slim extended their psr7 objects but I don't think it has all of those convenience methods. Iirc there was a debate over inclusion of additional methods.
Yep and this realization about the synergistic effect of breadth of knowledge really makes me think that the whole jack-of-all-trades-master-of-none catchphrase is not as valid as I initially thought.
Nope just a sql database, which I could use for session storing as well...
Just a personal preference. I always assume that an app is going to eventually have larger data needs, especially if OP is talking about opening this up to a user base.
I've been reading up on SOLID. It's exactly what I need. I'll check out the Laracasts on it.
I am not TOO familar with Scala... if Trait's could be injected dynamically then yeah I could totally see them being a valid tool. As they stand now it's just broken DI to me, more or less a dead feature.
What alternatives are there to phing? 
/r/phphelp - they will show you the way.
Depends what you are working on. It can take between 15 minutes and two weeks. 
&gt; The set_time_limit() function and the configuration directive max_execution_time only affect the execution time of the script itself. Any time spent on activity that happens outside the execution of the script such as system calls using system(), stream operations, database queries, etc. is not included when determining the maximum time that the script has been running. This is not true on Windows where the measured time is real. 
In my experience yes. I've had to download files to a server before that I didn't want to do through ftp, so wrote a script that just downloads the files and I had to deal with workarounds because the script kept timing out. 
Was that on Windows?
What is wrong with you-- that is terrible advice!!! (Three exclamation points.) plaintextpassword.txt You bastard. Get it right next time.
Could you elaborate on that?
&gt;It will be interesting how this will affect the adoption of Vue.js for projects like October CMS that rely heavily on the front end for providing optimal user experience. October CMS user not affected. BYO front-end framework. Not much different to [creating a site using Notepad](https://vimeo.com/172202661). edit: Added quote for people who can't read.
But you should make it public, so when you open "www.domain.com/passwords.txt" you can see it. This way if you forget the credentials, you will have easy access ;)
As a majority of the Laravel community uses Vue.js , it's quite logical they offer some boilerplate for it. And it's only boilerplate, you can totally ditch it out in a matter of seconds.
Slim was the one I found too. I don't think they released it as a standalone package but I honestly didn't look past a cursory check of Packagist and the Slim docs. It seemed most the new methods were just truthy checks for the HTTP method type. I've been reading through the PSR-7 meta document trying to suss out the more baffling choices and it's really hit home Anthony Ferrara's ["99% problem" blog post](http://blog.ircmaxell.com/2014/10/an-open-letter-to-php-fig.html). It feels like FIG was so interested in covering everything that is and will be that they failed to make a tool that's useful for what the majority of developers do *now*.
Nope. Don't know the exact os as it's a webhoster, but definitely *nix. 
After this, _practice_. It's all well and good knowing what the principles are, but putting them into practice is an entirely different story, especially when you need to fit them into the domain of your project. Also bear in mind that SOLID isn't the end all be all. Sometimes it makes sense to break those rules.
 Sorry I assumed people still actually read things these days... zzz
I wonder if anyone finds it odd that their PHP framework is selecting their JavaScript framework. I understand it's not a precedent, but scope creep is a real issue many projects are dealing with, and to me this is one sure sign of it. 
Well, if you are using laravel for a production app, you are most definitely going to choose a js framework. I find it better that laravel actually has a default framework, so new devs can learn without going through js framework hell. As far I understand, you can still choose to *not use vue*, just as many devs(including me) chose to use postgres, even though mysql is laravel's default database. 
Interesting, althought I have not heard it in its full form before. Very often misquoted, I guess.
quite useful - thanks
I reported a possible vulnerability to the author. If anyone else thinks they found the same one, please don't post it here or as a Github issue.
There was Zend Framework 1 chose Dojo back then
Because I felt your report should be know to everyone I added a little note about this vulnerability in the readme https://github.com/spatie/ssl-certificate/blob/master/README.md I will fix this soon. I must first research the problem / solution. If anybody can point me to some good code to verify if the certificate is signed by a trusted authority, I'd be very grateful. 
I'll start a pull request today. It's a nontrivial problem to solve.
No, this is a [bad idea](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/).
never does friend. never does :) Terrible managers don't realize there's a cost from going Project A to Project B. It's not a material cost, or even an expertise cost... it's a human cost. Devs find it really annoying to switch from 1 project to another. The cost of the switch has a hole bunch of different factors. The sooner our managers realize this the better off we all are.
Depends on what you're using it for. [Robo](https://robo.li) seems like the most straightforward alternative. It's essentially a PHP equivalent to Grunt. If you just need deployment (from Git), [Deployer](http://deployer.org/) is a good choice.
Is not coupling, is about boilerplating... You can always use raw or extend in Laravel to use with other frameworks. Is democratic but not excludent.
From the article, as what JWT is good for: &gt; Hello Server B, Server A told me that I could &lt;claim goes here&gt;, and here's the (cryptographic) proof. This is exactly the scenario that OP was describing.
We don't use Vue.js for anything on the front-end. The only thing that is "default" about it is that support for compiling Vue components is baked into Laravel Elixir (our Gulp compilation) tool by default. We don't actually include any Vue front-end code with the framework.
memory tables work ok
Other way around. I found it first, then showed it to Jeffrey.
Nothing in Laravel is tied to Vue. Compilation of Vue components is what is supported out of the box. There is no Vue front-end code in Laravel. Also I'm the one who showed it to Jeffrey - not the other way around.
I have used JWT and it is not that easy to get right. If you can live with server-side state, it is probably a lot less likely that you will shoot yourself in the foot.
Who used that though ? jQuery just took everything by storm at the same time. Fortunately there was ZendX_jQuery ...
I'm CEO of a small company in Nuremberg, Germany, I'd like to share my experience with searching new devs, maybe that helps. We found most of our devs through devs that are already working for us, so knowing a lot of local programmers definitely helps. Connect yourself with others via twitter, linkedin or xing (xing is mostly for the German market, don't know where you are from) What I can also recommend is going to local meetups of companies that might be searching devs. E.g. in Nuremberg we have something called the "Webmonday" where a lot of local web-companies meet once every few weeks and talk about web-related stuff. Being open for other web-related topics like SEO and going to local meetups e.g. of SEOs (which might usually also need programmers or are devs by themselves) helps too (and is fun ;-) ) In general it absolutely makes sense to have profiles e.g. on linkedin, fb or twitter which show your experience and that you are interested in programming as a lot of ceos check those profiles before a job interview. Good luck!
You can use what you want in Symfony for routing, choosing from yaml, xml, php or annotations. I believe that didn't change for v3. Edit: here it even says that annotations are best practice: http://symfony.com/doc/current/best_practices/controllers.html http://symfony.com/doc/master/bundles/SensioFrameworkExtraBundle/annotations/routing.html http://symfony.com/doc/current/book/routing.html
You can choose, that's why I'm trying to decide :) It defaults to annotations, but annotations feel very counter-intuitive to me. I saw the annotations in the best practices but that threw me for a loop...I thought that there was a lot of controversy over the use of code in comments?
I'm auto answering myself, but I'd say that whatever is the format you'd choose, choose it to be the same than your other configuration files, to have all files keeping a consistent format, it'd probably help newcomers on the project; having all sort of different formats will make useless noise making harder the whole project comprehension for the developer (even yourself).
Your condolences are accepted and appreciated, I will make a sacrifice in your name to Drush and pray it is appeased ;) My biggest issue with annotations is more or less what you've said...in the end I really don't like having code in comments, but as /u/NLZ13 has pointed out, Symfony's documentation says that annotations are best practice and it's confusing me.
YML and XML are best practices too, don't let the documentation fool you, Symfony is a framework that leave you with a lot of flexibility, and every choice you make is potentially a good one, if it makes sense in your archictecture/software design. Fabien Potencier did write an article about this, I can't find it right now, but he does explain that every choice you make is potentially good and there is no enforced law when you use Symfony, use it your way. As long as you use something pretty much standard (XML and YML both are among the community) you keep portability and readability, so they are good choices as well.
In France you can find basically anywhere if you know Symfony 2/3 (Based on my own experience)
Well, it's proposed in best practicies, maybe because it's the easiest way to define routing in Symfony Standard Edition, it's autoconfigured for that, you don't need to create additional config files etc. But do whatever you want, Symfony does not force you to use one format over another.
Thanks for the clarification. I really don't see why this has been so polarizing. Worst case scenario a high quality open source project (vue.js) just got a big jolt of support. And if that support drives other big js frameworks to improve based on greater competition for developer mindshare then we all win right?
I am talking about learning es6 and jsx in addition to react, which does seems to be a must. ----------------------- It's pointless to continue this discussion as Taylor has said that the react-etc article is misinformed and vue is not default framework, only the compilation of vue templates is added by default in laravel-elixir.
&gt; As a majority of the Laravel community uses Vue.jsâ€¦ Probably not, other than for developers who are just learning about this stuff thanks to Laravel's support. React is far, *far* more popular.
XML for configuration can go right back to where it belongs...in 2009.
used both in multiple projects, their are both fine, neither lead to problems. both are supported 100% by phpstorm also. the only thing i avoid is xml for everything except the translation formats
This is the worst kept secret in history of Laravel. Anyone who listens to Laracasts or follows Laravel smelled it from a mile away. Now - they could do a lot worse than Vue. I don't mind it.
Please, read my answer about the disadvantages of annotations [here](http://stackoverflow.com/questions/12528108/yaml-or-annotation-mapping-in-doctrine-2/17595072#17595072).
I'm glad you are defending the fact that there is no dependency or sticky glue whatsoever. The huge amounts of love Vue.js gets from the laravel community is just insane, or scary. I love React.js but almost feel ashamed to tell my fellow artisans. Laravel shouldn't make any assumptions on what frontend stuff you use. I hope it will stay like that forever.
Definitely JWT with API's..it is newer a good idea to use sessions with any API..JWT is easy and secure, I recommend using the Firebase library for PHP
If you're writing reusable stuff, then I'd recommend NOT using annotations. Most people aren't, that's why it's in the best practices.
I don't think you know what, "CSV", means.
Don't know why the hate for Sublime, some people just don't really care about all those bells and whistles PHPStorm have. Personally, I work with several languages... Golang, Node.js, Python, PHP, and a little bit of C. Sublime text is THE best tool for me by far. Even if I were to tackle a project that's purely PHP, I would still choose Sublime text in a heartbeat. It's got everything I need.
How is vue complex?
If you haven't already, then give Atom a shot. It really feels like Sublime 4 and is much more actively developed.
They can downvote you as much as they want, but it's true, after 20 plugins you still won't be able to get a decent autocomplete
https://medium.com/p/9dda7af674cd for more information about the extension.
I too prefer sublime. After years of making snippets and configuration it's just hard to spend the time configuring something else knowing i'ld be done already. Auto complete? Lol. 
I love Sublime Text and use it along with PHPStorm for smaller projects or quick file editing, they are both useful in different ways. But trying to make Sublime Text into an IDE is a mistake in my opinion, why not directly use an IDE if you want full-fledged project intellisense with indexing etc?
I switched from yml to annotations about a year ago, and I love it. In the end it's easier to work with than adding an extra file for me, but YML is fine too and with IDEs it's not really that much of a pain to switch files. Annotations aren't that counter-intuitive once you get used to it and the advantage is that you can see at first sight how an entity is retrieved if you use doctrine and need advanced stuff like retrieving an entity with special joins (somewhere where fetch eager wouldn't work) : /** * @Route("/{product}", name="product_detail") * @ParamConverter("product", options={"mapping": {"product": "slug"}, "repository_method" = "findWithJoins"}) */ public function productDetailAction(Product $product) { // work with you product entity .... this way, there's no need to check another file to see what repository method is called to retrieve a Product entity here. But you might not need or work with that kind of stuff.
I don't understand the "one or the other" mentality. They're tools of the trade, not sides in a war. You can use them both.
Chances are you're going to need something - given Laravel's game is to "simplify things", and given the absolutely mind bending array of choices in the front end framework space, it was ripe for simplification by opinionated selection. Now, there are arguments to be made as to whether it's the best choice... (and for the kind of work I do, it's not.. but the kind of work I do is probably not representative of Laravel users in the main), but there isn't a problem with the choice being made in general I don't think. Personally I'd like it if there was a clean way to opt out of it at project creation time (along with a myriad of other things I simply don't use), but that's a minor quibble. tl;dr, not my cup of tea, but don't have a problem with a choice being made. 
He *is* a bigger man, [a figure behind the most useful standards](http://www.php-fig.org/psr/). It's a pity that since these days of productive work, now bureaucrats took over the devs in PHP-FIG, taking their duty as nursing their personal frustrations. 
^^or ^^just ^^use ^^phped 
I've been completely in the dark on this, I would appreciate any background, or pointers to a blog post or something that explains the situation. Thanks! Edit: there's a link to the discussion thread in the post. This is giving me the context I need. TBH I'm not surprised.
Woody Gilk sums up my opinion of Paul very well: &gt; In my professional life, I would not be willing to work alongside someone who was openly a misogynist or racist, no matter how smart they were. I'm not saying that PMJ is either of those things but several of his blog posts about non-technical subjects have made me very uncomfortable. Paul has a tendency to bring off-topic topics into technical discussions about PHP. It's not that I mind him having a quite clearly very conservative opinion, it's just that when I'm reading about PHP, I really don't want to be party to his views on gun control. He himself has said on Twitter a long time ago that he feels people don't want him to talk about politics because his political opinion doesn't suit those people; he is actually probably not wrong, but I would like to counter, by suggesting that PHP conferences and PHP blogs are not the right forum for ventilating opinions on United States domestic politics.
&gt; now bureaucrats took over the devs in PHP-FIG, taking their duty as nursing their personal frustrations. So it happened what I said [here](https://www.reddit.com/r/PHP/comments/4piv4i/phpfig_drama_continues_as_the_group_publicly/d4m2swf) ?
Really? I've customized the heck out of my shortcuts. I don't think I've found one yet that I didn't have access to. I've always consideedr it one of JetBrains' strengths 
For those asking about intelligent code completion, you can do it in Sublime with Code Complice. It works really well. https://twitter.com/burriko/status/758970567965839360
I believe the context for these key points is: "when dealing with people pushing for COCs"
Adopting a code of conduct is not a special kind of discussion exempt from normal responsibilities.
However the approaches used to achieve this goal sometimes aren't the most friendly.
&gt; I believe the context for these key points is: "when dealing with people pushing for COCs" Which is what this is to him, if him following the "conducting operations" section from that talk wasn't clear enough. The only complainant [he directly addressed](https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/EUehhuf6CAAJ) was [Larry Garfield](https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/ww0kKM0vAAAJ), who accused him of, among other things: &gt; * He openly attacked Secretary Candidate Michael Cullum as "against freedom of speech"[7] for daring to speak out in favor of the proposed PHP Internals Code of Conduct. Since he saw it fit to drag Internals into a FIG process, I will note that Paul's own behavior in the Internals Code of Conduct discussion was abhorrent and insulting. Declaring anyone who even remotely supported a CoC as "fascist", "anti-freedom", etc., repeatedly, is not conducive to a mature discussion. Disagreeing with the PHP Internals CoC is fine, and Paul or anyone else is entitled to that position. Vitriolic attacks in the name of that position are not appropriate. Those are the actions of a bully. And [when the discussion was posted to Reddit](https://www.reddit.com/r/PHP/comments/4piv4i/phpfig_drama_continues_as_the_group_publicly), someone opined: &gt; It's ironic that Paul prophesied the CoC mind cult would be used for this very purpose. To which [he replied](https://www.reddit.com/r/PHP/comments/4piv4i/phpfig_drama_continues_as_the_group_publicly/d4mbnao?context=1): &gt; Yes; uncharitably, a "mob" mentality.
&gt; Well ideally the result is lopsided in favor of either one side, for or against Paul. Honestly I don't think it should matter that much if it isn't lop-sided. If 51% of a group vote that a member is too toxic to continue being part of that group, then it's pretty clear that the person is causing a problem in that group, even if it's not unanimous. 
No. The first question should be "Are we really gonna write Php in 2000 fucking 16?".
why the hate? a good programmer will write good code in &lt;lang&gt;, a bad programmer will write bad code in &lt;lang&gt;. 
Spot on
Good programmers realise that he is only human, and uses all the help he can get by using a good langauge, to protect from his own mistakes and write correct programs. Bad programmer does not recognizes this, and keep thinking that he can do a good job with a bad tool, while chanting the logic you mentioned.... And no hate. Just sympathy.
But it is perfectly acceptable to bring up opinions of that sort as long as they are left leaning and supportive of the safe spaces/no meritocracy crowd.
PHP7 is great, and it pays the bills. Go back to 2000 and late
The answer is almost always yes. If you waste your employer's money writing config parsers, standard form validators, and routing, you don't really understand what it means to be a professional.
You're going to do almost exactly the same as all the other people. You need some sort of database layer, you need something for templates, form handling, etc. Stop reinventing the wheel. Just use a framework.
&gt;Go back to 2000 Well, I am here, right?
Agreed. The whole CoC should really just be about making sure they people stay on topic with other members of the PHP FiG and maybe things like strong cases of open racism.
- You don't have to wire it together yourself wasting time. - Framework is tested by people. How you wire libs together isn't (yes, we have unit tests but something often slips through).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [Php is too hard for you. You should try Ruby.](https://np.reddit.com/r/lolphp/comments/4v6ibc/php_is_too_hard_for_you_you_should_try_ruby/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I can't wait until they turn on themselves now. It will be glorious.
Isn't a framework just an appropriate selection of libraries?
This is a bit outdated (2013?). &gt; The framework should be able to only push the components that you need to the production servers. Sounds like Composer solved this issue (v1.0.0-alpha1 released in 2012). &gt; There are some frameworks that, ok, they are modular enough that you can pull things up. Sounds like many frameworks have taken this approach (Symfony v2.1 released in 2012, Aura v1 released in 2012, the PHP league started in 2013?, &lt;insert your favorite framework here&gt;, Zend v3 released in 2016).
.... You didn't watch the video ... did you?
Less flexible, but better tested and faster to use initially.
I've watched the video. However, I decided to comment for the title because 'Should we use a framework at all?' makes no sense and is really the wrong question OP is getting out of this video. A lot of people will read the title as 'I should code things myself'. I just think OP's title is bad. I should've clarified that.
During the time of this video, there were fewer loosely coupled frameworks and more opinionated ones. To give you an idea, this video comes from a time when Zend Framework 2 was just starting to be stable enough for bigger, corporate-like projects. During this time, we saw many frameworks that required the use of framework-specific database, routing, models, view/templating, and you couldn't easily drop in any replacements. Now, things are a bit different, but what he says is still very relevant.
Yep. 3 years ago is an eternity when it comes to package development. Hell, when I was working at Disney in 2011/2012, we used Zend Framework 1, and we had no idea about what composer was. I didn't even start using composer until 2013, when a package I wanted to implement was using it.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I have a massive feeling that most people in this thread 1) haven't seen the video and 2) don't understand that in 2013, things were much different with regards to frameworks. What Rasmus says here is very much true, for 2013, and I even agree with his feelings about specific-use frameworks (like Wordpress and Drupal). Though, we may have more loosely-coupled frameworks (like Slim, Lumen, and the like) now, the video specifically states that if the framework is spending more time looking for hooks than it is executing the core code, then it's a poor framework (and it "sucks").
Because it is difficult to find my responses in that monster discussion thread, I link to them here for your convenience: - [My initial response](https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/EUehhuf6CAAJ) - [Regarding attempts to contact me offlist](https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/hL0uk2FUCQAJ) - [Asking that the vote be called](https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/j7G5Sx_dCQAJ) - [Telling the complainants to suggest alternatives](https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/KNY9lbNSCgAJ) - [Responding to the suggested alternatives, and final summary](https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/0E5oVMueAQAJ) --- **EDIT** to highlight some of the points from my different responses: &gt; On the one hand, there are the initial 20 complainants (some of them Voting Representatives and others community members). Collaborating with the secretaries as an aid and a shield, they prepared and honed their action against me over the course of a month or more. They were thereafter joined by other commenters here on this thread (I number them between 5 and 9) and on Reddit (I counted 6 that are at least roughly in agreement with the complaint) over the past two weeks. Call it from 31 to 35 in favor my removal. &gt; &gt; On the other hand, with no advance notice of the action against me, a mix of current and former Voting Representatives (along with other prestigious members of the wider community) spoke up either to refute the points in the complaint or to rebuke the very act of the complaint. On this thread, the "opposed" number about 20, and on Reddit they number roughly 15, for a total of around 35 opposed to my removal. &gt; &gt; If you take those numbers as even a remotely representative sample, they show that the community is thoroughly divided regarding the complaint. About half feel it is well-founded, and the other half for various reasons feel it is not. &gt; &gt; ... &gt; &gt; [S]ince not everyone here agrees that my speech was objectionable, perhaps you can say specifically (in reference to the many points you raised) what you would have *liked* me to have said instead of what I *actually* said. That would probably be the best indicator of your desires. &gt; &gt; ... &gt; &gt; I infer from [Larry Garfield talking about how the FIG cannot ban Voting Representatives] that the complainants' intent is to (1) strip me of my status as a Voting Representative, then (2) attempt to ban me from the mailing list as a non-Voting Representative. &gt; &gt; ... &gt; &gt; If "we're not the problem, you are" and "you should only talk the way we want you to talk, on the subjects we'll let you talk about" are the best responses the complainants can muster, then we are at an impasse. I do suggest you read all of the responses for a fuller understanding, though.
Ahh ... my apologies then. And yea, I didn't realize that people would react to the title and not the video. My bad.
No apologies needed. I really should've clarified it. My mistake.
Thank you, I find people use the two interchangeably much too frequently and don't necessarily distinguish between the them. Then comments, like the one you responded to, makes people feel they've been to a corner just because a decision was made not to use an actual framework.
It's [the Iron Law of Bureaucracy](http://www.jerrypournelle.com/reports/jerryp/iron.html) at work. In full: &gt; Pournelle's Iron Law of Bureaucracy states that in any bureaucratic organization there will be two kinds of people: &gt; &gt; First, there will be those who are devoted to the goals of the organization. Examples are dedicated classroom teachers in an educational bureaucracy, many of the engineers and launch technicians and scientists at NASA, even some agricultural scientists and advisors in the former Soviet Union collective farming administration. &gt; &gt; Secondly, there will be those dedicated to the organization itself. Examples are many of the administrators in the education system, many professors of education, many teachers union officials, much of the NASA headquarters staff, etc. &gt; &gt; The Iron Law states that in every case the second group will gain and keep control of the organization. It will write the rules, and control promotions within the organization. 
Again, there are two answers if you should use a framework at all. If your application is planned for a 5 year life cycle you immediately degrade it's future with a framework built for today. Your answer would have been better stated as "The answer is almost always yes for my purposes". 
&gt; literally has a talk about resolving conflicts "Literally" it is a talk about codes-of-conduct, specifically the Contributor Covenant, and how to resist their introduction into online-only organizations. It is "literally" *not* about general conflict resolution.
Like I said, the man had a point.
Other than academic ("decoupling is good") - what other reasons do you like to develop this way? 
An accurate summary.
Symfony, Zend, Laravel, etc all have nice qualities. However they add the overhead that is addressed in the video. That is all. 
To be fair, what he says frameworks should do is actually quite easily achievable in most modern PHP frameworks.
Coding things yourself is a bad idea? Sure, we can use someone else's framework, and then grow dependent on it; or we can pull specific components from various sources, include them in our own micro framework, scrap parts we don't need, and optimize parts that we keep. In this way we see the most benefits. I've built my own micro framework, and then use composer to load specific components to solve targeted problems within my framework, creating interfaces between my application and those components. I eventually start replacing, extending, and optimizing those components so that they suit my application better. It's quick, it's easy, and I have more control. It's like the arch linux of PHP. And any PHP developer should be able to do this with ease and excitement. I'm not saying this will benefit all situations; there's definitely a separate corporate culture that says we need to use a general purpose framework and try to make the best of that. Optimizing a general purpose framework is a hell of a lot more complicated, time consuming, and wasteful than building your own application, though in a corporate environment it is advantageous to have an unoptimized application up front, so I can understand why it's done.
What's interesting here is that, at least currently, the split appears very close to 50/50. That is, Group A (roughly half) say "X is a problem!" while Group B (also roughly half) say "X is not a problem!". (This is simplified, but you get the point.) Using your reasoning, then, it is just as valid to say that Group A is itself a problem as it would be that X is a problem, since Group B think X is not a problem. Having said that, the vote will reveal whether or not the apparent 50/50 split is accurate.
Huh? You realise a framework is just a bunch of components bolted together? And you realise large frameworks like Symfony and Laravel have a whole bunch of people working towards the same goal? That goal isn't "make this framework irrelevant 5 years from now". Give me one example where you shouldn't use a framework...
*looks in the source directory and sees more than 10 folders* Light weight? ha. no.
Because it all just works. I can spend time getting paid, rather than mucking about. 
I'm sure it's true for 2013, but that's totally irrelevant now. This thread should just be sent to the bottom where it belongs. 
This is highly unrespectful and very childish to say the least. This says more about the members of the FIG than Paul M Jones.
Say "Wordpress/Drupal/etc developers are not real PHP developers" and no-one bats an eye; say "Framework X developers are not real PHP developers" and everybody loses their mind.
no?
Again, that is fine. If that is the assessment to use Slim or Silex then so be it. This thread is not about whether or not you should ultimately use one, you just need to verify that you need one. The idea of everyone SHOULD use one without question is idiotic and best saved for .NET programmers 
Did anyone here build an application on Laravel 3 or 4 and now want to upgrade to 5? How about Yii 1 to 2? How about Any Framework Version X to Version 2X.... Is that overhaul enjoyable? How did that go for you? Was that extra time you could have spent somewhere else or making new features? If the answers are, it didn't bother me, then enjoy ! If the answer is , yeah that was a headache, then you see the point. 
I replied to someone else specifically addressing what I've seen happen to codebase a over time - time spent on plumbing is time not spent on features. I would argue the exact opposite of your point based on what I've seen. Nobody cares about time spent on plumbing (in the sales department or on the client side). They care about deadlines and features. Time spent custom building or maintaining a framework is time not spent building features, and over time I've seen this lead to poorly maintained code over and over again. I did say "almost" because I am sure there are some legitimate reasons not to use a framework, but every project I've seen developed without one falls apart over time because of the disconnect between maintenance and new features and money.
&gt; Because coding things yourself is a bad idea? For the class of things which are included in software frameworks, yes. &gt; Sure, we can use someone else's framework, and then grow dependent on it You will always be dependent on a framework, whether it's yours or someone else's. Depending on a framework which has guaranteed interoperability, regular updates and security audits is far smarter than depending on a framework you've cobbled together yourself (assuming "yourself" here consists of a team that is smaller than ~150 developers). &gt; In this way we see the most benefits. The single most important trait for a software library is that it is easy to write code against. The second most important trait for a software library is that it is easy to bring additional people up to speed. The third most important trait is that it will not introduce unexpected bugs or security flaws into your software. Cobbling together your own framework tends to degrade the effectiveness of all three of those traits, oftentimes without the people doing the cobbling understanding that they're doing so. &gt; And any PHP programmer should be able to do this with ease. How quickly can you get four other developers up to speed working with this framework? Where do those developers turn when they encounter bugs in the interoperability of your libraries? How do you identify security issues? &gt; though in a corporate environment it is advantageous to have an unoptimized application up front. You're misunderstanding. It's not that it's advantageous to have an unoptimized application, it's that from a business perspective it's almost *never* important to optimize your software. Throwing more servers at a problem is generally *much* cheaper than throwing developer hours at it. There are exceptions to this rule, but almost no one falls into them. 
&gt; You always need a router and you always need config and you always need a DB layer Nope, not always and not for every request. I have couple of projects where I had to set apache to reroute some of the requests to specific php scripts instead of routing everything through laravel.
Yay even more fullstack frameworks! That's what we need!
We don't? why?
**oops I'm bad at reading.. just woke up lol** This is one thing I'm debating on if it's a problem or not, because no one else in the organization will be touch that configuration. 
Because we already have about a million of those. And I haven't seen anything in the framework that makes it `unique` or `more useful` than the options already available. So why should I use this instead of a framework that has been battle tested in production 1000s of times if it doesn't actually offer me anything new or interesting. Besides the movement should be to make mix and match type components so we as developers can pick and chose. If I take 1 look at the source code, this framework definitely doesn't adhere to that principal. 
Cheers. Everyone should do what gets the job done correctly. btw, i usually start off with Slim and packages and go form there. ----- Btw.. i would like to point out the irony in your statement "I've never seen a good, well documented, "frameworkless" application in the wild." -- those are actually custom applications built without frameworks themselves and you said there are 10-15 solid ones available.... just had a chuckle on that. 
Thanks for taking the time to express yourself coherently. You have a valid point for the production-proof note. But I don't understand why a framework would need to be made unique. It is more useful than most frameworks I went through because the documentation is much more approachable and in sync than that of the frameworks I've been researching for a while. Why mix and match when you can achieve the same thing with well checked and well coordinated components? Are there really structural problems with this framework? Would they really hurt my application in the long run?
I mean, you've always been a dick. Sometimes you're right too. But I have never seen you post here in this sub as anything but a "my opinion is the only one that matters" kind of person. You've literally told me personally before that because you didn't understand something it was wrong. I don't understand what any of this has to do with FIG because the purpose of FIG is very limited, but their differences with you are very in line with all the behavior of you I've observed before.
I wouldn't know. I Don't use elixir either :)
From the top result: CI and Fuel are the same, both dead. That makes only 8. That's the law of life - the old trees are to fall, the new are to grow. But just like toddlers you are guys are tramping fiercely on the new stalks. You'll end up in a desert. I imagine people were talking 20 years back: we've got Perl, why that stupid PHP? 
That's not how this works. That's not how ANY of this works. See: &gt; And I haven't seen anything in the framework that makes it unique or more useful than the options already available. 
[Woooo team JetBrains!](http://66.media.tumblr.com/79823ae374f0a9a88c54397715e9e9ef/tumblr_nkoyk6itGO1tpri36o1_1280.png)
I did Laravel 3 to 4 on one job, yes. It still runs on Laravel 4 and the application itself will probably be EOL in about a year. All is dandy. You do realise taking your own framework (because that's what it is when you stick a bunch of composer packages in a directory structure) from v1 to v2 is effectively the same thing? Building something with today's methods is the same as rolling something out today on Laravel 5 or Symfony 3.2 - nobody's forcing you to upgrade every major version. Last few things I've worked on we've just been following Symfony's LTS releases. We're on 2.8 now, and will sit there for another couple of years while keeping track of deprecation notices etc. 
I think Symfony's release schedule goes as far a 2019 - near enough anyway. 
Sort of... requests were sent in bursts of around a hundred in like a tenth of a second, but on average there wouldn't be more then a 10 or so such bursts a minute...
1) What about a framework's codebase? It's built from scratch but if not well-architected nor -maintained (because said codebase doesn't exist) then it's probably not a good idea to use it. Obvious logical trickery is obvious, but hopefully illustrates my point :) 1.5) Time spent getting choice libraries to play nicely is time that would otherwise be spent making your choice of framework behave as you need it to, so there's no gain there. Either way, you're still trying to make someone else's code do what you want it to in the hope that it requires less time and effort than it would to write the code yourself, which, I believe, is something we both agree on. 2) You did, but you then said that it would be unprofessional to answer "no". It's not the preference that I'm arguing against but the prescriptivism.
PHP. That's enough of a specialisation. 
In Php lols. No seriously. First you have to specialize in all the edge cases and weird behaviors of the language. For this, first of all, you should read the Php manual cover to cover. And commit all the important passages to the heart. Particularly the weird type juggling behavior. [In some cases](https://www.reddit.com/r/lolphp/comments/4v0d24/numbers_from_simplexml_elements_are_implicitly/), Php extensions can have their own type juggling behaviors), so you have to learn them too. Then you should read all the Php bug reports (because not every weird behaviors are included in documentation), particularly the 'wont fix' ones. You should do this for all the main php extensions and libraries. Once you have completed this, and you still want to work in Php, you have to observe /r/php and other Php communities for a while, to become familiar with the politics and the important people of the community. Trust me, you don't want to piss them off. Even after this, you want to still work in Php, you can start learning a framework, or the Composer package manager, and start writing internet facing, php web applications. And do subscribe to /r/lolphp. Because that is where new gotchas get posted. You don't want to miss one of those....
That probably depends on whether it fixes the "most of the actual functionality is in the database without version control" issues.
&gt; This community is hostile, but its hostility is childish, people tend to pick on the trifle parts, never able to appreciate the idea or at least the effort. This right here.
I refactored the code so that it's doing something like this. The content objects that use this and other keyword functionality all create a keyword object in their constructor, and anything to do with keywords is passed off to that instead. I think I'll be moving away from the use of traits in general, unless I need a boilerplate implementation of an interface.
There hasn't been any hard evidence of Paul being obstructive, only a bunch of people disagreeing with his opinions.
Nothing. Not even PHP. If it is the only language you know do leran another one. It will help you a lot. 
Presenting alternative ideas is not being a dick.
The problem is Group A because they are intolerant with other opinions that do not match with their prejudices 
Building a PDO based query and outputting from class should be simple for any php developer worth their salt. Creating a model class based on a ORM or ODM can have consequences on performance and re-usability, unless project B uses same code base. The video, by the creator of the language, says using bits and pieces is the way he prefers and not getting tied to the frameworks way of doing things or a particular version. I simply do not need their interfaces in between all the time to complete the job. I refuse to create my own packages based solely on it being used for one framework. I will use it, and it's functionality as intended without service providers or other interactions that are framework specific. The only specification should be proper PHP. Using a framework automatically slows down PHP and if you are not going to use the entire framework from top to bottom it simply is a waste of resources and speed of your app. 
&gt;He is a bigger man, a figure behind the most useful standards. That's not the same thing. I doubt there's anyone who questions Paul's technical bona fides. (They would be stupid to.) But when a significant number of your colleagues say they don't want to work with you it may be time to step aside whether their reasoning is wrong or right.
I don't understand this, you're just saying "let someone else make decisions for me." Why can't you use Doctrine, Twig, etc for those things? Why do you have to use the framework? In this day and age, namespacing, pimple, and composer make it really hard for me to go with a framework when you can achieve the same thing with packages.
In order to put properly together a set of libraries you need to waste time studying all option, learning to configure all these libraries..watching all libraries for changes and lots of other stupid tasks you would spare with a framework where people, experts, whom you trust already put them together 
To be a bit fair to folks asking for it's raison d'Ãªtre, good ideas are worthless (execution is everything) and there's no direct connection between effort and value. Plus, a little hostility is going to bounce right off of anything worthy â€” historically, the best ideas have always experienced the most hostility.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Nested database transactions? This is bad. Very bad. https://github.com/mako-framework/docs/blob/master/04_databases_sql/01_basics.md#savepoints Transactions are not just useful for improving efficiency. The entire point of a PDO transaction is that it is indivisible - it is a guarantee that the queries will succeed as a group, with expected results, or all will fail. Queries that depend on other queries being completed successfully must be placed into a transaction. This concept of nesting the transaction, so that one part succeeds and another fails, breaks atomicity completely. I don't know what problem this was intended to solve, but I can't imagine a scenario where this would be the better solution instead of creating two transactions, for example. I'm prepared to be enlightened but right now this looks awful to me.
Indeed, what you say is true. I see the mistake, thanks for pointing it out.
RESTful api design
If, in a volunteer organization, a person rubs others wrong consistently, makes them uncomfortable to work along side, this impedes the purpose of the organization. Calling them "[bureaucrats](https://www.reddit.com/r/PHP/comments/4v5gyu/phpfig_vote_to_request_a_new_aura_rep_aka_replace/d5vvgj9)" to some extent shows the disdain he has for the other members of the organization (which, I think, is understandable at this point). I don't have a pony to ride here, and to a huge extent, I don't care whether he's in or out. It just seems that for the good of the community, we should all be moving past this. Paul should step out, put another contributor for Aura in, and ... really nothing changes, as he's still on groups, mailing lists, et al.
Actually it is not that simple..I decided to use the Symfony Router with annotations for one of my projects and it is quiet a pain to change it :) I am spending right now some time to select between Aura, Zend Router or the Symfony Router. I need to consider if I will be building the project around HTTP Request Response, consider Middlewares etc. ..but the point was this is just one library. If you would like to use some mvc core, DI or IoC..now Doctrine or Propel for DB..at this point you will need to have some standardized way of wiring it together and thinking about future..what if you would like to change the db layer..now you need to define some standard interfaces and you are getting just closer to a framework..the point of a framework is: composer create project your-framework your-project and you are ready to go to deal with your business logic
This would have been a much more palatable solution but it doesn't achieve the agenda they were after.
The fairest comparison I can think of for this situation is to imagine if it were Linus Torvalds being ejected from being a kernel developer because some people thought he was a dick. The whole world suffers because someone got their panties in a bunch.
No one had a problem with Paul until the CoC was getting shoved down everyone's throat. Just sayin'
For what it's worth, I've only ever had positive interactions with pmjones. I'd believe him guilty of nothing more than being opinionated, as we all are.
The real reason is the "end game" is to ban him entirely from the list once he is no longer a voting member.
&gt; I'm not saying that general purpose frameworks are inherently bad, in general they work, but they are technically bad at solving a specific problem in the best way. You are framing development wrong. The problem most developers are trying to solve is "get this program to spec as cheaply as possible" not "get this program to spec as technically sound as possible." If the goal is to make money, and it usually is, frameworks are almost always the right choice. &gt; it removes the possibility of truly innovative ideas You have to write a CRUD app as a CRM, where's the room for innovation? You have to write a REST API that talks to Elastic Search, where's the room for innovation? Just because other people have solved these problems already doesn't mean their problems are bad. It's exceptionally arrogant to think that domain experts who have donated their time creating software are going to do a poorer job at it than you are. Innovating, r&amp;d, whatever you want to call it has a cost. When I take my car to the shop for an oil change, I don't want the mechanic experimenting on my shit and running up my bill; if I'm paying someone to develop me a standard-issue website, I sure as fuck don't want them to experiment either.
For one page you have all that? Interesting. Ya I can see WP then
Frameworks not only offer components. They also offer structure. If you glue everything together yourself, new developers in your team will have a harder time figuring things out. And also, you're the only one who knows your self-build framework, so it's always you who needs to explain everything. And yes, I let someone else make decisions for me. Why? Because the makers of Symfony or Laravel, know way more than me about software development. It would be crazy to not use that knowledge.
If your application, more specifically your business logic, is tightly coupled to a framework, you're doing it wrong.
A fair point.
Solving problems using best practices, within budget.
Why the fuck do you need dependency injection in a small command line tool?
Thanks to all who made this happen, especially andres. Love Phalcon and using it in all my projects.
If you haven't heard of Auryn, please check it out lol.
better question is why the hell is he in a php subreddit lol
A patently false statement. I had a problem (and expressed it publicly on the list ~~as well as privately~~ [can't be bothered to dig through email/Twitter to find the DM] to Paul) long before the CoC hit the group.
&gt; It's exceptionally arrogant to think that domain experts who have donated their time creating software are going to do a poorer job at it than you are. I never said this, but to your point, it's arrogant to think that people who write their own frameworks, rather than use one of the many industry standard ones, can't do it right. &gt; When I take my car to the shop for an oil change, I don't want the mechanic experimenting on my shit and running up my bill; if I'm paying someone to develop me a standard-issue website, I sure as fuck don't want them to experiment either. Your analogy is ridiculously stupid in the context of what I've been saying. PHP does not equal a job developing something for someone using PHP. Obviously, if someone is hiring you for a job and wants you to use Laravel, you fucking use Laravel. No one is arguing that at all. But this is /r/PHP; not /r/remotephp; not /r/laravel; not /r/drupal; not /r/codeigniter Not everyone is here to talk about existing frameworks, or how they can develop a site as cheaply as possible. There are more appropriate places to have those discussions. Existing frameworks are not the only way to solve a problem, because the problem isn't always doing it as quickly and cheaply as possible to make money.
As someone who has build an e-commerce website completely from scratch, without the assistance of any framework whatsoever about 4 years ago and still maintain it every single day, I'd like to share my experiences and my Dos and Don'ts that I gathered during all this time. * Before you start to even thinking about making something like this, make sure to understand all the basic OOP principles and know really well what SOLID is about. After two years from my application being in production, I almost had to rewrite the whole thing because I made that mistake and the codebase slowly started to become unmaintainable. Also, take a good look at some design patters and particularly the MVC and the front controller ones. * Now we have Composer, use it! Composer wasn't around when I first started working on this project and it wasn't until the middle of 2013 that I became aware of its existence, luckily I had very little dependencies back then so migration wasn't a huge deal. * Never, ever, ever copy paste code. I know, sometimes you are rushing to implement a new feature and copy-pasting might be tempting, but do not fall into this trap. I made that mistake too in the past and I regret every single time I did it, and no, no matter what you tell to yourself that you are going to go back later and redo it properly, I assure you, you will not. If you copy-paste code inside your project and you need to change something in the future, you will have to go on every single place where this particular piece of code appears and update it manually, it just not worth it. * Use PDO with prepared statements, unfortunately for me when I first started the `mysql_` wasn't deprecated yet and I really had no idea in what I was getting into. On late 2013 I had to migrate all the codebase to use PDO with prepared statements and it was a real pain which could've been easily prevented. * Use a template engine like Twig and enable the autoescape function (on Twig it is enabled by default). No matter how good you think you are, eventually you will make the mistake and forget to escape one string before outputting it to the browser and your whole website will be vulnerable to XSS attacks. A template engine will also help you to keep things organized and your business logic separate from the views, but the most important reason to use it security. The autoescape function of a template engine is for XSS, what prepared statements are from Database Injections. * Use Git. Don't even think about starting such a big project without using versioning, I'm guilty to say that I did and I really regret it. After starting using Git on 2013 my life completely changed. Without Git you are constantly worrying that by making a change you might make a mistake, break something and then forget what the change was and stuck with a non working version of your code. On the other hand, when using Git, you can dive in the code with no fear and if manage to mess everything up just run `git checkout .` to undo all the changes, clear you mind and try again. Of course this is just one of the many reasons why you want to use Git. * Use database migrations. From my experience I can tell you that as long as you have designed the database schema properly from the start, it will not change very often. But migrations are really the only proper way to keep track of the changes on the schema in comparison to the changes to the code. Not as essential as the versing of the code itself, but incredibly useful. Also, if later you reach a point where you decide that you want to use a deployment tool you will really want to thank you past self for taking that decision. * Be organized. Every time you need to implement a new feature or fix a huge bug break it into smaller ones and create a TODO list to keep track of your progress, so you will know at every single moment what you need to do next. This might sound obvious but I found myself many times forget about how important it really is. No matter what you may think your mental capacity is limited, you can't remember every single little detail. * Learn from the code of others. Don't be afraid to take a look at other popular PHP projects and see how others implemented certain features. Actually writing code may be the only way to gain experience and improve yourself, but by also seeing how other developers more experienced than you, did it certain things, can really help you to become a better developer. * Security, security, security. Learn as much as you can about security, this is really important and by no means optional. Learn about all the popular vulnerabilities like XSS, CSRF, Database Injections, etc and try your best to break or even hack your own application by submitting invalid input. No matter how well your code is tested using unit test, you still need to do black box testing. Remember, never trust the user input, be paranoid! Imagine that every single one of your users is an evil hacker who wants to steal your data and break your web application. * Write tests. I wish I had someone to tell me that back in 2012 when I still was relatively inexperienced. Writing tests takes time sure, but the time that is going to save you from preventing changes that break your application from be committed is 10 time more valuable. Also, very important too, don't write your code first and then try to right the unit test, do both the same time using TDD. * Use PHPMailer, I was a fool, I though I was able to do it better and that `mail` was all I needed. Well, apparently the answer was no, no matter how basic are the emails your web application is going to send initially, eventually you will need something more than that. Also, trust me when I say to you that you really don't want to maintain your own mail server and neither want to use the mail server of your hosting provider, in case you're using shared hosting. What you will need to do in order to both ensure deliverability and keep your code maintainable, is to use a mailing service like `Sendgrid` or `Mailgun` for example. It is true that most of them have a PHP client available developed by them, that you can install using composer, but do not fall into this trap! If you do it you will get locked into their own API and you won't be able to use anything else without having to migrate from one to the other. On the other hand, if you use PHPmailer and set it up to use the SMTP API that those services provide, switching from one to the other will be as simple as updating the SMTP credentials inside a configuration file. The development of the first version of the web application took me approximately four months of everyday work, at least 10 hours a day and with almost zero days off. After that four months, I've spent an extra couple of months doing excessive testing to make sure that there were no security issues and that everything was working as expected. After those 6 months the application was finally production ready but the supported features were very basic. It came online on the late August of 2012 and since then I keep adding features and fixing bugs, in fact this is my full time job. So to summarize, unless you plan to start a project that you will maintain probably even for the rest of your life, don't do it. An e-commerce website is like a living organism, it will constantly need the addition of new features based on the current needs of the business and you will have to implement them. Of course, in such a website content is the king obviously, but still, what content is without an infrastructure to support it? In the end, it was a great learning experience for me and in fact still is, but this is something I would never do again in my life, at least not without the use of a proper MVC framework like Laravel. Everything I wrote on this post, is everything I'd tell to my past self if I was able to somehow go back in time 4 years ago. I hope that you found this information helpful.
Can you at least give us a synopsis? Was it about something technical and related to PHP?
On a number of occasions, Paul brought discussions and personal fights into the mailing list. I asked him to stop. Each time I was met with patronising resistance. This has been stated in the discussion thread linked (if you'd like direct links to one or two examples). I don't really want to further discuss the linked thread, or my personal feelings on Paul though. Just wanted to point out that this has never been about Paul's feelings about a CoC, and I have no agenda for FIG getting one. I am not even a part of FIG anymore. Edit: for the sake of being constructive, I would have no problem if you changed "No one had a problem with Paul" to something like "Few had a problem with Paul". I'm not trying to repudiate the sentiment but rather the allusion that everybody is after the same thing (having a CoC and/or excluding anyone else who doesn't).
I'm curious about using it but there is no activity in the repository code-wise. Is it feature complete and bug-free? :-)
You can use those things inside a framework though. If you want to use Doctrine or Twig inside Laravel for instance, you can very easily switch those pieces out. 
Don't have dependencies or pass them as arguments
Could the fix be in? Apparently the vote closes before it even opened ;) "This vote will proceed according the Voting Protocol and will close on 11-August-2011 at 23:59 UTC. " 2011?
Fair enough. I would still say most major frameworks are maintained more reliably than the underlying roll your own plumbing of most framework projects, simply because the user and contributor base is larger. Yii or symfony or laravel or whatever is pretty much guaranteed to have a much larger user base than the entire Dev team of most Dev shops or SMBs. And the contributors are working on the framework specifically when they are working on the framework, not minimally patching something to get to billable hours. But you are right, if nobody maintains the framework, it's no good.
&gt; The answer is almost always yes. If you waste your employer's money writing config parsers, standard form validators, and routing, you don't really understand what it means to be a professional. Your comment betrays your belief that such components are only found in frameworks. Which is the tragedy with most developers that are die-hard defenders of big "full stack" frameworks. There's a bigger world out there. You'd think Composer and Packagist would've opened the eyes of more people by now.
I don't think it's fair for me to be held to views you want me to have as opposed to views I have. If I were to do the same thing to you that you just did to me, I would say the problem with intelligent young developers is that they feel only cool new things can solve problems, and they lack the understanding and appreciation for frameworks that years of experience can provide. I neither believe this to be true about you, nor do I endorse the absolute certainty of the statement. I use it only as a counters ample of the horse shit you pulled in the previous comment.
No. A framework imparts architectural constraints and decisions on top of libraries. That's the difference between a big library set (like PEAR was) and a framework.
PHP7 betas were available a year ago, and this is the first Phalcon release that's even mentioning PHP7 support, yet it's not completed yet. This should give people who rely on Phalcon a serious pause. In the company I work for, there were 3 projects that rely on Phalcon and they stalled our entire upgrade schedule, because they couldn't run on PHP7. Not to mention that the decreasing activity on the Phalcon GitHub page in the last year or so has been quite alarming. We're moving those projects away from any Phalcon dependencies currently. Phalcon is a project built by obviously intelligent and capable people, but strategically, using it is like shooting yourself in the foot. It's not worth it just to see a bit less CPU usage on your server (although ironically we see more CPU usage as we're stuck to PHP 5.6 due to Phalcon).
I wrote an app 8 years ago that is still being used today. I wish I'd used some framework. I think unless you are writing a one-off script or you are literally developing a framework you want to use a framework.
ping me if you find something useful!
Please remember that /r/PHP has strict rules on civility. Personal insults will not be tolerated. Strong criticism is encouraged, but keep it from being personal. Since this is a discussion about a particular person and their actions, the line there is a bit more blurry, but please keep things respectful. I won't have much time to moderate this thread this weekend as I have personal commitments to keep, so please help us by reporting any comments which clearly infringe upon our rules, and please refrain from reporting comments that you merely disagree with. Us mods are people with lives and loved ones. Please don't add stress for us unnecessarily.
No one within the FIG appears to have had the guts to say that outright.
&gt; What are the chances that the next contractor or new hire for your team is familiar with the specific combinations of the specific packages you chose to use? That's a nonsense question. A contractor wouldn't need to be familiar with "a specific combination" of packages, they only need to be familiar with the packages. There's nothing to learn about the "combination". Go check one popular standalone router, FastRoute by Nikita Popov. If it takes a developer more than 10 minutes to figure it out, then how is that developer expected to figure out the custom business logic and domain of the app? Also documentation is *not exclusive to frameworks*, either. Components do have documentation. What kind of an argument is that, I don't even... Does a "framework" to you mean simply any component maybe? Or are you seriously assigning common attributes like familiarity and documentation to be exclusive to frameworks somehow? All your arguments only talk about serious self-imposed tunnel vision. Do check what's out there. It's not scary.
It is very personal when a group of people try to ruin something I enjoy. Phil Sturgeon is one of the leaders of this group or at least one of the most vocal with the biggest soap box. I understand you've got to follow your rules but I'm not willing to edit my comment. Why shouldn't we call people out on bullshit? To do otherwise we're practically endorsing it. It's specific people who are doing this and everyone needs to be aware so they can guard themselves from this sort of behavior by these people in the future. I feel like this is a fitting conclusion to the FIG. They served their purpose and did great things, when they ran out of things to work on they created the CoC as a solution looking for a problem, once they oust Paul they'll have nothing left to do. If they don't have enough support to oust him this time, they won't give up. That's a direct insult.
I am not concerned with your criticisms. I am concerned with you calling them assholes and children. Find a more constructive way to word it.
Nothing I wrote accused packages of being difficult to understand or lacking in documentation. I think you are now being intentionally dense to prevent addressing anything I actually say in favor of what you would like to argue about, or you just plain lack the experience to understand what I am talking about. In either case, I can't help you unless you pay attention to what I am actually saying.
Ahhhh, yeah. I misread the code sample and didn't read their intro text. I agree, that example is bad behavior and should have been in two separate transactions.
16 years developer. 4 years team leader. I came into a team of 12 developers here, and after I got rid of the dead weight, and the random frameworks used across two dozens of failed projects (Phalcon, Silex, Slim, Symfony, Lumen... yes all of them, there was a lot of "experimental" work going on here), we're more productive than ever with just 6 devs and a minimal modular architecture that's spanning all our projects, from background cron jobs running on our internal server, internal web tools driving business processes, to our public site and dashboard for clients. No frameworks, just components. I don't see how this makes you or doesn't make you an "asshole", I see you more as a victim of prevalent mentality, where developers and team leaders give up before they've even tried and fall back to the popular options, because they're perceived as "safe". Initial familiarity with the framework is only a bonus if you have extremely high burn rate for developers, where you want to get new ones in as fast as possible, because the old ones are getting out just as fast. Developers and managers are the exact kind of employees you *don't* want a high burn rate with, it's not like replacing the cleaning lady. So solve *that* retention problem, instead of using Laravel to work around it. Having hundreds of hands try their shot at a generic codebase is not a way to build and maintain a quality project. You need people who care and they'll stay around and train other people who will also care.
Why "yawn" ?
If I wanted to be civil, I wouldn't let myself get dragged into this idiotic non-technical nonsensical PHP drama! #PHPLivesMatter
What /u/Airhead2016 is saying is that the integration surface is so wide that it's basically a whole world of maintenance on its own. That's not an opinion, that's a fact, and a problem. Whenever the Zend Engine has changes, Phalcon will have to do some integration work to sync up, and new bugs and issues will arise (it's not an "if"). This makes upgrades much slower and much more risky than just dealing with userland changes in the language. These difficulties and risks have to be compared with the benefits, and you need to be able to balance them in order to justify the usage of this particular tool chain. For /u/Airhead2016 (I assume, correct me if I'm wrong), these benefits don't manage to balance the disadvantages/risks.
Yeah, as someone who voted against this I have no issue with the timing. That being said I wish the secretaries would have listened to my input regarding the language of that amendment, and am still annoyed that my requests to clarify the secretary's power on this matter was pushed aside to deal with this Paul mess.
This may not answer your question, but Codeigniter is ancient and unmaintained, there's NO reason to use it on a new project! Reconsider..
http://security.stackexchange.com/questions/97845/how-secure-is-codeigniter-3-x http://www.codeigniter.com/user_guide/general/security.html
Sorry, I think my question was vague. I meant to ask if there is a way someone tries to hack my website and tells if there is any issue.
Nice reference. Totally true.
no u
That's objectively untrue, or everyone in the FIG would find each other toxic relatively often. It's his approach to communication that's under question, and my point is that it doesn't really matter who's right or wrong - only that neither side is taking the "high road" here for the betterment of the group.
Yes. This is good. I will definitely look into this.
&gt; That's not an opinion, that's a fact, and a problem. it's a biased hypothesis assert that any future change in the Zend Engine will cause an entire refactor in Phalcon thus introducing bugs (having bugs is normal in any early development cycle). Bear in mind, that they achieved support of ZendEngine2 and now ZendEngine3, who can assure that they will not be able to support future versions of the engine successfully? Of course, the whole idea sounds more complicated for mere mortals like us, but who says they don't have the skills to achieve wharever they want? It would be a mistake conveniently belittle them
Yeah, it's the same reason I wonder why people are using php. Don't they know they're wasting cycles when they could just use Python? /s Php has survived as a language because it saves companies a couple weeks of development time.
&gt; but who says they don't have the skills to achieve wharever they want? It would be a mistake conveniently belittle them Nobody did, what /u/ocramius was saying is that's a risk worth pondering and that you may not be willing to take for squeezing the performances. It doesn't change the fact that the work they've done and doing is incredible and they can boast of doing something in a very different way than others. 
I love having disagreements because I often learn from them. Kind of the same reason I love being wrong, because if it is determined I am wrong then again I have learned something. It seems to me, even if disruptive or often disagreeable, having a character like pmjones around would be beneficial to the organization if they wish to advance and further succeed. If the goal here is to only surround themselves with agreeable members, that will ultimately be detrimental to the significance of the group.
+0 and -1 are very different. The first is, at least in my opinion, saying that someone is uncomfortable with the vote but not enough to block it. It contributes to quorum, making sure nothing is prevented from passing due to passive members, while not actually saying "yes" or actively fighting it with a "no". This was not the only reason either. I think that if kicking someone out literally comes down to a single vote then there was a failure of the group to build a real case for expulsion. Therefore allowing a single vote in the yes column at the start of the process should be mostly meaningless. 
tl;dr
The problem with general purpose frameworks is that they all eventually crystallize into their own version of a swiss-army knife with some tools that work better than others, and every framework has areas in which they specialize while being less useful in others. It's non-trivial to mix-and-match components that are not core to the framework and necessarily this means you don't get the support and "many-eyes" benefit that integrated components do. Sometimes the framework makes assumptions that are simply anathema to your use case. If you can't find the "goldilocks" perfect framework, you are left to simply implement a collection of libraries that best fit your use case and essentially build one of your own. And that's perfectly fine, there's not a decent PHP programmer out there that shouldn't be able to be productive in a typical thin-layer routing/DB/view library framework that glues together a lot of specialized components. It's easier to introduce a Laravel developer to a thin framework like this than try and shoehorn them into a Symfony workflow, and vice versa. An added benefit is that developers who don't get as much "magic" out of their framework can more readily follow the execution flow and understand how the "magic" in other systems is beneficial but also what it is abstracting that very likely you previously did not understand how to do natively (ORMs being a common issue here, as too many devs have no idea how to utilize PDO or the native *sql_etc drivers.)
Also a valid point.. I subscribe to the best script to provide the best performance for the best solution. There is no "default answer" out of the box. BTW a random benchmark I noticed in recently "Perl has the same trend as Python and is steadily 22x slower than C++. PHP 5.x is the slowest with results between 47x to 60x behind C++. PHP 7 made the big surprise. It is about 10x faster than PHP 5.x, and about 3x faster than Python which is the next fastest script language."
ohhhhmg, that wall.. https://media3.giphy.com/media/5AVgmIw7iAzdK/200.gif
The configuration management initiative was one of the most successful pushes for Drupal 8. As someone working on production Drupal 8 websites on a team of people all site building with configuration managed in version control, it's stable and covers all configuration you could create from the UI. Don't know what's unfinished or buggy about it?
&gt; Since this is a discussion about a particular person and their actions, the line there is a bit more blurry, but please keep things respectful. When in doubt, sometimes the best comment to make is no comment at all.
Are you on drugs or are you just terrible at metaphors? This makes zero sense.
&gt; easily Yeh its true.... its because of his contribution and game play - we got such a interesting language. PHP was not streamlined like other languages but then also it became a KEY PLAYER in the market and dominate the web market better than the language developed for actual purpose like PYTHON, RUBY... etc etc Thanks to FACEBOOK, for whom more people came to know about PHP even during 2004 ... also it was great.
And yes they are really easy to go trough. It's a great update and thank you sponsors as well :) 
you don't see a difference between disagreeing and being disagreeable? I uhmm.. disagree :) Seriously though, constructive criticism is not under attack here.
Benchmarks are hard to go by. It's certainly faster than 5.x, and does appear to be faster than cpython. In this case we're comparing a hammer to a wrench though. Zend's testimonial to their speed is doing mandelbrot against cpython, not any of the far superior interpreters for numeric analysis. I'd like to see 7.x against numpy, cython, or pypy instead. I do think PHP is a far superior language for web development but the claims made to it's speed don't seem accurate, especially for web. - [kinsta](https://kinsta.com/blog/the-definitive-php-7-final-version-hhvm- benchmark/) : between 2-4 times faster - [Symfony](https://www.symfony.fi/entry/symfony-benchmarks-php-56-hhvm-and-php-7) : about two times faster - [Random benchmark repo](https://github.com/martin-helmich/php7-benchmarks) : less than two times faster 
I post this only to motivate other people to build new frameworks in PHP. Simply put a language where people only use the frameworks which are established is a dead language because no innovation can happen.
People creating their own new frameworks is a problem in php. Why? Because people in php community does not know good shit from bad. So they might end up using your broken framework, for production use. Now, why do people in Php community does not know good shit from bad? Because if they are smart enough to know good shit from bad, they wouldn't be using Php in the first place! Or in otherwords, people who still choose to work in php, *does not know or care about using the good stuff.*. Hence proved that it is dangerous for people in the php community to build their own frameworks. People in the community has even acknowledged that it is not only dangerous to re-invent the whole wheel, but they cannot even be trusted with building a wheel from rim and a set of spocks. (using composer to wireup the components). So, as I told before people who still choose to work in php, *does not know or care about using the good stuff.*. Oh, actually, they do care, but their caring ends at finding a bunch of guys that agree with them and stroking off each others ego. So if I am using opencart, and I can find 50 guys who use opencart, and will vouch for it (You know, Opencart is fine, I have been using it for two years, blah blah blah) then that is all I care, and the rest of the world can fuck off. And this is exactly why you guys still use Php. and *this* is the problem. And that problem is the price for building a community around a shit-for-brains language.
Haha, I love it when organisations like this make Documentation typos. http://i.imgur.com/wipSge1.png
Looks like a folk of laravel IMO
Everything is possible with php, of course ;-) I haven't tested it, but found this after a quick google search: https://github.com/skiplagged/pokemongo-php
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
That one is simply an api for an existing service which maps user submitted pokemon spawns. Not really useful unless you just want to create a wrapper around that or something, since it doesn't talk to any official API. **edit:** Sure it does use the official API, but only for fetching the player profile.
Yes, obviously you can look at any of the other languages to get a better PHP implementation. Only thing though is that the API probably doesn't do much. Haven't looked into finding out what's available there but wouldnt be surprised if you really can't do much of anything ;)
best Flippa Clone Script to start own flippa like website with website ,domain, apps auction buy sell marketplace http://fliponic.com
In my opinion it does not make sense to specialize in only one specific topic as a "regular" php developer. If you want to be a consultant that is a different case. When working for a company as a php developer it usually doesn't make sense to be the security specialist but to have no idea how e.g. unit testing works. It also doesn't make sense to e.g. be able to build great tests but not the original code you want to test. I also do not think it is cool to specialize on a specific framework and have no idea how other frameworks work (or coding without a framework to understand how the framework you are using actually works). You might want to change the company you are working for one time and will have fewer options if you do so. I as a ceo of a company mainly working with php would always prefer somebody with a wide range of knowledge (within php) than somebody highly specialized, but that of course is dependant on the size of the company you are working for (I run a rather small company)
Protip: if you want a discussion, stop ranting and make some coherent points.
Lol react is complex and unnecessary
Yeah, I was planning on having an interface contract for plugins. The Loading portion, though, That will return plugins that implement the interface correct? Couldn't I just do if ($class instanceof PluginInterface)
I thought that was going to be an interesting discussion but then I realized the "serious question" wasn't really a question, it was just a header for your rantâ€¦
&gt; I personally would prefer that people try making components without many interdependencies instead. This is exactly the vision behind [Aura](http://auraphp.com). Its library packages have no dependencies at all. (I am the project lead.)
Actually, most magic you can get in "big" frameworks such as Symfony or Zend is when they do it for performances; but most of the time the underlaying algorithms and code flows are quite straightfoward, if it wouldn't be, they wouldn't be extensible. It's actually fun when you played a lot with those "swiss-army knife", you quickly learn that they never force you to use anything, and you always bypass what's looking too magic for you and use only what you meant to use in the first place.
Congratulations! Well done.
I would be interested in seeing some benchmarks comparing some of the equivalent use cases using the almighty array.
See [this post with benchmarks](https://medium.com/p/9dda7af674cd). 
&gt;I use laravel, Talking about production sites and using laravel. Doesn't laravel change wayyy too fast for anything production? I mean their LTS is only 2 years! &gt;symfony Options: Use either - twig | PHP templating | die; I just don't get how people can accept frameworks like symfony that are dictating things like frontend templating engines!
Wondering why you got downvoted... Aura has been excellent for me.
&gt; But the whole concept, right from the start, remains a huge risk for users, for little benefit. Just going to put this in place: You can do more out of the box without third party packages with Phalcon than 99% of the other frameworks AND they usually run faster with less peak memory use in unit testing, benchmarking, and real world use. 
This is true, i tried to get into phalcon shortly before php7 released. and the docs were just. mind boggling. i didn't get exactly what a class did. Just how Phalcon's examples used it, which was not fit for what i wanted to use it for.
What you come to find out, is you can do it 10 different ways to get same result.. so their example "apps" are all built out differently. There needs to be a basic road map for some standardization and an easy step by step.. they never did that. [I found these useful to build out from](https://github.com/phalcon/mvc)
Is there any chance of this being included in PHP's standard distribution?
Or we can continue to talk about what we wish without shutting others down for using a different method. 
Somewhere everyone stopped talking about actual apps or functions they created and are more concerned about the underlying code they chose for their project which everyone is already aware of like it is something magical. 
If you are transpiling JSX or using ES6 you will probably have to use node tooling. I wouldn't want to transpile one language with another one anyway :) If you just need to compile Less/Sass there is a pure PHP task runner like gulp called [robo](http://robo.li/) that seems to do all of that. For watching for changes I really like [entr](http://entrproject.org/), which is language independent. I wrote a [little guide](https://yuloh.github.io/2016/automatically-run-unit-tests-with-entr/) on using entr to run unit tests automatically. I hadn't heard of lurker, that's pretty neat. You could use entr + sassc to compile assets and not need to depend on node or php :D
&gt; We should stop talking about frameworks and start talking about packages. Symfony is a bunch of packages ;) "Framework" is just one of it.
go back to your ruby or whatever rust or some such php is just fine, we dont need you or your attitude. The language and community continue to improve and help eachother out just like any language and community. 
im not so sure about slowest... i dunno maybe? but my heavier symfony projects get like 50ms response times in dev mode, and I havent heard a single complaint about slowness from any customer or user whos been on the receiving end of it. I cant speak for laravel but the caching system in symfony does its best to really reduce the amount of code a request swims through for each page load. It generates a single bootstrap file that has everything being used baked into it, pre-compiled for exceptionally fast execution and not loading 90,000 files every request through includes and autoloaders. Twig caches right down to raw pre-compiled php so its not even parsing the twig files each request. Those two optimisations alone make it faster than 99% of the custom frameworks ive used from peers and expunged co-workers 
&gt; so you can teach symfony about it Say if I want to use mustache. How easy/time consuming/error prone is this process ? 
How is react remotely complex Im actually curious.
I don't know where you get your figures but Phalcon is quite basic. What advanced features does it have that others don't?
Silex, Slim, Phpixie, Phalcon, Laravel, Zend, Symfony, Codeigniter, Nova, Cake, Yii...been there .. done that.. used them all one time or another. This is my point.. frameworks and "micro frameworks" .. everyone picks and chooses what they need.. the dicussion should be "you should always use one and use the ones already built cause they are mature" .... it's bad philosophy. They don't all work out and there isn't one that is the best. 
Symfony as a "full install" is slow .. slowing down PHP 100% for the sake of a "framework" is silly to me. You do not need Symfony to run packages. 
Just going to put this in place: You can do more out of the box without third party packages with Phalcon than 99% of the other frameworks AND they usually run faster with less peak memory use in unit testing, benchmarking, and real world use. 
Wait how much of the Alexa top100 ran on PHP. Yeah keep telling yourself PHP is not a "real" programming language while the rest of us just make more money.
Aah the old "slow" argument. You do realize some of the biggest high traffic run on Symfony or Laravel? You know the kind of scale where speed actually matters... Have fun with your &lt; 10ms blog.
I like php. WordPress will get you owned. To be fair, the current core is mostly OK, however most plugins are of poor quality.
I never said you can't bypass the magic, only that the framework itself will often emphasize doing it the "Laravel way" or "Zend way" and therefore most devs will want to follow that workflow, precluding them from learning how to do it themselves (again, ORMs being a big problem in this area.)
I suppose you'd also like to tell that to c/c++ developers as well? These languages give you all the freedom you need and enough rope to hang yourself if you choose to. But php is bad because of its small learning curve.
I think it's far too new and unstable to be considered at this point. Maybe someday. :)
What's the advantage of using this over using a composer package that does the same thing?
You know I completely agree with you. PHP needs less inclusive dependencies when it comes to coding at the low level. I've even posted in this subreddit about PHP needing more modularity and less of a comprehensive toolset to build full-fledged web apps. &gt; Yeah I knew someone would disagree, but in all honesty these giant interwoven PHP machinations are cumbersome and not very extensible. I'd prefer modularity over stuff being embedded. It's the true reason why projects like Symfony branched out int laravel and Silex, which are way easier to get up and running and can be modularized. Build tools for us to build the houses, don't build the houses for us. Propel was way better before Symfony came along and stripped out a lot of great reusable features. Doctrine was a victim of the same thing before it even had a chance to be its own thing. Frameworks killed libraries toolsets. I'd rather have libraries along the lines of Java or C++ than have to hack away at a pipelined framework, this way I can break things down if the code gets too heavy or needs an refresh. I don't want to have to depend so heavily on an overly integrated system that gets easily outdated. Even Zend has sold out to the interested framework crowd. I like that it tries to preserve some standalone instances of the API but I ran into a ton of dependency headaches with it a few years back and I decided to completely remove it from my projects. I thought no it was the OAuth instance that as I kept moving up in versions it just was a project hindrance. But I'm lost on your arguments against the frameworks you mentioned. They have their place. On the other hand more developers should be building out less codependent toolsets that using the principles of OOP. If code is organized around this principle their is really no need for locking things down in a framework.
The Frameworks, all of them, are great tools. Great Items. However if I can get the same features at less overhead that is what coding should be. Slow websites ruin experience. I don't want to throw hardware at something to overcome code base. I ran from that in the 90s with classic ASP... never going to deal with it again. 
The internet is a small place for developers, I remember taking a look at your foobar repository a few months ago. The amount of documentation was pretty astounding I thought 
Haven't used symfony's di component, but pimple is a Dependency injection Container and Auryn is a Dependency Injector~~DiC (Container) and Auryn is a DI (Injector)~~ - Auryn auto wires your dependencies for you without having to actually do work unless you need to specify how it should be passed for example say you have a class: interface TestInterface { } class Test implements TestInterface { private $dependency1; private $dependency2; private $dependency3; public function( Dependency1 $d1 Dependency2 $d2 Dependency2 $d2 ) { $this-&gt;dependency1 = $d1; $this-&gt;dependency2 = $d2; $this-&gt;dependency2 = $d3; } } When you call test from Auryn it'll auto wire your dependencies and all its depedencies for you. Like so: $test = $auryn-&gt;make(Test::class); You also have the option to create aliases for classes like so which will use a class in place of the one called where ever the dependency is called upon like so: $auryn-&gt;alias(TestInterface::class, Test::class); You can also go as far as defining how a dependency is wired with the define method, or even using actual already created instances (this is where you could use a DiC alongside a DI) and pass them to the defined dependency, etc... My post doesn't really do it justice, you'll have to play with it. Edit: Updated for clarification thanks /u/williamgbuckley 
I thought it were _officially_ stable now? :-P
Good point on the Pimple being a DIC, and looking more into it, it seems the Symfony DI component is more about building that Container that can enable initialised services to be injected, but it does allow [setting up for autowiring as described here](http://symfony.com/doc/current/components/dependency_injection/autowiring.html) again ill check out Auryn, looks promising 
Although I appreciate the freedom of speech and the occasional rant over PHP, I have to say I don't really get why the mods of this sub is going to let this fly. It's obviously a troll post and it's not intended for neither debate nor educational purposes. But of course, that's just my opinion.
I tried out Falcon a few years ago, lured in by its promise of speed. However, the framework felt very barebones compared to something like CakePHP which is my go to. It even felt barebones compared to Code Igniter 2. I am wondering from Falcon developers how it stacks up to frameworks like Cake, Laravel, Symphony etc... these days.
&gt;But php is bad because of its small learning curve. No. Php is bad because it a broken piece of shit. The easyness just makes matters much worse.
You repeatedly say "has x and y and z like any other that performs better" and that is not what "larger feature set" means. It's just a long winded way of saying it's faster in general. Which in a whole range of applications is irrelevant, and in the rest you can use techniques that don't require binary extensions. Phalcon's ORM, to take an example, is rudimentary compared to something like Doctrine, heck even Cake's ORM and Eloquent. And I don't even like those. Many of Phalcon's components provide only baseline functionality, only enough so they can tick off that checkbox "yup we have this feature". I am guessing you don't have much experience with other packages other than Phalcon. 
It can do everything those frameworks can, it just is not prepackaged in a way to show that or have a unified rule set. 
That's ridiculous, never thought those worlds would collide. Were you stuck on a question? I might request another soon. 
There will be a 2.* someday. While the API is stable for now, the project itself will take some time to mature. :) 
NIH-ing everything is not a feature, especially when the result is mediocre. You are not doing Phalcon any service by adopting an "us versus them" fanboy mentality in your argument. When I sit down to write an app, I don't care who dun it. I care what I have at my disposal. You said Phalcon has more features than "99% of frameworks" and now suddenly you're saying, "never mind you can still use Doctrine". Yes, I can. What an amazing revelation. If we start listing mature alternatives to the basic facilities Phalcon provides, it turns out Phalcon has nothing going for it, except "it's faster". Faster but crippled. And "faster" is not even accurate right now, because in internal benchmarks, PHP7 implementations of basic Phalcon-like functionality beats using Phalcon on PHP5.6
Men, ioncube for examply has much bigger development team etc and they still didn't release version for php 7, you know this ?
Doesn't rhyme properly 3/10
As i remember php 8 will come in 5 years from php 7, php 9 from 10 years. Is it soon ?
While I would dispute the unorthodox and confusing use of those particular acronyms by SaltTM, I think it is quite clear in the context that the sentence you have expanded should read as: &gt; pimple is a Dependency injection Container and Auryn is a Dependency Injector Such an interpretation reveals a justifiable differentiation based on the feature-sets of the libraries in question.
I've been using and reusing my own database functions for years - I've updated them as needed. Same for other things. Don't get into coding if the very first thing you want to do is cut corners that don't need to be cut. There's a reason we have so many millennials who think CSS is "coding" and that it's somehow a badge of honor for a "project" to rely on as many stupidly named 'frameworks' as possible. "I'm full stack brah, full stack!"
Yeah I wasn't trying to confuse anyone or discourage the use of Pimple or other DiC's, was more trying to highlight the fact that one auto wires dependencies for you whilst the other requires _some_ manual setup to do the same thing. Updated my post.
How's the performance compare utilizing the polyfill as opposed to more traditional approaches? I'm thinking about for libraries/frameworks where some of their users are inevitably not going to have access to install extensions, does it actually damage performance for those users?
That's not what he's saying. He's saying you can use symfony packages without the whole framework.
Every six weeks /s. The point is that the work is done now and this situation won't be repeating like this. Its a one time deal that also just happened to strike right when Zephir was getting started.
I agree with him you can use the packages as needed. I was stating the Full Install of a Project with All the Bells and Whistles has a big footprint. 
I don't get your point. &gt; Symfony as a "full install" is slow Just don't use symfony/forms ;) I don't use it and everything just cool. I never expirience "performance problems" since... 10ms or 30ms is just irrelevant to my tasks. &gt; You do not need Symfony to run packages. You need composer. Which is rely on symfony/yaml...
This actually seems like a really, really cool and useful addition. I like it! I mean, obviously lazy-loaded variables can be achieved in a number of ways, but implementing this directly into the language does make sense.
Its a cool feature, and I wonder though, is it possible for lazy statement to automatically import function/method local variables so we dont have to write use($a, $b, $c, ...) like we are forced to do in PHP anonymous function? So instead of writing this: $var = lazy use ($x) { return $x; } We can simply write: $var = lazy{ return $x; } The use statement is by far the biggest flaw in PHP anonymous function/closure design, and if lazy statement removes such redundancy it will be the very first step for us to stop this nonsense. 
Depends what you want out of your development career. The ones op posted never heard of someone specializing in. Any case, specializing to narrow will lock you into working for a large team/company and dealing with coding your specialty into existing code or intergrading into a project. Where specializing in say a framework opens you up for a larger scope. I did a lot of research after trying out c# (did not like the job opportunities) and personally decided on php w/Laravel and symphony. One I liked the less strict nature of php. Two Laravel spoke to me, I really enjoy it and the community. Third of course money. Fourth high demand for developers in the area I wanted to live. Basic php and Wordpress devs are a dime for a dozen. No money and competitive job market. Start getting into specializing in other frameworks like Yii and Zend has decent money but job market is lacking. Laravel and symphony fell right in the middle of both worlds. Good money and good job market for now. I'm not a huge fan personally of working on a large team, so being a bit more rounded was what I was shooting for. Amazing the rÃ©sumÃ©s and portfolios I see. Devs claim to be experts at php, Wordpress, Zend, JavaScript, jquery, CSS and HTML 5. Along with angular, ember and c++. Bull crap. 
&gt; Ds\PriorityQueue have first in, first out ordering preserved for values with the same priority You're the best. Seriously. I once complained about the [SplPriorityQueue's lack of sane ordering](https://www.reddit.com/r/lolphp/comments/4lavbw/splpriorityqueue_does_not_behave_like_a_queue/) in lolphp with commenters even defending the undesired behavior. The polyfill approach is brilliant and I hope it gets to be part of core in the future. 
WOW, this looks great. Can't wait to kick the tires.
This is great!
If you need to add more keywords and additional syntax into language to do something like this than this language should not be considered as "expressive". Also all this can be achieved without any additional keywords using [proxy generator](https://github.com/Ocramius/ProxyManager#proxy-example). Just wrap it into function and everything would be like: $user = lazy(User::class, function () { return User::find(session('user.id')); }); p.s. this is example of procedural PHP... no any sign of OO. Just global state, side effects and stuff. I thing this should not be considered as "good" example of how to do stuff.. this encourages bad, highly coupled design. 
This is fantastic. Congratulations! I remember your original post, and I was actually thinking about your project the other day when I was going over data structure implementations in PHP. I haven't gotten the chance to use it yet, but I'm glad to know it's made it into the PECL.
Interesting feature, but given how much I worked with introducing laziness in the language, I'd need a very precise list of what may cause lazy execution and what not. I'm mostly thinking of a specification similar to Scala's `val` vs `var`
I have considered making Immutable versions, might make it into later versions if there is enough demand for it. While they do allow other optimisations, the need to constantly create copies has a cost (if I understand correctly). 
How do they compare performance wise? I haven't benchmarked against Hack yet, but I suspect the Hack collections would perform significantly better ~~due to the fact that they can make use of generics internally. For example, an HH\\Set&lt;int&gt; would only need to allocate and handle integers and not concern itself with dynamic types. PHP doesn't have generics (yet, hopefully) which means that we can't compete with Hack's Collection types~~. **Edit**: Assumed Hack generics were used at runtime, pointed out by u/nikic that they aren't.
Will definitely spend some time adding more examples, you're welcome to come up with some as well to contribute. 
I don't like it. There are templating engines that handle this, and handle it better. No need to add this ball of yarn to PHP.
Its very good work, congratulations. And I wonder, how does this compare with SPL's data structure. I know both are coded in C, and SPL's data structures are included in PHP by default. What are the advantages and disadvantages of using this data structure extension over PHP's SPL data structure? 
This is what I feared, and to an even worse extent in some cases. :/ I could see these being a tremendous boon to some heavier frameworks, but I suspect the cost of performance to users who don't/can't install the extension will generally be a dealbreaker. Still love this and hope to see some clever ways to utilize them to great effect. Thanks for the benchmarks. ðŸ‘
I've covered most of the differences in [this blog post](https://medium.com/p/9dda7af674cd). In general, they are better than the SPL structures in every way.
Great start would be on stacks overflow new documentation section.
Wow all votes so far are on the "No" front. Can anyone kindly shed a light why everyone is with that? It doesn't break backwards compatibility, and provides security by default. You are not limited to a single htmlspecialchars() function, and it provides a way to override them as well. The only problems I can think of are: - Potential performance issues in the parser (kind of a deal breaker really). - Code looking messy with a function being called out of nowhere. - Doesn't promote a template engine by default. PHP is arguably easiest languages to get started. The applications with XSS vulnerabilities are often the ones written by those who can't afford to use a replaying engine. This RFC provides a really easy way escape stuff, and those who keep using this &lt;?= operator will now have something they can easily switch to. It will be more convincing for them to change the operator instead of using Twig. 
Congratulations, and thanks for this wonderful addition. I have yet to try these, but they look like a really performance replacement for many use cases. 
Looks great, I may use this. Have you done benchmarks against HHVM/Hack equivalents? Thanks for the extension. edit: also, what do you use to create the graphs on your previous benchmarks?
Looks pretty good!
I see you have got facts and well-researched arguments in your angry comment. /s
I (and no doubt others) really appreciated the medium post, benchmarks, robust testing and generally time-and-effort taken on this. It's just quite cool. What enabled you and others to spend time on this, or was it just that SPL was no longer fitting your needs? It's only 4 contributors to the C extension that I can see on GitHub with you very much being the primary. Did a customer or group of customers pay for this (commission something requiring)? I'm very interested in open-source projects and their impact and contribution to their creators.
Kinda similar to Kotlin's [delegated properties](https://kotlinlang.org/docs/reference/delegated-properties.html#standard-delegates). I would prefer taking some inspiration from that.
&gt;PHP is the only language that requires this nonsense. Technically, C++ also requires you to specify a lambda capture list, though you can use `[=]` / `[&amp;]` to auto-capture everything that's used (by value or by reference). But they clearly still felt that giving people the manual option was worth it.
There's no point of using house made generic framework. Even if, as put in the item B above the company needed something simpler. There is just one cause in which making a custom framework is valid: business/niche specific frameworks. And in the process of assessing such a need, it goes everything - and oft remembered security is just one of the weighing factors. There are a dozen of business/niche specific needs that general frameworks don't cater for. Just naming a few: functional mathematical framework (for translating spreadsheets into PHP code, while keeping the same numerical precision), memory constant frameworks (for memory predictable applications - frameworks are almost memory cost-free and constant through the request life cycle) or even paradigm specific framework (I actually saw, in a freelance, a functional programming specific house made framework). The rule of thumb is: you don't need to create another framework, except for one specific case. That if you knew what the specific case is, you wouldn't be asking such question anyway. (not OP, but an hypothetical person)
Nope it's the best parts. Just because you and a few others dislike it this way, doesn't mean it's a bad feature.
This can introduce some nice errors in your code. A lazy variable could be dependent on other data that isn't the same at every point in time. So if your code needs to access the variable sometimes earlier and sometimes later and you expect it to be the same, you could have a surprise. 
It's more magic. Which I don't consider a good thing. In particular it makes reasoning about programs be ludicrously difficult*. This code has a circular dependency: class Foo { public $a, $b; public __construct() { $this-&gt;a = lazy { return 1 + $this-&gt;b; } $this-&gt;b = lazy { return 1 + $this-&gt;a; } } } $foo = new Foo; echo $foo-&gt;a; The last line of code will crash at runtime as the values can't be resolved. Having reading a variable cause a crash is very high on the [astonishment factor](https://en.wikipedia.org/wiki/Principle_of_least_astonishment), and so is 'probably' a bad thing. The circular dependency is reasonably obvious in that example, but in real world scenarios where you've got a large application, tracing dependencies around is really not easy. And yes, the same circular dependency is a problem when you're using functions: class Foo { private $a, $b; function getA() { return 1 + $this-&gt;getB(); } function getB() { return 1 + $this-&gt;getA(); } } $foo = new Foo; echo $foo-&gt;getA(); But to me, when some functions have a circular dependency is not too astonishing, and easy to think about. Having reading the value of a variable have a circular dependency would make me give up programming to become a farmer. * which is one of the reasons why I almost always avoid using __get(). 
Xdebug already triggers the magic __debugInfo() function, which is very irritating as it can lead to code being executed long before you think it should. I wasted an hour discovering that once....
[removed]
Will do! Thanks :)
Whatever happened to xml, anyway? Xhtml failed. And then json just took over seemingly overnight. 
This is an actual piece of XML I had to deal with this week, heavily redacted: &lt;xml&gt; &lt;json&gt; &lt;![CDATA[ statusObj = [['Check "Redacted" (&lt;span class="RedactedClassName"&gt;Location Redacted&lt;/span&gt;&amp;nbsp; &lt;span class="RedactedClassName"&gt;Location Redacted&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;(RedactedData)&lt;/span&gt;)', 'RedactedClassName','Find It'],['Available at &lt;span class="RedactedClassName"&gt;Location Redacted&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;Location (LOCATION)&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;(RedactedData)&lt;/span&gt;', 'RedactedClassName','Find It'], [' ','RedactedClassName','Find It'], [' ','RedactedClassName','Find It'], [' ','RedactedClassName','Find It'], ['Available at &lt;span class="RedactedClassName"&gt;Location Redacted&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;Offsite Collection&lt;/span&gt; &amp;nbsp;&lt;span class="RedactedClassName"&gt; (@439404 )&lt;/span&gt;','RedactedClassName','Find It'], ['Available at &lt;span class="RedactedClassName"&gt;Location Redacted&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;Location (LOCATION)&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;(RedactedData)&lt;/span&gt;', 'RedactedClassName','Find It'], ['Available at &lt;span class="RedactedClassName"&gt;Location Redacted&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;Location (LOCATION)&lt;/span&gt; &amp;nbsp; &lt;span class="RedactedClassName"&gt;(RedactedData)&lt;/span&gt;', 'RedactedClassName','Find It'],[' ','RedactedClassName','Find It'], [' ','RedactedClassName','Find It']] ]]&gt; &lt;/json&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;html&gt; &lt;/html&gt; &lt;/xml&gt; 1. Root element called `xml`: âœ“ 2. 10 empty elements called `html` (whitespace is meaningful!): âœ“ 3. Element called `json` that contains something that isn't JSON: âœ“ 4. Massive section of XML/HTML/whatever melange wrapped in an unneccessary `&lt;! CDATA [[]]&gt;`: âœ“ Also, no doctype declaration just to screw with the toolset.
There's still a *lot* of XML flying around the information superhighway, but it's becoming less visible on the Web. XHTML died because XML is too strict. It was not a good choice for writing standard "tag soup" HTML. HTML (in the form of `.html` files or templates) is often written by handFolks are going to write stuff like: &lt;ul&gt; &lt;li&gt;Milk &lt;li class=expensive&gt;Coffee&lt;/li&gt; &lt;li&gt;Donuts&lt;/li&gt; &lt;/ul&gt; XML doesn't allow that sort of thing. XML was also a bad choice for a transport between Web servers and browsers. It's too verbose, and the benefits you get from the XML ecosystemâ€“validation, namespacesâ€“aren't that useful in AJAX. Honestly, most XML is probably a bad idea. XML is a great markup language for encoding human-written documents, but it isn't the best at encoding arbitrary data.
I can't wait to see how broken this is with empty() and isset() 
You're arguing in my favor here. Putting an entire framework in an extension is a liability. 
Some people use the accusations "racist, sexist" (and others) really liberally nowadays, and it's become meaningless. Also what kind of a weasel accusation is this? &gt; *I'm not saying* that PMJ is either of those things *but* several of his posts made me very uncomfortable
There wasn't a customer, group, or technical requirement involved. I just really love product design. This project started as a combination of a love for data structures, a desire to learn C, and to give back to the PHP community.
Looks awesome! I'm confident of a future where using these structures will be the norm in PHP applications. Quick question: The fast C extension requires PHP 7, yes? It wasn't immediately clear in the docs. And the polyfill (which is slow) can work on PHP 5 as well as 7?
Knee-jerk reactions from skimming on phone: * As a language grows it's important to manage complexity by pushing it to libraries when possible. * We need to minimize and remove the "global-ness" of functions like `set_error_handler()`. * A lot of escaping depends not only on the immediate output context (e.g. "html attribute") but also on what the source string or object already is.
Most (all?) projects I worked on involved interaction with php cli commands and/or cron tasks. What's your workflow in that case? I did not find a viable solution and fell back to installing nginx/php locally and containerizing other apps/services. Another question, how to xdebug from inside the container without hardcoding remote host IP addr? [edit] whats your opinion on mysql/mysql-server from Oracle vs _/mysql from library?
Congrats!!! Great addition to PHP!
XML did serve a purpose I think. It helped educate developers that proprietary encoding and transports weren't going to cut it anymore, and to adopt *some* form of standard. I agree though, in general XML was never that suitable other than as a stepping stone. Too verbose, too cumbersome to work with, and I'm glad JSON stole its crown. 
&gt; var_dump(4, 0b100, 4 &lt;&lt; 2 + 1, 4 &lt;&lt; 3, 0b100000); int(4) int(4) int(32) int(32) int(32) Basically, 4 is 100 in binary. `&lt;&lt;` operator appends zeroes to the binary number: 100 + (000). The resulting binary number in 100000 which is 32 in decimal.
a) you should look up the definition of irony. b) I think you misunderstood me - apps built without frameworks; generally terrible, unless built by a large team (20 or more) and well documented. Apps built around frameworks; generally more manageable if the original architect stuck to that particular frameworks patterns and best practices. 
&gt; Even if this person has done a lot more work than the rest? &gt; *citation-required* In all seriousness, the last spec that Paul contributed significantly to was PSR-2 (4 years ago). He also had significant contributions to early drafts to PSR-4 (2.5 years ago). In the past 2.5 years, the majority of the contribution has been around the politics this very thread is complaining about (Paul was a primary author in many of the bylaws processes, as well as a voice that constantly makes the FIG have to argue process (remember the vote to expel Dracony? Failed because Paul put process over everything else). &gt; Is it really him impeding their "work" if they do little more than bicker about petty politics like in this case? This is the ultimate irony, because Paul himself is the prime source of *petty politic bickering* in the group. The picture painted by this overall thread (all the comments on this topic) and the reality of the organization are in stark contrast...
&gt; He is a bigger man, a figure behind the most useful standards. And which "useful standards" might those be? That he has had non-trivial technical contributions towards the ratified standard? The answer might surprise you...
We just wish there was a better way to do math than MathML + MathJax.
Thanks for breaking that down to me almost ELI5. It was super helpful!!!
You don't. Cast them when you need them as integers.
No you don't. You get them as strings and whatever ORM you're using is casting them for you.
Yes I do. I get integers as integers and strings as strings in MySQL. https://jpauli.github.io/2014/07/21/php-and-mysql-communication-mysqlnd.html And I don't use ORMs.
I understood perfectly without you being so anal about it. What wasn't, and still isn't clear, is that one is an interface and one is an implementation just by reading the documentation.
Not op. Have not read article. We do install PHP locally at my company, so we can run cli tasks such as phpunit. Docker just runs nginx/MySQL/redis/etc. We mount the code from a local folder so we can make quick changes. And we launch docker using a script which grabs the local IP, binds it to the container, etc...
Looks the same.
You don't have to explicit call it.
Then you're using some lightly supported feature that isn't supported in PDO. My recommendation is that unless you honest-to-god cannot know what types you're possibly expecting at any moment (and I can only think of a single case where that would actually be the case), just cast the value. You'll spend more time trying to get the DBAL cooperate with you than you'll gain by trying to be clever.
Tasks on the cli can be invoked using `docker exec`, and it is possible to run cron in a container as well. When I've had to do this, I created an image based on my php image and simply ran cron as the command. Just need to link it to the volumes or ports it needs. 
&gt;The fact is Phalcon has more built in features (not interfaces to outside packages) then other frameworks. Have yet to see the so much different features. But maybe I didn't dig in enough. &gt;Performance gain aside, which isn't squeezing, it is literally 100 to 1 at times. Personally my speed problems are not coming from PHP, so makes no difference... If processing time is critical, I would not use PHP in the first place but switch to something like C++, and hopefully this is extremely rare. &gt; Anyway guys, I build mostly API modules .. so the full stack of Symfony, Laravel, Zend is too slow for response time.. Lumen is much better. Slim 2.6 out performs Slim 3 ... etc etc... it is all a matter of some of need and want the speed. Not sure what you mean, an good Symfony is not slower than Slim 3 or Lumen. You can get an nice API hit millions of times a day with a response time &lt;50ms with a good archi, Symfony, Lumen, Falcon or whatever. 
JetBrains has a confluence article on getting xdebug configured with docker. You could also just connect to vim within the container. Another way is to make sure port 9000 ( or alternate port if you want to specify) is externalized in your docker run command ( or docker-compose file) and then you can just specify localhost.
I think this has also to do with long running process stability which php's garbage collector is not as good yet. 
There is a way to run cron with php cli commands automatically upon spooling up a docker container. I had to do some strange things, because I also needed to pass in environment variables, but it is possible and it works. That said, it's the stuff of nightmares, and if you or anyone else is interested, I can write up how to do it sometime in the next few days.
Check out the custom functions section of the article. Looks like he's written a custom CLI command to stand up a container and run the give. PHP command. 
A large part of our workflow involves PHP generating and/or modifying IDML templates. XML works really great in this context. This is music publishing, btw.
A collection of packages is all a framework is these days. So making your own is making your own framework. Your own custom framework that no one else is using, and you get to find the edge cases, weak points, security holes, lack of documentation, lack of domain knowledge for new hires, etc. Have fun.
That's actually a good point, only `abstract` in the method headers would indicate that. I'll change that, thanks for the feedback. 
I don't think adding more and more constructs to the language would do it any good. There are a huge load of lazy-loading patterns that you can use in PHP that all work really well. I think by adding another construct for that, newcomers to PHP would just be even more confused when looking at framework code. I like the feature itself, but I'm saying that because I know all the other ones well and it's not hard for me to learn and use that one new feature. When I remember what problems I had understanding `::` 10 years ago and my struggle with all those OOP keywords, I always think people learning PHP today have it way harder with all those trait, iterator and generator patterns around.
Your comparison would hit, if we'd not be proposing a basic motor when we already got high-speed inter-city trains. This feature would by no means bring in _competition_. The only thing it would add is _complexity_. Constructs, that people have to learn, that they have to understand. They have to grasp the basic concepts of escaping before they're able to understand your code, not only _alright, that one's calling some function, I've seen that already, I'll look it up later_. Template engines _do_ handle output escaping far better and the mechanisms are bound to the template engines itself, not to any global mechanism. Implementing this feature would not make template-engine authors switch, since you have global behavior that could manipulate the way it works. They'd still provide their own mechanism and it will most probably be better and easier to use (if not completely automatic, e.g. Twig and Tale Jade). Just adding new, weird looking screwdrivers to your toolbox doesn't make it a good toolbox. 
By simply reading the documentation you can see there isn't a flag you can set to return the data values in the format you desire. Simply because a feature is available via the mysqli_ functions doesn't mean it's going to be similarly available with pg_. I suggest you go and read the [docs](http://php.net/manual/en/book.pgsql.php) if you haven't already. It'd probably be your best resource. Otherwise, if your database user has the appropriate permissions set, you could always retrieve the results from [pg_meta_data](http://php.net/manual/en/function.pg-meta-data.php) and cast based on the datatype of each column. Good luck, friend.
No, there is no such point. Whatever "beginning" you have heard of might relate to - HTTP headers, that indeed have to be sent "somewhere in the beginning", or, to put it a formal way, HTTP response headers must be sent before HTTP response body. In layman terms, header() and setcookie() functions have to be used strictly before any output. - Namespace declaration, that has to be the very first statement in the script - Strict types declaration that have to be the very very first statement in the script.
Basically what is being linked is saying using traits badly is easy like hard coding use of a specific implementation to your classes. Writing them more correctly is more difficult https://gist.github.com/havvg/5372832. I really like the gist linked to above as it shows some nice ideas (use traits with interfaces so the implementation can be passed in via injection). Practically I think the container complicates the whole process and the controller should have a less-generic way of receiving an implementation for it's redirection. The problem is how that would look in PHP. I'd love to see some code examples of those that are using DI with traits. I'll checkout Laravel on lunch as I feel it might
If that should ever, ever be your bottleneck I seriously admire your programming skills.
I haven't done any benchmarks against HHVM/Hack equivalents. You can configure and run the benchmarks in that blog post yourself using the [benchmarks source](https://github.com/php-ds/benchmarks), which generates the graphs as well.
&gt; I don't know PDO, PDO has less features. At least PDO can return you typed results from mysql. However, I don't know whether it's possible for PG &gt; How would I cast the value if I don't know the data type? You do. There is always a metadata related method, like mysql_fetch_field() I suppose there is something similar in pg ext as well.
From a quick glance at the source, that seems to output json. I was also wondering what did you use to convert the json into these images you post. Also, do you think polyfill would perform considerably better without the type hints? Edit: nvm, you answered the graph question. I was too quick to answer because I was looking at that and forgot to check reporter.php, sorry about this. Edit again: I saw you mention a 2.0 "for someday", will there be any breaking changes to the API/existing types, or do you see current version as pretty much final?
Docker is really cool, and there is a lot more that can be done with it than the article touches upon. However it also has a number of shortfalls that it needs to overcome before it could become a development standard. Once you go beyond the basics it lacks a number of 'quality of life' features that you would expect making it clunky to work with as you often have to hack around or just accept its quirks. It's also dog slow on OSX. Even using nfs mounts, it takes me 2+ minutes to run a test suite that takes 13 seconds on a Mac running PHP natively. It's the noticeable slowness that has prevented any adoption at all from my team beyond my own experimentation.
Can you answer my last edit too, its the most important thing for me, this is the last question I promise :p
For someone who never used docker, but is using vagrant exclusively, would you recommend to switch to docker? If so, why?
I'm a big fan of vagrant but have just to dabble in docker because it's getting a lot of attention and seems to have really leaped ahead in the past year. I was curious after reading your response: do you experience this same sluggishness with a vagrant/VirtualBox vm? Does your team have a local development environment or is everybody on their own locally/pushing to dev/staging? Am I the only one that gets a vibe of kool-aid drinking from docker evangelists? 
&gt; A collection of packages is all a framework is these days. A collection of *coupled, integrated packages*, where extensibility is provided "plug-in" style (i.e. Inversion of Control), i.e. it's easy to get started, but you're not in .control of the architecture of the app. Sure frameworks do vary about how much "frameworks" they are, versus a bunch of components, but most, especially the popular ones, are less the latter and more the former. &gt; Your own custom framework that no one else is using, and you get to find the edge cases, weak points, security holes, lack of documentation, lack of domain knowledge for new hires, etc. One factor you exclude in all this is skill. Telling to a chef "yeah, cook your own food if you dare" is not exactly a scary proposition. Also the surface of a focused framework is much smaller than you might think. Just because Symfony and Laravel take hundreds of classes and hundreds of thousands of lines of code to do something, it doesn't mean it can't be done simpler.
PHP7 provides a long list of features, which cumulatively significantly improve both developer and server performance. Singling out one feature wouldn't do justice to the overall value of the upgrade. And I wouldn't call PHP7 a "big upgrade" in terms of *risks*, because, save for Phalcon, all our apps basically run unmodified on PHP7. The BC breaks are extremely modest. Aside from raw performance, what significantly would improve the clarity, cohesiveness and compactness of our code are scalar and return typehints, anonymous classes (used extensively for adapters), the expectations RFC, and due to the nature of our work, generator delegation is opening new, more efficient and clear ways of dealing with async code (I hope we get native "async" one day). 
I doubt it'll ever be a bottleneck, but I admire u/darkhorn's desire for efficiency.
XML is still fine and maybe even preferable for formats that are not read/edited by humans. e.g. RSS, OpenDocument, ...
Sure. :) Semantic versioning ensures that the API under 1.\* is final, but a major release (ie 2.\*) would almost certainly include breaking changes to the API. I (and whoever else involved) would continue to support and improve on 1.\* even when a new major version is released, much like PHP 5 vs PHP 7.
Ruby on Rails is rapidly losing market share because its no longer 'the cool kid' because they stopped innovating, people like new shiny things and rials isn't one of them any more
This just fucking blew my mind. I've never realized. All these times I've been doing it wrong. Thanks for that clarification :)
That was not the point I was trying to make but thanks for contributing.
why php has money_format() while it is not portable (not avaiable in windows). that is not optimal ,no ?
&gt; But itâ€™s still the same structure, â€œoptimised for everything; optimised for nothingâ€ with room for improvement. That's not factual, it's unfair to the work that was done on arrays in PHP7. In PHP7 an array that represents a continuous list is internally coerced to a list-like structure (not a full hashmap). So it *is* optimized for lists, and as it's a hashmap otherwise, it is optimized to be a map... Additionally, performance advantage here is often demonstrated via specific edge cases, where arrays are not used optimally for the use case. For example, it's trivial to implement a deque as a circular buffer, and this can be done with PHP arrays, which would make get(), set(), shift(), unshift(), push(), pop() all O(1) without any C extensions. So I'd like to see how that performs compared to a C extension. I think it'd be quite comparable. Before we jump to C extensions, the algorithms should be properly implemented in PHP, so then it can be analyzed if involving C is helping significantly, or it's only the algorithm that brings most of the value (in which case we can skip the extension part).
Do anobody know why it doesn't throw any error? $bool = true; var_dump($bool['test']); $int = 1; var_dump($int['test']); Originally posted here: https://m.reddit.com/r/lolphp/comments/4uuk1o/til_you_can_read_from_null_just_like_from_regular/d5ttrn0
I've never seen this before but it's fucking awesome.
What do you think of Microsoft word document XML (.docx) and also Open Document Initiative (.odt)? Personally I love CDATA if it means I don't have to encode non UTF-8 chars in some weird construct (looking at your Microsoft).
Thanks for the tip about Robo and entr. I'll take a look through your tutorial this week and see if it fits into what I'm doing. I appreciate the reply!
We use the National Libraries of Medicine's JATS library, but that's specifically designed for academic journals. NLM also has [BITS](https://jats.nlm.nih.gov/extensions/bits/) for books but I'm not familiar with it at all.
De facto ones.
Same here. I think the title should just be "Concise: an extension of PHPUnit" or something. Looks great, though! I love the autocomplete side of things.
&gt; where I forgot to import a variable from the parent context, Don't you use an IDE? This is what I see when I use a variable that is not defined in a closure in PHP: http://i.stack.imgur.com/Tedke.png PHPStorm marks the variable as undefined. I also get that error when I run my static analysis tools over the code. Presumably you don't use those either? How do you catch errors when people rename variables in one place, but forget to change them else where?
&gt;Would you say PHP would be better if we had to import in every block statement as well, so we have explicit "dependencies"? Nope, because you're not "exporting" an if block, or if you want to do it you export it via a closure or make it accessible via a function for which the "dependencies" will be known. If every piece of code was readable, there would be no debate, but when I run in a closure of 100 LoC or more, knowing what are the parameters of this function instead of englobing the whole parent scope helps. I rarely run into this problem in PHP because closures are not used as much as in say JavaScript. But when I have this problem in JavaScript, I really miss this PHP feature, although I agree a better alternative would be to have clean code instead...
To whom is he replying to with his answer-like tweet? Or is the point just to tell people Assembly is used in PHP's source? What's the backstory of this tweet? I am severely confused.
Not sure. I don't know either. 
The main problem that we face in PHP is that any structure we build (except for link based structures) has to rely on a PHP array - we don't have anything at a lower level than that. While the work done on arrays in PHP 7 was so impressive that it inspired this extension, it simply can't compete with a Deque or a Set implemented in C. The only structure that comes close is Stack, because it's always contiguous and `array_push` and `array_pop` is already O(1). I wrote a basic Deque implementation in PHP and benchmarked it against the extension. The benchmark was set up to push one million integers. I also compared an array-based stack against the extension. Structure|Time taken :--|--: SplFixedArrayDeque|300ms ArrayDeque|260ms Deque|140ms Structure|Time taken|Memory used :--|--:|--: ArrayStack|200ms|34mb Stack|138ms|19mb --- Even if you implement the algorithms perfectly in PHP, you're still stuck with an underlaying structure that is ready to morph into a hash table at any time. The scope of its design is too big to be as good at everything as several structures each designed to do a subset of that functionality particularly well. Also, in order for Deque to implement the Sequence interface, there are some surpringly complex algorithms which would be horrendously slow in comparison if implemented in PHP. The polyfill uses an array as well as it can, but it can't compete with the C implementations of Vector and Deque for most if not all operations, especially the more complex ones like *insert*. 
&gt; # Requirements &gt; &gt; * PHP 5.2+ [Sigh](http://blog.ircmaxell.com/2014/12/on-php-version-requirements.html). 
[removed]
Where is the problem? Well then why did PHP add short array syntax when array() isnt much more typing? And why is this lazy language construct is even being proposed? Yes, its because people dont want to do extra typing when its totally unnecessary. Even Java right now is considering adding 'var' support for implicit type declaration, so you wont have to write nonsense like Map&lt;string, int&gt; map = new HashMap&lt;string, int&gt;() any longer. A good language aspires to make life easier and more convenient for programmers, not the other way around. For me, most of the time I have a method as simple as this(its a pseudo example, but it proves a point): public function calculateTotalPrice($currency = "USD"){ $totalPrice = 0; $this-&gt;cart-&gt;each(function($item) use ($totalPrice, $currency){ $totalPrice += $item-&gt;getPrice($currency); }); return $totalPrice; } As you can see, there are only two variables in this method scope, $totalPrice and $currency. One is a local variable, another is a method parameter/argument. There may be more or less, but the number of variables should be between 0-5. With the way PHP closures are designed right now, I am forced to write use statement to import these two variables. Its tedious, ugly, and error prone(especially when there are closures inside a closure), and as you see there is no problem with messy code or hidden dependency since its very clear what it is doing. If at least in method scope the variables are imported automatically, it can save me a lot headache. Maybe I can revise my proposal a bit, that function/method scope variables will be automatically imported, while non-local variables defined in procedural code will not. This way it will prevent messy code, and yet make life easier when you have clean code that doesnt suffer such problem. The issue with PHP's closure implementation is that, this behavior is mandatory and not optional, I think at least it should provide such an option. Like I said before, if you write clean OO code, keep your class and method short enough, dont use tens of arguments/parameters, you should never experience the issue of messy code. If you write messy code, its because you aint a good programmer. A language shouldnt reject a feature just because bad programmers can misuse it to write poor, insecure and slow code. Period. 
It does not matter. [It's not like PHP inserts `$this`](https://3v4l.org/rVuC1) into the static method or otherwise changes things when you call it non-statically. Granted using `$this` will change the way method resolution works (it would be similar to calling `static::assertWhatever`).
Well PHP 7 compatibility surely is an issue for Phalcon, but I believe the biggest problem with Phalcon was pointed by many people in earlier topics already. Phalcon is a C extension, it is fast but then it prevents you from getting much knowledge about the internal source code. You have to rely on Phalcon team to be actively fixing bugs and updating the framework, unless you have a dedicated team of C coders. This can make maintenance difficult, and result in unpredictable outcome in future. 
Then you get the point. Like I've said again and again, if your code is truly OO and modular, you write short methods, classes with single responsibility, parameters list with no more than 4-5 arguments, you should never experience the problems with mistakenly captured variables that should belong to another scope. Of course if you write long procedural code with global variables and variables from included files all over the place, it becomes a problem. But then as I said again, you aint supposed to write such poor code to begin with. If you write messy code, you shouldnt blame it on a language feature. Bad programmers will write messy and un-maintainable code anyway, even if you force them to be as explicit as possible. PHP introduced closures/anonymous functions for the sake of advanced and good programmers, a bad coder wont even truly understand how to use closures anyway. 
What part of [this](https://github.com/toml-lang/toml/blob/master/README.md) is really calling out for a YAML comparison? YAML and TOML aren't even really competing all that much: TOML is very configuration-focused, whereas YAML is more for interchange/serialization.
For example, Use === over == and associated edge cases and how to avoid them. To prefer named parameters over string interpolation in query strings, Warning about some functions returning 0 as a valid return value and tell them to check with === false for failure, etc etc.... And what is wrong with PHP endorsing a particular practice? Is it worse than letting people go on with outdated and dangerous practices?
There is a huge caution note in the documentation about specifically this issue: http://php.net/manual/en/language.generators.syntax.php grep iterator_to_array TL;DR you need to use preserve_keys=false.
Ok. I found the documentation about this: http://php.net/manual/en/language.generators.syntax.php#control-structures.yield.from
So long as the context for the "best practice" is framed appropriately, sure, I could get behind that. Lot's of times (I see it a lot on twitter), developers want to proclaim a golden rule that is free from context: "Always do X", "Never do Y"... even when there might be a non-majority use case where the rule doesn't fit. Using == when === exists by itself is not a bad practice. If you know the equality rules and type conversion table, you can use == to your advantage, especially in one-off scripts. SQL query parameters? In the context of a web app, sure I could say interpolation is _always_ bad. If I were writing a Symfony console/cli command that did one thing quickly, interpolation is not bad, especially if you know the source and the context of the parameter. That's my 2c ;)
Why this discussion dont exist in Java community?
Of course. You can find cases where you can justify even the worst, so called 'bad practices'. 'Bad practices', here mean those features (functions/behaviors/configurations) in the language that have a long history of being misused.
Yes. Use a framework. "but we have all these components that we can mix and match together to make everything work" Yeah, the framework developers already did that, tested, and verified that they work together: hence, use a Framework.
I agree with this, everything is becoming more and more meta. A framework can now mean nothing more than, "An assembled collection of packages, tested and verified to work well together - so you don't have to"
&gt;O rly? ya rly: [YAML is a human friendly data serialization standard for all programming languages.](http://yaml.org/) I don't care what symfony does or doesn't think about it, and I don't even really mind people using it for configs. Hell, I love salt for configuration management and it's using YAML for the base of a DSL. But I can accept those things while still understanding the goals of the YAML people are distinct from that. &gt;The readme author disagrees with you: "The YAML format is oriented towards configuration files just like TOML." Well I suppose they should refer back to the YAML people too. &gt;This: Comparison with Other Formats. Care to read? What about that makes you want to see the side-by-side comparison? If you don't know YAML such a comparison would be pretty useless, and if you do know YAML the counterparts should be pretty clear anyway.
because faster
I'm pretty sure that the proper name for that is "common errors and mistakes"
It's almost as if you need some kind of [presentation system](http://talks.php.net/) to list all of the available presentation on PHP.
"Because PHP". There is a proposal underway to fix this: http://externals.io/thread/168
They are actually usually really useful, especially when the doc is incomplete or doesn't have examples. This is for me the best feature of PHP docs. But yes some comments are bad, but I don't see the problem, they are downvoted. For me this is what is missing in other tech docs: user comments. Saved me hours or research a lot of times.
That's the great thing about twitter. Never any context.
Your Upload.php seems like it's properly uploading the photo. The problem is your server. I would be able to help you a little more if I knew how you were hosting your website, but generally speaking, this is what you have to do: 1. Create a route, /i/*, for your server to serve 2. Create the page as seen on http://i.mcgahan.yt/EzWSV, inserting the image where you want it. Most server frameworks put the parts of the URL that are RegEx in a list of parameters, so where you want to insert the image, put `'&lt;img src="/i/' . params[0] . '.png" /&gt;'` (or the equivalent in whichever language/framework you're using, and with the correct extension).
Just a note, they created the Zephir language , you can basically write in PHP style code and compile your own extensions. They have all their code available in raw format to review. 
Agreed. PHP The Right Way is pretty damn good.
It's a great article, [but I can't get past the resemblance](http://cdn.gigjets.com/wp-content/uploads/2014/07/megamind-2.jpg)
Please go to php.net and try to find how a return statement inside a 'finally' block behaves in Php...
It is often used as a marketing term. But that does not mean that such a thing does not genuinely exist.
TOML inspired me to create Jin because there was no PHP Parser at the time: https://github.com/dotink/jin -- Jin makes use of PHP's build in INI parsing and JSON decoding.
Yes. The point is to consolidate this particular kind of info that might be scattered across a million documentation pages, in a single, easily accessable, easily discoverable and even better, in-the-face type of page in php.net. Any one coming to php.net should not miss this page. That is the point. A single page of that kind in php.net will reach a lot more, targeted audience and make a lot more difference, than a 100 phptherightway type of sites scattered all over the net..
It only checks the lines you e changed. Everything else can be wrong, it doesn't care. The idea is that it makes sure you know you're committing something that goes against your groups specifications, and has to be fixed or purposefully disregarded. While it's not for everyone, I know from first hand experience that it's nice to use when you have inexperienced developers on the team.
no offense, that's cool, but you're kind of hijacking the thread.
The author(s) of that site produced a book IIRC. Not sure they'd be willing to just move it to php.net as they would lose their "brand". 
 foreach (new APCUIterator('user', '/.*/') as $entry) { echo "$entry[key]: $entry[value]\n"; }
which then contradict everything the PHP docs show as examples... The PHP.net site is atrocious at some things. Consistency and quality of examples being one of those things.
This is incorrect. All the php the the right way's content is released under the creative commons, so as long as php.net give them attribute php.net can copy and paste the entire content if they wish to do so
Your an idiot.
I had exactly the same issue with relatively small dataset (20k records, a fraction of second to process using raw PDO/arrays) but had to stick with enormous CPU and memory consuming way, because of the code reuse. So I am eager to know if there is any workaround as well. The only thing I could suggest is to turn garbage collection off . It were taking 9 seconds on my dataset processing, so I spared that time by calling `gc_disable()`. 
this looks like a cool library. you should really change the title to this post, it makes it sound like buzzfeed.
The compiler make the best it can, but sometimes is necessary to have some human intervention to help
This question is not about performing a query. It is about a query result format. 
If it is only the result of a getter that you need, I wouldn't try to make this more complicated and create a method (wherever it fits) that retrieves the value of a property. Or in the example case you could just access the array key of the result.
I think this chapter answers all your needs: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/batch-processing.html tl;dr Iterate: $iterableResult = $q-&gt;iterate(); foreach ($iterableResult as $row) Detach for GC: $em-&gt;clear(); 
Well, I suppose there is not much [manually written] behavior in my entities. It's rather built-in relations and lazy loading stuff. Objects calling objects calling objects - all just standard Doctrine objects. It is very good when you have to deal with a single blog post or even a list of 100 blog posts to be shown on a web page. But it turns nightmare when you have to export several thousand orders using PHPexcel.
&gt; barebones ?! What phalcon don't have that you need ? Acl, models, roles, forms, views, event handling, queue handling, cli, applications and many more. I already addressed this in other comments here. If you feel what Phalcon provides is adequate for your work, by all means keep using it, and keep using PHP 5.6. &gt; And not everything is always working on those persistent php applications. How very specific.
&gt; Auryn auto wires your dependencies for you without having to actually do work As a software architect, I can't understand why people don't find this terrifying.
Human optimization of multiplication? Sounds odd and unneccesary to me
This would still hydrate all objects in the result set, just not at once. So if the issue is not just RAM but also CPU...
&gt; It's rather built-in relations and lazy loading stuff. Well the solution is neither to load all eagerly, nor load all lazily, but to specify explicitly what should be loaded. Not something ORMs tend to provide. Although a true data-mapper would.
I've been experimenting with a domain model along these lines lately (with the DTO having immutability enforced), do you know of any good resources on it? The best I've found are a few articles on why the anemic domain model isn't an anti-pattern.
in that case i would suggest working in the mysql cli client and copy pasting the result sets, you'll save quite some cpu cycles, or even better, pipe it to /dev/null
Ah yes, it's Doctrine or going back to using sticks and stones for computation. There is no alternative. They named that project aptly. 
The extra composer files are just for the build process (Travis CI) for a build matrix allowing concise to be tested against different versions of PHPUnit with different versions of PHP. But updating those extra files has become a pain and unnecessary, there is a ticket to remove them here: https://github.com/elliotchance/concise/issues/302
Yes, absolutely. I know a few people that use concise just for the better CLI.
That's fair - in heidsight I can see that. No doubt there will be an article in the future with new release features that I can use a better title for... ;)
&gt; For example lets say i have a blog post class and it has the method isPublished(). I want to find out if my returned results are published, but i only have the array and not the object for performance reasons. What is the best practice for calling that method on my dataset? [array_column](http://php.net/manual/en/function.array-column.php) could be used if you just need the blog post id and isPublished bool. This would kind of create an "index" for your larger table. [array_filter](http://php.net/manual/en/function.array-filter.php) could be used to check isPublished and only return "published"/"draft" results. Both these assume isPublished is a simple boolean field in the array. If your objects have business logic tied to the isser/getter, that will be problematic. &gt; Should i create a new blog post instance in a loop and populate it with my array? I know that will be inefficient but it wont be as bad as the items that come back from doctrine. That could be one way. How is the entity populated? Reflection? Constructor field list? Constructor array map? May not be worth the hassle. Again, assuming there is no real business logic in isPublished() method. The real answer lies in what you are doing with the data. If you need the entities to edit them, well, you'll need Doctrine to manage them, or use another SQL manager (PDO).
|If a developer makes mistakes with a framework they'll do the same things without one Oh god yes.
People keep making new frameworks because everyone's use case and style are different... it's just like asking why people are writing new spaceship fiction novels... Every framework has a different style, and adding more to the landscape is good for the community.
Voting to kick Paul out of FIG at least made sense, even if it would be a poor decision. Voting for Aura to have a new representative makes _no sense_ because Paul _is_ Aura.
This would be an interesting post in r/crypto (although perhaps a little light for that subreddit), but has nothing to do with PHP, no?
JSON doesn't support statements like that, but you can cheat and run a preg_replace on the json_encode output to remove the double quotes around your position values. **edit** However, you would be better off storing the lat/long params as their own values in the object, then in javascript, iterating over the objects in the array and creating the position objects from those values.
I'm a fan of CQRS as an architectural style, which is a fancy way of saying "My query-stuff path and my do-stuff path have fundamentally different needs and I'm not going to try too hard to force everything into one load/save object definition because it *will* eventually backfire." The flip-side is that a certain amount of logic-duplication between the two halves is inevitable, so I'd either put your "is this published" logic into the actual SQL query, or else host the relevant code somewhere convenient like `Blogpost::IsPublished($sqlRow)`.
But it wouldn't be JSON after such hacking:) Better encode just coordinates and create objects on frontend in plain JS.
Totally with you on that point. I am using Yii2 for a fairly decent sized project and came across a domain specific edge case that wasn't handled out of the box (nor did I expect it to). Problem was fixed with these steps: 1. Identify the core class providing the default functionality 2. Read and understand the code 3. Extend the class &amp; overriding the method 4. Use the extended class I am fairly confident that I can work with Zephyr, but then deploying the changes across Dev -&gt; staging -&gt; production -&gt; disaster recovery and to keep up with version changes would definitely be a pain.
Valid JSON can contain only booleans, numbers, strings, null, arrays, and plain objects. If you try to convert something else to JSON (Google.maps.latLng in your case), it will be converted to one of those supported types automatically. What you want to do is to create a plain JS object out of your latLng first (eg. An object with a "lat" key and a "lng" key), and then stringify that object to JSON.
That's very cute, but some of us have apps that see more than a couple of requests a day, and do more than basic CRUD. OP came here complaining that hydration takes too much of their RAM and CPU. Would you be willing to pay their Amazon bill? I'm sure you're sending them your credit card as you're reading this, right?
I made a thing, upon request: https://www.reddit.com/r/phpsec/ Feel free to join the discussions there. Hopefully it will have a high SNR for people seeking to learn about PHP and security.
No it won't, you'll just get a syntax error as JSON doesn't support those kinds of statements. Try it: JSON.parse("new google.maps.LatLng(51.7203, -0.289706)");
That "O" in JSON stands for "object". 
&gt; but json_encode turns every value into a string. I didn't read through all of the JSON TBH, I was just addressing &gt; but json_encode turns every value into a string Which is true whether there's invalid JSON or not.
The function money_format() is only defined if the system has strfmon capabilities. For example, Windows does not, so money_format() is undefined in Windows. strfmon being - http://pubs.opengroup.org/onlinepubs/009695399/functions/strfmon.html
For the PHP CLI, I have a function on that page which allows you to call 'docker-php [script]' and have it run in the same image as the original container. If you need links to other containers, I just either alias a proper docker run command, or make a small bash script. Crons are a bit trickier. Right now I set up apps that need crons on specific hosts, and use the system cron to call docker run. 
Yeah, the same can be said to you, you wont change your mind. And btw, your comment triggered auto-reply from Reddit's grammar bot, congratulations. 
but `"new google.maps.LatLng(51.7203, -0.289706)"` isn't the json you produced ###no error: JSON.parse('[{"position":"new google.maps.LatLng(51.7203, -0.289706)","type":"info"}]');
That just produces a string for object's key, whereas the OP wanted it to execute the code represented by the string and store the result in the key. It's impossible to accomplish what the OP wanted to do using `JSON.parse()`, as far as I'm aware.
This is a pretty common issue. The right solution depends on exactly what you're trying to do. But in general, you want to avoid hydrating more than a handful of entities at once. If you're doing a long list, or some kind of reporting (basically, anything read-only with a bunch of records) the best practice is to just use SQL. Given your example of "isPublished()" and thousands of records, the solution is usually just "use SQL". The implementation of "isPublished()" is probably something like `return (bool) $this-&gt;publishedAt();`. That's pretty easy to translate into a term in your SELECT. If you're doing some kind of non-trivial mass-update, you probably want to try to use entities and services that consume them. In that case, you want to go in batches. The entity manager's identity map and unit of work get exponentially slower as it has to manage more entities. So you want iterate some small number then flush/clear and repeat. 
I'll likely be creating a Sentinel authentication walkthrough shortly-- I'll likely post that.
`eval()` to the rescue!! /s
Hold my beer!
[removed]
If you vote to request a new representative and the project cannot provide one, the project is expelled. The point here is that the complaint is against Paul, not Aura; it's not for the FIG to decide if Paul is Aura, nor fair for Aura to suffer a loss of membership if it is more than just Paul working on it when Paul is the one considered by some to be a problem, not Aura.
But the same guy then realizes why it can be useful and produces this: https://github.com/danharper/JSONx
I've had this problem once. Mysql's table collation on production server was set to something different. On localhost it was set to utf8_general_ci and that was okey. But dunno if this is your problem. 
meh, he's been brainwashed lol
`iconv("UTF8", "UTF8//IGNORE", $stuff);` Is what I am going to guess will fix your issue.
https://mathiasbynens.be/notes/mysql-utf8mb4 &gt; TL;DR MySQLâ€™s utf8 encoding is awkwardly named, as itâ€™s different from proper UTF-8 encoding. It doesnâ€™t offer full Unicode support, which can lead to data loss or security vulnerabilities.
[removed]
I don't want to be prejudiced about this, but I am. The static access betrays immature skills in software architecture. It shouldn't be the default approach to accessing data and entities. At least make the default access non-static so each instance of your ORM is independently configurable. Then if you are dead set on statics, make it a layer on top that is optional. 
Because this is a library, not a framework. 
phpsec sounds a lot like phpspec: https://packagist.org/packages/phpspec/phpspec
seriously? i dont even know how you can get mad over this. when i said rapid development, i meant forget micro optimizations, that this type of code quality, mowing down code to use less cpu cycles for batch processing, is usually not relevant if you picked php for the job. if it is, theres probably another language(level) you should be picking 
JSON is ubiquitous. there's nothing wrong with using JSON functions when working with JSON.
I actually read it as phpspec at first and had to do a double take
I'm mostly lurking on php but if this has half the drama /r/php has it'll be a godsend. keep it up.
Weird, I tried using this script before but it didn't work with my setup for some reason, but now it does. Thanks.
AFAIK won't help turn .NET into PHP, or PHP into Java
It's not a private framework, it's what gets the job done. Seems like nobody here really has worked on a large, competently managed project. The first thing you do before a single line of code is written, is establish coding conventions and documentation/code commenting policies. There is little to no justification for reliance on frameworks. If you higher a developer, you should trust them to do the job you hire them to do without you micromanaging them. Lots of ignorance being tossed around, showing how little experience these responders actually have.
You want a lot of customization but you want to work within the confines of an existing project, including its flaws, bugs and security issues? Why? You should bring on a competent developer and build your app from the ground up. The time it takes to rework an existing project to enable advanced custom functionality is often more than it would be to just create something entirely fresh. Don't worry about "reinventing the wheel" or any other cliches. Make a list of what you need, what you want it to do. Detail that list. Include stuff like order checkout flow, product display, customer interactivity, updates, etc. You don't even need to be a developer to do this, but it's an important first step. Once you write these things out in an organized manner, you can then use your list to determine whether an off-the-shelf option will do, or whether you're better off going commando. Don't forget that initial costs are not all that matters - you'll need to factor in ongoing support as well. Say magento has a major update - what happens to all of your customization? You're going to be stuck backporting them into the new version or using the old version.
I have never worked with Magento, but i know few people who use it daily. They tend to be suicidal. I use Laravel mainly and i'm pretty happy. 
XML, or how can we add super-unnecessary bloat and overhead to what should be a simple way of sharing structured data. Avoid being a bozo by not using XML for anything, ever.
The problem is, the percentage of projects/companies/agencies etc that would allow this ability are very very low.. and in anything related to agencies this also wouldn't work - because requirements by the majority of VP/Directors are stacks not be "custom" but based off a well known name because as you may also know "Why not Wordpress"... More reasons like previously bad hires also cause these issues within companies. &gt;&gt; The answer is generally no - don't use a framework. Make your own, learn how things work in the process and reuse your own works as needed. I don't know how else to read that than make your own framework (or private/internal framework)
Consider adding /r/phpsec/ to the sidebar?
There is already an existing site. This new build is replace their old system. We aren't looking at getting some sort of prototype out, we are building a full fledged site which we hope to do future development on. So what take from your advice is go with laravel spark? 
We have got all our user stories written out and there are over 200 off them for mvp. The reason we are worried about reinventing the wheel is due to time constraints. We want to spend our time wisely and on important features. The idea of using laravel Spark is to build it from the ground up. We can take the facets we need such as team authentication, invoicing etc and build upon that with high levels of customization. 
To clarify I don't.
http://i.imgur.com/jsW2ZqA.jpg
Haha I just copy/paste the title and click "Post" without reading it :D Gonna keep your meme, loving it!
[removed]
If you close your eyes and listen, Taylor almost sounds like... ray barone from everybody loves raymond.
[removed]
i mean either it should be implemented in all platforms or removed from the API.
comment are super useful.
I say this coming from 15 years exp, numerous large agencies working for fortune companies to small shops and hundreds of projects.. I'm stating the reality of production environments where this is the norm... There's the way it should be, and the way it is. You have to balance business requirements, costs, expectations and sanity. A developer doesn't take responsibility for the architectural choices made in a piece of software. A team leader, manager or technical architect takes that responsibility.. a developer is there to create the end product using the specifications laid out previously. If a developer screws up, it's the managers problem.. which is why managers have these guidelines they operate by, which is crafted through experience and past history with developers. You're also assuming every developer is good at what they do. A framework is a set of tools (or libraries), combined together seamlessly to allow you to rapidly build out said "frame". If you combine numerous libraries or functions together, you have to abide by those design ideologies laid out in those libraries.. so its a framework any way you look at it. You're now referring more closely to a CMS "entire system to provide functionality for a specific purpose". 
They changed the structure, not the design...
Upvote, just to counter the usual kindergarten hostility of /r/php
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Thanks for the reply. Going to take a look at Robo. I guess I am fed with XML when using phing.
The only thing worse than XML is XML that is used as a surrogate for program instructions
It depends ;-)
In short, you can hire a security professional to go through your code and find any problems...
I believe the point of the micro-frameworks is so that you don't have to write your own routing engine for every new project you start... stuff like Slim literally ships with nothing aside routing and dispatch... so what you write your own implementation every time? seems like a gigantic waste of time imo.
main line and backup both went down with ETA 23:55 fix. I was kinda shitting a brick, so coding something simple calmed me. Everyone else just thought I was ignoring them haha
that's the most retarded thing i have seed ever, no wonder the PHP docks are full of shit. 
Why all the downvotes?
Try [in-array() ](http://php.net/manual/en/function.in-array.php)
```if (in_array('next', $rJson['_links'])) {``` ``` // Do something``` ```}```
Hi! Please join the CakePHP Community on either slack (cakesf.herokuapp.com) or our forum (discourse.cakephp.org) for help queries and support! 
What you probably need to do is hook up an AJAX request for when the top select changes.. $('nameOfSelector').change(function(item) { .. ajax call in here, populate next selector }); Or you could make the page submit itself every time you change the selector and determine the values of the second selector based upon the first. Hope that helps
I never worked with Ajax, so i'll try your second tip... but how to make the page refresh upon change on selector?
You really should use Ajax. It's the correct method for something like this. 
Can you just give the example data for PHP and Python both? Because I'd imagine in Python `rJson['_links']` would be a string value, in which case the `in` operator will check if 'next' is a substring of the string `rJson['_links']` If `rJson['_links']` is a list it'll check if the string 'next' appears in the list. If it's a dictionary it'll check if 'next' is a defined key. Since Python lets the behaviour of the `in` operator get defined by types it the appropriate PHP check depends on the types you're working with. Are you trying to determine if a PHP object has a certain attribute defined on it? 
You will have to do that with Javascript, or only show the first selector with a submit button, then show two.. etc etc
That's up to the moderators of /r/php. :)
Probably something to do with the all caps - it's been widely associated with shouting since the days of Usenet. I do wish people wouldn't do this (but, FWIW, I've not voted). 
Just to clarify something about this, on the **PHP 5.2+** requirement the important thing is the plus symbol ( **+** ), that means that you can use any version of PHP starting on 5.2 and above. Isn't like i want you to use an insecure PHP version because i'm evil, it's about some syntax elements used on the library that requires stuff that exists only from PHP 5.2. Also, if somebody wants to use PHP 5.2 even when knowing it's an insecure version, because of [insert your crazy suicidal reason here], i won't stop them from doing it and my library will be more than happy to run on that platform. That said, thanks to sarciszewski for pointing that out so people that aren't aware of this can learn something new and useful. While i don't share all the opinions on the article i see the point. 
I don't see the point on adding a comparison between TOML and YAML on a package that's a TOML parser (i'm not the creator of TOML). It's like if i write a Linux driver for a webcam i should write a side-by-side comparison with a Windows driver for a printer. 
We use namespaces within the application so we can have shared code and just route requests based on the prefix. 
I think you should learn how to use markdown styling. I appreciate your different flavored kool aid though.
I appreciate that you are being nice despite what you really want to say. I'll agree to disagree.
Can you be a bit more specific?
np ... but I do have a point out a few flaws in your explanation. &gt; Implementing objects or a system of objects is all about coupling No. It's about reducing code reuse. Abstracting common logic into classes means interactions can be centralized. This leads to easier testing and mocking which you point out to be important in creating quality code. &gt; coupling creates problems Yes it does... which is why you should type-hint against an interface and not a concrete class. &gt; SOLID principles, using composition over inheritance, creating layers of abstraction are NOT design principles or best practices. They are simply fixes which must be implemented to any system built on an object-oriented philosophy. Again, what is touted in the industry as best practices are nothing more than fixes to a bad philosophy. You didn't offer any explanation as to why you disagree... Object Oriented Design at it's core is creating a capsule of properties. It's no different than having an array of sub-keys aside from being more stringent. And in most cases flexibility in this case is terrible for readability and maintainability. &gt; As a PHP developer not only are you expected to espouse the OO philosophy, but now we have to know and love frameworks. Yes, this fact separates Wordpress developers from actual PHP Engineers. *ducks* &gt; Why have we willingly given up the ability to easily see the flow of code to instead hide it in the depths of configuration files? Because we do not need to know how things happen in a system. However should you wish to learn the underpinnings of your framework you can always read the source code. It's just not possible to generate readable code w/o using classes... Here's a fun little thing to try. Please do tell me how you can implement say a router/dispatcher without an object. Is it readable at the end of it? Or is it nothing more than a bunch of if statements... what about handling 404s, do you just let the web-server deal with it? ... etc 
You are too nice yourself, I don't like people being nice with me when I'm nice with them, it's too much nice-ception.
To be fair to OP, this is the title of the article (in caps) because they're not using text-transform to uppercase it like they should.
with Symfony we are using something like this; # parameters.yml api_versions: '(v1|v1.1|v2)' # available versions api_version: 'v2' # current version # routing.yml posts: path: /{api_version}/posts requirements: api_version: "%api_versions%" defaults: _controller: AppBundle:Post:index api_version: "%api_version%" rules: "version == 1.1": AppBundle:Post:indexV11 "version &lt; 1.1": AppBundle:Post:indexV1 # KernelRequestListener.php // this code works on kernel request event http://symfony.com/doc/current/components/http_kernel.html#the-kernel-request-event // and changes controller if necessary // ... $attributes = $request-&gt;attributes; if ( ! $attributes-&gt;has('rules')) { return; } // expression language https://symfony.com/doc/current/components/expression_language.html $language = $this-&gt;language; $rules = (array) $attributes-&gt;get('rules'); $values = array( 'version' =&gt; 1.1 // get real version from request ); foreach ($rules as $rule =&gt; $controller) { if ($language-&gt;evaluate($rule, $values)) { $attributes-&gt;set('_controller', $controller); return; } } // ...
&gt; Pointing URL to that particular path on your web server ( e.g. http://api.com/v2/stuff, http://api.com/v3/stuff ) This :)
Interesting. I wonder though, is your 2.65s benchmark the entire time it takes to complete a request(including the PHP API calls), or is it just the raw time to compress a file(with all other time factored out)? If the former is true, then perhaps you can make Sqon faster and on par with PHAR if you write your library as a C extension, rather than a PHP library. 
Is there a hotkey that works like `alt+j` in phpstorm that selects the word in a variable excluding the `$` ? Similar to how `ctrl+d` works in sublime text.
- Code reuse? That argument died around the same time as the argument for inheritance. - As far as offering an explanation why SOLID is wrong (along with the others), it tries to fit in a mechanism for decoupling into a philosophy that forces coupling. - Regarding separating Wordpress devs from Engineers: Heard of code smell? Your comment has a Kool-Aid smell. Detect the hint of superiority in what you said? - Router/Dispatcher? So your question is "tell me how to implement my objects without using objects"?
According to [this build](https://travis-ci.org/kherge/sqon/jobs/149548778), I am able to compress and decompress file contents. Unfortunately it seems that I have other problems with running Sqons on HHVM. I'll be working on figuring that out. EDIT: [Got it working](https://travis-ci.org/kherge/sqon/jobs/149559473). The build is failing for an unrelated reason, but both `bzip2` and `gzip` compression is working on HHVM.
The 2.65s is for the complete build from start to end. The contents of the files that are added are compressed on the fly. Since the majority of the work is handled by the `pdo_sqlite`, `bzip2`, and `gzip` extensions I'm not sure there would be enough improvement to justify writing a `sqon` extension in C. Would be interesting to see the performance difference though!
Usually, PHP is running in Linux or BSD environment. For Windows C# is native. So, there is no reason to cut some function just because it doesn't work in Windows, and it can not be implemented now. File locking in Windows also works in different way, but you can lock files in Linux in the way Linux allow it, even if you can't do that in Windows. 
- lol - lol - yes, it was intentional - A routing/dispatching is a function of a system not an object.... you can easily dispatch a request which is a single page that has no objects at all, via `include`. Nice try on the deflection.
&gt; t tries to fit in a mechanism for decoupling into a philosophy that forces coupling Ah! ah! Nice try. Should you explain what is that mystic force that forces coupling ? It seems you are nourishing a pretty wrong fantasy about Luke and Leila copulating. The problem is SOLID is that people now when to start doing it (when they read it exists) but don't know when to stop. Using good design patterns and principles become very wrong when you have more meta code than code itself. That doesn't change the fact the SOLID is a very good thing, when you're dealing with the public part of your API, mostly. You need interfaces and closed components, what you don't need is too many interfaces and private/protected/internal stuff being closed.
I kind of like the idea of writing object without objects, that's actually doable rather easily. It's just less extensible and definitely less encapsulated.
Don't route based on URL. That's the worst possible way to version. Much better to use a header that defines the request version. If no header present, default to the most recent.
Go
I mean *code*, parts of a real application written the way you would write them.
- Do you concede the point? - Is that comment below about Luke and Leia (not Leila) copulating your concession on this point as well? Or is it a comment on incest? If you have a point make it in a civil manner. - Admitting to intentionally making a disparaging statement doesn't make it any better. - Using objects to implement routing/dispatching doesn't dispense with the logic (if statements) necessary to make the decisions to perform the desired actions, it only cloaks it in layers of OO goodness so that you can call yourself an Engineer and not a WordPress Developer.
Any Go code. Look at the philosophy of how they use types (not objects) and the practical implications. Imagine implementing an interface without actually having to say "implements". POOF, coupling gone. Why does it work better? Because the language is built with a sense of practicality instead of simply tacking on OO by following broken dogma.
- No. Inheritance is valid. - SOLID is about being flexible, being able to swap functions. coupling is fine, get over it. - You are right. But funny... is funny - How do you unit test procedural programs/systems?
You could go the way Stripe does their api and "migrate" the request in real time to the current version. For instance if you're using verison 2 and the current version is 4 you would send the request object through a migration step that would convert its body from 2-&gt;3-&gt;4. 
By the way, administration interface uses such components heavily and some elements like sign in modal dialog are using Polymer as well, so it will be a part of the framework anyway. But the plan is to allow developers to disable Polymer loading for other pages than administration interface if necessary (also modules in repository will stop working, since they're utilizing Polymer as well, but for completely custom websites this might not be a problem).
This piece is a bit too pugnacious for my taste, and I am not sure a reference to the Jonestown Massacre is an amenable way to appeal to an OO readership. Nevertheless, would you edit into your article some code examples? That might be a more practical demonstration of your view. I read something else advocating against objects recently - in support of Go I think - which mentioned getting a free gorilla and a jungle when all you wanted was a banana (turns out [this is referenced quite a lot](https://duckduckgo.com/?q=object+gorilla+banana+jungle)). 
The KISS approach is best, in my experience. If the change is not breaking (bug fixes and new, but backwards compatible additions) I don't change the version in the URL. If the change is breaking, but local, I tack a version number to a specific resource. When the changes become too many at the resource level, I create a new version of the whole API by adding a number at the base of the URL, with just the latest versions of the resources. Old versions are supported through adapters, and they begin to return "deprecated" warnings. Eventually the old versions are removed. 
I'd just like to point out the rant against using organized (if properly designed) code was authored with an 8 and 13-line paragraph.
[removed]
Why is it better to use a header? The way you proposed it, you break all applications using latest API version each time you decide to increase version. (same url that returns latest version (for e.g. v1) will return v2 after version increment, thus breaking every application NOT sending the version header - extremely wrong behavior IMO). Yes, you can drop the "default to the most recent" part, but then can't point browser directly to the api url.
TOML is a wannabe YAML replacement, which is admitted by the author, if you ever care to read the description. And as yaml is a de-facto standard already, the toml author have to make some effort to display the advantage of his home brewed solution over an existing one, vividly demonstrating the benefits (if any). The stupidity and ignorance of local folks who cannot read two lines of text and cannot draw a silliest conclusion are unbelievable. 
As a practioner of OO don't tell me you insist on brevity. Or is that brevity wrapped in several layers of abstraction?
Just a quick heads up, your `.idea` folder should be ignored (in your own global git ignore file that is, not the project's ignore file).
Where's the code that demonstrates your assertion? And not in Go, either, this is the PHP sub. . .
Stop using php, don't you know variables are actually objects? /thread
Zvals are structs not objects xD
At the moment, Sqons self extract to a temporary location. These files are treated like any normal PHP script, so I believe all optimizations apply.
Indeed, but my point is PHAR does this without temp files. Temp files are problematic for at least two reasons. First, running files from your temp folder is not secure on most shared hosts, where all users have access to the temp folders. And second, I use PHAR to distribute licensed components to clients, and the license forbids them from extracting the code from PHAR, and reverse engineering the component. PHAR is just a glorified zip file, but it maintains some semblance of a boundary, which can be used to describe use terms in a license. It's like a .NET executable file. Easy to get the source, but at least it's clear what the "product" is (EXE file) and what the "source" is (MSIL and C# files). If the source gets extracted to temp files automatically, all bets are off legally, IMHO.
I see what you mean. In another post I mentioned that the `phar` extension registers its own stream wrapper for allowing files to be loaded directly from the PHAR. If the PHP engine optimized `include`s from streams in general and not just the one registered by `phar`, I should be able to create my own stream wrapper and benefit from the same optimizations.
Is that using the phar unpacking stuff? Or always a packed phar (which given the times are the same, I believe is the case). I imagine that once both are unpacked, the performance is basically identical. Also, always unpacking means you should be using the opcode cache making that a moot point. Though PHAR uses the opcache regardless.
Not sure what is going on here. You store rules somewhere else and then load them in and send them through some logic filters or something? 
I was thinking about this, but instead using a CakePHP plugin for each version, which is basically this approach and I alluded to it in my initial post. I think I rather not bloat my code base with a bunch of stuff like this and instead just use branches and separate installs. That's just my gut feeling on it. Honestly, 3 years down the line I am not sure which will be the best approach.
The PHAR never unpacks in the test I did while the Sqon did unpack on the first run. I didn't have an environment without the PHP extension installed handy for the test. I think it's safe to assume that you are right, if both needed to unpack performance would be about the same.
OO is nice, the problem is when people abuse overengineering. A cake to the first person that find the exact line of code where the CURL request is actually sent: https://github.com/guzzle/guzzle (without previous knowledge of Guzzle internals)
I've been working on an alternative to [PHAR](https://secure.php.net/phar)s called [Sqon](https://github.com/kherge/sqon). [I created a post](https://www.reddit.com/r/PHP/comments/4vzam0/sqon_an_alternative_to_phar/) without realizing this thread existed.
If only there was a TV station like Fox News, but for disgruntled beginner developers, you could have a show around 11PM every day and share your thoughts with everybody.
&gt; Can you (or anyone else) explain why route based URL is a bad way to version and header is better? It's a trope in some niche, but vocal REST subcultures. Answers to the above usually involve disgruntled mumbling about some entirely subjective interpretation of a corner of the HTTP specification, presented as the gospel of API design, garnished with threats that if you don't do exactly as told, you'll break the Internet. Just put versions in the URL. It's fine.
it looks good , do you have plans to remove the sqlite dependency and store the paths in json or other format? 
I don't know if my title was clear, but this is only an issue if you use a "&amp;" on your foreach loop variable (so that you have a reference variable). It's also mentioned in the PHP manual, but how many of us have reach the PHP manual page for foreach recently? I never realized this could happen until I spent today struggling with a strange bug caused by this. I really think the next major update of PHP should unset the loop variable after foreach loops. That would be a breaking change, but personally I think it's worth it to fix this kind of insanity.
Fixing one insanity with another insanity is a bad idea. Glad you learned it, now you can unset and everything will be all right.
Unfortunately no, SQLite is the heart and soul of this particular format.
Not a beginner, been a professional developer for over 30 years. I've seen it all. You know how many times I was asked on interviews about database normalization? You know why nobody talks about database normalization anymore? Because it is a very small tool in a very large toolbox. It was a huge buzzword for awhile. The same will happen with OO. What a waste of time and thought and effort. It's a pile of almost completely worthless self-gratification. Move on already.
When I first saw phar being used it seemed like an interesting way of handling dependencies that didn't require installing pear or requiring sudo access to the parent system. They could also be packaged up with an application and sent off to third parties and know they would just work. The downside is it created a larger footprint in git/svn/etc and made diffs less useful. Then along came composer and most of those benefits went out the window while at the same time removing the downside of the larger source control footprint. The biggest downside of composer was whether the library in question was published on packagist or not but even that is very rarely an issue these days. The only software that I would likely see using phar/sqon for is composer itself when sending it to a third party. In what scenarios would you envision seeing sqon being used that couldn't be better handled by composer/packagist? The only one I can think of is if you had to be absolutely sure all libraries were always there without internet access, or you had to send an application to someone you couldn't trust to run even `./composer.phar install` correctly.
Possible case of [Imposter Syndrome](https://en.wikipedia.org/wiki/Impostor_syndrome). Which framework are you using? 
In my experience, though it surprised me, there are many customers I meet in large corporate environments who are still deploying via SFTP and have no ability to use composer in production â€” they very much appreciate the [PHAR releases](https://github.com/akamai-open/AkamaiOPEN-edgegrid-php/releases) I do (and I put a lot effort into making it a nice composer package).
Weird, it was 0.1s slower with that setting enabled with the correct path. &gt; phar.cache_list = /Users/kherrera/Downloads/bench/phar.phar **Option On** Iteration #0: 0.336s Iteration #1: 0.334s Iteration #2: 0.332s Iteration #3: 0.328s Iteration #4: 0.330s Iteration #5: 0.330s Iteration #6: 0.326s Iteration #7: 0.327s Iteration #8: 0.328s Iteration #9: 0.343s Average: 0.331 **Option Off** Iteration #0: 0.235s Iteration #1: 0.251s Iteration #2: 0.254s Iteration #3: 0.232s Iteration #4: 0.237s Iteration #5: 0.237s Iteration #6: 0.229s Iteration #7: 0.249s Iteration #8: 0.241s Iteration #9: 0.239s Average: 0.240
Got a public demo online?
&gt; Not a beginner, been a professional developer for over 30 years. I've seen it all. You know how many times I was asked on interviews about database normalization? You know why nobody talks about database normalization anymore? A question loaded with a statement that's obviously not true... &gt; Because it is a very small tool in a very large toolbox. It was a huge buzzword for awhile. The same will happen with OO. Ok, are you willing to bet money on this? How long should we wait, let's put boundaries on this. Alan Kay coined the basic concept of OOP in the 80s, and while it has developed a lot since then, the crux of it remains the same. You've been waiting for 30 years for OOP to die. When exactly you reckon we can bury it? I'll set myself a reminder on my phone. And more importantly. There's a disturbing lack of "here's what will replace OOP" in your rants. You just want to tell us we'll talk less about it. This is *very* different than saying "OO is not the way". And while there may be less focus on RDBMS theory around blogs and job interviews (although, depends on the job, mind you), which was your point earlier, nobody has ever said "SQL is not the way. Stop drinking the Kool-Aid." Instead, it still remains in heavy use throughout the industry, and the future looks bright for it. Despite niche alternatives. Heck, "NoSQL" vendors have started implementing SQL subsets in their own products. So. If "OO is not the way"... what is? Do you even have a point? Do you have any insight? Or do you just want to squirt around your bad feelings about OO on us and hope it means something? 
It's not really a bug. That's just references work.
about magic methods and empty(): you need to implement __isset() too for it to work. So if you have __get and __set don't forget to implement __unset and __isset about isset: if you ever find yourself using array_key_exists() with get_defined_vars() you are probably going too far - why does it matter if the variable is set and null? if you want to know if $_POST['bla'] exists check $_POST['bla'] not some side-effect variable about references: 1 - don't use references 2 - use references inside a method that is short enough so that you won't shoot your foot
**tl;dr** *"OO is full of abbreviations, principles, techniques and patterns. So much stuff, gahl! Wake up, sheeple! Can't we just, like, write good code, mkay?"* (Answer: no)
Is it line 5 in invoke in Handler\CurlHandler? ðŸ˜¬
I recently implemented a simple API with [Silex](http://silex.sensiolabs.org/) (based on Symfony components). Its super lightweight and fast as hell. Implementing it on top of your already written CRUD logic would be a breeze and it takes care of all of your requests and routing. 
It is not clear what you are trying to say. Do you want to call it "List of Php gotchas and how to avoid them?" instead of "best practices"? If the is what you are saying, I agree that it will be more apt name, but as you said, because of marketing reasons, it has a less chance to fly. I think the net result will be a loss by maintaining status quo. But if the community can sell it by the name of "best practices", even though it is a sort of 'click bait', it will be a net win. 
Interesting, I get caught up thinking there's a "proper" way to do something. But yes, I've had no issues integrating my swift application with the API. Maybe I need to just let it go!
There's usually a few recommended ways of doing things. But for very few things is there a 'proper' way. (security excluded) If it works and is easy to maintain, you did well. If not, consider how you can improve. Post some code if you need opinions. P.s. There's definitely wrong ways of doing things...
I don't know if best practices have to be on php.net itself, but that probably would be a good way to get more people to read it. The content of http://www.phptherightway.com/ probably is a good starting point for that.
I think [words matter](http://www.jsoftware.com/papers/tot.htm), so we should be careful about using the wrong ones. I've seen a lot of very junior programmers get very confused when they use language like "right" and "wrong" with programming instead of "working" and "not working", or "fast enough" and "not fast enough", and then using this "right" and "wrong" to evaluate tools they acquire instead of whether the tool is useful in helping them quickly write more working code that runs fast enough. I don't know if "List of Php gotchas and how to avoid them?" is a better title for what you actually want, but it might be a better title for what *I* think you're working on, and I think "best practices" should be strictly defined as practices that help us programmers (more) quickly write (more) working code that runs fast (enough). I'm not convinced PHP (or most languages for that matter) have many well-agreed best practices according to that definition: [foreach is faster](http://www.levijackson.net/are-array_-functions-faster-than-loops/), but [we shouldn't use foreach](http://www.giorgiosironi.com/2010/02/stop-writing-foreach-cycles.html)? And so on. However if you *are* interested in working out what *are* best practices then I am very interested in that.
I support this form of concerted reverse public blackmail, or whatever it is.
You can always do a foreach as $k =&gt; $v and just reference the key.
&gt; This means that a copy of the array will be returned Not quite. PHP uses [copy-on-write](http://www.phpinternalsbook.com/zvals/memory_management.html), the array won't be copied in memory unless modified. PHP manual explicitly states [not to return](http://php.net/manual/en/language.references.return.php) references to increase performance. &gt; json_encode() converts non-ASCII symbols It *escapes* non-ascii symbols by default for backward compatibility, and I don't see a reason to mention it here. `JSON_UNESCAPED_UNICODE` flag disables this behavior. There's no difference in the decoded output. &gt; Thinking that PHP supports a character data type PHP does not have a string datatype, either. PHP "strings" are simple byte arrays/buffers, consisting of a simple length header and the data that follows. It is completely unaware of string encodings and can hold binary data. How to interpred data in these byte arrays is up to developer.
It has nothing to do with whether you call it ORM, and everything to do with where is the connection and other settings for your "not ORM" coming into those static classes. I can't quickly set up a copy of your system with specific settings, specific table names, specific connection, etc. pass it as configured around, test it or use on in isolation, then tear it down. Instead, I need to smear global static state all over the place, and possibly affect other modules that may use that same ORM (or not ORM). I'm not over-applying a generic rule, I'd have an actual problem with integrating this into a bigger app, where architecture matters. I'd also have difficulty writing tests for components that use your system. I'd have difficulty migrating from one version of a module using this ORM to another, as I can't configure two instances of it independently. There is just one "instance" serving rows globally. It's a major limitation. While the consumers of your system may not care where the connection is coming from, my composition root that should give the components to their respective users certainly does care. Static access actively prevents me from designing the flow of configured dependencies throughout my app. Those row objects are state. And while static access has its uses, storing mutable state is definitely not it. That part of my objections is not theoretical, it's a problem here and now. You can ignore the criticism, but you should know many advanced programmers will have the same problem. The reason I'm saying I may be prejudiced, is that it stops me from exploring your system further, as this architectural flaw speaks about inexperience, and seems to advertise the rest of your work matches that level of design quality. 
Since I'm writing APIs all the time, I've been using a lot of micro frameworks lately. For a smaller project, I'd advice you to use something like [Slime](http://www.slimframework.com/), an awesome micro framework that have easy learning curve. Full REST support of course. I can't advice you [Lumen](https://lumen.laravel.com/) because I never tried it but I heard really good thing about it so you may check that out. Afaik, it's born out of Laravel and their ecocycle, preferable for a bigger project. You may aswell try [Silex](http://silex.sensiolabs.org/), it's lightweight and offers customization based on Symfony components. Not my type of choice but it's something you may find yourself in.
Or just use a for ? :) i know it's some extra to type, but hey, it's not "that" bad and it's clear when you read it again what's happening.
`local` isn't a keyword, it was me thinking out loud on how the problem _could_ be solved. The calling of closures like `(function() { })()` is new for PHP 7 thanks to uniform variable syntax â€” otherwise for &lt; 7 you would define and assign to a variable, then call it :)
+1 for generics.. but once implemented it still needs to be approved by 2/3, and I don't see this happening.
Ok, imagine that your controllers (or actions) is just an adapter between HTTP request/response and your logic layer. So if we change our API, we change some (usually not all) requests and responses, and maybe routing. So we just add new adapters for this particular API version. We could still reuse old adapters if they fit our needs. Also we could just write two routes for single action if everything that changed between versions is routing. Also out logic layer should support both versions, which is obvious. I use symfony, and i made simple package which provides me [request object](https://github.com/fesor/request-objects), this just simplification of http request adapter. Also I have specializes object which responsibility is to provide responses. So I just splitted my adapters to one who process requests and provides responses. But the main idea of "new adapters for new API" is pretty much the same.
&lt;JOKE TIME&gt; &gt; you can more or less pollute the global namespace with functions all you want. Actually, that's what Drupal until 7 does. &lt;/JOKE TIME&gt;
It was a question, not an insult, and not a dick measuring contest. With the language becoming faster it becomes significantly more appropriate to create applications and extensions that take advantage of it. While the groundwork (and the first 18 floors) is already there in Python, there are aspects of the web oriented nature and direction of commercial software that make it a more viable tool for data. More viable than php was before I mean. The same could be said of JavaScript 
Oh, you.
Mixins is just a meta word for saying "doing composition with a set of complete or incomplete classes" - in some languages where it is actually the only way to implement stuff, it's very good, but in Python it's not (Python is more like Javascript than any other language by the way - I don't like VMs taht allow code that can change itself over time, literally).
is it just me or are these javascript modals super annoying on page exit?
References are a bad thing almost in every case. The only legitimate case is where you pass an array to a function and the function should mutate the array instead of returning a new one. Note that this is *also* a bad idea. 
Yeah Silex is nice but I've switch over to Lumen now and we have noticed a slight speed increase of 10ms on average per each request. Worth looking into.
nice
It's a framework, not a CMS, there's not much to see out of the box...
Makes perfect sense, but why would I go thru the trouble of using a try/catch block when I can simply use `@` to suppress any errors(which I won't, just making a point). I honestly think I didn't exactly understand what they're trying to say, that's why I posted here. 
Well thats confusing, right there in the readme it mentions blogs, commenting, feedback, galleries, ecommerce, and WYSIWYG. 
&gt; for &lt; 7 you would define and assign to a variable, then call it :) You can call a closure without defining a variable like this: call_user_func(function () { // stuff }); 
as a user of the library I don't need to care about the implementation. Even in messy code the API can be good. The problem is that contributors still need to read the code and if some of the PHP most used packages look like this under the hood what can we expect from our everyday code? I'm just disappointed...
&gt; A single try/catch around your entire script for logging is just ugly and unmaintainable. An [exception/error handler](http://php.net/manual/en/function.set-exception-handler.php) is the way to go. See, with a global try-catch you will have to write some handling code in the catch block. It will make your code unclear. So, the next step is to put the handling code in a function and put only a function call in the catch block. But the thing is, you can already put this function to work, without even using a try/catch - by setting a handler! &gt; that's what they are trying to say https://www.reddit.com/r/PHP/comments/4w3r9y/pdo_and_exceptions_or_rather_anything_and/d63qtoz
So basically use try/catch to log errors but never report them?
The situation is quite reverse: the only address you can rely on is REMOTE_ADDR, as everything else can be faked even by a 5-year-old
"There are individuals in the PHP community that are dogmatically logic-minded. This is understandable, because a dogmatically logical mindset can make for incredibly good programmers. Unfortunately, when it comes to certain complexities like empathy, understanding and interacting with people, without the use of other thought-tools dogmatic logic can be a bit shit." Logically explaining that logic is not good enough. Great! There is a point when the "appeal to emotions" goes from "logical fallacy" to "deliberate manipulation". Most of the times only the people using it for the latter will continue using it after being told it is a fallacy.
Have you looked into league/fractal?
I would suggest never using array_walk(). It is much more fragile than foreach.
Your answer makes me think you would rather reinvent the wheel than use a high-quality package that does what you want.
&gt; Never use @ that's the only PHP feature that no-one should ever, never use. Unless you use file_get_contents(), json_decode(), ..., ... But hey, it's not a rule if there isn't an exception, pun not intended.
&gt; This is part two of a blog series, about why the PHP community is having a rough time talking about diversity related issues I actually think the PHP community should focus on talking about PHP.
I'm going from this post here: http://stackoverflow.com/questions/4773969/is-it-safe-to-trust-serverremote-addr It seems its a pretty reliable way to do it and maybe I'm taking it for granted but every ISP I've had in the UK I will always have the same IP for the duration of the contract 
I have direct access to the DB so that wouldn't be so much of an issue but I take your point. The application in question used internally (in the company) by a select few and at their home addresses so it might be possible to do add IP whitelisiting but could deny legitimate users in some cases 
I'll check it out, but I would still like to know about best practices in terms of the question
&gt; &amp;$ BAD! NAUGHTY PROGRAMMER! &gt; array_map Is the answer you're looking for. Alternatively get a collection library of some kind, Laravel's eloquent collection can do stuff like this: $multiplied = (new Collection([1, 2, 3]))-&gt;map(function($item) { return $item * 2; }); You can also chain things like filter: $multiplied_even = (new Collection([1, 2, 3])) -&gt;filter(function($number) { return $number % 2 == 0; }) -&gt;map(function($number) { return $number * 2; }); &lt;3 functional style.
To be fair, this is exactly why VPN was invented. You can block the app at a firewall level, white-list local company IPs and require a VPN for any external access. 
I pretty much have accepted that in all programming languages never to try to modify an array I'm in the process of iterating over just create a new array
Discovered that one the hard way - a reference loop within another loop. Got me scratching my head for a while before I realised the end of one loop instance was feeding into the next loop instance. And `unset()` after the loop fixes that. I just try to avoid them now.
Where's "Common Mistake #11", being lazy about SQL injection: $res = $connection-&gt;query( "SELECT `x`,`y` FROM `test` LIMIT $limitFrom, $portionSize"); I know you defined those two numbers just a few lines above, but that doesn't stop someone in the future from changing your code around, and not noticing that you left it wide open for injection. This is just lazy coding. Prepare your statements, or filter your parameters. Always.
One would assume that the library suggested would be a good one to look at for "best practices" if it is considered a "high-quality package" keeping in mind "best practices" for your project might not make sense to be "best practices" for my project.
I agree, it is confusing. Sometimes the author refers to it as a framework and sometimes as a CMS but I can't see a lot of user interface going on in the linked repository. The author shared a video exposing the installation UI if you'd like: https://youtu.be/GVXHeCVbO_c
&gt; ... Laravel's eloquent ... Laravel is never the answer. :: ducks :: ;)
Imo you are right - every time I use concatenation to build my queries, I make sure to at least typecast to `int`.
In short, catch an exception only if you have a handling scenario other than just reporting it. Otherwise just let it bubble up to a site-wide handler (note that you don't have to write one, there is a basic built-in handler in PHP, which is quite good). 
I'd strongly recommend the use of the Symfony Serializer component if at all possible, it makes this kind of task a doddle: http://symfony.com/doc/current/components/serializer.html It'll convert your XML into easy to use, JSON, YAML, PHP arrays, or PHP objects (Entities) if you have one representing the data structure.
Look at how fractal does it. There your best practice.
Thanks, but I think this is not necessary for this project. I'll consider it next time :)
@ is blunt, it suppresses every error. While all errors are different, some you want to bypass and some you have to report. For file_get_contents() I would convert PHP errors into Exceptions using error handler, then wrap file_get_contents() in a try-catch and there consider the action depends on the certain error, just like it shown in the top comment.
If the intent of the ProductFormatter is to return a formatted product then I would think your first option makes the most sense. The other options seem to move the actual formatting to the foreach loop. No easy way to share foreach loops. And since the formatter really only needs one public method then I would call it __invoke thus turning you class into a callable. And user array_map to get rid of the foreach stuff. class ProductFormatter { public function __invoke($product) { return $formattedProduct; $formattedProducts = array_map($productFormatter,$products); 
I've always done it this "as" way, no idea why anyone would use references for anything but pass by reference, except as a cute PHP trick (that's bound to backfire as we see)
I have never once used a reference in a foreach. I don't see any reason why you should?
You keep saying I give you "dogma" and "the gospell" while ignoring all my technical arguments. I didn't read somewhere on a blog that what you did is poor design, I've lived it. I can't give a flying ef what the community thinks, I know *exactly* why it's poor design from my day to day work. You know, I tried to be exceptionally clear, but it's quite apparent that you're not looking for feedback, only looking for approval and responding defensively to all critique throughout this thread. And... the pattern I was referring to isn't called "active rows", but "ActiveRecord", and your ORM is an unwitting implementation of ActiveRecord, with all its drawbacks, like inability to do DI, and coupling storage, serialization and business logic in the same class. You're pushing these drawbacks as "benefits" and calling your ORM "unique", and you can't get the name of ActiveRecord right. Given your code samples show a typical ActiveRecord implementation through and through, it's impossible to take your word seriously that you've researched this pattern, let alone that you understand the problems with it. In any case, have fun with it if you like it, but don't expect high praise from people with a clue, because we've seen our share of ActiveRecord messes and we've learned our lessons.
&gt; For file_get_contents() I would convert PHP errors into Exceptions using error handler, then wrap file_get_contents() in a try-catch and there consider the action depends on the certain error, just like it shown in the top comment. I wish it was that simple, but this would preclude you from receiving the response body (the implied scenario was using the HTTP stream wrapper and getting back a 404). In my projects I do convert warnings/notices to exceptions, and I didn't want to support @, but I eventually had to, for two reasons: 1. Some poorly written components (and it's full of them on Composer, and yes, some are quite popular and established) make use of @ in random places, and getting an unexpected exception breaks them. 2. The aforementioned PHP internal functions, and some others, do throw notices and warnings (when they shouldn't, I'd argue), *while also returning results* and so it's impossible to get both and use them correctly if you don't silence the notice (and hence the exception). Until PHP fixes its own mess, we'd have to accept that silver bullet solutions to error handling remain a dream.
Right after she cleanses PHP-FIG of all undesirable elements.
Won't work here, implied use case was 404 response when using the HTTP wrapper. It's one of those infamous inexplicable examples where the stream API decides to fart out a notice. As for your file system example, two problems: 1. You perform three IO operations, instead of one (I think stat cache reduces this to two IO operations, but still more than one). 2. You still afford for a race condition to occur between your if () check and you reading the file, so an error could still occur. In very rare cases (which is the worst kind of error).
It looks like the author intends to illustrate that unexpected exception types would be handled differently in those examples. They might also be implying that best practice would be to always have an emergency fallback for unexpected exception types.
 { // Code to handle the exception } catch (ExceptionType2 $e) { // Same code to handle the exception } Because you then have duplicate code. What happens is that someone updates the code in one place, but forgets to update it in the other place, that is supposed to be the same as the first case. The whole point of the RFC is to allow the same block of code to handle both exceptions. So there is no duplication, and so there is no possibility of forgetting to update the 2nd block.
I fear I missed your point. Are you suggesting I should stick to Laravel because it's minimalistic and fast? I mean I find implementing a blog in Laravel really easy. It's the 'editing content' that I'm concerned with. Specifically I don't want to reinvent the wheel. 
&gt;my question about future extension possibilities was met with "php isn't dynamic like Python..".. If you don't want irrelevant responses, do not include irrelevant comparisions in your question. Plain and simple.
Additionally, since ExceptionType1 and ExceptionType2 presumably inherit from Exception, `catch (ExceptionType1 | ExceptionType2 | \Exception $e)` would be identical to simply `catch (\Exception $e)`.
The bylaws allow only this voting action, or considered and historical reasons.
I wouldn't use a singleton just on principle - if the object doesn't have any dependencies, it's not difficult to just instantiate it when you create the dependent object.
There are plenty of ways to create scope to release memory while creating and modifying arrays. Or I should say foreaching over an array in that situation may not be the best approach for low memory systems.
&gt; if they do little more than bicker about petty politics like in this case Said while multiple groups of people (not just Paul) do great work on the open PSR's...
Hi /u/silver_j -- I'm the author of [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp); I ask these questions because I raise them in that book, and am looking for real-world stories. - Did you all estimate in advance how long you thought the rewrite would take? - Did you revise your estimates as you went along? - At which point did you realize the rewrite would take 15 months to complete? - Did you find the scope of the rewrite changing along the way? - How did your revenues do during the rewrite period? - Did you end up neglecting the older application during the rewrite period (i.e., not adding features, not fixing bugs, etc.) ? - Is the rewritten codebase essentially a copy of the previous codebase, in terms of features presented to users, or were new features added along the way? Thanks for the writeup in the first place.
Valid point. For me, it would depend on the extent of the formatting/transformation. If it's a simple few-liner function, a simple static or private class method would do the trick. If the data transformation requires dozens/hundreds of lines of code, then I'd definitely split it off into its own class that could be instantiated where needed. I usually err on the side of KISS, except where the level of complexity warrants its own instantiated object with multiple helper functions.
You could also include a bit more "magic" by creating a `formatProducts` convenience method and allowing that to be used via Invoke, like so: public function __invoke($productOrProducts) { if( is_array($productOrProducts) ) { $formatted = []; foreach($productOrProducts as $index =&gt; $product) { $formatted[$index] = $this-&gt;formatProduct($product); } return $formatted; } return $this-&gt;formatProduct($productOrProducts); } But different people have different levels of tolerance for magic, so I'd put that down to personal preference.
Not to get philosophical, but what is *written correctly*? If it works **and** there are no pending changes, then I call YAGNI on anything else. On the other hand, if you have changes, and they're hard to make, then I understand the concern.
&gt;why do the major CMS's not block the admin page based on IP address? Most people have volatile IP addresses, and you need a backdoor to fix the IP whitelist if something goes amiss even if you do have static IP. If you own and operate the machine it's simple: the backdoor is physical access to the server that lets you do anything you like. For the technically savvy it's fairly easy: keep SSH open with a key requirement. For shared hosting / the average schmoe user most CMSs target? It'd probably just end up wasting a lot of customer service rep time explaining the IP whitelist, how to use it, and fixing it when it inevitably locks people out due to an IP change or because they don't understand their IP doesn't carry over between their house and their office. &gt;My thought is to build a white list of IP's and then when someone accesses the admin login page check the $_SERVER['REMOTE_ADDR'] and see if it matches anything on the whitelist, if not then redirect somewhere else and don't render the page, so they don't can't even try and access the login form. You could do that, but the more idiomatic and generally technically correct way to is to filter at a firewall level or at the webserver level. I don't know offhand if there are any 'fun' caveats to how `$_SERVER['REMOTE_ADDR']` is populated, but it should probably be fine security wise to use that. Don't quote me on that, though. But that said: you shouldn't really have an issue even if you do let russianproxies.ru or whatever try and brute-force your admin login: use a good password and set a good policy. If you're really paranoid adding a key requirement would probably beat out IP white-listing in terms of actual provided security given how inevitably mismanaged most IP whitelists I've seen have gotten.
I love you. Your book helped a lot when I was refactoring a turd a few months back. Worth every penny. 
It must be rewritten in javascript. .NET, never hear of it!! /s
`call_user_func()` is slow though, and I'm trying to forget that it (and `call_user_func_array()`) exists
*Lunar Lander crashes due to missing NPM dependency*
This article would have been *sooo* much more interesting with any or all of these details.
where is the moon? ENOENT
I'll try to post some of the calls when I get home later tonight. Appreciate the help everyone!
i'm storing rules on the route definition, and then, before the route's controller was executed(on Symfony this is Kernel Request event) i'm checking that routes rules and if one of the rules evaluates true, i changing default controller with that rules's controller. so with that definition; posts: path: /{api_version}/posts requirements: api_version: "%api_versions%" defaults: _controller: AppBundle:Post:index api_version: "%api_version%" rules: "version == 1.1": AppBundle:Post:indexV11 "version &lt; 1.1": AppBundle:Post:indexV1 this controllers will be executed; */v2/posts* -&gt; **AppBundle:Post:index** */v1.1/posts* -&gt; **AppBundle:Post:indexV11** */v1/posts* -&gt; **AppBundle:Post:indexV1**
Excellent - definitely a topic I know people would like to hear. I get questions about it often.
Incidentally, there *are* other moderators for it besides Scott *cough*like me*cough* :)
Use a client side certificate.
This statement is just plain wrong. NodeJS is like PHP single threaded. Node is only async, not parallel. PHP can do the exact same thing. You don't need language support to write an event loop. One example is Amp with its server named Aerys: https://github.com/amphp/aerys 
Let me copy what I just said below... Actually, I played it up a little, but I'm not really a troll. My point was very clear and simple. The philosophy built around OO are not improvements, or "best practices", or the maturation of software engineering. They are simply fixes to an underlying concept which is flawed. Seriously consider what I'm saying and what I wrote in the original post. The most popular comeback here is "show me the code". Why? It's like proudly showing my bald head to a wig maker and saying, "look this is better." It won't fly until you are willing to rethink some deeply held beliefs.
This is my first time trying to build an SPA and I wan to implement Log In with Twitter to get the user's timeline. i feel like I've read all the documentation. It's the implementation that confuses me. I see alot of framework and modules online. But I just want to know I get this to work with php. It's for Chrome Store btw
Yes, they should have used Symfony!
Not one mention of OOA! For heavens' sake! Where are you guys going to school?
this is truth. he has no idea what he's actually talking about. I think he read a book, couldn't get it and now he's here to rant.
No you can only do it via an ajax request. Also why would you want to do this?
would assume like in most languages that have try/catch the final one is to handle any other types of exceptions that you aren't specifically targeting prior (Exception 1,2). Sort of a "catch all" for all other types. 
Sure. And for those users a good password combined with rate limiting is more than adequate. Enable two factor if you really need some extra cushion. White-listing a stack of IPs is very clunky. 
Haha true. He probably wants the next â€œguyâ€ to suffer. I almost killed myself for fixing some other dudes custom cms.
I highly recommend a book called [Build APIs You Won't Hate](https://leanpub.com/build-apis-you-wont-hate), it's helped inform how I built several APIs used at work. It's not exclusive to PHP but I believe it has PHP sample code.
I was actually thinking that he was a 13yr old who thinks he has an intelligence that rivals Einstein, but in fact found out he is dumb as shit... so he comes here to tell us we are all wrong.
Zend more rigid than Laravel? I've always considered Laravel to be one of the more opinionated frameworks. Edit: backwards. I need sleep. 
He said Zend was too rigid, so they went with Laravel. A **much** better choice anyways.
&gt; If we perhaps added a local keyword, we could do something like: Or "var". It's already reserved. 
&gt;&gt; "*Did you all estimate in advance how long you thought the rewrite would take?*" &gt; "*Our initial estimate was that we expected to be finished in January, but it eventually completed in May. In honesty, it was not made with any real knowledge as it was tough to foresee how long the whole app would take when at the start, so I was pleased it was not too far off.*" ---- OK. So you were flexible on delivery dates. Did you define ahead of time ***any criteria at all*** for what would constitute a "*Success*"? For example, stuff like... * *Amount of money it would cost for initial development* \[*in dev salaries per day, for example*\]? * *Amount of money it would cost to maintain over the entire life span of the product?* * *Number of defects per kloc in the I^th release?* * *Amount of unit test coverage?* * *...or...?* Or did you just cross your fingers and hope for the best?
You're right, the speed at which a language can manipulate data has nothing at all to do with manipulating data. I guess hoping for language improvements is as pointless as arguing with you.
Haven't been able to make it the last couple of years but attended 3 or 4 times. If you have the time (and if there are still tickets available) I highly recommend checking it out.
&gt; Mmm...interesting! Looking forward to their next rewrite.
&gt; constructive dismissal It is not. Constructive dismissal is an entirely different thing. The membership are empowered by the bylaws to expel members by requiring a member project to select a new member. 
I want to try to understand your viewpoint here. Do you think the PHP community is free of the problems Phil talks about, or (if they exist) they don't merit attention as much as discussing say the next MVC framework?
Totally shitty idea ahead: class ExceptionType1 extends ExceptionGroupType1{} class ExceptionType2 extends ExceptionGroupType1{} class ExceptionGroupType1 Exception{} then catch (ExceptionGroupType1 ){}
I've always loved and admired your work. THANK YOU! haven't for some reason bought this book yet, and certainly looks like my next PHP book (although I have been fortunate enough to work with modern PHP with my clients). 
If the exceptions are of the same group, this does make sense, e. g. two HttpExceptions (403 and 404 for example). But of course if there's no logical connection this would be a terrible, terrible thing to do.
You're very kind to say; one is glad to be useful. :-)
&gt; I used to think that calls for diverse speaker lineups were "positive discrimination", but I saw the light &gt; I used to think Code of Conducts were pointless and daft, moaning about conferences implementing them with my friends like a sullen child. &gt; When somebody says something bigoted, you want to say "That is bigoted", but then they throw up a shield and no ground is made. Maybe try and avoid using those sort of words &gt; As somebody who used to be incredibly ignorant to these topics, I feel driven to help the situation now that I've had my eyes opened. &gt; Whatever we do, we need to stop turning these confused extreme voices into martyrs Born-again Phil.
&gt; Do you think the PHP community is free of the problems Phil talks about Phil is the problem.
Consider the follow code that expects an array: function example($arr){ $origLength = count($arr); $arr['hello'] = "world"; assert($arr['hello'] == "world"); assert(count($arr) == $origLength+1); $hits = 0; foreach($arr as $k =&gt; $v){ $hits += 1; } assert(count($arr) == $hits); $copy = $arr; // Copy on assignment semantics $copy['hello'] = "dood"; assert($copy['hello'] == "dood"); // Great! But... let's just make sure our original array is unchanged, right? assert($arr['hello'] == "world"); } Looks sensible, right? Most of that functions works flawlessly when you pass in an array-like object. (For example, something that implements `ArrayAccess`, `Countable`, and `IteratorAggregate`.) But not the very end, where it explodes because -- despite identical syntax being used -- objects don't have the unique assignment-behavior which PHP gives to its arrays.
Would be really good for all if you could tell which resources we can use to improve on that: books, sites, articles, etc.
God. As I learn more about this stuff, I am becoming more and more convinced that Php is a toy language that should not be used for anything serious...
&gt; They're their own things. I know, hence the phrase "interfaces *like*". Interfaces which allow your custom objects to take advantage of built-in syntax. &gt; Not to mention the whole boondoggle could be avoided with a typehint. That only works at the topmost level though, you can't control nesting. Anyway, at the end of the day, the problem is that there's a fundamental difference in array-vs-object behavior lurking beneath the identical syntax, and the bugs it causes are not obvious or immediate. 
It is quite ironic that you claim that this vote is a "witch [hunt]" against PMJ, and then complain about the excess of "pompous statements", which is all that PMJ has contributed to in the FIG for years (https://www.reddit.com/r/PHP/comments/4v5gyu/phpfig_vote_to_request_a_new_aura_rep_aka_replace/d5ysgew). He even successfully derailed the vote against another voting member by arguing about process and politics. One of the reasons for the vote is because PMJ **is** the obstruction preventing the FIG from getting work done.
&gt;I know, hence the phrase "interfaces like". Interfaces which allow your custom objects to take advantage of built-in syntax. They're not like ```Traversable``` though. They're different things with different goals. ```ArayAccess``` is almost the exact opposite of the design pattern I'm suggesting. The goal is to work with objects to reduce nesting and guarantee type. &gt;That only works at the topmost level though, you can't control nesting. I don't quite understand what you mean by that. If you typehint an array the function can't consume anything else. That's why the [iterable type RFC](https://wiki.php.net/rfc/iterable) just passed. Certainly when a function or method is that tightly coupled to arrays then it needs to be typehinted to an array.
no that's just you not knowing all the things you should know. and you can't really call php a toy considering that a large portion of Web is based on it.
So? Just because there are alternatives doesn't mean that a polyfill is a bad idea. I like to code in PHP, and I see no reason why I should have to rely on switching to a different hosting system **just for a formatting function**.
It may be _wrong_, but not _plain wrong_. Get your wording right and try to notice the strike-through in my post above. Just up there, read it and you'll never find the word _parallel_, and no, I didn't edit it. The question was if it's better to use Node.js or PHP for this. A fact is, JavaScript/Node.js has asynchronous events out of the box, PHP has not, which involves overhead for the PHP version of it. It's also a fact that Node.js can handle more concurrent requests than PHP, especially _because_ of said overhead. So my statement is not even wrong, it's just wrongly read or interpreted by you. &gt; Node.js is just the right technology for Websockets. This is the truth. And I even prefixed it with `I think`.
Phil should stick to writing about PHP. If I read any more non-PHP rubbish like this, then I won't be buying any of his books in the future.
Hehe, kinda true, look at the amount of people grinding away at WoW, that aint fun ;) But i feel he does have a valid point in possible making it way more interesting.
Sorry, I thought you're creating a new repo for it :)
Sometimes it's easier not to wipe my ass. I still wipe it though. Call me weird.
Nah, if i make it it would probably end up in the main project in some way. The library to calculate levels and such might be somewhere else though, we'll see. ^^
Thanks! 
https://github.com/borisrepl/boris
No - the OP is describing a passhash being provided by PRTG (ie. out of his control) that needs to be persisted throughout the session. The correct solution there is to store it in $_SESSION. The example of what JWT is good for is for cases where *both* servers are under your control, and where you need to prove that a request is valid - in this case it's just about persisting a bit of data (that happens to be an API-provided passhash) on *one* server.
As a lazy developer, I love tab-completion. I wanted completion for composer, so I put together a super simple bash script. The script provides "common" composer commands, but is focused on the "update" component. It parses both "require" sections to provide completion. I only use bash, so if you want zsh support, perhaps you can run with the idea. https://github.com/mahngiel/composer-package-completion
For only works on arrays with numerical indexes and hopefully no gaps,, alot of the time my arrays have string keys or the keys might be id's from a database with unknown order, unknown start and end, unknown gaps,, i rarely use for.
I see you don't know the meaning of pointless. Take a few deep breaths, go outside, take a walk.
Currently is does nothing with the project itself. The reason for that is, that if you want to run the tests for that project you need to install all the libraries and so on. For our company it analyses 500 repositories, that really is not feasable. For now its quite static, by design. :)
Test Driven Development: By Example by Kent Beck is a good book to start out with. Some people believe we should not [TDD](http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html) at all. Read up and don't take my word for it. TDD is just another way to develop. My normal workflow is: 1. Go to the spec. Find one feature that is bite sized. In this case, its a CRUD interface. Users want to be able to create tasks. 2. Create the basic view test (Route and view). Pass basic view test. Users can see the task view. 3. Create Test for the model. I usually include relations within the tests. Others will argue that this is not necessary, but I do it anyway. Users have many tasks. 4. Create controller test. Pass controller tests by passing in sample data. I usually do a quick followup with the customer/team to see if this view is what they want. 5. Hook up any additional processes like services, emails, etc... TDD those as well with phpspec/Mailthief 6. DRY/SOLID refactoring as much as possible before hitting live. My previous tests should make this process easy. 7. Go to 1 until product is complete (its never complete). You can also try the Scaffolding approach which is feature first, Tests after, then refactor. Its a bit quicker and is better with teams on a deadline. The only issue with quickly scaffolding without testing first is devs are tempted to skip testing altogether or do the least amount of testing possible for their feature. I have found these projects can become unattainable after a time. For the very basic, Laravels docs have some good examples. Also checkout some projects that you use from github to see how/why they test.
&gt; Magento, Wordpress, xcart and Prestashop How about "Punchingbag"..
I'm not sure if you're working on trying to TDD a web application or not, but I recorded a screencast awhile back that might help get you started: https://adamwathan.me/2016/01/11/test-driven-laravel-from-scratch/
&gt;JetRails Makes me think I can host rails apps and its main intentions is for Rails. What about: "Masochism" For what you are hosting? LOL I kid. EasyHost? Most of these things seem easy to get up and going ....
Do you have to be so negative (point wise and literally)? I mean I am sure they know what they are doing. 
Thanks, good feedback!
Since you seem to be eCommerce, perhaps a name that is relevant to your focus. IronFlash doesn't say much, it's just a name really. JetRails makes me think of Ruby-on-Rails. RapidBox sounds good, like a fast server, except it also makes me think of filesharing and things like RapidShare and Dropbox having a baby. If I had any suggestions to bring up, it could be JetComm or RapidCom/ComBox. (Try to reuse any of your names in the event you were attached to certain parts of them.) If you want a totally new/original name, that'd take a bit more effort and research than just a thread here probably. Something that both encompasses your brand and seems like something you could recognize as labeling your company or service. And if these existing names _do that now_ then please, provide some rationale for why those names were chosen so we can better appraise them. Without context I see a small list of madlibs.
Thanks, I appreciate the advice!
Sorry, I was bit a hangry ... it's fucking hot as hell here and no food = angrybear.
While I'd agree your methodology is generally correct, this is terrible advice. Phpunit provides all sorts of built in functionality for (among other things) mocking dependencies/abstract classes/traits and code coverage analysis. Mocking objects is *especially* important when testing things that connect to any sort of data source (database/web API/etc.). In response to OP's question, another important thing to consider once you nail down the basics of UTs is writing testable code (something that properly executed TDD will help with naturally). Often times this is done via [dependency injection](https://en.m.wikipedia.org/wiki/Dependency_injection), sometimes referred to as "DI."
&gt; Just up there, read it and you'll never find the word parallel, and no, I didn't edit it. I know. I just added it as clarification of _"handle multiple clients at the same time"_. &gt; With pcntl you can also bring in some async-feeling In fact, you don't need `pcntl`. You need it only to handle signals. PHP has native support for http://php.net/stream_select and there are extensions for more advanced event loop implementations such as `libuv`, just the same event loop used by Node internally. &gt; A fact is, JavaScript/Node.js has asynchronous events out of the box, PHP has not Right, Node has the event loop implemented in the language whereas in PHP we currently have to implement it in userland. However, `stream_select` or `libuv` is still the main part of the event loop and that part _is_ already part of PHP.
A point that you don't hear made as often - if ever - is our industry is filled with a bunch of idealistic cry babies who'd rather spend their days architecting the perfect/ideal solution instead of rolling up their sleeves and doing what's asked of them. Complaining about technical debt is even more unacceptable if the team complaining is the same team who created the debt in the first place. Learn how to code and meet deadlines effectively, or learn how to push back at the appropriate times. Bitching about things after the fact is just ridiculous, and of all the developers I've worked with over the years, the ones who've done the most bitching seemed to be the least competent anyway. /rant
More likely, a team that's ineffective gets some new developers because things are going too slow. Those developers try to shape things up, but the old team doesn't want to change anything. "Eh, it works, why bother?" they respond to every attempt to modernize. Autoloading? Better deployment? Unit tests? Programming to interfaces? Git instead of SVN? "We've done just fine without it. Let's keep doing what we already understand." The new devs either leave the swamp right away or stick around while their skills rot. Either way, that kind of attitude won't improve the codebase.
This is a mark in favor of automated testing, not a mark against refactoring.
&gt; um. in our case we're being forced to created debt by idiotic managament decisions. Nope. That's just your excuse. The sooner you own up to the fact the debt you're creating is your own fault, the sooner you'll be a happier developer :) Or, you know, you could seek employment elsewhere. Spoiler alert - you're going to face tough deadlines where ever you go ;)
&gt; just your excuse. The sooner you own up to the fact the debt you're creating is your own fault, the sooner you'll be a happier developer You're assuming a lot. Last example was them outsorcing frontend creation, managing contractors themeselves, changing specs all the time. When outorcing partner faild to deliver after moths of delays they dumped a trainwreck of a code onto me.
Here's something that I've found to be true over and over again: A working acceptable solutions &gt; An proposed optimal solution If it ain't broke, don't fix it. Focus your time and energy on solving actual business needs, and get off your damn soap box. I assure you the customers/clients of your business could give two shits whether your dev team is using SVN or Git. And chances are there's a rather large backlog of requests submitted by actual paying customers that would be a much better use of your time.
&gt; A point that you don't hear made as often - if ever - is our industry is filled with a bunch of idealistic cry babies who'd rather spend their days architecting the perfect/ideal solution instead of rolling up their sleeves and doing what's asked of them. Which industry is that again? I hope you don't confuse what people write on forums with the state of the industry.
person they first dumped this code on ended up leaving.
Would you say the same thing in the course of filling those new requests? We're building a new site. This time, instead of mixing all of our logic with with the HTML output, can we use a template system to hold all the HTML? "That looks complicated. Get off your damn soap box."
Oh come on. Anyone who follows Linus Torvalds and the Linux kernel community will surely remember all of the bitching and moaning people did about Linus "not being nice". It was really sad, developer's are given a once in a lifetime opportunity to ask the grandmaster himself anything they want, and they spent their time asking why he had to be so mean. Here's a link if you're interested: https://www.youtube.com/watch?v=5PmHRSeA2c8 And for fuck's sake, who here doesn't remember the whole code of conduct snafu: https://www.reddit.com/r/PHP/comments/3zhapd/rfc_adopt_code_of_conduct/ This industry - from the kernel to the web - is full of cry babies. I'm not saying that _everyone_ is, but we definitely have our fair share.
Learning any other language will most likely be beneficial, whether you put it to use or not. Comparing the design choices and features, understanding why one language is statically typed and why one isn't, how things like generics are implemented in languages and why PHP wants them, etc. It will help you grow as a developer, and you can apply what you learn to whatever language suits your next project.
&gt; Losing excellent developers If they leave over such things then they're probably only excellent in their own minds.
I think the beauty of Laravel is that past its opinions, it is quite configurable and flexible as well. Having worked with Rails, Laravel, Symfony, ZF1 and 2, and Spring (Java), I have to say that Laravel gives the best developer experience, in my opinion. The opinionated default configuration lets you do 90% of tasks quickly and easily, and the flexibility lets you achieve the other 10% of tasks without a lot of pain.
&gt; do not tell them you'll be starting from scratch hmm. I definitely agree on this one. Previous project which was a shopping cart migration. Same pattern -&gt; subcontractors were supposed to do everything with our management managing. Long story short -&gt; they've butchered it and after 1 year of development with no results it came back to me. Couldn't hear the end of groans and moans when I said scrap|rewrite. 
Somebody with any amount of self esteem isn't going to stick around long when everything is broken again because doing feature branches in SVN is impractical. Oftentimes, people who are good at what they do know they're good at it. These people may not have much patience for tethering their careers to a lead developer's inexplicable conservatism.
It's only a test of your ego and lack of comprehension of the possibility that you are not infallible. I've heard plenty of what I would call acceptable reasons not to unit test. This one is not an acceptable reason.
?
* Not enough time * Not enough money * Don't know how * Throw-away code * Experimentation (in some cases) * Unclear business requirements * Adding code to something without the ability to unit-test (WordPress it's pretty hard to make useful unit tests for, it's easier to do other tests) I think my code works, or I know how every component of language X works is not in the list. It's in another list (things that add risk to projects).
Good luck! Give it a shot and let me know if you get stuck. I've done some pair programming in the past if you want to give that a shot as well. Works really well with TDD.
hosty mchostface
Wow. This is the best explanation I've seen for unit testing yet. I've never used it, but I'll definitely give it a try now that I realized how useful it can be. I've had a lot of trouble by fixing a bug while adding 10 more and not realizing it :) 
Any particular reason/requirement that makes you need a minimal framework? 
Slim is nice. If you want one with a big ecosystem behind it, check out Silex.
Not in the right direction at all.
what do you mean?
The bureaucracy is expanding to meet the needs of the bureaucracy. 
I'm guessing you just started coding?
he lost me at pressing ctrl+cren
Why is `extension_loaded('hello')` still `false` at the end?
Well the fact that you dont know how to write good OO code doesnt mean OO is not the way to go. PHP started its life as a templating language, and then purely procedural language. It implemented OO and continued to add OO features for a reason. Are you suggesting you are smarter than the masterminds of PHP community? Also 30 years of programming experience, doesnt necessarily make you a competent programmer. I've seen someone like Tony Marston who had 30+ years of experience and still failed to understand the basic concept of abstraction. So stop acting you are superior for your 30 years of experience that worth little to nothing. 
Care to expand on why?
Op was not presenting a reason not to unit test though... 
Id suggest the name FIR - Framework Interop Reloaded. Seriously, by then we would have 2 standards body. Reminds me of an xkcd comic on how standards proliferate.
It's maybe worth looking at https://github.com/phalcon/zephir which tries to make writing PHP extensions easy and allows you to write PHP-like code instead of C. 
Totally agree, I find that even the most lightweight frameworks start off from some rather weird approaches that put off most new people, or even veterans that are just looking for a little skeleton framework and functions so he/she doesn't have to reinvent the wheel on every project. I have been put off so many frameworks that I actually use my own. And I find it huge and complicated lol. I am currently trying to make another framework that is **really** lightweight, and instead of requiring 10 lines of arguably not-so-easy code (like every single framework says, like "learn this framework in only 30 minutes"), it actually is one request and then you write your own code. I hate how most frameworks just **add** complexity and new knowledge, instead of optimizing PHP for you.
Probably worth looking at how to build an object oriented extension rather than a simple function. All the newer PHP APIs are object oriented. 
Took me quite some time to start working with OO, and when I did, I liked it, but yes, I must confess that the reason it took me some time to get into OO still persists in my mind: it adds overhead, it is slower, and a lot, **I DO MEAN A LOT** of people overuse OO so much it gets sick. I worked in a company once where **I swear to god** they implemented stuff with so many objects that when I quit one of the reasons were "before you implement a class for letters". They had a pool system in which every option of a pool were an object, the pools were objects, collections of pools, and an object for answers, and sure enough an object for a "answered item" in the pool and .. God! **and they had no clue why their basic CMS-thingy was slowing down to a halt on a dedicated 16 core xeon machine** So, yes OO is awesome, but when used wisely, and if you see too many objects, it is time to start thinking about scaling down. For simple stuff, just ditch OO, you don't need 8 objects to write "hello world".
Seems good.
Zend Expressive. Why ? : * PSR-7 * Use any DI containers. ( Aura.Di, Pimple, Zend Service Manager ... ) * Use any router ( Aura.Router, FastRoute, Zend-Mvc .. ) * Use any templating engine ( Plates, Twig, Zend-View, Mustache ) * Like other frameworks you can choose any other libraries via composer. Integrate Aura.Auth, Cake.Orm , League/Oauth etc.
&gt; no that's just you not knowing all the things you should know. Well, that is just ridiculous. It is because Php is a toy language, that I have to know these weird edge cases. And the more I see people defend these things, the more I lose respect for people using Php.. &gt;and you can't really call php a toy considering that a large portion of Web is based on it. Even php developers consider earlier versions (4, 5 &lt; 5.3 or so) of Php as a shitty language. But even then a lot of web apps were being created in these versions. So the point is, running large portion of Web does not mean that the language is not shitty. A probably reason can be people are more concerned about convenience and cheap availability of devs than using something good.
I don't wanna be mean... But: Uff. :-(
TL;DR Committees! Get ready for a lot of camels.
Fat-Free framework. Or Codeigniter 2/3. Or you could take your time to learn a more modern framework like Laravel 5 or Symfony 3
From a quick glance, a few pointers: * Windows users are going to be sad, because there is no `config.w32` * Don't include `PHP_FUNCTION(hello_world);` in the header. Note that this is basically your "public" header, while `PHP_FUNCTION`s are generally an implementation detail. * Instead of `{ NULL, NULL, NULL }` use `PHP_FE_END`. Ensures forward-compatibility if the structure changes. * It is customary to put the `ZEND_GET_MODULE` behind an `#ifdef COMPILE_DL_EXTNAME` guard (though not doing so should not actively break anything) * The header is missing something like this (this is required to support a static build of the extension): extern zend_module_entry extname_module_entry; #define phpext_extname_ptr &amp;extname_module_entry Another good starting point for creating an extension is ext/ext_skel, which generates the necessary boilerplate.
That unfortunately doesn't work with PHP 7 yet.
This is just a hello world, I will be moving onto objects of various types in later ones as I learn more about them. This for me is mainly a learning exercise whilst trying to document what I learn
Thank you.
Thanks for that. I did try on the vagrant machine to run `ext/ext_skel` but it didn't work. I can't remember why, but it certainly didn't do what I expected it to. Also, in terms of the config.w32, is that the same structure as config.m4 or is there something different involved there? I have no windows machines capable of testing this on unfortunately. The only official PHP documentation I could find uses `{NULL, NULL, NULL}, perhaps that could be updated? It does say it is up to date as of PHP 5.3.3, so perhaps the entire section can be updated? Please could you explain what this means: `#ifdef COMPILE_DL_EXTNAME` Also, what is the difference between static and shared extensions? Is a static extension something compiled into the php build, and shared something like xdebug which you can install afterwards, if so, whats the benefit of static? As I write more of these, would you mind if I were to email you a link for a quick proof read, since this is obviously very helpful to me, and will help me provide better posts for other people. Thanks 
What frameworks do guys use and what software are you using to power your tests?
You could think of unit tests as acceptance criterias for your objects/functions. The smallest part of your application. Then integration tests checks that multiple parts are working well. When dev try to use TDD first time usually they facing several common problems: - People don't understand difference between unit and integration tests (for example testing your API using HTTP is not an unit test). Especially in Laravel comunity people often like to "rename things". - People don't understand that tests should be separated from implementation as much as possible (this is really hard by the way, especially when beginners mocks everything). This leads to simple problem - tests are tightly coupled to implementation and brings more pain than profit. I recommend you this video to see some tricks on "how to make your test not to be painful": https://www.youtube.com/watch?v=URSWYvyc42M - TDD doesn't fit for all devs, some of the them more like to write simple prototypes and examples. This is not really something different from TDD, but just a small workflow change. Is is very useful in JS world, where you always have interactive console and you don't need to write tests suite to write examples. After all things working - you could just copy examples into test sute. - TDD is about reducing feedback loop. If your test suite doesn't reduce feedback loop or tests brings you pain and fear - than this is just useless test suite. Also read Kent Back's book about TDD and XP. This is really useful. Also just write more tests) In some point if you will think what you are doing, you will fill that tests doesn't bring any additional overhead to your dev time.
i thought the OP was asking about how to determine what the unit tests should test. i gave them a simple way to determine this
Instead of diving into a framework consider reading: http://symfony.com/doc/current/introduction/from_flat_php_to_symfony2.html Might give you a better idea of how things fit together. This is also very useful: http://symfony.com/doc/current/introduction/http_fundamentals.html 
IMO FIG should just close up shop. We have a way to auto load code and share it via Composer. Everything else can be decided in the free market of competition. If two projects want to define a shared interface for some functionality they can easily do it without the FIG.
The FIG has done amazing work. The opportunity to do amazing work on the lower level interoperability has been taken advantage of though. Now, they are getting into less clear territory. Frankly I would rather the group be very very selective. Steward and champion what they've done in terms of guidelines and low level interoperability and only take on other stuff when there is a clear need. I just don't think they have a clear way to do that, and it's a challenging thing to do in the first place.
Certainly. A beuracuacy is a system of communication and it has degenerate forms like other systems and vice versa. A framework and the FIG itself was a form of beuracuacy as they codify a system of it intercommunication. Now, the FIG is in less clear territory and they want to layer onto themselves when they should probably just be more selective.
I will! Thanks! :)
Thanks Paul. Have been away from reddit for a while and just noticed this.
&gt; increase diversity of thought, background and culture ... in a dignified, cautious and respectful manner Hear, hear. And, one might add, with an eye towards actually *solving problems* instead of attempts to establish social dominance.
lol, I went to the link before reading your comment and I thought WTH? how can something so simple be so complex? why did they post this here? I was really lost until I realized that yes, it was meant to show the train wreck xD
Uhh closures have been supported since PHP 5.3.0 which came out in 2009...
I really don't get this attitude. Nobody is telling anybody what to do. Your "free market" product can do, quite frankly (and not trying to be rude), what the fuck it wants. If more than one project wants to get together to work out some shared conventions, then how can you tell them that they should not in the same breath as "free market of competition"? People who are not interested in the FIG - for whatever reasons - can simply ignore them. And that is perfectly fine. Or am I missing something here?
Two projects don't need the FIG in order to work together. One maintainer e-mails the other and says "hey, do you want to create an interface to share some stuff?". PHP doesn't need "PHP Pixie" voting on its "standards".
Good thoughts to consider. Thanks.
Amazing work by the PHP internals, congratulations. PHP 7.1 is getting closer to stable release now. 
Programming has to be the only industry where it's even questionable whether you should act civil and professional.
Most web apps nowadays aren't created on such old versions. The only reason older versions dominate the market is because of legacy code and using outdated frameworks/packages/plugins, and also because of dropped support/updates.
These 12 people will do a vote on whether all formalities were respected and complaints heard etc. They do not have autoritative power to enact a PSR directly. Ultimately the actual working group has to approve it too. And without that these 12 people won't even be able to make it pass.
It does, phalcon 3 works on php 7 too.
I still can't see it, but I accept that may well be what the intent was and that it's my comprehension or interpretation of what was written that may be at fault... I need more unit tests lol
I can say one thing - people have to read the fucking manual on the language, and re-read it every few years, regardless of their position, experience or years in the craft. Regardless of the language or technology they are working on. If you are not doing that, you get complaisant and it ends up biting you in the ass. Sometimes with bad consequences. 
It's all good. As far as I'm concerned, you almost cannot test enough. IMO the easiest case is to test when things go right. That's why I suggested the OP look for what would be catastrophic at any point in his code and create unit tests to make those things happen.
That's the issue right there. You have to read the manual. Period. It's not big. You will be done in an hour or two, refreshed with the ins and outs, and actually learning quite a few useful things about PHP.
On balance, it is better for non-experts to post their code and to get a deluge of critical feedback, than to hide it and not be aware of the number of problems it has. 
&gt; Instead of appeals to authority, why don't you explain why you think it's bad? Instead of making claims that I've not offered explanations, why don't you read what I have said? I'll say it again: &gt; The FIG 3.0 proposal is a fine idea for a *new and different* organization under a *new and different* name. Let it be free of the history and accomplishments (and baggage) of the FIG, and build a following of its own through its own new accomplishments. Now, instead of merely critiquing a critique, perhaps you should offer *your* reasons why it is a "good" idea.
Right thank you for the precisions. I'm more worried if those 12 people do not consider a PSR as "interesting" from their POV and vote it off after it has been worked and agreed upon by projects.
Wordpress seems to fit the bill from your description. I too am a bit inexperienced with frameworks and have pushed Wordpress probably too far sometimes. But it is a fantastic base camp, if you will, for a whole host of projects.
&gt; Things like Python are slow because it's dynamic capabilities vastly surpass that of Php... For example? I'll be shocked to hear of Python doing something PHP or JavaScript can't do (and JavaScript is much faster than both Python and PHP). Dynamic capabilities are not the cause of Python's performance, that's just an excuse. The reason Python is slow is because there's no one in the community with the right combination of will and skills who can improve the engine.
Just convention, you could name it `--do-whatever-i-dont-care` if you wanted :)
ah okay, thats good to know :) Quick question about how the `if test "$PHP_HELLO" != "no"; then` thing works. Im assuming that because my extension is called `hello`, that the name is derived from this. Is that correct? 
Performance wise is it worse than Docker or a VM? Or just worse than native? 
I understand what you mean. I wouldn't want this to be removed either, but PHP is not only a language, but also a platform - and any platform should have as little underlying-platform-specific behaviour as possible, even more so with functions which I can't use if I want to support as many users as possible. If I had the expertise to create a polyfill, I definitely would, but I am lacking the experience in C. Might be worth picking up sometime though... All I really meant was that just because there are alternatives (e. g. C#) doesn't mean we should allow platform-dependent functions to exist as long as there's a reasonable alternative.
I've adjusted my comment.
Thanks. I also wrote a small intro the day it was officially released: https://ayesh.me/ubuntu-bash-windows-10-wsl &lt;/shamelessselfpromotion&gt; One good thing about it is that the entire network stack is shared. It wouldn't cut for a permanent server, but could be helpful to run some quick tasks that Windows is notoriously failing at. Have you had any luck integrating the bash.exe with Console2, cmder, etc?
Yes, but i started using closures only 2 years ago. I dont remember exactly, but i think it took my company some time to switch to php 5.3, still does not explain why i only started using them 2 years ago, i think i just didnt know about them.
Interesting article. Wrong subreddit.
Interesting...seeing test failures on one of my projects for beta 2 that didn't happen on beta 1. The failures seem to be related to the Symfony YAML component. Anyone else notice anything weird with this release with the Symfony YAML component? Haven't had a chance to dig into it yet. Seems to be causing a segmentation fault.
I haven't spotted anything, so any information you can give on that would be great!
&gt; And the solution is so easy... escape everything. ["escaping" is too vague term to be used](https://phpdelusions.net/sql_injection#vocabulary). The discussion below is spawned solely by its essential ambiguousness. And when it suggests one of PHP's escaping functions it's plainly wrong. In short, any layman taking your suggestion literally ("escape everything") will expose themselves to SQL injection for sure. &gt; Detecting injection is easy, Detecting injection has absolutely nothing to do with protecting from it. Even if you detect not 90% but 99%, it won't help you. There are injections that involve not a single quote at all.
Only if not defined in such blunt terms like "escape everything".
php -a I never use a repl much and to test something simple this is enough for me.
Please do not use the term "escaping" in relation to SQL injections. It led to so many disasters already. And to this very argument, mind you ;)
Your article is too weak to be of any real help. The main points of improvement are: 1. Try to avoid ambiguous statements. What you were trying to say in the "How does it affect different frameworks" section? What practical advise anyone is supposed to take from it? 2. Try to learn some exceptional cases, like adding identifiers to the query. 3. Get more experience with the practices you recommend. 4. Stop promoting that scary tale about "unreal prepared statements".
It would be nice if there was some sort of demo to try it out for the lazy like me ;)
1. Prepared statements is not a silver bullet. There are cases when they are useless. 2. Calling prepared statements equal to escaping is too much a stretch. Prepared statement is a certain and unambiguous term, that warrants a protection (when applicable), while whatever "escaping" will lead to millions of injections. 
My English will improve over time, but you will remain too narrow minded forever, obsessed with an idea of helping babies, unable to understand that such a "baby" is not posting to learn but posting to teach. And the harm from multitude of such "teachers" is enormous.
Honestly, your ideas are a disaster. First you started talking of "escaping everything". See, you need excuses for this statement, "I didn't mean this, I didn't mean that". But if your statement needs an excuse, it's unreliable. That's what you've been told and there is nothing to argue about. Just admit that. But your excuses led you to even worse statements like "parsing the variable to ensure" something. Honestly, no sane measure ever "parse" anything to "ensure" anything. A layman trying to implement what you said will end up hunting for stupid things like single quotes or the word "union". Please watch what you are talking about. I've no doubts you are a professional and your code is secure. **But the wording is essential!** Neither "escaping" nor "parsing" will help anyone. Please call a cat a cat. If you mean "prepared statements" - than say exactly that term. If you mean anything else, then use non-ambiguous wording and describe **practical** measures that anyone can use.
&gt; if the user name have quotes or semi-colons Poor Patty O'Malley :(
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
{ halfercode gives colshrapnel a **big warm friendly hug** to cheer him up } `:-p` `:-)` `xx` 
Isn't the reflection api what you're meant to use to 'parse' php source code - your approach seems error prone ? https://github.com/JunkyPic/php-pretty-print/blob/master/src/JunkyPic/PhpPrettyPrint/PhpPrettyPrint.php#L63 
I appreciate the hypocrisy when you are hugging with one arm and writing a report to the mods with another, mr. self-appointed Angel.
We started PHP course for online students, we will upload 1 article for php on dailybase.
It's just not practical to use GUI to connect to terminal when you can do it directly from terminal
you could try to use netbeans, bit I'm not sure how it works with php, or install some plugins in sublime text to get close to an ide.
try https://atom.io/ :)
I used Netbeans before switching to PhpStorm. It's not nearly as nice as PhpStorm (which is totally worth the price IMO), but for very basic development it's fine.
I dont mind getting rid of WHM and going down the second option you pointed out but what takes WHM's place? How are new accounts/bandwidth limits, etc. set? Without knowing the terminology searching "NGINX admin panel" for the most part brings up the hybrid solution i am working with now. 
SSH and your favorite text editor. I guess it depends on how many sites you have and how comfortable you are with *nix command line. It's just as good a time as any to learn. I generally do a single site per VM, have a Linux user used for running the site on (php-fpm and file ownership etc). If you need bandwidth limits you can either restrict the throughput in nginx configuration and have no threshold it can exceed. If there's a threshold it needs to exceed, a 3rd party product/script would need to analyse the usage from the logs and mark it offline when it's exceeded. ADD I think http://ajenti.org/ will work with nginx. I had worked with a customer years ago on an nginx control panel and I *think* this is what we used, but it's been a while =P
Got you. A hug of Halfer is the same as a kiss of Judas. 
(Responding now to your edited version.) &gt; You haven't actually explained why in this thread. My explanation from the FIG thread [is quoted above](https://www.reddit.com/r/PHP/comments/4wd8kt/the_tldr_of_fig_30/d66c2me), and attributed to me. Either you read it and ignored it, or read it and dismissed it, or you *didn't* read it and are now trying to backtrack on your mistake. &gt; I certainly don't want to be patronised by you. Nor I by you, as you attempted to do by opening the conversation the way you did. Since you're now apparently trying to give me advice, I'll give you some in return. My conversational habits tend towards "mirroring". That is, if you start with a particular attitude, I will respond in that same attitude, sometimes in a slightly stronger way. So if you begin by "trying to teach me something", I will teach you something in return. If you open with accusations, I will respond with accusations. If instead you speak deference and respect, you will get back deference and respect. Or if you begin with a willingness to learn, then I too will show a willingness to learn. It really is all up to you.
&gt;Prepared statements is not a silver bullet. There are cases when they are useless. No, but when done correctly is provides guarantees that no data being put in a statement will be interprerable as a directive or otherwise as non-data. That's all it's meant to do. &gt;Calling prepared statements equal to escaping is too much a stretch. Well they can be more if they want to given they should have all the context of the whole query, but the gist of them security-wise is to know enough about the database (SQL dialect, current charset in use, etc.) and the variables being injected into the query to provide the appropriate form of escaping. &gt;Prepared statement is a certain and unambiguous term, that warrants a protection (when applicable), while whatever "escaping" will lead to millions of injections. It's not ambiguous, it's just abstract. It's a more general team: it applies and is used in far more situations. In some situations a more naive escape strategy may be insufficient because of the nature of the context the data will be put in - it may be you need something akin to a statement builder or pre-parser to ensure the entire statement matches the desired meaning. But in SQL it's not so difficult: If you want to put a variable into a statement as a literal value just make sure no tokens exist in it that will cause the SQL parser to believe that token has ended prematurely. If you approach it using a silly system like: "SELECT * FROM users WHERE password = " . escape_string_for_sql($_POST['userpass']) . " AND id = " . escape_int_for_sql(6); Then sure it's very error-prone because people are bad at ensuring consistent use of the correct escaping strategy by hand, and it's hard to see errors after the fact by reading the code. So you make a system something like $sql = "SELECT * FROM users WHERE password = :pass AND id = :id"; $cursor-&gt;execute($sql, ["id" =&gt; 6, "pass" =&gt; $_POST['userpass']]); The advantage here is that since the cursor call can investigate the values you send it you don't need to personally choose the right escaping strategy for, say, a string vs an integer. It can even parse the SQL before/after and ensure that, after insertion, the statement as a whole still matches the same grammatical structure as the original to ensure no emergent alteration in meaning from multiple insertions. These are all things you can do manually using well made escape functions, it's just more error-prone and a hassle. So systems were made to make it easier, less error-prone and more readable. Incidentally the escaping strategy for inserting literal text into an HTML document is very simple and not context-laden, hence why you don't see many prepared statements for HTML snippets and why most/all templating engines that offer to auto-escape or handle escaping in-template only run the output through a pretty simple escaping function for HTML literal values.
I'm not sure what you are arguing with. People like to do things the way they are used to.
&gt; It's not ambiguous, it's just abstract. It's way too abstract to be of any practical use. Besides, the name incidentally suggests *whatever_escape_string* and therefore should be avoided at any cost. 
Once again, the repository pattern precludes a generic set of operations or a fixed implementation. It should start with an *interface*, and contain only the operations an app needs, nothing else. So saying "repository pattern right from the start" betrays misunderstanding of what the repository is, at least in DDD where that pattern comes from. What you have instead is more aptly named a table gateway, a mapper, a DAL. But not a repository. 
For deployment I would just put the restarting in your deployment process, for development I would use a filewatcher there are several out there gulp is not a bad choice for that.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Honestly, that is greatly exaggerated. NetBeans is definitely a usable IDE for PHP development. In general, both IDEs arenâ€™t as different as many people make it sound.
Not too worried about production just yet, still just playing around for now :) As I said in my OP, I'm not sure if gulp is an elegant solution. Is there a specific package you can recommend that I've missed? How do you suggest I handle stopping and restarting the process, and making sure the output still comes through to the console. There doesn't seem to be a precedent that I can find for long running processes like this?
PM2 (node.js land) works for php too. It can be setup to auto restart the process via the --watch parameter
The problem is the interface: - https://github.com/PHPRepository/repository/blob/master/src/Domain/Model/Repository/Contracts/Repository.php - https://github.com/PHPRepository/repository/blob/master/src/Domain/Model/Repository/Contracts/ReadRepository.php Maybe I need only this: interface UserRepository { public function add(User $user); public function findSatisfiedBy(Specification $spec); } And some other entity requires different repository interface (since it different entity). Also I pretty much don't like that your interfaces located in `Domain\Model` repository even if it just part of infrastructure, you don't know anything about MY domain. So this is more like table gateway + data mapper than "repository" itself. This is not bad, this is just "different". Different purpose. "Light" replacement of Doctrine if you want but this is NOT repository implementation.
To be fair, I haven't used NetBeans in a couple years, so I'm unaware of any improvements they may have added. At the time when I made the switch, PhpStorm simply had more/better features that I as a power user appreciated.
It doesn't suggest that your language/library has to exclusively provide functions to escape strings to the programmer to enable proper escaping at all, it doesn't suggest any implementation. You should also use TLS for any socket connection over the public internet sending sensitive information or requiring any verification of identity. That doesn't suggest that `start_tls($socket)` needs to exist, it's just a description of something that should be done in some way. In fact PHP is fairly alone in implementing it in the `escape_string` thing; most languages consider such things outside their scope and it's up to libraries to provide appropriate escaping mechanisms for what they do.
Or... slam it in a docker container, then let the infrastructure itself run it? Most docker-friendly-ish deployment systems keep your containers alive. Thinking about Heroku, Amazon ECS, etc... Locally, it would be a `docker-compose kill` + `docker-compose up` while developing (plus you can decide what has to happen if a container dies). I know it sounds like an additional layer of indirection, but it really works cross-platform this way...
Good suggestion, thanks. I just installed it and ran some quick testing, seems promising. I do have a weird issue though: For some reason the php process pm2 is handling seems to be a bit unstable (for want of a better description). If I refresh a the client page I can only connect every 4th or 5th time to the server process. I'm sure there is a config or something I need to tweak, but if you have any insight that would be appreciated :)
Using Netbeans for more than a year. Maybe Phpstorm has super features that i'm not aware of, but Netbeans has everything i need - xdebug, refa torings, code completion, composer, bower, npm, git integration etc. It's working fast as long you dont keep 20 projects open at the same time. Small tip: theres Obsidian theme that makes al UI dark, looks great.
Ok, got you. You're a kind that can rant on any subject for hours, without any relation to the previous discussion and without any practical application. Keep on.
I'm using the Homestead VM, mainly because it comes with all the basics setup with sane defaults. This is just a toy project I am playing with, mainly to try out Rachet and how it compares to nodejs + socketio, so I'm not sure I'm keen to setup an entire docker layer. But on the flip side, might be nice to make an effort to actually play with some docker stuff too, haha :)
&gt; How would you propose that be implemented exactly? What? I'm not sure you understood what I said. I wrote, "_**If**_ it were that easy, then the database authors would simply..." which means that I think it's NOT that easy. So you and I are saying the same thing, right? It's as if I said, "it can't be implemented", and you respond, "oh yeah? well how would you implement it?" I would normally ask if you even read what I wrote... but you quoted what I wrote... so maybe we're just speaking different dialects of English? I'm confused. Am I missing something?
Netbeans
Have to agree with this I switched back to netbeans from PHPstorm 2 years ago when I changed jobs and there is nothing that PHPstorm does in my daily workflow that Netbeans can't
&gt; If it ain't broke, don't fix it. That sounds great until you need to maintain/extend it. I've inherited a collection of utility scripts written between the mid 90s to ~2010 mostly written in Perl. These scripts are responsible for automating and verifying various steps in integrated circuit design (IC layout, design rule check verification, archiving, etc.) Some of these scripts have the potential to cost many tens of thousands of dollars if they do not work correctly. These scripts were also written by folks who were electrical engineers first and programmers second. It is impossible for me, with the code in it's current state, to implement a change/addition request with any level of confidence in a non-trivial amount of time. * Globals EVERYWHERE * No scope usage * Abuse/lack of understanding of weak typing * Fun sections that work accidentally instead of intentionally * No tolerance for unexpected return values when calling shell utilities * No tests whatsoever * No easy way to verify that scripts behave consistently in the various environments in which they will be run * No real documentation * No code or naming convention(e.g. ```$v```, ```$v_chk```, ``` $ver ```, ``` $verCheck ```, ``` $versionCheck ``` all represent the same thing in different context) * It's all WET(write everything twice). You can find 100 line chunks that are copy and pasted with one string changed in the same file and across multiple scripts. There are dozens of versions of many methods that should be consolidated as part of a module There's more but you get the idea. These scripts aren't broken, but there is so much overhead, uncertainty, and risk involved in working on them that they do need to be fixed. There are tons of very beneficial features/changes/additions that simply can't be reasonably made due to this technical debt. Disclaimer: To be clear I'm not shit talking the people who wrote these scripts. This company grew quickly and they made changes/enhancements as they needed over many years. I give them serious credit for learning as much as they did. 
It is easier if you start the process in your dev / watch task and restart it when the files change.
I perfectly know that for 99% it won't hit even 10 stars on github. Still I think it will be valuable for the community because there is lack of good examples of Phalcon 2+ usage. I've already created 2 usefull phalcon driven websites one of which is used internally at my company tested by a few serniors agsist security and tens of users for it's functionality and I think that I'm ready to public some code that will solve problems I was struggling with like year ago. That's why I am not saying it's gonna be perfect CMS and WP greatest competetitor. It's gonna be a fun, learning project and I'm just asking for best solution in order not to start with big mistakes from the beginning. 
Was the xdebug configuration the only reason you were not thrilled? Because while the suggested netbeams/eclipse are excellent alternatives, they all work pretty much the same for day to day development. 
When xdebug isn't working, if you are on windows it is usually you blocked it by accident. Go to firewall then advanced and find phpstorm. Personally I love phpstorm. Way better than any other thing I've tried. 
Thanks, I will surely take a look at it
&gt; My explanation from the FIG thread is quoted above, and attributed to me Ah, there's the problem. I didn't read that. &gt; Nor I by you, as you attempted to do by opening the conversation the way you did. It does appear you suffixed 'The authors of FIG 3.0 are attempting to broaden that scope to "all of PHP-land"' with 'As a founding member and the lead on PSR-1, PSR-2, and PSR-4, I think that is unwise, and to be opposed.' "Fallacious argument" and "Appeals to authority" are names of this type of argument. Unless the use of them is rude, incorrect or just mean, I don't see how my initial comment could be seen as patronising. I do concede that, whether in this thread (via someone else's quote), or on the mailing list, I missed your reason. It's possible that, while I didn't mean to offend you or that you may have felt I was being patronising. That was not my intention. I apologise if that's the case. I did (and still kinda do) desire some kind of understanding of your reservations. I'm also baffled why you need this confrontational style when speaking to me. I feel like I always have to point out that I'm not trying to be your enemy and that I respect a lot of what you do (even if I don't share all your views).
Well you can just use Nikita Popov's scalar objects extension, this will not only give you object oriented string, but also object oriented array, number and any scalar types you want: https://github.com/nikic/scalar_objects
Blogging about Phalcon or starting an example project is probably a better way to give back to the community.
&gt; Ah, there's the problem. I didn't read that. Noted. In future, you may want to check that your assertions are not easily disprovable. &gt; I'm also baffled why you need this confrontational style when speaking to me. When you open with confrontation, I respond with confrontation. Try opening with respect and deference, and you'll get back respect and deference. &gt; "As a founding member and the lead on PSR-1, PSR-2, and PSR-4" I said that in the spirit of "full disclosure." Not everyone reading this is aware of my history with the group.
I never used PuTTY but rather the OpenSSH client that is built in with Git for Windows. The only thing I do use is Pageant for key management because the ssh-agent is a pain. There is a complete page dedicated to explaining all of this in detail now so anyone can easily get started with this. https://github.com/git-for-windows/git/wiki/OpenSSH-Integration-with-Pageant Hint: if you use the latest nightly of PuTTY/Pageant you'll get Ed25519 support.
That's nice, thx!
&gt; `ucfirst($this-&gt;string)` This won't work for any characters outside ascii/english. Before rolling your own class, please at the very least take a look at [Java](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) and [C#](https://msdn.microsoft.com/en-us/library/system.string\(v=vs.110\).aspx) string APIs, and then at [Go strings package](https://golang.org/pkg/strings/) and [why](https://blog.golang.org/strings) it's similar to PHP way of handling strings. In addition to raw string data, a string object must hold metadata about current encoding, normalization form, collation and locale used in all transforms. In PHP, these would be handled by `mb_*` functions and the Intl extension, specifically it's `Collator`, `Locale`, `Normalizer`, `IntlBreakIterator`, and `IntlChar` classes. No way you just borrow method names from Laravel's Str helper sans the static keyword, wrap it in a class and call it a day. Which, btw, uses mostly correct `mb_*` functions, if only you tried to read it's source.
I don't have my own blog but still... I do :) http://www.polcode.com/phalcon-a-no-compromises-framework-2/
Not to well(I think), no collapse option, so it will probably murder your browser(no cli option yet). But as far as I can tell it doesn't have any hickups, then again not a lot of people use it, I'm sure it has bugs. Honestly I haven't tried it. Made it mostly for fun, but I guess I could test it out. It's not very mark-up heavy so it should be ok-ish overall.
Huh, well, would you look at that. I guess there aren't too many options when it comes to this.
I've been enjoying Codeception for a few years now. Have you tried it?
In my shop we call this sort of exclusive lock code a "Highlander". You know. "There can be only one".
That previous discussion's link appears to link to "search" rather than PHP content.
I havent run benchmark on that, but I have a website using scalar objects extension in a PHP 7 production server, and it doesnt give me any performance related issues thus far. There are some userland implementation for scalar objects extensions on github, the most famous one was by Ross Riley but it was for an older version of Scalar Objects and not PHP 7 compatible. I build one myself(apparently for the live site I build), but havent added documentation or unit test yet. If you want links to the libraries, I can send them to you in a private message, since I dont want to distract other users here with irrelevant links. 
Looks pretty nice, shame about the unprofessional license.
There is no difference *in the context of SQL injection protection.* Your silly attempts to catch a script-kiddie running an automated penetration tool are ridiculous. Can't you find yourself any other occupation? 
Your double-faced behavior is causing me emotional hurt. So please keep on slandering me, but leave me alone with your sermons.
I miss when we used to argue over the date.
lol wrong subreddit?
~~I used to prefer this to spl types, but the spl types work well with numeric operations...~~ Edit: I was confused. And a little silly.
the logs should capture errors and debugging (print_r) messages you will output; do: "pm2 logs" 
to make things clear I know DI, SOLID, OOP design, I am trying my best to keep my new codes to follow solid since I read about solid a year ago. But for legacy codes we all know. :P
How does it compare with https://github.com/hoaproject/Ustring?
Concise 1.x used the latter. It looked like this: $this-&gt;assert($obj, has_property, 'foo', with_value, 'bar'); https://github.com/elliotchance/concise/blob/v1.7.3/tests/Concise/Matcher/HasPropertyWithValueTest.php#L30-L35 However, this turned out to be much less flexible (since there is no useable code completion), it also broke a lot of rules with PSR standards and looked far too alien. Concise 2.x went with a must more BDD like syntax that people are used to using with frameworks like jasmine, rspec, etc.
&gt; This is what also the developers at Zend thought until they discovered it's not right and moved to prepared statement :) I can't make a statement so vague even if I tried. What did developers at Zend find? What does it mean "it's not right"? Any source? &gt; even when using prepared statements one needs to be aware of what he is doing because there are a few exception when PDO will not help you Ok, vague statements continue. There are "a few exceptions". Like what? 
PHP is an entry level language with a curve: easy to learn, hard to master. You won't make these mistakes in Python because Python won't let you. Because Python is strict. People write code in languages they don't fully understand, people drive on unknown roads -- everything's a 'danger' when you're not familiar with the task at hand.
I seriously can't see the point in this at all? Why would you want all the great Linux commands yet run it on an expensive, vulnerable bag of shit? If you want all the Linux goodness then just use Linux?
Question from a naive person: I really like this ext, but is there a reason why it can't become a part of PHP 7.x, 8?
Typo: "It call it, The Stringler. It does a bunch of handy stuff." &gt; It call it
HeidiSQL
s/think twice/not use Any professional/serious company will reject a licence like this one, and go for a standard/usual one, especially for non-compiled binaries.
Navicat, but since it's not free and my Boss does not like to pay for Software, I'm have to use HeidiSQL. The operation of the system is difficult to get used to, what does not have to be a problem. There are many features implemented to prevent accidental modifying of data.
I am trying out HeidiSQL atm, but will probably switch back to MySQL Workbench, since I consider HeidiSQL nagware (there are blinking elements that won't go away until you donate, I can't work with that), so I guess my answer would be MySQL Workbench for the time being.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What seems pretty straight-forward to you is most probably the opposite in court.
Navicat. Favorite is probably pushing it too hard, it's not perfect. But it does the job way better than PHPMyAdmin. It also supports SQLite, which Heidi doesn't.
SQLYog Community Edition. Absolutely love it's simplicity. 
if you use it like that it's idd worse...
I am constantly refactoring my code and it's a lot better for it. There is no legacy that I'm afraid to touch because it might send a metal plate into the wall.
Those search results look terrible too.
I've discovered DB Forge through work this year and I like it a lot!
This. `git clone` straight into my public dev directory. 
+1 for HeidiSQL. I've been using it for the past 4 years or so, and it is wonderful.
SQLYOG ... https://www.webyog.com/product/sqlyog It's a bit pricy, but meh i love it.
My fear is that we are creating more room for backroom politics.
Finding out that there is no OSX version of SQLYog was the most disappointing moment of switching. You can use it with Wine if you really want it, but the shortcuts didn't feel right because it always wanted control instead of command.
No, if you have PHPStorm you have the exact same features as DataGrip; DataGrip is just a standalone of their database module. I'm not sure which of the other IDEs from JetBrains comes with it.
[removed]
Small update on this topic. Starting from build 5.25.0+build-2374 (Nightly currently) there is [an option to disable Web Components support](https://github.com/nazar-pc/CleverStyle-Framework/issues/42) within framework entirely (polyfills, Polymer and its behaviors, HTML imports). So now you can avoid Polymer overhead entirely if you don't use it.
http://i.imgur.com/GUrv6ss.jpg
use the EAPs they are free
 &gt;&gt; There is an ongoing question if the FIG produces PSRs for member projects or for the wider community; especially when the wider community pays it so much attention due to its de-facto status as â€˜the php standards bodyâ€™. &gt; Each *-interop project can define for itself the audience it addresses. As an outsider, the fact that FIG is in fact the "PHP Standards Body" is the biggest advantage of FIG. The fact that any recomendation I make that's backed by a PSR (Force all code to be PSR-2, encourage a migration to PSR-7, type hint against PSR-3 instead of relying on Monolog) adds a lot of weight to it. Frankly, if FIG wasn't the standard, I don't think it'd be very relevant at all in the first place
+1, HeidiSQL is like the sublime text of mysql clients
&gt; backed by a PSR (Force all code to be PSR-2, encourage a migration to PSR-7, type hint against PSR-3 instead of relying on Monolog) adds a lot of weight to it. That's not the right way to use a standard. It's for adding interoperability, not for adding credibility. At least the way I understand the phrase "adds a lot of weight to it". You may want to clarify.
you can with PuTTY/plink
[Devart dbForge Studio for MySQL](https://www.devart.com/dbforge/mysql/studio/) works pretty good, though they make you pay a subscription once a year to keep getting the updates.
It decodes to this: http://pastebin.com/qYFeHHbC
Have you tried disabling autocommit and then commit manually?
Seems like it is an auto-updating backdoor. PM me the domain you found it on, and I'll be happy to poke at the tarball they have for your server.
i've been using phpmyadmin imma write this stuff down
Yep, without doubt. We also use Microsoft SQL Server and PostgreSQL, both of which is supported by HeidiSQL alongside MySQL, so it's a win-win-win for us. Excellent app, has never given us issue. We have donated to show our appreciation
I gave phpspec a try and found it neat, but the context of '$this' was a little odd, added a bit more cognitive overhead than I prefer. 
I have already uninstalled it now after having learned about alternatives in this thread. Yes, HeidiSQL seemed like a good, lightweight SQL client that is worth donating to, however I grew frustrated with the constant distractions long before I started appreciating it. While I want to support software I use frequently and enjoy, I don't want to reward software that keeps nagging you non stop until you pay up, regardless of amount.
http://kennycason.com/posts/2016-04-04-wordpress-hack-fix-google-redirects-to-spam.html
It's also worth knowing the reason behind the convention: When you use --with-*, the user is often allowed to specify the path to the dependency. So, for instance, --with-mysql=/usr/lib would tell the configure script to look in /usr/lib for the MySQL libraries. Generally if the user doesn't specify a path (--with-mysql), the configure script will just look in the default path. Fortunately, you won't normally have to think about this - many libraries will provide an M4 file that you can use, which takes care of the details. MySQL's one for example: https://github.com/charliesome/mysql-5.5.36/blob/master/support-files/mysql.m4
I'm not sure if I agree on the matter of credibility and interoperability. More often than not, these two are intertwined in this particular context. PSR2, for example, guarantees no interoperability other than making sure IDEs don't blow up with coding style violations due to multiple styles being used by different libraries within the same project. Which is not really a framework concern, if you think about it. Its pervasiveness, however, brings a great deal of credibility. In my current workplace there was a discussion about coding style. I brought up PSR2, and the main points for adopting it were: 1) Pervasiveness - most people have used it already, so new employees don't need to learn/adapt to a new coding style; 2) We don't need to tell our IDEs to ignore specific vendor folders because most libraries are already PSR2-compliant. We could derive two very objective advantages from the standard credibility/popularity.
SQLYog hands down.
phpmyadmin used to be great, since they ajaxified it its horrible, "adminer" is a solid alternative if you liked the old phpmyadmin more
What are you basing this on? It seems like FUD to me. I work for a F500 company in the real estate industry and we had no problems getting WTFPL licensed code past our ARB and into production, as well as other highly permissive licensed code.
Can we have a nice favicon for our bookmarks? :)
Do you really need to fetch all 20k entries at once? Try using a Do-While statement to fetch paginate the results. You should also consider reducing the number of queries by exposing this logic in the repository layer. BlogRepositoryInterface:findPublished($page, $pageSize);
[Adminer FTW!](https://www.adminer.org/)
&gt; Credibility is very important when it comes to establishing what to actually use for interoperability, though. Sometimes a standard emerges from the ether that can stand on its own merits, but that's more of an exception than a rule. It's popularity and fitness for purpose. Credibility means nothing. Well, I suppose some lean on credibility when they can't judge fitness for purpose. Which is disappointing. Oh, well.
I can never remember where in the menu it is; it's one of the tray toolbars. If it's not in your tray or sidebar already, you can use the search toolbar (double-tap shift), enter "Database" and it should be one of the top results.