[redacted]
The scenario you've presented isn't really applicable. Any outstanding data is written to the session before its lock is up-heaved, which normally happens after the script's finished executing unless you've explicitly called session_write_close or one of its aliases. Meanwhile, any concurrent script is blocked until the lock has been up-heaved. This only causes a problem for concurrent calls, especially so with a keepalive script as it might cause the other scripts to time out before it finishes. This doesn't really apply to the redirect chain. 
I disagree with this in principle. The reason is simple: The fact that an engine can track variables is nice. What we need is the ability for humans to be able to do it. So instead of adding taint, encourage people to put their escaping code as close as possible to the output. So it's 100% clear to see what output is safe and what's not. Instead, this type of functionality enforces "if it doesn't tell me something's wrong, I'm safe!". What I would recommend is having auditable code. That means code that performs escaping as close as possible to the output. That way it's trivial for static analysis or a human to verify "Yup, it's safe". The difficult part is when you spread this functionality all over the place. Then it's nearly impossible to check (human or static), and hence things like taints are required. Encourage good architecture and practice. And things like taints become not necessary. Fix the problem with education, not mediation. Also: where's the URL taint type (for inclusion in a url via urlencode)? And the MAIL_HEADER taint? And the XML taint? And the SOAP taint. And the JSON taint. And the BLAH taint.... etc... **Not to mention they don't work:** this isn't fully possible to do anyway. Example: $sql = "UPDATE users SET isAdmin = 1 WHERE id = " . mysql_real_escape_string($_GET['id']); That would pass the taint check, but is extremely vulnerable to SQLi. The same is true for HTML, and shell, and every context listed. The only thing worse than a broken system, is one that makes you think it isn't broken. **EDIT:** also, there has been no activity on this RFC for nearly 6 years (the last non-formatting change to the RFC was in [July 2008](https://wiki.php.net/rfc/taint?rev=1215475482&amp;do=diff). *holy-old-post-bringer-upper-batman*
So basically, TelVue runs on server A (which I presume to be some sort of scheduling software) and server B runs a webserver that loads the feed from server A. I don't know what your setup is so I can't give any concrete advice but you'd have to parse the xml feed, loop through each item and change the title attribute then display it or whatever it is you do. It also occurred to me that you could remove the timestamp much simpler using substr and strpos: $title = substr($title, 0, strpos($title, " - "));
Apples and oranges... but when Google did this for their tabs, they were the coolest kids on the block.
**Server A:** Broadcast Server (Yes, You're right. It also Schedules) **Server B:** Bulletin Board Server (In between shows, when nothing is scheduled, the Bulletin Board is shown) --- So when the Bulletin Board is up on the channel (Server B), It shows some slides, weather, etc. Across the bottom is a frame that says "Coming up next". We're using an RSS feed hard-coded into Server A to tell Server B whats coming up next on the channel. We cant edit the XML file on Server A. So what we need to do is alter the XML file to drop the timestamp with a substr somehow, then take that "New" XML file and tell Server B to use it. So we're wondering what we have to do to take that XML file on Server A, Modify it, but keep it as an XML File.
Well then if you can't alter the XML on server A, then your only option is to do it on server B.
Fluff piece that wasn't really worth the time to read. You're not going to learn anything new or exciting from it.
All I can tell you is what we experienced, and how we solved it.
Pecl is dependent on/part of Pear and it would really be nice to remove Pear from PHP core. That's not going to be possible to do until there is a replacement mechanism for installing extensions available....even if installing from source seems to be the clearly superior option to me.
And I'm telling you the situation in which it occurs, namely with concurrent scripts. Plain redirects like the scenario OP described does not trigger it.
Yes, but how would I create a new project type that currently doesn't exist?
I think you can add to those by adding new plugins to PHPstorm, but I haven't tried it. 
Lot of info in here just seems wrong. &gt; The last three versions of PHP—5.4, 5.5, and 5.6—are feature-rich which makes PHP even more robust now. Adding features = robust? I couldn't disagree more. I'm not saying I have a problem with PHP adding features. I just don't think that's what "robust" means. Robust, to me, suggests stability and security. &gt; Closures, built-in development server, namespaces and many more exciting features are there. You name it and PHP have it 1. *has* it. 2. Static typing and type hinting? Treating Strings and arrays, etc, as objects? Consistency? Native nullables? A global namespace that isn't cluttered with shit? __toArray()? Tuples? Lamdas? Seriously, there are plenty of features PHP is missing. &gt; As they say numbers don’t lie and in the case of PHP, numbers are its most strong argument. No one says that. What they say is "there are lies, damned lies, and statistics". &gt; Number of PHP developers, number of sites built using PHP, and number of open source projects based on PHP all indicate one thing: PHP remains to be awesome. This absolutely does **not** indicate that. Popularity and quality are outright absolutely not the same thing. People watch Two and a Half Men. People listen to Pitbull *by choice*. This *Argument from Popularity* does nothing and carries no weight. You could rightly argue that PHP's popularity will stop it from going anywhere. You certainly can **not** argue that PHP's popularity will make it good. &gt; Popular websites, like Facebook, QQ, Flipkart, and many more, trust PHP for its server side requirement. And Facebook found it limited enough to extend the language... Because it's got absolutely no missing features! &gt; It is also worth noting that WordPress, the CMS which powers the 20% of online websites, depends on PHP for its functionality. And is a clusterfuck of godawful shit we should be distancing ourselves from, not embracing. It is everything that is **wrong** with PHP, not a good example of its virtues. &gt; powers ~~the~~ 20% of ~~online~~ websites Is there some other kind of website? &gt; Don’t be afraid to use experimental versions of PHP like PHP NG. They are as stable as any of the recently evolved web development language. This is factually untrue. PHP NG is a new direction that the PHP core is taking *internally*. It's not something you can just slot into development now. You're probably referring to Facebook's Hack, an unrelated project. Which I would not really characterise as being as stable as PHP. It's a great direction. But it's still pretty new. Don't get me wrong, I use and like PHP. But we shouldn't be whitewashing its flaws like this, nor should we be ignorant of what it can and should be. Nor, most importantly, should we say dumb shit that's simply wrong.
/me shrugs
I don't think python is the answer to your problem. Learning python will make you a better programmer. Even your PHP will improve a bit, if you don't let it rust. However, you're not likely to improve your logic that way. Instead, you'll learn to use python CMS's in addition to PHP CMS's, and then you'll have more ways to solve the same problems you already know how to solve. The truth is, the kind of logic you seek has very little to do with the language you write it in. There is no easy way to learn it. Studying computer science or math is the most effective way by a long shot, but that might not be compatible with your attention span. An iffier but more realistic approach might be to do a bunch of lateral thinking problems, or even some brain games. That said, learning a second language is a good stepping stone to actual logic - it'll at least get you thinking about some of the right things.
You can just use the composer package for eloquent? https://github.com/illuminate/database
The best Laravel-like ORM *is* Eloquent, Laravel's ORM :)
I did not know that existed. Winner winner, chicken dinner!
Agreed. I was looking into extracting it from Laravel. I didn't know someone had already forked it into its own package
Why don't you start by writing programs for printing triangles in php?
It reminds me of magic quotes. 
&gt; apt-get install libssh2-php That's Debian specific.
That isn't a fork, it *is* Laravel's ORM. Laravel is made up of lots of little packages which are all under the Illuminate namespace. 
Oooh okay. I'm new to the PHP framework scene. I've played around with them, but nothing serious. Pardon my ignorance
Your ignorance is always forgiven at obtaining the knowledge that you were lacking off.
Im going to need to come back to this
Admittedly I've never used php storm, but I have used a dozen other IDEs.... Can it really be that good if it takes 2 hours to explain how to use it?
Nah. Not quite Laravel ORM enough...
Why would I need something like this?
Have to echo this. I understand what it's doing and it's neat but without a practical example I can't really picture why you would want to do it unless you have a ton of places where you're reusing some ArrayAccess logic which I'd again ask why.
This is simply great :)
I use it whenever I need a dictionary of values computed from a data object. This allows me to decouple completely the data from its representation. In particular I am using it in a Rules Engine, where the input values are expected to be \ArrayAccess implementations.
I don't get it. When you're accessing your pseudo-array like this.. $arrayzedNic["full name"]; its crying out to get rid of the flaky string key, and turn it into a constant, like $arrayzedNic[self::FULL_NAME]; But how is this any better than just calling $this-&gt;getFirstName() to begin with? 
Sorry but I don't get the point. What do you mean with "the sake of abstraction"? What do you mean with "doing this all over the place"? This is a library that has a very single responsability: providing a lazy array adapter. If this adapter is used "all over the place" or only for the sake of abstraction is not up to his library. If your are using a third party library that force you to have an ArrayAccess implementation as input, Arrayze can be a handy adapter for that. That's it. 
Sorry, I don't understand, who is crying out...? The library is a lazy array adapter. If you need an array adapter in your code, use it. Otherwise you don't need it. 
This is an official project by the PHP developers, designed to replace the current PEAR/PECL installer (and probably allow the eventual removal of the PEAR installer in favour of recommending Composer). php-internals mailing list thread (announcement): http://thread.gmane.org/gmane.comp.php.devel/87712 php-pecl mailing list thread (main thread): http://news.php.net/php.pecl.dev/11879 RFC: https://wiki.php.net/rfc/pickle 
Logic is not dependent on a specific programming language.
&gt; Learning python will make you a better programmer. No, It wont. &gt; Even your PHP will improve a bit Learning python wont improve your php. &gt; Studying computer science or math is the most effective way by a long shot Learning math wont help in improving Logic. 
That's actually very hard for the average PHP developer. Think developers who use PHP through XAMPP, MAMP, WAMP. If you are a server adminstrator, you breath that stuff, but that's not the case for every one. That's why I'd love something like: pickle install ssh2 and be done with it.
Still don't get the point of the library, but kudos for building and releasing it to the public.
Yeah, I want this: 30 seconds for everyone.
Try using this: $iWhileMax = 10; $iAfterComma = 0; $dWinningProb = 0.000095; $epsilon = 0.00001; while($iAfterComma &lt; $iWhileMax) { $iAfterComma++; $dWinningProb *= 10; $iProbEqual = (int)($dWinningProb); echo $iProbEqual.' ('.gettype($iProbEqual).') - '.$dWinningProb.' ('.gettype($dWinningProb).')'; if(abs($iProbEqual-$dWinningProb)&lt;$epsilon) echo ' - EQUAL'; echo("&lt;br /&gt;"); } Where $epsilon is the level of precision you want.
Look for Floating point precision at http://php.net/manual/en/language.types.float.php you can cast the float/double values to string to avoid it: if($iProbEqual == (string) $dWinningProb) 
I'd disagree with a few folk here, I quite often have a misc functions, but I probably wouldn't use it for the things you mentioned. I tend to try and keep it to things I consider supplementing the standard library, my favourite of which is array_get($array, $key, $default = null)
Thank you.
TIL this is possible with PHP: $var = (new ClassName)-&gt;methodName();
Thank you, this helped.
*use it to its full potential. I have a car, I can drive an automatic, who needs to use gears right? car does it for me. So having to learn to use gears must mean that car is not as good right? Or the ability to use gears now gives me more control over the car? I can still drive around in 1st gear if I want, but I wont get anywhere as fast as I could be going.
What are you trying to achieve with this code? You are comparing an integer with a float and that's really problematic because of how floats are represented on a lower level. See the huge red warning in the PHP manual: http://php.net/manual/en/language.types.float.php Either use the epsilon method shown by ilovemicah, rewrite the code to only use integers, cast both numbers to integers before the comparison, or use [BC Math.](http://www.php.net//manual/en/book.bc.php) The right solution depends on what you want to achieve, though.
I am trying to get integer and how much 0 (zeros) was in front of it for e.g "**0.00095**" I will need to get **95** and **4** (4 zeros in front of it).
Of course the example is not so meaningful, its aim is only to show the interface of the tool. It seems to me here we are not talking what the library is about, but how you can use the library in the wrong situations. Take the library for what it is: a lazy array adapter. That's it. Libraries can have very specific purposes, and this is the purpose of this library. It's a very small one, but quite well abstracted for my needs. If you need a lazy array adapter, use it. Otherwise, don't.
As per PHP 5.4+. &gt; Class member access on instantiation has been added, e.g. _(new Foo)-&gt;bar()_. [Source](http://php.net/manual/en/migration54.new-features.php)
You keep saying "if you need this, use it". The point we are all trying to make is that you would never need it. If you want to show how the adapter is useful, you really need to show an example where using the adapter is the best solution instead of posting examples where it's clearly a pointless abstraction.
Ok, so I should try to confute the sentence "Array adapter are useless". Although it can be useful from a educative point of view, I don't have the time to do that. However I will consider it on future updates to the documentation.
I agree with tagging but semver has it's downsides. At minimum tag your releases, though. 
You can get ~~[the order of magnitude](https://en.wikipedia.org/wiki/Order_of_magnitude#Uses) (~~the number of zeroes~~)~~ with [log10\(\)](http://www.php.net/manual/en/function.log10.php). Edit: Sorry, the number of zeroes is not the order of magnitude.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 1. [**Uses**](https://en.wikipedia.org/wiki/Order_of_magnitude#Uses) of article [**Order of magnitude**](https://en.wikipedia.org/wiki/Order%20of%20magnitude): [](#sfw) --- &gt; &gt;Orders of magnitude are used to make approximate comparisons. If numbers differ by 1 order of magnitude, *x* is *about* ten times different in quantity than *y*. If values differ by 2 orders of magnitude, they differ by a factor of about [100](https://en.wikipedia.org/wiki/100_(number\)). Two numbers of the same order of magnitude have roughly the same scale: the larger value is less than ten times the smaller value. &gt;The __order of magnitude of a number__ is, intuitively speaking, the number of powers of 10 contained in the number. More precisely, the order of magnitude of a number can be defined in terms of the [common logarithm](https://en.wikipedia.org/wiki/Common_logarithm), usually as the [integer](https://en.wikipedia.org/wiki/Integer) part of the logarithm, obtained by [truncation](https://en.wikipedia.org/wiki/Truncation). For example, the number 4,000,000 has a logarithm (in base 10) of 6.602; its order of magnitude is 6. When truncating, a number of this order of magnitude is between 10^6 and 10^7. In a similar example, with the phrase "He had a seven-figure income", the order of magnitude is the number of figures minus one, so it is very easily determined without a calculator to be 6. An order of magnitude is an approximate position on a [logarithmic scale](https://en.wikipedia.org/wiki/Logarithmic_scale). &gt;An __order-of-magnitude estimate__ of a variable whose precise value is unknown is an estimate [rounded](https://en.wikipedia.org/wiki/Rounding) to the nearest power of ten. For example, an order-of-magnitude estimate for a variable between about 3 billion and 30 billion (such as the [human](https://en.wikipedia.org/wiki/Human) [population](https://en.wikipedia.org/wiki/Population) of the [Earth](https://en.wikipedia.org/wiki/Earth)) is 10 [billion](https://en.wikipedia.org/wiki/1000000000_(number\)). To round a number to its nearest order of magnitude, one rounds its logarithm to the nearest integer. Thus 4,000,000, which has a logarithm (in base 10) of 6.602, has 7 as its nearest order of magnitude, because "nearest" implies rounding rather than truncation. For a number written in scientific notation, this logarithmic rounding scale requires rounding up to the next power of ten when the multiplier is greater than the square root of ten (about 3.162). For example, the nearest order of magnitude for 1.7 × 10^8 is 8, whereas the nearest order of magnitude for 3.7 × 10^8 is 9. An order-of-magnitude estimate is sometimes also called a [zeroth order approximation](https://en.wikipedia.org/wiki/Zeroth_order_approximation). &gt; --- ^Interesting: [^Orders ^of ^magnitude ^\(numbers)](https://en.wikipedia.org/wiki/Orders_of_magnitude_\(numbers\)) ^| [^Orders ^of ^magnitude ^\(length)](https://en.wikipedia.org/wiki/Orders_of_magnitude_\(length\)) ^| [^Scale ^analysis ^\(mathematics)](https://en.wikipedia.org/wiki/Scale_analysis_\(mathematics\)) ^| [^Orders ^of ^magnitude ^\(time)](https://en.wikipedia.org/wiki/Orders_of_magnitude_\(time\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ci9qkdn) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ci9qkdn)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
In this case, why not do it as a string parser? Look: $n2 = number_format($dWinningProb, 12); $significantZeros = strspn($n2, '0', strpos($n2, '.')+1);
Oh my god, are you serious?
Exactly what I was thinking. Check out [Laracast's screencast](https://laracasts.com/lessons/how-to-use-eloquent-outside-of-laravel) on how to use Eloquent outside of Laravel.
I'm using Mamps. Where would I do it there? 
Can you explain the downside of semver ?
Are you talking about logic in terms of if/else/while etc, or do you mean logic in terms of software architecture? Actual algorithmic logic is language agnostic. However, software design and architecture is mildly language &amp; framework dependent. How you structure something in Python Flask is going to be quite different from how you structure it in PHP Laravel. Learning Python will help give you a different perspective on PHP and I definitely encourage it, but it's not going to improve your logical thinking. For what it's worth, I'm the same as you. I learn through repetition and memorization. I was a terrible math student.
Mostly its having to hold off of backwards incompatible changes until the next big release. No matter how small they are. People aren't happy to change the big number
I've always considered controllers as an inseparable component of the framework and http as a point-of-entry to your application, so I feel that the concept of "framework-independent controllers" is kind of paradoxical. Instead of calling them controllers, why not free them from that semantic baggage entirely and just call them services?
I wouldn't say that's a downside though. If you have a well thought (and stable) codebase I don't see why you would need constant BC breaking changes. And having 1-2 major releases a year is not that uncommon in the first year of a package. 
Hey guys, downvoting the OP when he explains himself does not promote discussion. If you want informative discussion don't discourage those providing more information!
I wasn't meaning it in such a derogatory way as you received it, so I've changed that. And to your points: &gt; 1) Modified the api of the Person class Not in the first example -- binding a closure to a class doesn't change the API of the class. You are calling a closure in the context of the class, not a class method. In the second example, it does indeed modify the prototype of the class. That's why there are two examples provided. &gt; 2) Removed the capability to define in a programmatic way the transformations, since they are all hard-coded into the closure. It's just a closure, so you could do whatever you wanted with it, up to and including passing in more mapping closures to the toArray method... Plenty of ways to extend that cleanly that don't involve a wrapper. &gt; 3) Made it hard the reuse of single transformation callbacks, since, again, they are hard-coded I think this is the only valid reason to use your method, given a requirement of accessing an object using string array keys. Even then, there are better ways to achieve this. Now, the downsides of using ArrayAccess and a whole load of closures is that ArrayAccess comes with a lot of overhead. So does call_user_func. Each is at least 3 times more expensive than the corresponding native access, depending on the implementation. That's not much when you're dealing with a single object, but what happens when you need to loop 1000 of them? It would be better to just write a child class of the objects in question. Easier to debug, easier to read, easier to write... Better all around in my opinion. You can downvote me with all the accounts you like, but it won't make this approach any more useful or the architecture that requires it any less painful to work with.
Yes, please tag your releases. Please. Also, please. Even 0.0.1 is better than dev-master.
I love how much you contribute to this subreddit for things other than Sentinel and Data Grid.
There's nothing stopping you from maintaining multiple major releases at the same time. For example, you can do a 1.0 followed by bugfixes and non-breaking changes while also releasing a breaking 2.0 later. In fact, most major projects out there clearly document this sort of release strategy so users can know how long they can expect to have support for the major release that they are using.
Thank you for sharing. I just bought the book.
Sure, if you call the adapter thousands of times think twice before use it, like for all libraries in the world. In addition to that, consider that in my case only an array of callbacks is stored, even if you have millions of array adaptee instances. The memory gain with the lazy adapter, in some cases, can so be huge compared to your manual array construction. 2) You can do anything in a closure. It's a closure, so it has the whole power of a php script. And for me it's all. I do not even consider your other insinuations.
Haha he downvoted you
&gt; Mostly its having to hold off of backwards incompatible changes until the next big release. Sounds like a good thing to me.
You mean explain how to use its extensive and comprehensive feature set to the fullest? You'll spend more than two hours learning that... Completely worth it.
If you want to make packages that you expect other people to use, you have to apply some discipline to your coding; you can't expect everyone to constantly know exactly what changed in your code's new versions so that they would know how to adjust in every project they used your code in. If you keep increasing your major version number often, your project would come across as indecisive and changing too much, but at least you're being honest and are ensuring that people using your package know when a backwards-incompatible change is coming.
Nice. Thanks bro
I think that's only a problem if you treat major version number changes as a "big deal". My suggestion is to just forget about there being any glamour associated with a major version change. The practical benefits of semantic versioning outweigh the "coolness" of launching a new major version with a bunch of new features, at least in the package/library development world. We're on Chrome 35 nowadays, and no one is going to care when Chrome 36 comes out.
Why would I use Semaphore over https://travis-ci.org/? Travis has a free account for public repos but I did not see that with Semaphore.
Hey, first off, my response that you're about to read is in now way a bad reflection of your work or any disrespect towards you. That being out of the way. I can see the use for this, but what's the benefit over the way you're doing and simply using a secondary class? For example: &lt;?php class Adapter implements ArrayAccess { protected static $caches = array(); protected static function normalizeKey($key){ $cacheKey = 'normalize'.$key; if(!isset(self::$caches[$cacheKey])){ self::$caches[$cacheKey] = preg_replace_callback('/\s(\w)/',function($part){ return strtoupper(trim($part[1])); },$key); } return self::$caches[$cacheKey]; } protected static function getMethodFromKey($key){ $cacheKey = 'methodFromKey'.$key; if(!isset(self::$caches[$cacheKey])){ self::$caches[$cacheKey] = 'get'.ucfirst(self::normalizeKey($key)); } return self::$caches[$cacheKey]; } protected function keyExists($key){ return method_exists($this,self::getMethodFromKey($key)); } public function offsetExists($offset){ return $this-&gt;keyExists($offset); } public function offsetGet($offset){ return call_user_func(array($this,self::getMethodFromKey($offset))); } public function offsetSet($offset,$value){ user_error('Cannot set values on an adapter.'); } public function offsetUnset($offset){ user_error('Cannot unset values on an adapter.'); } public function __get($key){ if($this-&gt;offsetExists($key)){ return $this-&gt;offsetGet($key); } else { user_error('Undefined variable '.$key.'.'); } } } interface IPerson { public function getFirstName(); public function getLastName(); public function getBirthYear(); } class Person implements IPerson { private $firstName; private $lastName; private $birthYear; public function __construct($firstName,$lastName,$birthYear){ $this-&gt;firstName = $firstName; $this-&gt;lastName = $lastName; $this-&gt;birthYear = (int)$birthYear; } public function getFirstName(){ return $this-&gt;firstName; } public function getLastName(){ return $this-&gt;lastName; } public function getBirthYear(){ return $this-&gt;birthYear; } } class PersonAdapter extends Adapter { private $person; public function __construct(IPerson $person){ $this-&gt;person = $person; } public function getFirstName(){ return $this-&gt;person-&gt;getFirstName(); } public function getLastName(){ return $this-&gt;person-&gt;getLastName(); } public function getFullName(){ return $this-&gt;firstName.' '.$this-&gt;lastName; } public function getAge(){ return ((int)date('Y')) - $this-&gt;person-&gt;getBirthYear(); } public function getNameAndAge(){ return $this-&gt;fullName.', '.$this-&gt;age; } } $person = new Person('Nicolò','Martini','1983'); $adapter = new PersonAdapter($person); echo $adapter['full name']."\n"; echo $adapter['age']."\n"; echo $adapter['name and age']."\n"; ?&gt; I'd understand if the benefit were less classes, but in your implementation, there is actually an extra class. Thanks!
I think your example is fine, you give a generic Adapter interface for objects. The drawback I can see is that the value you are going to adapt has to be an object, and you can get data from the object only through method calls, while in Arrayze you have generic callbacks that elaborate the data. I don't consider to have less classes as a benefit. Often the code is much cleaner with very simple and small value classes instead of native arrays, for example. But this is another story... :-)
Eloquent is amazing outside of Laravel just like it is inside of it. I had built a utility server using Symfony console and Eloquent, and it feels as if I am still working inside Laravel. It's a good time to be in the modern framework ecosystem. Good luck man.
I don't really see this as a problem as long as you're using a lock file, it will basically "tag" head for you when you add it to your composer file. This only becomes a problem if you're in the regular habit of running composer update on *everything at once* which you shouldn't really be doing very often for software that you care about the stability of.
It's pretty much magic quotes with a check so it doesn't double-escape data. It has all the issues that were there in magic quotes as well.
SemVer isn't a development strategy, it's a version notation. There are plenty of reasons to hold off on backward-incompatible changes, but "I don't want to bump my version" should **never** be one of them. SemVer allows us to understand what's going on in a project at a glance, and makes it difficult for developers who depend on your codebase to be surprised by backward-incompatible changes. Maybe I'm misunderstanding your point, but that's not a reason to avoid semantic versioning.
Why not just build a input_escape_register() function, and flag any use of an input if it hasn't been parsed by one of the function in the register? For instance: require('./InputEscaper.php'); function myEscapingFunction(&amp;$str) { //escaping stuff } input_escape_register('myEscapingFunction'); input_escape_register(array(new InputEscaper, 'sanitize')); echo $_POST['var']; // throws an error myEscapingFunction($_POST['var']); echo $_POST['var']; // everything is okay I mean, that's a simple version of it. Obviously you'd want to be able to run it on an entire array of input strings. You should be able to assign the input to new variables without an error, but not use it as an input to any other function or in relation to a language construct.
I have just added some benchmark to the repository done by a tool developed by me (https://github.com/nicmart/Benchmark) Here you can see the results: http://i.imgur.com/EG9WtPH.png The "native" example is taken from your code, with slightly changes, to have the properties computed in the same way (no access to private members please!). As you can see, on iteration my library is obviously slower, but not so much (less than 2.5 times slower). But, thanks to laziness, on a single lookup is twice as fast. The benchmark suggests that, thanks to laziness, arrayze is faster than closure-to-array conversion if you access less than half of object offsets. Clearly this is ad advantage of lazyness: you can define plenty of views for your objects, without worrying about performance penalties, and only the needed one will be computed. 
Sure, the second link in the first paragraph is a link to a blog post by nikic benchmarking the routing core. I'll do some further tests and compare against other frameworks and post within the readme. Thanks for the feedback! EDIT: I've updated the readme with some simple performance stats from apache ab https://github.com/joegreen0991/phroute/blob/master/README.md#performance
Googling to figure out what you are seeing leads me to about 5000 shady sites wanting you to download something to fix your registry. Whatever you do, don't download any of this crapware. Give us a little more information (OS, version, web server, where you downloaded PHP from, etc), and there's a good chance that one of the NiRs (Nerds-in-Residence) here can help. That said, there's also /r/phphelp, which is probably the more likely source of a solution. Good luck!
Yeah I didn't download it I knew it was super suspicious. I am on Windows 7. Web server I think is IIS, which is on what ever version comes with windows. I downloaded PHP from their site. I got the exe for PHP 5.3.28. I am following this tut. https://www.youtube.com/watch?v=gcs8h8kyNNA
You would probably be better off with xampp https://www.apachefriends.org/index.html
That's what he's suggesting actually. It's just that these services behave like controllers. This is explained in the official docs as well: http://symfony.com/doc/current/cookbook/controller/service.html
While tags are much better, you can always require a specific git commit hash with composer: https://github.com/composer/composer/issues/599
Yes, lazy accessors are faster in any case where you only need part of the entity. I was unfairly harsh. I don't see myself ever needing this code, but if you have a need for it, then who am I to judge? Just as a final note, many of your mappings will point straight to accessors on the wrapped class. You could easily make your mapping code accept either a closure or a string, and simply call the class method named in the string instead of using a closure for every one. That would get you close to native performance on simple getter calls. 
Oh I am using git. I'm not gonna let that private student account go to waste ;) But no, I'm pretty horrible at remembering to do backups and it's just as easy to build the scheme into a model and put in some seeders so I can do an artisan command to bring back my development data
Thanks! I've gotta push out something useful (students are gonna be using it) by the end of summer so I can start gathering UX stats to improve the next version, so refactoring in an ORM will have to wait. I really wanna do ORM because I landed my first job in my filed this summer, they're moving to ORM and it looks like everyone else is too. My university's database course hasn't even heard of ORM, so I'm inserting it into my own studies to supplement. I'm thinking about talking my professor into letting me do a full Laravel project after this initial release because it'll give me that MVC experience that everyone is using now. My professor thinks that I need to get to bare metal and learn how the underlying structure works. I agree that I should, but at the same time I feel as though putting that restriction on me and not letting me learn new technologies will ultimately hold me back. 
Because context is everything. It's literally impossible to build a "make safe" function which makes output safe for all possible scenarios. Escaping must be sensitive to the context of where, when and how it's being outputted. Therefore, it "feels" safe, but really isn't any safer than not doing anything (overall)...
Anyone who uses your project should generate their own keys and plug them in. Edit the config files so they are publicly ready, push it, then add it to gitignore. This allows the config to stay consistent for others to integrate, and allows you to modify it locally.
But, if later i need to add something to some of those files , i'd have to remove them from gitignore and do the same process that you mentioned...
You can use environments in Laravel, so just put all your sensitive config in config/production/app.php (or session.php etc) and it will overwrite the main config variables. Then you can safely ignore the whole folder.
I'd probably agree (without knowing too much about what you're doing). XAMPP will get you up and running quickly, and if you're not super savvy about PHP (i.e. just getting into it), it's OK to be a sub-version or two behind. [You should also check here](http://www.php.net/manual/en/install.windows.iis7.php) for information on installing PHP w/ IIS. There are some other items, from a configuration standpoint, that need to be there for PHP to work.
Most likely your users would use the config files directly as they wouldn't be uploading sensitive data and if they forked it to develop on it they would probably have the same question and get the same response.
Just to clarify, leave the app/config dir as is, create a new directory called app/config/production (this is the directory you will ignore) then you can just copy parts of arrays into it, eg one config file for session could be: &lt;?php return array( 'domain' =&gt; 'mydomain.com' ); This would overwrite the config value for session.domain and leave the other variables as is. Sorry I'm on mobile or i would be more descriptive.
Correct, by default the environment will be called production, this is not something you need to change in any way and anything in the production folder will override the main config providing that is the environment being used. You can define further environments in start.php or paths.php, his gives you the local environment providing your machine name matches. In this case you would create a folder called local which would override config for development only. You also have the environment testing built in for when you're testing. Tl;dr the end users will just edit the config files directly and won't know you did it another way.
I got it :) Thank you very much for the explanation. 
The typical solution is to provide a sample config file. So in the repo you'd have something like config.sample.php, then the user fills in the values and saves it as config.php. The latter file is the one that's read in your app, but is ignored in gitignore.
No, I do not mean if/else/while etc. What I meant was Logical thinking I will give you an example: In an interview I was asked to find repetitions of n element in an array using php, although I remember from my classes there was just come kind of simple loop based logic but I couldn't solve it off my head so I used hack method, I looped in_array(n) in while loop then counted number of prints in the while's output and the interviewer giggled. **This is my problem.** I know I can improve on architecture only by practice, I couldn't figure out simple blog database for the first time but after doing some projects I built an Custom mini-forum with real users in our company using CodeIgniter with multiple roles for admin, So I do understand that architectural logic will come from experience and practice. So what do you suggest ? Should I just learn AJAX/jQuery that has been in my learning list from quite some time and continue my schedule of programming with practice **or** go learn another language and get the basics down ?
In these cases I keep my "master" branch as the one I share on GitHub, a second branch (lets call it "personal") I branch from this and add my private config/setup. Any work on the project I then do on "master" and rebase into "personal" when complete.
The key to this is to create a config.php.EDITME file with sample configurations, and which is version controlled. Then add config.php to gitignore. You then just cp the config.php.EDITME to config.php. Config.php remains out of version control, while the EDITME remains in version control, allowing you to modify it as needed. Just be careful not to mv config.php.EDITME, else git will think it's been deleted. Always cp it.
Alright thanks! Yeah I am just trying to learn the basics of how to setup a website and manage it. I have a basic knowledge of HTML and CSS so I want to expand on it while understanding how to actually host my page on the web. 
exactly what I was going to post
Hey you didn't mention what is the application? I'm curious to see it
as a curiosity, why are you using `while` instead of `for`? the same code would look like this: $dWinningProb = 0.000095; for ($iAfterComma = 0; $iAfterComma &lt; 10; $iAfterComma++) { $dWinningProb *= 10; // ... } 
At first I started to write it in **while**, because there was no limit how many numbers could be after comma. I did put that "max" limitation because I tested other solutions and I didnt want to go into "infinite loop" by mistake. Just to be safe for testing purpose.
Thx for letting us know about this package.
If you absolutely need to deliver these sensitive data I suggest to use some code obfuscator. Some of them are free. Obfuscator does not prevent your code to be stolen but make it harder to read. You could also use something like IonCube or ZendGuard (expensive). Although the solution of a separate config file is pretty obvious.
You have two options: * Have a dummy config file (e.g. config.php.default) that users will have to copy to config.php and edit. * Read sensitive values from environment variables using [getenv()](http://www.php.net/manual/en/function.getenv.php)
With laravel you can structure the config files into folders depending on the instance they run on. A folder called "dist" would be a good place to put the distribution files. 
Semaphore was designed primarily for private projects, although support for open source projects is also coming. ;)
please dont
Thanks :) Any ideas on videos explaining how to set up a project properly? Folder structures etc? My gut says I will just dive in and have to redo it all.
The basics are fairly consistant these days: src/ &lt;- Your code vendor/ &lt;- library code web/ &lt;- front controller, public assets Your vendor directory should be populated by composer, and you can configure your autoloading / namespacing needs by selecting PSR-0 or 4 in your composer.json Beyond that take a look at the sample projects provided by modern frameworks; if you're using Symfony2 try to follow it's pattern, the same for Laravel, Zend2 etc.
Here: http://www.edzynda.com/use-laravels-eloquent-orm-outside-of-laravel/
Take a look at http://www.phptherightway.com
I don't understand this. It says you should keep passwords out of config files, then proceeds to create a config file with a password in.
Yes that basically what I was thinking, i.e. you'd have some default config somewhere anyway. I guess it makes more sense for the user to copy the default config rather than have the 'sample' file as well.
On it now thanks for the link!
[Seriously](http://supervisord.org/)? [Or maybe](https://circus.readthedocs.org/)?
&gt; mcrypt is stupendously slow I thought that was the point.
In our case, seriously. Unfortunately.
I think he means, why aren't you using Supervisord or Circus, something already created, tried and tested to do this.
Can you provide an example of this? 
&gt; I don't understand this. It says you should keep passwords out of config files, then proceeds to create a config file with a password in. Two points. First, the default .gitignore file ignores files matching this pattern: .env.*.php .env.php This means that you'll have to deliberately include the files in your repo. Compare this to the number of times credentials are accidentally pushed to a repo. Second, this is the *quick and easy* way to setting environment variables. No reason why you couldn't put these in an environment file, or an Apache or Nginx config etc etc.
https://github.com/symfony/symfony-standard/blob/master/app/config/parameters.yml.dist Bonus: when you have the incenteev bundle (installed by default) composer will prompt you for the correct values on first run! Laravel doesn't do things properly. You have the answer to your question from others in this thread, but consider using a better framework for your next project.
Mcrypt is indeed multiple times slower than OpenSSL. Especially the "setup time" is slow (if you make multiple encryption calls the speed difference grows). &gt; I thought that was the point. I guess you mean password hashing. Whereas symmetric data encryption is supposed to be fast.
Here's how you do it (and you can use my repository as a reference: https://github.com/brightmarch/picto - the framework doesn't matter). * Create a build.settings.template file (located in app/config/ in my repo). * Have instructions for them to copy that to build.settings before they build the project and to fill it with configuration data. * Use Phing to import that file during build time, and to build the actual configuration file with it (in app/config/parameters.yml.template and build.xml and build-dev). * No fuss, no muss.
It sounds like your boss doesn't know what he's talking about. Of course you would get a nice raise if you became magento certified, because you'd be going from learning basic HTML to becoming competent enough in a server side language, like PHP, to be Magento certified. Screw raise, you'd probably leave your job and find better work. But you can't go from knowing nothing about PHP straight to Magento certification. You need to learn PHP first. I would suggest learning enough to become Zend certified. Then, maybe, consider Magento. However, if you know enough PHP that could get you Zend certified, then you'll get that raise because you'll have acquired a new skill. It's not even so much of a raise as it would be a job roll change, which developers make more than someone who just knows HTML
Honestly, configuration files outside of what the framework requires to run, shouldn't be committed into a repository. Trying to .gitignore them is generally a bad idea, especially if you're going to need this on multiple environments. If you're going to be storing sensitive information you can either: 1. Store the configuration files outside of the document root and read them from there. 2. Pull the needed data from the environment (stored in the web server config) 3. Get the information from a database or some other data source Of the three, I'd say #1 is the most preferred. As long as the files live outside of your application (and there's no vuln that lets the user read from them) you're better off than trying any trickery to not include them. Plus it doesn't require any kind of configuration change that you may not have access to change. It's a little more trouble for the person using the application, but if you include some kind of "install" script that can do most of the work for them, it's not as bad.
That probably *shouldn't* be relevant for libraries, only for "end projects", although examples like Symfony prove that there's truth in what you say. I personally wish all of the Symfony components followed SemVer individually, and that a new Symfony "release" just consisted of selected versions of the components, combined and tagged with a public-facing version number. At least then I could have some confidence in what new versions will break BC without looking up their custom versioning scheme or reading changelogs.
&gt; In an interview I was asked to find repetitions of n element in an array **using php** It sounds like he was asking you to solve this in the most efficient way possible **in PHP**. In otherwords, how would Python help you in a PHP specific question? Here is my solution, although I don't see how this is really based on logic, but rather an understanding of what array functions are available in PHP to extract the number of "n" in an array: echo count(array_keys($array, 'n')); All this does is print the total number of occurrences of elements that contain the value "n". Unless I misunderstood the question, this should be an elegant way of doing what the interviewer asked. However, as I said, this doesn't really have much to do with logic. If we break my solution down into two steps, the first function, array_keys, will return an array of all the keys in the array passed as the first argument where the search value is the second argument. The second function simply counts the result of array_keys
It's worth noting that these days you can relocate the front controller out of `web` in most cases. It's definitely possible with Nginx and the inbuilt PHP dev web server, probably Apache too but I can't say for sure.
&gt; Nor does PHP 'run separate' process for each request in modern php-fpm pool based setups. &gt; In a typical setup you actually want to increase pm.max_requests configuration to prevent respawning of processes. They do tend to segfault quite a bit under heavy load. 
The intention is to keep passwords out of source control, so that a project can be open sourced at any time. The ".env" configuration files in Laravel should be in your .gitignore file.
It's better to have a sample file that's distributed with the repo, and keep your real config file as ignored by your version control system. For instance: Ignored, not a part of repo: /config.php The next one is commited. it is a sample representation that needs to be copied to config.php: /config.php-dist
If you prefer learning with an instructor, our [JumpStart PHP course](http://www.phparch.com/training/jump-start-php/) starts next week. $250 for 7 hours of instruction and hand-on excercises to learn the basics of the language. Disclosure, I'm one of the owners of php[architect]
&gt; cheatsheet This is definitely not a cheatsheet. Cheatsheets do not contain paragraphs. &gt; Use AES-256 in CTR mode Article makes it sounds like it's the only option. While CTR mode is good for parallelization, it is not the only mode you can use.
Looking at the various [Magento certifications](http://www.magentocommerce.com/certification/) available. You should clarify which ones your boss wants you to get and also negotiate with him what portion (all of it) of the training/certification costs they can cover, a timeline, and possibly the amount of a raise. You're boss might want to ask you to commit to stay with the company for some time. I'd think up to a year might be reasonable, but that's without knowing the full cost of getting the certification.
&gt; This is definitely not a cheatsheet. It's my bad, just couldn't come up with a better name. &gt; Article makes it sounds like it's the only option. While CTR mode is good for parallelization, it is not the only mode you can use. That's why I stated in the first paragraph: *Naturally the recommendations given here are not the “only possible way” to handle data encryption in PHP, but this cheatsheet aims to be straightforward and tries to leave less room for mistakes and (possibly confusing) choices.*
&gt; And Facebook found it limited enough to extend the language... ... instead of giving up a severely limited language in favour of a robust and feature-rich language.
Just to add: SemVer is one way of many. Being backward compatible is the big goal and what most expect. And: If you want a proper deployment use PHing ;D
:) Fair enough. "cheatsheet" is kind of a go-to word for things nowadays. And even though you have that blanket statement at the top, I'd recommend specifically saying there are modes other than CTR.
Yep it's true we could use both CBC and CTR with PHP (that's actually all the available reasonable choices we have currently). I tried to keep all the choices at very minimum, and ended up recommending CTR because it does not require padding (less code and room for bugs). That was the reasoning for not to mention about CBC. Maybe it would be a good approach to mention about CBC mode in the comments. Tough decision ;)
Looking at the code of both (both the library, and the PHP extension), I prefer the opposite. OpenSSL's version is much harder to audit, does much weirder things, and is overall a much stranger implementation. Compare [mcyrpt_create_iv()](http://lxr.php.net/xref/PHP_TRUNK/ext/mcrypt/mcrypt.c#1393) with [openssl_random_pseudo_bytes](http://lxr.php.net/xref/PHP_TRUNK/ext/openssl/openssl.c#5359) which proxies to [RAND_pseudo_bytes](https://github.com/openssl/openssl/tree/a898936218bc279b5d7cdf76d58a25e7a2d419cb/crypto/rand) &lt;- note that's an entire package, not a single file. Also note that openssl's version bypasses the systems's dev/urandom generator, and implements its own. Overall, mcrypts source is just nicer and easier to follow (my opinion). Performance matters. But it's by far not the only thing that matters. Nor is it the most important thing (for web application usages at least)...
He wants me to learn backend work and im sure he's looking at the developer certifications. Your course does sound like something i would like to do but maybe after i read up a bit. Do you have a book that goes with the course or a book for someone with no experience to get into php? Thanks
Thanks, I probably make it sound like its easy to learn. I understand that it will take me a few years to get certified. I've always wanted to learn PhP and e-commerce is my passion. I have probably about 2-3 years working with magento and i feel that becoming magento certified will give me a skill that i would use for a long time since i plan to work in e-commerce for a long time. I will start reading and applying what i learn. Thanks for the advice.
Check out Symfony and Laravel, two different PHP frameworks, and see how they organized everything.
&gt; This is a tool that simply lets you monitor processes when a lot of your business logic is currently tied into a language simply not suited to sub processing. Why would your business logic be required for monitoring processes? 
Go to www.phptherightway.com and www.codecademy.com Go to Codecademy first to work on HTML and CSS until you feel strong with those, so that you'll feel more comfortable. Then get a dev environment set up (they talk about that a bit in phptherightway, but you can post here again when the idea itself makes more sense I'm sure). If you actually want to do this, make learning HTML/CSS/PHP at least 2 hours of your day, every day, for the next 6-9 months, and you'll be in a position where reading a few books might get you certified.
&gt; though I would likely not have used AES-256 in CTR mode as the cipher of preference I ended up to recommend CTR because the extra code required with CBC (padding). It leaves less room for bugs. It is true that CBC stands abuse better, but given there is a requirement for random number generator anyway, using CTR would be a resonable choice. &gt; Why would you run the hex-encoding of a cryptographic key through a KDF or hash function instead of hex-decoding it? This is to make sure you don't leak information when doing hex decoding (or base64 decoding etc.). It is maybe not necessary, but I'd be cautious when "de-coding" strings, and that's why it is more comfortable to just raw hashing them.
Definitely stick with it. The worst thing any IT professional is stop learning. Technology moves fast, don't let yourself fall too far behind... but also know it's never too late to start learning something new. Don't do it for the raise, do it for the passion to build things with the new tools you've acquired. It may feel tedious in the beginning but the more you learn the more you will begin to love it.
That's exactly how it's done, the front end communicates the offset to a generic API method that returns data starting from that offset. No over-thinking required ;) 
The documentation is fine. You don't want it to be overly verbose. All the necessary information is there.
&gt; Compare mcyrpt_create_iv()[1] with openssl_random_pseudo_bytes[2] ... Actually, I generally still use the mcyrpt_create_iv() function for generating IVs specifically because I can force it to source from /dev/urand &gt; Performance matters. But it's by far not the only thing that matters. Nor is it the most important thing (for web application usages at least)... I wouldn't dismiss it so readily. I can tell you that this performance difference meant **a lot** to out web app (which relies on a, pretty much, entirely encrypted database). Specifically, switching to openssl methods reduced server load across a 30 server cluster by 30% for foreground machines and nearly 80% for background job servers. That's a lot of dollars saved in machines we won't have to purchase. --- The other reason I factor openssl methods is that mcrypt gives people far greater leeway to do "bad things" and create improper encryption -- and you see it all the time*. I mean, this "cheat sheet" is multiple paragraphs long and covers a mere one cipher combination. It's kind of like before [password_hash()](http://www.php.net/manual/en/book.password.php) when everyone did password hashing themselves and often did it wrong. _\* One of the top google results, http://aesencryption.net/, is incorrect because they switch the cipher from MCRYPT_RIJNDAEL_128 to the 192/256 variants which isn't AES._
&gt; For "real" applications, it is advisable to keep all of your sensitive configuration out of your configuration files. Things such as database passwords, Stripe API keys, and encryption keys should be kept out of your configuration files whenever possible. You think this isn't verbose? All I'm saying is move the note about source control from the bottom to the top instead of being misleading in the first sentence.
Leave CodeIgniter. Sure, it still has a large community, but development has slowed and it seems like version 3.0 will never be released. Here are some other reasons for considering more modern frameworks like Laravel or Symfony. * Tested, and testing built in. CodeIgniter is not fully tested and doesn't provide good tools for testing your app. * ORM for easy data access. CodeIgniter requires you to build your own models. You can build your own base model class or use Doctrine by hacking it in but it isn't worth your time. * More packages. Composer gives you access to thousands of up-to-date, tested, modern packages that work for all frameworks rather than just one. * Use modern PHP. CodeIgniter is stuck in the PHP 5.2 days and isn't moving anywhere. You lose the speed improvements and new features that come with PHP 5.3+, and trust me, you want to be on at least PHP 5.5 now. * Better code. CodeIgniter has superglobals and some poorly structured OOP. By using a more modern framework you will learn better coding practices, like SOLID. I ditched CodeIgniter a while ago for Laravel and have not looked back a single time. CodeIgniter was a great framework but PHP has moved on and left it behind.
&gt; Specifically, switching to openssl methods reduced server load across a 30 server cluster by 30% for foreground machines and nearly 80% for background job servers. Then your use case is definitely different from the most common ones :-) &gt; I wouldn't dismiss it so readily. I wasn't trying to dismiss it. I was just saying that, as with anything, a tradeoff exists. You're in a performance critical situation. So that matters more to you. But the average user is using crypto in far fewer places, and with far less data. So to them, the performance difference matters less (it still matters, but becomes less critical). That was what I was trying to say... &gt; The other reason I factor openssl methods is that mcrypt gives people far greater leeway to do "bad things" and create improper encryption I agree 100%. But I think openssl gives too much leeway as well. I'd rather see a wrapper which basically presents the user with the following interface: interface SymmetricEncryption { public function __construct(KeyRing $ring); public function encrypt($data); public function decrypt($data); } Leaving nothing to choice for the user. Obviously that doesn't work for all use cases, but the common ones, it definitely does.
Nice work! This seems to provide a lot of good functionality. However, for large/complex codebases where you have to create dozens/hundreds of objects on-the-fly, the overhead from Reflection will add up to a noticeable slowdown. Still, this shouldn't be a problem for most projects.
That seems to work as intended. I'm working on some simple search functionality and this MySQL is way to big to be searching on and sending back json crap, slow as balls. 1 table | 40k+ rows | 80 fields per row. This question may be better asked in a new thread, but would it be beneficial just to create another field in the table and store the data as json in that field? Then I could potentially drop all the fields that don't need to be searched on, right? It would reduce it to like 15-20 fields per row.
At this point, it's not worth porting existing CI projects to another framework. CI still works just fine (as long as you use mcrypt). However, there's also no good reason to start a new project with CI. Use Laraval or something else that is being actively developed.
Obviously, this isn't meant for a huge number of objects. Although, if you map ten objects without to much properties (or even a hundred objects) it should work fine! If one wants to parse a huge number of objects I think it's a better idea to use the [JMS Serializer](http://jmsyst.com/libs/serializer).
CodeIgniter is dead. No one is going to pick up the development because it needs a full rewrite to bring it back up to par with any of the latest modern php frameworks. There's zero incentive for any group to do this when there are plenty of better options. Sure it's going to limp along for years due to all the apps still running on it. However, starting a new CodeIgniter project today ensures that your project is immediately obsolete. There is no development path and there never will be. 
At the moment we don't have a beginner focused book. I know a lot of folks got their start with PHP from [Larry Ullman's PHP for the Web](http://www.larryullman.com/books/php-for-the-web-visual-quickstart-guide-4th-edition/) and have nothing but good things to say about it.
Enter fig, http://php-fig.org/ . Autoloading and folder structures. ( PSR-0 , PSR-4 ) , styles PSR-1, PSR-2 , log PSR-3 , and coming more.. like cache
&gt; I ditched CodeIgniter a while ago for Laravel and have not looked back a single time. CodeIgniter was a great framework but PHP has moved on and left it behind. Bingo. I actually had improved my skills and techniques by leaving CodeIgniter and using modern frameworks like Laravel and Symfony.
Why would I use this when I could just use something like [YOLO](http://yolophp.com/)? &gt;After some drunk testing, the new demo controller&amp;view are complete. I'm a pretty huge fan of your commit messages
 Every person has a different way of expressing things that may or may not suit one's intellect. The purpose of the article is to give author's perspective about state of PHP which would definitely enlighten a subset of its readers. &gt; You're not going to learn anything new or exciting from it. With this attitude one can even say that "Alchemist" is a fluffy book as paulo coelho has not put anything new in it.
You shouldn't have been using CodeIgniter even before its announcement. It is a relic of the past which has long since been superseded by many other far superior frameworks. We need to let it die so people move on to better ways of doing things.
[Forget about CI](http://bit.ly/ZWppZI)
I have played little bit with Laravel and I have to say I liked restful routes and many other things but my primary concern is can I host Laravel on shared hosting? most of my projects are hosted on shared hosting so I cannot go with anything that requires VPS.
&gt; And Facebook found it limited enough to extend the language Facebook found PHP as the most suitable language. As far as extending is concerned, there's no language that can support Facebook without extending the core. 
I just punched my grandmother after reading this code. If that's what you were going for, kudos.
&gt; It's not so overly complex that you couldn't maintain it yourself. The entire codebase?
Your table sounds improperly designed. Normalize it a bit and you will probably see some performance improvements. MySQL/Postgres/etc are all capable of millions of rows on modest hardware if the database is designed properly. https://www.simple-talk.com/sql/database-administration/ten-common-database-design-mistakes/
public function has_params() { if(!$this-&gt;get_params()) return false; elseif(!$this-&gt;get_params()[0]) return false; else return true; }
I don't know, why would you? And thank you.
Excellent.
Reminds me of something I'd whip together for a really small website that I didn't want to use a framework on.
Nowadays, after getting some practice with domain-driven design, I tend to structure projects like so: demo/ //demo code, if applicable docs/ //documentation, if applicable src/ src/Domain/ //business logic, the functionality that provides value to your clients src/Infrastructure/ //persistence logic, like repository implementations src/Application/ //stuff that connects the business logic to the infrastructure, frameworks, etc tests/ //tests of all kinds vendor/ //external dependencies (managed via composer) Depending on the project, I also have other directories that represent different ports in and out of the application. For example: src/Web/ //controllers, template files, assets for rendering html src/Api/ //RESTful api controllers src/Cli/ //Command line tasks When it comes to namespacing, I use composer with PSR-4 autoloading to translate the "src" directory to "(vendor)/(project)". For example with the vendor **Shield** and project **Avengers**, **src/Domain/Hulk/Smash.php** would translate to full classname **/Shield/Avengers/Domain/Hulk/Smash.php** **Disclaimer:** this is a relatively new approach on my part. I like it so far but there could be some downsides I haven't run into yet.
Do a [glob](http://nl1.php.net/glob) to get the files in the directory and then [array_rand](http://nl1.php.net/manual/en/function.array-rand.php) to get a random file from the array.
But look at my pretty magic numbers. Its bad code etiquette 101. I wonder whose will parse quicker?
That was kind of the point. I was writing the same clean-url shit for NGINX forever and then decided to just make this to use for everything small or original thing I needed to make.
I've been investigating trying out a data mapper instead of an active-record style ORM recently, so I'll be keeping an eye on this! One thing I'm not a fan of is the need define the configuration for mapping on your model - to me at least, this violates the separation of concerns because the model knows about it's external source. Also, this means you can't map multiple sources to a single model. I would suggest specifying alternate ways to define the mapping between a source and model. Does your package automatically do typecasting based on the docblock annotations? Because that would be amazing.
 $var = "27"; if ($var &gt; 5) { echo $var." is greater than 5"; } This goes string -&gt; int -&gt; string. It has to be string, because it's user input. Then it has to be int to be compared. Then it has to be string to be echoed. 
To me, the best part is conditional evaluation. For example, in arrays, there's no reason to use `!empty()` or `count() &gt; 0` when trying to find a non-empty value, just pass the array itself. (Of course this is contextual). $array = ['foo' =&gt; 'bar']; if ($array) { // passes The same can be applied to strings. I even have a really old test case that benchmarked this: https://github.com/titon/titon/blob/master/tests/titon/ExprBenchmarkTest.php Type casting happens everywhere, whether you realize it not. What if you cast `strlen()` on an int? Or `number_format()` on a string? Another instance is the database. All records returned from a database are usually strings, even if the table column is an int. Those will have to be casted at some point as well.
I've never taken myself seriously, so thank you. I have definitely picked up a lot of little things building this, and I don't think I'm anywhere done learning and shit. I'm looking forward to what I make with this.
 $string = "0"; if ($string) { // Does not get here } else { // goes here instead } However: $string = "00"; if ($string) { // goes here } else { // not here }
wow
I'm not a huge fan of using strings in conditions like this. It's really a better habit to express what you really mean. Do you care if the string is '', or should that not work? As /u/JordanLeDoux said, '0' evaluates to falsey. Is that what you want, or is that a bug?
That's the worst part of package managers, you just decide to install everything that sounds cool, and you never end up using it.
It's not a bug as far as the implementation of PHP is a concerned, but if you're asking if that's a bug in his programs, it very well might be. strlen("0") == 1; empty("0") == false; ("0" !== '') == true; (bool) "0" == false;
There are real reasons and use cases for dynamic typing, especially in environments where all your data is stored or received as strings. &gt;complex logical bugs as a veteran. Maybe that's the only use you find for it, but not me. I know to check type if I care about type.
&gt; I would suggest specifying alternate ways to define the mapping between a source and model. I've been thinking about this one actually but I think my main pain-point with this is that it becomes rather "bloated" (although that is definitely not the right word for it). I think it should be possible to have another way of defining the mapping for models, perhaps with some configuration of some kind. &gt; Does your package automatically do typecasting based on the docblock annotations? Because that would be amazing. It doesn't yet, but that is indeed an awesome idea and I'm on it right away! Since I'm using reflection anyway it should work (it should be noted though that, since it tries to use getters and setters before accessing the properties directly and I personally do type casting in the setters).
Simply name them 1 to x and then open rand(1, $x) This way you don't need to read the whole directory each time.
I think it in its entirety is verbose enough. All necessary information is there. I think the only issue is you've interpreted a broad definition for the term "configuration file", whereas Laravel is specifically referring to those in the `app/config` folder.
Dynamic typing has nothing to do with care about type; if you don't care about type, then you don't care about your code design.
Check and cast* I check to prevent autocasting when I don't want PHP to autocast.
I can't believe someone actually took the time to purposefully make the worst possible framework...
&gt;It has to be string, because it's user input Not really. PHP abstracts a HTTP request to strings, which is a design decision they have made, it doesn't really speak to benefits of dynamic typing. Conversely in a statically typed language. You expect an int, the user provides an int, so it is an int. This immediately resolves removes a range of potential bugs. 
I have to tell you this is far from the worst possible framework... Have you seen CodeIgniter or Laravel? Just trolling, sorry...
I'm saying that dynamic typing is a logical consequence of dealing with input data in only string format, not that HTTP itself would require web applications in general to be dynamically typed. That would be silly considering the other languages that also successfully handle HTTP data.
&gt; Dave | 913afc6d00 | I don't remember what I changed in the index. I am a FAN.
Yes, like I said, it's contextual. It was just a simple example. I primarily use the conditional evaluation for arrays. Perhaps I'll change the example to reflect that.
Hahhhh, but seriously, why did this guy make this?
Learning? Haven't we all done this? I'm not suggesting anybody use this but the guy billed this as a "probably a really bad framework", in other words acknowledging that he doesn't know enough to justify calling it anything else. It's labelled appropriately. When I started with PHP I certainly didn't start out with Rails or Symfony or Zend or CI or Kohana although they didn't even exist at the time. I think constructing your own framework is something every PHP dev does at some point or another in an effort to more logically organize your code and get sites out the door, this guy has just posted his here rather than keeping it on the server in his closet in the basement (didn't we all have one of those?). I don't think he's imploring anyone to put this into production, more likely just would appreciate some direction and feedback and I don't mind the humour either. I took this thread as a "tell me how bad this thing sucks" kind of post.
This is a job for a bookmarklet, not PHP.
What does ADR stands for? I didn't found it anywhere? any good article/pos to get a deeper understanding of it? is it a pattern? an architecture? 
&gt; This is not an "extraordinary claim"; it's an industry accepted fact. Not to mention common sense: if you don't even know what's safe and what's not, how can you possibly create an effective white-list? You're advocating for defending against unknown-unknowns as opposed to known-unknowns. Your method makes it impossible to know what's safe and what's not, as opposed to simply what's not. &gt; I already referenced OWASP. If you're more curious about why OWASP recommends the things that they do, this is a good little starter Thanks for the condescending link to an article about naïve `str_replace` escaping. But the full-fledged DOM-based parser the rest of us are discussing here already addresses all those points, and several that the OWASP HTML filtering library does not.
And don't forget **tests/**, it is as much important as src.
I'm also looking for a general lightweight data mapper. Have you had any luck? 
You da real MVP
But that situation could still be dealt with via casting. I don't see how dynamic typing (where a variable needs to change what type it holds) is absolutely necessary. As long as you have an easy way to convert from string to another type, you're golden.
This is incorrect, I have PCI compliant Woocommerce websites (verified compliant by 3rd party Trustwave) Compliance more concerns how your hosting and security is setup, not Woocommerce itself.
You could try some kind of scripting solution and/or use something like Selenium and record in the browser... But really I think the best solution would be a mouse recorder or something like AutoHotKey. 
I use dynamic typing in collections sometimes; for instance I use something that expects an iterator of values of type A and give it an iterator of values of type B (which implements/extends A). That exact operation is type unsound from a theoretical point of view (List&lt;B&gt; does not pass for a List&lt;A&gt;. This might technically be weak typing; all I know is that I don't know of any statically typed languages that would allow this; only dynamic languages. As for a variable changing its type: the only time I do this is if I'm converting from some general type to a specific type. If a function arg expects an integer I generally cast/convert it to an integer (instead of a string representing an integer), or if something is a numeric value and I specifically want it to be an integer.
Greasemonkey is probably you best bet here, not sure a bookmarklet can both navigate to the page and then open the menu when its loaded in one click.
&gt; You're advocating for defending against unknown-unknowns as opposed to known-unknowns. Your method makes it impossible to know what's safe and what's not, as opposed to simply what's not. I don't have a "method", so I'm not even sure what you're referencing here. All I've been saying is that "use a white-list" is not an adequate solution to the (very complex) problem. It's not bullet-proof, and it gives new developers a false sense of security, because they think it's just another drop-in solution ("oh, /r/php said all I have to do is use HTMLPurifier and then I can't be XSSed..."). My "method", if I have to pick one, is to educate oneself on the problem. Understanding it is the best way to prevent it, bar none. That does *not* mean that you can't (or shouldn't) use tools to help you along the way. It just means that using those tools does not mean you don't need to learn about the problem. If you don't know the problem, you won't know what kind of limitations your tools have. &gt; Thanks for the condescending link to an article about naïve str_replace escaping. But the full-fledged DOM-based parser the rest of us are discussing here already addresses all those points, and several that the OWASP HTML filtering library does not. That was not meant to be condescending at all. If you hadn't shown up with your torch and pitchfork, you'd have probably realized that I have absolutely no way of knowing what your knowledge level is, and that the article is actually quite a good primer on XSS fundamentals and basic attack vectors.
Well, when evaluated they are type casted to booleans. It's a form of changing the type to another. The only other major type casting I ever use is between strings and ints, or sometimes turning something into an array. $array = (array) 'foo'; // ['foo'] But for literal dynamic typing, I can't think of any daily use case examples. Hah, and yes, I was that gearvOsh.
No, I've interpreted the phrase "keep all of your sensitive configuration out of your configuration files" as what it says rather than "keep config files out of source control" which is what it's supposed to say.
We use Monolog for our PHP applications and use that to pipe the logs to http://graylog2.org/ which we use as the central logging store for all our applications. Why: * Fast searching with good search filtering options * Can save searches as "streams" of information * dashboards with widgets for a "status" page http://graylog2.org/assets/images/announcements/v020/screen1.png * Email notifications when certain events happen (e.g 5 database errors in 1 minute )
Appreciate the honesty in your project naming :) 
Your classifying a database with 40k rows as big? From the sounds of it your database has issues, I'd be checking to make sure it's indexed properly. However with that said your idea is pretty much exactly how endless scrolling works :) Personally for me though i hate endless scrolling, i much prefer pagination because as a user it let's me jump ahead as far as a i want, where as with endless scrolling, i have to scroll continuously. Thats my personal opinion though
So, if this is based on [nikic/FastRoute](https://github.com/nikic/FastRoute), what does it offer that Nikita's library doesn't? I enjoy when people post their libraries on this Reddit, but I find the "why" is often missing. What does this library offer that isn't found elsewhere? &gt; Many modifications to the core have been made suit the new library wrapper, and additional features added such as optional route parameters etc, but please head over and checkout nikic's library to see the origins of the core and how it works. Can you explain specifically and with examples what you're getting at here?
Sounds like it does piece together a Model View Container mindset then. So far I have not seen examples of how people route the rest of the pages through the index.php file but I like the idea of that being done. It sounds like how I would use a layout page to encapsulate all my pages in .NET (the body would change depending on what is needed)... Will look up Composer now and Symfony2 as well. Thanks :)
I had the pleasure to work on a "professional" in-house framework which is also "Enterprise Ready". Which according to the author/lead dev is more secure than all those non-sense open source frameworks.... I died a little when I was reviewing the code... Did I mention that it was referencing Magic Quotes...
Right, that was kind of my point. It's not a bug in PHP, but how he was using the conditional could result in a bug in his application. That's why I like to be more explicit in my checks (typically false === empty($string), or '' !== $string)
Side note: Forever scrolling can present some issues with memory usage for end users. I haven't seen this done yet, but if you can remove previous 'divs' while you are scrolling down and add them back when scrolling up (reverse forever scroll), that should help. 
Fair enough. Make a pull request with the changes you'd recommend if you believe it should be changed. :)
This is why tagging works, if a library has tags and is on say 1.2.1 you can specify 1.2.* and automatically get important updates that are guaranteed not to break any compatibility for you. So you can composer update with out a care. 
So, in exchange for maybe saving .00001 seconds on fully automated solution, you have a manual file naming scheme where you have to keep the x in the script in constant sync with the x in the directory, make sure there are never gaps in the files, etc? This is why we can't have nice things.
That's definitely true if you're talking about Symfony or whatever, 2.3.2 and 2.3.3 are going to be just fine integrating with the rest of your code. But we're talking about taking code from someone who doesn't even tag their releases, do you really trust that person to now maintain major/minor versions and not break compatibility between all of them? IMO if you want to leverage a poorly maintained open source package, you've just inherited the responsibility yourself of at least tracking what's changing etc. When you start pulling in lots of smaller projects like this into your composer file, it becomes increasingly more dangerous to run update on everything at once with no particular reason in mind. Also I'm slowly starting to hate how retarded everyone is on /r/PHP - I'd bet good money that nobody in this thread actually maintains a live web application with a large (50+ libraries) composer file.
good work! one day, you shall be bolton, ramsay. 
Oracle will buy this, close source it, rename it to Enterprise Web Cloud Framework 3000 and put a $5000000 yearly licese fee on it.
Both Symfony and Laravel come with Monolog integration, and Monolog is really really really powerful. Just the list of log handlers alone should give you an idea. https://github.com/Seldaek/monolog
Understand .NET is controlled by Microsoft (the 'Dictator') so they dictate how things should be structured and everyone follows. It becomes a standard because it is dictated. Understand LAMP is a loosely coupled grouping of technology consisting of Linux, Apache, Mysql, PHP but all components have alternates and the stack is constantly under attack (dont use Apache, use Nginx; dont use Mysql - use MariaDB or Postgres or NoSQL/MongoDB; dont use PHP use Ruby or Python or NodeJS). The LAMP stack survives but there is no dictator and it is constantly getting attacked and a little fragmented. For PHP itself there is also a fragmented non-standardized battle going on - should you use Zend framework (they wrote PHP after all), or Cake or CodeIgniter, or the currently popular Symfony or Laravel). Or should you use a slim framework like Silex. Should you create your pages using a framework at all (or just use bare PHP) or should you use a CMS (Wordpress, Drupa, Zoomla etc.) - dont laugh, millions of websites are powered by thse tools. If you are developing a Wordpress site your code layout is somewhat dictated by Wordpress, and way different from what a Laravel site looks like. Also PHP is an old language and every version has always been backwards compatible which means it contains a lot of old functions that you dont really use any more. The phptherightway.com website suggests how modern web sites should be coded (in the authors opinion). A lot of people hate on PHP because of all these old functions and how it confuses things and makes things inconsistent but its one reason why PHP is so popular. New sites work great using the latest OOP stuff but so do sites written 5 years ago in much older versions of PHP. Talking of opinions some of the folks who answer below say Symfony or Laravel layout their projects like this so you should too. This may be an ok structure but its just an opinion from one framework (albeit a very popular one). Other frameworks lay things out differently. The php-fig.org website has the PSR standards document (latest is PSR-4) which tries to make sense of this mess and suggest some standardized structure for new versions of projects coming from many different vendors (of frameworks, CMS products, language tools) to follow to try to get them on the same page. Some vendors have signed up so these vendors will start following some standards and become more similar but many vendors have not. However the PSR standards is a good read and not a bad start if you are transferring from .NET. So there is no industry standard for PHP (somewhat because there is not a Dictator running things). There are some good ways to lay out your code but even this depends a little on the app and requirements. If you are interested I can expand on this and how I lay things out in a different response. Sometimes a little context is useful....
I still write them for fun when I'm learning a new concept. It helps reenforce what you know and makes you study what you don't.
Your making the case op did but trying to argue against it at the same time. If everyone used semver and tagged releases this problem wouldn't exist, regardless of how small the package is. 
Not sure you this sub allows tips... +/u/dogetipbot 500 doge verify I hope I don't get in trouble but at the same time I want to give you something for the great reply. This is making more and more sense to me. I have a few sites which I want to port to PHP from .NET. One is fairly simple and allows users to enter data into a DB and then they can see data from other users and filter it if need be. Not too bad at all and was fun to make. Others are client side (mostly) and use a lot of javascript/jquery. And others mix client and server side code. What I plan to do is simply create the site (nothing really sensitive at all and then develop a better 'structure' as time goes b). One concern I have is porting a custom user login with hashing into PHP...was a lot of work getting it to work nicely in .NET and useful due to being able to store hashed data vs plain text passwords etc in a DB. I will have to relearn quite a bit but I am up for it. Fun stuff ahead!
__^[wow ^so ^verify]__: ^/u/coding_is_fun ^-&gt; ^/u/technical_guy __^Ð500 ^Dogecoins__&amp;nbsp;^__($0.182052)__ ^[[help]](http://www.reddit.com/r/dogetipbot/wiki/index)
Joke's on you OReilly has already started their Bastard reference book and it's coming out soon. Tonight I'm going to the New York Bastard meetup.
I'm arguing that this thread is catering towards a theoretical premise: "It would be great if everyone could just use semver, then I can run update all I want and my software won't break!" The reality is that software breaks even within minor releases, in unexpected ways, constantly. It doesn't matter how well you grasp the beauty of semantic versioning, all software has bugs. The counterargument here completely ignores this. Lock files are better for stability alignment than tags are. I'm not really sure where you're finding all of this magical software that never breaks anything when you update it, I'd sure like to get me some of that.
Yet they will manage to make it even worse
Uh, no! Saying that "anything can cause stuff to segfault" is a gross generalisation. Under various circumstances and configurations, I've found php-fpm child processes to segfault often under heavy load. Sure, a faulty extension could cause it, but then, it would cause it much too often, not always only under heavy load. If it was a combination of bad ram, bad disk or bad kernel drivers (if you do, you've got bigger problems here than crashing php-fpm children), the consequences would manifest themselves in various other forms (your nginx would be crashing, or your database would) and in many other places. 
Not to mention back button breakage on endless scrolling.
I predict you have a bright future ahead of you as a wordpress core maintainer.
In what is a "bad" Framework? It's very simple (no doc need) public function __construct($uri) { $this-&gt;uri = explode("/", $uri); unset($this-&gt;uri[0]); $this-&gt;uri = array_values($this-&gt;uri); } it's ingenius.
Method overloading (kinda) is the only use case I see. [Here for example](https://github.com/symfony/PropertyAccess/blob/master/PropertyAccessor.php#L52)
It's not that you can't write a simpler clone, but Supervisor (supervisord's real name is Supervisor) is very light. It's not bloated at all. And honestly I love PHP but I don't think that's the right tool for the job. It's possible, sure, but it doesn't make a lot of sense IMO. And of course, for a project to be interesting, you have to add something new. Like you said, Silex brought something new: simplicity. Supervisor is so simple I don't see your project as more simple. But the main problem is obviously the name, because you write a PHP clone with the same name… Anyway I'm all for doing things and all, but don't expect that because you *can* reinvent the wheel, people will get excited about it. Especially if you also call it "wheel", and if you didn't add anything better into your wheel.
PaperTrail too! FYI it reads your log files (so you can use Monolog or whatever in your app) and pushes them asynchronously to PaperTrail so that you can view them online.
I'm aware that monolog is the de facto standard for connecting/handling the logs, I'm more interested in where they are sent by monolog.
You should clarify this in your post. I would be interested in where people pipe their logs too.
Oh my, mysql_* queries in 2014...
And people will buy it and we'll all end up having to use it, forever.
&gt; all I know is that I don't know of any statically typed languages that would allow this; only dynamic languages. Pretty much all static languages support doing this. See Generics and Co/Contravariance: http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science) 
You could do the same thing in a static language, accept a root type, and then check it's specific type in the method.... but you wouldn't ever do that in the wild. You'd just have two different methods with different overloads for the different types: GetValue(object foo) ... GetValue(array foo) ... 
Nope, nope nope nope nope. [typeahead.js](http://twitter.github.io/typeahead.js/examples/)
Downvoted primarily for use of mysql\_*, but also because using (only) such dropdowns is a bad idea unless you _really_ want to restrict people to a specific country and (probably incomplete) list of towns/cities.
So you're teaching CodeIgniter 2 in 2014, and you don't even have proper code formatting on your programming tutorial site.
Captha is to prevent automated abuse of forms. Although OWASP says it's as efficient as a CSRF token, it'll still drive your users crazy if you put this everywhere. [edit] obligatory illustration picture https://pbs.twimg.com/media/BqepaISCAAAiKSj.png
You got a point there. It would help if you are just gonna add it in more sensitive areas.
According to its community there is only one framework, Laravel. So if you use that, you won't need to know what a framework is
According to The Internet, everybody has slept with your mom and 90% of them didn't like it ..... just saying
Kind of, something is fucked up with it. I got my hands on a copy from the admin and it's a little over 2 GB. I was expecting maybe 300 MB tops. Need to figure out what else is being done on this DB. Any experience importing a 2.1 Gb file to MySQL? Or point me in the right direction? Keep running into server limits.
you are going to get eaten alive by the /r/php community for posting a code igniter tutorial. Laravel is the god framework, here good luck disputing that
Since you already know some PHP lets not stray away from that. My suggestion would be to learn (just in general) Object Oriented Programming(OOP). This will help to improve your logic understanding as well as your applications. Someone posted this the other week and it is very useful and stays up to date unlike most google search links: http://www.phptherightway.com/ this section specifically should address my point: http://www.phptherightway.com/#language_highlights That's my 2 cents, good luck
In general, I do not consider Captcha to be effective at preventing CSRF. Without a token in the form, any attacker could simply present the captcha on their site's form. The user thinks they are submitting a form to site X, but the form really submits to site Y with a different action and payload. Easy peasy. The only way around that is to tie the captcha to the specific form instance (by generating the secret the captcha uses with the form generation itself). But at that point you have the exact same mechanism in place as you would with a CSRF token. You're sending a secret in the form HTML, and relying on cross-site protections to keep it secret. And at that point, there's no effective difference between a CSRF token and a captcha. So why not use CSRF tokens everywhere, and add Catcha where you need to verify form submissions (not usually needed with a valid authenticated user, but can happen, for example if your spam engine detects that a comment may be spam, you may want to present a captcha to the user).
The "Meta" class in the libs directory with all the consts is what really got me. Well done!
&gt; **framework** — A product with the business logic removed, but all of the assumptions left in.
Hope you don't mind that I plug my own silly framework. [Thing framework.](https://github.com/thebuccaneersden/thing-framework) The point of this framework is to be a very technically complete yet frustrating obtuse. Work on it has stailled a bit lately due to work, but I have big plans for it. :)
These are the types of tutorials that give PHP a bad name (mysql_ namely, but the sloppy code, HTML/js included, all around). And that makes me a [saaad panda](http://imgur.com/gallery/ya6d92t). To offer a slightly more php &gt;= 5.3 way of doing things, here's how I recently solved this problem (albeit this was just for USA data. Because 'Murica): * sqlite DB of states, counties, etc. (this data doesn't change often enough to warrant a server-side DB back-end IMHO) * Illuminate for easy access to my DB if I ever do want to make that bitch server-side * Class to access the DB with some other little sugar methods to pull an array of states, an array of counties for a state, etc.) * Threw all of it into a composer repo which makes updates super easy if said data ever does change * Profit I'd love to share this repo with your wonderful people, but unfortunately it's a private repo at my work and I doubt they'd be very happy if I distributed it since I built it on company-time. But maybe I'll get off my ass and re-write it and put it on packagist some day. Maybe...
It's abstracted to assist with mocking in unit tests. Not sure how interfaces could be considered inflexible though. Kind of the opposite.
Pretty clear from his title. 
All persistent and reflective XSS automatically turn into CSRF attacks. Captcha doesn't prevent that. They just add an additional step. Let's look at an example. Imagine you go to your banks site. Which has an XSS vulnerability that's being exploited. An attacker has placed a javascript payload on the site. They can do whatever they want. But there's this captcha blocking them! What are they to do! Well, one thing they could do is socially engineer the user into filling out the captcha. They could present the user with a dialog "We don't recognize your browser, please validate that you are a user" with a captcha. (or some dialog that will get the user to enter a captcha). Now that's not just any old captcha. It's the one from the "account transfer" page, which is loaded in a hidden iframe (or via JS, or whatever). It's a legitimate box. And most users will enter the password and complete the captcha. And boom, the attacker can now send all of your money to whereever they want. And that's why XSS is serious. Once an attacker can get JS onto your site for a victims session, it's game over. They can do pretty much anything the user can do. Or if they can't (solving captcha), they can socially engineer the user into doing it for them (think clickjacking). So no, Captcha is no more safe than a token. All it will do is piss your users off. Instead, fix the vulnerabilities that you may have, and above all else, prevent XSS... Right from the very link that you shared: &gt; It is imperative that no XSS vulnerabilities are present to ensure that CSRF defenses can't be circumvented.
No. And evidenced by the top voted comment. His description does hint that it's the "to where?" being the question. Otherwise the title in of itself seems to mean "with what?"
Catpcha is for validating that the user is human. CSRF tokens are for validating that the request originates from the correct domain. Depending on the captcha implementation, it may not be effective form of CSRF prevention, since the user can be tricked to solving the catpcha or it may be machine solvable. In addition, I would pretty much advice using CSRF tokens for all POST requests, which would make captchas really painful for the user. You really only should use catpchas where automated submission may be an issue (such as a contact form or a login form). I recently wrote a library for handling CSRF tokens (available at [github](https://github.com/Riimu/Kit-CSRF)). Based on that, let me also give few additional pointers: * There is no need to regenerate the token for each request or form as this adds little if any additional protection to using a token that is generated per session. I would perhaps recommend regenerating the token on authentication as this prevents attacker from taking advantage of a rather specific case of session fixation. Note that regeneration of CSRF token breaks the use of 'back' button in browsers. * You may want to think about how to securely generate the tokens themselves. Using random generators that are not cryptographically secure leaves an unnecessary attack vector. There's /dev/urandom, mcrypt_create_iv() and openssl_random_pseudo_bytes() for the purpose of secure random generation. * As the [BREACH attack](http://breachattack.com/) last year demonstrated, the CSRF token can be used as an attack vector for encrypted connections. My library deals with this by using XOR encryption with random encryption key generated for each request.
And I would laugh all the way to the bank, pay off some debt and buy a large pizza with **3** toppings.
It looks like you are going in the exact opposite direction I wanted to go. Neat. Also, I like your `sober`, `tipsy` and `drunk` aliases.
syslog
Doesn't the phrase &gt;storage/analysis Make it pretty clear?
Okay, maybe it is logically clear, but it doesn't feel clear :D
The article doesn't go into specifics, which makes it rather un-useful. [We wrote]( http://itbrokeand.ifixit.com/2013/07/21/csrf-how-we-do-it.html ) a little library you can just plug-n-go with.
Just a quick thought I had earlier about this: &gt; One thing I'm not a fan of is the need define the configuration for mapping on your model - to me at least, this violates the separation of concerns because the model knows about it's external source. An option for this is to create a subclass of the model for API specific responses. Let's say (for example) that you're using a `Message` model that is used to represent messages from various social networks. If you want to map a tweet to this object, you can create a `Tweet` class which extends the original `Message` class with only the `getPropertyMapping` method implemented: class Message { /** @var string */ public $identifier; /** @var string */ public $message; /** @var string */ public $platform; } class Tweet { /** @var string */ public $platform = 'twitter'; /** @return array */ public function getPropertyMapping() { return array( 'identifier' =&gt; 'id_str', 'message' =&gt; 'text' ); } } This way, you can still map data from an external API to a `Message` object! By the way: I'm working on the automatic type casting at the moment, you want a notice when it's released?
Have to say, the way you sort of couched this whole thing I thought this was a parody framework. Hence the YOLO reference! But seeing as you're actually giving it an honest try I want to say, sorry if that was disparaging. I was just trying to be in on your joke. And I agree with /u/codenamegary that you've got the right attitude. I've heard it said that basically, people build frameworks 2 times. The first time they're just learning. The second time, it's much better because of all the experience they learned from the first one. There is generally no 3rd time because at that point, they're able to fully appreciate the value of all the existing options out there. Symfony, Laravel, Silex, Slim ... So if you're using this on projects that are small enough where it works out okay (though you do sacrifice some future scalability / testability / maintainability ...), and you're learning a ton by doing it, I say props to you. You're on a good path.
[logstash](http://logstash.net) with [kibana](http://www.elasticsearch.org/overview/kibana/) is pretty sweet. I use if for Apache logs, but PSR logs would be fine, too.
LOVE YOU
Thanks for your nice criticism. I will try to solve this problem as soon as possible. 
Well .. The irony
Google translates this odd post to: "I can discuss with the Chinese people will discuss it with you and you with me"
From an embryonic idea we've achieved 10,000 subscribers. Thank you to everyone here for the ideas and thoughts when we were first starting. It's really appreciated
Done a great job with it, you should be proud.
Yes, I think, @RiXrdb mentioned the way I wrote and words I used. Definitely, I believe that, every criticism will make me perfect day by day.
&gt; Naming convention of interface class is as like as class file. For example, class.class-name.php, now we are going to use, interface.interface-name.php. This should be updated to follow existing php standards. File names should be the same as the object name.
well, noted.... thank you.
Okay. I'm back to the grind of getting this to work. How do I alter the XML on Server B, and keep it as an XML File? I guess I have to use SimpleXML?
You desperately need someone with english as a first language to edit your articles. They read like they were created by some kind of automated engrish generator.
Well, here is how I structure my sites without a framework: Top level: - appname/ - appname/public - this is root folder for web server - appname/private - where I store php classes - appname/database - my db schema - appname/docs - appname/skins - (for international sites/sites with multiple skins for different clients) Inside public: - public/index.php - main PHP file - loads initial skin - public/ajax_gateway.php - main gateway for all ajax calls - public/css/* - public/images/* - public/js/* - public/plugins/* - JS 3rd party files - public/*.php - stub PHP files for other pages Inside private: - class_*.php - class files - config_inc.php - config file - init.php - standardized init file (loaded by all stub php files) - private/interfaces/*.php - APIs and exernal interfaces - private/tools/* - PHP plugins for PDF, excel, 3rd party utilities - private/data/* - output area for log files, report files, temp storage This is not a standard - it is what I do after 10 years experience with web apps when at a client without their own structure. It works pretty well - I make sure the private area cannot be got to from the client under any circumstances. My public PHP programs are stubs that do the following: - load the init and config files - setup the session and an XRSS token (for authentication) - load in the initial html file, css files and js files and present the initial view. The js files act as a controller for all events on the client device - they trap the event, authenticate it and send an ajax request to the ajax_gateway.php which in turn redirects it to the appropriate back-end class file for processing. The PHP callback message is sent back the JS callback function which then routes it to a JS function to update the client view. So a flow is like this: - user_login.php stub loads up the html, js and css for login screen - user enters data and clicks the submit button - the click event is trapped by the JS, user input validated and then we make a jQuery $.ajax call (ia a wrapper function) to ajax_gateway.php with the XRSS token, an action code, the validated user input (hashed and using SSL) and a callback function name - the ajax_gateway.php authenticates the token this is a valid client, then calls a back-end class based on the action code. The back-end class re-validates the user input, checks against a db or LDAP lookup and returns an ajax message such as invalid-input, valid-user, bad-password. - the JS callback function receives the ajax message, and calls a different view function depending on its contents. The view functions will update the screen and trigger a request for the next screen if the login is successful (processed by the JS controller). That should give you some idea. It looks complicated but it is very flexible. Most of my systems are collections of SPAs (for example I have a login/menu SPA, a contract management SPA, and order enter SPA etc. so each SPA has its own stub file in the public folder. This is non-framework PHP. With a framework I would lay it out according to how their examples work. Note there are pros and cons to using a framework!! I hope this helps a little bit. 
Unfortunately I don't have the slightest clue really since I don't use XML. I took a look at [simplexml](http://us3.php.net//manual/en/book.simplexml.php) and while reading XML is pretty straight-forward, there don't seem to be any code for writing XML. You could look on [packagist](http://packagist.org/) for a good XML library.
Thank you. To be honest most of the work is done by Katie, who work with me. She literally hasn't allowed us to miss a Thursday since we started, even when she was ill. Thanks for the kind words
I don't think you need a VPS, and you can do Laravel on shared hosting even without ssh access. What you have to do though is setup and develop everything locally on a linux type setup, something like Vagrant is perfect for this. This allows you to do all the composer and command line stuff from your development system because you have full access. Then you can push up just the actual site files to the production server on the shared host when you are ready to go live. I believe this is how it's done for people using shared hosting. There are also plenty of decent, cheap shared hosts that give you ssh access, allowing you to use composer, git, etc.
When the OS kills a process, that process does not segfault. SIGSEGV != SIGKILL Running a database on the same server where php-fpm runs *should not* and *does not* cause segfaults. If your hardware is going south, your processes aren't to blame. 
Congratulations! I just subscribed to your RSS feed but the formatting is a bit off, can you perhaps take a look at making it more readable?
I find it really odd you decided to use the same name as GitHub's Mantle for Objective-C. Just makes it confusing and difficult to distinguish.
 &lt;form action="index.php" method="POST"&gt; &lt;input type="password" name="openinputbox"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;?php if (isset($_POST['openinputbox'])) { $pass = $_POST['openinputbox']; if ('hello' == $pass) { echo '&lt;textarea&gt;&lt;/textarea&gt;'; } else { echo 'password not working'; } } ?&gt; Just wrap the logic in a check to see if that post key is sent on submission. If it's not, then none of the code in that block gets executed at all. FYI, you should post questions like this in /r/phphelp or stackoverflow.
&gt; When the OS kills a process, that process does not segfault. SIGSEGV != SIGKILL On both instances kernel is sending a signal to terminate an application. Both are signals (SIG*). I never said running pool on the database server causes segfaults, I stated it's a horrible practice. Re-read my comment. Please stop with the stupid straw man logic. 
cool worked , thanks
It's most useful in situations where `$i` is going to get really, really big. Arrays in php, well, let's just not say they are "light weight" data structures. If you put a bajillion things into the array to return it, you're going to balloon your memory pretty quick. A yield helps with that a lot.
In addition to what chuyskywalker said, I think it's important to note that generators are only available in 5.5 and up. Here's a year old article with a visual on php adoption rates: http://www.lornajane.net/posts/2013/php-version-adoption If only you're going to be using it though.. then feel free.
It was linked to in the comments of the article too.
thanks
It's funny how php kids have reached this simple understanding ~20 years after Java. TL;DR why invent a wheel all the time instead of learning from existing experience (and mistakes made by others)
Here is a good use case for yield: Let's say you have to test if any of a set of possible conditions is true and that list is potentially huge. Using yield allows you to return early once you find the condition you want. function testInput($input) { foreach(getVariants($input) as $variant) { if (testVariant($variant)) { return true; } } return false; } Consider this version of getVariants that return the array function getVariants($input) { $variants = array(); // Figure out each variant and add to array return $variants; } To something like this function getVariants($input) { // Figure out each variant and yield it } Depending on the problem I might end up spending a lot of unnecessary time in the first version of getVariants but the latter doesn't use any time it doesn't need to.
You're pretty close, just need to move `[$i]` slightly. It should be `$_POST['team'][$i]` because `$_POST['team']` is a multidimensional array. The way it is now, it's actually looking for an input named "team[0]", "team[1]", etc. Edit: To clarify, in HTML, when you use [] brackets in input names, it gets sent as an array. See [here](http://davidwalsh.name/checkbox-form-input-arrays) for more info.
For arrays there won't be much of a performance difference unless the array is large. Here's a more practical example. Let's say you have a function that's abstracting reading lines from a CSV. It reads from the CSV, grabs the headers, and then returns the associative array. So something like this: function readCSV($file){ $fh = fopen($file,'r'); $headers = fgetcsv($fh); $lines = Array(); while($line = fgetcsv($fh)){ $vars = Array(); foreach($line as $key=&gt;$val){ $vars[$headers[$key]] = $val; } $lines[] = $vars; } return $lines; } Loops through the file, puts all the lines in an associative array, returns the array. But what if I'm just searching for one entry? What if that entry is at the top of a 10,000 line CSV? If I call readCSV, and get the whole array, I've read the entire file in when I just need the one line and I'm done. Instead I can do: function readCSV($file){ $fh = fopen($file,'r'); $headers = fgetcsv($fh); while($line = fgetcsv($fh)){ $vars = Array(); foreach($line as $key=&gt;$val){ $vars[$headers[$key]] = $val; } yield $vars; } } foreach(readCSV($file) as $vars){ if($vars['username'] == 'JoeCoT'){ echo "This is what happens Joe. This is what happens when you fight a stranger in the alps.\n"; break; } } Now I can just iterate through the lines until I find what I'm looking for, then stop. Yields allows me to functionalize things, such as this, which have previously been rather inefficient to abstract away. It also makes abstracting dealing with things like SQL query result sets significantly easier, since you can have your wrapper function call the sql fetch command in a loop with yield, instead of having it buffer all the results into an array.
Okay, thank you!
I do like the infinite scroll concept, but I never see them done with updates to the URL that would allow the user to refresh the page and return to that offset easily. (*history.pushState/replaceState()* may introduce too many back/forward states mind you)
Forgive us, we php kids are trying to learn Java every day but it's hard
Also, what information should I be looking at to confirm/rule out potential issues?
/r/learnprogramming
You should be using vagrant instead of XAMPP. http://www.vagrantup.com/ This seems like a decent tutorial on how to get it up and running on windows (though you want to install precise32 instead of lucid32) http://aryannava.com/2014/04/05/installing-vagrant-on-windows-7-and-8/ And here's a tutorial on getting a LAMP stack setup http://fideloper.com/ubuntu-12-04-lamp-server-setup
heard of that, turned off skype...
...ok, but why vagrant over XAMPP? and thanks for the tutorials, I'm checking them out right now!
&gt; this is because generics in these languages are not covariant; ... &gt;I believe some newer languages allow you to declare your variance rules. There are plenty of examples in the Wiki article I linked. Eg: IFoo&lt;out T&gt; -or- IFoo&lt;in T&gt; Is used to mark the generic type as co or contravariant.
There are pros and cons to vagrant. 
I can only ever get vagrant to boot once. :(
I know I'm a bit late to the party, but I have a question! I first want to thank you for your contribution and putting the code out there, that's great, and when I get more time I intend to have a closer look and understand how it works. But in the meantime, I understand what 'lazy loading' means in the context of say, Doctrine ORM, where it loads a 'map' that it doesn't hydrate until an explicitly requested read, is that the same notion with a 'lazy array' and 'lazy accessors'? Is there some support built in to PHP for writing lazy accessors etc? A manual page that can be linked to? Or is this a feature provided by your library? Cheers 
Honestly I don't see the point of your function. http://codepad.viper-7.com/tPhbvz# This randomizes your teamname array along wtih the $_SESSION superglobal. This is the idea I think you're trying to implement, however if I'm wrong I'd need you to elabroate a bit more on what you're trying to accomplish to better assist you.
Your code and what you say you're trying to do, don't exactly match up. I think you're over complicating what you're trying to accomplish. Either that or you may need to be more specific. Shuffling $_SESSION array: &lt;?php session_start(); $_SESSION['teamnames'][0] = 'Team 1'; $_SESSION['teamnames'][1] = 'Team 2'; $_SESSION['teamnames'][2] = 'Team 3'; $_SESSION['teamnames'][3] = 'Team 4'; shuffle($_SESSION['teamnames']); print_r($_SESSION); Copying $_SESSION sub array: &lt;?php session_start(); $_SESSION['teamnames'][0] = 'Team 1'; $_SESSION['teamnames'][1] = 'Team 2'; $_SESSION['teamnames'][2] = 'Team 3'; $_SESSION['teamnames'][3] = 'Team 4'; $arr = $_SESSION['teamnames']; shuffle($arr); print_r($_SESSION); print_r($arr);
In short, establishes a dev environment that will/should be similar or the same as your production environment, while keeping your host machine totally clean of things like webservers, databases, etc.
You want to use vagrant in order to get your development environment as close to your production environment as possible. It cuts down on bugs in production and helps you learn how to linux which imo is one of the best skills you can have as a php developer.
You need to check the apache log files to find out what is erroring. Or try to open a cmd prompt and launch apache. If it is erroring while starting it should say why. 
Just to double check I'm understanding you right, apache starts but mysql doesn't? First thing would be to check the logs to see what's going on. Next if that doens't help you check what port you're using, you could try changing your port inside my.cnf(or my.ini) to 8306 or something else other than 3306. You could also disable whatever is on port 3306 (could be mysql already if you've installed it seperately to xampp, uninstall that). If you change the mysql port make sure to also change the port phpmyadmin connects to via the phpmyadmin config file. Lastly when you connect, specify your port in the connection function.
I made use of yield for a Twitter timeline reading class I recently wrote (and posted here before). Works great since Twitter's API works in batches of tweets per request - but using yield you can just keep foreach()'ing over the generator and internally the class makes out a new API request after the current batch of tweets have been exhaused - but hides all the logic away from the consumer - you just see it as a single iterator to work over every possible tweet in a users timeline. https://github.com/magnetikonline/phptwitterclasses/blob/master/twitter/usertimeline.php#L72 Making use of the pattern quite a bit with API connectors (Tumblr posts API is another good one I recently did).
&gt; Supervisor [...] is very light. It's not bloated at all. This project is all of 13 files. supervisord is a lot more than 13 files. Neither seems to be "bloated" from a broad point of view, but this project is certainly a lot slimmer and simpler. &gt; I love PHP but I don't think that's the right tool for the job. That's a completely fluff argument. If you have some concrete proof that a process supervisor written in PHP somehow underperforms one written in Python, please elaborate. &gt; for a project to be interesting, you have to add something new I don't think the OP presented this project as interesting or exciting. The article read more like "I found a problem and here's how I solved it" to me. Maybe you read more into it than was there? &gt; Supervisor is so simple I don't see your project as more simple. It isn't my project. It most definitely is simpler, though, from a feature set point of view. &gt; But the main problem is obviously the name, because you write a PHP clone with the same name… Fair enough. But, it's entirely likely that the OP wasn't aware of the other project beforehand. &gt; don't expect that because you can reinvent the wheel, people will get excited about it. Again, I think you may have read more into the article than was there. I didn't notice any such expectations. The OP was just sharing with the community a solution he came up with. He didn't seem to be trying to hype it at all.
&gt; Yes, each model should be assigned to a single table. Erm, nope. Persistence is an entirely distinct concern from the 'Model' in MVC. 
No, /r/PHP is an English-oriented sub. If you wish to discuss in Chinese, feel free to open your own Chinese sub.
Two types of models ... I never heard this concept before :D So if I'm implementing an e-commerce website which receives a lot of orders, I could create an Order_model handles all tasks about single order, and an Orders_model handle tasks that related to multiple orders by calling its own methods or methods in Order_model ? Thank you!
"MVC" for the web is a *very* high level catch-all for organizing your code into more maintainable chunks. When you talk to less experienced developers they will tell you to put *all* your logic into Models, and leave Controllers as skinny as possible. Or, like /u/mrterryh, they will tell you to treat Models as if they are 1:1 with your database. This idea is incorrect. If you throw all your logic into Models, then you will have bloated, complex Models that are hard to work with. Slice your code into small, logical chunks. There are many different patterns and names for these chunks, but they all have the same goal in mind: making working with your logic easier and more organized.
Btw, what If some tasks are sending emails or SMS related to orders? Still put them in Order_model or Orders_model, right? But sometimes I really feel weird to put that kind of tasks there. They don't seem to be directly related to 'orders' since they don't event update the data in the table.
Some people do it that way, which is fine for small apps that don't require a lot of maintenance, but I prefer to extract them to their own class (not a model). 
I extract the sending emails and SMS procedure into libraries. Now I have three methods to send different emails. These methods fetch order model, determine the proper messages, and then call the email library to send mails * notify_the_atm_order_expired * notify_the_atm_order_is_created * notify_the_order_is_paid . Where should I put these three methods? in Order_model?
You could use GROUP BY artist name? This would only return 1 result per artist.
Got ya, there is no real simple solution to do this in a single call. You could use a combination of functions to get the desired result. There is a good write up about selecting the top n rows from each group [here](http://www.xaprb.com/blog/2006/12/07/how-to-select-the-firstleastmax-row-per-group-in-sql/) and you could do that with grouping by artist_id. Hope that helps.
Seems like a solid small update.
Helps a ton and lots to soak in. Many thanks for the detailed response.
I see. So if I am using Codeigniter, I should create a Notifying_model, put those methods in, and call them from Order_model or controller, right? 
Uh.. No. OK, the entirety of your App does not, and probably should not, fit into one of the M, V or C's. MVC is a pattern (in the context of web) for handling the interaction with a user. Your controller, being the intermediary, can pass off calls/processing to "other" parts of your system. You might (for instance), have your controller call an OrderProcessor, which will have the responsibility of updating the orders and sending off notifications, etc. All this logic is called from the controller, but it doesn't live there, it lives... elsewhere. 
Just forget the notion of MVC. Forget it altogether and think about what you're really doing here and specifically the Single responsibility principle. Does *sending* a message by SMS or *email* really have anything to do with a model? Do those functions belong in there? Assume you'd like some things in your application that can help you *send* **emails** super easy. That's two things. A verb and a noun. Send and Email. One thing that does stuff, and one thing that is stuff. Think about the verb, the send function. If you were to create a thing that was responsible for sending email, what would you call it? Consider: &lt;?php interface Mailer { // Sends an email public function send(); } There we have it. An interface for sending email! It's not very useful but it has a very clear responsibility. It sends email. Well, in this case it doesn't send anything because we haven't told it what it can send. Just that it has a send method. And that's cool. Now think about what it's going to send, email. What would you call a thing that gets sent by the mailer? Consider this: interface Mailable { public function to(); public function from(); public function subject(); public function body(); } Interesting. That's go the properties we need. Let's tell the mailer about it and tighten that up. interface Mailer { // Sends a mailable thing public function send(Mailable $mail); } There we have it! The mailer now knows what kind of things it can send, and what methods it will have access to on the thing being sent. Now let's think about this in the context of your Order model. You want to email your order. Hmmm... ok. So based on what we've defined up above, you can only send mailable items. That's cool, for now lets make the Order mailable. class Order extends Model implements Mailable { // ... other stuff that's already in your model. public function to() { return $this-&gt;customer_email; } public function from() { return 'orders@myawesomesite.com'; } public function subject() { return 'ORDER #' . $this-&gt;order_number; } public function body() { return 'The current order status is: ' . $this-&gt;status; } } Super fantastic! So now we can email ORDERS! Here's how you'd do it. First we need an ACTUAL mailer, not just some dumb interface. class AppMailer implements Mailer { public function send(Mailable $mail) { mail($mail-&gt;to(), $mail-&gt;subject(), $mail-&gt;body(), array('From: ' . $mail-&gt;from())); } } Cool beans man. So we got this mailer thing. (Note: Code just scratched out here, can't remember header values for from address so this is probably broken but you get the idea). Now we want to email an order so let's do it. &lt;?php $mailer = new AppMailer; $order = new Order; $mailer-&gt;send($order); Wow. Code should not be this easy! Look at that! My 7 year old could tell me what that code does. What he couldn't tell me is how the mailer knows that it can send an order, and he raises a good point. That's not immediately clear from the code, a mailer can mail an order? An 'order' doesn't strike me as the type of thing that a mailer would be interested in, it wants mail, not an order. The other thing you'll find is that your "body()" function grows huge. Imagine trying to cram an entire HTML email inside that function! So silly. That doesn't seem like it belongs in the model at all. Hmmmm... hows about we separate that logic rather than embed it in the actual order? First get rid of the extra crap we threw into your model. Now let's make a separate mailable thing for the order. class OrderMail implements Mailable { /** * @var Order */ protected $order; public function __construct(Order $order) { $this-&gt;order = $order; } public function to() { return $this-&gt;order-&gt;customer_email; } public function from() { return 'orders@myawesomesite.com'; } public function subject() { return 'ORDER #' . $this-&gt;order-&gt;order_number; } public function body() { return 'The current order status is: ' . $this-&gt;order-&gt;status; } } Jeez man, that's a LOT of classes! It sure diddly is. But look at THIS! &lt;?php $mailer = new AppMailer; $order = new Order; $mail = new OrderMail($order); $mailer-&gt;send($mail); So. Cool! Take that logic, slap it in a controller method, add the requisite shit for data validation and filling the order model, and Bob's your uncle. 
Wouldn't say small - Varidics/splats are a pretty big edition to the language along with constant scalar expressions (finally!). But yep - a solid update.
Tainting variables does not change them. If Library X is perfectly secure with taint enabled then it would be perfectly secure with it disabled (or running on an older version of PHP). It's a warning system. I'm not convinced it's a great idea but that isn't an argument against it.
OH I see. Took me a few reads but I better understand what you're saying now and how it works. Thanks!
Did this get the BC `unserialize` fixes from 5.5.14? Otherwise, I can't really test my code on it yet: don't think Doctrine2 nor PHPUnit have tagged a stable release with their fixes for the break. And, yes, I happen to be using `-&gt;disableOriginalConstructor()` in a few tests. Edit: Nope. Looks like it didn't.
&gt;/u/svenvarkel we are still learning the way Java guys are still learning from PHP reddit. I'm both personally - a Java guy and a php guy. That's why I have pretty good base for comparison. The odds are not for PHP when we talk about tools, processes, code quality, developer quality etc. I'd be happy to see php world taking more stuff over from java. Good example is Doctrine2. It's created based on great java library - Hibernate. 
I'd split it up into 2 selections. First one takes 2 songs from the current artist. Second one, takes 8 songs from every artist, that is not the current one. Then just add the lists together. Something like SELECT * FROM songs WHERE s.artist = songs.artist AND song.title != current_song.title LIMIT 2 UNION SELECT * FROM songs WHERE s.artist != songs.artist AND -whatever criteria you use to select specific songs or bands- LIMIT 8
Fuck yeah. About time we see a shitty commit record on a project instead of a squeaky clean fancy nancy mumbo jumbo spewin commit record. I hold a beer up to honor dvorakkidd on his realistic and honest commit comments.
Have you never ever heard of "Don't reinvent the framework?" a common phrase here on the web
Feels like PHP going towards a classical ASP approach
Thank you Thank you Thank you Thank you !!!!! Love you Love you Love you Love you Love you !!! :DDDDD I will try to imeplement this!!!
 Classic ASP? /shiver
https://drive.google.com/file/d/0Bxhu5ENE3HgrZVE0LTduRUktNGs/edit?usp=sharing https://drive.google.com/file/d/0Bxhu5ENE3HgrbnRScHpLQjh2OTg/edit?usp=sharing Here is a JPG file (input) and a broken webp file (output)
Perfect explanation. +1
I'm looking forward to having phpdbg bundled by default. I've always found Xdebug to be unbelievably painful to use.
Um, one thing here...I'd still recommend regenerating the token for each request/form. If you use the same one for all forms across the entire site for a user's whole session, you leave it more open for issues that could be caused by XSS. Remember, XSS doesn't have to be a site-wide thing. It could only happen on one page with one form in the site and, if you're not rotating it, the attacker would easily get that one token.
I've not had any problems with xdebug, I had issues with setting it up initially. But now I have it hooked up with PHPStorm I find it's pretty easy to use. What do you find painful about it? 
how so?
Look closer. I'll give you a hint. If `$_GET['id']` was "foo", the generated SQL would be: UPDATE users SET isAdmin WHERE id = foo
Not saying anything against phpdbg, but the issues of vagrant is not xdebugs issues definitely. I don't get why people like it, it's just a very-hard-to-control-isolated-environment. It's like asking for some problems :)
Sorry, but I fail to see how anyone can possibly think Vagrant is hard to control. The whole point of it is that you have complete control and can easily replicate your development environment to another machine if necessary. If you can write a shell script, you can throw together a Vagrant config for your needs. It means that you know every developer who is working on the project is using the same setup and so you can avoid the "well, it works on my machine" problem. It also means you can store your server setup under version control rather than all having to use the same version of XAMPP, and different projects can use radically different setups. You can get the two working together, but it can be tricky. However, once it's done it's done you can replicate your Vagrant config for new projects.
Looks great, but I do get the feeling it's fixing a symptom of Composer being dreadfully slow (which I hope will be eventually fixed).
Someone here did offer to make a standalone cross platform lightweight xdebug client if we fund it for him, but we all shot him down. To be fair, what he way claiming to make seemed like much more work than he would have thought, and the costs shouldn't have been able to cover it. Plus we didn't know anything about the guy.
Yeah, that's largely why I wanted it. However, the vote's not going in our favour at the moment. 9:1 against. Was 9:2, but philstu removed his vote :( EDIT: There was a major screwup with the literal and dereference RFCs having the same voting widget, so the votes were reset.
I am glad this is getting a negative vote. For a guy who works with JS and PHP every day, I understand WHY this is asked, but it is clearly just a copy of the JSON notation over to ONE component of PHP; if you're going to bring over JSON notation, at least bring it all over instead of just one small facet. The other thing is that I don't think it fits well with current PHP "standards" being that they very much look like variable names, yet don't have the leading $, which to me, would introduce mass amounts of confusion. In addition, the only "positive" thing I see mentioned about this approach is that it is less keystrokes... which IMHO is a terrible reason to change implementation of a language construct =/ IMHO, if you want to write your arrays like this, simple do a json_decode on a string you have constructed in this way, and you have done it. Wrap json_encode in a function called j() and you can save yourself 10 characters. win/win.
I would rather have the colon as an optional replacement for the =&gt;. This proposal just adds a lot more inconsistency to array syntax.
I think he is referring to the RC1 compared to beta 4
Thank you for the love :-)
I think that instead, they should focus on integers and floats having the same upper and lower bounds on every machine. This RFC doesn't look like it changes that. There is very little use for big integers and there is already an extension for that. So in my view, nothing is actually added here. Add to that that you can't declare a variable's type in PHP and then this becomes nothing but a source of unnecessary bugs.
I've downvoted your post because your form class written with multiple bad practices. To start, it's a huge violation of the [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle). It's doing at least three things: 1. Validating data 2. Sending a contact email 3. Rendering the form HTML Instead of accepting the relevant form data flexibly, you're referencing $_POST a dozen times inside that function, which has absolutely no benefit whatsoever and means you would have to fake post data in order to test it. You provide no [CSRF](http://en.wikipedia.org/wiki/CSRF) protection on a form that submits an email to a third party. I could spam/DOS someone using your server by submitting post requests to your form a few hundred times a second. In addition, there's no way to test that the form submits an email without actually submitting the email and just seeing if it shows up in your inbox. Your form class shouldn't even be rendering HTML, it should be passing the relevant data to a template. If you're not doing that, you should return the HTML as a string. But you're just echoing it out instead, which means that your ability to control where and how the output is rendered is more complex. Here's how I might implement something like this, in case you're interested: https://gist.github.com/thepsion5/c8c1bae57c3563938db4
Yeah I dont like the bare names. Bare names in PHP are constants, and that's probably the most consistent thing in PHP. The colon replacing =&gt; syntax is somewhat nice though
this sort of accomplishes what i'm going for but i'm hoping there is an easier way. $dup = null; $count = 1; $list = array(); foreach ($results as $key =&gt; $v) { if (!empty($dup)) { if ($dup-&gt;song_artist === $v-&gt;song_artist &amp;&amp; $dup-&gt;user_id === $v-&gt;user_id) { $count++; if ($count &gt; 1) { # code... continue; } } } $dup = $v; $list[$key] = $v; } $pagination = count(list);
Requests take too much time compared to the code, so it won't help much.
It probably would, but the voters knew it wouldn't pass regardless and so they didn't bother to poke holes in the RFC.
I'm not so sure. When I use HHVM instead of PHP to run Composer, it's like 10 × faster.
The [dereferencing RFC](https://wiki.php.net/rfc/bare_name_array_dereference#vote) is just as odd in my opinion. The only savings you get are a slightly shorter syntax - which I don't think is outweighed by the potential for confusion. Use an IDE.
Experienced any issues that way? Been thinking of trying it out.
cus·tom·er noun \ˈkəs-tə-mər\ : someone who buys goods or services from a business
I am getting addicted to functional programming in PHP, so this is definitely a large release for me. I will use these A LOT: use function [iter](https://packagist.org/packages/nikic/iter)\map; use function [React\Partial](https://packagist.org/packages/react/partial)\bind;
Would you mind elaborating in this a bit? I'm interested but I haven't heard about this specifically. 
dic·tion·a·ry noun : something you pull out to support your one definition, with no acknowledgement other definitions may exist or be more appropriate.
No. `foo =&gt; 3` continues to resolve the constant. `foo: 3` does not.
You are absolutely right, sorry. Ran my mouth off before reading properly!
No, it makes *generating* JSON easier as string key arrays are currently a pain.
How, exactly, does an IDE help? It can fill in quotes, sure, but it's no less keystrokes.
One of the motivations of this was that it would give us a clear syntax choice for named parameters if/when they are added, and they'd be completely consistent with arrays.
How would it cause bugs?
In Intellij at least, dereferencing only involves typing the first `['` as the end part are auto-filled. I'm sure Vim and others can be configured to map `identifier: val&lt;RET&gt;` to `'identifier' =&gt; 'val'`. I just don't think brevity should come at a cost of clarity when it comes to syntax.
Hi, please ask /r/phphelp
I just starting using HHVM + Composer yesterday, and the results are amazing. Normally Composer takes a couple minutes to update a Symfony project that has dozens of dependencies, but with HHVM the same update takes 20 seconds. The difference is like night and day. So I think porting Composer to C/C++ might be a worthy endeavor. Heck, any other multi-threaded scripting language would be better than using PHP. Even using Node.js might be an improvement because of how I/O heavy Composer is, and how quickly Node handles those kinds of tasks. I'm thinking Jordi could make better use of his time by writing and publishing an official Composer specification, and let the rest of us develop tools built to those specifications in which ever language we feel is best.
I use Vdebug extensively. I'd suggest checkout that out.
And how is it tricky to get xdebug working with vagrant? Especially if you're a VIM user. What are the specific issues?
&gt; Even using Node.js Please, no. &gt; an official Composer specification Isn't most or all of this already (indirectly) in the documentation? A Composer user needs to have much of this information available to understand how to configure a package (versioning, dependency contexts, `replaces`, etc.). There'd be a fair bit of reverse-engineering involved but much of the core must, by necessity, be quite stable, and that will only be more true now that it looks like Composer itself is finally being versioned. It could be an interesting project but there'd be a lot of catching up to do. As an aside, PHP is capable of parallelism. It just never really gets used.
The string key arrays would stay exactly the same, it's only the way you write array literals that would change. So I guess you're telling me that you're currently spending a lot of time writing array literals in PHP and then converting them to JSON. I have a hard time coming up with a bona fide use case for that, that cannot be exchanged for a much more convenient construction (such as writing JSON literals).
PHP is written in C, and PHP integers are currently implemented as native integer types. This change, but I may well be wrong, will need to hook into any point any PHP int is used, and juggle between native integer types and class variables.
awesome content and guide, thank you for sharing. 
Yes, it's expected behavior. Why do you write so much instead of typing some stuff into Google?
During sleep(10), the PHP process is sleeping and the CPU is free to work on other processes. Therefore, this does not count as "execution time".
Thanks! The route matching engine is based on the core from Nikita's. I think this library differs in a few ways - The reason I created it was to offer a clean routing interface, a full feature set, with 100% test coverage. All this underpinned by a fast routing engine. I am a big fan of the laravel routing library, so I chose to offer a similar interface. Key features include: * Named routes and reverse routing * Restful controller routing * Route filters and route groups There's lots more information about these features in the readme along with examples for all of them, so that's probably the best place to see what the library has to offer. Reading from the specific line you quoted, the main feature addition to the core is optional route parameters which were not included in the original core. Other changes were mostly interface and how the objects were composed. Hope that answers your question! Thanks again for the feedback
I did get it working in the end, but it was an uphill struggle. I think more than anything else, I just don't want my debugger to be integrated with my editor in that way - it's inimical to the way I work. I would much rather have something I can interact with from the terminal, and phpdbg seems to fulfil that pretty well.
Most likely, `$stmt` is null. Check the result before you try and bind to it--you likely have a syntax error in your SQL.
Just ran a check it does not seem that way.
As a side note, those people actually coming from Google will appreciate /u/ArthurOnCode's response (even though this could be easy to find elsewhere).
I think you might be right :)
Pretty much all of it :/
I'm not a fan of it at all either. I find it hard to follow and the lack of actual examples a bit annoying. That and it change far more often than I'd like.
I don't know about facebook sdk, but whenever I find something hard, I try to consider that there may be a reason for it. This is because a guy on IRC once pointed out something to me which was pretty interesting. He said, "you'll spend most of your career being a non-beginner". Maybe facebook people made something which isn't simple for beginners, but which will pay off later when you become intermediate/expert on it. I'm sorry if this isn't much helpful. Your question just reminded me of that. I remember asking this IRC guy once why XYZ software docs were so complicated and expert-friendly. He told me something along those lines, and it was enough to get me thinking.
The way we're doing it at work is that we're POSTing the user/pass which generates an oauth token which is returned by the server (symfony). Then in all subsequent API calls, the app adds that token to the header. The server pushes the token expiry back everytime the web app makes a call. If the token is expired (401 on an API call), the app pops a login prompt in a modal (it holds the request promise that was made here to resolve it afterwards) and asks the user to log back in. When he does, the app sends the request again and resolves the initial promise with the new request's results. The initial login could be more secure with proper oauth implicit grant, but that was overkill for our needs.
Best bet would be to research a specific use case - "I want to do foo" - and search Stack Overflow. Usually some good examples to be found. You could also look for some boilerplate code projects on Github. That's a good way to find working examples, assuming it's a current repo.
This scares the shit out of me.
"Do not use it for malicious purposes!" http://static.gamespot.com/uploads/original/1510/15104833/2431101-1001960865-micha.gif
It's a fun toy, but I'd never...ever...ever use this in a real production setting. Anything apache has access to do on this machine, you have access to do as well. It's also a pretty wide-open vector for looking at the rest of your network. TBH, if you need console access, it's pretty easy to just use SSH. :-P To be fair: &gt;Also make sure the machine is properly firewalled (port 80 should not be reachable from the Internet). But I'd still never use it... &gt;.&gt; This is exactly the sort of thing you find on a webserver that's been compromised. First thing they do is install a script like this, usually also written in PHP, that lets them browse around on the command line. I've seen it before...
Your probably didn't bother doing any research or hell, just opening up their documentation pages and reading through it. Get off reddit and try again.
&gt; Heck, any other multi-threaded scripting language would be better than using PHP. Yeah right, to write a tool (which is a part of the php ecosystem) in other *scripting* language. &gt; So I think porting Composer to C/C++ might be a worthy endeavor. and wait for decades to get updates and bug-fixes. the main *thing* in writing that tool in php is that other PHP developers can contribute to that project.
I haven't spent any time with Laravel/Eloquent, but Doctrine has a nice [data fixtures bundle](https://github.com/doctrine/data-fixtures) on the symfony2 side. It should be framework-independent, though it would require the ORM. Might be something similar in the eloquent world
Nice solution. Planning on dropping FOSUser here soon to approach the API re-auth issue (forced redirection on auth token invalidation...booooo.) At the moment we're in the process of migrating to symfony from a completely custom (but kohana-esque) framework, we only have LDAP authentication, though manual account registration is next up on the docket. We perform on demand synchronization to the configured LDAP server and grant/remove roles based on configurable group memberships. The user's data and roles are saved to redis for faster/less intensive re-authorizations, and expire every x minutes which requires retrieving the user from the 3rd party source. This lets us scale back the amount of auth requests hitting the LDAP server, keeping the symfony role assignment fairly automatic, and allows for a user's authorization to be revoked behind the scenes if needed. Just figured I'd share. We're looking at evaluating Auth0 for more of an SSO-type approach for traditional/social user reg/login in addition to enterprise users. 
Did you read the documentation for `prepare` or MySQLi's prepared statements? [The first one](http://us.php.net/mysqli_prepare) explains what it can return in case of an error, and [the second one](http://us.php.net/manual/en/mysqli.quickstart.prepared-statements.php) demonstrates how to get the actual error message in this case... If you're getting error messages referring to non-existent line numbers, make sure you are looking at the right file. If you transferred this file to the test server via FTP, make sure you are using binary mode to transfer files, not text mode.
Forreal? I learned PHP by using the FB SDK. It was pretty easy IMO.
OAuth?
&gt; "Sometimes you want shell access from the browser." No...no I don't.
Basically, there's no real need for an index.php in the document root if you're only using a single front controller. You can do this via the PHP built-in web server: php -S localhost -t /path/to/document-root /path/to/front-controller.php This will route **all** traffic through the front controller, but you can return false from the controller to fall back to file serving. Read more [here](http://www.php.net/manual/en/features.commandline.webserver.php). It's also possible to tell Nginx to do something similar, but I can't find a good example right now.
Every operator *already* juggles types between integer, float, true, false, null, string, object, array, resource and reference. This just adds a new set of supported type pairs to existing operators.
It's good if you don't have SSH access, or really need SSH access as the apache user.
To me the 'M' in MVC is the same as the Business Layer in the 3-Tier Architecture (see http://www.tonymarston.net/php-mysql/3-tier-architecture.html). All knowledge about the application is contained in the Business layer while the Presentation layer (which contains the Controllers and Views) and Data Access layers are completely application-agnostic. I personally create a separate Model class for each database table, and my framework provides reusable components for Controllers, Views and Data Access. Each Model class contains all the information it needs on that database table, which allows field validation to be performed automatically. Relationships with other tables are also dealt with automatically. I don't need to use that abomination called an Object Relational Mapper. As for the question "should I avoid using $_POST and $_GET in the Model?" the answer is YES. It is only the controller which should refer to these explicitly, and it should pass them to the Model as arguments in a method call such as this: $result = $dbobject-&gt;insertRecord($_POST); $result = $dbobject-&gt;getData($where); I do not use separate classes for dealing with single rows and multiple rows as the result set produced by a query can contain any number of rows.
I think this is a problem best left as it comes up. Planning the syntax in a highly anticipated addition in an RFC for a feature very few want that of itself has no benefits and only drawbacks... Not good thinking.
How is `'{"foo":3,"bar":true,"baz":' . json_encode($qux) . '}'` better than `json_encode([foo: 3, bar: true, baz: $qux])`? The latter is best practice (using a parser) and less error-prone. People already deal extensively with generating JSON from PHP arrays. Writing JSON manually is never a good idea, so we should make arrays more convenient.
If you don't have ssh access, there's probably a good reason.
&gt; How is '{"foo":3,"bar":true,"baz":' . json_encode($qux) . '}' better than json_encode([foo: 3, bar: true, baz: $qux])? The latter is best practice (using a parser) and less error-prone. Exactly my point: you're doing it wrong to begin with. BOTH of those I don't like. You're better off building an array and then `json_encode()`ing the whole thing. Again, you're just hard coding PHP arrays and making JSON out of those, and again, I don't see a use case for that. You want to hard code JSON, then hard code JSON. You want to generate JSON dynamically, then generate it dynamically.
Because every developer think they can at least get users' email via Facebook API, but actually Facebook didn't promise this. If you implement member system with Facebook data and use email as primary key, you will write very buggy code. I think a lot of developers had been fucked up by this. https://developers.facebook.com/bugs/298946933534016
Oh sorry, I meant not control, more like tying parts together when they are in different environments. Xdebug is a showcase, it can also be just forwarding ports from your vm to the host machine. Also, it kinda forces you to use some things that you might like not to use, for example for our project guys use bash - I don't like it, I prefer zsh, but need to install it every time someone updates vagrant file and tells all the people to update their VMs. There is some other examples in this regard - I like to turn on autostart for xdebug, which is by default turned off in our vagrant setup, also there's usually some mess with port used for xdebug... I don't like the argument "It's easier to start for new developers in your project" because the tradeoff then is that they won't know how their project works, what architecture it uses, because it was all built automatically in vagrant... And the complexity of this "setup your environment" thing is usually like O(1) while you will have to work with this system all the time from start to the end of the project, so I prefer to spend some time in the first couple of days than wondering what goes wrong and why solr gives me "bad request" response and how can I know what's wrong with my request...
Because it feels as if nobody took time to create a sane interface, options are everywhere and can be hard to track. Also, it becomes worse when you decide to install themes which come with slightly modified versions of the original modules because the trend is to create a whole config panel for those slight modifications what become poor and/or faulty adaptations from the original module (i'm looking at you, multishop)
You need to know the time zone the user is in. Normally you want to "only" store UTC times/dates in your database but combined with a time zone you can convert this to anything you need/want. If you don't store the time zone for a user you might be able to retrieve it from the client with Javascript.
You should add BazingaHateoasBundle to that list!
for the record we didn't modified the format, we just added a check which validates that the proper serialized format is provided for unserialize() for objects implementing the Serializable interface. the change didn't affects anything produced by unserialize, but indeed it can affects people/projects manually crafting invalid serialize strings.
Ignoring the technical debate - this RFC isn't going to be possible. The GMP library is dual licensed under GNU LGPL v3 and GNU GPL v2.0, which is not compatible with the PHP license. Implementing this RFC would fundamentally require anyone selling a PHP application to provide the source code, which is a massive license BC. To clarify, PHP would still be distributable freely as source code. But anyone creating something like a Docker application, that distributes PHP as compiled source code, and so would have linked against GMP, would be subject to the LGPL. Although there might be ways around that for Docker - for people who produce standalone executables using PHP, [yes it's possible](http://stackoverflow.com/a/9046775/778719) - even it's not a fantastic idea, would have at least some of the LGPL restrictions on them. I don't see anyway around this. 
You missed one subtlety; currently if you have: ``` float + float =&gt; the result is a float. int + int =&gt; the result is an int. string . string =&gt; the result is a string. ``` etc. This RFC adds new behaviour of: ``` int + int =&gt; the result is unknown. ``` Making it harder to think about code seems like a massive problem with the RFC.
You can also check out http://www.php-login.net/
Holy shit dude. That's it. How can I prevent this?
&gt; This probably doesn't need to be said, but as engineers we need to be pragmatic and choose the right tool for the job. Yeah right, Well lets write all the php frameworks in java. If you are looking for more speed. consider writing composer in x86 assembly. &gt;That's a weak argument. The PHP community is overflowing with C/C++ developers, as C/C++ goes together with PHP like jelly goes with peanut butter. Since When?? PS: I hope that php will use libuv for IO Operations.. That along with jit might solve lot of probs (that you say) php has (i personally think that php doesnt have any language issues).
Just to have some fun with the SDK, I want to create an app that is very similar to Watch_Dog's [Digital Shadow](https://digitalshadow.com/shadow.php) Once I figure out how to use the SDK, I can figure out everything from there :)
I have read up on their documentation. I've used Twitter's SDK in the past and that was a breeze to understand. Care to explain the latest SDK? 
This is great, thank you
I've used Twitter's SDK in the past and that was very easy to understand. I agree on the part that Facebook is notorious for rolling out a lot of platform changes. Last time I used the SDK was a year ago and alot has changed :/
No. I'm not going to do your job for you. Google is at your disposal. Use it.
&gt; int + int =&gt; the result is an int Not always: PHP_INT_MAX + PHP_INT_MAX That will yield a [float](http://3v4l.org/N3H7d). So, no. And with dynamic typing in general you can't say generally that "type OP type" will be a specific value for all operations. Many depend on the actual value of the two types, not just their type...
Only heard of, but haven't used myself https://www.grc.com/sqrl/sqrl.htm 
&gt; Implementing this RFC would fundamentally require anyone selling a PHP application to provide the source code, which is a massive license BC. That's not how the LGPL works. If PHP directly used a GPL (not LGPL) library, then PHP would need to be GPL licensed. Which means that any forks of PHP itself would need to be made available under the GPL. But not code written in PHP the language. Also note that LGPL provides an exception to this for libraries. In fact, PHP already ships with bindings to the LGPL GMP library [in core](http://lxr.php.net/xref/PHP_TRUNK/ext/gmp/). LGPL provides this ability in the [Combined Works](https://www.gnu.org/licenses/lgpl.html#section4) section. Also note that with the LGPL, simply including a header file (which is what PHP does) is covered under [Section 3](https://www.gnu.org/licenses/lgpl.html#section3). So no, nothing would change about PHP's license, or how it behaves. If it was the GPL, then yes. But LGPL isn't as evil (it's still evil, don't get me wrong). 
Bonus points for being written in pure ASM with Gibsons special brand of woo mixed in for good measure.
[`sleep()` is a system call](http://en.wikipedia.org/wiki/Sleep_%28system_call%29) . Thus it doesn't affect the timeout. 
Exactly! I might add that yield is also a pretty lightweight substitute for iterators in some cases. but bear in mind, that this is ye olde trade between cpu and memory, where you always have to decide if it's better to have data precomputed in memory, or compute them dynamically at run-time. both has tradeoffs and advantages. 
&gt; cycling that token value is a simple step that can help prevent automated scripts from trying to brute force the form. CSRF tokens are supposed to prevent attacks where the attacker takes advantage of active user's session to act as the user by getting the user to load the page with the intended payload. Brute forcing is impossible in these scenarios because the attacker cannot invoke enough requests using the victim's connection to have any chance of guessing the token correctly. &gt;but what if you don't have an XSS vulnerability If the attacker can retrieve any session based CSRF token via any means, it usually means you have bigger problems to worry about than any protection the CSRF token can provide. Thus, regenerating the token does not provide any additional security in such cases and is unlikely to mitigate any other vulnerability either. &gt;Remember, though, that security is a balance between keeping the application safe and user frustration. Regenerating the token on each request breaks any action that requires a CSRF token when using the 'back' button and quite possibly when browsing the site using multiple tabs. Depending on the site functionality, this may also be a major usability issue. On the other hand, regenerating the token on form submissions can be used to prevent double form submissions. There *may* be a few special cases, where regenerating the token *might* improve security, such as if the website's traffic is high enough that entropy of /dev/urandom gets lowered considerably. Taking advantage of these cases, however, tends gets highly theoretical and unfeasible. Unless you're doing banking or working as a security contractor, don't worry about it. It is **not** inherently wrong to regenerate the CSRF token on each request, of course. Simply understand that it does not usually provide additional security to what CSRF token is supposed to protect against (or against any other vulnerabilities). Because of this, it is usually not worth the usability issues it causes.
Have you looked at Json Web Tokens? It's a new type of authentication but it's simplier than oauth and works very well with separated frontends such as angularjs.
If you want to do the timezone conversion in PHP you can use the DateTime class. e.g. $dt = new DateTime('2014-06-22 11:10:58', new DateTimeZone('UTC')); $dt-&gt;setTimezone(new DateTimeZone("Europe/Paris")); $dateString = $dt-&gt;format('Y-m-d h:i:s'); [DateTime](http://www.php.net//manual/en/class.datetime.php) has been around since PHP 5.2. 
I was discussing this with Hakre earlier.....so it turns out it's complicated. You're right that it wouldn't affect distribution of PHP source, but I think it would affect people who distribute things built on PHP. And yes just because the header files were touched during the compilation process, because the actual library isn't used, then the LGPL wouldn't apply. Currently people can disable the GMP extension (I assume), and they are then free to compile PHP and distribute that binary as part of an embedded application. e.g. through either Docker or through something that generates an executable file. If GMP was a required part of PHP core that would no longer be the case, as the Docker app, or executable would now be distributing and using the LGPL code, which would now make it a 'combined work' which would impose the requirement: &gt;You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: &gt; ... &gt; Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. i.e. That would be required to give out the tools to rebuild the application. Even if this didn't affect the copyright status of the PHP source code, it would effectively mean that it would need to be distributed somehow. Additionally, the GMP library is presumably going to be required to be compiled statically against PHP core? It would be really odd if it could be compiled as an extension. That would mean that any other extension that is statically linked would need to be provided as source code so that people could rebuild the PHP binary that is part of the 'Combined work'. _TL:DR_ It's not going to affect copyright, but it will make it a requirement to add the ability to recompile applications distributed with a compiled version of PHP. 
No. Int + int will now always give an int. Currently it gives a float if overflow, else int.
Also, bigints would actually make the output predictable, so far as userland cares, as you'd always get an int.
Is this really a problem? Linking to the source is enough, and gmp could be linked dynamically.
JSON would handle numbers by using an integer if it's an integer, or a float if it contains an exponent or decimal point. Also, operations involving floats already result in floats, and divisions always result in floats unless there's no remainder already. EDIT: Maybe you're confused by reference counting? Strings and arrays are reference-counted and copy-on-write, just as bigints would be. They don't have "reference semantics" like objects. EDIT 2: JSON *does* support big integers. It does not specify a maximum or minimum number length, and in fact there is no integer/float stipulation. However, some languages implement it as a float, so we could add an option to encode as a string. Actually, you already need to do this (Twitter does!) as JS 64-bit floats can only represent 53-bit integers losslessly.
Might want to check: https://www.owasp.org/index.php/Guide_to_Authentication http://stackoverflow.com/questions/549/the-definitive-guide-to-form-based-website-authentication
I usually integrate PHPass into anything I do myself. http://www.openwall.com/phpass
I think taking the time from your DB and displaying it with a javascript conversion would be the best way to go, unless you log a users timezone in your db. http://stackoverflow.com/questions/6525538/convert-utc-date-time-to-local-date-time-using-javascript
Thanks, I wasn't aware of the 53-bit Javascript limitation. But I still think plays into the handling things that might be big ints should be done explicitly rather than transparently. 
Wiki knows best: http://en.m.wikipedia.org/wiki/ISO_8601 The trick is in datetime format - it should be in ISO_8601 format with time zone INFO in it. Before storing in mysql apply (increase/decrease) timezone interval on utc part. There is CARBON lib which can helps too.
Isn't this just something that could be implemented in a static language?
If you're distributing an application as a product (like a docker app, or a compiled executable) then no, linking to the source of PHP isn't enough. You need to make your application be rebuildable with a new version of GMP. i.e. you'd need to provide a set of tools and either source code for the rest of the application or a set of binary files, that enable people to rebuild the application. tbh that might be acceptable to the PHP community, but it is a large license change.
I love all your contributions that aren't blatantly self-promoting spam.
No code, no help. Also, this sounds like a job for /r/PHPhelp.
Why are you using mysql_connect? It's a deprecated, old, broken library. Use mysqli_connect() if you have to.
The bug here is relying on `max_execution_time`, which as you can see is about as useful as `safe_mode` was: wildly inaccurate and behaves completely differently between OSes. If you need to enforce a maximum time limit on runaway processes, use hard OS resource limits and a fcgi-respawning daemon.
Are you crazy? There are applications where users definitely require authentication and security from each other.
&gt; 172.31.3.42 Is this server listening remotely or only locally? I believe MySQL is set to only listen locally unless you configure it and add an account to listen remotely.
Dont use mysql_ functions. They're outdated, insecure, and deprecated. Use mysqli pr pdo instead. I'm on my phone, so no links for now...
Nope. Sorry. There's never a good reason for this. &gt; You should always update and patch PHP to the latest version to prevent exploitation of known security holes. Tools like “disable_functions”, “open_basedir” and Suhosin reduce the attack surface and prevent exploitation of unknown security holes. You can use them to create implement a layered security strategy. Also do not forget about privilege separation. Yeah... All the bandaids in the world won't help when you just took a chainsaw to your gut.
If you need their timezone, it is easier to calculate it in javascript, something like: var time = new Date(); var timezone = "GMT " + -time.getTimezoneOffset()/60; If you need PHP to have access to that, I suggest passing it via an ajax call and setting it as a session variable. For a pure PHP solution, based off the client, you would have to do some Geo-IP lookups or something of the sort.
What different type of int? Bigints still give fractional values. Where did I ever say they don't?
Interesting, but I doubt that I'll ever use it. The performance impact of using getters isn't great enough to justify having another dependency... at least to me. 
Thanks, that seems like a good plan.
This is why uniform access of properties and methods is a neat thing - which this library exactly does for PHP. Just for clarification, uniform access means instead of $obj-&gt;foo; // property, probably fixed or state or... $obj-&gt;foo(); // usually a calculation you just write $obj-&gt;foo; // i dont care if fixed or state or calucalted, just get me foo
Make the property private and the method public or protected (and optionally final) and this problem goes away. My issue with solutions like the one provide here is that it is magic - you can't look at the code and immediately know what's going on, which should be priority 1.
&gt; So, you haven't read the patch then. Better than that, I *wrote* the patch! If I might direct your attention to `div_function` in `Zend/zend_operators.c`: case TYPE_PAIR(IS_BIGINT, IS_LONG): if (zend_bigint_divisible_long(Z_BIG_P(op1), Z_LVAL_P(op2))) { zend_bigint *out = zend_bigint_init_alloc(); zend_bigint_divide_long(out, Z_BIG_P(op1), Z_LVAL_P(op2)); if (op1 == result) { zval_dtor(op1); } ZVAL_BIGINT(result, out); } else { double out = zend_bigint_to_double(Z_BIG_P(op1)) / (double)Z_LVAL_P(op2); if (op1 == result) { zval_dtor(op1); } ZVAL_DOUBLE(result, out); } return SUCCESS; The meaning of that should be fairly clear; if divisible, it does an integer division, else it will do a traditional floating-point division. The internal function `zend_bigint_divide_long` does an integer division. I should maybe clarify that in the comment describing it, though I would have thought it was obvious given that its output is integer.
[behat](http://behat.org) For obvious reasons. Behavior Driven Development is very important for just about any programmer. 
Agreed. That's a very cool way to do it though. Thanks for the share.
Horse shit driven development is also obviously important!
I love SVN for the repo, great for version control and caters for that time you thought you had to rewrite code because you think it was messed up... Then I use Sublime Text 2 for my text editor. Cygwin to give me a bash terminal (I use a Windows pc). Grunt JS, Photoshop, FileZilla, XAMPP.
I'm gonna have to see how to implement this for websocket connections.
This was a great explanation. Took the words tight out of my mouth. 
Right now... * Git * Nginx/PHP-FPM * Sublime Text 3 * LineEndings plugin * GitGutter plugin * Flatland theme * TodoReview plugin * SCSS syntax highlighting * Navicat MySQL/MariaDB * MariaDB * Redis * Rsync * Docker 
I'll add Gitolite, Vagrant, Puppet, Composer, Twig, ircmaxell's password_compat library, tmux and zsh.
PHPStorm, best PHP IDE ever. Vagrant, provisioning made easy especially when working in a team. Git or any decent VCS, because fuck you if you don't. 
And why don't we write the php interpreter in php... 
The term model as you are using it is incorrect. What you are referring to as a model is actually a domain entity. It's a very common misconception, mostly stemming from rails usage of the word model. Model in mvc basically means all application specific code used to solve whatever problem your code is meant to solve. 
I prefer CodeCeption over Behat because it offers acceptance, functional and unit testing. I think it's just personal preference though.
If you're distributing a compiled version of PHP as part of an application, then no, you'd need to provide a way to rebuild the application if the user wanted to modify GMP. &gt;Combined Works. &gt;You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: &gt; &gt;0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. I'm also not a copyright lawyer, but I'm pretty confident that a docker app, or a PHP application that has been compiled to a single executable file would be considered a combined work and so the whole Docker app, or compiled executable would need to be rebuildable by end user. This doesn't mean you would need to ship the source code for everything in the 'combined work', you could ship binary blobs, and a build script to build the application, so long as the final modified application worked. As I said above, this wouldn't affect copyright of any distributed apps, just what would need to be shipped with the app. 
Salt has made everything so much easier, but I'll also second redis and git.
&gt; If you're distributing a compiled version of PHP as part of an application, then no, you'd need to provide a way to rebuild the application if the user wanted to modify GMP. Only if GMP is linked statically. If linked dynamically, you don't need to anything. So says the FAQ anyway. &gt;This doesn't mean you would need to ship the source code for everything in the 'combined work', you could ship binary blobs, and a build script to build the application, so long as the final modified application worked. I'm not sure you'd actually need to 'ship' it, just provide it upon request. So far as providing the source, you could probably just link to the GMP website.
PHPStorm FTW. I'm pretty sure that it is subliminally telling me what to type and is actually smarter than I am.
Um, do you mind if I ask what is salt? Thanks!
Took a bit of google fu but I guess this is it http://docs.saltstack.com/en/latest/
Git and my two hands. Oh and a LAMP stack.
[PHPDebugConsole](https://github.com/bkdotcom/PHPDebugConsole): simpleton include-and-go console-like debug/console class $debug-&gt;group('I'm a group') $debug-&gt;log('my array', $array); // outputs pretty &amp; expandable "var dump" $debug-&gt;warn('I\'m a warning'); $debug-&gt;groupEnd(); //etc // end plug :) I've been using it for years, but just threw it out on github 
Thanks. I was just wondering what was storing the auth key and making sure it was being added to every request. I've not used any js frameworks in earnest, so in my experience what goes into the header in requests is just what the browser sends. And that does include some auth tokens for some protocols. 
I used to use gitolite, but once I found gitlab... I fell in love. 
diet coda for portability
Is there any part of this discussion you're not going to fucking get wrong?
Technically anything but the farther you get away from web stuff the harder it will be.
linux, vim, tmux, zsh, git, gitlab, redis, composer, postgres, laravel/artisan, docker.
&gt; Only if GMP is linked statically. If linked dynamically, you don't need to anything. So says the FAQ anyway. Static vs dynamic doesn't make a difference when you're shipping a binary: &gt; If you dynamically link against an LGPL'd library already present on the user's computer, you need not convey the library's source. On the other hand, if you yourself convey the executable LGPL'd library along with your application, whether linked with statically or dynamically, you must also convey the library's sources, in one of the ways for which the LGPL provides. And with the other bit: &gt; Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. It's pretty clear that it means able to relink the application against a modified version of GMP, not just making GMP be recompilable and not usable. And it's clarified here: http://www.softwarefreedom.org/resources/2008/compliance-guide.html &gt; LGPL also requires that you provide a mechanism to combine the Application with a modified version of the library, and outlines some options for this. Also, the license of the whole work must permit “reverse engineering for debugging such modifications” to the library. Therefore, you should take care that the EULA used for the Application does not contradict this permission.
* vim * Vagrant (and VirtualBox by association) * Git * Postgres * Nginx/PHP-FPM (seriously, switch now) * Symfony * PHPUnit * Redis There's a shit ton of other stuff (almost all 100% open source) that I'm forgetting. Don't care what anyone says, it's an incredibly powerful, efficient (both in terms of code execution and development speed), and gets the job done very, very well. Sidenote: I know it's incredibly condescending, but *please* take the time to learn vim (or emacs, but really vim) well. Or, at least somewhat well. You never know when you'll be without an IDE and knowing how to use vim can save you tons of times. Also, learn basic server management. It'll help influence your coding tremendously.
 $array = json_decode($data); $team = $array['name']; Do you mean like that?
Exactly as they're displayed. $array['results']['FBBScores'][0]['Team Name'] $array['results']['FBBScores'][1]['Team Name'] You could also iterate over the FBBScores foreach($array['results']['FBBScores'] as $score) { $team = $score['Team Name']; }
Nodepad++ The syntax highlighter is a little outdated, though. Some functions refuse to highlight probably being introduced new. Maybe PHPStorm is worth a shot soon, but I do also use NP++ for JS and Lua and html things.
I'm going to be embarrassed if its that simple after all! I'll give it a go, thanks for the help.
I used to use Notepad ++ and now that I'm getting into PHP at a more serious level, I downloaded NetBeans. I'ts. incredible. You should check it out. It's free, and I have it saving directly to my VM server via SFTP. Hit save, hit refresh, see changes. 
Not hating on SVN, but what benefits does it have over git? 
vim, git, composer
Is it much better than Sublime Text ? Would you recommend switching to PHPStorm? Sublime Text has so many great plugins..
https://github.com/ircmaxell/PHPPHP
&gt; PHP is not generally regarded as being multi-threaded/multi-process runtime http://reactphp.org/ http://pthreads.org/ https://github.com/chobie/php-uv &gt; Since forever. PHP was designed as a template language for use with C/C++. It's written in C. The extensions are written in C/C++, and as I already pointed out PHP related projects that are written in C/C++ are not short on contributors. I was answering to the statement: the PHP community is overflowing with C/C++ developers
&gt; I used to use Notepad ++ and now that I'm getting into PHP at a more serious level, I downloaded NetBeans. I'ts. incredible. For Me, I used to use Notepad ++ and now that I'm getting into PHP at a more serious level, I use PHPStorm. I'ts. incredible. 
I think its just a good idea not to use the word model to mean domain entity in any context. It just makes more confusion. I don't want to be anal, and its not like its a huge deal, but by using terms incorrectly we perpetuate the ambiguity for what they actually mean. :)
When I was trying to transition from sysadmin to PHP developer, all job prospects wanted to see some sample code. I wrote a XML parser with Google spreadsheet as a data source. It didn't help with any jobs but it did give me a nice project and I learned quite a bit about the XML capabilities in PHP. https://developers.google.com/google-apps/spreadsheets Random quote generator. Every page refresh shows a different quote. Apartment search helper. Set up a form that saves addresses to the database and then display them on a map. Google maps api or open street maps. Tip calculator. Chat service. Set up a page that will let people type in their nick/handle and see everybody else's messages. Web sockets is the latest way, or AJAX, but you could go old school and just refresh the page. Appointment reminder system. Save a task and a deadline and get an email when it is due. For example your dentist appointment 6 months from now. Lunch/dinner meeting system. If you have a group of people that you want to get together but nobody can pick a place. Everyone inputs their nomination and then everyone votes. Instead of saving to a full blown database try to save to a text file instead. Essentially write your own database system with searches and updates. It should never be considered usable in production, but it is good practice in opening and closing files as well as parsing data. See how many different micro frameworks you can get to display the same page. They each have their quirks and knowing their strengths and weaknesses is valuable. To run them publicly you can use Google app engine for free and I recently found open shift.com with free services. Plus there are a million other web hosts that you can get started very cheaply. 
Sublime text is great text editor. I still use it all the time in conjunction with phpstorm. That said, sublime text still isn't a full IDE. It cannot go through and parse your code and auto-complete based on that. It cannot tell you if a method is nonexistent on a class. It cannot let you know if you create a variable and never use it. Some of the features an IDE provide can be installed on sublime text via plugins. You can get xdebug to work (but phpstorms xdebug integration is a lot nicer). You can get syntax linting. git integration. ect... When you start using phpstorm, it may feel like it inhibits your workflow at first, since it doesn't manipulate text as quickly or easily as sublime text. Where it does significantly increase development speed is catching errors or inconsistencies as soon as you make them. It formats your code according to whatever standard you set. It automatically namespaces files for you. It will show an indicator next to methods that are overriding parent methods or are implementations of an interface. Also, for me, one of the biggest bonuses is the Symfony2 extension. It actually parses my yaml configuration files to autocomplete services from the container as well as knowing the class of the object the container returns for each service. 
There really is no difference. Well not that I know off, it's just what I used and am comfortable using it. 
* Vim + Eclim(php support) * Git * Composer 
I know this is probably bad coding but this is working... $i = 0; foreach($results["results"]["FBBScores"] as $score) { echo "&lt;p&gt;{$results['results']['FBBScores'][$i]['Team Name']['text']}"; $i++; } Thank you for your help.
You don't need the counter, you can either use the counter and for, or use foreach which has an internal counter. You can define a foreach with a counter, but you don't really need it: foreach($results['results']['FBBScores'] as $i =&gt; $score) { echo '&lt;p&gt;' . $score['Team Name']['text'] . '&lt;/p&gt;'; } Or you can use a for loop, with a counter: for($i = 0; $i &lt;= count($results); $i++) { echo '&lt;p&gt;' . $results['results']['FBBScores'][$i]['Team Name']['text'] . '&lt;/p&gt;'; } You have kind of mixed these two together, which works but I've never seen before.
It is that simple, but is you have organized hierarchy through the nested array, you can make a recursive function and excute function or modify the values given the key.
Netbeans (and the Netbeans Git plugin) + WAMPServer + Firefox... and Windows to run it all on. PHPass and PHPMailer are nice libraries to have handy.
Would be interesting to provide speed comparisons to in-config (e.g. mod_rewrite or nginx rules) routes.
There really are a great many differences. SVN is easier to wrap your brain around but once you go git you'll never go back.
Since when did *fast* win over *maintenance* and *ease of use*
It really is completely different though. Checkout out this [great answer on SO](http://stackoverflow.com/a/875/790169)!
Nothing to edit code? 
Thanks for your suggestion. Im trying to improve my php skill and try to do one by one of your project. 
Personally, I'm a big fan of Komodo Edit. You can tell it where the PHP (or Python) executable is on your system and it will run your code in real time as you type, and highlight syntax errors with red squiggly lines. The other reason why I started using it is because it was one of the only editors with a dark theme. Nobody should have to stare at a white screen for 8 hours a day.
Git requires discipline. This is a deal-breaker for some people/teams.
$array = json_decode($data); returns an object. $array = json_decode($data, true); returns an array.
Yes, but you have to *step through* the code. The nice thing about debug logging is that you don't have to step through the code at all. Don't underestimate the power of debug logging. With it, you can have a nice concise trace of what is really important in your code, and it's always there on every run.
have you tried phabricator yet? &lt;3
A friend of mine created [var_dumpling](http://vardumpling.com/). It's a very handy tool in cases where you're unable or unwilling to get xdebug setup. The only tools I really couldn't live without are vim and tmux. When properly configured to work well with each other, you can get a really amazing workflow going.
Must be a 386 or something.
Very usesful. Thanks for sharing.
Ok, I guess I was a little to short.. I use Netbeans to edit with. I don't use any scaffolding stuff or frameworks. I do use a quick start app that I wrote that makes some starter forms based on a db structure. I also use Twitter Bootstrap and jquery in my code. *edit: bootstrap, not boot camp.
Bootstrap*
Your right...I just woke up, and no coffee...what do you want from me??
I tried tons of IDE's, and after picking up sublime, i haven't looked back. It's light weight, and got all the functions i need. Check out this post: http://www.reddit.com/r/webdev/comments/28mqdt/what_extensions_do_you_use_on_sublime_text/
I don't know why he use a class instead of functions since that class contains no internal state or ressource :-/ Also, what if you need to add a specific CSS class to one of your input tags ? I belive it is better to write simple forms like this by hand, and use a template engine or a seperate PHP file to render them.
Bookmarked. I hope it gets kept up to date with new releases.
That color scheme for frequency should have a bit more contrast. Other than that, fantastic. Thanks for sharing.
How'd they come up with the frequencies for the new 5.6 stuff? Myself, I think I'll be using `**` a lot.
Green-Yellow-Orange-Red might have been better.
Only three? Four! You deserve it.
did php really need goto?
Perfect, thank you very much! &gt; foreach($results['results']['FBBScores'] as $i =&gt; $score) { 
You can use oauth to login, but I think it's overkill in most situations. You're correct, it's designed to grant an access token to an api or something like that.
Great question! ~~The reason the developer used a ReflectionClass instead of a call_user_func_array() is because call_user_func_array() does not allow you to catch errors. See how the reflection class is wrapped in a try/catch? If the developer used a call_user_func_array() and an error occurred, it would not be caught.~~ After rereading this thread, I've tried to write code samples that demonstrated this but I could not so I'm going to change my answer - apologies. The only information similar to my original answer is from the PHP manual: &gt; Callbacks registered with functions such as call_user_func() and call_user_func_array() will not be called if there is an uncaught exception thrown in a previous callback. [PHP Manual](http://us3.php.net//manual/en/function.call-user-func-array.php) After looking through the code further, I found that this is no specific reason to use the ReflectionClass over call_user_func_array() except that the code is much easier to read. The same functionality is possible using call_user_func_array() - since the author assumes no arguments need to be passed to constructors, but there would need to be more checks in place to ensure the class exists, the method exists, and that the method returns the correct value. Sorry for any confusion.
That makes perfect sense now. Thanks!
Nano doesn't have nearly enough tooling to compete with vim when it comes to editing code. Any competent developer can be useful in vim in a day or two.
Code Sniffer: https://github.com/squizlabs/PHP_CodeSniffer Mess Detector: http://phpmd.org/ PHPUnit: http://phpunit.de/ 
&gt; unwilling to get xdebug setup Unacceptable.
Would love to see such summary for the whole history of all popular languages.
No one uses [Aptana](http://aptana.com/)? I use it on desktop PCs. When I'm on netbook I use [Notepad++](http://notepad-plus-plus.org/).
Ohh this is helpful, I switch between a few projects that are PHP 5.2+ and one that is whatever's the latest stable, so sometimes I forget what goes where. PS: I thought after reading the title that PHP changed their syntax to python-like or something :P
I moved from Netbeans to Sublime. Sublime is an excellent text editor but to be honest to be productive I find PHPstorm the best. The more I use PHPstorm the more of its features I seem to discover and the more impressed I get. With this in mind just skip sublime and go to Phpstorm. If you still need a text editor as well just use good old vim. You will find this article interesting: http://ericlbarnes.com/blog/switching-to-phpstorm
I can see the usefulness of both, I was merely pointing out that xdebug has a slightly different purpose. 
No but I might randomly stick it in so an intern can say wtf.
 Comm on
Can you show some open source examples where this is used? Edit: Upon reconsideration thanks to the responses herein this feature has been promoted *uncommon*. I still maintain that it has limited use for the reasons that: (a) only a single value can be retrieved and (b) it presumes a lack of error checking prior to retrieving the value.
I am unclear about yield. Please explain it to me thanks.
When you say call_uesr_func_array does not allow you to catch errors, could you elaborate? The following code echos 'caught', so I've not quite understood what you mean. &lt;?php function bar($foo) { throw new \Exception('foobar'); } try { call_user_func_array('bar', [1]); echo 'done' . PHP_EOL; } catch (\Exception $e) { echo 'Caught' . PHP_EOL; } 
The problem this library wants to solve is not related to performance. &gt; This can work only if SomeService#getDependency() was called at least once upfront (which may well be under certain circumstances), and therefore is a cause of bugs/headaches/suicides/etc.
that's nice, teaching interns good programming practices
I don't think traits are uncommon at all. We're already seeing them all over the place in (e.g.) Silex and a lot of pretty popular Laravel packages.
I'm not a developer. I just build little tools for my own internal use/purpose. 
I haven't done much with them but I got the impression they are the equivalent of mixin modules in ruby, which are VERY common, so I would think they would be quite useful in PHP too.
Paywall.
exception !== error 
From http://www.php.net//manual/en/language.generators.syntax.php &lt;?php function gen_one_to_three() { for ($i = 1; $i &lt;= 3; $i++) { // Note that $i is preserved between yields. yield $i; } } $generator = gen_one_to_three(); foreach ($generator as $value) { echo "$value\n"; } ?&gt;
even if it isn't quite common in open source projects yet, this is most likely due to being able to support older versions and not break old installs. same with the new array syntax, and probably most of the new features will need a while to appear in open source projects, when requiring php 5.4 is not an outrageous demand. however if you have a good control over your environment you should start using these things now, when you need them. And function array dereferencing is pretty useful
That's so crazy
Presumably errors like the class not existing or it not implementing whatever interface defines execute().
&gt; http://reactphp.org/ http://pthreads.org/ https://github.com/chobie/php-uv Yes. I chose my words carefully when I said "not generally regarded". Threading libraries exist but are rarely used. You're not going to find a popular framework that makes use of any of these libraries, and most are not in active development.
I did not know about the ternary shorthand. That's one I'm gonna use a lot.
iTerm Vim VirtualBox MySQLWorkbench Git That's it.
Ah, yeah. What I'm interested in is if their ideas ever got implemented, or if the issues they spoke of got fixed.
[Business Logic (aka Domain Logic)](http://en.wikipedia.org/wiki/Domain_logic)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Domain logic**](https://en.wikipedia.org/wiki/Domain%20logic): [](#sfw) --- &gt; &gt;In computer [software](https://en.wikipedia.org/wiki/Software), __business logic__ or __domain logic__ is the part of the program that encodes the real-world [business rules](https://en.wikipedia.org/wiki/Business_rule) that determine how data can be [created, displayed, stored, and changed](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete). It is contrasted with the remainder of the software which might be concerned with lower-level details of managing a [database](https://en.wikipedia.org/wiki/Database) or displaying the [user interface](https://en.wikipedia.org/wiki/User_interface), system infrastructure, or generally connecting various parts of the program. &gt; --- ^Interesting: [^Business ^logic](https://en.wikipedia.org/wiki/Business_logic) ^| [^Empty ^domain](https://en.wikipedia.org/wiki/Empty_domain) ^| [^First-order ^logic](https://en.wikipedia.org/wiki/First-order_logic) ^| [^Domain-driven ^design](https://en.wikipedia.org/wiki/Domain-driven_design) ^| [^Multitier ^architecture](https://en.wikipedia.org/wiki/Multitier_architecture) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cieahvh) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cieahvh)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Unless there was a ninja edit, I didn't detect any sarcasm in that post.
No I was being serious - was in a rush to write the comment before the F1GP started last night :)
Your detector works well :) Was being serious.
I find the "Frequency" column weird - to say that "array and string literal dereferencing" has rare use cases certainly isn't the case for me. Even the nested array unpacking is something I often use now.
Can you provide some examples what you use the array/string literal dereferencing for? I have a pretty hard time coming up with non-artificial use-cases for that.
Wah? PHP *does* implement "Copy-on-write". Just to be different I'm going to reference a 5 year old comment on the PHP docs that covers my response. http://www.php.net//manual/en/language.references.php#85118
Ah brain fart "array/string *literal* dereferencing" - yeah good point. I'm thinking of: $buffer = 'MANY MANY CHARS'; $pluckAByte = $buffer[$position]; and... function myFuncCalcMultiResults() { return ['Result1','Result2']' } myFuncCalcMultiResults()[0]; // result 1 That stuff gets much use for me. 
I don't get the downvote for this user here - all have to learn sometime? Yeah generators - worthy to learn, very powerful and helps write some clean code.
It's called Angry nerd syndrome. Thanks for the input friend
Orange or red wouldn't be a good choice - they indicate *warning* or *error*. I would feel being advised against using those features.
Well then my apologies. Derp. 
Your first example has nothing to do with string literal dereferencing. That works in PHP 5.2, and I believe will work all the way back to PHP 3. To be completely honest, I cannot think of a practical use for string literal dereferencing. The best example I've seen yet is this, and even it is a bit contrived: $randomChar = "abcdefg0123456789"[mt_rand(0, 16)]; Your second example is missing the parens for the function call.
I've gotten used to it at this point, I have the commands and php.ini options stuck in a file somewhere for reference and it takes me less than 5 minutes.
The power operator, really? What do you do that requires the usage of powers? Variadic functions and splat are where it's at.
Array literal dereferencing can sort of be used in place of a switch case, but not really because it will probably throw an undefined index warning.
He's getting downvoted because he's asking about something that easily googlable and asking others to do the work for him.
It is pretty sweet, but it still pisses me off that `"0"` is falsey. So many times I've justed to do `if($string)` or `$string ?: "whatevs"` but nooooo I can't because `"0"` is totally a valid non-empty string.
Array dereferencing is gonna be hawt when we get to use it (we're hamstring at 5.3 at work, unfortunately). And, yeah, undefined indexes throw notices, so not optimal, but can be annoying depending upon who sets your error reporting policies.
I really really want just one placed in a key part of the codebase, say, deep in the ORM, so that everybody cringes when they see it but nobody wants to touch it out of fear of breaking everything.
Well, the character "0" *is* a string. You're probably talking about form input, which is always a string. Just have to convert it to a number first.
&gt; Well, the character "0" is a string. Yes. Precisely. It's a string. So why does PHP need to treat it like integer 0? And no, I'm not necessarily talking about form input. I can sanitize that shit before I start comparing it, there's no need to screw with my string-ifs. 
I think the answer is [even simpler than that](http://stackoverflow.com/questions/2409237/how-to-call-the-constructor-with-call-user-func-array-in-php). You *can't* use `call_user_func_array` to instantiate an object.
That's true, but I was more asking why it wasn't just done as new $whateverClassWasPassed; And what I took from the answer above was that he was using a ReflectionException to ensure that the class existed rather than using something like class_exists(...) 
its almost... functional xD
You're really trying to convince me and other developers nano is equally as competent as vim? http://www.vim.org/scripts/script_search_results.php 
....you can't. It has arguments. $status = $class-&gt;execute($this, $args); They could have used a `class_exists`, but if that came back true they'd still need to use reflection.
http://www.php.net//manual/en/types.comparisons.php Scroll down to `$x = "0";`
This looks absolutely beautiful. Will be installing it tomorrow. 
You know, back in like the php 2 or 3 days I submitted a patch to add a power operator to php. The reason was that I was doing some online quizzes to solve math functions and it would be a lot easier to evaluate submissions with an operator rather than a function. Alas it got rejected because they said you didn't need an operator when they already had a perfectly good function for it. Looks like 10 years later they finally agreed with me :)
Sort of neat, I suppose, but I wonder who is returning so many arrays that they needed a shorthand to refer to an element like that. It actually seems like a bad thing, because people might use it without understanding that they're invoking a function each time. So really it's only useful if you're only getting that one value and only getting it once, in which case, why are you returning a whole array in the first place? Sure I can think of very specific cases, but enough to justify a new language construct?
tbh, i wont be using variadic or splat a lot... None of the 5.6 features....
Symfony's router uses it quite efficiently 
The parens make it pretty obvious it's a function. And it's useful for things like database queries or api calls where you only care about one value. Sure it's not absolutely necessary but if nothing else I think it's worth adding just because when you look at the code most people wouldn't see any reason it *shouldn't* work, and tend to be surprised when it doesn't. 
Have been in need of something like this, awesome.
My only concern with this is security. It's obviously running some Linux commands with exec or system, how are they built to be run or are they "hard coded". I would feel safer if there was a non-web accessible daemon that was collecting data and logging it to a place that the web portion could display. 
Er, did you read the abstract? I am curious if the problems with PHP's implementation it found were fixed. 
Haha you just inspired me.
The point of versioning is to receive minor updates but not major updates (with possible breaking changes).
It's just there in the readme: &gt; This is problematic because implementors and people subclassing SomeService will eventually write: class SomethingElse extends SomeService { public function doOtherWork() { $this-&gt;dependency-&gt;doMoreWork(); } }
PHP doesn't have 'big int promotion' though, that makes it kind of shitty for math problems like the Euler ones. And powers tend to produce big numbers. Python is a better choice there.
That being said, I find it a bit wrong to use the exception to handle the cases where the class doesn't exist or is not instantiable. A simple `if` would be much clearer but most of all it would be faster. Exceptions can be really slow, it's usually not a good thing to use them for simple control flow.
HeidiSQL...fuck that phpmyadmin shit whenever its possible ;) 
Well one problem is if you do if (class_exists($className)) { $class = new $className(); } class_exists only tells you if the class exists. It doesn't tell you if you can actually create an instance of it. The code in my example will error if the class constructor isn't public. Where with the reflection method you can catch the exception in a case like that.
http://www.nagios.org/
I can point out plenty of open source examples where namespaces aren't used even though he seems to think it's "always". This list is basically just wishful thinking. People who need any of those features will use those features, and you should know about them all *regardless* of how likely you think it is that you'll encounter them.
Bitfield operations. 2**$something where $something is the position of the bit you want on.
it's slightly cleaner. if you do 2&lt;&lt;0 you get 10. 2**0 on the other hand gives 1. In this way it avoids the first position edge case.
If you want to have powers of two, you use `1 &lt;&lt; n`, not `2 &lt;&lt; n`. What's the edge case?
&gt;Also, certain operations with extremely large numbers can cause gmp to error fatally, which sadly can't be recovered from or handled gracefully. Does anyone have any details on this? It seems like this could be a fairly significant security issue if it was realistically exploitable.
Hi, I'm the author of the RFC and patch, and I'm also concerned that it could be a security issue, but I'm not sure how exploitable it really would be. I've only hit the fatal `gmp: overflow in mpz type` error so far when using very large exponents with the pow operator. If I try to create or multiply some extremely large number, I usually just hit the request memory limit and everything's fine. I obviously need to do some testing, however at the moment I don't think it's going to cause a DOS vulnerability unless you're doing `$_GET['foo'] ** $_GET['bar']`.
There are times when you don't have a choice (shared hosting) or are on a restricted page on a prod host where you're var dumping and definitely do not want xdebug active.
They are hardcoded, just look at the source on GitHub
Thanks - all good points! Hopefully I can put your mind at ease. &gt; What's worse is that because it's all wrapped in closures, profiling it is very difficult. This sounds like the root of the problem. While closures can seem like an elegant way of writing the routes, and PHRoute certainly supports them, it's not the only way of mapping logic to routes. Firstly, you could swap the closure for a string function name, but you would still have to include the file with all your logic at runtime. Better than this, you could map it to an autoloaded class. $this-&gt;get('/users',array('User', 'listUsers')); The user class will be loaded as required - If you hit another route, mapped to a different class, then the logic for listing users will never be loaded. The other option with PHRoute is to use [restful controller routing](https://github.com/joegreen0991/phroute#controllers). I've done a quick memory usage test and to map 100 routes to methods on an autoloaded class and dispatch them costs about 300KB. Do with this what you will, but think about the memory usage your logic will consume when executed. 300KB may well pale into insignificance in contrast. &gt; "throw a couple more instances at it" is a dangerous attitude to have for the sake of saving a few minutes of time to create good routing configurations/regexes. I completely agree that not caring about performance is not a good stance to take. I would hope that my interest in this regex engine is enough to show I am at least considering performance (whether I'm achieving it TBC). However, I think worse than that, is a solution that is difficult to understand, impossible to update, even harder to test and because of this is costly to maintain. It may be that routing is your bottleneck and spending lots of costly developer time benchmarking, honing and maintaining a highly tuned server environment and low-level routing engine is what you need. In my experience even conventional PHP based routing engines are rarely the bottleneck, especially in applications backed by a database (thinking about memory usage, latency, database r/w times), but I think its safe to argue that in this case PHRoute would certainly not be.
To look clever.
Also, if the array of data should be split to each parameter of the Policy classes. Say PolicyUser(UserID, GroupID), you pass those into an array on the 'can' method, there is no way to split those values from the array into each 1st/2nd etc parameter slot without using 'newInstanceArgs()' (Until 5.6 with the argument unpacking support using '...')
Is the big integer support really worth the trouble and effort? Other languages where you'd expect math to be used more often than in PHP (e.g. Java, C++) don't support big integers natively and for a reason I am guessing. I'm sure people using PHP can live without it. (I would agree with int64 though)
&gt; Is the big integer support really worth the trouble and effort? Integers would be completely consistent on all platforms and not overflowing to floats means your code is less likely to break. I think that's worth it. Also, perhaps I'm a masochist, but I &gt; Other languages where you'd expect math to be used more often than in PHP (e.g. Java, C++) don't support big integers natively and for a reason I am guessing. Java and C++ aren't scripting languages like PHP or Python are, nor are they functional languages or used for mathematics, so I wouldn't expect them to support this kind of thing. &gt; I'm sure people using PHP can live without it. Sure, but the same can be said of most features.
Don't link to premium content.
I agree Heidi is awesome, but it can be buggy and doesn't have the pretty live graphs that phpmyadmin has for monitoring ;) 
Just because I have to pay to see it, I downvoted it.
Bcrypt is good, but it's not going to save you from things like SQL injection or XSS issues in the authentication system. It's a good practice for *password storage* but not for authentication itself.
This looks fantastic. Is there any way to view a history of these stats?
Eh, might have been good 5 years ago but I can't see building anything new with CI now.
WAT.
"huge rip off" made me chuckle. :) Great books aren't defined by the number of pages they contain. Take [https://leanpub.com/signalingphp](https://leanpub.com/signalingphp), for example. It's an excellent book, at 34 pages. I would be happy to send you a review copy, so you could better motivate your position on the central premise turning out to be "done dirty hack"... Also, Leanpub books are often "in-progress". This means they can be published, while incomplete (currently at about 50% done). Those 58 pages are the theoretical portion of the book. The sections I have yet to complete are: - Designing for the future - taking a look at how many of the concepts contained herein are being realised in core PHP, RFC's, superset languages and libraries today! - Sample Implementations - the concrete (less-explained) code which implements the theoretical portions of the book. I hope that's helpful! :) Edit: I've also added a 17-page sample, available at http://samples.leanpub.com/typedphp-sample.pdf
I wouldn't recommend PHPass with the release of PHP 5.5 or with ircmaxwells compat password library. 
Thanks for the substantial sample!
indeed, this clearly shouldn't work (new Class)-&gt;method()[0]-&gt;method(); but it does. crazy. Edit: chaining: "it just works."
Why are you developing on production?
VirtualBox Puppet Vagrant GIT Composer SublimeText 3 VIM XDebug PHPUnit PHPSpec MySQL, Apache | NGiNX, PHP 
That's the first step, but the beauty in using the extensions is the ability to automatically unbox them (saving calls to things like `toInteger()` etc). I have used this approach in a couple of production applications, and it has benefits and drawbacks. If you afford to use the extensions (Zephir/SPLTypes/Scalar Objects) then it's really easy and clean. If you're on shared hosting, and you don't mind wrapping and unwrapping variables, then you can still use the methods described. The sample shows only the most basic code (manual boxing and unboxing). It gets much, much better after that... Edit: At the very least; you'll see how to build clean and consistent, procedural code. At most, a beautiful (and easy to use) OOP type system.
I need some suggestion to improve my application. Thanks
I programmed facebook. I want to show the connection between a User and his friends and his friends' friends. How do you supposed we do that "OOP" without instance objects of the Users?
I agree that there are a lot of valid instances in web development where you could use static objects, but to make a general rule that everything could be static seems to be a bad idea. For example, I like being able to pass an object as a parameter to a generic method that will do a particular operation on the object. If I use all static objects everywhere, generic code that receives objects that implement particular interfaces will become quite complicated.
OP is clearly not saying you shouldn't use objects for anything. Just that a lot of things could be handled with static methods, like templating. Because you only have one templating object.
1. instantiation facilitates dependency injection. 2. constructors are often useful for setting up state. 3. your code seems contrived. your instance example could be written to be similarly succinct. - $m = new Template('path_to_a_view', ['debugging' =&gt; true]); $m-&gt;render($array_of_variables); - 4 stateful static objects tend to be abused the same way globals are. 5 you might enjoy [laravel facades](http://laravel.com/docs/facades). 
You pretty much always need 2 of these as soon as you hit an edge case (which you will hit), regardless of testing or any kind of "clean code" approach. Coding against singletons rarely works. Yes, if your use-case is fairly small, then this *may* work, but as soon as you have to expand your application even by a little, the entire thing will fall into pieces just because you'll have to change a lot of these singletons to follow the new requirements (or duplicate code everywhere). Interfacing with external code also becomes quite complicated and messy. We had them, we moved away from them, and that's pretty much the reason, as with everything that keeps global state encapsulated. Local state is a much more acceptable pain to deal with.
I have found that the biggest obstacle to modernising legacy code bases is not the code itself but the people working on it^(unless you get to be a decision maker). :/
Data model object is an unbeatable example. You are right. I think I'm too tired of the helper and utility classes which shouldn't be instantiated but instantiated! Thanks for your template example! That's really a big benefit.
I gave the preview a quick scan because interesting subject to think about ... just a few observations I must communicate (or I will explode) ... It's surely incorrect to call PHP "very procedural"; you can write very procedural code, you can write very object orientated code, PHP is (attempts to be) indifferent. I'm not sure why it's necessary to have a chapter on inconsistencies, perhaps the reason for it's existence is explained elsewhere in the book, it's not obvious .... kinda feels like part of another book. Somewhere you mention that it's strange that PHP doesn't support regular expression strings in the same way as javascript, noteworthy that, Java, C# (read: .net), Python, C++, and C all support regular expressions in the same way as PHP. Javascript (and I think ruby) are the odd ones here it would seem. Even more modern languages like D are using something closer to the string representation that the rest of us use (r"pattern"). I wanted to review the core idea of the book, because interesting, but I cannot help but think, and say, that this isn't something you really want to do in the real world. You will cost yourself considerable overhead however you do it, the solution to this problem, if it can be called a problem, must come from PHP itself, or at least from an extension like Nikita's scalar methods test extension. I'd be interested in reading the whole book because I'm probably missing context, I don't know how the previews are prepared or if you have control over the content, but thought observations might be useful ;)
*Whoosh*
Sorry, I couldn't [resist](http://m.memegen.com/bztx27.jpg)
Can you give an example of what you're trying to install? I'm not real sure what you're asking, but Composer packages, in general, are not meant to be "installed" in custom directories. The packages are added to the /vendor directory, and you instruct your class auto-loader to search for classes in that directory. Composer comes with an auto-loader that serves that purpose.
That goes without saying for any form...
Hey, thanks for this feedback! I'll try to address it all here, and please forgive me if I misunderstand any of your points. &gt; It's surely incorrect to call PHP "very procedural" Perhaps I've explained my thoughts poorly here. What I mean is that the majority of PHP functionality is expressed through functional constructs, and that PHP went through 4 (5 if you count 5.3 as a separate version to PHP 5.4) before getting a reasonable OOP implementation. The meaning of "reasonable" is debatable, but I think we can agree that the OOP in &lt;= 5.3 is quite different to the OOP it supports today. I do see that indifference you talk about, but even Rasmus brushes aside the notion of strong types in PHP. I asked him, personally, about his thoughts on strong typing in PHP, and he wasn't supportive. That's ok, because PHP is malleable, and this book looks at both styles of type management. &gt; I'm not sure why it's necessary to have a chapter on inconsistencies That part is not the focus of the book, but rather motivation for the amount of work involved in solving a very specific problem. I have used PHP for a decade, and will continue to use it. It's been toned down quite a bit, but I can hardly expect people to take the time implementing a solution to a problem they don't know about or understand. :) &gt; Somewhere you mention that it's strange that PHP doesn't support regular expression strings This part of the book is fairly subjective, but there is a certain clarity even about `r"pattern"`. The point I try to make is that PHP treats regular expressions as strings, yet provides an additional set of functions which only apply to regular expressions (when they are correctly formatted). I think better options would be either having a different type representation for expressions (like JS) with their own functions, or having a single set of functions which work with strings and expressions. Curiously, JS does both of these things, yet only the second is described in this book. &gt; I wanted to review the core idea of the book ~~Please DM me and I will send you a copy.~~ I'll DM you a copy. Your feedback is great, and I would love more of it! Edit: I forgot (I seem very forgetful today) to mention that that all references to "Scalar Objects" are exactly "Nikita's scalar methods". Similar to SPL Types, and very cool. I cover both of these in great detail...
I don't imagine frequency of use should play much of a role in what gets dedicated operators or not. A not-insignificant number of existing operators aren't used in the vast majority of PHP projects. I think a better rationale would be giving dedicated operators to the operations that benefit the most from the increased readability. In this case, I think exponentiation definitely qualifies, as a lot of equations and formulae can be expressed in a closer-to-the-math kind of way.
Sure, so if I am working with a wordpress project, I have wordpress dependencies (e.g. plugins) that I want installed in a sub directory of my application... My application's layout is as follows: ---app (where my application's themes and plugins reside) ------plugins ---------Plugin1 ---------Plugin2 ---------Plugin3 ------themes ---------MyTheme ---wp (where the wordpress application resides) ---index.php (entry point) ---wp-config.php (configuration file) ---composer.json (composer manifest) The way wordpress works (coupled with the workflow I have been using), the dependencies (plugins, for example) reside in app/plugins/{$NAME}. Other dependencies i.e. 3rd party libs (Codebird, for example, which is WordPress agnostic), I would specify that it is to be installed in app/themes/mytheme/includes/{$NAME} Expounding on my initial post, Codebird didn't have composer/installers required, so it would only install in the vendor directory. Luckily it's actively maintained, so I submitted a pull request and they added it almost immediately, so I'm good to go, but I am sure I will run into other third party libraries that I will need to submit a PR to if I want to use it in wordpress. If we had the option to place the components in specific locations it would make life a lot easier. Sure WordPress is opinionated but I'm sure it's not the only framework whose workflow doesn't quite match up with the /vendor/ pattern that composer is built for, I don't see what the harm would be if composer/installers was enabled for all packages. Would there be harm in doing so?
Yeah, I took a look at it and saw that the commands are hardcoded, which isn't so bad. I guess for security options, a daemon that runs and logs the data, where the front end only queries those flat .json files, could be a nice improvement to it.
I've been one of those roadblocks in the past; have hope though--we can change!
Did you read the article? I don't think you did.
I suppose if this is a rebuttal, there must have been some claims to it being a dying language. Perhaps he is responding to that . . .
I did ... I agree with the article. I was responding to the first part of the headline. Apologies ... I guess that was just too confusing. 
In my opinion, daemons are much less complicated. By executing commands from a web service, you need to consider application and session timeouts, whether the web daemon is restarted, piping that data between the executed command all the way to the browser, etc. A monitoring daemon would be self-contained, managed separately, and ignorant of the web. Me gusta.
Ah, my apologies. I thought you just read the title and thought it was another "herp a derp PHP is dead" article and went on the typical rant about it not being dead without reading the article. 
Why do you need the 3rd party libs in app/themes/mytheme/includes? If you are using the composer autoloader it would automatically load that Codebird class for you and you'd have no need to place it anywhere else.
That's fair. But what about specific plugins that I want to use that have to be placed in app/plugins/ ?
I feel like theres got to be an easier solution than doing this... Adding `composer/installers` adds a dependency thats only required by a small fraction of users, and it does add overhead, to both installing the code, and to maintaining the project (making sure its up to date and what not). Personally, I'd rather leave it out for all my projects.
Generally when I run into these kinds of problems my first thought is, "What am I doing wrong?" For example trying to change a tool to suit my workflow instead of adapting my workflow to the tool. I came [across this site](http://wpackagist.org/) (you may have as well) which looks interesting, and it links to the [Composer docs on setting custom install paths](https://github.com/composer/installers#custom-install-paths).
If they are Wordpress specific plugins, cant they be loaded in the normal way?
PHP Console https://chrome.google.com/webstore/detail/php-console/nfhmhhlpfleoednkpnnnkolmclajemef
wpackagist is great, but it only covers WordPress.org specific plugins, so third party ones only maintained on Github have to have installers as a dep.
You may be a little out of luck. I mean, Composer is a package manager, not an app installer, and it doesn't matter where packages are installed. Using Composer to install apps is probably going to lead to some additional work on your end, and that's just the way it is.
http://codex.wordpress.org/Managing_Plugins edit: Comments are preferred over downvotes...
Can't tell if sarcasm.
Seems to me like it's just poorly emulating Facebook's [Hack](http://hacklang.org/). Or does the approach bring some advantages over Hack?
I guess you're right there... it's a package manager. Thanks.
&gt; Seems to me like it's just poorly emulating... Without reading the book, or any reviews of it, there's no empirical way you could know that. I'm watching Bones, currently, so that kind of talk is going on! :) It may seem like that's the only point of the book, but it's not. Much of the book is based on things you can do with plain old PHP. No extensions, no Hack. Some of it is about extensions which get pretty close to implementing the same level of structure as is available through Hack. The extensions I describe are open-source. Hack is not. Furthermore - the sample implementations will require a fully-functional implementation of type methods. The vast majority of the code is useful without any extra extensions or magic. Just plain old PHP. Finally, the book also contains no-fluff instructions on how to install and use a number of poorly-documented, and very useful bits of software. Other than Vagrant (which is brilliantly documented, including a great book by Erika), the extensions are hardly used because they are hardly used. They happen to be well implemented, but they suffer from an unfortunate lack of publicity and utilisation. You should definitely read the book before deciding it's not your thing. I will happily send you a copy, if it means you will approach it with an open-mind, and not just write it off with 0 evidence. :)
You can't?! 
I want for Parsedown to be as simple as possible.
I.E. The Goto Command is killing PHP or the fact that that's causing it at all but it's still happening. 
Those ruby folks are hardcore fanatics. (Not that that's necessarily a bad thing.)
I guess the Composer devs prefer the term "dependency manager". You could take a look at the [pre-install/post-install script support](https://getcomposer.org/doc/articles/scripts.md). You might be able to hack something together that does a proper install of any WP plugin you depend on.
This is basically *one* of the features of Hack. If you were going to do this, I'd just learn Hack instead.
Forgive me for sounding dismissive, and please allow me to try try and redeem myself for a lack of communicative subtlety. :) &gt; it's an extension of PHP 100%, though I believe it can also be described as a superset language. That is "PHP + other stuff". So while Hack resembles PHP, it cannot be run on the leading PHP engine. It is currently only supported by HHVM (to the best of my knowledge). That means; to write Hack code, one has to be running HHVM. Which is entirely owned by Facebook. I know Hack supports stronger typing, and I know people can use Hack to write apps with stronger types. That's not the point of this book. Hack may be a very, very good implementation of a stronger typing system, but it is not based on a language spec. Neither is PHP. That's a problem, because Fb can pivot the language in any direction they want. Will they? No idea. Can they? Sure! I don't think it's fair to say that Hack is the only option for stronger types. This book shows how it can easily be done without learning Hack. That doesn't mean that learning Hack is bad. Just that it's one of many viable options for stronger types in PHP codebases. Did I redeem myself? :)
PHP hasn't been dying because it isn't used; it's been dying because it's not used by professionals on new projects (as much as other languages). I'm sure there will still be plenty of shitty little WordPress sites needing PHP for years to come, but I sure as hell don't want to ever work on those.
I program PHP as a day job and Rails for my personal projects. I prefer RoR. 20 years coding experience, 10 or so in PHP. PHP feels pretty primitive and verbose, but PHP jobs pay better. I'm *way* more productive in RoR. underscore.js makes js feel much more like Ruby, so flipping from RoR -&gt; html, css, jquery, underscore isn't a huge mental leap. Going PHP, Smarty, Eloquent -&gt; html, css, jquery takes a few moments to try and remember $var, var x, $('.selector'), {$variable}, foreach(), for(), etc... etc... all those differences add up in the mental cruft dept. Advice: know all the tools and choose the one that you like.
I love how the article cites git and github as reasons that PHP Isn't dying as if they were outgrown from the PHP community instead of the much broader Linux community. 
The only PHP stuff I've worked on in the last few years has been legacy maintenance of older systems. PHP isn't dying, but it sure as heck isn't being picked up for new projects by most professional developers these days. /2c
There are a multitude of reasons to dismiss hack when all you want is strong typing added to PHP, not limited to: - Needing a new interpreter to run - The interpreter being nonfree - The language being owned by a corporate entity - The language not being widely tested yet - The language subject to massive change, as it is brand new - The language being subject to unwelcome change as a result of non-community decision Besides any one of those reasons being enough to not use Hack for many situations, hack *is a different language*. It is a **fork** of PHP, it is not an addon package for PHP.
I work on some very large ecommerce sites that are built in Drupal. This is a market that is plainly growing and has been for a while... So, what is your explanation for that? 
The article cites that we're using git and github as a contrast to not using version control in the early days. I don't see how you could possibly interpret that as git and github being grown from the PHP community.
all depends on the complexity of the objects, and if you can detach them from the unit of work, or hydrate them into to 'dumber' objects. 
Oh my god, no.
Aside from the fact using Doctrine will incur a non-trivial overhead of hydrating 500k objects you're also likely going to run into problems with memory if you need all 500,000 objects to be around at the same time. Without taking special precautions you'll find all of your objects will hang around in memory until the end of the request (or with 500k, killed due to OOM). Have you considered not using an ORM for this 500k object request? I frequently use Doctrine in my projects as it allows for fast and easy development. However, for bulk operations or some high throughput endpoints I normally just use just the Doctrine DBAL or PDO directly.
Okay, that makes more sense, but you were arguing with a point a never made: that Hack is the only way to do strongly typed PHP. I was asking what the value of doing a *second* strongly typed PHP implementation is, and your answer seems to be, "then you get to use Zend instead of HHVM". Okay, that's fair I guess. I have no special attachment to Zend, so it's not really a selling point to me. But "learning Hack" and "learning /u/followchrisp strong PHP" should be able the same level of work for a person starting from zero. It just brings optional strong typing to PHP on Zend. I would actually complain, then, about the fact that this doesn't segment the code. With Hack, you use the &lt;?hh to make sure your codebase isn't executed on incompatible systems after you introduce breaking changes. With this, there would be no way to ensure that your codebase isn't executed on non-compatible systems, since it should produce a fatal error on tokenization which prevents you from checking whether or not the plugin is installed first.
I guess my only response is that the vast majority of implementation code is procedural PHP which should work on 5.4+ (Zend), without extra extensions. The theoretical work (that which is already in the book) explains that, so I still think there's value in you reading it. The bits which utilise the extensions are only glue. And it's not "/u/followchrisp strong PHP" - I merely point people towards the exceptional work of the authors of these extensions. I recommend the writings of many others. I hope that, in doing so, I propose a valuable perspective to other developers. In the aim of learning and teaching. :)
I'm in the same boat. It was hell setting up ruby/gems and gitlab, but its all working now and I couldn't go back. Though I may set up phabricator up on a new box, thanks for the link!
If you are just logging a user out wouldn't you just want to clear the user information and not the entire $_SESSION array? I usually just do $_SESSION['user'] = array();
EDIT: My example was incorrect, my apologies.
"[...] being taken over by trending technologies like Ruby on Rails?" LOL! Funniest thing I've read online all week. :p
I don't disagree with you there. I wasn't saying exponentiation shouldn't get it's own operator, just that I'm surprised that someone thinks they'll be using it *a lot*.
&gt; edit: be aware that both call_user_func* and Reflection are really slow and resource heavy, so use them seldom and wisely. Do you know if the new splat operator will incur this same cost?
[Your assumptions are kinda correct](http://redmonk.com/dberkholz/2014/05/02/github-language-trends-and-the-fragmenting-landscape/)
That's boilerplate first fifteen pages of every php book. There's nothing new there. So your 58 pages are reduced to maybe 40. Poor value.
If you need full result sets of 500K rows at the same time, you'll probably run into memory issues even with arrays.
You're welcome to just not read it. I'm not going to lose sleep over irrational criticism. Read the whole book (or a logical review thereof), if you feel like offering a cogent refutation of someone else's hard work. :) Edit: as a matter of interest; please could you point me to all of these "every php book" that begin with the same 15 pages. I would like to know whose copyright I'm infringing upon...
Here is my current list: * PHPStorm * Git or Mercurial * XDebug * SequelPro * Redis
I prefer the term "career-inferred estimation" to "assumption." Edit Also kind of interesting http://www.google.com/trends/explore#cat=0-5-31&amp;q=Ruby%2C%20JavaScript%2C%20PHP%2C%20C%23%2C%20Java&amp;cmpt=q
&gt; destroys the named session, which is the same as Not the same - the first code example does not take a parameter (void) and frees all associations with the current session. The descriptions are a bit cryptic so I can see where confusion can creep in. http://us1.php.net//manual/en/function.session-destroy.php The second code line you have posted will unset the array key in the SESSION variable named 'session_name' only. The session_destroy() man page itself makes the following note: &gt; Only use session_unset() for older deprecated code that does not use $_SESSION. If you just want to "forget" association of the session to your application state a $_SESSION = array(); will do the trick - this will reset the current session to "empty array". But the session will still persist - it just now has zero knowledge of what/where it was in the app. If you **really** want to nuke the session ID (which for most people/PHP installs will be a session cookie) - you need to nuke the session cookie as well. The session_destroy() doc page has an example of this too.
*Sad face*. I don't have those restrictions in the work I do luckily.
One word: outsourcing. edit: Am I actually downvoted? His statistics says there are 1700 sites per developer in the US, that can't possibly be right. It's way cheaper to buy programming power from countries like India and China, everyone knows that, and most of the sites in the US are based off of foreign programmers. This is also known as "outsourcing".
I would not suggest using Doctrine ORM for this. The UnitOfWork pattern applies badly to huge datasets, and you can't do much about it. If what you are doing is batch processing, and you can actually chunk data before working on it, then go on, but Doctrine ORM becomes slower as the amount of data kept in memory grows (pretty much like a large serialized transaction in any RDBMS), so I would consider using it only if there are &lt; 1000 entities in memory at any time. It is probably better to keep this in the realm of SQL if possible.
My mistake, I utilize a library to handle my sessions so it's been a while since I used the builtin functions.
we have wordpress, we will survive!
No issue really - have to admit I usually just blow away the session using $_SESSION = []; Having a good read of those functions, the documentation could use some rewording updated - had to re-read a bit to confirm.
&gt; Growing adoption of PHP 5.5 Agree. &gt; and PHP 5.6 Wat.
Nice article. We will beat those Perl guys yet.... (oh, was that battle already won?) 
I just heard: blah blah blah blah "i am a RoR fanboy" blah blah blah blah "RoR is love, RoR is life" blah blah blah,
&gt;Copied from www.php.net/manual/en/function.session-destroy.php private function destroy_session() { $_SESSION = array(); if (ini_get("session.use_cookies")) { $params = session_get_cookie_params(); setcookie(session_name(), '', time() - 42000, $params["path"], $params["domain"], $params["secure"], $params["httponly"]); } session_destroy(); } 
c# has goto. c# is a great language
Well if you relate it to what composer leverages as a base - then yes. 
Intresting that you mention that PHP jobs pay more. In my small sample size I've found RoR to pay more. That could be the local market though (Greater Toronto Area)
I hear you. So often, the most difficult parts of our work are not technical, but social and managerial. One key here is to figure out your own tradeoffs: if you have to spend some of your own time to make some quality fixes to the codebase, and in the end that improves the quality of your work life, then maybe it was time well spent. But better to get management buy-in if you can. ;-)
Swap MySQL with Maria and you are set!
oh look drupal has eaten symfony and come out with a mutant that is even more bloated than Drupal was before... the smartest thing Drupal could do is dump Drupal and switch completely to Symfony. That would be a major improvement to Drupal. Anything less than this and Drupal deserves to simply die.
PHP is the Cobol of the web. Much hated, but there is so much software written in it, if you know it you will be employable for a long time.
I think you're confusing structure with inflexibility. Your reasoning is eerily similar to the people who say "But I wrote it in one line with nested ternaries, why would you split it up to multiple lines?" With your suggestion I would have to either read through the documentation (which may not clearly point out exactly what that closure would be required of it.. or look through the code to understand what it is. Since there is an interface I have a contractual obligation to follow exactly what is expected of my class. For instance, since you hate guzzle for some unknown reason (a dependency? It must be 2004, we don't have dependency management..) class FileGetContentsAdapterInterface implements \Snoop\AdapterInterface { public function getArray($uri, array $headers = array()) { $headersString = ''; foreach ($headers as $key =&gt; $value) { $headersString .= sprintf("%s: %s\r\n", $key, $value); } $context = stream_context_create(array( 'http' =&gt; array( 'header'=&gt; $headersString ) )); $data = file_get_contents($uri, false, $context); return json_decode($data); } } The code itself started as simple enough that this level of abstraction makes it a worthwhile tool and is something that can easily be declared as clean and well tested. I'd much rather see this than a gist that does it but isn't tested, isn't available via composer, and is just procedurally written locked to file_get_contents. Also, again, I think a lot of the interfaces may be there so that they can be quickly mocked using whatever mocking library they are using.
I said "most", not "all". Also, imgur was created 5 years ago, in 2009. A lot has changed since. But I digress, none of this changes the fact that PHP was Rasmus's amateur pet project that grew into the clusterfuck that it is today... This is a matter of simple fact. Shit like this: http://news.php.net/php.internals/70691 is why PHP is a clusterfuck. PHP is very easy for an amateur web developer to pick up, and that is why it will never die, and that is also why there is a vast expanse of shitty PHP code out there. PHP makes it far too easy to write shitty code, and people who pick up PHP as a first-language will need to unlearn the bad practices that are espoused by 90% of the PHP API. Don't get me wrong... I know PHP like the back of my hand, and have been using it for many many years, but it is definitely not my go-to language, and the same is likely true for many other developers, at least, developers who are polyglots. **edit** Also, imgur was created by an amateur college student, as a pet project, too. You have totally missed my point.
This is what basically I use in my logout class. if(isset($_SESSION['PHPSESSID'])) session_unset(); session_destroy(); session_write_close(); setcookie(session_name(),'',0,'/', null, null, true); session_regenerate_id(true); } Thanks http://developer.ifreelance.asia
Here in SF, the paying jobs go to the following in my experience: * Java * PHP * JavaScript * Ruby The only real reason Java is on top is scarcity of good developers.
This is a very poor analogy aside from being employable for a long time. PHP remains a rapidly evolving language, whereas attempts to move COBOL forward failed. 
&gt; people who pick up PHP as a first-language will need to unlearn the bad practices that are espoused by 90% of the PHP API. This. If only these PHP fanboys would understand what PHP *encourages* is actively harmful and, in most cases, completely defy proper CS paradigms. Yet if you try to tell people this, you just get called a "PHP hater", "*but that's the old PHP!*" or some variation of it. It should be telling that I have *never* met anyone whose only language is PHP to have a firm grasp of CS fundamentals. That is *terrifying*...
isn't ALL session data user-specific? what information might someone want to keep?
That was kind of my point. :) 
In my opinion this is the wrong approach to adding strong typing to PHP. A far better approach would be what Typescript is to Javascript. Compiling a type annotated PHP to pure PHP would give compile time type safety with full compatibility and very low to no runtime cost. 
So let me get this straight, I show you evidence that PHP is actively being used and considered in new software, you choose the *one* you can find something wrong with to point out, ignore the rest, and insert your anecdotal opinion without citing anyone but yourself. Then you try the tired old "but the neewwwwbs will do it wroooong" argument that we see in 50 "PHP IS DEAD" blog posts here every week. Troll harder.
Ruby on Rails is not a language. It is a framework built on top of the Ruby language. I agree with some of the author's arguments, but if you don't get the basics correct, people can't take you seriously.
&gt; knowing only one language speaks to a lack of effort in learning. True. &gt; That's not a problem with PHP. It is a problem with PHP. Comparing a person whose only (or preferred) language is PHP to someone with Java/Python/Ruby etc. the PHP guy is *always* the one who lacks CS knowledge. PHP is *specifically designed* so you can program without learning programming. Even internals is effected by this. For example, a bug [like this](https://bugs.php.net/bug.php?id=66608) (without even so much as an acknowledgement in *5 months*) would *never* appear in a well designed language with well versed developers. And yes, I make my living with mostly PHP but I don't delude myself thinking it is a good/acceptable language. &gt; This skillsaw will cut off my arm without stopping if I stick the running blade on my arm! Skillsaws are BAD! Yes, if you are using [this](http://a.thumbs.redditmedia.com/ol9clFDVjTJlLQpf.jpg), while everyone else uses a proper hammer, than your tool *is bad*. Is it really that hard to understand?
Wordpress is like the hydra of php. You cut one head off and two more grow back. 
&gt; With your suggestion I would have to either read through the documentation (which may not clearly point out exactly what that closure would be required of it.. or look through the code to understand what it is. I'm thinking about the number of different files that I have to flick through in order to grok what I need to do to get something working, I'm already looking at the main interface file or the IDE hints and using that as my main point of reference. The more files the info is spread out over the more frustrating it becomes to use, and having such a tiny thing in so many different files pushes it into the realm of annoyingly spread out. &gt; Since there is an interface I have a contractual obligation to follow exactly what is expected of my class. Yeah I agree that interfaces provide clear contractual obligations to follow, but it's still imposing additional structure and more importantly a specific programming style that requires me to define yet another interface and usually another file on the filesystem. Closures are extremely handy, as is being flexible in the parameter types you accept, which isn't incompatible with using interfaces. After all, isn't the point of providing a library to make it as quick and easy to use and programming-style agnostic? /** * Set the URL retriever which returns JSON as stdClass * Callable prototype: ( $uri, array $headers ) = stdClass * @param callable|RetrieverInterface $retriever */ function setRetriever( $retriever ) { assert( is_callable($retriever) || $retriever instanceof UrlRetrieverInterface ); $this-&gt;retriever = $retriever; } protected function default_retriever ($uri, array $headers) { // file_get_contents... } protected function retrieve( $uri, array $headers = array() ) { if( $this-&gt;retriever === NULL ) { return $this-&gt;default_retriever($uri, $headers); } else if( is_callable($this-&gt;retriever) ) { return $this-&gt;retriever($uri, $headers); } return $this-&gt;retriever-&gt;fetchJson( $uri, $headers ); } &gt; For instance, since you hate guzzle for some unknown reason (a dependency? It must be 2004, we don't have dependency management..) Composer is awesome and I have no gripes with it, and while it's nice that he provides Guzzle support it doesn't work out of the box without adding *yet another dependency* (if I don't already use Guzzle) or having to provide more boilerplate to plug it in. I see projects being slowly sucked into bloated dependency hell all the time, where using what could've been a simple library turns into auto-loading another 50-100 files throughout a call. Yes, APC negates some of the hit until it's doing thousands of `stat` calls behind the scenes spread out at various points through a page runtime to check if any of them have been modified and I start doing \*rolleyes\* All these extra files is death by a thousand papercuts, sure it's a drop in the bucket compared to Symphony or Doctrine - but they're not exactly shining examples either (even though I do quite like both of them). &gt; Also, again, I think a lot of the interfaces may be there so that they can be quickly mocked using whatever mocking library they are using. From a practical point of view the only thing that needs mocking to fully test something as small as this is the retriever, it makes little sense to provide interfaces for all of the models with logic-free 'model' implementations that just provide getters for some variables given that the `Snoop` class creates all the models from the retrieved JSON anyway. All these extra things are going against the principles of minimalism, DRY and KISS by abstracting too early for the sake of abstraction, leaving a lot of code which if removed doesn't reduce or alter the functionality and is superfluous for the way the package is used. &gt; I'd much rather see this than a gist that does it but isn't tested, isn't available via composer, and is just procedurally written locked to file_get_contents. I was never suggesting that it were to be procedurally locked to `file_get_contents`, especially given that to test it I would need to provide my own test data. Having it tested and available via composer is neat, but given the novelty that it uses an undocumented API call and could be condensed down into a gist for quickly dropping into a project makes me wonder if the trade-off of having all this extra code vs "oh cool, this is how I do it, and it's a neat self-contained class that I can drop into my project that works without any extra stuff" is worth it - I would probably just have gone with adding a single easily grokkable file into the project and upvoted for saving me some time without polluting my codebase.
Just wait until Perl 6 and things will change.
&gt; muh anecdotes and le claw hammer meme XD
Beer
Our department is making a concerted effort to support existing WordPress installations as well use it for our own, new projects. Please shoot me.
As long as Ruby stays at the bottom, I'm happy with whatever else happens.
Great article - saved in my prefs
The sarcasm is from the fact that PHP is not dying, goto is hated by a lot of people, and PHP recently got goto (which is a coincidence and doesn't at all mean PHP is dying).
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
&gt; I'm just trying to say, you can't really kill a programming language, and the more you do the more people will just start picking it up for fun. Cobol would like a word with you. Oh wait, he's dead.
Parses and autocompletes yaml config files? Is this a real world? Mine parses and autocompletes only xml config files.
100% agree, that's why I called it "a better way" ;) I'm working with Symfony for 3 years now and the assetic bundle is one of my least favorite bundles. In theory it can do almost everything with proper filters however amount of configuration it require to do so is to big.
session data is specific to that user's browser session, it may contain user specific information but you can also use it to track site or application specific things that have nothing to do with the user being logged on/authenticated. For example I often have my calling page set a token in my session variable then check if it is set in an AJAX rpc, this gives me the peace of mind that rpc request is originating from an authorized application page. edit - I also often use the session array to pass success messages on a post-&gt;get redirect.
I'm not PHP Only. But go on, post the 2-clawed hammer picture again! It does so much to reinforce your rehashed points that you read verbatim from blog posts in 2004.
Recently? It was added in 5.3 which was released in 2009 and is now EOL.
/u/sunshine_killer used the word 'recently', so I did too. I didn't bother looking up what version of PHP it was added in; for all I knew, it could be a feature from PHP 4. Though as someone who's not yet backed up all his data for the 14.04 upgrade and is still on Ubuntu 12.04, PHP 5.3 is still the current and latest release...
Cobol is not dead. Latin is dead, because no one uses it any more, cobol is still used, and therefore, not dead. Outside of your knowledge perhaps... but based on your wit, I imagine that doesn't take much. Do your own research. 
dd("language")
I simply think there is a huge difference when you consider that a "less popular" programming langauge can be picked up and still make a perfectly usable and functional application, whereas a spoken language, when it dies, really serves no purpose to learn. A dead programming language can be picked up in a week or two if you know coding to begin with, and it is still usable, alive. Latin would take the modern person decades to learn, and would be nearly useless aside from reading old books or for historical purposes. It wouldn't maintain its original usage like a programming language does. 
Having researched more about COBOL, it seems I was indeed wrong, but only because I didn't realize that since COBOL 85 they broke backwards compatibility to keep the language more modern. The most recent version of the COBOL standard came out this year, 2014. So indeed, it's not a dead language. The original language *before* they broke backwards compatibility, however, is a dead language. &gt; It wouldn't maintain its original usage like a programming language does. I can't find any evidence of *new* software being written in COBOL, just new features added to old software. In a way, that implies that COBOL no longer maintains its original purpose either; it's not used to create new software, just maintain old software. But I have no proof that new COBOL software is *not* being produced, so I cannot really say that for sure. I admit defeat; you are right, it is not a dead programming language.
@konradpodgorski can you also merge individual files from js in a particular order together? How about: merge: includes/views/*/css/*.css or better yet merge: includes/views/*/less/* I'd love to see some examples of more dynamic file structures to assemble js &amp; css from pattern-oriented frameworks.
Edit: I see reddit it stripping * from paths, had to wrap them with spaces around the problem is that in most js/css libraries order matter maybe instead of src/KP/LearningBundle/Resources/public/css/*.css you could write src/*/*/Resources/public/css/*.css this is also possible but no one would have control over it, so it's not recommended :) src/**/css/*.css not sure if that's what you mean. If you could explain it a little better
 if(is_array($foo) &amp;&amp; $foo) {
You did not show *any* evidence that PHP is being actively used and considered for new software. I know it is, unfortunately. But the example you chose to use, Imgur, is most certainly not new software, and it is also not **professional** software, even, which was the primary focus of my first post. I'm not trolling, I'm being 100% honest, and sharing my professional opinion. If you can't take the heat, get out of the kitchen. PHP is, and always will be a clusterfuck, because of the way it was originally developed, and due to the maintainers' inability and/or unwillingness to clean up the inconsistent syntax and apis. It won't happen without a fork, and nobody in their right mind would fork that clusterfuck, unless they had millions of dollars and lots of code monkeys to throw at it, because all of their legacy shit is riding on it (Hello Facebook) If you're denying this, then you are blind, or have no idea what you are talking about. And guess what... I STILL USE PHP. So quit telling me that I'm trolling... I'm not. It's 100% fact. PHP is a clusterfuck of epic proportions. Is it needle/haystack or haystack/needle? VerbNoun or Noun_Verb? Anecdotal evidence? HA! Go read the fucking PHP manual, pal, and take a peek into the underlying C code. Have you ever written a PHP extension? If not, you don't know what you're talking about, and you're out of your depth. PHP's garbage collection is a nightmare. Lemme put it this way, PHP is bad enough that Facebook wrote a new PHP interpreter and compiler from scratch (HipHop) rather than rewrite all of their legacy shit in a new language. And this is why PHP will never die, and again, backs up my original point. LEGACY support and maintenance are where a majority of professional PHP development is done.
&gt; And yes, I make my living with mostly PHP but I don't delude myself thinking it is a good/acceptable language. This. So much this. The last part, especially. Delusional, is putting it nicely, ha! It's like Stockholm syndrome, but for programming languages.
&gt; there must have been some claims to it being a dying language It's funny because the article doesn't really provide a source for those claims, apart from "some junior programmer".
&gt; This skillsaw will cut off my arm without stopping if I stick the running blade on my arm! Skillsaws are BAD! The difference is, the skillsaw manual doesn't tell you to do that. Having said that, I don't think the PHP manual does either. I'd sure love some examples from /u/callcifer to back up their point.
Just go for it. I've been learning through laravel for the past few months, taking it one step at a time. I started by just looking at the sidebar, and figuring out what the subjects were that laravel helps with. ( routing and requests? What's that? ) Then as I got a better grasp on those I started to get into oop a little more - really understanding classes, abstract classes, interfaces and such. Reading through some of the source code helped like crazy for me, taking Google breaks every time I hit a line of code I didn't understand. After I was comfortable with the basics of just oop structures, and the concept of interfaces / dependency injection I started reading up on design patterns like facades and repositories to really understand where some of the ideas came from in the first place. At this point, I feel like I've learned more in the 3 months of using a framework than I did in the 6 prior months of learning from a book. So just start with any framework of your choice, follow tutorials for it, build something every time you learn something, and ANY time a framework function feels like magic, stop what you're doing and figure out how it works (as best you can) before you move on. You will learn very fast doing this.
Not well. You will have memory leaks. But that goes for PHP in general, too, even with plain old arrays. I've done some super heavy data processing in PHP, we ran a site that got tens of millions of visitors per day that did pretty heavy data lifting, and I can assure you this: If you can shard that work out to backend servers, that's what you should do, whether that's a pool of PHP-FPM workers, database clusters, or using map-reduce with a NoSQL data store like Mongo or Hadoop... You're better off avoiding as much processing in PHP as possible, unless you can break it up and work in parallel with FPM pools. You will have memory leaks in PHP trying to deal with this much data, the garbage collection simply cannot handle it.
Good job! Just one problem - you need to fix the wrapping in the tables. The right column is wrapping single words like Freque ncy Comm on 
Folks like Nikita are already presenting many of these concepts (in the form of RFCs). I am not proficient at writing PHP extensions or extending core, so my efforts are better spent helping others to experiment with the tools available. If the working group are interested then I'll gladly send them some books, gift wrapped. Of course I want to improve PHP; and teaching developers how to use PHP is the embodiment of that desire! This is a book because research has gone into how to install and use the extensions, and how to build clean and consistent APIs. I already write (and freely distribute) many PHP tutorials and libraries, so I don't feel guilt in the slightest for wanting to make some money for the many hours I spend on PHP community work, every day. :)
I agree with this, a decent framework (Laravel certainly falls into that) will both help guide you and teach you OO concepts because they're the right way to do things to fit in with the framework. When starting out I realised after that I'd picked up some design patterns I didn't know by name from frameworks I'd used.
&gt; new $varname doesn't support variable arguments Funny coincidence, I was just having this exact problem yesterday. As noted in the Stack Overflow question linked above, this will be possible in PHP 5.6 using $instance = new $class(...$args); Is that was you meant by "pythons parameter packing" ? 
There are many online resources from *well respected CS personalities* that go to great lengths why PHP is bad, but sure I'll [provide](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) [a few](http://phpsadness.com/) [links](http://www.phpwtf.org/). Still, even if PHP didn't have *any* of these problems the following is still true: **It does nothing better than anything else.** And that, should be reason enough for competent developers.
Hehe, and chances are those people also haven't looked under the hood at Wordpress core either *shudder*. It's a cacophony of clusterfuckery. PHP's own problems are bad enough, then it's expanded out, branching, like a fractal pile of shit, fucking rat-nest. Granted, I haven't looked at that crap in years, but I have a feeling it hasn't changed much, because, you know, that thing that plagues PHP too... failure to do "backwards compatibility" properly. :S
If you already work with Magento, master it. Laravel is *php in 2014* and it's really fun to work with, but i rarely have free time available to do much with it. Instead ive spent the past 2 years learning Magento inside and out, this benefits my company and makes me a more valuable employee. All of my recent hobby apps were built in laravel, but my paycheck is built in Magento.
Obligatory shout out to http://laracasts.com. Not only will it help you learn Laravel, it will help you learn better programming practices. Jeffrey Way is the man. 
Does `$generator` always look like an array from the outside? For example can you use `count($generator)` or other array functions after line 9?
&gt; Hack is open source [them] calling it open-source doesn't make it so. They own it until they give it to a group of people who they don't pay... ;) &gt; Really, if we could get a consistent php, with autoboxing and sane methods, I'd be delighted That's the goal. It's difficult to show that without spoiling much of the fun! Scalar Objects (Nikita's extension) allows autoboxing. SPL types allows auto-unboxing, but needs explicit instantiation. There are ups and downs to both, which are described in the book. The book is short, but exceptionally focussed. Then there's the excellent technical review of Paul Jones and Phil Sturgeon... &gt; From what I could gather, it seems to me the approach is to create classes to wrap the native types The boxing code (in the sample) is the very first of a few sections with just plain PHP. The book describes the process of creating a full suite of functional PHP type methods. The only OOP-esque part of them is the namespaces in which they are arranged. Then the extensions are used to glue the autoboxing to the functional library. So the [sample] library implementations can be used with simple function calls, or as part of a larger OOP approach. Either will work, and the functional side will require nothing more than standard 5.4+ PHP. I would love for you to read the book (I'll send you a free copy) so you can tell me if you think I need to change it to be better for the community. :)
It's called Lazy Questioner syndrome.
You're ready if repetition pisses you off and you feel like you're just doing monkey work instead of solving actual problems.
If you've done anything relatively complex in Magento you already know Zend Framework 1.
COBOL IS SO TOTALLY NOT DEAD IT IS REALLY DEEPLY IN USE BY A LOT OF REALLY COOL PROGRAMS BUT HOPEFULLY YOU WON'T RUN INTO IT VERY OFTEN SINCE IT IS SORT OF LIKE SHOUTING AT YOU OR YOURSELF MOST OF THE TIME
That's it, yes! I just read yesterday, that this is included in PHP 5.6, so my question about the current status is moot. :)
You are ready. Side note, it might be a good idea to advise your company to dump opencart, because the developer of that framework is insane.
Hey, thanks for the free copy, I'll give it a read soon and let you know what I think. As for Hack and open-source.. I guess we need more words :). It's definitely open-source as in forkable and definitely not open-source as in community-owned. So yeah, about as free as Java or Chrome, for better or worse. Though I must say I have no problem with that so far. Well, I'll go and start reading now :).
WHAT ARE YOU TALKING ABOUT? THE DEVELOPER OF OPENCART IS LITERALLY GOD. YOU CAN'T TALK ABOUT PEOPLE LIKE THAT. HOW MANY ECOMMERCE SOLUTIONS HAVE YOU DEVELOPED? WHAT'S THAT? NONE? THEN YOUR OPINION DOESN'T MATTER. PS: YOU'RE AN ASSHOLE.
"PHP... 1998". It started in 1994, and was in even moderate use in 1996 (most of my projects in 96 were in PHP). 
From what you described of your current architecture (super class extended for every model) doctrine 2 would consume far less memory. This is because D2 allows you to use POP (plain old PHP) objects which extend nothing. However, I think any ORM would struggle to manage 100k model objects (as would PHP). Do this many model objects really need to be loaded into memory for your application to function? Might be worth rethinking. As for performance, it really depends on what you're trying to do with your data. In some circumstances a "UnitOfWork" can be more performant. The way this works is it allows you to manipulate as many of your models as you wish. All changes are collected and stored in a UnitOfWork and are then executed as a few optimised queries at the end of runtime. If for some reason you were iterating inserts, or frequently changing your model's state, using this method could significantly reduce round trips to your DB. But, if you're just pulling out data, or inserting without any future modifications / inspection in each request, then an ORM/DBAL abstraction could well be unnecessary. Certainly don't ever hesitate to just grab a DB connection pointer and apply modifications directly if it makes more sense.
The same page above mentions that the Generator object implements the Iterator interface. It makes no mention of the Countable interface, and since Iterator doesn't implement Countable either, the answer is "no you cannot use count() on a generator." I haven't tried it myself though--give it a shot and see what happens! Edit: try this: http://www.php.net//manual/en/function.iterator-count.php Theoretically any function you can use on iterators should work on generators 
I do think this is useful, thank you. Looking forward to the next part especially the less/sass part
&gt; THE DEVELOPER OF OPENCART IS LITERALLY GOD. That explains so much...
&gt;Back in 2006, when Ruby on Rails was developed from Basecamp by David Heinemeier Hansson, it seemed to be the next, best pioneering language. Does this imply that Ruby on Rails is a Language, because it is not... &gt;Order, It all comes down to order. Order is what defines us, clarifies ideas. Order allows us to get to market quicker, safer, and less defects. Order is a pristine engine that is maintainable, scalable and extendable. What the... How did this get up-voted to the top? I really think the quality of this sub is taking a nose dive...
From my understanding, hack doesn't change any of the php function names which is the usual gripe people have. All it does is provide a JIT compiler and strong typing. Happy to be corrected
The power of Wordpress will just bring you back
If you want to know how to make a proper white-list, please check out the Content Security Policy specification. [HTML5 Rocks](http://www.html5rocks.com/en/tutorials/security/content-security-policy/) has a quick primer. It is white-listing done the right way. While yes, XSS can still occur, this raises the bar extremely which is the entire point. If you feel you can bypass this (without being stupid) then please go for it and discuss how you did it in the [webapp-sec mailing list](http://lists.w3.org/Archives/Public/public-webappsec/) since it would be something that maybe needs addressing.
You sound ready to me! Since no one else has posted these, here are a couple introductory docs from Symfony2 that I like to point people towards when they're just getting the hang of frameworks. Symfony2 is a stellar framework, but you don't need to use it to get some good starter knowledge out of these: * [Symfony2 and HTTP Fundamentals](http://symfony.com/doc/current/book/http_fundamentals.html) * [Symfony2 versus Flat PHP](http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html) 
Do you want to learn a framework?
Except that Symfony2 documentation is only good on the level of the components. As to how the framework actually fits together those components...good luck.
Could you recommend some good resources to learn Magento?
\*'s around a word are used to make text italicized. If you want actual \*'s, stick a backslash in front of them. &gt; \\*
Was this to the tune of Frozen? Do you want to build a snowman... I sense a nerd parody in the making. 
[The best way is to hit up the creator. He usually is pretty accomodating.](http://en.wikipedia.org/wiki/Devil)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Devil**](https://en.wikipedia.org/wiki/Devil): [](#sfw) --- &gt;The __Devil__ (from [Greek](https://en.wikipedia.org/wiki/Greek_language): [διάβολος](https://en.wikipedia.org//en.wiktionary.org/wiki/%CE%B4%CE%B9%CE%AC%CE%B2%CE%BF%CE%BB%CE%BF%CF%82) or *diábolos* = [slanderer](https://en.wikipedia.org/wiki/Defamation) or accuser) is believed in many [religions](https://en.wikipedia.org/wiki/Religion), myths and [cultures](https://en.wikipedia.org/wiki/Culture) to be a [supernatural](https://en.wikipedia.org/wiki/Supernatural) entity that is the [personification](https://en.wikipedia.org/wiki/Anthropomorphism) of [evil](https://en.wikipedia.org/wiki/Evil) and the enemy of [God](https://en.wikipedia.org/wiki/God) and humankind. The nature of the role varies greatly, ranging from being an effective opposite force to the [creator god](https://en.wikipedia.org/wiki/Creator_deity), locked in an eons long struggle for human souls on what may seem even terms (to the point of [dualistic](https://en.wikipedia.org/wiki/Dualism) [ditheism](https://en.wikipedia.org/wiki/Ditheism)/[bitheism](https://en.wikipedia.org/wiki/Bitheism)), to being a comical figure of fun or an abstract aspect of the individual human condition. &gt;==== &gt;[**Image**](https://i.imgur.com/Q2Fsg7N.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Codex_Gigas_devil.jpg) - *Depiction of the Devil as seen in the Codex Gigas.* --- ^Interesting: [^DevIL](https://en.wikipedia.org/wiki/DevIL) ^| [^Devil ^\(Dungeons ^&amp; ^Dragons)](https://en.wikipedia.org/wiki/Devil_\(Dungeons_%26_Dragons\)) ^| [^Devil ^in ^Christianity](https://en.wikipedia.org/wiki/Devil_in_Christianity) ^| [^Devil ^\(2010 ^film)](https://en.wikipedia.org/wiki/Devil_\(2010_film\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cifrli9) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cifrli9)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It doesn't have to be a framework.
I'm waiting for the day when someone like Fabpot, or Rasmus replies to him.
Definitely, its your rights to choose whether you use class or simple form. Yes, it is true that, this tutorial will not add any css class or id because I used simple format to access that class, nothing else. This may be one of the reasons.
Huh, TIL.
Kinda like SQL? I know capitalization is optional in most SQL variants, but I like to use the all-caps when using built-in keywords, and all lowercase when using names and whatnot I've made myself.
And if the constructor throws an exception? I mean I don't care if you use exceptions or not. The issue is why do they use reflection, regardless of exceptions. Even in the code posted I don't think they handle for that scenario but you may still end up dealing with them anyway depending on your scenario.
Kinda, except all the COBOL I've ever seen is always ALL CAPS. And the people that write it seem to always end the line at the same point too. You'll notice the above has about the same number of chars in every line. Only issue with SQL (or at least MySQL, I don't mess much with MSSQL) is remembering not to name your database fields the same thing as a built-in keyword...or to use the ` quote around them. ^^But ^^I'm ^^sure ^^you ^^already ^^knew ^^that. ^^Sorry!
Haha, I'm more than fine with people talking about things I already know about. Only time that's annoying is if the person knows me fairly well, and they know I know, but repeat it anyway. Worst is when they say I already know it before they say it. But yes, I'm quite familiar with MySQL. It was one of the few languages I learned where I picked it up and ran with it; for some reason, SQL just *clicks* with me. Database diagrams may confuse the hell out of me, but give me a giant list of `CREATE TABLE` statements and I understand it completely x) By the way, if you want to post code here on Reddit, put four spaces in front of each line. For code snippets that are inline with other regular text, put '`` ` ``' around it (like `` `this` ``). And in typing that I discovered a new trick: to actually have backticks inside of inline code, double the backticks surrounding the inline code. For backticks at both the start and end of inline code, wrap the contents of the inline code with spaces so that it looks like: `` `this` `` Can make posts with code much prettier :)
Which browser and platform?
&gt;the example you chose to use, Imgur And what about the other FIVE EXAMPLES I linked you to that you ignored? Stop cherry picking or fuck off. &gt; [Regurgitated 8 year old shit that's been debated ad-nauseum and things that were fixed a major version ago here] ZzZzZz - My point is that PHP is being actively used and considered for new projects, not that it's better than whatever web language your chubby is inflated for. &gt; Lemme put it this way, PHP is bad enough that Facebook wrote a new PHP interpreter and compiler from scratch (HipHop) rather than rewrite all of their legacy shit in a new language. That seems to defeat your point, not back it up. Facebook likes the language so much that they'd rather make drastic improvements to it on their own than use something else.
&gt; PHP, A Fractal of Bad design notthisshitagain.jpg Obviously you haven't been in this subreddit long enough to read the long list of reasons that outdated blog post is for the large part, horseshit, that gets posted every time that article gets posted. &gt; It does nothing better than anything else. Them unquantifiable opinions, yo.
Don't tempt fate. If Daniel replies to any sort of retort from those guys I guarantee you the world will segfault.
Have a look at Silex... https://github.com/silexphp/silex
Oh, and I applaud your attention to avoiding globals and singletons!
Functionally from the perspective of memory management, yes, but that's not the point. A singleton uses the global namespace to manage the instance. Both a service locater and a Dependency Injection container use a class whose responsibility it is to manage the state of the 'singleton' and ensure that nothing needs to actually manage it, only utilize it. With a DIC, it also manages things like lazy-loading, constructor and setter injection, and namespace prefixes.
I tend to like an 'indexed singleton', as in you have a class that holds the PDO object in an associative array. This way you can keep the connection while allowing for other connections, and not reconnecting every time you use it. 
For a more general case, yes. My meaning was a database-connection specific class.
I don't need to bypass it, because a large chunk of the internet doesn't even support it (&lt;= IE9). Ignoring that, CSP also has conceptual vulerabilities that aren't possible to mitigate due to the nature of the design. Not XSS-related, but still not good. Anyway, "raising the bar" is great and all, but it's still not as effective as educated developers. Things like CSP and HTMLPurifier are great as safety nets. They guard against accidents, mistakes, and ignorance to a pretty good degree. But none of it is fool-proof, and the best way to protect your apps is to understand the problem.
Ah, well if it's specific to the DB class then it's just a wrapper and offers no benefit over the global namespace.
I understand that globals are undesirable, and I know that singeltons are anti-patterns and all that, but surely there are times when we only want one instance of something? The DB connection seems like a prime candidate. No?
Fork them!
"One instance" != "singleton" Using a single instance if a class is a very real (and common) use-case. That instance just shouldn't be accessible globally, is all. And singletons are effectively globals.
I think you are ready when you are familiar with: - OOP - MVC - Dependency Injection
qinq is probably my favorite out of those. Very interesting work from the readme's. EDIT: Okay, you need to document the dependencies in the readme. I was just looking at qinq a bit more, and most of the interesting stuff is actually implementations of other packages you made, but that's not clear from the readme, only from the composer.json
That is quite the collection there, well done! I didn't get a chance to take a close look at them but as a small, offtopic suggestion, please tag your releases (bonus points if you can abide by semver) as using dev-master destroys all stability guarentees. Anyway, you seem to be doing an impressive amount of work with these libraries, keep it up!
I assumed this post was to collect feedback before tagging releases for composer and packagist, but I agree with this as well.
 $stmt = $mysqli-&gt;prepare(" INSERT INTO Q".($count+5)."table ... ") 
&gt; Engineer on Hack here, glad to see folks excited about it! Awesome! Not your guys' job, but if you could perhaps encourage some IDE tools for hack it would be grand. Do you all use vim/emacs internally? I'd love to see Hack support in Netbeans for instance. &gt;Most of the type system of Hack is enforced by a program separate from HHVM that you have to run, see http://docs.hhvm.com/manual/en/install.hack.bootstrapping.php. This is kind of confusing and I'm working on making the process better here, but that's the way it is right now -- you need to be running the separate hh_client program if you're using Hack, otherwise you aren't getting any of the benefits of having a static type system! That is indeed very confusing, and not something I gathered from any of the docs I read, but good to know. Is Hack something that HHVM is slated to support itself in the future? &gt;"Unsafe" isn't a mode but rather a way to say "hey typechecker just trust me about this" for a specific block of code, see http://docs.hhvm.com/manual/en/hack.modes.unsafe.php. This I actually tried to make clear, but I probably didn't. The docs are very clear about this. &gt;We're actually neither a superset nor a subset of PHP -- we've added some things, but the typechecker disallows you from using some things as well, e.g., $$var. Also something I gathered from the docs, but sort of a nitpick for the "first introduction to Hack" type thing IMO. A bit of nuance I thought to introduce later. :) &gt;I'm clearly biased here, but I disagree :). Gradual static typing (via Hack) provides a huge win in maintainability and developer efficiency in my experience. This I agree with completely, but for experienced PHP devs unsure about Hack, working with their existing app might feel weird. A lot of PHP devs don't really understand strong typing that well.
&gt; "One instance" != "singleton" I think you just broke my brain.
Kudos for writing 12 packages.
It would techincally do the same thing, but you can only have one instance of a singleton. So when you want different connections, you are kinda screwed.
Can you use both? Slowly migrate everything over?
Here are all the useful articles i found while i was studying for my MCD last year: http://goo.gl/37O5VJ
That's fine. I was like that. Then I tried Python, Node, Ruby etc and found something better. This will happen to you one day.
By professional I do not meant **PHP PRO** I just wanted to say that now I work in industry working on real projects rather than doing crappy pet projects. Anyways thanks for your **non-motivating** comment. It helped alot.
I understood some of those words! These all look really well done, I have trouble getting used to some of your coding style but that's just a personal preference thing... e.g. - namespace thing { ... everything goes here ... }. Doesn't bother me much because I'd never look at it when just using it anyway. XRAL looks useful! Very nice abstraction. I like it. Starred.
Can you give examples of when you would use each?
Google Chrome, on both Mac and Ubuntu. Your font size is too big in the tables really, you ought to make it a bit smaller than the body text. Or just use `white-space: nowrap` on the cells in the right column.
&gt; e.g. - namespace thing { ... everything goes here ... } Good question. My preference when using the namespace directive depends on the predominant patterns used on a per-file basis. I favor using braces in php files that strictly define OOP abstractions, as seen in most of these packages. There are some cases where I might (have to) do differently, like for example in a file that contains primarily procedural code or a file where the primary language is not php(i.e. html template view). 
Sure, let's take a look at a simple function, [file_get_contents](http://php.net/file_get_contents): What does it do? According to the docs it *"Reads entire file into a string"*. But does it actually do that? Let's look at its arguments: **filename**: What is a filename? A local URI? If so, does it need "file://" in front of it? How does it handle backslashes? Is it platform specific? Can I pass a URL here? (***yes I can***, even though it is undocumented - examples are not documentation - and ***completely out of scope*** for a function that "gets the contents of a file". Remote URIs are not files) If I can pass any URI, which protocols does it support? How does it do the handshake for secure transports? Does it need certificates for SSL? If it fails, how do I know? **use_include_path**: Why does this exist? How does it interact with open_basedir in php.ini? How is it related to the *content* of a file? **context**: *A valid context resource created with stream_context_create()*. What? What stream? I didn't open a steam, where did it come from? If I wanted to use a stream to access a file I would have use fopen. Why is it here? How does it behave? Does it support all stream context options (hint - it does not!)? **offset**: It says the behaviour of this argument is ***unpredictable*** for non-local files, but it *might* work? What sane language has a *might work* function in its stdlib? **maxlen**: **Holy shit!** What is maxlen? How is it measured? In bytes? Bits? Characters? If characters, according to which encoding? The one with the file? Or the PHP locale? Or maybe the system locale? So how does it relate to your question? The language (and its documentation) actively encourages this horrible, *insane* function: &gt; file_get_contents() is the ***preferred way*** to read the contents of a file into a string A sane language would never even ***allow*** this, much less encourage it. Hope this helps. **EDIT:** I missed the last part of your post: &gt; name a server-side language for the web that is fast, easy to install, and Just Works with either a simple one-page script right up to a full-blown web app. Python. Faster than PHP, setup via virtualenv takes seconds and is a breeze, you can put a single index.py and it will work. For Apache users there is mod_wsgi which is the Python equivalent of mod_php and it is just as easy to install it. For more advanced setups (like PHP's FPM) there are similar solutions for process pooling, configuration etc.
Apart from syntax is the issue. Your query expands to: INSERT INTO `TEST-TABLE` (Test_Title) VALUES(testname) Note, the value testname is unquoted hence it thinks it is a column identifier. You need to place it in quotes like so: $stmt = $mysqli-&gt;prepare("INSERT INTO `$test_table` (Test_Title) VALUES('$TestName')") or die($mysqli-&gt;error); Also you should consider using a prepared statement and binding parameters rather than concatenating values directly into the SQL, see the example: http://php.net//manual/en/mysqli.prepare.php
Nice post. The only thing preventing me from writing Hack is that it's still unstable for my app.. It keeps segfaulting :( but damn would I love to strong-type that code! Cheers.
You're better off putting this in ``filters.php`` under ``App::before``.. and make use of the ``$request`` var that it gives you. Putting it in routes files just like that is weird. 
Professional **programmers** do not ask if it's the right time to learn something. They just do it.
let the drama begins 
Yes, that's absolutely correct. The singleton pattern is just a way to *enforce* that only one instance is ever created; whereas without a singleton pattern, you have to manage that constraint yourself.
Well for example with qinq, is there a certain problem that it solves better than the built-in array functions? Or is qinq supposed to be a replacement for the array functions?
nice summary..last time i talk about how shitty php is, most pf the /r/php make fun of me..most php programmer cant accept how shitty php is..they live in denial...and i agree with the BC..i used to told /r/php main problem php is the maintainer is pure retard..do not want to break BC..how on earth u gonna fix the language if u do not introduce BC..heck after major release, they make a decision to introduce GOTO keyword..php core dev is a moron
There seem to be a lot of packages that handle this over here. https://packagist.org/search/?q=paypal Maybe one of those would work for you.
qinq, in most cases, is practically identical to default array handling behavior (replacement). qinq does provide additional convenience methods outside of simple array handling to assist in reducing the conceptual cost of doing standard array transformations. An example might be the *Average* statement that will sum an array and divide by the array size. This reduces the amount of code and thinking required for this relatively simple task. $integers-&gt;average() vs.. array_sum($integers) / count($integers) If you look at [Average.php](http://github.com/jgswift/qinq/blob/master/src/Object/Query/Average.php), that is exactly what the statement does(line 11). This may be a bad example, and I'm sure some will argue the performance cost outweighs the conceptual benefit but it can be useful nonetheless. Having an abstraction layer here does add flexibility at the cost of performance. That is usually the case with object-oriented php. The primary benefit is that queries provide a simple approach to handling arrays that is consistent with itself and other similar conventions like SQL or LINQ. 
The Qing package is really awesome. Thanks for releasing these.
I can't not read that as Fapbot.
Well, In my case it is different. I do not need to learn it as the company where I work requires me to learn something, in that case I would have already learned it. I want to learn it for myself thats why I asked for suggestion. BTW for the matter of never asking question please don't tell me that.
&gt; but if you could perhaps encourage some IDE tools for hack it would be grand. Do you all use vim/emacs internally? Folks internally are pretty split between vim, emacs, and FBIDE (our own IDE which, last I heard, we want to release at the end of the summer -ish). If others want to add support for other IDEs, I'm more than happy to give them some pointers on where to get started -- in particular, looking at the vim plugin https://github.com/hhvm/vim-hack is a good place to start. We'd absolutely love it if anyone else wants to add support to other IDEs, but just don't have the resources to do it ourselves, sadly. &gt; Is Hack something that HHVM is slated to support itself in the future? It depends on what you mean by HHVM supporting Hack. Of course HHVM does support Hack -- it runs the code! :) The distinction really makes sense only from a historical perspective; we weren't sure the entire typechecking thing was going to work at all, so we wanted to minimize changes to HHVM -- as far as just running the code is concerned, Hack is almost identical to PHP. It's just the extra typechecking phase, which was a separate system. It also makes a lot more sense to write a complicated typechecker in OCaml than in C++ -- complicated transforms and computations on an AST is something OCaml is very good at. (C++ is very good at the low-level JIT magic that HHVM does, on the other hand.) To answer the question you were most likely trying to ask: no, the runtime itself will probably never be able to enforce the whole type system. It's just a different way of looking at the world. However, will we try and blur this line as much as possible? Definitely. The fact that it's two separate binaries right now is definitely an implementation detail, and something quite likely to change eventually. This is why I've been telling people who are trying to run code that is ill-typed that they are well into undefined behavior land -- it happens to work now, but if we ever couple the typechecker and the runtime more closely (and we've tossed around lots and lots of ideas for different ways we might want to do this), things may stop working or do weird things in the future.
&gt; as far as just running the code is concerned, Hack is almost identical to PHP. To clarify this -- it's become a lot less true as we've added more involved language features such as short lambdas, async functions, trait requirements, etc. But that stuff only started happening after it was clear the type system was a good idea and going to work well.
Static variables can't enforce anything. You could create two instances of your database class and assign both to different static variables, or even both to the same static variable in different parts of your code. What a singleton does is disallow you to ever create more than one instance in the first place. No matter how many times you call `Database::getInstance()`, it's going to return the same instance. And you can't use `new Database()` to create a different one because constructors are made private in a singleton pattern.
I'm wondering why some of these have to be PHP 5.5+, projects such as persistr parse perfectly fine on 5.4.
Good question. I struggled with this myself and am still not entirely sure the best way to approach it. The main problem is that one particular package dependency, namely qtil, requires 5.5 because of the use of the "finally" keyword. persistr requires qtil to reduce duplication and therefore inherits this dependency from qtil.
So how are you differentiating things that aren't implemented by the interpreter itself in hack (typing) and things that are (async)?
typical PHP user lmao
When did you read the docs last?
This was all just a ploy to sell my new book "Programming On Steroids." Just kidding.
You don't have to use DIC if you don't want to. It has some disadvantages. There's a lot more setup (building up objects and pass their references around) usually to get things up and running. Here's a StackOverflow page that discusses the disadvantages of DIC more: http://stackoverflow.com/questions/2407540/what-are-the-downsides-to-using-dependency-injection
Planned features are autologin when user have remember me functionality. Checkout the todo https://github.com/auraphp/Aura.Auth/blob/develop-2/TODO.md
I look at about half of them and I must say this is very impressive. It is very clear that much thought has been put into this and I sense either great programming experience or academic background (or both). However, I would most probably never use any of them, the whole thing looks over-engineered quite a bit and is too far from the rest of the PHP world. This is not a bad thing on it’s own, but I generally like that other people can understand my projects, so having a new programming style mixed in the middle with a heavy use of recent paradigms such as traits might be too much. Let’s take for example `kenum`, its task is rather simple: wrapper around Enums to provide some goodies that are present in other languages. However, the library contains 1 trait, 2 interfaces, 1 manager class, 2 public classes (meant to be used) and uses 1 other package referenced through 1 interface and one extend. That is some crazy complexity, I was confused just understanding what this class was doing: class kenum\Enum\Registry extends qtil\Access\Registry extends qtil\Registry { use qtil\Reflector; } *** Being similar to the rest of the ecosystem is important, it is way easier to get people to adopt it, that is why there are things like [PHP-FIG](http://www.php-fig.org/). Things to consider imho: * Switching your code style for PSR-2 * Adding a vendor prefix * Changing all namespaces to capitalized * Adopting the heading syntax for your namespace declarations. * Using more `use` statements instead of referring to classes/interfaces with absolute names, this way it is clear, at the top of the file, which foreign classes are used in the file. * Reducing the amount of voodoo to keep the whole thing understandable for normal humans who did not spend hours (days?) developing a library, but still want to use it.
I agree that most of the PHP community lives in denial, but PHP can't just break BC. If they did, no one would have any reason to use PHP anymore because when you break BC, your new project can just as well be written in a saner language (Python, Ruby etc.).
One suggestion whether you choose laravel / symfony / zend or aura is closely watch the repo and read the code, what it does. It may help you to become good in what you do. It is always good to learn components rather than a monolythic framework in my opinion. Where components help you when you want to maintain a website or do any additional features when it is not written on a framework or collection of libraries. If you stronlgy feel you only need a monolythic framework and will be working only on that go for the best one you like. Hope that helps a bit!
The code above is commented out. Is it uncommented in the actual script?
You're looping through a query instead of looping through the array you're intending on fetching. From php.net, try something like this instead: $stmt = $mysqli-&gt;prepare("SELECT name, userid FROM somewhere"); $stmt-&gt;execute(); $row = array(); stmt_bind_assoc($stmt, $row); // loop through all result rows while ($stmt-&gt;fetch()) { print_r($row); } Also, kudos not using mysql_, but I'd suggest using PDO over mysqli.
This is taken from [Aura.Di](https://github.com/auraphp/Aura.Di#variation-2-lazy-loading) $di-&gt;set('database', function () { return new PDO('dsn', 'user', 'passwd'); }); and calling $db = $di-&gt;get('database'); will get you the database object. Now regarding how you can pass the object to another class is you want to set the params that are needed for the class and use the di container to instantiate the object. See constructor params https://github.com/auraphp/Aura.Di#variation-4-class-constructor-params $di-&gt;params['Example'] = array( 'db' =&gt; $di-&gt;lazyGet('database'), ); $example = $di-&gt;newInstance('Example'); or pass $db directly to the object as $example = new Example($db); If you go through the documentation of the Aura.Di you will clearly understand more variations and usage examples. I highly recommend to read it https://github.com/auraphp/Aura.Di . It is really great content for the Di well written. at-least in my view.
You should use the connection as the 1st param in mysqli_select_db (and your dbname as the 2nd) if you use the procedural way. (same in mysqli_query)... - look at http://www.php.net/manual/en/mysqli.select-db.php and http://www.php.net/manual/en/mysqli.query.php
actually, CI3 is around the corner with a very active repo. I still can't decide between CI3 and Laravel
As I understand filters I have to apply them directly to routes or route groups and this would require more code, or do I think wrong? Sorry I'm new in Laravel.
As stated in the blog post I didn't wanted to use an URL with the language code after the domain.
This is a great response. You hit the nail right on the head. I definitely appreciate the depth and gravity of these comments. Thank you for suggesting PHP-FIG. This looks like a wonderful effort and I will certainly research this group and their collective approaches. I generally agree with your pragmatism which I might call, leaning towards the average. I agree that it is most certainly important for ease-of-use and mass appeal in the moment. However, I respectfully submit that such moderation can come at the cost of flexibility, code duplication, and future-proofing. This is a difficult balance to strike given the degree of conflicting goals apparent in academia and business. In other words, I am not only working within the constraints of the programming language but also the relative knowledge and disposition of my respective community. By extension I can either simplify the code (limiting my tools) according to predominant practices *or* patiently sit ahead of the bell-curve waiting for the average to catch up (assuming it does or that this approach is valid in any future). Honestly, I don't objectively know anything and can hardly make an argument citing a non-existent alternate universe. Like you mentioned, establishing consensus is why organizations like PHP-FIG exist. Forgive me if this is inappropriate but I hope to bring some levity to what is a common risk analysis method businessmen use every day. I see I have a responsibility to lean towards the average *or* alternatively compensate using documentation to bridge the gap between what people conceptually understand and what machines can objectively handle. A relevant analogy might be found in the car industry. For example, during the start of the industry, cars were simple enough that any competent machinist could handle their maintenance. Nowadays, in contrast, being a mechanic requires a great degree of specialized knowledge as cars have drastically increased in complexity. Perhaps I am naive for assuming the need for improvement exists or that an objective principled standard is possible. Certainly there is a great variety of structure/verbosity among programming languages at large and applying certain practices to php might certainly be inappropriate. In any case, your comments are appreciated, completely valid, and nearly beyond reproach - I will absolutely take this into consideration. 
It also remove some of the more outrageous features like variable variables etc.
Qinq is the most interesting to me, being able to query arrays is quite awesome.
let the drama begins :)
Thanks! &gt; How did you write 12 packages Through extensive trial and error. Simply put, I decided to write a framework after many years of developing web applications The Wrong Way(tm). Most of these components were used in some capacity for that endeavor. Ultimately I decided for numerous reasons to break it apart into individual packages(outside of the framework) and release them under an opensource license. &gt; in what time span Not surprisingly, this answer isn't as easy it should be. Rather, it depends on how you look at it. If I assess the sheer man-hours I estimate each package required ~3 days (~72 hours) to write. That is, without sleep, eating, or anything resembling life involved. If I take life into consideration then each package took about ~10 days - so roughly about 12 packages in ~4 months. &gt; how do you pick names for packages Well essentially I used terms specific to the individual packages and wrote a list of ideas. I might simply add a letter or remove a vowel until I found something catchy. I will also do a brief search to check that other similar projects aren't using the same name. 
What in the world. A normal developer would NEVER run into all those issues explained (unless you're doing something terrible wrong). Instead of bashing on the tool and writing useless blogposts, write a patch and just shut up. "There are only two kinds of languages: the ones people complain about and the ones nobody uses" - Bjarne Stroustrup
I did it with both wordpress and ghost. Ghost has a cleaner database schema, which was really really easy to fetch from Laravel. 
mysqli expects 2 parameters try this: mysqli_select_db($connect, "mynewdatabase"); mysqli_query($connect, "SELECT * FROM members WHERE username = 'john' "); 
I've fallen out of love with Wordpress.... Does Ghost have capabilities for management of custom content types?
Nope. It's simple as fuck. Doesn't even have multi-user authentication last time I checked 5 months ago (maybe its changed now). 
I always wonder about this: did you not read the messages in the errors ? I mean really, googling any of the error messages verbatim would have given you an answer, its as simple as that. They tell you exactly what the error is and on what line: - mysqli_select_db is missing a parameter. lookup php.net/mysqli_select_db and find out what your missing parameter does. for future reference, always go to php.net/$function_name and it will tell you what it does - same goes for mysqli_query, also missing the second param - third one is telling you the function you are calling does not exist. the code you give as an example does not have this function anywhere, so I am assuming you replaced mysqli_fetch_result with mysqli_fetch_array, which has resolved the error 
while learning a framework might not take so long, mastering it certainly will. Before doing that try this: http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1 
 App::before(function ($request) { $url = explode('.', $request-&gt;server('HTTP_HOST')); $subdomain = $url[0]; $languages = ['en','de']; if ( in_array($subdomain, $languages) ){ App::setLocale($subdomain); } }); It's the same thing, but doesn't use superglobals, and its put in the right place. I would also replace $languages to a config.. ``$languages = Config::get('languages.available')`` or something. edit: fix formatting
It always seems like the complaints people make about PHP are when they start doing things that I would classify as "trying to be cute with their code". Mixing and matching all types of weird shit and then calling some strange function or language feature and then complaining when they get some unexpected result... until you sit-down and step-through it all and see that if they had just stopped trying to be so clever with their code they wouldn't have run into strange edge-cases.
More upvotes for this guy
&gt; What is a filename? A local URI? If so, does it need "file://" in front of it? How does it handle backslashes? Is it platform specific? Can I pass a URL here? ... That's all documented [here](http://www.php.net/manual/en/wrappers.php), which is linked from the manual page. Do you really expect full details to be listed on every single function that allows stream wrappers? &gt; Remote URIs are not files Of course they are. Just because they may not correspond to a specific static file on the server doesn't make it not a file. The same occurs on your local filesystem (e.g. symbolic links). &gt; offset: It says the behaviour of this argument is unpredictable for non-local files, but it might work? What sane language has a might work function in its stdlib? All languages have undefined behaviour in certain circumstances. &gt; maxlen: Holy shit! What is maxlen? How is it measured? In bytes? Bits? Characters? It says right at the top "starting at the specified offset up to maxlen bytes". &gt; Python. Faster than PHP [citation needed]
Thanks for your help!
I would prefer: average($integers);
&gt; calling some strange function or language feature If they are not meant to be called, why are they there in the first place? If they are "old stuff" why are they not deprecated/removed?
It's been setting on 3.0 forever. The fact that it's own parent company, who uses it in its flagship product ,is trying to dump it off on someone else says a lot. Even in 3.0 it's ass dragging behind symphony and Laravel.