Yes, yes it does matter. If you haven't bothered to follow a consistent coding style it gives a bad 'code smell'.
"secure". should just be called old.
PS... here is my html for that is repeated several times throughout the page - &lt;div id="assessmentdiv"&gt; &lt;input type="text" id="risk" name="risk[]" placeholder="risk" value=""&gt; &lt;br&gt; &lt;textarea name="riskee[]" id="riskee" placeholder="Who is at risk?"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;textarea name="control[]" id="controls" placeholder="Control measures in place"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;select name="rating[]" id="rating"&gt; &lt;option value="high"&gt;high&lt;/option&gt; &lt;option value="medium"&gt;medium&lt;/option&gt; &lt;option value="low"&gt;low&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;textarea name="additional[]" id="additional" placeholder="Additional measures required"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/div&gt; 
It's not about upgrading, the problem is that that the wordpress theme should support as many php versions as possible. According to stats, a lot of customers are still on 5.2 and 5.3, so in order to increase the number of potential clients, we have to lower the requirements unfortunately.
One of my former co-workers sent me it this morning, had no idea
Because not everyone has time to be a devop or admin. Surely you understand a need for managed hosting?
This should work based on your form: foreach ($_POST['risk'] as $key =&gt; $value) { $risk = DB::getInstance()-&gt;insert('risks', array( 'risk' =&gt; $value, 'riskee' =&gt; $_POST['riskee'][$key], 'control' =&gt; $_POST['control'][$key], 'rating' =&gt; $_POST['rating'][$key], 'additionalInfo' =&gt; $_POST['additional'][$key], 'company' =&gt; $user-&gt;data()-&gt;company )); } One tip to keep in mind if using checkboxes, it's better practice to set an index in the field names to keep them in sync, like `risk[0]`, `riskee[0]`, etc.
There's (at the moment) no better IDE than PHPStorm. Really wish they had a bit more competition though. Sure, there's Netbeans, Aptana, PHPDesigner, etc - but (aside from personal preference) they are not as feature complete.
Managed Hosting != Shared Hosting.
I'll PM you a PHPStorm Professional key I got from one of the developers. :)
Wow, thanks!
Please make good use out of it... I only had two from them (one for me, one for you).
Nice move :) btw, what's the best Lamborghini?
Hmm? I'm confused. I don't know a single thing about cars.
PHPStorm is free for open source.
He asked what the best ide was and someone gave it to him for free. Now he's asking what the best Lamborghini is... Jokes to make your dad proud.
good idea
Technically yes, but I seriously doubt someone new to PHP is going to be maintaining a project that meets Jetbrain's requirements for getting an opensource license. https://www.jetbrains.com/idea/buy/choose_edition.jsp?license=OPEN_SOURCE
Phil, in the README you mention wanting to focus on shared hosting, but immediately list Linode as a company you're wanting information on. I use Linode in my daily work, but it's most definitely not a shared web host... it is a VPS provider. I could retrieve numbers, though, if you feel it's needed. Was Linode added by mistake, or are you looking for something more along the lines of benchmarks against the various linode sizes? Let me know.
I'm not good at jokes when tired. I do hope that he makes good use out of that key though.
Komodo Edit 
If you're a student, you can get a free student license: https://www.jetbrains.com/student/
This is written in PHP, obviously. Just sitting on my dedi server.
off topic. Sanitize and escape that data!
Oh sorry, was interested if it used a framework or was vanilla php. Also the database would of interest, if the point data is stored/cached or if they were all lookups.
+2 for PhpStorm. It's the first IDE I was willing to put down my own money for. By comparison, the only other IDE I had a legit license for was Zend Studio, about two years ago, but I made my boss buy that for me. It's nice that it's reasonably priced. JetBrains makes great products all around. 
Misuse being like 1k+ per second for no good reason. Just behave with it. There is no rate limit. How am I meant to know when it will be out of BETA? I don't know how stuff will work out. There will be no pricing plans at all. This is completely free to use.
It's obvious to you and me, but there are plenty of people out there whose only criteria is cost and recognition, and GoGaddy or 1&amp;1 have easy better recognition (they have TV ads!) than Digital Ocean. It's like Eternal September, just... not at all different.
+100 for PHPStorm
Consider using a transaction while inserting multiple rows at the same time.
Then the ratelimit is 1K per second, and you should state that. What you consider to be "no good reason" will not be the same as someone elses "no good reason". This is the reason we have published terms and conditions and ratelimits. If the service is always free, how do you plan to scale if/when it gets popular? Where is the money for hosting and time spent on support, features and bug fixes going to come from?
No, it's not. I said "for no good reason" (or similar). If some random person with a tiny site sends 1k+ requests with no good reason they can go away. And this isn't run by a company or any type of group... so my "no good reason" is merely based upon opinion. I have more than just this site, so the income is fine. I have absolutely no rate limiting, but if you're stupid with it you can piss off as far as I care.
wp engine was still using 5.3 as of September of this year. I'm seeing 5.3.2-1 on the sites that we currently have hosted there.
you can just turn the apache service off and never use it, it doesn't take that much hard disk space, i run my installs on nginx and php-fpm in centOS and i just never turn on apache after the install so it doesn't have conflicts with nginx
If you or any of the other eZ devs happen to be at PHPBenelux next month, I'd love to meet and discuss building CMS'es over a beer or two. :-)
Isn't that like trying to use a shoe instead of a hammer to bang in a nail? There are a slew of good PHP-specific IDEs.
It takes a special kind of person to think that $mock = Mock::mock(); Is a good bit of code. Also the &lt;code&gt; sections on that page are incredibly annoying, gibbering all over the place like that and obscuring the top line when you mouseover. (I am really not a fan of fluent stuff so won't comment on the rest)
+INF
`vim`
I would guess it's mostly [template parsing](https://news.ycombinator.com/item?id=8817517). It might be hard to queue the work since people expect to see their edits directly when they are saved.
Good idea, Phil. I'm surprised at how many hosting companies don't say which PHP version they use on their site. They'll just go "we have PHP and you can install WordPress or Joomla with one click of your mouse".
&gt; [The League of Extraordinary Packages](http://thephpleague.com/) Just sayin. 
[I made a survey about the situation in Finland back in Feb 2014](http://www.labs.fi/discussion/index.php?topic=577.msg2007#msg2007). The result was that most of them would support &gt;= 5.4 by summer 2014.
Should say every framework. He's just chest thumping his radicore love.
/r/titlegore
This is what happens when you choose your opinion and then find points to back it up, rather than the reverse.
For Ubuntu 12.04, 5.3.10 is the standard version you get without jumping through some hoops. Usually using some third-party repo to get the upgraded PHP version. This could have something to do with it.
1. No one cares about wordpress 2. This is just the usual shitty blog spam. Nothing to see here. Can tisindia.com please be banned entirely? They produce no content themselves as far as I can see, it's all stolen and then spammed.
That's probably why rapidcore is the most used framework ever. [http://phptrends.com/?q=rapidcore](http://phptrends.com/?q=rapidcore)
Hostgator lets you select the version of PHP you want to use.
gotta admit you got me to click 
I've used several.. Sublime Text (2 and 3), NetBeans, Eclipse, Zend's Eclipse mod, PHPStorm and IntelliJ (since I also work in python sometimes). Personally, I prefer PHPStorm (Sublime is a close second but is no where near as fully featured). PHPStorm just has soo many add-ins that make it worthwhile.. it's only downside is how much memory it takes to run.. make sure you have a beefy system.
The funny thing is that someone has broken their website. 503. Gave me a chuckle.
That's surprising given that 5.4+ would seem to drastically help their business and is perfectly supported.
Are the line numbers which appear on the reddit post here accurate to your IDEs numbering? i.e. does line 58 "&lt;div class="inline-video-wrapper"&gt;" actually start on line 76 in your IDE? If so it could be a case of you not echoing the HTML code. Change the else into multiple echos and it should work. It could be that PHP is reading the starting divs "&lt;" as PHP. If this is not the case I could do with seeing the whole "/home/arokui/wanderlust.ly/wp-content/themes/pivot/page_builder_blocks/video_embed_block.php" file.
I work for a large US company and am a Lead Developer on a multi-faceted project. My actual education and original background is Networking/Telecommunications, but coding has been a hobby since High School. I've written in ASP, JavaScript, Java, Perl, Python and PHP. My current project is mostly PHP with some Python mixed in.. With that said, I do love what I do, even though it can be stressful at times. We work with Phalcon, and the application I'm maintaining has Silex. My project is not at all social or allowing users to maintain content... but to enable automation of tedious tasks within the company. So.. my projects are rather complex as we have to talk to a lot of third party, custom systems and no real framework I've tested has any advantage when it comes to that. Many people have made good suggestions... you need to make yourself outstanding, and the way to do that is to play around on your own. Also, OO is key.. PHP allows, very easily, for one to not follow OO principles... but it also allows you to do so just as easily. Document your code!!
What changes did you make to this file? Also, instead of using &lt;?php echo $variable; ?&gt; you can just do &lt;?=$variable?&gt; That will do the same exact thing. I'm not that familiar with Wordpress, is the $link variable global? &amp;nbsp; Also: $block_options = array( 'name' =&gt; 'Video Embed', 'size' =&gt; 'span6', 'block_icon' =&gt; '&lt;i class="fa fa-fw fa-file-video-o"&gt;&lt;/i&gt;', 'block_description' =&gt; 'Add a Video Embed or self hosted Video to the page.', 'block_category' =&gt; 'misc', ); Added a comma after block_category.
You haven't closed that last PHP tag 
I agree, and it may be a different version on their newer accounts. We have a dedicated server with them, and there's no option to change the php version from the dashboard that I have access to.
I personally did not do the benchmarks... my coworker did and all I know is it is indeed very fast. It's because it's compiled in C. They are currently working on a middle layer (Zephyr) that will be a hybrid between PHP and C (i.e. type enforcement on variables). They are a small team so support is not as easy to come by on harder issues. It's best to test it on your own... and it also does require your own server that you can install the php extension into. Also, Oracle support in their Model/ORM was broken.. I had to override a few of their classes to fix it. They are working on fixing it in 2.0, I think.
"All frameworks *by other people* suck." -- Every Developer Ever
From https://getcomposer.org/doc/00-intro.md: &gt; Composer is a tool for dependency management in PHP. It allows you to declare the dependent libraries your project needs and it will install them in your project for you. The article describes autoloading perfectly, but I wouldn't say autoloading is Composer's primary goal.
This is exactly why you should NEVER use Wordpress' built-in editor. Always use a reliable IDE like [PHPStorm](https://www.jetbrains.com/phpstorm/), [Notepad++](http://notepad-plus-plus.org/), or even [NetBeans](https://netbeans.org/) if you plan on changing anything on your website. What you need to do is download the file you changed, make any edits you need to in the IDE of your choice, and then re-upload your changes. Notepad++ has a nice built-in FTP plugin that will allow you to make on-the-fly changes to your server files without having to download the whole project. In any case, the code you posted is not responsible for the error you're seeing. As /u/onlythingicanthinkov mentioned, it would help if we could match up the line number error you're seeing with the code you actually have. Please post /home/arokui/wanderlust.ly/wp-content/themes/pivot/page_builder_blocks/video_embed_block.php in its entirety.
True - super provocative title - not agreeing with all he says, just found his arguments interesting, and at least he has a framework to back it up. Also, there is a point to be made about KICK vs KISS - and he's making it, so.
&lt;?=$variable?&gt; This is not recommend as it's a PHP ini setting for shorttags which is usually turned off and it's also not supported by all PHP versions. I recently spent a day tracking down fatal error which was caused by this. It's a nice syntax sugar but should be avoided as it's not fully supported. EDIT: Also to explain the second piece of advice in the comment above, the reason you should add the comma to the last line is because it does not cause an error, so it can save you headache later when you come to add new items to this array, if you add a new line and forget to add the comma to the previous line then it causes an error. So to save time and reduce future stress just try make it a habit to add that extra comma to the last line of an array
Well, I just found his points interesting and with his friendly and inclusive style it won't take long.
You're right, you aren't supposed to. It's due to the way PHP includes work and the fact that whitespace after a closing tag ?&gt; can cause fatal errors. So because of this the recommendation is to just skip the last closing tag in the file.
&gt; Undeservedly , the post is downvoted... Just FYI, posts saying nothing more than "thanks", "lol" etc are usually downvoted since they are kind of pointless.
Specifically: &gt; Prior to PHP 5.4.0, this short syntax only works with the short_open_tag configuration setting enabled.
The same is true of HawkHost. They support all the way up through PHP 5.6.
So why write it with PHP 5.4 features in the first place?
I meant author's post, not my comment ;)
&gt; This is not recommend as it's a PHP ini setting for shorttags which is usually turned off and it's also not supported by all PHP versions. Since PHP 5.4 `&lt;?=` is always available, even with `shorttags` off. PHP 5.3 has reached end-of-life now, so I see no reason not to use `&lt;?=`.
This morning, Debian Wheezy got updated from 5.4.35(-0+deb7u2) to 5.4.36(-0+deb7u1). I'm not sure where the 5.4.4 came from.
I think it's about using what you feel you are comfortable with. I really like VS.
No one has mentioned it, but PHPED is quite good. However, your best options are Komodo Edit and PHPStorm. I've quite literally gone through just about of the options. If you are serious about it, or make any money off of PHP, just get PHPStorm.
What would you say it is that makes it a beter chooise?
A lot of frameworks such as Symfony contain a lot of general use functions
If you read the article, that is only part of the problem. Ubuntu 14 is now the stable one, which has 5.4 by default 
It isn't, but I would still say that it's probably the best way to autoload your classes, and a feature that people often forget. Some people may ignore Composer if they feel they do not need to use any libraries, but it still has a lot to offer
The great thing about composer is that you don't need a catch-all helper library to cover every requirement. I like to use small libraries that do one thing really well. Here are some of my go to 'helpers'. * [Stringy](https://github.com/danielstjules/Stringy) * [Doctrine Inflector](https://github.com/doctrine/inflector) * [Money](https://github.com/mathiasverraes/money) * (shameless plug) [Crutches](https://github.com/glynnforrest/crutches) Overall, I'd suggest looking at something like [awesome-php](https://github.com/ziadoz/awesome-php) and picking libraries that do what you need.
But what about outside the Frameworks, I'm in the progress of learning one of the micro-frameworks, but I would like something I can use independent of anything else. 
Can't think of any, I believe none are well received as they discourage learning the logic and it's usually easier to Google your problem then copypasta from Stackoverflow than remember a bunch of functions
There are 'awesome' libraries for pretty much everything. [awesome](https://github.com/sindresorhus/awesome) 
If you ever have the opportunity, check out Beau Simensen's talks on Composer. He does a great job explaining things. I can't find the video online, but here are the slides: https://beau.io/talks/2014/11/11/managing-dependencies-with-composer-phpworld-2014/ 
But Digital Ocean is neither, isn't it?
But that *should* be fixed now since 14.04 LTS has been out for months.
Why omit PHP 5.3.29? I know it's not supported any more but are there actually known vulnerabilities?
They actually support 5.3 through 5.6 currently on their shared hosting. [Here's a screenshot.](http://i.imgur.com/vG7n0gA.png) It's not clear what patch versions they support, though.
I don't see how you'd really get numbers for Linode, since it doesn't install anything by default (besides the OS). You could take the versions from whatever the latest is on each OS (e.g. Ubuntu 14.04), or alternatively look at the most popular [StackScripts](https://www.linode.com/stackscripts) (as far as I can tell, those install the latest version of PHP available to each OS).
Ok dude that's good to know. I personally will never use this as I've run into issues with certain PHP versions and sometimes you don't get to pick which version you have available so I tend to make sure my code works as best it can in most situations that could pop up for me.
I also think that he is not totally wrong, frameworks (not only in PHP) often comes with a bunch of feature you'll never use. But you should choose a framework that fits your use case, not a framework that "everyone use so it should be ok". The point here is that he criticizes others because he prefers minimalist code, which runs faster according to him. But speed is not the only criteria when choosing a tool. Maintenability, UX, security, stability, community, ect. are as important as speed. The problematic is not the same for everyone and that's the thing he missed for me. On ORMs for instance: he states that "PHP has a lot of string functions, that's simpler than using an ORM". And if I don't want to mess with escaping and security? What if I want to be able to use multiple storage backends? Why transforming a db row into an object would be such evil? Finally, no one is using its amazing framework (that's what I wanted to show with phptrends). He has 3 partners and the framework was created in 2006. For all these reasons, I think that he should not have claimed that everyone does shit except him. Note: sorry for my poor english
Excellent. Then I will gather data about few services from my country in next days.
I'm a huge fan of PhpStorm (and IntelliJ IDEA) too, but like you said in another post, use whatever you are comfortable with. IDEs are opinionated and everyone's opinion is different. As for the differences between the two, [this page](http://development-software.findthebest-sw.com/compare/9-23/Microsoft-Visual-Studio-vs-JetBrains-PhpStorm), while spammy looking, did provide a good comparison. Keep in mind that PhpStorm supports has a large community of third-party plugin developers, so if PhpStorm doesn't provide something by default, you might be able to find a plugin for it.
The fact you are asking means you know the answer! It's very untypical to use such different systems, particularly as there isn't any need to do that. Different file systems, different file layout conventions, different memory usage patterns, let alone different builds of the software are a good way to have bugs. My first thing would be to ask why you are using Windows to develop for a Linux stack? Do you make heavy use of Windows only features that make this important to you? Do your developers run Windows on their personal computers? If you are using Windows specific features to improve your productivity, then use Vagrant with a very similar set up configured - if it's just LEMP on Ubuntu, then one of the off the shelf images will likely be fairly appropriate without major/any tweaking. 
This is what virtual machines are for.
Originally the post is about "Cheap" Shared Hosting, when I mentioned Digital Ocean, the response was that people need Managed Hosting. And As I said Managed Hosting and Shared Hosting are not the same thing. Digital Ocean, is neither. It is a low cost VPS host.
I can't say I've seen anyone willingly choose IIS for development when production is linux, no. [Vagrant](https://www.vagrantup.com/) makes it very easy to spin up a linux virtual machine that can mimic the production environment. You can keep using the same windows editors and browsers and share the code with the virtual machine using NFS (supported out the box with vagrant).
the A in XAMPP is Apache. He doesn't want Apache.
Exactly my thinking!
I had read your link, and I think I agree (and stated essentially the same point) in my comment - it is an interesting way to push the commonly accepted boundaries of the language. However, I believe that suggesting to use something like this in a production environment is a bit irresponsible - PHP was not built to be a long-running process, and tradeoffs that rely on this have been made. This makes failure modes interesting to explore! It just also makes it an inappropriate approach to production software.
Sorry, still not understanding your point. You asked why people are not using DO, wycks gave you an answer (they are not managed hosting).
We've been working on a new project here, and have been given some free reign to try out new software. I had some prior knowledge of Vagrant, and have been working with it for my research on the project. I love it, and if I could, I'd change all of our development environments over to that sort of structure. After all, what in the world are we doing developing on IIS locally? As I mentioned in my reply to /u/physics4life I don't have much experience in the way of DevOps, so while I have convinced my teammates of how great Vagrant is, getting the brass to give it more than a glance has been difficult. 
Thanks for the advice. I'm fiddling around with PHPStorm now. I like it.
I can't overstate the benefits of developing on a VM using vagrant. Some key points that should help convince management: - The vm more closely matches the production environment so you reduce the amount of bugs related to system differences which are usually the most annoying and time-consuming to track down - You can put your vm provisioning scripts in version control so the machine and all its systems are transparent and self-documenting, and can be easily rolled back to a previous version if something breaks - With automatic provisioning the time it takes to deploy a new machine or redeploy a broken one goes from hours to minutes. The time it takes for us to get a new developer up and running used to take 2 days, now it takes a few hours. If a vm gets in a bad state we can vagrant destroy and vagrant up and have a brand new, working vm in about 5 minutes. It used to take several hours. - Developer have a lot more options to what os and tools they use since it's completely independent of the development environment, which should make them happier and more productive Any manager that reads these points and doesn't immediately see $$$ is blind.
Keep in mind that $mock is just a variable name for the sake of example. As for Mock::mock() I see your point, we could create an alias e.g. Mock::create(). Thanks for feedback on the blog page, we will fix it. And Happy New Year! :) 
http://en.wikipedia.org/wiki/Buzzword_bingo
I asked why people that are using Shared Hosting not using DO. Shared Hosting is not Managed Hosting. If someone needs Managed Hosting, then they should be using Managed Hosting which neither Shared Hosting nor DO is.
Time to dazzle everyone with a powerpoint, yo!
Not bad, Phansible and Puphpet look very similar, the former actually looks more professional - I can't get past the team working on puphpet.
You can try [Ouzo Goodies](https://github.com/letsdrink/ouzo-goodies). 
Have you seen [CssCrush](http://the-echoplex.net/csscrush/)? I'm not sure if it's true SASS, but it works well, you can provide an array of vars which will replace/substitute the variables listed in the file and it supports mixins &amp;&amp; imports. 
It can be done. But you will typically run into some smaller issue like directory and file name recognition differences between the OSes etc. So most likely you would end up developing on Windows, then needing a test environment in linux to make sure it runs correctly there as well. TLDR; Use VMs for dev and testing that resemble your production environment as close as possible.
+INF+1
You don't need to use the whole framework. Check out the symfony components. No better way to learn how frameworks work, than using their components.
Ah yes, great point. Having a base box would be great for working on different projects, each using a similar VM but with different application-specific stuff. If something is left to a human, there's a chance it'll break. Any time I want to change the configuration of a box I put it in the provisioning files. It takes discipline and I hated it at first, but now I can be sure that all my VMs and servers are reproducible. I don't even use SSH any more.
Sounds like you have more devops experience than you think ;)
Composer autoloading is excellent and easy to set up even if you have a mixture of psr-4, psr-0 and mixed up crap everywhere. It's replaced awkward phpab build steps in our applications and made it so that our modules don't get commits like 'forgot to rebuild autoloader'
This thread *is* making me feel pretty smart.
This is exactly what I want to do. The problems we have are surprisingly few, but they are avoidable. On top of that, it gives devs a poor understanding of how this stuff works in production, since we spend all of our time in Windows and IIS.
Does WordPress core count?
Yep, by their very nature, helper classes will violate at least one of the [SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) principles, usually several of them.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**SOLID (object-oriented design)**](https://en.wikipedia.org/wiki/SOLID%20%28object-oriented%20design%29): [](#sfw) --- &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), __SOLID__ (__Single responsibility, Open-closed, Liskov substitution, Interface [segregation](https://en.wikipedia.org/wiki/Segregation) and Dependency inversion__) is a [mnemonic](https://en.wikipedia.org/wiki/Mnemonic) [acronym](https://en.wikipedia.org/wiki/Acronym) introduced by Michael Feathers for the "first five principles" named by [Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin) in the early 2000s that stands for five basic principles of [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) and [design](https://en.wikipedia.org/wiki/Object-oriented_design). The principles, when applied together, intend to make it more likely that a [programmer](https://en.wikipedia.org/wiki/Computer_programmer) will create a system that is easy to [maintain](https://en.wikipedia.org/wiki/Software_maintenance) and extend over time. The principles of SOLID are guidelines that can be applied while working on software to remove [code smells](https://en.wikipedia.org/wiki/Code_smell) by causing the programmer to [refactor](https://en.wikipedia.org/wiki/Code_refactoring) the software's [source code](https://en.wikipedia.org/wiki/Source_code) until it is both legible and extensible. It is part of an overall strategy of [agile](https://en.wikipedia.org/wiki/Agile_software_development) and [adaptive programming](https://en.wikipedia.org/wiki/Adaptive_Software_Development). &gt; --- ^Interesting: [^Robert ^Cecil ^Martin](https://en.wikipedia.org/wiki/Robert_Cecil_Martin) ^| [^No ^Silver ^Bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet) ^| [^GRASP ^\(object-oriented ^design)](https://en.wikipedia.org/wiki/GRASP_\(object-oriented_design\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnal8b4) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnal8b4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
That's just INF.
Not normal. Use vagrant or something similar for local development. 
This sounds like you wrote an Active Record implementation to support MySQL. This would be akin to [Eloquent](http://laravel.com/docs/4.2/eloquent) or [Propel](http://propelorm.org/). I'd be interested in looking at your code only after you've written why it should be considered over those two implementations.
My strategy is to create your own helper classes, so if you use any packages you aren't explicitly depending on their class API. Later, if you need change the package, remove the dependency, etc, it's painless as long as they're covered by tests.
I end the post saying pick node for production but don't stop exploring async in PHP. Very responsible of me.. :P
That is not normal at all, that's totally fucked up. Also it's stupid because you're inevitably going to find situations where something works on dev and then breaks on live. **Your dev environment should exactly mirror your live environment.** 
Eh... It's a horribly fallacious point, though. Just because something is complex, doesn't make it bad to use for scenarios where something simpler would suffice. Do you need a car to go to the grocery store across the street and pick up a 6-pack? Nope. You could just walk. But, if it's already there for you to use, makes your trip more convenient, and comes with no significant penalties, then using it isn't some travesty, as the author would have you believe. The fact that a framework creates a hundred objects to serve up an index page is no more a travesty than hopping in your car and starting up hundreds of moving parts, disparate systems, electronics, gauges, etc. just to cross the street.
*THANK YOU* 
Allowing a string "7 years" to convert to the integer `7` is madness. It's not even the worst example of PHP's overly permissive conversion rules. If this feature is primarily an error detection and prevention feature then it should do the least surprising thing. 
The refactoring tools. Want to change the name of a class? PHPStorm will go through all the project files and present a list of changes that you can accept toggle individually. Same with Namespaces (including moving files based on PSR-0/4), methods, variables, includes, etc. It saves me HUGE amounts of time, every day.
&gt; Allowing a string "7 years" to convert to the integer 7 is madness. It's not even the worst example of PHP's overly permissive conversion rules. I should probably point out that this produces a notice: PHP Notice: A non well formed numeric value encountered in Command line code on line 1 But yeah, I agree, it's not the nicest of behaviours. However, it is our existing behaviour for integer and float parameters to internal/extension functions. This RFC avoids inconsistency (a problem with previous RFCs) by sharing their behaviour and implementation. Perhaps a separate RFC could fix this behaviour. I'd vote for it, certainly.
&gt; I should probably point out that this produces a notice: That's not terrible. I convert all notices, warnings, and exceptions into errors anyway. It wouldn't be changing the behavior to make the notice message a lot better -- I would consider adding that to the RFC. But I wonder if this is the best way to go as really the behavior of sending values to extension functions isn't really well documented. I, for one, don't know how internal functions handle being passed strings for arrays, arrays for strings, etc. Do you get a notice in most of these situations or is the value silently converted? It might be worth being more complete in RFC on that as well. 
It's a great idea to get outside of your comfort zone, especially in this industry. You're square-pegging a round hole - if you try and take those practices anywhere else, you'll get weird looks at the very least.
I deeply and sincerely hope that this gets through. The last RFC fell flat on its face for the reasons Andrea mentioned, but I believe that this loose hinting, as casual and PHP-ish as it is, will significantly reduce bugs and unexpected behavior in our programs. I work with a very large codebase (hundreds of classes, tens of thousands of PHP files), and a significant percentage of the bugs we encounter are due to PHP's loose typing combined with the organic growth of our system. Unit tests can solve a lot of the same problems, but with (often) significantly more effort involved. Our whole application doesn't run successfully in HHVM so we use it in static analysis mode only to try to catch a lot of this type of thing, which is also very useful, but I've been hoping for Hack-like optional scalar hints for a long time. I really thing this is one of the best things the PHP language can do to allow software authors to build more robust programs.
I like the idea of loose scalar typehinting, as it's more PHP-like. If I had voting powers, I would vote **against** this RFC, though, until PHP's implicit conversion rules have been fixed.
Wow,I didn't know PHP behaved like that,which is just bad...
Don't let great be the enemy of good. I'm all for fixing PHP's implicit conversions, but if I had to choose one or the other I'd rather have this RFC.
Try this: echo "7 years" + 5 The result is 12. 
No good can come from this RFC without sensible conversion rules. Got a method expecting a person's name? Typehint string. Get passed an array. End up sending an email to your customer that starts out "Hello, Array!" No, thanks.
Not affiliated with them in any way. They support the development of the best security extension for PHP, Suhosin. I think the developer of the extension, Stefan Esser, is one of the founders of Sektion Eins(don't quote me on that though).
EDIT: See below.
I know what you're saying and his attitude doesn't help. I'm building a project on top of phalcon and one of the things I really like apart from its raw speed is that I can reasonably keep its structure in my head. With symfony it's really hard and zf is even harder. 
Not working on a CMS, mostly working on [a music platform](https://github.com/foocorp/gnu-fm) and [a social network](https://github.com/foocorp/gnu-social) in my spare hacking time.
I'd almost prefer an entirely new warning level (let's call it `E_CONVERSION_NOTICE`) just so it's easier to convert into a more common `UnexpectedValueException`, although if this were to take that route, it's probably better to just make the typecast warning type configurable by an ini setting (none, error, exception). All of the string&lt;--&gt;int conversion is a little weird already, and as this is focusing on inputs from $_POST, making that conversion really predictable is critical to adoption. If, for example, you get `"0x80"` in an `int` field, do you expect this to be truncated to 0 per string-&gt;int conversion rules, or evaluated to `int 128`? Currently you'll get the former (with a possible `E_NOTICE`, it seems), but there's enough fuzziness around this that it needs to be made really clear before being adopted. I've personally written my own input massaging library to handle this kind of stuff (as I'm sure many others have) and it would be great to have more native support in the core language, but it really does need to handle all of these weird edge cases to see real adoption. Other magic methods for casting (`__toInt()`, etc.) could probably help too, especially with the BC break.
They're doing a bad job at this, this is just one example related to a severe bug in one of the latest 5.6 release https://twitter.com/i0n1c/status/545986545539633152
For Visual Studio http://www.vsphp.com/ is a fantastic extension. I used this when I was working at a Windows shop but also had to do some PHP stuff on the side, so I could do everything in the same IDE. However as others have said, unless you are already using Visual Studio for other things, it's a non-typical choice for PHP.
Sorry, I think I misrepresented myself. I was implying the ability to pull benchmarks, but that doesn't really seem to mesh with the idea of the project. That's why I'm asking for clarification. I assume it's simply a mistake?
I'm likely -1 on this proposal. I've held a different position in the past, but by now I'm thoroughly convinced that if we introduce scalar typehints, they should be strict. No wiggling, no casting. Apart from being consistent with the existing behavior of typehints and being what the majority of the vocal community wants, it is also possible to reason about strict typehints statically. This means that an IDE or other tool will be able to perform meaningful analysis based on typehinted functions. E.g. if you pass the result of a `string` function to an `int` parameter, your code is definitely wrong and you can be told so. Loose (casting) typehints do not offer this possibility, because a string can be or can not be a valid input to an int parameter depending on the exact value. For the same reason loose typehints are also more fragile. Code that worked in casual testing during development will fail in production when unexpected, improperly validated user input is encountered. With strict typehints on the other hand it is very likely that code working with one input will also work with all other possible inputs, because the type check is not value-dependent. The ability to statically check typehints is rather important to me. I think much of the usefulness of this feature would be lost without the ability to check correct usage with tooling.
If you're passing user data to unserialise() though, you've probably got much bigger problems than this vulnerability.
I still don't really understand why the RFCs aren't implementing it as you suggest. As long as we are keeping typehinting optional, I don't see why you would do anything but require a string to be a string and an int to be an int. I get that most user input is via HTTP so it's all strings but we already validate/filter that data, I don't see why casting before passing the data to a function is a problem. This sort of automated conversion sounds like a complete nightmare. 
I dare you to find an clasic object injection bug in SugarCRM, this was gave as an example of a vuln app to this unserialize memory corruption :) https://bugs.php.net/bug.php?id=68594
And how is that acceptable that depending solely on the input (and **not** the function signature), it will either: - raise a fatal error - raise a notice - or silently coerce the input? Do you *really* think this is well designed behavior?
Content management system systems.... = ATM machine...
I don't think Wordpress would score over a 30% on a Grade 11 Programming assignment. 
Im going to try out phpstorm, sounds like a really good IDE.
&gt; If, for example, you get "0x80" in an int field, do you expect this to be truncated to 0 per string-&gt;int conversion rules, or evaluated to int 128? Currently you'll get the former (with a possible E_NOTICE, it seems), but there's enough fuzziness around this that it needs to be made really clear before being adopted. Hex values are sometimes numbers and sometimes not, it's a frustrating inconsistency in PHP. Nikita has an RFC to get rid of them, I'd love to see that pass. **EDIT:** The RFC in question: https://wiki.php.net/rfc/remove_hex_support_in_numeric_strings
Come on, stop being pedantic. You know damn well that people using shared hosting do'nt want to set everything up themselves.
Thanks. Not sure what the problem is with Allen here. They just want to criticise everything.
Symfony was recently heavily decoupled, you can now pick and choose components from Symfony that suit your requirements. For instance, the VarDumper component which can be dropped in to replace var_dump etc. 
Thanks for the insight, /u/FB777
It's not just the whole HTTP/strings thing. I just didn't feel strict types fit well with the rest of the language. It'd be inconsistent with extension functions, and we already have enough inconsistency with those without introducing more. It isn't really fitting with PHP's weakly-typed tradition. Plus, there's the issue that strict type hints would be rather brittle in a weakly-typed language. PHP juggles between the scalar types, so `$a + $b` is sometimes an integer, sometimes a float, and if you pass the result of that to a function with a strict integer type hint, it would blow up when it produces a float result. **EDIT:** Perhaps a better example of PHP's weak typing causing problems is PDO and MySQL. If emulated prepares are on, all columns come out as string values. If emulated prepares are off, columns come out as different types. With type hints as proposed in the RFC, you could switch emulated prepares on or off and your code would still work. With strict hints, if you were forced to switch emulated prepares on, everything would break.
Buzz is that you?
Any reason why you didn't implement it in a map reduce system? User experience?
Not to be rude, but, how does this relate to PHP?
Depends on whether or not you have your PhD in PhP.
&gt; Besides, strict hints would be inconsistent with the rest of the language. I don't understand this rationale. Surely it's purely opt in? if you want the existing type coercing behaviour, don't hint? Or alternatively, introduce some "looser" hints, such as, i dunno a "numeric" hint which will accept anything PHP would currently consider numeric (1, 1.0, "1", etc) and leave int/float/bool for strict type checking. or introduce a new to prefix the hint for the purpose of enabling loose checking. As a developer if I go to the effort of stipulating that an argument should be an int, I mean an int. Not a thing that could be represented as an int. If I wanted that behaviour I wouldn't bother to specify the argument type in the first place... &gt; PHP has never been strict for scalar types, and I think they'd make a rather awkward fit. the "Because PHP has never done X, it should never do X" is a little self defeating I think. The question should be asked is PHP's current behaviour acceptable and expected? And will introducing new features against that behaviour further serve to confuse and befuddle people? If I write a function that expects an int and I don't get an error when someone passes "7 years" to that function then that to me that is a violation of the Principle of Least Astonishment. 
I used to have a lot of CMS tasks at work, until we got a few junior programmers and brought them up to speed with those CMSs. Now they get the CMS jobs and I get to deal primarily with custom-built systems and integrations, which is much more fun to me. For example, I'm currently working on a "recurring inspection" system for food inspection, where managers set up scheduled quality control/maintenance tasks to be done (e.g. "every Friday, measure the temperature in the freezer; every day, check the expiration dates on all products"), the employees use a web app to overview, perform and report those tasks. Our customers are companies that are legally mandated to perform such tasks and have documentation, but a lot of them don't know these regulations when they start their business, so we help them get started and make sure their tasks match the legal requirements. The cool thing, though not PHP-specific, is that as the sole dev in this project, I get to deal with everything - the scheduler logic, data aggregation, reporting, failed inspection alarms, client web app (html5 with websql and Typescript, can run offline for a month), etc. To be honest, I can't think of anything PHP does better than other languages in such systems, .net could do just as well here (if you have the budget...). What I don't like about PHP in these systems is the lack of strong typing, I don't like chasing down bugs that could have been avoided with proper type declarations. If I'm extending an existing system like Magento, I usually dislike existing code because it lacks type information (or worse, some parts of Magento have *misleading and incorrect* type annotations...). On the other hand, integrations with third-party stuff have their WTFs. I should write a few /r/programminghorror posts about those.
np
So for the sake of consistency, a function that takes an array argument should also cast any given variable to an array. Right?
thats my main use for phpstorm, as a refactoring tool. then i go back to sublime. phpstorm has just so many things i find annoying (very slow on large projects, non stop indexing, annoying 'inspections' that cant be turned off, stutters on autocomplete, etc etc..)
If you can't even motivate yourself, nobody else can.
There is a reason for it. It's good if you're getting screwed over by cache.
If you want to start programming php is not the best option. It's slow, complicated, illogical and in many parts broken beyond repair. I'd suggest trying something fun like python or javascript (node.js).
Why would any of us care about this?
You know what comments are for, right?
This post is off topic for /r/PHP. Please refer to the sidebar for more information.
It is, however, in line with the Principle of Least Common Sense, something often encountered in PHP. :)
They do use type hints of a kind. They don't just blindly accept any value.
Maybe tone down your post a bit. It's hard to take people seriously who sound angry and are calling people stupid and describing things as "dumb shit". &gt; **Typehinting is going to confuse people** I never said that. &gt; **This isn't how PHP works.** &gt; **PHP is not strictly typed, so it shouldn't have strict type hints** &gt; Why are people ignoring the obvious solution of just not using them. The typehints are for when it matters. If it doesn't matter, just don't use them. Perhaps you misunderstand this point. The problem with strict type hints is that they do not interact well with the rest of the language, which is highly dynamic. Operators, functions, incoming data, all of these do not consistently produce a single type. Using strict type hints forces you to add lots of (unsafe) casts everywhere, and actually makes code more brittle than non-strict hints. It doesn't mean strict type hints can't be done, of course they could be done. But they aren't a particularly good fit.
Why numeric and not integer or float? There's a place for a numeric hint perhaps, but I don't see why you shouldn't be able to ask for an int or float specifically.
All of that (and much, *much* more) can be achieved with strict types as well. Also, that "conversion rules" table is a *complete joke*. Anything can be passed as anything? Seriously?
It would become `int(5)`. However, as the RFC notes: &gt; Only non-NaN floats between `PHP_INT_MIN` and `PHP_INT_MAX` accepted. So stuff like `INF`, `-INF`, `NAN` and very large floats aren't accepted. The only thing that will be lost is the fractional part. This matches C's behaviour (well, actually, C blindly casts, so we're better than C here), for what it's worth.
&gt; An important reason for us at work to stay with PHP for now is the prospect of a stricter language without the hassle that is Hack. A lot of the hassle of Hack comes from its strict type hints. You can't do an addition or a division without casting the result. You can't use PDO without casting the result. &gt; Would an E_STRICT error reporting option work that could toggle strict type hinting on? That way default, and thus the experience for new users, is loose while making it an actual choice for experienced programmers. Kind of like 'use strict'; in JS. I'm not sure this would work too well. You've introduced a new inconsistency (strict mode vs non-strict mode) and that means extra mental overhead. Now you can't use code samples, because they're written for (non-)strict mode while you're using the other mode.
This isn't a "new" quirk, we already have exactly this behaviour for existing functions.
It would likely throw notices, at least, when method signatures are changed and not all of the existing calls are updated, which happens often. 
No, it shouldn't. Scalar types are juggled. Complex types aren't. Heck, I suppose you could say all types are juggled, but conversions that can't be done aren't done. There's no sensible conversion from other types to arrays, so that's not done implicitly.
&gt; unrelated parts of the language Internal functions aren't unrelated at all. Wouldn't new users be confused that the documentation uses the type hints for internal functions, yet they have completely different behaviour?
Feel free to ping me. I'm a Symfony dev, but I also have experience with Laravel, Magento and lots of other fun stuff. Not sure I take the concept of "learning buddy" correctly, but I'll be glad to help you and tell you about some best/worst practices, etc.
&gt; There should be a warning if a string has a character postfix that could not be converted and get's lost. There is. That produces a notice (when passed to functions, anyway). &gt; Conversion from anything to bool We already do that. &gt; And there is a lot of bullshit that should result in an error, always: 1. array to anything string: That's already an error. &gt; array to int and float conversion That's already an error. &gt; Scalar/array to object Also already an error. By the sounds of things, you really like our existing behaviour. :P (Note that this is just for parameters: The rules for some other things are a bit looser.)
I have a large CRM-style application running on Apache 2.4. I have a simple virtual host configuration and a few mod_rewrite rules. Performance (as it relates to the PHP portion of our stack) has not been an issue for us. For those of you have that worked with both, is it worth putting the time and energy into switching to nginx?
&gt; For example, you now have to force cast the results of addition or division operations So surely that's where the focus should be around solving idiosyncrasies rather than, quite deliberately, adding to the language in a way which makes no sense? If I was a new PHP developer and I came across code which said a function accepted an integer, but didn't explode if it was passed a bool, or a string, or a string starting with something that could be treated as an integer...could you understand why that would be *astonishing* to me? Again, it's an opt in feature. If it blows up in peoples' faces because they pass junk to a method declaring a scalar type hint, I'm fine with that and I'm sure most developers would be too. If people decide to attempt to circumvent type hinting by just casting willy-nilly with considering checking what they are passing around, potentially losing data and other such horrors, then on their heads be it... 
&gt; So surely that's where the focus should be around solving idiosyncrasies rather than, quite deliberately, adding to the language in a way which makes no sense? They're not idiosyncracies. The fact PHP is weakly typed makes it a much nicer language to use in some places. Forcing a language to act strictly-typed when it's fundamentally not isn't fun. &gt; If I was a new PHP developer and I came across code which said a function accepted an integer, but didn't explode if it was passed a bool, or a string, or a string starting with something that could be treated as an integer...could you understand why that would be astonishing to me? I understand why that might be somewhat surprising if you came from a strictly-typed language and that was your only experience, yes. 
But either way they have different behaviour. Adding loose type hinting isn't quite the same as having no hints at all (depending on what the functions do with all the parameters passed to it). And to me it's more important that *all* type hints are the same (either strict or loose) than whether some functions use strict type hints or none at all. The point about the documentation is irrelevant. We should worry about what is best for the language first, then figure out how to make the docs clear later. We can easily decide on some alternate notation for what are strict type hints and what are not.
&gt; Honestly? It's hard to take these arguments seriously as well. Frankly I think this is some dumb shit. If you don't take me and others seriously, I don't see why I or even we should take you seriously. Mutual respect is important and is really just basic courtesy. &gt; There are complexities to the language, but surely within a method they won't matter. I don't see why these things cease to matter within methods. &gt; Again, I don't think I can express enough - these are completely optional. Given that they don't need to be used at all, it makes no sense to have half a feature. This doesn't solve anything. Optional features are no less inconsistent and fit no less badly with the rest of the language.
&gt; Is it for this? Or is the point that the method was called with the correct arguments. In my view it is the latter. That the purpose of typehinting is to ensure that the caller uses the method correctly. That it's not a matter of forcing the type, but a matter of enforcing the type. Non-strict hints do also enforce correct arguments, but they provide more wiggle room that strict hints. Convertible values of the right format are accepted. It's not as if literally anything is OK.
&gt; Not using type hints isn't an option when it wasn't you who made that decision, but the author of the library you're using. Don't have a problem with this. If I author a library that requires you to pass me an int, and you pass me 7/5, then I don't care if you get an exception. Check your on input before you throw it at my library. And if you decide to just cast it to an int blindly, also not my fault or problem. My library expects an int for a reason. It must have one. I don't want to be writing boring input validation when I should be able to rely on a language which apparently gives me the ability to require a type. Even if it *technically* doesn't give me this ability, the semantics of integer and the semantics of providing a type in an arguments list are well established. There is an implicit expectation of a behaviour which is setup here. Requiring a developer to read the manual and understand a complex set of rules and circumstances under which "7 days" will be treated as an integer doesn't seem terribly reasonable. 
&gt; My library expects an int for a reason. It must have one. I don't want to be writing boring input validation when I should be able to rely on a language which apparently gives me the ability to require a type. Well, you do get an int. You don't have to do input validation yourself.
&gt; Because you are using a language idiom which is shared by many other languages which set up that expectation. The expectation is thoroughly reasonable. What's not reasonable is to provide similar syntax, behave utterly differently, then direct people to a table of conversions. It doesn't behave *utterly* differently, other languages convert types too, albeit to a more limited extent.
I think OP is referring primarily to normal casts, not to zpp casts.
Ah, fair enough. Though some of what they're on about is already done for implicit casts.
I thought of the numeric typehint in regards to issues brought up in this topic (like division on ints can return either an int or a float). Also also if in the future we will be able to handle bignum's as other numeric values (all int operators) in the language that code will work nicely. Alternatively maybe add numeric alongside the int/float typehints. 
I just wondered why you wouldn't also allow int and float, they have their place. Bigints wouldn't really affect this, they'd be covered by int. They are just integers, after all.
Works a treat, thanks a lot!
Here is my $0.02; hopefully you find it helpful: * Cramming things into less lines may support the "write less" mantra, as advertised, but it also makes code less readable. For example, putting an entire SQL query, its bind parameters, and execution all into a control statement makes for some very awkward and hard to follow code: - foreach($db-&gt;dbQuery("SELECT * FROM table WHERE col_a &gt; ? AND col_b LIKE ?", [ 16, '%abc%' ]) as $row) { var_dump($row); } Instead of going overboard with "write less", try to "write more clearly": $sql = &lt;&lt;&lt;SQL SELECT * FROM table WHERE col_a &gt; :aval AND col_b LIKE :bval SQL; $st = $db-&gt;dbQuery($sql, [ ':aval' =&gt; 16, ':bval' =&gt; '%abc%' ]); foreach ($st as $row) { var_dump($row); } Structuring your code vertically is easier to scan, and makes for more relevant diffs. Using named parameters over positional ones makes it easier to pair values with their context, and makes the code less prone to error. Keeping verbose expressions out of your control statements also makes for easier to follow code. * I would also like to see `sanitize()` completely removed, as it's nothing but SQL injection waiting to happen. If you need to embed untrusted input into a SQL statement, you should use parameter binding where possible, and a white-list where not possible (e.g. table/column names). * I'm not a fan of single-character or overly abbreviated method names (e.g. `q()`), as I believe that method names should be as short as possible *while still describing the task that they perform*. The `iterate()` method name seems arguably less descriptive and obvious to me than something like `forEachRow()`. I also find `col()` to be misnamed; it doesn't return a column, it returns a single value from that column. As such, I think `single()` was a much better name. * Variadics are awesome, but using them for bind parameters precludes the possibility of named parameters, which I feel is a deal-breaker. It also imposes an otherwise unnecessary PHP 5.6 dependency on your library, which could then be lowered to 5.5 or 5.4 instead.
&gt; To be fair, that particular case is handled by the RFC That's even worse, as it introduces a *different* set of implicit conversion rules that will conflict with PHP's existing rules. Talk about confusing...
&gt; This actually matches C's behaviour, for what it's worth. It's not worth much! This should really trigger a notice even with the native functions. 
I want to add to what /u/dracony has said because he's 100% right in my opinion. I have tested multiple set ups (apache/php, apache/hhvm, nginx/php, nginx/hhvm) and the real difference I saw was hhvm. Our app pulls a lot of data from PostgreSQL (at the very least, a few hundred megs each report) and processing that data was not very performant in PHP. Once we started using HHVM we saw a drop off in memory consumption (not always but less than PHP overall, HHVM is funny with memory every so often) but we saw the processing time drop to about half the time across both apache and nginx.
Sadly, it's very slow. But thanks anyway, I used it and was a good start point for me. I'm using QueryPath now and it's faster. :)
Thanks! Are you considering putting it out on GitHub at any point? I would be quite interested in checking it out, when it's a done deal.
&gt; I still feel that this just moves the problem somewhere else. You have a value, it might be the string "5" but to make that an integer that your function will accept the most common solution is a cast. And casts accept everything. So you've effectively made scalar type hints useless. I think your premise here is right, but the conclusion you draw from it isn't. Yes, if you receive input as a string (e.g. from HTTP) you will have to convert it to the appropriate type. You do this by validating the wellformedness of the input, followed by a cast. Alternatively you may make a conscious choice to not perform validation and cast directly, because you believe the input to be always correct (e.g. strings coming from a database) or because you believe that a misinterpretation of the input is of no consequence in your scenario (GIGO). Strict types force you to make a choice either way. Both approaches can be appropriate depending on context. Just follow the normal practices for input validation.
Unfortunately I won't be attending, but did ping a few guys on Twitter about this :)
&gt; Does being consistent with internal functions somehow invalidate the inconsistency that i mentionted or what? Well, no, but inconsistency with existing type hints leads to consistency with internal functions. &gt; I don't know what you mean. Care to explain? Internal/extension functions (those built-in to PHP or defined by extensions) have non-strict, casting parameter types with almost identical behaviour to this RFC for scalar types, and strict parameter types for non-scalars.
I' m also just starting out, so hit me up when you need a buddy, it always help to ask each other stuff.
How does it work. I would like to pick up on Android tutorial, but I am new to this mentoring thing. 
&gt; &gt; There should be a warning if a string has a character postfix that could not be converted and get's lost. &gt; There is. That produces a notice (when passed to functions, anyway). It only produces a warning when passed to a build in function. As most of my functions are pure PHP, there is no warning. Or if I $int = (int)$string; cast something, no warning. &gt; &gt; Conversion from anything to bool &gt; We already do that. I did not deny that. But some conversions are just arkward. &gt; &gt; And there is a lot of bullshit that should result in an error, always: 1. array to anything string: &gt; That's already an error. Only in the core ... &gt; &gt; array to int and float conversion &gt; That's already an error. Only in the core ... &gt; &gt; Scalar/array to object &gt; Also already an error. Just learned array to object is valid (see [/u/i_lick_dicks'](http://www.reddit.com/user/i_lick_dicks) post) &gt; By the sounds of things, you really like our existing behaviour. :P &gt; (Note that this is just for parameters: The rules for some other things are a bit looser.) I really do like PHP and the ways some things are easy to do. But I look at the things from a PHP programmer's point of view that uses code written in PHP and does not write C extensions. So most of the "We already do that"s do not really apply to me ;-)
&gt; It only produces a warning when passed to a build in function. As most of my functions are pure PHP, there is no warning. Or if I $int = (int)$string; cast something, no warning. Explicit casts never fail, I think that's a feature not a bug. I suppose you want scalar type hints, then.
It is totally not! I like PHP, I use a current PHP 5.6 version and "new" features like namespaces, traits, closures, static::, ::class and many more. But there is room for improvement like cleaning up the namespace, make naming consistent and the above mentioned conversion issues, but in total PHP is a really great language. &gt; (Not to hate on Python - it just seems like the vast majority of PHP hate comes from Python shills.) People who use a language where whitespace has semantic ...
&gt; &gt; It only produces a warning when passed to a build in function. As most of my functions are pure PHP, there is no warning. Or if I $int = (int)$string; cast something, no warning. &gt; Explicit casts never fail, I think that's a feature not a bug. I suppose you want scalar type hints, then. Even implicit casts fail: $int = "7 years, 3 month" + 23; will also just get you 30, what is ridiculous and I can only construct very abstruse use cases where that is desirable. And optional static type hints would be nice to have, would spare us a lot of parameter validation trouble.
I think this is the first time I have heard of someone moving TO GoDaddy... 
Am I the only one who hates these hyperbole filled titles?
That's exactly the thing. nginx promises to be faster so every jumps on this "Apache is too sloooooow" bandwagon, when nobody for years ever saw it as the bottleneck. There are definitely load profiles that can benefit from it - but like HVVM, the average user has far more to gain by better tuning SQL indexes and caching queries. 
~~Yes~~ No you're not, nginx has been heavily adopted for years now.
&gt; Even implicit casts fail That's not "failure". It won't produce an error. It's not what I'm talking about.
I tried to get LEMP set up a few times and failed miserably.
I'm pretty sure it's very clear to everyone that is not the point.
This is all valid and valuable feedback. Thank you! &gt; Variadics are awesome, but using them for bind parameters precludes the possibility of named parameters, which I feel is a deal-breaker. That's sort of why I offer both the variadic method as an alias, but also a normal method. dbQuery() works with named parameters. &gt; It also imposes an otherwise unnecessary PHP 5.6 dependency on your library, which could then be lowered to 5.5 or 5.4 instead. http://php.net/supported-versions.php 5.5, perhaps. But 5.4 is in "security-only" mode now. I'll consider renaming some of the methods while keeping the aliases in case someone already uses this library. https://github.com/resonantcore/lib/issues/5 Once again, thank you :)
This sounds like the epitome of open-mindedness.
&gt; I realize you can configure Apache with PHP workers, but it's not how most people run Apache Just playing devils advocate here, but if you're using Apache and haven't configured it optimally, why not just spend time configuring it properly? Instead of throwing the whole lot in the bin and moving to nginx (which you are equally likely not to configure optimally either) 
It really depends, you wont know until you figure out where your bottleneck is. My hunch is its probably not worth just switching web servers, since most the CRM perf will be dictated by the PHP and database code rather than simply the http But you know, theres no reason why you cant run apache in tandem with another web server for different purposes. One of the biggest performance gains on my site many years ago was to ditch apache (1.3 at the time) for serving static resources, images etc, and serve them from lighttpd instead. I then set up a longer HTTP keep-alive on lighttpd so it could pipeline many images very quickly over a single client connection, and left Apache with a very short keep-alive timeout so mostly it just served a single php request and then closed the connection. The gain was immense, both in reduced load and perceived user responsiveness. One of the other biggest gains you can get is to ensure you're running an opcode cache. For me it was TurkMMCache and then later APC, but these days OpCache is officially adopted and built into PHP (just needs enabling/configuring). I still use lighttpd to great effect (infact now for both php and static assets), although not sure I'd recommend it as development has all but ceased other than security fixes.
I've tried a number of templating languages, and Twig is by far my fav. It's very well designed, extensible, and easy to get started with. It's also efficient (all templates are pre-compiled).
Second. Twig is awesome, clean, tiny and works well.
Sorry I'm late to the party... thanks for the excellent question, BessaBrick. Yeah, I'll echo everything everyone has said here about Twig. It's just ultra simple and so elegant.
Thanks dean_c! New to composer... that's awesome! I will definitely take that route. Much cleaner, and I like cleanliness!
If your production was nginx it could be worth switching to mirror the environment; but otherwise no, apache is just fine.
I basically have a collection of 10 apache servers that perform external API calls and database accesses on every hit. That is the majority of the work. There's nothing really heavy performed processing wise but there are some simple math operations. These servers get over 4 million hits per day. Would there be any benefit to switching to HHVM from Apache? The reason I ask is that when I update to the next version of Ubuntu I will have to change my hardware from 4 CPU cores, 512 MB of RAM to 1 CPU core, 1GB of RAM. The new hardware is much faster but with 1 CPU core I may not be able to handle as much load.
HHVM is a PHP Engine, developed by facebook. You would be using HHVM and Apache/Nginx at the same time
&gt; Your HTTP server and your PHP workers SHOULD be separate processes. This is very true. Back when heartbleed was an issue I was mostly OK because all the hacker could get were the user's cookies. But inspecting another random site I could see things nobody should be able to see including source code which contained passwords. The problem is he used Apache for everything so I could read whatever was in Apache's memory. From a security standpoint you absolutely should keep these separate exposing as little as possible to the outside world.
Why not all three?
I know some of these persons mentioned in this post personally. Seeing inhouse CMS systems falling left and right has taken many companies with it. This presentation? looks more like a pointless rage induced by stress. Bashing on all the new things that have actually proven to be the best tools we have today. Been there a partner in a successful Finnish CMS startup with many a like in the Ohjelmistoyrittjt software group in the 2000's. After dev costs are overcoming the support money and new prospect client projects it's all downhill. CMS's don't survive without MIT and strong companies behind it. Companies that build things on frameworks can keep themselves healthy and the whatever programming groundup they are breeding from.
While language versatility is a good thing, I would suggest, if a person wanted to learn multiple languages, choosing a combination of wildly different languages like "PHP + Java + Erlang". A person who is skilled with Ruby stands to gain little overall skills from learning Python. 
It's true though. In around 1990, Perl and PHP were pretty much all that could be seriously considered. Ruby and Python didn't exist, and JS was a laughable language used to create alert popups in Netscape. PHP was nothing like the PHP we have today, but Perl was pretty much exactly the Perl we have today. Composer didn't exist. CPAN did. For just about anything people like about PHP today, it didn't exist, and Perl had a better competing option. 
Well, you would be switching from the PHP runtime to HHVM runtime. You could switch from Apache to nginx and you might see some more performance but you would have to test that out (which you could easily do with something like vagrant). As for switching to HHVM I would say build one server with it and give it a go. You can litterally swap out PHP for HHVM and vice versa at the drop of a hat. The only thing you would have to do upon switching is change some Apache/nginx config and restart.
Try dabbling with all of them. There is no perfect language. It all depends on the use case. I would choose Python. It has good documentation and huge community.
udemy posted an infographic comparison of these 3: https://www.udemy.com/blog/wp-content/uploads/2012/01/PROGRAMMING-LANGUAGE-3.png 
the thing keeping me from learning php is that it 'has alot of security issues" is that the reason people dislike php?
seems outdated, thats from 2011
I've never really understood what magento can do for me.
how deep do i need to get into ~~your mom~~ javascript because i want to be a backend developer, thanks alot for the answer.
There are two types of programming languages: Those people complain about, and those nobody are using. PHP is as secure as you write it, just like Ruby and Python are. 
Well, the trend is shifting towards a blurring of the distinction between backend and frontend. In many cases, it's making less and less sense for the backend to do anything other than provide data through a REST API. A full working application often involves a considerable amount of the application logic living in the front-end as a Backbone application that is responsible for routing and view modeling, while the backend handles data requests and last minute validation. So while you can technically build just the backend, it's a bit meaningless without a rich frontend application to consume it. Of course, someone else might be responsible for building such a thing, but you can't always guarantee that if job security is your thing. So regarding javascript, I would go deep into it and learn at least Backbone + Require.js. You will find that even though these technologies live in the frontend, the development process has strong parallels with the backend. Javascript is much, MUCH more than just presentational stuff these days. *Applications* are built with it, no different than using PHP on a server. And with Node, it literally is javascript running on the server.
You're adorable.
&gt; Didn't nginx start as a fork of the Apache 1.3? No
You're welcome! Ping me if you need any other advice/mentorship, I've been interested in getting involved in that kind of thing for a while.
When I hear helpers, I always think view helpers (https://github.com/auraphp/Aura.Html/) . But it seems you are looking for libraries which can be used any where on your project . Aura have a few libraries like auth, router, dispatcher, di, db, mappers, form(input), validation / sanitization (filter) . Have a look into the repo https://github.com/auraphp or website http://auraphp.com Other similar projects are https://github.com/symfony/symfony , https://github.com/zendframework/zf2/ .
thanks man
There's a ton of misinformation going around this thread. First, I can't speak to Python or Ruby, as I'm not fully versed in those languages. I recommend posting in those subreddits as well asking this same question, and hopefully getting some straight facts to compare to. That said, as far as popularity goes, PHP wins hands down. This is important as it means it's far easier to find a php job than it is to find a python or ruby job. As far as keeping that job, a lot of times that depends on where you get hired. Many places have a revolving door of developers due to bad management, or just bad business decisions. I've held down a steady job for 10 years running with PHP, but i've been employed by about 6-7 different employers over that time frame. YMMV here. As far as all the hate php gets, there is some truth behind it. Yes there are some dark corners of the language itself, such as inconsistent functions and inconsistent parameter order on similar functions. But this stuff is easily solved by a quick google search, or a proper IDE(of which, many exist for the PHP language). Beyond that, much of the hate comes from people who misuse the language, making horrible confusing messes that the rest of us are inevitably tasked with cleaning up. This is a reflection of php's popularity more than anything. It's incredibly easy to start, and being so popular, it's not uncommon for some amateur to come in and make a mess of things before a company learns and hires someone with some actual skill. I also adamantly disagree with others who stated you're stuck implementing basic wordpress/drupal/magento sites. This is absolutely not what being a senior level php developer is about, hell it's not even a junior level php developer. Many sites are either custom built, and reasonably well done, or they are built using a popular framework(symfony, laravel, codeigniter, cakephp, kohana, etc). The amount of jobs that fall into this category are not nearly as frequent as those that fall into the wordpress category, but they are more enjoyable, pay better, more stable, and offer you more growth. This again comes back to why PHP's popularity is a great choice. Because for every 2 wordpress jobs, there's 1 non wordpress job that may be a perfect fit for you. And while those odds sound discouraging, do a quick search in your area on craigslist, or on any other job board and you'll quickly see thousands of non-wordpress jobs. I'll leave you with this: I started programming professionally 10 years ago with out ever getting a college education. I've been working from home for the last 5 years, and making over 6 figures for the last 3. for my money I'd chose php again.
Same here. Learning python after php, seems so refreshing.
I die a little inside, whenever somebody says LEMP. Nginx doesn't start with an E...
As you know, PHP only cares about the type of the *value* not the type of the *variable*. It doesn't care *anywhere* that an integer is represented by twos-compliment binary value, an ASCII string, or an IEEE 754 floating point value. In all operators, functions, and comparisons it's merely an implementation detail. Even more importantly for this discussion is that it will freely convert variables from one type to another as needed: $var = 5; // Var is int(5) $var = 5 * 2.0; // Var is float(10) In your most basic example of getting input from the user (which is always string), the performing input validation (as you should), and spitting out a variable with the correct type strict typing hinting is no loss. But because PHP isn't strongly typed or strictly typed, you will have properties and variables come from all over the application with no guarantee about their variable type. Strict type hinting is going to require developers to litter their code with casts or safe-conversions to then make that guarantee. In my example, `$var` would fail on any function strictly accepting an `int`. So now I introduce a cast. So now I have more syntax and I've neutered that hint on that call forever -- if I later introduce a type bug on `$var`, the code will silently work. &gt; Alternatively you may make a conscious choice to not perform validation and cast directly, because you believe the input to be always correct The nice thing about loose scalar typing hinting is that they work as expected **and** and they provide a useful additional feature: They can be used for value-type validation. Not necessary user input validation, but validation everywhere. So now my situation where I assume the value will always be the correct type (e.g. integer strings from a database) are actually checked and will trigger an error if they don't match! In my opinion, that's a *hugely* useful feature to throw away for strict type hinting. So really strict type hinting seems logical but its more work for developers and it's less useful, so why do it? 
Pronounced "engine x" though. 
Who the hell downvotes you just for saying "thank you"? I swear... some people...
&gt; nobody chooses ruby anymore That's quite a stretch. 
I realize I'm a bit late to the discussion, but I saw a couple other posts that mention symlinks from /var/www being downvoted. Other than being "stupid", can you give an objective reason not to do this? Consider a link from /var/www/example.com that points to /home/user/sites/example.com. The ownership is set with "sudo chown -R user:www-data /home/user/sites/example.com". I realize this is a little different from what you described. I like the setup because the user is allowed to write files, but the webserver can only write to files/folders that have write permission granted to the group (i.e. www-data, apache, or whatever it is for the Linux distro you are using). What is the downside to doing this?
The other type of solution would be Active Directory or LDAP or the like. This would keep the responsibility to authenticate with the client and away from your app.
If your server requires the credentials to other services only when the user is logged in, you can encrypt the credentials with the user's password and upon login decrypt them and hold them in a session. So an attacker can only decrypt the password when the user is logged AND the user has access to the system. If he just has access once and copies the entire server, the encrypted credentials and a securely hashed user password as the key will not allow him to uncover the data. You have to make sure that after the session the credentials are securely removed, so no entries in a session database table, etc. remain with the clear-text credentials. Be sure when encrypting your data that you make yourself not vulnerable to a known-plaintext-attack. If you just encrypt a serialized array or object, the unencrypted string always starts with the same string which will reduce the strength of the encryption significantly. Best is to start with a random contents and random length initialization string.
 This tool can be used for many purposes here is two that I can think of right away - As a package maintainer you may want to know where and how parts of your package is being use on other packages. - It may help find similar interfaces being used throughout the php community/packagist.
There is value in lighter (in terms of byte size) data interchange formats: - When sending data over data over slow cellular connections to mobile devices - In environments where you don't want lots of overhead of decoding data such as banking transaction systems where you might be dealing with millions of requests a second. I'm not suggesting that JSONLite is the right format for both of these scenarios but it's also not useless either
Yeah, I never really got that argument as you can use PHP-FPM with Apache. There are plenty of legitimate reasons to use Nginx over Apache (mostly performance). Every big company (Facebook, Google, Dropbox, Spotify, Amazon, etc) uses nginx over Apache. At my company, we did extensive performance testing and even with Apache well tuned, nginx beat it by a huge margin. Also nginx + the lua module + LuaJIT is a super powerful combination.
That just proves that nginx is faster than Apache, isn't your blog post saying otherwise?
I think I agree with /u/StiltonOnStilts here. This seems to be more of a novelty than anything else. To address your points, if you're sending data so large that saving a few bytes on quotes makes any significant difference, then you might want to look at breaking your data structure down into more manageable pieces that can be sent separately. Compression of said data might prove more beneficial than anything, and is easily understand by Javascript using [external libraries](https://github.com/imaya/zlib.js/blob/master/README.en.md). As for the "overhead of decoding data", you will see more overhead from using a library written in PHP versus any perceived overhead from a C extension. Even if you could demonstrate a significant overhead from the built-in C extension, it is probably negligible compared to the overhead of having to interpret and execute your PHP-based library. So, with that said, and assuming a real performance hit with the existing JSON library, you'd probably have a better argument for performance if this were written in C. But, until you can demonstrate this performance problem, as a developer I would pass on using this over the existing JSON standard. Also, with regard to the project as a whole, you should take a few minutes and update the README telling people why they should use your library. Demonstrating how to write the code is great, but given the contrived examples, it does not demonstrate why we should use your library. Right now, it just seems that this is a solution in search of a problem, and not the other way around.
I can definitely understand the mentality though, I used to be in the pro-apache camp. Nginx can be a bit intimidating at first because their syntax is so much different then Apache, and it's configured quite differently. However, after you read the docs and set it up a few times, you'll probably find the syntax is pretty easy to grok.
Indeed, that's a point I can get behind. People shouldn't compare Apache + mod_php to Nginx + PHP-FPM, if anything they should compare Nginx vs Apache or mod_php vs PHP-FPM. However, your blog post does over simplify some other points. For example: &gt; If you have only a single core PHP-FPM wont be faster than mod_php ( itll take a separate blog post to explain why ) I probably know what your separate blog post will say, but it depends on your application and setup. You also need to ensure you factor in the cost of starting up a new mod_php process vs a PHP-FPM process (PHP-FPM wins here). &gt; If you need performance use HHVM Bit of an oversimplification. Almost nobody will be able to dropin HHVM as a replacement for Zend right now. You're going to require a lot of code changes to your application. It's also a different department normally (Ops might roll out Nginx and/or PHP-FPM, but dev has to update their codebase to work with HHVM and Ops also has to be involved to roll it out). 
The post isnt me rolling eyes on nginx being faster. Just on people comparing Nginx+PHP-FPM to Apache+Mod_PHP. I heard some people say that one should move to Nginx *because it has fpm* when clearly they both do. 
If you really want a lighter serialization, also quite a bit faster, look at msgpack. 
&gt; If you have only a single core PHP-FPM wont be faster than mod_php If you have a single core server you should be more worried about getting a new server.
Thanks =) I've now added a blockquote to the post to clear that out
I think the concept is good; but who in their right mind would ever not pick JSON over almost everything (XML is fine)?
This article reads like it was either poorly translated by Google Translate or it was programatically generated by some poorly seeded Markov-chain
Say nginx aloud. What is the first sound out of your mouth?
Centos 7
This post has bad grammar, unattributed quotes, bullet lists that are desperately trying to prove something and is full of unsubstantiated anecdotal claims.... to tell us that you should remember to use the right tool for the job. Weak.
Because that's how acronyms work.
The default configurations for Apache that come with Debian and Ubuntu seem to work just great. With PHP make sure to have APC installed. The only thing that you might need to tweak is the number of apache workers to support, but that is not required for 90% of cases.
Doesn't Google use a home rolled HTTP server?
This post is off topic for /r/PHP. Please refer to the sidebar for more information.
This post is off topic for /r/PHP. Please refer to the sidebar for more information.
MySQL is the backend, and I would expect there to be a lot of writes. Possibly ~100 concurrent users at one time. Not sure if you consider that a low workload or not.
But just to make sure I'm following this correctly, if they can modify the PHP code, they can get the key (because the PHP script has to be able to get the key), right?
There's an end to that sentence though =) It's easier to set up to be "good enough". While apache is easier to just "set up". Both are rather hard to make them bulletproof
edited that part)
I'm guessing they use different servers for different things. The google search engine HTTP interface could very well be hardware implementation to eek out every single ms. They probably have quite a vanilla Go servers (maybe under a file / response cache) as it's (surprise, surprise!) designed to be fast and performant right out of the box.
I reckon in general, if someone is saying "shit, my servers is under load! I serve enough requests!" 99% of the time the majority resource hog will be the backend language / database, not the server.
Why would a company ever end up in a position where it hired a team of developers none of which know this stuff, and now needs someone to school them on the subject.
This post is off topic for /r/PHP. Please refer to the sidebar for more information.
vim can actually be configured as a pretty full-featured IDE for PHP, even with add-in xdebug support. But I still mostly use phpStorm for big projects, and just dip into vim for small edits.
Gotcha, thanks
lol
Excellent, thank you. I'm in complete control of the system configuration and it is only being used for this application. I'm going to take your recommendations and apply them to the php.ini configuration.
What was your experience while doing the port? How did it compare to working with normal PHP? What did you like particularly? Did you run into any problems?
Fantastic stuff in here. Nice to read a full stack framework written in Hack which really makes use of the language; Traits with 'require implements' clauses (which I see being used in your event system), type aliases (didn't know you could do this: https://github.com/titon/framework/blob/master/src/Titon/Event/Emitter.hh#L13), &lt;&lt;__ConsistentConstruct&gt;&gt;, etc. Question: are you using PHP docs to get IDE integration where it is lacking, or because you still prefer it be there? I wonder how necessary it is to annotate parameter and return types with a language which has type annotations? Anyways, cheers. Awesome project that I'll keep watching!
There are a lot of small businesses in this position. Three of the past four companies I've worked with have had no version control in place. All four had no testing (unit, integration, or otherwise), documentation, or any live application monitoring solutions in place (like New Relic). Each one of these companies had development teams of three or more. I think the solution proposed would be a hard-sell because development in these companies is still seen as a cost center, and not necessarily a revenue generator.
 &gt;I think the solution proposed would be a hard-sell because development in these companies is still seen as a cost center, and not necessarily a revenue generator. Yah I agree. 
PHP users are always so curious about Hack \^^
This is not correct I think. As long as you don't bottleneck CPU, php-fpm has lower memory usage for static assets, because in mod_php, workers that are serving static files like images and CSS still have all of PHP/WP in each workers memory. Opcache alleviates this a little but I'd still say using php-fpm is faster since you can spin up more workers.
IOU - I Owe You 3M - Minnesota Mining and Manufacturing Company K9 - canine I see what you mean /s
More abuses don't make the abuse less. :)
I'll be adding some docs in the coming weeks, so be sure to keep checking it out! Thanks for the support.
I'll get back to answering this when I get off work.
Cool, thank you for the link. Also a fan of PHP town hall so thank you for that too. 
Sweet, cool. I'll send you a private message, and I can help you along :)
Thanks that would be awesome. I will set up all the required application till then. thanks again
Should PHP users not be curious about a PHP-derivative language?
I hope you find it useful. :)
Close. It's the ability to access InnoDB table(s) via the memcached protocol. But treating tables as "flat" (no joins/etc. no SQL). But yes - the data persists to a table/disk.
Works fine here. Maybe there is a DNS cache overactive somewhere?
The gzipped payload isn't going to get appreciably smaller by removing key quotes from JSON. Making that stuff irrelevant is kind of its raison d'etre.
You've either never worked for a company, or been *incredibly* fortunate to have only worked for good ones! Sure it's unlikely that absolutely no one knows anything, but there are plenty of mediocre developers out there. Or even ones that are good at some things but maybe not others. I think you especially find low-quality programmers at companies where the code plays a support role and isn't the primary product (i.e. "line of business" apps, or basically any company whose main product is *not* software or an app/service). A lot of those companies don't know much about programming themselves because it is not part of their culture, and they maybe don't want to pay market rates for good people, or they just go off of buzzwords on a resume, etc.
+1 phpstorm 
Cool. I am also working on a [social music platform](http://cloudaud.io/) (meant to be a alternative to SoundCloud).
That sounds like a personal problem
Actually it is a corporate one. 
Because he is still on stilts :)
The real answer is that multitasking mod_php+mpm_prefork is, for all practical purposes, the same as php-fpm. Both can run simultaneous tasks on a single core. Both can scale the amount of workers for demand. In the former php-fpm manages a pool of ready to run workers, many can coexist on a single core at the same time. When you hit the max workers then the web server will stop serving PHP until a new worker is freed. In the latter apache manages a pool of ready to run workers. They may serve static assets (that's why mod_php is seen as a ram/perf waster), but mod_php is always ready to run in case the request is a script. Again, many workers can run at the same time on a single core. When you hit the max workers then the web server will stop serving ANYTHING until a new worker is freed. TL;DR: the amount of core is completely irrelevant when we're talking mod_php vs php-fpm, both scale the same way by different means.
Hey s3nt1nel, first, apologies for the delay. Ever since I released the codebase, I've been a little busy with the influx. Thanks for taking the time to provide feedback, and the granular details. As I've stated in the README: "This is my first go at publishing something extensive on GitHub. I'm far from perfect, and have been in somewhat of a bubble. Regardless, I have decided to get my feet wet so I can collect feedback from the community, and grow as a developer. So, your constructive criticism is encouraged." Some of what you have pointed out makes complete sense... other stuff, I'm a little foggy on. Like, the mixing of procedural and OOP. Not sure where I'm doing this. If you could point to something, if it's explainable, that would help. Also, the part about public properties in classes... not sure what a "accessor method" is... So, you see, I'm not fully there yet, and I am aware of this :) My goal is to see this through, and have it morph into something that's (hopefully) beautiful. Feedback and guidance from folks like you will undeniably make this possible.
stringy for string functions, guzzle for curl functionality, symfony/filesystem for io(file), doctrine/common for collections..
I can't figure out why so many people want to add auto-casting to functions. Type conversion is so problematic in PHP. To make it worse, they call it "type hinting", which suggests it's some kind of static analysis tool like the current class type hinting when in actuality it's just auto-casting. 
It could depend on the area. Companies in my area are having a hard time finding truly experienced developers (that is, not developers who have been doing shitty work for 10 years and think they are worth veteran salaries). I think the hard part would be convincing companies of the value added in doing things properly, because you can still get paid and still make margin off of sloppy process.
The memcache interface can be used as a drop-in replacement for memcached, with the memcache/d extensions. You don't need to use mysqlnd_memcache, but in documenting it for the MySQLnd series, I dove deeper on the innodb memcache stuff.
Actually, not exactly. For the `mysqlmd_memcache` extension anyway, `*` wouldn't work. You must specify the columns explicitly as only specifically configured columns are returned, and the `mysqlnd_memcache` extension checks those to see if it will automatically convert to a `GET`. But your premise isn't too far off
&gt; Be sure when encrypting your data that you make yourself not vulnerable to a known-plaintext-attack. Any algorithm vulnerable to the type of attack you described would be considered totally broken and thrown out. Most SSL connections start with the same exact GET header, followed by a predictable ACCEPT, Content-Type, and so on, but that hasn't been (among the many) a method of breaking SSL. 
The fuck you are talking about, all I fixed was one grammar thing and emphasized a paragraph turning in unto a blockquote
I'm not really fond of CMS' for mostof my projects. I sort of built my own CMS, or framework I guess? I'm more a man of action, not so much a man of terminology. I've found building on my own framework I develop much faster, have more flexibility, and can write more efficient code. However doing this you need to have a clear understanding of all the security risks and what types of bottle neck you're likely to encounter.
Seriously, stop using 'guys' to address the whole of /r/php.
My first move would be to get rid of the ASP and MSSQL stuff. Having a single technological base (PHP and MySQL/MariaDB) will simplify things a lot. I would try to create a complete schema/set of model classes using doctrine and rewrite to backend to handle all the CRUD stuff using doctrine. Put your complete model stuff into a composer-package so you can pull it into the backend(s) and the frontend(s). Use the new model in the frontend and just replace your current SQL queries with access to doctrine. Next try to identify code parts that are implemented there where good libraries exists as composer packages. Throw the custom code out and replace it by stable tested external code. Separate business logic and presentation logic in the frontends (if there is more business logic than just access to the models.) Create a controller in the middle to connect the old presentation with the extracted business logic/model. Now you have the M and C of the MVC already. It is up to you if you want to introduce a full-stack framework then. I would recommend a framework that can use doctrine, which would get you to symfony I think. 
Hey dean_c... [I have implemented](https://github.com/ghalusa/PHP-Skeleton-App/commit/c8e0e2957917506d889f4948fbb0760cde145697) the create-project command as you suggested. So elegant! Thanks again!
This is nothing against OP... These kind of posts show up at least a dozen times on this subreddit each year and it is rather disappointing that the companies behind these products simply don't invest into bringing in a consultant on these issues. I don't understand why companies are so outrageously cheap when it comes to these sorts of issues. In most cases the company is just piggy backing on their existing team to just know how to deal with this or a couple quick google searches and they'll be fine kind of mentality. Doing any refactoring work is generally costly upfront but it is even more costly in the long run if done by "amateurs" aka team members that have no prior experience tackling such a large refactoring project. The best advice I can give people who might be in a similar situation is to put on the big pants, go to management and tell them them they need to drop like $1k investment to get some professional help on this matter. **Disclaimer**: Maybe overly angered by this and or bias because I run a consulting company that does this.
No you're right. Poor management believes that maintaining legacy software is somehow cheaper. Its not. There is so much new tech that makes development, even PHP, much more simpler to use. Which means bug fixes and new feature are possible are not these daunting projects.
You hit the nail on the head in the last paragraph. All Apache workers are in a pool, and since there is generally 10-30 static files (css/js/images) per dynamic request, most of the workers will serve static files, but as they are rotated in the pool, every worker will soon have seen the dynamic request at least once and will bloat up. So in the end, all of the workers will be bloated. The only way to alleviate this is to set the MaxRequestsPerChild to a low number. This will, however, increase file I/O since workers will have to grab the raw php code from disk more often as they get revived after MaxRequestsPerChild limit kills them off. I remember an old client using PHP 5.3 without opcache. they were struggling keeping a site afloat on a 16GB machine. Their average worker process was about 80MB, and they were struggling with memory. After enabling APC we saw each process drop down to 8-12 MB. They could scale the memory down to 4GB and still up their worker count. This is because most of the processes now shared the compiled opcodes which were previously cached in-memory inside the worker process.
&gt; PHP, much more simpler to use. More than simpler, is consistency. With consistency, developers can expect something from one project to another, they can stack learning, and share learning.
Often times, they aren't just being cheap. It's actually pretty difficult to justify a consultant in a lot of situations for companies with in-house engineering teams. Between the wealth of knowledge/experience/advise available for free on the internet these days, and the competence of an existing team, it may just not be cost effective. Then you have to factor in the (unfortunate) facts that finding a good consultant with reasonable rates is non-trivial (and the process of finding one has associated costs in and of itself), and that being a good consultant doesn't magically mean that your insights are worth your rates in every situation for every client. So, it's a lot more complex than just "if you don't hire a consultant, you're cheap."
I've seen some projects bring in a 'consultant' that left things worse. In one case, I think I may have been that consultant (my situation was more political than technical, but still). But in many cases, people just don't care, or the business is predicated on features/functional changes taking X weeks, and budgeting XYZ weeks for testing/fixes. Presenting an argument that changes should take hours or days, vs weeks.... isn't generally persuasive if the business as a whole is still profitable and continues to be. If they're hitting competitive issues, a panic may set in, and the argument can be "it'll be too late to make the changes necessary at that point", but it's a hard sell to make unless you've got forward-thinking leadership.
Sorry, was my friends birthday last night, didn't have time. Will do it right now. Edit: Posted above.
I'd ask a different question than the ones above: What's broken? Reading your description, it sounds like a messy architecture that's evolved haphazardly over a long time. But while it may not satisfy what coders like you and I call "good design", are there any business reasons why new feature development should be backburnered in favor of rewriting the stuff you already have? I know how heretical this sounds. "But the technical debt, you pay a greater price later, etc." I've made that argument many times and sometimes still do. But I don't think it's a universal truth. You mentioned this app's been around since 1996, and the technical debt accrued hasn't sunk it yet. Is it about to? Are you at a point scaling the app where you can't move forward because of how it's built? Is new feature development blocked by past architectural decisions? If the answer to any of those is "yes" then I think retrenching and rewriting makes sense. But if it's more about scratching a programmer's OCD itch, then let me tell you - it's all a mess. The internet runs on code you'd probably be horrified to know the messy details behind. But it works - and that refactor/keep going tradeoff should, IMHO, be tilted much further in favor of "keep going" than most programmers (including myself) would care to admit.
&gt; Nullables and the null safe operator ?-&gt; are really handy. Hmm, what would you say the advantage of nullables is over PHP's existing support for null typehinted parameters?
Interesting. This sounds like a use case that doesn't really exist in regular PHP, since you could just do `Foo $foo = NULL`.
I'm working on a legacy PHP app right now, one that has existed since the 90's, has no structure, etc. While the "Modernizing Legacy PHP Apps" book and everything you find on the Internet suggests extracting the domain layer first, I'd recommend doing that last. These apps tend not to have cleanly architected database schemas and the domain is fuzzy, at best. The goal is to bring as much clarity to the code-base as quickly as possible to reduce the pain of maintaining it as quickly as possible. I'd argue that the biggest gains can be made in separating the view out of the controller and then structuring those behind a front controller. As you do that, you can start to get a feel for what the major nouns in the code are and how they map to the database back-end. At this point, you know all of the places where a given db field or table is used and can clean that up without worrying about knock-on effects. You can also start to extract commonly-recurring bits of logic off to the side in low-level functions and objects. I'd also add that legacy apps, particularly ones that have been poorly maintained over the years, tend to come with lots of garbage. There may be chunks of code, or even whole files and pages, that never get used. There are likely to be several fields, potentially even whole tables in the database that can simply be dropped. Clean out the trash whenever you encounter it and you'll start to see the current application emerge out from the mess.
&gt; I've got a copy of Paul Jones book on modernizing a legacy app.
Its not public yet, its far from useable at the moment. Have to implement a lot of missing features, and better comment it before its ready
Release early, release often.
I'll retain the point that this should be a complete non-issue. What that PDF describes is an implementation flaw in a large complex protocol. Prepending random data to your plaintext is not a solution. There is no "plain AES" unless your data is exactly 16 characters in length. If you're referring to ECB mode, it has its share or problems, but being immediately broken in a known plaintext attack isn't one of them. Using a proper encryption system is a solution.
Puur, if you're into patterns.
&gt; tell them them they need to drop like $1k investment to get some professional help on this matter $1k wont go far surely? Most consultants would charge in that area just for a days work, and it seems like OP's project is gonna need a lot more than a casual review &gt; These kind of posts show up at least a dozen times on this subreddit each year I don't find this surprising either. Businesses tend to develop systems and then once its doing its job the requirements change and it ends up getting pulled in ways that the original spec didn't anticipate. Odd bits of Frankenstein functionality get bolted on, or you need conversion routines to massage data etc This wont ever change, and even redesigning it with a consultant, and then recoding it all from scratch, in maybe 5-8 years it will just face the same age old problem. I think in many cases the devs are able to do the consultants job with much more insight and business knowledge, but they just the lack the authority to make a call on it. 
If you are IO bound (reading the console), why not use non-blocking sockets?
Stop storing passwords in a plain text file.
In fact, stop storing passwords altogether. You're not supposed to. That's why we have password hashes. 
I have to disagree. Although consulting companies are very important, it never hurts to get a broad view of opinion from the community at large before you start discussing sinking a substantial investment into a consulting company who may or may not envision exactly what you're attempting to achieve.
I would consider storing in non-plain text (i.e. hash) as still "storing".
rtrim() should be preferred, we don't know if OP may want to preserve the line.
You, uh.. work for Sony?
Your initial example should run despite $foo being undefined. PHP displays a *NOTICE* when a variable is not defined and its value is assumed to be null. A notice isn't an error as execution continues. &gt;Enabling E_NOTICE during development has some benefits. For debugging purposes: NOTICE messages will warn you about possible bugs in your code. For example, use of unassigned values is warned. It is extremely useful to find typos and to save time for debugging. NOTICE messages will warn you about bad style. For example, $arr[item] is better to be written as $arr['item'] since PHP tries to treat "item" as constant. If it is not a constant, PHP assumes it is a string index for the array. &gt; It is not necessary to initialize variables in PHP however it is a very good practice. **Uninitialized variables have a default value of their type depending on the context in which they are used - booleans default to FALSE, integers and floats default to zero, strings (e.g. used in echo) are set as an empty string and arrays become to an empty array** Edit: if you really want to do what you said in your last paragraph, you can disable the NOTICES by using error_reporting(E_ALL &amp; ~E_NOTICE); 
+1 for PHPSTORM !
If you hashed a large file like a film, and stored the hash in your database, would you say that you are storing the film? I'm pretty sure you'd say no.
Exactly. How can this code not be sure if a variable exists? If it's a method call then you know, if the variable is a class variable then you know. It seems odd to be in that situation.
well, I can't think of anything this clever to say, so you win
Whilst heeding the advice of the other comments around the safe storage of user credentials, what you are after to do things a little nicer is fgets() with an rtrim() - rather than fread($unFile, 99); http://php.net/manual/en/function.fgets.php
That's true. But being a pragmatist rather than an autistic pedant, I still consider a hashed password as being stored. :D
Thank you, but I started this discussion to see if I should consider doing that. I definitely believe the community on this one, but I'd like some more concrete example of why this would be a counterproductive idea.
http://3v4l.org/rcDo0 You are doing something wrong.
http://www.phptherightway.com/#security
I have been though this on many levels. I spent 10 years migrating a few dozen web applications from ASP classic (and cold fusion) to VB.Net. I also migrated a very large music website from cold fusion to PHP. So I've seen some shit. First off to I want to say that unless your boss is specifically requesting to change their entire infrastructure as well as the database (after spending thousands of dollars on CPU licenses) as well as scrap every piece of code and re-write in a new language for a new platform then you do not want to approach them with this idea. You'll either quit or be replaced in 6 months. No employer wants to hear that you want to spend the next year or two being paid working on stuff that is not making them money. New, doesn't mean better. And just because it's better does not mean it should be done. In their mind it works and it makes money, and what you want to do is spend money that does not make more money. Ok, having said that this is what I have done in the past. I would update the pages from ASP Classic to VB.Net. 90% of your code can be reused. You keep the hardware, the database and site design and get your presentation layer separated and cleaned out. This is the main reason why VB.Net exists and that is to migrate ASP Classic over to newer and better coding practices, language, etc. Doing this is a great benefit because you can reuse almost everything and your migration will be easier. All your code will be separated between master pages (which can easily be transitioned to a template system) and you can actually start writing OO code. You can even easily convert the VB.Net code to C# if you really wanted to with very little work. The down side to this is that your boss may not want to progress further then this but it's your responsibility to convince him that further migration is needed. If you do continue on to migrating to PHP do not make the mistake of using an existing CMS, at least not for the front end. You'll learn very quickly every limitation and bottleneck that the CMS has that you cannot work around. When I migrated my music site I went with wordpress and it was a year long pain in the ass. Then changed to Dorpal and it was the same problem. You will be better off using a proper frame work and building off that. I would suggest Symfony2. You'll have easy support for the MSSQL database with Symfony2 / Doctrine. So in summary this isn't just a problem of infrastructure, migration, framework or which language to use, the biggest problem will be convincing the company that change is needed, and to do the changes over time. I would update from ASP Classic to VB.Net to separate code and presentation. Next start the PHP migration using the existing site design and database. Once you have a PHP framework running well you can make the transition to Apache if need be, migrate from MSSQL to MySQL, etc. Oh, and I wanted to say I'm not promoting VB.Net in anyway or not saying to use PHP. I'm simply saying that it is a good, fast and easy transition from ASP and that most employers will not be willing to spend a year with no progression of work.
Hi there! Im focusing in PHP for the last few weeks, Im following few courses that I bought on udemy, doing the challenges on /r/dailyprogrammer and created a [blog](http://webdevfromzero.wordpress.com/) just for posting the stuff I learn so I can use as my database later, feel free to contact me :)
... And how many of these security issues would actually contribute to a compromised server? The blog title is fairly misleading.
Have you tried encoding the data into JSON instead?
I never thought of json to be honest. And json is a lot nicer. Basically, the data will just be dumped to an array and iterated over with foreach to display. I won't be running queries on it.
I completely forgot about using json.
Where's the stackoverflow post? Off the top of my head, I'd suggest your data-model is messed up if you aren't damned sure every object implements either Serializable or the magic _methods.
If you don't know where to start but have a concrete website / webapp in mind, look at [this checklist](http://stackoverflow.com/a/14833267/664108) to get an idea what's most important.
In your opinion, what is the best way to store this kind of data?
I would store it in a table *if* there is **any** chance that you would need to edit it manually at a later date. If it really is something that is a simple iteration array that you'll never change. A hard coded array is easier to manage than a JSON encoded one in the database.
 your_main_table -------------------------- id | email 1 | bran@stark.com 2 | aria@stark.com your_tagged_usernames_table ---------------------------------- id | main_table_id | username 1 | 1 | hodor 2 | 1 | jonSnow15 3 | 2 | syrio 
Except you'd be storing the hash, not the actual password. 
Note that at high scale, json_encode/json_decode are much slower than serialize/unserialize. If what you are serializing is simply a list, why not just join into another table? Joins are ridiculously fast, it's one of the things databases are optimized for. This seems like a lazy shortcut.
&gt; $1k wont go far surely? For something like this with such a small team personally I'd bill around the $100/hour. That breaks down to about 10 hours with a 15 minute free consultation. The consultation weeds out projects that I feel I'm unable to help, lets the client get a feel for how I am personally, making sure the billing sounds fine and general ironing out the top level overview of the project. After that the 10 hours breaks down roughly to: Spent on discussing tech stack, details, minimum that needs to be accomplished, and long term goals with the project. The point of this conversation is usually to make sure everyone is aware of expectations, what we have to work with and how far out can we adventure; Example of what I'm aiming for: Management wants this done in X timeframe. Developers want clean code. With that in mind what is their current stack, what is the low hanging fruit to refactor, what isn't going to happen in the current timeframe, what are the fundamentals that should have the most time spent on, etc. Discussion on various modern tech improvement; Version control? Composer? Unit tests? Service layer? PSRs? Hooks in place to prevent shitty code? ChatOps? Vagrant/Docker? Etc etc etc. At that point there's usually a plan that I draft up for them to generally follow to put them on the right path to accomplishing what they need. There's a fair chunk of time spent with the client's team on general discussion, "How does this tie into this? If you had to rewrite this how would you go about doing it? What is blocking you from rewriting? Out of the whole system what do you try to avoid touching?". Just that small conversation that I've outlined above was enough information from one client's employee for me to draft up a very basic plan in 20 minutes to get them on their way for the next 2 weeks of work. If a client asks me why they should bring me in considering my billable rate, they already have a team of usually ~10 developers and they feel there's enough resources online to get them through this I usually respond with these points: * More than half the problems I solve only outsiders can usually solve. Joe manages a core piece of the system. Matt is the team lead. Matt &amp; Joe don't exactly get along and neither exactly calls each other out on bad code or mistakes. Usually only someone from the outside who trumps everyone everyone can set the tone and call everyone out. "See this code, right here? This is really shitty code. Yes, I know it was written in a rush but it is bad code and I need everyone on the team to know it is bad code because if not they're going to continue writing this way." * Founders of a startup do everything but eventually they bring in expertise Why did the founders of the company even bring on employees? Well either for scaling reasons or they hired people who have expertise better than themselves or they knew it'd be more beneficial for them to focus on what they're good for and someone else to focus on X. Having someone on your team spend all this time researching into good practices of how to refactor, scaling and making sure the same issues don't happen in the next year or two takes away from them doing their current tasks at that time. This usually means they're going to become a bottleneck because someone is waiting on them with the stuff they've pushed aside to focus on this. Bottlenecks in a team means X employee(s) are not operating at 100% of their capacity and that means the company is losing out on money. * My view of "good" consultants I don't bill my clients for small after the fact messages from their employees. "Hey, I've been debating using X library vs Y library... any thoughts?". Usually if it is less than a 10 minute conversation or I have a good relationship with my client I pass on billing them for these sorts of things. I also make myself available to their entire team 24/7 (assuming I am not sleeping). I disagree with the process of a team lead sitting down with me, chatting and then going back to their team with a plan and force feeding. Having a plan is one thing but educating everyone on why the plan is X is extremely important as well. 
&gt; If performance is an issue HHVM would be something to switch to instead. I agree with your basic premise, and will add that after having set up HHVM and PHP-FPM on many systems, I think HHVM is significantly easier to setup on nginx than apache, and it's easier to setup HHVM on nginx than PHP-FPM on nginx. There's so much fear around HHVM because everyone thinks it's going to be so much more difficult to install than PHP, but it's downright trivial and I tend to run into way more wtf-problems on PHP installs. The biggest concern if looking to go to HHVM ought to be application compatibility. If you have a reasonably modern application, one based heavily on a popular framework/CMS, or an old app that's well architected and changes have been consistently tracked and well organized, then a move to HHVM will be easy. The PHP lib is pretty huge, so if your app is just some giant black-box, full of so much spaghetti, anti-patterns, and relies on an absurd number of seldom-used libs and functions, you're going to have a hard time.
I've worked on an open-source, web-based 4x style game for over a decade now. It was originally Blacknova Traders, but unfortunately the lead programmer for the game has stepped away. I've since forked the code to rebuild the game with a new storyline called The Kabal Invasion. https://github.com/thekabal/tki/ has the code. Cool things included the process of moving from a pre-PHP4 code base to modern standards, especially things like ancient input filtering and templating. It is still very much a work in progress, and I'm the first to admit the code today could be much better - and I'm working to make it so. I love that PHP is extremely friendly to new programmers, and yet has a toolset that expands as you learn more. I don't particularly love using cronjobs for processing game events, as I think a daemon is a better choice, but most folks can't install a daemon on a shared web host, which is our primary target audience. PHP is definitely not just CMS/Forums/etc.
I don't consider nginx more complicated to setup -- I generally have an easier time with setup for nginx if it's on a production system, and for a dev box both are trivial. That said my main development laptop typically has my apache service started and not nginx, because I develop many sites off of it, and several of them are on CMSes that manage their own `.htaccess` files. It wouldn't make sense for me to try and migrate all the configs in those `.htaccess`es to nginx simply so my other sites that are nginx in production can be nginx on my dev box.
Postgres can handle JSON data, allows querying and manipulation: http://www.postgresql.org/docs/9.3/static/functions-json.html 
This right here is the simple reason for so much of the complexity we see with apache configs. The structure of apache configs sucks - it's some kind of half-measure approach that is xml-ish but not really XML. The syntax of rules are inconsistent across various mods, because there isn't a simple, well-structured format for them to take. Error reporting for config problems is also very inconsistent - I've wasted way too much time searching around the docs for some mysterious error, only to find it's because one line of my config would be perfectly valid if it were used in a slightly different context, but not in the specific one I chose.
Why not use a one-to-many relationship?
*I have heard* of people who use serialize unpushing an internal serialize method version number onto the array of data to be serialized and saved, so that the unserialized array[0] element describes what scheme the array is. Which isn't efficient or anything but was still a thing. I like using serialize in my WordPress plugins to reduce my plugin DB overhead to one query (each way, in the case of POST data), but I don't do that versioning headache I just described so frequently during development I am deleting my saved options/data and starting over with a slightly different serialization.
To answer your question, you'd want to look at the following process: * Connect to your DB - See http://php.net/manual/en/pdo.connections.php * Run a query to return the items matching your parameters - see http://www.mustbebuilt.co.uk/php/select-statements-with-pdo/ However, I'm not sure that the way you're going about this is necessarily the best way for what you want to achieve. It'd involve a lot of manual inputting in the database on your behalf, and won't account for differences in formatting the zip codes. Could you let us know the following: Can you give a brief synopsis of the site, and what the user will achieve by putting in their postcode? e.g. It's a real estate website. Putting in a zip code will show all real estate in the town of that zip code
I'm I right: you want to store an undefined number of usernames for a user? Best way to do is to use a users table and a usernames table. In the usernames table, you save the users id, along with the username This way you'll have non-serialized data, but you code stays very readable.
Don't store raw serialized data or JSON. You should store the data in the database properly, i.e. divided into the appropriate columns and tables, to make the data easier to handle in the future. Storing object data as a string is just going to give you a ballache when you want to query it later.
This is not meant to sound snarky, but generally it is a good practice to only store DATA in a DATAbase. When you start storing formatting too, you open yourself up to all sorts of headaches later. If I need my data formatted into an array/json I generally write a method/function to take the raw data from the database and transform it into whatever format I need.
Yes it is a sales site that offers deals for cable, dish, etc. When they enter their zip it'll bring them to a custom page. I have developed a bot that is going to build the pages out for me with variables and I am going to build a bot that plugs all the data into mysql. I will be using a deals_city_state_zip.html file format. When they enter their zip, I want mysql to search through the db and say if the zip is 01001 and the page is hotdogs.com ( that's an example url) then I want the redirect to be to the url in the db. 
So what is the difference between these custom URLs?
I guess you're right 
I did some simple tests and JSON was faster than native serialization. I'm curious what your objects looked like (I expect JSON is faster with a more complex object since it doesn't encode member variable scope, etc) Having said that I still agree with your conclusion for the vast majority of situations. Any sort of encoded data in the DB is a pain to deal with - almost inevitably, you'll find that you do have to query against that data that you swore you'd never need to query so it's safe to store in a blob. 
For now. Things change. Also storing it the right way means you can easily add more functionality, without dealing with the bad decisions past-you made. Sorry, but I've had to spend quite a bit of time converting columns that stored JSON data into proper tables because the original dev was assured it would "never change" and was too lazy to make a second table since it "didn't matter"...so please don't do this. If there's anything I've learned being a software developer, its to always plan for things to change.
What kind of web service? What is it going to do? 
I'm sorry I didn't know that there were different kinds of web services. My app just needs to be able to get and put data into a database. Connecting the app directly to the database isn't safe, so that is why I'm using the web service.
&gt; Now since you want to make schema changes, I think its a good argument to move any database logic into stored procedures, and first update your legacy code to call these instead of hitting database tables directly. I would strongly advice against this. Debugging stored procedures is a lot harder than debugging that stuff in PHP. We have one such stored procedure application and it is no fun introducing new features or changing the schema. Decorate the stored procedure to provide logging information? Not so easy. Using a debugger and step thru? Nope, at least not with MySQL/MariaDB I think. Abstract the access to the database using PHP, not stored procedures.
great answer by /u/McGlockenshire: http://www.reddit.com/r/PHP/comments/2jagm6/guidance_needed_outdated_framework_company/cl9x68k
&gt; I won't be running queries on it. What you mean is "There are no queries on it defined in the current requirements of the application." Given what you just described, it's reasonable to think that some day there might be queries against this data. This should be kept in a relational data structure, not a big serialized dump field.
All you need is a single PHP page, then. You are going to need to learn PHP one way or another. Or use Go or Python or Ruby maybe. 
Sounds to me like you need some non relational data stored... Have you thought of something like mongo or redis? 
If the web service is going to be a communication between 2 servers then you might consider to use SOAP.
&gt; Is it safe/recommended to do this? The data will contain usernames but you could specify 1 username or 100 usernames and this is the only way I can think of that will be sensible. You're not seeing people advise that on StackOverflow for a good reason - that's one of the *worst* ways of storing that sort of data. You won't be able to query against that data at all. A one-to-many / many-to-many relationship is perfect for this.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 10. [**Patterns by Type**](https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type) of article [**Design Patterns**](https://en.wikipedia.org/wiki/Design%20Patterns): [](#sfw) --- &gt; &gt; &gt; &gt; &gt; &gt;[Creational patterns](https://en.wikipedia.org/wiki/Creational_pattern) are ones that create objects for you, rather than having you instantiate objects directly. This gives your program more flexibility in deciding which objects need to be created for a given case. &gt; &gt;* [Abstract Factory](https://en.wikipedia.org/wiki/Abstract_factory_pattern) groups object factories that have a common theme. &gt;* [Builder](https://en.wikipedia.org/wiki/Builder_pattern) constructs complex objects by separating construction and representation. &gt;* [Factory Method](https://en.wikipedia.org/wiki/Factory_method_pattern) creates objects without specifying the exact class to create. &gt;* [Prototype](https://en.wikipedia.org/wiki/Prototype_pattern) creates objects by cloning an existing object. &gt;* [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern) restricts object creation for a class to only one instance. &gt;These concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality. &gt; &gt;* [Adapter](https://en.wikipedia.org/wiki/Adapter_pattern) allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class. &gt;* [Bridge](https://en.wikipedia.org/wiki/Bridge_pattern) decouples an abstraction from its implementation so that the two can vary independently. &gt;* [Composite](https://en.wikipedia.org/wiki/Composite_pattern) composes zero-or-more similar objects so that they can be manipulated as one object. &gt;* [Decorator](https://en.wikipedia.org/wiki/Decorator_pattern) dynamically adds/overrides behaviour in an existing method of an object. &gt;* [Facade](https://en.wikipedia.org/wiki/Facade_pattern) provides a simplified interface to a large body of code. &gt;* [Flyweight](https://en.wikipedia.org/wiki/Flyweight_pattern) reduces the cost of creating and manipulating a large number of similar objects. &gt;* [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern) provides a placeholder for another object to control access, reduce cost, and reduce complexity. &gt;Most of these design patterns are specifically concerned with communication between __objects__. &gt; &gt;* [Chain of responsibility](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) delegates commands to a chain of processing objects. &gt;* [Command](https://en.wikipedia.org/wiki/Command_pattern) creates objects which encapsulate actions and parameters. &gt;* [Interpreter](https://en.wikipedia.org/wiki/Interpreter_pattern) implements a specialized language. &gt;* [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) accesses the elements of an object sequentially without exposing its underlying representation. &gt;* [Mediator](https://en.wikipedia.org/wiki/Mediator_pattern) allows [loose coupling](https://en.wikipedia.org/wiki/Loose_coupling) between classes by being the only class that has detailed knowledge of their methods. &gt;* [Memento](https://en.wikipedia.org/wiki/Memento_pattern) provides the ability to restore an object to its previous state (undo). &gt;* [Observer](https://en.wikipedia.org/wiki/Observer_pattern) is a publish/subscribe pattern which allows a number of observer objects to see an event. &gt;* [State](https://en.wikipedia.org/wiki/State_pattern) allows an object to alter its behavior when its internal state changes. &gt;* [Strategy](https://en.wikipedia.org/wiki/Strategy_pattern) allows one of a family of algorithms to be selected on-the-fly at runtime. &gt;* [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior. &gt;* [Visitor](https://en.wikipedia.org/wiki/Visitor_pattern) separates an algorithm from an object structure by moving the hierarchy of methods into one object. &gt; --- ^Interesting: [^Design ^pattern](https://en.wikipedia.org/wiki/Design_pattern) ^| [^Perl ^Design ^Patterns ^Book](https://en.wikipedia.org/wiki/Perl_Design_Patterns_Book) ^| [^Software ^design ^pattern](https://en.wikipedia.org/wiki/Software_design_pattern) ^| [^Structural ^pattern](https://en.wikipedia.org/wiki/Structural_pattern) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnendm6) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnendm6)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; You mentioned this app's been around since 1996, and the technical debt accrued hasn't sunk it yet. Is it about to? Well, technical debt isn't something that just happens all at once like an avalanche. It's effects are subtle, insidious, and occur slowly over time. Did New Feature X take 15 hours to build when on a clean architecture it would have only taken 10? No big deal. Then several months later New Feature Z takes 18 hours when with clean architecture it would have taken only 16. Again, no big deal, but things are starting to add up. You can end up crossing the design payoff line silently, and slowly, and not even realize it until you look back.
Are there any other good free PHP books? That book is not really for beginners. Can you just read the manual on php.net and then progress to that book?
I have found this useful: https://github.com/domnikl/DesignPatternsPHP It lists many patterns, and also gives examples.
Cool! Very useful, love the included UML.
I would bet the vast majority of these "statistics" are out-of-the-box cPanel shit hosting, with outdated, unmaintained WordPress (or similar) software running. It has nothing to do with PHP, except that it is the most popular language for web dev. If Python was the most popular language for web dev, then you would see Python in this headline instead. Simple as.
Like where? Pretty sure it's not standard in the U.S. or here in Europe? Edit: sorry, you were referring to the 05-01-2015 format. That does seem to be the standard in most of the world.
Yeah, I was. If you mean 2016-01-05, that's pretty common in IT. Also common practise in Japan, interestingly. 
Also, 2015-01-05 makes sorting easier. 
Going from largest time increment to smallest does seem to make more sense. It's only because we are used to Month-Day-Year in regular life that it seems weird.
Sorry this isn't entirely PHP but I like you guys... When connecting with Facebook's and other website's API (through their SDK), is the idea to store the access code on a database (or session) and the use it to build a session on every page load or is the idea to just build a session once and then remember the data? I'm a little lost on the best practices of it all.
Whether or not mail ends up in the spam folder is not dependent on whether or not you use the php mail() function or not. It's all about domain and IP reputation as well as the actual content of the emails - as others have suggested, the easiest solution here is to use a service such as Mandrill as they will tell you how to set up your DNS records for SPF and DKIM and help you to deal with blacklists. As for sending emails on behalf of someone else, this is where things get tricky. Without having the clients do any setup work, SPF and DKIM means that you need to use exactly the right combination of headers to tell the recipients server that you're sending emails as one domain, but want replies to go to another, and even then some server setups are likely to treat your mails as spam or just block them completely. This means that the most reliable way to work is to get clients to add additional DNS records to allow you to use mandrill to send emails on their behalf. The easiest method to handle this is to use a dedicated subdomain of their domain for your application. This avoids any conflicts and helps to avoid clients accidentally wiping out their own DNS records. You could also use delegation to a DNS server you control for the subdomain, which reduces the number of DNS records clients have to change and gives you much greater control to change DNS records if/when needed (for example, if you decided to switch to a service other than Mandrill, or to keep up with best practices). In my opinion storing clients SMTP details is a bad idea, and many clients will likely be reluctant to allow you to do this. (Also, clients may have setups that only allow people to send email through their SMTP servers from particular IPs, so there will likely be issues here you'll need to work around or support clients with).
Not exactly what you're asking, but a possible solution to your problem: you could just use a unique ID in the From: header and store the client's email address in the database. That way you can forward the emails to the clients and you also can measure conversion. 
I understand that, and my point still stands.
This is similar to linkedin hit-reply emails. 
That is an impressive looking library.
And yet, SQLSRV driver runs like a slow bloaty hog. I love you dblib.
Forget about storing SMTP settings. Setting DNS records? You lose 99% of your clients there. Use long unique addresses and do your internal routing/forwarding etc.
What about `From` being the servers domain/address/SMTP server and `Reply-To` being the applicants email?
I would use something like Sendgrid and set the from header to your app's generic email and the reply-to header to the client's email address
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**ISO 8601**](https://en.wikipedia.org/wiki/ISO%208601): [](#sfw) --- &gt;__ISO 8601__ *Data elements and interchange formats  Information interchange  Representation of dates and times* is an [international standard](https://en.wikipedia.org/wiki/International_standard) covering the exchange of [date](https://en.wikipedia.org/wiki/Calendar_date) and [time](https://en.wikipedia.org/wiki/Time)-related data. It was issued by the [International Organization for Standardization](https://en.wikipedia.org/wiki/International_Organization_for_Standardization) (ISO) and was first published in 1988. The purpose of this standard is to provide an unambiguous and well-defined method of representing dates and times, so as to avoid misinterpretation of numeric representations of dates and times, particularly when data are transferred between [countries with different conventions](https://en.wikipedia.org/wiki/Date_and_time_notation_by_country) for writing numeric dates and times. &gt; --- ^Interesting: [^UTC+03:30](https://en.wikipedia.org/wiki/UTC%2B03:30) ^| [^ISO ^week ^date](https://en.wikipedia.org/wiki/ISO_week_date) ^| [^UTC+02:00](https://en.wikipedia.org/wiki/UTC%2B02:00) ^| [^ISO ^2711](https://en.wikipedia.org/wiki/ISO_2711) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnf2dii) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnf2dii)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Can you use the "Reply-To" header? I've always used that in the past and never met any issues. Your "From" is still your domain.
Besides the OWASP Top 10 mentioned in another comment, the group also has a decent [PHP security cheat sheet](https://www.owasp.org/index.php/PHP_Security_Cheat_Sheet) but even that doesn't encompass everything PHP security-related. Web application security is a *really* big topic to tackle, so I'd recommend taking it in small chunks to not get overwhelmed, especially if you're just starting out. The OWASP Top 10 is a great place to start, at least from a "topics to focus on" angle. There's plenty of articles out there about how to prevent the issues it lists in PHP too. I would offer one word of warning, though. There's a *lot* of articles out there that are older and refer to things that either have been found insecure (like trying to prevent SQL injections with mysql_real_escape_string) or no longer exist in the language (like register_globals or safe_mode). Be sure to check the date on the tutorial to ensure it's relatively recent. There's also several other resources you can check out to learn more about PHP security: - [ Building Secure PHP Apps](https://leanpub.com/buildingsecurephpapps) by Ben Edmunds - the [Securing PHP series](http://securingphp.com) series (disclaimer, this is my own work) - the excellent, but sadly unfinished [Survive The Deep End: PHP Security](http://phpsecurity.readthedocs.org/en/latest/) There's also various tools that you can use to test out your PHP code and installation for security-related issues like: - [iniscan](http://github.com/psecio/iniscan) - [versionscan](http://github.com/psecio/versionscan) - [RIPS](http://rips-scanner.sourceforge.net/) (it's no longer maintained, but it can give some decent results) - The SensioLabs [security checker](https://security.sensiolabs.org/) - Roave's [security advisories tool](https://github.com/Roave/SecurityAdvisories) for Composer installs - Google's [Skipfish](https://code.google.com/p/skipfish/) web application scanner (for learning purposes) ...just to name a few. I'd also humbly suggest my own [@SecuringPHP](http://twitter.com/securingphp) Twitter account and weekly newsletter (signup on [securingphp.com](http://securingphp.com)) for tips and recent security news.
I prefer to handle this on the server side via mod security for apache, I show my WordPress devs [this article] (http://www.liquidweb.com/kb/wordpress-modsecurity-rules/) when they have a similar task to you. this works by counting failed post requests per file/location then 401ing the request before it ever instantiates the application. (helps prevent brute force where your example won't). however this information won't be accessible to the app which means you won't be able to 'lock them out' but I assure you thats a terrible idea because then anyone could then maliciously lock user accounts provided they have access to usernames.
There's no way sqlsrv is slower than dblib on windows. Do you have some more details on why dblib is better? I'm genuinely curious as way back when sqlsrv 1.0 came out, it was the bees knees, miles faster than ODBC.
&gt; I would question why you would want to specialize in this. You would mostly work with companies that have a track record of not valuing good work, where you would work with people that are obviously not very interested in learning. I've considered trying to consult on doing stuff "the right way" and I always come back to this issue. Process is broken and the wrong stuff is happening all over the place, but for the most part code ships and things work as planned (or expectations are adjusted). Selling this service is about has hard as selling deoderant: In one breath you have to tell people they stink and in the next tell them you can make them not stink. Most people get stuck on hearing that they stink. As I see it there are two possible audiences for this services: 1) Developers: They don't know or don't care that stuff is done wrong, or they are managed in an emergency culture where there isn't time to document or do long range planning. In that situation they aren't likely empowered or respected if they recommend your services. 2) Managers: Unless they have a strong IT background they simply won't understand any value in this stuff. There is better than half odds the reason the right things don't happen is because their only measure of production is feature delivery and they regard all explanations of infrastructure complexity/etc as developer whining. The key to this business is to find the unusual manager who *wants* better process, but knows his staff are too overworked or inexperienced to lead the way. Finding people with such clarity about themselves is rare. Even so, they may still have barriers to paying for it. Much better in my opinion is to seek out the market that is a little over 50% of the way there and needs a boost. Do they do 7/12 on the Joel Software Test? Good. Help them ace the rest of it. They already see value in the good processes they already have, but I would write off the companies who have near zero process maturity.
Even if we ignore all of Mandrill's features, they have *reputation*. Mandrill have a vested interest in their emails landing in the inboxes of Hotmail, Gmail and Yahoo customers and **not** in spam filters. A few years ago, I struggled to get an internally hosted platform to send emails out to people. The business' ISP hadn't separated out their IPs (Residential/Business), so the entire block was on every single blacklist out there. So, because of a third party, I was getting shit for poor deliverability. That's the sort of thing that can strike without you realising. 
I'm trying to understand this generated CRUD update method for Symfony. My form has an embedded form, im trying to understand when the changed value gets persisted, as all I see in the method is $em-&gt;flush: public function updateAction(Request $request, $id) { $em = $this-&gt;getDoctrine()-&gt;getManager(); $entity = $em-&gt;getRepository('AppBundle:EndpointInstall')-&gt;find($id); if (!$entity) { throw $this-&gt;createNotFoundException('Unable to find EndpointInstall entity.'); } $deleteForm = $this-&gt;createDeleteForm($id); $editForm = $this-&gt;createEditForm($entity); $editForm-&gt;handleRequest($request); if ($editForm-&gt;isValid()) { $em-&gt;flush(); return $this-&gt;redirect($this-&gt;generateUrl('endpoint_edit', array('id' =&gt; $id))); } return $this-&gt;render('EndpointInstall/edit.html.twig', array( 'entity' =&gt; $entity, 'edit_form' =&gt; $editForm-&gt;createView(), 'delete_form' =&gt; $deleteForm-&gt;createView(), )); }
I guess where I'm confused is in this method, I don't see any entities passed to $em to be persisted. Where is flush() being told what to write to the DB?
&gt; As for it being a standard please see the [1]ISO-8601 link below. ISO-8601 defines an international date standard of YYYY-MM-DD or YYYYMMDD. Fairly sure they meant "de facto standard", which 5/1/2015 is.
The entity is first pulled from the database using -&gt;find($id). Then it's added to the form, the form updates the entity with new data. Doctrine keeps track of all entities known to it during your request. This means that the entity received by -&gt;find($id) is known to Doctrine, running a -&gt;flush() flushes all the changes of all the entities known to Doctrine to the database. So this is including the one updated by the form. With Doctrine you only have to do a -&gt;persist() when it's a new entity.
So if I wanted to do something with the data before it was updated in the database, i should be able to do that in the if statement on line 14, before $em-&gt;flush() is called?
Why doesn't this bot generate ISO 8601 dates in the thread titles? :(
So there's two ways to go about this: 1. Log just the failed login attempts, then have a script evaluate the "last bad login" time and see if the user can be allowed access again. 2. Log all login attempts with a status. If the number of failed logins in the 5 minute time period is reached, set a "deny until" timestamp on the user record. This saves you from having to re-query the login count table which could get very large. This second option also allows you to "reset" the user just by removing that value. Remember, you also want to remove that value if they do a password reset too. Oh, and as a side note, I really hope you're not using string concatenation to create SQL statements in your application like it seems here. That's a potential SQL injection waiting to happen. Check into bound parameters/prepared statements with PDO instead.
So I've got something hacked together using Git. Not sure if it's optimal but it works pretty good. I've got a local webserver running on my computer with my git repository, here I work on my various branches and get them all debugged before going live. Once I have the approval and testing is done I merge and push these to my webserver via git. This seems to work great but the only problem is keeping the SQL database sync'ed. I have a script which will download my SQL backup and push that to my staging site. So at any time I can get my database sync'ed up to this morning when my backup went off. I'd prefer something that is a little more real time but database replication seems a bit complicated for my uses. One issue with my approach is that I work alone, so I'm not sure how the workflow would be adapted for multiple people. I'm sure it could be though. I could dig up some links if you want on how I set things up via Git. It wasn't that complicated but there was a hook or something I set up on the web server in order to get everything working right. Everything happens over ssh, so it was as easy as setting up git on both ends then a few adjustments for the hook.
We're using PHP to do datacenter automation. Out of the box enough?
We version control using Git and feature branches; anything that's merged into the master branch must be able to work in production (we deploy several times a day). We're using Fabric for deployments, to pretty much do the same things that Capistrano does: create releases and manage them. For day to day development, we use a snapshot of the production database from midnight. To ensure our clients' privacy, we strip that development copy of any sensitive information. 
Version control with trunk, tags, and branches setup. Since it's just me I use trunk for all my maintenance and minor updates. I use branches for my longer term updates or new features Tags are the only thing production runs on.
Capistrano is good. Vagrant looks good but I have not used it. Jenkins works as a tool to build packages that you can then deploy automatically or manually. If you are just starting out one of the biggest "gotchas" is database changes. You will eventually want a system to get sanitized content from production into lower environments for testing / verifying issues / performance metrics and such. You also will want a way to revision DB schemas and updates to them. Schema changes typically flow from lower environments up. So whatever process you decide on, keep DB content in mind.
Sure, it can be done, but that way you can't track replies. 
This looks like a good solution for my beginner deployment and server skills. I do am using Vagrant for local testing now, Let's see if I can combine them!
There's still a bunch of stuff you'll have to learn like ssh keys, nginx conf files, etc. But all that stuff is really easy to pick up. Good luck :)
Do you have an in dept article on this? or a good tutorial?
Correct, any changes made before the flush will be updated in the database.
"It's the only test that matters, why waste time?"
Yup, I use Vagrant to mimic a Linux box. I'd still choose Mac over Windows for development however, simply because Terminal is better, and it has Homebrew.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help.
Ooooh! I got this one! Definitely what /u/theantichris said: Capistrano. Here, I even wrote a whole book on it, free! https://leftnode.org/posts/expert-php-deployments.html
This isn't parallel processing, you're just spawning a separate process. You can't communicate with it, or receive meaningful information from it (unless you dump everything back and catch the output). Take a look at the [pthreads](http://php.net/manual/en/intro.pthreads.php) extension to see proper multithreading/parallel processing. The other alternative would be to set up a queue system using beanstalkd (or similar).
&gt; You can't communicate with it, or receive meaningful information from it (unless you dump everything back and catch the output). Sure you can. [IPC's](http://en.wikipedia.org/wiki/Inter-process_communication) exist. Other then that I agree fully, with the addition that the [PCNTL](http://php.net/manual/en/ref.pcntl.php) functions also exist. For perhaps a more old school approach. 
Funnily enough, yesterday I wrote a lame blog post about that. I am working on more computers (desktop and laptop) and I use Git to keep everything synced. On top of that, I use [FTPloy](http://ftploy.com) to watch my Bitbucket repo and upload it to my development server anytime I push a new commit. Works great. For production server, I still use FTP (yikes), because my clients still use lame shared hosting :(
Yep. I use an in-house tool inspired by Capistrano (there's a few things we needed it didn't do specific to our environment - although this was set up years ago and it probably does now), and it's a pretty decent way to get up and running quickly. The general idea was: * Clone repo at specific revision/tag/etc * Run `make local`, which downloaded some dependencies * tar up this directory * scp the tarball to a "jump box" (SSH bastion) * from the jump box, scp that tarball to all servers that are getting the release * untar on each server to a `releases/` directory * swap the `current/` symlink that the web server uses to the new release The last step is probably the most important, as it guarantees atomic deploys across releases, in contrast to just doing a remote `git pull` where some requests may see a half-updated codebase (or worse, you get some ugly merge conflict) Basically, you set up nginx (I'm sure apache would work similarly) to have `document_root` point to `somewhere/releases/current`, and that file is a symlink to `somewhere/releases/release_id` (timestamp, commit hash, whatever) As an added bonus, it makes rollbacks pretty trivial* in case something goes wrong: just point the `current` symlink back to the previous releases *unless you had incompatible DB schema changes. this is avoidable.
I have done something very similar in the past - grab a release and save into a directory named that of the Git SHA1 then symlink back to "current". To ensure this is truly atomic for a full request cycle with Nginx - be sure to use $realpath_root for document root/script path to PHP-FPM. This value will contain the resolved symlink directory/path - otherwise you do run that small risk of a user mid-request getting half/half of the previous/current app release during the symlink switch period. 
I'm guessing you need some ruby knowledge for this? 
Yes - that's a very good point. Although if you're using a typical front controller setup and your autoloader uses `__DIR__` for pathing, it's already resolved to the realpath so in practice it's not likely to be an issue (unless you change the FC script during deployment)
We (songmeanings.com) uses capistrano with webistrano. Very happy with it.
I use this too. Its an excellent product. Version 2 is coming soon 2 with an updated interface.
Ansible is awesome. &gt;Then in turn each EC2 instance is removed from the load balancer, stop Nginx, download latest archive from S3, unzip, switch symlinks, start Nginx, run some quick behavioural tests then re-add the instance to the load balancer. How do you handle the fact that some servers are running the old code? Do you use sticky sessions?
Yep, phpexcel is the easiest option. 
Thanks a lot for posting this -- I'm an engineer at Facebook working on Hack (I think we've chatted a couple times on github and IRC), and I always love hearing what people like you think of Hack, good and bad. - Would you mind to file an issue on github about any problems you ran into with collections, particularly missing API methods? The current API basically covers common use cases at FB, so feedback on what missing API methods cover use cases outside of FB -- or what might already exist and be poorly documented! -- is super useful. - Yeah, async is way way underdocumented right now. We've deliberately not said too much about it since a lot of the core APIs you need in order to really take advantage of it, like async mysql or curl calls, aren't available yet. I think async curl is in HHVM master as of a couple weeks ago, and more is on the roadmap, but that's why it's a pain to use, because a lot of it is actually just missing :) - As for generics, I think they're just hard to understand in any language :) I hope we at least emit more useful error message than other languages -- but that doesn't mean this isn't totally a fair complaint.
I worked out an easier way with a .csv format, but I was primarily having issues because I'm using CPanel to host and PHPExcel throws all sorts of fun permissions errors as a result. 
I think there's an error in your "Hello, name" program, where you're using `!=` instead of `!==`.
Seems legit.
I knew a guy who did the same shit, but didn't even bother testing his code.... Its like he would write out a few lines, commit and then turn his computer off. Hes no longer with us
Jenkins runs all our build crap then publishes over ssh. It's alright.
?
Well IPC is just an umbrella term, and sockets fall under it :) So what you are doing is essentially IPC. And yes it can be painful for anything non trivial. Depending on what you want to do there are many services that could perhaps lend a hand. I've heard some good things about Stomp/ActiveMQ for firehose type data sharing for instance. http://stomp.github.io/ http://activemq.apache.org/stomp.html 
I've been compiling a giant wishlist of features I would like to see, so I'll be sure to post them at some point. Thanks for all the help!
I use Chef. Deployments are completely automated. We have a development environment which is nearly identical to our production server, so we do all testing on there and when something is ready we merge it into the master and then do our chef run. The chef run looks something like this: (this is all triggered by a new version being available on git) 1. Make sure all vendor libs (composer, npm, bower) are up to date with their lock file (or config file) versions. 2. Run grunt to compile all the site's static assets. 3. Make a copy of the whole codebase into a revisions folder. 4. Run database migrations. 5. Update the vhost config to point at that new revision 6. Graceful reload apache. If anything is broken for any reason, then the chef run errors out but the site is unaffected since the site runs off a revision which is not swapped out until apache is reloaded. The only thing that can really take the site down is some sort of misconfiguration of apache itself which would result in the reload failing. Also, due to this structure there is zero downtime on deploys and the possibility of version mismatches between libraries, code, and the database is minimized to a window of only several seconds - when database migrations are running but apache hasn't reloaded yet. The entire server (apache, php, users, etc...) is managed by chef too, so spinning up a new server from scratch is done basically the same way that doing a deployment is - `sudo chef-client` Dev environments are managed by the same code, which even goes so far as automatically setting up hosts file redirection and cloning the production database (or using a cached local copy if available). So it's one command to set up a completely functional local development VM, and there was very little extra code to write to make this happen. All of that runs in about 16 seconds in production when there is no code update. When there is an update (and deploying happens) it's typically takes about 45 seconds unless there are a lot of vendor libs to update, in which case it might take a couple minutes. We've been using this for quite a while now and so far there have been no major issues. I've thought about writing about it since I haven't seen anyone else take this exact approach.. but that would take an awful lot of time to do I think.
What you say might be true, but google uses a compact JSON format for translate and gmail (and probably other services) that is reparsed client side before turning into JSON. You might say it is insignificant, but google disagrees and I tend to trust the master of scaling more...
You misspelled "troll". 
The real mistake was made by your parents. 
&gt;Thanks for doing this ~~Phil~~ Josh Lockhart. FTFY
Because WordPress already has a huge following and WordPress only developers refuse to use anything else.
&gt; Tabs switched to Spaces Why.
The accepted convention is that you should use whatever is appropriate. 
He is asking because the top comment called the guy by his first name and not Mr. Last name or something more casual. It's just a thing some people say especially if they believe that calling someone you don't know by their first name and nothing else is rude. It's like meeting the Prime Minister and calling him Dave or calling the president of the US, Barack. It's just unnecessarily informal. 
Is there a PDF version anywhere?
it's not so much about using what's appropriate, but using the best approach that requires the least amount of maintenance. what if, in the future, a variable compared using double equals has its type changed and would therefore need a triple equals? while in a lot of codebases the statement would be changed, there have been a few cases where the statement would be forgotten about or overlooked, leading to possible bugs or unpredictable behaviour. while I admit I was being pedantic in my original comment, my point is that using the most future proof and appropriate method, as opposed to just the most appropriate, leads to a lesser chance of bugs as well as less code refactoring. 
Can someone "sell" this book to me, explain why I need to read it? What is this book?
Thanks for your input, but I think all of this can be summarized as what /u/i_lick_dicks said. "Use whatever is appropriate."
Ok cool where can I do that? I have the PDF version from a year or two ago. I'd like to update it.
https://leanpub.com/phptherightway
Very constructive, thanks for your contribution!
It seems like the majority of this article covers setting up a WAMP/LAMP environment.. 
&gt; Tabs switched to Spaces Never!
Maybe it would make sense if you knew more about how the individual tools work?
dude, read my last comment again and he honest with yourself.
phps not good for any job, C#/Java can do everything. who would program in something that can do one thing (web) and doesn't even do that very well. doesn't make sense.
Psr-2 mandates 4 spaces instead of tabs
A good lesson and a well made video. I, as Rican1 eluded to, would be one who would argue whether you've actually made it simpler. Sure its cleaner but someone who isn't familiar with Laravel would not instantly recognise it as simpler. I appreciate however that this would, in many situations, be an easy code "base" to build from. If this is OP's blog I have since subscribed.
Allright! I'll take a look! I'm using Vagrant for my local setup, So i have to install capistrano in my vagrant box rather than on my host machine? 
Nar, "stain".
Sure, but the American date standard is **stupid**. I mean, it really is. No other numerical standard I know of is not in order of scale, one way or another. I don't care if it's what you know, it's dumb. Stop it. If you must, use YYYY-MM-DD for clarity, because absolutely *no-one* uses YYYY-DD-MM. Because that would be nuts. Just like MM-DD-YYYY.
So that your code is readable on all platforms, no matter how tabs are interpreted. If you make a tab midway through a tab-stop, then that code is going to line up differently if you have tabs at 2, 4, or 8 -- and it will look horrible, guaranteed, on any other tab width than your own. The most important feature of any code is that it is readable easily by humans.
Text encoding issue at the top of p9 of the PDF version: &gt; Your project will likely use several of them  these are project dependencies 
Tnx, I will check it
Oh. I've build desktop GUI apps with PHP. But then again, if you've head up your own arse, how would you know? 
Why not tabs for line indenting (So, always at the beginning of a line), and spaces when you want to align things (=&gt; when you work with associative array, for example) ? if ($test) { tt$variable = array("key"sssssss =&gt; "value", ttssssssssssssssssss"myOtherkey" =&gt; "otherValue") } Where "t" is a tabulation and "s" is a space. The advantages of tabs is that everybody can chose the size of them, the advantages of spaces is that they will always look the same no matter the environment.
Quick /u/konrain, delete this post too before anyone else sees how dumb you look!
The argument of "because so- and-so" does it is not a valid reason. As mom always said, would you jump off a bridge because your friends do it? You seemed to miss my entire point, which was that a parsing library written in PHP, is not going to be as performant as it would be if written as a C extension. I guarantee you Google doesn't do it in native PHP. Neither would Facebook for that matter. ;) I've taken a cursory look into Google's [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview), and I see that it is a binary representation of data. I would say that this goes to prove my point, since their protocol buffers are compiled into binary format. Also, the compiler and such are written in C++. Also, I never said that this library was insignificant. I did say it was a novelty, and let me explain why: At first glance, when reading the [README](https://github.com/eixom/php-jsonlite/blob/master/README.md) on github, it does not do anything to sell me on the idea of using this library over another - more established - protocol. The examples are very contrived, and do not demonstrate any practical real-world purpose. As a developer in a business, I'd have a difficult time selling the decision makers on using this library for any practical purpose. As a hobbyist, for personal purposes, I might try it out to see what's going on with the library; hence, novelty. Edit: spelling, more words
&gt; If you make a tab midway through a tab-stop Don't do that.
I use capistrano at work which is ruby based but that has caused a few problems since our ruby guy left and when we had a few bugs when deploying our sites. http://rocketeer.autopergamene.eu/#/docs/rocketeer/README This was posted here a month or so back and will be looking into it for a personal project but have yet to actually try it so cannot full comment on it yet.
Yes. I use Vagrant, also. Here is the manifest I use for Ruby: https://github.com/theantichris/Puppet-Modules/blob/master/puppet/modules/ruby/manifests/init.pp Put a Gemfile in your Vagrant root like this and the manifest will install Capistrano when provisioned: https://github.com/theantichris/game-collection/blob/master/Gemfile 
 it really depends ... are we talking few transactional emails? then both mail() or smtp or equally valid, just make sure the mailserver is setup correctly using both SPF and DKIM if you care about spam-detection. are we talking 10k+emails/hour ? use a service like Sendgrid, mailchimp, emarsys, mandril etc ... they are more expensive but do the job very good. Are we talking more than 500k mails / day ? either find an admin who knows mailservers or any ISP that has mailservers as a managed service, if you have european customers make sure that he is in the CSA (Senders alliance) as this is basically a whitelist for the bigger european Mail-SPs. Make sure you warm your servers up correctly (dont start sendingng with high volumes instantly) and cluster your outgoing mails by email domain, throttling some domains (like yahoo) slower than others. this is the CHEAPER way ... still services like Sendgrid/mailchimp/emarsys etc do a fine job just much more expensive. In the beginning SendGrid is probably the easiest and most reliable option (as its CSA certified for europe) if you want to send transactional emails, and mailchimp is a very good alternative if you want to send newsletters.
please dont use a DB for that, use memcache or any other NoSQL
Another vote for DeployHQ, we use it, it is great.
Damn 1&amp;1 DNS! @willwashburn, are you still facing the same problem or is the domain resolution ok? (I'm Packanalyst lead-developer and I need to know if I must take action or if it's just a DNS cache issue).
&gt; Also comparing two strings together nothing will be casted. Not true, try the following: echo "0e4839487598734" == "0e8349752838744"; They will both get casted to integers, and because they both are 0 as an integer, the end result will be that those two strings are equal according to that operator. I'd be willing to go as far as to say: the == operator almost never does what you want it to do. So unless you can fully explain == behavior and have a good reason for using it, just avoid that operator and use ===, which will actually do what you expect it to do. For the technical details, take a look at the [compare_function](https://github.com/php/php-src/blob/master/Zend/zend_operators.c#L1706) function in the PHP source code. Eventually you should find the [string vs string case](https://github.com/php/php-src/blob/master/Zend/zend_operators.c#L1758) in which the function [zendi_smart_strcmp](https://github.com/php/php-src/blob/master/Zend/zend_operators.c#L2515) is called, which will only compare two strings as strings if they aren't equal as doubles or integers. Generally I'd say though, looking through compare_function, there are way too many edge cases and branches in that function to get a nice mental model in your head of what it is supposed to be doing.
I would've used them if chaining them together didn't result in such hard to read code. I had originally done the refactoring in Ruby where arrays are objects out of the box, and resorting back to the inside-out chaining you have to do with PHP's array functions made me sad :) Especially with the intermediary refactoring to `reduce`, this is what the code would've looked like at one point: $user_score = array_reduce(array_map(function($event) { return $event['type']; }, $events), function($sum, $score) use ($scores) { return $sum + isset($scores[$type]) ? $scores[$type] : 1; }, 0); Hopefully we get some of this stuff in 7.x and we won't need to use third-party array objects: https://github.com/nikic/scalar_objects
Looks good! I'll have to check it out in more depth at some point.
"Chaining them together" need not be the goal. Here's a readable variation of the example you give, split across multiple lines: $map_func = function($event) { return $event['type']; }; $reduce_func = function($sum, $score) use ($scores) { return $sum + isset($scores[$type]) ? $scores[$type] : 1; }; $map = array_map($map_func, $events); $user_score = array_reduce($map, $reduce_func, 0); Not "such hard to read code" after all.
Hey Paul! Yeah this is nicer I agree, I still prefer reading the chained version myself though. This was my original refactoring in Ruby: user_score = result.map { |e| scores.fetch(e['type'], 1) }.reduce :+
I disagree. I looked at the Laravel collections library that was used, and it scared me. As in I can see its usefulness, but it's huge and misses a lot of what could be done (and should be done). I'd avoid it. But I don't think that detracts from the usefulness of the demonstration, and that's why I didn't comment to it. The collection object as used in the video is easy to understand. There's really no difference between `$events-&gt;map(...)` and `array_map(..., $events)`. Yes, one uses a built-in tool, and one uses a library. But if you understand one, the other should be obvious. The concept however is what's interesting. And I think that was demonstrated **really** well, no matter the tooling used. And that's why I posted this.
ultra pedantic. Refactoring conditionals by means of polymorphism is noble but this is not the example to express it. This is the equivalent of the interviewer telling you "hey write a function to sort elements of an array", and you just use http://php.net/sort
I agree with your concern, but I don't feel like it should be up to the language implementation to prevent (or care at all about) bad OO design decisions. That's the developer's job.
ircmaxell had mentioned this as well and we had a brief conversation about it in the blog comments: http://adamwathan.me/2015/01/01/refactoring-loops-and-conditionals#comment-1773978084 In short, I left it as multiple operations really just to demonstrate more clearly the sorts of cool things you can do by chaining these array transformations, and thinking about them as steps in a series, each with one small job. I totally agree you could and probably should just do it in one step ultimately. Saves another loop and is still simple enough to be easy to follow.
You mean David "call me Dave" Cameron? I would totally call him Dave.
It was born through reddit, a bit like imgur. 'nuff said :-)
Are you trying to cause trouble? That's the kind of thing that trouble-makers say. There will now be tears and blood by the time this thread is over.
Urgh! Indenting should be about the structure of the code, not some arbitrary random indenting that happens to depend on the length of a variable name five lines up.
This is an interesting one. The jekyll build process is putting those into the HTML, as is LeanPub. The original Markdown just has standard `-` not a fancy ``.
If you want a funny read, it's [mostly this](https://philsturgeon.uk/personal/2014/11/15/alien-status-extraordinary-again/). Further information before that is in [this earlier article](https://philsturgeon.uk/personal/2014/08/04/i-was-an-extraordinary-alien-for-a-week/), which gives a bit of interesting insight into how hard the US visa process can be. All good now though! :)
Thanks :)
Even when `"0" == "0.0"` is true?
Ok, then an alternative to array_map would be to use PHP 5.5+ array_column :) $reduce_func = function ($res, $type) use ($scores) { return $res + (isset($scores[$type]) ? $scores[$type] : 1); }; $types = array_column($result, 'type'); $user_score = array_reduce($types, $reduce_func, 0);
Haha awesome. So did you not really?
Damn auto correct! Yes I did mean ***virtualizing*** lol! Well originally I am a Linux Sys Admin, and this caught my eye as I was reading into [PHP The Right Way](http://www.phptherightway.com/). The ability to move servers at the run of a script - without any dependency issues, or having some hefty Chef recipes. Also then being able to have *real time* apps running using web sockets. It sounds like something I ***should*** be using - but am currently not
I said thanks Phil because I know there are a some people in the community who can't say anything positive about you or your work (as seen in the first comment when this got posted). I just thought it would be nice to thank Phil for all the hard work he probably put into this (and post the link to this sub-reddit). This does not mean I have no respect or neglect the work the other writers/moderators put into it. So: Thank you Kris Jordan and Josh Lockhart, you guys do a splendid job. About calling Phil Sturgeon "Phil": Again not trying to be disrespectful. Everything I read about the guy makes me feel like he's an easy going guy and wouldn't mind it that much. That should about cover those 5 words. 
Haha, yeah sounds like it! You - and anyone else - is absolutely welcome to call me Phil. Crazy people around here. :)
Yes, you *should* be virtualizing your environment for non-trivial codebases. If all you're doing is running a single install of Wordpress with vanilla MySQL then maybe it's overkill. If you're not familiar with the details of virtualization, I wrote a few things: https://jtreminio.com/2013/05/introduction_to_vagrant_puppet_and_introducing_puphpet_a_simple_to_use_vagrant_puppet_gui_configurator/ https://jtreminio.com/2013/06/make_vagrant_up_yours/ Once you're ready to jump into creating your own virtualized environment, I also wrote something for that: https://puphpet.com
But then we'll have more people whining about how PHP encourages writing shitty software.
Thanks for sharing Chris! If anyone has any questions, I'm happy to answer them (as the author of this package).
Well, I wanted to point out the nuance about what the difference is...you don't always want a strict equality check despite what the beginner tutorials say :) if that were the case they'd deprecate == and !=. Just thought it might help someone.
You're right. I'm glad you brought this up. This could be a desired result though if you wanted to regard those as equal (0.0 would be coerced to value 0 if converted to a numeric type.)
(On my phone so this won't be well written) What is it with people thinking that HATEOS is required for or is rest. HATEOS is NOT rest, nor is it needed for a resource to be considered restful. Rest is what is defined in the original spec, and most APIs that call themselves rest APIs ARE restful, the spec is not very strict. Please stop enforcing this idea that REST needs HATEOS, it's just bullshit.
Agreed, which is why Glide comes with [signing key](http://glide.thephpleague.com/config/secure-images/) support. The examples on the documentation website are intentionally not signed so that developers can test Glide.
Ok we can play this game. &gt; "By Josh Lockhart and Phil Sturgeon" I didn't make the cover, Josh did. &gt; If we look at the actual contribution page, you only have four commits: Which is why I said 2012 and 2013. 2014 was all traveling and visa drama. I wrote a _lot_ of that website, over 1200 lines according to the statistics Josh Lockhart wrote into my visa support letter as evidence, but in the last year my position has switched to moderation and advice. Can't tell you where those commits have gone, but I wrote at least 1/3rd of that website. &gt; I think it's a bit unfair to the other contributors who aren't even mentioned other than as "contributors from the open source PHP community", especially since their contributions so vastly outweigh your own. We already list all contributors on the website in the "Credits" section. If you'd like to PR the conversion script I added to get their names dynamically into the thanks section of the book then crack on, otherwise it'll stay as it is. This is a ebook export script, which I built, for a project I am a named collaborator on, and released under my LeanPub account because it had to go somewhere. You really really want to try and make me look like some sort of ego-theif douchebag, but you're clutching at straws.
This is great - I've been looking for something like this for a long time. I didn't want to use one of the more antiquated libraries like TimThumb. I've resolved to use one of the services that has something similar (http://uploadcare.com) but I'm surely going to be implementing this library soon.
I'm not un-calm, just the same of expectedly annoyed by accusations on Reddit. I'm stealing credit, I'm forcing other people to submit work under my brand, I'm selling a book which violates licensing terms. All of these accusations as constant. Anyhow, I remembered the a change of email address causes GitHub to fall over. So: &gt; $ git shortlog -s -n --email &gt; 238 Phil Sturgeon &lt;email@philsturgeon.co.uk&gt; &gt; 84 = &lt;info@joshlockhart.com&gt; &gt; 66 Phil Sturgeon &lt;philsturgeon@users.noreply.github.com&gt; &gt; 66 Josh Lockhart &lt;info@joshlockhart.com&gt; &gt; 33 Kris Jordan &lt;krisjordan@gmail.com&gt; I think us changing our email address didn't help those stats. I'm missing a few thanks to that. I know exactly why my name is on the cover, and it's because I deserved it and Josh was attributing me accordingly, not because I decided to put it there. I'll make an issue to try and auto-populate a list of committers into the book somewhere, but I'm not gonna do that for quite some time. 
ApiGen is my usual choice.
You'd have to talk to Josh and Kris about that. The two of them work together, so they're perfectly capable of discussing if one of them should go on a cover that the other made. And yes, I do think you're being unreasonable. You are "just asking some questions" but they all come from the basis that I am doing something unreasonable. That's the bit I'm taking exception to.
While I'm glad the option to use a key is available, I feel that for most users, specifying the configuration via the URL is fine as long as there are sanity checks in place (which, based on the documentation, there appear to be).
Mmmmh today if you implement `ArrayAccess` and reject values in `offsetSet()`, then you are already violating LSP. The thing is that 90% of the LSP can be done today with `ArrayAccess`, `Traversable` and `Countable`. I just want the 10% left.
What I'm more interested in is how to translate config file entries to handlers. Simple if/else with logic along the lines of if ($handler === 'streamhandler') { $thisHandler = new StreamHandler(...) }? I'm creating one Logger instance per class as opposed to using a shared instance. Is this a good idea and is the builder candidate better here?
I wouldn't use this on the front end, just keep it for back-end admins. This library would be handy to generate all the required image copies, and then store those in a DB ready for passing to the HTML. 
Part 0: http://marcofiset.com/programming-language-implementation-part-0-setup/ Part 1: http://marcofiset.com/programming-language-implementation-part-1-lexer/
There's also compiling php with dtrace and running it on OSX or BSD. 
I was recently looking for exactly this and I only found https://github.com/imbo/imbo, great to have options! I'll defenitely look into Glide. how stable/production-ready is it? best points vs imbo or other alternatives you may know? thanks for your work!
How do you test these final classes then? You can't mock em.
I believe this is why the suggestion here is interfaces. You can't mock the final but you can mock the interface that the final implements. Code which depends upon the final implementation should typehint for the interface. If that isn't your cup of tea, Mockery provides a proxy mock capability which might be one way around the limitation. 
Make sure when implementing that that you are passing the right IP address to PHP. It is very easy to mess up and use the one of your reverse proxy or load balancer and still lock everybody out.
Dtrace is great, phptrace is more convenient especially on linux
Have you tried https://laracasts.com/? I find the content to be of very high quality. Some of the videos are targeting the Laravel framework, but there is much framwork agnostic videos too. The larevel videos are often applicable to other situations as well. I also learned a lot (especially about tooling) from [PHP The Right Way](http://www.phptherightway.com/), and [Tuts+](http://code.tutsplus.com/categories/php/courses) is also a great resource. EDIT: Check out http://code.tutsplus.com/courses/agile-design-patterns and https://laracasts.com/collections/design-patterns if you are interested in how to implement specific design patterns with PHP.
all of the things you listed seem to show you are on the right path. &gt; I'm watching youtube videos regularly to try and improve upon my knowledge and skills but few of this information is in php, it's frequently in a lisp like language (JavaScript, Python, etc.). that's great! you're always looking to learn something new. here's the problem though: a lot of people want to learn just by watching a youtube video or skimming through an article: absorbing all information. it's not like that. you need to start writing code. reading about best practices. implementing them. try solving the same problem in different languages. experiment with different design patterns. most of all, **just do something**. you can't dig a hole by just looking at the dirt and not picking up the shovel and going in.
&gt;lisp like language (JavaScript, Python, etc.) [wat](http://i.imgur.com/synonSr.png)
Your comments have been most insightful. Thank you. Just out of curiosity, what's your preferred method? Bonus, if IoC with DiC, which DiC? I'm using dice right now and quite happy with it
Wow very cool. Thanks for this. I've been throwing around the idea of building a toy language in D. This is great reference.
&gt; how stable/production-ready is it? I would say it's very much production ready, and I'm hoping quite stable, especially given the high test coverage. Having said that, it's still very new and hasn't been battle tested yet, meaning it's quite possible that a few bugs exist. This is why I haven't tagged version 1.0 yet, as I suspect a few features could be tweaked or added and small bugs fixed in the next little while. &gt; best points vs imbo or other alternatives you may know? Very hard to say, considering this is the first I've heard of imbo. A quick glance tells me that imbo has bitten off a little more than I have with Glide. It appears imbo provides image uploading, editing and deleting support, editing of meta data and more. Glide simply handles the manipulation and output of images, nothing else. It also appears that imbo is meant to run as it's own client/server, where Glide was more designed to work within an existing project. Not that Glide cannot be setup as it's own image server, it certainly can, but it's nimble enough to be added to a route of an existing app. Also, I cannot tell if imbo offers any sort of cloud storage. This was really important for me with Glide. I wanted to be able to store both the source and cached images anywhere I wanted, an in particular on Amazon S3. Glide makes this process painless by using the [Flysystem](http://flysystem.thephpleague.com/) file abstraction library. I hope that answers your questions!
You only have two hands Mr. Puppet Master, leave your vim using team members be.
Yeah, it's very much a modern day TimThumb, except if I'm honest I got my inspiration more from services like [Imgix](http://www.imgix.com/) and [Cloudinary](http://cloudinary.com/) than TimThumb. Glad to hear you're going to give it a try, hit me up if you have any questions.
And you're welcome to use it that way. While Glide is designed to be used as an HTTP based API, it can also be used using straight PHP as well. The example shown [on this page](http://glide.thephpleague.com/config/basic-usage/#accepted-method-parameters) gives you an idea of how that's done.
That what makes drupal so vulnerable. You can index a sites images and presets and give it a big instant whack.
Now that you've read all the comments. Try to understand how deeply you are in the wrong and how dangerous your position is for the stability of your team and your own employment.
This looks great. Nice work!
&gt; archaic tools such as VIM What the heck is archaic about a tool I can use with twice the efficiency of everything else you listed?
Yes. Enforce conventions not environment.
Of all of the points the author makes, there's only one or two that are actually good reasons to use `final`. A lot of the points are just passive-aggressive programming. I don't sit down and think "How can I keep other programmers from fucking this up?" every time I have to write code. For me, the real reasons for using `final` are points 6 and 8. In regards to point 6 (`extends` breaks encapsulation), any class that may be extended should explicitly state how it should be extended. Point 8 (you are free to change the code) is the absolute best reason for marking a class as `final`. If I write a database service, I don't want to worry about breaking child classes if I have to refactor it. But as I said before, most of the time, simply writing guidelines for how your classes should be extended is a far better solution than forcing composition (and re-composition ad infinitum).
Is this a joke? Why does an ide matter? You should say use whatever you are the most productive in. You sound like a micro manager get ready for unhappy developers and low productivity and code quality.
10/10 Nice troll. 
Why can't you configure using PHP? You said you use Dice, can you use PHP code with Dice? Else give a try at [Pimple](http://pimple.sensiolabs.org/) or [PHP-DI](http://php-di.org/).
I would quit your company **so hard**. You **never** dictate what dev tools a developer uses. I mean, are you kidding me?
I've been using vim for over a decade. At my last job, everyone loved PHPStorm so much, and *it has sweet vim support!* so I finally gave it an honest shot. A real shot, not a trial run. For 6 full months I used PHPStorm. I customized everything available and embraced the change. The vim emulation sucks (surprise, they always do), but the last straw for me was when the big new feature people were talking about was the Vagrant integration. This was, after all, an example of why the switch was worthwhile! The Vagrant integration amounted to menu options in the GUI that executed `vagrant up`, `vagrant halt` and `vagrant reload`. Definitely not impressed, but it highlighted for me that I'll never see these "features" the way the proponents do. So back to vim. This was like 18 months ago or so. I've got autocomplete, offline help, ctags, a variety of project searches (ag, ack-grep, grep, with all the flexibility of each). The only things I miss are some of the refactoring tools; those came in handy.
Tell me and I forget. Teach me and I remember. Involve me and I learn.
Someone really needs to check out [.editorconfig](http://editorconfig.org/). Also, try not to poop your pants with excitement when you finally stumble on [Composer](https://getcomposer.org/) too.
Another take away from this post is to make sure you have interfaces cover all public methods of a class.
Is that not what I said? Not sure why downvotes. 
Learn something fairly different. I've been enjoying elixir. Functional built on top of erlang but with some nice rubyesque metaprogramming. http://elixir-lang.org/
I Like [XenForo](https://xenforo.com/) but it's not open source :( [FluxBB](http://fluxbb.org/) seems like a good forum software (I didn't try it but I heard about it a lot). It's [open source](https://github.com/fluxbb/fluxbb) and also this forum has a [converter](https://github.com/fluxbb/converter) from PHPBB to FluxBB. 
do something good for your back, learn juggling! it not only helps your back but also raises concentration [in the period after] its perfect for short breaks too, also a good thing to socialize in the park ;)
Hi. Are there any resources for a website where this is currently used? For instance, we were using TimThumb on our old server but it started running out of RAM (possibly a bad file, we still don't know), but the SuPHP requests would stack up and eat the RAM, causing it to crash. We have since switched to a 64GB RAM server, and are using DSO for PHP (but this may change back soon), and I was very interested in using your library in a queue system, but to be honest I don't know where to start! I have never done anything queue based before. I know that Laravel has a queue system but that is all I know. Do you have any words of advice on a way forward? By the way, it looks like a great library and EXACTLY what we need. Dynamic, on the fly, cached, image resizing to make multiple size images available for our website.
Yes, that's A solution to the fact that you can't mock a final class. A much simpler solution that doesn't bloat up your project with for-tests-only interfaces: don't use final. Amirite? Haven't seen the proxy mock feature, thanks, will look into it.
\o/
 $handler = 'StreamHandler'; $thisHandler = new $handler();
I would say [http://www.phpdoc.org/](http://www.phpdoc.org/) is the most common.
[Flarum](http://flarum.org/) doesn't include the ability to import at the moment but i believe they do plan on adding it.
I've seen people advocate final classes and private (instead of protected) visibility, both for ideological and not practical reasons. In reality, no class is ever so small&amp;simple that my reimplementation won't need to share any code with the original. So I end up copy-pasting 50 or more lines of private helper functions just because I wanted to change the behavior of that single public method. It gets worse if the final class has several public methods, and I only need to change one. Someone wrote in the blog post comments: "I'd rather just copy the entire class body and commit it to my own code-base. Copy-paste is still a better solution than inheritance". So, some people find that to be desired. I don't. Furthermore, once I've pulled in the library into my project via Composer, what I do with it is my business, and I should have the power to decide whether inheritance is good for my specific use case or not. Forcing me to copy-paste instead feels limiting for no gain. 
I'd like to understand how the signing key works. Is a unique token generated for each combination of parameters, with the token only being calculable if you know the signing key (which is kept securely on the server)? So any combination of parameters that does not include the correct token will be treated as incorrect or unsecured? Presumably, these URLs will need to be generated on-the-fly always, because if your signing key gets found out, you would need to change it, and so any URLs with the token stored in them would no longer work. Or perhaps you have got around this by checking whether the file is cached already regardless of whether the token is valid for the parameters, and delivering that cached image. Or maybe multiple signing keys are needed - one for generating new images, and a bunch of others that allow read-only access to already-cached images. Am I making sense here? Basically, if the ability to access an image (manipulated according to parameters) relies on a token in the URL, and that token could be withdrawn if the key used to generate it has to be changed, then there will potentially be a bunch of URLs out there that will no longer work. It would be nice if they continue to work.
Imbo is meant to run as it's own server, usually by having one imbo installation shared for all the projects where you want to use images and their derived forms. The client libraries are for storing images in Imbo and for generating the URLs to serve them from Imbo (for the browser). We (in a loose sense, since I've written a few transformations and done a small amount of design work while under development) do not have any inherent editing support (as the whole installation is interfaced through a REST based HTTP interface), except for what the available transformations provide (meaning you can ask for a cropped version of a image, etc.) There is a [S3 storage adapter](https://github.com/imbo/imbo/blob/develop/library/Imbo/Storage/S3.php) if you want to use cloud storage as your backend (as well as regular file system, GridFS, etc.). Imbo is also suitable for high volume web sites, where you'll have varnish in front of your installation. It does however cache stuff internally, so even without Varnish performance should be decent.
I'm not the original poster, but we also use request parameter signing in several applications. &gt; Is a unique token generated for each combination of parameters, with the token only being calculable if you know the signing key (which is kept securely on the server)? So any combination of parameters that does not include the correct token will be treated as incorrect or unsecured? Yes. &gt; Basically, if the ability to access an image (manipulated according to parameters) relies on a token in the URL, and that token could be withdrawn if the key used to generate it has to be changed, then there will potentially be a bunch of URLs out there that will no longer work. It would be nice if they continue to work. You can do that - keep the old signing key around, and accept requests signed by that key for resources created before a given date. Another option is to keep a list of valid keys (and their signed content) that have been used recently. We also use varnish to keep live versions of old URLs active as long as they're still seing regular requests. The preferred solution will be a trade-off between security, storage and speed.
 &gt; what I do with it is my business Only once you pulled it in your library, but what the original developer does with that class is his own business, as long as he maintains the public API unchanged.
A friend of mine just linked this thread to me. I'm not running a devops company, but sysops one and as a contrary to the topic I'm forcing VIM as the only editor. All the environments have it installed and configured one way, so anytime I'm reviewing systems I have everything in the same order. The uniformity of the configuration files, scripts and whatever sysops do entails enhanced security and lowers the risk of mistakes. But you pick the tool basing on the work you're going to do. I have no experience in running anything related seriously to devops, I was never a developer. The devops is way more creative than sysops ever was, so I believe in this department forcing stuff might kill part of the spark...
I've been using modernbb. All themes they include are also responsive
From a quick glance at the README sounds like something similar to https://github.com/rosstuck/tactician Would be really great if you two could team up and create one wonderful command bus from it.
&gt; And what about the decorate/delegate/proxy hell that is the result and makes it far more complicated to find the method that actually does something? Except for state-handling proxies, proxying should happen at interface level anyway. &gt; To me the nice thing that makes PHP superior to e.g. Java is not the language in it self but the attitude to let you make things the easy way. Print a number? Just use it in a string. The Java way? Create a string builder, fetch a number formater thru a factory, create the string, 20 LOCs written ... That is still true even when applying `final`, tbh: it actually is even easier to learn, as the rules get greatly simplified, and there is no such thing as deciding between `static::` and `self::`, or problems that require you to use `get_class($this)` because `__CLASS__` is unreliable. I don't see a complication here. If your programming model is monkey-patching, then copy-paste is still superior when compared to inheritance. &gt; The same with your articles. Fluent interface? Could make code smaller and classes easier to use, so it is bad. Inheritance? All other programmers suck, so let them write tons of boiler-plate code so they can learn great patterns like decorator/proxy/whatever. That's your choice, but that also cuts the line between writing small websites and complex scenarios that require some decent domain modeling. You are free to keep working on the websites part: that is something that I indeed do not like writing myself.
&gt; &gt; The same with your articles. Fluent interface? Could make code smaller and classes easier to use, so it is bad. Inheritance? All other programmers suck, so let them write tons of boiler-plate code so they can learn great patterns like decorator/proxy/whatever. &gt; That's your choice, but that also cuts the line between writing small websites and complex scenarios that require some decent domain modeling. You are free to keep working on the websites part: that is something that I indeed do not like writing myself. That has nothing to do with websites stuff and domain modeling at all. I just prefer stuff that exposes an easy-to-use interface over packages that miss the final step. After all a package should be used and not only have some interface that applies strictly to patterns without actually considering the users perspective (and thus requires tons of boiler plate to use).
Visual Studio 2013 Community Edition with PHP TOOLS plugin
Imagine this: my "origin" (blog for example) www.superblog.com/imge1.jpg Server with glide: myglideserver.com Settings: Tell glide that images.myglidserver.com/* load images from superblog.com (resized, watermarked) for example. So in your blog you just "rewrite" urls from: superblog.com to: myglideserver.com and you are done :)
The user-facing part is typically solved by providing either a Faade or a factory that simplifies execution (in case of non-required abstractions) or returns an instance of a particular interface inside of a package. I don't see a problem with that?
Last I knew it was [the equivalent of a menstruating hippo in a swimming pool of sharks](https://www.google.co.uk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=phpbb+security+vulnerabilities) from a security standpoint..
That would be amazing :) 
Well, this project is VERY new, so suggestions are certainly welcome. :) I hadn't really considered splitting cached images into separate folders, but I don't think this would take too much to implement. Feel free to open a ticket [on Github](https://github.com/thephpleague/glide/issues) to get some brainstorming going on this.
[myBB](http://www.mybb.com/) is pretty good. It's being actively developed, just recently released a new major version with a ton of changes and improvements. &amp;nbsp; It has a ton of plugins and themes. Pretty much everything is customizable. For example, [this](http://www.pcmasterrace.net/) is one of my favorite themes, considering it has almost nothing in common with the default templates and styles.
Someone stole my idea :D
Allow everything, support only PHPStorm. What does it mean? Say you have to follow a certain codesniffer standard (psr-2 comes to mind) or setup remote debugging etc. Information how to setup this things have to be in some kind of company knowledge base (if nothing else then to bring new employee up to speed). - it is not feasible to maintain this documentation for every editor (phpstorm, netbeans, eclipse, vim, you name it) - choose 1-2 IDEs you support (probably just PHPStorm) - leave the rest to setup it on their own This way, the PHPStorm usage is encouraged and 'vim' users are allowed to use their IDE without costing company extra time/money/effort. EDIT: psr-2, not psr-3 :)
No no, I opened it because of you!
oh, hehe ok :)
Are they large files? I wouldn't use this on giant files, but if they are small you could simply: $file_contents = file_get_contents($file_name); # Foreach loop here $file_contents = str_replace('old data', 'new data', $file_contents); file_put_contents($file_name, $file_contents);
&gt; The user-facing part is typically solved by providing either a Faade or a factory that simplifies execution (in case of non-required abstractions) or returns an instance of a particular interface inside of a package. I don't see a problem with that? Needing to build an extra class so the user can actually use your classes seems like a superior design decision.
You could just use an IDE to make the replacements. I use Netbeans and it would work great for a find and replace across different file types. You could use others like Atom or Eclipse
What about multiple php files? Like maybe 1000-2000. Would that run for ever and or brick my shit? 
sed can do it from the console easy From [Howto wikia](http://how-to.wikia.com/wiki/Howto_use_find_and_sed_to_make_a_replace_in_multiple_files) find . -name "*.c" -exec sed -i "s/oldWord/newWord/g" '{}' \;
I think that /u/Rygu's point is that a class being tested should not be modified purely for the purpose of being testable. So if your class already implements an interface, adding final and mocking the interface instead of the class itself is fine. Extracting an interface from a class *for no reason other than* the ability to add `final` and still mock it is not.
 &gt; This kinda sucks But it's still more stable than extending and depending on protected API changes ;-) &gt; What you suggest is just copying the whole class over I do, indeed.
I use Consolibyte's dev kit and actually had to modify / override it some to get it to fit in to my own multi-tenant application, which does a bit more than you described. In my case I have to take orders from one system and convert them into Customers, Vendors, Invoices and Purchase Orders and Items (including passing in Cost and Sale Price)...and also keep them in sync if any change in the source system. On top of that I also have to deal with Tax Rates - both domestic (US) and international. If you thought the US tax system was tough to swallow... Unfortunate, working with the QBO API is not trivial, and there are some long standing bugs that Intuit has yet to get to (such as the inability to work with custom PO fields). They actually had a meet and greet here last night that I would have gone to if I wasn't already scheduled for something else. Anyway, your question is kind of generic and doesn't tell us what leg of the OAuth you're struggling with. The initial tokens are to be used for the purposes of getting the customer to grant you access to their account, and then you're provided with grant tokens good for 180 days. It almost sounds like you're using initial tokens incorrectly, but I don't think I have enough info. Do you guys have a budget for a little outside help on this? 
If you already specifically cast it yourself, the step to just do this: $mapped = array_map($callable, $collection-&gt;toArray()); isn't much more work. What I'd really like to have is this: $mapped = array_map($callable, $collection); And do this for __toString() as well. PS. yes, I see the point of using (array) cast, since that is a standard approach, while the 'toArray()' method could just as easily be called 'getAsArray()' or 'JonDiFool()'.
Everyone who has responded so far is pouring on a lot of hate, so I'll come in with a different angle. I understand what you're trying to do, and there is a lot of merit in standardizing the development *environment* for a project multiple people are working on to help ensure all development environments are the same and to help development match production, etc. Standardizing tools though, and forcing all team members to use the same ones is a mistake. You can *encourage* the use of PHPStorm by providing a free license, etc. but a programmer's editor is a deeply personal thing, and they have likely invested a lot of time into learning the ins and outs of their favorite editor. To get an idea of what you're asking, imagine telling someone that has used Android for many years and has invested countless hours learning the ins and out of all the settings, invested money in custom apps they have downloaded, has favorite apps they love using, etc. that you have decided iOS is better, and are going to force them to switch. Can you imagine? This is what you are asking of your developers by forcing a new editor/IDE upon them. As for vim/emacs, I personally switched from Sublime Text to vim four years ago, and it has improved my efficiency significantly. Having to go back to using a mouse would slow me down a ton. Lots of people underestimate the amount of time and how many motions are wasted going back and forth between the mouse and keyboard. Vim may be "old", but that doesn't automatically mean it's bad. Vim and emacs were specifically designed by programmers for efficiency. There are lots of plugins that make vim a very good editor with nearly all the same (and in some cases even more) features than most IDEs have. Additionally, vim/emacs can be used directly over SSH on remote servers - something GUI editors and IDEs can never do. So to answer the question directly, YES it is absolutely still acceptable to use vim/emacs in 2015, and for at least another 20 years too.
Horizontal scrolling on mobile. Have to bookmark to read later. Not good on 2015.
The primary reason I prefer to use `(array)` vs `toArray()` is that you can use `(array)` on a scalar value to turn it into a single-member array, which makes it easier to write methods that can handle single or multiple values. For example, `$strings = (array) $stringOrStrings;` will convert a single string to an array with that string as it's sole member, and will leave an array of strings unchanged.
Did you actually checked that ? Because it turns out the Hypo is just a baby [Porcupine](http://balloffireconsulting.com/wp-content/uploads/2011/10/baby-porcupine.jpg). :-) phpBB had [5 advisories / 6 vulns](http://secunia.com/advisories/product/17998/?task=advisories) (*the last one is from 2010*) and [18 CVE](http://www.cvedetails.com/product/2635/Phpbb-Phpbb.html?vendor_id=1529) (*including mods and the last one is from 2010*). And let's not forget about the fact that [phpBB](https://www.phpbb.com/about/launch/) started to use Symfony components with version 3.1, which should make things even better.
Yep, we are in the process of redesigning the website so it looks more "2015-ish". The new design will be very slim, and with no ugly wood pattern :) Hopefully, the framework user interface is better. And this is what Mouf is about: a web-framework with a user interface.
Sadly my code is on a Windows server, unless sed it windows based.
strace for php is exciting, and this seems like a pretty good start. i got a segfault after a preg_replace call, but it still provides some very insightful data.
Very nice framework, nicely build and easy to use. I love it
The title is misleading, as this list is missing some big names like: - magento.com - 5,761 - phpbb.com - 12,420 - packagist.org - 18,258 - phpmyadmin.net - 18,878 - doctrine-project.org - 52,616 (to name a few)
instructions save this file in the starting directory, input the starting directory folder name and run. I highly suggest you specify the file type if you have a lot of files. Mentioned by another user for anyone with the same kind of situation. &gt; A statically linked sed exists for windows from here: http://unxutils.sourceforge.net/ &gt; &gt; You could distribute it alongside your script if that is an option. &lt;?php set_time_limit(0); error_reporting(0); Function GatherFiles($Starting_Directory,$Target_FileTypes,$Parents){ If(empty($Parents)){ $Dir="../"; $Parents=array(); $Parents[]=$Starting_Directory; } Else{ $Dir="../"; ForEach($Parents as $Values){ $Dir.=$Values."/"; } $Parents[]=$Starting_Directory; } $Array_file=array(); $Array=scandir($Dir.$Starting_Directory); ForEach($Array as $Values){ If(strpos($Values,".")===false){ $Array_sub=GatherFiles($Values,$Target_FileTypes,$Parents); If(empty($Array_sub)){} Else{ ForEach($Array_sub as $Values1){ If(empty($Target_FileTypes)){ $Array_file[]=$Values; } Else{ ForEach($Target_FileTypes as $Values2){ If(strpos($Values1,$Values2)===false){ Print_r($Array_sub); } Else{$Array_file[]=$Values1;}; } }; } }; } Else{ If(empty($Target_FileTypes)){ $Array_file[]=$Values; } Else{ ForEach($Target_FileTypes as $Values1){ If(strpos($Values,$Values1)===false){} Else{$Array_file[]=$Dir.$Starting_Directory."/".$Values;}; } }; }; } return $Array_file; } Function Replace($FileName,$OrigionalString,$NewString){ $file_contents = file_get_contents($FileName); $file_contents = str_replace($OrigionalString,$NewString, $file_contents,$Count); If($Count&gt;0){ Echo "In ".$FileName." ".$OrigionalString." was replaced with ".$NewString." ".$Count." Times.&lt;br&gt;&lt;br&gt;"; file_put_contents($FileName, $file_contents); } } $Array=GatherFiles("../www",array(".php"),array()); ForEach($Array as $Values){ If($Values!="file name used to change everything"){ Replace($Values,"MegaDicks","SuperMegaDicks"); } Else{ } } ?&gt;
My bad, I haven't looked at these in a long time just remember when SMF came out and it wasn't too bad! Times change!
Yeah, that was just a first pass, and a proof of concept.
As the manager of a team, you have next to zero right to dictate this. I've seen swathes of my developer friends take great pleasure naming and shaming people like you on facebook, and usually the post that follows is more bullshit ending with "and 75% of the team quit" Do yourself a favor, concentrate on being a manager, not a micromanager. Your team is composed of adults, they don't need their software choices dictated. If they do, you obviously don't trust them and should hire a new team.
I'm going to approach this from a different perspective, as what you are trying to fix is a very real problem(no matter how naive many here are acting), though I don't necessarily agree with your solution. I believe you have to be very careful when dictating someones own tools(OS, IDE), versus anything that's in shared space(CVS, CI, QA, etc). Peoples minds work vastly different, and what is beneficial to someone, might not always be for others. Likewise, what one thinks is best for them, might not always be the case. Theres a fine line there to walk, and I find the only real metric you can accurately gauge is performance. Let me give you an example, we had a dude in our office who was previously a sysadmin, transition to heavier and heavier programming. He was very proficient with cli, and was a huge proponent of VIM, but as systems got more complex, he really struggled with anything regarding traversing through object inheritance, or going to declarations, or major refactoring. This started to effect his performance on some of these more complex projects and was directly affecting his ability to work as efficiently as his counterparts. Eventually I introduced him to the VIM editor in PHPstorm, I didn't force it on him, but I asked him to give it a try and see if it would help him at all. He did just that, and found it to give him a good balance of both worlds, and I immediately noticed his productivity went up. Now, this same dude also chose to use gimp instead of photoshop(he was on linux). Any time we tried to give him front end related items, we'd ALWAYS find issues. It was to the point where our PM's would avoid giving him anything that required he open a photoshop file, and this obviously hindered his performance once again. This was a situation where we had to give him an ultimatum of getting photoshop working(whether it be via Wine, Dual Boot, anything), or look for another place to work. In both cases, what the dude thought was best(and what he was most comfortable with), were obviously hurting his performance, and that's when the line had to be drawn. I don't think it's necessarily bad to encourage them to try new things, and push them outside of their comfort zone, however I'd be very hesitant to force once solution across everyone. 
You should consider doing a few code quality checks too, there is mixed indentation in many files, and all of the class files have a closing PHP tag [which is not necessary and can incur some unwanted side-effects](http://stackoverflow.com/questions/4410704/why-would-one-omit-the-close-tag). You also have a bit of a lack of consistency in file naming, i.e. most classes are pascal case yet others are camel case. And some inconsistencies in code style, i.e. gaps under use statements in some places, yet not in others. In an open source project, your aim should be to have a codebase that's as high quality as possible. I've not looked at *that* much of the code and already came across several issues. The code doesn't seem to be of poor quality, OO concepts are clearly understood and used throughout, you have an okay folder structure - but I'd also consider making it a little more modular perhaps, or just splitting up the folder structure a bit more. Frameworks are always difficult to write and release, but I hope you can take the criticism because you may be left with something great that people thoroughly enjoy using at the end of it. Good luck. 
Most people, IMO, who hate PHP have used PHP 4 (namely Rails devs). With PHP 5, there has been a massive difference in what can be done. I mean, Facebook was (and still sort of is) written in PHP. As there is no "standards" aka being able to write the same thing in like 5 difference ways, people dislike it. Seeing as it is the most popular web language, I'd say your professor is wrong. Source: PHP developer for 5 years.
How would I use this but still let Apache serve the image avoiding PHP altogether if possible? What I mean is, if the resized file exists, serve it with Apache. If it doesn't, then use the PHP to resize and serve with your lib.
&gt;professor There's your problem right there. 
In my case everything is broken which is why I'm aiming for a rewrite.
http://stackshare.io/stacks seems to disagree with the "the modern internet is build on the back of php"
Quoting from myself earlier: &gt; Having said that, I know that you can use Nginx's X-accel functionality to still output the image using Nginx. You would do this by setting some headers in the PHP script, and then Nginx would pick up those headers and do the rest. I believe Apache has similar functionality, called X-Sendfile.
My big complaint with php is the ad-hoc function naming... &gt;would rather hand write html pages rather than use php. That's like saying you'd rather climb a mountain than build a rocket to get to the moon. There's nothing wrong with mountaineering, but if you want to get to the moon you'll need some technology. Javascript, Python, Ruby, PHP, it doesn't really matter what you use as long as you have liftoff.
Fixed that. Thanks for the heads up.
&gt;something as convenient as rails Was he high when he told the class this? In my experience rails is not convenient. Not even close. Since this is a Sys/Network Admin class, try this as an experiment. Set up a web server, whether it's on your own box or something like a Digital Ocean droplet. Try getting a "hello world" script running in rails (probably just plain ruby script at that point) and do the same for PHP. Then you can decide how convenient they both are.
if the output is getting to the command line it sounds like whatever you are doing to try to put the output into an excel isn't working. To get a better answer you are going to need to show us whats in testing_phpexcel.php 
Your professor is an opinionated asshat, but that's nothing new in higher education. He is also completely wrong, but don't bother arguing with him about it.
Yep, if hes Systems and Network Admin he is likely uninformed and spouting shit cause its not his pet language. If a professor who actually taught something relevant to programming said this I would be more inclined to at least listen to what they have to say.
Key Website on there are Facebook and tumblr. But, I'm sure the statement that /u/kolwrath made was more of the fact that most web host providers offer PHP more than any other language. There is also the fact that stackshare only lists platforms and doesn't show the fact that a big number of top [Alexa ranked sites](http://www.alexa.com/topsites) (like Wikipedia, or Wordpress) all run PHP. Hell, even the Whitehouse.gov website uses Drupal, which is a PHP application.
He may have been an ass, and right, 5 years ago. Today, he's just an ass. PHP has evolved a lot, but many people still believe PHP (and the PHP world) is what it was a few years back. The problem is their mind is set and nothing will change it. The book you are about to read is exactly the opposite of what they imagine PHP to be (that's why the book is named "PHP the *right* way"). So keep reading that good stuff!
I wouldn't presume to say that PHP is better than any other language, but PHP has it's positives and it's negatives. Every language does. It never hurts to know what language you work best in, but don't get too comfortable with it. Learning things like Javascript (for node) or Python helps to keep yourself rounded and is likely to add more jobs that you'll be likely to find. The professor was also a bit too opinionated about the subject. While PHP 5.2 is horribly out of date, I personally feel that 5.6 is incredibly fresh and has removed a bunch of the quirks that have plagued past versions.
I have liked it so far, I want to keep learning it. Thank you for the thoughts. Also, I could have said something like that but 1, it's day 2 of class, I really don't want to fight with the professor over something stupid that doesn't necessarily relate to class and also the last thing I wanted was to draw attention to myself as the guy interested in php when the people around me were all on his side mumbling "God it's just terrible" and other shit like that as if they have been professionals in the field. I just thought, "I don't care, this is weird because I have never heard these complaints before I'm going to see what the outside world has to say about this." Thank you for the response, I will continue on in my studies and hopefully he doesn't make a habit of bitching about php's failures.
&gt; PHP isn't really the "academic" language that people within academic mindsets appreciate. Maybe so, but then the guy goes on to suggest ruby... is ruby really a language that people within academic mindsets appreciate? I'd of thought not...
Hack is close enough to PHP to be able to lump them together as far this this discussion is concerned. Any PHP dev could pick up the nice stuff Hack added to the language in less than a day. 
My favorite part is how many folks who rail on PHP clearly are not even familiar with the language, just the talking points on phpsucks.com. Its certainly far from perfect, but it has incredible strengths no other server side language has ever matched in all of history. Foremost being adoption. It also has an vast library of open source tools, frameworks and especially applications. I work with some incredibly talented devs, and we daily work around PHPs shortcomings and even those of some frameworks. But we are still a lot more efficient than if we switched platforms, in both cost and dev time. Oh well. Let the haters hate. It probably just means more jobs for us.
I didn't care enough to argue with him, especially on the 2nd day of classes. Life goes on, his personal opinions about php shouldn't affect me in anyway for this class. At least I hope. 
I took a web programming course a couple years ago and php was the server side language that was taught. One of the TAs said a lot of people bad mouth php, but when they can't do something in their current favorite language they always come back. 
Hopefully, really it was just slightly discouraging but the resounding "Who gives a shit what he says" from the community here backed up with personal anecdotes about their life with php and resources showing the shortfalls of php have really helped me feel a lot better about the whole situation. 
I have found that Rails people tend to be really insecure and have the need to bash other languages to make themselves feel better, of the top used sites on the internet several use PHP, only twitter used rails and they're already abandoning it in favor of scala, so yeah just because he's a teacher doesn't mean he's right
XAMPP is pretty easy to do for sure. I come from the perspective of linux shared hosting and vps configuration for PHP and Ruby/Rails. Maybe it's because it's been around longer and more ubiquitous but PHP is no where near the wondrous cluster fuck my short time with anything Ruby has been. That's just my opinion though.
Every language has it's uses. &gt;he would rather hand write html pages rather than use php Your professor either sounds ignorant or pretentious; or both.
&gt; phpsucks.com not a real website. I checked.
By that I'm assuming you mean Ruby exists in the real world in comparison to Prolog, ASM, Matlab and Eiffel. Not Ruby exists in the real world in comparison to php?
So OP... I hope you weren't looking for unbiased answers by coming to the /r/PHP circlejerk. That's like going to a cock fight and asking why cock fights are wrong. Take their opinion and no form of sport is more noble and more human than Cock Fighting. Take the opinion of /r/PHP and it's a language that doesn't suck. Neither are right. Listen to your professor bud. Unless you live in some far off 3rd world country where people go to get dirt cheap developers. 
&gt; "I don't understand why anyone even uses [PHP] anymore. Especially when there is something as convenient as rails." let me switch stuff up: &gt; "I don't understand why anyone even uses Ruby anymore. Especially when there is something as convenient as Symfony 2." That is how ridiculous that is.
Your professor is an elitist dick who has lost touch with the real world. A site using 5.2 should update, but PHP is not out of date. How many billion page view sites run rails? Approximately zero. But don't fight this fight. Anyone who says shit like this is trying to feel superior. If that person has power over you and you correct him, he will possibly use that power against you, or at best harbor resentment. Let it go, knowing you will eventually be building things with the tools appropriate to the task, and he will still be flapping his gums and building jack shit.
That's right. I mean have a look for Eiffel jobs and let me know how you go. At least they exist with Ruby.
I thought Twitter was abandoning rails, and I must admit I forgot github and am not a user of the other two so they didn't even occur to me. I stand corrected - almost no huge sites use rails, and 25% of those who do are abandoning it. My point still stands that using rails is not the indicator of a sophisticated site, and this professor is a douche.
Rails performs at about the same level as a PHP framework. They still use Rails to do a large portion of their web logic. They had to move from a prototyping language to a more robust language to handle the sheer amount of traffic. A company and site that size can't exist on a single language or stack. This switch "off of rails" is also from 2008. The last PHP 5.2 release was 2009. I should also mention, I am not a Rails developer and couldn't even declare a variable in Ruby. 
Actually did checked the fuck out of thacked. Hypocked? Porcupinecked? Symfonycked makecked everythincked goodcked.
Best of luck with that :-) You must have plenty of practice filling out forms now, and I'm sure there are a few more of those to work through.
I wasnt trying to argue with you, i just wanted to clarify because people were downvoting you and I think it might have been because they didn't understand if you were referring to php or the other language. 
Its a matter of opinion skewed by the fact that there are many PHP developers who write bad code. There are probably less Ruby devs writing bad code as its less of an entry language, partly because its much less popular. Also, Rails is a framework, Ruby is the language. He should be comparing PHP with Ruby, or Rails with Laravel. I'd guess he's read some opinionated posts on some forums and strung together his own misguided opinion. Carry on learning, make up your own mind. Both have advantages and disadvantages, some are more important than others for different people - the same as many, many things.
Tell him that facebook, Imgur and many famous sites are developed with PhP.
I cane to /r/php to post this because i knew that here would be many people with a good understanding of the language. I was worried about the possibility of the bias of responses but i ventured this would be better than nothing. For the most part i can tell the difference between the hardcore circle jerk and the actualy constructive helpful comments. Thank you. But really quick where do you suggest I x-post this for the most reliable responses?
&gt; Common annoyances of php can be found here for example: http://phpsadness.com/ And then you find stuff like this: --- &gt; [(intended) Static variables in methods are bound to all instances of the class](http://phpsadness.com/sad/18) - Bro, You don't even understand how static works. --- &gt; [Member variable definition to function call is a syntax error](http://phpsadness.com/sad/2) - Maybe you should try resaving your file, because the error is referencing a line that does not exist in the file. --- &gt; [Sort functions operate in-place](http://phpsadness.com/sad/5) - &gt; Requiring the developer to needlessly create extra temporary variables merely to pass a value from one language construct to another encourages lengthy, messy code which is costly to change and difficult to follow. So instead of doing: sort($foo); shuffle($foo); bar($foo); You want us to do: $baz = sort($foo); $fizz = shuffle($baz); bar($fizz); That is exactly the opposite of what you wanted. Sure, with the second method you can do bar(shuffle(sort($foo))); but why not just do function myspecialsort($sortable) { sort($sortable); shuffle($sortable); return $sortable; } bar(myspecialsort($foo)) and now you don't have to look for 30 different places where you implemented the sort, you just have to look at the function you created. (DRY)
&gt; You cannot take regular PHP code and put it on the HHVM. This is misleading. 99% of PHP is compatible with HHVM. Furthermore, Facebook _did_ write a new language on top of HHVM called Hack. Source: I work on an HHVM project and commit to HHVM. 
And many of them can be fixed by running http://cs.sensiolabs.org/ before a commit
I have lumped this behaviour in with religious fanaticism. Basically they chose some language/technology and evangelize it over others and condemn those who support other languages as heretics. Java is certainly a bad language for attracting the religious types in that it is often the only language they know. Rails too, as this post indicates, has many people who think that rails is the be all and end all. Now I certainly fell in love with Python a while ago and can be found singing psalms in its praise, yet I have programmed a ton of PHP and wouldn't even think of condemning someone for choosing PHP. But for shear self abusing enjoyment try having an argument with an Oracle person that Open Source based NoSQL is the future (even if you don't believe it yourself). But I think we can all agree the PowerBuilder users do travel on the short bus. 
&gt; [Sublime is binary compiled for the platform. Its core is written in C/C++...](http://stackoverflow.com/a/22471391) It's really quick and you can easily find and replace in a folder - plain text or regex. :) 
Might find this useful: https://laracasts.com/lessons/laravel-5-commands
 &amp;#3232;_&amp;#3232; http://w3techs.com/technologies/details/pl-php/all/all &gt; PHP is used by 82.0% of all the websites whose server-side programming language we know. http://www.phpclasses.org/blog/post/208-5-Reasons-Why-the-Web-Platform-War-is-Over-PHP-Won-with-75-says-Google.html http://www.quora.com/What-is-the-market-share-of-ASP-net-compared-to-PHP-Ruby-or-Python &gt; php 81 % http://venturebeat.com/2012/10/02/php-andi-gutmans-future-mobile/ &gt; Today, after multiple massive iterations to the codebase, 35 percent of web traffic is handled by PHP, says Gutmans. **Wikipedia says 75 percent of websites use PHP.** Facebook, Wikipedia, Yahoo, and Photobucket are all built in PHP. WordPress, the most popular blogging platform in the world, runs on PHP and probably accounts for half of that 35 percent. Most of the other major content management systems, such as Drupal and Joomla, are also built in PHP. http://en.wikipedia.org/wiki/PHP &gt; As of January 2013, PHP was installed on more than 240 million websites (39% of those sampled) and 2.1 million web servers.[4] Statistical Evidence &gt; Anecdotes 
Something something something those that can't do, teach. Don't be discouraged by your lecturer. PHP has been paying the bills for many of us for years! You can only see improvements in your abilities by learning more :)
Here's a simple answer. Employer: We'd like to pay you $100k+ a year for you to mange our websites, which are written in PHP. You: Sure! I like food on my plate. End. Of. Fucking. REALISTIC. Discussion.
Yup, because the WTFs are based on actual experience.
Neither of those explain their position whatsoever - they're basically just asserting Greenspun's tenth rule.
&gt; but then the guy goes on to suggest ruby He didn't. He suggested Rails. "Your apple is so stupid. It's years out of date! Why would any use it when there's something as convenient as a doorknob!" PHP doesn't have ANY of the features Rails has, because PHP is a language and Rails is a framework. Compare Laravel or Yii to Rails. Compare PHP to Ruby. But comparing PHP to Rails just shows that you're ignorant and biased.
&gt;"I don't understand why anyone even uses it anymore. Especially when there is something as convenient as rails." Last I checked PHP was still the most used scripting language on the web by large margins. And RoR has what, single digit market penetration? He can talk all the shit he wants but PHP programmers are in demand and you'll never have a problem finding work. So laugh all the way to the bank I guess. 
Anecdotally, I work in the videogame industry; we built the back end of www.dragonagekeep.com in PHP. Its not like PHP is just used by smaller developers or tiny projects/old projects. Its relevant, and it can be very performant.
Some people seem to really hate PHP. The reasons they site seem minor to me. I don't understand it very well. The modern PHP language constantly impresses me with what you can do using it and how fast it is to get good code working. One theory that I have is that the PHP haters have a certain programming style that does not fit well within PHP. For instance I like powershell, but am frustrated whenever I use it because its code flow is so different from PHP. I often get frustrated because I know I am writing poor powershell code, but it works and I don't know how to do it better. I wonder if that is the real reason why some people hate PHP. When they use it they are writing poor code and they know it, but it works, and they don't know how to make it better. 
And involves loading every package you want to run by hand on most servers.
Twitter is now on Scala, I believe.
it's not required and it's not based on directory structure . also, languages like python and java include lots of nice libraries within their "built-in" namespaces
You know, I like Rails a lot, but I hate people who bash languages. It's something I used to do when I was 20, but then I grew the fuck up. PHP has all sorts of problems with it, but I feel that way about almost every language I've ever worked with.
I can't speak to eloquent specifically, but I will say that any active record based ORM is going to run into scaling issues when dealing with collections of objects. This may either never be a problem for you, or you can work around it by simply dropping down to the SQL level and hydrating only where necessary. Just be aware that you will probably need a plan for it. On the other hand, Doctrine2 models (entities) are just simple lightweight PHP classes. There's far less problems handling collections of objects. It's entity manager is able to usually come up with a more performant path when performing multiple SQL operations. Doctrine2 requires a lot more ceremony and setup to get working right, and even more learning is required once you get to more advanced topics like performance, but the pay off in the long run can be well worth it. Both have their use cases. If it was an application that was going to be maintained for a long time, I'd probably select Doctrine2. If my experience with Doctrine2 was limited and timeline was a factor, I may go with something else (to be perfectly honest, I'd probably just go with a table gateway style pattern over using an active record based ORM - I've been bitten too many times in the past)
Complete side note: if you're looking for an API-first approach to app development, apigility (https://apigility.org/) looks really awesome. I haven't had a project to test it out with yet, but I'm looking forward to it. 
I had a Java professor who tried to teach us that Java is pass-by-reference -- don't take your professor's word for what he says. One of the best skills a programmer who Gets Stuff Done can have is they can judge how well a language, framework, library or some other software construct will help you solve a problem. 
I dont have experience myself with Laravel, I only speak through the opinion of others and perception, but I am a strong advocate of Symfony. There is a bigger learning curve, but in the end, the result is more flexible, stable, tested, etc. You can come up with your own set of tools and bundles and suddenly everything gets way easier; it is a very rewarding experience. Nowadays, everything is built on Symfony, but not everything is built on Laravel, you will feel at home anywhere you go with Symfony experience. Also, Eloquent is big no-no for me. I am very solid in Doctrine and I wouldnt ever want to go to ActiveRecord again (I didnt like it in Rails either). What flexibility do you lose? Eloquent is less flexible than Doctrine, services and bundles are harder to override, configuration validation is weaker, the services stack feels clunkier, etc. Laravel is fine, but if you go for the long run, I would strongly suggest Symfony.
"If my grandmother had wheels, she would be a bicycle"
wait, we're not putting require_once on the top of our pages anymore? fuccccck.
I'm sorry, but i dont really find node that elegant.... It always feels (as javascript usually does) to stumble over itself with callbacks and anonymous functions.
Completely agree. I've written in PHP professionally for 15 years (before sessions!) and it has come a long way in the last few years. Symfony honestly kept me in the language, and I've worked with ruby, Python, node, Java, objective c, etc. They ALL have their warts. Ruby's versioning is a mess imo. To OP: I think structure and maintainable is paramount and PHP will be just fine. Keep at it, PHP the right way is a great resource. Check out KnP tutorials too. I think dependency injection is a really important concept to grasp early, and is portable to other languages. Learn how to architect good code and you'll take that with you through all the fads.
The fact that the professor is comparing a language with a framework already speaks volumes about his knowledge about technical things, at least in software. This is a sysadmin class? Debatable whether that's acceptable or not, but certainly don't ever take an actual software development class from this professor. Reading his couple of comments in your post, basically he's an idiot.
It's a matter of the right tool for the job.
*Alt-tabs and continues typing C#*
&gt; You will not get realistic answers in this thread. &gt; most of the people who frequent /r/php and do nothing but surround themselves with other php circlejerkers like themselves. and you are here in this group to point that out..That, my friend, is called a circlejerk. 
Its 2005 all over again.
I agree, i'm also a big symfony fan. My biggest gripe with it is some of the architecture choices. The bundle system is meh. Even in the newish best practices doc they suggest only using one bundle per project. Coming from CodeIgniter and then Rails as my goto frameworks, I always enjoyed the simplicity of having all your controllers in an app/controllers folder for example. Regardless, once you get used to it's choices (which I would attribute to the learning curve), it's a great framework that can pretty much do anything you want. I use it for anything i do php related.
I would never write a `myspecialsort` function like you've done there -- breaking with the consistent approach taken by the sort functions is sure to cause someone else some headaches down the road. You're better to just use a `usort`, especially since we don't need to deal with that passing-function-by-its-stringname anymore, and can simply pass in a Closure like so (with dummy data + sorting function, since your sort then shuffle example doesn't really serve a real purpose either): $foo = [1, 2, 3, 4]; usort($foo, function($a, $b) { return (bool) $b % $a; }); bar($foo); and of course, that function doesn't have to be anonymous if you want to re-use it later.
There are always people who love to hate PHP. Sometimes I'm one of those people, but at the end of the day I make my living coding PHP and even with its nuances it gets the job done. PHP powers a majority of the Internet (saying that WordPress itself powers about 25%) and it if getting much more useful and powerful. Truthfully "rails", "django" or "larvel" could all be used to create the same site it's usually the programmer that causes problems. Most of my issues with PHP are caused by my mistakes. 
That was me! They were using a 5 year old build. He went on a rant but I knew there was no point arguing. Edit proof: room 1211!
Hey man come talk with me after class. I've used it for a long time and have become pretty familiar with its shortfalls. I'm building a REST api for a startup right now using composer, redis, and a relational db, and I've also webdev'd in other environments. I can at least help show you when and where php can be a good thing, and when it might be best to try different tool (async, multithreading) Never be discouraged to learn something new
The best thing about php is that it's really cheap and easy to get hosting or even to run it on your own computer (xamp and whatnot). For RoR you need to know a lot more of the stack to get it running, and the only way to host it is by running it in a VPS, which means you need to know a bunch of stuff about Linux administration too. Sure, it's messy in the way functions are named and stuff, but it's still the best way to get started (not to mention there's a ton of open source frameworks and CMSes to build on).
My personal favorite is Scheme. Ive never used that in production ever. Great way to learn algorithm design.
His opinion is based on out of date information. And ruby is no bastion of purity either. 
the code at that company is not really a positive example.. Wayfair's codebase is much of what's wrong with PHP, though it shows that even a terrible bit of code can make you some money.
The better you become at programming, the less the actual language matters anyway. People pay me to program in PHP, so I program in PHP.
Please also realize he compares a language (PHP) with a framework (Rails).
Have to disagree - professor's an ignoramus, it'll probably be an easy grade.
Yup. If I dropped a class every time a professor said something silly about the industry or modern languages, I would've been out of college after a year.
In the recent years there are no fundamental changes in Php , so those tutorials should be OK
Your professor is (pick one): a) holding on to outdated information after reading an article 6 or 9 years ago. b) a ruby fanboy, so there is no better language Short version - he's full of shit *now*, but depending on his reasoning, he may not have been once upon a time.
PHP is in the business of getting shit done. When we want to create something we can all talk about, we might turn to a trend, like go, so we can look trendy while talking. When we want to make money so that we have time to sit around and make things for fun, we use PHP. PHP isn't the only language you will ever need, but it's a fine starting place. Your professor is ignorant of the real world, the one where you have to earn a living, where you have to make ideas work in as little time as possible.
Thanks for sharing this! I'm the author, and would be happy to answer any questions.
&gt; I don't understand why anyone even uses it anymore. Here's the thing. If he read through the source code of a modern php app, he might understand. If it's still bothering you, direct him the [League of PHP](http://thephpleague.com/) for some great examples. 
You can use rewrite with RewriteCond and -f - or you can use Apache 2.4s FallbackResource .. or set a custom 404 handler (which can be a PHP file). We've had a few situations where we've used a custom 404 handler, and then dropped the file in place from the PHP application when the 404 handler is triggered, served the file .. and next time Apache just serves the file from disk instead.
&gt; So I have to create a mock and stub the query method in $wpdb for each test, correct? Is this how it works? It just seems a little bit cumbersome and I'm thinking there might be a better way. That's correct, yes. There isn't really a better way of doing what you describe, but you might want to consider the type of tests you're writing for something like this. Personally, I'd hit the database while testing the code you've described. Do yourself a favour and write a handful of tests that do use the database first, that cover the most valued behaviour. Then write a handful of isolated tests with mocks for other behaviour. See which are easier to write. See which are easier to maintain. If anything is painful, reconsider.
looks very interesting, it's on my list now on things I need to test:)
Why did you not use instead ASP or just wrote one liners in Perl back then? LOL, memories. 
Yeah, it's one of these things where showing your working is more important than the answer itself. This is particularly so in household name languages. Sure, maybe xyz, a non-Turing complete abandoned language only ever installed on three computers that's not been updated for twenty years, has zero redeeming features but there's got to be something if all those other people are all using it.
It's also the monolog suggested Graylog2 handler since monolog 1.8
https://github.com/theseer/phpdox https://github.com/FriendsOfPHP/Sami http://apigen.org http://www.phpdoc.org/ Personally I love apigen.
PHP is a crossbred mutt language, and that angers and confuses people. Don't let them dishearten you, English is also a mutt language and it is usually recognized to be expressive and powerful in ways other languages are not and drives the anglophile world in directions that are difficult to translate. The thing about mutts is a that they are academically easy to attack, but usually all the criticisms of their supposed flaws are usually descriptions of its strengths too. Later gen languages like python, ruby and go had their designs influenced as a reaction to the previous gen languages like PHP. So by comparison they are generally cleaner, more consistent and terser. These languages fetishize "clean" aesthetic. Their philosophy is "there is only one way to do it" or "code by convention". I imagine they are all written on Macs in perfect clean rooms. Generally they sacrifice features or runtime in favor of sugar and rigid consistency. But if that were as important as they think, we'd all be speaking Esperanto. More academically rigorous languages like C, Java, Lisp, smalltalk, etc complain that PHP is not academically rigorous. These languages fetishize ... C or Lisp or OO. It's typical ivory tower masturbation. They hate split infinitives and duck typing and arrays which are not arrays or sets or hash or lists. If they had our way we would all be speaking Latin. Personally I know and like many of the languages named above, I'm not disparaging them. I'm simply pointing out where I believe many of PHP's critics biases come from.
'Last I knew' wasn't intended to reflect the current state, and to me doesn't read as asserting this is the current state. In the context of just how recent the overhaul has been, what I said seems a very reasonable and suitably-qualified statement. Are you a dev for them or something?
PHP dev tuning in, Wordpress has nothing to do with quality products you can piss on that all day long and you will only observe my cheerful applauses. Not as bad as joomla, but still quite unpleasent.
where are they?
I guess you shouldn't have coded your spam bot in PHP huh?
Most approximations say that PHP powers around 80% of the web. So if you go to any random site on the web, there is about a 80% chance that it's written in PHP. There are also big names running on PHP - Facebook, Yahoo, and supposedly also Apple. And because it's so popular, it keeps evolving, because it has to keep up with the times to keep everyone invested in it happy. It will continue to evolve and keep up with the times because of this. Reading PHP The Right Way is an excellent choice. I'm going to be working my way through it too.
3 crucial points to remember when posting to reddit * Include content * Proofread * Formatting
Symfony 2 is a very good framework, but in general I feel it is too much configuration driven, so it is a bit of a pain to use in the end. I would suggest that you give a CakePHP 3 a spin, some of the advantages that it has: * Detailed documentation * Powerful and intuitive ORM * Creating APIs is super easy * Focused on quick development * Commitment to stability and long term maintenance * Fast!
Hey, PHP-hater here. I pretty much loathe PHP, and think you all are stupid for using. Ok, that's not quite true, but I do hate PHP. It's an archaic, clunky language that's not really good at anything. You want an easy language? Learn Rails or Python. Perl is probably good too, I just don't think it's as user friendly. If you're young and just starting out, I see no reason why PHP would be your first language. It's difficult to write, it takes a lot of code to write something that should be short, and doesn't lend itself well to bests practices. You were right in your question when you said people here would be biased. I assure you, they are. There's no reason you should be learning PHP right now. These people already know it, so they have a good excuse, but it's a dinosaur. Just trust me. I know you don't have any reason to, and you were probably just looking to reaffirm your beliefs, but you don't want this language. Go to a different subreddit, like /r/web_dev (you can subscribe to a plethora of web development/coding languages here: http://www.reddit.com/user/krispykrackers/m/programming) and ask the same question, and see what kind of answers you get back. Sorry if this sounded harsh, just trying to look out for you.
So `require_once("inc/".$_POST[file].".php")` is no longer a thing? Dang!
Learn PHP. And learn Ruby for the sake of your CV. Then go contracting for three years. Let's pretend that'll work straight out of university for the sake of argument. At the end of the three years, you'll have a dozen PHP sites that you're proud of on your CV. And the one Ruby program you wrote in Uni to prove you knew the language. Maybe you'll get called in to an agency to fix the code some kid wrote in Ruby to get it on his CV and then left to go contracting, but you won't enjoy it. PHP's a mutt, but it's one that'll get you paid. And for some reason, some people think that's not good enough. Don't worry, you aren't wasting your time.
Out of curiosity, what do you use instead ?
Just give me the address of that file, and I'll check it out for you. Make sure it's up to par. 
With register_globals = 1, your code can be even simplified: require_once("inc/$file.php"); Ta-da!
Get used to this. People LOVE to shit on PHP and in the past they had good reason to but nowadays it's gotten immensely better IMHO. There is still cruft but it is slowly being deprecated and removed. I program full time in PHP and trust me I see its warts but it's no where near as bad as most people want to make it out to be. I prefer NodeJS for personal projects and would like to do it professionally but I have a lot of love for PHP as it was my first web language and I thought myself it (You'll always remember your first :) lol). Don't let them get you down, I've been paid quite well to program PHP and there are lots of jobs out there looking for PHP coders.
While I was learning Delphi in the university, my professor was telling me that code indentation is bad and makes the code less readable. She was asking everyone to avoid it.
Thanks for checking it out. I came across Ross's Tactician after I had already more or less finished Chief to the point it is now. Although the idea of teaming up would be great, this started out as more of a learning exercise really which is why I hadn't considered it
Opinions are like assholes... everyone has one - so here's mine. I guess he is just going to skim over the fact that thousands upon thousands of websites are running PHP right now. WordPress? PHP. Facebook? PHP. Wikipedia? You guessed it. Its one thing for a professor to say PHP isn't as good as language_foo because of any number of reasons, but its another when that professor doesn't tell you what the language is actually good for as well. Like any tool or language, each of them have their pros and cons and has better uses in certain situations over others. This is why I hate the PHP vs PickYourLang arguments because its totally subjective to the project at hand and quite frankly is a major waste of time. PHP is a highly active and employable field right now - you have picked a good starting language. Just don't make the mistake of stopping your education at PHP.
Did you forget to commit the /tests folder?
&gt; Not sure what this question actually means, but comparing Symfony and Laravel in terms of BC, I've had Laravel break on bugfix updates, so backwards compatibility is clearly not a priority. On a related note, whenever a new minor version of Laravel is released the old ones don't get any updates - not even critical security fixes are backported. Combined with the fact that new releases almost always breaks things, this is not a good combination. Depending on what kind of work you do, this is huge. I know for our shop it was pretty much the deciding factor. We started on Symfony 2.3 and have upgraded every time a new version comes up, without any issues ever.
No, there are no tests. The library is about 24 hours old, and it's changed significantly since I started. As it's becoming more stable, I will probably use this version as the basis for tests in a rewrite.
You're not a positive example. 
Hi Jordan, Thanks a lot for the feedback. Actually, the video might give you the impression that Mouf does mainly generate code, but apart from generating a controller stub, there is really no code generator in Mouf. Instead, the real focus is on dependency injection. If you are used to Symfony 2, you can view Mouf as a graphical editor for the "services.yml" file (except Mouf does not make use of YAML). So the direction we are taking is definitely not towards generating a lot of code. The idea is rather to be able to easily build an application by binding instances together, which is very different. Of course, there are people that don't like dependency injection or find it to be overkill. As you may guess, we are big fans of this design pattern and want to see it used as much as possible (hence the graphical user interface). Thanks again for the constructive feedback!
The asynchronous Gearman behavior doesn't allow the callbacks, and the synchronous Gearman behavior is...well...synchronous.
I'm glad this isn't going the way of Dreamweaver. My only concern really is that things working like magic aren't always a great thing for newbies as it can sometimes lead them to feel there's no use learning the native way (Here's looking at you, jQuery). However this entirely depends on the developer so it's really not an issue on your part and is more up to the developer to learn why it's working. Again, it's a really cool thing you're doing and I'll definitely be giving it a try properly sometime.
&gt; We are planning to possibly make an API ourselves too. &gt; Just how adequate are Laravel and Symfony2 for creating APIs? Which would be better and why. &gt; Any other framework I should consider? Regarding APIs, latency will be the biggest dragon you need to slay and it's best to look at all the tools available. That said, and if you can, I'd avoid a PHP framework all together for this aspect and leverage a Java framework or a lightweight Python framework like Flask. If there's no getting out of using a PHP framework, I would choose Laravel over Symfony2 as it appears to provide slightly better performance according to the Techempower benchmarks. This isn't any kind of indictment against PHP frameworks (I use Laravel quite a bit), but when it comes to building high performance APIs, it's best to leverage every advantage you can get.
I am a PHP dev, and do not agree with your prof. However, if you are a new programmer deciding what language to learn first, PHP prob shouldn't be it. Seriously, you will learn better practices and set yourself up for more varied employment, and probably more interesting and modern projects to work on, if you learn something else. I would recommend **Python**. (you will also feel better as people wont then always be criticising your choice of language)
+1 about symfony being too much configuration driven.
Since there's no interface for the wbdp class its going to be tricky, since ideally your __construct(TYPE_HINT $wpdb) should have a type hint. What your perhaps better doing in this case is creating a class that wraps wpdb then use that class in your application. Something like this perhaps (not tested written on reddit). Your application will now depend on WordpressDatabaseAware/WordpressDatabaseAdapter Meaning your not actually locked into Wordpress should you move.. and if anything changes you have room to change things easily in 1 place. &lt;?php // The original wordpress class class wpdb { // ... public function save() { return true; } } // Your interface to typehint across your application interface WordpressDatabaseAware { public function __construct(wpdb $wpdb); public function save(); } // Your wrapper class which provides access to the original wpdb class WordpressDatabaseAdapter implements WordpressDatabaseAware { protected $wpdb; public function __construct(wpdb $wpdb) { $this-&gt;wpdb = $wpdb; } public function save() { return $this-&gt;wpdb-&gt;save(); } } // Your example class class Field { protected $wordpressDatabaseAdapter; public function __construct(WordpressDatabaseAware $wordpressDatabaseAdapter) { $this-&gt;wordpressDatabaseAdapter = $wordpressDatabaseAdapter; } public function save() { return $this-&gt;wordpressDatabaseAdapter-&gt;save(); } } class FieldTest extends PHPUnit_Framework_TestCase { public function testSave() { // Create a 'mock' WordpressDatabaseAdapter so we don't actually touch the Database $mock = $this-&gt;getMock( 'WordpressDatabaseAware', ['__construct', 'save'], [], 'MyAwesomeWordpressMockAdapter' ); $mock-&gt;method('save')-&gt;will($this-&gt;returnValue(true)); $field = new Field($mock); $this-&gt;assertTrue($field-&gt;save()); } } $wordpressDatabaseAdapter = new WordpressDatabaseAdapter(new wpdb()); $field = new Field($wordpressDatabaseAdapter);
&gt; I just bought PHP The Right Way This confuses me. I know about the website with the free E-book. Is there another book published with the same name that you have to purchase?
Oooh, I see. Thanks for clarifying and thank you for donating to such an awesome cause!
&gt;&gt; Especially when there is something as convenient as rails. &gt;&gt; he would rather hand write html pages rather than use php these statements make me think he's never done anything remotely interesting or complicated.
He's comparing PHP (a language) to Rails (a framework), so that automatically tells me that he doesn't really understand what he is talking about. Especially considering that PHP has many polished frameworks that offer the same things that Rails does.
&gt; phpsucks.com/index.php FTFY
No, the original reason was it was Rasmus' personal script library he wrote to quickly do some things in C. He didn't think much about naming because he was the only one who had to look at the code.
Look at any developer job board, then go learn whatever is at or near the top. Php will be there. 
I've done some web apps in C#. I didn't particularly enjoy it, but there are definitely some modern frameworks available. MVC (yes, they named the framework MVC), Sitecore (which is hella expensive), and Umbraco are fairly popular for C# web dev.
I like your analogy to a mutt, but I would just like to point out that Python and Ruby are not next-gen languages. They were all started at around the same time. * Python 1991 * Ruby 1995 * PHP 1995 Go builds on and reacts to C more than anything else, definitely more than PHP.
I've coded in both php and RoR, your professor is an idiot.
Don't worry I took a web dev 1 course and my professor told me Dreamweaver was the right way to build a website. Yeah...okay Doc. It was also the lowest grade I received during my schooling and I was already a working dev.
I mean, just because I wasn't fond of writing in C#, it doesn't mean that you won't still enjoy it. I'm just saying that there are definitely some modern web frameworks written in C#. ...as far of ridiculous verbosity, C# is definitely more terse than Java, but I've found that it sometimes is too terse to the point that it's verging on Perl in unreadability.
I know what you are talking about, but I was never programming in ASP although there were so many advocades pushing for it. I knew right away PHP would lead and when today somebody talks about RoR I know it will never reach the user base PHP has. Some people do not know that before PHP they used CGI which was really a pain in the ass and was mostly used for forms. People were waiting for something more readable and PHP was in the right place to the right time. And that is how it constantly envolved with its users. The criticism is useless because it does not matter how inconsistent the programming language is if it gets the job done and a huge user base can obviously deal with it. 
I've noticed that haters tend to still think the language is like it was in the 4.x days, which is a very different beast compared to what it is today.
...me too
Sort of makes sense, it's a tool for finding the fully qualified name, so if the class does not exist, it returns all it knows, and then a normal "class not found" fatal error will occur when you try to actually use it. No real need to add additional error handling for this.
I agree that his post makes little sense and the doc was "clear" in that instance. He should acknowledge his own mistake instead of whining and generalizing by saying "people" instead of "why programmers hate other programmers". That being said he's right about one thing: Programmers are usually arrogant or said more nicely: proud of their work. Too often a developer won't help you if you dare use their (open-source) project for something that is even slightly out of what they had in mind, even if your usage is legit according to their own doc.
WordpressDatabaseAdapter does implement the interface so not sure what your talking about, also the mock is the interface also.. again unsure what you talking about. As for the interface with a constructor I see your point
thanks to all captains obvious
mass inheritance just couples everything tightly together with no wiggle room
&gt; So far employment purposes, Symfony might be better? No, in my opinion most companies worth working at won't require specific knowledge of a framework. A good programmer is a good programmer. If you're a competent programmer, you'll write good code in either framework. On the other hand, if you're an incompetent programmer who only works in Laravel or only in Symfony, you'll write bad code in either framework. An intelligent company will hire a developer because they can write note good code, not because they worked with a given framework. **tl;dr** It's far easier to teach a developer a framework, then it is to teach a bad developer to be good. 
Agreed, he probably wrote this out of frustration. Also, there are users and users. You've got your programmers, and then you've got your laypersons who barely know how to go to a website. I don't think that's a fair comparison.
In this case, since all three of your returned columns are the same, I'd recommend a UNION for those queries. So for example: SELECT id, name, random, 'blog' AS type FROM blog UNION SELECT id, name, random, 'events' AS type FROM events UNION SELECT id, name, random, 'news' AS type FROM news Then you can parse everything in code to split out the different types of data for display. 
I'd profile both approaches to see if spitting out the different data types is really faster than issuing three queries. If the content doesn't change too often, you should cache the results for some time (15 minutes, one hour, a day?) and avoid the hits to the database. In fact, if they change at different frequencies, I'd keep it as 3 separate queries w/diff cache expiration.
5.1 is out of date. But to declare all PHP out of date? That is bad form. There are things that PHP doesn't do well. Thats fine. There are things it does very well. The "rails" comment definitely makes me think "Oh, one of those" language zealots, who insist /THEIR/ language is the only one you'll ever need for a task. Don't let the opinion of one person tell you to avoid a language. Especially when their opinion comes pre-packaged with Their Favorite Language.
&gt; I get really frustrated when I see a bad interface and there are a lot of them. Most of the time, it is because a clash between expectations of the programmer and the user. Hang on. There are other people involved in the process, such as the PMs, the visual designers, the client, QA, sometimes even upper management, and the programmer has to do whatever *any* of those say, unless there's some sort of rigorous spec. And I don't know about you or other folks here on /r/PHP, but I've been programming professionally for a while now and I've never seen any rigorous spec for anything I've ever made for non-programmer users. I, for one, can't count the number of times where I've been "overruled" into doing something I disagree with, only to be scolded by someone else down the process who rightly says it makes no sense. Also, I get a lot of flak for stuff other people did: apparently, because I'm the programmer, I'm somehow responsible for any and all other people's fuck-ups including people giving me crap for their own mistakes. I love my job, but I wish people would use their noggins a bit more and put blame where blame is due; or even better, do away with blame altogether and spend time teaming up to make something beautiful. You got shit from someone because you did something that had an undefined result, well I say RTFM. Also if you're skilled at C/C++ like you say you are, then you should know that you need to you allocate memory before you use it in those languages.
No, that's not a bug. That's expected. Methods and Properties live in different symbol tables. So that means you can have a property with the same name as a method, and they will never clash (unlike many other languages). The reason your example works is that: $this-&gt;c($v) is a method call, so it looks up the method symbol table. However, $closure = $this-&gt;c; is a property lookup, so it looks up the property symbol table. This is very much expected behavior. You can simulate the concept you're thinking of with `__call` and `__get`: class Foo { public function __call($name, array $args) { if (isset($this-&gt;$name)) { return call_user_func_array($this-&gt;$name, $args); } throw new \BadMethodCallException(); } public function __get($name) { if (method_exists($this, $name)) { return function() use ($name) { return call_user_func_array([$this, $name], func_get_args()); }; } } } Note that's 5.4+ code, and really shouldn't be used besides as a demonstration for how the symbol tables can be related together.
What is it that you do day-to-day for your employer /u/sarciszewski? Is there another team that uses Laravel and you interface with that with PHP somehow?
That was quite and interesting read and I really appreciate you linking me to it. It made me feel a lot more confident in my choice especially as this is not my first language. Also, I'd like to thank you for your contribution to my learning and the creation of PHP: The Right Way.
http://php.net/manual/en/getting-started.php
I currently use html2pdf in one of my big php projects. The documentation is mostly french and it lacks any fancy css3 bells and whistles, but it is very stable, relatively quick, and, best of all, free. Feel free to ask me about it.
Yeah there are [a LOT](https://packagist.org/search/?q=html%20pdf) of these packages and they rarely advertise their specific approaches, goals, etc clearly. Go find one with a whole load of stars. Many of these are wrappers for a specific framework, but most use `wkhtmltopdf`, `mpdf` or `dompdf` in their guts. Just find a relatively popular one with an API you like the look of. 
The adapter pattern is for creating a common interface between normally-incompatible classes, so WordpressDatabaseAdapter doesn't make much sense as an interface to me.
You say you have no experience with Frameworks. Does that mean you are used to rolling your own code and not used to change the way you think to suite how Framework X asks you to think? Take logging. How do you do it? file_put_contents? error_log? \Log::error? $this-&gt;log-&gt;error? There are LOTS of ways to handle it and for instance Symfony expects you to inject the logger. Laravel gives you a static global to log. Which one is better? Which one suits you? If you got to write an api, why not search packagist for an API package you feel you can work with, then see what framework is the best match. What I have noticed that a lot of stuff about frameworks is extremely abstract. Someone is making instructional videos for Laravel 5 (and 4) and yesterday I watched a bit on the idea of Contracts. And it seemed to me to be a step to far in planning for the future. Well about 100 steps to far. Because you might one day replace System X by System Y which is identical in function you need to wrap everything? If System X and System Y are so similar they have the same interface, why are you swapping them? And the entire point for doing extra work NOW is to prevent possible extra work in the future. As always, what do you really need and what can you really do right now. It sounds like you got no time, no budget and frankly, no experience. Is this the time to start experimenting? Or just create a working system and see if in six months you are still getting payed. Don't experiment in a job. Do that in your free time. 
This. Unless it is a small, very simple PDF, use a wkhtmltopdf. Example: 1 report with 50 pages. Each page was nearly identical. 3 tables, 12 columns, 20 rows. 7-8 minutes to generate using mPDF or domPDF or FPDF or any of them. Less than a second using wkhtmltopdf.
Fantastic, thank you :)
This was one of my general intuitions as well, and it appears you're right. Thanks!
I'm suprised no one posted [this image](http://i.imgur.com/gyU0me4.png) yet.
I recommend https://github.com/siriusphp/stratum (yes, I'm the creator). It requires less code and it doesn't use reflection.
That makes sense, since the [hash already contains the algorithm used for generating the hash](http://php.net/manual/en/images/2a34c7f2e658f6ae74f3869f2aa5886f-crypt-text-rendered.svg).
&gt;The PASSWORD_DEFAULT constant is currently set to use the Blowfish algorithm That's not strictly true. PASSWORD_DEFAULT will use bcrypt, which happens to use Blowfish internally as one component. Note Blowfish is not a hash, it's an encryption algorithm, so: &gt;Blowfish allows specifying the cost of generating the hash Is also incorrect. Edit: It's worth pointing out that the default cost of 10 is a little low these days, for most architectures (although plenty for an RPi for example). 
I don't really recommend using the library for anything too serious but https://github.com/camspiers/closureaccess does what you want.
This is the approach I am using and this is the library I use: https://github.com/kriansa/h2p
Looks nice. :) They're similar, but HookPHP provides some additional functionality. I think it would really just depend on the functionality someone needs. Nice work!
Only if they update blindly
What additional functionality? 
I don't want to 100% commit to this yet, because I'll have to figure out how to fit it into my copious amounts of spare time (cough), but [per Twitter earlier](https://twitter.com/LGnome/status/553289797830078464), I'm seriously considering creating and maintaining a patch set against 5.6 that will basically implement the deprecation notices that I wanted to see in 5.7. Patch sets are annoying  they're hard to maintain, and hard to use, since you have to build (or we'll need people to handle packaging, since I probably won't have time)  but it seems to make more sense to me to build this on top of the canonical parser, rather than writing a third party tool to check validity where it can. (I mean, someone will probably do that too.) Thoughts? Does that seem useful/useless?
Just wanted to reiterate the above response. We used all three of the above libraries and found them magnitudes slower than wkthtml. Wkhtml is also much easier to use and setup if that is a factor as well.
Some examples are listed on http://hookphp.org/
E_DEPRECATED (so the same in terms of behaviour), and yes, the intention was that 5.7 would only warn on things that were actually in 7.0 (which would have been doable, since 7.0's feature freeze would occur before 5.7 was tested and released).
Higher education in a nutshell. 
It doesn't require making additional classes, it works using a timeline style approach instead of a layer approach (not additional, just different), you can use it on any instantiated class without affecting other instances of that class (may be good, may be bad, depends), and it lets you remove hooks. That's about all I can see. But again, this may be entirely unnecessary, so it's just a matter of what a developer wants/needs.
Ok, so if upgrading to 5.7 is too much of a process and you would rather wait for 7... couldn't you just do that either way? If you don't want to bother with 5.7, couldn't you just ignore it and go right to 7 later?
Step 1) Stop using godaddy Step 2) use url rewriting in nginx or .htaccess
Or one could just disable E_DEPRECATED error, since it is likely that in 5.7 all the errors relating to PHP7 will be listed as deprecated.
Why do you need a workaround? What's wrong with index.php?
Some things I noticed after having a quick glance: * why is there a bower.json? Bower is generally used for front end stuff, and while it can be used for anything else, why not keep it in the place that was designed for this? I.e. composer. I'm not sure a lot of people agree with this, but for me bower is for front end development, composer is for PHP. Don't mix it. * Calling your class "H" is silly, it makes code unreadable. "H::hookObject"? Why not just call it `Hook::object();`? * What's the point of using composer but not using it's class loader system? No need to manually require files. * Try and keep to a decent standard such as PSR2 * You're using way too many static methods and variables. * I assume this is using a proxy class or similar (it looks like it from what I can see). No caching mechanism? * [really](https://github.com/sciactive/hookphp/blob/master/src/H.php#L143)?! * Not sure I like your testing mechanism. What's wrong with using the good ol' PHPUnit? EDIT: forgot to say, I fail to see anything useful from this when in production. Reflection and all that, not a good idea. The only place I can see this being useful is tests.
&gt; Have I missed something? ... some warnings that might BC in PHP7. There doesn't seem to be that many things that are not currently deprecated in 5.6.x that would be deprecated in 5.7.x It would be quite a large task to release and maintain a new minor version of PHP. There's only a small benefit for doing so, and the PHP project can spend people's time more effectively doing other things. In particular, tools to analyze code that you want to migrate from 5.6 to 7 and report any issues, or even generate the changes that need to be applied...which is less work, and should be more useful than a new version of 5.x 
Yes, that was just my response to /u/TransFattyAcid If he did not want to be disturbed about seeing such warnings in 5.7 he can suppress them, *provided* that if this *was* accepted. 
Is there a way to use this library without writing it to a file?
Seconds unless you have a good reason.
Wait a second...PHP uses $ for their variables. So they will never conflict. Class names should be capitalized, and keywords not, so it's unlikely they will conflict. Constants should be capitalized. The only things that might conflict are bare function names, but you shouldn't have too many of those either. Edit: Forgot about PHP's case insensitivity. Sorry folks.
&gt; how this is more secure It is not more secure than generating own salt. It's really more about convinience. And helps avoid rookie mistakes. Also, the hash function does provide an option to pass your own salt value. &gt; I could regenerate my rainbow tables with the known salt and regain efficiency Each password is stored with it's own salt. There is no one master salt value.
PHP is not case-sensitive. namespace The\Clone\Wars; won't parse. Edit: Fixed a mobile capitalization that confused someone.
How much is Sitecore? 
I know this is an introduction, but don't forget about `password_needs_rehash`. After authentication with `password_verify`, `password_needs_rehash` should be called to check for increased work factor or algorithm changes, and then update the password hash accordingly. The point of a work factor based hashing algorithm is that it increases over time to keep up with changes in hardware speed. While it's easy to add this to your application later, there's no reason not to add it at the beginning, even if you don't have a mechanism in place to increase the work factor every few years or so.
Yes.
&gt; Using PHP methods such as "array_intersect" would be considered "cheating". Why? It's in the language.
1. Because other projects that use this one in one of my larger projects use bower, so it makes it easier than having to run composer and bower every time. There is no downside to having a bower.json file in the repository. 2. Yeah, I see your point. For now, you can always do "use SciActive/H as Hook" 3. I do use Composer's class loading system. I don't say anywhere in the documentation that you shouldn't. Just that if you don't, this is how to make it work instead. 4. I don't like that coding style. You'll find that all of my code follows a strict style, just not PSR-2. 5. If you have a suggestion on improving the code, I'd love for you to submit a pull request or an issue on GitHub. :) 6. I'm not sure what you mean. 7. That is part of the larger project that I was talking about. It has no effect in any other project. 8. There's nothing wrong with it, and when I have some more free time, I'm going to write test cases in PHPUnit, absolutely. :D I find it quite useful in a number of applications. Maybe one day, you might find a use for it too. :)
Holy red flags, Batman. Not only is it a waste of time for both parties for an interviewer to ever ask the "best" (or, in this case, the "most efficient") answer to a particular problem (especially when the specific solution they have in mind isn't even objectively the best), but to discount alternative/creative solutions as "cheating" shows a real lack of insight into problem solving.
This is a relatively simple algorithm to perform. I'm sure you can even improve it with the use of the SPL library which has many C implementations, resulting in faster performance. While writing mine I kept thinking about the performance of in_array() and whether or not sorting the arrays before hand would improve performance. 1. Convert the strings to arrays. 2. Remove duplicate values. 3. Check for matches between arrays. &lt;?php function stringToSortedUniqueArray($string) { $arr = explode('', $string); // Convert string to array $unique = array_unique($arr); // Remove duplicates to improve sorting speed sort($unique); // Sort return $unique; } function findMatches($a, $b) { $a_unique = stringToSortedUniqueArray($a); $b_unique = stringToSortedUniqueArray($b); $matches = []; foreach ($a_unique as $char) { if (in_array($char, $b_unique)) { array_push($matches, $char); } } return $matches; }
Wow... I just realized I had a comment "// Sort" on the line where it... sorts using the... sort() function...
&gt; When did the opinion change on sha-256? I thought it was preferred even over sha512? Watch this: https://www.youtube.com/watch?v=eNdW5HWBhG0
You may have more luck in /r/PHPhelp.
thanks. added
This is the TL;DR of what was said.
Sad elephpant
&gt; I think the fact that you're +4 right now is very telling of the type of people who frequent this sub. so if someone in another group upvotes a member who said something similar then that will be unbiased.. right... moving on...
I'm with Phil on this one. I'm really saddened to see this declined. It would have been an excellent transitional tool as well as providing a longer period of security updates for those stuck on 5.x for whatever reasons. We already have major issues getting people to upgrade through major version changes and I think this would have really helped.
I personally try to not use UNIX timestamps at all. I'm much more keen on using ISO-8601 (`YYYY-MM-DDTHH:MM:SSZ`).
He appears as an hologram like Hari Seldon.
Arch official repos. Works out of the box.
I'd recommend the Engine Yard collection of posts (or any one of the other posts written with regards to password hashing in PHP): https://blog.engineyard.com/collections/password-security/
I think the idea of 5.7 would have been to introduce some deprecation notices gently - old apps still work but just generate more warnings in logs. Some users will notice these and will start dealing with them - making it easier to switch to 7. Without this, they'll have a "big bang" change when 7 arrives. 5.7 would not have been a mandatory upgrade - 5.6 straight to 7 will still be possible. But some people may have wanted to take advantage of a smoother upgrade path. The proposal being declined is not the end of the world - good software will be unit/functional tested against the versions it needs to run on. Unfortunately not all software is written like that, and the worry is that 7 may introduce enough breaking changes to seriously annoy a section of the userbase. 
Also if I am not mistaken you wont be able to use explode to split the string. Explode wont accept and empty string so you will need to use str_split.
There's a difference between [ALL CAPS](https://en.wikipedia.org/wiki/All_caps) and [capitalized](https://en.wikipedia.org/wiki/Capitalization).
I'd say neither - ISO8601 is a much better solution for a number of reasons, but the big one is that it encodes timezone information - something that is very important to distributed systems.
I assume it comes from a database? thats written to disk FYI. If you really want to be picky you could write to /dev/shm/ then its in memory.
I agree that PHP's standard way of dealing with HTTP Requests using super globals isn't very good. &gt;We need good HTTP abstractions to simplify web development The [Symfony HTTP Foundation Component](http://symfony.com/doc/current/components/http_foundation/index.html) has been widely adopted to solve this problem for HTTP Requests to the server and Responses from the server. Lots of frameworks already use this: Symfony, Laravel, Silex. Even Slim is trying to figure out how to use it: https://github.com/codeguy/Slim/issues/776 On the other side of the issue, for making HTTP Requests, Guzzle is the defacto industry standard. Much of the work in PSR-7 is based off of these two libraries. 
Without DI and a service manager likely very hard. The goal should be to have controller code that has a set of classes passed via the constructor to be used and not extending any base class. Like Symfony2 has the EngineInterface with one method renderResponse, now I can use their class or I can write my own class which implements EngineInterface to completely customise the renderResponse method. Via the DI configuration I can make the constructor be whatever class I like, the typehint simply ensures it matches what I want. Maybe if this was a user controller I would pass a UserRepository object in. Taken from the Symfony2 docs, aside from 1 interface this controller is completely decoupled from Symfony2, infact If the application wrote its own interface/class for the renderResponse you could move it from Framework to Framework (which supported DI) use Symfony\Bundle\FrameworkBundle\Templating\EngineInterface; class HelloController { private $templating; public function __construct(EngineInterface $templating) { $this-&gt;templating = $templating; } public function indexAction($name) { return $this-&gt;templating-&gt;renderResponse( 'AcmeHelloBundle:Hello:index.html.twig', array('name' =&gt; $name) ); } }
I think he meant PHP written in the past few days. I agree that PHP has evolved and you cannot compare php 5 to php 4 but still it's primitive compared to ruby python java etc. PHP libraries suck, PHP interpreter sucks. There's no JIT that would allow you to write clean code without worrying about performance. Garbage collector sucks and will suck because PHP language definition requires reference counting. There are multitude of inconsistencies in standard library. But the worst thing about PHP is PHP developers. They still use zend or cakephp and procedural programming even though there's symfony and laravel. They think that TDD is a thing in car engine. If there's a new library making things easier nobody uses it because "you can do it with pure PHP" (I'll not give you an example of that pure PHP approach because I'm disgusted).
Really good article. This helped me understand event sourcing better. Thanks Chris!
What you're looking for is called _code review_. - https://pay.reddit.com/r/codereview - https://codereview.stackexchange.com/questions Also whatever you're writing, a thread, an email, summarize your question directly in the title. To name a question "Question" is unhelpful.
Is the server you run your application on an encrypted disk? I assume all your api connection details for truevault are in somekind of .php/config file.. Anyone with SSH access could gain access to truevault via those details. With that in mind I don't think writing a PDF file to an encrypted filesystem to then upload it to the "Binary File Store" within Truevault is any real security risk, when anyone with access to the machine/ssh could gain those connection details.
&gt; It's worth pointing out that the default cost of 10 is a little low these days, for most architectures (although plenty for an RPi for example). I think that's misleading, 10 is a great baseline. Heck, even 8 is quite good. You can go higher, and if you have exceptionally powerful servers (or exceptionally sensitive accounts) you can go higher. But I don't think the average use-case should go much higher than 10 simply due to the added DOS risk. It's something that needs to be considered in the scope of a larger project.
&gt; When did the opinion change on sha-256? I thought it was preferred even over sha512? First off, no, sha-256 was never preferred over sha-512. In fact, sha-512 is more complex and therefore is slower to compute due to it using 64 bit primitives instead of sha-256's 32 bit primitives (which is a good thing in password hashing). Second, the hashing algorithm you pick depends on the use-case you're using it for. Are you computing a HMAC (Hash-based Message Authentication Code)? Then use either SHA-256 or SHA-512 in a hmac construction. If you're hashing passwords, than you need a slower construction (like PBKDF2 or bcrypt).
No, the capitalization of namespace had nothing to do with my comment. I was pointing out that /u/mahacctissoawsum was incorrect that you can avoid reserved word issues with capitalization because clone is a reserved word but Clone causes a parse error.
I stated that in my comment, but yeah and I think this is a fantastic change. That was just one example i had of "architectural weirdness". We are still slow to adopt at work though :(
You generally seem to be missing the point. A metric ton of man hours are spent every time a new version is released. This includes those folks who package new versions for the various distros, people who go through their checklists before deploying, and more. It's odd to propose spending that time, as a community, because folks who want to be proactive can't, instead, subscribe to a wiki page on php.net where backwards breaks are listed as they're added to PHP 7. 
&gt; I think he meant PHP written in the past few days. I agree that PHP has evolved and you cannot compare php 5 to php 4 but still it's primitive compared to ruby python java etc. Ruby has some cool features and Python is a solid language overall, but I don't think it's fair to say that PHP is "primitive" compared to them. For example, Ruby has no concept of typehinting or interfaces and relies 100% on duck typing. Java has a lot of nice features but I can't stand its verbosity and deep object inheritance graphs, but those are personal preferences more than complaints against the language. &gt; Garbage collector sucks and will suck because PHP language definition requires reference counting. There are multitude of inconsistencies in standard library. I agree about the standard library, but it's rarely impacted any impact on my productivity, same with the garbage collector (and iirc both Python and Ruby use reference counting as well). &gt; But the worst thing about PHP is PHP developers. That's always an issue with a language that has a low barrier of entry - just look at how many people are still writing absolutely *terrible* HTML and Javascript. Best one can do is attempt to educate them.
Maybe a dumb question, but wouldn't having PHP 5.7 possibly delay the development and release of PHP 7?
It would be great if PHP would implement the http request and response objects as part of the core. The amount of bootstraping code the Symfony2 HTTP Foundation components has is just too much if you look into it. Having it done as a PECL extension would be good enough as well. **EDIT**: Didn't see it, but there is an rfc proposing putting pecl_http into core. https://wiki.php.net/rfc/pecl_http Discussion: http://comments.gmane.org/gmane.comp.php.devel/89542
You edited the post to show "namespace" and not "Namespace". PHP *is* mostly case sensitive. The namespace syntax, however, is not.
Surely you couldn't just have warnings for a reserved word?
Are you storing the whole salt+hash as one string (the only reason I can think of for the"hash changes upon every input"). You should be able to repurpose the `password_verify()` function to match.
Then get better interview questions.
Without seeing code, it's impossible to say for sure, but my guess is you're possibly using a automatically generated salt (or generating a new salt every time). This is great for passwords, where you don't want or need the same string to every appear, and you're only ever comparing one stored password hash to one input string, but when you want a database you can search through this would mean having to pull out every single result, then compare it to the particular string. What you want to do is hash the entire database of email addresses using the same salt. Example: php &gt; $a = password_hash('foo', PASSWORD_BCRYPT, ['salt' =&gt; '1234567890123456789012']); php &gt; $b = password_hash('foo', PASSWORD_BCRYPT, ['salt' =&gt; '1234567890123456789012']); php &gt; $c = password_hash('foo', PASSWORD_BCRYPT, [] /* autogenerated salt */ ); php &gt; var_dump($a); var_dump($b); var_dump($c); string(60) "$2y$10$123456789012345678901uCRRbKE34vdIbfHf0dfmKnb/hHuUqIyu" string(60) "$2y$10$123456789012345678901uCRRbKE34vdIbfHf0dfmKnb/hHuUqIyu" string(60) "$2y$10$Fx/xB333AcHWjYFYdCvZSO9zgwQDycTHTIQpS6bn2oIfzr7C7PM6i" Strings A &amp; B match because they used the same salt (note how the salt is stored as part of the hashed value), while C does not because it uses a different hash. I used password_hash in the example above because I was being lazy, but you may want to use [hash()](http://php.net/manual/en/function.hash.php) instead
Yep, I currently have a transformer class so all I'd have to do is put a '* 1000' in my function.
Yeah the database is going to published publicly for transparency reasons but the emails need to be hashed so that the end user can't figure them out. The PHP script is only outputting a simple Yes/No checked against the database.
Yeah I meant to say "... the concept of release management **in PHP**." Sorry about that &gt; Different projects have different requirements, and different projects follow different release procedures Right. They do, and PHP do it differently to how you'd like to see it done. I think it makes sense to know if you're aiming for a new minor version or not, instead of just slapping them out every X months or every time substantial new Y is added. It is especially important to plan the goals of versions given the context of PHP 5.7. its entire goal was to add a bridge version which would specifically deprecate functionality that would be dropped in PHP 7. Nothing wrong with any of this. As you say, various projects work differently. 
&gt; but the emails need to be hashed so that the end user can't figure them out That's not possible. If a user can efficiently look up one email, they can simply try emails over-and-over to see if one is in there. This is brute forcing. And you can't really protect against it at all (considering it's the design of your system in the first place).
Sure, I gathered that. I explained why I thought broadly it was a good idea. (Not your DV, incidentally). 
Sorry, I misread
Look at the RFC this way: "Is there going to be another minor or not?" This puts a lot of things into context, such as "Can we remove functionality in PHP 7 that has not yet been deprecated, such as PHP 4 style constructors?" This: https://wiki.php.net/rfc/remove_php4_constructors If there is no later minor after PHP 5.6 then the entire discussion for that RFC is completely different. If there is deprecation its fair and stepping from 5.6 to 5.7 to 7.0 is nice and easy, but if there is not deprecation the jump from 5.6 to 7.0 is much bigger.
The same chap from Guzzle put a lot of work into PSR-7 before MWOP took over. Josh has also experimented with PSR-7 in previous iterations for Slim. The sooner it is implemented the better for all of these projects that are interested but coding against a moving goal.
The symfony http foundation a bad abstraction for this sort of thing. Yes, it's the best thing we have (for now), but far from optimal, which is why we need PSR-7
Well, sure - if you're doing thousands of calls like this, the difference would likely be very apparent. I actually spent a good amount of time to reduce the memory footprint but generally these approaches are object-heavy and rely solely on user-land code. The fastest solution would be to write a C++ extension to PHP to allow this behavior. However, that probably isn't recommended as any changes to the object model would break it whereas user-land solutions will likely always work.
Head over to the internals ML to give them your constructive feedback. Pretending the entire RFC process is perfect would be insane, but I believe 1. there should be a 5.7 2. it wasn't a bad idea to ask how people felt about that idea with a vote and an RFC
phparch.com is 161,128
thanks
I honestly thought this was common knowledge... I don't think I've ever ran into a programmer, developer or cs major that though programming was math, the part about people being bilingual makes sense - but at the same time speaking 2 languages doesn't make you a logical, process driven individual with problem solving abilities... being a natural with math leans to those qualities which is where the idea that being good with math means you'll be good at programming comes from. Not to mention anybody with a CS degree who goes into high level development jobs is a waste of their degree, anytime I see that, they should be working on game engines, financial software and other things, that rely on real math - advanced equations, physics, algorithms more difficult that 2(x)=y (most the shit you run into in high level languages). 
Thanks for the input. I feel like this is technically feasible currently as the request, response, and view objects are all interfaces that the controller makes use of. Will be a lot simpler once I get the DI stuff implemented.
If you have BC breaks, either: - 5.7 starts spewing **notices**, and your program still works while you upgrade it to not spew notices. - 7.0 starts spewing **errors**, and your program breaks until all errors are fixed.
I've not had chance to use it yet, but [jqGraph](http://jpgraph.net/) does the job server-side outputting images.
impressive, given that you cant read
Thanks, I'd come across that one but it has been abandoned, no updates in 5 years.
You could mount a ramdisk and write it there.
Thanks, I didn't know that. We already use HighCharts and own a license so this could be viable option. Its a few more hoops than I wanted to jump through but I can make it work.
We use [pChart](http://www.pchart.net/) in the application I work on. Seems to work well. I don't use it personally, but the other developer here does and says it's pretty good, although we don't have real complicated requirements.
FusionCharts...We've used pCharts in the past, and google charts, and a couple of other ones. But yeah, FusionCharts is what we're using now (mostly) and we're very happy with it.
Thanks I've come across that one. Not sure why I ruled it out initially, probably the license price. I will revisit it.
I am slightly out of topic and I'm probably nitpicking, but about middlewares: function (request, response) { } Why would the response be provided? The response should be returned. It looks like the pattern quite common in C where you provide a `result` parameter and expect the function to fill it, while the function returns a status code. Symfony's `HttpKernelInterface` approach looks more sensible to me: /** * @return response */ function (request) {} That's exactly how it works with [Stack](http://stackphp.com). After all, a function, program or HTTP server takes parameters (aka request) and returns a response/result.
Thanks this was mentioned by another user and is currently looking like the best option.
I agree that getting it implemented soon would be awesome, but it's such a huge part of PHP that I'd rather it took a year and was done right rather than rushed through.
Basically its just shit: "Do write secure code", "Don't write insecure code", job done! EDIT: OWASP I mean, not OP's article.
This looks awesome, thanks!
"Least efficient"... Well, let's see. You're making a full pass over `$a` and then in the worst case a full pass over `$b` for each character. So your worst-case solution is `O(n * m)` (where `n` is the scale of `$a` and `m` is the scale of `$b`). But your best case (`$a` is "aaaa..." and `$b` is `"a"`) would be `O(n)`. So far, pretty good already. But your average case would be `O(n * m)` (since we'd expect `m/2` and O() notation eliminates scalars). Let's see if we can reduce that. Well, we need to do at least one full pass over `$a`. So the minimum worst-case is going to be `O(n)`. The question comes what can we do to `$b` to reduce the expected runtime? Imagine we computed a [Hash Table](http://en.wikipedia.org/wiki/Hash_table) for all characters in `$b`: $bChars = []; for ($i = 0; $i &lt; strlen($b); $i++) { $bChars[$b[$i]] = 1; } We now have a mapping of `[$character =&gt; 1]`, which was computed in `O(m)` time. And a hash table lookup is `O(1)` best-case, so an implementation of: $matches = []; for ($i = 0; $i &lt; strlen($a); $i++) { if (isset($bChars[$a[$i]])) { $matches[] = $a; } } Would have an expected best-case of `O(n + m)` (however since this addition is linear, we can reduce that to `O(n)` by convention), since the hash-table lookup's (`$bChars[$a[$i]]`) best-case is `O(1)`. However, the hash-table's worst-case is `O(m)`. Which means that someone can create a string where all of the characters hash to the same value. So the overall worst-case `$bChars[$a[$i]]` lookup would be `O(m)`. **NOTE**: in the specifics of 255-byte characters, this will not come into play as per [/u/nikic](https://www.reddit.com/user/nikic)'s comment. I'm leaving the analysis as it's applicable in the general sense (not indexing characters, but arbitrary values). So far, our code is the following: $bChars = []; for ($i = 0; $i &lt; strlen($b); $i++) { $bChars[$b[$i]] = 1; } $matches = []; for ($i = 0; $i &lt; strlen($a); $i++) { if (isset($bChars[$a[$i]])) { $matches[] = $a; } } Which has a time-complexity of `O(n)` (best case) or `O(n*m)` - otherwise known as `O(n^2)` (worst case). And the average case would be `O(n)`. Can we do better? Well, we know we can't do better in the best case. But can we do better in the worst case? Actually, yes we can. Instead of using a hash table, we could use a [B-Tree](http://en.wikipedia.org/wiki/B-tree). Since characters are ordered, we can create an effective index of the table. Since balanced b-trees are non-trivial to construct, I'll leave that as an exercise for the reader. $tree = new BTree(); for ($i = 0; $i &lt; strlen($b); $i++) { $tree-&gt;insert($b[$i]); } $matches = []; for ($i = 0; $i &lt; strlen($a); $i++) { if ($tree-&gt;contains($a[$i])) { $matches[] = $a; } } Then our best-case lookup will be the same as the worst-case which will be `O(log m)`. Which will bring our overall lookup cost in both the best, average and worst cases to `O(n log m)`. Which means the best-case and average case got worse, but our worst-case got better. So in the worst-case, your solution is just as expensive as the hash table one (with the b-tree based being most efficient). In the average case, the hash table is far more efficient than either of the other two (with yours being the least efficient). In the best-case, both your and the hash table are the most efficient. So the end result is what do you want to optimize for? Best-case? Average-case? Or worst-case? If you want the best best-case or average-case, go for a hash-table. If you want the best worse-case, go for a b-tree. In the case of strings, just use the hash table as the best, worst and average case is `O(n)` as long as you're talking *ascii* strings.
Well, let's analyze each function call. Assuming the scale of `$string1` is `n` and `$string2` `m`: * `str_split($string1)` - `O(n)` * `array_flip(str_split($string1))` - `O(n)` * `str_split($string2)` - `O(m)` * `array_flip(str_split($string2))` - `O(m)` * `array_intersect_key(...)` - `O(n * m)` confirmed via [the source](http://lxr.php.net/xref/PHP_TRUNK/ext/standard/array.c#php_array_intersect) * `array_keys(...)` - `O(n)` So overall it has a best-case of `O(n * m)`, a worst-case of `O(n * m)` and an average-case of `O(n * m)`. Which is exactly as complex as the original implementation :-) **HOWEVER** since the arrays passed to `array_intersect_key` are limited to 256 unique values, the whole operation becomes `O(1)`. Therefore the complexity in this case comes out to `O(n)`, which is effectively the same as the hash table operation.
I don't think your analysis regarding the hashtables is correct. PHP strings are binary, as such there at most 256 distinct characters. Even assuming all of them collide, a hash lookup would still be an O(1) operation, as the upper bound is independent of `m` and `n`. Though in practical terms, where the hash function for one character strings degenerates to `($offset + ord($chr)) % $tableSize`, the best you can do are 16 collisions, for the case where the string only contains 16 characters with an offset of 16 each. (Note: I did not verify this claim.)
I still use jpgraph. It's solid for what it does. Very little work to get implemented and has most of the features anyone could need. Produces some good looking charts too. 
chartjs combined with phantomjs? it sounds stupid but it may work, phantomjs renders the page on the serverside with a headless webkit browser and then you can output it to a png or pdf and save it or display it
Can you not just publish the database without the email column? The moment you say "I hashed it so it's unreadable", there's nothing that it adds to transparency anyway.
Not a fair comparison at all. A ruby install isn't any more complicated than a php install -- they should both require running a single command using your package manager of choice. The article you linked to describes steps for setting up additional tools (rbenv, composer, rvm) which provide functionality you don't get from a standard php installation, specifically dependency management and support for multiple self-contained environments and interpreter versions.
You both just introduced a vulnerability called LFI (Local File Inclusion): http://hakipedia.com/index.php/Local_File_Inclusion
Only other columns are id and date added. Nothing else of value. 
Passing in the response has the advantage that you typehint the response class. You do not create it inside, so the middleware does not bind do a specific response implementation. If you decorate middlewares, you might want to do something with the response, pass it in, and do something more with the response afterwards. And you might want have a list of middlewares that work one after another on the response, e.g. the first creating the actual response content, the second rewriting links, the third replacing some stuff, etc.
Regardless of the method you use to find the matches, I'd make use of similar_text() to know how many matches there are, then stop searching when I hit that number. Why search past the max 
In case OP is confused... Your prof is comparing a programming language (PHP) with a framework for a programming language (Rails).
It's not about which specific functionalities these steps are providing, it's about how they can [break themselves along the way](https://www.google.com/webhp?sourceid=chrome-instant&amp;rlz=1C1ASUM_enUS461US461&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=ruby%20install%20broken). All of my RoR friends have countless horror stories about fritzed setups. I have none in PHP. 
I'm working on a similar project. There are a few options, like jpGraph, but to be honest, they are all pretty ugly. My product manager is not thrilled with their aesthetic potential. 
So if you can't figure out rvm/rbenv, don't use them... They are totally optional, and are just there to make life easier for developers. They make it easy to ensure the software you're running in your dev environment matches the software you run in prod, without requiring you to use a vm for each app. If you're serious about developing quality php apps, you'll eventually setup something similar, and every solution will have its own set of issues.
Try not to rub it in people's faces and you might get some value out of it (which I doubt).
Well done man. You're a better person than me! I'm too lazy to do my Zend certification. 
I entirely write my own graphs in whatever image library is available. I find any graph lib to be more work than just doing it yourself.
They still aren't Capitalized, as capitalized infers only the first letter, but semantics. The wording didnt seem clear to me
I'd say knowing your toolbox well is a big part of any trade. The people you want to watch out for, are the ones who come up with crazy "algorithms" for simple problems, not the ones who are smart enough to use every tool at their disposal. I understand that you're trying to test creative thinking, but a creative thinker does not a good developer make.
[Relevant xkcd](http://imgs.xkcd.com/comics/lojban.png)
This looks nice, though! Thanks.
Thanks. I had an environment issue that caused git to fail when run via php's exec. 2&gt;&amp;1 allowed me to see the error and I eventually solved the problem.
&gt; It's heavily inspired by CodeIgniter Just to let you know it's 2015, it should be inspired by Symfony2/Silex or Laravel ;) Can't you add composer and implement namespaces for example?
where have you read it is becoming deprecated?
I am 99% positive that it is ONLY the IMAGE API. The JS + SVG Google Charts API is NOT BEING DEPRECIATED. 
Add http://www. to the href of your link. Should resolve the issue. 
I suggest you take a look at Gitter instead, it's a package built for interacting with Git repositories: https://github.com/klaussilveira/gitter
Here are some other (free) charting libraries to use: chartjs - limited number of charts but active development on github http://www.chartjs.org/ d3js - extremely powerful. enjoy banging your head against the desk; this library is for you! http://d3js.org/ flot - larger community, more charts, plugins.. sometimes buggy.. also on github http://www.flotcharts.org/ 
Sorry I should have been more clear. I'm talking specifically about the image API. 
Sorry I should have been more clear. I'm talking specifically about the image API. 
TL;DR: You can't do magic by switching to nginx or vice versa: think of switching to hhvm instead. I've been using both apache and nginx in production environments for years now and my conclusion is: Normally your php application is your bottleneck anyway (in terms of cpu, io, memory or bandwith usage (either directly or via a db it's using). So when you've configured your webserver correctly ther in fact is no significant benefit on either side. If you're server isn't capable of dealing with say 100 parallel user interactions you better think of switching to hhvm which has a huge effect on youe php's cpu and memory footprint. 
Oh absolutely, but rushed is a fairly loaded term. Every time somebody tries to finalize the Cache PSR somebody screams "dont rush it", and that damn thing has been going for about 9 years now.
That site looks sketchy
...yes? Apparently this won't solve the matter though.
I've used jpGraph a lot of while it is absolutely crap, it does work. The main issue with it is its API. Customising the charts in unusual ways often requires lots of different method calls which would seem to have the same meaning like you'll have to call setColour, setLineColor, line-&gt;setColor to set the colour of a line (not actual methods but you get the idea).
If you're trying to determine whether emails are valid (by attempting to connect the SMTP servers), I can make two recommendations: 1) Pre-screen based on the domain name. A lot of invalid addresses can be outright rejected because the domain does not exist or has no MX records (if you have a list of known disposable domains or other domains you want to filter against, this can also be done at this stage). You can also screen for "NULL MX" records (there's actually a [ draft RFC for this](https://tools.ietf.org/html/draft-ietf-appsawg-nullmx-10), but there also domains that have MX records pointing to invalid IPs such as 0.0.0.0, or unreachable / reserved IPs such as 127.0.0.1 / 192.168.*.*) (Yes, technically a domain can accept email without an MX record using the A record as a fallback, according to RFCs, but this behaviour is technically deprecated and I've yet to find evidence of any valid emailable domains actually relying on this) You will want to make sure you have a fast, reliable DNS server for this. 2) Use a service to screen the remainder (such as [BriteVerify](http://www.briteverify.com/)) - they do a lot of leg work in terms of problems you'll encounter attempting to do such SMTP checks (the range of responses you can get from SMTP servers, grey listing, etc) as well as implement workarounds using alternative methods for some of the big providers that SMTP checks don't work for (either because they actively try to block such behaviour, or because their setup is such that they will often initially accept anything and then reject later). The big providers will also give you problems with rate limits and obviously services like BriteVerify have ways to mitigate this sort of thing (caches, or I would assume if you upload a file rather than doing instant API checks, space out the requests to avoid them). If you're intending to do this long-term, there's a lot more fun you can have with things like monitoring WHOIS records / domain registration status. There's also at least a couple of big anti-spam providers who own a lot of domains which I highly suspect are pure spam traps. ---- Of course, the best and easiest method of verifying email addresses is double opt-in, where you require users to click a link or enter a value sent to them in an email. Any good bulk-ESP service should also be able to help you monitor how recently you successfully mailed addresses and how frequently you get errors and/or positive activity from them (opens / clicks / even further activity with triggers added to your website / CRM / other customer interaction points)
How does this website look sketchy? It's well established and there are many projects already hosted there that are doing very well. It's also probably the best way at the moment to get people to help you work on a project and scope out interest for developers, designers etc. It will also give you tools to help you communicate with those developers. It basically breaks down all walls you will find when trying to start a project like this
There's an xkcd for everything.
Uhh why are you outputting an entire HTML document into the footer of another HTML document? That is probably ignored by most browsers, which is the only reason it works at all. The way this would be done with fewer compatibility issues is to give the client a piece of code that places an &lt;iframe&gt; into the page, which loads your footer page. Usually this is accomplished with Javascript to make it easy for them, because the &lt;iframe&gt; will need styling to remove borders and scrollbars to make it invisible. Using your current method, you're also forcing every single page of every single client's website to do a round-trip to your server for an HTML file *synchronously* before any content is returned to the visitor. With the &lt;iframe&gt; method, at least retrieving your footer HTML document is opening a new connection and downloading in parallel and the visitor's browser can cache that page. If your server goes down, you effectively take down all of your clients' websites. The default PHP page timeout is 30 seconds, and there is no explicit timeout on the request for your footer file, which would slow those sites down so much as to be unusable.
It appears to be trying to monetize a GPL project. I have no desire to do that.
DaniWeb.com is nice; StackOverflow is alright.
Looks like we're leading the church of ~~Vim~~ ~~God~~ Satan then boys... As for; &gt;with stubborn team members pretending they're doing just fine with VIM We don't pretend we're doing "just fine", we're doing fucking fabulous.
Not really sure what to say, I see it's "vanilla PHP", but even so, there doesn't seem to be any structure to the app. Everything is in root, OO is non existent, you have variables which aren't checked properly which will throw notices for undefined vars. Well you do have some OO in after a deeper look, lack of comments though and precariously named methods `getinfomu()` `crkey()`. In my eyes it's not really modular, nor modern, I can't see how I can snap "modules" in and out. However good luck with it.
I think that particular one is just the skeleton for building an API centric project on Orno components. I don't think the brand name is actually "skeleton". I do, however, think the OP has selected Skeleton as his particular "brand name" for his project though. Unbeknownst to him, this particular term in the php/composer world of late means something specific: a package that is intended to serve as the basis for a composer create-project command. So, it's choice is likely not a best-of-breed name for a new project. Ha, putting "skeleton" into packagist brings up at least 25 pages of repos. Interesting.
Yeah, I had a chuckle at "vanilla PHP"...
This strikes me as a situation where {$this-&gt;c}(); should work, but I just tested and it doesn't. I get an error for unexpected }. Why can't we use curly braces like this?
I'm writing my own &lt;svg&gt; inline generators. I should find/make a library...
I wrote to the author and explained that to him several years ago. He responded that he would fix this but never did. It's a shame because the library is nice but with those muddy license terms it's unusable. 
Having a URL should never be sufficient to gain access to a resource. If it's a security risk with the shortener, it's a security risk without it. (Or don't you think that Google indexes the URLs in their customers' emails?)
Why would anyone even **need** a "platform" for shortening URLs? 
The only problem is MailChimp are fairly anti-spam and you'll be reprimanded with a high enough bounce or non-open rate
Pretty good for companies that want to use their own domain, handy for tweeting and sharing on Facebook, plus you could have your own custom analytics/marketing when the user lands.