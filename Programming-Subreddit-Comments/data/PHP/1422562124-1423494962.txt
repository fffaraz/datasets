What are you using now?
Oh, I see how some people might find this statement confusing. PHP has the stronger OO system, it's just not used as pervasively throughout the language. Using the example of Java again: The language has a strong OO system with all the bells and whistles, but it does not have any "everything is an object" semantics - the primitives are separate. Personally I simply consider having proper interfaces and optional type specifications to be much more important than being able to call methods on an integer - I would love to have that in PHP (well, at least for arrays), but it's more of a syntactical gimmick to me. Other people view this differently for sure. Some would say that PHP's OO model is too old-school and not dynamic enough (monkey patching anyone?). There's different schools of thought here and I'm usually on the conservative side.
&gt; but behind-the-scenes manipulation with Imagick and GD are still preferable for most purposes if you know in advance what image manipulations are going to be needed That's one of the huge benefits of using a library like Glide—you don't have to know which manipulations you need ahead of time.
There is [php mess detector](http://phpmd.org/) and [php code sniffer](http://pear.php.net/package/PHP_CodeSniffer/redirected), but the downside is you sort of have to come up with your own rules for what you consider good or poor code quality, which can be quite a bit of effort. As far as I know, out of the box they check the obvious stuff like code formatting, but you have to tell them to look for anti-patterns like service location, or god classes, or too much n-path complexity etc...
What is MI
I'm really surprised and horrified that nobody here has mentioned the single biggest asset that PHP has... A strong community.
Why would anyone do development on windows? Ok, I know. You're on windows, why make things harder on yourself by adding another unknown (some unknown OS) into the mix? OTH, chances are that the finished product will run on Linux, so why not spend that week getting up to speed on the basics - a simple virtual machine with practically everything working out of the box, and be done with it? You'll be clear of almost all the annoyances windows users fight with on a daily basis. Of course, you may miss some niceties, though I can't think of anything specific - MSOffice perhaps. My personal experience is that setting up a Linux machine from zero to actively working takes between 1 and 3 hours depending on how much you need (once I broke my HDD close to a serious deadline, and still 4 hours later I had bought a new HDD, installed it, reinstalled my system recreated all data from backup and was back working). 
We have a Laravel/Klein application that we've been developing for the past half year. It is in a pretty good state in my opinion but I would always enjoy written reports about it. May I ask how does codeclimate works, and how is it smart enough to give us guidance? If you can explain the basics, I would be really interested to try it, and purchase it for our company most likely.
In future videos, consider watching your habit of using a [high rising terminal](http://en.wikipedia.org/wiki/High_rising_terminal). Otherwise, great video. 
Seconded. 
I went through the set up process, and every time I try and bring the box up, I get these errors: * The 'before-provision' provisioner could not be found. * The 'cleanup-nginx' provisioner could not be found. * The 'add-nginx-host:hhvm.app' provisioner could not be found. * The 'add-env-vars' provisioner could not be found. * The 'after-provision' provisioner could not be found. * The 'update-composer' provisioner could not be found. * The 'restart-services' provisioner could not be found. Did I miss a step? Or do I need to install something else?
As other have noted - don't expect the best performance out of a windows server running a PHP stack. Certainly don't use nginx - it's not performant under windows as the documents note due to limitations in windows APIs. It's really only built for development. With Apache - you should fare okay - with mod_php - doubt PHP-FPM will get you far. You might want to even look at IIS as the web server and back PHP onto that - might work a little better. Best of luck - certainly not a situation I would want :)
&gt;Unless you’re developing from day one to be scalable (abstracted data store instead of file system, centralized sessions vs on disk, etc), you’ll have some retooling to do. If you're not developing with scale in mind (it's not that hard), then I'd you've got bigger things to worry about than a couple of ms in the **base** load time of your framework. Increasing performance at the framework level would be the last area you would target. You will get orders of magnitude better performance with decent caching. The overhead of the framework is really not that important. If it was, then PHP wouldn't be a thing.
It's also a billion times better with [Carbon](https://github.com/briannesbitt/Carbon)
&gt; it is a C extension [...] not wanting to learn C That was my main concern initially, but it isn't any more, from version 2.0 - sort of: It's written in a special language called zephir which is *very* close to php but compiles to pure c which is then compiled to the extension. This means that you, with your php knowledge will be able to learn how to write php extensions in a couple of hours - no joke! I did it. I even patched a bug in the main library very easily. What I find so amazing about this is that if I have a php class that's doing something heavy I can easily rewrite it as an extension and gain the speed advantage. If you know c you would even be able to fine tune the resulting c-code before the final compilation. &gt;With speed i find the majority of time spent is in the database, applying business rules or processing That's true. It's also true that the general speed of php is going up on all fronts, so whatever speed advantage phalcon may have is fading. There is one advantage, though, to the extension strategy, with the zephir language: It allows me to remove framework code/clutter that IMO ought to be a blackbox. But then again I'm not so experienced.
&gt; IMO, the customer should make decisions based on the advices they receive from the professionals they hired. If they completely disregard those, they most likely belong to a category of unpleasant people to work with, who think they know what they need but they actually don't, and will inevitably make things go FUBAR. A consultant is there to offer informed advice, not dictate. There could be a number of reasons an organization is locked to a particular technology stack. It's not black and white where either they do exactly what is advised or they completely disregard. &gt; Technically, the WAMP stack has no reason to be preferred to a LAMP stack, and I'm not talking out of my ass, I actually have experienced the pain of dealing with such an abomination. Anecdotes! I've had both great and terrible experiences with both Linux and Windows stacks. What's true for you isn't universal. &gt; In the days of virtualization, dev environment abstraction and Vagrant, this whole concept is now preposterous. Production grade virtualization isn't always that easy or cheap. Vagrant is great for development environments, and I've seen great success using it to provision cloud servers as well. However, to do so on dedicated hardware requires a compatible (and non-free) hypervisor and associated management infrastructure. VirtualBox, while great, is not production grade and isn't intended to be so. &gt; Production usage was NEVER a thing with the WAMP stack. If you do use it for such a case, you will have to deal with a series of problems (e.g. security, file system, system calls, performance, third party libraries, extensions woes, lack of documentation resources) that you wouldn't have normally, so I don't really see the point of it. I disagree. Working for the M vendor in *AMP, I can tell you production usage on Windows is most definitely a thing. Apache has been production grade on Windows for quite a while, though you do need to fetch third-party binary builds or build it yourself. Microsoft's Open Source group has been very active in providing support and resources to bring much of the *AMP stack to parity on Windows. There's still some work to do, as I've noted elsewhere, but the issues are well documented. &gt; Furthermore, if you don't have the know-how to manage a LAMP stack, you're SOOL for WAMP too, because most of it involves the services, not the OS. How do you figure? Managing Windows is a completely different beast compared to managing Linux. The OS most definitely is the biggest piece that's different. I've seen inexperienced admins completely fuck up a Linux system whereas the Windows servers under their control ran perfectly (more anecdotes!). The software packages are far easier to manage. &gt; Seriously, if you're really desperate to run a PHP application on Windows, it should be more natural asking about IIS+MSSQL+PHP (which is still sub optimal, by the way) rather than an entirely different stack on top of the wrong OS. Actually, the fact that this wasn't even considered is a symptom that these guys don't know what they're doing at all. I suggested IIS in my reply to OP. It's often overlooked by people with purely Linux experience, but it makes the most sense for Windows Server deployments. It is a performant Web platform - for some workloads, IIS benchmarks higher than other Linux-based platforms. &gt; In the end the bottom line really is that the platform should be defined by the requirements established while designing an application, not the other way around. In an ideal world yes. Reality rarely lines up with the ideal. It's better to learn how to adapt than to throw a tantrum about not getting your way (just to clarify: not saying you are, but I have seen it happen). OP posted a question about the best way to proceed when Windows is a requirement. I think the mistake made was assuming WAMP, but Windows was the hard requirement. Everybody naysaying and bitching about Windows are being counter-productive, and showing their inability to adapt.
Yup, been saying this for ages. /u/pmjones has been doing a lot of these tests and he always gets shouted at too. To me, a framework benchmark is one metric. Imagine watching Top Gear and they did a car review. They'd tell you the 0-60 mph speed, top speed, handling, dashboard, etc. There are a lot of metrics to know if a certain car is "better" and obviously it all very much depends on what you want out of the car. The framework benchmark is the 0-60mph speed, and I want to know it. These benchmarks are not useless, they're just normally done really f**king poorly.
If I were that concerned about execution speed, I wouldn't use PHP in the first place. There are lots of other factors which make a much more meaningful impact on the application's performance. Code execution speed is rarely the problem - I/O is. 
PHP's biggest strength is that others have most likely encountered your issues and solved them for you. i've thought about starting projects using new languages, but one thing keeps me from doing do. 99.99% of my problems have been solved in PHP. if your project gets big &amp; complex enough, you're going to run into weird roadblocks &amp; issues. most of the time, these have been solved for me by someone else in PHP. i'm not talking about PHP specific issues (although we run into those as well), but general development issues. along the same train of thought, over the years i've run into most of PHP's quirks &amp; limitations, and figured out way to offset them. i'm not sure i want to replay that game in a different language.
which always works great until you use it on a big file ;)
&gt; If I were that concerned about execution speed, I wouldn't use PHP in the first place. Just for the sake of argument: if, with your current php knowledge, you could achieve speed comparable to other fast languages, wouldn't that be worth it? It's just a thought and Phalcon is probably not the solution. I've been wanting to start with Go myself but haven't had a good enough use case yet.
On a different note, learn golang. I like playing with it. If you're on an efficiency trip that may cure it for a bit.
I highly recommend you PHP The Right Way. http://www.phptherightway.com/ Why, from the welcome page: There’s a lot of outdated information on the Web that leads new PHP users astray, propagating bad practices and insecure code. PHP: The Right Way is an easy-to-read, quick reference for PHP popular coding standards, links to authoritative tutorials around the Web and what the contributors consider to be best practices at the present time. There is no canonical way to use PHP. This website aims to introduce new PHP developers to some topics which they may not discover until it is too late, and aims to give seasoned pros some fresh ideas on those topics they’ve been doing for years without ever reconsidering. This website will also not tell you which tools to use, but instead offer suggestions for multiple options, when possible explaining the differences in approach and use-case.
&gt; golang Isn't that Go?
Probably because that would make it a different language or that the changes don't actually do what the people insisting on them do or have more downsides. Care to give an example of a 'fix the language' so I can analyse it in depth?
Never had a problem with big files, even logs of years long time in production 
Yes, I'm using VB, and it looks like Vagrant was at 1.6. Sorry, I must have scanned over that on the instructions. I upgraded, and now after running "nexus up", it goes through the boot process, and is now stuck on the trying to connect. I am getting this: default: SSH auth method: private key default: Warning: Connection timeout. Retrying... default: Warning: Authentication failure. Retrying... default: Warning: Authentication failure. Retrying... default: Warning: Authentication failure. Retrying... And it keeps on going like this. I've had this problem with Vagrant before, but it usually doesn't keep going. It will right itself after about the third or fourth attempt. Any ideas? 
Me either! I've never actually been excited about the upcoming release of a programming language before.
PHP7 will be fairly easy but HHVM will take likely more than a few years. Getting the Zephir JIT and debugger tools finished is a priority.
People refer to it as "golang" so they can find information about it with google.
&gt;what do you consider to be PHP's biggest strengths that have attributed to it's growth, adoption rate and popularity? No matter what /r/lolphp thinks, it's a mature language that runs tons of quality code (and tons of shitty code, but hey... you give a man a hammer, he gets to choose what to do with it). Sure, it could be remade into not having a few quirks, but it no longer has such a luxury - PHP has to have backward compatibility. Anywhoo... It has a great deal of support for newbies, and plenty of support in terms of 3rd party libraries and frameworks, not to mention that it's compatible with almost every popular HTTP server out there. Why? Because when it appeared, no matter how simple it was, there was literally nothing out there that could stand a change of being easier, cheaper and faster to implement. The average Joe could have a dynamic website, and all that paved the way over to the new web as we know it today. I find that to be awesome. It's a language designed for the web, and it does that well. While you may find other languages powering OS native apps as well as web apps, PHP is mostly well suited for churning out HTML data to the client's browser... and for that, it's absolutely perfect. *Why will it get tons of flak?* A few years ago, when you created a shitty project in your favorite programming language, it remained on your PC, or you perhaps shared it with a few friends... maybe posted it on an online forum, but that's it. These days, when you create a web application, it's visible to everyone in every timezone. It can be viewed by millions, it can be criticized, it can be targeted by netsec experts... it's not a good platform for a beginner to be on. Frameworks based on Python, for example, have a higher hurdle to jump over, and thus newbies will stick more to PHP than to other language/framework combos.
So that's what you call that. :) Yeah, I noticed I was doing that after I finished the recording. Super weird. Thanks for the pointer!
Sure is, and it might surprise you: it's cscope. It's not perfect (the interface is limited to symbols, so if you've got the same method in a bunch of different classes `:cscope find g` will end up giving you a pretty large list), but it's usable enough.
Is HHVM going to be the default engine for PHP7?
make the table using the web GUI. Or in the `sql` tab for your database you can paste the statement and click run. EDIT: seriously go watch a youtube video on "how to use phpmyadmin" the 30 second video will help you more than anyone trying to type usage directions here.
No, PHP-NG is https://wiki.php.net/phpng
yeah i was looking for the sql tab in myphpadmin also, any general web gui ? is that why you are referring to? 
Actually they do help with the time spent in database as well. Phalcon built an entire ORM in c as well, which really helps with keeping memory size low which as a side affect makes your db request faster. I know that may seem confusing but as data grows in your php application (Like when doing an unbuffered sql call) more time than you think is spent allocating memory and getting it ready to return to you. Their orm makes efficient use of pointers that keeps data smaller. In my experience doing some benchmarks comparing their ORM to doctrine it's able to communicate to the database way faster. It was a really interesting experience because while the profiler tells you selecting 1k records took 0.09 seconds, in realtime it took 1.3 seconds before that data actually got returned to an array and i could use it. When using the phalcon orm the same query still takes 0.09 seconds, but it was returned to the array in 0.2 seconds and was ready to be used.
No phpmyadmin is a GUI for a database. There is a create database form. Create table forms .... Trying to paste SQL commands into it largely defeats the purpose of using its web interface.
Well file_get_contents() and file() read the entire file into memory, so if you have a larger file you'll usually hit the php memory limit.
Ten years PHP experience, ~five written with frameworks (Drupal, Laravel, a little Symfony, CodeIgniter) here. For me it's a combination of two primary factors: 1. Requiring an extension **adds too much complexity** to deployment. My Laravel and Slim apps require to 3-4 simple steps that set up on a typical LAMP server. I'm not comfortable adding extensions to and recompiling PHP, and our IT people are always in high demand. 2. **Speed is almost never my bottleneck.** My ability to quickly develop and launch reliable applications is, along with the ability for my boss (who only codes part-time) to follow along. Using phalcon negatively impacts both of those needs.
Wow, that's remarkably similar to the PHP array, except more static :) I would use the shit outta these if I were a C++ programmer.
Perfect summary. &gt; **Speed is almost never my bottleneck** I would even say **Speed of the framework is almost never my bottleneck**. Phalcon will not make my SQL queries faster (or reduce their number). Phalcon will also not make **my code** faster… E.g. in a Symfony app, Symfony is almost never the bottleneck. If speed is all Phalcon does better, that's really not enough to sell it to me.
Yep, you're correct. I could spend 40 hours extra hours writing my app with Phalcon...or spend five minutes running a few EXPLAIN queries and then adding an index to one of my tables. I feel like the gains would be similar.
Multiple Inheritance
Actually my main reason to use phalcon is that it is very easy to understand and work with. As I said in another comment, i worked with symfony but I don't feel i know what's going on. In phalcon i can have the whole execution path in my head most of the time. I value that a lot. 
Yey, awesome dude.
Well, here's the definition on Wikipedia http://en.wikipedia.org/wiki/PHP
When I looked yesterday I got a bit confused with the 2 examples. (1 ) Example 2 ) A few more inputs and outputs:) . Basically I didn't read all the text, but was mainly looking the code and outputs only. My bad. Looking now once again, one question is on /foo/bar/ ./hi/../../baz /foo/baz This is the only example which can be interpreted differently by different people. * `foo` can be replaced by `hi` . `baz` can be appended to `/hi/bar/` =&gt; `/hi/bar/baz` . * It is moving 2 directory according to cli. So it can also be `/baz`. Good work on it. Thank you
good catch :)
Apparently you have never used magento
A good place to start looking is https://packagist.org/users/wikimedia/. https://packagist.org/packages/wikimedia/cdb and https://packagist.org/packages/cssjanus/cssjanus are the two libraries highlighted in the post. We have several other components in https://github.com/wikimedia/mediawiki/tree/master/includes/libs that could be extracted. Other code in the codebase will need various small or large manipulations to disentangle MediaWiki specific features such as mwDebugLog() and other global method calls. (disclaimer: post author. WMF employee)
If you want to test variables for specific conditions, you can have $a, $b, and $c be conditional variables where it would return values respective of its if condition like so $a = (condition) ? {If true} : {If false} Do it for all three, and you can use the first method you used--which is the cleanest way to do achieve the conditional you desire (also, you don't need the parentheses wrapped around the variables on the if statement)
Code Climate goes through your code and checks for security vulnerabilities, best practice violations, things that make it more difficult to maintain or extend your code, etc. It then displays the checks that your code fails, and with each check, there is also a "readup" that will tell you what failed, why that's a bad thing, how you can refactor your code to fix this, and gives you some links to more resources like articles and presentations where you can learn more about the topic. Our goal is to educate you and help you become a better developer, not just leave you with a list of failed checks. 
Yes, please, that would be great!
As others have mentioned, the fact that it's an extension is a bit of a turn off - it limits (or at least complicates) deployment options. Laravel gets a lot of buzz mostly I think because of it's ease of use both in terms of development and deployment. But it is far from the only popular framework. The take away would seem to be that outright speed is not the most important thing when selecting a framework and there is some other underlying reason why Phalcon isn't popular (speculation: traction in the other frameworks or a better development experience, better rapid development tools... etc) 
That seemed to do it. Thank you! 
Jinja (and Twig) uses `~`, which I think is great. At the time of PHP's creation, `-&gt;` was more commonly used to access an object's properties/methods than `.`, so I understand why it's like that, but it still annoys me.
You can have a function/method/class that does all this validation and throws an exception on failure. That's the simplest way if you don't need to have a list of all the conditions that failed and you're ok having only the first one.
No problem, thanks a lot for giving it a try!
If you can change the API, make it return an API token and use that instead. User logs in to your site, you pass their credentials immediately to the API, receive a token and discard their credentials. Store the token in the session. Encryption is not needed. Otherwise, store the credentials encrypted in the session. You don't need them when the user isn't logged in, so why put them permanently in the database? Encrypt using a public key and decrypt using a private key. I believe PHP has an openssl extention which can do this. For added security, use a second server to handle decryption. That way your private key isn't stored on the same server as the encrypted data.
Great library. One question about where to store the cached images. On the page here: http://glide.thephpleague.com/config/source-and-cache/ and in the screencast: http://vimeo.com/118089742 It mentions keeping the source image on S3 and the cached images on the local drive. "you may choose to store your source images on Amazon S3, but keep your rendered images (the cache) on the local disk." I know it's just an example, but normally wouldn't we want to keep the cached images on S3 as well? For instance a service I'm working on now stores all their product images on S3 with three different sizes. We actually keep the sources locally since they don't get displayed anyway and we don't want to add extra storage costs to S3 for them. We keep the resized (in this case cached) images on S3. Does it make sense to do this with Glide and how does it check if the cached image has already been created? Would there be performance issues if the cached images were on S3? 
PHP7 is *really* fast. This performance difference is making PHP much more feasible for actual *applications* outside the realm of usual web SAPI templating. Also, additions like the abstract syntax tree from /u/nikic will make it possible to do all sorts of cool new things (and optimizations) going forward. Oh: and typed returns \o/ ... I expect we'll see quite a few more goodies start coming down the pipe as folks rush to make things happen between now and the feature freeze in mid-March.
It has been enlightening but also discouraging to see the comments here. I like phalcon because it's so easy to understand, I also like the extension idea and the fact that you can easily make your own code into an extension as well, if you control the server, which is obviously a prerequisite. But I may leave it again, at least I'll have to dig deeper into Laravel.
Are you saying that one should avoid using an ORM?
I don't get what was hard in that. 1) Download .zip and extract somewhere 2) Add that path to your system's %PATH% 3) Install VC11 runtime mentioned on the download page 4) Configure php.ini if you don't like the defaults 5) Optionally install composer using installer and run the PEAR installer Takes 5 minutes tops. If IntelliJ or PHPUnit mess up, it's not the fault of Windows or PHP.
No its not but I think that PHP7 with Phalcon 2.* will be fairly comparable performance wise to HHVM as PHP7 just increased their performance by another ~15%. I expect that Zephir will successfully target the HHVM system by around the time that Linux distros are including HHVM packages and at the moment HHVM is moving too rapidly and I think that they just implemented or talked about HHVM LTS releases. With Linux I'm already accustomed to waiting 6-24 months to get new PHP versions (as I don't care to build PHP) so I don't expect to have any issues there when the time comes. The last Ubuntu LTS 12.04 ended up shipping an older PHP 5.3 and I was stuck with that for a few years. In reality it can at worst case takes a few years to push all of this stuff through the ecosystem once it becomes viable.
No its not but I think that PHP7 with Phalcon 2.* will be fairly comparable performance wise to HHVM as PHP7 just increased their performance by another ~15%. I expect that Zephir will successfully target the HHVM system by around the time that Linux distros are including HHVM packages and at the moment HHVM is moving too rapidly and I think that they just implemented or talked about HHVM LTS releases. With Linux I'm already accustomed to waiting 6-24 months to get new PHP versions (as I don't care to build PHP) so I don't expect to have any issues there when the time comes. The last Ubuntu LTS 12.04 ended up shipping an older PHP 5.3 and I was stuck with that for a few years. In reality it can at worst case takes a few years to push all of this stuff through the ecosystem once it becomes viable.
The best reason not to use it, is that it is not required. As others have mentioned Zend (the CPU) can't really be the bottleneck for a typical web application, unless you are doing something wrong. I love C, and extensions. I don't buy the "if it's an extension, it's too complicated" argument; You never hear people saying I'm not going to use APC/redis/memcache/couchbase/mongo/etc because it's an extension, so this is a nonsense argument. If your sysadmins really are incapable of installing an extension then your sysadmins are crap, get new sysadmins. Say I ignore that it's not required, and I consider maybe it has a nice API and is a decent framework; the reason I can't recommend that you use it is that it is written in a language you probably do not understand. To debug your phalcon or zephir code, you need the skills of a C programmer; You need to be able to use gdb, and valgrind, and other such tools in order to be able to debug your code. In addition to that you might need Zend internals knowledge depending on the bug. There are good debugging options that any PHP programmer can understand when they write in PHP, use them. There are many frameworks written in PHP, code you definitely understand, if frameworks are your thing, use them.
I've been wondering what would happen environment-wise if I had a few Phalcon projects on my dev server - say I want to update the Phalcon libraries, what happens with, say, the v1.6 projects vs. the v2 projects? The lack of carrying framework files around in my project trees is very appealing and yet this same feature could be a disadvantage. Not that I know, I haven't tried yet, but the project as a whole does fascinate me.
Because HHVM. It turns every framework into Phalcon basically, without its disadvantage of not being able to debug them if something goes wrong.
&gt;So unless the development stays slow(er) for a very long time then it could end up being the preferred way to develop PHP extensions for the entire ecosystem. Oh, man, that's really what I want to hear (basically: I made the right decision and should stick with it). Well, anyway. I've learned a lot from the comments here. I was worried that Phalcon may be a dead end because no one seemed to care. I'm going to check out Laravel when I get the time. For now I'll finish this project and. I actually switched to phalcon 2.0 recently with no major issues, I've also made part of my code an extension. I intend to move more of my code into the extension as it stabilizes.
Agreed. I used to do the same as OP and it's a mess. The throwing exceptions way is super nice and clean. Just don't get so excited and start creating exception classes for everything. Sometimes just the generic exception is enough if you just want to log the error and return a message to the user.
&gt; To debug your phalcon or zephir code, you need the skills of a C programmer That's a real concern, true. But wouldn't that be true of any extension? I mean we already use a lot extensions - my local installation has well over 50, some are not official at all, like the yaml and uuid (and probably others). Regarding installation, I've done that myself with no issue at all.
&gt; I've been wondering what would happen environment-wise [...] v1.6 projects vs. the v2 projects? That wouldn't work - is the official word - only one version at the time, I don't have the link right here but it was discussed some time ago on the forum. Just like you would expect from php itself or any other extension - I guess. You'll probably have to depend on backwards compatibility. I think, though with version 2 with zephir it might be possible to namespace them differently, though I don't know. In my own project, I've already moved some of my code into a custom extension and I'm going to move more code there. Here I could easily have different versions of that extension with different namespaces.
Technically you can do this with a switch statement: &lt;?php function foo($a, $b, $c) { echo "foo"; } $a = 1; $b = 0; $c = 1; switch (false) { case($a): { $error = 'Failed on condition A'; break;} case($b): { $error = 'Failed on condition B'; break;} case($c): { $error = 'Failed on condition C'; break;} default: foo($a, $b, $c); } if (isset($error)) { echo $error; } But you might get abuse from whoever has to maintain your code... 
&gt; That's a real concern, true. But wouldn't that be true of any extension? You don't have to debug built-in PHP extensions yourself.
There's no middle ground for you between PHP and C?
&gt; Because HHVM Yes, there's a lot of optimizing going on in PHP, it may kill the phalcon project, that's what I've been thinking. A great idea overtaken by other great ideas, maybe.
No. I see what you mean. Ideally I shouldn't have to debug the framework either, but my own extensions I would have to debug, and then c may hit.
I don't see how this is a relevant point? You should never create a language around tools like IDEs. This is about making it easier to make clean, more concise PHP code.
True, I wouldn't be against it if the suggested syntax didn't make things more complex to write, understand and maintain. While I agree we shouldn't design a language around tools, the situation today is that with proper (widespread) tools there is no problem. That's just the current reality. With the suggested change, it would be a bit worse.
I can change my own API but that does not necessarily help because the other aplications are not token based and I can not modify them unfortunately . if one was token based how would I assure both were able to use the same token? Thank you for the idea I will look into the public private key method .
Another crappy copy-cat blog post. It's a new major version - of course BC is going to be broken. If you don't break it in a new major version, then when do you? Also, the blogs seem to be reporting this as something new, but BC was first broken months ago, almost as soon as the PHPNG branch had been merged in, with the [Uniform Variable Syntax](https://wiki.php.net/rfc/uniform_variable_syntax) changes (phpng was merged on the 15th August, and UVS changes were merged on the 27th August, going by the RFC 'implemented' update dates) Can these blogs really not come up with anything new or interesting to talk about?
I dislike this proposed change. It provides no benefit and in my opinion makes the use list harder to read at a glance. Additionally, if you decide to move a class between namespaces, a simple search will no longer allow you to pick up the use statements that need to be updated. You can argue that an IDE that would be able to perform this update for you, but as others have already said elsewhere in this post, you shouldn't build a language around tools. It's the same reason the 'function' keyword will never disappear.
100% sure any "widespread tools" or IDEs that cares about it's user base will receive updates to support any addition to PHP language. For instance, the recently approved return types feature https://wiki.php.net/rfc/return_types. Concerns about IDE support should not impede language improvements.
Thanks for that comment. I'll keep that in mind for the future. About standards, that's what I'm thinking of and what prompted my question. When I first saw Phalcon it seemed a nobrainer, when I started learn it, it still seemed a nobrainer and there was a bit buzz around it last summer, but it's now died down and I got curious why. I'll have to finish my current project but I'm probably going to explore Laravel for the next one.
I've used Laravel on a number of projects and been extremely happy with it, I highly recommend giving it a shot!
If it's *that* compatible that removes my main concern. Am I right in thinking that production-wise, it's going to necessitate VPSs? Which are looking so affordable these day anyway. PS thanks for the answers, you're a gold-mine!
&gt; Windows in some incarnation for 24 years Yes, something similar for me but switched to Linux 8 years ago and made my last Windows install about 5-6 years ago. What I find when I work with windows "old timers" is that they are oblivious to the what has happened the last ten years. They are horribly inefficient but they don't know it, and none of their peer old timers know either, and, of course they don't respect me as I'm not a real developer (which is true) and I don't use "real" tools (which is not true ;-) ). This is, of course, not about windows but about the lack of pressure to learn new things.
The "no benefit" and "hard to read" arguments are both hard to buy.
Being a major release is not really an argument in favour of breaking BC for any given language feature. Otherwise you could justify any BC break with "I do it because it's a major release" as bad as that specific change might be. The fact that the decision of doing a major release has been made cannot be used to justify every other BC break, they have to be evaluated in its own merit. I want to be open to changes and improvements, but I also think BC has been one of php's greatest strengths :) 
Those are all useful features for certain programming styles, but I don't think it's fair to call them OO features. They're more related to early binding and static typing. Smalltalk for example has none of those features either, and it's the language that essentially defined object oriented programming.
In that case, rather than change the API you could add a second authentication method. The legacy apps can use the old method while yours uses the token method. I'm not sure what you mean with your question. The token is basically a session ID. Two apps would not share the same token.
Parroting to the niche Phalcon user that the popular mainstream framework is available seems a little.. redundant.
Seriously? Why not just link to the fucking article? https://laravel-news.com/2015/01/laravel-5/
Thank you. Have not read the RFC to comment on the same.
Laravel 5 will have a package called Socialite that you can plug in. It works with Facebook: http://laravel.com/docs/master/authentication#social-authentication
&gt; Currently, a statement like global $$foo-&gt;bar; is allowed in PHP. For PHP 7 it has to be rewritten as global ${$foo-&gt;bar};. My first thought was "what kind of maniac would write code like this?" &gt; Changes like these break Magento 1 on PHP 7. Of course.
Okay... I get it can crash my server if I use a monster length string... When the eff would this ever happen and.. What could it possibly do other then crash the apache instance?
That may be possible for one of the apps, thank you. But a few of the apps I need to make calls to are 3rd party, for example jenkins what would you suggest for that one? I will not be able to add a new Auth system to jenkins .
&gt;VPS, I'd think so, I have my own physical servers, one with esxi i.e. with VMWare VMs, on the other one I'm going to learn docker. I'm compiling phalcon directly from source - it's super easy one or two commands. If you do it without root (which you can without problem), you'll have to copy the extension to php's extension folder yourself and in any case you'll have to make the ini files (remember to do for both the web server and cli). Somebody in here seems to think you also have to recompile php but that's not true. For zephir, it's worth spending a couple of hours making your own extension, just for sake of having done it ;-) Anyway, a lot of people here advise caution about phalcon, and I'm thinking that's wise. I'm close to finishing a project so I'll finish it. But I'm thinking more seriously about laravel.
&gt; Have you actually tried ruby? Actually, no. I've used Python and some other languages. &gt; Name one I had a look and, actually, most hosts seem to also have support for Python and Perl CGI scripts, but I don't think they support them in any other mode, and CGI is not performant. &gt; You can't call it an advantage, since all languages have things coded in that language. It's still an advantage of that language. If you are modernising an existing codebase written in PHP, it gives PHP an advantage as you don't need to switch. &gt; Give me an example of a method you feel has insufficient docs I had a look over the Java and Python string docs, they're more extensive than I remember, actually.
Out of interest, what was the issue you had with scopes?
Well if you need performance shared hosts kind of suck anyway. Last time I checked none of them used php-fpm. The reason why I'm arguing so much is that I've been thinking a lot of maybe jumping the ship to a different language some time. PHP is taking strange turns nowadays: it still advertises itself as "super easy to do stuff in", but in fact the community is shifting towards a more enterprisey approaches ( think Symfony2 and new Drupal). And I think in those enterprisey uses PHP is becoming a huge stumblepoint with it's performance, legacy stuff and (especially) a lot of mediocre devs turning up. 
Hello Laravel Creator, thank you. ps: that was genuine, love working with Laravel and just wanted to give a little shout out :-)
&gt; In Laravel 4 Blade included the following two styles: `{{` and `{{{`. The double curly bracket was a raw echo and the triple curly bracket escaped. &gt; &gt; Now both the double and triple curly brackets escape the variable and a new `{!! $var !!}` is for raw. Go home Blade, you're drunk. 
I consider a good benchmark a sign of the effort and detail put into designing the architecture. The microseconds don't matter that much themselves, but if I see that the developer is initializing all possible plugins when a page load needs only one of them I consider it bad design.
Care to explain why you think its the best?
I loved L4 but man oh man do I love L5 that much more. Taylor has made some amazing improvements with very few things that I dislike (only thing that comes to mind right now is the removal of local environment configs in favor of .env files which is bad for my specific use case). Upgrading can be a pain, especially with packages like Entrust not being updated so I just forked them, patched them, and used those. 
Slight inconvenience to convert your old templates over, but you really shouldn't be needing to raw output often besides when using HTML helpers. `HTML` and `Form` aren't even included with L5 out of the box.
I actually plan on continuing my fork of Entrust to something that gets updated a bit more often.. I love Entrust for what it does but it relies on Ardent and both of them never get updated. Hopefully in the next few weeks I'll have it rebranded (obviously giving credit where credit is due) and I'll post it to packagist. 
Not really something i can explain. Its just annoying for me. It's also a pain that objects can't be iterated as easily. For instance, getting a count of the items isn't as simple as just `.length`. (I know theres `Object.keys(obj).length`, but its not the same, and rather annoying to do.
Jenkins has [an OAuth plugin](https://wiki.jenkins-ci.org/display/JENKINS/OAuth+Credentials), which is promising. Your use case is pretty much exactly what OAuth was created for, so if all your third-party services can be made to use it, that's what I would be looking at.
If your application works, you don't have to upgrade - it is still being supported.
There are definitely some other places where you may have HTML that you want to render. One possibility could be you're writing a blog and you write your posts in HTML. Or you write posts in Markdown and convert them to HTML on the backend.
They're static code analysis tools, there was a [discussion about them yesterday](http://www.reddit.com/r/PHP/comments/2u2g2e/comparison_of_php_code_quality_tools/).
Also makes the developer think before they print unescaped shit
Static analysis tools.
I don't know anything about Laravel, but it seems odd that the main reason they went from 4 to 5 was changing the directory structure?
You can change it to whatever you want.
Semver
I don't see your point. My point is that a major release is the cause of breaking BC, and not the other way around, if that makes sense.
For how long? I believe Laravel had little to no LTS.
So the question is, is Doctrine's DBAL and ORM better than Laravel's? 
Eloquent is great but once you get over the hump that is Doctrines learning curve you will never look back.
Can you explain why? They just seem the same from the outside. 
Yes and no. Given that an `if/else` is a split between two different behaviours it strongly suggests two different methods should be used. Can you provide an example of code that's clearer or more readable WITH an else?
Not sure i agree entirely with prefixes/suffixes. I think its helpful to have the `Interface` suffix, and the `Abstract` prefix. Though, the rest of that argument did make a lot of sense. But that may just be me. Also.... Holy typos batman.
The repository pattern (to me at least), makes a ton more sense than the ActiveRecord pattern. It's also a lot more.... Complex, and i mean that in a good way. 
&gt; HTML and CSS: the presentation and styling languages of the web &gt; PHP: the most popular language for web servers &gt; SQL: the database language to store and retrieve information &gt; jQuery: a library for interactive web pages &gt; JavaScript: the programming language of web browsers &gt; AngularJS: a framework for building interactive web pages &gt; Drupal: a content management system powering millions of websites All within four months!!!
Cause Laravel has always followed SemVer.... &gt;.&gt; /s
 array_walk(array('$a' =&gt; $a, '$b' =&gt; $b, '$c' =&gt; $c), function ($required, $key) { if ( ! $required) { throw new MissingValueException(sprintf('Missing value %s', $key)); } }); $return = function($a, $b, $c);
Create an adapter (wrapper) class for that api and mock that class. Test the actual interaction in another integration test. 
Data Mapper - you can design your domain models first, cover it with unit tests and they just don't know anything about DB structure Unit of work - do not worry about writing to DB. Just change current objects states and flush them when you are done. All changes will be committed with one transaction. Personally i do this on `kernel.response` event after all business logic is done (covers most of use cases).
I don't get it. What do you mean by "removing a scope"? 
On the topic of L5 in general, I predict a whole lot of overuse of the new features in L5, even in situations where they really aren't needed. (Especially things like dependency injection and the command bus.) PHP and Larvel devs are mostly fairly new to unit testing, software patterns, SOLID, TDD, orthogonal design, etc. The tendency when people first learn these things is to be convinced there is no other way and to overuse them to an extreme, before you eventually realize that your apps are so much more complicated and difficult to maintain than they used to be. And that's when eventually you get more selective about when it actually does and doesn't make sense to use these design patterns, and also when to break the "rules" and just go with simplicity.
This is a good article that [explains the differences](http://culttt.com/2014/07/07/doctrine-2-different-eloquent/) more in depth with code examples. 
 &lt;?php interface CalculableShape { public function getArea(); public function getPerimeter(); public function getNumberOfSides(); } abstract class Quadrilateral implements CalculableShape { public function getNumberOfSides() { return 4; } } class Square extends Quadrilateral { public function getArea() { return pow($this-&gt;length, 2); } public function getPerimeter() { return 4 * $this-&gt;length; } } class Rectangle extends Quadrilateral { public function getArea() { return $this-&gt;length * $this-&gt;width; } public function getPerimeter() { return $this-&gt;length * 2 + $this-&gt;width * 2; } }
Uuhhh. class FooWidget extends BaseWidget {} class BarWidget extends BaseWidget {} abstract class BaseWidget implements Widget {} interface Widget {} 
This seems to be nothing more than a rambling pile of nonsense. 
IMO the `Interface` suffix is helpful like `$stringName` and `$intAge` is. When type-hinting against a `Logger`, I don't care if it's an interface or not. When implementing it, I know it's an interface because I'm implementing it.
 Class FooWidget implements Widget{uses SimpleWidget} Class BarWidget implements Widget{uses SimpleWidget} Trait SimpleWidget{// was formally an abstractWidget //but abstract classes are pointless with traits available.} Interface Widget{// because really we dont care if we have foo or bar, we are only going to deal with Widgets.} 
No problem! I really suggest you give it a try one of these days. It's pretty fancy.
Okay Mr. Grumpy pants.
&gt; An interface should be a "thing" Except, an interface IS supposed to be a description of a thing.
The article does seem pretty rambly.
I don't know if there are any other instances, but when you write a global scope the interface requires a way to remove it.
Yes, the implementation details are, but the naming isn't. Calling it `interface WidgetInterface` is a form of [tautology](http://en.wikipedia.org/wiki/Tautology_%28rhetoric%29).
 &lt;?php interface Result { function andThen(callable $next); function onError(callable $next); } class Okay implements Result { private $value; public function __construct($value) { $this-&gt;value = $value; } public function andThen(callable $next) { return $next($this-&gt;value); } public function onError(callable $next) { } } class Error implements Result { private $value; public function __construct($value) { $this-&gt;value = $value; } public function andThen(callable $next) { return $this; } public function onError(callable $next) { $next($this-&gt;value); } } function example() { getA()-&gt;andThen(function ($a) { return getB()-&gt;andThen(function ($b) use ($a) { return getC()-&gt;andThen(function ($c) use ($a, $b) { return runFoo($a, $b, $c); }); }); })-&gt;onError(function ($e) { throw $e; }); }
Nope, but I believe this is an attempt to start following it.
If you organise classes by domain instead of what type they are then its much easier to work with larger applications and refactor code into separate packages. The namespace VendorName\FeatureA then contains all the code for feature A in your example. It could be extracted to a separate reusable component very easily. You can also search across all of Feature A for code; eg code using classes outside of Feature A.
Yup, and it has literally incorrect content: php -r '$lang = "PHP"; $lang = ($lang == "PHP") ?: "Javascript"; echo $lang;' //1 `$lang == "PHP"` is returning a boolean, not a string. So yeah, no...
All you've done here is replace one prefix (`Abstract`) with another (`Base`). The whole point is *not* to use affixes, remember?
The problem with DateTimeImmutable is that its not actually immutable. Thats kind of funny, as the class itself has the actual word "Immutable" in it. But hey, this is PHP what do you expect...
Because it's what they started benchmarking with so they need to stick with it in order to show the improvement over time.
Isn't it cheating if somebody tells you how to do the test?
Are you trying to create a test for other people to do, or are you trying to do a test to hand in to someone else and these are the requirements?
Wow looking at how to video for Laravel I see how much I don't know about PHP tools. There talking a lot about Composer and command prompt, I didn't need that with the little knowledge I had playing with CodeIgniter. :o 
I understand what you mean by saying it made you a better developer with command line requirement and composer I feel pretty beginner looking at Laravel how to videos. CodeIgniter felt easier
When I started with laravel, I was worried as well. It's a wonderful framework and as a beginner you can dive in and expect great results right away, and learn as you go. The community is awesome and there are a lot of sources to learn from. 
&gt;[**Why Not Both? [0:04]**](http://youtu.be/vgk-lA12FBk) &gt; [*^Chris ^R*](https://www.youtube.com/channel/UCLUqfUTCOdCt7F9mQNbppGA) ^in ^Autos ^&amp; ^Vehicles &gt;*^619,530 ^views ^since ^Mar ^2012* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
Is it time for the monthly "MVC is bad/ADR is good" already
It means Collector.
Yes, composer is wrapped with phing commands. The same is done for npm and bower. Composer is something I don't even think about anymore, so I forgot to mention it. What I do right now is download the dependencies on codeship (CI) and then rsync them into the target host. That way I know for a fact that stuff works. Up until now I always ran composer on the target host. There are arguments for both I guess.
Why do I keep hearing re-rendering of the views? and this part? &gt;The View stays unidirectional: it gets the signal to update, it reads the state from the model and displays the updated view. How in any way does a view know to update data? This part seriously confuses me each time I hear it. The view shouldn't care about what happens to the data, the view just knows what values to render that were passed from the controller or model. Normally, when you perform a CRUD operation, you are redirected to a new request that has your new data and presents it if needed. Usually, the view shouldn't even have a model, just bits of data because you should be following LSP. If I'm wrong, some insight would definitely be nice.
http://lmgtfy.com/?q=best+php+framework Yes.
Look at Symfony and/or Laravel if you want the framework to do most if not all of the heavy lifting. Slim or Silex if you want a lightweight framework. Personally, I'd pick Laravel. Get your feet wet with laracasts as Jeffrey makes learning Laravel an enjoyable experience. 
Traits are not appropriate for emulating inheritance for several reasons, including: * They don't allow (clean) extension of method functionality, only replacement (you can't extend a trait method and then call the original without remapping all the methods in the use) * They don't respect property scope (traits can access private properties of implementing classes). * etc...
Funny, considering MVC is catalogued as a web presentation pattern http://martinfowler.com/eaaCatalog/. I guess Martin Fowler doesn't know what he is talking about. /s
Thanks. Yeah, I was considering going the PSR-4 route, putting every class in its own file. When you say "concrete", do you mean as opposed to "abstract"? I feel like my classes are pretty succinct, in terms of what they do. However, I could probably move more of the code into traits, if that is what you're getting at. I am also thinking about moving all of the hardcoded templates in the Form\*, Button\*, etc classes into separate HTML files. However, it should be noted that you can still load alternative templates in the constructor (maybe I should make that clear in the documentation). I haven't really played with interfaces yet. What in particular do you think could benefit from more abstraction?
You can't just drop in a trait as a replacement for an abstract class. Code reuse is not the only thing abstract classes are used for...
What's the advantage of a templating system like this vs. a simple function call, e.g.: echo mediaTemplate([ "img_src" =&gt; "http://avatars1.githubusercontent.com/u/5004534?v=3&amp;s=400", "img_alt" =&gt; "Lord of the Fries", "heading" =&gt; "Alex Weissman", "body" =&gt; "Alex has many years...", ]); echo jumbotronTemplate([ "heading" =&gt; "Developers", "body" =&gt; [ mediaTemplate($fooArray), mediaTemplate($barArray), ], ]);
Then just call it `Widget` if you don't have an interface, or `BaseWidget` if it's just a base class.
Do Foundation please.
Thanks saw a lot of blogs and youtube videos - do you have anything you recommend?
http://verraes.net/2013/09/sensible-interfaces/
Sometimes its not that simple. 
The architecture of my system (enterprise web-app that my company sells) is such that I have two layers: * Apache and PHP * Servers written in Java (4 of them) Currently a MySQL db sits in between them and is a convenient intermediary for data that is shared between these two layers but I also want to begin sharing business logic between the two so I'm not having to replicate it in both the PHP and Java layers. A php-Java bridge seems like a great solution. I already encapsulate business logic retrieval and would like to implement calls to Java objects using a bridge - I just don't want to have Zend or Tomcat in my environments to achieve this. 
With L5 we won't really need Confide as Taylor has baked a lot of those things in (it seems, at least). Could you make a Github repo and I can check the code out and see if I can work it in? At the very least maybe we could make it it's own package that sits ontop of mine. 
As mentioned before, `BaseWidget` is just `AbstractWidget` with a different prefix.
Is this PeopleSoft? We had to use a Java Bridge to use PeopleSoft Component Interfaces in the past.
It doesn't matter whether a type hint is a class or an interface as long as you are providing a concrete implementation to satisfy the type hint. If the type hint is `Widget` or `WidgetInterface`, it doesn't matter, as the reader of the code is going to open up that file regardless to understand the implementation. Adding `Interface` as a suffix isn't solving a single thing.
Yeah, definitely. When I get a chance I'll put it up and shoot you a message 
But `Base` **is** a technical detail. Unless you're conveniently excluding inheritance as a "technical detail".
Even back when it was maintained, it sucked. We used it to talk to a Java system in place of SOAP calls to a remote system, because all the devs hated SOAP at the time (and still do). The bridge had numerous memory leaks and often left zombie Java processes all over the place. We had to restart services nightly to clean things up, and even then it was sometimes unstable. It's not worth the pain.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Morton's fork**](https://en.wikipedia.org/wiki/Morton%27s%20fork): [](#sfw) --- &gt; &gt;A __Morton's Fork__ is a specious piece of reasoning in which contradictory arguments lead to the same (unpleasant) conclusion. It is said to originate with the collecting of taxes by [John Morton](https://en.wikipedia.org/wiki/John_Morton_(bishop\)), Archbishop of Canterbury in the late 15th century, who held that a man living modestly must be saving money and could therefore afford taxes, whereas if he was living extravagantly then he was obviously rich and could still afford them. &gt;Elected officers ([members of parliament](https://en.wikipedia.org/wiki/Members_of_parliament) and [councillors](https://en.wikipedia.org/wiki/Councillor)) sometimes may have recourse to a variant on Morton's Fork when dealing with unhelpful unelected officers, or civil servants. This variant asserts that an unelected officer's non-compliance with the directive of their elected officer must be due to one of two equally unacceptable causes: either the civil servant is lazy or incompetent, or the civil servant is acting willfully or maliciously against the instructions given by his or her elected officer. &gt;An example of Morton's Fork occurs in the [Poirot](https://en.wikipedia.org/wiki/Poirot) novel *[Death in the Clouds](https://en.wikipedia.org/wiki/Death_in_the_Clouds)*, in which Poirot sets a trap for the murderer by asking him to dress in disguise as a blackmailer. When the suspect does so – with a hapless lack of skill – Poirot reasons this was because the murderer was trying to hide the fact that he is actually highly adept at changing his appearance. Yet if the suspect had indeed proved his skill at disguise when asked (rather than dress up with "a false moustache that cries out to heaven, and those ridiculous eyebrows"), it would have alluded equally to his guilt. &gt; --- ^Interesting: [^Morton's ^fork ^coup](https://en.wikipedia.org/wiki/Morton%27s_fork_coup) ^| [^False ^dilemma](https://en.wikipedia.org/wiki/False_dilemma) ^| [^Breakfast ^in ^the ^Ruins](https://en.wikipedia.org/wiki/Breakfast_in_the_Ruins) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+co7e3em) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+co7e3em)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It was a tool of Satan, and gzurpped itself into another dimension.
I mean base not as in "inheritance" but simply as "the base to build a widget".
I'd also be interested
This section has been removed (by me) from the manual - as well, as other php4-only extensions. Old documentation, covering PHP4 stuff is still [available](http://php.net/manual/php4.php) if you need it.
'Dangerous'?
Some of the more complicated commands are very unintuitiv. Let's say you want Friday of this week. It's not that simple. Also the same as with sql: never directly use variables with an unknown content
for me the biggest reason is that it makes things easier when coding. IUser.php or UserInterface.php in the tab tells me right away what I'm looking at. It's also important in my code itself, I know right away if I'm type hinting against the interface or implementation, which is especially helpful when refactoring code. 
That's not a "connection problem", that's a syntax error. Are you sure you've copied the file as-is? Use something like https://gist.github.com to post the source of connect_to_mysql.php
Careful with using mysql. While its ok to use. Mysqli or using pdo will be better in the long run 
You can make your code more readable by putting four spaces before a line. $db_host="localhost"; $db_username="a9614727_emg000"; $db_pass="pop000100"; $db_name="a9614727_emg000"; mysql_connect("$db_host","$db_username","$db_pass") or die(mysql_error()); mysql_select_db("$db_name") or die("no database by that name"); Ok, so let's start with what's wrong here. The problem is *probably* here: mysql_connect("$db_host" You don't do this. You don't need to put quotes around that, and you shouldn't. You just need to put `mysql_connect($db_host`. Secondly, and most importantly you should **not** be using mysql\_connect at all. The mysql\_* methods are deprecated and will be removed in a future version of PHP. For reasons of security and compatibility you should be [using PDO](http://php.net/manual/en/book.pdo.php). It's no harder and better in every way. Finally, you should be posting this on /r/phphelp
I'm lucky to be in Michigan, which is a big PHP shop. Granted, we still have the Javas, .NETs and others, but my skill set of Python is not as valuable here as PHP is. But with PHP 7 coming out I feel the language wars will shift a bit.
Apparently in California and Washington state, the you-name-them companies poach all the best developers, before they even graduate if they can, so the rest of the employers are left with a developer pool of considerably lower quality than elsewhere in the country.
Sorry for the wrong formatting and thread. I will definitely look into PDO immediately. Still, I removed the quotes (stupid mistake) and i'm still getting the same error.
Can you post your code again with your update? If it's still throwing a syntax error, you most likely missed a quote or have something else now with incorrect syntax.
That is how one learns. Those concepts are very hard to just pick off when to use them just from reading. For me, using some of those patterns saved me a lot of time, since often times I work on systems which at first are very small and then evolve to huge enterprise solutions after a while. If you start with good patterns even when the app is at it's first stage then it will build up better later. 
Sorry, I'm in the Eindhoven area; Amersfoort is a little far for me. Thanks for the offer though!
Hmm, I've heard about a PHP dev from Eindhoven looking for a job. Whether it's you or not, best of luck! :)
I don't really see a problem using Facades in the view. It's not code you test and it's semi tightly bound to the framework, especially to `helpers.php`. That having been said, it's fairly easy to remove facades from the view. &lt;?php use Illuminate\View\Factory; use Illuminate\Html\HtmlBuilder; class MyController { protected $html; protected $viewFactory; public function __construct(Factory $viewFactory, tmlBuilder $html) { $this-&gt;viewFactory = $viewFactory; $this-&gt;html = $html; } public function myAction() { return $this-&gt;viewFactory-&gt;make('views.my-page', ['html' =&gt; $this-&gt;html]); } } If you think this will become tedious after awhile, you could use a view composer to bind `$html` and `$form` into every view.
Please update the error message too. Which version of PHP are you using?
You mean the mysql_* extension for PHP. MySQL is fine (...or not? :) )
so, I really don't see what gave you cancer. The only thing i'm unhappy with is how i implemented the check to see if the upload is ongoing. great news it is open source so you can fix it. Thanks. P.S. If you give me some actual feedback on what you find horrifying I just may fix it.
looks promising, however I would advise you to follow psr code style since that is an excepted style by the open source community.
Yet still taught at schools over here, I die() a little inside.
Some pedantry that's actually relevant: 'accepted', not 'excepted' - they're almost opposites of each other.
lol no verb formal past tense: excepted; past participle: excepted specify as excluded from a category or group. "five classes of advertisement are excepted from control" synonyms: exclude, omit, leave out, rule out, count out, disregard, pass over, bar "you're all crooks, present company excepted" antonyms: include
The error message is the same. PHP Version 5.2.17
One of the first things I learned when I started interviewing software dev candidates is that education level (or lack thereof) is rarely indicative of application development skill or knowledge. 
No tests?
I realized that when I began a programming course in HS with a few years of coding already under me, I ended up dropping out and still managed to get good paying jobs in big companies, I wasn't even asked what my qualifications were, they just assumed I had at least a bachelor's. Meanwhile my friends took the course and even got a bachelor's and didn't get anything other than checkout at supermarkets. So I guess it has a lot to do with the person, too. I didn't feel happy regardless of money or anything so I ended up quitting and trying to move to another country, and maybe get a degree in something, I never expected to amount to anything so I never really had any goals so I still feel kind of lost.
The code was readable before I uploaded it to Github, it seems that Github uses 8 space tab indentation but my class file uses 4 space, which messes up the formatting and makes it a lot unreadable. If anyone knows how to change the tab space settings in Github, Id appreciate. 
I know, everything seems formatted correctly and if it was a problem with what I set the variables as then it should be spitting out one of the errors I have, but it's not. I'm new to website development as well so this is a little discouraging. I guess I will just watch the Superbowl and look at it with a fresh set of eyes later. Either that or I'll scrap the whole thing and set it up with pdo.
I really wouldn't gauge academia as level for development. I never even got an associates in computer science/programming but got a job based on my skill set I did on my own. I get what you mean, and the company I work for just experienced that for ourselves, but I don't think all the weight should be put on how well you do in school.
Oops, stupid mistake :)
&gt; Being a long running process does not of itself constitute a "server". A server is able to accept and respond to requests from an external client. Usually that means running as a service and listening on a port or socket. Very true. Perhaps I should rephrase my question. Are RESTful services simply Servlets or PHP scripts that use inputs from the querystring and output data over HTTP? 
That is actually a valid way of storing the secret CSRF token. It's called Double Submit Cookies. You can read a bit more into from the OWASP page: https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Double_Submit_Cookies In short, the attacker doesn't have access to your cookies any more than he does to the content of the website. Thus, storing it in the cookie does not allow additional attack vectors.
This is an interesting package. I took a look at the link in your code, http://www.mysidiarpg.com/, and discovered that the url opens an index of files and directories. This is an unsafe practice. Are you working on it?
Thanks to the help from Chris Pitt, PCF has received some changes in formatting and should be very readable now. Take a look at it again and here's an example of the updated ArrayList.php file: https://github.com/HallofFamer/PHP-Collections-Framework/blob/master/src/Collection/ArrayList.php
It's been in development longer and is used as a dependency for ElasticaBundle 
RoR and Node seem a lot hipper than the other ones you mentioned. Maybe it's that?
Hahahah, thank you I'm totally going to use that.
Wow... "the rest of the employers are left with a developer pool of considerably lower quality than elsewhere in the country"... how did you get that from big employers grabbing students who haven't even graduated yet? Those would be, for all but a handful of focused/academic problem spaces, *the worst* developers to have to get stuff done. From a *cost* standpoint, sure, they're less expensive than sr folks, but they're also more pliable, and will put up with crap from mgt without knowing better. If I wanted people ready to pull another 100-hr death march weekend, yep, I'd hire students all day long. 
As someone who also builds a lot of ios apps (and uses PHP for servers), I would like to point out that all anybody really needs is the equivalent of NSArray, NSSet, and NSDictionary (array, set, hash) and maybe a bag would be nice. Also, you might have a look at \Illuminate\Support\Collection in laravel, that seems to provide most everything I need and I already have it.
As much as can be done with [php-cs-fixer](https://packagist.org/packages/fabpot/php-cs-fixer). Still needs refactoring by hand! :)
On the [TDWTF](http://thedailywtf.com/) forums, a few guys pointed that out (it's mostly guys). Apparently, the big guns have a noticeable effect on the developer pool.
Yup, because Rails is a "shiny new thing" ;)
The new `dd()` (Symfony Vardumper) is a pile of shit. Whoever thought it was a good idea to make the default styling collapsed instead of expanded was drunk. *It doesn't help anyone a god damn little bit to have to manually click to expand everything to inspect its contents* So now I need to boiler plate all my L5 apps with the old `dd()`, or set up a CSS sheet on all of my browsers across all of my dev environments to remove the `display: none;` from the collapsed elements. Vardumper (or at least L5's implementation of it) is an unnecessarily complex way to display what xdebug does for you perfectly fine. What the fuck was wrong with the xdebug output that prompted the need for vardumper to even exist, let alone for Laravel to use it?
Ah right, sorry I was under the impression you were moving to The Netherlands. In that case I can't help you but I'm certain you will find a job relatively quick! Best of luck!
This is one of those application size trade-offs. I call it vertical vs horizontal application structure. "Vertical" is namespaces starting with your application domain concept (e.g. User, Comment, Forum, Blog) etc. "Horizontal" is what the default L5 app structure is - mixing classes that span several domain concepts into single folders. I've found that for small projects, the horizontal structure makes the most sense. For mid-sized projects, the vertical structure starts to make more sense. The only thing "tying" you to the horizontal structure is that is where the generators place files for you, so you have to generate and then move them, which is a bit of a pain. However, the big problem isn't the organization of classes like providers and services and commands - it's the organization of the HTTP layer application files (routes, views, and controllers). Those are scattered all over the place in really un-intuitive locations when you start dealing with applications of any meaningful size. Here's how I structure my L4 applications now, and I have yet to see any downsides to this for anything other than the smallest of applications: http://i.imgur.com/fy2gnCh.jpg Everything that represents a "component" of the site gets its own "sub-app" (note that this is similar to, but different from packages and bundles etc) I really wish L5 encouraged *this* Http application structure instead of the intuitive one it uses now. Like... why are views in a folder called "resources"? I don't think "resources" when I think "where the fuck are my view templates?"
No damnit. When I estimate something I demand that you hold me to it and get mad at me when you don't give me any time do to proper discovery and take 3x longer than I anticipated.
Sorry, but when I'm browsing files in a folder structure I want it cystal clear at a glance which files are contracts, and which are implementations. When something is named an interface, I KNOW it's an interface, I know that I should be implementing that thing. When something is not named as an interface, I have to open it to see what it is, I can't make the assumption that it's an interface - I can't make any assumption about it at all, actually. There's ZERO reason not to call out interfaces and traits as they are, and frankly, it hogs a name that could be used as a decent parent should you need inheritance. **This:** * UserInterface - obvious * User - obvious * ForumUser - obviously a specific type of user that will extend `User` is more intuitive than **this**: * User - interface (suprise mother fucka!) * BaseUser - is this the parent user class, or just a different type of user? * ForumUser - maybe extends `BaseUser`, maybe it doesn't. `BaseUser` could just be a sibling. What's more is if you're following LSP, then `User` and `ForumUser` should be totally interchangeable in appropriate contexts, thereby `User` is a perfectly valid class to use directly, and as such, naming it `BaseUser` is superfluous.
'Certification' lol
Interesting. I'd assume that any scenario where CSRF is a concern would also benefit from some tracking cookie of some sort, even if there's no user visible login step. 
Why is this using an XOR cipher? I mean, trying to be taken seriously in terms of security, but then hiding an XOR cipher in there? I can't stress how not good that is. Especially since you're using a static token. [Give this a read](http://blog.ircmaxell.com/2013/02/preventing-csrf-attacks.html) for a good breakdown of the problems and solutions involved.
Well, I *was* going to, but I won't now. :(
time() or GTFO
I'm in Michigan too :) northern lp. I'm assuming you're from where I think you are, the area where the jobs are down state. Let's chat :) I would love to meet a local Michigan guy and talk about possible startups and fun things. 
"Sails agents" eh?
...but that is the ISO standard?
I figure at *some* level of abstraction *something* is going to be smart enough to optimize out all the nops .... 
What about storing the user credentials in a cookie that is encrypted + hmac'd. You still have the issue of a cookie/token allowing someone in, so serving it as HTTP Only to help mitigate fetching via an XSS exploit, but at first blush it appears to have all the strengths of your token method, but without needing another table, and as long as you use constant time equality checks (or better yet, the hash_equals function added in PHP 5.6) you should be golden. Of course, it adds some complexity - you need mcrypt installed, and need to know which cipher and block mode to use (AES 256 and CBC for those interested), and that you should encrypt THEN mac, but if that can be wrapped in a library for the user it removes some of that.
pull request waiting
Ooh, good question! The only reservation I would have is that cookies have a size limit of 4KiB, so the overhead of a proper IV and HMAC depletes precious cookie real estate. It still accomplishes the goal though. :) I recommend https://github.com/defuse/php-encryption for AES+HMAC. It recently switched to openssl which means if AES-NI are available you get fast, cache-timing-safe symmetric crypto, which is a huge win.
It would be done through JavaScript, not PHP.
I apologize, as I'm relatively new to programming. 
Nothing to apologise for. Good for you for learning! For some resources, check out [this site](http://www.phptherightway.com), or this [class](http://www.codecademy.com/en/tracks/php) is pretty useful. Maybe check out this [framework](http://laravel.com) and use it as a diving board. 
It is even worse. file_get_contents has no timeout either. I've seen people use it to get http responses and end never ending their own request. 
I'll certainly look into your point; what PHP is specifically **for** - I asked the question because I'm not sure what the capabilities are at times, and tend to explore the capabilities of what I'm working with before branching out.
You shouldn't have to open the type-hinted argument's class file to see whether it's an interface or not, is my opinion. Type-hinting against a concrete class instead of an interface is a potential code smell, and as such it should be as easy and quick as possible to spot it.
In the end it really just comes down to preference, similar to the whole tabs vs spaces debate.
Using XOR is a simple way to send out a new token for every request (and thus mitigating compression info leaks), but at the same time making it possible to validate also previous tokens, i.e. from multiple tabs or after a request made after back button hit. Instead of XOR one could use "real encryption" to *mask the value*, but here just a plain XOR is a sound approach.
&gt;Why is this using an XOR cipher? The idea comes from the [nosurf](https://github.com/justinas/nosurf) library. The purpose is not so much encryption, but to turn the static token into a random one for each request. A static token can be used as an [attack vector](http://breachattack.com/) against HTTPS encryption. The only purpose is to prevent that. XOR cipher is fast and efficient for this purpose. Though, I suppose your nonce approach would serve the same purpose. &gt; Give this a read for a good breakdown of the problems and solutions involved. Thank you. There were some good points in that. What I understood from that, is that you are concerned about the use static tokens due to replay attacks? Would it serve the same purpose, if one were to simply regenerate the token on each successful form submission (although, it would offer worse user experience in some cases)? I would prefer to stay with static tokens on the library due to the fact that a static token can be stored in cookie on systems that do not use sessions and because your method of storing nonces can quickly add up to large session arrays, if it is not managed in some way. If you feel this is real corcern, I suppose it would good idea to mention it in the documentation.
Nice writeup pmjones :)
[This blog post](http://blogs.microsoft.co.il/idof/2011/08/10/wsdl-vs-mex-knockout-or-tie/) suggests that MEX is just WSDL-over-SOAP. As if SOAP wasn't enough of a clusterfuck already, now you're using SOAP to define future SOAP calls? It's apparently a [W3C Recommendation](http://www.w3.org/TR/ws-metadata-exchange/). You might be able to cobble together the correct SOAP call from the specification document.
Good initiative. Maybe this could be presented as a table instead for clarity though? With like | Year | Framework | Version | Link |
Why store 2 cookies instead of 1? If an attacker gets access to `token` it will access `authenticator` as well. I would also store browser information and invalidate the tokens if the request was not made from with the proper browser.
Someone tell me what is wrong with this scheme. Creation: User Supplied Password -&gt; password_hash() -&gt; Database User Table User Supplied Password -&gt; hash_pbkdf2() -&gt; password_hash() -&gt; Database Authentication Table User Supplied Password -&gt; hash_pbkdf2() -&gt; Cookie Verification: User Supplied Password -&gt; password_verify() &lt;- Database User Table Cookie -&gt; password_verify() &lt;- Database Authentication Table
Google hangouts has an audience app which works similar too Twitch chat, that is how the online audience generally gets involved. We're also active on Twitter during the meetups.
What an utterly pointless article. Hardly a "versus", more like a very brief overview of both languages (regardless as to whether or not the overviews are correct)
It allows for composite comparing $a &lt;=&gt; $b // Returns 0 for equal, 1 if $a is greater, -1 if $b is greater Eh..I guess it's useful for sorting functions but I can't see much use beyond that, cool name though.
I guess I'll just have to admit that I don't have a sense of humor. Not going to vote yes for an operator only because it has a cool name. This is a good feature, but it should be a function, which does not pollute the language, is more obvious when reading code (`compare` vs `&lt;=&gt;`) and can be used as a callback.
Create an application that makes use of the database? But you can do that in a lot of languages too ;]
Sure. What exactly is the point you're trying to make? I could take your post a number of ways but I don't want to be rude and assume you're arguing for something you're not.
Create a simple database interface for whatever interests you. Common one seems to be the personal inventory model. The classic is a todo list with ability to add/delete/edit/order list items. Include pagination if it isn't advanced enough for you. Create a simple API might be the best option but it might be too involved if you're starting out. Could do a super simple current time API to get started. 
I still have to learn all the database-side concepts, is there any course you suggest to follow?
It's not *just* because it has a cool name that I'm in favour of it. It's a fundamental operation, it should be an operator unless we can't help it. Simply because C screwed up doesn't mean we should. It's not even a novel operator: other languages have it too: Perl, Groovy and Ruby. Heck, many CPU ISAs (like ARM, x86, etc.) natively support this operation, and in fact `&lt;`, `&gt;`, `==` and so on are performed on such CPUs by checking the result of the three-way comparison. Also, none of our other operators can be used as callbacks, but the solution to that is to add some means to get an operator as a closure, not to block the addition of new operators.
Thank you. &gt; Create a simple database interface for whatever interests you. I'm missing this point, probably because i have no idea how to actually create a database!
Perl, groovy, and ruby are kitchen sink languages. PHP has strived in the past not to be, but now appears to take on the "If it's a feature, we'll implement it." approach.
I wouldn't say all of those are "kitchen sink" languages, and even if that's true, it doesn't mean that we can't copy useful features from them if the downsides are few.
&gt; To use it in all those cases, which if you return to nikic's original statement of it should be a function, it actually becomes far more useful since you can avoid the functional wrapper But that's not actually true. `usort($foo, 'compare');` is utterly pointless because that's just a slower version of `sort($foo);` `&lt;=&gt;` shines for *custom* comparison functions. In those cases, you already need to write a function.
pdo_pgsql, newrelic, redis and amqp are the extensions we've installed. The segfault in the bug report is from data in the magic file, not something that's supplied from our code or user data. The UTF-8 error in the PDO exception can't be caused by user data (which is what is being inserted) as there is a check in the code (using mb_check_encoding) before the point the exception is thrown to validate that the data is valid UTF-8. Plus it occurs 100% of the time and we are running 100s of inserts a second - I doubt all the data suddenly becomes invalid UTF-8.
&gt; pdo_pgsql, newrelic, redis and amqp are the extensions we've installed. Hmm. Not all of those are bundled with PHP, right? Your issues might be caused by a bug in one of those extensions. Of course, it may be a PHP 5.6 issue. &gt; The segfault in the bug report is from data in the magic file, not something that's supplied from our code or user data. Ah, fair enough.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Three-way comparison,**](https://en.wikipedia.org/wiki/Three-way%20comparison,): [](#sfw) --- &gt; &gt;See https://en.wikipedia.org/w/api.php for API usage &gt; --- ^Interesting: [^Three-way ^comparison](https://en.wikipedia.org/wiki/Three-way_comparison) ^| [^Meld ^\(software)](https://en.wikipedia.org/wiki/Meld_\(software\)) ^| [^Qsort](https://en.wikipedia.org/wiki/Qsort) ^| [^Comparison ^sort](https://en.wikipedia.org/wiki/Comparison_sort) ^| [^Sign ^function](https://en.wikipedia.org/wiki/Sign_function) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+co8sn2x) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+co8sn2x)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Your memory is correct; cf. https://web.archive.org/web/20051124044126/http://www.symfony-project.com/content/credits.html 
Will upgrading from 5.2 to the latest version of PHP break compatibility in any way? (Yes I'm aware of the vulnerabilities, hence the need to upgrade :D ) If it does break a few small lesser known functions that's fine but we have quite a lot of users and I don't want to roll out something that'll break everything.
Judging by the other replies, looking into Databases first might be best. but if you are interested phpacademy had quite a nice tutorial on it, although it is over a year old now. [phpacademy OOP Login Tutorial](https://www.youtube.com/watch?v=c_hNNAdyfQk&amp;list=PLfdtiltiRHWF5Rhuk7k4UAU1_yLAZzhWc&amp;index=2)
Any particular attack gives a *lower bound* on exploitability. An attack just says "something is wrong" and gives us a reason to fix the problem. Arguing that the problem shouldn't be fixed because the *one example attack* is impractical ignores the possibility that attacks only get better, and that other related attacks can exist. An example attack's impracticality does not upper bound exploitability. For example, in this case, consider local cache-based side-channels running from another virtual machine on the same hardware (cloud hosting), which may be more practical. Another reason not to think this way is that, in order to do so, you have to make assumptions about how valuable the data being protected is, and what environment the code is running in. Those assumptions may cover 90% of the actual uses, but there's still that remaining 10%. You also have to consider the possibility of your design setting a trend and getting stretched into totally different environments. This mode of thought has been the norm in cryptography for years, and I think it would be hugely beneficial for the appsec community, and even just regular developers, to adopt it as well. All of the good software engineers I know about attacks this way. Edit: Just wanted to clarify: If resources were unlimited, obviously we would fix all issues, even the ones we deem minor. Here, I'm not arguing against the idea of prioritizing major bugs over minor ones. That's absolutely crucial if we want to get anything done. What I am arguing against is dismissing problems as impractical, when it is very practical to fix them.
Have been using 5.6 for some time now. With nginx and mariadb and about a dozen php extensions no problems so far
Does anyone know what will happen in terms of HHVM and PHP7? Will HHVM still be the fastest implementation? 
How can garbage collection work in php, when on every page request php reverts to its default state? Is there a code example whereby I can leak/collect a memory just for practical purposes 
I think it needs the strict version &lt;==&gt;
Well, nice to have. But completely non-essential. It's useless outside of usort callbacks, and the entire rationale seems to be that somewhen someone incorrectly wrote `$a &gt;= $b`. Moreover `strcmp` is already available for that. And if you wanted `&lt;=&gt;` to actually behave like in other languages Perl etc., `strnatcasecmp` even.
We are also using 5.6 on production with mysqlnd, pdo_mysql, odbc, protocolbuffers, newrelic and the usual default stuff. No problems here. So maybe it's specific to pdo + pgsql?
I *really* hope not. Could it be treating null badly? It shouldn't...
All i did was using brackets to create html pages including php and javascript, while following various tutorials and guides. I think i'm missing how to actually make everything work, like how to use/choose a webhost.. I'll look into your links, if you have any more suggestions let me know :)
I haven't used Docker before, but after looking at your [Dockerfile](https://github.com/dave1010/php7-docker/blob/master/Dockerfile) I fail to understand, why use Docker here? This basically asks to be a shell script. EDIT: I think I got it. Is it something like chroot so that main system doesn't get the garbage?
Zend Server has great enterprise support for hosting PHP sites on Windows. Anything besides Zend, the problem is going to be the web server. All of the Apache binaries are compiled by "the community" last time I checked. Not a great decision for production stuff. My advice; setup IIS to work with php-fpm ... or just pay someone to manage the linux web server. Its not hard. If they are still balking what you can just use the PaaS services; Engineyard, Heroku, Pagodabox ... all run php
Part of the idea of Rasmus' Vagrant box is that it tests on an identical machine setup through a VM. When using Docker on non-Windows/OSX, Docker still uses the host's kernel, so testing compatibility this way might not be ideal.
Thanks for taking the time to read this post and share your valuable feedback. I found your suggestions insightful and agreeable, so I've amended the article to reflect them. :)
Thank you. I wanted to test it out before publishing my site, i want to avoid publishing my site and then being unable to completely understand/manage it! I think that the solutions is WAMP. It emulates a webhost essentially?
This has one (1) use case, and it introduces a new comparison operator that behaves completely unlike other comparison operators. This sort of thing is exactly why PHP haters hate. I wish the PHP folks would refrain from adding stuff just because they think it might be cool to use sometime.
It doesn't just emulate web host, it runs exactly the same software web host runs, but it's configured out of the box to only be available locally. And it also has a nice GUI for managing it.
My 2 cents: I agree with nikic's and other nay-sayers; I would add that the RFC doesn't make it obvious what happens with nested objects/arrays: [1, 2] &lt;=&gt; [1,3]; // -1, okay fair enough [1, 2] &lt;=&gt; [1, [1, 2]]; // what now? 
We are running 5.6.4 and have been running 5.6 for a couple of months in production with Laravel 4.1 and have had no issues.
We haven't been able to get our apps running on PHP 5.6 [last try was with 5.6.5]. We run into: 1. Major memory leaks with long-running PHP instances, such as our gearmand runner and PHP-FPM workers. Eventually every FPM worker would use up the max memory_limit, each. 2. A high number of segfaults via PHP-FPM. 3. Backward incompatible break where setcookie('name') does not overwrite/update a cookie of the same name. https://bugs.php.net/bug.php?id=67736 Our apps use PostgreSQL via PDO and MariaDB via PDO, acpu, and running on latest Gentoo.
Since when java.util.Date is cool?
Sorta. The intended use of Docker is to build a virtual appliance, which you can just ship to some server somewhere, start it up, and not have to worry about dependency hell. It just does the one thing you built it for. If there's a base Docker image for PHP (and [there is,](https://registry.hub.docker.com/_/php/) would you look at that (no 7 yet, though)) then we can base our own containerized applications off that and not worry about building PHP ourselves. If you're not doing the fully-containerized application thing, then having a Docker image for testing is mostly the same as having a VM image. There's less isolation, but on the other hand in my totally non-scientific messing around with both things Docker was something like an order of magnitude faster in downloading the images and starting them up, so. There's that.
A fair number of C functions don't specifically say they'll be `-1` or `1`. They say they are negative or positive respectively, but not necessarily those specific values. I suspect it's the same for PHP but could be wrong.
So it's basically a provisioner that also supports some form of virtualization, that works faster than a VM. Thanks. EDIT: Better explanation if anyone is interested: http://stackoverflow.com/questions/16047306/how-is-docker-io-different-from-a-normal-virtual-machine
That's correct, the standard in some languages is "less than 0, 0, or greater than 0", in others it is "-1, 0, or 1". You can convert the former to the latter by merely running it through `sign`, though, which PHP helpfully lacks (huh?). In PHP's case, `compare_function` always produces `-1`, `0` or `1` and I'm guaranteeing `&lt;=&gt;` will always produce those values, since it's quite useful. I'm not sure about `strcmp`. Internally, the misnamed `ZEND_NORMALIZE_BOOL` macro is used to ensure these sorts of things.
Another PHP Dev from Michigan. I know of a few good openings coming up as well.
&gt; to be that somewhen someone incorrectly wrote $a &gt;= $b. More accurately, people write that *all the time*. &gt; Moreover `strcmp` is already available for that. Only works for strings.
Why does it need to? Our comparison operator behaviour is well-established.
Does it give you an error? Why do you have two constructors?
I can use both the $teacher &amp; $student under the same construct? And the error I get is "Parse error: syntax error, unexpected T_LNUMBER, expecting T_STRING or T_VARIABLE or '{' or '$' on line 17"
This is great! I will definitely use your Dockerfile as an inspiration to add PHP 7 nightly to [dunit](https://github.com/Vectorface/dunit).
Not enough responses to make any judgement yet, but it's starting to sound like PHP-FPM is the common factor here.
Still learning php so I don't know for sure but that sounds like a type error. If I understand correctly php guesses at the type by context and for some reason maybe it guessed wrong. Perhaps there's a way to explicitly tell it "use a number not a string"? My guess is that in the person class the member declarations default to strings, then later you try to access them as a number, throwing that error.
Did you figure it out? You removed the link to paste bin.
I haven't figured it out, no. Maybe it's just an issue with Codecademy, also, the pastebin link should still be there!
&gt; If SQL is pronounced "sequel", can we pronounce PHP as "phap"? No, at least not for the same reason that SQL is commonly pronounced "sequel". In its first draft, SQL was named SEQUEL, short for "Structured English QUEry Language". It was changed to SQL later on due to a trademark conflict. That's not to mention that the [creators and ISO consider](http://patorjk.com/blog/2012/01/26/pronouncing-sql-s-q-l-or-sequel/) the proper pronunciation to be "ess-queue-ell."
Your post content was "removed". http://i.imgur.com/P7uF9z1.png
That is strange. At any rate, the first thing you want to do is remove the second constructor along with any reference to $teacher or $student *within* the class. You should be using "$this" instead of $teacher or $student. You won't reference $student or $teacher inside the class. The point of a class is to keep all that outside and you instantiate a new object for each Person you want to create; in this case, a teacher and a student. Also, you seem to be using the class variables backwards. Instead of: $teacher-&gt;boring = $firstname; $teacher-&gt;12345 = $lastname; $teacher-&gt;12345 = $age; Use this: $this-&gt;firstname = "boring"; $this-&gt;lastname = "person"; $this-&gt;age = 45; You also need to make sure you define each of those variables within the class before you try to set them for each object (which you have done here): public $firstname; public $lastname; public $age;
Why are you executing long running workers via PHP-FPM? This is a job for the CLI SAPI. 
Seems like this would be a known issue if it was PDO + PgSQL. OP isn't the only one running PHP 5.6.x and using Postgres over PDO in a production environment with that amount of transactions.
The remember me function is never safe. If someone has physical access to a device and you are still logged in, cookies aren't your biggest problem I think. You can try to bind a token to a useragent, IP adress or whatever you want. But it's never completely safe.
Awesome! Had a play with dunit and it was partly what inspired me to write one for PHP nightly. Feel free to grab as much or little from the Dockerfile as you need. On a practical note I'm not sure the best way to keep the container up to date. Should you destroy it and re-download the image or should the container be able to update itself?
~~Certification~~ Money making scheme. But I do like Symfony2 otherwise.
Things to ask: - server OS/distro? - 32/64bit? ( would assume the latter) - distro package or source compile? - installed PHP base extensions? - note from another comment you are running some additional extensions. Are these all solid against 5.6? Possible to isolate and remove these to test for a possible culprit? - how are you spawning child processes? Have to admit I have never had good success with the spawn/die method (including seg faults) - a fixed number of child's for me is much better and very solid. - in addition to above - have you looked at your PHP-FPM conf and the max requests setting? (Sorry on phone can't remember exact name of stanza). E.g. Allowing child's to die and then respawn after serving a specific number if requests - often fixes memory leaks introduced by buggy extensions. - running bundled opcache?
Thanks for taking the time to look at it, should this work now: http://pastebin.com/JNP0zD73
Minimal PHP routing was solved a long time ago. What does SnappyRouter bring to the table compared to nikic/fast-route, league/route, or aura/router? We already have [22 pages of routers](https://packagist.org/search/?q=router) on Packagist. Is writing a router some kind of rite of passage? ¯\\\_(ツ)\_/¯ 
Nice analogy!
The same people who write that 1. will still be using PHP 5.2 for the foreseeable future. 2. won't be using PHP 7 for another decade! And... 3. won't have the acumen to even KNOW about &lt;=&gt;, much less WHEN IT IS APPROPRIATE TO USE IT. **ALL** this will do is 1. Make code, especially bad code, that much more unreadable. 2. Increase the likelihood of incorrect use cases. Fortunately, we won't have to worry about sweatshop coders churning out horrible code with this in it for another ten years (see point #2).
&gt; usort($foo, function (FooBar $a, FooBar $b) { return $a-&gt;baz &lt;=&gt; $b-baz; }); Wouldn't this be just as good? usort($foo, function (FooBar $a, FooBar $b) { return spaceship($a-&gt;baz, $b-baz); }); 
Have you tried your code on maybe a vagrant box with a standard PHP version on it, as opposed to PHP-FPM? /u/2012-09-04 says he/she's running into problems and also mentions PHP-FPM.
It wouldn't for a good portion of PHP code, but anything using any PECL/C extensions would make a difference.
Have you reported the issues at php.net? Especially when the issue is reproducible, they tend to be quite good about fixes. 
Can you give me an example of how, say a RHEL vs a Debian kernel would create differences in a PHP extension? Or if a kernel was compiled with different options? AFAIK pretty much all differences get abstracted by the time it gets to PHP. Would be interesting to learn of any differences though.
If PSR-7 would came out, wouldn't a completely new Guzzle 6 have to come out even though v5 came out not too long ago?
Are you guys talking about The Nerdery?
The bug report I linked was reported by myself :)
Hi, thanks for pointing me to that package, I only really was doing it for fun, then started seeing a practical application and didn't really see anything similar on Packagist. Also, what would you recommend doing instead of the ternary operators? I wanted to ensure that only a `boolean` value is returned, in that example `substr_count` returns integers.
We're using Sentry (getsentry.com, source at: https://github.com/getsentry/raven-php) but we also have error reporting as a side effect of Newrelic although we don't primarily use this as Sentry is more detailed. Sure, we can try running our staging environment on a debug build but it seems to take a fair number of requests to trigger the issue.
Eh?
We're running on EC2 instances using Ubuntu 14.04 x64. We use PHP as built [here](https://launchpad.net/~ondrej/+archive/ubuntu/php5-5.6) but one of the things we tried was building PHP ourself but we still have the same problem. The only extension that our app will still continue to function without is Newrelic so it makes it difficult to test the extensions in isolation. We've got a static number of children with unlimited max requests, can try setting a maximum number of requests. Yeah, using the bundled opcache.
He is saying that you can do: return substr_count($string, $substring) &gt; 0; this is actually a boolean.
Clearly I can't read :/
Depends on the server and chan you frequent lol
There were actually some reports a few months back saying phpng (php7) was faster than hhvm. [Here's a blog post from July for example](http://blog.zend.com/2014/07/17/php-next-generation-outperforming-facebooks-hhvm/)
I'm just one guy, so your mileage may vary. That said, in a junior I'm looking for "can write PHP," "has used at least one framework or CMS." It's been my experience though that most people are looking for someone with a specific skill, but limited enough experience that they don't have to pay so much. That said, my advice is the same as for everyone: Learn a little about a lot of things. Go play with every framework and tool you can get your hands on. No need to pick up extensive knowledge, just enough that you have a decent idea of what one tool might be better at than another. Shouldn't take more than one or two nights for any given thing you want to play with. That way, you are showing a few things: * You don't mind using new things * You are capable of learning (this sounds sarcastic, but the number of developers who learn ONE THING and then try to force every project into that one solution is astounding) * You now have experience with multiple ways of doing things, so you probably won't choke if you have to switch projects or work on more than one thing * You may get lucky and find a job that just so happens to need someone with at least a little experience in one of the things you learned
&gt; One thing I learned was that return types are crippled by the lack of nullable returns. For most of my functions, I need to return TRUE (success) or a string (error message). I'd be fine with switching to NULL (success) or string (error) so it's hintable, but I can't actually do that, because we lack nullable returns. That means I'm omitting return types on most of my functions, unfortunately. I hope that the Nullable Types RFC can pass and fix this. FYI, I've been moving more towards using simple Data Transfer objects for methods that can fail without that failure warranting an exception. For example, I have a `ValidationResult` DTO that gets used like so: $result = $this-&gt;validator-&gt;validate($input); if( $result-&gt;failed() ) { $errors = $result-&gt;getErrors(); //do something useful with the array of errors, return } //handle success Granted, I use it to solve a different set of problems (encapsulating validation meta-data and cleanly passing different success/error messages to the end-user, but it seems like a good way to get around the issue of non-nullable return types.
I guess I was asking too much :/
/facepalm I'm an idiot
have you given any serious thought on any methods other than "declare(strict_types=1);" to add strict types. (adding that to every file is pretty lame). function (int $a) {} &lt;-- for strict types function ((int) $a) {} &lt;-- for weak types will look better.. PS: before replying .. if argument against using (int) is that *we currently dont do that for objects*. that wont hold because we dont use () for casting one object to another, but we do use that to cast scalar types. Weak typing *without value loss* will be better for php. and this method wont have bc breaks (as you can use the () casted function parameters for c functions, so that it will continue to work as it is now..)
&gt;Its the most simplistic secure log in system Getting logins to be secure can be surprisingly difficult. Post some code so people can see the problem.
&gt; have you given any serious thought on any methods other than "declare(strict_types=1);" to add strict types. What makes you think I haven't? The RFC discusses why I didn't choose other approaches and why I think they might be harmful.
Yeah, something like that might work, might be better as it can express a more sophisticated value. As an alternative to nullables I could also use an optional type, but without generics they wouldn't be terribly type-safe.
'll quote dmitry "Declare() is a working solution, but it's not excelent. Thanks. Dmitry. "
Isn't it paid? Are there any free alternatives?
It's the best, but yes, it's a commercial IDE. If you want free stuff, I think you can try NetBeans (for PHP), or Aptana. Edit: You said you are using Eclipse already. Sorry.
We (Grooveshark) have been running 5.6.4 php-fpm (moving to 5.6.5 soon) for months behind nginx without any issues so far. We use json, mcrypt, openssl, curl, mongodb, redis, memcached, posix, mbstring, mysqli, bcmath, gearmand and a few other extensions. We don't use PDO, which might be the issue here? Edit: OS is CentOS 6 (and 7) with php being custom built with our own curl.
That sounds nice. Let me try it out. Thanks.
I did download it and it is asking me to either provide a license key or use a 30-day trial. 
Sublime is a text editor. States right in their main page. Phpstorm is an IDE. Both are great btw
Ugh, yes I did - think my lack of sleep has finally caught up with me!
When working with your own packages in Satis run composer install --prefer-source to get git repos instead of packages. Now when you run composer update it will tell you that you have local changes and ask what you want to do about it. It also means you can easily push from within your vendor folder.
If your using semver and specify your dependencies like "~1.2.3" then running update will only get you newer patch versions which, in theory, should be safe.
We currently use Ansible and Jenkins. It's an absolute charm.
Hrm - very similar setup to what I run on production boxes - even down to EC2 - but have used other cloud providers/hypervisors too. Maybe try the max connections per child option - it could be a leaky extension causing the issue - with enough children (assuming you have the RAM) you can recycle the children pretty aggressively - 250-500 requests max without any issues. The OPCache is shared between child's - so don't worry about having to rebuild the opcache. And on the opcache - have you tried running without it to rule that out? Even if only on a single node in your ELB farm (assuming that as your load balancer - but you get the idea). 
This doesn't allow you to verify "previous forms" as it's not possible to figure out the "getTrueToken" from a plain form submit (you can't construct the actual getTrueToken just by having the $key and HMAC output of them). That's why a reversible operation is needed here. And indeed I think XOR is the best approach as it is super simple (and does the reversible "masking job" all good). 
For the deployments we are using Phing, a PHP port of Ant. http://www.phing.info/ For orchestrating Chef and Puppet + Phing For CI we are testing Scrutinizer and PHPCI. For PHPCI the bad part is that it has bugs, the good part is that you can fix and/or create plugins because is a PHP project. https://github.com/Block8/PHPCI
I really like it in Ruby where it's essentially the default comparison. Instead of overriding several different operators when you want to add object comparison, you just override the one spaceship operator, and get all of the other ones for free. That's not happening in PHP though, so it doesn't really have the same benefits.
Okay, so if I was to go down this route, how do I specify in composer.json that only my satis packages that I want to develop should use --prefer-source, but the remaining packages should use the regular --prefer-dist? I've had a look but I can't find a flag or anything that I could add in composer.json. If I understand correctly, this the expected workflow when editing directly in the vendor directory: 1. 'composer update' in the app root folder 2. Manually delete the folders of the packages I want to develop 3. 'composer update --prefer-source' (forcing the packages I've just deleted to be reinstalled with VCS) Then once I've finished modifying the package files and I'm happy with my changes, I would have to: 1. Commit and push my changes to the VCS from withing the package folder in the app's vendor directory 2. Update the app's composer.json to reference the newly updated version number of the package 3. Manually delete the folders of the packages I've just finished working on 4. 'composer update' in the app root folder to reinstall the package, but this time as a regular vendor package with no VCS. This still seems really long-winded, is there a better way?
Yeah, NetBeans is great. I used it about 5 years.
Mine offered, but I got in under a Youth Mobility Scheme (Canadians under 30 don't need a sponsor). I also got hired and pulled to the UK for work.
Good job I noticed a small error in Dockerfile line 21, missing a "&amp;&amp;" between the "cd" and "./configure" command
I use Netbeans and it works really well.
I second this :/
Codeigniter 2 - January 2011 https://web.archive.org/web/20110805025800/http://codeigniter.com/news/codeigniter_2.0.0_released/ And v3 due to be released very soon I believe.
You didn't include your zipped link. Your `userLogin()` method seems pretty solid to me. But it would be nice to see the rest of the class and a place where you use it.
I found your zipped version in previously opened tab, I don't see anything that stop it from working, except maybe you should rename your index.html to index.php, so it gets executed?
Not really answering you but sharing anyway: I don't. I copy the files to the server manually using FTP with FileZilla, and even delete files manually when necessary. This happens a few times a week. If there's also a database change, I execute it first with MySQL Workbench before copying the files, but this doesn't happen very often.
Sure, but what does that add to this discussion? He says it's not "excellent" - I know that, it's not a perfect solution, none of the solutions are. But I'm yet to see something better proposed. The RFC covers why the other solutions thus far, from my perspective, are inferior.
Fair enough. The RFC has a pretty big rationale section if you haven't yet read it.
A direct link is easy. I said try using a search engine and see how many operators you can find without knowing the technical name for them.
I use PHPStorm or IDEA (mainly since it supports a few others). There is stuff out there that allows you to generate a key.. but obviously if you like it enough, you should purchase a license. PHPStorm is 100$ I think. IDEA is more (unless you go with the community edition, which is free).
Laravel Envoy following a successful CircleCI build.
Rocketeer it's like capistrano for php written in php
In java/maven using eclipse, this problem has already been tackled. Eclipse keeps track of all opened projects, and if one of them matches dependencies of other projects, the opened project is used for that dependency instead of the remote version when running/debugging. A match is only made when the project id and version number are compatible. When I started developing in PHP (again), I was a bit surprised to find out that PHPStorm does not support this with composer, although I do realize it is not trivial to implement this.
I don't understand how this is a PHP post. It seems to be just about links in general.
I don't use this method myself but some of my colleagues do. I believe they just use --prefer-source and get the source for all packages. It's a little slower but does no harm in that you get the exact same code. As for the changes I think step 1 and 2 are correct then just run composer update --prefer-source again in the main app simply to update its lock file.
I've been giving some thought to moving to Berlin in a few years. What's the job market there like?
[Seriously?](http://lmgtfy.com/?q=pinterest+rest+api)
Really? Show how I can get access token?
TIL about lmgtfy.com, thanks.
I know they didn't an an official rest API about 2 years ago. However check https://developers.pinterest.com/ for more information. From what I can see they still don't, however I am sure you could of found this yourself with a little bit of imagination. 
Jenkins + Puppet. 
Have you ever work in big team and develop software for long term? :|
I've heard nothing but good things about Ansible. Is there a good resource that you would recommend, aside of the official documentation of course?
&gt; "Exceptions only for exceptional cases" is just a meaningless phrase meant to sound nice, No, it is an important principle. Exceptions are slow compared to manual error handling, so if something isn't "exceptional" and happens frequently, you should handle it as a manual error. Exceptions terminate your program if unhandled, so they shouldn't be used for things that are *supposed* to happen. Exceptions aren't flow control, they're a last resort. But I'm not an expert on this, there are far better resources that can be found by searching.
Git hook that informs jenkins who runs capistrano.
"CI server"- what CI server do you use? Jenkins? Is there any chance u can publish a code that builds a docker container and pushes it into a repo?
I'll check it out. Thanks!
What's the benefit of unlimited max requests? Seems like the purpose of that feature in the first place is to help avoid the kind of leaky issues you're experiencing no? 
You could also do `return (bool) substr_count($string, $substring);` since 0 will cast to false and anything else will cast to true.
Netbeans is inferior. The only way it isn't worth the money is if you don't actually *make* money from PHP development.
You also don't have to build images at all... you can load a standard base image and use a provisioning tool to configure on the fly, which I believe to be preferable as it keeps more of your application's information in human readable format in source control.
You're using private repositories through Satis, right? Why not in your primary app update your composer.json to use a new version (dev, or whatever you want, follow [SemVer](http://semver.org/) if you like). Then you're free to update each of those `feature` repos and pull in changes with `composer update --prefer-source`? Also, our company uses GitLab for hosting all of our repositories, and I'm using [`terramar-labs/packages`](https://github.com/terramar-labs/packages) to handle our Satis build. I've been very pleased so far.
I tried that before asking others for help, unfortunately there's only 8 results most of which are either translations, individual components or someone also trying to learn. https://github.com/search?utf8=%E2%9C%93&amp;q=auraphp
I like to use phploy with a custom script before to set up production environment.
I mean, I know why it was broken up (as it should be) into different RFC's, but I'm probably just moving fully to Hacklang if PHP7 doesn't also get nullables and generics. The only thing really holding me back right now is that I need IDE support since I have a lot of junior developers that work for me that benefit from all the nice things IDEs provide. PHPStorm should be getting Hacklang support sometime this year.
I use dokku on Digital Ocean. It uses docker. I develop locally then push my code up to DO using git push deploy master. It tries to bring up the container and if it fails then it never brings down the old container. It is fine for my small site but I think putting a CI server in the middle of my workflow is probably the correct way to go.
I haven’t tried Docker, at the time, we thought it was still too unstable, especially on hosts other than Linux. However, we are using Vagrant and we are having a blast so far. https://github.com/wemakecustom/wmc-dev
You can take a look at [this one](https://www.digitalocean.com/community/tutorials/how-to-set-up-automatic-deployment-with-git-with-a-vps) :)
Im using varant too for development. But those are very different things though. Vagrant is for development environments, Docker is for production. P.S. also - why would you use docker on any other hosts but Linux? given that LXC containers are Linux-kernel thing
I've used vagrant/puppet for both development locally and production deployments to rackspace. That saved my ass when a coworker said, "What happens when you run 'sudo rm -rf /'? Why isn't the machine working." I had another site stood up in less than 5 minutes.
It only is if you didn't make it all the way to the bottom, which is fair I suppose... it's pretty lengthy.
Github, to CircleCI, to Heroku. Pretty simple :)
The official docs are actually really good. Ansible is simple, you should be able to pick it up pretty quickly - even writing your own modules is dead simple.
Fig is a development tool. In production, you'd have your configuration settings point to your various services that are hosted on different machines. Fig just allows you to simulate that environment. For example, you might have `config/production/db.php` that has your production config (ex. `db.example.com`) and then you'd have `config/local/db.php` that has your fig settings. Fig creates host file entries on the webapp's Docker container so that you can point to the other Docker containers via a hostname. So my `config/local/db.php` would have a line that says: `host: 'mydbcontainer'`
I've been using [Dockie](https://registry.hub.docker.com/u/dockie/dockie/) as a Docker base image for development. [Fig](http://fig.sh) for any needed services, like MySQL. Here's the [Quick Start Fig example](https://github.com/RobLoach/docker-fig-php) for a demo.
FWIW: We've taken a lot to experimenting with ReactPHP in an internal project so far. We have some fixes (like Resolver querying hosts file) that we've yet to push forward, but ReactPHP is so amazing. I'm a huge proponent of nodejs, so I love writing event driven code like this.
For our internal project we've essentially built a whole EDP framework for PHP that also is designed to support large scale SOA applications. We're planning on open sourcing it later. :) 
There is no sure way to make things secure when you are saving data on to a client as a cookie. You could make use of SQL to limit logins/account by saving a timestamp, an ip, a PK etc whenever someone logs in, and deleting it when they log out, but as soon as a hash or encryption is saved to their computer, there is no telling what will be used to hack it. I found this article to be very helpful when building my first serious authentication system: [http://www.sitepoint.com/password-hashing-in-php/](http://www.sitepoint.com/password-hashing-in-php/) Using a "salt" could add a significant benefit if you want to have a remember me checkbox. Even if a hacker decodes the cookie, they would also have to know to salt associated with the user's account. 
I've been using ReactPHP in a fun PHP side project for DLNA, DIAL, and tv casting type stuff. It does SSDP, UPnP controller and mediaserver, DIAL, Chromecast CastV2, and has an HTTP API and CLI. This library has made socket work and event-driven programming very easy to do in PHP.
In addition to the official docs, this repo is quite useful: https://github.com/ansible/ansible-examples
Sure! It's a bit messy at the moment, so I'd want to put some more work and cleanup into it before making it public. There is a psr-4 library I've been working on that does the upnp message formatting and such, it is also a work in progress so please excuse the quality until things are further along. You can find it on packagist under jalder/upnp. There are a couple of socket functions in that library that you can use to start talking to devices with single requests, but the automation and event response type stuff is all in the app using React.
Here's the thing: Everyone wants to downvote you because tooling is better for a number of reasons and in large groups it's the only feasible option. But the question was "what tooling do you use?" and you answered it. If you walked into an environment that's resistant to change and has been doing things this way for 20 years it can be hard push your views on senior people, regardless of what's "better", and that's a business reality that people often miss.
Fearmongering in a title helps no one. All code has bugs. If your code falls under the umbrella of "all code" then it too has bugs (gasp). Does that make all code "unstable?" Hardly. A title like this is irresponsible clickbait and doesn't reflect the actual content of the post. *edited for brevity
I played around with react when I was doing something that required realtime parsing of messages between users. It was absolutely a joy to set up react with web sockets (even if a couple concepts were over my head).
sell me mongo db please. how can you make relational data there? How does the crud work if you have several entities related to each other in complex ways? think on an sotre with inventory, shipsments, sales, products, managers, areas, category products. To me the fact that there are no foreign keys sounds like a nightmare, anytime i have worked with a relational database without foreign keys i lose a year of my life
you must first find a framework or cms that covers the need of your proyect, then read the requirements for the tools you choose. Most php libraries are not optimized for the latest php versions, some even have bugs there. For example if you choose to use magento (please don't) then you better stay with 5.3 or 5.4
Have a look at the wappalyzer browser plugin.
Too bad, because manual error handling increases the code that needs to be written about tenfold, and means the code is harder to change. Also, if validation fails at a step of my application and I forget to handle the validation error, you're damn right I'd want the application to terminate immediately.
Most content management systems are using a generator meta tag that tells you about its origins. But to always be certain about it you need to get some experience with these in order to understand the layout that they use. Earlier it helped me to distinguish between two paid solutions: FirstSpirit &amp; Infopark Fiona (don't kill me on that name, I have a feeling that they tend to change the name every year). Generated urls are often a good indicator as well. 
Plus, AWS will be getting Docker support soon.
thats good one, save for later ;) thank you
This reminds me of when I would be programming in basic and you would set the line numbers in increments of 10 so that if you needed to go back and add an extra line or two it didn't mean renumbering the whole file. The benefit of doing so in a programming language like BASIC is quite clear, however as class constants are a mapping of an integer to a constant key the value of that integer is moot because you would be comparing against the constant rather than the integer. As for why the json_encode options increase to the power of two (2^n), without looking at how they are used I can only guess that they may be used in bitwise operations against another value. 
Flags (options, as in series of binary values) should be represented as a binary set (2^(x)) as one can combine them into a single value ([bitwise operators](http://php.net/manual/en/language.operators.bitwise.php)), and can test that value later whether it contains a specific flag. Imagine you have A=1, B=2, C=4. If you combine A and B using "A | B" you get 3. Later you can check whether A is in that value by using "(3 &amp; A) == A". Please don't quote me on those operations and better read up on them - I haven't use bitwise in a while myself. Return codes like error ids or other values only ever representing a single state should be a linear series, and if one wants to be pedantic, one can order them. It should make no difference in your code if you later add one in between by reordering your values as you should always use the name in your code anyways instead of values. Of course you can't reorder if you save that value somewhere like a database.
For more on how you can do cooperative concurrency with PHP, check out nikic's blog post from a while back about coroutines and generators: https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html 
I believe their numbers are like that so they can use [bitwise operators](http://php.net/manual/en/language.operators.bitwise.php) to determine what applies. Here is a simple ACL example: USER_READ = 1 USER_CREATE = 2 USER_UPDATE = 4 USER_DELETE = 8 Using an ACL like this, can store a single number against a user in the database and from that number find out what roles apply: * Someone with 12 can `UPDATE` and `DELETE` (4 + 8) but not `READ` or `CREATE` * Someone with 10 can `CREATE` and `DELETE` (2 + 8) but not `READ` or `UPDATE` * Someone with 4 can `UPDATE` but not `READ`, `CREATE` or `DELETE` Because there is no other way to make up the score (you can't make 8 from adding 1 + 2 + 4) you can then use bitwise AND, OR or XOR to determine what the user can and cannot access. In the example you've given, you can only pass a single integer to `json_encode()` as an option. This integer can relate to multiple options, for example you might want `JSON_HEX_TAG` (convert &lt; and \&gt;) and `JSON_HEX_AMP` (convert &amp;) together, so you would pass 3 as the option (or `JSON_HEX_TAG + JSON_HEX_AMP`). Edit: I actually read the link provided re: the JSON constants.
Anything that is relational goes in mysql though we don't really have too much of that anymore. It's also just a matter of how strict you want to be. If a user is deleted and any related data in MongoDB isn't deleted is that a big deal? Not to us. If data was added to MongoDB for a user that doesn't exist that isn't a big deal either. We have much more important things to worry about than little consistency issues like that. We can just run a cleanup script once a month that removes any invalid or expired entries. MongoDB for us is awesome because we can add and remove data/keys/indexes on the fly without having to update a ton of schemas/code or heaven forbid, run an alter.
&gt; if a user is deleted and any related data in MongoDB isn't deleted is that a big deal? In most of the cases I can think of yes it is. I am doing mostly management systems and ecommerce. For example one of the biggest headaches I had last year was a system about selling tickets. Its vitaly important all the fields on a sale where consistent. Buyer, seller, seat, pay method, everything. It didn't had foreign or unique keys when I started. Things like selling the same seat twice (sometimes on the same sale order), inconsistencies on the ticket price depending on which table you looked, uncompleted operations with missing fields or fields that doesn't point anywhere (for example ticket/order relation gets saved but the order gets cancelled or the seat is no longer available). And the reports. Ohh god the reports. Every penny had to be precise to the cent because it was gonna go to IRC and taxes. Besides the marketers wanted to know every detail on how many tickets were sold, from which sections, at which prices, etc. All that information were theorically there but impossible to make it make sense. 
I do know node? Working with React is amazing. It's like working with node only not having to deal with ECMAscript's object model. Also, you obviously haven't looked into React itself at all. :) that's okay, I haven't gotten to the posts where I really explain it in depth yet. Stick around and I'll answer your questions in later posts. 
Thank you for the idea. But my goal is to use a "standard" PHP installation.
Really cool post. I'm just wondering, how do you guys configure the server as to ensure uptime? A web server strikes me as more reliable than a php script running listening for connections. What if the script crashes or runs out of memory?
It looks like the jsonstreamingparser linked to does use standard php. It only lists a requirement of php &gt;= 5.3
As of this reply it's been 56 minutes, but I meant in more posts like the article I wrote here, which I'll be writing more of over the next few weeks. 
No, I meant your topic, not your reply.
Hi Guys, Long time lurker in /r/php A friend and I wrote a blog post for our company, hopefully it is fine to post it here and get your guys thoughts! 
That's a library you just drop in your project and not an extension you need to compile into your PHP installation. So it stays pretty standard. As for your question, if you don't find a better solution you could make some experiments and estimate the memory usage from some sample strings. Then restrict the JSON string length based on those estimates.
You could run some tests with `memory_get_peak_usage` to get a rough size in kB/MB of the largest JSON you could parse.
Great post. I would consider extending it to include frameworks like Symfony and Laravel, Testing frameworks like phpspec, codeception etc? I would also include build and deployment tools to increase efficiency as a developer.
I did some test, but I could not get usefully results. I tried to compare filesize/memory_get_peak_usage Number of commas/memory_get_peak_usage Since I don't have a fixed schema for the JSON data, it could be everything, from an integer to deeply nested objects. And the JSON file could contain whitespace and newlines which increases the filesize but not the peak memory usage I guess 
Give the guy a break. Writing technical blog posts takes time and not everyone have all the time of the day to do that in. 
The upgrade process is pretty easy too: http://laravel.com/docs/master/upgrade
Actually my cookie only stores the following information in the following format: user_id:token:timestamp User ID I figured is not a big deal or security issue. The token is just a randomly generated string of numbers. The token is unencrypted on the cookie but using encrypted using BCRYPT for the version I store in the database. So apart from user_id there is no personal information being stored in the cookie, and also none of what is there is encrypted, so no need for a person to try and decrypt it. The encrypted version of the token is stored in the database and I read the cookie for the unencrypted token, encrypt it and compare it to the SQL version.
simple approach is dont use linear numbers but const1 = 1000 const2= 2000 const3 = 3000 ... you then have enough space to fill gaps thats what has happend with http error codes for instance 2XX success messages 3XX redirect messages 4XX error messages and so on
Hi I'm a java developer who might have to do a project in php in the near future. I've heard that Laravel is more of a "child's" framework in that it is designed for more beginners and follows intermediate architecture principles like facades whereas Symfony is more truly enterprise and modeled after Spring. Can anyone confirm?
&gt; more truly enterprise Can confirm, java developer. That's what you wanted confirmed, right? &amp;nbsp; ^(it's just some humour - I don't believe in silly flamewars - use what suits your project/team!) 
Oh man, you're gonna start a long drawn out argument with that second sentence. Short answer: You can develop large applications in both. Symfony is definitely more enterprisey. Is being more enterprisey a bad thing? Nope.
I would say Laravel has more "enterprisey" features out of the box such as queue support, command bus, more thorough dependency injection by default, etc. Those enterprise features are just executed in such a way that they don't "feel" enterprisey when you are using them.
Release Notes: http://laravel.com/docs/5.0/releases
The first one for sure. The second seems like a code smell.
Is it really released or is it RC ? Never noticed a alpha or beta or RC when going through tags.
Laravel is sometimes referred to as "PHP on Rails", it is very good and quick for development, but as mentioned in some other comments is very opinionated in some areas. My java friends much prefer symfony and/or ZF2 as their framework of choice. (Even though they are a bit heavier and more 'complicated' than laravel.)
Congrats on the release and Thank you.
I think we're all forgetting the fact that if it's not hard, it's not enterprise.
&gt; A lot of people seems to have been testing it for a while though. that said, I am not blaming. But I do recall a thread someone saying "oh you breaking the api". And Taylor saying it is not yet released even in alpha, so api can change , no one guaranteed the api. So let's hope everything is fine and all users are using in production rather than just trying laravel5.
That is some very good news
What's to prevent a malicious client from opening up the console and wrapping the send function in an infinite loop?
I'm using a [slim curl wrapper](http://fossil.include-once.org/hybrid7/wiki/curl) for such things. It's a trivial map atop the ugly procedural curl_* functions, not a distinct API, and much briefer: $result = curl($url)-&gt;post(false)-&gt;httpheader(..)-&gt;exec(); Once you've set up such a curl handle, (without using -&gt;exec right away), you can stash it away for later reuse. Just augment `$curl` with new options if you need to, or run and operate multiple such curl queries together: $results = curl_multi([$curl1, $curl2, $curl3])-&gt;exec(); 
So at this rate Laravel 6 will be Symphony with facades?
&gt; 1. Connect your email provider Choose from a variety of email providers. We currently support Mandrill, Sendgrid and SendWithUs, and the list is growing. How would you protect mail server authentication information if nothing is stored server-side? Mandrill (and presumably the others) use an API key, which needs to remain secret.
I can see some usage to this from a small marketing shop perspective, but any larger businesses won't want to use this, mostly because server side email isn't particularly a difficult task (or even that costly!) . People that deal with email have other concerns, the sort of concerns a client side solution like this can't answer to.
&gt; Your API keys are not exposed, and only predefined templates can be sent. Optional CAPTCHA built in. This is their answer, but I don't understand how the API key is not exposed.
See you there!
Private scope perhaps. E.g. (function() { var hiddenInfo = 'come find me'; })(); But I still wouldn't trust this if it's the case.
it can make money for you too, a certification on your CV is pretty good
"Pretty easy."
Laravel ADDED global functions in this release. 
Damn, and I started a new L5 project yesterday! I wonder what has gone in between now and yesterday. Cheers for the new version!
What could possibly go wrong?
Actually, working through the actual worklog, it's not *that* bad. A lot of steps, but mostly small steps and the guide really is well written.
I've also heard very mixed things about the project's maintainer in that his architectural skills are quite questionable compared to Symfony's maintainer. Do you find that there is any truth to this?
I'm attending as well!
I bet most of the email sent from this client ends up in the Spam folder because the average client doesn't have a DNS entry.
Oh, you don't care about technology, this is some territory thing for you. You should have led with that.
What is a model scenario? How are they used? Is there an example? I first heard it on Yii2 and found a lot of articles on the subject for example http://www.bsourcecode.com/yiiframework2/yii2-0-scenarios/ But they all seem to start on the assumption that you know what they are and what they are used for.
In many ways it can work just as well. But PHP doesn't *prevent* you from fucking up the event-loop, Node does. If you use PHP+React as a full replacement for Node, take extra care in designing your software.
composer update and find out!
Growing/Learning pains perhaps? Doesn't mean it will be a trend.
You don't need to abstract a constant. :)
Same. I don't see any reason to do so, and if there is a need for a previously completed 4.2 project to move up to 5 at some point, the upgrade doesn't look difficult. 4.2 is widely enough used that any critical fixes will get taken care of for years to come, even if it's by the wider community. I would be more concerned about when the entire PHP 5 branch goes EOL than when a 4.2 app can't be updated. Maybe someone more knowledgeable can let me know why I should worry about upgrading completed, stable 4.2 apps.
Jeffrey had said that the second L5 was released the new series would be available for free. Glad he kept his word, even though I am a subscriber. 
My only complaint with his casts is he'll show you three "wrong" ways of doing something before showing you the best way. I'd rather he just showed the best way immediately and mention there are other ways without bothering to code and recode them.
Even if they are wrong, it's good to know them. 
Also have a look at this. http://container.thephpleague.com/ probably the best one I have ever used.
A few months back they had a non-produced video they were going to post in November on how to upgrade from 4.2 to 5.0. Anyone know if this was ever published?
Bitmasking is appropriate for some tasks and wildly inappropriate for some others. When you have mutually-exclusive values (status/state tends to be), you should **not** use bitmasked values. "Flags" (such as permissions, per your example) are a great use of them.
This looks interesting. Will certainly dig more into this. And I never said that it was a good idea, only that it achieves what I want it to achieve. :)
Maybe it'd be worth it for route caching if you need the performance?
I understand so far. So I have some code like this $('.send_email_button').on('click', function(){ EmailJS.send(template_name, template_params); } Assuming EmailJS is a global, what prevents a malicious user from opening up the console and then executing: while(true) { EmailJS.send(template_name, template_params); } 
That's why there needs to be a strict operator &lt;==&gt; and probably also a *very* strict operator &lt;===&gt;
I found it to be quite responsive. It didn't slow down till I added my retirement account - which I was surprised even had an API - and now it's slow because the retirement account's API is slow.
Nothing. However, If I understand correctly, you're saying someone might abuse our API to send spam, i.e. for some personal gain. There are a few things that can protect us from that - rate control by IP, use cookies, do some analysis of the request parameters, etc'. That said, and while this is something that can occasionally happen, I hope that this is not "life-threatening" condition for this business. To be honest, I've always wondered how come nothing prevents me from abusing Google Analytics / MixPanel / KissMetrics, etc, and flood some site's account with fake events. To the best of my understanding, nothing really does. Let me know if you know of their ways to protect themselves! Also in the spammers case - they are looking for positive ROI on investment usually, not to just do damage. I believe looking for services that use emailjs.com, analyzing the templates, updating the scripts for the specific template, and all that for sending 1k emails in the best case (until they are blocked either automatically by the rate protection, or manually) would not be the best idea for them :) Additionally, we also intend to support captcha - you'll be able to request an image via the API, and we'll require it on the server side, if enabled. What are your thoughts?
[Like I said last time this was posted](https://www.reddit.com/r/webdev/comments/2taskc/send_emails_using_javascript_only_no_server_code/), I don't understand why you're adverse to server code. Particularly now that you're posting in /r/php where, in general, you can expect users to have been sending emails using server side code for years, I still don't get how introducing a new product "saves time". Edit: I typed an address in your "request invitation" box and all I got was [this](http://imgur.com/zccooz4). Is this indicative of your email sending product?
Again I don't know much work/maintenance you think this really saves. But more importantly... see my edit above. That's only got to happen once before your product becomes more work/maintenance.
Sorry about that! This happens when you enter an address that was already sent. Could that be the case? If not - Did you try again afterwards? - I just checked this and it seemed to be working fine.
I've just generated a whole new address and got the same thing. Do you have problems with special characters? 11qrqh+71t4981hahju8@sharklasers.com
Possibly - it's passed on to Mailchimp, which perhaps returns an error. Will check this first thing in the morning - pretty late in this part of the globe :) I can add this address manually to our list if you like for now. 
I'd prefer server side, but this still is a good venture, and will be nice for people without PHP,ASP,NODEJS...
This webmail service uses a disposable email provider's rss feed coupled with MX dns records to receive email, and the php mail(); function to receive mail.
Any tips on how it's set up? We do the same thing, but I'm trying to standardize the Ansible side a bit more. Currently have the best-practices folder structure for provisioning, and a separate deploy.yml playbook) - suppose they should be integrated?
Can confirm that Laravel is good for beginner and intermediate entry. But if you want an over engineered, java enterprise like code base, it can more than accommodate you on that as well 
Replace the last line with $controller = $container-&gt;get(SomeController::class); $controller-&gt;foo(); And it can now work with any container in the world. You don't *need* Auryn for such a simple case of DI more than any other container.
Absolutely agree. It's a mutually beneficial arrangement. Way helps ease people into Laravel and through the initial pain. There are enough advanced resources for people to want to learn more. I find myself wishing there were similar resources on other things I'm trying to learn. Especially EmberJS.
&gt;a class \Model\BaseModel, which instantiates the doctrine ORM Why are you instantiating the ORM inside a model? It would be much simpler, and solve your problem, to instantiate the ORM and then inject it into the model.
The method 'foo' requires a param of type 'BackupRepository' - so you couldn't just call it as 'foo()'. As previously mentioned, the container at http://container.thephpleague.com/ doesn't appear to support delegation, so it would be quite the job to get that to work.
Yes, I store them in database and my state flow is similar to 1 -&gt; 2 -&gt; 11 -&gt; 6 -&gt; 4. It's okay, but I just feel it's error-prone and will be quite buggy in the future. Thanks for sharing your experience, it makes me feel it's not as serious as my worries.
The new `dd()` that gets in your way and makes you manually expand arrays and objects is a sure step in the right direction...
Laravel hasn't been an MVC framework for a while now, either. The only thing coupling you to any sort of project structure is the fact that command line generated scaffolding has to go *somewhere* by default. But you can always move it later if you want.
Why was the template tag `{{{ }}}` replaced with `{!! !!}` instead of just inverting the old syntax (i.e. making it now two braces to escape, three to leave raw)? To me, the syntax always seemed backwards. That is, in my subjective opinion, the default should be the easier to type and mess up option (two curly braces) and, not escaping would require that you pound it three times (since you "really mean it" this time). So, I'm actually happy that we're able to use the simpler `{{ }}` syntax to escape, but I find the choice in the new syntax to be somewhat confusing. I mean, if you're making a breaking change, I'd say this is the time to do it (obviously on a full version release) and just go ahead and invert it. There are plenty of situations where I still really need to use the non-escape syntax (now `{!! !!}` which is intentionally more difficult to type), like when I need line breaks (e.g. `{!! nl2br($var) !!}`) which is now a bit of a PITA to write and needs a custom implementation to roll out if I want to save time and keystrokes on projects that need it frequently. That is, unless I'm missing something, since I'm not finding an easier way to do this out of the box in the documentation (introducing line breaks without having to haggle with the new raw syntax combined with a function call). **EDIT:** Or another syntax (probably better) that both escapes via `e()` and also calls `nl2br()` like so: `{!! nl2br(e($var)) !!}}` ... hey, how about `{{{ $var }}}` now? Since it's now the same as `{{ }}` and is redundant... heh.
You can maintain line break white space with CSS. .something { white-space: pre-line; }
There we go. Packages that haven't been upgraded to support 5.0. You'll face a lot of those, so stick with 4.2 till all major packages have been upgraded.
Sounds a lot like you reinvented HRBAC, substituting in groups for roles.
Date function! http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date
Perfect! Thank you so much!
If you're okay with paying, Treehouse has been good for me. If you're already a developer you might find some of the material redundant, but they eventually move onto more complex topics. Once you complete the units on there you should have no trouble figuring stuff out on your own: http://teamtreehouse.com/library/topic:learn-php If you're not able to pay for courses like that, you could also look into something like Code Academy. They have a free track on building websites in PHP: http://www.codecademy.com/en/tracks/php
Thank you! I am looking at Treehouse right now. i haven't gotten to the price yet. I am possibly able to pay, it all depends on the price. This may sound pathetic but after losing my job I moved in with family and my mother said I could stay with her but she wanted me to take a class or classes. She is old fashion and her idea of school means leaving the house and attending a class with a teacher and other students etc so it would have to meet her approval as well. Thanks for your suggestions! i also will check out CodeAcademy. I have done web work but honestly everything I know I taught myself and there are probably easier and better ways to do some of the things I do now. I would like to learn "the right way" vs "my way". 
Question for you. You did the Treehouse thing? I saw they have a PHP Track and Android Development Track which is courses built up to learn both of those subjects. I saw under pricing they have 2 options. $25 &amp; $49 a month. Is that right or did I misunderstood? That's a lot cheaper than I thought it would be. 
I know some people are just kidding but it astonishes me how much people nit pick and criticize something that someone has spent countless hours on. You don't like it, don't use it, but don't be a dick. /u/utotwel has been instrumental in helping many PHP devs move beyond Wordpress or Cake or whatever they were stuck on. Let's try to be less dismissive. 
Validation was **clearly** the example case given here: http://www.reddit.com/r/PHP/comments/2ukd7a/my_experiences_porting_my_small_web_app_pictoswap/co9dv1z
Like I already said below, I never said that this was a good idea, but it got me started. As for saving models into the entity manager, I don't quite understand this. Wont this couple the models with doctrine? I kinda don't want this. What I want to achieve is a working MVC structure, where I can swap out doctrine for whatever I want, at any point, with as little modification as possible. Not all of my models will even be used together with a DB. Some will get/send data through a REST API.
Seriously? I doubt anyone actually goes to college with the purpose of learning PHP. I'd just get a PHP for dummies book or something like that.. either set up WAMP/MAMP on your computer, and just play around. 
It is a part of college courses. How else do people learn? i do know a little and have made quite a few websites but I would like to be better and l like I said before, I am probably doing certain things wrong or could do them an easier way.
I agree. It's pathetic that when I read this comment it was -1. It is indicative of this subreddit sometimes. That being said, criticism is not always bad, as long as it is given in a constructive way.
I didn't downvote you, but your comment did come across as needless scaremongering. http://sitecheck.sucuri.net/results/www.blonde.net/blog/2015/02/03/what-rocked-and-about-rock-php-world No malware or other issues found. It isn't listed in any of the major balcklists. Your AV is throwing a false positive and should be reported to them for whitelisting/analysis. Edit: also https://www.virustotal.com/en/url/b892a3c57604c12c6e9130899da8701951c477fa16cb8795706e52e11c061bd8/analysis/1423128836/ The only reported issue is from webutation. Which probably means someone flagged it with their toolbar/app. Edit 2: http://www.webutation.net/go/review/blonde.net It was docked for not having links from wikipedia and social networks.There are no reviews of the site or any "social buzz".
Anyone debugging without a debugger (xdebug or similar), is doing it wrong anyway. Just set a breakpoint and examine the state of the entire application at that point, it's the correct tool for the job.
&gt; As for saving models into the entity manager, I don't quite understand this. Wont this couple the models with doctrine? I kinda don't want this. Ideally no it wont couple your model code to doctrine. But it will couple some of your code (e.g. the controllers) to doctrine. The idea is that your write your model classes without doctrine. Then you map them to database (using annotations or YAML). Then when you save or load an entity, you use the entitymanager: $user = $entityManager-&gt;find('User', 123); or $entityManager-&gt;persist($user); But the `User` class itself doesn't know about doctrine, because that class doesn't know about persistence.
This is something I put together a while ago based on some problems I ran into using a few bits of the spl. Thought I'd put it out here in case it's useful to anyone.
Thanks! 
I want to try the demo but I'm getting a lot of 404's [Imgur](http://i.imgur.com/fU6YE4b.png)
Unless you are going to compare values (e.g. `if ($status &gt; SUBMITTED_STATUS)`) then it doesn't matter what the numbers are. All that matters is they are different to each other. But you could easily update your database to put the new numbers in. `UPDATE table SET status=100 WHERE status=2` and so on.
Just like with any language - buy a good book or a few, start reading and writing code. I would have a look at these: * https://leanpub.com/phpfundamentals (if you have never programmed before) * http://www.bookdepository.com/PHP-Objects-Patterns-Practice-Matt-Zandstra/9781430260318 * http://www.phptherightway.com/ Good luck.
How is the foreach behavior defined in Facebook's recommended PHP specification?
irrelephant
http://pagebin.com/ZY8g8zHD
Really big fan of the Laravel Scheduler. I wrote a similar, database-driven task scheduler for Zend Framework 1. However, I like to look of the simple, expressive syntax in the Laravel Scheduler. Is it possible to use the scheduler as a standalone component without including the whole framework? I checked on packagist and it doesn't appear to be available as a separate project. Is anyone using individual Laravel components inside another framework (eg. ZF2)?
Jeffrey Way, the guy who does these, is one of the best teachers I've ever had. He gets you from oldschool-shitty-everyonehatesyou-PHP to the bleeding edge of design and development principals in no time. He did lots of videos on tuts+ but the price was always too high for my taste. Laracasts is 9$/month to access all the video (and you can download them all, too). My first thought was "cool, I'll pay the nine bucks and download them all". Of course I never did that. ;-)
It isn't supposed to. It's something I hacked together, and it may be of use for early prototypes if you want to get up and running quickly. But I don't recommend it for production use.
The demo and source is missing the js and css folders
It also misses the point entirely. When I want to make sure that my User object contains the right information, I want speed (hence my complaint about the needless inefficiency of the new `dd()`) Using a debugger to see that information involves just as much work as manually clicking to open each little collapsed item, totally defeating the purpose of *quickness*. I never use a debugger unless I'm absolutely stumped by why code is not working properly and need to find out why. I almost always use var_dump just to see if I'm getting the correct data at all, and if not (and it's not obvious why), THEN I switch to a debugger to start stepping through the application.
Thank God. Some of this has burned me in the past. One of the few things in php I'd consider broken and not just annoying. 
Is this correct? Tldr: my entities depend on services (such as orm), but how do I manage these services within my entities? I solved this problem the other day in one of my projects using entity listeners: http://doctrine-orm.readthedocs.org/en/latest/reference/events.html#entity-listeners. Create a new listener class for your entity and use the services there. Entity classes shouldn't know about that stuff anyway.
It wouldn't be entirely fixed if they split the two. If they did that would be a huge change to fix an internal issue with not as much of a benefit in the language. PHP's `current` function _is_ a C-style access to the internals - it returns an int that is the arrays internal pointer. Most of the older PHP functions are based around the internals. The reason is not that PHPs designers are "numb nuts" but rather that stuff like that wasn't really.. Well, designed. It was organic.
I hate to be "that guy" but why are you doing array (structure) modifications in a foreach? If you need to manage the array as part of the loop, then you shouldn't be using foreach.
That fact has nothing to do with the behavior that allows the weirdness that currently exists. 
Lol wow.
Jeffrey is the man
I have mixed feelings on something like this. On the one hand, having cleaner/better interfaces to some of these libraries would be useful, but on the other hand, you'll need to keep these abstractions up-to-date by hand to reflect the changes within each and every library. What happens when you get bored of the project?
Name calling isn't really called for.. I never claimed it wasn't a problem if you'd reread my comment. I only said that it would not fix this particular issue and that the amount of change that it would bring to the language would dwarf the benefits. To do so you would at least need stricter types or type hinting for scalars when used on a scalar.. Implementation-wise not the hardest to do but you'd have to take into consideration the impacts it would have on the language. (Plus you'd have to get people to agree on strict type hinting) You'd still have this array internal pointer issue. And you'd be taking away a large (odd) part of what makes PHP unique ( "special", heh. ). If you want a different language then use a different language. This is the craziness of this one. I'm not excusing it, either. There's a reason the SPL has these types. PHPs implementation of what it believes are arrays is slow and had quite an overhead. You even have the ability to make your own implementations of (most of) the array because http://PHP.net/arrayaccess and http://PHP.net/iterator exist. I only used the term organic to mean that the language grew into the mess it is today rather than it was designed. I wasn't trying to imply it was a good thing - heck organic when used as a term for food just means " more expensive ". You could maybe say that it mutated or that people kept shoveling more into it until it became gross. Incompetence isn't the word I would use as for the most part it's been more of a lack of leadership than anything else. And really, if it is incompetence then they must be doing something right for PHP to be as popular as it is today. Someone, somewhere seems to like this incomprehensive language, ya know?
Ah, OK, thanks.
Using the mysql functions as an example, I would say that most changes to these libraries try to maintain backwards compatability so as not to break current implementations. The greater 'danger' would be that the functions wrapped become deprecated as PHP creates its own replacements - and at that point people should be using those anyway! On a sort of related note, I'm happy for people to contribute to the project and hopefully that would help maintain the codebase. There's also always the 'Issues' feature on Github - even if I had moved onto another project I wouldn't ignore those. Thanks for your comments!
&gt; I have an MVC pattern, and I've sort of hit a brick wall with this, and can't &gt; decide which way to go. Model View Controller, but your problem doesn't involve Views or Controllers. Just being pedantic :D &gt; So here is my issue, I use doctrine ORM for database access, and have a class &gt; \Model\BaseModel, which instantiates the doctrine ORM, and other models extend &gt; from this class, so I don't need to instantiate in each model. So your \Model\BaseModel looks like this? &lt;?php namespace Model; /** all the use **/ class BaseModel { function __construct() { // or something like that $this-&gt;doctrine = new Doctrine(); // etc... } } &gt; Which works, as long as there is only one model in use. As soon as two &gt; models are loaded, I am instantiating the doctrine ORM two times. So I was &gt; thinking: &gt; dependency injection, instantiate the doctrine ORM and pass the object into &gt; the model that needs it Would look like this: **\Model\BaseModel** &lt;?php /** namespace, use **/ class BaseModel { // or something like that funciton __construct(Doctrine $doctrine) { $this-&gt;doctrine = $doctrine; // etc. } } **bootstrap.php** &lt;?php /** all the require() **/ /** all the use **/ $doctrine = new Doctrine(); /** stuff **/ $fooModel = new FooModel($doctrine); $barModel = new BarModel($doctrine); &gt; registry, instantiate the doctrine ORM, save it to registry, and on loading &gt; the second registry check if it has been already instantiated, and simply load &gt; it out from the registry. Thinking about it, isn't the global variable namespace like a registry? In that sense, then the registry is most likely only necessary IFF you're going to pass it around as a variable? Does the registry provide lazy-loading? Or is that feature independent of the concept. I'm not sure. &gt; Which way is better? Why? If you are working with MVC, then the registry solution is pretty much better, especially if it includes the lazy-loading stuff. Since with MVC, the models that are needed for a particular code execution branch are loaded after routing, it would be very helpful to have a lazy-loading solution. **Registry.php** &lt;?php /** all the stuff **/ class Registry { function getDoctrine() { if (!isset($this-&gt;doctrine)) { // or something like that $this-&gt;doctrine = new Doctrine(); // note that you can use setDoctrine instead... } return $this-&gt;doctrine; } function setDoctrine(Doctrine $doctrine) { $this-&gt;doctrine = $doctrine; } /** millions of other dependencies **/ function getFooModel() { if (!isset($this-&gt;fooModel)) { $doctrine = $this-&gt;getDoctrine(); $fooModel = new FooModel($doctrine); $this-&gt;fooModel = $fooModel; } return $this-&gt;fooModel; } function setFooModel(FooModel $fooModel) { $this-&gt;fooModel = $fooModel; } /** billions of other dependencies **/ function getFooController() { if (!isset($this-&gt;fooController)) { $fooModel = $this-&gt;getFooModel(); $fooController = new FooController($fooModel); $this-&gt;fooController = $fooController; } return $this-&gt;fooController; } function setFooController(FooController $fooController) { $this-&gt;fooController = $fooController; } /** trillions of other dependencies **/ } This example Registry class is super verbose and is definitely NIH if you use it. There are examples of libraries you can use in other comments; I've only used Silex/Pimple. **bootstrap.php** &lt;?php /** all the stuff **/ $registry = new Registry(); /** more stuff, figure out $router stuff **/ // @todo: refactor and lazyize the router-&gt;controller execution if ($router-&gt;matches('/foo')) { $fooController = $registry-&gt;getFooController(); $fooController-&gt;doFoo($request, $response); } else { /** other stuff **/ } There is a way for the registry solution to be worse, and that would be sending the registry to the Model itself: &lt;?php /** ALL THE STUFF **/ class BaseModel { function __construct(Registry $registry) { // or something like that $this-&gt;doctrine = $registry-&gt;load('DoctrineOrSomethingLikeThat'); } } This is basically an unnecessary level of binding - you don't need everything in the Registry to instantiate a class extending BaseModel -- so have it figure out exactly what it needs and be happy injections. Also, you can't test your BaseModel without a Registry instance. &gt; Is there a third and better option? Try Symfony, as that provides DI, Container(/Registry, are these synonymous?), and was developed by the same team (I think) as Doctrine. *All hail the great purposeful purple porpoise.* EDITS: Formatting, expansion of examples, small example inconsistency fix
In the base model, I only save the entity manager to the class property, other than that, everything is the same. If I had a project on my hand, that I would need to make something out of it, I would use an existing framework. This is only a pet project, to get down and dirty, and find out, how those abominations work. I was already thinking this this morning. I am kinda, sorta, missing a bootstrap. All I did is get the controller/method from the router and called it directly.
Troll fail
touché jose!
I have the 25/mo plan and it's great. I feel like there's no way I'd make it through all of the content they have. I prefer it over Codecademy but Codecademy is free. They are a perfect example of "you get what you pay for". Get into [http://www.sourcetreeapp.com/](http://www.sourcetreeapp.com/) and [http://www.bitbucket.org](http://www.bitbucket.org) as well
I think i hadn't thought about opinionated-ness of the commands and i agree with you. There's always these subtle differences I come across that end up having huge impacts down the road. I appreciate your thoughts
Hey, we're in /r/PHP If the conversation didn't devolve into a shit-slinging pedantic mess everything would just feel wrong. /r/PHP Decision Flow: 1. Consider the cost of being "that guy" against the benefit of pointing out something trivial or off-topic about a post 2. Be "that guy" no matter the outcome of step 1
Symfony development doesn't focus on spelling. My bad. Where did you read about the vuln php myadmin?
bu-bu-bu but no real site uses php
http://krebsonsecurity.com/2014/10/silk-road-lawyers-poke-holes-in-fbis-story/ http://blog.erratasec.com/2014/10/reading-silk-road-configuration.html#.VNO_IS7Cegw
Can you give an example of how its not actually immutable?
TIL 82%+ of the internet isn't real `:^)`
Lolll so he did have a phpmyadmin page. Ross was definitely not a web developer expert.
Not quite just would've had a Facade of security. *Edit* Wow gold feels great! Thanks stranger!! 
Unreliable. Often wildly wrong (this code reports im in Nottingham - I'm about 200 miles from there) Easily spoofed. Addresses are often reused. 
Many support. So approve. Much wow.
They are really cool. I prefer $this-&gt;ch === false more than false === $this-&gt;ch This is even more clear for users with less experience. 
10/10 understood perfectly
Yeah, well - we are sorry about the level of the code - It is merely a proof of concept and we were under a lot of time pressure, so it could be considered a _working_ prototype. Many things should be done differently, but the focus was on the two concepts and not the code.
Haaaaa.
Indeed, and we can blame ISPs for that. City level accuracy is not needed so often and yes, at this level the results are most of the times unreliable, because most ISPs will dynamically allocate the IP space they own, according to their internal rules, which most of the times are a mystery to outsiders. Because IPV4 is entirely allocated, many ISPs will not allocate (_in advance_) for small towns one IP per contract, but just a fraction of IPs. If the traffic data says that on a peek level just 200 clients are online on town X, that town most likely will get a /24. From time to time, on holidays or what ever, the entire /24 will be used and any new client that will connect from town X will get an IP that "on paper" is allocated to a town nearby. This is how a person from Calverton shows up on the Internet as living in Nottingham. (_random example_)
The irony http://imgur.com/MjYN5E1
When I run the foreach statement after writing *$result = fetch($the_url, $the_id);* it doesn't produce any results. This is the case, whether I replace $result with $test, if I then write *echo $test;* or any logical possibility that comes to mind. If you don't know or whatever I understand. 
Yes voted with an extra hard click.
Please, please, please...
No it doesn't.
&gt; I still can't make the code strict, someone else up the chain will get to decide. Yes you can. The code is as strict as you choose. You can't force the users of your library to use strict typing, but all the innards of your library can be as strict (or weak) as you like
&gt; No other language with scalar types seems to have a problem with this, why would PHP has to? Well, most of the other languages aren't dynamically and weakly typed. Nor are their communities divided on the issue, nor do they have a legacy of weak type enforcement for function parameters. &gt; What? No you won't, because the function signature will tell you Yes, I still have to remember that and keep it in mind. The IDE may remind me, but I still have to worry about it. You'd also inevitably get stuff like `function foo((int) $x, int $y, (float) $z)`. &gt; Which is much more preferable to modifying internal function behaviour from userspace with declare. Internal function *behaviour* isn't modified, and it's non-global.
Voted YES. I really think this will be incredibly beneficial for the language, both in technical as in business terms. Loved the felxibility, loved the similarity to Perl's 'use strict', as pointed by Matthew Weier O'Phinney on Twitter. Fingers (hell, even toes!) crossed.
Read as *dick....*
In case people have missed it this RFC doesn't just allow scalar typing in userland. If you want strict type hinting it, then the declare statement turns it on for that file then it also does this: &gt; This RFC further proposes the addition of a new optional per-file directive, declare(strict_types=1), which makes all function calls and return statements within a file have “strict” type-checking for scalar type hints, including for extension and built-in PHP functions. In addition, calls to extension and built-in PHP functions with this directive produce an E_RECOVERABLE_ERROR on parameter parsing failure, bringing them into line with userland type hints. This makes the strict mode incredibly annoying to use. Unless I've completely misunderstood this means that the code: function foo(int $numberOfRightTurns) { $x = $numberOfRightTurns * 90; sin(deg2rad($x)) } Will work in a source file that is 'declared' weak, and break in a source file that is 'declared' strict. Having to check the top of the file you're in to be able to reason about some code is not good. 
You read the bit about changing the behaviour of built in functions?
How about saying that Command-DTOs should be "strictly-formed messages"? "Message" implies minimal behavior and independence from any big class-hierarchy or object graph, while "strictly formed" means it's not just a bag of mysterious key-values.
What a moron. The level of stupidity (and egotism) to keep a detailed diary about your billion dollar drug conspiracy is just mindblowing. So is the idiocy of thinking you could learn to code and run servers in the process and not be vulnerable.
You just said what was on everyone's mind lol
He would've been too busy chasing the next upgrade of the laravel framework to worry about getting any actual work done for his business.
A debugger should be the first thing you do for the below reasons. Why should it be a last resort? 1. It is faster than using var_dump. You only need to click a line in your IDE to set a break point. You don't have to a) write the code to debug (either dd() or var_dump()), and you don't have to remove it after you are finished. 2. You can see your entire application state at the breakpoint, not just what you choose to var_dump. 3. You can see how your application is behaving (logic flow) using step over/in. 4. You don't have issues with var_dump'ing at multiple levels of the application in different classes. Simply set another breakpoint where you need it. It is entirely possible that var_dump will end up in production code if you don't have analysis tools pre-commit. 5. Conditional breakpoints. Try var_dump'ing in a loop when you only want it to trigger conditionally. Wrapping var_dump in an if statement would be a horrible solution. I would understand why there is such as resistance to debugging tools if it was faster (as some other commenters have mentioned), but it just isn't. There are valid cases for using var_dump, such as logging errors. Writing more code to try to find a bug in your existing code just seems nonsensical - that's why debug tools exist in the first place.
&gt; there can be no perfect solution Weak typing with safe casting rules is the perfect solution.
All you need to make your code work in strict mode is an explicit `float` cast (which is guaranteed to have the same behavior as loose mode without the cast), right?
Just one more NarcCast episode before I start implementing. Just one more and I'm done I swear. This is the last one.
Nope. Even a weak hint will still cast the value to the correct type. In `function foo(int $bar)` the `$bar` will always be an integer (well, unless you reassign the variable of course). This is independent of the strict typing mode.
&gt; which is guaranteed to have the same behavior as loose mode without the cast), right? I don't believe so. Or at least not without other changes to PHP. Take this code which is inside a file with declare(strict=1): $array = array(); $x = (float)$array; sin(deg2rad($x)); //This works because $x is float(0) I'm not sure that there is ever a reason to cast blindly...or if there is then it's at best a poor reason. 
Reversing would immediately introduce security vulnerabilities into existing applications, because if three braces suddenly became raw when developers thought it was escaped, that would be a big problem. The only mindful solution that maintained security was to make BOTH of them escape and introduce an entirely new syntax for unescaped, raw output.
Currently at 11-6, way too close for comfort. Edit: Projecting a Fail on this one. No's the majority right now and we need a 2/3 vote. Unless a bunch of Yes Men come out of the woodwork it's just not happening. :(
getting certified would not be necessary, but zend framework 2 is at least as good as other mvc framework and a good place to start. Laravel and Symphony are newer than ZF2, and thus they have a few interesting improvements. Especially Laravel is supposed to be easy to learn. But ZF 2 is most well documented and mature while not too old. And ZF3 is on the horizon and it would be quite interesting game changer. 
I still don't quite understand why this can't work like how Hack handles it? Why must it be so complex? If I put `function (string $foo) {}` I want it to be a string, and nothing else. Simple. Otherwise I'd have left it without the type hint. Why if this is something that currently isn't in the language would that be such a difficult thing?
So just to be sure, we will have to put `declare(strict_types=1)` in every single file? No way to say "I want all my app to be strict"?
Curse that two thirds tyranny!
&gt;Nor are their communities divided on the issue, And in that divide, they chose a ridiculous implementation that caters to the *minority* position.
This assumes that people who support weak types are in the minority. It's really unclear from what I can see: sure, reddit doesn't like them much, but /r/PHP is not the PHP community.
"Seems" based on the evidence that we currently have.
I really hope this will get thru. But I see the problem that a lot of people actually don't understand how the strict mode works. As we see here and on the list, some even think function foo(int $bar) will make $bar only an int in strict mode, which is wrong btw. And I can not hear this "I want to decide if people use my api strict or not" argument. For the api implementors strict or not strict does matter exactly zero as they get the same inside their function. So get all the pro scalar type hints RFC people to vote, it just sucks to see people have voted against it that said exactly nothing in the million mails threads. I wish I could vote...
That's why [`declare`](http://php.net/manual/en/control-structures.declare.php) can take a block: declare(strict_types=1) { // strict code } // loose code But in general, yeah, it's unfortunate that PHP's legacy makes this kind of awkward. I think it's worth it to be able to have truly-strict types though.
Do you have any insight as to the benefits of moving from ~v1 to v3? I would like to approach the boss with a short list of pros for updating, though I'm not familiar enough with ZF to know.
I'd recommend that you contact this company: http://www.simpleport.net/osc/ PM me if you have anymore questions. 
Strictly formed is one of those nice in theory, not always possible in practice things. If I'm creating objects with an undefined and variable number of attributes such as OP is doing, then I have three choices: 1. Suck it up and do it 2. Change my business rules 3. Bend over backwards to make it so that there's no such thing as objects with variable properties in my system, no matter the cost. In his case, he could probably just provide a bunch of defaults to keep the structure consistent, but that's not always going to be feasible.
I am just tired of it. It's not worth fighting, not worth defending; just tired of it. Last thing I want is a sarcastic circle jerk about how developers in other languages belittle my intelligence. Perhaps the sarcasm would have been more funny if the site didn't get shut down because of a pretty absurd vulnerability. 
Aha! Thanks for clearing that up!
&gt; It is faster than using var_dump. You only need to click a line in your IDE to set a break point. You don't have to a) write the code. I disagree. Dumping gives you a tighter feedback loop when debugging an application, *especially* if you're debugging against a test suite. Writing out var_dump($abcd) does take slightly more time than clicking, but visually identifying the exact symbol you need to view in your debug window can also take time, especially when many other symbols or watches are present in the scope. var_dump shows you *exactly* what you want to see and it does so immediately. Fidgeting with the UI to add/remove watches, resizing debug window panes to find symbols or to read the full content of the variable, signaling the debugger to resume your process (especially if you set multiple breakpoints), accidentally stepping into or over subroutines that you did not intend to and other similar minor pitfalls steal little chunks of time when using a debugger by default. The debugger certainly feels *more convenient* because you don't have to think deeply about what you want to examine before hand, but it's slower pretty much by definition. &gt; You can see your entire application state at the breakpoint, not just what you choose to var_dump. Sometimes this is useful, but usually it's unnecessary. Once again, it might feel more convenient, but it doesn't really add anything substantive unless you're new to the project and don't understand anything about the application's state machine. &gt; You can see how your application is behaving (logic flow) using step over/in. Usually unnecessary, and definitely slower than just dumping what you need, but more importantly, you shouldn't rely on a debugger to tell you how your application is behaving, instead, robust and comprehensive logging should be implemented so that you can get a concrete output of the application's state, rather than manually (and more slowly) stepping through several lines of code whenever there is a problem. &gt; You don't have issues with var_dump'ing at multiple levels of the application in different classes. Simply set another breakpoint where you need it. It is entirely possible that var_dump will end up in production code if you don't have analysis tools pre-commit. I don't see this as a problem. You're right that a var_dump could end up in production if you're sloppy, but really you shouldn't be leaving var_dumps "at all levels" of the application, this is what logging is for. &gt; Conditional breakpoints. Try var_dump'ing in a loop when you only want it to trigger conditionally. Wrapping var_dump in an if statement would be a horrible solution. Conditional breakpoints have their place, but an if statement works just fine for me, you still have to write code for the condition whether it's in a debug window or directly in your code. &gt; I would understand why there is such as resistance to debugging tools if it was faster (as some other commenters have mentioned), but it just isn't. It really is. By the time your brain acknowledges that the code has stopped at the breakpoint, read the output, then hit resume on your debugger, my page has already been refreshed and on its second iteration. I also didn't have to hit stop/resume. I'd also add that relying on a debugger by default can make certain types of problems harder to debug like race conditions and other issues related to concurrent programming. &gt; There are valid cases for using var_dump, such as logging errors. Writing more code to try to find a bug in your existing code just seems nonsensical - that's why debug tools exist in the first place. There are valid cases for using a debugger, such as trying to grasp the context of a complex state in an unfamiliar code base or examining a situation that seems to contradict fundamental expectations of the environment, but in general, the debugger is just unnecessary and absolutely slows you down compared to someone who doesn't waste seconds at a time manually maintaining the state of a debugger. &gt; Writing more code to try to find a bug in your existing code just seems nonsensical So does that mean you think writing tests is nonsensical? I doubt you do. I don't think it's *nonsensical* to use a debugger, but someone could certainly argue that it seems absurd to use a second application to freeze your first application just so you can read the value of a variable when your program is perfectly capable of displaying the variable's value on its own. 
http://www.youtube.com/watch?v=WWaLxFIVX1s
Updating for the sake of updating is a bit silly. If it's working for them now then upgrading could be a huge risk. Any programmer that comes in and recommends rewriting the whole system or changing frameworks just shows his own inexperience.
Because the story is bullshit. They used illegal means to find him, then used [parallel construction](http://en.wikipedia.org/wiki/Parallel_construction) to hide that.
I meant that you don't need to say vulnerable when you talk about PHPMyAdmin. I missed the "of" too
FWIW, I didn't downvote it. Hence my sarcastic reply as well.
Makes sense, thank you. 
That's a popular theory, but unfortunately no evidence for that will see the light of day, if there is any; the underhanded prosecutors apparently made damn sure of that. :)
You could potentially adopt an approach in the future that allowed you to "strictify" a namespace though... so the setting would cascade down through a namespace starting at the class in which it was declared... But it's a moot point.. Doesn't look like passing.. Makes me sad...
&gt; showing people that the language isn't what it used to be I think that'll need to start with showing the *developers* aren't who they used to be. The amount of "how to" guides around there with terrible, terrible PHP code is obscene. [If you could find a way to make things like this cease to exist](http://www.ehow.com/how_4693316_create-own-php-website.html), the language as a whole would be better off. 
It's helvetica for me.... weird...
No real proof though. I had heard that before but again, it's just one more story out of the many that may or may not be true. I think in 20 or so years it will be an interesting movie.
Agreed. Shitty ol' PHP devs are just beginning to retire and it's great, but we still have some ways to come...
No, helvetica-nueu is actually specified, that is not a fall-back. And a mac's fallback web-font is only helvetica if sans-serif is specified, otherwise is times, just like everyone else.
I'm looking at the source for the site and I see: "proxima-nova",sans-serif helvetica is specified, but chrome tells me it's being overridden.
What the fuck was he even doing in the states. Surely there would be somewhere more "secure" to operate from.
&gt; I still can't make the code strict, someone else up the chain will get to decide. That's not your problem. Your code will receive the correct type so it doesn't matter how it got there.
Maybe a new start tag would be cleaner. You have to type it anyway. &lt;?php7 And scalar type hints are already invalid in all previous versions of PHP -- so this wouldn't break compatibility with anything.
/r/PHP is not a support subreddit. Check out the sidebar.
I noticed in your code that there are a lot of casts... you cast user input, you cast function input, over and over. I've made this argument before that casts pretty much defeat the purpose of hints. Your example, if indicative of PHP code to come shows that PHP code is going to have a lot of casting in the future. We're going to see a lot more improper zeros in data. 
WHO THE HECK DOES THAT?!? I had to change the body CSS to font-family: sans-serif !important; GEESH!
this is incredibly dumb.
I agree. The future is an upward trend, not a downward demise.
so then you've achieved similar success? 
Virtualbox can be a bit sluggish to boot up. I do not need a full virtual machine, just a small server to test my small things. Zwamp was perfect for this. I am running a small api with php and doing the bulk of my work with angular.
Better name it **real**foreach to be BC.
There is no Virtualbox per se with Vagrant (not in the traditional sense), it's all command line. The boot up time is seconds, so the downsides are next to none. Even with small apps and APIs you'd benefit from vagrant as it allows you to make sure not only that everything works on several versions of PHP, but also that you're developing on an OS as similar as possible to the environment you intend to publish to.
yes for educational purpses its worth learning, though ZF2 would be better. If however you can chose which framework to learn nowadays, ZF would not be my first choice as its getting used less and less. But still, from a "learning" point of view - it certainly has robus concepts and is a good thing to know.
people tout their languages as better than PHP when they identify the name as Ruby or Python I laugh hard. Those languages are shitty tier. Comparing shit with shit. Haskell is statically typed and is more expressive than ruby or python and a lot more faster. It is not possible to think PHP or Ruby or Python or JavaScript are fine languages. They lack variant or sum types. They are crippled programming languages that can't describe variant logic. Java &amp; C# have types that are nullable which breaks the type system. There are still a lot of shit posts on HackerNews touting how great these languages are when they are not. JavaScript, PHP, Ruby, &amp; Pyhon are all terrible. JavaScript will be the least terrible since the addition of tail calls.
&gt; Branding should not creep into method/class names I have to agree with you. Learning a new "vocabulary" instead of one that is pretty standard today is a waste. That being said, I tend to be really frustrated with PHPUnit's mocking API (very verbose and confusing), so this is a welcome change and I'll definitely give it a try.
We have just started our next large scale project and after a lot of research we decided to stick to PHP for our new back-end Web API. In the back-end we also use Python+Twisted and an Nginx+Lua combination as well where it fits. PHP is in a better state than ever and the results of the recent RFC's is going to push it even further. That being said there are people out there who are actively bullying PHP developers and trying to bad mouth PHP at every chance they get. In all honesty, I think that as PHP haters they are scared that PHP will stay a popular web development tool and even increase in popularity. It is funny, I could go on all day about the issues we've run into in other languages such as Python, Javascript, Java (Android), etc., but I don't, because they are all great tools with flaws that we can deal with. If you can't deal with a language's flaws or work around the issues you are frankly not the kind of developer I want in my team. If you only consider the bad points of PHP and none of the good points, you are a bad programmer and way too opinionated for your own good, end of story. PS: Sorry if my sentences are hard to read, English is not my first language. 
How about Lua?
Yeah. I know all the benefits. But it is running a virtual environment. I wanted to dodge that, but ended up with vagrant anyway here. 
&gt; prophesize Yeah as soon as I saw that I closed the GitHub repo. I'm not interested in dealing with nonsense method names, I want to get things done.
There's lots of things I like about PHP. But one nice one is that so much code is already written for you. There's obviously a big choice in frameworks, but for me even more importantly... API wrappers. I hate having to spend time learning the intricacies of every API I use. But seeing so many PHP wrappers are out there, I don't really need to. I guess this is really just an extension of the popularity argument though. Suits me well not having to do many things from scratch. HHVM/hack and Phalcon are pretty cool too.
There's a bunch of reasons. A big problem is that your source code could be accidentally exposed if ran on a server with an older PHP version. Another is that having eight different include statements would be rather ridiculous, four is bad enough.
But the error message isn't an error in the program, it's an error in user input. The exception is functioning merely as a vehicle for a user-readable error message string.
&gt; **Update, Feb. 5, 2015, 8:10 p.m.:** After this article appeared, Werner Koch informed us that last week he was awarded a one-time grant of $60,000 from Linux Foundation's Core Infrastructure Initiative. Werner told us he only received permission to disclose it after our article published. Meanwhile, since our story was posted, donations flooded Werner's website donation page and he reached his funding goal of $137,000. In addition, Facebook and the online payment processor Stripe each pledged to donate$50,000 a year to Koch’s project.
I find my perfectionism to be the main reason I try to avoid PHP. I perfectly understand the notion that PHP is the fine tool for its job, but the little imperfections and the fact that other languages got it so much better makes me feel left out, stuck in a dead-end job with mostly shitty projects because most talented people migrate to other tech stacks. And please, stop mentioning Facebook because "they used PHP and look where it got them". Facebook build their own language superset of a PHP ([Hack](http://hacklang.org/)) with strict typing and a VM with JIT compilation. If you think that your project may reach Facebook's scale, you'd better think about switching to more performant and scalable solutions early.
That's irrelevant. Either way it's a stupid comment.
Ha, sorry I didn't really read your comment properly.
WordPress is not something php should be proud of... 
I foresee an opportunity for the rising of a new podcast: PHP DarkHall. Episodes that only are available on apowiejfawo1231.onion and take 3 hours to load. Anonymously. 
The point is not that PHP is better than other languages but that it has caught up (and is still catching up) with other languages and the tools that make their work flow better. That means the things you can complain about PHP is slowly but surely being eroded. In the end many people will continue to hate PHP and that is fine, but at this point disregarding all the effort that is going into making PHP better and then making an effort to drive people away from PHP your daily mission (as one guy in /r/programming claimed he is doing) then you are basically an idiot (not saying you are, don't misunderstand me). 
This. This is the main reason I'm considering leaving PHP. I have no issue with the language itself, but it seems nearly every single PHP job now a days has to do with CMS work, which I find terribly uninteresting.
Have you come to any further conclusions over the last week? I've also spent a lot of time recently deciding on Phalcon vs Laravel. The biggest thing that scares me is the number of IRC users (on freenode)... * #phalconphp: usually about 20-30 users * #laravel: usually about 500-600 users So I really hope Phalcon doesn't die off. I'm going to stick with it for now though I think. But I'm really interested to know where you're at on this decision right now?
Agree 100% I was just talking about PHP yesterday with someone about how people who trash on PHP are often some of the least productive coders and that their complaints are largely baseless. After that conversation someone who was listening in on it came by and said "I f*ing hate PHP." and walked away. He happens to be one of our least productive developers. LOL.
It's really about people that don't know it but want access to the sheer number of jobs there are out there for it so they discourage its use so they won't have to learn it. They want everybody to use the language that THEY know. Over the past 40+ years I have seen that phenomena over and over again: "Package/language/program is dead, use THIS Package/language/program....(because that's what I know)"
Yes, I was referring to having to install it on each server which I understand if you are following industry standards is a non issue (as you have scripted builds of your VM's or dedicated HW). Looking back I'd like to retract that statement because I made a bigger deal over it than was really required. The reason I mention it is because I work at a company that doesn't have scripted builds and we have run into issues with VM's not matching up well enough. I will agree with you on Laravel changing sometimes a lot between releases but as far as I've seen the changes have not been particularly hard to deal with and are rarely change for the sake of change. The earlier versions had a lot more change than the newer ones IMHO and I feel that that trend will continue as Laravel enters a more mature state. My biggest worry with Phalcon stands that the community just isn't there. I haven't seen anything like what we see in the Laravel camp with the video casts, books, blog posts etc and that worries me a little. I don't think Phalcon is a bad framework just that it may not be as stable or supported as Laravel (Full disclosure: I'm stuck on CakePHP 1.3 at work and personally don't feel like the CakePHP future is very bright even if we had the resources to upgrade to Cake 2, that said at the time the decision was made Laravel wasn't around and Cake may have been the best choice). Good luck with your project and props on thinking about helping with the Phalcon docs, it's an underrated job but so fundamentally important to a framework (or any code for that matter).
Your website is NOT accessible to me. The fonts are light grey on white, very small and are NOT resizable. I have modified the Code Complete box to a font system I can actually read. I bet most people will think my mod is nicer. Vote up if you agree lol. https://www.dropbox.com/s/ma8dtmue0l6btua/Screenshot%202015-02-06%2009.15.09.png?dl=0
Ours is like that, it's a pretty well battle-tested framework but next to no documentation so I dread to think how we'd introduce a new guy to it. As I'm sure you know, once you have a mature codebase it's already too late.
WordPress is cake and so well documented that it's really not a bother work with at all. God help you if you have to deal with Magento.
But I use PHP in bash all the time?!
I took me a while to realize all the frameworks/languages I "didn't like" was because I didn't know how to use them. For now, I make good money at a great company working on different projects using PHP. I'm hoping to expand into some Ruby and JS but I don't see PHP dropping off my skillset anytime soon.
We spend far too much time talking about it. I feel like we can't go a week without an article about how the rest of the world thinks PHP sucks. The time is better spent showing people that PHP is a capable choice. That people can build good software in it. The best way to show them is by doing it, not by writing self-pity articles. Don't play the victim. The victim doesn't grow when he has an army of people behind him telling him it's ok. Quite the contrary. The victim goes on thinking it's a-ok to continue being a victim and that everything they're doing is fine instead of being critical of their work and looking for ways to improve.
CoffeeScript is indent-based on two spaces. That should be illegal.
That sounds more like a "you" and "your company" problem than a PHP problem.
good thing i don't have to deal with this petty discussions in my line of work, i mainly do websites and web apps for a living and i'm the only programmer on the agency and my clients couldn't give 2 shits about what language i used as long as it works, and they do work well, so keep the hate coming!
Tried mockery?
Thank you for your feedback. We will be really grateful if you can share your thoughts with us. What is the main reason for not trusting to enter your client's details? All data are encrypted. We are adding SSL support these days.
This is really nice, thank you. What is the JavaScript in? Angular? Backbone? Ember?
I might use a concrete Guzzle Response object. I know now you're not test just one unit of code, but I think the test will be much easier to read and later maintain. use GuzzleHttp\Message\Response; use GuzzleHttp\Stream\Stream; public function testHealthCheck() { $this-&gt;sdkClientMock -&gt;shouldReceive('healthCheck') -&gt;once() -&gt;andReturn(new Response(200, [], Stream::factory('healthy'))); $service = new Service($this-&gt;sdkClientMock); $this-&gt;assertTrue($service-&gt;healthCheck()); } You could also update your implementation to cast the body to a string, this would allow you to remove a mock from your test. return (string)$guzzleResponse-&gt;getBody() === 'healthy'; public function testHealthCheck() { $responseMock = \Mockery::mock('Guzzle\Http\Message\Response'); $responseMock-&gt;shouldReceive('getBody') -&gt;once() -&gt;andReturn('healthy'); $this-&gt;sdkClientMock -&gt;shouldReceive('healthCheck') -&gt;once() -&gt;andReturn($responseMock); $service = new Service($this-&gt;sdkClientMock); $result = $service-&gt;healthCheck(); $this-&gt;assertTrue($result); } 
You should add some description to the site, when you share the link, in Slack, Facebook or wherever, nothing is displayed. 
good call and thanks for sharing it :)
Thank you for the detailed response! 
Very nice
I've seen horrible PHP, I've seen horrible Java, I've seen horrible JS, I've seen horrible C/C++, and for each of them I've also seen the equivalent of incredible beauty, elegance, terseness. I don't judge a language anymore, they all usually fit a niche or a specific purpose or style or whatever fancy for which they are equal if not better than others. He who writes the code on the other hand.. for him, I spare no ammo. Feeling blue because you can get things done in a language other despise should only impact your life if that language offers no career paths. Though, grow a pair, and if that's the only language you know, go learn how to do your job with all other languages that allow it to be done well. Even if you'll never use them again, you'll have options, and might discover new ways to win!
Thank you for your advices, I think they have a lot of users, I'll ask in the next interview. what do you mean in this part: &gt; in the end ask how many days they budget for sugarCRM stuff per month How much of my time will be invested in sugarCRM?
Fortunately, most serious web work in PHP is done in frameworks that are spiritual successors to Rails (whether they admit it or not). MVC is the most prevalent framework design pattern. Most of them use ORMs as the Model layer, frequently implementing the Active Record pattern. Most RoR developers I've met have a week or so of ramp-up with PHP syntax, but conceptually they feel quite at home.
Hi r0ck0 Right now, I'm fully committed to Phalcon. I'm finishing this project that I'm working on. *If* my work pays off, I'm going to contribute financially to the project, regardless of my decision on Laravel. My thinking is the following: **The pros:** The zephir language I'm seriously thrilled by the possibility to create my own extensions. I have already made minor parts of my code into an extension which integrates totally seamless with my other code and I'm going to push more of my code into it as it matures. The option to deploy your app as an extension Contrary to what others have said in here about deployment I think deploying your application as an extension can potentially be a lot easier than as php code. I'm imagining an application with mostly empty controllers and an extension. Of course this only works on a server you control, but that won't be a real issue for a lot of devs, it certainly isn't for me. They may be caught up in this "database agnostic, server agnostic" thinking that in reality forces you to program for mysql and a shared host. The simplicity, yet high flexibility of the Phalcon framework itself. The most important reason I decided to start my current project with Phalcon wasn't its speed but its ease of use. As I've said in other comments, I can mostly comprehend the full execution path in my head which, thinking back to my work with Symphony this is a *major* advantage. The quality of available information I find the available advice and any information in general of *very* high quality, there's practically no noise. And I like that the framework and the people around it are very non-opinionated, except for the obsession with performance. Finally regardless of the future of Phalcon, it will serve me for my current project and I will come out much more proficient, php and framework wise. **The cons:** The primary reason to worry is the small community and the demotivation that may result from the the steep competition in HHVM and PHP proper. I already see some signs of unfortunate slowing down. There have been some movement from the community very recently to change things but the devs weren't convinced yet, hopefully there can be some more convincing initiative. There is a European conference underway - hopefully. TL;DR: I'm strongly inclined towards Phalcon, I'm going to stick with it for this particular project. When the workload of this project levels off, I may find time to look into Laravel. Upfront, I'm irrationally, strongly opposed to a framework that calls its parts *artisan* and *eloquent*. But I'm a pragmatic and will use the tool that gets the job done. 
yeah - exactly, what the "time budget" per month in man days is for sugarCRM ... i.e. they budget 10 days per month, and you're the only one that does sugar dev, then it means you have to do those 10 days 
Looks good on a retina screen though.
Hi! Thanks for opening this up. I've been using ReflectionParameter to match associative arrays to method/function calls in a couple of scenarios: - A dependency injection container that can call methods and constructors. - A router that syncs route parameters names with callbacks and methods. Parameters are already full of things. isDefaultValueAvailable, isCallable, isOptional, etc. I would like very much an API similar to ReflectionClass::getModifiers() that could list these various aspects as a bitmask. It could improve significantly how I check them. Thanks once again!
&gt; Maybe an apropos followup question would be what the thoughts are of those who have moved from Rails to a modern PHP framework such as Laravel or Symfony. I have some guys on my team who work in both. Word I hear is, Rails and Yii are conceptually *very* close together.
Yes but they have their education which is way more valuable.
I'll admit that I've often wondered why people vote no on some of the RFCs (I don't read internals), but all requiring a reason would really do is cause more internet arguments. I don't see anything constructive coming out of it.
thanks!
ZF2 is my php framework of choice.
it's on the todo list!
i'll add that to the list :)
Not really sure how relevant this will be, but there are a couple of quirks when we use ReflectionParameter for mockery. The biggest is getting a type hint as a string: https://github.com/padraic/mockery/blob/master/library/Mockery/Generator/Parameter.php#L26 
Oh if you like Magento, its a great time right now for you. I see tons of postings from people who really can't find any Magento developer. Since I prefer working on the back-end of things, APIs, database management, handling and processing of large data sets, it feels like I'm using the wrong language though. These jobs seem to be very rare in PHP now a days.
I just can't stand all the procedural code. Haven't looked at 4 yet though...
&gt;Despite thinking that PHP is a perfectly fine language.. PHP is a fine language for making contact forms.
Horror!
Chrome used to have serious problems rendering webfonts up until a few months ago when they FINALLY patched a couple-year-old problem, so that may be why.
I see, can you give more details about when you were using it, version, what was developed, etc?
I find it just as verbose for simple mocks :/
ReflectionParameter currently im using to my ORM library like Dotcrine , where i don't need use annotations for type of column etc. Currently im writing this on HHVM - i still waiting for PHP 7. &gt; What about the current API do you dislike? I dislike array type. Should be like in HHVM: array&lt;int&gt; or array&lt;int, string&gt; currently is only array .... array of what? 
Welcome There are a few things I'd highly suggest: * https://github.com/ziadoz/awesome-php#php-websites - and many of the rest of the links there for that matter * Read some and skim the rest of http://php.net/manual - knowing what you can easily do, and what you have to drop to an external library (or worse, have to write) can save you huge amounts of time later * https://packagist.org/ has become **the** place to find good code, and with https://getcomposer.org/ and the [PSR standards](http://www.php-fig.org/), it has never been easier to install and use them. Know that the popular frameworks (like Symfony) and libraries (like Monolog and Doctrine) are excellent for a reason - they are well tested and will do a lot for you. * testing - PHPUnit is #1 for unit testing, Behat for BDD. They go great together - and separately. Both have a healthy ecosystem of plugins and extensions that can help you as well. One that was just release is [Humbug](https://github.com/padraic/humbug) - Mutation testing your tests by changing the code under test and seeing if your tests notice :) Always check out the quality of code before you use it though. PHP has always been seen as easy to use - which just means that there are a lot of inexperienced developers out there, and so it can be found, a little too easily sometimes. The good code will show itself. I skim-read the RSS feed of new packages at https://packagist.org/ - and it's amazing some of the real gems that come past. More than once I've seen a library that allows me to do something incredibly useful that I would have had no way to be able to do it myself before - or at very least would have taken me so long, it would not have been worthwhile. Now, it could just end up be a matter of an hour or two to integrate something.
Good lord... people still use form posts?
me too :p thanks!
Thank you for your reply, it's very useful to me. You remember what version you used and what you did with sugar? One of the things I want to ask in the next interview, is who they want to use sugar, I am hoping that since one of the requirements for te position was SOA, they plan to build services around it, I don't know.
Use the WOT API https://www.mywot.com/wiki/API . Implement the child safety ranking metric.
My first thought was "Who is this company and why should I trust them with my codebase?"
Asana. 
Teamwork.com
Where???? The ones I found on eBay look hideous. Also, is there more programming merchandise (not necessarily php). I assume the answer is a resounding yes, but is there a website dedicated to that? 
Those are good points. Suggested alternative: &lt;?php 7; 
I've been against strict scalar type hinting but, at this point, I think now it's the best choice for just getting this done. It's easiest to reason about and it isn't a messy compromise. As for internal functions, they can stay the same for now. What to do with them can be the subject of an entirely different RFC. 
It requires PEAR?
at least get your fact straight. symfony copies spring.. not rails! :)
Oh. It's just that my home machine is a bit slow. Virtualization can bog it down. I just wanted a light php engine / web server to run some small programs. (Until I buy a ssd) I use Zwamp on my laptop, and it's been perfect for my use.
I cannot think of any worse tools to use than jQuery and Google APIs 
We have a few things going on with our playbooks. Firstly, we setup our group_vars like so: group_vars/production.yml: envvars: DB_NAME: "mydb" DB_PASS: "mydbpass" DB_USER: "mydbuser" users: name: deploy ssh-key... Then, we have the deploy role, which takes a hash of 'deployments', and looks something like this: deployments: - site: My Site deploy_to: "/srv/www/mysite" src: "git@git.com/example/example.git" strategy: "gitsync" permissions: - {dest: "/content/uploads", mode: "0760"} We made it so you can multiple deployment strategies: 1. Gitsync -- clone the Git repository to your build server, then Rsync the deployment to all servers. 2. Git -- clone the Git repository to every server. The deploy role creates a release structure similar to Capistrano, with a timestamp of the release that is symlinked to where your Nginx site is pointing to. The second is our PHP-FPM role, which configures PHP and can also take a hash of envvars for your PHP app. php_pool_ini: listen.name: www-data pm: dynamic ... php_pool_env: {{ envvars }} Thirdly, we have a role that actually "installs" the app. This will setup the database with its users and also the Nginx site for your app: yourphpapp_installs: - site: My site install envvars: {{ envvars }} install_db: yes root: "/srv/www/mysite" The great thing about this structure is that the "envvars" can be populated dynamically via Ansible's extra_vars. This means that when you provision new infra with Ansible or CloudFormation, you pass in the database / caching endpoints at run time. Then, you only run the deploy role after that, which doesn't mess with your apps configuration. It's also extremely modular, if you ever change to a different CMS / framework, you simply create another *_installs role and adjust the group_vars. When a new dev comes on board, they simply Vagrant up and the whole thing is provisioned. It's pretty neat. Hopefully this helps a little. 
That's the "hideous" one. This is what the real ones look: http://php.net/elephpant.php Notice the "beware of imitations". Sorry :)
At the end of the day, you're trying to do modern software development in 1. Not a modern development platform 2. Not a modern development platform that also happens to be Joomla 3. Joomla 4. Fucking Joomla 5. Did I mention it's Joomla? While your efforts are noble, I personally would not bother. Your time is better spent sprinting through your Joomla work so you can get on to more serious development in code that will actually benefit your career.
The best tool money can buy is a professional developer.
The advantage is that you can mock the dependency in tests. I think it's sound as long as it's temporary to help the transition.
&gt; is Drupal as much of a chore to work with as WordPress? Talking from my own experience. FUCK YES! Wordpress you can get it up and running in a few minutes, if you want extra functionality you can achieve it by dowloading plugins. It is used to make mostly small sites. Drupal is sold as an all in one solution, a mighty hammer that can do anything easily. But if something is not supported by default you are pretty much in hell. Don't try to get help, drupal devs are the rudest and most self centered persons i have ever meet. The last tiime for example i needed something simple, a costumer wanted a form to load info on a database. I wanted to create a module to do just that with an small form. Using the drupal html forms was easy, i had that ready in a few minutes, but getting the data from $_POST was basically iimpossible, so i tried google and couldn't find it, i checked IRC and no one helped me at all, they interrogated everything about the server, IDE, software versions, etc and nobody helped. Tried more google, found an small tutorial about making a module, tried to do it, then i had problems with the different user permissions the client had, then i had issues with other modules sending random errors when i tried to use mine, then everything went downhill. I tried to go to IRC and forums several times and each it turned into a heated discussion IDE vs VIM. &gt; Would you take a job that focussed solely around building a custom application in Drupal? After my last experience I made a holy vow to never work with drupal again
Ha! 
"He's an angry elf!" - Buddy
&gt; It's just that my home machine is a bit slow. I can see that as being a showstopper. I have a monster laptop and even it bogs down when running a VM, an IDE and Chrome.
Worked on an inherited Drupal project for several months. Would not recommend. 
I have a lot of experience with WordPress and have written countless plugins, bespoke themes, etc. it's just not challenging. And from your post, it sounds like Drupal is a lot worse to work with. Do you find it Is challenging because of a lack of documentation, poor code, or are you a relatively new developer?
I'm an end to end developer. So quite happy handling HTML, CSS, JS, PHP. Usually I work with WordPress, sometimes Laravel and Angular JS. I was looking to move away from WordPress, because I don't find it challenging. Once you've built a few themes and plugins, you've pretty much tackled most of its nuances. I therefore wasn't keen on the idea of Drupal, when approached by a recruiter, but had nothing on which to base my opinion. Hence asking you good people about your experiences.
This made me smile. And I can tell that you have whole heartedly embraced the madness! Cheers for your input.
&gt; Would you take a job that focussed solely around building a custom application in Drupal? No, that's sounds like a nightmare for most of the same reasons as taking a job building a custom application in WordPress. The problem is that Drupal and WordPress are not custom application frameworks: they're CMSes, and they are designed to handle specific use cases that fall within that domain: Drupal is more geared towards enterprise-esque monolithic content management while WordPress is geared towards blogs and mom-and-pop brochureware sites. If you're building custom applications, both Drupal and WordPress are both ill-suited for that purpose (though Drupal is arguably a little more suited than WordPress). They are both highly opinionated in their own particular ways and anything "custom" you attempt to do that falls outside those opinions will be a fight all the way through. All that said, Drupal, like WordPress, is morally neutral. If you still want to work on website building but want to get into something more meaty than your standard fare in a WordPress factory and learn something out of the ordinary, Drupal is fine. Drupal developers tend to get paid substantially more than a standard PHP or WordPress-specific developer with the same experience, and because Drupal is in high demand in the non-profit and government sectors, you might find yourself with better job security. But if you want to do custom application development, get the right tool for the job and use a full-fledged framework.
Example?
If your job is going to insist on forcing you to work with a tech stack that is not suited for the project you're working on, I wouldn't put the blame so much on the tech stack being "shite" as the management of the company and I'd highly recommend quitting as soon as it's economically feasible. Those $120k+ Drupal jobs are generally not looking for a code monkey who works with whatever the higher-ups tell them to even if it's a terrible idea: they're almost always Drupal-specific shops that take on projects that are well-suited to Drupal's strengths. And when you're working on a project that plays to Drupal's strengths, it's fine and will generally save a ton of time over having to reinvent the wheel.
I think they still use functions for some type of hooks and module stuff but everything else is done with objects now and most of the configuration is done trough .yml files.
Thanks for your thoughts.
I agree with most that has been said here already, but there's something else to take into consideration. Drupal really isn't that bad if you need it's huge amount of functionality. But if you do, you will need to learn to roll with it. A _lot_ of functionality is done real easy, but it will be done in the way that Drupal wants to do it. You want a nice multi-faceted view? No problem, it's done in a few clicks, but you'll also get a handful of extra divs with atrocious classnames. If you want to be happy Drupal developer, you will need to accept that. Not everybody is able to do that. Also, the procedural code of Drupal 7 is a joke, in 2015. Drupal 8 will be better, when it will be done eventually. Still, Drupal is a good tool, and it works well for large websites where you need an editorial workflow, many subsites or other stuff like that. &lt;shameless plug&gt;If, however, you need something less complex, that is written in code that will _not_ make you want to claw your eyes out, you should take a look at **[Bolt](http://bolt.cm)**. It's written in Modern PHP, which is actively being developed and pleasant to work with.&lt;/shameless plug&gt;
Are the front legs too short? Mine stands on its 2 back legs and trunk. Its front legs just dangle.
yes..
What exactly do you want to improve? Discussion culture on internals? The specific RFC? How they quote in mail replies?
I used Drupal a few years ago (Drupal 6) so I don't know how applicable this is. Drupal has a very steep learning curve. To work with Drupal you basically need to do it the Drupal way. This means that even to accomplish the simplest thing you need to be across every Drupal sub-system, from theming to the form builder and what's not. Because of this, if you're learning Drupal and you're not working with an experienced Drupal dev you can learn from, the first 5 or so projects you churn out will be pretty shit. I guess you need a little over a year to get comfortable with Drupal. If you go for Drupal you should only be doing Drupal. Drupal is not a system you just casually use on a project here or there, you must live and breath it. This means that you're really going to sell in a substantial amount of your career years to Drupal if you choose to do so. Maybe Drupal will fail in the next 5 years, then what? Personally I hated pretty much everything about Drupal. It's an arcane system, invented around the turn of the century in a time before MVC and the what's nots. It's pretty much an ingenious system of hooks and pulleys created a mad scientist. Some see the beauty, I certainly didn't. My advise; Tread carefully... 
I wanted an 'Image' object to be used as an image resource would be with the normal API. The constructor can be used for instantiating an image object from dimensions so I still required a method for instantiating an image object from a file. Rather than complicate the constructor parameters, I thought it would be simplest to use a static method. I couldn't use a non-static method because that would require it to have already been instantiated.
The entire thread is infuriating. I spent some time wondering whether certain people were only pretending to misunderstand so as to confuse others into voting against the proposal. I couldn't get past page three. It's just person after person not reading what the change does and thinking it breaks things that it doesn't break. Specific comment: The proposed rules for typing are very very very similar to C's rules. Specifically, if a method is passed a value of a different type than the type it takes, the value is cast to the type of the method. With compiler warnings in C or declare(strict_typing=1) in this proposal, this silent conversion throws an error and you must convert explicitly. The primary difference is the way the values are cast. Nevertheless, many many many internals devs don't seem to understand the proposed rules. Multiple different developers propose that these rules break code in such a way where I question whether they actually write any code in C - the language in which PHP is written. NB: I don't mean to dismiss some of the real concerns. It's just that half the negative responses seemingly come from people who are entirely clueless.
The particular issue that's being talked about has just become a giant mess. They've thought about things too much, and a solution is now being suggested that is just too complex, and not very useful.
The thing about drupal is i͍̘͓͓̰̪̕t͞'͚̘͔̖ͅͅs̜͇͖̰̝ ̨ḁ͕̥̖ ̼͕̱͖C͞M͘S͍̘̘̘͞,҉̘͓̥͓ ̼͍a̢͈͎̳̥̥͎n͜d̼̮͓̀ͅͅ ͈̮̲̘͙͎̳͡t̶̞̖͇̦̲ẖ̝̱̗ͅe͔͇̰̫͚̺̺͡ ͍̭͢t̤̬͘h͝i̷̮̯̺̞̗n͉̘͓̘͈̮̫g̮͙ ̡̭͓̘̲a̞͓̝̼͘b̨o̬̳̫̗͓͖͟ú̜̦ͅt̯͍ ̮͕͙̻̣͡C̦̦̤̣͎M̙̝̜͓͘ͅͅS̤̳͕͡e̲̯͓̜̩͉͘ͅs̼̘͕͓ ̛͇̖̬̜̟͉i͟s̹͇͕̙̱,͚̟͎̣̱̝̜ ̤̠̟͕͍ E̸̅ͪͨ̅̑҉҉̺̯̯̬͉̭m̸̥̊ͣ͋ḃ̵͖̝̟̳̉ͯͫrͫ̀͏̤̣̖̹a̵͉͙͇͆ͣ́̚͡ç̆ͨ̊ͯ̏̀̚͏̢͓͓͖̠̭͈̖̫e̵̘̭̦̬͍̝̹̯͕ͥͭ̄͌ ̷͕̳̣̫̬͍͓́ͥ́̌ͣ̑̿̊̀͘C̸̜͉͍̠͇͙̰̰̄̀̾͆ͪ̑͜M̧͑̿̔̄͆͛͐̾͝͏̳̳͙͕͕͓S̨̖̲̫̗ͩͤͪ͆ ̡̖̟͍̄͊̒͑͜͡w̼̥ͫ̈́͊͆̅̒̽̚ò̗͚̱͚̺̥̖͉̤̌͊ͦ͂͌̋̾͘͟͡r̭͑̒ͫ̏ͥǩ̴̖̞̳̠̭̭̘ͦ͌,̷̬̜̼̗͈̘̫̌̑ͪ̈́ ̴̗̬͇̫̪͛͐ͯ͂͑̒͊̎͞C̱̫̮͍̳͚̆̋̓M̰̺̭͎ͬ̍͗ͨ͢͟S̗̮̓̃ ̶͉̬̼̜̦͍̩͉̒͗͑͜w͓̤͔̫̳̝̉̈́̋̂̂ͩ̊̕͢ͅô̙̤̼̳̟̑͐͋͆͋̚͢͞͡ͅr̓̇̎́ͩ̔̀͘҉̧̻ǩ̨̜̺̻͇̘̳̔͊̾͘ ͔̮̽͆̋͒̉̽͟ͅį̨̱͎̯͕͔̱̞ͭͮs̢̬͑ͥ̿̀͞ ̥̻̟̖̠͍̱̫͓ͮ̈̂̐ț̷̪̥̤̙͇̊ͨ́͠h̟̣̣͓͖̘̟̣̙̒̑ͧ̈̽́͡e̛̘͍̬̪ͮͣͤ̍ͮ̾ ̦̦̜͈̮͚̉̊̅̑̑͗͌̔͋o̪͎͛ͧ̇ͨ͐̈́̅n̹̲̲̫̞̽̔̊͐ͥ́͟l̷̶̲̞̩͔͖͖̘ͨͣ̅y̷̢̝͚̬̿͑ͭ͒̉̽͛̚ ̸̨̦̫̮̔̽̕w̧̲̤͍̬̲͛͂̋o̶̜̖̣̲ͪ̏͆͛̆ͯͣ͢r͙̹͚̣ͥ͛͂̚͡ķ̗͍̼͆̏̌̆͘͟,̵̴̤̠̦̱̱͉͎̰ͤ͒͑͜ ̨̛̰̯̣͎̺ͫ̔͡H̰͉̲͑̄ͭ̄̕E̘̬̥̫ͥ͒̇̐͑̎́ ̧͕̹̦̳̫͋̌̑̌̑C̛̹̹ͩͩỌ͎̔ͭ͡M̼͉̉ͫ͌̉͝͠Ẹ̸̮͈ͣS̡̏҉͓̬̪͖͔̤̜̜ D̛̀͜͠R͘͏U̴̢͜͏P̸҉͢͢͝A̴̡̡̨L̡͏̢ ̶͜͡͡Í̧͝S̨̨͡ ̨҉̢L̷̶͏̢͟I҉̕͠Ģ̕H̵͞Ţ̡̀͞ ̵̶̷͘͠D̴̴̴͘Ŗ̧̨U̡̡͝͞P̀͘͏͘À̷́Ĺ̛͏͏̸ ́͘͜͠I̷͜S͜ ̸̵̡́L̴̢I̵͏F̢̧́͠É̛̕
I guess the rewrite they did recently did not help adressing these issues?
Is Asana overkill if I am doing the project without the team? It seem Asana is designed for team project.
&gt; what we can do to improve this? *Everyone can stop being stupid and agree with my decisions which are obviously the only right choice !!1!* People disagree over both big and small details. Because PHP maintains backwards compatibility so strongly, getting something wrong means that we would be stuck with it for a long time. Talking these things through is the correct way to proceed. And even when stuff gets repeated, it' an okay thing. Some people aren't convinced of something the first time, and need to hear it multiple times to understand and accept it. And yes, there are people who don't add much value to the conversation in my opinion. But I might be wrong! Unless they're being obnoxiously disruptive they shouldn't be banned from having their voice heard. Hey, at least we're better than the Linux distro maintainers, where people have started receiving death threats: https://plus.google.com/+LennartPoetteringTheOneAndOnly/posts/J2TZrTvu7vd
Very tempting. I'm still waiting for this: https://www.kickstarter.com/projects/1560940280/laravel-elephpant.
Name the projects in wide use .Net, Java, Ruby and Python can be proud off. ... sounds of crickets ...
I absolutely disagree with you. Its "shitty" past has lead it to be the most used web language for years. It is a great enabler, anyone can learn it and use it. All the web applications ordinary people can use to create their own sites and webshops are in PHP. I see people like you as people in ivory towers creating unworkable toys that hurt to play with wondering why the plebs on won't play with them. PHP as it is absolute dominates the industry. It has gotten there by being accessible, by being easy to learn and easy to use. Does bad code arise from that? Sure but if we accept lousy car drivers resulting in thousands of deaths a year to enable the freedom of a car dominated culture, then what is a few bad coding practices? There are millions of totally unimportant sites where it don't matter. And the few programmers that go on to do bigger things can always learn to improve. Your way would put a massive wall around PHP and deny it its ease of use and accessible to everyone. 
For the record, I don't think C is in any way a valid analogy for the "weak typing" as proposed here. The fundamental difference is that C's type coercing rules are type based, while PHP's would be value based. By inspecting the type of a variable, you will not be able to determine whether or not it satisfies a type hint. I think many proponents of strict types (me included) would be fine with accepting an integer for a float argument or a `__toString` object to a string argument (but not more than that). My gripe is with cases like strings passed to integer arguments, where it may or may not be accepted and you can't tell in advance. So no, I don't think the rules are similar at all. Widening an integer type of coercing to float is one thing, accepting a string subset is something entirely different. C will not take your `char *` and based on a fair dice roll interpret it as an integer or maybe not.
This one isn't one of the "real" elePHPants based on Vincent's original design. Those are the kinds you see in the [elePHPants photostream](https://www.flickr.com/groups/elephpants/). It's pretty clear when you look at them what the differences are. Unfortunately, even the ones on [get-elephpant.com](http://get-elephpant.com/) aren't the "real deal" either. If you want one based on Vincent's elephpant design, you'll either have to try to track one down at a conference/user group or follow along with some of the kickstarter ones already mentioned: * [Laravel](https://www.kickstarter.com/projects/1560940280/laravel-elephpant) * [Amsterdam PHP](https://www.kickstarter.com/projects/rdohms/the-amsterdamphp-elephpant) * [phparchitect](http://www.phparch.com/2014/01/get-an-orange-elephpant/) There's lots of colors out there now too: * red (Zend) * yellow (Sunshine PHP) * orange (Laravel and phparchitect) * green (Zend) * purple (PHPWomen) * black (Amsterdam PHP) * another custom Zend one, Z-Ray, that's a blue one with the spinny eyes * a blue one branded with Oracle on one side * and, of course, the standard blue and pink Some of them are a lot harder to find these days as they were very limited runs, but you can still find some if you look in the right place or ask around. Your best bet for now is either the Laravel or Amsterdam PHP ones as far as purchasing.
You might be doing things wrong.
This is probably gonna sound weird here in/r/PHP, but we use Redmine and we love it. 
Thats the funny thing about PHP .... You dont seem shure *LOL*
What about Third party API calls? can message queue handle them? How can I trigger message queue?
It's simple enough to use that i don't think you'd consider it overkill. You can create a project and then create a list of tasks and then just use it as a checklist. Or you can assign dates and add comments, you can make it as simple or complex as you want it to be. 
Message queue is just a data bus between your application and workers. Workers can call third party api call and do something with results. - Application publishes message to queue (some serialized object, array or json... whatever you like). In your case it will be task to call some API - Workder listens for new tasks in queue. If there is one, he takes it, do the work and wait for another task. There is a lot of possible options. You may want that your workers will confirm that they done task, and retry if fail. Or you can publish messages to all workers at once (sone system-wide events for example). And most important. Different parts of your application may be located at different servers, written in different languages and so on. 
I'm saying this as a php / python / java developer... Php owes much of it's frameworks idea to ruby. Without ruby, Laravel probably won't even exist. Nothing exists in php comes even close to how great python's django frame work is. Java powers our finance world and banks. Jvm is also the backbone for Scala. No bank / hedge fund would be stupid enough to write a trading program in php.
Ha. A few years ago I was working at a spot that was mainly developers with a few designers. We were all split off on to different projects and I was one of the "PHP guys". We had a few more hipsterish coders always trying to work in django or ruby for no reason. I ended up having to take over / rebuild CMS projects from them because what they had built with the cooler languages wasn't really cutting it. 
I would think about decomposing the class into other classes. When you have that many distinct pieces of data for the same class, it's often (but not always) a sign that the class is doing too much. Also, consider *not* using inheritance. Inventory is the canonical example used to explain why composition should be favored over inheritance. There are lots of great articles on the subject.
Don't put them all in the constructor. That'll be a nightmare to maintain and it'd be easy to mix up the order of parameters. Having methods like set('name', 'foo') and get('name') are better, but there's potential for you to get the fieldname wrong and your code won't raise any errors. The best way is to have a getter and setter for each field. Not only does it solve the previous two issues, but stuff outside of your class shouldn't be concerned about how the class names it internally.
Yeah, they do. Oh well. :(
If you put Sheogorath instead of shoggoth, Drupal's madness would almost make sense.
The question was rhetorical...there is no answer to what an "actual programming language" would be. OP's comment was both non-sensical and sophmoric to say the least.
&gt; Having methods like set('name', 'foo') and get('name') are better, but there's potential for you to get the fieldname wrong and your code won't raise any errors. Why would you do this but not throw an exception if the property isn't among valid settable ones?
You should add getters/setters of every property or use a Magic method. Constructor should take an array which you can iterate and check if there is a setter of that index and set it with value.
It's been a while since I've been on a dev team but a few years ago we were still using Basecamp. I've been using Springloops for my Git hosting / deployments, and there's a little bit of PM functionality integrated within there.
Ahah thanks. 
&gt; It does ONLY make sense if The Output of this command is interpreted. Thats the case when you are writing JavaScript Inside PHP. See, without that part, the joke doesn't make much sense because it just seems like you're needlessly outputting two escaped double-quotes. And really, if you're writing javascript with PHP (vs just outputting PHP into a JS variable or HTML data attribute), you're most likely doing it wrong ;)
&gt; And really, if you're writing javascript with PHP (vs just outputting PHP into a JS variable or HTML data attribute), you're most likely doing it wrong ;) Just annother layer of abstraction ;-) You will get used to it, makes things Easy. I thought the Headline transported it. I allways thought this meta programming Stuff was one of the main reasons to use PHP. Writing OnClick events for example? How do you do it otherwise? 
&gt; Writing OnClick events for example? How do you do it otherwise? I define JS functions or objects that encapsulate the listener assignment and pass the relevant selector(s) and data as arguments. For example, if this is my HTML: &lt;input type="text" id="vendor-autocomplete" name="vendor" value="&lt;?=$currentVendor ?&gt;" /&gt; &lt;ul id="vendor-autocomplete-list" style="display: none"&gt;&lt;/ul&gt; This would be my javascript: var vendorAcUrl = "&lt;?=$acSettings-&gt;url ?&gt;"; var vendorAcDelay = "&lt;?=$acSettings-&gt;timeDelay ?&gt;"; setupAutocomplete(vendorAcUrl, vendorAcDelay, '#vendor-autocomplete', '#vendor-autocomplete-list'); The `setupAutocomplete` method actually registers the event listeners (an onKeyUp instead of an onClick but same difference) and does everything, you just use the two selectors to point it in the right direction.
Yeah for me PHP allwas was a Q&amp;D thing. Also writing the Values directly to the Function call reduces the Code Overhead (The two variable declarations). If you would call the Thing Once its okay, but Twice or N Times other constructs are more "Flexible". With the Mukli Masked Output you can Also Parametrize the Function name you are Calling: $AutocompletionType+"Autocomplete('"+$acSettings-&gt;url+"', '"+$acSettings-&gt;timeDelay+ "', '#vendor-autocomplete', '#vendor-autocomplete-list');" but its been a while i coded PHP.
Just to clarify: you think I'm stupid because I opted not to outright remove PHP 4 constructors in PHP 7?
It wasn't really a rewrite, just a new version. They do some good things (symfony components), but in the end, the shitty core system stays the same.
I really hope it passes. Funding opensource devs is the next step in programming imho. Think about it: thanks to youtube we can already sponsor content creators by watching ads or directly with sites like Patreon. This allowed to turn a lot of amateur enthusiasts into full time video creators. If this comes to opensource that would be awesome
First, /u/nikic, let me say that my negative comments are generally not directed at you - you seem to understand the proposals you discuss and generally contribute to the language. While the typing system proposed isn't exactly C, my point is that the fundamental misunderstandings were about differences from C that did not exist. Consider a function foo defined in both languages to accept an double. In C: &gt; foo(5) // works &gt; pragma turnonwarningshere &gt; foo(5) // gives warning about implicit cast from int to double &gt; foo( (double) 5) // works in PHP under this proposal: &gt; foo(5) // works &gt; declare(strict_typing=1) &gt; foo(5) // gives error about implicit cast from int to double &gt; foo( (double) 5) // works It's true that the rules for converting int -&gt; double are different. In PHP, the rules are based on the value and in C, they are based on the type. The actual conversions are also different. But the fundamental concept "conversion happens before call" which seems to be the source of confusion for a solid quarter of the internals posters. But Lester Caine thinks this will imply that all libraries need to define functions many times. And Pavel Kouril doesn't hasn't coded in C for a while so doesn't really know the rules. And Marco Almada thinks the implications are things that would fundamentally make C unusable. Arvids thinks it's similar to a feature which unpredictably put variables into global scope. Zeev also thinks it implies things that would make C unstable. Mike Wiliams is likewise confused and thinks libraries would "have to handle both cases" aka the conversion happens after call. I understand - the feature I'm talking about isn't really a C feature. It's a feature of every popular programming language - where conversion to a signature happens before function call - including specifically the programming language in which PHP is written, C. I cannot stem my frustration with internals when so many people seem to fail to understand how programming languages work. Edit: ~~and I might forgive Lester. He was the first one to be confused, so I'm not additionally annoyed at him for ignoring the multiple clarifications Andrea had sent out.~~ I am also progressively more annoyed reading the thread as the same thing gets clarified repeatedly and more and more people ignore the larger and larger number of previous clarifications.
It really only depends on whether or not you want to line Vincent's pockets. These ones are as real as anything. They just look a bit different from Vincent's design. Since it's artificially difficult to get one of Vincent's, it's pretty likely that there's going to end up being more of the Ukrainian design than Vincent's at some point.
I'm not irritated about people's decisions. I'm irritated about the people who seem to lack necessary background knowledge or cognitive skills or simply didn't take the time to fully read the proposals and nevertheless dominate internals threads.
In any team, from any company there will be people with different characters, which will result very often in debate and dispute. The first (_big_) difference between them any open source team, is that the OS team will have all that discussions in public (_in a mailing list most likely_) and not between four walls, where nobody can "_hear_" them. The second difference is that most of the times the OS teams are spread across the glob, with people from different cultures, which may interpret the same thing in a different way. Because of this you would want to be as clear as possible when you (_don't_) like something. This is even more true if you are in a position where you can decide about something. If you don't like what Joe is doing, you need to say that to Joe as soon as possible and to be very clear about it. If you are ambiguous, Joe might understand that you like the idea, but you don't like the approach and he might start rewriting everything, which means lost time (_because you will not merge Joe's changes_) and maybe a developer in minus, if Joe does not have a thick skin. 
drupal had a very big dilema if they changed the core they would be backwards incompatible with previous releases. if they didn't changed it they would be imcompatible with other frameworks and tools that moved to composer, namespaces, etc. They found a magic middle point where they achieved both. Drupal 8 is incompatible with previous releases and with other frameworks and tools
The shoggoth were amorphous, shapeshifting entities originally created to server their masters, but whose own growing intelligence eventually led to their insurrection. But they could not be eliminated, because by then their masters were simply too reliant on them to perform menial tasks. So an accurate metaphor for Drupal Views.
Waffle onto our github issues. Not perfect, but it get's it job done. There's a certain benefit of having everything as GH issue and be able to reference it transparently from PRs/commits/code.
Did you steal it? https://twitter.com/SunShinePHP/status/564080942281916416 EDIT - never mind. I just realized this post is older than the theft. Sorry about that.
[**@SunShinePHP**](https://twitter.com/SunShinePHP/) &gt; [2015-02-07 15:19:11 UTC](https://twitter.com/SunShinePHP/status/564080942281916416) &gt; Whoever stole the blue elePHPant from the Zend table this morning, Hope you enjoy it. \#ssp15 ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Drupal 8 is also available trough composer. https://packagist.org/packages/drupal/drupal The reason the main method is still a compressed file, is because: 1. Drupal 8 isn't released yet (still beta). 2. Drupal 7 runs on systems composer can't even run on because composer needs a higher PHP version. 3. Loads of environments that you can run drupal on don't allow you to run composer (shared hosting is famous for this)
Tony the Pony. He comes.
ITT: lots of people with very little experience in Drupal
what's up with the down votes? Did I post this in the wrong subreddit or something?
&gt; the code doesn't support psr-4 This isn't even close to being true. Drupal was one of the main parties pushing for PSR-4's acceptance by the FIG. Drupal 8's core libraries use PSR-0, but Drupal [*only* supports PSR-4 for module/userland code](https://www.drupal.org/node/2156625). For example, [here's the core Action module's PSR-4 code](https://github.com/drupal/drupal/tree/8.0.x/core/modules/action/src). 
Why would it sound weird? Just because most of us focus on PHP development doesn't mean we don't use tools written in other languages.
Hmm.. I find it really easy to read.. it seems you're not alone though so I removed the Typekit font and set it back to Bootstrap's default. Also, the weird font selectors are auto-generated by Typekit, not some weird approach I took.
If 5 or less of those fields are required, I'd add those to the constructor and make setters for the others. In any case I'd write an InventoryItemMapper that transforms an array of properties into an object. Reflection makes this pretty easy, you can even set protected/private properties without invoking setters, which makes them as close to immutable as you'll get with PHP.
magic methods can be documented by a doc comment, interfaces are not required or needed for every class. constructors can also be documented, or you can have several factory constructors
To paraphrase someone else: &gt; "Drupal is almost never the right solution, but it is almost always *a* solution" I mean, I could technically build a house using nothing but a hacksaw, but why the fuck would I want to do that? &gt; but just feel that there's more interesting work as a web developer. As such, I've started looking around for new opportunities. My advice - stop working with CMSs and learn how to write PHP and do software design &amp; architecture. Then discover frameworks like Symfony and Laravel and your life will be complete.
Also, you can group properties, for example price, last price, cost price you can group as another object `PriceDetail`.
Compared to US standards, it is. Compared to standards of countries where Phalcon's core contributors come from, it's "okay". They're humble people.
As an operations guy, I have no problem scaling Drupal applications out to hundreds of thousands of visitors per hour. It's not easy, and it's not cheap, but it does work. Drupal is just like PHP itself. There are absolutely more elegant solutions, faster solutions, perhaps even just _better_ solutions. But Drupal, like PHP, gets work done. If you're inheriting the codebase, you'll survive. If you need to scale the codebase, you'll survive. That said, focus on a rewrite using an actual application framework, rather than a CMS. If PHP is your choice, I've seen good results with Symfony applications in production (although I've never developed or maintained a symfony application, so I can't speak to that). If you're good with wordpress, from an operations perspective, they're exactly the same. I actually maintain a fork of the Rackspace Cloud Files CDN plugin with a multitude of patches and improvements: https://github.com/erulabs/drupal7_cloud_files Also, just like wordpress, the key to scaling is Redis everywhere. I've had great results with https://www.drupal.org/project/redis
The vast majority of fixes will be adding the `i` to `mysql_*` functions, and reversing the order that the db connection is passed in. you'll also need to provide a replacement for `mysql_result`. All-in-all, it's a fairly easy fix. You're still better off moving to PDO etc.
I wasn't aware that this was in the works, hurray! Thank you for increasing my knowledge today.
Yeah, I like Drupal. You want a website with a CMS and some minor customization? Bam, done. I don't use it as a framework for applications though, that's madness. 
Drupal is like this: Take something that is really simple to do and break it into 50 smaller steps that don't work by themselves, then glue them back together every single time you use it. It's great for building websites, it's garbage for writing apps.
10/10 for final sentence, would grin again ^_^
Painfully slow, would not recommend anyone using it.
If you're only 14 just keep going down the path you're going. Jesus. If this stuff existed when I was 14...
Why can't a cronjob handle your third party calls? You could trigger a php script via CLI or just fire a curl request to the app itself. A que system maybe over kill for you initially, plus its on more thing to maintain.
Added rasmus and levi as they mostly vote *no* for cool features in php.. some people in the internals vote what rasmus has voted. And derick too.. not actually bad... but cries *bc* *bc* all the time....
It would be better to break this down into sub entities. product should hold the product information name, description, price etc. vendor should hold the vendor information name, location, etc. product_vendor should hold the information related to a product and a vendor, such as the last_cost_price, warranty etc. now inventoryitem only needs to know the product_id, vendor_id date recieved, cost, quantity ordered and location. these can all be used outside of the inventory model and have meaning. 
If you don't have any idea why your code does not work in strict mode (or if you just cannot read error messages at all), stay away from it. I hope several features make it to PHP 7 before the code freeze..
Awesome, thanks for the link, that's what I was looking for. I guess half the battle is knowing what things are called. Cheers!
I like StackExchange as a worthy counter example... Where people's real names are frequently used, they're tied to real-world GMail and/or Facebook accounts (not easy to sign up dozens of sockpuppets) AND your name is frequently tied to careers.stackoverflow.com. The mods do NOT put up AT ALL with downvote brigades, and every single time users have collectively ganged up on me -- usually from something I said here in /r/php which they just disagreed with -- the StackExchange mods and admins have not only quickly rectified the damage done to my posts and karma but have FREQUENTLY issued penalties, including 2 outright bans against the more egregious aggressors from this very subreddit
Should probably read the docs and we should probably be more specific in the README
Agreed. I started learning PHP when I was only 11. Now I'm 25. Maintain course. Follow your passions; they'll get you farther in life than conformity or standardization.
You are looking for the Apache mod_rewrite module. 
&gt;The question: what's the technologies that I should know? Is there a framework that's a must know? Is there something that will be promoted in the future? I like learning new things! * Just keep that attitude. You will be in the top 5% easily if this is how you continue. * Rather than focus on PHP specific solutions, learn some other languages as well, e.g. you will find that .net, rails, and symfony2 are all essentially the same architecture. * Learn the stack around PHP: web servers, caching layers, different database strategies. * Learn TDD. For PHP start with PHPSpec. This is really important. * Learn security. Here's a nice way to learn about crypto: http://cryptopals.com/ &gt;First version was writed on Laravel 4.2, but I decided that this framework isn't good base for CMS. Er, you're already in the top 5% :P
I couldn't disagree more, unless you are talking about Drupal 8. Best advice IMHO is to learn more than one language and stay curious. Source: I've been a Drupal dev for 8 years. 
&gt; Learn TDD Oh, that's my Achilles' heel. But PhpSpec looks good, I will try with it! :) &gt; You're already in the top 5% Cuz I realized that Laravel isn't good framework (static facades etc.) or cuz I know Laravel? :D Thank you for nice words :)
Continue learning as you are doing now. Be good in high school. Study computer science, seriously, it makes you an even better programmer. 
is it on github (or some other public hosting) by any chance?
Version 1.0 of the web application firewall Shadow Daemon got released recently. It intercepts requests and filters out malicious parameters. It can be used to protect PHP applications and does not require any code changes. If you are interested and want to make your web applications/server more secure I recommend to read the [introduction](https://shadowd.zecure.org/overview/introduction/) and [architecture](https://shadowd.zecure.org/documentation/architecture/). I am happy to answer any questions that come up. Also, if you are a tech blogger, journalist or something similar I would be grateful if you would consider creating a small post about this release. As a tiny open source project it is hard to get the word out there at the beginning, esp. for a niche product like this one. Every help is appreciated.
this is r/php, a news and information about php in general. You posted new empty link for what ? yourself ? help maybe ? information ? if it's for help - then you have r/phphelp if it's for some interesting article or information about php (spotify?), surely you can post it here - but you just opened empty link for yourself... also, you removed something, what was it ?
"Url rewriting" is common in PHP world, "routing" is well known outside of it.
I'll install this on my personal side project this weekend and see what's what. My little thing gets hardly any traffic, so I don't expect to see a lot of it right away, but it looks pretty useful nonetheless. I appreciate how trivial the work is to add it to a PHP project! For those of you who haven't read that far, you install it on your server, then configure the connector script in php.ini in the "auto_prepend_file" parameter, so their script always loads before every request.
So... It's a reverse proxy. What does it block by default?
&gt; Although the idea seemed rather strange at first .. it seems to be a really cool project. Heh, thanks. The result is the important thing and it does its task very well. Of course I compared it to existing (public) web application firewalls and in my small tests it detected attacks much better with less false-positives. &gt; However, what is the impact on performance for high-traffic websites? I answered that in another thread, so I'll just link that post here: https://www.reddit.com/r/webdev/comments/2v6p4o/shadow_daemon_a_web_application_firewall_for_php/coeysr5
They do this in Python with key word arguments... function_name(var, var2=false, var3='dave'): ...code def.. obj.function_name(1, var3='bob')
The "execution time" is not always the best metric when dealing with high traffic benchmarks - usually it is much more relevant to see just how many requests per second you can handle (with/without the shadowd) - you might want to use something like **ab** and various scripts, not just a Hello World script that people seem to like so much. And the way I see it, adding a record in DB for each request when someone is trying to attack your website is a very good way to kill yourself - your PHP script might handle all the traffic, but doing 1000 INSERT requests in DB for it .. that might not be that nice. You might want to consider a mechanism to prevent this kind of things, such as a memory buffer and do the actual insert in DB after X seconds - it doesn't really NEED to be real-time, it just needs to log it in the database at some point (and of course, it would be best to auto-block things).
Uhh, every Stack Overflow example that links to this RFC that isn't PHP says: [USE OVERLOADING](http://en.wikipedia.org/wiki/Function_overloading) IMHO PHP's functions with "many optional arguments" is the sloppy seconds side-effect of not supporting Overloading and i don't think "fixing" this by making developers lives easier when it comes coding more functions with more optional arguments is in the best interests of the language. Just an opinion. 
Yea, I agree. I will do much more detailed tests soon, that is also the reason why I did not add the graphs to the site yet. I just wanted to know how the system behaves on many parallel requests. Thanks for the *ab* tip. Do you have a resource/link for that? It is hard to find anything relevant via Google. I have to admit that performance was not my main concern for this version, security was. That is also the reason why I chose to intercept requests at the position I do. Worse performance than a reverse proxy, but better detection results. The next major version will improve performance much more though. The insert buffer is a great idea. Another thing that will be included in the next version are persistent connections between the connectors and shadowd. Blocking of too active clients is also on the *todo* list, though it is possible to do it in the current version. It just does not happen automatically.
Except surely these two things are actually completely different? I mean, when doing url rewriting you simply map the URL segments back to a file: posts/my-new-post = posts.php?slug=my-new-post. Routing is a whole different thing involving a front-controller that intercepts and interprets the requested path. Am I wrong on this?
I don't really see how overloading would solve this problem. I'm not saying you're wrong, nor that proper overloading wouldn't be great, but I don't see how it's relevant in this situation. If you wanted to use overloading to solve this you'd essentially be advocating multiple methods with and without the default values. That seems like a solution for a different problem.
Thanks for the feedback, I appreciate it! The indexes surely have a negative impact on inserts, but using the interface with sequential scans on every select is no fun either. I will lock into it and see if I can remove some of them to get a better total performance. There is a command in the user interface already that is intended to be used as a cron job to clean up the database ([link](https://shadowd.zecure.org/documentation/user_interface#clean)).
I disagree myself. Being able to be more clear and explicit in a method that looks like this would be excellent. $user-&gt;setShipping(1, 0, $shipping, 0, false, 0, null, 27, User::ACTIVE, 'Idaho'); A good IDE comes to the rescue most of the time for these cases, but... not always.
You always can use Configuration objects for such cases: $shippingConfiguration = new ShippingConfiguration($shipping, 'Idaho'); $shippingConfiguration-&gt;status = User::ACTIVE; // ... $user-&gt;setShipping($shippingConfiguration); You really should avoid such methods if you don't have something like python's named arguments and you really want to change only few arguments. Default values can be changed in future, that is the main problem. IDE wouldn't help you with this.
As a general principle, it is usually much better in a production environment to have slower statistics but lower system impact - for rather obvious reasons. Also, try to consider a distributed architecture: the daemon would run on each web server and you could have the user interface on a management server without public access - you don't really want to slow down your frontend servers just to have faster statistics. I know that this scenario is not supported right now, but from my point of view this is the actual setup that would fit must of production environment (yes, there are web applications which use more than 1 server with wordpress installed).
&gt; Also, try to consider a distributed architecture: the daemon would run on each web server and you could have the user interface on a management server without public access - you don't really want to slow down your frontend servers just to have faster statistics. I know that this scenario is not supported right now, but from my point of view this is the actual setup that would fit must of production environment Huh, but it is supported right now? You can run shadowd and the user interface on a separate server than the web server. If you have the resources to do that it is the recommended way to increase performance and security anyway. And you can use more than one shadowd instance per web server. If you really have a server where every vhost has 10.000 requests per second it is no problem to do that and probably a good idea.
You're suggesting a refactor that's totally out of the scope of discussion. Yes. You shouldn't be doing this in the first place. But that's hardly the point.
&gt;Then discover frameworks like Symfony and Laravel and your life will be complete Seconding this as someone who started to use symfony in projects this year. Especially if you know your way around php and the most basic design pattern principles, you won't even notice the absense of premade CMS tools but easily program them yourself and still come out better than a drupal/wordpress solution.
I started html/css/php at 25, I am 27 now. So many regrets for not starting earlier but tbh I couldn't afford to buy a PC had I even known about it then.
&gt; a solution is now being suggested that is just too complex, and not very useful Any solution to this specific issue is necessarily quite complex. Type systems are complex things. Adding them to existing languages is even more complex. I'd also dispute that what is proposed is somehow 'not very useful'. It is only as useful as either of the modes it offers, and there are loads of people who would find one or the other useful.
I have written an old article over sitepoint : http://www.sitepoint.com/web-routing-in-php-with-aura-router/ which was dealing with version 1, v2 have some improvements. Still applicable https://github.com/auraphp/Aura.Router
Seems pretty cool! I'd love to offer something like this on [puphpet.com](https://puphpet.com). However, seeing as this is your first release, I'm going to hold off for a bit before adding it, just to make sure the project is stable and continues to mature. Starred! edit: What design is that? Is it custom? Open source? I've been looking to redesign puphpet and the design on your looks spot on for what I had been envisioning!
Thanks. Looks like a cool project, I'll have a closer look at it. And it is understandable that you want to wait. Which design do you mean? The admin interface uses the default bootstrap design and themes from bootswatch. The documentation layout is also based on bootstrap. The theme and general layout is from hugo, but I modified it a lot. The icons are from front-awesome. You can find the doc [here](https://github.com/zecure/shadowd.zecure.org). It can be turned into html with hugo (which is released under a gpl-like license).
Yea this is crap. Get named arguments in there and be done with it.
I'll quote nikita.. one mans bug is another mans feature.
I know I'm super spoiled by yum and whatnot, but I'm having some dependency trouble. I don't know cmake, so I'm a tad out of my depth. [root]# cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_BUILD_TYPE=Release .. Boost found. Found Boost components: program_options;system;thread;regex CMake Error at CMakeLists.txt:24 (message): libdbi is missing -- Configuring incomplete, errors occurred! See also "/root/shadowd/build/CMakeFiles/CMakeOutput.log". See also "/root/shadowd/build/CMakeFiles/CMakeError.log". Except that: [root]# locate libdbi /usr/lib64/libdbi.so /usr/lib64/libdbi.so.0 /usr/lib64/libdbi.so.0.0.5 ... [root]# locate dbi.h /usr/include/dbi/dbi.h After googling some, I tried adding `-DLIBDBI_INCLUDE_DIR=/usr/include` to my command line, but no joy. Thoughts?
&gt; there are plenty of APIs that depend on having some previous optional parameter defined before a later one comes into play. Perhaps you ought to read the RFC again? It is poorly named, it doesn't skip params, it sets them to default. function foo($a='a', $b='b', $c='c'){} To set $c to 'sea' but 'skip' the other two you would call it with foo(default, default, 'sea'); So it's skipping over setting the value for a param, not skipping over the whole param. 
Larry's recent slides are also a nice intro: http://www.palantir.net/presentations/ssp15-d8-crash-course
Certainly was the case, yes. Clearing the cache allowed me to move on to resolve my issues with libjsoncpp, which has to be installed from source on Centos, and which installs to a path that isn't what cmake expects. Whew. Hurry up and get in yum, wouldja? The RPM doesn't install due to unsatisfied dependencies, though I have now satisfied them via rpm or manual install. Next issue, `make` itself fails: [root]# make [ 4%] Building CXX object src/CMakeFiles/shadowd.dir/server.cpp.o In file included from /root/shadowd/src/server.cpp:39: /root/shadowd/include/server.h:96: error: ‘signal_set’ in namespace ‘boost::asio’ does not name a type /root/shadowd/src/server.cpp: In constructor ‘swd::server::server()’: /root/shadowd/src/server.cpp:45: error: class ‘swd::server’ does not have any field named ‘signals_’ /root/shadowd/src/server.cpp:47: error: no matching function for call to ‘boost::asio::ssl::basic_context&lt;boost::asio::ssl::context_service&gt;::basic_context(boost::asio::ssl::context_base::method)’ /usr/include/boost/asio/ssl/basic_context.hpp:49: note: candidates are: boost::asio::ssl::basic_context&lt;Service&gt;::basic_context(boost::asio::io_service&amp;, boost::asio::ssl::context_base::method) [with Service = boost::asio::ssl::context_service] /usr/include/boost/asio/ssl/basic_context.hpp:40: note: boost::asio::ssl::basic_context&lt;boost::asio::ssl::context_service&gt;::basic_context(const boost::asio::ssl::basic_context&lt;boost::asio::ssl::context_service&gt;&amp;) /root/shadowd/src/server.cpp:53: error: ‘signals_’ was not declared in this scope make[2]: *** [src/CMakeFiles/shadowd.dir/server.cpp.o] Error 1 make[1]: *** [src/CMakeFiles/shadowd.dir/all] Error 2 make: *** [all] Error 2 This is with what's currently on github.
Keep in mind that queues work best for asynchronous functionality. E.g. you need to send out an email and it doesn't matter if it happens in the next few seconds or even minutes. However, if you have a task from which you require the result (i.e. synchronous) then a queue might nit be the best solution. 
The solution being suggested tries to cater to too many people, I'd rather not have it in the language at all over what is being suggested. It's not as useful simply because it tries to cater to too many people, and in doing so means that people who want to use stricter types... don't get to always do so... which makes the whole thing seem pointless in it's current implementation. I'll reiterate what I said in the other thread. It should just be implemented as Hack has implemented it. It is simple, effective, backwards compatible, and just makes sense. Whereas allowing something like the following makes no sense: function foo(string $bar, int $baz) { echo "Foo'd " . $bar . " " . $baz . " times."; } foo(12, "1"); // This would work? What?! I do understand you can make it strict, but you have to use the ugly declaration, and spam that all over the code. I know the following is my own opinion on how I think it should work, but, here we go anyway: Type hinting should always be strict. No casting, even if it *could* or *would* work. If you pass in something that doesn't match the signature, it would throw an exception. PHP internal functions would not be affected in any way. You would never have to declare strict. If you needed to pass in an int to a function that was asking for a string, you would convert it to a string before you call the function. This would not affect backwards compatibility in any way. That would keep things simple, and allow developers to make their code work the way they want it to.
Laravel will help you to write organized code with MVC model which means that you will be able to separate the view (htmls) from the code itself (controller) Laravel also enabled you and others to create packages for different functionalists and to be plugged to the solution very easy. working on a framework like laravel will make it easier to handle security even on terms of data (you can secure a specific model to work only on specific fields) and many other advantages.. specially on database.. like that you will not be dependent on the database engine. 
I wouldn't say it's a separate problem. It's a *related* problem. Also, if you're insinuating that I've downvoted you, I haven't. 
I appreciate you taking the time to explain that for me. Thanks! :)
Yeah - once you start forgetting the order of parameters or what is even available, it's a sign that your API is sloppy, not that the language has a shortcoming^[1]. To solve this particular problem, some sort of query builder DSL would be far more appropriate: &lt;?php $query = (new QueryBuilder()) -&gt;select('mytable.*', 'othertable.*') -&gt;where('column', '=', $somevalue) -&gt;join('othertable', 'mytable.foo', 'othertable.foreign_foo') -&gt;orderby('create_time', QueryBuilder::ORDER_ASC) -&gt;limit(10); or something to that general effect. Being able to change error reporting at runtime is just horrible design. I've seen "create" methods end up having similar problems as they grow over time with all the new features. It's far better to prune them down and call explicit setters; trying to replace a huge list of options that you need to skip with an array of options (effectively named parameters) is just masking the problem. It's far clearer to developers as it's more explicit about what you're doing, and as an added bonus it's almost always a lot easier to unit test as well. It certainly reduces the surface area for testing when you want to add a new option, since you no longer need to check each call point to your `create` god method. ^[1] We'll ignore all of the standard library array and string functions...
If you can't understand your codebase without an IDE, it's still a messy codebase. That method does **way** too much. Pro-tip: when you inevitably need to debug that method call in production with vim (because you're over SSH and that's what you have), you're screwed.
i think that 'strict' should be something to configure on the .ini files. Lets say I have two classes &lt;?php strict class Foo { public static function print(string $s) { echo $s; } } and &lt;?php class Bar extends Foo { public static function print(string $s) { parent::print($s); } } class Gar extends Foo { } Does it throw a compilation error for changing the type of a method? what does Bar::print(0.1) do? what does Gar::print(0.1) do? What if i execute both methods on a file declared strict? &lt;?php strict Bar::(0.1); Gar::(0.1);
Hey so I couldn't stop thinking about this problem, one thing led to another... and I came up with this: https://github.com/thinkspill/FindMethodExceptions It could definitely use more real-world testing, but it seemed to work on the extremely simple test classes I fed it. You pass in a class or a class+method, and it uses Reflection to find the class filename and the starting and ending lines of the method, then tokenizes the code within those lines to find any exceptions. Probably not extremely useful, but it was a fun proof of concept to toy around with.
Well that's fairly easy, i am going to sprout out first step for you, and give you a basic database layout from what you described: * **users** - general table for users that can access your administration, does not include fighters * **fighters** - your fighters table, bio, pic, name, what you have. If you have many data to store here, you can extend this with fighter_profile table (one-to-one relationship) * **events** - this will hold your event info, posters, date of event, etc. * **fights** - this will hold your individual fights that will be on an event. Here we have some relationships to mention, events has many fights, fights has many fighters, you can than work pretty well with this, if you will use any ORM, like Laravel's Eloquent. * **fight_results** - here you have your fight results for each fight, so we have some foreign IDs of fighters here, this is I think the hardest part. I assume that there will be always a match between one and one fighter, so this will be a many-to-many relationship referencing IDs of fighters, nad another column will be a winner ID. You can then easily count wins, loses. Or even better, you can have a winner_id, loser_id and store the IDs there, than querying your relationships you can count those. Or even better, have a model hook and store the counts in fighter table. What could be tricky, is the last table. I assumed that is only two fighters fighting, but if there will be three or more, this could get interesting how to design it. Anyway, I suggest you pick up a framework called Laravel. If I would be having such project and a someone would be handling the front-end part, and I would be handling the back-end and logic part, this could be done in less than 40 work hours, including consultations, and rewrites. I would say this project would be somewhere between easy and normal, based on what you would want from me, besides that.
Thank you for the suggestion. Like I said, I want to learn. Can you point me in the right direction as far as looking up resources etc? If I can look up how something is done, I am fairly certain I can do it. I don't know what Laravel is and will google it. Would you suggest Laravel?
Thank you! I had not heard of Laravel until now and will look it up. In an event, there will be several fights. There are usually between 10 and 15 fights in an event. Does that make it more difficult?
&gt; i think that 'strict' should be something to configure on the .ini files. Then you'd have no control of it in shared hosting environments, and it'd affect any libraries you use, which rather defeats the point of having strict mode (allowing people to have *choice*). &gt; Does it throw a compilation error for changing the type of a method? Of course. &gt; What if i execute both methods on a file declared strict? Read the RFC...
&gt; "use strict" is a common implementation, although would collide with importing namespaces Also removes the `use strict;` easter egg :( &gt; Since it implies a global opt-in to strict mode, new strictness checks could cause existing code to break more thoroughly (e.g. undefined variable warnings or invalid array offsets become exceptions) I'd rather we not add any other changes aside from scalars behaviour.
&gt; Does it throw a compilation error This kind of check will be preformed only at runtime (not compile time) and will produce Recoverable Error. Your IDE or some static analyser may produce warning for you. Let's see your example. Foo.php is in strict mode &lt;?php strict class Foo { public static function print(string $s) { echo $s; } } Bar.php is in weak mode &lt;?php class Bar extends Foo { public static function print(string $s) { parent::print($s); } } class Gar extends Foo { } index.php is in strict mode &lt;?php strict Bar::print(0.1); Gar::print(0.1); Strict or Weak mode only applies to caller, not callee. So you don't have to know which mode is used in another files. If you call `Bar::print(0.1)` from index.php, which is in strict mode, you'll get an error. But if you call the same from Bar.php, which is in weak mode, even if it calls print from parent class, which placed in file in strict mode, everything will be fine since your float will be casted to string and from Foo POV it will receive a string. This is very useful for vendor libs and it's internal stuff. You always get right type and you sure that typing is not lost during some PHP magic.
Sorry, I understand how my wording could have been confusing. I've edited.
The RFC proposes type hints that behave one way normally, and behave another way when told to be strict. I've seen some people call for changing the vote to be "yes, with optional strictness" and "yes, without optional strictness" in addition to "no."
I've been thinking about trying to deploy my app on a CentOS 7 docker container, too... Maybe this will get me moving about that.
&gt; Read the RFC... You have got to concede that this is not explicit at all (hence the need to read the RFC) and his point has some ground.
The cycle will continue. He will start (or be forced to) to use symfony bundles by the shit loads (because it saves time, they are tested etc) and then he will be told to use Sonata (because it saves time, it is tested) and he will realize that he is trapped and no longer a php dev but rather a symfony (or laravel) dev and any fun or creativity will be lost if he doesn't stay in the frameworks box
Good Idea! I was thinking of maybe (if possible) have it so you could click their fight record and see who they fought. The record looks like Win-Loss-Draw so it'd be like 03-11-01 and maybe you could click it to see a list of everyone they have fought in for this promotion and each fighter's name will link to their profile that has their info and fight record.
First up, you may want to hit /r/phphelp for stuff like this, but anyway... Yes, the variables will be accessible. If, for example, you have the following code: $foo = 'bar'; include 'someFile.php'; And your someFile.php has echo $foo; You will get the expected output of 'bar' from the included file. Oversimplified, but I think this is what you mean.
Might be a little late, but I agree with the others how say you should decompose your product class into smaller subclasses. 
Yep, that's what I meant.. Thanks a lot!
Do this with laravel. An amateur could do it in a week.
&gt; The point raised here is that it's not explicit "naturally", i.e. you have to read the documentation to understand how it works. So are many language features. It's not super-intuitive, no, but few things are.
There's not much to learn: strict file? Calls and returns are strict. Non-strict file? Calls and returns aren't strict. Rather simple, really.
again, not intuitive and not simple to understand when you mix it.
I have done a little coding but mostly from finding scripts and editing them to fit my needs. I don't know anything about Laravel and wouldnt know where to start. I am interested in learning if you can suggest a website?
Why, was it just the "declare" bit of the scalar typehints RFC that resulting in people voting against the RFC?
At least one person has said they'd change their vote, and it seemed to play a part in Rasmus' opposition. But mostly, it's simply better. It's less ugly and avoids `declare()`'s quirks.
Genuine question, have you worked much in a language that has named params? Your callback example seems contrived, and they're generally not as awful to work with as you seem to think. :)
I don't think that works in practice. What if you have `&lt;?php` at the top and then `&lt;?phps` later in the file?
Fuck them. And fuck whoever wishes the use of Java upon someone
I don't think that me wanting to use strict types should affect how builtin functions behave. In particular, the built in functions that expect a 'float' value will fail when passed an int which is a bit of a pain as it will mean you have to cast stuff if you're calling `sin()` from some strict code, but not if you're calling it from non-strict mode. The same goes for boolean...just being able to pass anything non-falsy into something that wants a bool value is quite nice. If we had a 'numeric' type (which might actually be possible) the int/float wouldn't be an issue...
Presumably it would be scoped similar to any of the other proposals for the strict directive.
&gt;Oh, that's my Achilles' heel. Probably because you just dev by yourself, and don't refactor much. But when your code has a long life you'll appreciate good test coverage. &gt;Cuz I realized that Laravel isn't good framework Yup, everyone loves it because it's easy, not because it's good :|
The reason in coding to do it this way I'd because I'm modifying another (active) developers code, and would be good if I could just place the one line where I need it, and not need with anything else. The code is already a mess. Curious though, what's the reason why it wouldn't be a good idea?
It becomes unmanageable very very fast. If you are working on someone elses code, and it is already a mess, I would state that the code needs to be redone. If everyone knows it needs work, it should be a matter of taking the time to redo. If you do not, you will code yourself into a corner. The longer you work on it without redesigning, the more it becomes your code, and you will eventually be blamed for it. Even by the guy who created the mess in the first place: "it worked fine until you f%$ed it up". The sooner you speak up, the faster you'll be able redo the code completely. Now just given your question I am not sure you have (at this point of time) the skills for it. That is fair enough, everyone starts at a point. :-) 
Depends. Do you want them to stay? Or do you want them to bail the second you've trained them well enough to make a decent wage?
If you are working with another developer on the same code I would highly recommend getting on a version control system like git. That will allow you to continue to use good coding practices and work together seamlessly. 
That was how my internship started out and I got paid $10.00 an hour. Of course I was only working part-time though
I'd say between $15-20/hr (For US/Canada).
I'm a contractor, and working on this 'legacy' code. Their budget is fixed, this particular project is around 5 billable hours, which is right at the top of what they could afford. If I were to offer to redo it all, it'd be closer to 100 hours. The in-house developer is a designer, with very little programming experience. So in there eyes, it works, but they just want to get X done. X will take me ~5 hours, and being able to just include it in one line helps me to be sure it won't be accidentally messed with by their designer. The only time I've ever used includes was just as you said, at the beginning of the code. Just want sure how it was executed. I'd love do redo it all from scratch, but they aren't going to be able to afford that any time soon.
Scalar argument validation is going to be a nightmare on strict functions called from loose contexts. Quoting so it's not just my opinion: &gt;To be clear: yes, we have problems in our type conversion matrix. The fact that `"21 Jump Street" == 21` is an issue (particularly because it's silent), and we should be talking about that. 
 For 5 hours, it might be one of the projects you leave. I came into a project..it was atrocious..they insisted the same as your client, and I was dumb enough to agree, and they kept on insisting that could not afford it..they eventually also could not afford me and left me hanging with a $1500 tab I am eating. Its a matter of prioritization. If they need a well running system, and they will gain something from your fix, they should be able to quantify that. 
Ok, thank you for your reply. Where are you located (state / country is fine)? Edit: were you happy with that? Did you have alternatives, and what is your experience? 
That specific case produces a notice you can trap. I'm not convinced.
KY/USA I was completely happy with that as seeing the only experience I had before was HTML and CSS coding. There were a few bigger, top tier companies looking for interns so there were a few alts. I honestly enjoyed it, I always wanted to learn PHP but I never wanted to just follow a tutorial. I was given CRUD projects with forms etc etc that made me use my resources but also my imagination in doing the projects on my chosen subjects (like guitars). A good idea (and great practice), if you didn't already have this in mind, is to get them adapted to using GIT too. That way you have easy access to checking their progress and it will be useful in the future.
No, nobody gives a shit what you think.
Ouch. But yea, they know exactly what they are getting for the 5 hours. It's kinda storage from the functionality of the rest of the system. So essentially they just want X, and as long as X is delivered they are happy. They know full well what a mess they code is, but for the time being as long as it works they are happy. (Funnily enough, what I'm doing would take an hour or two usually, but the extra 3-4 hours are dealing with the mess)
I never said it, someone replied it to me.. 
Yeah. And somehow my version of 7 is different from the authors.
I started PHP at 15... I'm 31 now! PHP started as my love... After ~16 years of daily use... It's turned into my bitch ;)
That's okay. Many of my first 5 or so years was me noodling around between neglecting homework in middle school and hanging around with the wrong crowd in high school, rather than actively learning. We all start somewhere, and we make our own path. Just because you've walked this one for less time than others doesn't mean you won't get closer towards whatever dream you pursue :D
No, you still stay as a PHP developer. Symfony packages (or anything on packagist really) provide you some more abstractions on top, that's all.
Slightly off-topic, what are some good development communities (forums, etc)? (Including other subreddits)
&gt; I’ve heard it said that good object-oriented programmers, in particular, are born and not made. But like fine music, wine, and literature, you can learn to appreciate good code. This guy is a true code artisan.
Absolutely NO, pragmas are the worst possible thing in a language.
Scalar type hints might actually result in the internals team splitting apart, from the way things are going. Perhaps the solution is that one group should fork the repo and do it one way, and the other should keep the current repo and do it the other. Many experienced developers want to break BC in order to make PHP more sane with regard to typing and building consistent applications, and many (more) developers who use PHP as a templating language and little else want to keep it basically the way it is and do their heavy lifting in Python/Ruby/etc. Although ALL of this might be a moot point once Hacklang is supported in PHPStorm. I very well may never touch PHP again once that happens.
Well, you have talked *against* strict types on many occasions and you didn't exactly vote for strict types as the current RFC doesn't even *let* you make your code strict, someone else up the call chain decides that. Are you really telling me you would vote *for* a proper, optional, strictly typed scalar hints? Even when the caller doesn't get to decide?
Just joined sub, been doing nothing but PHP (and Psql) for the last 2 years at my new job. Has anyone built an integration for Quickbooks? I've only seen 2 SDK's; Official and consolibyte's open-source. I don't like either (but could work with both)...
Take a look at the community section of PHP The Right Way: http://www.phptherightway.com/#community
There is not such a thing as a stupid question, from most "stupid" questions you can get some valuable informations either for listener, or for person who asked a question. Thus if this "stupid" question wouldn't been asked, no improvement would be made. Sometimes it's just needed to look from different angle then "why you ask stupid questions?". Based on author example, his "stupid" question that seems to be wrong just because it's not specific enough. But it raises different important questions: * Why you don't remember what was about with this issue and if it was solved? * Maybe we don't have issue tracker or you don't have access to it? * Maybe it would be nice that when issue is closed, system notifies others that the problem was fixed? * Maybe we're giving too strange names for issues like WX-1345 and nobody knows which one is about what issue? * Maybe our system is bloated with too many open issues/tasks, so it's hard to navigate them or sort by date? * Maybe our informations are not propagated enough to other people (daily meetings would be nice)? This stupid question raised a problem - why is it hard to remember about what was that issue about, why you can't find information in our system so you have to ask another person about it - which gives room for improvement. If it wouldn't been asked, nothing would be changed, old problems would be still existing in silence. If it would be asked "correctly", it wouldn't show the problem that information is not being propagated correctly.
Don't you already use configuration files? That's a kind of "logic" in an external file (often XML or YAML, etc.) But yeah, misusing comments in this way instead of just adding native annotations to the language is a terrible hack. And even then, I don't believe annotations should "do" anything on their own, they should just be readable by other userland code. Unfortunately, doesn't seem like anything of the sort is happening anytime soon :/
Depends on the area. For example I was offered $17 an hour fresh out of high school for a company in S.F. and was pretty happy. 2 months later I got a raise to $30 hour. I find myself to be much more experienced with programming in general than over 90% of programmers my age however. Hope that gives some perspective
I built a relatively simple PHP web app (my first) almost from scratch, with a sql db behind it. The code was procedural at first, which I turned into what I believe a more functional approach. Two questions: (1) should I be wanting to turn the code into an object-oriented design? I have no experience with OOP and it looks too complicated for what I'm doing mostly. However, everyone is acting like OOP is the shit and everything else is garbage. (2) should I be wanting to put the existing code into a known framework, or just leave it like it is? I often feel like implementing things that have been done 1000000 times already, but those frameworks often look too complicated as well.
...er, such notices are already being thrown, have been for years.
&gt; you may apply CS section of the best universities Can you explain? I don't understand. Maybe I badly expressed, but Laravel promotes bad things such as defined above static facades. Yes, it's easy to use, but it's bad solution. There are a few more ways to do this with pretty style too. Laravel is using well Symfony components or design patterns, but some things are done for convenience, not for code quality. And it hurts :/
Neat work, thanks for sharing!
We use Phabricator (http://phabricator.org/). It's full-featured, written in PHP, and is really nice and efficient on a daily basis. Plus there are some funny stuff at random places which is always nice. It's really robust, and they iterate quite nicely (there's no versions, you just clone the upstream). Fyi it was developped at facebook, open sourced, and now there's a dedicated company for that tool.
why don't more people work as doctors? why don't more people work as marketing managers?.... because not all people like the same things...
btw I'm not the one who said this.. 
Sure thing, here you go: https://launchpad.net/~zit-hb/+archive/ubuntu/shadowd
T̈́͒ͦͣ҉͉̩͠o̦͈̗̯͊ ̘̬̜̻͕̣̳̿̓̽̎̌i̷̬̣͙̪̺̤̿ͤ̌̆̑n͉̙̋͢ṿ̢̄͂̓̍o̬͇̗̣̖̽̊̇̔ͦͣ͛͌̚ḵ̼̺̖͔̠̪̱ͬͯ̇̒ͨ̌̑ͅe̲̻̊̃̀ ̯̖̱̻̺͙̞̊͠ͅt̶̘̘̲̹̀́͝h̛̥͍̜̻̺͈̙̱̾̾̏̅ͬͣ̿̊e̮͇͖͖͎̣̞͊̑̉̉ͨ͂ ̡̮̦̹̲̖͐ͪ̂͒̈ͪ͟h̨̪̮͉̯̔̍́̕ͅi̡͍̾ͤͥ́͛̂v̸̒ͤͥ̏͛͛͠͏͔͈̤̻ȩ̘̤̪̌̋̈́͋̈́-͎̞̲̍͊̏ͫͩ̊͞m̝̬̑ͭͥ͢i̻͙̇ͥn͉̙͍͎͓̺ͨ̈́ͫ̒̏̌ͦ́ḑ̛̺̬̺͇̳͖ͦ̂ ̧̧͎̤̰̼ͤ̃ͦ̉͐r̩͍̓ͯͯͤͧe̖̓̔̉͢p̸̩̬̩̣̍̐̔̈ͧ̆̌r̴̥͎̰̈̅ȅ͖̟̟̠͚̿̌͢š͖̝̦͌̄̒̿̍̕͡e̷͇̼ͨ͐̃̂̒ͬ̾̚͜͜n͇̥̊̃̒ͭ̅͝tͣ͗ͯ̆ͣ̊ͣ͗́̚҉͉͚̪͖̬̗i͉̫̓͆̍ͥ̀n̡͓͇̤̜͇͙̽́ͮ͗̍͐ͧͬg̷̗̬͓̝̜̳̤̭̏ͮ͢ͅ ̷̤̗̬̳͙̣̺̥̚͜͞ͅc̶̘̱͇͖̾̆̒ͤͣ͑ͨ̚hͤ͏̸͔̞̘̞̗̦̝a̞̎̅̀ͬ͋ͬ̎o̡̠̖͇̖̮͎̻ͣ̕s̼ͧͭ͆ͤ̚͟ͅ.̘̤̥ͦ̒̉̽ͧ͡͠ ̜̟̘̙́̃̂Ï̵̷̛̘̗̖̱̭̬̟̬ͮ̅̏̇́n̸͕̻̞̙͋ͩ̇̏͡͡v̸͒̎̾ͨ͏͚̻̘͕̯̪o̡̻̅̔ͩ͐̀̾̊͘ḵ̝͈̼̯ͩ͌̔͂̋̇͆i͓͐̅́̋̌ͬ̀n̥̱̓g̻̩̜̞̦̮͖̤̬̉ͦ͞ ̠͓̯͉͇̯̣̮̥̾ͦ͑ͭ̾͂͋̅́t̸͇̃̇̏͋͟h̐̒ͬ̐͊̾̕͏̡̺̟̥e̛̳̙ͨͪͥ͟ ̶̥̲̮̻͕̣͕͇͐̓f͔͙͙ͫ̽͡e̲̭̫̻͖̜ͬ̚͞ͅe̗͇̲̺̘͍̼ͣl̞̩͖̦͑͜͢i̼̹̯̘̩͙͈͛̊̋͊ͪ͑n̡̬͇̼̻̰͕̱͋͒ͩ̌g̨̖̤̻̱̔̋̃̃ͣͫ ̵̘̬̜̘̬̦̌̔͗̓̕o̴̫͓͈̙͍ͧͥ̋̀ͅf̢̬̥̳͕͎̟͎͎͐ͤͧ̕͜ ̷͓̬̩̲͈̭͎̻͆̉ͧ̍̋̉c̡͍̭̰̼͓̖ͧͪͧͪ͆̀ͩ̓̾ͅḩ̸͖ͩ́̊̋̾̅̚͢a̶̶̮͔̯̲͂͆̔͂o̴̶̲͈̣͊̒̈́ͣş̦̺̙̱͉̻̗̲̔ͣ.̸̝̘̔̄͌̀̿͑͐̏͟͞ ̢́ͦͪ̌̌̃̓͌͏͚̰̖͓͍̣͎̠̟W̝̭̻̟͎̃ͯ̉̌͛ͩ̍̈́ͪ̀̕i̮̙̤̺̙̎̋͘ͅt̢̼̲͖͕͍ͧ͛̌͢͟h̴̖̗̫͚̳̩̮͛̈́ͫo̜͙̗̻ͩ͌̂̅̀̀̀ͅu̟͖͙͎̫͚͑̈́̔̏͜͢t̸̫̻̲̟̱͓͍̟͗ͯͩ͟͞ ͍̥̻̘͉̘̝ͬ̑́͑̿o̸̞̬͙͖̮ͨ̏͋͋̅ͭͅr̢̥͙̖͉̻͙͈͂ͬ̊̓̎̃͟d̘͓̖̥̦̔̇ͨ͘͜͟eͨͩ̅̾ͣ͆҉̛͎͔̱̰r̷̦̹̐̿͋ͯ̎.̮̥̗̜͇͎̬̪̆̆̑̓̍͡ ̵̬̞̜͚̟͕̤͉̞̉̎̎͂͊͑̍͊͜T̡̳͔̋̅̓͘h̶̨̡̦͉̅̈͑ͣ̂ê̸̝͊͜ ̤̥̣́͛͆̒̈̕N͎̔ͬͣ̏ͬ̋͛e͕͍̠ͮͨ͘z̰̱̰͔͍͕̰̎̑̐͌̕p̴̟̦͗ͬ̉͛͘ͅe̷̟͍̳̅͋ͬ͊ͩ̽̾͒ͮ͟r̼̫͉̟̲̞͚̻ͣͤ̿̊̍ͪͅd̴̸̮̥ͩ͌͒ͨͫ̀i͇̯͕̎͗ͥ͌̒͛̃̽̍́͝å̺͈̮̱̉̎̽̽ͪͤ͞n̗͙͇̫ͬ͊ͬͣ͝ ̺̬͍͚̝͈̠̜̫̆̂̊́̀̌ͧ̿͌͜h̯̫͈̬͎̦̞̹̱͛ͯ͂̌̚i̟̣̺̥͇̥̿̀͗͂̏̏̑v̴̪̟̭̪̮͊͆͗̚ę̦ͦ͋̈-̖̠͉͍̻̖̹̪̓ͮ́ͩ̇̍ͬ̈̕͢m̜̗͂̎ͯ̈́ͮ̽̃̑̏͠i̗̰̭̺͈͇͙̟̅̉̑͆ͣ̉͌̅̂͟n͗̎͗҉͕̟d̢͍̯͙̱̾̌̀̈́͑̔̈ ̙͇͉͓͇̥̱̼̠́̇̈́͐ͣ͞o̫͈̹ͪͫ͆̃̌̅ͪ̚ͅf͎͇͖͌̌̿͝ ̸̸̥̘͓̪̜̑ͧ͋̾̍͐̿̌͘ć̗͎̖̙̝͔̹̃̔́͘ḫ̨̢̩̒̔̅̆̔ͤ̊ͣ̚͘ã̝̫̫̯͎̪̗̻͛ͥo̧̩̪̰͇͌͛̉̔ͮͩ͢s̡̲̩̞̜͙̞͑̽ͭ̓̓̐͆̐͒.̴̬̠͇̱͇̀̓ͦ͋̂ ̵͚͉̻̲̪͈̞̥̆ͨ͒̌̑ͥ̈́̀͜Z̗̻ͧ̇ͫͯ̎ͯ̈́ͮͦ͜͠͠â̼̲̫̟͓̪̝̑͟͜͟lͬ̑̌ͫͮ̃̈́҉̠̞̕g̝͚̮̹̭̣̲̐͟ô̧̱̠͓̖̈́̔ͩͪ̈́.̆̃̔̀̽̓ͮ̌҉̥͍̝̙̺̰͡ ̜̰͕̘̃H̴̡̗̟̬̯͈́̉ͩ͗͌͋ė̵̴͚̜̜̭̖̪̯̝̰̅͝ ̫̙͔̰̗̜͔ͧ̅ͭͪ̇́͘w̶̢̳͈̠̏̅͢h̩͓̃̈́͛̔͛̃͗o̸̝͚̹̒̉ ̡͒̓͒́͛̂͏̻͇̳W͈͚͉̰̠͆͒͛ͪ́͆ͤͅå̴͎̖̹̪͓͍ị̴̐ͨ͆̎͋̚͢͜ţ̛̪̬̟̪̼̞͖͓̿ͪ́ͭ̇̑ͩ̽͞s͚̹̭͚̫̙ͯ̕ ̒̅̔͏̱̣̩̩͇͢B̌ͭ́̒ͬ̈́͂̈̓͏̵̨̱̜̫͇͈͓ȩ̷̡͈͎̟̞̹̙̠̩̃ͫͬͭh̲̙̘ͧͣ̒͗̿ͯͯ̀͜i̢͈͎̲̇̆ͥ͌̑̅͆͒̚n̴̰͈͙ͧ͐ͪd̷͔̯̭̦̗͐ ̳̱̺̪̦̤̪͇ͣ̃ͨ̈́̕͠͝T͖̫ͭ͆̒͐͆ͥ̇̂ḩ̶̰͔͚͕̭ͮͥ̒ͥ̏̆̚͡e̙̞̝͆̓́̑̉̾͜ ̵̢̳̺̣̪̞͉̦ͩW̵̙͈̽̈́̾͂͠ą̴̢̯͍̲̞͚̻͚̓ͬ̎̏ͩ́ͥ̐l̥͇̠̝̤̦ͤͫ̊͠lͯ͂ͬ͂̄̎̿ͫ̑͏̶̰̭͇̬̙͜.̴̘̟̠̻̻͕͍̈́ͨ̈́̏ ̡̲̇̎̈́͌ͯͤ̇̒͊Ż̬̓͑ͧ̀̕Ȧ̸̧̩̓͐̍̆̋ͨ̊̈L̵̢̜̞ͣG̢̙͈̰͎̼̘̣̝͋̆̀ͤ̂ͧͧO̡͔̝̼͆̋͒̾̀̋̽̂͝!̵̵̡͈̱̮̃̃ͬ ̈̽̽͏̧̺̭̯͓͉͉͉T̶̰̪̱̻̹̞̩͉͙̑̑̚͘h̡̦̦͉͌͝͞ḛ̛̝̩̣̠͋̽ ͪ̍͒͏̹͢ȩ̧̦̼͉̺͉̾̅̄̌ͦn̙͙̓͗̓̒̌ͨ̇̿͊t̡̖̄́ͬ͠i̞̣̥͈͍͙̙ͦ̀̊͒̒̏̃́͠r̨̭̼̰̞̣̍̌̂̑̿̋̎ͣ͘͞ͅė̺̳̣̼͑̌̑͛̒̚ ͌͊̌̓̆̇̍͡҉̜̦ͅr̪ͥ̿̓̊͞ơ̟̪͙̏ͧ̆͐̚͢ỏ̤̯͇ͅm̸̬͓̖̗̅̎̆̑ͤͨ̔ͦ͂ ̆́ͤ͌͐͏̛̥͕͖i͕̺̳͔͙̜̒̆̽̀͜s̨̛̘͖̞̺͛̾͡ ̛̛͖͉ͨ̋̔͝ͅf͗ͮ̇͏̹̹̹͈ĩ̼͉̼̻̙̯̻͖̇͗l̷ͨ̄͞҉͚̱̖̩͇̥͎̦l͖̺̖͈̲̺̗̹̊̈̉̓̍͛͘e̢̤̘͗ͤͩ͑̍̇͢d͖͙̙̝ͩͨͩ͊̓̅̂͡͡ ̏̔̏̽҉̜̫̼͚̠̟w̡̢̻͎̱̯͎̋̀̊̆͜ͅį̶̞̙̳̟̫̮̆̽́t͗͌̌ͧ̔͊̓̚҉̥͓̝͎̥͎̫̖͢h̪̜͙̝̺͈̉́ ͍̼̱̩̝̻̂͗̋̀Z̤̟̤̮̰͂̐̑͐ͮ̀̚͢͡ǎ̗̭̞̲͔̺͌́̅l̞͙̲̫̝̼ͪ͐͛ͫ̐ͪͬ̌͟g̡̟̭̺̟͗̾̾͛̇͂̉͝o̷͎̣̜̦̞̻̮͉ͭ͛ͣ̂ͮ̂ͨ̓͢͡.̸͓̟̠̠͈͖ͦ͌ͤ̚ͅ ZALGO ̸͎̥̠̉̔̌̿
Article is quite old (2003), and don't bring much more information then a short version in wikipedia. I would rather propose reading a little more depth about technical debt article, that (at least for me) is more informative &amp; gives better visualization of the nature of this problem: https://msdn.microsoft.com/en-us/magazine/ee819135.aspx
I've got some more helpful hints: * Do some work * Use a computer * Make website * Don't stab the clients 
PHP **is** technical debt.
Wow, it looks phenomenally better! It's a great article, too, now that I can read it.
Let's just put aside the major security issue with passing user input to the command line for a second to help debug the issue. Double check the $cmd string actually works from the command line by just dumping it out instead of running it. `var_dump($cmd);` Then try running that from the command line with the same user (apache?) as the PHP script has. Now back to the major security issue. You're allowing users to directly run commands on your server. What's preventing someone from passing ` &amp;&amp; sudo rm -rf /` in the $_POST['data']? I would recommend ONLY allowing valid strings in each of those variables if you absolutely must use it that way. You can do some major filtering to force only numbers or alpha characters for example.
I disagree ... if named parameters aren't voted into PHP 7 (or any other of the following iterations) this RFC would be exactly the shortsighted "let's just get it working any kind of way, no matter if it's fugly" type of decision that people chide PHP and PHP-Developers for. I'd rather have it stay as it is instead of creating a kludge bandaid solution that makes me cringe anytime it's used.
Well, because the RFC tries to strike a pragmatic compromise and allow both weak typing and strict typing, with you being able to choose.
i am aware of the security issues. and honestly i dont care :) but thank you for pointing them out. if you know a better function that does the same thing ill be glad to hear about it this will run for 2 hours top (when i make it to work) and will be destroyed right after. var_dump gives the good command. there shouldnt be any issues with running the program its set to 777 (yes i konw thats stupid, i just want it to work) edit: i dont know what happened but now it works... thank you never the less
I seriously hope this will pass. That combined with the return type hinting will make PHP so much better in terms of **readability**.
&gt;language I do not approve of is technical debt
Ehh I still think there are stupid questions. In an unstructured format of communication, the writer should shoot for a balance between anticipating what information someone needs to solve your question and clarity. Sure maybe this is a systemic problem caused by their processes, or maybe he made a mistake and didn't consider his audience.
But if he wouldn't asked "stupid" question, you would assume that everything is correct in their processes, wouldn't you? I mean this guy is asking about exactly issue #X. If he would be specific each time he asks, like once a weak - would this be a strange thing? Would you had a lighting red bulb above your head screaming "something is not ok, because he asks clear and understandable question"? Rather not. Now imagine, that he asks once a weak each person in 20 people team. It will take time, till the problem would became visible - but which problem? That he is "worse" then others (cause others are not asking so often everybody), or that there is a flaw in information flaw proces? That's why stupid questions are not so stupid - if somebody is asking something, he doesn't know it. If he cannot articulate it correctly - it also can be a cause of something. Those informations are usefull. In my team we have identified and solved few problems like that, some of them increased our productiveness quite a lot.
&gt; Don't stab the clients Are you sure that is how it works? Like, what if I shot the clients instead? Would that work better? &lt;3