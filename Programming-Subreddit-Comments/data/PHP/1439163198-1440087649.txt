I'm really interested in seeing /u/kinablel's actual solution. I wrote a simple library myself that converts a DOMDocument to and from an array. If anyone is interested you can find it [here](https://github.com/chadicus/dom-php).
I think the author should elaborate on the objectives at the beginning of the post. And the expected results/benefits. It would ease the reading.
Not only does it not make sense most of the time, almost all of the time it is very irresponsible if you're working on a project that is going to require any sort of security. Even in the best case scenario where you've got a few developers interested in your project, or maybe you've got some people on your team that are going to help maintain it, without the visibility and cumulative experience of a community constantly stressing your framework, there is an exceedingly high chance for vulnerabilities to exist. Depending on your continued involvement, the time to implement security fixes could exacerbate that problem. Thousands, if not, millions of people continue to unknowingly put their privacy at risk because of the decisions software and service companies make about what tools to use, where, when, how etc... It's important to be aware of the risks and liabilities when you want to re-invent the wheel as opposed to using a tested and trusted tool to do the job. 
&gt; There was no misunderstanding Of course there was, from your side, or you wouldn't have made that joke that makes no sense. When people say "guys" it's gender neutral, if you knew that you wouldn't have made that "joke". You're not going to convince me you didn't anyway.
(/me nods) I get that; there's a lot to be said for "let the framework handle it." Alternatively, there's a lot to be said for "separate your Domain from your HTTP presentation framework."
It's not bad that you said it, it's just bad that you are carrying on with this thread of conversation. We get it. Okay. We get it.
Is PhpStorm and Windows 10 operating together satisfactorily? (should I update...)
I personally still love CodeIgniter, I only wish it had an easy to use ORM. Out of the box it has the beautiful `/controller/method/argument` routing system which is so neat and tidy.
&gt; separate your Domain from your HTTP presentation framework Not arguing against that, just more on the side of using exceptions as feedback vs. returning objects.
Me too, you really don't know how much a framework can not only help you building applications but make you a better developer in general until you use one for a while. For me it introduced me to topics and design patterns I never would have discovered unless I was reading up on the docs and the community around the framework.
I wouldn't say it's "hate". I would just say that for a majority of modern applications an object oriented approach makes more sense than doing everything procedurally.
How long have you been using symfony?
*shudders*
I couldn't have said it better. I loved CI. My livelihood depended on it for 4 years. But it stagnated, better things came along and most of us moved on. They need to let it die except for security updates.
Even if you're not using Laravel, Homestead is a great box. It's a solid PHP box (the same as deployed by Laravel Forge) which touts support for the other frameworks like Symfony, but really it will work for most PHP applications anyway.
I have had two jobs that worked in CakePHP and even though I am fairly proficient in it, I still dislike it. We have an ecommerce website written in Cake that takes in 600k to 1 million dollars a day and Cake performs poorly without varnish. Our api calls that cannot be cached crushes the servers. I would recommend Cake only for a business landing page or corporate sites with little or no web services. Even then it might be less technical debt and support hours to go with a cms.
Don't forget linking to a blog post from 3.5 years ago as proof
https://www.sektioneins.de/blog/15-08-03-php_challenge_2015_solution.html -- welp, seems like I was too stupid to put the parameters into the correct order; didn't see the forest for the trees.
The file extension doesn't matters, the goal is to avoid to store a password in plain text in the system. This force humans to do an action if they want to know it, then intent could be proved.
Just like *a library* doesn't need "must haves" in terms of specific features, a framework shouldn't need them either. Your question presupposes a framework is something big, monolithic and all-encompassing, that you base your application on, and that you shouldn't need anything outside this framework for typical apps. But a framework as a scope is not different than a library, it's reusable code designed for a given purpose, and that purpose doesn't have to be everything-and-the-kitchen-sink. It can have different scopes (app, part of an app, a cross-cutting concern across apps, etc.) and specialization (CMS sites, blogs, e-commerce etc.). From the concerns you mention you need to consider which need to be a part of the same body of code. Let's pick some of what you listed. Could you explain why should these be integrated at all: - a dependency injection container - ORM - a templating engine - a mailing engine What are their touching points? These features have basically nothing to do with each other, and you don't stand to benefit by having them as a part of one framework.
This is a deliberate design decision; we don't want to encourage you to mock monolithic third-party libraries directly, as this will encourage you to depend on them directly.
But the config, oh god, the config... And the fact that the configuration is very badly documented, doesn't help either... I've been a ZF guy for many years, but when I discovered how much more ease of use symfony offers for nearly identical features, I've never looked back.
http://i.imgur.com/8WvgHqc.jpg
Excellent news, glad I could help!
Not quite. In general American usage, "guys" has acquired some gender-neutral tones - not entirely though - and the singular doesn't seem to have budged from its exclusively male meaning. Worth reading, for both points: * https://english.stackexchange.com/questions/193702/a-gender-neutral-informal-alternative-to-singular-guy * https://english.stackexchange.com/questions/11816/is-guy-gender-neutral I suspect your dictionary writer may come from the United States - here in the UK, it feels more complicated. For example, I spoke to a female bar worker the other day, referring to her and her mixed group of colleagues, and said "You guys are lucky to taste cocktails all day" - which sounds fine, and she didn't blink. But if I said to her "there's a bunch of guys over there drinking cocktails", it would absolutely be just men we'd be talking about. I always associate the gender shift with Phoebe from _Friends_, who would say "you guys" to Rachael and Monica. That can sort-of happen here, in all female groups, but it might sound strange in some regions. Tricky, huh? `:-)` 
&gt; Tricky, huh? :-) Exactly, and it doesn't have anything to do with CodeIgniter. We shouldn't even be discussing this.
&gt; An open source framework reviewed by thousands, used by thousands, carefully unit tested etc? Individual components are also unit tested and reviewed by thousands. &gt; I do not understand "hell" part of it as well. Isnt that a point of design by contract, to make your classess easly replaceable? You'll see hell because there's no framework in the world that provides a universal set of contracts for everything, that everyone follows. There are also no perfect &amp; universal contracts even for handling similar kind of functionality like "mailing" (again, check the MailChimp APIs) - it depends on what you're doing, and how the service does it. Symfony is relatively popular right now, but even it falls way, way, *way* short of providing a contract for everything, and having every API provider follow it. Laravel has a big directory full of contract interfaces, but you can't just go to any service out there and ask for their Laravel implementation. They don't have it - you need to write it yourself, or you need to limit yourself to what's available (which severely increases your risk of hitting a wall in your project). In short, a framework with everything is a pie in the sky. So, as I said, components split contracts in two: APIs and SPIs. Think about it like a contract in French and a contract in English. You provide the translation so both parties can agree with each other. And if you need to bridge components anyway, there's no need to have a central repository of contracts anymore, they can be decentralized and component-specific. This concern of "the framework as a contract hub" becomes unnecessary. More details about your Auth example: Check the drivers for Doctrine. MySQL, SQLite, PgSQL, IBM DB2, Oracle, SQL Server. Seems like a lot, but where's Cassandra? Where's Redis? Any of the NoSQL engines at all. What about cloud DB APIs? What about connecting to a custom persistence layer written in Erlang, or C#, or C++. If your Auth layer *requires* an ORM, then you can only use one of the above SQL drivers and they all work more or less the same under Doctrine, so there's little reason to change in the first place. If you hit a limit in MySQL, chances are switching Doctrine to PgSQL won't help you much, because Doctrine uses the same lowest common denominator in all its engines. You'll need a different non-ORM persistence logic altogether, but if your Auth layer can't handle this due to deep ORM integration... yes, you'll see hell, because you can't untangle the framework integration logic from that Auth layer.
Yeah i'm currently using Homestead for a Symfony build and it works great! Only issue with homestead is having more than one instance isn't easy. Also homestead uses Nginx which may or may not work for your project.
I'm afraid that the situation has you painted in a corner. If we could stabilize and maintain codebases without decoupling and testing, we wouldn't decouple and test.
&gt; \* http_build_query in php 5 will screw up array serialisation by encoding the square brackets &gt; \* and make it incompatible for passing to an URL's GET segment or sending through post data manually Aren't square brackets supposed to be encoded, based on HTTP standards? Not to mention PHP can interpret them just fine on the receiving end.
I didn't say I didn't want to decouple and test. I know decoupling is the first step. I just need to do it as effectively as possible. I was just hoping there are some tools or techniques that would help me with that. But maybe there's no other way than the hard way.
[Relevant](http://www.sitepoint.com/wordpress-framework/) :/
Have you? I found it to be more than annoying on OSX, as u have to go through a VM proxy, as OSX does not support Linux containers, so you end up battling with network and file system related issues.
Not yet, but it looks better than having several boxes to vagrant up. 
Do I understand it correctly that not only does it reinvent the whole stack, from webserver, to message queue and in-memory cache, but it's also its own framework with [a dependency injection container](https://github.com/appserver-io/appserver/blob/master/src/AppserverIo/Appserver/DependencyInjectionContainer/ObjectManager.php), router and all? The deeper I dig the more surprised I am by the ambition of it all. I even found an implementation of [aspect-oriented programming](https://github.com/appserver-io/appserver/tree/master/src/AppserverIo/Appserver/AspectContainer) as well as [a provisioning framework](https://github.com/appserver-io/appserver/blob/master/src/AppserverIo/Appserver/Provisioning/StandardProvisioner.php), directly in the webserver code. This ambition is however, at least in my eyes, not admirable. It's a colossus of code and I wouldn't use it.
Oh definitely, I'd never use a framework like Codeigniter or Cake for an e-commerce website. Anything with that level of complexity would require a framework that was built for that purpose, like Magento (as much as I hate Magento).
Especially with only 17% coverage. I know line level coverage isn't a perfect metric. For example you can write a test covering only half of an `if $a or $b {â€¦}` and forget to test what happens when `$b`. But its sure better than none. Plus a pure PHP webserver comparing itself to battle tested, performant C-based servers like Apache and Nginx strikes me as odd, at least. 
Graphical digital clock is repeated twice!
Not really question but more like a request. I would like to build a blogging application dedicated for web developers, it'll be minimal, fast and easy to use, with syntax highlighting, responsive design.. But I plan to share the libraries (Actually, just 6 classes `Request`, `Response`, `Router`, `Session`, `View`, `Container`) first for review in Github: **[`FastPress\FastPress`](https://github.com/fastpress/fastpress)** And I just wanted know, if there **is** anyone willing to join in making this blog app or give me a feedback.
Has anyone toyed with "compiling" router paths into memcached to see if they can reasonably handle more load? (Yes I know about OpCache. This is for fun.)
&gt; a new way for Magento Enterprise infrastructure ok, no.
Meh. 
I'm sure this is very fast...
I think its a developer choice... I can see the usefulness of it... having 'controllers' myself with exception logic, it would be nice to rewrite that and put it else where.
How is it customized for multiple clients? Conditional code blocks for different clients or multiple code copies?
Curious as to why you are doing this? Just feel like it, or something? I would have to imagine there are already plugins for wordpress that handle the things you are looking to do, and if not It would surely be easier to just make your own plugin instead of trying to build the whole damn thing. Seems like you are recreating the wheel, and the road it goes on.
Oh fucking hell no. App Servers are legacy Java Big Enterprisey Thingies. App Servers were great before there was a thousand other tools to do the same thing faster, easier, and smaller. The world is actually going the exact opposite direction towards micro services to decouple these giant monolithic applications. Think Silex over EJB/Ear. As someone stuck with Glassfish for the last 10 years, with no hope of finally getting rid of it, the thought of introducing this pain into other languages makes me physically ill. With services like Amazons Lambda and Microsofts Web Jobs, and the ease of building PHP applications, along with Redis or MemCache for caching, and a dozen message queue solutions, there is absolutely no need whatsoever for this ungodly monstrosity. edit: fix
&gt; Modernizing Legacy Applications in PHP by Paul Jones - I don't have this book - is it worth the $50? YES IT IS!!! (I am, of course, the author ;-) More seriously, you can read the [Sitepoint review](http://www.sitepoint.com/modernizing-legacy-applications-php-review/), various other reviews on [the feedback page](https://leanpub.com/mlaphp/feedback), the [PHPClasses review](http://www.phpclasses.org/reviews/id/mlaphp.html), and this review from [Matthias Noback](http://php-and-symfony.matthiasnoback.nl/2014/04/book-review-modernizing-legacy-applications-in-php/). Those should help you decide one way or another.
Multiple code copies.
I'm doing it #1 Becuase I need to make a blogging app, I have the time, and I need a pet project. #2 To understand how frameworks work under the hood. ( sometimes you have to re-invent the wheel to understand the wheel, instead of just using it ) #3 Most developers just want something too simple to blog like https://nikic.github.io so, why would I need full-blown, clusterous, frameowork with 150k lines of code for that, not to mention a codebase that does adher to SOLID, PSR or good design pattern principles? #4 Need to collaborate with people to get used to git more (in a teamwork context) #5 What's the "whole damn thing"?? creating blog page is not hard at all. It's fun! keep calm and join^fastpress :)
[Good answer](http://i.ytimg.com/vi/Gk4t0b071xo/hqdefault.jpg)
Is httpd covered by unit tests?
/u/pmjones ... had a spare hour this morning... https://github.com/geggleto/sframework ...looks neat.
One way I have done this in the past is to isolate common parts and create a repo for them. The customized parts you will just have to deal with... but all the rest of the common bits you can throw into a repo and check it out on all the client copies... at least you will have 1 source for that component. Just know that it will take a long time to get it all in order and it does require a lot of patience. also buy paul's book.
Well, windows doesn't actually support symlinks, at least, not very well. ~~Windows 10~~ Microsoft Vista introduced it from the command line, IIRC. Your best bet is probably just to create the links yourself from command line. Honestly, though, you might be better off using a dev environment that's more amenable to web hosting. Grab yourself a copy of VirtualBox and XUbuntu. Install XUbuntu, and run something like this: &gt; sudo apt-get install apache2 php5-mysql php5-curl php5-sqlite phpmyadmin That should pretty much get you up and running, and you can use SSH/SFTP to get in to the server from whatever internal IP address VirtualBox assigns.
&gt; Grab yourself a copy of VirtualBox and XUbuntu it's not gonna work if you use virtualbox shared folders. We've been through so much pain with windows+virtualbox+vagrant - that at this point everyone I know migrated out of it to Linux or OSx. 
Hello ! I submitted this library on Github. What are you thinking about ? I can't find a way to simplify the detection logic... Thanks a lot for your feedback !
Could be useful for sure, but don't most bots that want to avoid detection just spoof their user agents anyway?
Why did you choose to hard code in a bunch of if/elseif statements ( https://github.com/bee4/useragent-classifier/blob/develop/src/Detector.php#L25 ) and also have a bunch of bot classes (https://github.com/bee4/useragent-classifier/tree/develop/src/Bots ) ? Why not just have all the bot info in an array, then just do something like (just very roughly): foreach($all_bots as $bot) { if (stripos($user_agent, $bot['search_for']) !==false) { $this-&gt;set_bot($bot); //sets the bot name, tags etc } } I would say it is much much much easier to maintain an array of data than a bunch of if/else statements and making different classes for each bot type. also your variable names aren't great. ($lower? $oError), and the EmptyBot class isn't an empty bot, it is NOT a bot ("//Regular visitor (none of the above...)" from your comments - https://github.com/bee4/useragent-classifier/blob/develop/src/Detector.php#L93 ) Also the two try{}/catch{} seems a bit like extra unneeded code. Why not just have one try and two catches?
I assume you seperated things out so you can put detection logic specific to each bot - otherwise, its pretty crazy given the number of bots there are that can be identified out there. I once made a library that processed [this file from awstats](http://awstats.cvs.sourceforge.net/viewvc/awstats/awstats/wwwroot/cgi-bin/lib/robots.pm?revision=1.72&amp;pathrev=HEAD) and matched against it - if that goes to show you how many there are on useragent alone.
ITT: lots of people saying windows doesn't support symlinks. [It does](https://en.wikipedia.org/wiki/Symbolic_link#Microsoft_Windows), its just that your application is trying to be clever with them, and failing. Why does it need to know that a symlink is a symlink (check obviously failing on windows). Infact, why does it even care if its a symlink or a folder? *sigh*
I'm trying to think of a simple way of storing (human readable) key-value pairs in a single csv field (for reading into an associative array), and the best I've come up with so far is this: key1:value1 key2:value2 keyN:valueN But if feels pretty clunky and the parsing code for it isn't especially elegant either. Is there a better way? The data itself is user metadata for an SSO system. The keys are different per application so I can't define them as columns in the CSV.
http://designpatternsphp.readthedocs.org/en/latest/ Edit: sorry it isn't a video, but it's a great resource nonetheless.
Aside from the typical sources (GoF Design Patterns, Martin Fowler's site, etc.) another way to start discovering patterns is to simply detect patterns in your code you don't know the name of, and ask friends and colleagues what does it look like. Inevitably, someone else has discovered it and named it before you ;)
Why not json?
How so? If you present different content to the crawlers than you do to normal visitors, you're fast-tracking your way to getting blacklisted. I can't imagine knowing how frequently bots crawl your site to be terribly useful, but then again there's a use case for pretty much anything these days. 
 Dirty but should do what you want: echo "&lt;script type='text/javascript'&gt;alert('{$app_message}');&lt;/script&gt;";
Not sure if it's better, but here's one that my team wrote a while back, because we couldn't install the pecl http extension. https://github.com/dominionenterprises/util-php/blob/master/src/Util/Http.php#L124 EDIT: spelling 
Still fairly new to testing, but... I should say you want to test that when you call that method, $session-&gt;updateTimestamps() is called, and also $this-&gt;storage-&gt;store($session) is called. If any of those two aren't called when your method is called, something is wrong. It's all well and good knowing that $session-&gt;updateTimestamps() works exactly as expected but if it is not called at all when it should be then that's irrelevant and your tests should fail. Happy to be corrected though, as I say I'm pretty new to this.
Okay, thanks. Trying it in a Debian VM will be my next try!
I don't know why it needs to check them either. Like Composer says, absolute links have been created instead of relatives. And somehow the Application doesn't like that. 
My only concern with that is that I'm testing the implementation detail of renewSession. Maybe in the future it could be changed to achieve the same result, just in a different way (different method names, different procedure entirely). The desired indirect output is the same, but my test is now broken and/or unreliable. I suppose I'm testing for a very specific storage case - looking to see if the new timestamp was in fact stored. But I fear that test is brittle as well - because right now I have SQLite storage, but later on, I might change to some other type of storage, at which point my test is also broken even though the code will work just fine (since storage is abstracted)
It's useful to know if it's a bot or a person hitting your site. If you get 1,000 hits a day, it's nice to know that 995 of those were Google and your site isn't as popular as you think.
More discussion [here](http://www.sitepoint.com/appserver-a-production-ready-php-based-server), with authors chiming in to explain some things.
Is the outcome of your test detectable via the class's public API? If not, your best option (IMO) is to check your storage driver to verify the outcome. You can reduce the brittleness of this technique by hiding the implementation details in a factory method, and hiding the implementation of the assertion the same way, like so: //creates and keeps a reference to the SQLite storage driver $subject = $this-&gt;createSubject(); $session = $this-&gt;createSessionObject(); $subject-&gt;renewSession(); //checks the SQLite session storage driver to see if timestamps field was updated $this-&gt;assertSessionWasRenewed($session); Not a perfect solution, obviously.
Where do I go to improve my understanding of algorithms? IE: www.codility.com Also, I understand it is not necessarily PHP but i don't know where else to post w/o being safe... not judged, etc. :D
I needed to do this to give the marketing people accurate visitor statistics for our site. I just looked for words like bot and how many times they hit the site. Real people don't visit all the pages(usually).
try { try { if elseif elseif elseif elseif elseif } catch{} } catcth{} ??? Really?
Thanks for the link, the bot database seems very more complete than mine ;) I'll check it !
&gt; In a nutshell, the primary difference is that appserver.io doesn't lose its entire state between requests. The rest follows from there - you don't need memcached, you don't need SQL for basic persistence. If it's in memory, it stays there. It just works. Until there is an error or a lock or you want to do an update and you have to restart the app server or you want to spin up more instances. Now your memory is not there, and doesn't 'just work'. Now you have to worry about syncing the in-memory cache between machines. Have fun with that, especially when cache updates conflict. Store in MemCache or Redis on another machine, you can share the cache between all instances, or even restart your instances without worrying about it. Oh? And you have a long running process that needs the cache to perform well? Have fun warming up the cache every time you need to run it if it hasn't been loaded yet. With a separate cache that is a non-issue, you can always keep it warmed up and do whatever you want with the code, it's just a data store, not integrated with everything else. And I have been programming, and using app servers of all types, for a long time. 'Modular' is a pipe dream when it comes to app servers. Glassfish is modular. But try replacing Jersey, the default JSON parser, with Jackson. Guess what, you just broke automated resource discovery and several other things along the way. Also, EJB/Servlets/Actors are nothing like middleware at all. Middleware is all the rage bc they are plug-and-play. Create some middleware, insert it in the right spot, feed the data through and operate it against it along the way, and you get your result on the other end. Add/Remove at will. It's kinda like the way Wordpress uses actions and filters. EJB/Servlets/Actors are pieces of the larger puzzle. Whether they are written as individual 'modules' or not, in reality when it comes to app servers they all operate together as a whole. Jersey/Jackson is modular. But I can't just swap out the reference. I have to make a bunch of changes to my other code and add reference libs and restart the server. With middleware, you would just replace the parser at the end of the line (or beginning) and it wouldn't care which one it was using. 'Modules' are out the window when they all work so closely together. They pretty much can only be called 'modules' bc their source code is in different repos, and you can theoretically change them out (but not usually without a lot of hassle/changes). That is not middleware. &gt; This architecture appserver.io implements is still extremely prevalent throughout the industry Legacy code has a way of sticking around for a while. Companies don't replace their entire codebase as soon as something new comes out. But it is definitely on it's way out the door, being replaced by true, independent, modules that have individual functions and don't care what everything else is doing. That's the future. Infrastructure like this is the past. edit: added edit 2: as someone else pointed out, it's configured using XML. XML is so yesterday it's ridiculous. This kind of setup is just entirely living in yesterdays world. I would never start a new project using it. MAYYYYYYBE if I had a legacy setup that I needed to add a message queue and second level cache to quickly, but I would have to be extremely pressed for time and not care about the future of the application. 
A brief scan makes me think you're about a half-step away from Action-Domain-Responder. "Service Layer" is a domain logic pattern, making it the Domain; Responder is literally there; and in Slim, the natural state is for single-purpose actions (as closures).
Magento is complicated as shit to use. I don't have a lot of faith that anything else coming out of there wouldn't be the same way. They have had a long time to make it better and never have.
What version of cake is this you are speaking of? I'm interested in knowing what if you could figure out what the slower parts were 
&gt; Until there is an error or a lock or you want to do an update and you have to restart the app server or you want to spin up more instances. Now your memory is not there, and doesn't 'just work'. Now you have to worry about syncing the in-memory cache between machines. Cache doesn't have to be synched, cache is disposable, that's why it's cache. If you need to update your app, you stop it, update the code, and run it (there are also workflows to avoid any downtime on the same machine, even). &gt; 'Modular' is a pipe dream when it comes to app servers. So you're saying the industry is living the dream ;)? Those technologies don't exist only in theory, you know. You should check Erlang, as it has the concept represented in its most pure form. Other platforms are more pragmatic, like Akka, but Erlang is pure. And it'll help you understand the thinking behind it better. &gt; Whether they are written as individual 'modules' or not, in reality when it comes to app servers they all operate together as a whole. Modular means that you can swap a module out and use another in this context, or reuse the module itself in another context. It's a matter of coupling and lack of shared state between modules. It doesn't mean they can't communicate at all, in order to "operate together as a whole". **EDIT** To address your edit: &gt; edit 2: as someone else pointed out, it's configured using XML. XML is so yesterday it's ridiculous. This kind of setup is just entirely living in yesterdays world. Trust me, I'm no fan of XML for configuration, but I think it's a quite superficial concern, don't you think? "It's so yesterday" is not a serious reason to prefer one thing over another. At least not between engineers; teenage girls - different story. The typical reason for using XML these days is when it's a best fit for a certain (enterprise) workflow, or tooling which supports XML. You'd rather have an admin tweak XML settings and not the product's PHP source. It's pragmatic. And on its own, inconsequential about the quality of the final product.
While I do agree, it wasn't meant to be by any means a conclusive benchmark :D. I'd be interested to see how it stacks up against something like Symfony, perhaps it'll perform a lot better in PHP7 too, who knows!
HE ***SPECIFICALLY*** ASKED FOR VIDEO but this is great either way, cheers! :D
The nginx test suite is a series of functional client-side tests written in Perl. They don't directly "unit test" or have any coverage statistics. http://hg.nginx.org/nginx-tests/file/45d89d9c38a9 Yet the product is absolutely solid and well trusted. It makes an interesting case for the actual value of these "I base my trust in a product on test coverage" type arguments.
"preferred"
Known bug. See https://github.com/contao/core-bundle/issues/208
It was a joke but either way...
Ohh, carry on then :)
At my workplace we use the older version (2.x series) of Codeigniter and honestly it only ever gets in the way. It's mostly just used for URL routing and about half of our module loading (the rest is being migrated over to Composer slowly). It doesn't offer very much and after inspecting the source code for the features that it does have, it's basically useless and you're better off pulling some better libraries with Composer. Then again I've come into CI 2.x after having used Symfony, Laravel, Rails, Express, uh, and a shit ton of other better frameworks, so of course I'm going to hate it.
Why are they editing CSVs? Can't you turn that into some simple web forms?
Thank you! This is what I needed :). I'll try with Python - nice language :)
Heh, I actually did that for my personal website. (Instead of a real framework, it's a folder of PHP scripts that include an autoload file.) :)
I'll second the Laravel suggestion, especially with its Composer support and API brilliance. I used to use CI back in the day, but it's just not exactly what we need anymore.
Even though I feel like you're taking my points out of context a bit, or reading things into them I didn't say, I think we'll have to agree to disagree on most of these concepts. &gt; No comment, other than, you apparently have your priorities straight. However, it seems we can both agree on what the fate of the inventor of WSDL's should be.
Maybe we need to... I think I'm going to improve that detection with a DNS lookup from the IP address...
PDO is very easy once you've managed to make it work once :P I think this might help: http://webdevelopingcat.com/php-mysql-tutorial-for-beginners-connecting-to-the-database-with-pdo/ And this: http://code.tutsplus.com/tutorials/why-you-should-be-using-phps-pdo-for-database-access--net-12059. And about learning resource, when I was a beginner I used w3schools, but don't really know how good it's nowadays. Something that could be good to do, that I do. Would be to do research about new things you learn, to find out if what you've learned has security flaws, and what to do about it.
"CS164 Lecture 3 Design Patterns " - https://www.youtube.com/watch?v=mym5m-GKG0Q http://www.lynda.com/PHP-tutorials/Design-Patterns-PHP/186870-2.html
I wrote a PDO wrapper called [EasyDB](https://github.com/paragonie/easydb) to make it more intuitive for developers. &gt; I don't even really know what a prepared statement is (I think it's basically one that had been checked and escaped for MySQL injection?). What prepared statements do in the background isn't important. You don't really need to know how they work or why they matter right now. I want you to picture a query. SELECT * FROM accounts WHERE username = $username When you run this query, the variable $username is appended to the rest of the query string and then it's sent off to the database. This gives the database **no indiciation** of what the original query was. You can try to escape, but that path is filled with needless complication and corner cases. Obviously, if you change the value of `$username` to something malicious, you can make this query do undesirable things, like steal password hashes or [write a malicious payload to your filesystem](http://0haxor.blogspot.com/2012/08/into-outfile-uploading-your-shell-with.html). Let's change things a bit. Instead of inserting `$username` into the query string, let's put a placeholder and send it off to the database: SELECT * FROM accounts WHERE username = ? The database server will say, "Okay, you're asking for all the rows in the accounts table where a username equals a given parameter `{0}`? Can you give me a value for `{0}`?" So then you pass `$username` to the database and it runs your query. There is no way for a malicious user to alter the structure of the query string by changing your parameter. **When used correctly, SQL injection becomes impossible.** That's all there is to prepared statements. You send a query, then you send the data. You can actually *reuse* a prepared statement to run it multiple times with different bits of data. Using them turns out to be a bit cumbersome, so `EasyDB` seeks to make it a one-liner (it uses PHP 5.6's variadic function syntax, so you can just append variables to the function as much as you need): $user = $EasyDB-&gt;row( "SELECT * FROM accounts WHERE username = ? OR email = ?", $username, $email ); As for learning resources, I can offer two that are relevant to your specific circumstance: * [A curated list for learning application security on Github](https://github.com/paragonie/awesome-appsec) * I wrote a blog post on [definitively preventing SQL injection in PHP](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide) I hope some or all of this helps. Please don't hesitate to ask if something is unclear.
&gt; Yet the product is absolutely solid and well trusted. It makes an interesting case for the actual value of these "I base my trust in a product on test coverage" type arguments. It's more about the preconception of what is considered a unit test. Instead of relying on the abstract definition, many have decided that a "unit test" is code you write using a "unit test framework", which is simply lazy. The Nginx test suite is a set of unit tests, and the unit is the HTTP service Nginx provides. The service API boundary is a very suitable (maybe *the* most suitable) unit boundary for testing. 
Yii is a very powerful framework
Lets try to clarify a bit: - MySQL is a database engine and it is NOT depreciated. It is very current and used by the majority of LAMP systems. - PHP is a language and part of the language is the libraries it contains. Often the function calls in the libraries have prefixes to identify them. For example the PDO library functions are mostly prefxed with pdo_***, there is also a library prefixed by mysqli_*** and a library prefixed with mysql_***. You should use the PDO library in your PHP programs (the functions that begin with pdo_***) . You should not use the mysql library - this is depreciated. Things for you to google: - PHP how do I use PDO - PHP PDO what is a prepared statement - PHP how do i use PDO to create a prepared statement - PHP using PDO to prevent SQL injection 
I want to hire couple of PHP freelalncers for project which need 6 months + work. We need to automate a lot of stuffs using IOT &amp; RFID. We have Oracle R12. A custom report tool on PHP. The RFID programs are on C#. Though I can do most of the things on my own but I dont have time. So I am looking for someone who has good experience on PHP and ready to work as a freelancer. Any place where I can hire freelancers for short duration 
or is it MVVM, MVP or even Flux..... - http://www.codeproject.com/Articles/844789/A-Belly-Dance-in-Holy-Lands-of-MVC-MVP-and-MVVM-Pa - http://www.infoq.com/news/2014/05/facebook-mvc-flux 
Well if you want any concrete help you could maybe specify where in the world you're looking... Also, citing numbers without units can also be very confusing. This internet thing, it's kind of globalized. Maybe list some places where you've already looked? - linkedin - http://careers.stackoverflow.com/ - ...
Some info on your timezone would be good. And do you look for freelancers specifically, or would a firm work out too?. I have some free PHP resources based in Latvia (GTM +2, Easter Europe, Baltics region), so we could talk. But it's going to be 30-40 EUR/hour rate (meaning 5-6.5k EUR/month per developer)
Thanks! 12K was in SGD...I should have mentioned that.
Too many acronyms! The first article was talking about how back-end programmers are being forced to write shitty JS and get lost in the client-side frameworks. I can't sympathize unfortunately since I cut my teeth on front-end first. I have a JS fetish that has been tempered by jQuery.
Just FYI a better worded title for this article would be "Rate limiting API calls in PHP". Client-side implies the limiting is implemented *in* the client (which wouldn't be effective).
Are you on shared hosting with no SSH access (assuming that's why you'd use FTP)? If so is there no control panel, such as CPanel, where you can use the File Manager to upload and extract zip files?
I hate to dump on the hard work of others but this project is completely nonsensical to me. It's so slow as to be completely unusable. There is a universe of difference between an actual non-blocking server and the threaded userland approach appserver has taken. I mean this in the most respectful way possible, but ... in my opinion this project is an enormous step backwards. It is not an innovation and I would encourage its avoidance at all costs. *Caveat emptor.*
Oh, sorry. Well, than we could have a call on the subject. I do have some resources :)
&gt; It's so slow as to be completely unusable. Have you tried it? Could you expand on your experience I'm genuinely interested.
I'd say no, phpcs config - yes. Not all editors are built equal and could/will read that file for anything.
most developers i know don't use ftp and zip. rsync is faster and supports gzip compression.
what?
If it's exported from Excel, then people won't be writing the CSV, so it doesn't matter how the CSV looks. Also you can import Excel directly with a library like PHPOffice. The solution &amp; format depends on why you're storing key-val pairs in a value. 
Thank you for sharing your experience. I was expecting actual arguments and numbers rather than your personal feelings but that's still interesting.
I'm not particularly inclined to setup a benchmark right now but I can tell you anecdotally what I observed. People say "hello world" doesn't matter and that is true at the high range. But "hello world" is crucially important at the low end -- it demonstrates what the server is capable of in the best possible scenario. And spoiler alert: appserver is not capable of much. It's unequivocally awful. I observed on the same machine for hello world: Appserver ------------ ~500 requests/second with 100 simultaneous users Falls over and completely dies under real load (1,000 simultaneous users) so not even benchmarkable Apache prefork ------------------ ~65,000 requests/second with 1,000 simultaneous users Closed-source non-blocking HTTP server written in userland php ------------------- ~65,000 requests/second with 1,000 simultaneous users Appserver is literally the worst possible engineering solution to the problem of http application performance. If you can honestly say with 100% confidence that you'll never need to scale out your application in any form then it's fine. Otherwise it's something you should avoid at all costs. If you have a horrifically slow web-sapi application might that same logic be about as horrifically slow in appserver? Probably. That is not a good excuse to use an immature technology, though. Doing so would represent unmitigated developer negligence in an enterprise setting.
This isn't really true. The API for interacting with actual HTTP requests/responses (what PSR-7 does) is only a tiny fraction of what's needed to properly implement an HTTP server.
Tests become less important as the number of real-world users increases because you get de facto testing over the course of years with an established server technology. However, for an untested and little-used technology like appserver tests are crucially important. Putting an immature technology with low test coverage into production is what I would classify as developer negligence.
&gt; there's nothing inherently slow in the architecture they implement Architecturally, no. But this argument ignores the reality of what pecl/pthreads has to do under the hood to expose threading to userland. Implementing this architecture in userland PHP is terrifically non-performant whether you're testing "hello world" or a "real" application endpoint. If your app is already critically slow because it has to sit around waiting for IO operations will it be roughly as bad in appserver? Sure. Probably. The problem is that the appserver performance ceiling is *much* lower than what you get from other technologies.
I agree with this. Here's how I would decide a framework to use: CodeIgniter - Beginners and non-serious projects only Laravel (or Yii) - Great for making websites. Zend - Great for making robust applications. Symphony - ... Not sure, haven't worked with it, maybe someone could give insight on its strength And then for API's a microframework like Apilify from Zend or something like that. 
&gt; And what is this conclusion based on? I have the feeling you may be misinformed about how threading in PHP works. It's based on being a contributer to php-src and working closely with Joe (the author of pecl/pthreads) when he made pthreads public two years ago. &gt; We're in /r/php/ so if your arguing is going to veer into "use something else, not PHP" I'm afraid that off topic. My argument is that this is a terribly non-performant solution even compared to other userland PHP solutions. &gt; can appserver.io be an improvement over the default execution model for PHP apps The answer is "no" unless application performance means essentially nothing in the context of your application's problem domain.
Yes you can change it as stated. However I am convinced that most people will not. Especially when providing errors for devs (which is a pretty common case) the error message is perfect the way it is, but better than just getting a 429. :)
&gt; The underlying issue I'm referencing is that pthreads has to serialize data to pass it around and can't directly share zvals across the thread boundaries. This serialization is absolutely necessary to make threading work in PHP short of a total rewrite of pretty much everything in the language and it's heavy logic compared to compiled server solutions where you don't need such transformations. Yes, I thought you'll mention that. But that's honestly not an issue for something like appserver.io as the communication between threads is quite minimal. A request is sent off to a thread to process and it returns a response. That's it. The same kind of interaction happens when Apache or Nginx passes data to PHP. And the overhead of this indirection pales in comparison to bootsrapping a complex framework on every request, even with opcache. &gt; The only logic one needs is to run a simple benchmark for herself under any sort of real world load to see the truth of the matter. No, benchmarks are data. Logic is when you explain the mechanics behind something using... logic. So far appserver.io do have the logical explanation, and the benchmarks performed under load, and you have a theory based on nothing.
Then can you please explain *why* appserver is so unbearably slow by every possible metric? Far slower than any comparable solution? Because it is. Please explain why that is something people should just ignore when well-established, well-tested, well-supported solutions don't incur this penalty. This is a classic case of folks being so excited that they could that they didn't stop to think if they actually should. It's convenient to say, "Oh, there are no benchmarks" when those benchmarks clearly contradict all the marketing nonsense.
&gt; Then can you please explain why appserver is so unbearably slow by every possible metric? You forgot to link or paste your metrics &amp; setup. Are you trying to pull a Looney Tunes trick on me ;)? Kidding aside, the data I have is appserver.io's official benchmarks, and they show nearly twice better performance compared to the same apps under Nginx and Apache.
No, I'm pointing to the benchmarks given in the link provided by OP. I don't claim anything contrary to that data. You do, so the ball is in your hands.
For future reference, you can catch multiple exceptions in one catch (obviously highest parent needs to be caught last), e.g.: &lt;?php class SomeException extends \InvalidArgumentException {} class AnotherException extends SomeException {} try { if(rand(0, 1000) % 2) { throw new SomeException(); } else { throw new AnotherException(); } } catch (AnotherException $anotherException) { // do another thing with $anotherException } catch (SomeException $someException) { // do something with $someException } ?&gt; As I said the highest parent needs to be caught last as otherwise the highest parent will always be caught.
Scroll a little down to the giant presentation video and click play. I'm guessing you jumped to the opportunity to argue before even going through their materials. Tisk, tisk.
&gt;I'm guessing you jumped to the opportunity to argue before even going through their materials. Tisk, tisk. Oh, so a youtube video is a benchmark now? VERY SCIENTIFIC. Any server that doesn't make benchmarks available is a joke.
Here are some YouTube channels I'm subscribed to: [International PHP Conference](https://www.youtube.com/channel/UCfkn0LIp-bZwDsCSWJ_WBxg) [PHPBenelux](https://www.youtube.com/channel/UCt52674wehPyCk-MIxe1sZw) [PHPNW](https://www.youtube.com/channel/UCbnp95lhvGK1H7hs2TYQwFQ) [phpukconference](https://www.youtube.com/channel/UCX06sx2WWYGny7b3XDUyFCQ) [SunshinePHP Developer Conference](https://www.youtube.com/channel/UC_LnivLeslUifdsAnCXgA_A)
At least they show *metrics* we can discuss. You can doubt their metrics, but at least they're there. In contrast, you said "tell me why it's slow by every possible metric" without mentioning any metrics. Nonsense. But... if you're not willing to explore this architecture due to prejudice, the loss is entirely yours.
yup, there are frameworks and there is laralol
point taken. Can you elaborate on why it isn't safe? Thanks.
Good to know. It is geared towards somewhat less technical users.
Yes/Sorta... FastRoute by nikic has a caching option where your routes are stored on disk... https://github.com/nikic/FastRoute You can write your own to write to memcache instead of disk... likely would have slightly better performance. Also some have been using microframeworks with ReactPHP, where the boostrap of the app only happens once. You boost your Req/s significantly that way however its highly unstable.
most people dont give a shit, because most people arent offended by innocuous statements.
If you really need something like this you'd be better off writing a shell script that does the unzipping. Have that folder be watched by the OS and when a file appears in there unzip it. There are examples on google you can find for inotifywait to do this kind of thing.
I'm not a performance junkie, I just like to play with code. ;)
Just amazing: the level of insights on the technical topics is just perfect for the wider PHP audience!
It seems bizarre to me, as surely then there is no point in setting the visibility of the alias?
very good book, several aha moments were had because of it and it helped me greatly in a pretty large rewrite..thanks pmjones
This implementation does limit the rate per process. Do you consume an api that often within one request? If you want to widen the scope (e.g. per host) you need a shared storage for the timestamp. Also beware of race conditions. Fortunately I made all that for you already: [bandwidth-throttle/token-bucket](https://github.com/bandwidth-throttle/token-bucket)
Hey, I think "rolling your own" especially for learning how to do it is very good. I do that too. However when working on production code having a strong community is worth a lot. Also while at the moment it might be fun and easy to maintain everything, what happens when you have less time? Best is do do you own X to learn how to do it, but use an existing framework / package / lib and commit improvements (read: make this package even better and thus help providing the "community" benefit). Personally just reading source code seems weird. It only makes sense if you want to do something similar. I would always used tried and supported packages in production code, but try to build something myself if I am vey curious about it. However, I would not release it, as having 1mio packages on composer that do the same, does not really help the situation. 
Thanks, this looks really useful!
This is all really great information that clarifies things, thank you!
They say you write 2 frameworks when you learn a language. The first is a learning exercise, and an abomination. The second is better, and usable. The third you never write because you now understand what you are doing and realize somebody else has already done everything. That isn't to say there isn't any value in the first and second, quite the contrary! Just call a spade a spade until you know better, that's all. &gt; If we don't reinvent the wheel do we ever learn how the big frameworks work? Maybe. Everybody learns differently. There is a big difference between learning and publishing though. &gt; Why is it in some situations people experience a negative back lash at the concept of "rolling your own" Generally, marketing. Create and share something, sure! Just don't market your first shot at learning something as a "new framework, better than X-Y-Z". &gt; On that note: Laravel is new so what made them different then if I went out and rolled my own framework? Marketing. It grew up a lot, had a big community and some neat, newbie-friendly concepts when it first came around in v2 and v3. &gt; Do you learn anything from just reading the source of the larger frameworks? or do you learn "their" way of doing things? Just keep an open mind. It's like the Bible. There's some great shit in there, but there's also 10 different versions of it and different people that ascribe to the teachings of each.
Symfony truly has it's shit together.
Generally speaking the people receiving a "negative backlash" didn't research/understood existing solutions and wrote something based on bad assumptions (ex: Laravel ORM is too complex ). I know a company that refuses to use ORMs and writes their own implementation for each project. They mostly end up building an object mapper that constantly requires to be updated / upgraded / modified because the original authors did not envision a general use-case. ex: `select * from users where id = ?` was implemented but they didn't think of `select * from users where id IN (?,?,...)`
No worries, and best of luck with your study. If you get stuck with my material, feel free to PM/tweet me. 
&gt; Hey, I think "rolling your own" especially for learning how to do it is very good. I do that too. However when working on production code having a strong community is worth a lot. Also while at the moment it might be fun and easy to maintain everything, what happens when you have less time? This argument could be made for the developers of say zend (for example). You could counter argue that Zend has a community behind it and they do. It would be a valid argument. How ever When Laravel first started they didn't have anything - Now I dont know there back story, it would be fun to learn - But I am sure they were some company or group of people who needed and easier solution then what was out there, hence rolling their own. So if the argument here is "don't do this because what if you have no time" then how do new frameworks come about and stick around - community. But that then leads to the question: "If you don't roll your own because X is better and X has a community, then how does anything new ever come about?" &gt; Best is do do you own X to learn how to do it, but use an existing framework / package / lib and commit improvements (read: make this package even better and thus help providing the "community" benefit). Why? Then whats the point of rolling your own? Maybe I am mis understanding something here, but if the goal is to learn then use X, why not just learn X? &gt; I would always used tried and supported packages in production code, but try to build something myself if I am vey curious about it. However, I would not release it, as having 1mio packages on composer that do the same, does not really help the situation. What if your package offers a similar but slightly enhanced way of doing things? what if it suits the production code for what it does? I find that people tend to get stuck in this "Y already exists, dont do your own thing" mind set. I find that hinders the concept of learning. They then back track on their comment by saying, "roll your own, but use X because its more supported" This leads me to my last question on this comment: What if what you write works better or has a different approach that suits the code you wrote? Should you then not write you own X and maybe release it to the community to get feed back and interest? Or should you throw it out because maybe Framework X is battle tested and has the same component? When do we draw the line between use X and roll your own? 
A little on the uninformed side here but when we say 100% PHP7 compatibility, how is this affecting running on php55+?
The "MUCH" wider PHP audience! 
&gt; They say you write 2 frameworks when you learn a language. &gt; The first is a learning exercise, and an abomination. I personally don't consider either of these "frameworks" In the sense that my OP was about. Training wheels and mud cannot be shapped (personal Opinion). It was more geared towards, ok you have used Framework X for 10 years now you write your own and then release and the community is like "Why? just use Framework X. Stop reinventing the wheel." &gt; The third you never write because you now understand what you are doing and realize somebody else has already done everything. I hate this mindset, and I know they say you should never use the word hate, but I use it in all its glory here. This goes back to a previous comment I made on another post - "what if what you write is better for that particular use case then what framework x offers? what if what you write could help others?" It also leads back to the question: "If what is made is better, then how do we as community grow? How do we get out stuff out there?" &gt; Generally, marketing. Create and share something, sure! Just don't market your first shot at learning something as a "new framework, better than X-Y-Z". &gt; Marketing. It grew up a lot, had a big community and some neat, newbie-friendly concepts when it first came around in v2 and v3. This leads into the concept of: "Ok I wrote this, I ask the community what they think, usually the first question is: "Why did you reinvent the wheel?" I explain and they they state "framework x does this", so I am left wondering did I waste all that time?" No I didn't I learned something from doing what ever it was I did. I see a lot of this in the community, and maybe in some cases framework x does do something better, what I don't ever seem to see is that the community embraces something new, maybe its because secretly they are all 40 year old men who like working with the same code day in and day out because its tried and true and they **are** the old dog you cannot teach new tricks too. I get that there has to be a certain level of professionalism with everything that you release and some times the things you release don't work and are a ball of mud and sometimes what you do release, X does better. But what about those times when you wrote a framework, lets say its based off zend and it does what you need it to do, some people stated they would write there own things but never use in production code why? Is the answer legiti because "framework x does it better" what if framework x or y or z or A or B or what ever didn't exist? would we write our own? or would we wait for some one smarter then our selves to come along and write the "answer to our problems"? IMO, communities cant grow if we try and create something but the community is stuck in their "ways" so to speak. then again maybe it can ... 
This is intended as a simple implementation for smaller projects. However your token bucket implementation looks awesome - thanks for sharing.
&gt; Then you didn't build a framework at all, or you rewrote WordPress , pick one I completely disagree, Ill tell you why in a short summary. WordPress is ok for tiny sites and some lager sites. But its not used for things like application development for various reasons that this OP doesn't talk about or care about. What I did was to write a layer of abstraction on top of WordPress (think of Themosis) that allows you to incorporate concepts like: routing, DI, Template Handling, Form Building and so on when building themes, allowing you to still use the functions and familiarities of WordPress but have the organization and concepts as well as patterns of a framework. In summary, the concept was: WordPress -&gt; Abstractions -&gt; Theme/Plugin/ChildTheme &gt; Framework are not blackboxes, you can go read the source ,that's how you learn how other people code the proper way. Do you really? Or do you learn "their" way of coding? &gt; That's why I don't take the "no framework" people seriously , it's more like the "not capable of reading other people's source code and make sense of it". Its not about "No framework" its about rolling your own framework. But I see your point your making, lets move. 
Your angst is strong, Padawan. I applaud and encourage your willingness to learn, share and explore. We are all searching for the holy grail of code, programming Nirvana. Regard old dogs like you would an old dog. Speak your mind, as you are doing here, but don't forget to listen while you're at it. If your ideas are met with contempt, you may need to alter your trajectory.
&gt; Do you really? Or do you learn "their" way of coding? Symfony and Doctrine have thousands of contributors. Who do you think has a better way of coding , you or thousands of developers ? Who do you think is going to write more secure and robust software ? you or hundred of thousand developers that deploy these libs , read their source code and report eventual security holes that get fixed ? you don't really know if you code is secure until a thousand eyes take a look at it. 
What's the use case for this kind of thing? Something to do with routing requests?
In this specific case there's no reason to build an ORM. Last time I heard about the ORM they forgot to escape values when using `IN` clauses, thinking it would only be used with numeric id. They are also thinking of adding dirty-fields support to only generate the proper update statements (right now it updates the entire row). &gt; They went through rapid Iteration before becoming mature. if we say don't do x because y is better, then how do we improve the concepts of y? by contributing to y? Because they constantly chose to re-implement the mapper-pattern they do in-house, each iteration being slightly better, weeks of time are being wasted on an implementation detail vs the business logic. By picking CakePHP ORM, Eloquent, Propel, or Doctrine they would have saved quite a bit of time. If the tool you picked does something poorly improving it would yield a better return over time due to the community effect.
The question I have is does the ORM do something for the company that say Doctrine couldn't?
I think this is a mistake with the design of traits, but it's what it is. You're using a correct workaround: define the method and do what you want to do (if you want it to "not exist" just throw an exception when you redefine it).
Try to use as much as possible, but avoid tying a lot of your code to monolithic dependencies like some frameworks. Pay attention to public opinion, but keep in mind it doesn't reflect professional practices. Not always. Follow your gut. The only way is through experience. The only way to experience is practice and pain.
would you give the same advice to some one who decided to share that "gut" creation with the world?
I like this, but also I worry the middleware interface is too heavy for minor functionality like this. You could implement the same library with something like: $mime = YourLib::getBestType($acceptHeader, $listOfProvidedTypes); No middleware, no PSR, no nothing. And it'd be faster too, I bet. I get the appeal of having everything is middleware don't get me wrong. It's very uniform and user-friendly. I just can't decide if it's worth the overhead for this case, and many other cases to come.
&gt; And even then, personally, I'd rather do a few minor workarounds in a standard framework than go out on a limb with something that has no track record, so for me, it had better solve a pretty huge problem. When do those small work arounds become a mess or a framework its self? Is this when you look to what some one else maybe created to help you "organize" or clean up your logic? &gt; Have you ever started a job with a large project using an undocumented, custom framework? Have you ever done the same with a "standard" framework? I have an both times it was a mess. The first one was a custom framework that failed to do MVC even at its most basic roots and the second one failed to understand what Zend was all about. &gt; In my experience, there's a HUGE difference in your spin up time before you're effective, and you have to do maintenance in house, which all translates to lost time and a less effective team. This leads me back to the Junior and Senior Developer Job Question, who do you hire? Some one with 5x more experience or some one with 0? When is it appropriate to use an non battle tested over battle tested in regards to "work"
This is what I would recommend, even better is if you have a project you are building and you need a custom framework build it around, although abstracted from, that project such that it can be reused again.
Your exact use case is in [an example in the docs](http://www.php.net/trait#language.oop5.traits.visibility) (note the comments): // Alias method with changed visibility // sayHello visibility not changed class MyClass2 { use HelloWorld { sayHello as private myPrivateHello; } } I personally treat traits as if they are code that is copied and pasted between files. I've never needed to include a trait and then modify its implementation. I think it helps me avoid conflicts such as these. Maybe that thought process may help you?
It bears consideration, but there's always a trade-off using reusable / interoperable code vs. a purpose built custom snippet. That said, I'm not sure what interface you're referring to - a PSR-7 ServerRequestInterface, this library, or a middleware implementation? I'd have to test it, but my hunch is the real impact is negligible. I have more general thoughts on the utility of middleware, especially the interoperable kind, but I don't have them prepared to share. In the meantime I recommend @mwop's post: https://mwop.net/blog/2015-01-08-on-http-middleware-and-psr-7.html
What are you takking about? What prevent you from using object instead of array?
Unless you are providing something "better" than what is currently out there, you are just muddying the water with YAF. On the other hand, do whatever you want.
Have you considered the possibility of both?
While yes, this is true would you not agree there are times and use cases where its appropriate to role your own solution?
Before Laravel came out, everyone was like "Why reinvent the wheel? We have CodeIgniter!" Then Laravel appeared and it was much better than CI. So to answer your question, we *do* keep reinventing. Sometimes those things will be better, often they will not. Such is life.
Very, very rarely. In the cases of the utmost security, or something that must strictly adhere to something like say, an embedded system, sure. But for 99.999% of us, the solution(s) the community has already derived is generally going to be more efficient/secure/tested/etc.
Ok I can accept that, but let me ask you this. Why did the community accept Laravel? Why did the community accept (I dont know the time line of who came first so for give me) Symfony over Zend, when Zend was there all along. What makes these so special? Community? Ok I can get community. Marketing, no problem I am good with words (maybe not so much spelling and grammar - hence the community aspect). What is they have I or you or your mom or your dad rolling their own framework wouldn't have?
Yes... though "better" in that case didn't mean technically better, it meant easier to use and understand.
So it comes down to usability of a framework? If so why isn't every one rolling their own?
It's also a singular project entity. You can use either and be completely correct.
&gt; when a new ubiquitous technology like Composer gains traction I don't think its all that new. I look around at a lot of PHP frameworks and it seems to be the one thing you MUST use or at least incorporate and its something I incorporated from the get go, when building my abstraction. &gt; But the point in writing that new framework/system of frameworks will be to utilize a new technology, not just be to create a new framework because you can. So its about new technologies and seeing who can be the first or the better Christopher Columbus?
&gt; If we don't reinvent the wheel do we ever learn how the big frameworks work? Reinventing the wheel for learning purposes is great, but there's a difference between doing it yourself to learn, and doing it yourself to build a proper alternative. &gt; Why is it in some situations people experience a negative back lash at the concept of "rolling your own" When they think their solution solves a problem that either doesn't actually exist, or what they rolled is objectively not as good. &gt; On that note: Laravel is new so what made them different then if I went out and rolled my own framework? Laravel did two things: it was a catalyst for modernizing PHP development, and it had sane, straight-to-the-point API. It wasn't hard to use/learn like Symfony or Zend, it wasn't stuck in the stone ages like Cake 2 and Codeigniter, and it was more fully featured than Slim or other micro frameworks. It filled a major gap in the PHP framework landscape that many people didn't even realize was a gap. If you want to roll your own, then fill a gap. &gt; Do you learn anything from just reading the source of the larger frameworks? or do you learn "their" way of doing things? Yes, I learn a ton. I of course learn "their" way of doing things, but that doesn't mean I take that as being the only way of doing things.
Then, and only then, I'd subscribe to /r/lolphp and become a Python developer.
So people take the fast route instead of the learning route? makes some sense I suppose
Actually, no, they **don't** accept PRs. https://github.com/ziadoz/awesome-php/pull/450
Wow. I'm happy that there are finally strong multiple implementations of PHP, each with different strengths. It points to PHP finally entering a stage where the language is becoming a heterogeneous sourced and stable technology like C, C++, or Java. I would vastly prefer a published and living standard and multiple implementations by a variety of companies and open groups (which are typically backed by companies as well). We aren't there yet, but I like the direction.
If Zend became the owner, I'd pack up and leave to never again return. 
Sorry to hijack the thread, I see a lot of comments targeting writing a framework from scratch, what about using already built/tested components to build something that's basically a framework? Right now I use silex for routing + dependency injection, twig for templating and doctrine for database then basically build a simple architect around those with a few wrapper classes to handle specific tasks. Is this worse than using a full fledged framework? I'd assume it's better than rolling your own though.
I'm not sure what's the purpose of this speculation as indeed it can't legally &amp; logistically happen. But, for the record, Zend do have an IDE, and I'm afraid it's not the best PHP IDE out there (source: I use Zend Studio). In fact, from my experience filing bugs against their IDE, their developers don't even understand PHP's semantics or practice too well. They don't seem like they're active PHP users. Maybe it's a problem of money - if Zend were the owner of PHP they'd have more money and be able to offer a better IDE and maybe have PHP expose standard tooling for IDEs to ensure 100% parser consistency. But then again, if one company was the owner of a platform, it wouldn't be nearly as popular as it is. Chicken, egg. Despite IDE woes, Zend remains heavily invested in PHP and PHP7 happened in large degree due to Zend, which shows they have developers who are very deeply familiar with PHP's core and working on it (contributors outside Zend were also key to PHP7). But it's like two separate companies under one name: 1. A medium-sized company that's not very good at PHP, offers certifications, tooling and a barely acceptable IDE. 2. A tiny company with a few remote developers, who are very good at PHP &amp; focus on contributing to the core.
You should read the basics https://en.wikipedia.org/wiki/Software_testing first
It's a genuine possibility
As always, [reading Mathias Verraes](http://verraes.net/2015/01/economy-of-tests/) helps. This picture in particular is very useful: http://verraes.net/img/posts/2015-01-05-economy-of-tests/test_pyramid-small.png
heh :D
Hah. Was literally going to post about my first two frameworks which were a learning exercise / hobby thing. Now I just use Laravel! I wouldn't have a clue about any major core php concepts, design patterns and complexities without making my own the first time round.
I think you are applying unit tests in places that there is really no reason to. The framework or components you are using already have unit tests. Most of the 'application' is the end user interface. That part I test functionally. Send a call to the webpage, check results meet expectations, fillout forms, check results. Maybe create some rows in the DB and then check the webpage to see they are reflected. If you have some business logic in there then perhaps write unit tests for that part and skip the crud.
Unit testing is about taking one part of your system isolating that part and testing it. Is your software implementing a request and response? No? Not your software's problem. You only test classes/methods that you implement. Of course if you do it all in your own framework, you made it, you test it. For example in a MVC App, you only need to mock data to pass into a Controller, and then check that its outputs are sane. Check that any method you put into your Models also output something sane. It really isn't very hard, granted it is a lot of boilerplate. 
&gt; Unit testing is about taking one part of your system isolating that part and testing it I disagree. This is not what Kent Beck meant by isolation. He meant your *tests* should run in isolation, not your code. &gt; Is your software implementing a request and response The feature I want to be sure is working is executed through a request, and its output is a response. $expectedResponse = '....'; $actualResponse = $router-&gt;dispatch($mockedRequest); $this-&gt;assertSame($expectedResponse, $actualResponse); No different than $expectedOutput = [....]; $actualOutput = $someClass-&gt;doSomething($mockedInput); $this-&gt;assertSame($expectedOutput, $actualOutput); The request / response is the earliest and latest point your implementation of the feature might fail, so they need to part of your test mechanism. You CANNOT test just a controller, because the request might have several middlewares that affect the test. By testing only the controller, you cannot be sure that you've actually properly implemented the feature. If you test the controllers and middlewares independently, you still can't be sure because different requests have different combinations of middlewares, and as part of refactoring, you might remove or change them in some way. You don't want that to *break* your tests, you only want your tests to fail if that change to the middlewares broke the required feature.
&gt;you still can't be sure because different requests have different combinations of middlewares what you are describing is not unit testing.. this is integration testing. Integration testing (sometimes called integration and testing, abbreviated I&amp;T) is the phase in software testing in which individual software modules are combined and tested as a group. In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use. 
&gt; This is simply not true. Just because the components of a framework are well tested, doesn't mean you've hooked them together in a way that implements the specified feature. But that's not unit testing! That's integration testing.
&gt; But PHP7 is just around the corner... perhaps now is the time to start writing your PHP7 framework, that takes advantage of the new features fully - unlike what existing frameworks are able to do. is a contradiction of: &gt; If you make a framework now, there are frameworks that do take advantage of new language features, that are well tested, well written, and fast. Because a lot of frameworks that exist see the value in things like HHVM, Hack, PHP7 and so on and move towards that as fast as possible. Where its not a contradiction is if we were to say make a framework from the ground up, not incorporating aspects of symfony or zend, but a whole new framework using PHP 7 features.
I like pretending as much as the next guy ... we can pretend Zend could own (whatever that means) PHP ... What we can't pretend is that there is any direct correlation between a language being owned by a single commercial entity, and that language being any good, or improving, at all. What you might not know is that there are actually people from names much much larger than Zend with their fingers in the PHPie; Facebook, Oracle, Intel (recently), and many others, all dedicate some resources and hours to the development of PHP: So the assertion that companies are reluctant to dedicate resources to open source projects is wrong, and hasn't been right for years by my reckoning. The PHP ecosystem benefits hugely from choice, the fact there isn't a single IDE or framework, is actually a good thing. I'm not sure how you think it would be better to have only one. PHP certification will always be worthless. That is all ... pretending was fun ...
Good food for thought. Kinda makes me want to evaluate a few different middleware implementations at scale with / without PSR-7. Would make a mighty fine blog post! I must confess, I likely have diminished expectations for performance coming to raw PHP from the Drupal world, where we've gone all in on abstractions and pray the cache is warm in production. ; )
The article states that you need this separate tool to convert a Doctrine generated query in order to be able to take it directly to a db. The example sql is: SELECT t0.username AS username1, t0.username_canonical AS username_canonical2, t0.email AS email3, t0.email_canonical AS email_canonical4, t0.enabled AS enabled5, t0.salt AS salt6, t0.password AS password7, t0.last_login AS last_login8, t0.locked AS locked9, t0.expired AS expired10, t0.expires_at AS expires_at11, t0.confirmation_token AS confirmation_token12, t0.password_requested_at AS password_requested_at13, t0.roles AS roles14, t0.credentials_expired AS credentials_expired15, t0.credentials_expire_at AS credentials_expire_at16, t0.id AS id17, t0.first_name AS first_name18, t0.last_name AS last_name19 FROM app_user t0 WHERE t0.id = ? LIMIT 1 [1] [] Unless there's something in that query I'm missing, I'm not sure what advantage this tool gives. With the exception of the brackets at the end, this is easily ran at a sql prompt by replacing the '?' with the first parameter '[1]'. It would actually take longer to paste it into the tool, get the result, copy and paste it into my sql prompt than it would if I just did it myself without the tool.
Ikr? And they've done such a lovely job with Java and MySQL
Because?
[PHPExcel](https://github.com/PHPOffice/PHPExcel) is your friend :)
&gt; Personally I think it's because all JS frameworks are inherently a pain in the ass to use, mostly because Javascript itself is kind of a pain in the ass to use Good thing personal opinion can be used as an argument. the same thing can be said of PHP. &gt; ... This is not true. ... It is, think of it this way, you have a one application that does x, you then build another that talks to that applications that does Y, another that does Z and so on and so forth, instead of one app to maintain, with its flaws and its cons, you now have 20.....30.....40.....50....600 (exaggeration but you get the point) to maintain. One goes down they all could or at least the ones that talk to it. There is a point at which Micro services become a joke and there is a point at which monolithic becomes a joke. Its a fine line.
http://www.reactiongifs.com/r/kbh.gif
If you have PHPmyAdmin, you can just download a .CSV which'll load right up in Excel.
&gt; But when you're doing TDD with a fast RGR cycle But writing unit tests in TDD was never fast,you have to write multiple tests for each method you're going to use,for each branch in your code. With BDD ,you write tests for each feature your client expects to be working with the final product. &gt; When your designer changes the HTML markup or CSS class references, your test is going to break, even though it functions properly. Sure , that's called a feature change ,nothing wrong with that. Tests should reflect what is expected. But one design might change less often than classes . &gt; What's going on behind the scenes with this? Is this API just a facade for mocking a request, or is it actually doing selenium-like headless browser stuff? If it's the former, great, that's mostly what I'm talking about in my post. If it's the latter, this is probably going to be to slow to do rapid TDD red-green-refactor development. No i'm not using selenium , this is not end to end testing ,this is integration testing. the input(request) is mocked , the io(file systems,databases) are mocked ,but you test the application stack , not individual classes Read symfony's documentation about testing, it's written black on white. There is nothing more to say about it , just read it.
&gt; What you want is BDD and integration tests, not TDD. TDD allows you to use integrational/e2e tests (Kent Beck called it "Application level tests"). So basicly your approach with codeception is just good old TDD. There is no any rules that says "Only unit testing!". There is a thing like testing pyramid but this is just to optimize feedback time. BDD is not about testing, it's more about reducing costs of translation (by discovering ubiquitous language). When you uses BDD in your workflow, then you firstly need to discuss functionality, write specification and then write tests based on this specification. Currently Behat is only one BDD framework for PHP. It provides you ability to implement each step of your feature spec as separate test scenario. In this case specification just declares flow, and reusable steps checks implementation. Everzet wrote good article about what BDD is and how it could be applied to DDD and integrational testing: [Modeling by example](http://everzet.com/post/99045129766/introducing-modelling-by-example).
&gt; Currently Behat is only one BDD framework for PHP. No , you can do BDD with any test framework.BDD doesn't mean one has to use Cucumber or Behat, You can totally do BDD with PHPunit . &gt; There is no any rules that says "Only unit testing!". There is a thing like testing pyramid but this is not related to TDD at all. The author of the post never talked about integration testing , that's what I suggested it instead of unit testing.
I don't get it? it's a framework that knows what you want to do? you just push data to it and it knows that data represents subscribtion plans? You push a yearly plan and it recognizes it and changes the UI? What is this magic? edit: nvm, just a "framework" with plans included for some reason... shouldnt have skipped so much :) they aiming for startups or something?
To expand on this, you probably have something in your site that accepts image uploads. In this case the attacker uploaded a valid image with a .php extension, so your app probably isn't checking the extension. When saving the image to disk, always force the file extension to be what it should be. That way the file will be served directly to the browser instead of being executed by PHP.
Yes, a can do BDD with any testing framework, but Behat isn't testing framework, it's BDD framework, that what i trying to say. &gt; that's what I suggested it instead of unit testing. I see. This approach (with integrational and E2E tests) also called ATDD (Acceptance Test Driven Development).
&gt; What I don't like, is when people make a framework, don't know what they're doing at all, and then say it's better than X, Y, or Z when it's clear it's not. This is what I have seen, this is the majority of the backlash, which is acceptable. &gt; If they presented their framework as a learning experience for themselves, with a request for critical feedback, then I'm sure it'd get better reception. This is how I would approach the situation.
ok
Every framework has its strengths and weaknesses. For an active developer, there is often occasion to take different paths at different times. There is even the occasional client who wants you to roll your own for whatever reasons they deem appropriate to garner their money (Government, Private Enterprise, etc.). The only problem I see created by so many great off-the-shelf tools is that now everyone thinks they are a software engineer, and many 'programmers' aren't very good at programming to begin with; failing to understand basic concepts and unable to roll their own if they wanted to. I've seen so many cases of a client hiring a 'webshop' to build them a system (web "app") only to find themselves six months or even a year later with a half-baked product full of holes, bugs, and more. More and more often, we [myself and industry associates] hear stories due to a developer's deficiency passing the blame onto a framework's deficiency. A client will say, "The last guys we hired said we couldn't do 'x' because of 'y'" where 'y' was the fact that some framework 'didn't support'. Obviously it is not the framework's fault but this kind of thing happened so much less often before the days of having so many frameworks to choose from. The truth to this story is that the developer probably wasn't that good to begin with and didn't know how to add functionality to their chosen framework. We've seen this time and time again since the mid nineties but the complaints have shifted from "the guy we hired doesn't know what he's doing" to (previously stated) "the guy we hired said his system won't support 'y'". Using a framework is great! Use them. Learn from them. Dissect them and reinvent the wheel as often as you can! It will only make you a better programmer. But never discount the power of a competent programmer rolling his own. And if you are hiring a team to build something for you, just make sure you hire the right team that can make outside-the-box customizations happen without compromising security or functionality. And most importantly, a team that can get the job done without draining your budget like a leach. A final point, anyone that says rolling your own is bad is likely some sort of "integration specialist" and not an actual software engineer. The whole point of becoming a programmer for most *IS* the ability to roll your own. Programming languages wouldn't even exist if it weren't for this thirst for knowledge and power.
&gt; But writing unit tests in TDD was never fast If it isn't fast then there is something with your code. This is the one of the most valuable things in TDD (this forces continuous improvements and refactoring). If you write CRUD or transaction scripts, then yes, unit tests will never work for you this way. But you you a DDD guy, then you don't have a problem to get 100% cove coverage of your domain layer via unit tests. Anyway supporting unit tests usually less painful than supporting E2E tests. 
Thank you! The worst thing is that this upload can only be done by an administrator of the site. 
If you want to see an app made from scratch with BDD (Behat) (which seems like what you're looking for), see [Sylius](https://github.com/Sylius/Sylius/) (and its [features dir](https://github.com/Sylius/Sylius/tree/master/features)). [Here's an intro](http://www.sitepoint.com/bdd-in-laravel-getting-started-with-behat-and-phpspec/), too.
There's no log :P I didn't make this site but the security is unacceptable.
The naming choice is not very good, there exists a somewhat popular/well known open source software called [foreman](http://www.theforeman.org/) already which also has a [Wikipedia article](https://en.wikipedia.org/wiki/Foreman_%28software%29).
pretty sure its a scaffolding on top of laravel so it pretty much handles all of the repetitive code generation that goes into making a SaaS application.
That's... a fairly specific app to have as a reusable platform. I'm not saying it's a bad idea, but it's a bit of an eyebrow raiser. I can't say if there's a market for it. I guess depends on how far the customization goes.
&gt; full support for PHP 7 type declarations Not for me https://youtrack.jetbrains.com/issue/WI-28283
Thanks a lot!
Just for fun. I figured most people would be against it since in my experience, open source projects can attract anti-corporation types. I was a CS major and most of the people loved Linux and open source projects, and hated Apple, Microsoft, Oracle, etc.
Managed is probably a better word than owned in this case. I'm not saying the other frameworks, IDE's, or PHP implementations should be killed off. I only thought it might be good to have an "official" source. Especially when you're just starting off, it can be overwhelming trying to figure out which framework to use. (Also, I think Zend Framework 2 is terrible, I'm not trying to promote it.) My issue is not with PHP itself, but the frameworks. I built a few websites in CodeIgniter and the project became stagnant and looked like it might die. Now I don't trust any framework to stick around since they seem fall in out of fashion so often. I'd be much more trusting of a there was an "official" PHP framework. A more focused effort on a single framework could improve adoption of PHP too. It seems the development of ASP.NET MVC has increased adoption of .NET for web development. I imagine if Microsoft didn't create the framework and left it up to the community, you'd see less websites being run on .NET.
I'm actually the one who reported that issue when testing the last EAP build. I was hoping they would fix it for the official release, but apparently not.
Super stoked with auto $this-&gt; on variables and methods. I waited for it so many years!
Interesting benchmark :) Could you please give us detailed information about what and how you've tested? For example the code of the Servlet and the Symfony Action, so we're able to fully understand the result of your benchmark? Thanks
And that's how trademarks came to be a thing.
In testing, a **unit** is "_the smallest testable part of an application_". Functions and methods are the smallest testable part that are sane to test, so they're generally the targets of unit tests. When you're testing the behavior of multiple units interacting, those would be integration tests.
Now try it again with a dozen parameters, where few of them are several kbytes of text.
Well, maybe it is 'safe'. But say you put a large file there on accident, it will be running the whole process on the server. Safe probably isn't the right word, but I think you know what I mean. Also, you'd have to make sure the permissions are set properly, but that's a given with hosting. Now it would be interesting if you could somehow have the unzip be copied into the correct directory. That might be pretty useful IMO. So unzip from directory to the proper directory you want it to go to... I don't know if I would have a use case for that, but it might be useful.
Technically it is backed by a corporate entity. Backed != owned. Zend offers its own PHP builds with extended support and all the jazz.
Also [http://spark.apache.org/](http://spark.apache.org/) is a pretty well-known thing. But most everyday words are already used by some project, so sometimes you just have to say "eh, fuck it".
Rapid? I think Javascript iterates faster then PHP does ... 
But then from the name, one might expect Spark PHP to be a project that makes Apache Spark work with PHP in some way. Either way, I don't expect this to cause any significant amount of confusion.
I think for your first open source project this is really good, while the code and that might not be up to snuff, you have plenty of time to enhance that and the community might even be able to help you with pull requests and what not.
oh 8500 usd a month... yes I am looking for contract work ;)
Apparently you're unfamiliar with the vast amounts of changes that has been made to PHP in recent years. https://wiki.php.net/rfc Knock yourself out. 
This sums it up nicely: https://twitter.com/JacobBennett/status/631221227164704768 Go ahead and customize away.
Years. Being the word, Where as it seems with other languages - again I use Javascript as my example - changes happen in months, they might not be stable or as secure but they make there way into production faster then say php7 alpha or beta ... 
This is why you use `move_uploaded_file()` and then GD to reprocess and resave your images, kids. Any attempts to validate extensions or MIMEs should be for user experience purposes only - they are not security barriers. EDIT: Fuck, apparently even resizing / re-encoding can be bypassed in PNG files..... https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/
Its not PHP, but the [Rails Tutorial book by Michael Hartl](https://www.railstutorial.org/book) builds a whole twitter-like app and builds tests in from the beginning. Reading through it might give you some examples how a non-trivial web application would be tested.
That explains a lot. Does that intro exist elsewhere (in text or video form)?
You didn't check the link at all, did you? The language changes month after month. What you have there is the accumulated changes over a number of years. Also, JavaScript changes a lot less frequently than PHP does: https://en.wikipedia.org/wiki/ECMAScript#Versions
Spark is not a platform, it's literally just a pre-scaffolded application, the way Twitter Bootstrap is pre-built CSS. Since it's local only, you can customize it however you want. It just gets some of the common aspects of SaaS applications out of the way for you (auth, password recovery, two factor auth, team management, subscriptions), the way Twitter Bootstrap gives you a grid so you don't have to implement it yourself (among other things). Out of the box of course it's not going to be a perfect fit for everyone, but that's why you can customize what you need. It's not a service like Laravel Forge or Envoyer are. If you want to strip out everything except the two factor auth? Go for it. If it suits all of your needs and all you have to do is slap some CSS on it to make it look distinct? Great.
I will be giving it again at Laracon EU in two weeks. I believe they are doing video there. I didn't want to publish it out yet because I don't want to ruin it for my European friends. :)
A hex editor doesn't really make reading that any easier. Here's GVIM: http://i.imgur.com/zER59Pm.png (See 3rd line from the bottom.)
Let me add some fuel to the fire: - large companies get stuck with frameworks over time. For example, if X corp is using Cake or CodeIgnitor and have 10 systems written in it and employ 14 programmers, it is very difficult for them a) to move to Laravel and b) eventually find good Cake/CI developers. So for some companies, writing their own frameworks protects their code-base and future-proofs it. Note it is not very difficult for experienced programmers to follow best practices and build a framework that evolves over time, and they will typically look at a lot of code to decide how to implement their own version or possibly borrow code from existing frameworks where they can. - here is a much more controversial argument. PHP got popular by being easy to use and this led to some very bad code but also some very good code. As it got popular and started winning the battle (and over time) the Perl guys came across, the Java guys came across and the .NET guys came across. Some of these guys wanted features from their old languages so they developed frameworks containing these features and shoe-horned a lot if new PHP developers into using the new frameworks and features. While some of this may be good, it also may fundamentally change some of what made PHP popular in the first place. You could argue PHP followed the Unix philosophy and C philosophy and keeping things simple and letting simple components talk to each other to build complexity and you could argue we are rapidly moving away from that model. Note I have used combinations of all these technologies and firmly believe PHP is getting better and more usable for big complex systems but that does not mean I love all these new frameworks influenced by Java and .NET. 
I've started a full rewrite of a really old application, and from what I've seen in this video, Spark can probably save me a tremendous amount of time. I read somewhere that it's supposed to get released in a month or so, so, my question is, would it be risky to start using it right away for a live website? Thanks! 
&gt; arge companies get stuck with frameworks over time. For example, if X corp is using Cake or CodeIgnitor and have 10 systems written in it and employ 14 programmers, it is very difficult for them a) to move to Laravel and b) eventually find good Cake/CI developers. So for some companies, writing their own frameworks protects their code-base and future-proofs it. Note it is not very difficult for experienced programmers to follow best practices and build a framework that evolves over time, and they will typically look at a lot of code to decide how to implement their own version or possibly borrow code from existing frameworks where they can. I assume the ones that are able to grow over time and the ones that are fully fleshed out turn into the Zends and Symfonies? That eventually get open sourced? My way of thinking if that if you build a framework you use for your product and then if it works then you abstract its concepts away and release it. I don't see a lot of companies that do manage to build their own frameworks or cobble together their own do this ... the open sourcing part. It would help the community grow a lot more. IMO 
Correct, it is not. 
How would you do this in any language? This has been done numerous times. Here is an old example I'm fond of in Ruby: https://github.com/Sophrinix/TryRuby You basically want to `sandbox` uploaded assets and then allow code to run within the sandbox through an interpreter (that has been limited to allow "safe" actions). This has probably been done before in PHP. Since you didn't use jargon such as "sandbox" I suggest you start you're google quest there for answers. And look to previous examples of interactive web based interpreters to gleen how others have done it (in any language). Then from those ideas go hog wild.
Here is the security check part of your code: https://github.com/samayo/bulletproof/blob/master/src/bulletproof.php#L365-L372 [`getImageMime()` relies on `exif_imagetype()`](https://github.com/samayo/bulletproof/blob/master/src/bulletproof.php#L105) to validate the mime type of the image. [`exif_imagetype()`](http://php.net/manual/en/function.exif-imagetype.php) only reads the first few bytes of the file to determine its mime type. You can easily spoof this by constructing a file with the appropriate initial byte sequence. [There's even a cheat sheet for it.](http://www.astro.keele.ac.uk/oldusers/rno/Computing/File_magic.html) Thus you can create a fake file that LOOKS like a jpg/gif/whatever, and it will fool `exif_imagetype()` despite potentially carrying malicious code elsewhere. `getimagesize()` isn't going to stop anything as evidenced by this post: you can embed PHP in the EXIF data of an otherwise perfectly valid image. The only safe thing to do is scrub out the EXIF data by resaving/sampling the image, prior to exposing the image to the user. But even then apparently there are ways to bypass that with PNGs.
This is pretty awesome, generally I turn on the query log for mysql.
What's wrong with a contact form plugin that works with AJAX out of the box?
The problem is PHP can do pretty much anything it wants on the server, from sending your password file out to an attacker to removing all of the files. You can mitigate this somewhat using permissions, htaccess etc. but it is still a huge risk to give to a user unless you try to sandbox it in some way (so they can destroy the sandbox but little else). Heres one suggestion: http://php.net/manual/en/runkit.sandbox.php Another suggestion would be to use docker containers for each user that wants to run the html/php combo - basically you would create a docker container with a light webserver and php dynamically for each user session, route the users code to run inside that container only and maybe have the output be displayed in a html frame from that server, and then destroy it when it ends. Of course this might be a resource hog on the server if you have lots of users. 
Often the hacker who finds the exploit sells that IP address to a different group who need lots of exploited servers to host content or send denial of service attacks. You can make good money selling exploited servers, allegedly!
This is an interesting approach, thanks for sharing. Another technique is to isolate your tasks into workers (persistent php processes), which can be managed more generally (eg Python's SupervisorD which just keeps them running) and a message broker (AMQ, RMQ, Redis) to handle communication between them. A difference in this approach is there is no 'manager', just workers (one or many of a given type, which can be distributed across many machines if required) that wait for a job to do and pass it along, perhaps to another worker or maybe they are the end of the pipeline. No manager means you don't need to write a managermanager to manage the manager ;) By isolating your functionality into discrete workers that do one thing, it's easier to test it does what it's supposed to by mocking the input and testing the output, functional tests rather than unit tests. ps: editing cause this is, I'm fairly certain, my first ever Reddit reply (long time listener, first time caller)
It's free. 
Exactly. I think that's the brilliancy of this. Even if it doesn't cover a specific use case, you can make adjustments to do so. Of course, that's assuming it's flexible enough but knowing Taylor, I'm sure it will be.
Wtf?
Do your thing man. I have a private repository called exactly the same thing doing business process management. When I release it, I'm sure it will be called foreman... A lot of my domain specific language is built around a foreman coordinating activity-based workflows and tasks for workers. Will check this out at some point. 
One thing I *really* want from PHPStorm is better keyword color handling (e.g. different colors for *public* &amp; *static*)
Here's a video of the Keynote for anyone interested: https://www.youtube.com/watch?v=uOU_N8PNOD8
Don't assume you'll always be able to reliably detect malicious code in an image. You should ASSUME IT CONTAINS MALICIOUS CODE, which is why you use move_uploaded_file() to a non-web accessible directory, and give it a random, unpredictable name. Then you use an image library to re-save/re-sample the image to strip out EXIF data. It's naive to think you can just open the file and look for `&lt;?php` or similar code.
His goal was to reduce the amount of time required to get you to programming the meat of your application. Yes, a lot of this is easy stuff for most divs, but to be able to run generate:spark and have it set up auth, a powerful billing platform, roles, etc. and have simple, extendable code in place to build on is going to be absolutely helpful for Laravel users. It appears to be really well written too. Laracon was rad this year! 
That's not really the issue. The issue is that someone managed to get code onto the system and access it in such a way that they could exploit it. As [ircmaxell](http://blog.ircmaxell.com/2014/10/educate-dont-mediate.html) puts it, this just "masks" the problem. There was also another post on here a while back that explained how futile it was to attempt to disable all of PHP's potentially "dangerous" features. It's really not a substitute for ensuring proper server configuration and input handling.
Yeah, I asked about this on Twitter but didn't get much of a response. The theming support seems so far below something like sublime.
Just get PHPStorm unless there's a specific reason you need Java support.
What kind of issues? Traits seem to work fine for me.
Thanks! This is the sort of answer we're looking for. What do you think of this article? http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/ Not all of us are highly experienced PHP developers, and we're considering switching for the sake of avoiding the issues stated in the article, regardless of whether or not an expert is comfortable with them. 
I don't know if I can put aside time to join in coding but I can at least review your code and give suggestions 
I swear that article is the Python/Ruby/Java/Go developer's national anthem. The reality is that nothing enumerated in that article will *actually* get in your way. PHP has quirks. Maybe a few more low-level quirks than other languages, but quirks are easy to overcome, and when you use a framework, you are exposed to FAR MORE framework-level quirks than language-level quirks. Kind of like a fart in a hurricane. I've been developing with PHP for a long time, and that article basically sounds like the guy got tripped up by a couple gotchas, then went out deliberately looking for problems with a bug up his ass about it, and decided to quit PHP instead of just getting over it.
Edit: sorry, I misinterpreted OP before I wrote this: &lt;?php class ParentClass { public function a(){ return 0; } } trait TheTrait { public function a(){ return 1; } } class ChildClass extends ParentClass{ use TheTrait; public function a(){ return 2; } public function b() { return parent::a(); } public function c() { return ParentClass::a(); } public function d() { return TheTrait::a(); } } $foo = new ChildClass; echo '&lt;pre&gt;'; print_r([ 'public function a(){ return 2; } ' =&gt; $foo-&gt;a(), // 2 'public function b() { return parent::a(); } ' =&gt; $foo-&gt;b(), // 0 'public function c() { return ParentClass::a(); }' =&gt; $foo-&gt;c(), // 0 'public function d() { return TheTrait::a(); } ' =&gt; $foo-&gt;d(), // 1 ]); echo uniqid(); ?&gt; 
Thanks so much! This is EXACTLY the sort of answer I was looking for 
Thats the impression we're getting! Thanks for the helpful advice
I think naming collisions are not a problem in general, but if there is a Wikipedia article, the name is burned. Naming software after well known other software is bad, you should not release software that is called [Firebird](https://en.wikipedia.org/wiki/Firebird_%28database_server%29), [Firefox](https://en.wikipedia.org/wiki/Firefox) (that by the way was called Firebird until the older Firebird was "discovered"), [Symfony](https://en.wikipedia.org/wiki/Symfony) or [Composer](https://en.wikipedia.org/wiki/Composer_%28software%29). It will be enormously harder for your users to find information that is related to your software and not the more widely known other one.
That's reasonable, I just never heard of Foreman before.
You can find ridiculous edge cases in any language... Your example shows nothing for comparison sake. Why are you using ints as string keys anyways? The amount of edge case bullshit you have to know to write Java is just as ridiculous, and it takes twice as long to get anything done.
tl;dr: Don't bother trying to make this "safe" at the PHP level. You need to sandbox it at the OS level. I once did a similar thing for an IRC bot (supporting multiple languages, including compiled ones). It involved setting up an LXC container with **no internet access** (I just used an iptables rule for that), then the outside server passed the code into this container. Inside the container, a script (running as a user I'll call `manager` here) put this code into a file, and executed the file as another user with `sudo` (I'll call this user `runner`). This `runner` user could only write to own home directory and to `/tmp` (this was chceked with `find`). The `manager` user then monitored the process and killed it after 5 seconds if it hadn't finished by that time. After which it killed all of that user's running processes and deleted everything in the `runner` user's home and in `/tmp`. The output was returned from inside the container back to the host server and then back to the user (bot). There was also some rate limiting involved. Also the container had fairly strict memory limit and all that. Plus the fact that only a very few people knew/cared about the service.
One thing we do, we have stuff running on a bunch of servers, composed of multiple applications often communicating with each other. So in order to make sense of this, we use a fairly typical ELK setup - ship logs to a central server, process them with logstash, so that we can view (and search/filter/analyze/visualize) them in Kibana. We have a few dashboards there for tracking errors and other probable issues. One nice thing with PHP is that you can use the LogstashFormatter with monolog, which will then make all the messages available in logstash format - no grok patterns necessary. All the structured context data (the second argument in the PSR-3 interfaces) will be available as separate fields in Kibana. With numeric data, we can then view averages, maximum values in a certain time period, filter on these fields, etc. In addition to PHP logs, we also use Apache access and error logs and a few others. These are "connected" to the application logs via Apache's `mod_unique_id`. A unique id field is generated and added to every request in the Apache access log, which is then also added to every event in the PHP logs. If the PHP application makes a request to some other application, this unique id is sent along with it, so that we can then get a picture on the whole related group of events (logs from multiple applications + the apache logs) by filtering on that particular request id.
That's pretty clever.
&gt; If we don't reinvent the wheel do we ever learn how the big frameworks work? Its a fare point. I would say that some people must build new frameworks, and fail, for some to succeed. Its like evolution, the fittest survives and there will always come another one, being fit and trying to get the throne of frameworks. &gt; Why is it in some situations people experience a negative back lash at the concept of "rolling your own" Its like a spinal reflex. You say "Cherio, I built my own framework doing X!", they say "Why? There is a framework doing X-ish, why didn't you use that?". Instead they could have said "Good for you!" and then asked you questions about your framework, what you achieved and learned. But this seldom happens. its so much easier to just state "Why? There is another solution out there. Use that." Its basically how we react and respond to these thing. Then, there are these issues around building own code, as a poor programmer. It will be poor code. But on the other hand, if you are an awesome programmer you will build awesome code. Maybe people start by thinking that you are a poor programmer so your framework must be poor. Sometimes thats a wrong assumption. Its also a marketing issue. I wouldn't sell me new framework with "My new framework", I would polish it, relabel it, to avoid that standard comparison of "Hey, someone else has already done that". I know, I just done it better. &gt; Do you learn anything from just reading the source of the larger frameworks? or do you learn "their" way of doing things? Sure. I read a lot of code and code sample before doing my own solutions. Learning from others seem like good practice to me. I did study the Phalcon API (PHP Framework built in C) and reengineered its core to my own PHP framework. A fun exercise and my intention was to use it for education of programmers. I learned a lot and it works alright. So, the obvious standard reaction to this would now be... "Why didn't you use Y-framework instead?" Thats just how we react to things. 
Write to syslog or to a file, and let rsyslog redirect it wherever you want it to be.
I always find these posts amusing, especially as they are basically all the same thing which is "lol php type conversion sux". Then they cite /r/lolphp despite the fact that most threads there have someone commenting explaining why it's happening and provide a good reason as to why it's happening. I've been working full time as a PHP developer for several years and used it for many years before that, I work on projects that PHP really wasn't intended to be used for (so, far more than just simple CRUD apps) and I have never run into these situations that get mentioned. Funnily enough, I don't make arrays with numeric strings of keys then require strict comparison against them. What is the use case for that? Nobody is arguing that having these quirks is a good thing but that is all they are, quirks. &gt;The language is riddled with endless gotchas and edge cases like these. It just simply isn't, you can find them if you go looking for them but it's highly unlikely that you'll just stumble across them. 
its also remind me about codeigniter spark :D
Exactly : PHP is secure out of the box, but if you let users upload anything to your server you're screwed no matter which language you use.
Hi Christopher, appserver aims to be built against well documented interfaces and will therefor be using PSRs suggested from FIG. PSR-7 is on the way ;) https://github.com/appserver-io/appserver/issues/832 Also have a look at the other interfaces appserver.io exposes: http://appserver.io/get-started/psrs.html
That's not a true, or a good comparison. They didn't ditch php to use a framework built on php, they wrote a new, from the ground up, which resembles php. Then they ditched php and used their own interpreter. 
&gt; Kind of like a fart in a hurricane. You sir, have made my day!
&gt;But the reported problem isn't a problem of PHP as a language... Have code embedded in arbitrary content? Ability to specify the *file to be executed* over http? Not a problem of the language? Sure, workarounds exists, but that does not make it NOT a problem of the language.. 
We have a similar setup (ELK stack) here. One thing I wanted to plug is Monolog's FingersCrossedHandler. This allows you to log all messages (debug, info, ...) of a requests in case you hit a given severity (e.g. error). It's a very nice way to keep you logs clean from debug messages unless you're really interested in them. &gt; A very interesting wrapper. It takes a logger as parameter and will accumulate log records of all levels until a record exceeds the defined severity level. At which point it delivers all records, including those of lower severity, to the handler it wraps. This means that until an error actually happens you will not see anything in your logs, but when it happens you will have the full information, including debug and info records. This provides you with all the information you need, but only when you need it. https://github.com/Seldaek/monolog/blob/master/doc/02-handlers-formatters-processors.md
From the example code that you provided, i assume that you are the one who handled the id *i_make_snow_flakes*. Hows life pal ?? Oh, yeah and Array Implementation sux in php. We do need better datastructures in php. Had a weird array issue the other day :-P
This looks so bad :-(
I haven't seen any other modern language that works in this fashion (for example Python uses wsgi and uses a callable object as interface to web application, and as far as I can see, it worked in a similar way even in the mod_python days). So, I am not aware of other languages that do this, but please do share if you know one. 
Yeah, I think that one is also used in the default Symfony production config. It would be even better if it supported separation between the activation level and a new "log all these things anyway" level. Example: I want to log all INFO and higher level messages, but if there is an ERROR message, then give me all the DEBUG messages as well. I don't think it can currently do that, it's more of an all-or-nothing thing. Still pretty useful though.
&gt; I always save the file with a sha256 hash of its contents plus some other stuff, with no extension. And that helps how exactly? (Unless you explain "stuff" your comment doesn't make much sense...)
&gt; actually get in your way This is the wrong attitude for a developer. The issue isn't "things that get in your way" but doing things correctly and safely. A programming language should not enable/encourage certain behaviors by its own design.
&gt; (e.g. different colors for public &amp; static) I am using Idea with PHP plugin, but I would assume PHPStorm has the same options like this: http://i.imgur.com/q8Ykamt.png Or are you referring to something else?
I wish that was the case. I changed the names for the purpose of this post and mistyped it. My package: "autoload": { "psr-4": { "SideKick\\Base\\": "src" } } My L5.1 App: "require": { "php": "&gt;=5.5.9", "laravel/framework": "5.1.*", "cartalyst/sentry": "dev-feature/laravel-5", "doctrine/dbal" : "2.5.*", "SideKick/Base": "dev-master" }, "autoload": { "classmap": [ "database" ], "psr-4": { "SideKick\\": "app/" } }, My L5.1 App: use SideKick\Base\Databases\Eloquent\RepositoryEloquent; class TenancyRepoEloquent extends RepositoryEloquent implements TenancyRepoInterface { public function __construct(Model $tenancyEloquentModel)
Have ran 'composer dumpautoload' ? 
Java has lots of frameworks for webdevelopment but just a few are widely acceptable. This unifies the creation of tools and increases the ecosystem of these frameworks. The huge fragmentation of php tools ( thank u composer for fixing this) is what makes the language weak in some aspects.
Here's an example. These are two different themes, but you should get the idea. PHPStorm - http://i.imgur.com/P1JLGLY.png Sublime - http://i.imgur.com/AzzOA6z.png Notice how public &amp; function are the same colors in the PHPStorm version. It's not possible (at least to my knowledge) to change this. I'd love to use some Dayle Reese color schemes, but most of them don't look right because of the way PHPStorm handles keywords.
&gt; We have about half a year of work done but most of it doesn't work for reasons unknown That's a rather worrying statement. I'd prioritize figuring out these "unknowns". Seems like the choice of language is not really the problem here.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [Uploading image with PHP code in metadata executes that code when image is being saved.](https://np.reddit.com/r/lolphp/comments/3guasl/uploading_image_with_php_code_in_metadata/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Yes same as namespaces. \SideKick maps to app (laravel app) and \SideKick\Base maps to a src folder in a package. The package works standalone. So does the app. But I can reference the package from the app.
Ah, when you said "public and static" I thought you meant the color of those public functions and static functions. Yes, you are correct, there is no way to change the color of `public` and `function` to be different. In the color editor when you click on either they both reference the "Keyword" color
Since you have `Sidekick` mapped to `app` but `Sidekick\Base` mapped to `src`, I suspect that composer is using the former for autoloading. It's looking for `app\Base\AbstractRepoClass.php` instead of `src\AbstractRepoClass.php`.
I'm honored you have decided to make your first reply ever in my post, after more than a year. I have given this a lot of thought... and I've realized you're right. I'll make a centralized queue, but I'll make persistent workers (instead of a persistent manager). This will allow for better responsiveness, flexibility and horizontal scalability. Thank you very much for taking the time to read through my project, understanding what it did and posting a suggestion. I will move what I had planned for 0.2 to 0.3, and will start on the actual 0.2 version with your suggestion tonight. I got great feedback from a lot of people (curiously, many people felt like messaging me privately instead of replying here). I can't even begin to tell you how thrilled I am that people actually read what I did and are taking time to message me. Thank you.
Alfred
Yeah I could have worded that differently :D
Oh... I didn't realize it focuses on a window if you type chrome or the like. :) Thanks
this statement was more of a "we have to clean up messes older members left behind" sort of deal : /
I would love to also get a quick overview showing what needs to be done to port C extensions to PHP7. Aside of the fact that some parts of our code depends on some very old, no-longer maintained extensions (http://sourceforge.net/projects/saprfc/), I'd also like to help with those we're using that are still being maintained.
Assuming the dev in question already knew the other language, I would agree with you.
I don't know how current [these](https://wiki.php.net/phpng-upgrading) and [these](https://github.com/php/php-src/blob/master/UPGRADING.INTERNALS) are, but it should get you started I guess. edit: Added 2nd link
&gt; Its like a spinal reflex. You say "Cherio, I built my own framework doing X!", they say "Why? There is a framework doing X-ish, why didn't you use that?". The key parts of that whole sentence is: X and X-ish. This is why custom frameworks are built because X-ish is not good enough. Yet when people do this, the bask lash happens because apparently X-ish is good enough at least to the community. &gt; Instead they could have said "Good for you!" and then asked you questions about your framework, what you achieved and learned. But this seldom happens. its so much easier to just state "Why? There is another solution out there. Use that." But why? we are a community that should foster and help people grow and be happy for what they develop. Sounds like a a lot (in some cases) of jealousy. &gt; But on the other hand, if you are an awesome programmer you will build awesome code. Said no one ever. No one builds "awesome" code. We build what we think is awesome code and then we have the community rip it to shreds (dramatics) and we improve. &gt; Maybe people start by thinking that you are a poor programmer so your framework must be poor. Sometimes thats a wrong assumption. Expanding on the above point, people who don't know people don't trust people. Think of Paganism and Salem, Witch trials 101. To get known you have to form a community foot hold and then from there you introduce small tools and ideas and controversial topics. Its the same concept with frameworks, Frameworks start small and do one thing good and then they get known and they expand and so to does the community around said framework. &gt; to avoid that standard comparison of "Hey, someone else has already done that". I know, I just done it better. Why if you have done it better, then state that. Create documentation that shows the difference. Create case studies, bench marks and use cases for why yours is better then mine. &gt; I did study the Phalcon API (PHP Framework built in C) and reengineered its core to my own PHP framework. A fun exercise and my intention was to use it for education of programmers. I learned a lot and it works alright. So, the obvious standard reaction to this would now be... "Why didn't you use Y-framework instead?" Maybe I am not most people, but my reaction is - can I see it?
&gt; People aren't enthusiastic about all the javascript stuff either. You are picking strange examples like Laravel and React to compare to your own framework that apparently nobody likes. None of this is strange and no one said my framework wasn't liked. All of these are examples of fast moving products and services being supplied to the community and widely accepted. the argument is that things such as the example tools (minus my framework) are widely accepted the second they hit the door. How ever if you went out and built a framework tomorrow it would not be widely accepted. &gt; Looks to me like you are trying to avoid being bashed or ignored. So looks like you want praises or at least attention. However, I stick to my previous point. Looks can be deceiving. I want nothing of the sort. I want to understand the reason behind why people are discouraged, in the PHP community from writing their own frameworks where as other communities like Java script its almost a right of passage. &gt; praise and/or attention then make something new, different, or better. Again, see above statement. There is no "Attention seeking" going on here. Its simply a study of the minds of the people who live in the php world compared to other languages. 
I am the architect of my company's framework, and the reason why it will never be open sourced is because it contains so much proprietary and domain specific processes that it would feed our competition without providing any value to the general public. The frameworks that companies write don't do what you think they do. You don't need our routing or template engine, there are hundreds of others you can pick from that people made as part of a university project. We're a tiny outfit but we are able to voraciously compete with the big whales because of our software. If they got their hands on even half of what our code is capable of doing in this industry/domain then it would remove our competitive edge. This is an industry which is still oversaturated with people whose 9-5 is stuffing shit into Excel. We get business because we can do with a handful of people in a few hours what normally takes multiple teams of people weeks to coordinate. Basically, the only *component* I could release to the public would be my data.frame implementation... which anybody with even base familiarity with data structures and algorithms could create, releasing the EDI components would get me smashed with such a fucked up lawsuit that my great grandchildren would be paying it off, and the rest which pertains to various billing systems, state workpapers, and insurance processes really doesn't affect anyone except our competition. The whole framework just to satisfy the curiosity of some people on the internet? Okay.
&gt; I am the architect of my company's framework, and the reason why it will never be open sourced is because it contains so much proprietary and domain specific processes that it would feed our competition without providing any value to the general public. This right here is the reason why the community cannot grow or foster new innovations. Not saying you are to blame, its the mind set of the company and maybe the developers inexperience at abstracting the common from the specific and releasing the common. This is why I hate languages like Java and PHP (sometimes) because there is so much of this "domain specific" and "competitive edge" going on. &gt; The frameworks that companies write don't do what you think they do. You don't need our routing or template engine, there are hundreds of others you can pick from that people made as part of a university project. So if they are not typical what are they? Balls of mud cobbled together by developers that hope and prey they do what they expect it to do? With out tests to validate their hopes and prayers? &gt; If they got their hands on even half of what our code is capable of doing in this industry/domain then it would remove our competitive edge. My first point rings again. Loudly this time. &gt; releasing the EDI components would get me smashed with such a fucked up lawsuit that my great grandchildren would be paying it off Getting louder. (This time on the concept of components.) &gt; The whole framework just to satisfy the curiosity of some people on the internet? Okay. No, to educate and help the community evolve. I feel like companies like yours, no I am not bashing you directly I am against the mind set of the company, hinder the growth and the ability for the community of an open source language to grow and evolve and writing our own frameworks and sharing them under what ever license is essential to helping the community foster innovation. We are not Microsoft (pre open sourcing .net - so 1995), we are a community of developers, hackers and people who think in data structures and routing to name a couple of things. We are innovators and inventors. Yet we cannot abstract the common, so in this case the underlying framework, from the business (in your case the billing and the what not ... ). 
Agreed.
Cry harder.
One of the other devs here - I think one of the main reasons we didn't have any of this stuff in place is because the first version was literally just a guy at uni making it to learn the basics of PHP (in fact, I think that's where most of our team started with this project). Then it got bigger than he expected, people signed up to help, ore and more got added... which eventually prompted the rewrite because we realised things just were'nt making sense anymore. Since it's a volunteer project and not really intended to be "commercial" I think we slipped into the mindset of "eh... this is what bug reports are for". Luckily releasing the rewrite as an alpha has given us a bit of a kick up the backside with this stuff and the older/more experienced team members are putting our heads together to try and figure out proper testing procedures and stuff. Not really an excuse, but it's a little insight - none of us knew what we were doing to start with :P
First, I'd consider asking this somewhere other than /r/PHP if you expect an honest answer. People subscribed to /r/PHP are here for a reason. Second, some real talk. PHP was the first web development language I really picked up. We're talking *in the late 90s*. It was wonderful at the time, and for all of its quirks, was so much more enjoyable than ASP or Perl. A few years down the road, the world had moved on to bigger and better things, but PHP hadn't. Languages/frameworks were starting to do some serious handholding, and PHP was still the land of unorganized code where nobody was going to stop you from making terrible mistakes--whether we're talking about application design, security, portability, whatever. A lot of people moved away at that point. Professionally, I shifted to .NET early in its life, and then to Rails in the pre-1.0 days. Ruby, as a language, was a lot less haphazard. Rails did a lot of the grunt work for you, went out of its way to keep you from making some basic mistakes, and was, comparatively, a joy to program in. It was head and shoulders above PHP in terms of everyday use the way PHP was head and shoulders above CGI. The problem with these kinds of articles is *that* is the PHP they remember. They remember thousand line files, echoing out HTML, no classes, no dependency management, every function named completely differently with parameters in different orders, and having to manually escape everything for SQL injection. These people think of PHP as Classic ASP's slightly more tolerable cousin. And that really was PHP for a long, long time. Today, it's practically a different language. The latter half of PHP 5, combined with one of a myriad of frameworks, is easily feature comparable to what any other language out there has. It's performant, widely available, reasonably secure, easily maintainable and only mildly irritating to program in. You will absolutely run into baby fat where functions are named illogically, or there are 10 functions that seem to do almost the same goddamn thing and it isn't clear which to use, but it's not like it was in the PHP 4 days. Anyway, bottom line, it's totally fine. I've been back working in PHP professionally for about a year now. I'd still rather be using Ruby, but that's a matter of experience and personal preference at this point. There's absolutely nothing wrong with PHP, and switching for the sake of switching is insane.
really? seriously? how shitty of a programmer do you have to be to want to rely on an IDE to insert $this-&gt; for you? /mind blown
&gt; How is PHP's OOP better equipped? What do you mean by "better" in this case? &gt; For example Python's (and Ruby's) OOP is similar in expressive power to CLOS and there are no more expressive ones than CLOS. (Java's is much less expressive, for example) Type systems better suited for large-scale OOP are those that make app code more *stable* by means of providing more *statically verified invariants* like a nominal type system with type hints, interfaces and implementation compliance checks and so on. Large scale is not about "more expressive". "Expressive" has become a way to say "has fancy specialized syntax for this and that". Terseness of syntax is a trivial concern at large-scale. But ensuring invariants is critical. I can't think of anything more expressive than a dynamically typed script with objects, functions and closures, anyway. Many languages don't even have that, and they're still expressive enough. Python and Ruby have basically no static guarantees for type invariants. JavaScript also doesn't, although TypeScript helps fill-in some gaps. &gt; Comparing for (&lt;) is much worse and you memorizing it doesn't help the problem. If you compare anything else than values with number semantics with &lt; and the rest, it means either you don't know what you're doing, or your use case is niche enough to read the fine print. I'm trying to figure out when I had to use &lt; for anything other than numbers. Heck, even simple string sorting requires Unicode collators these days. As for the rest, like the sorting endless loop you said, it's interesting and a fair critique, but it has never happened to me in years and years of practice, nor have I seen it mentioned as a problem anywhere, except in theory. PHP has a ton of "theoretical" problems, so do most languages that get *used* a lot, including C++, Python, Ruby, Java, .NET family and so on. But it only matters if those theoretical problems translate into frequent problems in practice. And they really don't, if we have to be honest. The reverse example is Haskell, which is much closer to being theoretically ideal, and it's worth our respect for that (definitely one can learn from Haskell, Lisp and so on), but it has a lot of practical problems in return. Can't have it all I guess.
I just asked Anatol Belski https://twitter.com/mnt_io/status/631842197676105728. Maybe he could help you.
&gt; No, the common is in the code, the specific is in the database, and it's all tested with behat and phpunit. Business isn't about "creating applications" or "creating websites" it's about domains which are tied to audits, policies, laws, and processes. The general public has no use for a framework which manages these things. The idea of releasing it is juvenile and insane. This right here has flaws with it. With out derailing the general concept, the common is the foundation, all houses are built (generally built) with the same foundation, concrete basement with support beams. This is the framework. This can be "detached" and used on the next house, maybe with some modifications should the house need it. The common is the framework. The specific is the business code and the data in the database is nothing more then a detail. Aside from that business is about creating and providing a service, that service in todays world is majorly web based, from tax forms on line, lawyers on line this and that on line. Hell even silk road was a business of sorts. The service that a business provides online is a "Web site" it is a "application." To the manager thats oh so presently evident in your analytical explanation of what is and what isn't, I say this: Applications and Web sites power business and drive traffic to that service, as a result we should care about the underlying technologies and how they are used and if they are "given back" in some fashion to the community. First comes the code and the man, then comes the community and the innovation and finally comes the business that in turn should repeat the cycle. What you describe is "Build me x I don't care how, make it make me money." This is fair for the business execs above you, but you as the developer should care about what you build and if you can decouple it and give it back, custom framework as it may be would benefit the community. Now I am not here to persuade you to do that, I am here to explain that when we roll our own and we share there should be more acceptance and acceptance comes from more people and companies sharing and giving and receiving feedback.
Contributing to an open source project might be one way to flex your php muscles and give you oodles of experience. As an intermediate dev, you should be able to take a software system and implement smaller changes and participate in discussions about major features. You should also be able to read other peoples projects and have a solid understanding of the structural decisions they made. 
choose something you find very difficult right now and then sit down, study and really learn it. you need to challenge yourself and your brain if you really want to "level up". it's very tough but worth the reward in the end. 
security, security, and security 
This website really helped me explore new areas of my development process with PHP: http://www.phptherightway.com/ For example, are you testing your code? There are recommended libraries that you could start using, as well as digging into the source code of. Most of the items on that page are also great development and coding practices, and exploring those sorts of things has led me to a slew of topics to explore, wikipedia articles to read, etc.
- If you allow your C# application to upload files to your binary application folder, it will actually execute the files. - Likewise, if you don't indiscriminately upload user files to locations where the server is configured to run PHP code, it won't run PHP code there. The problem is poor server setup. It's not even the language.
Shitty php programmer sarcasm aside - it isn't about "relying", it's about speed and not having to think about obvious chores. Previously you'd have to type $this-&gt; to even have methods or class variables listed by code hinting, now they're available the moment you type first letter. 
I can't speak for others as I'm newer than the code in question but basically people have lives and this being volunteer work, it was kind of a as long as you say it works we'll keep it approach. 
&gt; There is always value in learning about the internals of the frameworks and libraries we use. I love you already.
unfortunately not entirely current and also only useful for people with a lot of experience in PHP extension building. It was of some help though, especially in conjunction with the two [blog](https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html) [posts](https://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html) by /u/nikic
This hack you linked to is absolutely caused by a weak application, not by a weak programming language. The problem, as I pointed out in the discussion, was that the image uploads were not correctly handled. The app accepted a .php file as an image, then placed the file in a web-accessible location, which means the file will be executed when requested.
Sounds like maybe code reviews would be good going forward! It doesn't usually take too long to do code reviews for others, and software like GitLab makes it very, very easy to do. Our experience has been that it improves the quality of code immensely, and often catches bugs or generates good discussion that wouldn't happen otherwise.
&gt; What you describe is "Build me x I don't care how, make it make me money." No I didn't. I don't deal with software stakeholders because I don't sell software, I sell money. Two people have access to my code: my office manager and my wife. Not even our clients have access to our code. &gt; if you can decouple it and give it back, custom framework as it may be would benefit the community. No it wouldn't. The open source community and open source frameworks have entirely different objectives than enterprise frameworks do. OSS cares about JSON and MongoDB not EDI and iSeries. Have you ever seen an EDI implementation specification? This isn't "community of developers" type shit. I appreciate that you have an ideology and stuff, but I don't think you really understand the first thing about software in the enterprise.
Try to be better at programming. The programming language doesn't matter. If you have a solid understanding of programming principles than you'll be much more flexible as a programmer, don't try to limit yourself to just one programming language. Unfortunately for PHP, the majority of client jobs lately are just that, WP and/or some basic website in Laravel or some other framework. Read books on programming principles, like: 1. [Seven languages in seven weeks](https://pragprog.com/book/btlang/seven-languages-in-seven-weeks) 2. [Code Complete](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670) 3. [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) There are a ton of videos on programming: 1. [Google Developers YouTube](https://www.youtube.com/user/GoogleDevelopers/videos) 2. [SensioLabs YouTube](https://www.youtube.com/user/SensioLabs/videos) 3. [Facebook Developers](https://www.youtube.com/user/FacebookDevelopers/videos) 4. [PHP UK Conference](https://www.youtube.com/user/phpukconference/videos) 5. [NewCircle Training](https://www.youtube.com/user/MarakanaTechTV/videos) 6. [InfoQ Presentations](http://www.infoq.com/development/presentations/) Some specifics: 1. [Building on SOLID Foundations - Presentation](http://www.infoq.com/presentations/design-principles-code-structures) 2. [Learn how to write good code](http://sevenstrokes.net/learn-how-write-good-code) 3. [Beyond design patterns](http://blog.ircmaxell.com/2013/09/beyond-design-patterns.html) 4. [Practical PHP Patterns, Refactoring &amp; Testing - HUGE list](http://www.giorgiosironi.com/2014/04/the-full-list-of-my-articles-on-dzone.html)
This is a really good talk on microservices and on software in general, I just saw it recently: http://www.infoq.com/presentations/microservices-replaceability-consistency
I own and operate a small web startup with a few devs. In January of 2014, I made the decision to have all of our clients and corporate projects and websites (and my personal ones, too) ported over to HHVM by December 31, 2014. We ran into a few incompatibility issues and were delayed, but we reached this milestone on 5 February 2015. Facebook staff have been glorious about addressing these inconsistency reports, even paying my corporation what I would consider substantial money for uncovering security bugs and addressing them through proper channels over at FB corp. I mean, those guys literally gave me their personal email addresses to facilitate disclosure. In early January 2015, I issued a memorandum and directive which specified that all new corporate projects would be done in HackLang, particularly after our internal metrics showed it being only a slight deviation away from NodeJS' performance in a great many areas, above and beyond pure PHP in HHVM, when utilizing Hack-specific constructs, particularly Containers. Memory usage is substantially lower. Since then, we have refactored the backend admin reporting systems of several clients to HackLang, and saved them substantial savings in CPU and memory expenses, not to mention report generation time. HackLang has also made possible stock analytical software that was written in NodeJS. One major block with its further adoption are frameworks. HackLang in Symfony, it doesn't make much sense. You lose most of the outright benefits of a pure-Hack system. I would like someone from Facebook to write an article or two on just how to efficiently utilize hack inside a framework. We were very sad PHPStorm decided to back out on HackLang support just because Zend got the holy bejesus scared out of them and actually started doing radical changes for the first time in years. I'm also very disappointed in the name "hack". Could they have picked a less googleable name? Why did they pick something with negative connotations ("hacks" are either bad pieces of code or posers, and no one wants to get "hacked" to death).
I forgot to add that for adhoc clients who don't have HHVM, when we do one-off projects like data calculations or something, we will code in HackLang and then use the PHP5 transpiler to give the client pure PHP code. The main reason, from my Team Leader / Architect position, to prefer hacklang even over PHP7 are the Hackisms that greatly encourage (and even enforce) much tighter programming and greatly reduce the need to, for instance, ensure the integrity of every piece of input data, all the way down the stack, which is essential in hardened PHP code.
If you are running PHP 5 via FastCGI today, then HHVM is usually just a drop-in replacement. A noticeable usecase that bit us hard was the Facebook team's total dismissal of every RDBMs besides MySQL. For us, it was lack of PostgreSQL support. But we found that support created by a third party, and it is certainly stable enough.
That's pretty much exactly what we do. Just add a log statement at every conditional block and step in the flow. However, we do log the IDs of all entities involved, as it's easier to query the databases for any issues if need be. So for example, your log message would be. {timestamp} [Queue] [Worker1] Article (34312) has an image.
Understood, thanks. Yeah I do it like that, I wrote them to Reddit so forgot about the ID. This was a habit I was getting as the application grew, so it's good to know it's nothing overkill.
I did _emphasize_ it for a reason â€” I agree.
Look into sandboxing each execution request on a new docker container. Sorry on mobile now but will edit with some links later. 
I do about the same, but choose sha1 instead of sha256. To replies below, it's about the filename, `1.jpg` becomes `f10e2821bbbea527ea02200352313bc059445190` with no extension and is saved on the fs like that.
For what it's worth, this is still very much a work in progress, so I wouldn't consider this particularly "official" just yet â€” there are things that straight up aren't documented yet and other things that need some work. Take with a pinch of salt and in conjunction with the [UPGRADING document in php-src](https://github.com/php/php-src/blob/master/UPGRADING). We're working hard on it! (Special shoutout to Sobak and Thomas Punt, who've written a tonne of this.) The one page that *is* pretty much done (I hope) is the [backward incompatible change page](http://php.net/manual/en/migration70.incompatible.php), although I'd like to split that up into multiple subpages just as soon as I can figure out how to tweak the DocBook source and PhD to do it, since it's way too long.
Sorry if i'm wrong .. Where should i put this for critic or suggestions. Thanks 
What the hell is "binary application folder"?............. Like you **clearly** have no idea what is an ASP.NET application, why do you try to defend your shitty language by smearing shit from your shitty language on to normal language?..
&gt; What the hell is "binary application folder"?............. Best guess? How about "Bin", where your application binaries are, genius. :-) ASP.NET actually has additional attack vectors compared to a generic C# project, as it'll pick up changes from App_Code and recompile them automatically. By default ASP.NET will also run any controller named after the URL you open.
I tried to figure out phroute recently (Found it on packagist) . Having no experience with routing it was impossible to use. I guess that I need some sort of .htaccess URL rewrite rules in place, but I couldn't figure it out. Are the rules here the same that I would use for composer routing packages? Like phroute or fast-route? And do the rewrite rules matter if I have the site in a subdir off of the web root? like: http://myserver.com/mysite/index.php Where mysite would be the base of the routing rules? 
Also IntelliJ idea community edition is free, and so far it's done everything I've needed including debugging. 
&gt; I haven't linked any hack, just php develolper's understanding about what's going on arround him... _(ãƒ„)_/ Like how delusional are php develolpers?.. I HAVEN'T LINKED ANY "HACK", yet by his understanding - I did. My god. MY GOD. Get the hell out of software development, you are a god damn disgrace to the profession. Please. Please. Stop smearing php shit all over this crafty profession. You insult me and other developers. You are the sole reason why media paints bad picture about how random goverment website gets hacked by china/russia and how IT sector cannot make a secure software. Yeah, you could argue that goverment goes with lower bidder, which is always php imbeciles, but why would you, php imbeciles, bid on anything more complicated than 2+2 scenario or word press plugin??? Eat shit, I hate you php phony develolpers with a passion, you degrade my beloved calling. Eat shit and die. &gt; So ASP.NET application is .dll. If I'll upload an image with .dll extension, it will get executed? No. &gt; And we're talking here about OUT OF THE BOX. Not that php devlolper would have any idea what's going on arround him, so why am I even bothering.. Ok you win. But only because I'm not mean enough to upset a child.
The raw performance of the PHP runtime, compared to popular JS runtimes like V8 (which powers Node.js). This is due to heavy investment in JS runtimes by browser makers. Few years ago the "are we fast yet" attitude of browser makers was in full swing.
Wow, I'm kind of surprised someone experienced in PHP is just learning about this. It's sort of one of those 101 questions that come up in some variant in lots of interviews (usually "why is using single quotes for strings faster than using double quotes?").
&gt; enterprise frameworks do Uh ..... Ok so what is Zend? Or symfony? Not enterprise? &gt; OSS cares about JSON and MongoDB not EDI and iSeries I smell a down vote coming on .... &gt; Have you ever seen an EDI implementation specification? This isn't "community of developers" type shit. And there it is ... &gt; I appreciate that you have an ideology and stuff, but I don't think you really understand the first thing about software in the enterprise. Why cant I down vote infinity. I smell elitism.
Ah yeah, fair point. I did say in the post that I was putting these services into the same container as it was solely for tests, and yeah those extra bits are a bit redundant. Ill look into setting up the linked containers and update this later on.
You're redirecting to another page before the second echo. Obviously it won't work.
Zend and symfony are general purpose web frameworks. This spawned from your half-baked assumption of corporate frameworks either being struggled or "cobbled" into existence. I said again and again that corporate frameworks contain proprietary information either in the form of specific implementations or manifestations of mental models which represent the proverbial "keys to the kingdom." Then you speculated something half-assed about how they're Micro$oft-era balls of mud that can't separate their nouns from their verbs and probably aren't even tested; if they'd only sip the OSS kool-aid everyone would be better off. I directed your attention to [the pulse, blood, and vein](http://store.x12.org/store/) of enterprise transaction management as an example of one component my framework is designed to abstract, which corporations can't divulge without a lawsuit *even if they wanted to*, and you call me elitist? You're a dreamer, man. You have a lot to learn. Downvote me if it helps you feel better, please.
I have been porting extensions (msgpack, mailparse, ssh2, yaml, stats and working on igbinary) so far, and would love to help if you find yourself stuck! There is an IRC channel on Freenode #gophp7-ext that people idle in that you can ask questions in (Feel free to mention me to get my attention) Check out https://github.com/gophp7/gophp7-ext/wiki/extensions-catalog if you add a line item noting that the extension is failing, I would be happy to grab it! Also is a good chance to get many extensions on GitHub with tests running against every commit + code coverage (show where the tests are lacking) I eventually would like to make a post in this subreddit to get everyone to surface the most popular extensions. The sooner things get ported, the sooner people start using PHP 7 and making it better. 
&gt; encourage (and even enforce) much tighter programming and greatly reduce the need to, for instance, ensure the integrity of every piece of input data, all the way down the stack, which is essential in hardened PHP code. so why did you even stick with php-&gt;hack? Why no try.. I don't know.. Go? Scala? 
That react php looks great. But how mature is it? And how it will support php frameworks in general (or frameworks supporting it)
I fully support your decision to not support references. However, do realize that a lot of standard stuff is designed around them (such as arrays). Parts of it will be painful. It would severely limit the portability of code to your engine because of this as well.
&gt; However, do realize that a lot of standard stuff is designed around them [references] (such as arrays). Could you elaborate on this? About portability, I've decided to give up on it from PHP to my subset, but allow it - at any cost - from my subset to PHP (5.6). This is to lower the commitment barrier. **Edit**: Ah, you mean `array_walk` and such, of course. Yes, that might be solvable. Hack does not allow references either, but I bet you could still use such functions. Will look into it.
Don't ask me, I'm not the guy behind it =) As for framework support I have seen blog posts of people trying it with various frameworks with various success, so it really depends on your use case.
&gt; Zend and symfony are general purpose web frameworks. This spawned from your half-baked assumption of corporate frameworks either being struggled or "cobbled" into existence. I don't believe I said that but ok. &gt; said again and again that corporate frameworks contain proprietary information either in the form of specific implementations or manifestations of mental models which represent the proverbial "keys to the kingdom." I would consider Zend to be a "corporate framework" as I would also consider Spring to be one as well. What you are talking about is an in house custom framework thats coupled to the actual application. &gt; Then you speculated something half-assed about how they're Micro$oft-era balls of mud that can't separate their nouns from their verbs and probably aren't even tested; if they'd only sip the OSS kool-aid everyone would be better off. I knew that down vote was for something. &gt; I directed your attention to the pulse, blood, and vein of enterprise transaction management as an example of one component my framework is designed to abstract, which corporations can't divulge without a lawsuit even if they wanted to, and you call me elitist? My words are my own, as are your yours' No need to get defensive. &gt; You're a dreamer, man. You have a lot to learn. Downvote me if it helps you feel better, please. It's not that it helps it that you contribute nothing but proprietary garbage and fear of law suits.
Interesting. Previously people would always tell you that PHP scripts should be short lived, but we've been running a few Laravel queue workers in production with supervisord, but we haven't had them crash at all (not very high server load). I think people are starting to warm up to the idea of having long running PHP programs. On the other hand, composer [disables GC](https://github.com/composer/composer/commit/ac676f47f7bbc619678a29deae097b6b0710b799) because it knows it is in fact short running 
This is basically the book I've been writing for the past couple months... (http://leanpub.com/php7) While I'm happy there's an official guide, I'm personally kinda bummed about this.
I might use this in a project I'm working on right now that aggregates events from various events hosting platforms into one place. Being able to dispatch dozens / hundreds of jobs in a controlled manner is something I've been a little worried about. If I do end up using this, I'll let you know about my experiences with it. Thanks for posting this. 
They've done one of these for every point release since 5.0 at least.
I am the back-end engineer at Dyne (https://www.dyne.com) and we built the private REST-ish API (supporting the iOS and Android apps, as well as a new very beta version of a web app) completely in Hack from the beginning. After having used Hack for more than a year in production, I don't think I would ever want to start a project in pure PHP again. I haven't been able to use any of the new (to our product) async features yet, but the collections and strict mode typing have made the entire project much easier to expand and maintain. As others have said, the lack of pure Hack frameworks meant I had to build my own. This prompted me to build my own router (https://github.com/kilahm/attribute-router) and factory container (https://github.com/kilahm/IOCFactoryContainer). I also built an ORM of sorts DB layer, but haven't extracted it into a GitHub project. *I have learned A LOT in the past ~6 months since I last updated these two libraries. They really need some love, but I'm much more focused on HackUnit now (https://github.com/HackPack/HackUnit) which hopefully is nearing a 1.0 release. In short: Yes, there are companies building applications in Hack.
&gt; It's the developer's fault to allow arbitrary content when actually only images are allowed. Image files can possible contain php code within it's metadata fields making it a valid image file an a valid php file at the same time. 
I thought Laravel already came with Twitter Bootstrap 3?
After reading some great discussion in the [PHP 7 Migration Manual Thread](https://www.reddit.com/r/PHP/comments/3guabr/official_php7_migration_manual_is_here/) I saw that some people were being held back by extensions not being ported. Well, here is your chance to get your favorite extensions ported **first!** and help out the community. There are also chances to learn about the zend engine API, and anything else that interests you. It would be really helpful if you could update the catalog, fill in details for extensions already on there and add lines for extensions that are missing. I am currently porting igbinary, but the highest voted extensions in this thread will get ported next! I am just doing this for fun/in my spare time so it will not get done as fast as it should be, but it will be started at least :) If you are interested in learning about extensions, and porting to PHP 7 here are some quick resources. * Guides to writing an extension for PHP 5 [here](https://www.simonholywell.com/post/2010/09/15-excellent-resources-for-php-extension-development/) * [phpng-upgrading guide](https://wiki.php.net/phpng-upgrading) * Diffs for ported extensions -- [stats](https://github.com/Sean-Der/pecl-math-stats/pull/1/files) [msgpack](https://github.com/msgpack/msgpack-php/pull/48/files) [yaml](https://github.com/php/pecl-file_formats-yaml/pull/14/files) 
I work on HHVM's open source team, but use it for my personal stuff too (and there's no coercion for me to do so). The reasons are: - async/await let you write efficient asynchronous code almost as if it were synchronous. No callback spaghetti, manual polling, etc. Interleaving async mysqli with curl_multi in PHP5 is much more painful than awaiting a AsyncMysqlClient::queryf() and an HH\Asio\curl_exec() simultaneously - I really, really like XHP. In general it's more than most template systems in that it's safer (eg you need to try really quite hard to be vulnerable to XSS) and strongly encourages a ReactJS-style 'components' way of thinking, but combined with async (yep, your XHP render function can be async if you 'use GenXHP') - it's great. I wrote more about that here: https://code.facebook.com/posts/858739974205250/announcing-xhp-js-building-efficient-user-interface-components-with-hack-react-and-xhp/ - The typechecker rocks. It gives me so much more confidence when refactoring, and does a great job of telling me how I broke something, rather than just what I broke. In a nearly-pure-hack-project, I find it's extremely rare for the unit tests to fail after a refactor if the typechecker says all is good. This doesn't apply to changes that are meant to be functional though ;)
If you need a tool to help automatically scan and detect potential code issues I created this project to assist with it. It will detect almost all backwards incompatibility issues. https://github.com/Alexia/php7mar
I vaguely remember reading about that in the commit messages on twitter (yes, I follow @HHVMCommits) and being really excited. I will definitely be using that feature in both the factory container and router packages when I am able to get back to them.
I didn't want people doing stuff with my IP address attached to it. Leaving internet access enabled in something like that is basically the equivalent of running an open wifi, or a Tor exit node.
The world needs to move towards 7.0 as soon as possible. The way PHP's reputation has been in decline in social circles makes me extremely sad. We all need to sit down and contribute and get the whole thing out there by next year or at least by next summer and do away with everything that has been criticized about PHP as soon as possible.
I tried to use it for event based stuff but quickly hit a few problems. You mustn't use blocking operations, otherwise your whole server stalls. And there of course is the crux: almost no library is prepared for this. No callbacks/promises/futures to keep the event loop clean. Ended up using NodeJS for this specific part, imho it is much more mature and the ecosystem works from the ground up with that approach.
Xdebug has not yet been ported :-(.
I'm not sorry for saying this but if you used laravel and not just altering a blade php template, you're not a junior developer, you're an intermediate developer or better at this stage.
At least Derick Rethans is still actively working on xdebug. I'm more worried about the availability of xhprof. Does anyone know what's the status of that?
Incidentally, this was written recently http://logicaltypes.blogspot.fi/2015/08/pure-functional-programming-claims-irl.html My favourite quotes: &gt; Then, a Big Six came in and said, 'we can do that for you with 250 programmers and Java' and stole the project. After ten years and billions of dollars, they were unable to reproduce my work. and &gt;Sunset dates I wish I had a dollar amount, but you can estimate for me: three teams of business analysts and software engineers over a six month period said it couldn't be done (or tried it and failed). I scrapped all that code, wrote the system from first principals (Category Theory) and got it working and approved in two months. You do the math.
I would look at uprofiler. It's a fork of xhprof that is seeing more active development than xhprof.
Wow thank you for this! 
Maybe in some aspects. I've also built afew projects in Cake.
Thanks for that! i've added it to my list of PHP resources. As for testing, not really. Most of my work is confined to Wordpress and supporting on Laravel projects. We are moving towards code reviews and unit testing in the next few months and properly following PSR.
You are very correct on that. What I am doing during down time in work is following some of the advanced PHP videos on Laracasts and Lynda. It's actually noticable how I find the advanced series a lot easier to follow compared to a few months ago. 
Noted! Since my intro into the working world has been mostly Wordpress I would like to dive in and get involved in some ways on the progression of that platform, seeing as its PHP. And maybe futher down the line I'll look into Laravel or such.
I've been working on a project that is very similar to what you're doing here! Trying to keep PHP applications alive between requests to increase performance. Using simple benchmarks (I need to do more!) I took a basic 500 page database driven Symfony application from 200 rq/s (with NGINX and PHP-FPM) to over 2,200 rq/s. There are obvious downsides, blocking operations has already been mentioned by /u/justaphpguy. Developers also need to consider code updates, memory leaks and much more! But, with a properly designed application and a few years of community interest it could become a solid practice. My project uses FastCGI so that you can keep the protection of a solid public facing web server. I'm still working on it, but if you like you can check it out here: https://github.com/PHPFastCGI/FastCGIDaemon I'd be interested to see if it gave a similar increase in performance! I might even have a crack at a PHPixie adapter myself when I get back from work - I've already made them for [Slim](https://github.com/PHPFastCGI/Slimmer) and [Silex](https://github.com/PHPFastCGI/Speedex)! edit: links to other adapters
There is no one-size-fits-all solution to this and it will depend on your specific requirements. As I mentioned in the article, the rewrite rule used there would not be great for real world use because it rewrites everything. This means that if you have, for example, a CSS file under the webroot, you wouldn't be able to access it. For the purposes of example I wanted to keep the rewrite rules as simple as possible. The link I included to the [Zend skeleton application .htaccess](https://github.com/zendframework/ZendSkeletonApplication/blob/master/public/.htaccess) would be better because it skips the rewrite if a physical file or directory exists for the path. If you're going to be running a site in a sub-directory this must be taken into account. The REQUEST_URI will be prefixed by the sub-directory name. This prefix must either be eliminated before routing or your routes will need to be prefixed to match. There are [work arounds](http://stackoverflow.com/questions/18805108/how-can-htaccess-change-serverrequest-uri) to change REQUEST_URI in the .htaccess file too but generally it is done by using a base URL to determine the prefix. You may also need to set RewriteBase depending on how you structure your rules.
Hm, yeah... I would either need a two-mode GC, which switch between different strategies depending on memory load, _or_ I could make user chose a GC during compile-time, _or_ the user would need to tune the GC for each script manually (where default would be for short scripts? don't know).
Awesome. That means ut should run pixie out of the box
It's only a valid php file, if the meta content is valid as well - he shouldn't leave the file name as is.
Also, don't restrict yourself with PHP. Go and learn objective JavaScript, just to take yourself out of your comfort zone, you'll learn a lot about other programming paradigms. JavaScript was like a whole new world to me. It's also quite challenging to learn (talking about OOP part here)
Not following. How is there any relation between file name and meta data in images?
Have you actually been asked that in an interview? I can understand being asked about the difference between single quotes and double quotes, but not in regards to speed, considering it's one of those microoptimization things that every experienced programmer says not to care about.
It was a standard interview question in some form at least two of the companies I've worked for, so I've been asked it at least twice and asked it myself in dozens of interviews. You're right that it's essentially no different in practical speed (especially in the modern era of template engines where very large string interpolation operations are rare), but I think it's supposed to demonstrate the ability to think about performance issues critically and test PHP specific knowledge without getting too deep into internals. In other words, it might not be something you know off hand or think about every day (by design), but by understanding how strings in PHP work you should be able to reason it out yourself. 
Both sprintf and string interpolation used to be used extensively to assemble SQL, leading to a whole class of security vulnerabilities (SQL injection attacks). This is basically why everyone (who knows what they're doing) now uses / recommends only PDO with bound parameters.
Like this: https://github.com/phpexpertsinc/redditmirror/blob/f532b828aadab823f779abe92cf71246516fb6e1/tools/tally_domains.php#L5
The framework does not have neither global nor static state. So after the request processing finishes there is no polution. Not having to instantiate the framework each time is the entire point if this approach
neither was javascript, the main reason reason why node.js was build on javascript as a language was that javascript had no IO at the time - the idea of the guy who wrote it was to make a demonstration for async IO. "using a tool that natively supports async" and thats where you are taking the wrong turn in your argument, both languages js and php (and most other languages) can do asynchronous stuff, thats not related to what frameworks (node, react.. ) do with it, and what sort of support they provide. and the lack of structure in the js world, even if it is supposed to get better with ecma 6 (lets see how the adoption rates are) is a good reason to look for alternatives. 
&gt; This library includes an executable that will scan your project directory for factories then construct a valid hack file that aliases all your factories as public instance methods of a single class Can you explain what this is? It seems really odd that you write code that gets transpiled into something else entirely. Isn't that a lot like writing classes as XML, and then a program converting that XML into PHP or some other language? What advantage does this give you?
Wow, there's some completely bullcrap in there. Laravel has slow bootstrap because it uses Composer? Poppycock. Laravel has a dependency on Symphony is a con? Changes to the Symphony API adversely affect Laravel? Utter rubbish. This is why you have Composer handling version management. Reusing existing code instead of rewriting it just because it's "not invented here" is a pro. Zend Framework has "loose documentation" because the code has a "loosely-coupled architecture"? What on earth does the code architecture have to do with documentation quality? Zend Framework is "partnered" with Google, IBM, Adobe and Microsoft? Citation needed, because I've certainly never heard anything like this. Some of these companies may be Zend clients, and some may use Zend Framework, but that doesn't partner them in any way. (I could see none of these on either the "Our Clients" list on zend.com, or the "Who uses ZF" list on framework.zend.com) There's extremely little in the way of actual, useful comparison of features / architecture / style. It's all a bunch of dross people who apparently haven't been using PHP for very long (or at all, quite possibly) puked up. It's even worse than the usual "top 10 frameworks 2015" articles that puts CodeIgniter in the top 3.
I've been checking this from time to time, and while many of the remarks are on-point and accurate, many are just hilariously wrong. If you crowd-source something, you need to ensure the participants are qualified and know what you're talking about. And because this site allows anyone to talk, this is not the case.
Well, possibly you could still use it for standard functions. I don't know how Hack deal with this, but I'll look into it. preg_match might need another function interface then, preferably returning an array which you destruct with list.
Hey, yeah I agree that some of the information may not be entirely on point because of the nature of having a crowdsourced comparison, it also has it's pros, namely you can comment or edit the pro/con if you feel like. This way the comparison stays updated and improves over tim. Also I have used Laravel and found the bootstraping extremely slow. If it's not Composer, why do you think it's that way? 
No one ever thought 15 years ago that we would be using Javascript the way we are today.
I wasn't talking about image meta data, but about file meta data - including the file's name and extension.
Thanks
Does anybody know why Weakref hasn't become a standard part yet? I know they're part of the Java core, and it's the kind of runtime-level feature that makes it much *much* easier to manage things like listeners and event-subscribers.
The problem is that the reference operator _exposes_ copy-on-write. Please read the links above.
About the speed difference between refcount and tracing GC, I haven't found any good statistics. They have different trade-offs, but I think tracing GC is considered to be faster but with more memory consumption. You can check out the garbage collection benchmark [here](http://benchmarksgame.alioth.debian.org/u32/performance.php?test=binarytrees). It would be really interesting to see how Swift compares, since it's the only compiled language with reference counting (that I know of).
I went through them quickly and I don't see the problem. Can you be specific.
&gt; the example use-case seems like it would be solved more effectively via a separate factory class Hear, hear.
Twice as slow as what? In terms of call performance it's like this (from fast to slow): 1. closure 2. function 3. static method 4. instance method Now, I don't know where constructors sit in that list, to be honest, but it doesn't matter as the above is for empty methods, and the difference in speed becomes irrelevant once you put code in them, as that then takes most of the time.
Perfectly said.
One set of templates. All the responsive web design magic happens in CSS / JS. This is the current best practice.
In css you should use the media-query's right? And what / how do you handle the problem in JS then? And maybe it's very simple, but the switching from 3 "grids" to 1 "grid" with an different order of information than before looks to me like a lot of hassle to get it working (never been really doing this, so maybe my assumptions are wrong...)
I've heard of bootstrap before, but I'm interested in the idea behind it. Why / how does it behave like that What thoughts have made it to let this happen. I don't want to just add an CSS class and be done. Don't get me wrong. I do think that CSS frameworks like bootstrap or skeleton are great, and maybe the best way to go. But nevertheless, I want to learn the how and why. I'm just starting to take web-development "serious", so I think it's better to get the fundamentals very settled before surrendering to an CSS framework
Well you cant say that either. Its not really that hello worldish. Routing, templating etc are still used. Yes it doesnt measure db access but thats only because db access is synchronous and you would not use react for such a case. If you were implementing a chat system the code in your controller would not be that larger than in my helloworld example
This may not be the answer you're looking for, but I see more and more desktop sites simply look like oversized mobile sites, where couple of things change through CSS media rules, and apparently that's how they "deal with it". In the end it comes down to money. The cheapest and laziest solution is the above. The most expensive and theoretically best solution is to design tailored experience with separate everything for every medium. Some websites honestly work better if you leave their desktop experience be used on mobiles, and they tap to zoom in. Zooming isn't that bad of a metaphor for UI, it's underrated.
The best approach is to have the flexibility of all tools in the box and be able to make ad-hoc decisions on a case by case basis. This is why when in my company we split people in teams, the front-end guys control PHP controllers, templates, and the entire client-side (and back-end guys are left with the domain services). This means front-end guys have the freedom to look at a project and take everything into account before they decide how to go, and they can mix all approaches page by page. There's literally no way to make a good recommendation without project specifics. **EDIT**: I have one general recommendation, actually. Design your UX in a wireframing tool, mock it up in Photoshop, then create quick semi-interactive prototypes cobbled up in your favorite app or directly in (ugly draft) HTML+JS. Once you settle on UX, that's when you'll know how to best do the production code, and that'll drive the implementation details.
Putting your title in all caps is annoying and comes across as shouting. We can see your post fine if you use regular letters. &gt; Sublime Text deserved second place, because it is free php ide (via WinRAR), I wouldn't classify Sublime Text as an IDE. Even with lots of plugins, it's still an editor. It's amazing, and I love it and I use it a lot, but an IDE it is not, even though you can come pretty close. Also I'm pretty sure Sublime has nothing whatsoever to do with WinRAR. Sublime Text is not actually free (although again, it comes close). Neither are Zend Studio or PHPStorm. There may be a few other nonfree ones I'm missing. &gt; support less spoken This phrase means nothing: you probably mean "supports fewer languages". Are you German speaking by any chance? In German people use the same word for "speech" as they do for "language".
In terms of js there are few ways to manage this. If you are going the JQuery route, have a: function is_mobile(){ //check mobile based on User agent } Although most of your JS should be generic. Just show hide components using media queries and attach JS handlers to events of all the components. If you are going to build single page applications I would try out something like Angular. It is complex to start...
Requests per second. Sorry I cant answer all of your other questions. ReactPHP still has a lot of limitations that make it hard to test everything with it. The purpose of the post was to experiment with react, not provide a ptoduction ready solution
Thank you very much! I've ordered the book right away. And I'll read that page later on, looks very promising. Thank you very much again random user!
No, I hope there aren't many.
&gt; Are you German speaking by any chance? Even I as a German couldn't understand what he meant before your clarification. 
A good responsive design is not lazy or cheap. It will usually take more work (time+money) to make it work well as a mobile.example.com setup will. Of course then there are copy and paste, unmodified bootstrap sites that are lazy and probably still expensive. So I agree if that's what you meant.
Really, it's don't go full retard on a feature or methodology. Traits come to mind with this. Traits can be good but like with anything in any language, people tend to find something new and go full on retarded using it.
probably in a web design subreddit. but not here. your site might be written with php, but that has nothing to do with the design.
That would only cause notices wouldn't it? Not a fatal, which would generate a 500 if display errors is turned off. From what I remember anyway, it's been a while since I wrote raw php tbh OP turn error reporting on in php.ini 
I did some quick formatting for you: &lt;?php // Contact subject $subject ="$subject"; // Details $message="$detail"; // Mail of sender $mail_from="$user_mail"; // From $header="from: $name &lt;$mail_from&gt;"; // Enter your email address $to ="email@example.com"; $link = "&lt;script&gt;window.open('confirm.html')&lt;/script&gt;"; $send_contact = mail($to,$subject,$message,$header); // Check, if message sent to your email // display message "We've recived your information" if($send_contact){ header('confirm.html'); } else { echo "ERROR"; } ?&gt; HTML BELOW: &lt;form method="post" action="send_contact.php"&gt; &lt;p class="full-row"&gt; &lt;label for="name"&gt;Your Name:&lt;/label&gt; &lt;input type="text" id="name" name="name"&gt; &lt;/p&gt; &lt;p class="full-row"&gt; &lt;label for="email"&gt;Email:&lt;/label&gt; &lt;input type="text" id="email" name="email"&gt; &lt;/p&gt; &lt;p class="full-row"&gt; &lt;label for="subject"&gt;Subject:&lt;/label&gt; &lt;input type="text" id="subject" name="subject"&gt; &lt;/p&gt; &lt;p class="full-row"&gt; &lt;label for="message"&gt;Message:&lt;/label&gt; &lt;textarea name="message" id="message" rows="6"&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;input id="submit" class="mainBtn" type="submit" name="send" value="Send Message" onClick=""&gt; &lt;/form&gt; Its a little confusing as to which file we're looking at here. Is this file named "send_contact.php" as referenced in the form? If it is, how does any information get into the `mail($to,$subject,$message,$header)` command? I don't see where any of those variables are declared.
I pull myself up by my boot straps
They gave me an EDU license for my organized PHP training classes. I can train newbies on PHPstorm directly, which after a year, translates into direct sales for them. I think it's a pretty tight business strategy. Before, I tried to negotiate the same thing with NuSphere because I loved PHPed, but they didn't like the idea. For a while I tried Netbeans, but I can't really stand it.
Usually, I create a layout for desktop usage, but keep mobiles in mind. That way, I can easily just add a few additional / hide some elements for smaller screens. However, when looking at a pretty good example of a mobile interface (namely [GitHub.com](https://github.com)), I always come to the conclusion that having different layouts for different needs is the best way to go here. You just have to make sure, you add a simple way to access all the features your full-featured desktop variant has, even if they may not seem that important on mobile. There's nothing worse than limiting people on phones, having to switch to a full desktop site instead of a only slightly ugly mobile one.
Routing, templating ... yeah that's pretty much everything you can do. I wouldn't be surprised if the used templating mechanism used blocking disk I/O, but even without, it's nothing more than a static page without access to a data backend. In that case a static page generator like Jekyll will probably be a better choice. If not, you'll have synchronous I/O in an event loop, which is a pretty dumb idea. If you want to use an event loop, you have to use async libraries in it to have a benefit.
&gt; I don't see where any of those variables are declared. I hope it's not relying on register_globals. 
&gt; I'm going to guess this thing was cut and pasted wholesale from one of those terrible online guides. [You're right](https://www.google.co.uk/search?q=%22%24mail_from%3D%22%24user_mail%22%3B%22&amp;ie=utf-8&amp;oe=utf-8&amp;gws_rd=cr&amp;ei=NWrOVY2bH4iPU7KoquAJ#q=%22mail+of+sender%22+%22%24mail_from%22&amp;safe=off&amp;tbs=li:1). I've found extremely similar scripts as far back as [2006](http://www.eksperten.dk/spm/701108). It's probably from even further back in history, and like I noted above it seems to be relying on register_globals being turned on. *shudder*
You can solve having sync I/O in an event lopp by simply adding more workers to the pool ( in php-pm). Templating doesnt really need IO, since its in plain PHP and thus subject to opcache
Wow, you've made a great job so far. I'm interesting in giving back to the FOSS community and contribute to port php5 ext. to 7 but i'd like to know what steps did you make to build the extension from source (linux distro under vagrant? directly under a distro? what about windows ?). I currently create a debian vm (using vagrant) which automatically dl the php-src, install the php build deps and build the project (`./configure`, `make`, etc).
Oh yea that is annoying, [wide-github](https://github.com/xthexder/wide-github) is a good way to fix that!
I do 95% of my development using [this](https://github.com/rlerdorf/php7dev) vagrant instance managed by Rasmus. It has two scripts `makephp` (to build PHP 5/7 easily) `newphp` (switch PHP versions in your PATH) that really make development easy. With that you don't have to worry about building php-src. As far as building extensions, you should be able to just clone then do `phpize &amp;&amp; ./configure &amp;&amp; make` hopefully the extension has a test suite that you can run via `make test`. If you have any questions feel free to chat on Freenode. The IRC channel is `#gophp7-ext` 
Thank you for your response. Sorry for not clearly describing what the foundation is all about. We are basically raising funds to educate less fortunate orphans, we do not really do the educating part. The website's main goals are to facilitate the donation process through online donations, communicate to members and potential members and easily store and retrieve information such as meeting minutes. From my research I believe moodle is an online school platform, this would be helpful to me in future but not for this project.
It will be for providing users with support (so think ZenDesk, WHMCS Ticket Support etc). If an agent has answered 100 tickets and we assume that 50% are technical and 50% are billing, Agent `X` could have 100% rating (50 tickets with 5 stars) on billing but only 25% rating on technical, it would allow me (or other agents) to provide feedback to `X` on how they could improve technical responses or avoid them altogether.
To play devil's-advocate a bit... &gt; Would everything go down? Would it cause fatal damage? The flip side of a single big app is that it may be much easier to restore and get running again than a web of smaller pieces that might have been backed up on different schedules. &gt; Even if that server was compromised, it wouldn't affect anything at all. At worst, it would cause our billing systems to be unavailable. This strongly hinges on the business-rules and limitations your company is prepared to tolerate. For example, are they OK with certain kind of billing actions being "queued", and all the reconciliation needed when something you *thought* would succeed ends up failing an hour later? If they aren't, then if the billing system goes down everything else will jam up anyway with "Error communicating to billing server". &gt; and we have nobody to take care of our devops stuff apart from me Then it may be that your company isn't big enough to need it yet. I'd focus on making **logical** splits between parts of the monolith, along zones of responsibility. That lays the groundwork for people to lever them apart into truly-separate services later on, when/if the need and capacity arrives.
- [check] facilitate the donation process - [check] through online donations - [check] communicate to members - [check] and potential members - [check] easily store and retrieve information such as meeting minutes. Yep, you can do this with PHP. I would use something between a framework and a CMS. So my choice here would be a content management framework (CMF) like ProcessWire. Very flexible, easy to get started, and none of the standard CMS bloat to get in your way as you build in portal features.
You're totally going to want a detailed breakdown of aspects that can be rated. You want to track "was the agent clear and helpful", because a single rating can be seen as a "my problem was solved" mechanism, and a user can still have a great experience even if their problem was not solved.
Just watched a tutorial on YouTube and it sounds like something that I could use. Thank you for the suggestion I never knew CMF's even existed.
I'm not really a fan of using other people's work, it limits my learning but that's a route that I can take if time will be a major factor so thanks.
You are actually right, I can get more ideas from people in git. Thanks. 
&gt; The flip side of a single big app is that it may be much easier to restore and get running again than a web of smaller pieces that might have been backed up on different schedules. Yes, things like that are what I meant by saying unseen threats, but why would you need to restore the whole application? A service may go down, it shouldn't cause issues on other services. Billing is down, so people cannot purchase anything, but the rest of the application remains intact. Billing server is restored, everything is restored. &gt; This strongly hinges on the business-rules and limitations your company is prepared to tolerate. For example, are they OK with certain kind of billing actions being "queued" We're a very small startup, so we currently care our tech stack more than tolerating crisis situations in the future. If we had to pick between a safer tech stack vs few days of money loss caused to the company, we would always pick the safer tech stack. Our billing system won't cause any jam ups, actually. Our app is designed in a way that it could work even without billing communication at all. (we just won't be getting new clients meanwhile and that's it, but once they make a payment everything can run forever) &gt; and all the reconciliation needed when something you thought would succeed ends up failing an hour later? I don't believe anything would fail a hour later if planned and tested well from the early. Why would it? The good thing is our CEO has programming experience and tasted what kind of troubles a technical debt causes in the past, so we mostly brainstorm together and try to find the best solutions for ourself. &gt; Then it may be that your company isn't big enough to need it yet. Yes, we're just a small startup. We're growing pretty quick and I want to prepare a decent stack for our future devops team/developers. I consider it as my responsibility. &gt; I'd focus on making logical splits between parts of the monolith, along zones of responsibility. That lays the groundwork for people to lever them apart into truly-separate services later on, when/if the need and capacity arrives. Well, that's the whole point of this topic. I'm asking if anyone has a real world experiences of a SOA. It looks like a great idea on paper but I have devops related concerns. That's why I am asking if I should slowly seperate my application into standalone services, and what should I consider as a threat when making the switch.
No i meant use it for tracking your code changes so you can always go back and see where things went wrong. https://try.github.io/
I think it's a good idea to do so. For example, you could use a queue (like RabbitMQ) to send "work" to the other services to do and tie it all together. It helps with scalability if you can scale up only the part of your application that is causing a bottleneck. It is possible to go too far, however, especially if you are a startup and are solving a scaling problem that doesn't exist.
I haven't used it, but I like the ideas behind Kafka: Less routing-centered, more of a stream-of-truth systems can publish.
Don't want to rain on your parade, but please for users sake don't write this from scratch. I'm a long time dev and project manager and what you're describing here is something an experienced â€¢teamâ€¢ would be required to tackle. Have a look at your different options, different enterprise level CMS (open or not) or, if you really insist on something custom and have many months to implement your ideas, have a look at frameworks like Laravel or Symfony that will at least give you some guidance and you'll have tons of great quality, compatible packages to use and build upon. You mentioned in an earlier post a concern for security in CMSs, but if you stick with vetted plugins for any CMS you choose, I bet it will be tons more secure that your current abilities will realistically allow for. Please don't take this the wrong way, assembling a system from existing parts and probably doing custom parts yourself will absolutely be a great learning experience in every way possible.
Well, if you need to do this you should look on how virtual hostings are set up. Starting from creating another linux user for each of your clients and using Hardened-PHP should be good start. But since it should prevent from accessing files with proper permissions and calling your script in unwanted way, I'm afraid there are still many security issues you should concern and try to prevent. Just talk about it with experienced server administrator. Proper server configuration (number of allowed processes, processes length and etc. is a must).
What is the process for allowing "request desktop site" when using just CSS / JS? Nothing I hate more than when a site is always in "mobile friendly" mode and loses half of its functionality with no way of forcing it back. Imagine if Twitter didn't have the ability to get back to the desktop version? You'd never have the ability to see only tweets. You'd always be forced to see that combined tweets + replies mode.
Pretty big performance penalty? We're talking about a milliseconds per request, and it's insignificant optimization for the majority of servers.
Still, it's still a disk seek and file access, and the config parser needs to parse and apply the settings *on every single request*. Putting it in your web server config means that it will just be parsed once (at server startup). Plus, you *already have* a config for the site, why not just modify it directly and use it for its intended purpose? Any good host will let you add config lines in the same way as you would with a `.htaccess` file. Straight from [the Apache documentation](http://httpd.apache.org/docs/current/howto/htaccess.html): &gt; Using .htaccess files slows down your Apache http server. Any directive that you can include in a .htaccess file is better set in a Directory block, as it will have the same effect with better performance. &gt; &gt; ... &gt; &gt; There are two main reasons to avoid the use of .htaccess files. The first of these is performance. When AllowOverride is set to allow the use of .htaccess files, httpd will look in every directory for .htaccess files. Thus, permitting .htaccess files causes a performance hit, whether or not you actually even use them! Also, the .htaccess file is loaded every time a document is requested. Further note that httpd must look for .htaccess files in all higher-level directories, in order to have a full complement of directives that it must apply. Also, most non-Apache servers (such as Nginx and Cherokee) don't allow .htaccess files at all.
It mitigates it, but it doesn't solve it. And it is horrifically inefficient. If performance matters, use async non-blocking I/O. Period.
Hacker attacks are not a good reason to go service oriented. It's more about failure tolerance (due to hardware problems or third party service unavailability, not hackers), keeping complexity under control, and scaling in terms of performance and team size. Try to organize your application using components that pass only low-volume, serializable data at their outer borders. This means arrays, scalars, and optionally - value objects that don't contain unserializable items like resources, or SQL connection objects etc. Those components one day can be broken apart as true services without changing their API, but even before that it'll help you think about your apps as a set of small apps, entirely independent of each other in terms of implementation (just the API calls in a small number of "interfacing objects", or endpoints as I call them).
There are lots of "other people" writing libraries and components that are very secure, very robust and very well tested. I think its really important to be selective about what code you use, but even as an experienced developer, writing everything from scratch is probably going to be more likely to lead to insecure, untested code purely because you don't have the benefit of those other people's experience to guide, sanity-check and peer-review what you have written. For example [The symfony http foundation package](https://github.com/symfony/HttpFoundation) has over 200 contributors - thats 200 people who have checked the code, found issues or improvements and fed back into the application. Now is a great time to be learning to build applications in PHP exactly *because* other people have already solved so many of the problems you must address when building an application, and with github, pacakgist and composer its so easy to use them. That's not to say you shouldn't write your own components, but its important to understand when you don't need to. For what its worth, heres a few components that I have found to be robust and could be very helpful when building the type of application you have described: * [symfony/http-foundation](http://github.com/symfony/HttpFoundation) Request/Response handling and Session/Cookie management * [symfony/console](http://github.com/symfony/console) Command line task helper * [symfony/form](http://github.com/symfony/form) Form handling - and validation * [symfony/security-csrf](http://github.com/symfony/security-csrf) Form application security * [twig/twig](https://github.com/twigphp/Twig) Templating * [symfony/debug](http://github.com/symfony/debug) Improved error handling * [phroute/phroute](http://github.com/mrjgreen/phroute) Routing (disclaimer - this is my library) * [league/route](http://github.com/thephpleague/route) Routing (alternative) * [monolog/monolog](http://github.com/Seldaek/monolog) Application Logging * [league/container](http://github.com/thephpleague/container) Dependency Injection * [swiftmailer/swiftmailer](http://github.com/swiftmailer/swiftmailer) Email * [league/omnipay](http://github.com/thephpleague/omnipay) Secure payment handling and subscription management (Paypal,Sage,Worldpay,Stripe etc..) * [illuminate/database](http://github.com/illuminate/database) Popular database abstraction layer Note - I find the illuminate layer quite bulky and it was missing syntax for quite a few features of MySQL I use frequently so I forked it, and removed laravel specific aspects, and added additional functionality. It can be found here: http://github.com/mrjgreen/database. Edit - afterthought :) I forgot to point out that by the time you have combined all these components into an application, you may find that its quicker/easier for you to use a framework like http://laravel.com/ to get you started. The benefit of this is that if you ever have to hand over to another developer they will more than likely be familiar with laravel and be able to get up to speed quickly if not.
@JeEmGu - thank! i think i need to practice more. One part is making sure that I know the syntax and the second part is practicing(putting situations into codes) and running them. Its easy to think you know how loops work, but when real situations come up and you are struggling to figure out how to loop it then you realize the importance of strong basics. 
Just keep writing code man, your problem is not with PHP, it's with programming. PHP is a great language for beginners because it is forgiving, and there is a HUGE community behind it. You sound like you are right at the start of learning, do something like codecademy, and just keep coding. You'll get better as you do more.
stfcfanhazz - yes. sql injection is a big problem- I have read and heard of cross site scripting. Thanks. Will spend more time learning on loops+arrays. 
Step one is to become familiar with the syntax. Codecademy is where I started, not very long ago. Once you've got a basic understanding, the next step is vital; do a project! For example, build a page (no login/authentication to start with) where a user can update their contact information or settings which you have stored in a database. You'll want to think about how you structure your table and the data types in your columns. Build a simple POST form with all the relevant inputs and write a query function which retrieves the user data on page load and fills the input values in your form fields. Hit submit to update the row in your database. Think about things like what input you want and what kind of user input could be a problem. For example, use a php function called preg_replace to strip out any unwanted special characters in an email address or phone number, or strip out numbers in a name field etc. You can also play with input validation so a user gets some feeedback if they try to submit 'bad data' or fail to fill out a required field. I think that would be a good place for you to start :)
hi stfcfanhazz- yes. i have tried doing a bit of that :) but again didnt get very far as my basics were not strong but thanks for your input! have you managed to get to using cookies and object-oriented coding etc.? 
Given your fears I bet you're reading enough books about how to secure servers and so on. The only other tips I can give you are: 1. Log everything and use it to spot atypical patterns (either via software, and by a human operator checking from time to time). 2. Practice for a hacking event with "fire drills". Put code to staging, simulate a hack, see if the logging system warns you (email, SMS, etc.), and how fast you can hit the alarm button to disconnect the hacked server, how the rest of the system will react, and eventually re-deploy the code and get back to normal. 3. Keep sensitive data isolated from the rest. For the sensitive data, use the simplest possible environment, so no side-effects from other pieces of software can occur that can affect this data's security. You can also keep such data encrypted, and the encryption key passed to the server for API requests and never put to this (it's a trivial measure, but it'll stop hackers who don't know your infrastructure from decrypting your data using only a disk dump). 
Did you manage to solve it? Try something like: foreach ($dates as $oldDate) { $newDate = date("Y/m/d",strtotime($oldDate)); }
oh yes i did. someone from the forum helped(basically did it for me and I saw the code, and it was very elegantly written) See the pastebin link. http://pastebin.com/EVBs6Ruh
:) . yes that is very true. it has a very strong community and has a lot of useful functions available, you just need to get a hold of the syntax and you can do a lot.(i have toyed around with printing pdf using php forms) . 
One of the most important things you need to keep in mind is: To become a good programmer, you need to read and write lots of code. Sitting and working with examples a d tutorials won't take you far. At some point you need to leave the shore and sail on your own. I know its hard. But try to come up with some project to build from scratch. Say a simple blog. Then you work on it until it works. It's important to have some clear goal.
Never had a book for PHP. Just used php.net/google to lookup everything. PHP is sure not too difficult for beginners. All languages seem difficult if you are new to programming. Best way to learn is to just code. I remember when I first started out I tried to create stuff I really liked even though they were a bit too advanced perhaps. To me it was a chat system (client and server). Code something you like, before you know it you're a pro!
What do you need to do to export as pdf from php? Do you have to build it with xml?
I think PHP is a perfect language for beginners. What you have to watch out for is its quirks - some who claim are the languages best features, while others say its the language's faults. You could understand the concept of anything really (eg. polymorphism, DDD, DRY), but where the hard part comes in is actually applying these concepts in real life with real data. You won't do that by reading or watching anything - you have to get your hands dirty and write some code. Only then can you *apply* what you read and interpret that into repeatable logical steps in your mind. You have to develop those pathways in your brain. I have found that when you're stuck on how to write code, it usually boils down to either a lack of understanding of the problem or knowledge of the environment/framework I'm using. I never ask myself "how do I use a foreach or while?", but instead asking myself "how can I use a foreach or while here?" At which point you need to assess a few things: what data am I working with and what do I need to do with it? You shouldn't blindly write code and expect things to work out, you need to break down each step of your problem. Computers are really dumb. They can only do what we tell them to (for now).
oh no. i was jut trying to print things onto pdf for fun. nothing serious.
interesting. i imagine you have a com sci background?
agreed. i guess its all about learning by doing rather than learning by reading(again i come from a biochem background(majored in biochem) and I tend to read more which isn't very useful when you are trying something abstract like coding/programming. I think its a different learning process. More of doing and less reading. 
If it's any consolation, I have never been a big reader. My learning has come from plowing through a problem doing lots of research and spending less time on the theory. Its totally doable from your background, just gotta' believe!
Thatonefreeman - I'll take your word and start creating projects that I enjoy, just relying/researching on the information I need and building up. This will be interesting. 
Why's that impressive :P, the school just sucked big time... No, perhaps c# but that was just a few months before that. When I was young I did some html and css but they aren't really considered programming languages. How long have you been learning PHP?
&gt; I struggle with logic(trying to think of appropriate loops and mechanisms) A great way to get familiar with a language is solving problems at [Project Euler](https://projecteuler.net/). It starts innocent enough: &gt; Find the sum of all the multiples of 3 or 5 below 1000. The problems become more and more difficult, challenging your problem solving skills. All the while you're exploring what PHP has to offer to find solutions faster. Many might seem unrelated to real world problems, but it's that way of thinking about or approaching problems that you want to learn. I keep skipping the math heavy ones though ;) Otherwise, Codecadamy has already been mentioned which is a great resource.
&gt; Schattenbaum PHP... Still, I consider this to be an actual resource I would show newcomers to learn PHP The information on that website is so outdated, I wouldn't show it to anyone, especially a newcomer. [PHP: The Right Way](http://www.phptherightway.com) is a much better and up-to-date resource.
I wouldn't deny that it's gotten into the years, but actually wondering what you consider wrong. Granted I didn't go into a all too detailed look but from everything I was able to grasp quickly it still looked fine. Still, obviously there are better resources!
No, because it resulted in an unhealthy flame war. Again. And I'd like to call to attention the mistakes that were made. Again. I'd like to call for tolerance somehow, and discuss objective observations, but I fear it may be too late judging by the number of #popcorn replies to that tweetstorm. I can do nothing about tolerance in discussion about ice cream, sadly. But we're a part of the PHP community here, they're community leaders, and newcomers coming into such an atmosphere can't be getting a good impression. So I'd like to try and fix what we *can* fix, namely PHP related discussion. Edit: response to ice cream edit above
I'm curious if Anthony dislikes Laravel in particular, or just the idea of full stack frameworks. Because if this is only a Laravel-specific dislike, I'd love to hear his thoughts about how you do dependency "configuration" in Symfony: https://github.com/Sylius/Sylius/blob/master/src/Sylius/Bundle/ContentBundle/DependencyInjection/Configuration.php#L113
the part about the cost is true, the other isnt though ... we have done A LOT of research, and theres a really small amount of users that do access our site from desktop AND mobile to do the same stuff ... the bevhavior and what people do on the site is completly different, we simply adapted to that. thers a lot of nice nielsen reports on that topic btw, i think in some years for most sites that approach will become a standard cause the acitivites you do mobile (and how you want to do them) are very different, theres also a growing amount of users who simply dont know anything else than mobile, they dont know desktop etc - and most site/product owners are still using the values they learned from makeing desktop site - which are very different to mobile values. (it starts with VERY simple stuff like, why would you display **** on a mobile phone for a password, its just not as good as ALLOWING to hide password, but showing it by default) 
Once again Taylor shows me why he doesn't deserve 10% of the respect he gets.
I believe the account he uses is /u/utotwel
Maybe try reading through [PHP The Right Way](http://www.phptherightway.com/). It has a lot of good resources from basic concepts to advanced topics.
I am not against Frameworks. I probably need to make this more clear in the article. I am against newcomers being thrown into the framework world without them having had a chance to understand what's happening behind the frameworks. When faced with problems those who don't know the basics simply won't be able to solve those problems alone. I want newcomers as well as companies to understand that - just with basically anything else in this world - the basics are super important. Because many things I see lately is people skipping the basics. This is the core problem I'm having ;)
Anthony's original comment was rather baseless, vague and unnecessary to begin with. I'm really not sure why we feel the need to attack projects in this manner. Creating strife for the sake of creating strife. I've got a lot of respect for both of these guys. I met Anthony a few years back at Sunshine PHP in Miami and he's a great guy. But this really should have just been a private conversation. Either that, or Anthony should elaborate with some kind of blog post. The tweet comes off as an attack and he's in a position where public statements like this one should be given more consideration. I just worry that this in-fighting over trivial matters may lead to people leaving the community, and I'd really hate to see that happen. The work both of these two have done for the community is incredibly valuable. They're both passionate about their craft... sometimes to a fault. Now let's all go have a pint and remember we're on the same team.
I'm not sure what made which popular. Laravel's "awesomeness" made Taylor popular or Taylors attitude made Laravel popular. 
I'm on the opposite side. There is no valid criticism here. Anthony used to post very insightful articles explaining why he doesn't like an idea and gave indepth reasoning for it. Accept it or not, you could read his articles and learn things from it. This is what we call a constructive criticism nowadays? &gt; a ton. First, coupling. Second, coupling. Third, insane coupling. Fourth, interoperability. Fifth, coupling. Oh, that thing, along with facades. Every single day one of those Laravel is horrible articles pops up and mentions those anyway. This is nothing new. Instead of tweeting and calling Laravel as a horrible thing, he could write an article like he used to and explain what could be done better for the sake of being decoupled. As of now, this is just a pointless Twitter rant with no actual information. 
&gt;There is no valid criticism here. I didn't say there were any *here*. In this instance perhaps it would have been best to either just ignore it, or ask politely for elaboration on the criticism. I've seen the same response on here, on IRC, on github a million times over though.. every time a valid criticism or suggestion is made it's met with anger and childish insults at best.
Hahah, sorry, I thought so, I'm just a little off today!
You will never know :p
What has Laravel done for the community? Besides give it a slightly more modern version of a monolithic framework to fall in love with for 5 minutes, I mean.
&gt; something like Symfony is a framework and a set of libraries, just like Zend. So it is still modular, you can easily use just a part without caring about the rest Try to use a Symfony bundle without the rest of Symfony. The fact you see separate packages in Composer, and separate namespaces in PHP doesn't mean they're decoupled. Symfony looks modular to you only because what came before it was even worse. But it's still not modular. 
&gt; or ask politely for elaboration on the criticism. Now that you mention that https://twitter.com/ircmaxell/status/632543444817313792
[**@ircmaxell**](https://twitter.com/ircmaxell/) &gt; [2015-08-15 13:24 UTC](https://twitter.com/ircmaxell/status/632543444817313792) &gt; I find it telling that when issues are raised, the default response is "you are wrong" rather than "I don't see that, can you elaborate" ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
projecteuler.net seems very math heavy!!! almost like math class(i haven't done math since college - last time I did Calc was in college year 1) Do I need to review them again?
I blame a lot of it on the lack of information. We have the old stuff pushing PHP as a html enhancement and then stuff that are framework specific. Finding things that say, heres a better way to use PHP to create a modern web application without relying on frameworks is not very easy.
For the sake of every other developer that will have to some day work on the code base, don't roll your own framework on anything that is not a personal project. Just don't. 
Twitter is a platform for expressing~~ion~~ your opinion and sharing articles, are you saying he can't at that moment express his opinion without writing a blog first?
Still waiting for ircmaxell's blog post about the better alternative to MVC... Day to day practice in real world seems to be lacking, otwell has a point.
Someone (a close friend) should tell taylor to stop tweeting, he's making himself look really bad right now (still tweeting)
**Objectively**, Laravel lowered the entry barrier significantly. With the brands built around it (again, objectively excellent marketing and business skills on Taylor's part), it effectively becomes a "Start here" beacon for newcomers. Concretely, it expanded the community. Now, whether or not it did so with quality PHP or shortcut-PHP, and whether or not one or the other side is elitist, conceited, egotistic, [insert favorite adjective here], is completely irrelevant. The *fact* remains that it contributed greatly to PHP's renewed popularity and brought in a new wave of next gen devs who, if educated properly, will carry the torch forward. So, subjective assessment about quality and whatnot aside, Laravel DID benefit the PHP community at large greatly, and I love it for this, even if I don't use it.
Hear what your saying "try using a Symfony bundle without Symfony" well that's because you're not supposed too. A Symfony bundle is essentially just a bridge or a wrapper to a different standalone bundle to Symfony in a way that Symfony wants it to behave in its ecosystem (a service, doctrine entities, listener, routing groups, config, blah blah) But the items themselves are, at least lately, all pretty disconnected now. You can use Twig without Symfony, where TwigBundle is Symfony's bridge, Guzzle has a GuzzleBundle and standard composer package for the standard library. Same with and especially Doctrine (though the Doctrine Bridge is HIGHLY interconnected into Symfony's ecosystem. It's painful trying to use a different DBAL/ORM than Doctrine). Also just about any Symfony component written for Symfony ncan be downloaded and used separately even in bare metal applications http://symfony.com/components But no ones saying you gotta use them that way either. For example, when dealing with Redis, there's a sweet Symfony bundle called Snc/RedisBundle that sets up some easy config for settings, places it in a nice service container, and exposes your Redis queries in the debug toolbar. But this thing is really just a bridge/wrapper for Predis which is installed separately as a dependency, and 100% usable in and out of Symfony by means of a simple instantiation, anywhere. 
While this might be true, I wouldn't say that expanding the (already extremely large) PHP community is a "great" benefit. The unfortunate fact remains that "easy" frameworks rarely teach good programming practices, and Laravel is no exception. It is very hard to market a well-tested micro-framework that does almost nothing (in a good way), despite the fact that it is probably a better foundation for an application. At least I haven't figured out how to do it.
lol why'd you edit your post completely
And never forget: It's not wrong to search for help online. Even the most experienced people tend to search. :) Making something on your own will bring you more knowledge, doesn't matter if it's made in a good or bad way. But making something that you feel that you know how it works is important.
&gt; Anthony's original comment was rather baseless, vague and unnecessary to begin with. Well, it was a tweet. It's not like he has a lot of room to elaborate.
My favourite part about all this discussion is how people defend Laravel by stating its low barrier to entry, specifically non-artisans.
**Update:** Anthony apologized and we may be getting a podcast out of this discussion. https://twitter.com/ircmaxell/status/632696502498947072 Guess I'll sum up the discussion: - Anthony tweets his tweet which everyone has read about laravel - Anthony briefly discusses his concerns with another user: - **User:** What makes it worse than any other thing like it? - **Anthony:** it is not worse than a few of them. But many are better (micro frameworks, as well as symfony and zf) as far as what, hidden complexity. It makes easy thing easy, while making hard things impossible. all the while coupling you so deeply to it that your only hope of refactor is a rewrite. - **User:** and coupling yourself to a framework is usually lack of understanding the consequences from the developer. Not the FWâ€™s fault. - **Anthony:** strongly disagree. Frameworks set the stage for how to use them via conventions and community. It is by definition their fault. - **User**: how can we promote best practices without raising the bar too high? How can we promote decoupling without overwhelming beginners? - **Anthony**: by teaching beginners what they need to know, not telling them they don't need to know it. This thought that a beginner should be useful in a professional context is insane. Show me one other branch of engineering that allows that without serious study\ - **User**: these are though questions. Laravel promotes simplicity. Preaching decoupling from the beginning introduces a much complexity. - **Anthony**: simplicity and easy are not the same thing. It may make it easy, but it definitely doesn't make it simple. Another notable [quote](https://twitter.com/ircmaxell/status/632542204322553856) from anthony: "@diaspar3 for the record, I am not talking about facades or helpers here. I am talking about the FW itself and illuminate." &amp;nbsp; Then Taylor came in swinging in full defense mode and the discussion kind of went left field [here](https://twitter.com/taylorotwell/status/632564915807481856), to be honest I think he read the original tweet and not the comment chain and went on the attack. My personal opinion though. &amp;nbsp; **Notable quotes from Taylor:** - Have you ever owned a business fulltime - *searches for code, still doesn't find any* - [also the "PHP community" is now selling out my conferences... Might want to reconsider your approach :)](https://twitter.com/taylorotwell/status/632589905005162497) - [I'm more than willing to walk the walk... I'm not a talker](https://twitter.com/taylorotwell/status/632594009735561216) The list goes on lol &amp;nbsp; **_Just wanted to make it clear the discussion started off civil from what I was reading_** Edit: Added some more quotes. 
That's because micro-frameworks provide micro business value.
What definition of business value are we using?
The "I can hire no experience people and let them churn out generic website for huge money" business value. Then you start having to do custom jobs which are not a CMS or Blog and manure starts impacting some rotating wind generator. And 5 years down the line you have an un-maintainable application: either you continue trying to pay inexperienced coders and accumulate issues. Or you burn money trying to get experienced ones who won't get out as soon as possible once they discover how bad your code is.
Great write up. My two cents: To any of you who doubt the ease of learning PHP code, let me explain to you, that I went to college and earned a double degree in Classical Civilization (i.e. ancient Roman and Greek history) and Early American Literature. I have no formal training in Computer Science or Informatics at all. After graduating I took a few courses in HTML to learn how to make web pages for a retail store I worked in. In that process I discovered PHP, and ended up building an e-commerce and inventory management web application for that retail shop. After 13 years, where I currently am a lead developer for a major university, where I have full knowledge of how to work with not just PHP, but also Java and Python, and everything else in between, I look back, and think that if it wasn't for me stumbling upon PHP, that taught me the rudiments of programming, I would have never made it as a professional programmer. Just food for thought. @manuakasam I completely agree with this article, that getting into development with a framework-first approach is sadly limiting to newcomers, and the industry is ruining there chances for future growth. PHP is not hard, it's just hard work to come up with great working concepts (which I'm sure the developers of Symfony and Zend experienced when making their frameworks), and that is the beauty of learning the basics first, and then building tools that make it easier for others to get the job done. Programming is not a business, it's engineering first and foremost. Learn how to build, don't learn how to sell how easy the tools are to implement.
YOUR MOTHER COULD USE MORE WORK AND LESS ADVERTISING
I think he is talking about here on /r/php, he gets a lot of hate for basically every post he makes like 99.9% of the time
Valid points, and they're definitely not limited to PHP. Ruby (via Rails) tends to be quite aggressive in the "just follow the framework" style, especially for newcomers. CS classes can't seem to keep up with modern development, and Google always seems to enjoy returning very stale results on the best way to solve problems. I'll say that it's not necessarily a bad thing, though. If people are going to dive in and just start hacking on a project, they're far better off as a newbie to follow the patterns of a framework than to try cobbling stuff together (that's exactly how PHP has earned a poor reputation over the years). It's not enough skill or understanding to work on something larger, but it's also less likely to produce something horribly broken and insecure than a pure DIY job. Professional web development skills are a moving target, and tend to be moving towards even more high-level tools. Just as I no longer write C and have never needed to touch ASM, the underlying stuff is generally mature enough to not worry a whole lot about it. I also don't need to know how a transmission works in order to drive my car; though I've never had a need to debug a transmission. What I've seen is that less experienced people tend to not know how to debug the underlying stuff. Part of that is that the tools aren't mature enough to not need to do so, but I've found it pretty alarming when people with many years of professional software development experience can't (or won't) use `grep` to reason about a library. More consulting gigs for me, I guess. It comes down to the developer's curiosity, I think. Plenty of people are happy just working with what they're given and go home at the end of the day. Others prefer to dive deep and find a better way. Both are perfectly fine, although the latter will probably present more career opportunities
They just need to de-couple from Twitter for a while.
Just shows how much people suck, unable to be genuinely happy for an excellent accomplishment (writing the most popular php framework yet) - and a whining liberal (offer a complaint, with no solution). Suddenly, the veterans of the PHP world find it cool to hate on Laravel. Well, if you can't join em, hate on em, I guess - right?
It seems the arguments in favor of Laravel are the same as those in favor of PHP. It may not be the fastest. It may not be the best designed. But it's easy to use and it makes development much faster compared to the alternatives. But for whatever reason, much of the anti-Laravel crowd are perfectly fine criticizing Laravel for the same reasons they favor PHP.
I didn't edit it, I deleted it and posted this one, because the original was too meta for you to get my position. Seeing as you putting words in my mouth and your "lol" get the upvotes, I guess objectivity has long left this thread.
The fuck are you even talking about, dude?
I would go for a up/downvote system with the option to leave a remarks on why he gave a good/bad score. I think using a n to n score is easier to corrupt, you make a few accounts set it to the lowest score and you won't a less reliable score in my opinion. &amp;nbsp; A Ideal rating system would be for me is &amp;nbsp; 1 A up/down system. &amp;nbsp; 2 A comment option. &amp;nbsp; 3 A captcha. 
This is a schema definition and ensures your configuration is valid. It isn't dependency configuration.
Also this is a tu quoque fallacy, the validity of criticism of Laravel has nothing to do with the validity of criticism against Symfony. It's just a red herring. https://en.m.wikipedia.org/wiki/Tu_quoque
I've spent zero time doing the stupid shit they tell you (this is how you make a variable. Type this into your computer) There's SO much material out there it's overwhelming. First thing you ought to do is stop and go back and learn how to learn. You can't possibly consume all of the information that's out there. What's worse is so much of it is in the screencast format. You don't have the time to sit through all of them, especially when someone's pacing is so slow. I learn best by having a goal in mind. Start out with something you want. Don't just build a todo list or blog for the sake of it. That's so boring. Next, only learn the absolute minimum you need to make something work. Learn to read the first and last sentence of a paragraph (everything in between is just supporting evidence if the author knows how to write). Learn to scrobble. Skip through everything until you get to a point where you don't understand and then go back to where you do and start from there. 
1. Sessions in some sort of database (preferably in a K/V store). 2. If you searches, use a search engine like Sphinx or Lucene. 3. Databases - Clustering (Master/Slave, Multi-master, Distributed). If you use MySQL/MariaDB, check out Galera. 4. Static content (images, JS, CSS) in a CDN (can be your own CDN on a small cluster of nginx instances) 5. Caching ~~is must, and you should have it in some centralized location, DB (K/V), Network shared, etc...~~ can help in some cases (HTML output &amp; DB Queries). [edited for order and updated information] 
To be honest, worry more about the functionality than the scaling at first. One thing you can do to help yourself in the future though: Write nothing (except maybe logs) directly to the server. Example: Don't use file based PHP sessions. Write your sessions to a shared storage (DB, redis, etc). Other things like caching will come naturally as you grow, focus on them later as-needed. 
~ zing ~
&gt; I think a big problem in any discussion is making absolutist statements without factual backing. On Twitter, that is just about all you can do. It's more like a rap battle.
Communists, or something.
Yes, I think that is the case.
One reason why companies harp on frameworks is because it creates a common standard way of implementing the code. If I'm using Laravel and working on someone else's Laravel project I'll know where the database definations are, where the tests are, how the tests are being done(extending TestCase), and I have expectations on how they're interacting with each database table. The other reason for frameworks in PHP is really to gloss over the ugliness of PHP being a 20+ year old language. If I'm using Eloquent to interact with the database, my app probably won't end up with a bug down the road in MySQL because I forgot to escape database inserts. There are also a lot of bugs that can get introduced when accessing the raw variables like _GET that frameworks will autohandle for you with good Request/Response objects. There's a lot of security(CSRF), best practices, and solid project layouts that happens when you're working in a framework. I think pointing newbies away from them isn't going to create better habits. We've spent 20 years getting to this point for a reason. 
&gt; A really ugly DSL doesn't really imply tight coupling I didn't say *anything* about tight coupling. But that DSL is borderline masochistic. Frameworks are supposed to make development easier, not harder and more confusing. That DSL is: * unreadable * extremely prone to errors * unnecessarily complicated Who the fuck wants to build applications using APIs like that?
Good reading? Check out the High Scalability blog: [http://highscalability.com/](http://highscalability.com/)
I was not making an argument therefore I was not committing a fallacy. Im simply implying I would find it interesting if ircmaxell had a problem with just Laravel given Symfony is built the way it is....
It's a config validator. It just describes the expected format as a tree of nodes. It can be a tad more elegant than this (and Sylius can format it *way* better than this), but nothing fundamentally different.
As someone who's had experience with launching and then maintaining (including significant changes in business needs) multiple large Laravel projects over the past ~3 years, I believe I can write a reasonable, experienced critique of Laravel based on real-world experience. And it's actually something I plan on doing once my work-life balance has settled down a bit. But I would consider it bad form if I just condensed my conclusions into 140 characters and then tossed it online. It seems obvious to me that it'd foster the wrong kind of conversations.
All right, that sounds quite interesting actually. I hope you get it done, when you can. Make sure to go through the codebases and remember all wins and fails you had, because memory lies ;)
This is not a post against frameworks. If you think it is, clearly you didn't read it well enough. It's about newcomers not understanding the basics of PHP / or the nature of web development and simply being thrown into a random framework. THIS is the bad part - but that's not the fault of frameworks!
Then don't use a tweet. It's incredibly difficult to get a point across in 140 characters. I believe Anthony eludes to that somewhere in that shitstorm. Clearly not the tool for the job. Unless of course the intention was drama.
why dont you just use "if this then that" ? in any way ... any service provider that supports cron jobs will be good enough ... you could use a free amazon ec2 instance for a year ... too ... i honetly believe you wont find many providers that dont support what you want just make it a cronjob instead of an endless loop - its a bad approach anyway
This seems like a really roundabout way to implement the Repository Pattern.
I like taylor, and I like Laravel, too, but unfortunately watching Laravel grow over the past few years also seems to have led taylor to fall back to the "the community loves me &amp; my project" argument more and more often. Both people in this debate have some fair points, but I really hate to see the "I'm popular so I'm right" attitude expressed.
so in 140 chars, whats your disposition? my thought is that laravel *is* for noobs and anthony has a point, but is not communicating it well due to the medium.
but what is faster than php with decent ecosystem? go perhaps?
Laravel is not nearly as shitty as Taylor is. 
yeah, it's great to go back to the content you had a really tough time with and how much easier and apparent it becomes. really challenging yourself on the harder things makes it easier for the next hard things to do, you are better equipped and conditioned on how to tackle it. 
You use the tools for the job at hand. Hell, even Wordpress has its role in the world. Somone comes up to me and says they want a website in 4 hours, it's what they are getting.
That... was funny about 15 years ago.
wut. Micro-frameworks provide as much business value as you assign to them.
That was my point. If you know up front that twitter isn't the right thing to use to get your opinion across, why on earth would you then go and use it? Using "Oh it's only 140 chars" as an excuse for being a shitty person is really not good enough.
It's not about the separate blog posts, it's more about the atmosphere they create if they reach critical mass. Laravel can lose mindshare as fast as it gained it. And that has happened with technology before. Actually, it keeps happening all the time. You can avoid that phase of Laravel if you quickly shift gears from "easy to start" framework to a "mature, good for large, long-term app maintenance" framework. That's what Symfony did from v1 to v2. I'm not calling Symfony ideal, but their shift in focus is obvious. Think about it like the Harry Potter movies getting progressively darker over time - that's because their audience is growing up for each new movie. It went from a kiddy magic story to a borderline horror-action. If Laravel keeps shooting for the beginners, then you should expect those first beginners - as they get intermediate and advanced over time - to revolt, and drag away the new beginners with them. The first few waves are small, but then by the time they get big, it's too late to change direction. **EDIT** You can read more about these kind of dynamics in this book: https://en.wikipedia.org/wiki/The_Innovator%27s_Dilemma It's written entirely from a business perspective, but with heavy focus on technology companies. I think you'll find it very relevant.
You mean [decorators](https://en.wikipedia.org/wiki/Decorator_pattern)?
Learning MVC, migrations and tests are the basics and is web development. Why PHP is confusing is because there are so many frameworks for it and they're changing all the time. It's a very fractured community with docs that are all over the place. Newcommers into Rails don't experience the same problems. 
Well, that seems like nitpicking to me. Since most server configurations are based on the file extension, you are (in terms of the PHP interpreter) making sure that .jpg files are handled like .jpg files (and not like .php files), if you force the correct file extension. Sorry for the unclear phrasing at the beginning, but by now it should be clear that my point was essentially that every user-submitted input should be validated (or not there in the first place, I prefer generating the internal names of uploaded files) and that does not only include the file's content, but also its name. For this attack to be possible the developer had to violate several security principiles at once and proper input validation is one of them.
the best thing that has come out of this thread so far lol
And so is Rails. Last I checked Rails was still pretty darn popular. The argument you are making could literally be made against EVERY single framework in existence in every language. I don't see the point.
I don't know where you get your numbers from, but Rails peaked a long time ago. The whole Ruby market has only been going down last few years in TIOBE. Rails will be around for a long time I'm sure, but it's not *that* popular.
You are vastly simplifying the "just integrate it" story. :) Anyways, have a good night.
Interesting that he tweets a few days after Laracon. Whatevs, yo. If he doesn't like the framework, he doesn't have to use it. Although I originally felt it was over-engineered, I've come to enjoy using it.
OK, I was just trying to be friendly with you. Reddit is apparently making that hard to read because my tone is not dismissive with you at all. I'm not going to continue this conversation further.
Also, I don't have a "head in sand" reaction to people who don't "unconditionally love everything I do"... that again is a false narrative you want to believe, not reality.
I'm glad is not. Both of you are well respected in the PHP community, I attended your SOLID talk at PHPNE 2 years ago and became a better coder because of it, and Taylor puts so much care into this framework and it shows. Glad to hear a formal discussion is scheduled, I respect both of you equally.
I'm not sure why Laravel creator always did that. Even his Elixir. It has a language call Elixir :(. I was shocked when I saw that I though they bring Elixir into Laravel somehow.
You're confusing "modular" with "independent". Why expect a plugin to work independently of the thing-it-plugs-into?
That's the truth
Wall of text crits you for 50k damage.
&gt; No one loves either Drupal or Magento, they just use them out of a need. This is true. _src: Drupal dev_
&gt; It is rather common that when someone makes point A.... I agree. I was not trying to disagree with ircmaxell. I have my own criticisms of Laravel. I am just a bit offput that its Laravel that gets sniped at when Symfony is sitting there festering in an obtuse API.
https://aws.amazon.com/lambda/ Maybe check out the Amazon Lambda service.
Sniping isn't any good. Being dismissive isn't good. This was an example of two people communicating poorly in public.
You are being irrational. You can't validly dismiss arguments by saying "everything else has arguments against it too", that is a bullshit argument and you know it. What matters is the substance of the arguments put forward and whether or not they are valid. It of course means something when valid points are raised against a particular framework.
You can ALWAYS use "native" PHP without a framework, even when you're using one. It's pretty expressive. 
Coupling was Anthony's main criticism of Laravel, so I assumed that's what you meant. No matter. Yes, I agree that DSL is shit, but it's an alternative to the more commonly used YAML. I don't know enough about Symfony's DI to know the pros and cons of the two, but the Sylius devs probably do. In any case, they **chose** to use the PHP DSL instead of the easier to read YAML config format. It's not a decision imposed on them by the framework.
Why wouldn't you want to write more code? Programming is fun. 
Do you expect this to be a permanent thing, or do you expect this (understandably unmentioned) drama to blow over and you to return?
That's fine. This was mostly posted to notify anyone that might miss my presence in discussions and, down the line, wonder where I've gone. Most of the people reading this, they'll probably wonder, "Who's this douchebag? Why should I care? Get this shit off my front page *downvote*." And that's okay. But I don't really know who actually enjoys reading my posts (recent experience has taught me that this is a larger group than I gave myself credit for), so I can't effectively contact everyone individually without making someone feel left out.
For learning, yes, I think frameworks are limiting. For production, I believe it's the opposite. In terms of other disciplines, you wouldn't expect a physicist to establish theorems (the framework) without learning the fundamentals of math (the programming fundamentals), in order to prove those theorems. To answer your question: yes.
Great. Either 140 char replies or real-time, chaotic discussions. Just great. I tell ya, go high enough and people start shaking the ladder until you _want_ down. I'm standing here thinking "How fucking hard can it be to just write stuff without the hot-headedness?!". And I don't even know if this is targetted at you or at the people you have beef with. Anyway, I learned alot from you and your twisted (nick)name. Thanks for that. Keep writing on that blog, btw.
They say no publicity is bad publicity; maybe this is all just a facade...
your story is inspiring. I have a similar story as you, but its just that I have been intimidated with so much material out there and trying to grasp all I can at one time. The biggest problem I see with myself is lacking the basics and trying to do complex things. Thanks for sharing. 
No, caching is not a must. **Profiling your code is a must**. Until you *know* that adding the complexity of caching is going to solve *real* performance bottlenecks, then adding caching is ill-advised.
Quitter.... 
But "Rails" essentially is a similar "problem". It's nothing but a framework on top of the language ;) Granted it may not be as extreme with RoR as it may be with PHP and it's frameworks, but ultimately it is the same dilemma. 
I think the whole argument can be summed up in terms of Star Trek: https://www.youtube.com/watch?v=tMrzdKzQTf8
Thanks for this write up. I'm really glad that I was able to get pretty similar stories out of other individuals since this write-up. I'm glad that I am not alone with my concerns.
A bit of analogy: we tend to think that scalability is like growing a balloon, we try to make it stronger or more resistant so it can withstand the ever growing pressure evenly. In practice it does not work that way. This is worth reading so you understand what's coming ahead of you: http://highscalability.com/7-stages-scaling-web-apps But the greatest simples and single advice is: try to decompose your code as best as possible. Having an single monolithic code design will create lots of problems to add scalability later. E.g., if a class that loads something from a database has inside itself all the database connection logic, it will be amazingly harder later to add a cache layer. Another example: if there is a page which is not decomposed into smaller components, it will be much harder later on to decompose into parallel renderable components (and you're going to hit a PHP limitation anyway as it does not allow for concurrent execution). Ensure things are separate, that concerns are not mixed, and you should be able to cope with the first stages of scalability rather well. After a certain threshold, you will be talking architecture - and not only code. 
We're running into some issues with Laravel with our current project as well. I hope you can elaborate on the issue you raised on Twitter. Blog article, explanation video or something like that
I think the key to creating scalable web apps is to build API first. Many projects start off using a PHP frontend talking to a MySQL (or similar) backend. Your only chance of scaling that is moving the database to it's own server. When building API first, it adds a lot of possibilities to scale, not to mention you only need to maintain one 'source' for multiple frontend's (i.e. a website, app, maybe intranet etc). Make all your frontend app's talk to the same backend, it will be much easier! I also somewhat disagree with caching being a must. Caching should be the icing on the cake, it shouldn't be absolutely necessity to get decent response times. Sadly caching is usually used to patch a wound instead of actually healing it.
I think the articles rings true for people new to programming, and in some way applies to any activities. I have a friend who is experienced in C#, ASP.NET, MVC etc. His new job was over-taking a ZF2 project. So he picked a book on PHP5 but after reading it he was of course still lost. I had to explained to him autoloading, composer etc. Setting him up with PhpStorm, Vagrant, Xdebug etc. Mad ZF2-style configuration was not helping either ... Ecosystem is still hard to grasp in any language. Knowing the language is a small subset of it. The challenge is how to learn it the most efficient way. The rest is experience and at some point you can't escape that. ps: now my friend has been task to rewrite the project in Java. Oh well.
I don't mean ircmaxell, but in general. I've written here before about modular design and people seem to be highly receptive. Someone will eventually pick up the slack and start pushing detailed materials about this, but just the idea of arguing with Laravel fans is... tiring.
The article does state it is a decorator pattern. But the name "wrapper" in this case is more descriptive of the actual behavior.
MVC is not simple if you're just starting out. And your feedback doesn't match anything that I'm saying in my post. I nowhere said that learning PHP is difficult. I said that the ecosystem makes it so that the basics aren't even taught anymore. And thus it creates a difficult barrier for entrepreneurs to dig deeper into the language level.
I first got really into PHP back in late 2011, when I was about 15. I was fairly knew to writing dynamic websites like that, even though I had been writing HTML for about 4 years before that. I didn't use a framework, everything I created was pretty much scratch. I had the dream of creating a social networking site, and I actually got pretty far too. I had profiles, you could comment, post statues, I used Ajax to refresh profiles in live time. I'm actually pretty proud of it, I haven't created a website like that since then. 
I doubt it.
idk, I view node.js as an implementation tool, like anything else, maybe appropriate for certain circumstances. I think it became popular via HN and reddit hysteria and the "functional" movement crowd..it is legitimate, but last I looked its adoption has leveled. we will see if it has staying power I guess.
You'd take a project with a 4 hour requirement? Sweet, now I know where to send all the bad clients! ;)
More like Jets vs Sharks: https://www.youtube.com/watch?v=uVspqShcXSA
PHP drive by's. There'd be three ways to do it, one correct (but subtly broken), one obsolete and one insecure ;).
And Ruby, PHP, Python are nothing but intepreters written in C which itself compiles to machine code. But that doesn't mean we start newbies in on assembly. There's always a deeper level to learn. But for newbies it's a lot more important to teach basic programming concepts like testing, documentation, good project layout, how to bundle dependencies, etc. 
[**@ircmaxell**](https://twitter.com/ircmaxell/) &gt; [2015-01-16 14:54 UTC](https://twitter.com/ircmaxell/status/556102253472272385) &gt; Can anyone explain why a class representing an invoice executes shell commands??? This is a classic SRP violation: https://github.com/laravel/cashier/blob/master/src/Laravel/Cashier/Invoice.php#L33-L45 ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Two t's.
I recommend doing exercises - get a book and do all of those. Find good tutorials on the web, do those too. Sometimes things won't be clear, but push on anyway - I like the idea of the 'eureka' moment when previously confusing things start to make sense. Always do the practical stuff - getting something working is satisfying as well as explanatory. By working through different projects you get the same thing taught from several different angles, and this helps the student to make sense of it. 
**tl;dr** *eZ uses Symfony 2 full stack, so they can use all Symfony bundles, and Drupal 8 uses separate Symfony components, so it can't use all bundles.* The missing part of this article is how do exactly Symfony bundles provide *real* value to eZ users. When you install a bundle, what you get is developer-facing features at the level of the framework. eZ won't get magically enhanced itself. Drupal 8 doesn't use all of Symfony 2, but you can still install Symfony 2 alongside and use all Symfony bundles. The effect, unless I'm missing something, is exactly the same. So, the value to users is... you don't have to install the full Symfony when you use eZ, because it's a dependency? On the reverse side, Drupal 8 is much less coupled to Symfony 2 and they can probably retain a lot of their APIs without BC breaks when switching to another framework in the future. So there's that.
I do drupal a lot and A LOT of the api's were actually just tossed. They retained some of the flavor to keep from upsetting the masses but there is little to no backwards compatibility in the strict sense. Really D8 is almost an entire rewrite because trained devs (OOP vs Procedural) were getting fed up with having to learn basically a new form of php when there is so much great stuff going on with php these days. I think the reason to only use components was to deal with drupals greatest strength and weakness, placing configuration in the database. It's a horrific idea from a CS point of view but it's also what made drupal so popular and I don't believe there is anything remotely close to this in symfony. I'm not saying your wrong but I think it was more the oddities of drupal (being a 10 year old framework written in php4....) not fitting in with symfony and timelines. D8 is already way behind because of the monumental undertaking and to rewrite it entirely in symfony would break what makes drupal nice, you can be an idiot and use it.
That's exactly it: the industry is filled with non-finishers. Laravel is great for code shops or freelancers who are handing the source code over to someone else to maintain. Not so great for the people maintaining and extending it. That said, I am quite happy that the PHP ecosystem is so healthy with competing frameworks - it seems like in so many languages there is a defacto standard framework, and I think having such a healthy competition in PHP pushes the evolution of the language and web development further. 
It's not a publicly visible matter.
When I started with PHP, I started immediately with Laravel. It was a mistake. I learned the framework but not the language. Makes it difficult when you want to do anything outside of the scope of the framework that requires vanilla PHP. I think sound advice when learning any language is to learn the language first, frameworks second. An example of when this is useful is for customizing the framework. Laravel's source (and the source of the libraries that Laravel takes advantage of) is vanilla PHP. I had trouble understanding the magic behind Laravel because I didn't know PHP all that well. Once I became more familiar with PHP, I could decode the magic and it made working with Laravel that much better.
You may be looking for this function: http://php.net/manual/en/function.set-include-path.php
that's why I prefer symfony. it mostly stays out of the way, and design itself is pretty good for a web framework. IT's also easy to understand how things flow. There's not a lot of magic there.
&gt; Would you still say that Laravel is worth picking up? Yes, absolutely. My biggest criticisms of Laravel boil down to two things: 1. Using Facades or their global function equivalents is a great way to hide dependencies and violate SOLID principles in a way that can and will come back to bite you later. Only use them where you're tightly-coupled to the framework anyway and have no plans to unit test (controllers, view composers, etc), otherwise use Dependency Injection. 2. Eloquent is incredibly convenient, but the ability to call the query builder directly from Model classes results in a ton of places where you can run into difficult-to-debug errors (for example, calling a missing method on a model generates an exception referencing the query builder). Because it's so convenient, it can be painful to switch if you want to use something like Doctrine later. This is due to all the magic enabled and supported by accessing model attributes as properties instead of getters. EDIT: My advice regarding the above two issues is simple. For #1, just don't use facades outside of places that aren't tightly-coupled to Laravel anyway (like Controllers and Artisan command classes), For #2, think hard about how and when you use Eloquent, especially for highly-complex models with a lot of business logic in them. Laravel is hardly perfect but it's still a solid framework that I've built excellent applications on top of.
Are you using a modern IDE?
Remember where I said that would be bad form? ;) I've [mentioned my two biggest criticisms here](https://www.reddit.com/r/PHP/comments/3h3nv8/ircmaxell_tries_laravel/cu5al5e). It's a few paragraphs long.
&gt; Sessions in some sort of database. Make sure it's a database that can scale with replication if you want users to be able to switch between different servers without losing session information (such as when load balancing). Probably a key-value store instead of a traditional relational database.
Ask any school teacher. The kids that can't just ignore shit like this are no more mature than the person who said it in the first place. 
if that helps: why not just create php script to do just that you can call any php script from cli too - and thus from jenkins. 
Keep learning both! Knowing javascript lets you build more interactive web applications.
Thanks a ton for your answer! 
sublime text? yes.
halfercode- thank. will do exercise and practice. yes. the eureka moments is what really motivates me. when it works. :)
I think you're entirely right about the coming backlash. I think PSR-7's middleware concept and having the request/response object be a first class citizen of the language is evidence of this. When all libraries are using the same interface for accessing the request and response, we can truly reuse components without a ton of translation to make it work with a given framework. I'm really excited for the day where I can truly pick and choose my component based on the merit of the component alone, and not how well it's integrated with my other components.
I'm a php developer in Vancouver Canada. I'm from West Virginia and was visiting home all summer. I'm leaving for Canada in the morning though. Best of luck!
You could: * simulate a user/browser interaction with something like phantomjs * or login via telnet to change the settings on the router
Valid points. A strong coupling to a framework itself does have it's dangers. But as a community limited in size I don't think eZ Systems did a bad choice. They struggled with their own framework and component library earlier.
I think eZ chose ok, the thing is - the choice benefits the smaller community that *builds* the eZ platform, because *they* can quickly add bundles and use it to add eZ functionality. Those using the resulting platform don't benefit that much. So the issue is the article is trying to sell the benefit of bundles to the wrong audience. But, anything that gets the word out, I guess. This article is the first time I heard of eZ being rebuilt.
No one ever got fired for ~~buying microsoft or oracle~~ using core php
Can some bright minds say something about this? It seems useful, yet nobody has yet said anything about it. Is there a more popular successor to this one?
My recommendation would be to just take some algorithmization excercise book and try to go through the excercises there. Like, you know, the basics where you mostly just use your brain + basic language syntax and try to come up with efficient solutions for sudoku solver, 8 dames problem, etc. The book won't most likely be for PHP (it will be either C or Java), but that's probably even better - you can use the given solution as hints how to solve it, but you won't be able to cheat by just copypasting code. ;)
the be public, leave the private ... whatever it is
PHP is more essential, while client-side JS is more in the realm of nice-to-haves, but PHP + JS allows you to create better experiences and it allows each codebase (one in PHP and one in JS) to remain focused and handle its own concerns. When you handle everything through PHP, you need to do some nasty stuff like Post/Redirect/Get, which isn't needed when you fluently control both server and client. There's a great overlap between PHP and JS, they're roughly in the same family of languages and the differences are mostly syntax and APIs. Which, over time, you'll understand aren't the hard parts of mastering a language (but it's about organizing large bodies of code, architecture, algorithms, design and so on).
&gt; Curated list of PHP libs for **web-scraping** and data-processing Oh sweet. \*clicks\* &gt; Web-Scraping Frameworks &gt; &gt; TODO Damn it OP
If your project is object oriented or you are using libraries/classes that may create name conflicts it is neccessary to use namespacing. 
IMHO most of those "fallacies" are quite entertaining, and sometimes useful to keep in mind, but also overrated. In this case, *if* there is a double standard (/u/phpdevster never said there were, just said he'd be curious to know if that's the case), I think it would indeed make Antony less warranted to criticize laravel. It wouldn't make his argument invalid per se, but it would make his point of view irrelevant. That said, although I strongly disagree with him about laravel being "horrible", I suspect he'd either find Symfony2 just as horrible, or explain why he makes a difference between the two frameworks, and I'd be genuinely interested in hearing that.
CentOS 7, I like the stability and enterprisey-ness of it :) In a dark past I ran Gentoo on a server. I don't know what I was thinking.
I can write a lot! Many of the popular frameworks are technically terrible. The following is a list of musts and must nots for frameworks: Frameworks must not involve magic. Laravel and many other fancy and nice frameworks involve a lot of that. Magic makes programs harder to debug, and security flaws harder to analyze. Frameworks should not invent a new language (yes, even for templates). Frameworks are there to ease the development, not to replace it. Frameworks should be modular and lazy loaded. 90% of the features are only used in 10% of the applications. Lets not load them by default. Zend achieves this beautifully. PHP Frameworks should not be very restrictive. Many frameworks lock you in a certain programming convention, like Java. If PHP is popular, its because its not Java, PHP applications are rapid and fast and easy to develop. Java applications are non of the above. Frameworks should be developed by a group of security experts and software engineers. Most of the PHP frameworks out there are created by hobbyists, people who created a framework for their own use, and then added magic features simply because it was cool, and then made it public. A lot of them have terrible software designs and horrible security designs. I have personally studied many of them and there are many many many potential and actual flaws in their software and security design. More: http://blog.igeek.info/2013/which-framework/ http://webinerds.com/choose-php-application-framework/ http://www.t3chninja.com/top-10-php-frameworks-worth-looking-forward-to-in-2015/
u're crazy
Gentoo. I like having flexibility. At work we use Centos and I feel too locked in to what Centos thinks is "right", which means PHP 5.3 and Apache 2.2 with mod_php. I like being able to set up nginx and php-fpm without wanting to shoot myself in the face.
I have a hard time believing that a one-line "namespace Foo\Bar" at the start of a file will make your life harder. It's about reusable code. You may not publish code to the entire world, but probably you're trying to reuse some of your code over time, so colliding with your own code from project to project is also a possibility. Also consider, let's say you're writing a rule engine called Foobar, would you rather name your classes: FoobarMaxRule FoobarMinRule FoobarLengthRule Or would you rather use the shortest readable name: MaxRule MinRule LengthRule You can have class names like the second set if they're in a namespace like Derive\Foobar to avoid collision with other SomethingRule classes you may have across *your* other components and projects.
I don't understand why is everyone getting infected with the idea of creating god Application objects that meld together router, dispatcher and dependency injection. In your case also HTML escaping and I bet dozens of other things. Those are entirely separate concerns that have no reason to be put on the same class, so they really belong in separate replaceable components. Just IMHO.
For, foreach, while, do, if, else, switch, case, break, continue, goto are also control statements, but they're nested. I support the idea you should be free to choose your own style, but keep in mind this particular one will probably look weird to anyone who is not you. Imagine someone deciding not to nest if statements for some reason.
Why does laravel's file structure include the public folder inside the folder which contains everything pertaining laravel instead of outside of it? Example: - laravel/ - public/ - app/ - bootstrap/ - artisan - etc... Wouldn't it be better to have it setup like: - laravel/ - app/ - bootstrap/ - artisan - etc... - public/ - index.php Since most servers already come with a `/var/www/public_html/` folder or a `/var/www/public/` wouldn't you want to group your laravel tight instead of plopping everything outside of the public folder on a normal server to keep things organized? Because that's how I've always done it. Editted: To make my question the focal point of my post.
You can change where your public folder is. But ideally it should be in the app, because it's a part of the app. Try using symlinks to your host's public_html.
Very clear and precise observation, but I left one detail out, the actual request, response, router, session ... and all the other classes are separate, decoupled and atomic .. there is no mismash anywhere. The application class is there just to make coding fun and light, in other words it's a syntactic sugar. You could delete it and the app will work just fine. So, I just need feedback on how the $app could be made simpler
I am really happy with my bitbucket + capistrano set up for deployment on different servers and on different enviroments.
Isn't web scraping is bad, or at least frowned upon?
the number 1 problem I think are old articles... PHP stuff that has been on the web since 2006... And newcomer's not realizing that stuff is old garbage... 
For a practical walk-through of creating an app or blog following are my recommendations which are quite helpful. http://www.w3schools.com/php/php_mysql_intro.asp http://www.freewebmasterhelp.com/tutorials/phpmysql http://www.simplilearn.com/web-app-and-programming/mysql-and-php-fundamentals#/osl Best of luck.
"Random other curated list scrapping process: pending"
Linux is for children! Where's my FreeBSD option? Get off my lawn and stop stealing my newspapers! Etc!
I don't understand: you instantiate Fastpress\Application, assign it to $app, and then proceed to use $app everywhere in the bootstrap. How can deleting it not change anything?
I use laravel + eloquent with some traits like this one: https://gist.github.com/bitkill/6204c123cc21abf985a3 So far it works pretty well in most scenarios, and I make additional traits for file uploads and statistics.
Sorry, I should have been more specific. I was looking for a lib to setup my own api. I'll check out doctrine also. Thanks!
&gt; I like being able to set up nginx and php-fpm without wanting to shoot myself in the face. On CentOS, just include the [webtatic repo](https://webtatic.com/) and tada, php-fpm and nginx without face-shooting incidents.
The shared container is a big part of the issue. Many of the syntax concerns are trivial, say, I may ask, why "{:foo}" and not "{foo}" or ":foo", and we can have a long list of those, but it's like PHP's why $this-&gt;foo() and not this.foo(). It doesn't matter. While the shared container for objects and settings matters a lot, I think. I see a lot of string settings assigned via $app-&gt;set() like page:title and what not. Why is this going through a central location with string settings? Can't I just operate with the API of the object that'll be reading those settings? What if multiple components want to have a "page:title" and not the same "page:title"?
No love for the rest of the *nix family (BSD). :(
How does the structure prevent you from moving away from Laravel in the future? You just delete the laravel-specific folders and put new ones there. There's a good chance you'll want to keep some of them such as the `resources` and `vendor` folders.
I never said it prevented you from moving away from laravel.
This is a very similar approach to what I did in [naroga/foreman's processor](https://github.com/naroga/foreman/blob/0.1.2/src/AppBundle/Processor/Processor.php#L131-L160). It keeps the application Kernel alive and serves another webserver from within.
Docker + Amazon Elastic Beanstalk - Some AWS tools are a pain to get working on anything other than Amazon Linux. Docker means I don't care that the host is running Amazon Linux - AWS auto-scaling is easy - no need to make a custom AMI, learn chef, or pay a support fee to a third party that's 20x the AWS cost. Just 'if response time &gt; 0.x s, spin up another instance' - I can run the same docker image in AWS, any other host, or even on my own laptop - Also, I use it with HHVM + Proxygen (the http server instead of fastcgi). HHVM only has official packages for Ubuntu and Debian - Docker means that I can use these packages on any host OS.
Personally I use https://github.com/jacwright/RestServer. It is very light weight and I typically use it for internal projects that no one else needs to touch. 
Is you is or is you ain't my scraper
Nobody ever indents labels in C, that's probably where Danacks preference comes from.
a while back I was teaching a class at my local university and the topic at the time was frameworks. Some of my students found out about Laravel and fell in love with it because it made creating things so easy. I remember having one hell of a sad day because Laravel and its community made one of my best students argue as follows: Student: "look I just type this and I got this. see easy". me (playing devil's advocate): "but, how did that happen? do you even know what it is you typed? How did that thing work without knowing about X, Y and Z?" Student: "does it matter? it works now doesn't it?" That conversation made me so sad. I spent the months thereafter trying to convince some of them to LEARN about the internal working of the framework rather than just taking it at face value. I am not saying don't use Laravel, but study it first and learn about its strength and weaknesses. That's the least you can do. right? right?... well, not not really. I spent literally months trying to show them why hidden complexity is bad and why laravel have BAD and straight out MISLEADING naming conventions. But no one cared. It got things done and that's what mattered. Now I understand why Taylor got personal. Because he is just like that. He just wants to get things done in a way that suits him, which is fine FOR HIM. But, it really makes me angry when my students and the junior developers that I interview follow the conventions of that community and think for themselves that THIS is how things ought to be done. Which is definitely not the case. It just makes me sad to see how this fw's community (not all ofc but I would argue most) STILL does not know that Laravel's facades != facades the SDP. That IOC is all about DI. That coupling business logic to core of the framework is NOT GOOD. etc. Yet still this is the #1 framework with the biggest community. What a sad sad sight!
The salt is real. 
Amen. I shall tag you as: the king of making sense!
Yea keep on saying that until YOU have to pay a team of 20-30 devs to rewrite your app. Which will take 6 months and you pay them full time salary yea? no I don't see you doing that. I have though. And trust me when I say that it is fucking bullshit. Having to dive into a project where someone else made a mistake such as picking the wrong framework could cost you MILLIONS. Just because you work on CRUD apps does not mean that every application is like that! And yes you are right, tools help teams ship. Until the tools become a hurdle for the shipping! 
We recently moved from ubuntu to debian on our dev server at work, not much has changed but still, liked the change. I also run debian on my private server
Use [EPEL](https://fedoraproject.org/wiki/EPEL) and [Remi's repository](http://rpms.famillecollet.com/). They're safe and will get you what you need. A little part of me died when funroll-loops.info went offline. Now I have to link to archive.org whenever anyone mentions they use Gentoo for anything (especially production systems). https://web.archive.org/web/20140517134248/http://funroll-loops.info/
No, not really. If your query is hot and properly indexed, adding caching can easily add more overhead than just the plain query.
It's not reliable is probably it's worst fault. However, if no API is offered, whatchoo gonna do?
Saltier than a whore's canker.
I use https://hub.docker.com/r/fredemmott/hhvm-proxygen/ For local development, I mount my stuff over /var/www (if your app has index.php in the root directory, you should feel bad, and mount it over /var/www/public for that image) For deploys, I build a new container with the app source actually in there.
I usually use Eloquent or Spot2
Curious if Ubuntu 14.04 LTS is taking the lead due to the 5 yrs of support? After all, Jessie has 5.6 while 14.04 is 5.5. 
If this only for one computer couldn't you just do some MAC address filtering on the network/server/etc level to prevent any other computer from accessing the login resources?
&gt; Really D8 is almost an entire rewrite because trained devs (OOP vs Procedural) were getting fed up with having to learn basically a new form of php when there is so much great stuff going on with php these days. This is a good thing.
We use docker for our development, staging and production and flyway for database migrations via delta files, it's pretty slick because a new dev can have an environment up and running locally with a bash or two. Compared to the workflow that was in place before I started here this is a godsend. My first week I wrote a large class file using non-backwards compatible features of PHP 5.6 and didn't realize my blunder until staging it, it required an hour or two of refactors to function the same way. Basically a lot less guesswork and surprises plus it gives our sysadmin a boner.[Ì²Ì…$Ì²Ì…(Ì²Ì… Í¡Â° ÍœÊ– Í¡Â°Ì²Ì…)Ì²Ì…$Ì²Ì…]
Oh no doubt, I think drupal has a lot of merit and is a good, cheaper framework for orgs who can't have a full time dev on staff but I run into the limits of what D7 can do daily. 'Features' if you are familar is a giant hack (nothing against the contributors, it's just the nature of the problem and all of them are much better coders then I am) and finding trained talent and not self taught who tend to be missing a lof of the hard cs science is painful. Good changes all around, just hope it will be enuf for me to stop cursing drupal every day =/
Or run/host the app locally which dumps results to a Google sheet or a Dropbox account?
How would you avoid that the user can read the private key and just use it on any other machine?
I'm looking on creating a RESTful service for a side project. Instead of hand coding SQL and baking my own RESTful API, I figured I'd reach out and see what other developers use. As for this: &gt;Sorry, I should have been more specific. I was looking for a lib to setup my own api. I'll check out doctrine also. Thanks! I'm looking to create an API that lives on my servers that other people (or myself) access. I'm not looking to MAKE requests, I'm looking to receive requests.
Ubuntu is an african word meaning "I can't figure out Debian" ... :D sorry
Upvotin' dat money
Run the app locally on the machine would appear to be the simplest solution.
The CentOS [wiki](https://wiki.centos.org/AdditionalResources/Repositories) lists Remi as a known problem repo. I use IUS Community repo for PHP, PHP-FPM and MySQL and EPEL for nginx.
There are legitimate uses for web scraping tools. There's a ton of data online that can be used for legitimate purposes. 
Not like a Debian Server is harder to configure than a Ubuntu Server, actually most stuff is similar. 
Has anyone thought of a thin-app using cordova, where once logged-in your account is set to be open; and locked to a client-ID, which is in localStorage? It's hardly invincible, and you'd have to ensure someone can be free of this restriction, but essentially the app would not let anyone login without the same one-time client-ID... upon logout the database record would be updated to have no client-ID / session-ID, which would permit another login...
Does this computer really have to be on the open Internet? Why not have the time clock application in a sort of "embedded appliance", ie, a desktop with a local browser?
A pity the poll doesn't support multiple answers. CentOS 7: Used by my employer and I tend to favour it in a production capacity for doing anything serious. Ubuntu 14.04: Used for personal projects, internal projects, or just silly beta things. I use this because it's the same as my work station which makes set up quite fast.
In a custom ruleset, include this: &lt;rule ref="Generic.WhiteSpace.ScopeIndent"&gt; &lt;properties&gt; &lt;property name="ignoreIndentationTokens" type="array" value="T_GOTO_LABEL"/&gt; &lt;/properties&gt; &lt;/rule&gt; Unless you happen to be using the PEAR coding standard, in which case you'll need to change Generic.WhiteSpace.ScopeIndent to PEAR.WhiteSpace.ScopeIndent
Dhcp lease is 2 weeks, but the client will request a renewal 1 week before expiration. The only time you'll have to worry about the IP changing is if the client is powered off for a week or the hardware changes.
I am also surprised by this number. That's why I created the poll.
&gt; A pity the poll doesn't support multiple answers. Yes, I am sorry for that. But there is no possibility to change afterwards.
So what does "in case you move to something that isn't laravel in the future" mean then? 
I'll be the first to admit I'm not a network expert by any means but doesn't the MAC address from IP tables come from the last piece of network hardware? So pretty much guaranteed to not be client computer. 
It's a redundant remark, I could delete that line and my main question is still in tact. I've seen projects where developers plop the laravel files above the public folder and a lot of files that did and didn't relate to said application making it pretty annoying to sift through.
Yes and I'm saying it's not a problem IMO.
u know.. I wrote a long response but then I realized that arguing with someone on reddit over what he thinks the right strategy for your application is (that he btw does not know squat shit about) is kinda retarded. I mean you know nothing about the context yet you argue that the mistake is "rewriting" rather than "augmenting". Dude... You don't even know ANYTHING about the project yet you are suddenly in the position of giving advice/point out mistakes. You are the worst kind of employee. Period. If I were your employer I would have fired your ass over such stupidity. God I hope you do not work in project management or are remotely in charge of any financial decision making. I really hope so!!!
okay
Well yeah. That strategy would assume the server and client are on the same network (in which case, yes, the MAC is the client computer).
if the data is being made available no scraping is needed, they would provide an API. Most scraping is still bottom feeders.
Linux is linux. The best distro is the one that works for you. I remember when I first started tinkering with Linux in the late 90's nobody asked what distro you used. They asked your kernel version, and how many times you've recompiled it. Use the package system to get you most of the way, then compile/recompile the stack you want and/or the parts that dont work correctly out of the box.
Why? Linux is Linux. There's little difference between them, since they all can have the same tools when compiled from sourcecode. And they all have almost the same pre-compiled tools, softwares and applications.
It's not difficult. The community has evolved and, nowadays, you learn PHP the right way: understanding and developing with good practices and OOP. This arcticle is kinda dull. Sounds like some old guy bashing "today isn't fun. You cannot learn how to program if you never did anything in C". I worked with Java (Spring, Maven, Hibernate, etc) for four years and, before that, pure PHP. The transition was slow at first but, later, everything made sense. And just because the PHP community, frameworks and tools evolved a lot that i went back to PHP. Nowadays i am working with Rails and i'm loving it. Its been easy to grasp the language and framework because of what i learned with Java and modern PHP. Edits: i hate typing on a phone.
If this is a business account why not get the store a static ip? It's usually a bit more per month but not unreasonably expensive in the grand scheme of business expenses. Then limit the clock ins to that IP. Code it such that if an admin logs in to review the time thry can click a button that says "update IP to current locations" IP and store that in a database. Check that IP matches the current IP when the user goes to log in.
Maybe not, but it's still worth learning. I'm also unsure what other approach would be considered acceptable without severely limiting the ability to upgrade, test, and modify code while avoiding potential breaks across the board every time something changes.
Ok, then pretty much any mico-framework (Silex, Slim, Lumen, etc) will do the job, along with any ORM or Query Builder you can find. I just wanted to be clear that there is no correlation between ORM and REST.
Neither one is "better" than the other. They're just different, and each are capable of handling their own sets of problems. Laravel actually uses Symfony components, so if you have an application that necessitates the use of a full-stack framework, Laravel is a decent choice. There's a lot you can do out of the box without having to roll your own low-level code, and bootstrapping new pieces of functionality isn't too complex. Symfony components are very powerful, and if you're comfortable with writing your own code to "glue" the pieces together, then it won't fail you either. Silex provides a little more in the way of structuring and organizing your code, so I would actually recommend starting with that if you're going to try other Symfony-based frameworks outside of Laravel. It was written by Fabien Potencier, who is the original author of Symfony, and it's actually a lot simpler to understand than the full-stack framework if you're a first-time user.
&gt;'if response time &gt; 0.x s, spin up another instance' Is that the best way to know when to spin up another instance?
"Cent-ose" sounds like some kind of cheap knock-off of Mentos.
If you have very few complaints after using a framework to build a program, then congratulations because you just won the lottery! Stick with laravel -- it's working for you. This is hard to find :)
I have always used Ubuntu. As a kid, I just really enjoyed the purple color. Ubuntu4lyfe
I thought PDO was a class, not an interface?
To the fact that the article says you can mock a PDO object by implementing PDO.
Ah, no problem. I was genuinely confused...
Call the ghostbusters! 
Doctrine 2 + Apigility. Use it :)
There is a simple solution, as always. Log out everyone else authenticated as this user if someone logs in. This way you can prevent having one user with multiple sessions. Edit: Having only single computer being able to log in, you need something from outside of your environment, for example a certificate to check against.
Personally, I prefer https://nette.org/ Some of its features are really really amazing, it doesn't force you into using any specific database layer, etc.
SOLID and clean coding in general. That allows you to test the code properly and keeps concerns separate. MVC is not an architectural pattern, MVC could be used in view classes and logicless templates, and NOT the whole application. Your application shouldn't be an MVC application, it should implement business values and use cases, MVC shouldn't define the structure of your application, MVC shouldn't dictate how you build software.
I'm doing the client script with a python script. 1. Send a request to the script.php on the server 2. script.php responds with a salt 3. Client responds with a salt:username:password (obviously encrypt this then base64 encode for easy delivery) combination and gets outside IP with STUN (script.php?auth=c2FsdDp1c2VybmFtZTpwYXNzd29yZA==&amp;ip=9.9.9.10) 4. Check if everything authorizes okay. If so, add the IP to the ACL then remove the stale IP. Edit: made things a little more clear
Since we're on the topic of Guzzle, has anyone experienced package version clashes with their own project demanding Guzzle 6 while some dependency is demanding for Guzzle 5?
Neither does Symfony, or a lot of other frameworks out there.
That's because you tell Auryn to create your controllers and run methods. Then it'll auto-recursively instantiate each object in the graph and inject them. Once you've set that up in your bootstrap, you don't need to touch it any more, you create a controller and it 'just works'. Also, you wouldn't make your UserRepository, you'd inject it :-)
I know it's not the only framework who goes with this approach. I just stated my preference between Symfony 2/Laravel - something totally different that's imho worth considering. Don't understand the downvote? Because I suggested something other than A/B, even if I strongly believe C is even better (use it daily for both personal and work projects as my primary framework for the last 5 years)?
I'll let Google know on your behalf `:-)`. 
That's slim 2 not slim 3 (check the video at 7:24 min)
Laravel definitely, as it's easy to get going out of the box. Also lots of friendly documentation available (this is an opinion of course). Both have a slight learning curve as they're complete robust frameworks.
I agree, I really like Laravel's documentation. My only gripe was that Laravel 4.2 documentation always came up first in google searches. But, Splitting hairs now... :) 
Thanks for the response. I found Laravel to be just flexible enough but definitely ran into some situations where I had to work my ideas into the structure of the framework, mostly the new Middleware layer.
Thanks for the response, i've never heard of this but i'm going to check it out! 
Outside of using docker to spin up little dev environments I was able to get some solid mileage out of it during a computer security competition. Not-entirely-on-topic-ramble incoming. Quick rundown: Prior to the 2 day live competition the blue(defending) team is given access to several VMware machines which have been designed by the white(event administration) team. These boxes are designed to be vulnerable. Sometimes the vulnerability is because it's been compromised already or due to poor configuration. On the day of the competition red(attacking) team is given access to the network and spend several hours performing attacks and pen test the boxes. There's an automatic service scanner as well as tasks you must perform throughout the day in order to earn points. ANYWAY, I use docker in this situation mostly for it's use as a linux container. This means that, even if there is a vulnerability in the web app or web server configuration, compromising the web server inside of docker doesn't directly compromise the main web server. In addition to that one of the main parts of this competition is that you must maintain minimum standards/feature sets to earn points. Sometimes this involves something like allowing ssh users access to make/javac/perl/python etc. In these situations I've had great success just dropping ssh users into a docker container and keeping the file system overlaps minimal. I've had great success with this as it's relatively difficult for red team members to figure out what's going on with the time they have. I'd love to use it more at work but unfortunately I only have direct access to RHEL 6.5 machines and haven't had luck compiling from source =(
The only downside I can think of is that the documentation is a little bit lacking. But you can always ask for help at https://gitter.im/nette/nette if something isn't clear ;)
It's not about being able to compile things. It's about having those things easily accessible from the built-in package manager, and not having to *manually* compile things. You're just making yourself look like an asshole with the "LOL" and ignorant by not reading the rest of the thread.
What you can try is using a GET parameter with a value of 0, and for each (for example) 100 rows returned, redirect the page to ?limit=100(and increment this each time with 100), and use a LIMIT statement to start reading from that position in the table. Btw, this isn't the php help subreddit, it's /r/phphelp
Thanks. I'm actually basing of the PSR2 rules, and so apparently I also had to exclude the ScopeIndent rule from the PSR2 ref: &lt;rule ref="PSR2"&gt; &lt;exclude name="Generic.WhiteSpace.ScopeIndent"/&gt; ... &lt;/rule&gt;
Just came here to shamelessly throw down [DUnit](https://github.com/Vectorface/dunit)
One of the main reasons that injection is better than service location is in testing. With injection, testing becomes easy because you can be sure that the dependencies of the class are known by constructor arguments and nothing else. Having a container passed around obscures that fact and forces all your code to be coupled to the container.
https://github.com/pmjones/adr
[Pimple](http://pimple.sensiolabs.org/) is as simple as DI gets in php. Love it...
I've never heard of Nette before, looks interesting. Maybe it's my cynicism, but when a framework makes the following **bold** claim, it's a little off-putting to me: &gt; Nette uses revolutionary technology that eliminates security holes and their misuse, such as XSS, CSRF, session hijacking, session fixation, etc. Not even Symfony or ZF2 make such a claim. In fact, Symfony comes with a [security advisories checker](https://security.sensiolabs.org) cli to scan your vendor folder for known vulnerabilities.
&gt; automatic resolution leaves you prone becoming coupled to your entire environment I don't understand this statement. What about automatic resolution is directly tied to coupling? If I type hint against PDO, it implies a contract that this class will use the methods defined by PDO and nothing else. &gt; no discipline what a controller may ask for This is no fault of injection, and not having injection does not prevent it.
What's simpler is not using Pimple. What's with this... magic pill mentality. Do we need have a component for *everything* these days. DI is so simple that doing it in plain code is already as short as it gets. You don't need some kind of monstrosity holding your object initialization code. And I've seen Pimple's code, I know it's short. But it's still entirely superfluous.
&gt; I don't understand this statement. What about automatic resolution is directly tied to coupling? If I type hint against PDO, it implies a contract that this class will use the methods defined by PDO and nothing else. That's the theory, but it's not the practice. In a real codebase, a controller would typically have a number of implied expectations about this PDO object, such as: 1. The kind of database it represents (say, MySQL). 2. The kind of schema it has (tables, columns, views...). 3. The data it holds (typically not produced by this controller alone, so encapsulation breach in 3, 2, 1...). Saying the contract is just "I need some sort of PDO" is the theoretical goal, but we're kidding ourselves if we're to claim that's what happens in projects using automatic injection from a DI container. Heck, I'd like to see *one* example of a code unit that truly just wants *some* PDO, and nothing is implied. &gt; This is no fault of injection, and not having injection does not prevent it. I didn't say it's the fault of injection. I specifically was comparing *automatic unconditional injection* from a *shared container*, compared to fetching dependencies from the container. The point is they result in many of the same problems. The implied contract for injection is just as important as the explicit one spelled out in your code via typehints. The implied contract with injecting container is "type anything from the environment, and you get it". No discipline required, which means unless something extraordinary ensures otherwise (like a micro-managing project lead reviewing every commit), the code will become coupled to the environment over time, because code thrives on dependencies. It's like being an alcoholic and a friend inviting you to have "just one shot of tequila".
I don't disagree on any particular point. That seems more a commentary about using PDO as an example than anything else, though. :)
&gt; It's not about being able to compile things. It's about having those things easily accessible from the built-in package manager, and not having to manually compile things. I know, because that's what all the other distros lack. ;) (is that better to denote humor? to try to poke a little fun? Or does it just ruffle your asshole feathers?) And you're making yourself look like an asshole just by being such a big one. No LOL needed, or sense of humor.
Well, it's a commentary on implicit environment expectations for objects initialized from injecting containers. Every object has a context. If it didn't, we'd use static calls all-around.
I use it for everything. Every service has a different signature I just satisfy via a one-line factory method. For controllers, it's pointless to define a different signature for every controller, so I define the signature in groups: - All public site controllers get this signature. - All admin site controllers get that signature. Etc. The signature contains three things: 1. Request object. 2. Response object. 3. Domain services entry point. The domain services entry point is defined specifically for that group of controllers, so I can choose what they have access to. The funny thing about this setup is it addresses the problems DI is invented to solve much better than reflection-based automatic injection from a shared container, but I can see the "you're using a locator" replies coming in already.
&gt; Should controllers have access to components stripped of the domain invariants that ensure domain model integrity and so on? Yes, but it's not the role of a dependency manager to enforce that. In fact, they can't. The only way to enforce that is code review. (at least that I've found). &gt; How are architectural boundaries preserved when using automatic injection, and everything you ask for is given to you? Because if you don't call a container, but putting stuff in your constructor arguments behaves precisely as a calling a container would, the difference between both becomes so thin, that it's inconsequential to the resulting coupling between callee and its environment. I understand the line you're talking about here, but I don't think it's as thin as you're making it. Sure, with automatic injection it becomes painless to do dirty things. But it is painless without automatic injection as well (just call `new`). At least with automatic injection it becomes FAR easier to refactor. And to me that single benefit alone makes it worth while. &gt; The biggest reason architecture erodes is because over time, without constraints, a codebase turns into a tight mesh of dependency arrows, where everything depends on everything. Automatic and unconditional resolution of one dependency to another is not helping reduce that that, it promotes it, just as much as calling a container would. Like most things, it's a tradeoff. It's not a magic box of awesomeness. But I think the benefits outweigh the costs (MHO). But it's 100% worth while making the costs explicit and communicating them, so thank you for sharing your thoughts!
&gt; Yes, but it's not the role of a dependency manager to enforce that. In fact, they can't. The only way to enforce that is code review. (at least that I've found). Well there's another way: if you don't want a controller to access your PDO objects, say, don't give PDO objects to controllers. If we don't have that form of control, then it's not inversion of control (detailed below). &gt; I understand the line you're talking about here, but I don't think it's as thin as you're making it. Sure, with automatic injection it becomes painless to do dirty things. But it is painless without automatic injection as well (just call new). At least with automatic injection it becomes FAR easier to refactor. And to me that single benefit alone makes it worth while. A controller can't "new" itself. Inversion of Control assumes we think about object creator and the object as two independent parties (and in many teams composition root and components are controlled by different developers). - In the "standard" form of control, the object decides which dependencies to take from the environment. - In the inverted form of control, the object asks for dependencies, but it's up to the caller to decide what to pass. The problem with automatic injection from a container is that the caller no longer "decides", it's just a mindless servant that gives to the object anything it asks for. So it *looks* like inversion of control, but... in fact it isn't. It's subverted through reflection and automation. And this is where all the issues come form. You say it's worth it - that's subjective, so I won't argue. Maybe it's worth it (to me it's not worth it in particular). But I wish we at least wouldn't call it IoC as that's misleading. We're basically lying to ourselves in the name of trying for convenience through magic.
&gt; Put things in arguments, caller provides them, then you use them Unfortunately, that's the complexity of it. In order for the caller to provide them, the caller has to know about them. And its caller has to know about them, and so on.... which is itself a form of coupling. And if done naively, breaks encapsulation. This is why containers and factories (and really, most containers are nothing more than abstract factories) are so important. I'm not even talking about auto-resolving IoC containers. Plain old callback factory containers like Pimple make dependency injection actually manageable. Plus they give you the obvious benefit of making your entire application lazy constructed - you're not needlessly constructing objects up front. I like the convenience I get from auto resolving containers, but I won't leave home without at least something like Pimple. Even for microscopic projects, it's such an indispensable tool.
I have been using FOSRestBundle with Doctrine on top of a Symfony roll out and its has worked beautifully. I also bridged the gap between controller &lt;-&gt; service layer by using Tactician (CommandBus) and a query implementation on top of doctrine Criteria for the read side, makes my controller very lean and my domain logic nicely encapsulated in the commands and handlers.
phpspec is only about unit testing (you should notice that $this used as test subject). This is where it shines. For integrational/functional tests phpunit/peridot/codeception/etc can be used. There is cool approaches with acceptance testing using behat, when you describe your requirements in form of feature specification and then you can use it to design different layers of your application (from integrational tests of domain layer to e2e tests). The main thoughts: - phpspec is about testing only one thing, not multiple (everything except test subject should be mocked, it has cool sugar for mocking stuff and this is the only reason why i use it) - phpspec is design tool (you can easily track lack of architecture since in that case it will be harder and harder to write tests) - use something else for functional/integrational/e2e tests. For example take a look at [peridot](http://peridot-php.github.io/) 
The thing is what you have stated: "before that, pure PHP" You HAVE learned the basics, you KNOW what's happening BEHIND the frameworks that you're using. My point was never to say that frameworks are bad. My point is that nowadays people don't learn what's happening behind the scenes anymore. And design patterns don't even help with that. The globals need to be understood, $_SERVER, $_REQUEST ($_POST, $_GET), $_SESSION. If you never learn how they function, you're simply not able to solve certain problems. And considering all the responses I've got so far I have been pretty convinced that I'm not just some "old guy wirting a dull article" but rather someone who speaks the truth, even though he won't be able to change anything :)
1. Laravel is growing strong, but Symfony is increasingly becoming the industry standard. Many high profile companies are looking for Symfony developers. There are some great opportunities at great companies. 2. Itâ€™s also pretty easy to sell to potential clients. Symfony wins out because there will always be developers available. This completes the circle. Symfony developers will be in demand for a long time to come. 3. With Symfony you learn how to build bigger applications the right way. It forces you to learn things like Inversion of Control and MVC. So you will grow your skills as a developer more. In my opinion to some degree this is true of Laravel too. But Laravel doesnâ€™t take these concepts as far as Symfony. 4. Symfony is built on top of Symfony Components. More and more OSS projects build on top of them. So your knowledge about the Symfony framework will become valuable when developing with other projects like Drupal, or EZPublish as well. More http://vschart.com/compare/laravel/vs/symfony and http://webinerds.com/choose-php-application-framework/ 
+1 nice, simple description. 
&gt; Choosing DBAL or PDO or being able to swap the database layer is a business choice. No it isn't it's purely a technical choice. I don't know any business people who would care how you do it, they just care you do what they want. Being able to choose DBAL or PDO at a later date is literally what DIP is all about. &gt; It seems like you're suggesting that DIP requires using interfaces as the only contract, which is incorrect. Do you have anything to back this up? &gt; I would argue that PDO is an abstraction It's literally in the documentation that PDO is not an abstraction layer. It's an implementation detail, therefore according to DIP it should be abstracted out. &gt; if it meets your business requirements. Technical choices are not business choices. It annoys me when I hear that technical things weren't done for "business reasons" when if you told the CEO we weren't doing it they would have fit. DIP isn't about business requirements, SOLID isn't about business requirements. Please re-evaluate your knowledge of SOLID. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/usenet] [Someone make usenet as file hosting, so if you see there is more junk files in usenet I bet this one of the reasons.](https://np.reddit.com/r/usenet/comments/3hgkpu/someone_make_usenet_as_file_hosting_so_if_you_see/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It's more anecdotal and stray observations than anything else. I know a lot of folks that got their Linux feet wet with Ubuntu desktop. That's not bad, we all have to start somewhere, and I used xubuntu for a while too. It's not a bad desktop OS. Again, this is my personal experience and I guess definitely not the norm given this thread, but I've found proportionately more poorly configured systems and questionable practices running on Ubuntu server (or worse Ubuntu desktop) in production on the public Internet. I've also noticed that those who cut their teeth on Ubuntu tend to have more problems when using another distro and sometimes Linux or UNIX in general. In the end, go with what you know, and the best tool for the job is the one you know best. YMMV etc. I've just noticed way more bad Ubuntu setups out there than with most other distros. If Ubuntu is what you know best then you should give Debian, CentOS, or one of the BSDs a try. Learning the other distros and more UNIX in general will make you a better Ubuntu admin. I also have a problem some programs claiming "works in Linux" but what they really mean is "works in Ubuntu", but that's another thing. :)
We have very different definitions of "business" in this context. I am talking about "business rules" meaning the requirements that are specific to the business/application. These are technical choices within the context of the business itself. Not all businesses require being able to switch between PDO and DBAL (in fact, most don't). In retrospect, choosing PDO as an example was probably not ideal, for the reasons you pointed out. Also, it is worth pointing out that my blog post was about dependency **injection** not inversion. The only time I mention it is in the first paragraph and I was not attempting to imply that my code was adhering to dependency inversion. I'd be happy to write a follow up post about DIP specifically. :)
Could you post an example dockerfile? Im curious how do people provision their docker boxes...
Anything with aliases can be easily abused as a service locator and make it easy to completely violate dependency inversion. This is the major flaw of Pimple.
It might be that the first several versions of Ubuntu Server were much more prone to breakage vs. Debian Stable. Bad tastes in the mouth are hard to wash out / forget.
Should they also study how the zend opcache works at a low level too? The student is kindof right. 
If Guzzle is as robust as you need, then why are you switching away from it? 
Pure Debian enviroment nowdays. I was using CentOS for running my VMs in the past but switched that to debian too with Proxmox @ stock Kernel. Stability is as stable as an "enterprise" OS and upgradeing to new releases is easier than CentOS and just works (just minor manual config fixes) 
I have heard good things about Swagger from API leaders in the community as well as the technical writers using it to work on the API documentation. Went to a API meetup with this as the topic and liked what I saw. http://swagger.io/
[Release article](http://blog.jetbrains.com/phpstorm/2015/08/phpstorm-9-0-2-bug-fix-update-is-available/)
I never objected to "a factory", as in the pattern. I question needing a container component, and auto-injection. That, for me, is the original point. I don't see what sort of effort Pimple saves you. What you see as "saving effort", I see as you losing control over your own dependencies. Construction is such a small amount of code (one line per dependency in most cases), and so important for keeping the project architecture in check, it's senseless to automate it. But, eventually people will figure that out. Until then, enjoy the magic.
Good to see you too, Tanks. :-)
I would suggest you look at something like bootstrap's modals... http://www.w3schools.com/bootstrap/bootstrap_modal.asp
You could simply ADD installer.sh /tmp/installer.sh RUN /tmp/installer.sh That will run your installer at *build* time. If you're thinking of doing that at *run* time, that's not really the "12factor" way. You want your containers to start fast, and you want them to be immutable. If they are installing stuff at startup, then a container you start today might be different to the same container started a week ago. 
Given the current knowledge of PHP that you currently seem to have (no offense intended) I'd strongly suggest against this! Pure overkill for a simple thing such as an alert popup.
This may be a lot to ask, but some bit of code (even pseudocode) would be much appreciated. I understand Service Locators, Containers (like Pimple), etc, but the impression I'm getting is that you use neither of those while still managing to achieve Dependency Inversion? Unless you are passing the "raw" instantiated object, I'm not understanding what you're saying.
With "you" I meant /u/punkeb. Sorry if that wasn't clear.
desktop: i spend all my time customizing my desktop to look like os x that i never actually do any real work err thats how it was 8 years ago
Seriously, why do you keep deleting your accounts?
Interesting and didactic. Thank you so, so much. Is there anywhere I can read more about this line of design thoughts, more in depth? Seems very rewarding.
To clarify, go into [command prompt properties](http://i.imgur.com/kLRtaHz.png) and enable legacy console.
I dont quite get this post. You write a blog article and link back to yourself on Reddit (why not, everyone else does it to get traffic), but in this case the article title is strange and content is sparse. So what am I missing? Is PHP not a language because its a preprocessor? Are we using words to create fuzzy logic? Or is my fuzzy logic not understanding your words? 
So nice incremental patches are working now. SO much easier to update / patch.
Well for your project you could probably still test that you are calling exactly the correct escaping method. Your test would say 'Expect escape_html_attr to be called with the value foo' You could also fork Twig and add some unit tests and to make sure that each escape method is providing suitable protection. If you can add some value to the project by uncovering a vulnerability then you could send a pull request. Here is the test class for the escaping functionality in Twig https://github.com/twigphp/Twig/blob/1.x/test/Twig/Tests/escapingTest.php Ultimately what I am suggesting would take you longer to set up, so it's your choice. I believe that you should not be testing third party code in your unit tests
I find 9+ hangs on autocomplete sometimes, anyone else getting that? happens on mac and windows
Our entire stack is based on docker containers running in CoreOS. * Docker is used as provisioner for dev Vagrant VMs * Running the latest HHVM * The code is in a data container, for development environments we are connected to it using SSHFS * Even our IDEs are in Docker containers (PhpStorm/Sublime Text), we directly pull IDEs properly configured with our app, workflow and best practices (formatting, hooks, debugging, plugins...)
I wanted to keep it short for the sake of the example. If you want actions, there are two solutions: 1. As you said, the handler reads the action from the request, and calls the right method. 2. There's an entire component I didn't include, the "dispatcher" which is where you can pass the handler, instead of launching it yourself. The dispatcher can also run the view within itself, thus saving you from repeating a few lines of code from app to app: $dispatcher-&gt;dispatch($handler, $request, $response); In projects I actually do both. I have a reusable dispatcher (which does a bit more than I cover here), but the action logic is in ActionController which implements the Controller interface and defines run() to call a method named after the action. It's optional - you can extend ActionController and use its run() implementation, or implement Controller directly and define run() yourself. Having both provides for best flexibility, you can choose how to proceed controller by controller.
How useful they are in certain situations pretty much depends on your philosophy. Ultimately both "do" the same things. They just optimise for different use cases (and it's this difference in philosophy which is the root cause of all the current drama)
Yes! I thought it was just my machine...
I think because it's assumed that you knew after purchasing the product that you understood it was an annual subscription based model. All the info about it is on their site.
As someone new to this IDE, this is not all that clear to me, I tried updating to the latest version when I purchased it a few weeks ago and it's not all that clear that this update is free. Thanks for your reply.
I appreciate you further explaining your thought process behind the grouping of your units. That's exactly what I was hoping for. I get the impression that most of what you've contributed today has little-to-nothing to do with the dependency injection pattern, and more to do with overall architecture and how you organize and envision your application's components, and that's likely why you're receiving a lot of the questions and replies seen so far (including my own). You've clearly put quite a bit of thought into it, and have done an excellent job explaining it (thank you!). However, I doubt you will find many people who share your opinion and choice of architecture. I'm curious how you handle dependencies in your domain? Do your various services have similar service-location-esque dependencies, or do you type hint individual dependencies? If the latter, that's one major point of contention I have personally: inconsistency. A fundamental pattern or concept should be universal. As a team lead, there's no argument that could convince developers that proper dependency should be followed in the domain, but ignored on the request side. &gt; This allows me to reason about my application at a high level and keep things under control, instead of giving up and "automating" crucial architectural decisions, such as dependency flow. To automate dependency flow, is to lose control over it. Statements like this seem contradictory your overall theme. Automated dependency resolution is a separate concept from dependency injection. I don't see how it causes a developer to "give up crucial architectural decisions." If you typehint a service in your controller, a container and IOC could theoretically build your controller for you. It doesn't affect the dependency choice you made for your controller, it just puts it together for you. This is a primary benefit for containers (combined with IOC, and totally **optional**), as it often saves a developer quite a bit of time. &gt; With DI containers in frameworks these days, there's no one place where you can see and set constraints about what those controllers can rely on as a unit ... You're right. Because that's not a container's job. A typical container and dependency injection / IOC setup does not fall into your ideal architecture. You can't place fault on modern containers and such for that, because it's not what their purpose is. &gt; Quick: what are the services your public site's controllers depend on? This is where I'll just share how I view things. I took a page from /u/pmjones' [Action-Domain-Responder](https://github.com/pmjones/adr) pattern and implement each controller action as its own invokable class. Those classes live in a folder architecture that groups common actions together (along with their routes, views, and other related non-domain things), which I call Modules. Actions follow PSR-4 and are as semantically close to their route name as I can get in the interest of quickly finding an action for a route. Dependencies are type hinted individually. A simple action for displaying a page may have none. Other actions may require a repository or service. Others may create a command to be handled. Either way, if I need to know the dependencies for a particular action, they are well defined in the constructor (or parent abstract, as sometimes I will extend the same abstract in multiple actions to keep things DRY). At the end of the day, you've created a solution that conforms to how you architect and think about an application, and that's awesome. I appreciate you taking the time to explain it. Even though I don't agree with it, I like to hear people's opinions, even if it just challenges me to think about mine and reaffirm them. :) Cheers!
Quite a useless article.
I'm not familiar on PHP release cycles but does that mean all being well that we will see PHP 7 (release) this year? 
&gt; You need to ask yourself why you perceive inconsistency between a component asking for dependencies through a typehint in an argument, versus asking for a dependency through a typehint... in an interface, in an argument. Because you need to go through the service to figure out the actual dependencies needed, and even then, there's no guarantee that the dependencies available in the service are actually used by the controller the service class is injected into. You'd need to actually go through the *code* to figure that out. It's service location, and that's exactly why it's considered an anti-pattern (even if it's implemented "properly"). &gt; You can think you have a very focused list of dependencies for your every action, but if you go in your codebase right now and start reading your actions, you'll see not every dependency is used every time. Caching is one obvious example. An action asks for $cache and $userService, but if the users are in the cache, the $userService will not be invoked. A specific implementation that can be easily avoided. Ideally a cache layer would be decorated on top of the dependency, and only a single class or interface would need to be type hinted. &gt; The idea with IoC is there's a clear, stable, explicit contract on both sides, independent of any environment, and both sides decide to enter it, with developers having full oversight and control of the process. Do you have some literature somewhere that backs this up? I've always interpreted IOC as providing a generic API to a custom portion of code, which is exactly what a modern IOC DI container does (by abstracting away the custom instantiation of individual dependencies through a generic API, e.g. `$container-&gt;make(CreateUserAction::class);`). You seem to be claiming exactly the opposite. Again, we're back to your entire argument is that it's too difficult to track down all the use cases for entities bound to a container, and trying to protect changes to the container from affecting your overall application. This is a known limitation of dependency injection itself, not modern container implementations or the like. You're certainly entitled to that opinion, which I understand, but do not agree with the importance you are placing on that disadvantage. Modern IDEs provide code usage tools that allow you to analyze where classes and interfaces are implemented. Integration tests can confirm actual usage consistency after a change has been made.
It's supposed to be in October.
Awesome! Can't wait for this.
I'll probably side-install php7 on my dev boxes now that there is an RC. Gotta see what breaks and what is awesome. :D Production probably won't get done until next May. :(
My personal opinion is that this is too fast. There are still unresolved issues with PHP 7, such as that the uncaught exception handler catches all throwables, including Errors (engine exceptions, such as type errors, calls to non-existant methods / functions, etc) too, which creates a large, unexpected BC-break in error handling code (and because changing this would itself be a BC-break from current master behaviour, you can't really change it in a 7.x release - fixing it would have to wait until PHP 8), and whether or not the new random_int/bytes functions should throw exceptions. The PHP 7 release team seem to be prioritising adhering to their timetable over actually releasing a well formed product, and this isn't right. Worse than the unreleased PHP 6, PHP 7 could end up being an actual, official release that has some horrible gotchas, if not complete breakages of the language, that should never have been left there and cannot be fixed until PHP 8.
yeah, they seem way ahead of schedule.
As far as I'm concerned, I prefer the simplicity of Pimple over heavier frameworks trying to protect me against myself.
Yeah, this naming is really unnecessarily confusing now. Not sure how I'd solve it though personally, without giving it some serious thought.
This has absolutely nothing to do with php. Why not check what args the imagemagick binary you have installed takes?
The problem with Pimple is that what it does serves no purpose in my eyes, as you can do the same with a plain class. "It's mundane" is not a good reason for a component to exist. That mundane stuff needs a good purpose.
&gt; there's no guarantee that the dependencies available in the service are actually used by the controller the service class is injected into. There's never a guarantee. Are you saying there *is* a guarantee that putting something in your controller argument list means you use it? Nope, there isn't. You can go and try it - put something in your constructor arguments, then don't use it. Works fine. :P If the scope of a file was enough to always be in sync with whether something is used or not, we wouldn't need IDEs to give us a warning when a name import "use Foo\Bar" is unused. And because there's no warning for your constructor arguments, you probably get it wrong more often than you realize, say right now, in your project codebase. &gt; A specific implementation that can be easily avoided. Ideally a cache layer would be decorated on top of the dependency, and only a single class or interface would need to be type hinted. You didn't solve the problem here. To decorate UserService you still need to instantiate it even if you won't use it. But now you also need a UserService-specific caching decorator. You added code and didn't fix the issue. &gt; Do you have some literature somewhere that backs this up? I have probably something better - look up how IoC-based frameworks with servlet/applet containers (and not just DI containers) work: EJB, Akka, Apache Tomcat fits that description. Notice that the injected arguments are not just a dumb match to a list of environment objects. Quite often they contain context specific to the object being constructed. IoC is a much richer paradigm than we give it credit for. &gt; This is a known limitation of dependency injection itself, not modern container implementations or the like. My approach is also DI, without that supposedly inherent limitation. So I guess it's not exactly like that. I see a very strange thing going on when discussing containers. People take benefits not provided by containers, such as "you have your object configurations in one file" and assign it to containers, as if they need a container to stop scattering everything in dozens of files. Conversely, here we have a container-specific issue that is re-assigned to the whole DI principle, so that it wouldn't be container's fault. It's awkward as a community we're so deep into it, we can't tell apart the DI principle from containers anymore. &gt; You're certainly entitled to that opinion, which I understand, but do not agree with the importance you are placing on that disadvantage. If you check frameworks that support architectural constraints (like the enterprise version of Visual Studio, or Eclipse tools for deriving architecture from a codebase), you'll notice a pattern: it's all about modules, connected by dependencies. I assign great significance to these things, because that's what the essence of architecture is, and not paying attention to architecture is how a good codebase turns into a "legacy" codebase. If you ever worked with a "legacy" codebase, or produced one, stop and think about it, and you'll know this to be true. "Big ball of mud", "spaghetti code", "tight coupling", "shared state", "globals", "singletons" are all symptoms of lack of architectural boundaries between contexts, bad encapsulation and unclear dependency flow. As for relying on integration tests for this... honestly. I don't think the problem I'm describing is understood, yet.
&gt; You seem to take the same stance as early Perl guys regarding OOP It seems to me I'm taking the reverse stance. We *do* already have very industry-standard OOP tooling &amp; conventions here, and Pimple reinvents it through magic methods for a reason that remains unexplained. I work in about a dozen languages, so I'm used to telling apart value and syntax, and the value of OOP certainly is not an issue of syntax. OOP is very defensible as a paradigm, while Pimple... isn't, because there is no new paradigm, just an arbitrary reinvention of syntax to reach the same end goals. Pimple reinvents method definitions &amp; method calls through ArrayAccess, and even reinvents protected methods through protect(). What drove this? No one has really defended it so far, aside from a generic "hey, people have the freedom to use things". I'd really like to know what's the major benefit of $foo['service'] over $foo-&gt;getService(). Is there any, or is it a secret? Because we keep beating around the bush whole thread about it, it's like reading a cheap sitcom script. How does using a pseudo-array through string keys instead of calling type-checked methods with IDE autocompletion improve your life as a developer? That would be a very interesting answer to read. Looking forward to it. Thanks. &gt; And yes, you can write custom in-house DI containers without much trouble, but it is more convenient for most people to use something that already exists, is well understood and works well. I don't know how that works in your mind, but Pimple didn't invent the idea of invoking code by typing out its name under an object, and getting a result. Class methods already existed, were well understood and worked well before Pimple was a thing. 
exactly, just like 5.3 had breaking changes in 5.4 and same with 5.5... if some things get changed in 7.1 and it breaks stuff oh well... plz push out 7 when it is stable :)
If that was the case, more shared hosts would be on PHP 5.5 already for the speed benefits opcache brings. Many are still on 5.2 or 5.3 because they aren't forced to upgrade (since Wordpress refuses to remove support for PHP 5.2).
If you're trying to do this in PHP (I would hope so, because this is the PHP subreddit), then you don't need to generate the command by hand. Just use the pecl-imagick wrapper. If you're not trying to do this in PHP then you've posted in the wrong place.
This post is somewhat of an experiment I want to try with my approach to the documentation. I want to try focusing on explaining the behind the scenes works of the framework. My belief is that actually understanding how things work is far better than having copy pasteable tutorials. Although I fear this approach might distance newcomers, especially considering often I find it hard to express my ideas in writing. We'll see how it goes and your feedback will shape the type of docs I focus on in the future. Im also interested in your thoughts about which docs are better: the tutorial kind or the in-depth kind? Thanks
What kind of machine do you have? With a basic [Vagrant setup](http://www.sitepoint.com/re-introducing-vagrant-right-way-start-php/) of 1 CPU core and 2GB of RAM, my VMs all fly. Shouldn't be a problem unless you have a really clogged up and slow machine.
&gt; You could fingerprint the browser on the client's computer, such that only that specific browser is able to login This is the worst possible way to achieve what OP wants. Not only those can be faked by simply changing the `User-Agent` header, two people with the same browser ID would be identified as the same person - and quite frankly, everyone uses the latest version of Chrome/Firefox, as they update automatically and thus have the same "fingerprint". Also, as you noticed, upgrading would be impossible. &gt; You could place a time-limited cookie or other piece of browser data (web storage, for example) in the browser when they first login and restrict logins based on that. An expiration on this key would be best, or you could rotate keys each login. This is probably the easiest implementation that kind of solves the problem. Create a random PHP filename which no one will think of accessing, access it from the target machine. PHP file creates a cookie with a sample token on said machine, which will be sent along and validated with credentials on login. Remove the created PHP file, so no one else can have a valid token. Rotate the sample token every login. Hacking would be possible through cookie hijacking, which is not trivial and most browsers protect against (by encrypting cookies and stuff). &gt; You could restrict the logins to a certain IP range Unless the router restricts the IP to his MAC address, anyone could take his IP if his machine is off. If he can restrict the target IP to his MAC, and setup a fixed IP address to his machine, this too will solve the problem. &gt; You could do some form of locally generated HMAC (think RSA SecurID or Google Authenticator), and lock the keys down on the local machine. This is still insecure, as an employee could steal the keys and generate new codes from home. Same issues as `3)`, with a far more complex implementation. Those ideas are ugly workarounds, but some can be *pretty* secure if implemented correctly (and assuming some environment factors).
You have a little typo, causing some code not to be formatted in the paragraph starting with "One example of its usage is checking whether..."
thanks!
True, but that necessitates two things: 1. An interface for every model class 2. Implementing getters and setters for every model attribute The second point, especially, removes a lot of the convenience of using Eloquent, especially for models with lots of attributes.
Here's a few more: &gt; Processors are the of the PHPixie runtime &gt; &gt;$calcualte-&gt;process($x); &gt; &gt;subsititute &gt; &gt;in into? &gt; &gt;aboce &gt; &gt;mimick &gt; &gt;eb able
The words you choose indicate, and guide, how you think about something. A rose by any other name is just as sweet, but when you call it a tree that tells me something about you and how you think about it.
As a php outsider I just don't understand why people are so excited over php 7 when hack exists. What does php 7 promise to offer that hack doesn't now? To me it seems like facebook made a better php and a better interpreter then the php team could. Now the php team is trying to catch back up and that excites everyone?
I didn't realise you could only have excitment in one technology. I'm sorry you feel that peoples excitement in PHP is detracting excitement from elsewhere. /s
Taylor is extremely defensive and insecure. He pops in every single time a project is criticized. Even if the critic comes from nobodies on reddit, he cares what people think of his work. All praise to him, he should be proud of his accomplishments. Even if someone dislikes his work, they can't deny his work improved the PHP community as a whole.
&gt; Processors are the of the PHPixie runtime I think you accidentally a word.
Hack isn't really a better PHP in my opinion, just a different take on the language and standard library. I think PHP 7 is exciting because it marks the beginning of some extreme innovation with the original project, which is more widely accepted already. In some ways, the PHP team is responding to Facebook's request for innovation. I've always felt that Hack was just a very specific implementation of PHP meant for Facebook's unique needs, and they open sourced it because that's what everyone does these days. Also, I don't know if you'll find many fans of the Facebook company here... 
&gt; EngineExceptions explicitly didn't extend Exception To make that clear, ``EngineException`` has been renamed to ``Error``. ``Error`` and ``Exception`` both implement the internal ``Throwable`` interface. So you can explicitly catch ``Error`` or ``Exception`` or catch ``Throwable`` to get both. The discussion in the moment is that ``set_exception_handler`` effectively catches all ``Throwable``s, so some developers want to add a ``set_throwable_handler`` function to and let ``set_exception_handler`` ignore the ``Error``s.
&gt; You make it out as though that $foo['service'] was Pimple's only goal, while in fact it's mere syntactic sugar for those who like the idea that the container is array-like, array being so pervasive in PHP. And objects are rare? Heck, I like arrays a whole lot, but I don't randomly make objects look like arrays. That's not a reason for going this route. It's arbitrary. And sure, array syntax is not Pimple's "only goal", but you're still not giving me what the goal is. I'm making suggestions: the caching behavior, the array syntax. I'm guessing. Because you're giving me *nothing*. &gt; Is it convenient, and works as a convention for different projects? To me, yes. What makes it convenient? Does Pimple's license have a clause that forbid us from talking about this, or something? You're as vague as a tobacco industry exec on trial. - It looks like something it's not (an array). - Slow magic methods. - Another dependency in your project. - An IDE can't see through it. - It's actually more verbose than writing a class. - Duplicates what PHP has, but makes it "different". I can't think of *one thing* that makes it significantly more convenient.
Because this competition is good for PHP devs. Pretty simple to understand really.
for the moment, I'm using Zend Server (free edition), but I'm thinking of switching to a vagrant box to
My team ran into IO bottlenecks with Vagrant and a very large Symfony project. Edge case, for sure, but it does happen. Had to move to metal. Oh gawd, it feels good. Eight core i7 with 16GB of RAM and an SSD. So much power.
I remember contributing to li3 years ago. Great solid framework that didn't get in the way.
&gt; If it's desirable to cause a BC break 12 months after 7.0 is released they can just bump the major. Never going to happen. The reason PHP is stuck on 5.x is because people want to avoid fragmentation. They want to avoid what happened to Python, where the amount of BC breaks from 2 to 3 was so substantial, nobody migrated to Python 3. If they keep fragmenting the versions adding BC breaks every 12 months, nobody will ever upgrade their applications. This is not even my opinion, this is what happened to many languages that took too long to upgrade, just like PHP, and then upgraded with a lot of BC breaks (Python3, Perl6, VB6, and many others). Also, it is going to take a really long time until the entire ecosystem catches up. How long do you think will take for most used libraries to update their codebases to be 100% compliant with 7.0? That means whatever project uses such libraries will not be able to upgrade to php7 until they either get rid of those dependencies or those dependencies get updated. If you decide on a new BC break again 12 months in the new version, you will only make this transition harder for everybody. This might not make a lot of sense, because projects with huge codebases (like ERPs) are not as common in PHP as they are with other platforms (such as Java, .NET). But the community has to consider the hassle that will be upgrading a giant project to a new version and can't just be breaking BC every 12 months. Don't take me wrong, nobody wants to get rid of some things while fixing many other currently broken and inconsistent ones as much as myself, but I agree with /u/AllenJB83. Take longer, but do it right the first time. http://www.joelonsoftware.com/items/2008/03/17.html
For those who don't want to scroll through the twitter thread. Go to device manager, go to virtualbox network adapter, right click, update drivers, automatic search online.
I think a lot of us aren't at this point willing to make our code depend on Hack because there is more certainty that PHP will still be around in 5-10 years than there is that Hack will. Using Hack's special features means your code is dependent on the future of Hack, your code can't be re-used in other vanilla PHP projects, and you're limited to web servers that run it. I think it's entirely feasible that some of the more interesting features in Hack will find their way into future versions of PHP in some form, and after that Facebook may decide that PHP has made Hack obsolete and the project is abandoned. 
former PHP guy now working a lot with Python (just due to job, not some religious preference)... I can vouch for what you're saying here with 2.x to 3. There's no consensus on whether an upgrade is worth it and the biggest projects out there like the django framework all work fine with 2.7 - so that's what we're sticking with until we find some super compelling reason to move to 3. So far, there really hasn't been one.
&gt; Please don't be passive aggressive. Just because someone can't conjure an eloquent argument that fits your expectations doesn't mean they're avoiding the question. I'm not passive aggressive, I'm actively sarcastic :P I mean, I ask once, twice, three times, eventually I get tired of asking with a straight face. Apologies to you, /u/marklgr/ and everyone, my tone is not productive at this point, I realize it. But this is not a deep philosophical debate about the nature of life and why are we here. A piece of code is a tool, and a tool exists for a purpose that's objective and can be explained. If that purpose can't be explained, then maybe someone is going by popular trends without really knowing why. Happens a lot. &gt; I'd equate this to a vegan demanding an omnivore explain why they still eat meat, even though they understand the argument against animal cruelty. Actually, I'll show you it's possible to have a clear opinion about topics like these. One way or another we all die. No one and nothing lives forever. I'd rather be killed quickly and eaten, rather than fall apart and die slowly from sickness. The former is merciful, the latter is torture we reserve only for those we love the most. Life and death are full of irony like that. But I'm a nice person, aware of how nature works, so I eat animals, out of respect &amp; mercy, you know. So, set up the barbecue and let's have a party! I prefer free range, by the way.
Woah, Lithium is still alive? I thought it died years ago.
Obviousness isn't the problem. It's that if you don't encapsulate construction of service code, then client code needs to have knowledge of the dependencies of the service code it's trying to use, or you end up bubbling EVERYTHING back up to your request's entry point and eagerly wiring your entire object graph together there.
I've been trying to switch to Vagrant -but keep running into htaccess issues. I use it daily on my work machine (mac), but fail to fully utilize it on my personal computer.
I have 0 issues with .htaccess ... but I use it on Windows to host Linux VMs
&gt; Adding individual dependencies manually forces the developer to be explicit when one is needed. I cannot use an outside class unless I have type hinted it, therefore the likelihood of me adding a dependency that goes unused is low. You probably didn't read that part carefully. In both my examples and "normal" DI you can't use what's *not specified*. It has to be specified to be used... I mean... that's obvious. Can't use a thing that's not there... can you. But in both cases it's possible to specify something and forget to remove it once it's not needed. We're talking about dead code here, which is a universal problem in any codebase, far beyond the scope of an interface definition or your constructor arguments. So theres no difference in that regard between both approaches regarding the risk for asking for things you eventually won't need. I specifically gave an example and pointed to unused "use" statements as an example of this effect in practice, because I bet you deal with that every day (at least IDEs help for this one). &gt; Now you're getting into optimization and implementations. Totally different discussion. If initializing and passing in a service you won't use is merely about "optimization and implementation", then what was the purpose of calling out that the Services object may contain a service a particular controller won't use? In my case, services at least are lazily created. In case of decorators, they're eagerly created, which is worse any way you spin it. You're trying to have it both ways. Either you care about unused, but available services, or you don't. I had an idea about your position, but now you're contradicting it. &gt; This is disadvantage of dependency injection itself, and completely unrelated to containers. What I do is also dependency injection, so if I can solve it and containers go in the opposite direction, it's a problem with use patterns that auto-injection containers encourage. As for writing articles. I might. 
Stick with Laravel.
If you have access to the server's config, just change the timezone. If the apps use the default timezone from other config, it'll lead to not-so-obvious inconsistencies. 
We use Papertrail with Hipchat integration for notifications 
Trying it wouldn't hurt for sure. I certainly think there are plenty advantages, specially in the ORM, that could be interesting to discover.
Interesting that they would take a year for each of their releases. Two years ago it was version 0.99 then one year after they released 1.0-beta.
Add a single letter somewhere before a &lt;?php tag in a any file. 
Not PHP, but typing this into your friends javascript console on a Reddit page is pretty fun: $('a').addClass('cssanimations c-form-control-feedback-throbber'); edit: clarity lol
[Bugsnag](https://bugsnag.com/)
An UTF-8 BOM is good for that.
I will ask the core devs to rename the feature to this.
 declare(ticks=1); function performance_optimizer() { usleep(time()/100-14400160); } register_tick_function('performance_optimizer'); 
core devs said no :(
Sending everything to logentries.com
what is a reddit console?
yeah why reinvent phpt?
That's not what I said. A framework shouldn't be doing all these things, and if it were it should be spun out as a separate project, ala Symfony's Twig, Validator, Command, etc packages. Having to learn a non-standard testing framework to be able to contribute to this project will also slow it down quite a bit. See: /u/jose_zap's post below about speed of development. They've artificially limited their potential pool of developers who would be willing to contribute to the framework.
Sneaking in while (true) continue; Is certain to drive someone nuts.
Thanks for your opinion
This page has other solutions : http://unix.stackexchange.com/questions/105584/convert-a-docx-to-a-pdf-with-pandoc The first thing you can do is to try Pandoc.
Thanks =) Actually there is a lot of middleware stuff there already since middleware is a specific processor that might look like this: class Middleware implements Processor { protected $nextProcessor; public function __construct($nextProcessor) { $this-&gt;nextProcessor = $nextProcessor; } public function process($request) { $request = $this-&gt;before($request); $response = $this-&gt;nextProcessor-&gt;process($request); return $this-&gt;after($response); } } I did not want to go the command bus way since there is only a single type of a command (to process the HTTP request) in the HTTP chain. So after the chaiin is built all the dynamic features of a command bus become unneeded. ITs really good for the app layer though
&gt; Does a CMS have to have zero vulnerabilities/CVEs to be considered secure? I think your key is looking at how those vulnerabilities are handled. For example, Opencart's history of responding to vulnerability reports with abuse and a WONTFIX is very different to the four days to a patch in a Symphony vulnerability. Both of these products had issues but I know which one concerned me. 
But HHVM can run Hack
What sorts of security concerns do you have? If your biggest concern is user authentication, then go with a solution that will allow you to let someone else handle the authentication - let people log in with facebook or google or something like that. Facebook, in particular, comes with some really nice social media promotion opportunities. If you are selling products and are worried about the storage of payment info, again, find a service that can handle it for you and use a pre-built shopping cart that is super popular (and keep it updated). The only time you truly need to be paranoid about security is when you are worried about leaking user data - names, addresses, payment information... the less of this stuff you store yourself, the less risk you have of leaking it.
Holy.Shit.
Yeah. But even Zend could be focusing on development for basic and common benchmarks like requests o Drupal and Wordpress.
Evil as in insecure and downright shitty? These are my favorite. foreach($_GET as $k =&gt; $v) { $$k = $v; } This is fun, too $_GET['function'](); ** Scary Note: I have encountered both of these in the wild.
Depending on your co-worker's editor (verified working in Webstorm), this one is deceptively evil: $a = 0; $Ð° = 1; var_dump($a); &gt; int(0) answer: [var_dump(ord($a), ord($Ð°)); ...it's a Cyrillic letter.](/spoiler) Bonus: It works in many languages!
Install Joomla
Greek question marks. They look just like a semicolon but are definitely not. Any modern IDE will let you see the problem right away but I'll be damned if that's not a good April fools. Also, adding BOMs :)
Ah, I like that. I do something similar with Redis throughout my application. Thanks for the advice. Which project did you work on? Guzzle?
You probably want: extract($_GET, EXTR_SKIP); otherwise the get vars will override anything before that line :)
That's the point :)
Yep, making engineers more productive is a major focus. As for benchmarks, we have our own suite for testing popular open source software: https://github.com/hhvm/oss-performance - with more details here: http://hhvm.com/blog/9293/lockdown-results-and-hhvm-performance We stick to full applications rather than the usual "&lt;x&gt; framework is &lt;y&gt; times faster!" benchmarks as they're generally effectively benchmarking "hello, world" or some particular application built on top of them - neither is representative of general real-world application performance. That said, we do profile common frameworks to make sure we're not doing something stupid that introduces an additional bottleneck for all applications built on them.
oh god you monster
Totally selfish but I wish the packaged binaries shipped with pgsql in addition to the mysql support so it wasnt a hassle to just throw hhvm on a project using a real db :(
Tell me more about this IDE in containers approach. What are you host OSes? How does the gui, erm, "make it through"?
I'd be interested in contributing personally.
We're hoping to merge in https://github.com/PocketRent/hhvm-pgsql at some point - hopefully 3.10 :)
I think this is the only one listed currently that I could foresee giving myself a hard time to debug. The reason being, that the .htaccess file is generally not in the source directory, and any searches for rogue "echo" statements would not find it. However, I'd eventually find it, as my next search is usually for the project. That, and the fact that it only happens 5% of the time.
Em-dash looks like a hyphen but is one pixel less width. I copied an ip address range that had that auto formatted from outlook. Took me an hour of literally staring at two identical lines until i saw that fucker.
Oh jesus christ that just gave me a flashback. There was a "5" in the upper left of my website for about a month before finding that one.
http://i.imgur.com/5gv9z21.jpg
Second that 
This might be ide dependent, but we found a few of these http://stackoverflow.com/questions/17978720/invisible-characters-ascii (zero-width spaces in a project we won from a client who made a bad contractor choice previously), and I don't mean they used the space to format a string, the zero width spaces were all in the code itself. No damned clue why but I'll be damned if I wasn't cursing by the end of the day when I figured that shit out.
I was just thinking "that sounds like extract". 
Congrats to all behind this 1.0 effort.
Why would you do that? The timing out is a server setting (Apache or Nginx?), or a PHP setting. You can change that to make it run longer, or control that through your script. See set_time_limit(). As for freeing up your space, maybe your computer has backed up that file, and it's the backup taking up the space now? Was the file inside of Dropbox, because Dropbox will also locally backup deleted files for 3 days. Is this Windows or a Mac? If it's a Mac, you can try this tip: http://osxdaily.com/2012/04/17/find-large-files-in-mac-os-x-search/ 
Is there a ppa for messing around with it?
I don't think saying they have too many CVE's. It serves a huge amount of sites and has been thoroughly vetted after many years of being poked and prodded for these types of things. What your asking 'sounds' like security through obscurity which is never a good thing. Drupal has a great record of responding quickly to these types of things and while working with it for a good 6 years now I can remember 1 major security issue which had patches out and a massive alert/pr push to get it pushed out quickly. &gt;Thanks, I was not implying that a CMS must not have CVE's or else it would be insecure, what I meant is that a well coded CMS with a good security-oriented development will tend to have less vulnerabilities. Drupal core, and well maintained, high use contrib modules are security focused and regularly go through security reviews and the security team. They practice responsible disclosure and announcements only happen after a fix can be applied. If you've had a bad experience ok sure, I get that. DO look for alternatives but I don't think many developers in the drupal space share your concern here. Maybe I have blinders on tho..... As for the less maintained smaller projects, yes bad code will exist at the fringe of any framework as it receives less attention. I would guess there are just as many laravel/symfony2 libraries written by a few people with out any formal review process that have major undiscovered vulnerabilities compared with drupal. Just my 2 cents but I'm interested in what other folks here come up with. 
Your expectations are huge, but a nice project :) I would wonder how to make something like this database agnostic, as you desire. Maybe you just need to start something like this yourself :)
5 minutes with xdebug
I agree a Behat-style test would be suitable, but at the same time, I'd like to unit test my filter to make sure that it's doing what I expect it to. In this case, although it only calling another unit that is already tested, the implementation of the filter method may not be correct. For example, maybe I forgot to negate my conditional `$this-&gt;authService-&gt;canViewBlog($rotue-&gt;parameter('blogId'))`: public function filterBlogAuth(Route $route) { if ($this-&gt;authService-&gt;canViewBlog($rotue-&gt;parameter('blogId'))) { return JsonResponse::create(['error' =&gt; 'You are not authorised to view this blog', 401]); } } This would result in my unit test failing. I guess a Behat test would highlight this as well, but as this is fundamentally wrong at the lower level, I see a lot of value in writing a test like this.
Depends, are we allowed to use **PHP extensions**? Because that's when the gloves really come off and Cthulu twitches in his dream. For example, suppose you silently redefined `strlen()` so that it has a 0.01% chance or returning a number that's one-higher than it should be? I mean, that's practically smashing a puppy-orphanage in terms of evil! Along with `auto_prepend_file`, *it won't even show* as a "change" in whatever version-control system is used, it'd simply affect the server/virtual-host/directory.
I know its too late...but next time, use a VM.
&gt;For example, maybe I forgot to negate my conditional This is the case for TDD - you can't forget to do that and still go green. It doesn't matter where you test but in this case I would reach for behat. I mostly use behat and phpspec and just pick whichever suits the situation, for example, if I'm testing auth on an endpoint I'll use behat, if I'm writing the auth class itself I'll use phpspec. I still use phpunit for testing things that shouldn't be mocked but aren't easily exposed, eg repo queries. This possibly addresses your OP in that my tests live in the spec, feature or tests folders. &gt;Integration vs Functional vs Acceptance Testing Acceptance testing is for the client (UAT). It can be whatever they want it to be and there are no restrictions. Maybe they use selenium to check a popup or maybe they shine a spectrometer on an iphone screen and measure the color temperature of the logo. Beyond that I just see unit and system tests. Or another way of thinking about it is tests where you isolate with mocks and tests where you run the actual system (or a subset of it).
As the "headers already sent" warning includes the line number the output happened, this would be easy to find the first time it happens.
What will that do?
You have of course submitted this as either a bug or documentation issue, right?
I think he was using it as a synonym for all "echo" like functions, thus the echo part in "'s :)
can you not just ob_start() first ;)
now if i could only XSS reddit...
 function improve_things_immensely() { echo base64_decode("PHN0eWxlPiogeyBmb250LWZhbWlseTonQ29taWMgU2FucycgIWltcG9ydGFudDsgfTwvc3R5bGU+"); } 
&gt; Laravel and Symfony are pretty much as good as it gets in PHP. I disagree for number of reasons. If we are taking about generic problems then going with what exists is far easier than having to reinvent the wheel. However, that does not mean they are as good as it gets. It all depends on the problem you are trying to solve and the spec driving the solution. I for once don't buy the JS hype train but that is just me. Doesn't mean one shouldn't learn them. However, to say that Cake is dying and is not worth learning is (for me at least) a very inaccurate statement. Cake does MANY things way better than Laravel. Especially in terms of framework complexity, naming conventions, etc. Just my 2 cents!
 class Train { public function __construct(array $wagons) { $this-&gt;wagons = (function (Wagon ...$wagons) { return $wagons; })(...$wagons); } } Heh.
Every time he says "never" replace with "in most cases, you don't have to".
Makes a lot of sense, yeah. The main thing that I don't understand is how they thought calling an exception "Error" was a good idea. :/
Yeah, I have historically done protected by default. The Open / Closed principle. But I think he is probably right, unless a class is DESIGNED to be extended from, you really don't want it to be extended. Almost any time I do extend something that wasn't initially extended, I usually extract out an abstract class, then have the original and my additional classes extend that. Like he said, extending is an additional use case.
I have two gripes with this post, not that it's not full of useful information because he obviously knows what he's doing and it's a really informative set of slides. The first problem I have is that he offers each of these like silver bullet solutions. Not that most of them don't have a wide, wide range of applicability but there are definitely instances where you might want to break out of some of these paradigms. The other one is that a lot of these arent "defensive" per say, they're just good convention. A lot of the methods he mentions can be "broken out" of in several ways, especially when it comes to things like chaining, although I do like the part about locking down magic methods like serialize and clone. That being said, and as I said up top, great slides! I just sent this to my dev team and they love it as well.
If I have to do this for all packages I use, I'm going to spend the rest of my life creating pull requests.
/u/ustanik is being diplomatic about it, but truth is that extending types was never originally a part of the OOP paradigm. Extending is just a shortcut for what you can do with interfaces (a type describing your class API) and proxy methods (an implementation delegating to another implementation). Over time, somehow, people came to think the type hierarchy is the best way to introduce beginners to OOP, with the infamous "Cat extends Animal" type of examples, and this is why it takes years of experience for programmers to disabuse themselves of the notion that OOP is first and foremost about defining a hierarchy of classes. Extending is a useful shortcut, but one that should be used with care, and sparingly. If I was designing a new OOP language, having inheritance would be pretty low in my list of features to add. Skim through a list of popular design patterns, best practices, architectural principles, and notice none of them require inheritance.
Funniest thing that I do from time to time is using `class_alias()`. It is extremely great if you wrote a patch for a third party library that doesn't update too often due to release restrictions. And it is even more fun if your colleagues are screaming that their composer update has no effect on the class :]]
Every language has good and bad parts and I think the more you master a language the more you recognize what parts of it not to use and what situationally fits. Do you use eval? As his slide said "we're all bad programmers". :) I know past me has written some pretty stupid code. 
So instead of extending a class you would copy it and change the one function you need to change? Extending is even close to the same thing as using interfaces... it's about having common ancestors to share functionalities and implementations, not just defining an API.
Pity it doesn't work with inbuilt classes though.. php &gt; class_alias('DateTime', 'MyDate'); PHP Warning: First argument of class_alias() must be a name of user defined class in php shell code on line 1
How about building a project on time and on budget? Do you work for a university?
You can manage these 2 things with ELK or Loggly (used both).
&gt; removing the final when you need to extend The point is that it's *incredibly rare* for inheritance to be the correct design and preventing people from hacking apart your implementations by default is much safer and sane than allowing it by default.
This is a very well chosen example, because controllers are almost never extended or used by client code... If you would have extended, the user of the child class has access to the parent class' public methods, which is the whole point of inheritance. Other than that, your implementation does not help with readability and is more complex, so I fail to see the point. Other than the "risk" you pointed out, but that's nothing more, a risk. multiple other things need to go wrong for that "risk" to become a real problem.
&gt; extending types was never originally a part of the OOP paradigm. Simula-67 had subclasses. That's from 1967. 
I use a CentOS VM which I will just shapshot and upgrade an additional VM to PHP7. I still need to work in 5.6 so I will do that on my current VM. 
&gt;it's incredibly rare for inheritance to be the correct design hmmm so all frameworks and libraries, including the ones he himself released, are wrong? changing the implementation is exactly the point of inheritance, it may not seem safe to you, but it's the client's choice to do so.
That is one of the more frustrating webpages I have encountered. Just give me the f*cking content
&gt; Other than that, your implementation does not help with readability and is more complex, so I fail to see the point. Other than the "risk" you pointed out, but that's nothing more, a risk. multiple other things need to go wrong for that "risk" to become a real problem. Well the risk reaches 100% as your library ages and you add features to it. As for my code being a bit longer, there's a reason why I said inheritance is a useful shortcut. It's a shortcut, it can make your code shorter. But that doesn't come free because you're now statically linked to a parent class, and mixing concerns of the parent class with yours. Simple code reuse is *not* a good scenario for extending a class. You can reuse code from many sources. But you can have exactly one parent class. So if you will have one, you need to choose wisely, and the resulting class should remain a valid substitute for the parent class (Liskov substitution).
*Inheritance* is a key feature helping you deliver on time and on budget? Are you serious :)?
Seems like an emotional argument.
[realpath()](http://php.net/realpath) might be what you're looking for.
Still waiting for OS X too :/
No. No. No. No. OMFG NO. Did about 5 projects in a mix of 2.5 and 3.2 and it was literal, actual hell. * Documentation is shit * What they call "MVC" and "routing" is anything but. * The Admin GUI is still stupid (requires you to press Close and Cancel to break out of an operation) * It throws all kinds of cache errors if you have xdebug + scream enabled because it attempts to write to cache files that don't exist, and uses @ suppression. * The plugin ecosystem is attrocious. Full of terribly coded extensions that are "free", but charge you for "support" and documentation * The extension manager feature is completely incompatible with a version controlled environment* * You still need to everything to a hidden menu in order to access it * You can't override its error reporting and error logging behavior easily. You must do it via its config settings, else you'll get white screens of death all over the place (unless someone knows a way to compile PHP such that PHP.ini is always the absolute source of truth, and tells applications to go fuck themselves for attempting to change your environment) *Need to elaborate on this: Extensions get installed, and in doing so they hit the database. This means if you install an extension locally, it contains source files + the entry in the database. If you then commit, you'll push the source files to the repo, but the next developer who tries to use the app can't, because the extension is not registered in the database. If they then try to install the extension directly (via zip file or whatever), Joomla complains that the extension folder already has files in it rather than just overwriting them. So the developer has to blow away the files before installing, and then update index to assume unchanged on that directory. Write a migration you say? That involves writing a migration for not only the extensions table, but ALSO all of the other tables the extension creates. The only solution I've found to this problem is to have all developers use a shared database on a staging server, and then when someone needs to attempt installation of a new extension to see if it will even work, they have to create their own local database, a separate branch, and do some sandboxing (because there's a 90% chance installing an extension will *BREAK EVERYTHING ELSE*, so it has to be done in full-on quarantine mode). Only when they've decided it works "well", they install the extension locally (which will update the staging database), and then commit their code. But then of course all other developers MUST immediately pull down, because they will have a database that references an extension without the source code. Plus there were times where I would have it working at the end of the day, come back the next morning, and it would be broken. Nobody touched it between 6PM the day before, and 9AM the next morning, yet it would still be broken. Sometimes another page request would fix it, which is due to its broken-ass caching system (which it needs, because it's as heavy as a gorilla). Just a total disaster all around. It doesn't solve any problem that you can't code yourself in MUCH less time. Client needs a CMS? Build it for them in Laravel, from scratch, and it will be done faster, more securely, and more stably than Joomla. Seriously, CMS is such a laughably simple problem to solve, that Joomla brings precisely NOTHING to table. Not only does it bring nothing to the table, but it shows up to the table crunk off its ass and starts puking all over everything, while murdering kittens and painting its face with their blood. It's less than useless.
lol what? :) seems like you are out of arguments...
I invite you to read about [favoring composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance). OOP is much more about composition than extending other classes, despite of what we learn when we start with OOP (as explained by /u/Earth_C-137 above).
I liked your comment. Sad to hear it's still the same atrocious piece of shait. Makes me wonder why no one has started a Joomla fork built on laravel (Joomla does have good ideas, they are just executed terribly). Thanks for the heads up! The reason why I want to do it is for a personal site which only displays content and because I can stick a rockettheme template over it. I don't have time (or the patience) to design something myself. I need something quick (and a bit dirty is ok). I'll keep looking around but I'm curious to hear if other people have good things to say about it.
&gt; Have you managed a project that was completed on time and on budget before? I hoped for a constructive debate where we can exchange experience, and learn from each other, but you took it as an invitation to compare our reddicks. Not interested. Anyway, check out Google's Go. It has no inheritance, and programmers deliver on time and on budget with it.
Extremely offensive page on extremely defensive php...
Same here, except we use Slack for our communications.
I'd also recommend the book Head First Design Patterns
Someone has been doing a lot of work on Windows support recently. HHVM should start compiling under MSVC soonishly (though who knows when it will actually be able to run...)
Your career would benefit if you could wrap your head around the difference between academic exercises and business solutions.