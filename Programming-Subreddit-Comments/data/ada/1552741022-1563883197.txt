Shouldn‚Äôt there be another one today/yesterday?
I mostly agree with this. Ada should be high on the Rust topic list given some of the goals of each PL. I have even seen Steve Klabnik comment on Andrew Kelley's Zig PL, but IIRC, it was in defense of Rust based on one of Andrew's assertions about Zig vs. Rust. There's also this: [https://www.reddit.com/r/rust/comments/4qs5sl/rust\_and\_ada/](https://www.reddit.com/r/rust/comments/4qs5sl/rust_and_ada/)
I know Ada and iam surprised that few companies use it. It's the best programming language after python. 
That's my article :D thank you so much for sharing ^^ 
That's a really interesting fact! Do you know the details on why it was called that way? :)
There were multiple languages with different codenames proposed to be Ada. Codename of the language that won was green. 
There were four groups from different companies, each given a team colour, red/intermetrics, blue/softech, green/Honeywell bull and yellow/sri. It‚Äôs all here https://en.m.wikipedia.org/wiki/Ada_(programming_language)
It‚Äôs a shame you didn‚Äôt go more into detail on why you think it‚Äôs cool, with example code to show your points.
It'll be a lot better (like actually have intellisense) when I get a working langserver!
Yes, you'll need to deallocate it. You can make your type controlled to avoid manual deallocation (Basically like C++ RAII). If you want to know more check out this for a quick summery of memory management in Ada: https://people.cs.kuleuven.be/~dirk.craeynest/ada-belgium/events/16/160130-fosdem/09-ada-memory.pdf
That's fantastic, thank you for the response. 
If you define the storage pool size for an access type then when the scope of the *type* goes out of scope then the storage pool will be reclaimed. type Character_Pointer is access Charater; for Character_Pointer‚ÄôStorage_Size use 2048; ‚Äî 2KB storage pool So when your code moves outside of where Character_Pointer type is defined then all objects allocated will be reclaimed. An alternative method is define your own storage pool for object and when the pool object goes out of scope your pool object will reclaim memory. See http://www.ada-auth.org/standards/12rat/html/Rat12-6-4.html
Ah I see, so should this be the preferred method of allocation when necessary?
It depends. For instance, if it's too restrictive to use access types with deeper scope, but you want to have automatic deallocation and not worry so much about dangling references, then implementing your own smart pointer or using one provided from one of the FOSS libraries might be the better path. Some people use the Ada containers to help manage memory (e.g. container owns the object so when the container goes out of scope, then it can destroy the objects during finalization). If you need to have more control over the low level details of how memory is allocated, then implementing your own storage pool is the way to go. Any of the ideas I mentioned or a combination of, could be useful depending on your particular needs. 
FOSDEM also have a video recording of that talk: https://archive.fosdem.org/2016/schedule/event/ada_memory/
Or, you can just do: type Character_Pointer is not null access Character; 
In my experience, access types are never needed in Ada.\* Therefore, I never allocate and never need to deallocate. &amp;#x200B; \*First-order approximation. Probably second and third order, too.
Wrong Ada. This subreddit is for Ada programming not the Cardano cryptocurrency.
I'm a rust dev and I read about and have been interested in Ada (hence , but I don't see why we would mention it? What's the point? Why not mention Java or other languages then? Most rust devs only want to see memory safe languages used - with an obvious preference to rust, but if it's Java whatever. I don't see these two languages as being at odds, I think we all just want safer software...
Too bad on the programming Reddit group, the author stated that he has no plan to switch to Ada. He was only looking at Ada so that he be more educated about it, which is something more Rust people should do (and vice versa) ([https://www.reddit.com/r/programming/comments/b6gvhy/learning\_ada\_steve\_klabnik/ejkphqs?utm\_source=share&amp;utm\_medium=web2x](https://www.reddit.com/r/programming/comments/b6gvhy/learning_ada_steve_klabnik/ejkphqs?utm_source=share&amp;utm_medium=web2x)).
Bring it up with Elon?
Well VDHL and Ada are basically next of kin... verilog is more akin to C Should you be concerned? Probably its almost certain they won't do a properly safe design first time around until someone gets hurt. Another consideration is layers of safety...it shouldn't be able to injure you to begin with...
What happened to [http://learnadanow.com/](http://learnadanow.com/)?
It was David Botton's site. His [other one](http://getadanow.com) is still there.
Does the device allow you to insert yourself into the Matrix?
It will be difficult for anyone to help you improve the architecture of code without being able to see the code.
I send a tweet to Elon. Will see how it goes
He might be too stoned to answer though ü§™
Understood. I'm not quite ready to release the source but plan to when I get it to a point I'm happy with. I'm hoping that I can find some more examples of Ada stream IO with class-wide types online.
Knowing what the errors are would help.
If you open up GPS there is a [helpful menu selection](https://imgur.com/qkpBjBR) for accessing the standard library. Generally the standard library are the "libraries (imports/withs?)" that are "shared" compilers. Everything in the GNAT submenu however is specific to the GNAT runtime and not shared. 
This helped me find the directory where the gnat ads files were thanks! Yeah Greenhills is proprietary, but I found the source (locally on my machine) as well (was easier then gnat lol) As I suspected, my problems are due to compiler differences so I guess I'm modifying/making gnat compatible versions
Features in Ada Reference Manual chapter 13 may not be implemented the same way by different Ada compilers since these features are really low level. Hopefully, fixing these incompatibilities are from moderate to trivial task. Just in case you hit some porting problems, just post them here. I am sure that some of us will be able to help. 
If it is implemented successfully in regular subprograms, moving it to a separate task is a trivial to moderate effort.
GHS has some custom ada runtimes (gstart, gmart, gmert) are you by any chance seeing library references to that?
No mostly ghs (implementation) differences in Ada package and it doesn't help that my ghs is compiling against a different architecture (gnat is compiling against win32 cuz I'm working on Windows and I wanted to keep it simple/didn't look to see if it was possible)
And no surprise after I post this same headline on the Programming Reddit group it gets downvoted.
Bizarre. However, I could imagine that some would not like it since it essentially is marketing material. 
[learnadanow.com](https://learnadanow.com) looks fine to me. [adaic.org](https://adaic.org) doesn't look anything like spam to me. It's the official site of the Ada Resource Association.
Could your task‚Äôs entry return an `access Foo‚ÄôClass` when it had one ready to be returned? The I/O task would need to allocate it, the main task would need to deallocate it (or you could make it a smart pointer).
http://mapusoft.com/admin/wp-content/uploads/app-coe-linux_x64.tar.gz http://mapusoft.com/admin/wp-content/uploads/app-coe-linux.tar.gz http://mapusoft.com/admin/wp-content/uploads/app-coe-windows.exe This one currently lacks AdaMagic. AdaMagic on its own supports 64 bit, but this particular edition is plainly missing toolkit files and sample project: http://mapusoft.com/admin/wp-content/uploads/app-coe-windows-x64.exe I track updates by visiting http://www.mapusoft.com/wp-content/uploads/documents/Release_Notes.pdf In particular, now it says: New ada release will support the use of hex (and binary and octal) literals in the generated C code, when the corresponding literal in the Ada code is base 16, base 2, or base 8, respectively. No longer use the "0b" prefix for binary literals, as it is not supported on all C/C++ compilers. It uses hex literals ("0x") instead when the Ada source program uses base 2 or 4. New compiler will support the use of Complex number functionalities.
This is very useful when you have localized algorithms that use pointers during temporary computations. For long-lived data structures you will likely have to declare the pointer type at the top level (library level in Ada parlance) and that never gets automatically reclaimed. Still good to be aware of it, but in my experience 99% of allocations end being managed in RAII standard fashion with Controlled types.
Not relevant to this subreddit
you're looking for /r/cardano/
Release notes would be dope!
Still GPLv3?
I didn't find any.
Yes, afaik still with the GNAT linking exception.
unfortunately my rate in SE is super-small, so I can not troll C++ fans ;) One guy asked where to find information about Ada from people who used it in real, not only Wikipedia quotes, right answer is to point out this subreddit where there are a lot of interviews with Ada developers.
You won‚Äôt forget nd the blue spec. We talked about it on c.l.a a while back. People say that Blue was the weirdest out of all of them. Red is online. Green is Ada and the original docs can be found easily. Yellow and Blue are not available, but should be.
I hope Null\_Unbounded\_String (being the default value of Unbounded\_String) does not serialize all tasks to mutate shared reference counter, and Ada finally becomes ready for multicore
A while ago I came across E Dijkstra's commentary on all the proposals including Blue. They are online. Not the spec but it may help?
Interesting finding. Thanks. &amp;#x200B; Blue [https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD659.PDF](https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD659.PDF) Green [https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD660.PDF](https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD660.PDF) Red [https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD661.PDF](https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD661.PDF) Yellow [https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD662.PDF](https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD662.PDF)
I, too, would be interested in a copy of the Blue language.
Backed by popular demand from my first "SHUA" post. This one goes quite a bit more in-depth. It was quite a bit of work to really drill down into this issue, but I thought it was a pretty great example of why the Ada type system and run-time checks are so effective at preventing really serious bugs. Hope y'all enjoy it!
While this is a step in the right direction, I don't have high hopes for them listening to the community; they simply don't have a good history of doing so.
Great analysis. Keep them comming.
This is an API that needs to be broken! In fact, since it seems that the user passes a uint32 UUID to an int32 (or int) parameter without anyone noticing anything wrong (doesn‚Äôt GCC complain if you do that with any sensible warning level?) no one‚Äôs going to notice the change anyway
Great articles! Well done, looking forward to more of them! A couple typos: - SHUA1: s/convinces/conveniences/ - SHUA2: s/indented/intended/
What really grinds my gears is how \`g\_param\_spec\_int\` in \`glib\` accepts explicitly invalid values and 'corrects' them. I see only bad things that can happen with a behaviour like that.
that sounds like an call to build a (g)libc in ADA :D
Great job! Once again, a wonderful write up by annexi-strayline. I am impressed how deep your analysis was. I think some diagrams would really help if you were ever to present this to an audience (hint hint). I am so glad you gave clear examples showing how despite different approaches to implement the code in Ada, all would still have caught the issue. I am really looking forward to more of your SHUA articles.
Thanks!
Thank you neighbour!
That was really the biggest surprise when I was analyzing the bug. When I found that call to g_param_spec_int I just thought "no.. no that can't be it". It was.
Well actually you don't need to. glib is basically a bolt-on OOP framework for C. That already doesn't make much sense, but Ada is fully object-oriented anyways. So everything that glib has, Ada has in the actual language. Ada also does it in a much more sane and safe way, obviously. I'll be focusing on that aspect in part 2, however :P
Thank you! I would love to do talks on these sorts of things one day. Thanks for the encouragement. This post was quite a bit of work, but these kind of reactions really make it worth the effort!
As with most of these kinds of projects that I've seen, the built process is normally a wall of warnings...
A giant step backwards. Ada doesn't need pointers. Neither does SPARK. What it needs is a good, standard set of proven unbounded data structures that SPARK programs can use.
I am on multiple projects where they use the Coverity static analyzer and it catches cases of mixing unsigned int and int values. Great! HOWEVER, the problem is that there are so many of these found that in a couple projects, they end up turn off the checks or ignore most of them. Why? Because a majority of the findings are harmless (e.g. most of them usually are with numeric literals, such as 0, which Coverity complains needs to be qualified with U to make it 0U), so it's mostly noise. This makes it easy to overlook more significant findings.
Another: s/Backed/Back/
Would it be possible to customise the errors checked for? I think there‚Äôs a Misra C checker that you can tell (by comments in the code) not to report on certain checks. In the case of `0U`, of course, you might as well fix it :-)
i actually meant a library other languages could use :)
\&gt; Misra C &amp;#x200B; Alternative may be also F\* (with translation to C).
So after a bit of digging, when setting a glib \`property\` to something that is not a \`valid\` value, the documentation tells us that the behaviour is undefined, but glib should issue a warning.
And that's what it does. And missing the capabilities to raise an exception that's about all you can do it that language.
This channel has nothing to do with Cardano, it's a channel for Ada programming language see [https://en.wikipedia.org/wiki/Ada\_(programming\_language)](https://en.wikipedia.org/wiki/Ada_(programming_language))
I apologize, apparently I did not understand. I deleted the message from the tape.
Maybe a freedom of information request with the DoD could dig up something? They must have had the specs at some point to evaluate them, including material on the evaluation itself...
That would be yet another tool in the chain (I mean the translator)
&gt; fixed the initial issues with the 2019 installer This topic is of interest to me - what kind of issues did you run into there and did you put in a bug report somewhere that describes them?
The initial 2019 install's gps didn't start even after I patched in ncurses5 libs. Then I ran the `doinstall` script after being confused for a minute and then assuming that this is merely an extracted tree from which I'm supposed to create the final installation with baked in paths and stuff. That 2nd install seemed to work at first but it didn't find `gnatlink`. Today, I deleted everything and installed again with the GUI, since I couldn't find a simple tarball as in 2017. This time, patching the ncurses libs seems to have worked. I've had it happen that, after quitting gps, there were zombie `gps_exe` processes. Haven't seem them yet with the new install. Ideally I'd write SPARK with ada-mode.el just like when I use Proof General for Coq, but I can live with SPARK-less ada-mode.el. Fully aware that the current licensing and distribution model isn't the result of random events, I would still like to explain what I expected and what surprises I've encountered when trying to adopt SPARK. Basically, my takeaway right now is that SPARK 2014 could be a great tool if it came with the same GCC compiler exception for everyone that wants to write SPARK without GNAT Studio and that way help spread more Ada into open source packages potentially included in major Linux distros. Dragonfly BSD has two tools written in Ada, and there could be a more SPARK mindshare with inclusion of SPARK into FSF Ada or a different Community release.
If you don't mind me asking, what platform was the initial install done on? &gt; SPARK 2014 could be a great tool if it came with the same GCC compiler exception for everyone that wants to write SPARK without GNAT Studio and that way help spread more Ada into open source packages Agree completely
Arch Linux. If GNAT Studio doesn't bundle ncurses 5 itself, then a Guix recipe would make a lot of sense, when you consider that it's both GPL3 and makes it easy to provide a GNAT env with the right tools and their (old) versions. There was interest in packaging SPARK in Guix a while ago. How do you use SPARK? Open source or professional at work?
Debian had SPARK 2012 but it got removed after gnat 8 failed to build it from source and may return after bugfixing, but 2012 is also a pretty old version and wouldn't be super useful. Still, this is what would help SPARK adoption, just a regulat `apt install spark` followed by using `gnatprove`.
The most recent version of SPARK2014 that will build with a FSF compiler (without further patches or gnat source) is the "fsf" branch of Adacore's SPARK 2014 repository. The 19.X branches will also build with small patches. You'll likely run into dependency or version conflicts if you don't also build xmlada, gprbuild, and gnatcoll programs and libraries first from more current source (e.g. github) than is typically delivered with linux distributions. Depending on your flavor and version of linux you may be able to use Why3, Alt-Ergo, CVC4 and Z3 that comes with it or you can build those yourself too. By building a gcc-8-branch or gcc-9-branch gcc first, I've had this working on Debian 9 as well Ubuntu LTS versions. https://github.com/AdaCore/spark2014/tree/fsf
Seems free Ada scripts on GitHub, they‚Äôre a bit out of date but copy the instructions, should work. Also for x86 32/64 Linux can also be used for bare bones, just use the ‚ÄîRTS flag. Also ‚Äúfreestanding‚Äù is part one father C spec, not Ada.
Thank you, that looks quite useful and only seems to be half a year older than GNAT Community 2019. If I build the fsf branch with gcc-ada from my Linux distro, which I assume is FSF Ada, then the result will be FSF SPARK that will allow me to license my SPARK code under MIT via the same compiler exception I get with gcc, right?
Yes, but not for the reason you may be thinking. Whether the linking exception allows you not to release source code with binaries is dependent on on the compiler tool chain and libraries. gnatprove (the program that most people think of when they think of SPARK) is not a compiler. It is a verifier and prover. From a licensing perspective it doesn't matter what compiler it is built with as it doesn't generates binaries. Think about it the same way as you would linters or other static analyzers.
[removed]
Of course. I also made the assumption that a differently licensed runtime library might be involved, if some of the assertions have to be translated to runtime checks.
At the risk of repeating myself or saying something you already know ... The assertions and runtime checks are Ada 2012 and come with the version of the GCC compiler. There isn't a different or SPARK specific library to worry about from a licensing perspective. So if you are willing to use two different toolchains you can use prebuilt binaries. If you want to use the same toolchain for development and deployment (with GPL linking exceptions) you'll likely need to build it yourself from source or try and cobble something together mixing binaries.
Nah, it's fine, and I appreciate you taking the time to educate/clarify. I was under the impression that SPARK 2014 expands on what invariants are expressible already in vanilla Ada's "sub-typing", my bad. I should note that I didn't write any SPARK 2014 code yet and am in the process of figuring out how feasible it is for an MIT-licensed code base. I'm glad we both agree that I should be able to write and distribute MIT-licensed SPARK code when making use of spark's fsf branch, which conveniently bundles (git submodules) the right releases of solvers etc. I have to admit, though, that the toolchain differences and missing FSF SPARK packages was a little unexpected. I was thinking that support, training and extra tools would come with GNAT Studio (like a commercial Lisp) but the underlying toolchain that can discharge SPARK assertions and also translate the Ada code to binaries would be on a similar licensing level as g++. Thanks for your patience and explaining it to me!
I really should push the last changes I made.
From the [Annotated ARM A.18](http://www.ada-auth.org/standards/aarm12_w_tc1/html/AA-A-18.html): &gt; 5.r/2 If a container's element type is controlled, the point at which the element is finalized will depend on the implementation of the container. We do not specify precisely where this will happen (it will happen no later than the finalization of the container, of course) in order to give implementation's flexibility to cache, block, or split the nodes of the container. In particular, Delete does not necessarily finalize the element; the implementation may (or may not) hold the space for reuse. &gt; 5.s/2 This is not likely to be a hardship, as the element type has to be nonlimited. Types used to manage scarce resources generally need to be limited. Otherwise, the amount of resources needed is hard to control, as the language allows a lot of variation in the number or order of adjusts/finalizations. For common uses of nonlimited controlled types such as managing storage, the types already have to manage arbitrary copies.
Interesting, thanks!
If I remember correctly Ada tasks are usually implemented as operating system threads, so performance would depend on how well that OS performs with hundreds or thousands of threads.
It's more a question of design than of the language. Ada's defined tasking semantics may just make your life easier. I've worked with real time systems with dozens of task running on a measly Motorola 68k, and later, PowerPC.
I'm not sure what do you mean by "scale", if you're asking if Ada uses green threads/fibers like Go then no, GNAT uses one kernel thread per task. You can still use thousands of threads just fine though.
Hi, I haven't used Ada with many tasks, however I'm sure there are people who have been able to get good performance with it, not necessarily the best, especially compared to some of the vendor specific extensions to C/C++ (e.g. Intel's Threading Building Blocks). For instance, I do recall there was a person many years ago, whose name escapes me (argh!), who wrote an Ada program involving many tasks for a programming competition. His program won. There has been efforts to improve the performance of Ada. For example, there is the Paraffin library that Brad Moore developed (see [https://sourceforge.net/projects/paraffin/](https://sourceforge.net/projects/paraffin/) ), but I have yet to use it myself. Currently, the next version of Ada will have support for more fine grain parallelism (for example see [https://ae2019.edc.pl/presentations/keynote/Ada-Europe%202019\_%20A%2020-20%20View%20of%20Ada.pdf](https://ae2019.edc.pl/presentations/keynote/Ada-Europe%202019_%20A%2020-20%20View%20of%20Ada.pdf) )
I don't see where Ada's task semantics would require more overhead than those of other languages. I doubt that any language is *designed* for running thousands of tasks. That does not mean that they are bad at doing it, it just seems like an exotic use-case. For example: Even on a typical server, you have less than 100 logical CPUs. This means that if you require thousands of tasks running in parallel, you'd build a distributed system with multiple nodes. On the other hand, if you need those thousands of tasks only running logically in parallel, you can as well just create as many workers as you have logical CPUs, and then give all of them the data sets you want to process sequentially. Most probably, that would be faster than having thousands of tasks (assuming the tasks are there for processing multiple data sets using the same algorithm; this is a common technique called *thread pooling*). And if those thousands of tasks are actually doing completely different things‚Ä¶ well, I can't think of a single use case for that while still staying on a single machine. Also think about stacks: Each thread requires a runtime stack. Different operating systems place different limits on the total memory usage of one process, and if tasks are mapped to operating system threads, you may run into a hard cap here when you create several thousand threads. In Ada, you can define this size in code using the [`'Storage_Size`](https://www.adaic.org/resources/add_content/standards/12rm/html/RM-J-9.html) attribute, so Ada may actually help you here to keep your task memory consumption low. However, this means that you also need to ensure that you have enough memory for the task to do its job. So, bottom line: There is no reason Ada would be a bad choice, however you may want to think about whether having thousands of threads is actually a good solution for whatever problem you're solving.
LWP?
Like POSIX thread library? it runs LWPs on Linux/Windows
You can pin tasks to cpus in Ada now.
Also look up the distributed systems annex for how to transparently spread tasks across a number of machines.
A
Originally there was a green threads implementation as well.
What are your needs and your background? It is impossible to answer this question specifically, but I'll try to give some general thoughts. I think Ada is worth learning because it, despite being around since the 1980, has a number of really solid ideas for software engineering which are not/rarely found elsewhere (subtyping, generic modules among these). Secondly, it is a language designed to fulfill a specification, which is unique and something which gives the design direction -- making it worth studying as a whole and not just a collection of parts.
Ada is devoted to producing correct and readable code that can last for decades. Understanding Ada can help you incorporate its ideas on your projects and could give you some of its benefits even if you don't use Ada. There are a lot of nice features in Ada, but here's 3 big ones. (at least from me an Ada novice still figuring it out) Strong types. Ada forces you to use types to describe your problem. For instance, don't a float holding meters, declare a type meters that holds a float data with extra meaning. Ada makes creating types a lot easier than C++. This let's you better describe the santics of your data, put constraints on it, and makes your code more robust. Design by contract with Ada 2012 is a pretty big idea Ada incorporated. Rather than just a return type, function name, and argument list, you can specify under what constraints your function may be called and what conditions must be true upon it's end. While good types can handle a lot of this, sometimes they aren't enough. Developing good pre and post conditions improves the correctness of your code and doubles as important documentation for the future readers of your code and yourself. The spark subset, which you can use via GNAT's community edition, can help give you stronger guarantees about the correctness of your code using formal methods and specifying other aspects or information about your code. e.g. the function relies on a global variable.
Ok, I‚Äôm going to guess you come from a C or C++ background? Why should you study C, C++, Rust, Go, etc.? Try looking at some of the cool language features those languages don‚Äôt have, then write your answer here...
Because the software-engineering skills you learn along with Ada (and with few, if any, other languages) will serve you well no matter what you use in the future.
I worked on a soft real-time system that had many hundreds, if not thousands, of simultaneous tasks, running on Linux. It worked fine. Most of the tasks, of course, spent most of their time waiting for something to do, but that tends to be a feature of well designed concurrent systems.
You should study Ada if you want to get serious work done and care about your time.
I also note that AdaCore has been really good about feeding patches upstream to FSF. The FSF GNAT builds well on most systems (Linux, FreeBSD, Illumos, Windows). Also the spark2014 fsf branch builds easily with any decently recent version of ocaml. This can give you a full GPL runtime exceptioned Ada and SPARK environment.
Is gnatprove available with FSF version? I know I can use it with GNAT community edition, but I don't remember seeing the option with FSF version I installed with APT.
https://github.com/AdaCore/spark2014 They have an fsf branch (it's also mentioned in the readme). We've successfully built it on Linux and FreeBSD so far.
Great set of slides. Ada is really making some advancements. While I'm excited for the new features, I do have one concern. To this day, most of the existing Ada compiler vendors are still trying to catch up to Ada2005 and Ada2012 (some better than others). My gut feeling is that the parallel programming features in Ada2020 is going to further seal Ada's fate to a single vendor only solution (i.e. AdaCore only). Of course, there are examples where that hasn't prevented languages from being successfully adopted (e.g. Google's Go, Apples, Swift, etc).
Still no plans to add support for lambda expression and other features necessary for implementing things like Optional types? I learned Ada over a decade ago and keep checking up on it periodically to see if it has reached this point, but I'm not sure it ever will, unfortunately. I think Ada was before its time in many ways, but now it seems to be incapable of catching up.
[removed]
Randy has said it‚Äôll never be a functional language. But there is an Ada issue AI to implement pattern matching but it‚Äôs not in this version. With that option types should be possible.
Does it really matter whether the SPARK tools are GPL or not? The SPARK tools just do static analysis, so Ada programs wouldn't contain anything from the SPARK tools which would require GPL in the final executable.
"going to further seal Ada's fate to a single vendor only solution (i.e. AdaCore only)" I'm almost certain that's why they are doing it.
Right now Ada is also competing with other programming language, so Ada needs to evolve.
"they"? If you mean AdaCore, they do not dictate the direction of the language. If you mean the ARG, they follow the instructions from ISO/IEC JTC1/SC22/WG9. AdaCore is not the only vendor represented in the ARG
It's not about being a functional language. Being able to make such abstractions is simply good for safety. Could you provide a link to the AI. Unless there's more to it, I don't see how pattern matching would solve the problem, which is more about how generics are handled, iirc. Also, who is Randy?
&gt;Optional types? What's wrong with discriminated types? Type Optional( Has_Element : Boolean ) is record case Has_Element is when False =&gt; Null; when True =&gt; Element : Element_Type; end case; end record;
Well, first, it's not *just* optional types. That's more of a baseline for me every time I look into Ada to see if it's something I want to invest time in. If I can't easily get that done to my satisfaction, then there's no reason to dig deeper. Ignoring that, my Ada is rusty, but this must be done for every type I want to optionally use, which is unacceptable in my opinion. If you make it generic, you still have to instantiate an instance for every type, iirc. Neither of these should be necessary, as all types can be known at compile time. I realize that's just kind of the Ada way, but that is also why I don't come back to Ada: it just seems to refuse to do give up on any of the original designs no matter how tedious they are. Unless I am missing something important, Ada could maintain (or increase) its safety while removing a lot of these warts.
There is at least one other compiler writer in the ARG.
The big problem is ambiguity. As an example with type-inference: given a `Character` and character-type DNA (`'A', 'T', 'C', 'G'`) what would type-inference \[dropping the `: type_name`\] say `X := 'A'` is? ‚Äî The same happens with the idea of most automatic instantiation drafts, except it explodes in number AND you wouldn't have names for them. There is an AI for implicitly instantiating generic-items within the parameters of a generic.
&gt;It's not about being a functional language. Honestly there are a couple of changes that would make Ada much more amiable to FP than it is now... and they aren't all THAT big, IIRC. &gt;Being able to make such abstractions is simply good for safety. Lambda-functions are nameless functions; how, exactly, do these increase safety? ‚Äî Honestly, I think the environment-problem \[closures\] is far more important than mere nameless-functions. &gt;Could you provide a link to the AI? I'd have to look it up; but you can do it too: [http://www.ada-auth.org/ais.html](http://www.ada-auth.org/ais.html) &gt;Unless there's more to it, I don't see how pattern matching would solve the problem, which is more about how generics are handled, iirc. I don't see the link between pattern-matching and generics; care to elaborate? &gt;Also, who is Randy? Randy is the paid-editor for the Standards documents.
This is correct!
To be fair, GNAT is part of GCC, and AdaCore is one of the most active contributors to GCC, period. All of the Ada 2012 features have been up-streamed in a timely fashion to GCC, and I don't expect it to be different for Ada 2020. AdaCore has every interest for Ada to not die as a language. It's basically common knowledge now that close-sourcing languages and compilers kills the language. I really don't think this argument holds water to be fair. You don't pay AdaCore for their compiler, you pay them for their support and ability to customize the compiler. GNAT is easily obtainable with the fully run-time exception, and Ada is a first-class language of GCC.
Functional languages have their place. Procedural languages have theirs. Ada is a procedural language. The ARG did debate this issue for a long time, but at the end of the day, Ada is not a functional language and will never be one. And that is OK. I know functional languages are a bit of a fad right now, but it might be a bit presumptuous to claim that these features are the future.
&gt;EDIT: This also completely defeats the purpose of the Optional type, as you still have to manually check the discriminator at every access. You can't write generic code to handle the contents safely. That's not true. The compiler will insert a run-time check on the discriminant if you attempt to access Element on an object of the type for which the compiler cannot statically determine the discriminant.
&gt; The compiler will insert a **run-time** check So it is true?
I have said nothing about Ada being a functional language.
&gt; how, exactly, do these increase safety? They, alone, do not. The ability to build the other mentioned abstractions does, and anonymous functions facilitate easier use of said abstractions. &gt; I don't see the link between pattern-matching and generics; care to elaborate? There isn't a link. My point is that pattern matching doesn't solve the problem, because the problem is related to generics.
That's not really the use case. I have not argued I want types automatically inferred. I simply want to be able to write something similar to what you did above, but use it with different types without having to add a use statement or whatever for every different type. The type would still be provided in the signature of the method, but there is just no reason I am aware of which prevents the compiler from seeing something like Optional[Integer] and inferring that an instance of Optional specialized for Integer is needed. I actually started to work on an Ada' to Ada compiler which would recognize such uses and generate all necessary use statements so I don't have to, but decided it was silly to waste time on it when languages exist that don't require that and people from the Ada world would likely not be interested in using it.
&gt;It's basically common knowledge now that close-sourcing languages and compilers kills the language. yes. But Ada, to be modern and alive, successful language, also needs general and one packaging tool (like Python's pip or Ruby's gem) and one common place in the Web (with Web UI, search, links to the documentation) for all packages/libraries.
good example how can be implemented pattern matching in OOP language (with Object Pascal under the hood) is last C#.
Sorry, but maybe I am completely misunderstanding option types, but how would a language like, for example, Haskell, implement them without having _any_ run-time checks?
&gt; But Ada, to be modern and alive, successful language, also needs general and one packaging tool (like Python's pip or Ruby's gem) and one common place in the Web (with Web UI, a search, links to the documentation) for all packages/libraries. I was working on doing something along these lines.
&gt;how would a language like, for example, Haskell, implement them without having *any* run-time checks? Magic!!
&gt;That's not really the use case. I have not argued I want types automatically inferred. I didn't say you did; I was using type-inference to illustrate the issue of ambiguity... exactly the same problem exists in most automatic/implicit generic-instantiation/-use proposals I've seen: conceptually replace "type" with "package" and you should get the linkage/parallel. This proposal would help with the having to explicitly instantiate so many generics: [http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ai12s/ai12-0268-1.txt?rev=1.2&amp;raw=N](http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ai12s/ai12-0268-1.txt?rev=1.2&amp;raw=N) &gt;I simply want to be able to write something similar to what you did above, but use it with different types without having to add a use statement or whatever for every different type. The type would still be provided in the signature of the method, but there is just no reason I am aware of which prevents the compiler from seeing something like Optional\[Integer\] and inferring that an instance of Optional specialized for Integer is needed. I actually started to work on an Ada' to Ada compiler which would recognize such uses and generate all necessary use statements so I don't have to, but decided it was silly to waste time on it when languages exist that don't require that and people from the Ada world would likely not be interested in using it. I would like to see such a compiler, as it is an interesting way to prove (a) that it can be done, and (b) that it is useful. It's also a bit unfair to say "people from the Ada world would be uninterested in using it" ‚Äî there's a lot of people that want better tooling, and better environment/economy.
&gt; I was working on doing something along these lines. I found about 2-3 pkg managers for Ada (for example: https://github.com/alire-project/alire), but it should centralized and all libs should be there. It's my personal opinion, but I think this is one of the most important "engines" of modern languages popularity. I am not Ada programmer but Ada as language and as community looks very intelligent. Such tool will help to newbies to try/switch to Ada IMHO.
&gt; I've seen: conceptually replace "type" with "package" and you should get the linkage/parallel. You're still talking about *inference*. I am not. The packages could still be specified with just as much accuracy as they are now. That is unrelated to the requirement to manually enumerate all instantiations of the packages.
&gt;I found about 2-3 pkg managers for Ada (for example: [https://github.com/alire-project/alire](https://github.com/alire-project/alire)), but it should centralized and all libs should be there. I was involved with the discussion for Alire; I proposed we should have a database-amiable intermediate-representation for the purposes of the package-manager ‚Äî this would have allowed for the package-manager to have very advanced functionality, things like: linking project-dependencies together, automatically checking that versions were compatible, and \[possibly\] automatically checking-for/searching-on license compatibility \[i.e. "my company cannot use GPL source"\]. This was essentially ignored as a "heavy handed" solution in favor of "we can write glue code for GitHub, bitchute, sourceforge, etc!". &gt;It's my personal opinion, but I think this is one of the most important "engines" of modern languages popularity. You're probably right; but, OTOH, there are some serious issues with (e.g.) Python ‚Äî a colleague was relating a story about a whole day wasted in an astronomy training-seminar because of Python &amp; python-library version issues; essentially the guy conducting the training minimized all the issues with "*it works on my computer*" ‚Äî really quite sad to hear, especially considering I've compiled 30-year old Ada code written for a completely different compiler on a completely different architecture with MINIMAL changes (most were identifier-classes with new keywords added in subsequent language-standards; one was because of limitations in the compiler I was using WRT compilation-units). &gt;I am not Ada programmer but Ada as language and as community looks very intelligent. Such tool will help to newbies to try/switch to Ada IMHO. You are right ‚Äî unfortunately few people want to do the "boring work" of sitting down and designing the system correctly first and instead want to jump in on the "exciting" coding.
&gt; very advanced functionality, things like: linking project-dependencies together, automatically checking that versions were compatible, and [possibly] automatically checking-for/searching-on license compatibility [i.e. "my company cannot use GPL source"]. Yes... I think mostly it's impossible to be done in some automatic manner, only with manual work: be collecting the libraries, setting versions, transform them in common format (like Python's setup.py/Haskell's cabal/stack files), adding all metadata (source ref, docs ref, vendor, versions...), etc, etc. It will be very difficult. A lot of modern languages have such repo. Old-school languages - don't. C++ tries to do it (I don't know current status). &gt; in an astronomy training-seminar because of Python &amp; python-library version issues; essentially the guy conducting the training minimized all the issues with "it works on my computer" There are 2 standard solutions for it: 1) to use always virtual environment (you can freeze all installed versions and to reproduce this setup in another virtual environment) 2) or to use Docker. PS. I think the idea to have central repo is impossible without serious help from a) companies b) community
&gt;You're still talking about inference. I am not. The packages could still be specified with just as much accuracy as they are now. That is unrelated to the requirement to manually enumerate all instantiations of the packages. How?
&gt;I think mostly it's impossible to be done in some automatic manner Well, about that‚Ä¶ it is doable, just like order-of-magnitude better Continuous Integration &amp; Version Control can be had, given a higher view of the problem than just text-and-filesystem. See: [Workspaces and Experimental Databases: Automated Support for Software Maintenance and Evolution (1986)](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.26.2533&amp;rep=rep1&amp;type=pdf) and note that this is mid-eighties, presenting a method to achieve better CI than modern systems \[WRT throughput, consistency, and needed-CPU time\], with better Version Control; for example, with this system, every version of the root-node is the entire project being in a compliable (and consistency-checked) state -- no more "I broke the build with the last commit" BS.
&gt; I think the idea to have central repo is impossible without serious help from a) companies b) community You're probably right on this.
I installed it on MacOS, but got errors like these trying to compile and run the included example files and projects: &amp;#x200B; Compile \[Ada\] diners.adb gcc: error trying to exec 'gnat1': execvp: No such file or directory gprbuild: \*\*\* compilation phase failed &amp;#x200B; Any hints for how to get the dev env up and running on a fresh Mac OS system?
&gt;Would this be a possible task for somebody still actively learning? Sure, why not? You can generate Ada bindings for C/–°++ headers with [GCC](https://www.adacore.com/gems/gem-59). (Note that you'll still need to manually change generated bindings, but for the most part it works fine). There is also [Cappulada](https://github.com/Componolit/Cappulada), i've never tried it, but it's supposedly outputs better bindings for C++.
"Would this be a possible task for somebody still actively learning?" Technically, yes. It doesn't take a lot of Ada knowledge to create some subprograms and mark them as Imported from C. That doesn't mean the results will be any good or very Ada-like. In my experience, you have to know Ada and how it interfaces to C well to create a good binding. There are other parts of the language you'd be better off exploring before you turn to binding to C. (And the only effective way to bind to C++ is to write little "extern C" functions to import.) If you're interested in game development, you might be interested in the GLOBE-3D library: [https://globe3d.sourceforge.io/](https://globe3d.sourceforge.io/)
I don't think C or C++ have that.
But lambda functions are the building blocks of functional programming.
&gt;So it is true? Is what true? Your issue was that you had to "manually check". But that's not true, the compiler inserts the check automatically.
This sounds as if your search path is broken. On Linux `gnat1` is at `/&lt;gnat-community-installation&gt;/libexec/gcc/x86_64-pc-linux-gnu/8.3.1/gnat1 /usr/local/adacore/gnat-community.2019/libexec/spark/libexec/gcc/x86_64-pc-linux-gnu/8.3.1/gnat1`. You could look if the file is there and if it is executable. Aside from that I have no experience with MacOS so I can't help you there with specific things.
Thanks for the explanation. That has given me some idea of what to do more reading on. I also didn't know about the GLOBE-3D library before, so thanks for that as well.
[removed]
Lambdas have the exact same functionality as subprogram access types.
In Ada it would be: ```ada type A is optional Integer; ```
This sub-reddit is not for ADA the Americans with Disabilities Act, it's for Ada the computer programming language.
Ooooh my bad I‚Äôll remove the post.. sorry