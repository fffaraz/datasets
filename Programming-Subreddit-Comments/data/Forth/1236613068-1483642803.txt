Nice. It's a Forth computer. I want to build one.
Bizarre. find &lt;dir&gt; -name '*.ogg' -exec cp -p {} /sansa/MUSIC/. \; What am I missing?
God I wish there was more info. 
Described [here](http://www.forth.com/archive/sftalk/2008/3743.html) and [here](http://objectmix.com/forth/711020-game-graphics-library-swiftforth.html).
Part 2 is really out of date and today to be fast on many cpus you need to separate code and data (due to caching).
Could you put something on the entry page? It looks like there is no content yet now. 
You should have posted [http://jasonwoof.org/forth](http://jasonwoof.org/forth)
Forth.
FIND accepts counted string because it's how they are stored in a dictionary and how is was in forth-83. Handling counted strings has advantage that you need to hold only one value on stack for it. Disadvantage that you can't construct string for arbitrary region of memory.
I wish I had access to these when I was first playing with forth on my Apple ][+. In pre-internet days finding examples of good programming style was difficult. For example, I kept hearing about how forth programs usually used fixed point numbers for math, but none of the articles I read (mostly byte or dr dobbs) ever explained how fixed point worked.
EDIT: I deeply apologize for the lack of correct links. I thought square brackets around the URLs below would make them into links, but Reddit seems to delete them (and the parentheses) instead. Sorry! EDIT: Huh, it linkified the URLs. Nice, I guess... You're looking, I think, for http://users.beagle.com.au/peterl/furphy.html (Furphy). You're certainly not looking for http://bitbucket.org/wtanksleyjr/tworing/ (Tworing), so don't go there, even if it is a stack-based language that's simpler than Factor, Joy, or Cat. It's brain poison. No -- it's a mind flayer. Liberate tutemae! -Wm 
Thanks but it's not what i've lost :(
Huh... It's the only major one I know of, and I'm supposed to keep track of things like that ;-). I'll be watching for the answer, since it's an interesting topic to me. Another thing you might try is asking on the Concatenative Languages mailing list http://tech.groups.yahoo.com/group/concatenative/ or comp.lang.forth on Usenet.
There was a language named Raven... Does that ring a bell? Its website seems to be down, though.
Are you talking about [this](http://aerosuidae.net/raven.html)?
Onyx uses braces for blocks: http://www.canonware.com/onyx/ So does Postscript. Other possibilities: Enchilada, 5th, Kevo, Ambi, Ripple, stacktor, XY, Abundance. I'm pretty sure these are not what you are looking for: V, Cat, Raven. I'm not sure I've seen a forth with the condition after the true and false blocks before.
Thanks. But i believe that forth was not gc'ed one :)
Yes, I was -- thank you. And clearly (now that I've re-examined it) it's not what you were looking for. Well, good luck. I'll be watching, since (as I mentioned) it's of interest to me. I wonder; could you possibly describe a bit more? Furphy seems to meet the description you posted, so I don't know where to go. Was this an actual Forth program, or an independent language? (Although I have to admit that the distinction might not be important -- Furphy is both.) -Wm 
As far as i can remember it was a forth implementation like retroforth.
it hasnt crested yet. Seriously. It is a rather good book.
A quick glance at the source suggests it's using a hacked version of [eForth](http://www.baymoon.com/~bimu/forth/). Should be interesting to see how much can be done with it...
Was it Neon or MOPS? Used to run on macos.
I think you'll find [Jones Forth](http://www.annexia.org/forth) to be interesting.
I actually came across that via Google and I was hoping there was something smaller :) I remember watching [this](http://mtnwestrubyconf2008.confreaks.com/15weirich.html) some time ago and if you go to about the 34:00 mark, you'll see he talks shows some forth implementations that are 11 lines and 2 lines long..! I have no idea if that is possible on x86 but I figured that level of minimalism might have been attempted before, although I'm not sure..
See this from IOCC: http://www.ioccc.org/1992/buzzard.2.design http://weblog.raganwald.com/2007/10/until-you-understand-how-forth-is.html This is the smallest that I have found.
&gt; See this from IOCC: http://www.ioccc.org/1992/buzzard.2.design &gt; This is the smallest that I have found. The actual source is [here](http://www.ioccc.org/1992/buzzard.2.c). Pity that it's [a] in C rather than assembly as the OP requested, and [b] quite thoroughly obfuscated (which was rather the point of the contest for which this gem was produced).
Check out [A 3-instruction FORTH for Embedded Work](http://pygmy.utoh.org/3ins4th.html) by Frank Sergeant for some inspiration. Frank is also responsible for Pygmy Forth, which I still consider after 20+ years of programming to have the best bang-for-the-byte of any development environment I've encountered.
I've known about Forth for awhile and this weekend decided to try my hand at learning it; The aesthetics of such a tiny language appeal to me. I decided to write a few things just to start learning and after much cogitation managed to write a recursive exponentiation function like so: : exp ( x y -- x^y ) dup if dup 2 mod if 2 / swap tuck dup * swap recurse * else 2 / swap dup * swap recurse endif else 2drop 1 endif ; Even though I understand the algorithm, it took me a long time to figure out just which dups, swaps, and tucks to use to keep what I wanted to work on on top of the stack where I needed it while keeping track of the order of everything else. The two lines that do the most work are almost the same, except obviously when y is odd I tuck away the extra x to multiply with at the end. Since that's stuck in the middle though, I couldn't think of a way to remove the duplication. Worst of all, I wouldn't expect anyone to read it and figure out how it does what it does without a lot of work. Then I learned about parameters and rewrote it thusly: : exp { x y -- x^y } y if x dup * y 2 / recurse y 2 mod if x * endif else 1 endif ; This only took a few seconds, worked the first time - unlike my first parameter-less attempt - and is quite readable. In comparison to my first attempt it almost felt like cheating (even though I know it's legal Forth). I thought the whole point of Forth was all about the stack, and every tutorial I've seen starts with all the dup, nip, tuck, over, swap, stack manipulation, so I had assumed that was what everybody used all the time. How often do you use these stack manipulation words compared to parameters, and how much does this kind of parameterized word cost in speed and interpreter/compiler complexity?
I think, although I am not any kind of expert, that most Forthers seem to not use parameters much, and let the stack and program flow influence the way functions are written so that stack shuffling is minimal and hidden. In factor, I think the use of combinators minimizes stack shuffling.
Parameters are an evil perpetuated by gforth. The benefit of forth is that your stack is in a known location. By adding parameters (locals) you allocate more space, and take hits to memory every single time you reference one. On modern architectures and implementations, stack words generally act on registers unless you're using something like roll or a forth with an addressable stack. The cache will hold the locals so your hit won't be huge, but it will be there. For a simple integer exponentiation function the clearest and easiest way to implement is imperative like this: : ^ 1 swap for over * next swap drop ; This is significantly shorter, faster, and contains only a single conditional (which can be pulled from the zero flag of the ALU). If you really really want to create a recursive function for this, you can unroll the for into a tail-recursive word. : ^core 1- dup 0; &gt;r over * r&gt; ^core ; : ^ 1 swap ^core drop swap drop ; ^core decrements b, then dups it and returns immediately if it is 0, otherwise it stores b in the return stack, does the same math, returns b to the data stack and calls itself again. This is still recursive, but it's tail recursive so the final call can just be compiled as a jump to the beginning of the word. Your non-tail-recursive code will compile a call instead and fill the return stack. Tail recursion allows constant return stack space to be used instead. There are lots of opinions on what forth is and how it should be written, but I'm a traditionalist and believe that forth code should basically always be as short as possible. The benefit of coding this way is that your code's speed has a general positive correlation with your code's size. Creating excessive numbers of comparisons, branches, and stack moves in your code makes it very hard to trace and understand. Generally forth words should be short and only do one thing. The rule of thumb seems to be a word should be composed of around 7 words, maybe up to 12 except in extreme cases. Forcing inline optimization for speed gains by reducing the number of calls can be implemented in the compiler itself without a huge amount of trouble. It seems to me like you're trying to write C code in forth, and not forth code. You can think of your stack words as being auxiliary to program content. The point of them is to adjust data to where you want it and the overall goal is to minimize the use of your stack across words. Sometimes this isn't possible and some stack hackery must take place, but in many cases, changing how you represent your inputs on the stack can dramatically simplify the code you write. As an addendum, it seems you're thinking in terms of "how can i implement algorithm x in forth?" which is the wrong question to be asking. The question to ask is "how can i do x in forth?" and then figure that out. I'm not an expert, but I do like forth and am working on designing a stack processor around an instruction set that somewhat resembles a combination of machineforth and the c18 instruction set. [Shameless Plug (PDF)](http://pairofducksparadox.info/proj/mlc.pdf)
&gt; Parameters are an evil perpetuated by gforth. The [GForth manual](http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/ANS-Forth-locals.html) indicates that its parameter syntax is provided as an alternative to the one ANS Forth provides with the (local) word, which is supposedly needlessly confusing. It seems clear enough though that supporting parameters at all must add a lot of complexity to an implementation, though I'm not in deep enough yet to judge just how much. I certainly see how they're useful for the programmer to organize things, but it seems like part of the point of Forth is to make an interpreter/compiler dead easy to write and their existence seems to conflict with that. Are there any common Forths that don't bother implementing any flavor (ANS, gforth) of parameters? &gt; It seems to me like you're trying to write C code in forth, and not forth code. My second implementation using parameters almost looks like RPN C precisely because being able to grab the parameters out of thin air and throw them on the stack as necessary made it obvious to write that way. I'm not familiar with the idioms of Forth yet, but after all that stack manipulation needed in my first try, the parameterized solution just didn't strike me as very *Forthy*, thus the request for feedback as to the preferred methods. &gt; ... [I] believe that forth code should basically always be as short as possible. The benefit of coding this way is that your code's speed has a general positive correlation with your code's size. &gt; ...As an addendum, it seems you're thinking in terms of "how can i implement algorithm x in forth?" which is the wrong question to be asking. The question to ask is "how can i do x in forth?" and then figure that out. I was with you until I read this nonsense along with your solution that requires O(n) multiplications. Anyone can write a loop that multiplies x by itself y times... How would that be an interesting exercise? I implemented [exponentiation by squaring](http://en.wikipedia.org/wiki/Exponentiation_by_squaring) because it's non-trivial, recursive, and I wanted to see how concisely I could express it in Forth. As you noted, it's not tail-recursive because it sacrifices memory to only do O(log(n)) multiplications.
I'll try implementing your algorithm later today and see what comes out. I think that isforth and retroforth (my old preferred forth) ignore ANS and so does colorforth (and i'm sure others small ones like pygmy). ANS isn't really inherently bad, but it locks you in to specific details of parts of the language (for example, the for loop in ANS standard runs for n+1 cycles which is silly, and almost never beneficial because you're not going to be pulling offsets from the return stack and adding to a base address you dup'd, you'll probably write the word as consuming the address and just increment it in the loop). A lot of people feel that locking standards into the language defeats the entire point of having a programming system in which you can add constructs that make sense for your problem. It also makes the compiler unnecessarily large/complex. It all depends on taste, platform, and desire to write your own bottom level.
I wrote a quick solution based on the wikipedia recursive method definition with some stack comments to show that the code should work. I'm using retroforth notation which includes the ;; operator not standard to most forths (it returns immediately from inside the word). Sometimes it is also seen as the ;then word. I haven't tested this code. : power ( x n -- x^n ) dup !if 2drop 1 ( 1 ) case 0 output ;; then dup 2 % (x n n%2) if ( x n ) 2/ ( x n/2 ) recurse dup * ( p(x,n/2)^2) even case output ;; then ( x n ) 2dup 1- 2/ ( x n x (n-1)/2) recurse dup * (x n p(x,(n-1)/2) nip * ( x*p(x,(n-1)/2) ) odd case output ; Or without stack comments: : power dup !if 2drop 1 ;; then dup 2 % if 2/ recurse dup * ;; then 2dup 1- 2/ recurse dup * nip * ; Granted I have not tested this code, but i think it should work, or at least the stack trace leads me to believe it will. Not much shuffling is really required overall it seems.
I see right away an issue with my implementation which you did right in yours was that I was squaring X before the recursive call instead of just squaring the result of the recursion. That's how I had originally learned the algorithm, but it's mathematically identical to square afterwards and skips two of my swaps. I'm stuck with gforth for now, so I don't have some of the words in your implementation, but I think you have the even and odd cases reversed. I was able to look at yours though and get this gforth that works: : exp ( x y -- x^y ) dup if dup 2 mod if over -rot 2 / recurse dup * * else 2 / recurse dup * endif else 2drop 1 endif ; You're right, much of the shuffling I was doing was unnecessary. I skipped the 1- word you used because with integer division it drops out on its own. I also preferred "over -rot" as a way to copy the second element into the 3rd stack slot vs. the "2dup ... nip" from yours. Thanks a lot for the input, this has really gotten me thinking.
You're right about my cases being flipped but that's not too much trouble to fix. and you're right about dropping the 1- because it's unnecessary. I haven't written much actual forth in a long time. I really liked retroforth, but over time the codebase has gotten more 'weird' i guess. The compiler became simpler but more introspective and they added some sdl layer that i never really got my head around and couldn't really get it started. If you're on linux, isforth was pretty good and i used it for a little bit and you could probably implement your own ;; or ;then and 0; which in my mind is one of the most useful words you can have. Retroforth had some other cool features like the :: word which basically created a new definition inside a word to create another entry point which let you do cool stuff like inlining the two words i had for the unrolled for loop from before. I really dislike gforth mostly because there's a certain limit you can go to before the fact that gforth produces gcc backend code slows you down. It makes your code hard to profile visually. As for the rot/-rot instructions, i tend to avoid them because on compile they usually involve regular stack shuffling with the addition of some return stack shuffling. Moore's newer architectures seem to be oriented around rings instead of stacks, so rot is just a question of spinning the ring data or pointer to TOS in the ring so it's just as fast, but comes at the cost of really needing to know how much stack space your code uses exactly. nip is generally as fast as drop on hardware and swap drop in software, and 2dup is just over over, so it tends to be faster than rots. In gforth, it's very likely that your solution is faster because it may just use stack addressing to perform the operation. Keep it up! Forth is a lot of fun. Seriously check into leo brodie's [Thinking Forth](http://thinking-forth.sourceforge.net/) if you haven't already read it. IMO it's a missing tome in CS literature.
Thanks for the tips. I'm sort of working in parallel through Brodie's Starting Forth &amp; Thinking Forth. I've heard Thinking Forth belongs up there with Knuth's TAoCP, which is awfully high praise.
Honestly starting forth isn't terribly great and quite outdated. Thinking Forth on the other hand is a book that teaches you about how to program from problem to solution. I guess I'd think of taocp as being the toolbox, and thinking forth being the apprenticeship.
That is impressive... very cool
"100 billion operations per second" is 10¹¹, not 10¹⁴. I look forward to seeing what people do with this. I think it's probably better to think of it as a more versatile FPGA than as a large number of crippled microcontrollers.
I think the title is misleading. It's really more like a 3-instruction target stub that you can use to download a FORTH into the target, and those "instructions" are subroutines, not machine instructions.
The machine-code kernel of the eForth Model is 171 x86 instructions in 399 bytes. I've [been trying](http://github.com/kragen/tokthr) to write an interactive x86 Forth that can run in 2kiB of memory for program and data. Its machine-code kernel is 239 bytes in 129 machine-code instructions, and it needs more than 1.2k to load. However, it's comparable in source-code size to Jonesforth, which inspired it: it's already over 1000 lines, and it's not even done yet. For small source-code size, I wrote [StoneKnifeForth](http://github.com/kragen/stoneknifeforth), which is 120 lines, and isn't really a Forth, since it doesn't have IMMEDIATE words. It's a compiler written in itself, generating an ELF binary. There's some incompatibility in the ELF headers I'm generating and the 2.6.28 Ubuntu kernel on my netbook, although it runs fine on the 2.6.27 Ubuntu kernel on my main workstation. However, aside from that maintenance, it's a usable bootstrap: it can compile itself correctly. 
&gt; For a simple integer exponentiation function the clearest and easiest way to implement is imperative like this: ... The benefit of coding this way is that your code's speed has a general positive correlation with your code's size. I think the primary benefit of writing less code is that you have less bugs, and that your code is easier to understand. In this particular case, I think you'll find that your iterative exponentiation algorithm, although a lot easier to get right, is substantially slower for large exponents. (Maybe that really only makes a difference when you're implementing modular exponentiation.) It very often turns out to be the case that much of the volume of a piece of code is there specifically to speed it up, and in those cases your correlation is inverted.
&gt; it's non-trivial, recursive As you may have noticed, Forth is not really optimized for recursion. You can make it work (it's not FORTRAN or BASIC, after all, and it's easier with locals) but it's not what it's designed for.
Suppose we use the top of the return stack for one of our variables? This worked the first time I tried it: : rexp ( y x -- x^y ) &gt;r dup if 2 /mod swap \ y != 0; split y into y/2 and y%2 if r@ else 1 then \ factor of the base or 1, depending on y%2 swap r&gt; recurse dup * * \ (x^(y/2))^2 multiplied by that factor else rdrop drop 1 \ alternatively, exponent was 0, return 1 then ; : exp ( x y -- x^y ) swap rexp ; Writing it as if I were writing C, with explicit variables; this is a bit simpler. Note that I don’t have to save x and y on the stack because I don't refer to them after I recurse. variable x variable y : cexp ( x y -- x^y ) y ! x ! y @ if y @ 2 mod if x @ else 1 then x @ y @ 2/ recurse dup * * else 1 then ; That’s an improvement, and it also worked the first time. What if I keep just one of the variables on the stack? variable y : cexp2 ( x y -- x^y ) y ! y @ if y @ 2 mod if dup else 1 then swap y @ 2/ recurse dup * * else drop 1 then ; That’s not any better, and it was buggy the first time I ran it, too, because I forgot a drop. What if I keep just the other variable on the stack? variable x : cexp3 ( x y -- x^y ) swap x ! dup if dup 2 mod if x @ else 1 then swap x @ swap 2/ recurse dup * * else drop 1 then ; That one was also buggy at first, and it's not really better. But, you know, we use y at the beginning and end, and x in the middle. What if we arrange the stack that way? : exp2 ( x y -- x^y ) tuck dup if 2 mod if dup else 1 then -rot swap 2/ recurse dup * * else 2drop drop 1 then ; That one also took quite a bit of debugging. What if we use the return stack instead, with the same pattern? : exp3 ( x y -- x^y ) dup &gt;r swap &gt;r &gt;r r@ if r&gt; 2 mod if r@ else 1 then r&gt; r&gt; 2/ recurse dup * * else rdrop rdrop rdrop 1 then ; That worked the first time. None of these have the kind of simplicity I'd like to see in a good Forth definition, although frankly I think `cexp` comes closest (and it's about the same as your parameter version). But I don't see how to simplify them by factoring them into separate definitions. I think the moral is that the parameter stack is basically good because it's the simplest possible way to let you write nested expressions, not because you can use it instead of local variables. If you have to keep track of two or three things on the stack beyond the expression you're currently writing, you're wasting your mental effort. Storing temporary variables on the return stack is often a little bit better, because its depth changes less often. Both of the versions I wrote here with the return stack worked correctly from the first time I tested them. In general, if I find myself having trouble keeping the stack clear in my head, I put things in variables. I just about *never* use `nip`, `tuck`, or `rot`, and I'm suspicious of `over`, `swap`, and return stack manipulation. There are several reasons not to use global variables in, say, C++: 1. Code using them is non-reentrant and not thread-safe. 2. They are accessible to your whole program, which makes for tight implicit coupling between big chunks of your code base. 3. Namespace pollution: if you forget to declare a local variable, you may end up using a global variable instead by accident, causing subtle bugs, and in some programming environments, if you have multiple global variables with the same name, they will alias. 4. The static initialization order fiasco. 5. They're often used to store state between calls, which makes your functions harder to test, and sometimes results in bugs when two different parts of your program call the same functions. In Forth these problems are smaller: 1. Recursion is less common in Forth (you have to make special arrangements for it, with a `defer`red word or by calling `recurse` or something), and in a multithreaded Forth, `variable`s are typically thread-local. So you can usually see if you might need to save off variable values on the stack, and do so explicitly. 2. Vocabularies (or wordsets, in ANS Forth) allow you to limit the scope of any kind of name. Also, a word is only visible after it's been defined. Finally, your whole Forth program is probably a lot smaller than your whole C++ program: both because Forth is more concise, and because Forth is more suitable for small programs. 3. You don't have the same namespace pollution problems; you can define multiple `variable`s with the same name, and they each exist in a certain scope in the file. They never alias. And you have many fewer local variables. 4. Forth, like C++, allows you to initialize your data, but it does it in a well-defined order. 5. This problem still exists in exactly the same way, but doesn't apply where you're using a global `variable` as if it were a local variable. Unless you make a mistake. Forth (the language, not the environment) is not designed to help you find and fix your mistakes. I should point out that I'm really far from being an expert at Forth myself.
Forth is exciting. I'm learning it too. Thanks for posting this, crunchymunchy - I was wondering about the same!
I would love to elaborate on what exactly happens. My observations are simply: 1) User seems to disappear, `id` command in your shell returns UID but no username. Sudo is therefore unusable since it does not recognize your user 2) No programs can be started 3) All desktop icons just disappear Interesting huh. :)
Why the downvote? Try it before you disregard it.
&gt; I'm using retroforth notation which includes the ;; operator not standard to most forths (it returns immediately from inside the word). I don't know retroforth. How is `;;` different than [exit](http://www.public.iastate.edu/~forth/gforth_28.html)?
They are the same from what that document says.
It says something sad about the nature of our society that this guy has to constantly fight for his financial survival, instead of devoting his full attention to making cool stuff to share with the rest of us. It's not like he's going to live forever. I hope whatever it is turns out okay.
"Fighting for financial survival" might be a [stretch](http://www.colorforth.com/poor.htm)[.](http://spectrum.ieee.org/at-work/innovation/what-is-patriots-game)
Shame on you. This man is starving! Anyone got his paypal addy?
Tic-tac-toe or Tetris.
I recommend implementing Forth, perhaps in Forth. I am not an expert Forther by any stretch of the imagination, but implementing a language (especially in itself) is an excellent way to learn it inside and out. 
I have considered it, but it is too much work, and some abstractions have no use while implementing (you don't use macros to implement macros in lisp...). But I'll keep considering it.
T-T-T is an option... but how would you do a Tetris? 
I think a Forth interpreter is pretty simple to implement in a high level language (or in Forth). You may not use all the abstractions available in Forth to write Forth, but you will have to understand all the available abstractions to implement them. You might also just learn factor.
It is also on my "maybe" list. But I prefer to go back to the basics... I learnt lisp before attempting to learn clojure :)
I like minesweeper; it's more complicated than tic-tac-toe, but doesn't need a GUI like tetris (just print out *-* or a number).
`at-xy` is really about all you need for Tetris's GUI.
In principle, you can do anything in Forth. But I think it only really shines in resource-constrained environments. Unfortunately, I don't have any experience of Forth on microcontrollers... but I'm sure you can find something.
Sokoban is a classic. See this [comp.lang.forth](http://groups.google.com/group/comp.lang.forth/browse_thread/thread/e0e703b307ac2917/284e9206ee3932ff?lnk=gst&amp;q=sokoban+contest#284e9206ee3932ff) post for information.
That points my ignorance in some forth commands: didn't know about at-xy. This sure means a lot more. I guess I'll change my current project (a C generator and solver of a logic maze I'm trying to set up, you can read where I stopped in my blog if you feel like it: [My take on logical mazes @ my blog](http://www.mostlymaths.net/2010/05/my-take-on-logical-mazes-part-1.html) , and for what are logical mazes in general, check Robert Abbot's page [here](http://www.logicmazes.com/theseus.html)) to be in Forth. This means it can be directly forth-played, no need to write a separate play package in something nicer than C.
[tt.fs](http://www.complang.tuwien.ac.at/viewcvs/cgi-bin/viewcvs.cgi/gforth/tt.fs?view=markup) I don't much like the code, but the design is straightforward.
Thank you a lot. I just played for a while... Didn't know I could get such an easy terminal game running so quick.
oh, I missed this response. Forth's KEY KEY? PAGE AT-XY and some knowledge of [terminal control codes](http://vt100.net/) make for easy terminal games. (They also make for easy Chinese input methods.) You can do the same thing [with other languages](http://github.com/ayrnieu/cl-sokoban/blob/master/raw-ui.lisp) -- but without thinking of these Forth words, you'll probably do something with curses instead. gforth comes with a nice game of sokoban, too; look at it use of text-transformation rules.
Thanks, I'll take a look at it. Gforth is the forth I have installed.
&gt;But I think it only really shines in resource-constrained environments. Why?
Are you asking me to speculate on why that is, or are you asking why I think that?
Either/or
observation/experience
link?
o_O. i don't know what i did wrong, i put in the URL ... is there a way to edit the link, or do i have to delete it and make a new one? edit: there we go. figured it out. sorry, this was the first time I submitted a link on Reddit.
1994 called and wants its webring back.
Is this going to be practical? I remember suggesting Forth as an embedded scripting language to a coworker in 1996, for a telecom application in C++, but now I think it was a bad idea. You don't get (what I see as) the unique advantages of Forth that way --- a small memory footprint, easy understanding of the whole system --- but you do get its disadvantages --- easy to crash the app in a way that's hard to debug, type errors give you crashes instead of tracebacks, and unfriendly syntax.
Oh! Good point!
Did anybody else read this as [FLCL](http://en.wikipedia.org/wiki/FLCL)?
There are some really odd posts in that thread: Hugh Aguilar: &gt; I'm going to dedicate my language standard to Jeff. He won't live to see it, but Elizabeth Rather and the rest of the Forth-200x committee will be defeated. They screwed up Forth-79, Forth-83 and ANS-Forth, and now they are screwing up Forth-200x --- but they will be defeated. Forth will no longer be considered to be a toy interpreter written in C (Gforth) or a non-optimizing bloated monstrosity (SwiftForth), but will be considered to be a viable alternative to C. I will call my language Straight (as in, not gay) --- Elizabeth Rather can continue to champion public homosexual behavior on comp.lang.forth, but I won't tolerate it. Jeff Fox was the exact opposite of a faggot in every way --- he was a decent honest person. Colin MacIntyre: &gt;there is so much more to this life than dedicating it to advocating a technology, no matter how compelling... &gt;"If you want to follow Me, you must deny yourself. You must pick up your cross and follow me. The person who wants to save his life must lose it, and she who loses her life for Me will find it. Look, does it make sense to truly become successful, but then to hand over your very soul? What could you trade that is even close to being worth it? &gt;The Son of Man will come in His Father's glory, with His heavenly messengers, and then He will reward each person for what has been done." At least it gets better beyond those messages.
I am really sad to hear this. I never met Jeff in person, but corresponded with him from time to time. He really got me thinking about what I should expect from my programming environment as well as the projects I worked on. He opened my eyes again to the possibilities and potential that we and our creations can have. Wherever you are now Jeff, I hope it's a place without fab delays and the chips work exactly like the simulation, right off the line...
Probably your android device run arm based linux. So you can compile tons of portable C forths that can run on arm cpus.
I was hoping that somebody already gone thought the pain, and maybe picked something which would come with an ARM assembly, and screen editor, or somesuch malarkey.
The homophobic one is wtf but the one condemning his life's work is ... Damn pointless
Best I've found are JavaScript-based. 1. [Retro](http://retroforth.org/android/) is an actual Android app. (Warning: it's just as deeply unpleasant as other versions of Retro.) 2. [jsForth](http://wiki.forthfreak.net/index.cgi?jsforth) is pretty awesome.
 : length ( list -- n ) || nil ( -- 0 ) 0 ;; || cons ( list x -- n ) drop recurse 1+ ;; ; An implicit ;; in ; , when necessary, would clean that up. : (length) ( u list -- u' ) || nil ;; || cons drop 1 under+ recurse ;; ; : length ( list -- u ) 0 swap (length) ; With tail call optimization. It's quite easy to create an alternate RECURSE that guarantees this. It's so easy to do so many awful things in both ANS Forth and in ANS Forth with some very broadly honored environmental dependencies (e.g., that : call &gt;r ; works). I wish people would say "here is my giant library with tricks [like the above] that will make your eyes pop out :-)" rather than "here is my *new, Forth-inspired programming language*."
Elementary use case.
Success: kragen@inexorable:~/media$ mplayer -dumpstream mms://205.178.152.129/1907796/WelcomeByChuck.wmv MPlayer 1.0rc4-4.4.5 (C) 2000-2010 MPlayer Team mplayer: could not connect to socket mplayer: No such file or directory Failed to open LIRC support. You will not be able to use your remote control. Playing mms://205.178.152.129/1907796/WelcomeByChuck.wmv. STREAM_ASF, URL: mms://205.178.152.129/1907796/WelcomeByChuck.wmv Resolving 205.178.152.129 for AF_INET6... Couldn't resolve name for AF_INET6: 205.178.152.129 Connecting to server 205.178.152.129[205.178.152.129]: 1755... Connected unknown object unknown object file object, packet length = 8000 (8000) unknown object unknown object stream object, stream ID: 1 stream object, stream ID: 2 unknown object data object mmst packet_length = 8000 Cache size set to 64 KBytes Stream not seekable! Everything done. Thank you for downloading a media file containing proprietary and patented technology. Core dumped ;) Exiting... (End of file) kragen@inexorable:~/media$ mv stream.dump WelcomeByChuck.wmv kragen@inexorable:~/media$ mplayer -dumpstream mms://205.178.152.129/1907796/DownloadedWhatNext.wmv &amp;&amp; mv stream.dump DownloadedWhatNext.wmv &amp;&amp; mplayer -dumpstream mms://205.178.152.129/1907796/IntroInterpKbd.wmv &amp;&amp; mv stream.dump IntroInterpKbd.wmv &amp;&amp; mplayer -dumpstream mms://205.178.152.129/1907796/IntroSoftsim144a.wmv &amp;&amp; mv stream.dump IntroSoftsim144a.wmv Okay, now I've finished watching those four videos. I'm still kind of underwhelmed. It would be great to have a chance to watch a screencast of someone using ArrayForth to do something useful with the chip. The key statement seems to be "Evaluation chips are available for shipment from stock", on http://www.greenarraychips.com/home/products/index.html, which is long-awaited and welcome news. Unfortunately I think it's not available *to me*, since I'm in Argentina, it claims the product is export-controlled, and I doubt they'll want to apply for an export license for a measly US$200.
well done, have a biscuit
Great.. going to watch now
Enjoying the book. Thanks for the link!
There's no sense buying hardware just to run Forth. I haven't done anything with forth in years, but you should start with [gforth](http://www.gnu.org/software/gforth/) or something similar.
Sorry, I should clarify, I'm not looking to learn forth with this, I'm looking to use forth for an embedded project. I already went through the gforth tutorial, but I'm starting on a couple of hobby projects that involve low-level programming, and I was wondering how I'd go about using forth for that.
You can still implement minimal forths on lots of existing microcontrollers. I'm not sure what kind of embedded project you are working on, but perhaps a ga-144 is overkill and significantly harder to design programs for. There are many flavors of forth for PIC and AVR micros which are useful for single-threaded applications using a decent chunk of RAM. There's also the option of getting an fpga and running something like j1 Forth on it (used in the gameduino system) which is a pretty straightforward forth. The ga-144 is massively-parallel architecture of small clockless c18 style chips. The ram is pretty limited on each individual core. Don't get me wrong, the ga-144 is sweet, and I would definitely consider getting one once I could set aside enough cash, but as an introductory platform to embedded forth programming, I think it would kinda suck. It introduces a lot of complexities that you shouldn't be dealing with just starting out most likely. I don't know what your technical background is, but it would seem like getting any regular micro and loading a forth OS on it would be better.
While this wouldn't be the cheapest way to go (you could grab a couple of tinyAVRs and a programmer for about $25), programming the ga144 would probably be the rather fun. I had no idea that they were offering the budget breadboard, and knowing that it exists has made me very tempted to try it out. However, if your goal is simply to do some embedding programming with forth, I would say that the path of least resistance would be to go with an AVR. If you're looking to try programming on some rather unique hardware, then the ga144 should be sweet.
There's also [propforth](http://code.google.com/p/propforth/wiki/PropForth), which runs on the (~$40) [Parallax Propeller](http://www.parallax.com/propeller/)
&gt; There are many flavors of forth for PIC and AVR micros which are useful for single-threaded applications using a decent chunk of RAM. Interesting. [amforth](http://amforth.sourceforge.net/) and [picforth](http://www.rfc1149.net/devel/picforth.html) both look like they're worth a look before I order new hardware (I already have a handful of AVRs kicking around). Thank you!
I wish he'd write a book on ColorForth.
Linked from [this ExtremeTech article](http://www.extremetech.com/computing/110061-eff-reverse-engineers-carrier-iq).
Thanks for it.
VFX Forth from MPE has bindings to Glade/GTK. I developed the graphics portion.
Very cool. Coming from IDL, I like to vectorize everything I see and I've always been interested in learning about stack languages, so this is a lot of fun.
I agree, this seems like the perfect combination of minimal syntax and vectorized efficiency. Very cool idea.
I'm anxious that his unique cowboy approach will be lost when he retires (dies with his boots on, most likely). I hope somebody is taking notes, or trying to recreate his style.
Intresting. I have seen similiar techinque in Atari 2600 and a PIC based telly test signal generator. Neather have enough ram to back a conventional frame buffer though such a device makes it much easier to composite various images together.
I'm sorry but that UI is a disaster. You should get a designer on the team.
yes, I'm not a designer!! if you like be more specific perhaps helpme.
it was a job of Jeff Fox of http://www.ultratechnology.com/ but he passed away year ago :(
Jeff Fox has died a year ago?
I always wonder if Moore isn't too far ahead of the world with [GreenArrays](http://www.greenarraychips.com/) and arrayForth. Is it relevant to the general concurrent | parallel | distributed conundrum? Could it make the video card an overpriced, overheated relic? Will it ever get traction without a C-lang? Will Forth Inc. try to use it? E. Rather, do you read this subreddit? Could a Forth be an acceptable Erlang?
what's wrong with \begin{verbatim} : WASHER WASH SPIN RINSE SPIN ; \end{verbatim}
lack of doc
[PDF]
Awesome! This is awesome! You are awesome! 
Too bad Jeff is no longer with us.
Is this combinators as in Factor/Joy combinators? As in higher order functions? Or is it something else?
Maybe some links to whatever's left of FIG and Forth Dimensions? Perhaps a link to a download of Gforth or the Starting Forth and Thinking Forth books online, to get people started? Call it "the Forth Starter Kit", maybe... Thanks for moderating!
I think it might be nice if there were a few links to big software projects still using forth and maybe some suggestions about what one might actually do with forth. I think Forth is a great thing for people to study and write code in, but it has become even harder to motivate that given the rise of higher level concatenative programming languages like Factor. Unfortunately, I think Forth really needs to motivate people actively to think about it. Anyone have any ideas?
Hard to tell. Selling Forth is hard, even to myself whenI'm coding "something new/for fun"
Beside the game examples, there are som interesting things in lib/Algorithms. A garbage collector, function currying, lazy generators and more.
help me on lean
Here's how I ran it in qemu: qemu-img create -f raw forthos.raw 2G sudo mount forthos.iso /media/iso dd bs=4k skip=1 seek=1 if=/media/iso/ForthOS1 of=forthos.raw dd bs=4k seek=100 if=/media/iso/ForthOS2 of=forthos.raw dd bs=4k seek=10000 if=/media/iso/SrcFS10000 of=forthos.raw qemu-img convert forthos.raw -O qcow forthos.qcow qemu -hda forthos.qcow -cdrom forthos.iso -boot d
Wow I like the way this guy thinks (although he seems kind of bitter). He worked at Bell Labs at one point, and has some cool products like a card you could put in a handspring visor to turn it into an oscilloscope, spectrum analyzer, and some other things that I don't understand. I looked at some other versions of his webpage and he had a similar product that you could hook up to a Gameboy Advance SP! I wonder who wrote it (seems to be an H. Winter ?) and what happened to the site.
What it's used for: Forth is typically used as a means to interface a computer with little or no true operating system (by modern standards). You said that you have a fetish for assembly, so you will see pretty quickly why it's used this way. On top of all of that, it's syntax is easy to lex, parse, and expand. The code starts very hard to read, but eventually abstracts itself into something human readable. Uses today: There is very little forth left. There are modern dialects used for scripting and other things (look up colorforth), but there is very little real world usage. Quite frankly, it doesn't have typical ALGOL syntax, and it relies heavily on assembly, so it is not viable in this day and age. Personally, forth is my favorite language. I too love assembly, and this language is very interesting. Be sure to read that book your teacher gave you, and it should at least give a little bit of insight as to why/how it was used in the past. If you have an android phone, there is a great forth interpreter (named forth). Also, if you are interested in learning to develop compilers/interpreters, writing a stripped down version of forth is not a bad idea. I have an x86 compiler that uses a stripped down version of forth, if you are interested. If anything, just peep that book, and see if you're interested.
&gt; Uses today: There is very little forth left. Weeeellll, maybe not quite. I wrote a tiny Forth interpreter just the other day to do powerful database lookups with a "safe" restricted vocabulary. Before that, I wrote a render farm manager that was basically a distributed Forth system -- very sweet, never had to reboot the servers to update the code! And before *that*, I wrote a Forth interpreter that would compile PDF files. And I could, perhaps go on... But here's the thing. The database query language interpreter was written in Python. The PDF compiler interpreter was written in Perl. Writing the interpreters this way gave me interoperation with all the datatypes and libraries of the host language, but joined with the protean flexibility of Forth. This isn't new... Chuck Moore's* first Forth was written in COBOL. The thing is, Forth is just about the simplest possible complete environment that a single person can get running in the smallest amount of time. That means *you* can get it running when you need it to transcend the limitations of whatever language you are nominally using. Forth is an *idea* and ideas are platform-agnostic. So spend some time with Forth. It gives you a whole new box of tools that you can use almost anywhere, almost immediately. \* Inventor of Forth.
If you like assembly you should check out jones forth. It's an assembly language program that implements forth, and then the rest of it is written in forth itself. So there's an assembly source file and a forth source file. It is a "literate program" in which the comments explain the program completely. It was my first and only exposure to forth and it was fascinating to me. I really want to implement forth on something now. I just got a hold of an Apple IIgs and already I'm thinking about putting forth on it somehow. 
On of the fascinating things about Forth is that it can be everything from the ground up - it is the OS, the application, the compiler, and your IDE, yet is surprisingly tiny. It's a powerful minimalist kernel of an idea. On PCs, though, people usually don't want to give up their OS and specialize their machine just for one application, so Forth is rarely used this way. There are, of course, Forth compilers and interpreters for writing general programs. Probably the most common use of Forth on the PC would be building a little domain specific language (DSL) on some higher language. oofoe has some good examples below. [Cacti](http://www.cacti.net/) uses it for defining custom functions to graph, for example. On embedded environments, you can find more examples of Forth running natively (although often built will a cross compiler since the devices themselves have no good screen). See http://www.mpeforth.com/ngr.htm#forthapps for some examples. Also [handheld FedEx scanners](http://www.computer-solutions.co.uk/chipdev/cf-fedex.htm), and [Wikireader](http://en.wikipedia.org/wiki/WikiReader).
Forth is used in dirt cheap situations when you need to be just above assembly language. The controller board inside your $60 printer is an example of something (probably) running forth on a $1 cpu. I've used Forth professionally writing the firmware for laser engraving machines, which is basically a big laser printer but with a CO2 laser. Something common in assembly language is creating lots of macros and meta programming tricks to make the job easier. You are dealing with the chip, and you don't get a lot of options. You need to build up libraries to do anything useful. Forth is similar in that regard. Everything is built up from primitive constructs. Each program has/is it's own domain specific language.
Forth is actually making a little bit of a comeback (not that it's going to get very far in it, but it's something). Hell, you want to have fun learning Forth, pick up Minecraft. One of the mods for it, called Redpower, uses a virtual OS with a Forth interpreter. Either way, it can be used for a lot. It carries some pretty compelling advantages: 1. One of the easiest languages to write a relatively efficient interpreter for. 2. One of the least complicated languages that you can dynamically add syntax to. 3. As an extension to 2, it's one of few languages that can handle high-level content cleanly with low-level content by defining bigger and more complicated building blocks in the lower ones. The biggest con, of course, is it's not really used for MUCH. It'll never be top-10 on the Tiobe index... But like others have said, it's one of few languages small enough to be used in low-end embedded systems, and lightweight enough to do much in those same systems.
Oh god... Minecraft is so terrible for me... Had it installed for 72 hours, and lost about 60 hours of my life during those three days... On the point of 2, I have to say I found that pretty amazing while I was reading my book. Definitely seems pretty great.
Retroforth is also available for Chrome. I cannot find much documentation - can you script Chrome with Gforth?
When you write Forth code, you are essentially building a DSL for your problem domain. Forth spans from the lowest level to the highest level. Few, if any, other languages are capable of this. Forth is like Lisp with fixed arity and postfix notation. Fixed arity removes the need for parentheses. Processors are essentially postfix. You put numbers in registers and then you perform an action on them. Forth, Logo and Smalltalk are like Lisp because you can expand these languages by creating functions/words that look, act and have the power of the built in functions/words. This includes conditional and looping structures. Try creating a new type of loop in C, C++, or Java. Try creating higher level functions such as map, reduce, filter, etc. If it is even possible, it will be ugly.
The 1990s called. They want their article back. Joking. I like Forth. I read everything I can on it. But that article **is** from 1999, so the use of the word "still" in the title is... weak.
Interesting to say the least.
With the revised control structures you had my curiosity, but with sub-words you have my *attention*. Proper string literals are very convenient as well. This looks really neat!
Is bounds checking done on the strings?
&gt; This isn't new... Chuck Moore's* first Forth was written in COBOL. That made me smile. I'm reminded of when I read that Dan Ingalls wrote the first few versions of Smalltalk in BASIC. Only Lisp was actually born out of its own asshole.
That's extremely cool, I'm toying with the idea of designing my own 6502 compatible / similarly functioning computer.
Nice. I always wanted to read/play-along-with jonesforth, but managed to get distracted every time. An alternative presentation might just rekindle my interest :-). I just looked it up to link to the original and stumbled across [this blog post](https://rwmj.wordpress.com/2010/08/07/jonesforth-git-repository/), which links to the repo and (in comments) to an "ANS-consistent" version. Elsewhere on Rich's blog is a link to an [ARM port](https://github.com/M2IHP13-admin/JonesForth-arm) for those less fond of x86.
i am interesting of the name of their database
Hi! The server itself is a standard SQL database. The Forth-ish part is the tool query language that is provided over XMLRPC. This allows me to provide a fast, flexible parser that composes "safe" queries, taking data model and security into account, but can be easily accessed from almost any language (that can talk XMLRPC). It's been a big win for us -- before I did this, specific calls to access specific data would have to be written, and there was a lot of overhead. Now tools can request exactly what they need and take advantage of relations. Thanks for your interest!
well a good case for forth as a DSL that's what i want to do with forth and redis :]
If everything is a file in UNIX/C, what is everything in Forth? Google results suggest everything is a "word".
By day I am a Lisper, and quite enthusiastically so. But really I have an affection for all elegant, minimal models of computation which nevertheless remain near to, if not right on top of, practical considerations. And as such, I feel quite morose about Forth. It is such a beautiful, powerful little language and the community of forth programmers seems densely packed with wisdom about the nature of problem solving. And yet, I can't see how the language is anything but dying if not dead already. Is anyone out there using forth for anything new? How many Forth jobs are there posted every year? It just seems like forth is destined to languish in greater and greater obscurity, which makes me sad.
Chuck Moore's Greenarrays quite alive, and even (DIY friendly)[http://www.greenarraychips.com/home/documents/budget.html] now. Forth Inc. seems alive too.
I didn't even know it existed until a couple of months ago. For 30 years my BBC Micro has sat there mainly unused. Now its time has come again. 
What's the origin of this video? He mentioned at least another one on the bitbucket description. Or are you, pointfree, the author?
The video is by [Samuel Falvo II](https://plus.google.com/107342658527226339723/posts) (not me) it was originally posted here: http://www.falvotech.com/content/videos/ots-01.mpg (now a dead link). I [found this video](https://www.wuala.com/randy2187/Misc/ots-01.mpg/?lang=zh) by trawling the internet for the filename. I then uploaded it to this libre video sharing site. If you find the other one please let us know!
lots of 404 links on that page
This is getting exciting!
How come you pulled your cross-post to /r/programming? Just curious.
Ahh, no worries. :-) I've been tearing through your posting history and was just watching some of the stuff you posted about Core Rope memory. Thanks for keeping me up until 6 AM looking more at the hardware side of things! Good stuff.
:-)
And when Reese gave birth to her Replicators, her first command to them was, "Come FORTH." https://www.youtube.com/watch?v=ap1Mq0fIidQ &lt;3 I always think of the Replicators or SkyNET in relation to FORTH. I can't see the code for either of them being written in any other language.
I'd never seen a decent description of colorForth before. This has opened my eyes. Thank you.
Sounds cool! I actually had the idea of making such a thing for Factor a while back since that feature is available in the Factor IDE. 
If you aren't aware of it already, there's a nice free pdf copy of a book on the topic: [Forth on the BBC Microcomputer By Richard DeGrandis-Harrison](http://www.jupiter-ace.co.uk/book_forth_ISBN-0907876064.html)
Is there a binary anywhere? I have a burning hatred for ant.
Just for you: [Mako](http://cs.mtu.edu/~jshiebel/files/Mako.jar) This is the standalone version of Forth Warrior. Just run the jar directly with java -jar Mako.jar
Thanks! The abuse of XML makes me irrationally angry. 
If you like this kind of thing, check out [/r/programminggames](http://www.reddit.com/r/programminggames/).
I don't have an answer to your question. But I believe there's a minor problem with your code as currently posted: it will always read from the terminal input buffer without regard to the current input source. E.g. consider what happens when a file is `INCLUDED`. You could either use `SOURCE` instead of `TIB TIB# @`, or check whether `SOURCE-ID @` is zero.
This is the original metacompiled model. It has been scanned from hardcopy, OCR'd, manually corrected, and verified by running it through a Forth compiler.
Thanks, hadn't thought of that! If I write S" filename.fs" INCLUDED in the interactive shell, I don't really want transcript.fs to be filled with the contents of filename.fs. I.e. I don't want the redefined VARIABLE, CREATE etc. to work that way when they're in an INCLUDED file. If anything, I just want to echo what I've written in the interactive shell to the transcript. So if I've understood correctly, I would then add something like: : ?TIB&gt;TRANSCRIPT SOURCE-ID 0= IF TIB&gt;TRANSCRIPT THEN ; and then redefine VARIABLE etc. with that instead. And maybe also add: : INCLUDED INCLUDED ?TIB&gt;TRANSCRIPT ;
Thanks! That sounds like a really good idea. Using this method, I would be able to write *and edit* the code while continuously testing it interactively. I guess my initial thought was simply to find a quick way to write and save the code directly in the interactive shell and then be able to edit and brush it up with an editor afterwards. E.g. if I've redefined a word several times, I would afterwards delete the earlier definitions. So I would sort of postpone the editing and not let it get in the way of creativity, so to speak. But maybe the gain wouldn't be that great after all, now that I think about it.
Problem is that forth runtime and forth source only map to each other in a single direction (unlike Smalltalk or DSSP) due to macros and other interactive compile-time execution (and it is everywhere in forth). I tried several times to write forths with ability interactively redefine words, and, well... Nothing useful came out of it, as i also wanted to redefine data interactively and here comes troubles. Also interactive works lacks that ability of source to have meaningful structure, comments and so on. It's like writing a book vs having a conversation, i guess. 
&gt; Problem is that forth runtime and forth source only map to each other in a single direction That's why I thought I maybe could intercept the code while I'm writing it and pipe it to a source file. Almost like the "script"-command in linux, but only for the input. &gt; I tried several times to write forths with ability interactively redefine words When I wrote about redefining words, I guess I just meant compiling a new word with the same name. I agree that redefining words, which other words already depend on, would probably be difficult. &gt; Also interactive works lacks that ability of source to have meaningful structure, comments and so on. &gt; It's like writing a book vs having a conversation, i guess. That's a good analogy and a good point! I want to be able to record my conversation into a book, and perhaps it's better to begin by planning the contents of the book from the start, instead of trying to write down a really good conversation I had. And to draw the analogy further: With the method you're suggesting, I can still have a conversation with the computer about the book I'm writing.
Right, something like that. Note that `SOURCE` will now only be called during terminal input, so is guaranteed to return the same thing as `TIB #TIB @`. I would prefer `SOURCE` in this case.
&gt; That's too bad, so far I rather like using blocks. Keep using them, and ignore that statement, was my point. Blocks are meant to be a fundamental feature of FORTH; it was wrong of GFORTH's developers to say that.
This does not follow any standard, rather I just used the design of an indirect threaded forth system as reference. It only reads numbers in in four character hexadecimal strings, and there is no looping word (there are enough utilities to implement one).
I also wrote one some time ago http://davazp.net/eulex.html. It was a great experience.
Also http://www.unz.org/Pub/ProgrammersJournal-1988nov-00056
The only thing I don't like about this forth [is the null-terminated strings](http://queue.acm.org/detail.cfm?id=2010365). I may need to change that at some point.
What is it that you don't like about the use of null-terminated strings? I had assumed this was just a token separator and that you wouldn't necessarily have to type null yourself? Edit: please ignore me I read that line of the article completely wrong!
Or you stop pretending Forth being C and write: : testports dup . ." - Test? Y/N" key cr [char] y = if swap execute then ; Or if you prefer another style: : ask dup . ." - Test? Y/N" key cr ; : yes? [char] y = ; : testports ask yes? if swap execute then ; 
A different kind of read, probably lower on the pragmatic scale of things, Eric LaForest [thesis on stack computers [pdf]](http://is.uwaterloo.ca/Eric_LaForest_Thesis.pdf‎) . Covers everything from Charles Hamblin RPN to Chuck Moore Forth processors.
A few interesting articles: http://www.bradrodriguez.com/papers/index.html And of course all issues of Forth Dimensions: http://forth.org/fd/contents.html
Are you using entirely standard forth or your own dialect of swiftforth? Will the source be released? Will you "port" the project to linux? 
The code compiles with a plain SwiftForth installation and only redefines a couple core words. There may be a couple version-specific dependencies - I'm using a 1 or 2 year old version. Yeah I think I might release source, once the game is finished and I have the time to document and talk about it; and figure out how to distribute some internal dependencies that I treat as separate projects ("base" toolbelt, XML support, Allegro 5 support, all self-written and barebones) Porting to Linux should be possible since SwiftForth for Linux is AFAIK source compatible. There are only a couple Windows dependencies. I don't have a computer with Linux and know practically nothing about it, so I don't think that's happening without some outside help. I'm not sure, is there a big market for games on Linux these days?
If Valve has their way, there will (soon) be a big market for games on Linux.
Good point - we'll see how that goes and consider it later. If this game is well-funded, we'll be able to start working on the next one right after it's launched, and then might be around the time when we'll know if porting makes sense.
&gt; I'm not sure, is there a big market for games on Linux these days? I don't know if it's a big market yet, but a market is developing, and here's hoping that Valve will give linux gaming a few more pushes. 
It's not a big market, but you won't have much competition in it as well, so you'll get a plenty of exposure to linux people just by supporting it.
I'm not familiar with SwiftForth (I've used SwiftX in the past). How does SwiftForth interface with external libs (like Allegro)? Does SwiftForth have a rich FFI or some darker binding magic?
There is a linux section in steam with 150 games in it. And there are 3000 games in general one. There is a chance for your game to simply drown among massive amount of windows titles. And under linux water is not even knee deep right now.
Nice idea but overly messy for my taste.
I'm not sure if it will be well received enough to not fall flat on its face in the Linux world; it's an art game, intentionally cryptic, and its gameplay is simplistic.
"intentionally cryptic" would appeal to Linux users ;) Honestly, if it will run under Wine, then that would be enough for Linux users to give it a try. (My household is 80% Windows free!)
Thank you for posting the link to the publications of [Bradford J. Rodriguez](http://www.bradrodriguez.com/papers). It is our sacred trust to keep track of *le tout* Forth which is so crucial to the emergence and evolution of [artificial intelligence](http://www.nlg-wiki.org/systems/Special:SearchByProperty/Worker/Murray). 
You should learn to use overlays (the MARKER word). http://www.forth.com/starting-forth/sf3/sf3.html Let me recommend that you head off to Forth, Inc. and buy the two Forth books they have there. One is a reference, the other is introductory. They are not specific to SwiftForth and they're really great. Also, And So Forth and Stephen Pelc's tutorial, and the other fine stuff available on the Net.
In [Kitten](http://github.com/evincarofautumn/kitten) I did something similar—entering a local scope with `-&gt; x` moves a value from the data stack to the return stack, invoking the local with `x` copies it back to the data stack, and the local frame is dropped before a return or tailcall. When a local function captures a name, it is converted to an explicit capture by value; at present, this uses the heap. I’m still not certain whether it’s better to have instructions to read from the current closure, as I do, or to explicitly patch it in as they do here. Anyway, this has the nice property of decoupling “lambdas” in the sense of name binding from “lambdas” in the sense of anonymous functions. And of course you can type these expressions in the same way that you do in any typed lambda calculus. 
I actually have a hardcopy of that book and didn't know that list was in there. Thanks!
He mentions the use of a second stack for holding the return addresses, which is quite unusual outside of Forth :-). Glad you enjoyed it.
I've been waiting for someone to ask me something like this. :) The experience isn't yet over of course, but, during the process I've found out some, perhaps fairly surprising things. To answer about doing it again - I would, hands down. I wanted to make a tool that I'd prefer to make games in over everything else. It might be because I've figured out how to use it to develop a large project, the missing piece for me. The trick is to do it in pieces and at the end connect them together. The tools, and by extension Forth, have enabled a different approach to making a game. Everything is more custom, more focused. Adding what you need when you need it is essential and routine. Throwing stuff out is less of a big deal. The main crucial difference is there is less code. I would say 5-10 times less, comparing to some of the classes written by other people I've laid eyes on. Most of my functions are 1 liners - not an exaggeration. Because of the stack lots of variables disappear. Because my scripting language lets you keep things on private stacks between frames in a way that doesn't screw up interactive testing I was able to maintain that. There's a lot more trying out of ideas and alternatives, more exploration. Sometimes just by playing and exploring in the commandline you come up with a way to do what you want that's so beautiful it gives you a kind of high. I created the barebones version of The Lady's level editor in 2 days. Because Forth is so indifferent about overloading things in the dictionary you can make things really modular. Because the nuts and bolts of the compiler is your plaything you can do some nifty syntactical things that, culminated, save you time and mental energy. I have found it useful to code with the idea in mind that, especially with tricky problems, it's likely, and in fact preferable, to expect to throw a piece of code away and rewrite it, after having learned so much about it. Forth makes this much less severe a prospect than in other languages, so the code is cleaner and your functions easier to use. Sure I've made some dumb mistakes that I can't go back on now but we deal. But yeah, the downside is, it's not easy (and it could be argued that programming shouldn't ever be considered an "easy" endeavor). When things go wrong, maybe there's a mysterious bug, or you painted yourself into a corner, or you made a terrible design choice, the pain of personal responsibility is crushing. Especially when you don't have a lot of time to rewrite and verify subsystems, you're on a schedule. If you're adding language constructs, which I do often, you have to unravel everything and test and dig and drill down and it can take days. Maybe you left something on the stack or ate something that you needed. That's terrible. If you're more of a stickler for correctness you may not get into as much trouble as I have. You could also say that because I was basically on my own that adding a lot of the low level stuff that people take for granted was a downside. Stuff like arrays and XML support. No kidding. Some of those are not as clean as I'd like. But they work well enough that I can sweep it under the rug for now with the knowledge that over time I'll clean things up when I have spare time and as needed, in the next project, and the next, and so on. There are also technical limitations with the SwiftForth itself - no access to C++ libraries etc, no MMX instruction support, that kind of stuff. Applications don't run as fast as C... but... honestly I think that extra bit of bleeding edge OJ is not worth the cruft and complexity. It's more fun to innovate. I've done some pretty cool things anyway - I have a bullet hell demo featuring thousands of bullets that runs 60hz on a crappy laptop. Fixed point math. I have plans to make my own IDE designed to deal with the unique issues I deal with in Forth. It will make the pitfalls that come up a lot be a distant memory. Thanks for asking! :)
Sure. That's not even all there is to say about it. One other thing that is hard to express the advantage of is the fact that things can be more rapidly tested by literally compiling or recompiling bits of code while a program is running. On the other hand testing needs a more methodical approach - forget about breakpoints (no step debugger), you need to type your shortly named function words over and over and try different things out so I tend to make them kind of short, sometimes cryptically so depending on how global the intended scope of it is. Ultimately what may be seen as a disadvantage ends up forcing you to Keep It Simple. From another angle, since keeping it simple worked so well for Chuck Moore the inventor, there was no need to add a step debugger, so you have to learn how to do that. It's not easy, because the programming world seems to be unacquainted with simplicity, maybe even averse to it. You run up against culture. I think I'm getting better at noticing when I'm faltering. I also found out that I've only scratched the surface, I didn't have the time to add everything I could have added to the toolset to make things go quicker and cleaner but next time I will. You wouldn't believe how long it took me to get to this point. I started around 2000 and only now getting it. I really want to share all I've learned some day but I'm so busy doing it I hardly ever talk about it. 
Could you do post-mortem debugging (e.g. using a debugger on a core file) with your Forth implementation? If not, how did you resolve segfaults? Did you write a test suite during development? And how was concurrency? Were you limited to a single thread? If you were, how did you hide that from the player? If not, how well is multi-threading supported?
When the game is running if there is an access violation it (usually) dumps you to the interactive commandline to diagnose. Often, sadly, the dictionary is corrupted at this point, which is due to a design flaw in SwiftForth (code and data is interleaved.) I don't write a test suite for the entire project. Sometimes when I'm developing a component I'll include some test code right in the file and then I'll "disable" it with the word \\\\ which skips the rest of the file. You can create threads. There's Windows API access so whatever related to threads and cores can be done that's not already included can be done that way. Threads aren't needed for a game, it's hard to parallelize usefully with current technology.
Threaded Interpretive Languages: Their Design and Implementation by R. G. Loeliger http://www.amazon.com/Threaded-Interpretive-Languages-Design-Implementation/dp/007038360X If you look hard enough you can find a pdf because it's $60 for a brand new copy. I have a second hand copy. It's one of my favourite books. 
It really is fun and so simple. I have always wanted to write a BASIC interpreter but I think this is much better and entertaining. I think the only thing i may have trouble is the colon operator but I'll see.
My javascript one (unfinished) is here http://code.google.com/p/jdrift/ I don't think that will be much help to you colon is fairly important :) and switching between compile and execute during word definition is the strength of Forth There's an interesting Forth called 4th. It has a basic interpreter http://code.google.com/p/4th/wiki/TinyBasic 
My thinking behind the colon would be to store the rest of the words in a list until a semi colon is reached.
Thing is if you get some code executing during the compilation, you can end up with a lot of code stored before building your runtime code. So you keep a stack running during compilation and pop the addresses for jumping about from the Return stack. It's all good fun
I'm not even storing byte code, uh oh but yeah I imagine i would be better off.
Google for "jonesforth github", clone one of the repos and read the .S file. A complete compiler/interpreter combo as a literate assembly file (no need to actually know assembly language). Once you've read the ~2k lines, you'll know everything you need to start.
There's a scanned version as a pdf here http://sinclairql.speccy.org/archivo/docs/books/Threaded_interpretive_languages.pdf It's not great quality but looks readable
Cheers, I have that already but didn't have a link to it 
Many upboats!
Lest we forget, Forth is good for **[artificial intelligence](http://www.reddit.com/r/mentifex)**. 
Yarrrr matey, thank ye for the plunder. ;)
Also, see that demo: http://www.pouet.net/prod.php?which=62959
Support Forth game development and buy it! For Windows 7 and up. If you find it interesting show it to your friends! I intend to release the source code once I get my shit together. Quite a few components come together for this project and I may not have organized things the best way especially from a distribution point of view. Thankfully no changes to SwiftForth itself are required. I'm happy to answer any questions about the development process or the overall codebase now that the game is done.
Awesome!
Haha!
Best response in this thread. This is what fascinates me most about FORTH. The raw simplicity.
As far as I know, this is a well known technique for small Forths. Notice that it isn't a particulary fast way to implement Forth.
Nice. 
I'm inclined to say that they're equivalant in power; you can write words that read directly form the input stream and do anything you could do with a reader macro, and it's arguable easier as you don't need to mess around with reader tables etc. which can feel quite restictive at times. You can define words that define words, which covers most common uses of macro's, or if feel like figuring out how your Forth compiler generates words or your Forth includes an assembler vocabulary (list of words) it you can emit machine code. That being said Forth and Lisp are quite different and I don't find myself doing this sort of thing in Forth. Lisp macro's often perform complex transformations on deeply nested lists/trees, which allows you to do a lot in a single macro. This is often done for infromation hiding or to simplify othewise ugly or repetative expressions. After a while with Forth you'll find that you can produce much the same effect with a few well chosen Forth words. For example (teaching me text editor how to change or insert or delete text and backspace) : c !mark mark+ ; : i text+ !mark mark+ ; : d text- ; : b mark- text- ; For example (teaching my assembler how to pack code and data into memory) : prep u #d 8 * lshift ; : used swap; : code 1 used prep ; : data n used prep ; : pack h @ or h ! h+! ; And using it : call 09 code pack data pack ; None of this uses what you may call macros. Other times a few defining words are useful, but this is as far as I usually go. For example (one common approach to implementing C-like data structures) : { 0 ; : field create over , + does&gt; @ + ; : int32 cell field ; ... : } create allot ; And using it { int32 x nit32 y } point point p1 3 p1 x ! 5 p1 y ! point p2 0 p2 x ! p1 y @ p2 y ! (I used the braces here to illustrate a point. You may prefer to use words like record or struct, begin-record and end-record etc. Forth is very liberal about these things) Notice how these examples all consist of a many small words working together, rather than one big macro that runs through a tree pulling bits out then splices those pieces into something that the system understands before emitting it and letting The Compiler do what it does best. This I think examplifies the Forth approach, or at least the approach I'm taking. In Forth you set things up so that everything is where it needs to be to be used. In Lisp you create some [comparitively] complex tree and proceed to use the power of the language to bend and shape it into what it needs to be to be used. Hopefully this goes some way to answering your question..
An example of a problem-oriented language for controling your terminal : \e[ h# 1b emit h# 5b emit ; : # d# 0 &lt;# #s #&gt; type ; : c emit ; : #; # [char] ; c ; : #m # [char] m c ; ... 0 constant black 1 constant red 2 constant green ... 30 constant foreground 40 constant background : color + \e[ #m ; And using it black background color red foreground color ." Hello, World! (In Red)" green foreground color ." Hello, World! (In Green)" Again no "macros", just Forth words, and like most of these examples, real code I use every day
I can only speak from my expereince with Lisp, but I would say a good 90% of the Lisp macros I've read or written macros (arbitary number alert!) were used for one of those: infromation hiding or simplifying expressions. Which isn't to say that this isn't great or that this isn't useful. And i'll accept that you can write macros that "compile completely new languages into compiled Lisp code", but I've rarely seen it. Of course like most people who've used Lisp for any period of time I've written (several of) my own object systems and found macros somewhat useful... though I must assert that the real guts of my object system was not really the macros, which sat on top and provided a nice syntax for defining classes and methods etc. Likewise the core of a Prolog implementation, at least as described in books like SICP, is not some macro magic (if I recall they don't even mention macros in this context). Anyway I think that may all be beside the point. My goal was not to imply that Lisp macros are somehow bad or not useful, but to highlight the difference in approaches, and in particular to show that the kind of syntatict abstraction that most macros are used for is achieved through words in Forth, when words are chosen for there semantic meaning rather than there implementation. The implicit flow of infromation between these words does the rest. Now this is not to imply that you can't "create compilers for new OOP dialects, or [...] implement Prolog or ML or Haskell" in Forth. But the approach is different. The Forth compiler doesn't exist as a single unit, but as a collective of cooperating words. Consider my [rudimentary] "compiler" for the admitedly simple ANSI escape language, in which I can write things like this (stripping away the pretty words like foreground) \e[ 0 #; 3 #; 4 #; 2J 0 #; 0 #H 38 #; 5 #; 130 #m 48 #; 5 #; 79 #m ." a very stylish hello world!" With the exception of the occasional hash etc. which I chose to add for my own clarity, you can copy and paste examples form the ANSI standard and expect them to work, but you can also embed any Forth code you like into this language because its all built from independent/cooperating words. If you don't know this language it probably looks very cryptic but it is very powerful and in &lt;50 SLOCs it replaces the ncurses library in my editor when running in the terminal. (This example resents the terminal, makes text italic and underlines, clears the screen, positions the cusor, sets the foreground and background color using the standard 256 color pallet) Of course you can then use more simple Forth words to abstract over the peieces, pulling them out as you see fit : reset 0 #; 2J 0 #; 0 #H ; : italic 3 #; ; : underline 4 #; ; etc. And using it \e[ reset italic underline 38 #; ... To furthur illustrate consider my editor language : e mark- ; : u mark+ ; ... : { mark@ ; : } mark! ; : % .page page. mark! ; : &amp; .page text. mark! ; : ^ mark* ; : $ mark~ ; ... And using it { &amp; $ b b b } ii \e u Which lets my remember where I am, jump to the end of the text, delete three characters then return to where I was, set insert and enter text until I press escape (using one of a number of standard and non-standard character encoding models.) And of course I can name that if I like : b3 { &amp; $ b b b } ii \e u ; Which as chance may have completely subsumes features like keyboard macros. The core of the editor is again &lt;50 SLOCs that form a problem-oriented language for visualizing and directly manipulating structures in memory (not just text!), onto which I layed abveriations like those show above. It's important to recognise that this approach to language construction often provides useful abstractions without preventing access to the underlying or surronding system, in the way that you might get if you thoughtlessly created a macro that compiled a tree representation of another language into Lisp.. which must necessarily be compelete. There are ways to get around this in Lisp and there was a whole body of research done into creating extensible evalutators/compilers but it can be quite tricky and often takes a lot of thought up front (to my knowledge there are no real implementations using this stuff). Which is certainly not to imply that nothing in Forth is difficult! But this just falls out from Forths design. So to bring this all together what I'd like to say is that using this approach you can freely mix these two simple lexicons/vocabularies/languages into Forth and with a few more short definitions make a rich text editor, complete with colors and styles etc. Then its only a short step to structured editing, and if you find you're missing something, you can always define new Forth words right there in your editing session. I haven't quite got to using this for programming yet but one of the things I enjoyed most about Smalltalk (which I've also used professionally for several years) was the ability to shape the environment while you were using it.
Regarding object-oriented programming in Forth I should probably mention that of course you can build object systems ontop of Forth if you find that really want that, and many people have. It's not something I've done myself because I prefer a language-oriented approach with Forth. That said if you do want to do things that you can think of as being object-oriented, then you can implement a tagging mechanism that allows you to attach meta-data to any in-memory structure [1]. Once you have that you can implement features like generic functions pretty damn easily. How you do this is completely up to you and since your object system will be designed to suite your problem you may find that it's ideal in a way that an off the shelf object system could never be. [1] if you implement this correctly you can then freely use tagged values with specific functions. I've already posted one way of implementing C like record structures so if you feel like thinking of objects as collections of "named" properties with a little behaviour on the side then your even closer than you think. Important point. You do not need macros or tree transformations or compilers or anything like that to implement this kind of thing in Forth since words are plenty capable of providing the necessary syntactic abstraction/semantic extension, if you're willing to think the problem through, and maybe be a little flexible about it.
I am *so* curious: what are you doing with Forth? It seems something different from the usual "let's program a controller" thing, more "let's whip together an app". If you have a blog or a website, please paste the link!
Just for reference, I am not a gforth contributor. I just noticed that it was updated and thought it would be of interest to the community.
&gt; Likewise the core of a Prolog implementation, at least as described in books like SICP, is not some macro magic (if I recall they don't even mention macros in this context). I'm at a bit of a disadvantage here knowing nothing about Forth, but a typical Prolog-in-Lisp is going to use macros: e.g. from http://norvig.com/paip/prologc.lisp (defmacro &lt;- (&amp;rest clause) "Add a clause to the data base." `(add-clause ',(make-anonymous clause))) The front-end of the implementation is invoking the `ADD-CLAUSE` and `MAKE-ANONYMOUS` functions to process the Prolog form into the corresponding Lisp code, which then can be processed by the Lisp compiler. This is not particularly "magic", as the intelligence of the compiler is of course contained in all of the functions that process the Prolog forms and maintain the Prolog environment. But it is essential to converting code before the invocation of the Lisp compiler.
I think you are missing the point. This macro is essential to be able to compile the *Prolog program* written using the macros. To elaborate: what a Prolog compiler in Lisp will do is to consume a series of Prolog forms expressing a Prolog program, although they are likely in an S-expression syntax. (Ultimately, you can also write a Lisp program that reads arbitrary syntax, but that is just a matter of I/O, once you have implemented the compiler.) The Lisp compiler then considers the S-expressions in the file. Because these forms refer to the macros defined as part of the Prolog implementation, the macro expansions trigger the computation which produce the corresponding Lisp forms, as well as updating the relevant data structure the Prolog implementation uses to remember the Prolog-level details of what is being compiled. Then, when the Lisp compiler sees that no further macros remain, it knows how to compile the resulting Lisp code and does so. Without these macros, the programmer would have to manually invoke the procedures to translate each Prolog form. Or write the incredibly tangled Lisp code themselves. This isn't just "syntactic abstraction." A C compiler doesn't just provide syntactic abstractions: it allows people to write C programs then translates them to a form which will execute efficiently. Likewise a Prolog compiler allows people to write Prolog programs and translates them into a form which will execute efficiently. The process of translation is of course mechanical, because compilers are just programs. But you can't just say that the compiler is "information hiding" or "simplifying expressions." It is compiling code. And the macros are necessary for that compilation to happen before the code is executed.
The macro is essential to be able to compile the Prolog program written using the macros, but this argument is circular.... You need those macros because you wrote the Prolog program using the syntactic abstractions provided by those macros, but the (as you yourself pointed out) useful Prolog semantics are not provided by these macros. You could have easily created syntactic abstractions using the procedural approach, and written the Prolog program using those instead. This is exactly how it's implemented in SICP. No macros are required, and the system is just as easy to program. The simplicity of the macro's should give you some indication of how esential they are. The macros are necessary for that compilation to happen before the code is executed but that compilation isn't itself necessary [1]. That, and tranlation of the most Prolog-like s-expressions into procedure calls are not the goal (I would imagine). That's not to say that there's anything wrong with using macros for this; I'll often contort programs to form embedded problem-oriented languages. Macros can be damn useful for this. But in simple cases like this, where you didn't really need macros at all, I'd suggest that the motivation for using them boils down to "information hiding" and "simplifying expresions". Two wonderful properties of language that are seemingly being taken as derogitory, rather than something beautiful and essential. [1] Incidentally the hardest part of learning Forth for me was starting to separate what's essential for solving the problem from what's done to support some solution. I'm not saying that to knock the solution. It seems like a perfectly fine solution. And doing as much at compile time as possible is generally a good thing... but as Chuck Moore has said (to be in keeping with this subreddit), it's even better do to things at design time. I really like macros and when I was programming in Lisp I made extensive use of them. I just don't miss them as much as you might imagine. In every decent language I've used, from Smalltalk to Forth to APL, there are ways of solving these problems that are equally powerful, and equally different. Which is not to imply that there are no problems with these approaches (and there is a part of me that would never want to program in Smalltalk again). The problems faced by users of Lisp macros are just better documented than most. Anyway let me be clear: &gt; But it is essential to converting code before the invocation of the Lisp compiler. You are correct. Assuming you *need* to translate code. Thank you for elaborating :). I've found our discussion so far very worthwhile. 
Somewhat related to editors, how do you feel about screens? At first I thought screens where arcaic and crude. After having read through the original FIG-Forth source code, I'm not so sure. It seems the restrictions screens impose may promote short definitions and modular code.
Thanks for your detailed answer! I only ever used files, so I don't have any experience with source code screens. But I'm tempted to give it a try. Sidenote on the length of definitions: Everyone agrees they should be short, yet most code snippets posted (e.g. to comp.lang.forth) are quite long. What gives?
:) You're welcome and by all means do try it! Your usual text editor might have a few problems with this you can hack up a simple editor for screens in a weekend even if this is your first time. I don't really visit comp.lang.forth that often but as for your question about definition lengths in the examples I'd like to offer this: some people are much better at dealing with different kinds of complexity than others. I myself am very bad at dealing with complexity of this sort, so much so that much of the code I write tends to be just about as simple as I know how to make it (despite this it also takes me a lot longer than most to find solutions I'm happy with :)). I'd propose that this may be the cause of many of our problems as programmer. Programmers, on average, tend to be quite happy with many kinds of complexity. In terms of Forth this means I spend a bit too much time looking for representations that require the least amount of stack jugling. Of course this isn't always possible and in those cases I find a few well chosen words make the difference between a short readable definition and a long definition (though they serve no other purpose and aren't strictly required!) Another case in which limitations are useful :). Chuck Moore and others once said that Forth is an amplifier for programming ability. Extrapolating from this, if you'd normally tollerate a reasonable amout of complexity in your solutions then in Forth you're likely to produce very complex code. Now let me be clear, this doesn't make you a bad programmer, but what's reasonable in other languages isnt't reasonable in Forth. When I first started learning Forth I got extremely frustracted... I'd been programming in C for a while and was use to writing quite long programs with little abstraction. In many cases you can just do that in C (think procedures with lots of complex assignments and large switch statements). I learned the hard way that **I** can't treat Forth that way and expect to get very far. Other Forth programmers (though seemingly not Moore himself) seem to be able to get much further than I can... and the result are the many long definitions on comp.lang.forth. Short is relative :). I hope that goes some way to answering you.
You need to use POSTPONE and IMMEDIATE. I recommend to write your own forth from scratch to get better understanding. Also, read these books: http://www.forth.com/starting-forth/sf1/sf1.html http://thinking-forth.sourceforge.net/
Thanks! You're right. : end POSTPONE ; ; immediate 
Even symbols like + and - are non-explanatory; even the words "define" and "end". All of the things that we think are obvious or intuitive are artifacts of our experiences - I personally fall on the other side of the debate. I think that we need more symbols, much like in APL (originally indended by Ken iverson as a better notation for maths). Having a single symbol for complex ideas has a remarkable simplifiying property, especially when problems get hard enough. But it does requires people to learn the uses and meaning of those new symbols. EDIT: I'd like to add a few points about Engilsh. Words from natural languages tend to be quite ambiguous, having eveloved and grown through multiple contexts, which can be useful in that a word can be seen to apply to many different contexts.. but finding a word that really fits your problem domain can be quite difficult. The right word might not exist, producing code that feels too much like a bad analogy. This is of course why Shakespeare invented so many new words (actually it's been written that he invented more words than any other individual. Go figure - if you're trying to write good poetry and the word you need doesn't exist, you can just invent it and use it, and the result can be... amazing.) And the strange thing about new words... nobody knows what they mean... until you tell them [exactly] what they mean, and how to use them, when and what they're for. It happens all the time. And I think we spend way to much time contorting the thoughts in our head to fit our natural languages, or the limited set of symbols we have on our [typewriter-derived] keyboards.
You could use Chinese characters for that.
:) You could but you have the same problem - you're writing in a natural (specifically what I think is a logography, for a tonal, analytic language) as opposed to a simple formal language. Still it might be an improvement, since most people wouldn't know what they mean, and they could therefore be given new and appropriate meanings.
:) Ah. I was an avid Emacs user once upon a time, then I used Vim, and Ed and Sam and Acme and now I'm working on my own thing. I still consider Emacs to be is an amazing piece of software with a lot to teach us, but I don't use it all that often now. I like your idea of targetting Emacs bytecode with Forth, that sounds like a fun experiment and a great way to learn more about both Emacs and Forth. Of course. If you post it I'm sure myself and others will be happy to give you our opinions - which is all they are - and you may disagree. In that case I wolud advise you to go with what you think is best :).
Three lines is not too bad, but a far cry from "three to five words" stated elsewhere. \ If you don't have a CODE definition for multiplication. : * 1 2&gt;r 0 swap begin r@ while 2r&gt; 2dup 2* 2&gt;r and if swap over + swap then 2* repeat 2r&gt; 3drop ; 
This is worse. \ Unsigned division of n by d, leaving quotient q and remainder r. \ All numbers here are single precision. : u/mod ( n d -- r q ) ?dup 0= abort" Division by zero" 0 &gt;r 2&gt;r \ R: q n 0 1 begin ?dup while dup 2* repeat r&gt; 0 begin \ S: [...1&lt;&lt;i...] d r 2* \ r &lt;&lt;= 1 r@ 0&lt; if 1+ then \ if n&amp;msb then r++ r&gt; 2* &gt;r \ n &lt;&lt;= 1 2dup &gt; if rot drop else \ if r&gt;=d over - \ r -= d rot r&gt; r&gt; rot + &gt;r &gt;r \ q += 1&lt;&lt;i then 2&gt;r ?dup 2r&gt; rot 0= until nip r&gt; drop r&gt; ; 
This: http://www.reddit.com/r/Forth/comments/2963n3/refactor_my_code/
Worth checking: http://www.colorforth.com/arith.htm
The approach is an implementation of binary multiplication or "peasant multiplication". If the stack effect of * is described as ( *a b* -- *c* ), then the stack picture during the loop is S: *c' a'* R: *b mask* In each iteration, *b* is ANDed with the *mask* to see if *a'* should be added to the accumulating product *c'*. Then *a'* and the *mask* is shifted left one bit. When the *mask* overflows, it becomes zero and the loop ends. Regardless of the algorithm, this may serve as an example of 1) a loop with much state on the stack which results in some juggling 2) that using the return stack may make factoring harder. Common wisdom holds that refactoring should make most of these problems go away, but I don't quite see how? The constraints are that this is part of a toy Forth which only has a minimum of CODE primitives (and in particular only + and NAND for ALU operations). At this point, AND and 2* is available, but not RSHIFT. Perhaps this is better explained by browsing through the [nucleus](http://github.com/larsbrinkhoff/lbForth/tree/master/targets/c/nucleus.fth), [kernel](http://github.com/larsbrinkhoff/lbForth/tree/master/kernel.fth), and [core](http://github.com/larsbrinkhoff/lbForth/tree/master/core.fth) of http://github.com/larsbrinkhoff/lbForth
I might need some hints on this one too sadly... I don't know about you but I feel a bit lost when looking at this. I generally work on the basis that 1 word of Forth is roughly equivilant to 1 line of X, which is why 52 words almost feels like 52 lines... only without the [hopefully] well chosen indentifiers to give you some context.
Thanks! I'll ponder this.
Please do let us know if you have any insights, especially if you can think of a good way of verbalising those insights
Thanks again, it's certainly much more readable than my original. Some random thoughts: * Maybe it's better to avoid using the return stack like I did. * (Keeping in mind this is an abuse of the stack) your technique would only work with a few items on the stack (or else use the dreaded PICK). * Your code reminds me of hand-coded locals. Again stack abuse? * I have a knee-jerk aversion against global VARIABLEs, probably from using other programming languages. * Curious about the non-abusive version. I may be more coherent after I get some sleep.
You're welcome. Moore asserts that you shouldn't really have more than 3 values that need to be accessed at any one time on your stack, and that seems to work well as a target, and it fits with having the many short words. Moreover when your words are short enough they probably don't involve too many values. It's important to keep in mind that words are not functions or proceducers. I've found the return stack to be very useful; when you call another word any local values are safely hidden away for you and you'll find out soon enough if you forget to remove them when you're done. They do pose problems for factoring but if you keep your words short to begin with (something that isn't always easy and takes a bit of practice) then you'll find that you can't use the return stack this way, so it just all works out. I've never actually used pick and roll etc. since that implies that you've decided to use the stack as an array and it always seemed to me that if you want an array then you should probably be using an array. This applies to other data structures. To give a short example, I once saw someone implement cons cells on the stack and proceed to complain that the resulting code was too awkward... which is probably to be expected when you consider that you're trying to implement data structures using only parameters. In that light it sounds kind of ludicrus, right? Yes. You can play a lot of games with closures along these lines but I haven't seen anyone seriously consider using these to implement data structures in practice. What I almost always find that what you really wanted was some data structure(s) - and a language for working with the structure(s). The natural place to create data structures is in memory. But I think it goes further. The stack is there to support composition of words and not to pass paramenters (I know that I related values on the stack to parameters earlier but bear with me). This is why I say that words are not functions or procedures, in the usual sense. The words themselves don't say anything about what data flow is implemented, and you could change the example above to use variables instead of the stack without changing the 3 main definitions. The support words form a very small language for describing just that algorithm. Which is a bit of a mess, if all of those words are now in the global namespace. Which brings me to your next bullet point. I don't really think of words as being being global or local because you can hide them pretty easily, preventing further use, although the mechanisms for doing this vary quite widely between different Forths. However this is done in your Forth this gives you explicit control over the scope of words, like variables, and by extension all data structures. This is one reason why I don't see the need for local variables (in fact I think this would be a disaster since it might encourage larger and larger definitions(?). Some limitations are useful :)) If you could fork the dictionary then you could even create little hyperstatic worlds, giving you control over the scope of side effects http://www.vpri.org/pdf/tr2011001_final_worlds.pdf I think that Forth has a lot of untapped properites that would be very useful in software engineering terms, and that's part of what I'm exploring at a startup right now. Anyhow to close I'd like to say is that there's are lots of opinions on how much to use the stack and I'm firmly at one extreme; take everything I say with a grain of salt, but please do also keep in mind, that the story of Forth isn't over yet, and if Forth in 100 years still looks like ANSI Forth today then think we've missed something. Moore threw the barn doors open when he created ColorForth and I think we owe it to ourselved to see how far we can take things. Recreating the same old systems from 40 odd years ago (as many of us have or are doing) is fun but it doesn't really teach us as much as it could. ;) I get a little too excited sometimes... I hope this made some sense to you. In some respects I think Forth is so different that our usualy vocabulary doesn't quite work as well as it might for describing it. EDIT: I'm particularly interested in exploring some of the ideas and approaches to problem solving I learned from APL to a Forth. If you have any thoughts I'd love to discuss them with you.
Some questions: * What does the p in p* stand for? * I can see you don't use stack comments, why is that? The party line (Chuck excluded) seems to be to always have them. (My first guess would be that your words are so short you don't need comments.)
So with your guidelines (and code) in mind, I came up with this. (Which is also nicely fits comfortably in a screen.) variable a variable b variable m : 2*! ( addr -- ) dup @ 2* swap ! ; \ Inspired by +! : ca+? ( -- f ) m @ b @ and ; : ?ca+ ( c' -- c" ) ca+? if a @ + then ; : +* ( c' -- c" ) ?ca+ a 2*! m 2*! ; : p* ( c' -- c ) begin m @ while +* repeat ; : init ( a b -- c' ) b ! a ! 1 m ! 0 ; : * ( a b -- c ) init p* ; Now, this is satisfyingly uncomplicated, readable (I believe), and well within the recommendation for short definitions. But at the back of my mind there's a voice whispering 1) what if two threads execute this simultaneously, clobbering the variable values, and 2) why do I have to store values in memory when other languages keep them on stack or in registers?
Your post is really interesting. When you say that words are not procedures, and the stack isn't used for parameters, that boggles my mind because that's exactly how I think about them. And I think many Forth programmers new and old do too. So I feel there's something important to understand here. Agreed re pick, roll and locals. If I want an Algol derivative, I know where to find those. My comment about global variables weren't meant to hint at namespace cluttering, but rather that they make definitions non reentrant (often not a problem) or thread unsafe (only a problem in multithreaded implementations of course). I suppose there could be some thread-safe flavour of VARIABLE, e.g. like USER. I keep getting amazed at the profoudness of this seemingly simple language. (Maybe it's *because* it takes simplicity to an extreme.) I have no APL experience, sorry.
The p in p* is for peasant in peasant multiplication ;). On a purely athetic level I find stack comments clumsy but I've never really thought about it. When I'm figuring things out I often doodle the data flow on paper but I never feel the need to transcribe those as stack pictures in the code. I could have put the stack comments in after but that would be more like reverse engineering. By the time I write the code that solves the problem I'm not really thinking about the stack. The words I defined fit together in a language, and any phrases made in that language tend to either have a clear meaning, or be nonsensical, and it's usually pretty easy to spot nonsense (especially if you know a bit about the context). This is unusally clear in to the example above, where I know than ca makes c and a available, and therefore that 2* will have the effect of doubling a, but otherwise leave things as they are. That is to say that 2a will leave c 2a on the stack, as I know that c and a are bound together, in the same way that b and m are bound together. This was a somewhat arbitary decision but in the context of the resulting language it makes sense. In a similar vain I know what 0ab1 will leave on the stack by deconstructing the name. Though I find this a bit unnerving it seemed to fit the pattern exemplified in the other words, and I think that's useful. If the pattern is broken then it's may indicate that something is wrong (in the implementation or in my understanding.) Let me try another example :) In the case of my assembler I have code like : code 1 slot used prep ; This is part of a language that is used like : call 09 code pack data pack ; While you can't see what's going on here it should be plain to say that 1 slot has been used while prep'ing, for the packing. If I then saw a word that looked like this : doit pack 09 code pack data ; Even though I just made this word up I can describe the context in which this word is valid, without ever thinking about the stack picture. doit is only valid after some code or data is prep'ed, and this code or data must be followed by some data to be prep'ed, and then packed. I can also tell you that this phase may be repeated as many times as there is data to be packed. Moreover I can tell you from the context that the data is an address of a word to be called. random-address random-address random-address random-address data doit doit doit pack (I'll just assume that random-address exists ;)) while admittedly pretty stupid it is a valid sentense, and it would assemble a valid program... though I can't tell you what that program does (it would probably crash most of the time). I can make these sorts of statements without considering what's happening on the stack, though be assured that the stack is being used here. The definitions of slot and used show above are : slot ; : used swap ; What I'm proposing here is that rather than the stack effect, we consider the grammar of the languages that are formed by the words we define. We don't necessarily have to write this down but it would be more useful than a stack effect. But I don't KNOW. To me the beauty of Forth (and the reason I use it) isn't about the stack or the return stack or the memory or create or any orthe other details... though I do find how Forth works amazing, and I love how everything can be understood. That there aren't these layers and layers of abstraction to dig through :). I use it because unlike any other language that I've used it lets me construct these contexts, in which I can reason and solve problems, without really thinking very hard. And I am lazy. The fun part and the hard part is finding the words, but once you do, the problem solves itself, in a manner of speaking :). Now when I do have to juggle the stack I hate it... and I'd be happy for a few stack comments ;). ... but I'm not sure that's every really necessary
:) very nice! If you wanted to try and make this even simpler you could try to find a simpler algorithm. This is where the biggest gains are usually found. I like that you found 2*! in the process. The problems you raised are real and I can't offer a final solution, but I have a few thoughts that may or may not be useful to you. In general I'm not a big fan of threads... which might sound like an odd thing to say but there are enough alternatives to choose from now that I'm fairly comfortable saying that. You could implement co-operative multi-tasking using co-routines (if you have control over your Forth this is a beautiful thing to implement); you could try implement CSP and channels; copy-on-write processes, something like UNIX fork (which has some excelent properties for resource management); actors, etc. If you have multiple threads of execution rampaging through a shared memory then you're heading for trouble anyway. You could stick a big lock around the whole thing. This is the most common solution, and is independent of the language. Or maybe implement thread local variables and use them :). EDIT: as you suggest yourself in your other comment. A little history: UNIX didn't originally have threads. Threads came about because copying processes was deemed a bit too heavy weight at the time. In Plan 9 the guys at Bell Labs gave you fine grained contol over the forking process and as a result processes can be as light-weight as normal threads, but you can still have copy-on-write semantics instead of shared memory if you like. This may or may not help depending on your platform but I think its interesting for context :). There are other solutions of course, you could change the domain of p* so that it expects a data-structure rather than using variables. Then in init you could create a new data-structure and pull out the result at the end (this may be your preferred solution if you have a background in functional programming.) :) And I guess I should add, don't underestimate what you can do in a single threaded language. Javascript is single threaded and very hot right now, and many interpreted languages have a GIL to contend with. The solution that I find most interesting involves communicating VMs (possibly running on the metal or ontop of a hypervisor :)) My understanding of the x86 machines is that they don't have a hardware stack. The reason that accessing the stack is faster is because the OS "keeps" the appropriate pages of memory in the processors cache (please correct me if I'm wrong). Assuming this is the case, if you kept your data structures in cache then there shouldn't be much of a difference. Just a thought. In any case depending on the language you're using you're stack may actually be allocated on the heap anyway, and unless you're doing heave number crunching (and probably even then!) you'll be accessing memory a fair bit anyway so it could be best to just accept it. Hopefully this ended up being somewhat coherent ;) 
I'm happy you found my thoughts interesting. I've enjoyed putting them into words, and hopefully my elaboration regarding stack comments and language grammars should make the case somewhat more solid. I still keep getting amazed at the profoudness of this seemingly simple language, even after using Forth for the past few years :). &gt; [...] global variables [...] make definitions non reentrant (often not a problem) [...] This is certainly true but it's easily solved in general by ensuring that things as you want them to be prior to your definition, by, setting base before you use it and not assuming that other code was well behaved and cleaned up after itself, for example. In those cases where I've had significant state to maintain, such as in my editor, I find that instantiating a new editor or invoking a general reset word allows me to get things back into a good state for testing. But admittedly both are less than ideal and if you can manage it then it may better to make your words as stateless as possible... I'm just sot sure how far you should go with this before it stops being worth it... for example the core of my editor is ~50 LOCs and inherently stateful, but because of its simplicity I've never really had any problems with it; I wrote it the first version without trying it and it worked almost the first time (typos are a killer!). I could just be lucky :).
The transputer is a nibble based stack machine.
Giving this a similar treatment as above: variable n variable d variable r : r+? n @ 0&lt; ; : ?r+ r+? if 1 r +! then ; : rd&gt;= r @ d @ &gt;= ; : r- d @ negate r +! ; : q+ 1+ ; : ?q+r- rd&gt;= if q+ r- then ; : 2*! dup @ 2* swap ! ; : -/ 2* r 2*! ?r+ n 2*! ?q+r- ; : ?zero dup 0= abort" Division by zero" ; : init d ! n ! 0 r ! 0 ; : b/ 32 0 do -/ loop ; : rq r @ swap ; : u/mod ( n d -- r q ) ?zero init b/ rq ; Is this more understandable?
I'm not a proponent of threaded programming either, but even if you have a single-threaded Forth, you may have asynchronous interrupts executing Forth definitions. I guess over the years, it has become my default mode to always try to avoid any possible race condition. In that light, the stack would seem to be the most obvious place to keep all local state. But then, maybe I'm overthinking this. If it were a real problem, Forth would probably have an idiomatic solution by now.
I think I see what you are saying, but I'm not at that level yet. The two mindsets are like "writing many small definitions (and agonise over stack juggling)" and "creating a language (vocabulary + grammar) for solving the problem". The end result might sometimes be the same, but the mental process is very different. It wouldn't occur to me to write words such as your SLOT and USED. I wish I had a few years or even months to work in Forth and practice this, instead of just a few hours every now and then. Thank you for the koans to meditate on.
Looks like the link is down :/
You need a browser that supports ftp. But anyway, here's an http link with source code: http://www.softrockradio.org/pub/Programming/Forth/TinyBoot/ https://web.archive.org/web/20051023234748/http://www.tinyboot.com/tof.htm
This one is a more complicated algorithm and that's still evident in this implementation but I find this much easier to work with. Not because it's much smaller, but there's a lot less to carry around in my head. That seems to have much more to do with how you decided to split the problem rather than the specific names you choose. I might have factored -/ a little more; just providing alias's for things like 2* in the way that I defined 2a and 2m previously. These two examples also have a bit in common and while that isn't too helpful in this case it's often useful if you can factor such simplar examples together. This can help you identify words that are generally useful, which you can then tuck away and consider as part of the language. In the end what matters is whether you think this is more understandable? As an excersise you might try to copy and paste the pseudo code for the algorithm (presumably you think this is easy to understand) and see how few changes you can to make before you end up with a working solution. Hint: you might want to keep in mind that strings like *N(i)* are valid Forth words. (I'm not really suggesting you do this in general but it's good to explore new ways of solving problems) 
Thanks!
You're welcome :) 
Any progress on that request? Those details will be posted to this subreddit, right?
I don't have the experience to know if this is good Forth or not, but I think Sam Falvo's VIBE editor is interesting. It reminds me of a poem. https://www.complang.tuwien.ac.at/forth/vibe-2.1ans.fs
No, but i'd search on GitHub first: https://github.com/trending?l=forth
It was denied for now. I'll be posting a lot about it on here when we're ready but that might be a while yet.
My top one is from "Starting Forth" : WASHER WASH SPIN RINSE SPIN ; : RINSE FAUCETS OPEN TILL-FULL FAUCETS CLOSE ;
I remember that example, that is a great book! 
[ColorForth IDE driver](http://www.colorforth.com/ide.html) [Fignition Turtle Graphics implementation](http://stackoverflow.com/a/12791327)
Well, if you write C code in Forth, you get what you ask - C without variables is painful. Better approach in line with the WASHER example: : vadd-one &gt;r over @ over @ + r@ ! r&gt; ; : next-coord &gt;r &gt;r cell+ r&gt; cell+ r&gt; cell+ ; : vadd vadd-one next-coord vadd-one next-coord vadd-one drop drop drop ; If you go colorforth way and use `a`/`b` registers code will be even simpler. *sorry for uninspired word names* 
I'm not sure this is an example of great Forth code but the implementation here is very simple and easily understood, and the idea itself is beautiful; depending on the kind of problems you're working on this may help you write better Forth code. It wasn't my first choice but it's non-specific enough that I actually have permission to share it with you :). : v postpone &gt;r ' compile, postpone r&gt; ; immediate This word simply wraps the next word is a pair of &gt;r and r&gt; at compile time, temporarily exposing the rest of the stack. But more interesting than the how of this is the why. This is best explained by briefly looking at hooks and forks from the array-based programming language J. In Forth the form f g = g(f(x)) (assuming words of one argument.) Well... In J the form \ hooks (f g) x = f(x, g(x)) y (f g) x = f(y, g(x)) \ forks (f g h) x = g(f(x), h(x)) y (f g h) x = g(f(y), h(x)) This might seem pretty boring but it shows up in some interesting places (particularly when maths in involved). v and v. allow you to define words based on the fork identities above. : d v 2^ 1+ - ; \ x^2 - (y + 1) : v. postpone dup postpone v ; immediate : d v. 2^ 2* - 5 + ; \ x^2 - 2x + 5 : mean v. sum # / ; : eu1 v. cos sin i * + ; \ e^ix = cos(x) + i*sin(x) : 2@ v. @ 1+ @ ; The hooks can be written it terms of forks an the identitiy function i which simply does nothing in Forth and can simply be ommitted or imagined. I've just started exploring these ideas but I think they have a lot of promise for quickly raising the level of abstraction; think about the problem rather than the stack. It's quite common to see this pattern of &gt;r and r&gt; in Forth code and I suspect this may be an indictation that there is a hook or fork hiding in there. EDIT: A more involved example from http://evincarofautumn.blogspot.be/2012/02/why-concatenative-programming-matters.html x^2 + y^2 - |y| f = drop dup dup × swap abs rot3 dup × swap − + becomes : g v. abs ; : f v g v 2^ 2^ + - ; Once you have a name for these forms you start to see them everywhere. In this case the original expression can be seen a 3 forks -(+(2^(x), 2^(y)), abs(y)) Or in J (2^ + 2^) - abs (using the same names as above for clarity)
Interestingly all of the common combinators found in Factor can be written using v defined above. http://elasticdog.com/2008/12/beginning-factor-shufflers-and-combinators/ For clarity I use *i* as a placeholder for the identity function but as noted above this may simply be ommitted or imagined (making the fork examples even simpler.) dip 1 2 3 [ + ] dip 1 2 4 v + i i 3 4 keep 1 2 3 [ + ] keep 1 2 4 v. + i i 1 6 4 bi a [ sum ] [ length ] bi / a v. sum length / bi* a b [ first ] [ second ] b* 2array a b v first second 2array bi@ "john" "John" [ &gt;upper ] bi@ = "john" "John" v &gt;upper &gt;upper = This last one isn't strictly the same since &gt;upper has to be written twice but it has the same effect and isn't much more work, and given that this is just a another fork and you don't need to learn the difference between these substantially similar yet quite different forms, I think preferable. Especially given how simple v and v. are, and how they don't require quotations, or the associated mental or runtime overhead. EDIT: If this dupilication bugs you enough, you might define a compiling word v: : v: postpone &gt;r ' dup compile, postpone r&gt; compile, ; immediate And then write "john" "John" v: &gt;upper = But I'm not sure it's really worth the effort. I'm also doubting whether v. is really necessary. If dup were given an abreviated name like " the resulting code would be just as concise and v. wouldn't need to be defined or learned. keep 1 2 4 " v +
Interesting. I independently came up with the same word as your *v*, only with the name *under*. But I haven't explored it to the degree you have. Seems the APL family have some cool stuff.
;) my version was originally called under, before becoming just u and finally v, for its visual simalarity to a fork. There are alot of really nice ideas out there that I think we can all benefit from in one way another, if we aren't scared off by unfamilarity, which is necessary for all real learning.
Thanks, that second one was new to me. Looks nice.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Microchannel plate detector**](https://en.wikipedia.org/wiki/Microchannel%20plate%20detector): [](#sfw) --- &gt; &gt;A __micro-channel plate (MCP)__ is a planar component used for detection of particles ([electrons](https://en.wikipedia.org/wiki/Electron) or [ions](https://en.wikipedia.org/wiki/Ion)) and impinging [radiation](https://en.wikipedia.org/wiki/Radiation) ([ultraviolet](https://en.wikipedia.org/wiki/Ultraviolet) radiation and [X-rays](https://en.wikipedia.org/wiki/X-rays)). It is closely related to an [electron multiplier](https://en.wikipedia.org/wiki/Electron_multiplier), as both intensify single particles or photons by the multiplication of [electrons](https://en.wikipedia.org/wiki/Electron) via [secondary emission](https://en.wikipedia.org/wiki/Secondary_emission). However, because a microchannel plate detector has many separate channels, it can additionally provide spatial resolution. &gt;==== &gt;[**Image**](https://i.imgur.com/IQgiCxC.gif) [^(i)](https://commons.wikimedia.org/wiki/File:Mcp_schematic.gif) --- ^Interesting: [^Photomultiplier](https://en.wikipedia.org/wiki/Photomultiplier) ^| [^Electron ^multiplier](https://en.wikipedia.org/wiki/Electron_multiplier) ^| [^Night ^vision ^device](https://en.wikipedia.org/wiki/Night_vision_device) ^| [^Particle ^detector](https://en.wikipedia.org/wiki/Particle_detector) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj0uzai) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj0uzai)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
This is currently my favorite Forth on my favorite 8-bit MCU. If you want a quick example of what it looks like, check out http://toddbot.blogspot.com/2012/05/smattering-of-myforth-crc16-checksums.html 
Looks really interesting. What lib(s) did you use to draw to your screen? Would you mind posting the code to your calculator?
My own custom stuff built around Allegro 5. https://bitbucket.org/rogerlevy/forestlib https://bitbucket.org/rogerlevy/studioui https://www.allegro.cc/ I used what eventually became ForestLib to make The Lady: http://www.indiedb.com/games/the-lady You can pull the repos and try everything out on SwiftForth. EDIT: The calculator is in studio/tests. I would roll back a revision for StudioUI if stuff doesn't compile. Currently reworking a lot of backend stuff as we speak. StudioUI is a GUI engine for SwiftForth/Win32 built on ForestLib/GameBlocks, geared toward the interactive development of game development tools. You can follow ongoing development here: https://trello.com/b/7GYI7XaG/studioui 
Just finished making the big changes, you can pull the latest StudioUI and everything should work.
I am at work right now, will give it a try when I get home. I'm on a mac and usually use pforth, but will download trial version of Swift Forth to test. Thanks for the heads up.
I could install Win7 in a VM to test it I suppose. I am not a very profficient Forther but I will do my best to help out. Have you tried pforth?
That would be awesome! Knowing how well it runs in a VM wouldn't be a bad idea. Regarding pforth, no, I haven't. I selected SwiftForth after evaluating the feature lists of many systems. SwiftForth had the best combination (for my purposes) at the time. My one regret is that it isn't freeware, and therefore you can't redistribute it, but TBH I've come to learn over the years that for the most part you get what you pay for.
I have a week off from work starting friday so I'll look into Win7 swiftforth your.libs + + You are right about that, usually you get what you pay for. Regarding pforth I started using that because the source is available and it's been placed in the public domain by the author. That way I can distribute pforth itself with any software I write. I have mostly been using Jupiter Ace Forth (Forth -79) and various Fig Forth implementations. Do look into pforth if you got some time to spare. I guess I could try getti g your libs to run in pforth as well. Step by step, piece by piece.
From what I just read, pforth's inner interpreter is a giant case statement, so the performance must be pretty low. That rules it out for me. I use Forth to write the game engine and everything else, not just as a scripting language for some C++ engine. But if you ended up wanting to give a pforth port a go, just to have the option to target a multitude of platforms, by all means. I wouldn't object. I'd imagine it would be useful for compiling simple games that run at acceptable speeds. (I.E. nothing like The Lady - there's a lot going on in that one, even with it being so minimalistic.)
Not sure exactly how the inner interpreter is put together, but a giant case seems very ineffecient ^^ The author makes a statement that is was built for portability and nothing else. As I mentioned I am still at the stage where I mostly play around in Forth. I understand you need maximum performance for a game like The Lady. I assume SwiftForth is metacompiled? Maybe I should look into SwiftForth. What is a week off from work without some hacking eh?
Yeah, SwiftForth is metacompiled. System modification is something I haven't done in a long time, even though I've had a few changes I wanted to make, mostly to the IDE. Normally I just "patch" whatever I need, like the floating point wordset; that's an overlay, so it can be customized without metacompiling. SwiftForth is probably the best desktop Forth, out of what I think of as "The Big 3", SF, VFX, and iForth. It has the best docs and it is maintained regularly by people with lots of experience. They're kind of stuck in "the old way of thinking" regarding Forth, though. They have no understanding of the stuff I'm doing, but I don't think it'd be any better with any other vendor. They actually are going to include ForestLib in an update at some point. I'm sure they'd give you a paid license if they heard you were porting it. Regarding porting... As far as I know, keeping in SwiftForth, the only things required to port ForestLib are a little knowledge about the Unix API, converting a few system-dependent words, and probably building Allegro binaries for Linux and Mac - though maybe those can be downloaded somewhere. In theory everything else should just work after that. Forest's file structure is documented in the readme, should be a good guide to understanding what needs to be ported.
Check back near the end of each month for new meeting notes.
cool stuff
usefull
I had a blast playing with ColorForth a few years ago. ColorForth is just an early example of the inevitable move away from using text files to store code. We have been doing it since the dawn of programming because someone decided to do it that way and it works, but it's not the only way. We should be storing code in databases as a series of tokens, and the editor should format things for us - names should be less important (and spaces could be allowed) and the programmer shouldn't be saddled with the burden of neatly formatting his code or using some quick-key to "prettify" it with his choice of editor and formatting preferences. It should be enforced and universal (per-language). Being able to store a variable within the source code is just a nice side effect. It may be weird but it's extremely useful. It turns the source code into a kind of virtual office where you can pick up where you left off. Edit: the "StudioUI" (working name) I'm working on in SwiftForth will have a version of this. The "source code" in this case will be more like a set of nodes that load the actual source code (from text files ... *for now*), but you will be able to change variables, save the "session", and load it back later, in the same way.
It's an interesting idea, but I'm not really sold. I agree that there are much better representations for code than plain-text but after some years working in Smalltalk I feel like I know too well where mixing state into your code leads. In this context a bug in your program or some unfortunate interaction with the user or developer can put your program into an inexplicable state. And how do you get out of it? If you're lucky this will be immidately obvious and you'll never save it but once you do and you start to depend on that.... well I don't know how you get out of it. You certainly can't just reload the program (something I consider to be a great strength of Forth.) This is something the Smalltalk community didn't think about for some 30 years is struggling despirately with rigth now. Being able to snapshot a running system is very useful, in development, and for deployment and trouble shouting, but you should always be able to build a clean image (or you get stuck writing "scripts" that try to manually strip out things that hopefully aren't needed or that might cause problems in production. In short, a nightware. This is the main reason I would never want to program in Smalltallk again!) I've never used ColorForth and it's possible my understanding of these Magenta Variables isn't correct? Do you think this is a problem? How will you solve this problem in you StudioUI? 
Thanks for your comments I'll think on this. &gt; It's more fun than speculation and theorizing. It is indeed but you may go in your mind further and quicker than you can on paper. The lively nature of the magenta variables and what you can do with them seems very similar to an inspector or explorer; tools which I've certainly derived a lot of value from, but as you said, you don't need to modify the source code to get this. &gt; Magenta variables are the way they are because they serve Chuck. That makes the tradeoffs much clearer. &gt; working in a refined, minimalistic environment is a lot of fun, but I ran up to limitations that I didn't have the experience or desire to deal with. That's why I work in SwiftForth now and have been for a couple years. Would you be able to elaborate please?
&gt; It is indeed but you may go in your mind further and quicker than you can on paper. Except that if you don't test your ideas against reality, you can disconnect from it easily. The mind is surprisingly poor at modelling reality, being influenced a lot by biases (for evolutionary reasons) and much worse when built on untested theories. &gt; Would you be able to elaborate please? Sure- One big thing was I wanted several nice features that the "Big" Forths have - exception catching, floating point, (better) external function and callback support, wordlists (same as namespaces), more string handling routines ... a long list. Another thing was that I realized that I'm bad at/don't want to do "Forth system design"; I wanted to put my chips on a language that was based on proven experience - so I moved to an ANS94-compliant Forth. ANS94 since turned out to have a lot of useless cruft and a lot of slow-to-change old hands behind it insisting that it shouldn't change too much, and perhaps just as many crazies who think it should be thrown out. I also thought that going "standard" would encourage people to try out my code and maybe even help, since what people used to ask me was if my code was ANS compliant. Now, they get on my case for redefining a couple useless old words like 2+ (old one adds 2 to what's on the stack, mine adds 2 numbers to 2 numbers) and almost all conversations on comp.lang.forth devolve into quibbling and dick-swinging over why the standard sucks and should be replaced (or why it's futile), or what are the best semantics for a new version of a standard word; needless to say these discussions are extremely unproductive and make me almost regret adopting the standard. The last big thing was, since my compiler was minimalistic, there weren't enough tools to build modern games with, especially when it came to trying to implement a usable OOP extension, there was just too much backend work involved; SwiftForth has helped in that area since it has a slew of useful and relevant routines. SwiftForth also has turnkey (.EXE export) support; none of my homebrew Forths could do that. For now, I'm happy with what I've got because I have the confidence of knowing that it can make salable games, and that at least there is a lot of documentation on ANS94 out there so I don't need to teach anyone my Forth for them to use my tools. The only part that isn't ideal is SwiftForth is expensive and the evaluation version has a 3 second nag screen.
This is late, but what the hey... I wrote a game programming library and am working on a GUI framework. https://bitbucket.org/rogerlevy/forestlib https://bitbucket.org/rogerlevy/studioui 
Very nice work. Sounds like something /u/registered_just4this would enjoy. Sorry it got caught in the spam filter. Feel free to repost with some empty querystrings ???? on the end so more people can see this.
This has too much stack-juggling, but thankfully it can be made shorter, if you are multiplying small numbers where the first number is always unsigned. With a the right double-precision primitives you could easily make a 32x32 bit version. Maybe someone can figure out how to let both numbers be signed too. : +* dup 1 and if over + then 2/ ; : * 16 lshift swap 16 0 do +* loop nip ; What you effectively get out of this is a 2-word "multiplication wordset" including "multiply-step", which is from the F18 instruction set. Getting reusable pieces is the main point of factoring, clarification is second, and shortening is a happy side effect.
Yup. Why doesn't this have more upvotes??? This is awesome. I'm going to see if I can figure out how it ticks.
I found this set of slides: www.forth.org/svfig/kk/11-2011-Nelson2.pdf Also, you may be able to contact the author through this comp.lang.forth thread: https://groups.google.com/forum/#!topic/comp.lang.forth/xg51FNmEtZ8 EDIT: http://bradn123.github.io/
thank you very much&gt; edu 
Intellasys's chips are programmed in ColorForth and/or a version of PolyForth, if I recall. Is anyone not connected with the company doing any programming in either language?
Although the papers are very interesting the comments are actually quite damning...
I got my 8 bit computer from the 1980s out - BBC micro. Went to eBay, got a Forth rom. While I was there discovered that fantastically someone made an SD card adapter for the machine. It has serial too. So I have a Forth machine with Internet via serial that is on in the time it takes the monitor to come on :)
Awesome! I was thinking maybe it required a conditional but I should have known it could be done without. Actually tested: : * 16 lshift swap 15 0 do +* loop negate +* negate nip ; 
Lack of critical mass. Forth is dying.
If the forth community distributed APIs like they python community does. The old forths editors that worked on DOS are much better than today's ones and they had turnkey capability that gforth doesn't have for example.
Forth is *unpopular*. I think it needs to evolve, but if it wasn't useful, nobody would be using it, right? It is being used in tons of embedded applications (people actually make a living off of it). I'm using it to create games (real commercial ones, not ASCII towers of hanoi). I have created numerous tools in the interest of maximizing the language for my own game projects - you (or anyone else who thinks Forth is "dying") should check it out. https://bitbucket.org/rogerlevy/forestlib
The pieces do fall into place when you write your own Threaded Interpretive Language. I recommend Loeliger, I bought a second hand copy. There is a scanned pdf floating around. It has gone from the URL I found it on though. IF THEN ELSE is just messing with the Program Counter, the real understanding occurs when you can write CREATE ... DOES constructs.
&gt; Forth is unpopular. That's what I meant. It's even more obscure than Lisp these days. &gt; you (or anyone else who thinks Forth is "dying") should check it out. https://bitbucket.org/rogerlevy/forestlib The field may be dying but there are some practitioners who are doing very nice work. There might be a few niches for Forth on the lunatic fringe of minimalism (FPGA and chip design, massive parallelism).
Please, I just ask you not to use that word. Not only is it not true, but it comes across as kinda rude.
Show me a graph.
Speaking about rude. You're doing that right now. But, okay. Here http://langpop.com/ Google trends indicates that the interest is very low, and the trend is down. Of course you already knew that, being a Forth developer.
How is asking for evidence rude??
Have you used Forth 1980 onwards? Did you notice a change in use personally?
I've used Forth since around 2000. There was a bump in interest around the time I was posting a bunch of my projects but other than that interest has been mostly static far as I can tell. I've noticed a bump in interest with the appearance of GreenArrays GA144. That there are daily posts in r/forth and CLF not to mention the existence of GreenArrays is evidence enough to me that Forth is alive and well, although not really progressing which is why it's still unpopular. Purists hold it back and other attempts to update it gave up too much. EDIT: BTW I am 30, so I picked up Forth when I was pretty young.
Are you honestly offended? which word??
DOES&gt; this help? "MOVING FORTH - Part 3: Demystifying DOES&gt;" http://www.bradrodriguez.com/papers/moving3.htm
Yeah, I got a good idea, thanks.
Thanks for posting this; I'm in the middle of building a Forth-based OS and bitfields were a bitch to handle.
I guess this doesn't work as expected with parsing words.
This article looks a bit like it was written by someone who doesn't have a lot of experience with Forth.
FYI, change `shift` to `rshift`.
Awesome!
"A bad choice of data structures is punished more heavily in forth due to unnecessary stack juggling involved than in other programming languages." I find this an interesting observation.
Reminded me of my attempt at Hunt the Wumpus: http://excamera.com/sphinx/article-wumpus.html 
The [hyper–surface area of a 4-sphere](https://en.wikipedia.org/wiki/N-sphere#Volume_and_surface_area) is 2π²r³.
Hey, are you the creator of the J1 SoC? I have wanted to get the J1 working on my xc6slx9 fpga but there are some missing files in the j1demo.tar.gz tarball (uart.v as I recall). Also, the wge100 source files and verilog files are inaccessible. I know that the wge100 has a more complete forth network stack for instance. Would you mind uploading those files somewhere? Thank you!
Imagine you are reading the arguments onto a stack and it will click.
This is how I format my Forth code and I wish more of today's Forth code would do the same. : P@REL ( --PadLast) FF CR1! DATA@ REL ; : P!REL ( PadLast --) FF CR1! DATA! REL ; I've heard in both Thinking Forth and English writing class that it's important to keep relevant stuff clustered with what its relevant to. But what I like about these classic Forth formatting schemes is that segments with corresponding functionality are aligned. This goes with the principle of keeping similar functionality close together and can potentially expose a common factor to pull out into its own word. Now in your last example the : and the ; correspond which is why they are aligned.
The comments made me very upset. It seems like the only exposure people have had to FORTH is the shitty stack manipulation beginners do and not the elegance of things like COLORFORTH's 6 line IDE driver.
I use the Teensy 3.1 for Software Defined Radio (SDR) experiments and I was not aware of this until today. Seems to be a nice alternative choice to the [mecrisp-stellaris](http://mecrisp.sourceforge.net/) mk20dx256. Teensy 3.1 cforth has nice line editing features and usb-serial support [which I was working on supporting in mecrisp-stellaris](http://hub.darcs.net/pointfree/mecrisp-stellaris/browse/mk20dx256/usbotg.txt) [warning! needs factoring]. I'll continue to work on the mecrisp-stellaris mk20dx256 port because I prefer forths that do not depend on C, and also, I am the new maintainer after Mark Schweizer.
Seems to create a pictorial membrane to designate "inside" and "outside"
I know of two asynchronous microcontrollers that are in the tens of microamps range (at least for most of its operation), the GA144 and the TAM16 (AFAIK there is or was also a TAM32). &gt;The GA144 consumes 7uA@1.8VDC (typical) with all nodes idling and 540mA@1.8VDC (typical) with all nodes running. http://toddbot.blogspot.com/2012/01/apples-and-oranges-ga144-and-arm-cortex.html http://www.tiempo-ic.com/products/ip-cores/TAM16.html
&gt; What's the tool chain like erm, we are in /r/Forth :) I just push 12V onto pins and churn bytes into it :) &gt; Do you know what wakeup sources are available in the 100 nA standby mode? I should warn you, that PIC10F200 is a very basic MCU, all-in-all it has only 6 pins and 16 **bytes** of RAM. For wake-up there is one timer and wake-up on pin change. If you need more you can look into other PICs, they are notorious of low power usage (except may be PIC32 range).
&gt; erm, we are in /r/Forth : Oh yeah, I forgot that. :)
&gt;Although running Forth on them is not practical, but cross-compiling is always a possibility. Sounds like the scenario for a [3 instruction [tethered] 4th](http://pygmy.utoh.org/3ins4th.html).
Embedded Systems with limited resources, like FPGAs, microcontrollers and microprocessors. However is very hard to find books, magazines and stuffs of how forth works. Theres is no good free IDE available and good free Forth with turnkeys capabilities like the olds forth. The bests free forth systems are Win32 forth for windows and gforth for Unix. If the forth community wants the language to be relevant again, better scan old books and make it available or sell kindle copies.
uhhh.. is the source for the FPGA hidden in there somewhere? :P
win32forth is not my preference. vfx and swiftforth are much faster than win32forth and their FFI's take parameters in the correct order rather than reverse.
[RTX2010 data sheet](http://www.intersil.com/content/dam/Intersil/documents/hs-r/hs-rtx2010rh.pdf)
I wouldn't use 'v+'. I would use instead an extension of '+!'. 3 cells value /VECTOR \ bytes per VECTOR : v+! ( vsource vdest -- ; extension of '+!' , add VSOURCE to VDESTINATION ) over - swap /VECTOR bounds DO I @ over I + +! [ 1 cells ] LITERAL +LOOP drop ; If and only if is needed : v+ ( v1 v2 vsum -- ; add VECTOR1 with VECTOR2 into VECTOR-SUM ) tuck /VECTOR move v+! ; 
How do you mean limited debugging capabilities? 
What sort of debugging capability is missing? I know that Forth code is usually debugged using mostly the facilities available in the interpreter itself (these facilities can be available when tethered to embedded systems, too, which is more than you get with some of the alternatives), but if you really wanted to (and are developing on a OS hosted Forth) you can use standard tools such as GDB and Valgrind.
&gt;Does anyone have any more details on this, and or on SOD32 by L.C. Benschop? SOD32 is available here: http://lennartb.home.xs4all.nl/forth.html &gt;are there other advantages to this besides reduced memory usage? I would think relative addresses would make the compiled image more machine independent. Also, by not using absolute memory references you could move around chunks of the compiled dictionary (provided you take the dependent words with you). You could move the compiled dictionary to another storage medium such as an SD card and it would work without adjusting the addresses.
Fuck no, I'm way too stupid. Also check out: http://jococo.github.io/sallied-forth/
/u/johntheoak, it looks like [another redditor banned your account](http://www.reddit.com/r/spam/comments/2hsrtf/overview_for_johntheoak/). You'll need to create a fresh one.
http://www.ioccc.org/1992/buzzard.2.README http://www.ioccc.org/1992/
the original poster mentioned that there is no 'rshift' in his set of words yet, but '2*' and 'and' are available. So here is my solution that i like because i understand it ;-) It works in gforth where values &lt;&gt; 0 are interpreted as TRUE. : bitmul ( b a -- m ) 1 swap 0 ( stack: b m=1 a s=0 ) begin 2over dup ( stack: b m a s b m m ) while ( while m &gt; 0 ) and if over + then ( b and m &gt; 0 ? s+=a; stack: b m a s ) rot 2* rot 2* rot ( m*=2; a*=2 ) repeat 2drop 2nip nip ; For some coincidence it works also for negative numbers.
thanks for the post, but stack abuse alert. when a word gets that complicated for me, you might as well use locals or throwaway variables. i thought of a way to do the 16 lshift without lshift, if you have h! . just store to the high halfcell of a variable and fetch. this could be factored into a word ... 16&lt;&lt; or something.
thank you for your reply. yes i agree, there are to many values on the stack. maybe this one is better? : 2step ( a b s -- 2*a b/2 s) rot 2* rot 2/ rot ; : bitadd ( a b s -- a b s'= [1 and b ? s+a : s] ) swap dup 1 and if &gt;r over + r&gt; then swap ; : b* ( a b -- a*b ) 0 begin over while bitadd 2step repeat nip nip ;
 That's great, but I've really warmed up to stack comments, and something I call phrasing (not sure if that's the official term or not). I put 2 spaces between words that feel groupable. Here's how I'd break up the definition: : { ( - ) da @ HERE H' 2@ h ! dA ! H' 2! ; I can more easily see that there are no obvious parameters now. Seems it copies the address of a place in the dictionary and updates (or rather, swaps) some pointers. Seems that h and HERE, and dA and da are related. Does da stand for dictionary address? Edit: Oh, I get it now. It just swaps some pointers. It's not a metacompiler, it's part of one. It just switches targets. Is that it?
&gt; It just switches targets Yep, instead of using lots of words like `C,-T` `,-T` `C@-T` `C!-T` `ALLOT-T` etc etc. Chuck Moore factored out the bulk of the metacompilation process (dictionary switching) into that word. (Another thing he did was eliminate the problem of `IMMEDIATE` words). It's seems like there's a number of different ways to do metacompilation. A book I have, *Embedded Controller Forth for the 8051 Family* describes metacompilation as an emulation process in which the host must also be be able to run words out of the target image while building up the target image in a series of [meta-system transitions](http://en.wikipedia.org/wiki/Metasystem_transition). I wonder how this could handle cross-compilation between several (more than 2) different non-equivalent hardware systems. Maybe openfirmware inspired device trees could be of use in the (cross|meta)compilation process. It's convenient to use very few primitives when metacompiling, but for a faster system the software would have to take advantage of the special hardware features available. There would need to be a lexicon for describing what's in common and what needs to be emulated (written in software, or implemented differently).
From my perspective, FORTH is an extremely efficient scripting language. The reason why I say that, is because what are usually called control structures in other languages, are about the only things it's simple to write in FORTH. The thing about control structures though, is that you're going to want some primitives (functions, other executable programs, etc) to work with, if you actually want to do anything useful. There's a couple of problems here:- * Assembly is generally the only language which is lower level than FORTH. * Writing binaries in assembly is generally an extremely painful experience, which is why no one does it, and is also the reason why C was developed. * As an operating system, FORTH is not multi-user, generally speaking. * FORTH has no real kernel as such. The most it has is a means of executing words. In that sense, using it as an operating system makes it very similar to DOS. * Even if you are happy using nothing but FORTH, you are still going to want certain services for interacting with files and the rest of the machine. At minimum, that means open, close, read, write, and exec. You can write these as includes or FORTH words if you want, but aside from these services, there are other monitoring functions that a constantly running kernel is useful for. Reliable time sharing, PID allocation, and secure multi-user support are all good things. * If you want to write say, an mp3 player in FORTH, then prepare yourself for a massive amount of pain. You will have to write drivers for a sound card, and then you will have to implement the mp3 algorithm. You will also have to do so directly from raw numbers; writing all of your primitives/support functions first, before you get to write the actual program itself. FORTH is, however, absolutely awesome as a scripting/control structure language. If I've already got an operating system, and other binaries or functions which connect me to the hardware I want to play with, then I can execute tighter/faster loops in FORTH than virtually any other language I know of. Most people however don't care about hardware efficiency; they just use JavaScript and accept its' bloated disgustingness, because it is convenient to do so.
At the moment I've been studying how [CMForth](http://www.neverslow.com/forth/wiki.php/Forth/CMForthRtx2000) works [without IMMEDIATE and STATE](http://computer-programming-forum.com/22-forth/8837e323016a8a52.htm). Anyone know more about CMForth's "dual-threaded dictionary" or its "optimizing compiler" ? --------- [mecrisp](http://mecrisp.sourceforge.net/glossary.htm) has `inline,` which allows for inlining/expanding a word for speed. Seems to be an alternative to speeding up a word by reimplementing it in assembly? -------- I've been going back into Forth Dimensions I've been searching for ["CASE Contest"](https://archive.org/details/Forth_Dimension_Volume_02_Number_3) and I've found some extensions beyond the usual CASE OF .... ENDOF .... ENDCASE which have been useful.
http://timothylottes.blogspot.com/2014/08/vintage-programming.html
There's a Node.js hosted Forth like stack based language. https://github.com/lawless-m/North It uses a JavaScript numerically addressed dictionary as memory and any JavaScript value can be stored in a cell. Although I haven't tried it, it will be able to run on the JVM using [Nodyn](http://nodyn.io/) and [DynJS](http://dynjs.org/)
Interesting! Thanks for sharing. Though I don't know JS, this made me feel good. It means that I'm not the only one thinking that for Forth to continue its glory, it must adapt.
It's a little like [Forth Haikus](http://forthsalon.appspot.com/), but as a twitter bot, and thus with the pressure for 140 characters or less. It could also end up being more social, by running through twitter and all. Fun idea!
EXCELLENT article! I really love using these word name patterns. It makes Forth easy to read in small problem domains. 
If you like source code, read [the Plan 9 source code](http://plan9.bell-labs.com/sources/plan9/) From the fortunes file &gt; A Professor of Computer Science gave a paper on how he uses Linux to teach his undergraduates about operating systems. Someone in the audience asked why use Linux rather than Plan 9?' and the professor answered:Plan 9 looks like it was written by experts; Linux looks like something my students could aspire to write'.
Whoever wrote that has a lucrative career in BrainF*ck waiting for him.
Joke's on you. The authors (Roger Hui and Ken Iverson) of that code are world-renowned for their software and language design. 
The fact that it's written in a different style than you are used to doesn't make it lousy.
It's just terse for the sake of seeing how terse it can be. Unimpressed. You must like regex.
This kind of coding is for people who code and only code. I'm of the opinion that a balance should be struck between readability by using white-space and english-language names, and efficiency, e.g. using as few "instructions" as needed, and overall terseness (# of bytes). This compacted/mathematical style of coding seems to concentrate entirely on the last one, ignoring the rest. Code should be to some degree self-documenting. If you need, I can make sound arguments supporting why code should hit all those marks as opposed to just one.
The C source code of the interpreter follows a very rigid structure. All functions use the same variable names for the same things; once you got used to the conventions it's very easy to understand. This style goes back to Arthur Whitney. Here is an [explanation](http://jsoftware.com/pipermail/source/2013-December/000525.html) of one of the functions in the source code by its author, Roger Hui. You might want to read it to understand what the advantage of this style is.
And most importantly, the interpreter follows the same guiding principles I laid out in the previous post.
That was absolutely ridiculous. Why did he name the files with abbreviations? What benefit does that have? "Don't use formatters on this because it will destroy the micro-structure"? It's got to be a joke, but it's not. All I see is an attempt to stuff as much semantic meaning into as little space as possible, as a kind of trick, like acrobatics. But the grammar of C prevents easy reading anyway because of all the mandatory punctuation. You might as well just stick to a familiar formatting and comment blocks of logic with simple hints. For all that saved space, the guy still has to write entire articles for anyone else to understand what's going on. If he comes back to it 10 years later, assuming he isn't the kind of programmer that obsesses over a single program for his whole life, he'll have to re-learn what all those little mnemonics mean. So ... what's it for, exactly?
I've got a number of my own [Forth] projects in darcs repos here: http://hub.darcs.net/pointfree
Bad link
Sorry, I'll resubmit this one: https://github.com/ForthHub
Purpose: build a network of Forth enthusiasts among GitHub users. Let me know, and I'll send you an invitation.
Heh, cool! I guess once you opt for postfix notation you'd have a hard time to not look like forth. At least as long as you only do numbers and operands.
I'd love to have some sort of APL / Forth combination. I imagine this to be a very cool thing.
Although it's not quite that yet I have been building a Forthlike in Javascript / Node.js https://github.com/lawless-m/North/ It uses any valid Javascript value instead of bytes I'm a fan of APL so I will be doing related stuff. I'm at Uni atm. (not doing CS) so I'm a it pushed for time !
:) I've been keeping it under wraps really until it I got the core idea up and running. There is plenty of scope for improvement, I've gone for "get it working first and then iterate" 
I did many of these exercises when I reduced my Forth to 12 primitives (plus four I/O words). Mostly for fun. https://github.com/larsbrinkhoff/lbForth/blob/master/kernel.fth
My PR just adds metadata to make GitHub detect the Forth files.
[Matrix Multiplication example ported to arrayForth](http://primarycolorforth.blogspot.com/2010/03/matrix-multiplication-example-ported-to.html) [SEAForth Matrix Multiplication Example update 1](http://primarycolorforth.blogspot.com/2008/01/seaforth-matrix-multiplication-example.html) [SEAForth matrix multiplication example](http://primarycolorforth.blogspot.com/2009/01/seaforth-matrix-multiplication-example.html)
I love Chuck to death since he saved my life as a programmer (corny but true!) but his stance on stack effects is just batty! Yes, if you never have to show your 100 lines of code to anyone else, you probably don't need the diagrams. But that's not the real world. Everything else is worth some discussion. For instance, wrongly-used locals do have drawbacks - factoring becomes more complicated. "Global" variables are really local to the program. In Forth, redefinition in the same program image is permitted, and programming in "phases" can be made to work (especially with vocabularies) so you can use global variables with less fear than in other languages. You can regard entire programs (wordsets) as "objects".
Also, the comment on stack depth and nesting is interesting. This is my opinion: If you can properly manage it, longer parameter lists sometimes can't be avoided. For instance imagine a word that would save a block of data to a file. You need 4 parameters. This is skirting the limit but that's such a common thing to do in Windows programming and not unmanageable. It's important to remember that Chuck lives in the world of chip design and has never written a desktop app because he's in the enviable position of not needing to have any faith in WinuxOS to do what he does. So a normal person could get maybe 50-80% of the code cleanliness he gets every day which will make some of the things he says sound like he's never actually written a program.
Cool stuff. I thought about this for only a second but in a "fat Forth" type environment (i.e. a traditional 16/32/64-bit arch.) seems like all you need to implement a matrix mult is something like TH. Could be wrong, never wrote a matrix mult. : TH cells + ; Then you pass the addresses of 2 (or 3) matrices in, save them in locals or "glocals" and have at it. Since the mult operation is unlikely to ever call anything else that needs access to the matrices (not re-entrant) it's okay.
That's the whole idea of Chuck's teaching - you only need 4 parameters if you have a generic "save-a-block-to-a-file" word. Don't do that! Write an ad hoc "save-what-i-need" word which takes zero parameters and writes to a one single specific file from a one hardcoded fixed-sized buffer.
He says a lot of stuff that's rooted in the land of ideals without disclaimers. That's where he lives.
Also I think he does put diagrams, but in shadow blocks. If I remember from looking at the GreenArrays/ColorForth source.
Unless I missed something, looking at the source it appears to be DIY assembler where you're writing hex to construct the mnemonics by yourself. It only appears to support what mnemonics are needed for eforth itself and leaves the rest up to the user (even most x86 instructions are missing). Thanks for looking, though. I appreciate it!
Yeah that's how I see it too. They see some familiar landscape and fool themselves into believing they actually understand what's going on. It's somewhat similar to an aversion to mathematics. One gets used to reading novels quickly because most of the words are superfluous, and it's frustrating for many having to slow down and unpack dense mathematical texts. It seems to throw off their rhythm in a way that is difficult to recover from - mainly because they can't see that even though they're going a bit slower, they're absorbing as much or more information than they would have without the wheat; artifacts they don't realize they're ignoring anyway for the sake of pacing.
I can't answer all of these questions because I'm not a forth expert, but so far assembly has been essential to understanding forth for me. That could be because I had some knowledge of assembly beforehand and because not all of the forth systems I used have documentation and in some cases they do but it's not in english. Being able to `see` a word helps understand what is going on underneath. Ex: &gt;see rot 5524A8 8B5500 MOV EDX , 0 [EBP] 5524AB 894500 MOV 0 [EBP] , EAX 5524AE 8B4504 MOV EAX , 4 [EBP] 5524B1 895504 MOV 4 [EBP] , EDX 5524B4 C3 RET NEAR What has also been useful for me is the `dump` word. It's a good way to just check out memory and make sure your modifications to memory are doing what you think they are. Since forth is typeless, it becomes very easy to forget about how the data is laid out, especially when you're implementing data structures. So in that way it feels like a really nice debugger/assembler. Unfortunately I can't find an inline assembler for x64 which would make it even nicer. I have a little experience reverse engineering. If you want to learn more about that, try /r/ReverseEngineering And I might be wrong but I thought `forget` was deprecated. I use SP-forth and that has `marker` which seems better for creating a kid of callable restore point rather than simply forgetting single words. IIRC `forget` had some problems with leaving holes in the dictionary causing fragmentation and in certain circumstances could also cause crashes calling a word that no longer exists, but I've only heard about this and have never tried it. *Starting Forth* even mentions it (and gforth has it, apparently): &gt;Some Forths do not have FORGET. In that case you need to plan the forgetting in advance, e.g.: &gt;MARKER -work &gt;defines the null definition -work to mark the current system state for you. When you execute -work at some later time, the system state is restored to that in effect when -work was defined. In particular, all words defined after the marker word -work are completely removed from the dictionary. http://www.forth.com/starting-forth/sf3/sf3.html 
Nice, I'll have to try those next time I mess with openfirmware.
Thanks for the information about FORGET!
JonesFORTH is a bit curious in that it sticks to raw assembly up until when it basically has a complete minimal Forth interpreter running, complete with integer parsing and everything. Many Forths start with a very minimal core of primitives written in assembly and do all the rest in Forth. One exercise to try with JonesFORTH is replacing the higher levels of the assembly interpreter with Forth code. Since you're still building the interpreter at this point, you can't type actual Forth source in, but you can input Forth bytecode to the assembler. JonesFORTH even has the `defword` macro for doing exactly this, but for some reason it makes very little use of it.
Here's the instructions http://www.amazon.co.uk/Threaded-Interpretive-Languages-R-G-Loeliger/dp/007038360X You can find it as a pdf online with google foo
&gt; Somebody needs to write something like JonesForth for metacompilation. Looks like I'll have to take a shot at it. That would be appreciated. I would like to see use of FORTH become a lot more common. If we can somehow tame the assembly learning curve, I think that will help a lot of people.
This is actually really interesting and something I might try out in my code. An interesting way of factoring common stack juggling patterns. 
Oof... I think that the new conditionals are an unfortunate design decision, though.
I found the paste serendipitously when looking for [S/K/ID: Combinators in Forth [PDF]](http://soton.mpeforth.com/flag/jfar/vol4/no4/article6.pdf).
Do not write a Forth implementation if you want to learn _how to program in Forth_. Really. I see so many people writing their own toy Forth, and it doesn't seem to make them good Forth programmers. I was one of them myself. The exception would be if you wrote your Forth in Forth. That's an amazing learning experience.
https://projecteuler.net/
write the same programs that did in other languages. 
Write [Forth Haiku demos](https://forthsalon.appspot.com/). Build a mesh network of AVR microcontrollers [with NRF24L01+ radios](http://sourceforge.net/p/amforth/community/HEAD/tree/nRF24L01+/). Get a Forth remote forth prompt between AVR's over the nRF24L01+ radio link by [redirecting I/O](http://amforth.sourceforge.net/TG/recipes/Redirect-IO.html). [AmForth](http://amforth.sourceforge.net/) is great.
I've quite enjoyed writing text editors in Forth
Is the source for this publicly available? I'm trying to decide on a good intro to programming for my kids and I'd love to check this out.
Yes but there's no manual or proper website yet. It's stable and partially documented with comments. https://bitbucket.org/rogerlevy/newbase https://bitbucket.org/rogerlevy/geode
Cool, thanks!
Sure - if you need anything get in touch. Also, quick tip. LOCATE WHERE and EDIT are your friends. Really - without a nice IDE like Visual Studio those tools are indispensable for figuring out and playing with a system.
archived links for RETRO articles http://web.archive.org/web/20061011053009/http://tom.bespin.org/src/retro/retro.conclusions.txt http://web.archive.org/web/20061011053005/http://tom.bespin.org/src/retro/retro.addendum.txt
It's "neat" by making the body of conditional structures a parameter - though it's already easily accomplished with ['] and EXECUTE (and the nebulous "code block" which has no agreed-on syntax) - but it's dangerous because it encourages complexity. Every time you write a conditional you'll be tempted to find a reason to make the clauses one or more parameter(s).
That's really cool! Do you still have the source code for this anywhere?
Have you tried running it through an emulator?
There is a tool called "praxis" which includes a Forth interpreter that can communicate with midi. https://github.com/createuniverses/praxis
Sounds vaguely like "Hierarchical Music Specification Language" https://github.com/philburk/hmsl
I was just thinking it could be an inspiration to somebody wanting to recreate the tool for a modern system :)
The Atari ST emulators I've tried don't include MIDI support.
Thanks for the link. Looks promising.
Best username ever.
Some things came together. First I really like the PDP-11 architecture and low level coding in general (I wrote a PDP-11 [emulator](https://bitbucket.org/aap_/pdp911) for plan 9). And since PDP-11 machine code is so easy to read and write I thought I wouldn't need an assembler (although keeping track of memory addresses can be annoying). I also wanted to get into forth a bit and have something to present on the [vcfb 2015](http://vcfb.de/2015/). The plan is to also write a forth for PDP-10 since Jörg will be there again with his cool [KI10 frontpanel](http://blinkenbone.com/projects/virtual-pdp-10-ki10-panel-on-simh). I don't have much experience with the PDP-10 yet (apart from writing a hello world program and hacking some KI10 stuff into simh for the frontpanel) but I saw you have some PDP-10 stuff yourself on github. Basically I'm planning to write forths for some platforms to have something useful to write and to have fun. And my B compiler also wants to be ported to the PDP-10 :D
Thanks!
You should donate it to the [Internet Archive](https://archive.org/details/texts&amp;tab=about). They can scan it and make it available for everyone.
[Floating Away with AmForth](http://www.physics.wisc.edu/~lmaurer/projects/FloatingAway/FloatingAway.html) is a guide that I quite like. The author provides an AVR board design, and instructions for flashing AmForth to the board and talking to it via a terminal program. From there, you could try some examples from the book Starting Forth. AmForth also comes with some example Forth programs, and the linked article's floating-point math routines could also be good to look at. I also found that you could learn a lot just by studying the assembler source for AmForth's built-in words.
Thanks for the link. It looks promising!
You want to use a crosscompiler? I wouldn't, the whole point of Forth is that you can have a complete environment in 2 kBytes http://www.ultratechnology.com/mmeta.html and you could develop incrementally, interactively via a serial console. I'm not an embedded developer. I'm only interested in Forth in context of hardware stack CPUs, minimalism and bootstrap http://www.excamera.com/sphinx/fpga-j1.html . My environments were MVP-Forth on the Amiga, F-PC on DOS, Novix 4016 (with Ting's Footsteps in an Empty Valley). I was eyeing MuP21/F21 and then GreenArrays GA144 but realistically I wouldn't have the time or money to spend on just a yet another hobby. 
I think this is a very interesting approach. I don't know whether this is Forth; it's certainly not the traditional Forth but it does appear to have much the same character. A thought occurs: you should be able to do a two instruction Forth, since if you can send code to the device (XC!), and then call into that code (XCALL), you could define XC@ after the fact, and call that to read the memory. Does that make sense?
But one less instruction would be built-in. The "Forth" described in the article is just as extensible. &gt; It is extensible and even the main loop can be extended to test for codes in addition to 01, 02, and 03 Thus if it can be said that this is a 3-instruction Forth because it starts by defining 3 instructions, and you can start by defining 2-instructions and get the same effect, I'd call that a 2-instruction Forth.
I guess a crosscompiler isn't recommended then haha. I guess the normal Forth embedded programmer uses a serial terminal to communicate with the forth environment on the microcontroller. The "Floating Away with AmForth" link below has a video on the first page of the guy using something like this. He uses the command &gt; 3 4 + . which i believe pushes 3 and 4 onto the stack and adds them in typical RPN notation. This all makes sense, but how is the environment on the microcontroller executing this? Is it compiled each time or interpreted, or am I just not truly getting how Forth works? Lol I appreciate you bearing with me with all my incessant questions! Did you personally do the J1 Forth CPU you linked to? That is pretty cool, but I'm trying to fully understand some of the advantages something like this would have. I guess register based CPU's are faster, but stack based ones use lower power and have less explicit code to manage (maybe I'm still thinking microcontroller).
I personally wouldn't use this approach, and compile Forth to C, but I can see a few advantages to it. * If there's a C compiler for a platform your Forth will run on that platform * C compilers today do a massive amount of optimization (I'm not a fan of optimizing compilers but you get one for free here.) * The source is surprisingly readable for a translation and might make it easier to integrate Forth into a project (naturally there's nothing stopping you from just calling C functions, so if you're running hosted you've got easy access to the system-provided libraries... often without much or any stack juggling...99% of everything in written in C or has a C interface and there are situations where it's useful to be able to talk to the world.) It doesn't go into the engine here but he's using a general source-to-source translator/translation approach, which can do more than just translate to C. * It's an interesting approach to meta-compilation (one that isn't usually applied to Forth but clearly can be) It would be trivial to change it from C to Java etc. etc. etc.
for example : &gt; : square dup mul end ; define-function firstly &gt; : square dup mul end ; will push a string of "square dup mul end" into argument-stack then &gt; define-function will take the string as argument and compile a function into memory (the dictionary) accordingly this allows me to define different type of things into dictionary like variable, macro, exception, and so on just with : &gt; define-variable &gt; define-macro (no using now) &gt; define-exception 
Going old-school here, for a moment... you could connect a [Jupiter Ace](http://en.wikipedia.org/wiki/Jupiter_Ace) to a TV or projector and live-code in Forth, right out of the box. The machine instant boots to a Forth prompt. :) Nice little little Z80 CPU and redefinable character-cell B&amp;W graphics. [-pic-](http://oldcomputers.net/pics/jupiter-ace.jpg) If you believe art or performance is fuelled by constraints, this could be an option. Good luck!
Interactive, visual Forth programming online: http://forthsalon.appspot.com/
[Impressive!](http://forthsalon.appspot.com/haiku-view/ahBzfmZvcnRoc2Fsb24taHJkcg0LEgVIYWlrdRjG_xQM) But it's purely generative - no possibility for interaction. Very inspirational though!
:r4 is not iterative, but graphics like forth https://github.com/phreda4/reda4
Just tried it out, runs like a charm. Really nice work you have there! Will definitely play around with this a bit :)
Exactly
&gt; They should translate built-in forth words to direct code, not function calls. Save function calls for code that is user-defined. The problem with that approach is that you could define your normally built-in words in terms of just three built-ins: `fetch`, `store`, and `call`. -- The advantage of doing things this way is that when bootstrapping you only need these three and then you simply execute your definitions (of the normally built-ins) to populate those words. (This [Reddit post](http://www.reddit.com/r/Forth/comments/3286z0/a_3instruction_forth_for_embedded_systems_work/) links an article showing how this is done in 66 bytes for the MC68HC11.)
&gt; a} How much do I need to know about assembly? Zero. Don't believe me? Here's a [toy FORTH written in Ada](https://github.com/OneWingedShark/Forth). (With a little experimentation about adding types into the language, but that's inessential.) -- The files you'd be interested in are `forth-vm-default_words.adb` and `forth-vm-functions.adb` which contain, respectively, adding built-in words to the dictionary and the definitions of those words (in Ada). &gt; b} While I've got JonesFORTH as mentioned, does anyone know of another reference for how to write certain FORTH words? The comment [here](http://www.reddit.com/r/Forth/comments/2x69e4/retro_programming_perverse_code_deviant_forth_an/coxlx2l) is a guy that reduced everything to 16 built-in words. &gt; c} Does anyone here know much about how to reverse engineer software? Not exactly my area of interest. You might get some good knowledge in `#Forth` in IRC-chat, or maybe a couple of the emulator/retro-console groups.
I do NOT use the define-macro to define global macro now instead I designed a syntax-stack and many rule-set syntax-stack is for switching syntax rule-sets are for add and sub syntax dynamicly the interface of rule-sets is as following :: &gt; 1. (add-rule) &gt; add a rule into rule-set &gt; 2. (sub-rule) &gt; try to sub a rule from rule-set &gt; once a time &gt; if can not find the rule in the rule-set &gt; do nothing &gt; 4. (find-rule) &gt; find a function from a word 
Very cool. Is the interpreter/simulator available for exploration? That would make it easier to understand the ISA and its unique properties.
I'm the author of :Firth. I wrote a pretty detailed blog article about the motivations and some design aspects of the project. If you want to play with a new little toy, I'd love any (constructive!) feedback, bug reports, pull requests, etc. http://blog.ionoclast.com/2015/05/firth-pre-alpha-1-a-forth-like-language-for-dsl-creation/
I don't know if it is appropriate to post another comment. Anyhow, I have uploaded the current state of my documentation.
Nice to see this show up again. I’m happy to answer any questions. I’m also the mod at /r/concatenative, which is currently rather quiet, but I’ve got some articles and software in the pipeline and hope to stir up some more activity soon. If you’re interested in the concatenative paradigm beyond forth, I encourage you to subscribe there.
Useful set of implementation words here - I am putting together J1 Forth right now, so these are of interest. I do not see a license in there... 
Would GPL be ok?
BSD is preferable, because that is the license of J1 Forth
I prefer GPLv3+'d code because it tends to be more complete and fleshed out (among other reasons). /u/beckman101, the revised BSD license _is_ GPL compatible. https://www.gnu.org/licenses/gpl-faq.html#OrigBSD
Actual page describing the language itself seems to be gone -- were you just referencing the vast trollfest in the LtU comments? ; - )
----------------------------- sorry, I should explain more instead of just post an old link ----------------------------- reading the fist few comments about quadratic-formula I really think named local variable is important for Forth-like language and I know there are many ways to implement named local variable in Forth-like language so, when introducing a Forth-like language to new comers we should emphasize this point ----------------------------- (the following arguments comes from the LtU comments) ----------------------------- quadratic-formula in math-like syntax (limited by ASCII) -b +/- sqrt(b^2 - 4 * a * c) ----------------------------- 2 * a ----------------------------- quadratic-formula in scheme (define quadratic-formula (lambda (a b c) (let ([minusb (- 0 b)] [radical (sqrt (- (* b b) (* 4 ( * a c))))] [divisor (* 2 a)] ) let ([root1 (/ (+ minusb radical) divisor)] [root2 (/ (- minusb radical) divisor)]) (cons root1 root2))))) ----------------------------- quadratic-formula in prefix notation quadratic-formula(a, b, c) def= (root1, root2) where minusb = - 0 b radical = sqrt (- (* b b) (* 4 (* a c)))) divisor = * 2 a root1 = / (+ minusb radical) divisor root2 = / (- minusb radical) divisor ----------------------------- quadratic-formula in joy (without named local variable) quadratic-2 == # a b c =&gt; [root1 root2 ] [ [ [ pop pop 2 * ] # divisor [ pop 0 swap - ] # minusb [ swap dup * rollup * 4 * - sqrt ] ] # radical [i] map ] ternary i [ [ [ + swap / ] # root1 [ - swap / ] ] # root2 [i] map ] ternary. ----------------------------- quadratic-formula in cicada-nymph : quadratic-formula &lt;&lt; a, b, c -- root1, root2 &gt;&gt; &gt;:c &gt;:b &gt;:a :b 2 power :a :c 4 mul mul sub square-root &gt;:radical 2 :a mul &gt;:divisor :b negate :radical sub :divisor div &lt;&lt; root1 &gt;&gt; :b negate :radical add :divisor div &lt;&lt; root2 &gt;&gt; end ; define-function ----------------------------- 
You always can write it like this: : quadratic radical divisor root+ root- ; 
I still feel the need of named local variable I will go to learn more about Forth and see if I will change my view 
It's tempting to try to do too much on the stack; a lot can be done without needing them but making use of variables when appropriate is a must in my opinion. You don't need local variable in Forth because variables in Forth aren't global [0] variable a variable b variable c \ creates a context where "a", "b" and "c" are available. \ you can *treat* them as local. : quadratic c ! b ! a ! b @ 2 ^ 4 a @ * c @ * - sqrt ... ; variable a \ creates a context where "a" refers to a new variable. \ the previous definition of "a" is hidden. \ "b" and "c" are available. \ you can *treat* them as shared (in the larger context.) : something ... ; This might be frowned upon by some but when it comes to implementing quick mathsy stuff this approach may be preferable, just be aware of the tradeoff you're making. After all - Forth isn't about the stack, it's about the words. The stacks are only there to support them. [0] This applies to names in general. You actually have quite a lot of control over scope.
The *method* is perfectly valid for recursive functions; you're right, this particular, non-recursive example, doesn't show this. If you want to do this with recursive functions you need to use a stack, or if practical, use a tail-recursive version (or use a more traditional iterative construct instead). Happily you have a stack already, so all that remains to be done is to push the current values of the variable on the stack before making the call. Then you can pull them off after the call if necessary. : recursive-function ... a @ b @ c @ ... recursive-function ... c ! b ! a ! ... ; NOTE: naturally you'll want to tuck these values away where they wont get in the way of your inputs. How best to do that depends on context (as with everything in programming Forth) The purpose of using names here is to provide a more obvious mapping between the problem and the solution, but allowing direct access avoids the stack shuffling, so you can just write the word (in a relatively straight-forward and clear way, independent of your experience) and move onto the larger problem. If it bugs you too much you can always factor it out. Maybe something like this. : recursive-function ... { \ store the values per your definition of "{" recursive-function } \ load the values per your definition of "}" ; or, with a marginally more work : recursive-function ... recurse-with-context ... ; If you find the names I've chosen here annoying you can use your own names. The important part is the idea not the example :-). I'm not saying this is the only way to achieve this end, but it's simple and effective, and I've had to do this kind of thing so infrequently in my experience that I see no value in introducing syntactic support for it. EDIT: As an example consider that Factor's standard library is very large (the whole system is very large!). Naturally the library goes to the hassle of providing local variables (along with the kitchen sink!), for the rare case that they're useful, but the Factor project has reported that they were used in only 18 words in their very large code base. These *mathsy things* are often held up as [unsolvable] problems for concatenative languages, but as you've seen, there are multiple ways of tackling them in such languages. In practice most code isn't like this, but when it is, it can be made very clear and easily understandable, with a little thought/practice. Or if thought is at a premium, you can just use variables (you can always come back later when you've thought about how to structure the problem better). If you do want syntax for local variable though, you can just add that as a library (if you're using something like gforth you might find that this has already been done). Making the user opt-in means that they [hopefully] wont just use a feature because it's available, and ignore all of the costs that come with it. Personal preference. YMMV NOTE: You can of course use any in-memory structure you like to provide the storage during recursion and you don't necessarily *need* variables.
after I implement named local variable I use them very intensively http://the-little-language-designer.github.io/cicada-nymph/core/tangled/show-all.html I still need to learn more from Forth because I found that when I am able to use named local variable in a very elegant way [elegant in my view] I tend to write very big functions [as you can see from the page about] 
Have you advertised this effort somewhere else ? /r/emacs ? HN ? Google+ ? Twitter ? Maybe you don't want too much people around yet. Nice to see anyway.
it is Tomasz Grysztar's flat assembler http://flatassembler.net/ https://github.com/the-little-language-designer/fasm-linux 
What do they do on platforms like OS X? I didn't know that. Thanks for the info.
No, nowhere. Because it still very much in its infancy.
What is meant by "programmability", in this context?
I was not aware of its existence.
We could start by porting over some surviving content from http://web.archive.org/web/*/forthfreak.net to our wiki Complete list of surviving URLs: http://web.archive.org/web/*/http://www.forthfreak.net* complete archive of all forthfreak wiki pages, plain ASCII, can still be downloaded from http://forthfreak.net/ForthFreakWikiAllInOne.tgz 
hook me up with permissions then. :)
I am not a MODERATOR of r/forth see here : http://www.reddit.com/r/Forth/comments/3679n1/should_we_open_the_rforthwiki_to_every_one/ pointfree[M] said : &gt; I've enabled editing for all users. Try now? send a massage to him, if you still can not edit
Ah. Fair enough. I guess I've pretty much just been lurking here all this time. I'm active on the IRC channel. :)
TL;DR : GOOD FAST SMALL ;
This in intriguing enough that I'd like to try it out. But when I google "machine forth," pretty much all I find is [this short description](http://c2.com/cgi/wiki?MachineForth). There doesn't appear to be code that I can download to my laptop and use, or any real documentation. Am I just missing it? It'd be a shame if nobody bothered to take such a simple but powerful system and put it in a form that could be used on a standard intel machine.
The ANSI Forth is nice for exactly that purpose: bootstrapping Forths but shouldnt be end all for all Forths.
----------------------------------- an API of reddit http://www.reddit.com/dev/api#POST_api_wiki_edit I will try to use it in the repo ----------------------------------- and I also see this https://github.com/jperson/cl-reddit maybe larsbrinkhoff can help on this :)
some people like code formatting because 1. they think formatted code [or any kind of text] is easier to read some people dislike code formatting because 1. Chuck Moore has lately been known to use no formatting at all "the worst is the best" 2. they think formatting is for sissies 3. their text editor do not have good support to format code 4. their want to save spaces for the machine, willing to waste some human time when reading 
&gt; Chuck Moore has lately been known to use no formatting at all I do most of my day to day Forthing in a Machine Forth/colorForth inspired language with next to no formatting. I'm not sure I would want to do this in another Forth but I haven't missed having formatted code in this system. Not having to think about formatting code to make it readable without loosing any readability is wonderful (not unlike working in Lisp with a pretty printer that perfectly matches your preferences - you just don't think about formatting). At the same time there is information that's naturally conveyed by formatting and we don't do that either... so... trade-off. If it made code hard(er) to read I would probably push to change it. I'm a bit of a sissie that way ;-)
Actually, I'm fairly anal about code formatting. I see the point of saving space in a cramped environment, though. It's not hard to write a program that will "unformat" Forth code to save bytes. I don't see any good reason to write unformatted code.
 &gt; dlyund said : "Merge Dialects into Implementations. It's unclear what distiction is being made, given the variety inherent among Forths." one way to decide a program is an implementation of the forth language, or an implementation of a forth dialect. is to see how the author of the program declare it as. in http://www.colorforth.com/ the author said : &gt; colorForth &gt; A dialect of Forth that uses color to replace punctuation 
What makes, say eForth, an implementation of Forth rather than a dialect? It's a normal Forth in that it's not standard compliant and the implementation is naturally different from other Forths, and it has its own set of words etc... ignoring the name, eForth feels like Forth and anyone familiar with Forth would probably find it approachable. But the same can be said of most Forths (hence the example), including colorForth. [From the Wikipedia definition of dialects](http://en.wikipedia.org/wiki/Dialect_%28computing%29), which is oddly appropriate here. "A dialect of a programming language or a data exchange language is a (relatively small) variation or extension of the language that does not change its intrinsic nature. With languages such as Scheme and Forth, standards may be considered insufficient, inadequate or illegitimate by implementors, so often they will deviate from the standard, making a new dialect. [..,] The explosion of Forth dialects led to the saying 'If you've seen one Forth... you've seen one Forth.'" Let's consider a slightly different example. Ruby has several implementations. What makes them implementations of Ruby and not merely Ruby-like is that they implement a compatible language. Code written for MatzRuby will run unchanged on YARV, Rubinius and JRuby. We don't really or necessarily see that in so called Forth "implementations". What we see is closer to the distinction between CommonLisp and Scheme, which are both dialects of Lisp. Given all of these definitions both eForth and colorForth are dialects not implementations. Perhaps what is actually being implied by dialects in the wiki is better expressed as "derivatives". Factor is *different enough* from Forth in terms of usage and ideas that we can agree it's not Forth, but it was inspired by and is hence derived from Forth. Factor was also inspired by Lisp and Smalltalk etc and we wouldn't call Factor a dialect of Smalltalk for example. Descendents, or Inspired Languages (Languages Inspired by Forth), may also be appropriate. The dictionary definition says "[In Computer Science a dialect is] a particular version of a programming language. [And more generally] a particular form of a language which is peculiar to a specific region or social group." Ideally what we need is to distinguish between an implementation of a particular dialect of Forth (the implication of the above definitions is that all Forth's are dialects, but some dialects may have multiple implementations) and the idea of Forth in general. 
--------------------------- "Inspired-languages" seems to be a much better name for the page that previously named by me as "dialects". explanation about the title of the page should also be added. [when you or me or someone have time to edit it.] ------------------------------- by the way, when creating the page, my personal wish is to let forth's community merges others. --------------------------------
&gt; by the way, &gt; when creating the page, my personal wish is to let forth's community merges others. Could you expand on this please?
 to let other forth inspired languages' designers be able to discuss their languages in a central place.
We need some help copying any appropriate content over to our wiki lest it be lost forever.
Also a text dump here: https://github.com/ForthHub/ForthFreak
 --------------------------- I just have readed more in http://concatenative.org/ I disliked that wiki because I thought it is all about factor [as showed by this page : http://concatenative.org/wiki/articles] now I know that my attitude was wrong. it is mostly about factor, because factor's people created it and write it and run it. -------------------------- I know that one of the most stupid thing is to say "oh! that wiki sucks, let's start a new one!". is it true that to improve a existing wiki is alway better than to create a new one ? maybe I should write things there instead of here. I am not sure anymore. --------------------------- 
I don't think it really matters all that much. There is a need for a decent Forth wiki. concatenative.org could be that but it's not. The content on our wiki, after about a week at this point, is arguably much better. Moreover what do we do if one day slava or whoever decides to turn it off. We're in the same situation that we are now that ForthFreak is gone. Reddit or GitHub aren't nearly as likely to go anywhere. The only advantage to using GitHub seems to be that you can easily download the whole thing? I don't know if you can do that with the Reddit wiki? Either way we'll just have to see how it goes :)
or: 3. you are missing the point. Forth is very moldable. No part of it is set in stone, you can have Forth without both stacks if a task calls for it (say, you are writing a program for PIC10F200). Perhaps, what you mean under "Forth" is a strictly ANSI Forth syntax. And that is a quite a limiting view. 
----------------------------------- it is possible to host a repo in Github, and to use the Reddit's API to synchronize them. ----------------------------------- and it seems that [I am not sure] Reddit's wiki has no default command line interface. while Github's wiki give you a default command line interface for free. -----------------------------------
:) Ah. Isn't language fun...
I was trying to explain this point on #netbsd last night (having been prompted.) I don't think anyone understood it though... it's the opposite of of how we think about languages I guess I guess. All of the Forth hate doesn't help either (Which has gotten a lot worse now that FreeBSD is replacing FICL with Lua in their bootloader, and various people are taking it as an indication that Forth is inherently useless, rather than acknowledge the fact that nobody working on that bootloader apparently knew Forth. One gentleman who claimed to have worked on it clearly didn't have a clue. Overall there's a distinctive C flavour to the code, including the usual very large (and hard to read) definitions with deeply nested control structures and general and complete lack of any kind of abstraction etc. One mathematically minded individual insisted that such a thing couldn't exist; that the observable flexibility in Forth is simply impossible and that our belief of such means that we haven't grasped the very fundamentals of computer science. And thus anything that we say is meaningless. \*sigh\* not the most fun evening ever ;) I gave up in the end :)). EDIT: I'm really not sure how people can keep insisting that things are impossible, when they're right in front of their noses! Not even the Lispers have to put up with this kind of crap; to the same extent. Yet this is the key reason many of use use Forth, I think.
By all means!
Depending on your problem or your Forth you might be able to add the extra information easily.
how good if the author just draw a graph to explain the idea. ╮(╯▽╰)╭ 
 ---------------------- I have implemented unnamed function for example the following function : test &lt;&lt; -- &gt;&gt; ["here" .s .l end] end ; define-function test apply will print "here" and a newline ---------------- test will return the address of the unnamed function apply will execute it the unnamed function is allocated in place, i.e. in the outer named-function's body [there is a branch helps to jump over it] nested unnamed function is also allocated in place ----------------- but you can see when the unnamed function is allocated in place, I can not do as good meta programming as in Joy and, without the list datatype, I can not do much cool things with recursive combinators ---------------------- 
Region-Based memory management with Forth: https://www.youtube.com/watch?v=BpgmG--UD-Y http://www.complang.tuwien.ac.at/anton/euroforth/ef14/papers/ertl.pdf 
Fantastic! You always have the best links!
Thanks for the comment. I program a little at work, but probably spend an hour every night reading about programming language theory. It's a fascinating subject. For the life of me I can't understand why we don't use Lisp, Smalltalk, and Forth as the main languages of industry. Sure I know the historical reasons: Expensive implementation for Smalltalk Fragmentation and association with the AI winter for Lisp Too niche with Forth I still can't fathom why we continually choose monstrously complicated languages (maybe Smalltalk shouldn't be considered simple).
Do you still have them? If so I would be interested. I'd also scan them to fill in the collection on the Internet Archive.
Yes, I still have them. Email me at bob@steelguitarnews.com.
If you've seen one Forth, you've seen one Forth. I think that every implementation is a dialect. Standards are the baselines. Every Forth extends some standard, and many do not completely implement any standard.
Linn and Forth, two of my favorite words together. [slightly related](https://www.google.com/search?q=linn+rekursiv)
Ouch.. I guess we should to keep in mind the broader state of operating systems at the time :)
You might want to steal some things from the wiki :) http://www.reddit.com/r/Forth/wiki/
I've written Forth VM and REPL in Javascript for having fun at self-extending in Forth. Referring to Retro and Jonesforth I've tried it without any Forth programming experience. This is my first Forth code. I had very fun. Already implemented (naively!): - local variable - vocabulary, private - quotation 
Nice! [here's the archive.org copy of the online Cat intepreter](https://web.archive.org/web/20150205054254/http://cat-language.com/interpreter.html), in case you need any more inspiration.
This is one of the best implementations of Forth I've seen on top of Javascript. Fantastic work! Source code if anyone is interested. https://github.com/phaendal/mkforth4-js/
It's not impossible.
It's very easy to implement something that passes for Forth in languages like JavaScript; recently there have been more toy implementations of Forth in Javascript than anything. These implementations often take shortcuts. What I like about this one is that it actually tries to be a Forth at the implementation level, with all the pieces [0]. That's not to say it's perfect in any sense but it's undeniably Forth. I also like this one https://github.com/ephsec/svforth If you compare the two you'll notice that this one is leaning on JavaScript much more. All the the ways that it's leaning on JavaScript are what stop it from extending itself (which is fine in that it's still useful, and maybe more so, but it's missing something of the quality of Forth). I also liked the shell/prompt with this one. [0] It's not a one-to-one correspondence but what Forth is? For example, I didn't notice create does&gt; anywhere but it's not too far off and you apparently can create new defining words etc. The string handling is also somewhat novel. EDIT: properly cleaned up and documented it might be easier for programmers today to learn about how Forth is implemented, and what exactly it is about it that makes it Forth, from something like this, than, for example, JonesForth. That's a bit of a tragedy but it's probably approaching true.
I am aware of Linux not being the only OS with a kernel... even Windows has a Kernel. I am just used to people meaning Linux when they talk about kernel modules. I actually work with NetBSD/Linux.
NetBSD does not run the Linux kernel so you may be a little bit confused here. If you were to do this, I can almost guarantee that gforth does not allocate memory in a kernel safe manner so you would be asking for problems. It would probably be easier to write your own forth to run in your module. I don't know what kforth is but if it is a user space forth, I would guess that it would be similar to gforth. 
I know that Linux and BSD are two different animals already. I'm looking at Open Firmware... which is boot time driver software, and kpForth which is forth in as a kernel module. I also had talked with some people who use Forth for a living. They remarked that it would be a tough sell to *nix Kernel Dev's and collaboration. Until I know more, I don't plan on pushing a collab project. I need to know more about kpforth before i start.
I really enjoyed reading these articles! When were they written? Will there be more coming?
My Tate Pairing and Capability Security Implementation are coming along nicely.. [TinyTate: Computing the Tate Pairing in Resource-Constrained Sensor Nodes](https://sites.google.com/site/dfaranha/pubs/oliveira-aranha-07-nca) http://www.reddit.com/r/capabilities/ http://en.wikipedia.org/wiki/Object-capability_model http://racingbear.blogspot.com/2009/03/object-capability-model-for-fun-and.html --------------------- By the way, if you didn't already know, don't rely on these for actual security until they use arbitrary precision arithmetic.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Object-capability model**](https://en.wikipedia.org/wiki/Object-capability%20model): [](#sfw) --- &gt; &gt;The __object-capability model__ is a [computer security model](https://en.wikipedia.org/wiki/Computer_security_model). A [capability](https://en.wikipedia.org/wiki/Capability_(computers\)) describes a transferable right to perform one (or more) operations on a given object. It can be obtained by the following combination: &gt;&gt; &gt; &gt;* an unforgeable reference (in the sense of object references or protected pointers) that can be sent in messages. &gt;* a message that specifies the operation to be performed. &gt;The security model relies on not being able to forge references. &gt;&gt; &gt; &gt;* Objects can interact only by sending messages on references. &gt;* A reference can be obtained by: &gt;&gt; &gt; &gt;* initial conditions: In the initial state of the computational world being described, object A may already have a reference to object B. &gt;* parenthood: If A creates B, at that moment A obtains the only reference to the newly created B. &gt;* endowment: If A creates B, B is born with that subset of A's references with which A chose to endow it. &gt;* introduction: If A has references to both B and C, A can send to B a message containing a reference to C. B can retain that reference for subsequent use. &gt;In the Object-capability model, *all* computation is performed following the above rules. &gt;Advantages that motivate [object-oriented programming](https://en.wikipedia.org/wiki/Object_(computer_science\)), such as encapsulation or [information hiding](https://en.wikipedia.org/wiki/Information_hiding), [modularity](https://en.wikipedia.org/wiki/Modularity_(programming\)), and [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns), correspond to security goals such as [least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege) and [privilege separation](https://en.wikipedia.org/wiki/Privilege_separation) in capability-based programming. &gt;The object-capability model was first proposed by [Jack Dennis](https://en.wikipedia.org/wiki/Jack_Dennis) and Earl C. Van Horn in 1966. &gt; --- ^Interesting: [^Computer ^security ^model](https://en.wikipedia.org/wiki/Computer_security_model) ^| [^Cross-origin ^resource ^sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) ^| [^E ^\(programming ^language)](https://en.wikipedia.org/wiki/E_\(programming_language\)) ^| [^Concurrent ^computing](https://en.wikipedia.org/wiki/Concurrent_computing) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crxkboy) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crxkboy)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Very nice implementation !
Interesting idea, I have two Raspberry's actually. Do you mean installing it in Raspbian, or using this? https://github.com/aviatorRHK/rpiForth
gforth works well in Raspbian http://www.scidata.ca/?page_id=857 I've been meaning to try rpiForth, I don't know much about it, but a bare-metal pi Forth would be nice
This will be a wonderful thing. I would request priority be given to the *Library of FORTH Words and Utilities* book. We don't have enough examples, at least from what I have seen, of how to implement the usual FORTH words. Also, if you're going to talk about metacompilation, I'd love it if you would mention how to write ELF headers into the resulting executable, unless it is meant to be a DOS .COM file or other raw (and thus probably real mode) binary.
Similarly, it is both highly restrictive (stack-only memory in purest form [eg in 'mindless' nature]) and highly permissive (everything is a first class feature as you say). While every other language attempts to translate thought into computation, Forth *IS* computation; anyone (or anything) can do with it what it will.
Maybe you should get in touch with Archive.org?
Thank you for scanning your library! Maybe you can post copies at bitsavers.org?
GPL would pretty much make it something a lot of people (including myself) couldn't contribute to. BSD/Apache/etc.. are all more dev/user friendly. Of course it's your code base and depends on what you want to happen to it.
Did the F21 chip ever ship?
The i386 Linux example is just that– an example. The point of the tools is that I was able to easily deploy that with just a little bit of assembly glue. It could easily target a bare i386 target, as easily as it could target an ARM target, or an 8086 target, or a SPARC target, hosted or unhosted, with compatible code and identical behavior and vocabulary. The idea is that the scripts generate a massive dictionary with ITC, and all the programmer has to do is supply the nucleus layer, IE + - LIT @ ! etc. All words in the ITC are prefixed with SAVE_WS, which with a sed filter or preprocessor definition, becomes the proper "save this address" directive for your assembler. 
This is really nifty. You should x-post it to /r/tinycode.
I love the washer word on the front. Leo Brodie chose a good example
I look forward to it! The lisp ones were great too!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/tinycode] [The complete source code for the starfield in a shootemup I'm working on. \[Geode\] : Forth](https://np.reddit.com/r/tinycode/comments/3d0e1x/the_complete_source_code_for_the_starfield_in_a/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
&gt; The generated forth doesn't really follow any standards (yet). That's [somewhat] disappointing. (Though you got to start *somewhere*, and obviously that'll be incomplete because you're just starting it.) &gt; Make and friends are really only needed for the test cases, and the usage of sed could easily be replaced. Hm interesting / I see. Given the nature of the project, the output might be for a radically different architecture than the generating machine. Installing that Forth and testing it (automated where possible) seems like it would be a good idea.
Wow, this was late. haha
Late would just finally be watching your vine :) It looks great! Can you provide implementation details?
thank you
Do you think the language encourages solo programming, or are solo programmers attracted to the language?
Does this have to be either or? Independent programmers tend to be self-directed learners and they're more likely to learn weird languages like Forth. Then again A Lot of people play with Forth a bit and move on. Maybe those that stay are the ones that like the power and independence that Forth gives them? That's certainly one of the reasons I keep coming back to Forth.
It doesn't, I was just wondering if there was a trend in the redditors of this sub. As for me, I'm a solo programmer by nature so I look for tools that suit me. I like having a community of other programmers around, but when it's time to code I like to be by myself. I actually tried pair programming a few times ... if possible its worse than project team meetings.
Oh sorry, maybe I should have expressed myself more clearly. I know what a Forth metacompiler is; I have written one or two myself. However, the Pygmy Forth metacompiler is supposedly very simple (much like the one in cmFORTH). I read the article some time ago, and also the cmFORTH source code, but I didn't quite fully understand the metacompiler. So if you have intimate knowledge about the Pygmy metacompiler, could you describe its magic?
I find the Platonic-Virtual Machine observation thought provoking. 
Yeah, forgot about factor, it's nice, but it's so big it's kind of hard to wrap ones head around, maybe I should give it a second try.
I can't get it to work under Ubuntu. Something with my graphics card.
&gt; I've been looking a bit into swiftforth as well, but it seems like it's having the same string and array handling as gforth, which I still struggle to wrap my head around So wrap Forth around your head, then! #serious This is Forth's strength and one other languages can't match. Invent a model for string or array handling. Define the words. I'm not saying it will be perfect, but when you are courting a language that is literally *designed* to be minimal and extended as your problem requires, you owe it to yourself to give that aspect a whirl. You'll look down your nose at fixed-syntax languages forevermore. IMO, Forth is so much more about extending the language to a specific problem-at-hand than it is about learning a pre-packaged language or library features. But to each their own. You'll get good advice here. Have fun on the journey! You don't have to start from scratch. Pick a good one -- sounds like you have gforth exposure already. Build from that but ignore all the ANS and bloat you'll probably never use. 
I think 8th has three advantages: It allows complete cross platform development, common requested features for application development are intrinsic part of the language and and it *offer* commercial support. If I take a look at there forum, for me it seems that the language gain some popularity. In addition it seems the user base grows. However, time will tell...
Related to the topic I would also like to highlight Parable: http://www.forthworks.com/parable/
Well I'd really love to, I really like working with gforth, and doing things in the repl, but then the time comes when I need to take long string of numbers from stdin and do some calculation on them and print them out again, Then try to make a string split it, making a linked list, and I slowly come to the realisation that I really suck at lower level stuff, and I've never found an example for how to do a thing such as get input &gt; 3 &gt; 4 8 6 13 10 365 64 &gt; 93 1 12 &gt; 562 04 76 1 Where 3 is the number of test cases and I want to print averages out. In factor 8th and oforth Factor it's pretty easy with strings arrays, map and reduce, but after struggling with doing it in gforth for so long I just have to realize that I'm rather stupid at the low level and wanting to do it as I do I'm not "man enough" to figure it out for myself. I'm reading through and doing the exercises in starting forth and thinking forth for the third time now, I just don't manage to do the things I want to, and that's why I'm looking for some more modern forth, since the things I'm too stupid to figure out for myself is already done, and I can do the stuff I want to get done in a programming style that I really love.
Under arch it's pretty easy ti get to run through aur
Thank you for all the links, there I have something to look through :) oforth is really nice, and the guy that's making it is really nice and responsive, the same with the guy behind 8th I'm starting to think it's something about forth, and it's such a powerful way of writing code. Now I have stuff to read for a while :)
Most likely you need to install de 32 bit version of the library that is missing
but 8th offer only commercial license
Progress bars for long SQL plans. Big Data, meet Forth. Forth, meet Big Data.
I found [this introduction + cheat sheet.](http://ficl.sourceforge.net/articles/ficlddj.pdf) The sidebar link "ANS" shows how it stacks up against [http://ficl.sourceforge.net/dpans/dpans.htm](this standard.) The next sidebar link surveys the glue API for embedding Ficl, although it punts some of the details by saying "see the comments in the header file". The rest of the sidebar includes docs on its local variables, its OO, and its extensible parser. That's all the docs I know of, but it looks reasonably complete. 
&gt; Arguably had more momentum than oforth or 8th, but the creator hasn't been working on it the last few years. The creator has stepped down, but it's still under active development.
This is the 8th developer here, thanks for the kudos :) The only difference between the commercial and non-commercial license (besides that the non-commercial is free) is that the commercial version produces encrypted applications while the non-commercial does not.
I've implemented them like this: https://github.com/larsbrinkhoff/lbForth/blob/master/experiments/interp-comp.fth
I don't understand; why doesn't my account page say anything about a ban?
Try going to https://www.reddit.com/user/8thdev when logged out or in "incognito mode" in your browser.
In case you're wondering, I'm the author of this.
Yay, another PDP-10 interested guy :) There are not that many of us.
And the intersection with Forth is even smaller! https://github.com/larsbrinkhoff/lbForth/blob/master/targets/pdp10/nucleus.fth
Explanation of Y-Combinators: http://mvanier.livejournal.com/2897.html
https://news.ycombinator.com/item?id=10358825
Hosted for some targets (e.g. x86), standalone for others (e.g. PDP-1, if it's ever finished). The goal is just to play around with it. No real applications so far.
It's a different kind of work, I barely understand it, but the author is a cpu designer, so the sophistication is higher than the usual forth system.
X-Post referenced from /r/programming by /u/andrewsnow [Forthwith: Adding Forth's type safety and readability to Swift](https://www.reddit.com/r/programming/comments/3prk8i/forthwith_adding_forths_type_safety_and/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
Originally posted on /r/programming by /u/andrewsnow.
I also like the diagrams from [*Starting Forth, Chapter 9. Under the Hood*](http://www.forth.com/starting-forth/sf9/sf9.html) they really show the Russian nesting doll approach that is threaded code: http://www.forth.com/starting-forth/images/ch9-dinner-exit.gif It would be cool to see an interactive multipart diagram/visualization with something like d3.js
Peer-to-peer architecture seems to be gaining steam over client-server in much of the Internet of Things. Small, simple, 'bottom-up' languages like Forth could find new life. 
I enjoyed this paper but I'm not sure why the exchange of strings has to do with any of the properties mentioned here.
Normal token-threaded Forth with 8-bit tokens allows each token to invoke one of 256 possible routines. The sliding window (into a large table of pointers) allows access to 256 routines from a larger set. As the code executes the window slides to a different place, accessing potentially different routines (the meaning of a token changes). Because of locality principles (code that deals with IO is in one place, math routines in another), this works out to 8-bit tokens standing for any number of routines.
That is just awful. In the age of opensource, a propriatary, encrypted, 3-day limited software developer's tool? There is a place for this in Dante's Inferno. For me, the "whole experience" does not include my tool or application locking up after 3 days, thank you. Actually, just hearing that makes it a "whole experience", no need to even download your 'th.
Sorry you feel that way, though I understand it's a common notion these days. How is 8th different in this regard from literally hundreds of other development tools which also have a "free" vs a "paid" version, where the differences are in some incremental features? To clarify: the difference in 8th between paid and non-paid is that the non-paid version can produce encrypted applications, which are only runnable for three days. That restriction does not exist in the paid version. The tool itself is not encrypted or locked or different in any other way.
This is nice. I especially like the last exercise!
Of course, any portable Forth written in another language such as C probably works. Gforth seems popular. If you're willing to pay, VFX Forth and SwiftForth have OS X ports. A search on GitHub: https://github.com/search?q=forth+osx&amp;type=Repositories
What do you consider a Forth-like language? In general *I* don't think there's any problem discussing related languages here but some languages are only superficially similar to Forth. Factor, for instance, may look very similar no Forth but to my mind it's very different.
Personally I'd consider any stack-based language to be Forth-like. That's really the defining feature of Forth, much as having S-expressions is the defining feature of Lisp. If Lisp people accept that Scheme, Racket, and Clojure are Lisp like, Factor is Forth-like. As is Joy, RPL (the language used on HP calculators like the HP48 series), and even Postscript (yes, Postscript is an actual stack-based language and people like Don Lancaster used to write articles about creating illustrations by actually writing the code!) 
Did you have anything you wanted to discuss, or?
On the other hand, some accept Dylan. (With the new infix syntax, not the old s-exp syntax.)
Classification is an Art, not a Science ;). That the hell is a platypus?
So far you have 100% approval ;)
Link to the Forth version of Crenshaws article mentioned in the blog post: http://home.iae.nl/users/mhx/crenshaw/tiny.html
You can in theory write anything in Forth it just would be really hard. It's a language that was borne in and excels in resource-constrained platforms, for creating simple, extensible, Forth-based solutions to carefully studied and explored problems. Think about what that means. Every good Forth program is essential just a special tailored version of Forth. If you're using it the way it was intended. People easily get off track and miss the point.
&gt; Forth is just a program that you extend Like Lisp or Smalltalk, then? &gt; I don't know what the point would be though. Lots of people climb mountains. Does that accomplish anything? &gt; Nothing, apart from that they were products of the same era. Have you read this [account](http://www.colorforth.com/HOPL.html) of Forth's creation? &gt; Forth was meant to do more with less. Was that was Moore had in mind, do you think? &gt; Be easier to write than FORTRAN In which ways did it succeed at that? How much easier would it be to write, say, a matrix multiplication routine, or a fluid dynamics analysis program, in Forth than in Fortran? What makes it easier to do so? &gt; compile faster than C How quickly does C compile, relative to other languages with similar semantics? &gt; run faster than BASIC How fast does BASIC run, relative to other languages with similar semantics? &gt; take up a fraction of the memory These are all things that Forth became notable for. To what extent were they design intentions? 
&gt; Like Lisp or Smalltalk, then? I admit I'm not familiar with their operation or usage patterns. &gt; Lots of people climb mountains. Does that accomplish anything? If it gives you personal satisfaction knock yourself out. We'll all be here waiting for you back at the bottom! &gt; Have you read this account of Forth's creation? I think I have! Inspiring story AIRC. Might have to give it a re-read. &gt; Was that was Moore had in mind, do you think? Definitely. He was tired of punch-cards and finnicky compilers. He wanted an edge, he wanted to be more productive. &gt; In which ways did it succeed at that? How much easier would it be to write, say, a matrix multiplication routine, or a fluid dynamics analysis program, in Forth than in Fortran? What makes it easier to do so? All languages are designed to be good at what the designers want to do with it. Some are general purpose and so end up complex. Some, such as Forth, are designed to debug and investigate hardware, drive telescopes, give scientists access to a simple database, that kind of thing. And excel at that. BTW I'm pretty sure Chuck Moore used whatever language was most appropriate for the task at hand. Forth was conceived and evolved for the purpose of solving a certain family of problems. That is he kept changing it and evolving it. The latest version of ColorForth was written specifically to design chips with, for instance. &gt; How quickly does C compile, relative to other languages with similar semantics? It depends on how many levels of optimization you tell the compiler to do, but in the case of a Game programming library called Allegro compiling on the RasPi I went away for an hour and came back and it was still at it. In Forth the compiling time vs volume of code is more linear and there's no syntactic analysis ... a classic Forth on a modern system processes a ~10k file in an instant. &gt; How fast does BASIC run, relative to other languages with similar semantics? there is no original "BASIC". the "BASIC" family of languages are interpreted (either straight or tokenized) so they typically run very slowly. Dark BASIC, which if I was told correctly became Monkey-X, is compiled and runs faster. Visual BASIC runs on the CLR so it does compile to machine code on first run but nothing in the CLR run as fast as optimized C ... well, apart from very carefully crafted JavaScript on Google V8... &gt; These are all things that Forth became notable for. To what extent were they design intentions? Huge. Typical operating environments had mere kilobytes to play with and precious few processor cycles. Computer time itself was outrageously expensive. Chuck didn't even get his own computer until Forth was already well into its nascent stage, he tested his Forth cards during scheduled time on a shared mainframe. So it's no wonder he wanted a better way to do things than always have to wrestle with COBOL, FORTRAN etc
As I understand it that would be correct. 
Just a couple more days left!
This describes the [Mecrisp](http://mecrisp.sourceforge.net/) project which implements an optimizing Forth compiler in 20 kB for various platforms including MSP430 and ARM M0.
Likely can beat a GPU-based solution, but very doubtful to match up to ASIC.
Likely, it will not perform anywhere near your expectations. For one, litecoin needs at least 128kb of RAM per miner. A whole GA144 only has around 40kb and it is split among nodes.
Approaching someone via email is way, way harder for me than asking random strangers on public forums. I have social anxiety so debilitating I can't even use twitter any more (for example). But from the teasers I've managed to glean, this sounds as though it's doing the same kind of optimisation as MPE's VFX generator... only it's free and open source, whereas VFX is highly spendy. Would that be a fair summary?
I feel a bit silly, but where can I enable the English subtitles on the CCC video player? I don't see any options for subtitles?
Try the “Download” tab to download the file with (mediocre) voiceover. Use torrents if possible to reduce load.
&gt; Would that be a fair summary? Yes. More concrete, Mecrisp implements the following optimizations, with some of them being available only on some platforms: * machine code generation (all) * automatic inlining (all) * constant folding (all) * register allocation (ARM-RA) * tail-call optimization (J1a) * “opcoding” (encoding constants into opcodes) (MSP430, ARM, ARM-RA) The code is available for J1a, MSP430, and ARM (one port with and one without register allocation).
Depending on your definition of "Forth", Factor language may suit you well. http://factorcode.org/ Somewhat relevant example: http://factor-language.blogspot.ru/2007/01/converting-excel-file-to-csv-factor.html
If you use 8th (a Forth-derived language) then it's not hard to do this. It has string splitting built-in as well as perl-like 'pack' and 'unpack' to deal with arbitrary binary formats. http://8th-dev.com/
The good thing and the bad thing with data manipulation in standard Forth is that you have to build up an environment of your own. Some amount of work results in a customized language for a certain kind of manipulations. Anything is possible but there will always be systems much better for each kind of manipulation. Just now I'm creating stack based sets for playing around with finite groups, finite topologies and matroids. Perhaps not what your boss would estimate, but it's nice and intuitive and interactive. It will appear on my blog in a few days I hope... http://forthmath.blogspot.se/
The advantage is that people actually chat in Gitter. ;-) Seriously, I'd like #forth if there were any discussions.
Soft stacks can be use for serving "the" stack in dynamic programming: http://forthmath.blogspot.se/2016/01/dynamic-sets.html
In the Forth system I worked many years in we had an extra object stack. This was totally integrated into the system and tasks. This extra stack made the programming so much easier. The object stack was used to hold a pointer to the current object that was active. The classes and objects all used this stack. The effect on the code was that code working on a simple single static data was almost unchanged when converted to work on complex data structures. Only the top level code needed to handle the complex data.
Misc drawer.
works everywhere except firefox, bug
Natural evolution is being harnessed instead of top-down circuit design. The advantages are many and include efficiency and fault tolerance. I see Forth as a natural language for such organic electronic Darwinism. 'Forthiness' (concatenative programming) is a much cleaner starting point than linking in vast top-down libraries. The latter would collapse under its own bulk and doctrinal structure.
Cool project. I wonder of how many such DIY boxes were built in the privacy of their circuit cellars, and never talked about.
Nice! I was using a Timex Sinclair with a Forth ROM around that time, then the Jupiter Ace.
I have included a third stack for local function definations. The new parsing rule is that headers for function declarations with ':' prefix are pushed onto this stack until the next dictionary entry is defined (now signaled though ';' prefix). In these case the stack content is discarded. The search rule is extended so local definations are searched first.
In this day and age, why not go with 32-bit floats on a main stack?
I did this in a few of my forths; it works great. Having a separate stack for floats or strings or objects or whatever has an advantage if keeping each of the stacks small but I enjoy the simplicity of a single general purpose stack. You can always add extra stacks, without loosing the generally, if that turns out to be useful. I've also got a forth system in which the primary interaction is though the mouse, but I'm working on improving the keyboard support.
I think you need some form of it. What's the alternative? Property arrays? Horrible for performance. There's also a real temptation to implement some form of "Inspector", but you have to wonder, if the state isn't evident in the graphical output of the game, or there is so much that a couple interactive queries don't suffice, then maybe the program is too complex to begin with. 
Is any of this downloadable? Do you exclusively use your own custom Forth system? I have to avoid getting waist-deep into compiler-design again - trying to keep this thing high-level. But if something is better suited to my goals than one of the big ANS Forth's then I'll jump to it...
An interesting quote, Moore's take on it: &gt; I've been bemused with the preoccupation of new languages with text processing. I've been accused of not providing string operators in both Forth and colorForth. Indeed, I haven't because I don't use them. Editing a file to pass on to another program never struck me as productive. That's one reason I chose pre-parsed source, to break the dependence upon strings and text processors.
Also, if you're in Berlin tomorrow (2016-02-16), I'll be demoing the project here @ Sonic Code Sessions: http://www.meetup.com/spektrum/events/228311024/
Forth is a better unix than Unix.
I'm playing around with it as a hobby and am liking it quite a lot (more so than factor, can't compare to other forths though). 
Beautiful!! I love Forth implementations written in C/C++. I've made some rough modifications to it so it compiles with Visual Studio 2010: https://gist.github.com/createuniverses/e7518bbacd698e42fe2c Compile it with: cl cxxforth-win.cpp 
Pastebin, dropbox? How about some git service?
Thanks!
Sure thing man. So what kind of compile-time support does 8th have? And how does it accomplish type-safety? At run-time? External library support? Game support? Are numbers floating point?
A hallmark of Forth (and one feature I hugely leverage) is the ability to interpret anything at compile-time. You can pre-calculate tables, process and compile in data, add a degree of interactivity to the build process, anything. Speaking of which is 8th interactive? For instance in a game engine I'm working on in SwiftForth I compile code at runtime for things like scripts. In fact the entire thing will boostrap/compile from (protected) source when you start the app. I'm assuming because of the cross-platform stuff 8th don't support anything like that, but just curious.
Sounds really interesting! The Raspberry Pi support is particularly attractive to me because of a special project I'm working on. You'll likely hear from me again. ;)
Ok, thanks for the feedback. I will work on something more explanatory. Can I ask what were the sticking points? And your background with Forth? 
The writing or the underlying FreeForth system?
Thanks
I think FreeForth strikes a good balance between simplicity and complexity. On the one hand, it's an optimizing compiler with some unique features. On the other hand, it is a small system, with a tiny assembly core (&lt;1k lines). I also think the docs are excellent, as are the code comments (For performance reasons, the ff.boot file lacks comments, but every word is described int the help file). My article is not a great introduction, but the Web site + distro are intelligible.
Could you explain what you mean by: &gt; if the types of word definations are handled beside compilation 
Because I don't like to upgrade stuff that works. 
sorry, for the unclear formulation. If the dictionary is searched often, side effects at compilation such as needed macro expansion can be factored out to immediate executable word definations, the word class. These special word definations are handled like constructors eleminating 'parsing' completly (with the exception of number conversion). You can take a look at retro forth for an example.
Maybe you should give oforth a try? It's a quite practical and fun forth, which is at least kind of typed. 
[Factor](http://factorcode.org/) looks kind of like a forth with types. 
That makes a lot of sense. Which is a reason I am looking for an implementation that has types which still keeps the Forth concepts alive somehow. 
I think i'm almost there already ... I wrote some interpreters &amp; compilers as experiments but never a Forth-like so it'll probably happen. Thanks for the warning :) 
Well Factor is quite brilliant ; some features in there would be things I would put into my list of must haves for ideal language. I'm not sure about usage ; for 'smaller' languages it is very hard to get numbers... 
The only immediate "pain" in it is trying to maintain "journalistic integerity" in the docs :) The stack inputs of all operations on these 2darrays has to be on "data" not "2darray", which potentially creates some confusion. I don't dare lie and say that they take 2darrays, even though, semantically to the user, it always appears to be. Thus I question the DOES&gt; action. The reason I did it is about principle. When possible, do you make your data appear to be "pure" so that it can be directly DUMPed? Counted strings don't. When inspected, the count is there for all to see. But CREATE'd words do. (word headers are "hidden"). On the other hand, the 2darray is fairly useless/pointless in all other cases WITHOUT the metadata. It's used to safety-check manipulations and automate array-to-array transfers and iteration. It's hard to come up with a reason you might want to do anything with a 2darray other than use the supplied "methods". This line of reasoning only goes for 2d arrays though. There might be data structures, like CREATE'd words, that naturally ought to hide their metadata. The line seems to be drawn at the question "is the metadata and the content to be used together, or separately?" 
In case anyone is wondering what this does. It creates a chunk of memory which stores the number of columns in the first cell, the number of rows in the second cell, and a two-dimensional array in the rest of the chunk.
I prefer blocks; they solve the problems at hand better than files and they're much simpler. But it depends on the tools you have for working with them. The advantage of files as I see it is that our operating systems include a huge number of tools for working with files, and they're more familiar. Perhaps this isn most clear when considering source code. There are some fantastically powerful editors for working with source code in files. This contrasts heavily with the editors for working with blocks. Forth editors are almost of a labour of love. That's not to say that they're less useful (I'd argue that there are some major advantages to having your own editor), just that like everything else in Forth they tend to be in the Do It Yourself philosophy. Unless you put a lot of work in to your tools, they probably won't even be comparable let alone competitive. Naturally this argument extends beyond the editors. If comparable tools existed then I think blocks would be much more widely used in hosted Forths. Note: I'm using the term tool in the general sense and not to refer specifically to graphical or interactive programs. Words. To put this in Forth terms.
That's quite a nice solution, and a nice demonstration of forth as well.
Hi! I'm writing Conservative Mark&amp;Compact GC Library for my learning. It works on gforth 0.7.0 on linux x86_64 without any modifying VM. My some other project take higher priority, so this may grow slow. Your contributions especially proper naming convention are welcome. I think that Forth is very suitable for learning memory manipulation.
Regarding editors, it's not that hard to make e.g. Emacs work with blocks.
Yeah, hat's the sort of thing I meant. Does it seem easier to follow now?
Yes, also quite impressed about the expressiveness!
 : input$ ( n -- addr n ) pad swap accept pad swap ; : input# ( -- u true | false ) 0. 16 input$ &gt;number nip nip 0= dup invert IF nip THEN ; Because you are hardcoding the string count to `16`, you might as well put that argument where it belongs at edit time instead of juggling it into place at the beginning of `input$` : input# ( -- n f ) pad pad 16 accept snumber? ;
Anyone that doesn't have this in their library; should.
I don't think anyone minds the occasional bit of news about 8th but my feeling is that this is bordering on spamming.
amForth on the arduino: http://rodbhar.com/how-to-install-amforth-on-the-arduino-uno/
Swapforth [1] running on an ice40 8k breakout board [2]. [1] https://github.com/jamesbowman/swapforth [2] http://www.latticesemi.com/Products/DevelopmentBoardsAndKits/iCE40HX8KBreakoutBoard.aspx
If you don't mind a bit of soldering, you can go with Chuck Moore's GA144: http://www.rs-online.com/designspark/electronics/blog/hands-on-with-a-144-core-processor 
I paid schmartboard $5 to solder it for me.
Though I haven't used it myself, the Parallax Propeller has a lot of Forth activity. https://en.wikipedia.org/wiki/Parallax_Propeller#PropForth
I just skimmed through the article. Just one stack? Ok for a short intro, I guess.
Well, it's mostly for people not familiar with forth to get an idea about how it works, and how one can program in such a language.
I think this might be something you are looking for http://kittenlang.org/
My Forth library for the FT800/FT810 GPUs: https://github.com/jamesbowman/forth-ft800 Am working on a skinnier version for 16-bit Forths: Mecrisp MSP430, SwapForth J1a and AmForth. 
I guess you could argue there are two; the ruby stack replacing the call stack, but overall I'm not convinced it's a Forth. It's certainly a concatenative language, but is that enough? I've never liked the emphasis that concatenative languages place on things like quotations, and combinators.
Full disclosure, it's not my article, it's written by a guy much more eloquent and well spoken than me. It feels more like what is a forth is a gliding more emotional question rather than a technical one, it would be possible to implement all of factor in forth, at which point does it stop being forth? What is it that excludes something from being forth? Indirect memory management? Objects? Is oforth a forth? 8th? What about gforth? I don't get why you and others here have such a strict definition of forth. To be honest I'm too stupid to do anything complex in forth, but in oforth or factor I manage to do useful stuff, I'd love to do it in forth, but I don't get how to do more complex things like arrays other than the basic, or strings other than printing them. At what point is something not forth?
I'm using Gforth 0.7.2, if I use ALLOCATE it defines my array, but if I try (with my library): 6 4 ** 2 ** a foo cr \ init ok foo a.l cr \ print lenght+1 1679617 ok 0 foo a&lt;s cr \ fill with 0 Invalid memory address foo a.s cr \ print all Invalid memory address I'm not surprised... To what concern '8th', students are not famous for their moneys... There is an alternative? :)
Gforth has the `-m` option for specifying dictionary size. E.g. $ gforth -m64M 16777216 allot ok 
OK, I misunderstood you to have a 6x4x2 matrix. Sorry about the money situation; been there myself, hope to not return there. Best regards, and success in your endeavors.
Basically, when you define a marker it records the state of the Forth system at the point just before it's defined; when you execute it, it restores that state, thereby deleting both itself and everything defined after it. So, for a tiny example: ` MARKER bin-hi` *ok* ` : HI ." Hello, world! " ;` *ok* ` HI` *Hello, world! ok* ` bin-hi` *ok* ` HI` *HI ?* ` bin-hi` *bin-hi ?* Does that help? 
A linked-list structure can be easily turned into a tree structure just by adding extra head references and adding nodes to them. The node structure doesn't have to change. So FORTH dictionaries are often tree-shaped when multiple vocabularies are supported, at least when you look at the structure formed by the links. Straightforward implementations of multiple dictionaries may allocate the nodes all from the same memory region, although this would make the straightforward implementation of "marker" systems wipe all changes to all dictionaries since the last marker. 
We now have a partner who will design and produce an "embedded-8th board", which is very exciting. Details are on our forum: http://8th-dev.com/forum/index.php/topic,923.msg4800.html
Reminds me a bit of the transputer instruction set... only without the prefix madness. (Nonetheless, allowing long, unaligned instructions is not ideal. I prefer the way Chuck Moore does things like constants: either use the rest of the current word, or pick up the next one - you get the compactness of code, but all fetches from the instruction stream stay word-length accesses.)
There was a version of Small C created for the Novix NC4016 processor that compiled to FORTH as its intermediary thread language. See Byte Magazine April 87
This is exactly what I had in mind! It seemed like FORTH would be a good host VM for embedded systems languages.
*whispers* but did it make a sound?
The `'` (tick) gets the execution token of a word. One thing the tick is useful for is compiling a lookup table (aka vectored execution), such as for handling a protocol's packets. : cmd0 ." got a packet of type zero!" cr ; : cmd1 ." got a packet of type one!" cr ; : cmd2 ." got a packet of type two!" cr ; create packet ' cmd0 , ' cmd1 , ' cmd2 , : header key ; \ get the header byte over serial connection, for example. : cmd [char] 0 - cells packet + @ execute ; : packets begin header cmd again ; The `[']` is the compile time version of the word. : compile-an-xt ['] cmd0 , ; Although... you can still use the `'` word within a definition it will just get the execution token within interpretation state instead. So the tables could be compiled with a word like this: : pkt: ' , ; create myhandlers pkt: bye header cmd ( enter the letter 0 to leave Forth interpreter) &gt; Having a hard time googling for a FORTH word made of symbols I have found the [gForth word index](http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Index.html#Word-Index) useful for that. 
In addition to pointfree's suggestion, here are some other word lists. Draft ANS Forth 94: http://lars.nocrew.org/dpans/dpansf.htm Forth 2012: http://forth-standard.org/standard/alpha PFE: http://pfe.sourceforge.net/words/index.html
To clarify, `'` does its work at *run time*. `[']` works at *compile time*.
Sounds cool. Forth is an unconventional language, so I welcome an unconventional take on OOP.
The big thing that allows all of this is Forth's ability to redefine any word. It lets you experiment with different forms of OOP in different parts of your program, without affecting established parts. You can even add protection against name conflicts using wordlists - great for words that have been tested and are localized. As one example I'll probably want to figure out a convenient way for different game objects to define simple words like CONTROLS and JUMP without burying them - the point is that I can do that, without changing Forth as a language. Developing OOP facilities in parallel with the application leads to cleaner, less noisy code.
It would be cool to see this implemented on an iCE40 FPGA.
More about using Forth for music and sound synthesis: https://github.com/ForthHub/discussion/issues/18
It looks like he is using stacks to implement sets. /u/lehs, have you considered using ZDDs to implement the sets themselves while still passing the references to sets themselves on the parameter stack? https://crypto.stanford.edu/pbc/notes/zdd/ http://ashutoshmehra.net/blog/2008/12/notes-on-zdds/
Nice Forth-only implementation of big ints. But the speed is (only) one reason 8th uses a C library for big ints (tomfastmath). The downside, of course, is it makes the engine bigger to include it.
Cool!
I think /u/lehs said somewhere that he got [his bignum system](https://github.com/Lehs/BIG-INTEGER-ANS-FORTH) to run quite fast by choosing better algorithms &amp; data structures. I'd like to do a benchmark on a microcontroller with mecrisp-stellaris-ra (register allocator). Because it's necessary to have [forth cryptography](http://hub.darcs.net/pointfree/forth-crypt) running on the small microcontrollers if one is to use Forth for IoT purposes.
Thanks for hinting about ZDD. I will study this and see if I can understand and use it. The good things with stacks are the simple garbage collection and that sets of integers are sub-arrays in an array for the stack. And that stacks keep it simple. A problem with my coding is that I'm neither a computer scientist nor a professional programmer. I sometimes wonder what professionalism could do to my code. Each time I adept new knowledge and make some changes in the code, the speed is changed to the better. 
The first part of the BigZ code is a minimized part of the BigInt code. And I'm sure that it's possible to make it faster. My first version of BigInt was hundreds of times slower. But all my code is a forthers experiment, and I could never be competitive to a whole society of C-programmers. Except that I have more fun than they have. :)
I would use libraries if I could. I wonder why no one host Forth-libraries?
What about the Forth scientific library? I'm sure there are others as well. Don't help me a whole lot, since they're ANS... but still, code is out there.
Next post I think will be about the currently settled-on design of the engine. (On a side note, preparations for putting the engine on a public repository are underway!)
No, I was not aware of it. Probably the naming is more popular than I thought
There's no rush, so, definitely. If this task is already taken care of by then would you be interested in helping with anything else I might have that's not too big? Such as help with adding better C-struct support to VFX's FFI so that I can use a fancy 2D physics library (Chipmunk2D)
That's ok. Just inform me in two months how I can help out.
;) I take it this is subtly addressed at me given our conversation over PM? As I wrote there, and elsewhere, I have no problem with ANS Forth and I certainly don't have any problem with you using it. I just prefer to use my own Forth system, and I see no reason to adopt ANS Forth for my work (which for the record isn't a hobby either! I make my living using Forth, just not ANS Forth.) I'm not sure why my comment about me personally not wanting to use ANS Forth or my not seeing the need for ANS Forth is causing this reaction, but I think it's going a bit far? You seem to be manufacturing conflicts were none exists. Do what makes you happy :). EDIT: while we're on the subject I think you're making a lot of assumptions and laboring under some false dichotomies. It's not difficult or especially time consuming to construct a practical Forth that runs in a hosted environment and has access to host facilities, libraries etc. for example. Now I'm not saying that you have to do this, but it's certainly not an argument for ANS Forth or against custom Forth's. Nor are the cries of perfectionism. The best argument for ANS Forth, in my opinion, is that there are a number of high-quality Forth systems that happen to follow that standard. If one of them strikes your fancy, and it helps you solve you problem, that's fantastic! Have at it! :)
As an alternative to putting a lid on new developments via standards, why not a Forth package manager with the granularity of individual Forth words? That would encourage collaboration and ecosystem-oriented development. Most other languages such as python don't need to be stifled by standards as much because there are only one or two major implementations, so instead they build ecosystems. However, I tend to liberally make use of the search order by redefining words according to context. To keep the code simple and manageable I also like to tailor it to the application at hand which is different from someone else's application at hand. Perhaps then the package manager would need a kind of tree structure. Also, ecosystems can also feel like a anti-innovative standards push through the so called network effects.
&gt; I guess your idea is less a replacement of ANS Forth and more a pruning of it down to core words perhaps, and a way to wrangle the complexity of importing vocabularies from unlimited authors. Both really. A more dynamic alternative to Forth standardization and a way to import some words and diverge from there. &gt; How deep would your standard's idea of "meaning" go? What I guess I'm saying is, at some point different vocabularies have to agree on a baseline of meaning. If we would want this to work all the way through the core of all participating Forth implementations the dictionary structure would need to be a directed acyclic graph rather than a tree, for the purposes of package management. A Forth implementation would be one path through that DAG. &gt; (Non-standard) Forth systems often have different register layouts, dictionary formats and so on. I was thinking the word packages would be identified not by the bytes laid down but by fingerprints of their structure rather than and the word dependencies they touch... but this could be a lot... and as you said there could simply be a different word format, so there would need to be some way to orthogonalize the semantic structure of the words. Perhaps some sort of [context vector](https://ai2-s2-public.s3.amazonaws.com/figures/2016-03-25/8ea53f0f84a4f034e76cf61a3e939a30a7b99d69/4-Figure4-1.png) scheme? I don't know yet.
I maintain VFX Forth. The license for VFX says that you can use the interpreter/compiler for engineering and maintenance use. That means that you can compile configurations and scripts at start up or as required. The point of such terms in Forth systems is to say that you cannot ship an open Forth system with asking our permission, which may well the granted, but we have to be asked! We do need to protect our copyright. We also don't want to see another undocumented Forth system ever again! There are techniques to provide sealed vocabularies with a restricted range of words. We are really not trying to restrict you, just to protect ourselves. In case you ask, we have been ripped off in the past.
This applies to the size of the cells in the dictionary memory, which means the stored program, and also the memory accessed by `!` and `@`. This of course has some practical side effects and makes it hard to map data and arrays in memory. It also slightly complicates compilation, for example when filling in the target of a `jmp` operation that has been written earlier. I should probably write some documentation about this, but I have no idea if anybody even cares about my implementation at this time. The stacks are just arrays of the chosen data type, since these are relatively small compared to the dictionary memory.
Very nice implementation with minimal effort ! However, maybe I see some easy applicable possibilities for better perofrmance: Your VM design is clearly limited by it grand switch dispatch for primitive routines. Because the number of primitives is currently quite low, a larger performance increasement is probably possible by implementing replicating-switch threading as option. This lead to a larger increase of code size but is otherwise a trivial ANSI C conform extension which you can add as compile option. Also the primitive routines depend on some functions and as such inherit the C call frame overhead dependent of the chosen compiler flags. Rewriting them as macros have the advantage of avoiding this overhead. In addition it allows defining the VM state local which offers the opportunity to cache at least the topmost stack element.
I'm not familiar with the concept of replicating-switch threading, can you point me to a reference somewhere where this is explained? Performance is not really one of my goals for this forth, but I'm open to any ideas for improvement.
I've got a rather battered old copy on my shelf, it doesn't seem that special but Amazon sellers seem to think it's pretty damn valuable.
That's pretty much what I thought. It does appear to be quite hard to track down, though. Maybe I should just scan mine.
I believe it is a tactic used when the seller is down to the final unit to avoid losing sales history for that item. If they sell the final copy, the details then get junked and, if they restock, it gets counted as a completely new SKU. By jacking the price they prevent losing that data chain, because they never actually run out.
Nice! This is great.
That cover is worth a lot of dollars in my eyes.
I'm just a bit too stupid to get stuff out of forth, having to redo string handling, printing, numbers and arrays are not stuff that I'm smart enough to do, with factor I can at least focus on doing the things that I'm trying to do, instead of struggling with understanding input output, string parsing and stuff like that, since they are already implemented for me, and the factor documentation is really good.
Especially looking at the example in the given link (adding 2 vectors into a third) I wonder if it’s really worth it to not use local variables. Also, is there common ground in the forth community about local variables? Are they frowned upon?
Well, in 8th you would probably do: ' n:+ a:op assuming the two 'vectors' are arrays and on the stack. As far as 'common ground' about locals? I don't think so. Some people love them, some hate them. I haven't added them to 8th, because in my opinion they needlessly complicate one's understanding of what's going on.
Sorry, I have no idea how gforth handles locals. 8th doesn't have locals at all, so...
The problem with this often cited post is that the programmer is really shitty at Forth. He just tries to write C in Forth and fails miserably. https://www.reddit.com/r/Forth/comments/2a4zi4/examples_of_great_forth_code/cisg6bq 
So you’re claiming the author of said post does not represent what it is like to be a forth programmer, despite the title which claims to be exactly that?
I’m not sure I fully understand your point … are you saying that it’s rather unusual to pass that amount of data into a word? Or that it’s just unusual to do it inline?
I am claiming that the author fails to write a program in Moore-style Forth. A forth programmer is a pretty wide spectrum. From ANSI Forth C-style guys, complete with LOCAL and LONG-NAMES-WITH-DASHES to Chuck Moore who said that 7 deep data stack is more than enough. 
In the example, the author of the post does everything off-line because there is not context with which to specialize the code towards. In a real world application it wouldn't need to be generalized so much because you could fit your code to an actual problem (such as with the three sensor readings).
I can't find the exact quote about 7 but another take on this is [here](http://www.ultratechnology.com/moore4th.htm) &gt; A Forth word should not have more than one or two arguments. This stack which people have so much trouble manipulating should never be more than three or four deep. &gt; [...] &gt; But as to stack parameters, the stacks should be shallow. On the i21 we have an on-chip stack 18 deep. This size was chosen as a number effectively infinite. His latests processor, F18A has only 10 words deep data stack. 
I may be showing my ignorance, but … that sounds to me like heavy usage of global variables in semi-large or even large programs. Am I mistaken? I can’t possibly imagine living with so few arguments and such a shallow stack.
http://www.ultratechnology.com/levels.htm The general idea (of C. Moore) is that if your solution is semi-large or large program, them your solution is wrong. Mind, i am not advocating this idea. More to say, in many instances it is a wrong to apply this idea. But this mostly due to social, not purely technical reasons. For example, unlike Chuck, most of us are bound by at least OS API and that alone prevents many shortcuts Chuck can make. Hell, he made his own computer chip just so hardware don't tangle his hands. And yes, globals everywhere. But with the style Chuck uses they do not bring problems you see in other languages. Although that's not right. The idea is to eliminate all variables where possible. With that you do not need locals at all and globals become rare and manageable. 
This sounds like the answer I feared I would not get :)
I can’t help it, but this sounds like: don’t tackle hard problems. If a problem cannot fit into a stack 10 words deep just fuck it and go to sleep. Am I wrong? EDIT: Is is possible to put globals into a local dictionary (vocabulary?) to avoid name clashes with other pieces of code?
That I get. That’s something I practice in other languages (usually various dialects of Lisp) already (at least I try). But it seemed to me that is shouldn’t be necessary to have more than 10 elements on the stack in total, at any given time.
I get that one should split a problem into several words, yet having more than one word does not eliminate the need for memory in the form of either (named) variables or elements on the stack (globally speaking). I know that it’s possible to redefine and even forget (is that standard?) words, but shouldn’t that be a last resort?
&gt; It seems to me they screwed up the scoping rules so its neither lexical nor “dynamic” (i.e. global scope &amp; indefinite visibility) I don't know how gforth handles locals; I've never needed to use them, but most Forth use hyperstatic scope. This seems to be what you're referring to above; global scope with indefinite extent. Assuming that we're talking about the same thing then I should like to add that this is not "screwed up". It's not "static" scope or "dynamic" scope, that's true, but why should they be the only options? Our discipline is full of false dichotomies :) Bias: I adore hyperstatic scope and given the choice I would choose it over ether static or dynamic scope. It's safe, and flexible, and very easy to reason about.
&gt; Is it standard is a hard question to answer for Forth. Perhaps it's better to say that if your Forth of choice doesn't implement forget then you can probably implement it yourself with minimal effort. The difficulty is that different Forth's use different data structures to implement things like the dictionary. A linked-list (of sorts) seems to be the most universal, but I've seen tree's, and hash tables, and my own Forth's use an array. I don't implement forget in my Forth's, but it's easy to store the address of a word on the stack, or in a variable, temporarily, then restore it later. This gives you a incredible amount of control over the visibility of words, and It's easy to add syntax on top of this. Doing this kind of thing simply and efficiently is one of the reasons that I ended up using an array instead of a list. Personally I find Forth's that use nested/hierarchical word lists to control visibility rather distasteful, if not unforthy [0] &gt; shouldn’t [redefining and forgetting words] be a last resort? Absolutely not. Words mean different things in different contexts; just look at any dictionary, or thesaurus. Most programming languages try to get around this by using sentences of varying lengths instead of words, and or complicated and inflexible scoping rules, to limit conflicts, but the result always feels less than elegant to me. [0] This quickly becomes complex, for both humans, and computers, and the constant updating and searching of word lists slows down the compilation, and wastes memory, etc. That's Just an opinion ;)
Pretty much any of the ARM boards would be good, it's a nice orthogonal instruction set and they're cheap. You can get an STM32F103 on a wee board the size of a 40-pin chip for about two quid on eBay. That's got 64kB of flash and 20kB of RAM, and "ample" GPIO (you've got timers, UARTs, PWMs, SPI, CANBus, USB and all sorts of fun toys). 
Also, Forth is still in the top 100.
In my experience after telling people about Forth, they get excited to learn it and then express fear of becoming addicted and not wanting to/being able spend as much time with the programming languages that are going to make them money.
People writing more applications would be helpful. And tell the world. It seems to me that in the public mind, Forth is mostly used as vehicle for toy language implementation.
What's Mosaic Industries? It seems like a hotbed of Forth awesomeness. I don't think I've ever heard of their QED-Forth.
Sure, it's a catch 22. It's always a catch 22 when you try to bootstrap (or in this case, revive?) a community. But I don't think there must be oodles of Forth apps, just a few decent ones. Like for Lisp, Emacs and Paul Graham's essays serve to continuously refresh the public consciousness. For what it's worth, I think you're doing a great job advocating Forth in /r/programming etc. I admit that I'm part of the problem myself. I'm also toying with my own Forth. At least I've advanced from playing with the implementation to writing tools.
&gt; For what it's worth, I think you're doing a great job advocating Forth in /r/programming etc. Why thank you :). That's mostly for my own amusement; I enjoy talking about Forth. I have a long standing theory that if the average programmer could be shown how simple and powerful Forth is, they would flock to it in droves. After all Forth makes life so much easier! (Once you get past the surface). I'd hazard a guess that many of the people here came to Forth for a similar reason. Maybe talking about applications isn't the best approach? Getting people interested in various applications is hard, but we programmers like talking about languages. Perhaps we need to appeal to the interests/curiosity of our fellow programmers? :) Another tutorial on how to create a toy Forth isn't going to help anyone but what about a manual on how to build a useful Forth system that can be used to solve real world problems? That would certainly have got my juices flowing when I was starting out :). I've been wanting to write such a document for years. What it absolutely couldn't be is one those build a toy Lisp interpreter in 30 days books, which don't go anywhere, but apparently teach you C? ;) EDIT: maybe something like the excellent Project Oberon book, but intentionally shorter, because Forth is supposed to be the simplest thing around right? http://www.projectoberon.com/
Looks like this has since been [x-posted to HN](https://news.ycombinator.com/item?id=12090985)
Sorry, stupid venting in the other reply. I closely watch GitHub for new Forth repositories, and I see 99% toys and 1% useful code. Your suggested book sounds great! I'm sure it would do good. I'm afraid most programmers don't look very far beoynd the surface. Lisp has the same problem, in spite of having at least one very good (and now free online) book about building useful applications. But new Lisp programmers do seem to trickle in. Forth would do great to grow at a similar rate. In the Lisp world, there's a brouhaha about a new dialect called Clojure. To me it doesn't seem to add much beyond sparkly newness, but apparently that's what it takes to attract fresh blood. Perhaps a new Forth (yours?!?) could do the same thing.
It's here ... under a tentative name https://bitbucket.org/rogerlevy/bubble-platform
it seems private.
Oops, forgot. Fixed! I was going to make a proper announcement when things were more ready.
Personal account. I've tried to pick and choose from these transcripts and I think I've succeeded and continue to improve thanks to some of Chuck's virtues. But some of the things in here are total red herrings, like the advice not to use the double words. I have not had a major problem in my game programming dealing with 2D or 3D coords on stack. Not to say it wouldn't be an interesting experiment to try passing addresses around, but trying to implement too much of what he suggests at once is asking for trouble. His problem domain is teeny-tiny, and he keeps it that way as part of his philosophy, that's why he says unbelievable stuff without even a hint of irony in talks like this, he just wasn't thinking about or concerned with a complex problem *at the time*. Some of his sayings come off as absolutes when he's really speaking in context.
The good intention of standards is to ease compatibility but IMO close collaboration is effectively the best kind of standard, because a language is a living thing. If we try to freeze it (and thereby kill it), it will be, well, dead.
Hey, this is Forth. We don't collaborate, we write our own! :-)
https://news.ycombinator.com/item?id=12118241 https://news.ycombinator.com/item?id=12118255
I'm posting this here, because it seems the exact opposite of Forth style, where small factors are promoted. Thoughts?
I'll start? I know it's not technically part of the [bulk of] the essay but: &gt; you should be made constantly aware of the full horror of what you are doing. When it gets to be too much to take, figure out how to factor blocks out into pure functions This bit at least strikes me as Forthy :). It's certainly possible to overdo the factoring or forget that there is a cost to our factoring, in terms of both machine resources and complexity. I think the advice that you don't want to have more than more that 2-3 things on the stack may apply to the callstack as well. Code that keeps the depth of the call stack to a minimum will naturally be easier to read, if only by not making you crawl through 20 definitions to get to that one bit of code you're interested in (I'm looking at you here Gforth :P). EDIT: On this point I'd like to quickly relate the depth of the call stack a common situation in large object-oriented codebases. I used to work as a Smalltalk programmer for the biggest remaining Smalltalk vendor (I wont see who but feel free to figure that out yourself.) One of the biggest problem that we had on a very large (1M+ SLOCs) Smalltalk program was the shear size of the class hierarchies and the 'depth of the call stack'. In Smalltalk it's very common to create a lot of classes and hierarchies, and like in Forth, it's very common to write a lot of very short methods on them. This works on the small scale (and one could definitely make the argument that if you have 1M+ SLOCs then *you're doing it wrong*), but in a large system, religiously factoring like this will quickly lead to code that, while very readable, can't actually be read. From a practical point of view it's just not feasible to follow the code down through all the layers, even when there isn't very much code down there. You simply can't know until you start pulling... and after a while you wont want to do this anymore because it seldom leads you anywhere. Admittedly this is much worse when you make heavy use of late-binding, which Smalltalk programmers love, and Forth programmers tend to use only when they need/choose to. EDIT; Personally I've found myself writing relatively large definitions at the start of a project and factoring these definitions, as necessary, or when I have enough code to see common patterns. The hardest part for me is finding good names for words; names which are concise while still being short. I think i have a pretty ingenious solution to that but I'll get in to that when I reply to another comment of yours (I'm on holiday at the minute.) Good design is all about making the right trade-offs. &gt; where small factors are promoted. That's part of it, but for me, and I know Chuck might disagree with me here, I think that Forth is about accepting that there will be trade-offs to make and that all else being equal, the overall simplicity of the system (holistically speaking) should be preferred. To me the factoring part is the icing on the cake :). A means to the end, which is overall simplicity. But of course, the system must actually solve the problem etc.
&gt; If, on the other hand, you privilege chosen data structures and syntax you must then resort to building upwards with the ill-fitting selection of primitives because you can't change what's below. But my point is that FORTH is not a language suited to sophisticated data structures, which is really about design abstraction. If you need to write B-trees, queues, and X-dimensional arrays, you're better off writing it a higher level language. If actual FORTH developers think its critical to have available a specific data structure, that could be grounds for a "library" or "module" for a future ISO standard. But most likely, it'll only be used once, and its not worth the bloat it will impose upon a ISO compliant FORTH.
I would agree with you that there's little emphasis on building sophisticated data structures and algorithms in Forth. It's more about having a lexicon that describes your problem.
I do not see why other languages should be principle better suited for higher order data formats other than such formats are likely intrinsic part of a type system and as such usable to generate optimized machine code. It may be that implementing them dependent of the Forth environment is not possible without some intrinsic overhead and compromises as the ANS standard is implementation independent specified. 
This doesn't answer the Forth aspect of your question, and I'm very late, but you may possibly be fascinated with the thoughts and ideas put forth at http://abis.io/, which I stumbled on a little while ago. Just discovered this tab was still open, so thought I'd mention this info just in case it's interesting (it may not ultimately be useful). As for the Forth aspects, going mailinglist/newsgroup-hunting may be of use - this reddit community is a bit small to get in-depth advice. Of the various programming-language-design subreddits, /r/ProgrammingLanguages is the most active (the others have their most recent posts months or years ago), if you'd like to ask in a more generic forum.
Out of curiosity, how is 8th doing in terms of adoption, and finances? Your business model seems airily close to other companies who've tried to sell programming languages, and are now out of business. Whenever I look in to 8th I'm reminded of REBOL. A lovely little language that didn't go anywhere purely because of the business model; after more than a decade of struggling go gain significant adoption, listening to people dismiss it purely because of the licencing terms, Carl Sassenrath admitted defeat, and released everything under an open source licence. Personally I wouldn't hitch my wagon to a proprietary programming language that I don't have any control over these days. What happens if you were to stop developing or maintaining 8th? Good luck!
&gt; It's a slow uphill battle, but we're gaining adherents. Nothing to compare with Python et. al., certainly; but that's to be expected. That's wonderful! Are you able to share any numbers? What are the reasons people give for using 8th? :) &gt; In terms of control, we do now offer the source-code for "Enterprise" licensees, which ensures they have the ability to continue with 8th should we for some reason stop developing or maintaining it. $2999 up front and $249 yearly is a lot to pay if all that I need is to know that I'll be able to continue if 8th is no longer developed and maintained. I could stretch to a professional licence, personally, but access to the source code is well out of my range. Perhaps you could provide access to the source code (with the NDA) with the professional licence? Or otherwise make a "promise" to release the source code to everyone if you stop developing and maintaining it? But I guess the problem is then, what if you sell 8th. Any previsions would have be binding to reduce the risk of investing in 8th and that would probably destroy the sale value. As it stands there are too many what if's. &gt; We do also do consulting and custom development work; at this point, that is the main income-stream. It's good to hear that you're your own primary user. The company that I work at created a Forth system for our own use, and we keep developing and maintaining exactly because it fits our needs better than anything else.
The numbers are not too impressive: we've got about a thousand dedicated users, mostly free-licensees. We're trying to give them a reason to move to something other than 'free', and likewise trying to give not-yet-users some incentives. As to the users' reasons, it's a good question. We've got some incredibly enthusiastic users, but I'm not sure there's a unifying reason behind them all. We could probably offer a source-code license separately. Something to think about, anyway. We have said in the past that if we were going to shut things down for some reason, we would arrange to make the source available. At this juncture, I don't see investors lining up to buy the company, so "selling 8th" (as a company) is not too likely. Selling programming tools is not a very profitable business...
There just so happens to have been a discussion in c.l.f on alternatives to Forth `struct`s: https://groups.google.com/forum/#!topic/comp.lang.forth/ylYNgTm1UVM
Impressive rant. I've seen better though, throw in a few more wild presumptions ;)
&gt; Old Forth seemed to have the luxury of working in a vacuum. Today we have too much tech to let go to waste by pretending to still be in such a situation. Seems like for Moore, step 0 in a project is to prepare that vacuum.
Let me take a stab, as an exercise (I'm not a Forth veteran). * A struct implies "many"--you don't reach for a struct when you have one of a thing, you just make a few variables. You probably need at least three things to motivate a struct, unless your things have a whole bunch of parts. * Many structs will either be elements of an array, or be instantiated in an ad-hoc way, perhaps as black boxes that you use to communicate with a library, or perhaps as an abstract data type like a vector. * If it's an element of an array, what you've actually got is a table, and a table is a kind of database. Take a step back and format your database and its accessors as a whole. * If it's for communication with a library, you may be stuck with it. If it's for communication between parts of your program, see if you can simplify it by turning the part which would be managing the struct into a stateful portion of the program, instead of having it be driven by struct data. This may imply a database if you actually need multiple sets of this state (e.g. a database of sound files). * If it's an abstract data type, rather than passing struct addresses on the stack, maybe you want a couple of registers or a custom stack to hold this data type.
The problem with structs is not that they're too abstract - it's that they're not abstract enough. When you use a struct in C, you're nailing yourself to having it be a named field. In Forth, you can do that, but you can also do things a little more cleanly - or a lot less... without changing the interface code at all, because Forth doesn't erect the barriers between syntax elements that C does. The meaning of sprite[i].width can't change in C without implementing it as width(sprite(i)) which will upset C programmers. Moreover, if you suddenly realise that you're using widths all the time, and clobbering your cache by not being able to run through them all at once, you have to change that code again, to width(sprite, i) However, in Forth, i sprite width is the natural way to write that, whether you're using straight structs, pointers to structs, arrays of fields, objects, or something that calculates the width on the fly. Which in turn frees you up to think about how your application actually accesses data, and what you need to do to make that efficient. (And as it turns out, a lot of the time separating out frequently-accessed fields and putting them in their own arrays really *does* pay off in cache terms. And dynamic objects and cache are not the best of friends at all... More generally, don't confuse an acceptable general solution with an excellent specific solution - and particularly, note that Forth, at least as practised by Chuck Moore and reflected in Jeff Fox's articles, is *all about* finding excellent specific solutions rather than living with acceptable generalities.) 
Interesting topic, new to FORTH and was likewise confused to the meaning of statements about structs, lots of good new to me info in this thread. Came across a data base support package in Polyforth which seems to be used in lots of early FORTH, Inc. projects. This is the closest I have found to significant, semi-modern application codebase written in a Chuck Forth style. Be extremely interested to hear any opinions on it as appears largely overlooked and could imagine using it idea's as an alternative to structs. https://github.com/DRuffer/vf-plugins/blob/master/vf/Plugins/doc/pfDatabase.pdf http://code.google.com/p/vf-plugins/downloads/detail?name=pFDatabase-5.zip
&gt; Beware object think. Objects are not only uninteresting, but, in my opinion, are dangerous. Opinions are cheap! Please elaborate.
I'm sorry but it is not my intention to tell other programmers how there 'should' program in Forth. However, if you are interested I will take the time to explain what I mean though examples and discuss comparably why I program that way (involving a more philosophical perspective). Because that is not possible for me in some hours, please understand that such assay would require some time to write (I am at current busy at work).
I have often problems understanding essays about Forth programming, but this I understand. Everything but the most hardware technical items! It's funny, but when we found Forth and discover the wonderful freedom of programming, we start to restrict our Forth and make it more like the limited languages that we have abandoned. Layers for its own sake is trying to sweep Forth under the carpet.
I am definitely interested. Feel free to post about it whenever you have the time.
solved that by replacing all the cpp command to cpp -P
I'm interested in this! I have given my three-year old son a VT420 text terminal, and hooked it up to an rPi running my own Forth. Some additional sound capabilities would be great.
&gt; The hardest part for me is finding good names for words; names which are concise while still being short. I think i have a pretty ingenious solution to that but I'll get in to that when I reply to another comment of yours I'd love to hear about that! Naming is hard.
There are also these: https://github.com/niclash/forthright https://github.com/zeroflag/punyforth EDIT: wrong link, see below.
Sorry, wrong link! I mean to post this: https://github.com/CraigLindley/ESP8266Forth
I'm playing with alternative user interfaces. The experiment started when I wrote a small program to edit bitmap fonts, making it easy to create new characters or symbols. I am a big fan of APL, and it wasn't long before I'd added some of the symbols that I missed. This worked really well and the code that used them felt much cleaner. This got me wondering how far I could take this idea. To be clear, this is just an experiment. I'm not sure where it will end up :). Rather than storing a textual name for a word I now store a small bitmap, and have a modified bitmap editor which lets me create symbols easily. Since the system was already predominantly mouse-driven this approach was a natural fit. We use the keyboard very little so we don't have the problem of having to remember what keys are bound to what symbols. This obviously isn't without it's problems. For some things, coming up with an good symbol turns out be very easy, for others it can be a challenge. When it works the code is much cleaner. What interests me right now is that it's much harder to come up with bad symbols than it is bad names; perhaps this is because short names, which we prefer, tend to be quite vague, and overloaded, out of necessity. One thing I've started doing to overcome the difficulty of creating new symbols is combining existing symbols, which feels rather Forthy to me. Often the name of a short word is an amalgam of the names that make up its definition, or some of the more important symbols, representing the main idea's. That seems to work very well, and gives an interesting definitions a kind of transparency. Moreover, the more symbols I create the easier it is to combine them to make meaningful compounds. At this point I'm finding it quite striking just how poorly our English words, which describe the world around us, no longer seem suited for describing the world inside the computer. There were a number of cases notable where struggling to find the right symbols to represent some idea has led me to see relationship that I just hadn't been able to see before, because the English words I'd chosen were hiding the fundamental relationship. The resulting factoring was simpler and the design of the system clearer for it. I'm still figuring some things out but I've been able to describe the whole of our system using only these symbols. EDIT: One area I'd like to explore further in the future is embedding hints, like the possible error cases, or stack effects, directly in to the design of each symbol. The theory is that if these things are clearly visible at all points, we'll be able to spot/prevent many common errors and mistakes before they happen. I'm continuing with the experiment for the time being in the hopes that I'll find a fundamental problem with it, but so far I'm quite happy with it. There's the possibility that this will end up in the system which we're working to open source right now, and are writing documentation for :). If you or anyone has any thoughts on this, I'd love to discuss it further.
You seem to have outdone Chuck in creating a ~~weird~~unconventional variation of an already obscure programming language. Good job! :-) I feel I'm married to programming in the ASCII character set using a QUERTY keyboard, so what you write seems alien to me. (Yes, I do recognise those are legacy technologies which have many problems.) I'm trying to imagine what it's like to program in your Forth. It seems like learning to read Chinese anew each time you see another program. (I've dabbled in Chinese; many characters are composed of symbols which hint at their meaning.) Is this your personal experiment, or is everyone on the team (or end users) exposed to this, and if so, how was it received?
You may well be right. At this point nothing is definitive. Symbols have the advantage that when they're well chosen they're self explanatory; combining several self explanatory elements tends to lead to symbols that are themselves self explanatory. Inventing new symbols in this way is incredibly easy. This worked very well for the Chinese, who according to some sources invented some 70,000 symbols using this approach (I'm simplifying a bit, to make a point.) Moreover if you have a whiteboard handy it is very easy to explain a system by drawing a few symbols on the board and pointing to them, while discussing the various ideas. Everyone who I've done this with has found it easy enough to follow, despite being very unfamiliar with it. On the other hand, inventing words? I wouldn't know where I'd start. There's too much historical baggage. In contrast to inventing symbols, sound words is essentially arbitrary. Inventing phrases is pretty easy. Perhaps that is what you meant? In any case, having discussed the approach with a number of people over the last week I have reservations that it could be adopted outside of the company. Not for any overarching technical reasons. It's just not what people are comfortable with; the initial reaction is one of shock. As such it's looking more and more likely that we'll revert the changes :-). Maybe it could be made to work but it's difficult fit for the world we have.
You might be right, but this isn't Chinese. Chinese is hard to learn because it has evolved in unpredictable and unexpected ways over about 5000 years; some characters make no sense anymore, the meaning having changer dramatically. It got particularly weird when they started adding phonetic components to characters. English is similarly fucked up, and for similar reasons :-). Both languages require users to learn about 300 words for basic literacy. An educated man, as I'm sure we all are, knows between 7, 000 and 10,000. I don't remember struggling too learn that many. The human brain is quite miraculous! In contrast, only I needed only invent few of handful characters. Everything else made of them. All of the characters are immediately obvious (when learned in the right order) and build upon each other in very predictable ways. There's no arbitrary variation in stroke ordering it etc. or any of that complexity. Everyone can remember a couple of dozen symbols and a few rules on how they compose. The composition is the only unusual part. All of us already know a few hundred different symbols; drivers especially, have to memorise a few hundred road, and bathroom signs, application icons, logo's etc. Pay attention and you'll realize that you already know a great many symbols. It's as much a myth that Chinese is a pure ideography as it is that English is a phonetic alphabet. The need for symbols is as readily apparent to our society as the need for phonetic indicators are to the Chinese. All I've done is create simple, compossible roadsigns :-). I saw this video a few years ago and have since read both of her books on Chinese, as well as other books on chinese. I can't speak Chinese (speaking it doesn't interest me much) but I learner enough in a couple of weeks to get by. I can make sense of menu's etc. but I would need to put much more time in to building vocabulary if I wanted to improve. https://www.ted.com/talks/shaolan_learn_to_read_chinese_with_ease :-) anyway as I said at the beginning, this is just a little experiment. As with all such things, it's a tradeoff. There are pros and cons to both approaches. Sadly the big pro for the existing approach is the big con for this approach.
Going off on a tanget here: I belive it's 3000 characters for basic Chinece literacy (that's what my teacher claimed). And then Chinese *words* are built of one or more characters. (As you should know, but most people seem unaware of that.) I certainly struggled to learn a few hundred Chinese characters. Props to you if you got far enough to get by! But back on topic. I certainly believe your language is much easier to learn than Chinese. Without actually seeing it, I can only speculate. The examples in the video are cute, however the bulk of learning Chinese isn't that easy. But I can well imagine that a ideographic programming languge could be.
I've truthfully never really considered it appropriate, for FORTH advocates to throw stones at UNIX; although I know it's a popular pastime with some of them, and from memory Mr. Moore himself has expressed some opinions which are not exactly complimentary. There are a couple of things that need to be kept in mind here. a} UNIX was always intended to be a generalised, rather than a specific or dedicated system, and has never pretended to be otherwise. I understand that in FORTH terms, generalisation is usually considered something that you are going to burn in Hell for, but UNIX people usually don't seem to consider it much of a problem. The only time I'm going to be opposed to generalisation myself, is if it gets completely out of hand and silly like it largely has with contemporary Linux. A kernel offering a basic file system and some convenient ways of interacting with hardware, however, are not necessarily bad things in my opinion, as long as they don't get out of control. b} Whether FORTH people (or even I myself) like it or not, the reason why UNIX became so popular is because it provided services that most people genuinely wanted. Yes, the code required for said services might well end up a snarled, tangled, unmaintainable mess, but that does not remove the fact that said services are wanted. Memory and hard disk mapping, multi-user support, timesharing, and networking can all be very useful things to have. c} A bash shell with the POSIX utilities is a lot closer to FORTH than some of you might realise. The main difference is that bash does not let me interact directly with assembly. Granted, many of the POSIX words are probably not implemented anywhere near as simply as they would be in FORTH; but the test command lets me write AND gates which are more elegant than the equivalent in raw assembly. Abstraction might be bad most of the time, but it isn't ***always.*** d} UNIX at least ***tried*** to give people what they wanted. The FORTH community never really have. They have simply complained about how horribly complex UNIX is. The issue here is whether or not we want to consider FORTH as ever having been in competition with UNIX; which frankly I don't think is appropriate, because the two things are very different. FORTH is a control language for either physical or virtual machines, and again, in that sense is analogous with the UNIX shell; UNIX, on the other hand, is an operating system. I think the reason why UNIX caught on where FORTH didn't, is because UNIX was designed for centralised hardware, where you had architectures that tried to do a lot of different things at once, which is what the hardware people were producing. If I was going to use FORTH, I'd ideally want to design hardware specifically for it first. That would mean that timesharing and all of those other things I mentioned earlier, would each have their own dedicated physical processor, and every different processor would have a contextually appropriate FORTH vocabulary, with nice clean registers. That would be the way to do it. FORTH has always needed and wanted dedicated hardware, whereas UNIX is generic. UNIX was designed to let me slap it onto a DEC machine from Kali knows how long ago on the one hand, or a contemporary x86 machine on the other, and not have to care about the boring details. Yes, you're going to lose some (and probably a lot) of optimisation doing things that way, but UNIX people don't care. The entire UNIX philosophy is predicated on the idea that 50% of functionality now, is better than 100% of functionality never. The priorities are different. The below old logo for NetBSD may prove instructive, here. http://www.netbsd.org/images/NetBSD-old.jpg UNIX was intended as a generic toehold or beachhead system, and in that sense, yes, contemporary abominations have far exceeded the original mandate, and FORTH advocates are entirely justified in criticising those as much as they want; I'll join you. As overblown and generally disgusting as it might be, however, Ubuntard still serves the same purpose. In original terms, though, UNIX was intended to be the computer equivalent of a packet of cake mix. An instant cake might not taste as good as something you can bake manually, it will be more expensive, and it will probably also be less nutritious; but the point is that you can use it to get a cake relatively quickly and easily. Writing a FORTH for strange hardware might take me who knows how long, whereas given how prolific UNIX already is, the size of my necessary diffs might well be less than 15% of the overall system, (which it definitely is for BSD on most hardware) and then after that, I've got a working system. It's about getting a pup tent pitched, not recreating Notre Dame.
Author here, thank you for your interest! Sorry for lack of updates to the code, I've been working a lot to design the language, considering whether to have branching or not and how to communicate with C. In the end, I decided to have branches, they were trivial to implement anyway. Next up is command buffers to communicate with C and even Forth (since they would be stacks too), instead of calling C functions with FFI. I'm excited to tell you I'm writing a rather long post about what I want to accomplish with this and ideas about tools to make programming fun. A lot of those ideas were recorded with a lot of notes and audio so it is taking a bit of time to organize them all into clear and coherent writing, which is harder than I imagined. Stay tuned for updates soon.
[removed]
Nice writing. The passion shows!
Known issue. Fixed, too, in [my fork](https://github.com/fuzxxl/jonesforth).
&gt; Such a [Lisp] dialect, however, would of necessity be close to the hardware, and wouldn't have garbage collection, types, and other things we tend to take for granted. This sounds exactly like what I am most interested in currently. I love Lisp, because it fits my way of thinking very well, but a usable Lisp system always seems to be quite complex. Forth on the other hand is so beautifully simple that I almost cried when I finally understood how it works.
Hey, it's very immature.
that's what i need. if you have checked the log of #forth
sorry its not a completed one and as it claimed, only runs on lbforth
No, I didn't check #forth. Pull requests are welcome.
Like to know more about those "Leap" keys.
I'm not familiar with vi, so I'm not going to reimplement it.
My lbForth is mostly my personal toy. It could be used for serious work if need be, but it's not a priority right now.
&gt;[**Leap Technology [17:34]**](http://youtu.be/o_TlE_U_X3c) &gt;&gt;Promotional video introducing Leap, the revolutionary navigation technology invented by Jef Raskin. &gt; [*^aamoviebb*](https://www.youtube.com/channel/UC7aGoyZAsInFMmlg7KH-1PA) ^in ^Entertainment &gt;*^4,724 ^views ^since ^Apr ^2011* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
Cool, SLIME has always been awesome and it'll be great to have something like it for Forth. How can I find a list of commands / bindings?
Would you recommend that I use Forth and turn it into a Semi-Lisp?
Unfortunatly, it isn't. :( I don't think I am smart enough to fully understand the 1000+ lines garbage collector, let alone be able to effectively modify &amp; debug it. Also, it's complex enough that I couldn't easiely figure out (by looking at the source code) whether it supports tail call elimination or not. (Turns out that it doesn't and the author thinks it shouldn't and you should write loops instead. Oh well, I find tails recursion to be easier to write than loops nowadays.) EDIT: Don't get me wrong, PicoLisp is awesome, but not quite what I'm looking for. I already wrote a [Lisp interpreter](https://github.com/wolfgangj/bone-lisp), and while I enjoy using it a lot, parts of it ended up being more complex than I would have liked; also it's written in C and so depends on a large complex foreign compiler, and being an interpreter it's not particularly fast either.
The tips presented there apply to Forths as well as to other languages
Perhaps that's because they're such general rules of thumb that they don't really need mentioning? What I mean is, they should be fairly obvious to anyone with a few years of experience. The only remotely interesting thing on your list is that accessing variables in 8th may be slow, but I'm not sure why that would be and I don't think it applies to Forth in general. I admire your persistence but at this point I've developed a a knee-jerk reaction to seeing anything 8th, If you're going to submit links then it would be great if they had some content. Right now it just seems like an excuse to say 8th repeatedly and it's becoming a bit annoying. Anyone who's reading this subreddit knows your product exists, and you're not making any friends. Contrary to popular belief, bad publicity, is bad publicity!
&gt; and picolisp's is a simple stop-the-world mark &amp; sweep collector, with no compaction or anything to worry about. About as simple as a GC can be Exactly! That's the problem. I've done enough GC-debugging that I never want to do it again - even with a "simple" GC. Well, at least not in my free time as a hobby. :) I'm more interested right now in alternative ways of managing memory. &gt; Even detecting tail recursion is a tough ask in such a system - the last 5% will kill you. I wouldn't mind if the last 5% are skipped and e.g. calls to "eval" and "apply" will never get tail call eliminated. I also don't mind a special form like Clojure's `recur`. &gt; most of the eyebrow-raising decisions in picolisp (...) have clearly been taken because they're the easiest to implement. I'll try to prove you wrong by implementing a simpler Lisp, but it'll take me a few years. :)
Do you know shell scripting? Do you know here documents? Imagine you have a shell prompt and your only way to write a script is with here-documents. When you write `cat &lt;&lt; EOF`, "EOF" becomes an immediate word in your here-document. Without such a word, you could never escape from inside the document, and your system would be unusable. Of course, this is not the whole story. Immediate words are useful for more things that finishing a word definition, but I hope it is a good example to help you understanding their importance.
You can do anything from immediate words, since you can execute arbitrary code. Otherwise all you could do is compile words. (Personally I always found the term immediate word unhelpful and prefer to think about compile-time execution, and compilation.)
Sufficient, but not necessary. (Immediate *words* are necessary, though - or at least, so useful as to be a virtual necessity - so some mechanism has to be provided for them.) Chuck Moore's Forths have always tended to avoid a state bit, preferring other, more generalisable mechanisms - for example deferred words, or macro vocabularies, or treating ] as a compiler loop terminated by [. And there are good reasons for being hesitant about coding state-smart words - not least that the state might not be what you think it is at any given point, and a state-smart word will invariably do the wrong thing. As Chuck Moore said in Thinking Forth, "You can say ``GO`` or you can say ``PRETEND``"; the implication is that having a ``PRETENDING`` bit control what ``GO`` does is a recipe for confusion at best.
Consider : &gt;DIGIT 48 - DUP 9 &gt; IF 7 - THEN ; Don't worry about the magic numbers; the important thing is the ``IF .. THEN``. Without immediate words, ``IF`` and ``THEN`` would just be compiled as normal words... and ``IF`` would have to scan ahead for ``THEN`` and resume interpretation from that point. Sounds doable... but then consider: ... IF ... IF ... ELSE ... THEN ... IF ... THEN ... THEN ... Now ``IF`` has to search ahead not only for any old ``THEN``, but for the ``THEN`` that matches it - or for an ``ELSE`` that matches it - which means keeping some form of bookkeeping as to which one it's doing. And that bookkeeping has to be re-entrant. That's a lot to do at runtime, especially in bits of code where performance is likely to be a critical consideration! However, with immediate words, you can define IF as a word that lays down a conditional branch with a placeholder destination, and THEN as a word that fills in that destination with its own address. It's a lot easier. Of course, it's not the only possible approach. If Forth had block structures - so for example, you could write { 10 0 DO I . LOOP } EXECUTE and have the digits appear on your terminal - you could define IF, and other control structures, as combinators, so the above word would become : DIGIT 48 - DUP 9 &gt; { 7 - } IF? ; But that brings up a chicken and egg problem: How do you define ``{`` and ``}`` without immediate words? *With* immediate words, it's easy: ``{`` stores the address of the code being compiled, ``}`` retrieves that address and shuttles that section of code off to the top of memory, leaving its address on the stack or compiling it inline. *Without* immediate words, you're back to scanning the code stream at runtime for ``{`` and ``}`` and counting nesting levels. And then there's the word that's in every definition, but whose function is always forgotten: ``;``. If you don't have immediate words, this needs to be specifically searched for by the compiler, in order to stop compilation and return to execution mode. And the compiler needs to worry about what happens if it runs out of input before seeing a ``;`` - although at least nesting isn't a thing in standard Forth. However, there's also ``[``, which puts the compiler on hold for a while - so now the compiler is searching for two special characters - and that set can't be extended without rewriting the compiler. (This is how Lisp REPLs were written before reader macros, incidentally. Forth's immediate words replace reader macros, rather than fexprs or DEFMACROs... and neatly demonstrate that reader macros, rather than Lisp macros, are necessary and sufficient for an extensible language.) So avoiding immediate words leads to an awful lot of special-casing all the way through the entire interpreter structure; it also means that that interpreter structure ends up unchangeable, and almost certainly can't be defined from within Forth itself. And it takes a *lot* more code. Even adding one immediate word eases the load considerably... and once you've added one, why not make a mechanism that lets you add as many as you like? And suddenly, everything gets much easier. And just to screw with your mind a bit more: consider that IMMEDIATE is generally *not* an immediate word - and how that could be put to use...
Yes, state-smart words have problems. On the other hand, I feel that some people overstate those problems.
The four first tips are great, but I don't know about the other...
Also see Peter Knaggs' [Ph.D thesis](http://www.rigwit.co.uk/thesis/), particularly chapters 6 and 7.
/u/lehs /u/jyf and anyone else who might be having difficulty hearing the video: I've written a transcript. Enjoy. https://gist.github.com/marksmith/7e50ecad82d2c4998a1211791f6b610b Please report any obvious errors :-)
He is right about everything he says. Forth is too good for the world, however. Thanks for the transcription! Very nice! I wich he makes a cellphone that I could program myself. And a car too!
It's a bit difficult to read on github - you have to keep scrolling right and then back left again over and over. 
thanks for that, english is not my native lang, so hearing might be a problem for me. basiclly i hope all of the video could at least have a english subtitles
&gt; You don't tell me what to do! IM JUST HAVING FUN OK!? This is the best, short summary of Forth I've seen yet.
As much as I love FORTH and would like to say that it is valuable in a business setting, I really don't have any experience to back that up. I pretty much scream this mantra in my head for every line of FORTH I write.
thanks very much. i am quite interesting of the brower written in Forth he mentioned, any tips?
you are very right, I really should write more documentations about it. I will soon write something for you, once I settle down my nomadic life (&gt;_&lt;) 
I look forward to it. I am very interested b/c I am working on a typed Forth. If there is anything I can do to help...
I guess it's half Forth, so to speak... but I'm not sure it's the defining half. I have no interest in 8th, personally, and it's not what I come here for. As for what I'd consider Forth, personally: * Two stacks, one for data and one for return/control. * Immediate definitions - see previous discussion. * No parser - just WORD and FIND. * No inherent data typing. * CODE definitions. * DOES&gt;. **edit**: I forgot what's possibly the most important characteristic: Interactivity. If you can't write a colon definition and try it out on the same line, at the keyboard, eg: : double dup + ; 16 double . it's not Forth. Forth is emphatically **NOT** a batch-mode language; the whole point of it evaporates if you force it into that role.
&gt; Personally I don't think Factor is Forth. &gt; I can give you a long list of reasons for that but the fact that they list Forth as one of many influences, along with Lisp etc. seems like a big indication that not even the Factor community thinks Factor is Forth ;-). That's a well reasoned arguement, and when I see it in that light I think I would agree, Factor does feel a bit like a lispish language with a syntax and quite a bit of inspiration from forth :) &gt; That doesn't mean that I have anything against Factor or the people that use it. I just don't think that articles that are specifically about Factor and are only relevant to people using it belong here. This is /r/Forth and you're allowed to subscribe to more than one subreddit :-). I do see this as well, and I go to this subreddit to get forth info, and to hope that I once get around to find motivation and inspiration to being able to do string handling and other stuff in forth, it's just an arguement that I see lumped at factor quite a lot, that forth is outdated (I don't think like it neither about forth nor factor) so I was thinking why not asking someone that knows :) Then we have stuff that lies on some other vector, like 8th and oforth, both not really forth, but concatenative and a bit forthish. &gt; Now to be absolutely clear on this point: if there's an article of general interest to the Forth community that happens to talk about or use Factor then it's more than welcome here. Hell if it's an article about C that happens to be relevant to the Forth community then bring it on! Yup that's how I think as well, and it's why I don't submit factor stuff here, sadly the factor subreddit is even more dead than the forth one, so I have to go other places to learn about or discussing it. &gt; That doesn't happen on /r/Forth because the number of articles is too low. Consequently you get what amounts to an advertisement for a commercial product sitting at the top of the front page for weeks on end. This is the situation we're getting in to with 8th right now. Again I do agree, and I wasn't trying to defend the 8th-evangelizing, it just hit me to ask about factor when I saw the 8th isn't forth line :) &gt; As I said earlier, if /u/8thdev wants to start publishing content that's actually of interested to people here then that's great. I don't think anyone has a problem with that honestly. For from it! I think we'd applaud the efforts of any company putting time and effort in to making a bigger and more vibrant Forth community! I would welcome that as well.
&gt; I might like to add to me Forth is simplicity I would agree with that, but it's possible for something to be as simple as Forth and yet not Forth - for example, FALSE. I'm not sure it's possible for an interactive, extensible, self-contained environment to be as simple as Forth and yet not Forth, though. Unless colorForth counts as "not Forth" - but that's not a point of view I'm keen to advocate.
/r/Forth has this to say about Forth Why Forth? 1. You can try things out interactively as you build your system. The compiling functionality is an exposed part of the language like everything else. 2. It can be used to debug itself! 3. Forth has no baked-in syntax or privileged data structures -- programming is done by extending the language to your application. Thus, it can become what ever you need it to be and fit the problem like a glove. 4. Forth has a "low floor; high ceiling" approach to abstraction -- that is, it can be both low level, high level and anywhere in-between. 5. You can do more with less. Forth fits in very small storage spaces. 6. Forth is one of the few environments which is totally comprehensible by one person. So I guess we could start by asking: are these statements true of 8th?
&gt; That's the main reason that we use **things like reddit** over comp.lang.* isn't it? I realize you were making a very real point about the attitude on comp.lang.forth and probably understood what I was getting at, but in case I wasn't clear enough there, I was referring to difference between reddit, hackernews, stackoverflow, dig and the good old forums and news groups is that users can vote on various aspects of the discussion and the site responds appropriately (though certainly imperfectly at times!) &gt; I guess John Passaniti won eventually, if outliving your interlocutor can be termed winning. It's a bit off topic but I'm curious ;-). What arguments are you referring to here?
I don't know if it's Forth, not having done all that much in Forth myself. But I am tired of self-promotional advertising about 8th.
[I helped get /u/8thdev unbanned from reddit](https://www.reddit.com/r/Forth/comments/3kwj7u/whats_the_best_modern_forth/cvhxda9) when I couldn't see his profile to know it is 100% self-promotion. Perhaps it was a mistake to get him unbanned. He's also spamming /r/programming and [the LinkedIn group](https://www.linkedin.com/groups/3385416) is even more overloaded with his posts. I think this sets the wrong first impression for potential new Forth developers. /u/8thdev you've violated [reddit's rules on self-promotion](https://www.reddit.com/wiki/selfpromotion).
In my opinion, 8th is a "stack based", "Forth like" programming language. I wouldn't call it Forth.
From what I've read about it, it looks like it is a real Forth. I agree that the business model is old fashioned, and thus feels a bit spamy. But they have every right to post here. It would help if there were just more posts on this forum! P.S. /u/8thdev have you considered opening up 8th and just selling support and a few of the add on packages, plus it would be cool if you spoofed up the documentation a bit more and sold it in some of those nice old school three ring binders. I think you might have more success that way then trying to sell the actual language. (Yes, I know there is free lite version, but I mean beyond that.) In any case spreading the release dates out a bit might send a better signal. 
&gt; It seemed to me in my naivete that a Forth discussion group would contain some people who would be interested in hearing about a new or different Forth. It certainly does! **But then you actually have to say something about your new or different Forth**, not just post lists of fixes, short "real-world" examples which draws ASCII art diamonds in the terminal, and link to the website, where in all fairness any understanding of what 8th is, or what it offers, is completely lost in the mountains of marketing buzzwords. I've looked at the website multiple times and I still have to ask the question. What is 8th? What's it's niche? Is 8th Forth? It certainly has some syntactic similarities but there are significant differences: it makes heavy use of quotations, and high-level data structures, and it presumably has a runtime that is managing memory for these things, and seems to restrict access to memory. But that's never actually said anywhere? Please correct me if I'm wrong here. I would personally love to read more about 8th from a technical point of view. Why/how did you arrive at this design? What problem were you trying to solve? What do you (as it's designer) think it's (the designs) strengths and weaknesses are? Do you have pointers, or just references? If it does reference counting, can there by cycles? Is that a problem exposed by the high-level data types in 8th? Does 8th have value types, and if so can these values be put on the stack, or do they have to be boxed? So many interesting questions that are never answered... So while I have no idea about what 8th is and the only bits that are highlighted are patently not Forth, 8th doesn't "look like" Forth to me. No more than Factor, or cat, joy, kitten, and the host of other concatenative languages, which don't claim to be Forth, and which don't drown /r/Forth in posts about themselves. As you've been told many times, but which should be fairly obvious since you presumably started as one of us: people reading comp.lang.forth and /r/Forth are interesting in technology. Forth users in general are like that [0]. You've had ample opportunity to share and discuss 8th from this point of view, but all you've put out is marketing crap, played code golf, and *flooded* the community with links to your website (read: links to your marketing material). *You're still welcome to reengage the community in these kinds of discussions.* It's your choice if you decide to bow out because you aren't willing to discuss things that are relevant or interesting to the *Forth community in general.* Or as many people here have noted, nobody would actually mind if you were posting updates once or twice a year. It becomes an issue when the front page of a *general* discussion group for Forth, becomes a marketing page for Aaron High-Tech, Ltd. People do manage to post relevant and interesting things here and do so far more often than a lot of other subreddits, despite the Forth community being much smaller in size. Look at the kinds of things that people find interesting, and are posted here, and adapt - that's half of being successful in business is. Know your audience! Then try again :-) or don't. And if you can't do that (nobody is good at everything!) maybe you should get someone with a business or marketing background to handle that stuff? You have some interesting technology, I believe you can make it a success! This is not the way you do it! Good luck! &gt; I further apologize to those of you who decided to check out 8th and found it interesting. You'll be unable to get updates about 8th via Reddit in the future. That doesn't sound like a bad thing. If I want news on 8th I'd go to the website, or read your forms, and I'm sure that's what your customers do, being that nobody here seems to be using 8th. I'd also subscribe to an /r/8th, but then, again, you'd have to post more than release announcements, or why would I, as someone with a general interest in, but who is not yet invested in 8th, care? &gt; In any event, I apologize to those of you who find my posts spammy or offensive or disturbing somehow. I will not post any more in Reddit. *Your cloister is now secure from my baleful influence.* Don't act like a child. The people who responded to this have given you the biggest gift that any company could ask for - honest feedback. It's your choice what you do with that. [0] But you seem to approach the Forth community like you would a gaggle of Ruby on Rails programmers- LOOOOOOOK!! SHIIIIIIIIIIIIIIIIIINY!!! \*waves hands like a man man\*. Many programmers might not want to know about the technology they're using. Forth programmers predominantly do. EDIT: Spelling
&gt; I've looked at the website multiple times and I still have to ask the &gt; question. What is 8th? Is 8th Forth? It certainly has some syntactic &gt; similarities but there are significant differences: it makes heavy use of &gt; quotations, and high-level data structures, and it presumably has a runtime &gt; that is managing memory for these things, and seems to restrict access to &gt; memory. But that's never actually said anywhere? Please correct me if I'm &gt; wrong here. The use of an 'engine' to run things is mentioned, as is the restricted access to memory. Both on the web site and in various forum posts. &gt; I would personally love to read more about 8th from a technical point of &gt; view. Why/how did you arrive at this design? What problem were you trying to &gt; solve? What you think it's (the designs) strengths and weaknesses are? &gt; Do you have pointers, or just references? Does 8th have value types, and if &gt; so can these vales be put on the stack or do they have to be boxed? &gt; So many interesting questions that are never answered... OK, so to satisfy your curiosity I'll dive in with technical answers. The reason I designed 8th the way it is designed is because I wanted a cross-platform solution which was as secure as possible, for an encrypted "notebook" app I wanted to write. This is also mentioned on the site, BTW. Specifically, I wanted to have a cross-platform way to make applications which were difficult to hack or subvert. That was one of my main goals. Accomplishing that goal (it's an ongoing task, as you can imagine) is the reason for a runtime engine which includes (nearly) all the libraries used (e.g. ssl/crypto/bigmath/etc) by 8th. One downside of this is of course a large runtime (only in relative terms: the engine is 10M or less, depending on platform). By including needed libraries inside the engine, the attack surface is reduced. The engine run script files directly, as well as "zipped" projects and encrypted zipped projects. The encrypted projects are tamper-resistant, since they use AES-256-GCM (which means that any byte modified after signing-time will cause the engine to not load that application). The downside of that is that it opens up the possibility of DOS attacks against the app. The upside is that if the app loads, the user is reasonably guaranteed that it hasn't been tampered with. Additionally, the encryption makes it difficult for a hacker to view the sources etc of the app. The zipped projects include all the resources (or can, at any rate) used by the application. Pointers. No, there are no pointers. There is also no memory allocation/deallocation. 8th uses "pools" of items (numbers, strings, etc). The pools are allocated at 8th startup (for the most used items; less used items' pools are allocated on first use). Items are reference-counted, and e.g. 'dup' will increase the reference-count and put the item (a pointer to the item, actually) on the stack. The stack contains pointers to items -- but the end-user can't manipulate pointers directly. "value types" ... well, as mentioned 'dup' simply makes another reference to an existing item on the stack. 'clone' creates a brand-new item with the same value.
So the subroutine threaded calls might actually be a little faster, except that other aspects of the code have to change to support this approach, e.g. accessing variables, which would ultimately slow execution down? Still trying to understand how indirect threaded code could be faster since there is an additional level of indirection, actually two in comparison to subroutine threaded code. Right? 
Threaded code has to make an indirect jump every time a word is called, so that's probably quite slow on contemporary processors. Branch prediction won't work well.
Can this compiler compile itself? :)
Thank you. &gt; Did you try to implement this yourself? If so I'd be interested in other solutions. I implemented it in [kforth](http://ccreweb.org/software/kforth/) like so: : bind ' @ ' ! ; : hello 0 . ; : hello 1 . ; : hello 2 . ; : hello 3 . ; : blah hello 4 . cr ; : whatever ." whatever" ; : hello.new 5 . ; blah ( displays 3 4 ) bind hello.new hello blah ( displays 5 4 ) With some modification your version works in [muFORTH](http://muforth.nimblemachines.com/) which more closely resembles the Forth I want to cross-compile than gForth: : bind ' &gt;body @ ' &gt;body ! ; Although... I do kinda like the straightforwardness of `: bind ' @ ' ! ;` verbally it says take the execution semantic context of `hello.new` and put it in `hello`. &gt; How is gelForth progressing? The PSoC has hard SWD, hard I2C, and hard USB. I'm writing a USB driver at the moment. Reverse engineering the routing fabric has been making the most progress among the tasks at hand. As for the logic synthesis, [Quine-McCluskey](https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm) is not particularly fast running on an ARM Cortex-M3 I would think. The Quine-McCluskey algorithm also seems better suited to FPGA's with their LUT arrangement. The PLD's on the PSoC have a sum of products AND array, OR array, and macrocells. Maybe I'm advertising my ignorance here, but I think a synthesis algorithm based on Boolean identities would make more sense. Essentially I would like to use Boolean identities (which are indeed [enough to completely reduce any expression](https://en.wikipedia.org/wiki/Boolean_algebra#Completeness)) to implicitly have identical Boolean expressions overlap when constraints (I/O pins) are provided and gates are compiled to the UDB array at runtime. As for routing, the PSoC's routing fabric works by short circuiting which is like ladder logic or short-circuit evaluation like you might find in the condition of a conditional expression. So I represent routing with the same Boolean algebra I use on the PLD's: parallel switches are represented by OR, in-series switches are represented by AND. For placement and rearrangement/partial reconfiguration I leverage the permutative, associative properties of Boolean algebra, etc. Right now my HDL looks like this: : xor 1 -- 2 /- , 1 /- 2 -- , ; I'm avoiding using locals style named parameters for gate definitions not only for Forthiness and brevity, but also because I want what is the same to look the same when gates are compiled at runtime with I/O pin constraints. `--` is a yes gate. `/-` is a not gate. `,` compiles the in-series switches that have piled up into a parallel wire, getting it out of the way just as a typical `,` or `c,` would. The numbers make it possible to have don't cares and mean I don't have to specify every single AND term inside every single OR term. Thanks for reading! i'd be interested to hear your thoughts. Perhaps I should write up a blog entry and post it to a new thread.
&gt; that rather than complaining about my posting once a month with an announcement about a new version of 8th, Self-promoting, commercial posting is no different from spam. And I prefer silence to spam.
Jesus, after the "8th - Is it Forth?" post and now *this* snip? Maybe this subreddit should just go away altogether. 
In fairness, you did forget to add content.
Don't judge a hole subreddit by just a few replies. I'm sure there are programmers more than willing to discuss your subjects as long it has some interesting content. Every true Forth programmer has made its own unique extensions that most other programmers disparage. The possibility to do that is one of the unique features in Forth that every Forth programmer loves. Just go for it but be prepared to be questioned.
Okay, sorry if it was a "shitpost". The only reason I asked was because it is a *variant*, and quite a substantial one at that. But I still consider if a Forth b/c it follows all the core principles of Forth under the hood. 
Good explanation. Thanks. I will just go for it then and see how it plays out.
This is done mainly because the different forms require different actions to be taken to close the forms. It's not hard to implement a generic word like `end` - all that would be required is to pass the address of the code that closes the form on the stack then calling it from `end` - but this `end` uses more stack, complicated all of the opening words, and doesn't really eschew the need for form the specific closing words anyway. To my mind that makes it hard to justify this approach. I guess it may look nicer syntactically to some but I would argue that the generic `end` word makes code much less clear. Indeed this is why it's not uncommon to see things like like } \\ end-if or end \\ end-if Of course this is usually only done when the code is too deeply nested, but being explicit and saying end-if and end-case, or whatever, instead of just end, still makes things clearer to the reader, and is cleaner to implement. 
Whether or not something is a Forth isn't always easy to establish and it doesn't really matter when it comes to posting here. As I said under "8th - Is it Forth?" most people probably wouldn't mind discussion about Factor, or C, or Lisp etc. As long as it's interesting and or relevant. We tolerated 8thdev advertising his commercial product here almost weekly for the last year or so, but it was getting to be a bit much, so I asked the question. I'd warned 8thdev about advertising here many times and suggested plenty of ways in which he could improve the quality of posts, or make them relevant. I'm still hopeful that he'll take that advice and post some "content" here, instead of links to marketing material. He has some very interesting technology and I would personally like to hear more about that. What I don't want is for /r/Forth hijacked by a commercial interest. Anyway, I'm looking forward to hearing about your ideas for (and about) Forth.
Hmm... Can the address be put on the return stack? The reason I ask about this, btw, is because in my variant of Forth, one of things I am working on is making the core words a bit more readable/simpler/intuitive. One of the ideas I had was using `;` as a generic `end` (though you could also use word `end` too). So, possibly something like: : say-zero ( int ) 0 = if: "zero" ; ; I see your point about readability of the end maker -- knowing if it is for the `if` or `case` or whatnot. But Forth words tend to be fairly small, so I am not *too* worried about that. I definitely won't do it though if the overhead is not negligible (or at least pretty damn close). 
&gt; Can the address be put on the return stack? If you can figure it out you can do anything, but I don't think you need to do this. The address of the closing word is passed on the data stack during compilation so it wont be in the way during execution. If you really want to use the return stack then your opening words will need to tuck the address of the closing word under the top of the return stack address before they return. Then your `;` could swap the top two items of the return stack and do a return to the closing word. Your closing word then has to close the form and return control to the compiler. &gt; The reason I ask about this, btw, is because in my variant of Forth, one of things I am working on is making the core words a bit more readable/simpler/intuitive. This is a worthy goal but I would be careful not to trade perceived simplicity for implementation complexity, unless you don't intend users of your language to understand and or modify the implementation. Forth users usually take great pride in understanding the implementation, and can make the language do amazing things as a result. The forth I use every day uses the names: this = dup that = over them = 2dup push = &gt;r pull = r&gt; &gt; But Forth words tend to be fairly small, so I am not too worried about that. This is actually one argument against complex control structures like case-of, which encourage the use of bigger words. My approach has been to reduce the number and complexity of the available control structures rather than trying to implement things like generic closing words; minor syntactic changes that I argue obscure what's actually going on (that's not a bad thing in itself it's just not what I'd do :-)) I have the following control structures: then ... else - conditional from ... next - count down loop from ... loop - infinite loop Like Chuck Moore's colorForth our system makes heavy use of headless definitions with multiple entry and exit points. The definitions are recursive by default and and tail-calls are optimized. With such a simple language we don't have to worry about how to make complex control structures look pretty. EDIT: Regarding things like ; ; ; ; ; I would like to draw a parallel to Lisp ))))). Even as someone who worked in Lisp for a few years I still find this obnoxiously difficult to read without the editors help.
That's something I'll look forward to!
What about implementing a separated control stack instead of using the return stack (or the data stack ) ? If you pushes the closing definition on the control stack at the beginning of a definition and closing words for each contruction ending by ";", you could do that. That is how Oforth works : "]" word just execute the top of the control stack. Each construction ending by ] just ends by pushing the word to execute by ] on the control stack. This allows to use this word on various constructions : Tests : x ifTrue: [ ... ] x ifFalse: [ ... ] else: [ ... ] Anonymous words : #[ ... ] Arrays : [ x , y, ... , z ] etc. 
That's interesting. I was wondering how you did it when I saw some of your other examples. How does the "else:" work without needing `x` put on the stack again? (Edit: Think I'll read some of the Oforth docs.) Actually it gives my a bit of a smile to see Oforth example like this. I imagine those old peanut butter and chocolate Reese's commercials and think, "hey you got your SmallTalk in my Forth" ;-) 
"Updating the Forth Virtual Machine" suggests adding four registers: A, B, X, and Y, and associated words. A and B are scratch or address registers with pre/post-increment modes. X and Y are address registers with base-offset addressing. [0] Here is an excerpt of the wordset given for the A and B registers: - `&gt;A ( x -- )` writes to A - `B&gt; ( -- x )` writes to B - `A@ ( -- x )` reads memory pointed to by A - `B!- ( x -- )` write to memory pointed to be B - `A@+ ( -- x )` reads memory pointed to by A; increment A by a cell And the X and Y registers: - `&gt;X ( n -- )` writes to the X register - `nX@ ( n -- x )` reads from the memory pointed to by X plus `n` - `nY! ( n -- x )` writes to memory pointed to by Y plus `n` It then goes on to show the code for a biquad filter using the A and B registers very succinctly. These registers don't necessarily have to be implemented inside the FORTH system--here's an example implementation of `A@+`: VARIABLE A : A@+ ( -- x ) A @ DUP CELL+ A ! @ ; The other words can be implemented thusly. It will be much faster, however, if they're implemented as code words and A, B, X, and Y are given their own dedicated machine registers in the FORTH implementation. A non-optimizing FORTH wastes machines that have many registers; this is one way to use some of them while keeping your implementation simple. Even more registers can be added, in fact—there are 26 letters in the alphabet after all! *** As for your idea of addressing stack items with "$*n*", FORTH does have something like that already: "PICK". Your stack-accessing words are basically 0PICK, 1PICK ... *n*PICK. If you want to keep it FORTHy, you might call your stack-addressing words like that. *** [0] http://www.complang.tuwien.ac.at/anton/euroforth/ef08/papers/pelc.pdf
:) If you prefer the if/else/then words, they are also defined and can be used the classical way (they are mainly used as basic tools to define other immediate words). For the "else:" word, the last address resolved by "then" ("then" is the word pushed on the control stack by conditionals and executed by "]") is stored into a variable and can be used by an hypothetical following else: . If interested, it is defined into the "prelude.of" file. All this is written in Oforth. 
&gt; I've been considering exactly that notation myself. Glad I am not the only one who has. Do you still use end-if, or end-then? No we don't; there's no end-if, end-then, etc. we just have then and else with the possible early exit. test? then do-this else also-do-that ; test? then do-this ; else just-do-that ; Note that using `;` like this implies, among other things, a stateless compiler. If you're planing to have `state` you probably need to introduce a word like `exit`. This somewhat breaks the symmetry. Your say-zero example would look like this : say-zero ( int - ) 0 = then "zero" say else ; If the then block is taken then control continues in the else block by default. Early return is used to change this behaviour. That might seem restrictive but I find it quite elegant. It works well in Forth code that has many short definitions. It becomes less useful in large definitions. This discourages code which ends with else else else else else else else :-). 
The problem with expanding the Forth virtual machine to include additional registers - and even more so additional stacks - is that you get a profusion of additional words to handle them... which destroys the relative transparency of the obvious, simple two-stack model. For every stack you add, you need to decide which stack permutation words you need with it, and whether it has a path to the data stack, the rack, or both; and every stack and register needs adding to the calling convention, or forget it. So here's my modest proposal, as an addendum to the above suggestion. By all means, add A, B, X and Y - but *have them cleared by ``;``*, so there's no danger people will start to use them to pass or hold parameters.
EDIT: I replied to the wrong person ;-). /u/transfire, this is meant for you too. Sorry for the confusion thamesynne &gt; So here's my modest proposal, as an addendum to the above suggestion. By all means, add A, B, X and Y - but have them cleared by ;, so there's no danger people will start to use them to pass or hold parameters Forth has always made use of variables, where appropriate, and registers are really just fast variables, in the processor. In this light I don't see any reason to force clear registers and this would destroy the utility of the address registers: in order to be able to clear the registers when a function returns you would need another stack which manages them, otherwise your registers would be cleared whenever you called another word. As you pointed out, once we start adding stacks for specific tasks then the complexity of the model explodes. Two address registers (with possible base registers) seems to be a sweet spot. They enables a lot of really simple very efficient solutions for the minimum cost. It's true that these registers can be used for temporary storage but since you need to access memory so frequently, you can't keep things there very long. Why force clear them? There's no need :-) Unless you're going to remove variables then you can't really stop people from doing this kind of thing. Unless you're going to go out of your way to back these things by real registers, they're not going to be faster, so we really are talking about variable here. In general I'd recommend against trying to protect people from themselves. Doing can only ever adds complexity and unless you plan to lock down your system to the point that it's no different from any other managed language, you're not going to succeed anyway :-). &gt; Instead I am thinking each word when executed will get a private scratch stack it can manipulate without worrying about clearing it. It will be thrown away anyway when the words ends. I don't think that you necessarily need to make this a central part of the system. It's easy to implement this if you need it, and you probably aren't gonna need it. I've been working with Forth for the past few years and I've never needed this. If you follow the common advice about keeping your stack small then not only will you have to do less stack juggling, but cleaning up wont be such a problem. I recommend keeping your stack shallow, because it forces you to simplify. I don't use local variables or pick at all because it allows code to become much more complex than it would be otherwise, and makes factoring more difficult. I do however use variables quite liberally. Otherwise I've become quite comfortable with manipulating the stack and understanding code which manipulates it. The trick is learning to read the intention, by considering more than one word. I'd like to finish this by taking a small detour to look at some common phrases. For example, The phrase: 1+ swap 1+ swap Means to increment the top two values. 1+ swap 1+ is the same but it implies that the order of the top two values doesn't matter and is more efficient. More generally f swap f swap Where f is a word with shape u - u, means to apply f to the top two values. The phrase: swap f swap Where f is a word with shape u - u, means to apply f to the second value. The phrase: pull this push is the value at the top of the call stack. Some Forth's use the name c@ here. I sometimes read `swap` as "under" when it's use is to slide the first value under the second value. Given that, the phrase: The phrase: swap drop Means to drop the second value. This is usually called `nip`, but that name is really rather arbitrary so I prefer to write `swap drop`. When I see these two words together I read it as "under" drop. swap push swap pull Means to slide the first value "under" the second and third values on the stack. This is often called `rot`, but understood like this, pattern is easy to recognize and used generally can be used to "sink" a value to almost any depth on the stack. The phrase: swap push swap push swap pull pull sinks the first value under the second, third, and fourth values on the stack. This is about as complex as it should get. If you need access to more items on the stack than this then you should consider using one or more variables. A final advantage to learning to code read like this is that it makes the cost involved in each operation transparent. If your stack really is a stack then you absolutely do not want to use pick etc. there's a lot of stack juggling going on, and you should really be aware of that. If your stack is an array then you need to ask yourself why you're using Forth; it seems like what you want is a more traditional stack-frame approach :-). In that case my preference would be to 1) use variables to eschew excessive juggling 2) build a data structure in memory and pass it's address around instead (or if there's only one such structure then resolve the address compile time instead, and don't pass it on the stack at all.) DISCLAIMER: I may be a bit of a purist when it comes to Forth but hopefully this discussion has been somewhat useful ;-) 
&gt; The trick is learning to read the intention, by considering more than one word. I'd like to finish this by taking a small detour to look at some common phrases. That is very helpful way to look at it. &gt; `swap push swap push swap pull pull` Although it starts to fall apart for me at this point. A couple of years ago I came up with an interesting short hand that had a mnemonic pattern to make it pretty easy to understand. Basically use dots `.` to rotate and `-` to hold a slot still. : .. swap ; : ... rot ; : .-. over ; : ..- push swap pull ; So, : .... swap push swap push swap pull pull ; I thought about adding a char for `drop` too, maybe `_` or `,`. It's quite a concise notation and easy to understand. But of course code would start to look rather "symbolicy". 
The nice thing about A and B is that you can use them to make scratch stacks 32 CELLS ALLOC &gt;A and then push or pop to them 1 A!+ / push '1' to the temp stack -A@ / pop from the temp stack `-A@` isn't in our wordset above, but it basically pre-decrements by a cell before reading. One disadvantage of this scheme is that your dictionary will be loaded with all the ABXY words.
&gt; Do you have a usecase in mind for this? Not really. Just saying it would be possible. It could be done as a block of memory in which case you'd have to give a size, or a linked list, in which case it's open ended. They would be on the heap. But I realize now the advantage of A B X and Y is they are tracked by dedicated CPU registers. Is that the idea? 
That they're held by CPU registers is one of their advantages, aside from their usefulness. On an many-registered CISC like the MSP430, you only need two instructions for `A@+` and one for `A!+`: a_fetch_incr: sub rDSP,#2 mov @rA+,@rDSP (code for NEXT) a_fetch_incr: mov @rDSP+,@rA+ (code for NEXT)
That's pretty cool. Question, if X and Y are used offset pointers how big can the offset be? How does it handle that? 
Hey what would `abcpair` look like without the locals? 
The offset would be the size of a cell. Admittedly, I'm not entirely sure if `nX@`/`nX!`/etc. take the offset from the stack or they take it inline--the paper is ambiguous on that. I'll assume it's from the stack. In that case, it would simply be a matter of adding the X/Y and the address taken from the stack and reading from that address.
I think the Forth-way of this is done by variants of the operations, like r+ ( a b -- a b a+b )
I too would sometimes rather explicitly `drop` an item than need to continually `dup` it. Your `&lt;&gt;` word, which inhibits consumption of stack items, reminds me a lot of the difference between `r@` and `r&gt;`. Perhaps you could just recycle that naming scheme for words that consume stack items or don't. I think it would be apt because you are anyway doing a fetch or pop from the parameter (or other) stack. Also you could sometimes just embed the `&gt;` or `@` words inside the definition and not put it in the name if it's otherwise clear how it works. My point is, it's good to be explicit about things while still making use of the descriptive power of context. : &gt; @ drop ; : &lt; ! drop ; 
&gt; I'm sure an optimizing compiler coming across A@ B@ + will just skip actually moving the memory contents of A and B to the stack, and compile it directly to an indirect addressing add, add [ax],[bx]. That depends on the architecture :-). While register machines are by far the most common now, stack machines, and particularly 0-operand stack machines like those designed to run machine Forth, wouldn't have such instructions and would just do the stack manipulation. The problem, if it is a problem, is that there's an inherent inefficiency in simulating a stack machine on top of a register machine. As was discussed at length in the book "Stack Computers: The New Wave", stack machines can be designed that complete with or easily out perform register machines. https://users.ece.cmu.edu/~koopman/stack_computers/ Stack machines didn't catch on because C is a very poor fit for stack machines. You need a prohibitively large and complex stack on chip to make it efficient and by hiding the stack you're removing the ability for the programmer to make informed choices about moving data etc. Despite what many believe, compilers still can't hold a candle to humans when it comes to rethinking a problem to take advantage of specific features of a target, and so gain performance. &gt; What exactly is the point of Forth then? Just a clever way to avoid writing two assembly commands, push and pop? The point of Forth is what it's always been; the Forth system allows for a highly and productive, interactive and integrated development experience with the minimum of complexity and overall cost. As a language Forth minimize the overall complexity of any given solution. With Forth you can do things in a few Kb's that would take hundreds of MBs using more mainstream technologies. Not only are the two stacks a simple solution, but they encourages simplicity by forcing you to simplify and factor your code, and preventing solutions from becoming complex. Everything else tries to hide complexity, so it grows... out of sight out of mind :-). That's not to say that Forth is perfect, but there's else nothing like it :-).
I suppose it could dynamically adjust how many registers are being used to cache the stack. 
&gt; this would destroy the utility of the address registers No, it would limit them to use in leaf definitions. &gt; in order to be able to clear the registers when a function returns you would need another stack which manages them... No, the rack would do fine. &gt; otherwise your registers would be cleared whenever you called another word. No. They *might* be cleared when you called another word, *if* that word is a high level word - which will execute ; at the end. If the word is a code word, no such issue. And perhaps the use of the term "clear" is misleading; what I actually meant was that **;** would not be guaranteed to preserve those registers. In other words, portable code couldn't assume that they wouldn't be cleared by **;**, and so would have to be written to pass all parameters on the data stack. Non-portable code can, of course, continue to do as it pleases. ;-) But I can certainly envision at least one implementation strategy for those variables that means that **;** would certainly, naturally trash them, even if it's just a return instruction. &gt; In general I'd recommend against trying to protect people from themselves. I was more thinking of protecting them from language implementors... ;-) &gt; I may be a bit of a purist when it comes to Forth I'm not sure a purist would rename DUP, but hey...
In that case maybe the scratch stack could be dual purposed if we cache the top of it too. Say it caches the top four cells of the scratch stack, and then in addition to push and pull, it provides random access to scratch stack, say `S0`, `S1`, `S2`, S3`. Then we should be able to perform all the same operations as A B X Y on them. The only trick is that if we are using one of these, say `S0` and then push to the scratch pad, S0 become S1. Maybe we can live with that? Or maybe instead it can automatically adjust so S0 still points to the same register? If we are using S3 and b/c of a push it falls off the scratch cache, then the index just winds up in memory, so it won't be as fast, but a good programmer obviously won't let that happen if speed is their primary concern. 
&gt; So my question would be, are we wasting CPU cycles with so much swapping, pushing and pulling just to get things in the order we need them? We're using CPU cycles, to get properties like concatenativity, easy factoring - enabled by the fact that call and return can be implemented very efficiently, when you aren't wasting all your cycles creating and destroying stack frames - and overall simplicity etc. The reason that it's important for people to learn about something before they try to improve on it is so that they understand why things are the way they are. Otherwise you're more likely to throw the baby out with the bathwater than to really improve things :-). Cases in point: Even if this can be done efficiently, giving each word a "private scratch stack", which will be cleaned up automatically, suggests something like stack frames, with all of the inefficiencies that entails. This means that people will have to factor their code less, or swallow the cost. "enumerated references to input parameters" annihilate the concatenativity property that makes factoring so easy. All of your proposals increase complexity. Individually this might be ok but my feeling is that if they're taken together, that complexity will be compounded, sacrificing simplicity etc. Now please don't misunderstand me here: it can be a lot of fun thinking about these things and I highly encourage you to keep doing so, and keep posting your thoughts here. These are my just opinions and you're free to form your own :-). Elsewhere in this thread you saw how A@+ and A!+ can be used to implement something like your scratch spaces. The solution is simple and efficient, and can be done on an as needed basis, so doesn't impose any cost on the user. While it might not seem very Forthy at the beginning these characteristics and general utility make it very Forthy :-). Forth isn't really about stacks but: tl;dr the stacks are not a weakness of Forth, they're a feature, that enable all of its other properties and applications. Don't try to hide them. http://evincarofautumn.blogspot.co.uk/2012/02/why-concatenative-programming-matters.html
Actually in my variant it would still be a single word, I just haven't explained that yet. I'll reconsider overloading `&lt;` and `&gt;`. Basically my I plan is to have lettered words for just about everything, and then symbolic aliases for the most commonly used ones. 
&gt; Basically my I plan is to have lettered words for just about everything What does this mean?
&gt; The reason that it's important for people to learn about something before they try to improve on it is so that they understand why things are the way they are. Otherwise you're more likely to throw the baby out with the bathwater than to really improve things :-). It's not like I haven't studied Forth for a while. I just have never written anything more than toy programs in it. I understand what you are saying, and that is a downside. And that's why I am here getting input on various details -- I have a fairly good idea of what I want achieve on the large scale. &gt; Even if this can be done efficiently, giving each word a "private scratch stack", which will be cleaned up automatically, suggests something like stack frames, with all of the inefficiencies that entails. This means that people will have to factor their code less, or swallow the cost. But we already have a scratch stack in the form of the return stack. My only change is that under normal usage I want to protect the coder from screwing it up. Your are right it will take some additional overhead, but we should gain some of the efficiency back because we no longer have to clean up the return stack. There is a larger reason why they need to be private though. I want to support concurrency at a low level. And if the scratch stack is shared, then things get very ugly very quickly. In any case I think there is a way to do it that isn't terribly heavy weight. It just needs to have an extra pointer to track the back-end of the scratch stack. It can still be one stack, but it won't let you go past the back pointer. These pointers would be tracked on the return stack. &gt; All of your proposals increase complexity. Individually this might be ok but my feeling is that if they're taken together, that complexity will be compounded, sacrificing simplicity etc. Yes that's partially true. But sometimes complexifications in one place lead to more useful simplifications in others. That's what I am trying to do. &gt; Forth isn't really about stacks but: So why not just write a Forth-like register machine? It's shouldn't be too hard. Just describe which arguments go into which registers. : SQUARE ( A! ) A@ A@ * &gt; the stacks are not a weakness of Forth, they're a feature, that enable all of its other properties and applications. Don't try to hide them. Hmm... I don't see how I am trying to hide them. 
&gt; As I said in another post, it would almost be possible to write all your code with just ABXY and barely ever touch the stack (e.g. a 6502 only has &lt;s&gt;four&lt;/s&gt; three registers). I'm not sure what you're arguing now :-). Yes you could... but this makes factoring code basically impossible, and you're going to need at least one stack if you want to reuse code using subroutines. 
For example there could be both `add` and `+`, two words for the same thing -- one "lettered" and other "symboled". That's a pretty obvious one, but some symboled words will be more esoteric. At the very least it will be helpful for beginners to to start with long forms and move to the terser symbols as they become familiar with them. On the other hand, an experienced coder might just prefer certain long forms over the short forms, and vice versa. Of course, as with most things, there is a downside -- multiple ways to express the same thing. So I am trying to find the right balance here and weigh the advantages to the disadvantages.
&gt; But we already have a scratch stack in the form of the return stack. The system doesn't attempt to manage, or clean up, the return stack for you. &gt; Your are right it will take some additional overhead, but we should gain some of the efficiency back because we no longer have to clean up the return stack. You're adding overhead to every call in the system while the majority of words don't need to clean up the return stack. Unless you're doing something wrong you should never have enough data to clean up that this should be a problem, and it certainly shouldn't be a bottleneck. Moreover if you're actually using the return stack to store temporary values then you're going to need to use them... otherwise why not just drop them... and if you're going to use them then you're going to have move them to the data stack anyway. If they're not consumed at the point of use and you don't need them anymore then you drop them; you'd never move them on to your scratch stack again. I know you're just spit-balling here but this isn't a problem that really exists. It's certainly possible to leave a value on the returns stack and accidentally return to that address, which usually leads to a crash, but this is very useful. You're free to disagree but I can think of a few dozen uses right off the bat. Maybe it would be safer not to allow access to the return stack but then you shouldn't allow raw memory access either. Are you writing a managed language? If so then your design decisions start to make more sense. &gt; In any case I think there is a way to do it that isn't terribly heavy weight. As a one off this isn't particularly heavy, but when you're doing this for every call and return this will quickly add up :-). &gt; It just needs to have an extra pointer to track the back-end of the scratch stack. It can still be one stack [...] These pointers would be tracked on the return stack. Not really. If you want to keep this information across calls then you're going to have to keep track of that on the stack, and since you don't want this to get in the way it can't be on the data stack. So now you're pushing and pulling multiple things on to the return stack, or you have another stack. OR you end up implementing stack frames. &gt; but it won't let you go past the back pointer. Now you're adding bounds checking. No matter what you do you're doing a not insignificant amount of work for *every call and return*. But maybe I'm wrong and your variant wont end up being any slower than something like Python. &gt; Yes that's partially true. But sometimes complexifications in one place lead to more useful simplifications in others. That's what I am trying to do. And that's why we're all participating. I for one am very curious what you come up with. &gt; So why not just write a Forth-like register machine? Because of the concatenativity property :-). Maybe you just should try and do that? You'll quickly realize that words written this way don't compose. See the previous link I gave you for somewhat more formal explanation of why. &gt; Hmm... I don't see how I am trying to hide them. You're trying to manage the stacks; adding what's in effect local variables, with all the problems they bring. And removing access to the return stack (more accurately, you're replacing access to the return stack for temporary storage with a third, special purpose, stack)
I guess you could do this if you had the access to the stack effect of the word that follows the &lt;&gt;. I agree that this seems like a lot of work, just so the user doesn't have to type dup or 2dup, 3dup.
You may or may not find this interesting: https://www.infoq.com/presentations/Design-Composition-Performance The relevant part starts at 32 minutes :-)
&gt; I'm on mobile now, but I'll gladly demonstrate with a code snippet once I have a keyboard in front of me. Yes, some additional examples might be helpful. &gt; You don't need to implement ABXY on registers for them to be fast. They can be in memory, which a CPU like the Z80 or 6502 would require (although the 6502's zero page is sort of like having extra registers). On x86, which only has 8 registers in protected mode, such a solution would be used. In that case, I am pretty sure I can provide what is necessary without overly cluttering the dictionary. And my variant should allow for some additional consolidation of words. A &lt; A &gt; A @ A @1+ A ! A !1+ X n @+ X n !+ Actually, I should be able to improve upon that a bit more too -- if A and X are cast as address -- then @+ could be used for both `A @+` and `X n @+` b/c it will recognize A and X are addresses, not just numbers. 
True. But my variant of Forth will be able to handle the "adverbial" format without issue. So I more curious about how useful such a thing would/could be. 
&gt; my variant of Forth will be able to handle the "adverbial" format without issue. How?
Put simply, the compiler knows how many parameters a word takes. This leads to a restriction that a word can only (and must) take a fixed number of parameters from the stack. I haven't seen many words (any words?) that do otherwise so I think it is a restriction that can be managed. If I find a way to support variable parameter words, I will. But the idea of `&lt;&gt;` probably will never be able to work for them. 
&gt; Put simply, the compiler knows how many parameters a word takes. So no EXECUTE. How are you going to build a REPL within the Forth?
Concurrency by default and a language where each word depends implicitly on the results left by the previous one do not seem like a natural mix... Are you quite sure Forth is the best target for your ambitions, rather than, say, Lisp - which would give you most of the advantages of Forth, but also allow you to evaluate all the subexpressions of a function call in parallel, and not leave you trying to figure out the dependency tree on the fly from a stream of inherently serial instructions running precisely the wrong way for that?
If you're adding a type system, our argument is pretty moot, since I feel like you're not going for FORTH anymore, but a concatenative stack-base language. But FORTHiness is pretty subjective, anyway, so I won't pick on that. As for my code sample: let's write `cmove` as a high-level word (which, you *don't really do*, but we're doing this for fun). : cmove ( src dst u -- ) rot swap / swap the source and destination addresses 0 do 2dup i + c@ swap i + c! loop 2drop ; or, without adding I every loop iteration: : cmove ( src dst u -- ) rot swap / swap the source and destination addresses 0 do 2dup c@ swap c! 1+ swap 1+ swap loop 2drop ; And now, with A &amp; B: : cmove ( src dst u ) &gt;r &gt;B &gt;A r&gt; 0 do Ac@+ Bc!- loop ; Perhaps the A and B words would work better parsed instead of kept in the dictionary--they have a pretty simple format. EDIT: mistake
Forth seems like a natural fit for SIMD, where you couldn't really imagine performing multiple steps of a computation at the same time (stack serialization and all that), but the tendency to use the stack means that it's easy to imagine performing multiple instances of the same computation at the same time. Are you trying for the former (MIMD/MISD) or the latter (SIMD)? If you're trying to do MISD with a stack, I think you're going to have some difficulties - the same difficulties people trying to do that in hardware to exploit instruction-level parallelism have. To that end, I'd suggest checking up on what the folks working on superscalar stack machines have been up to. a b + dup c / swap d * * can be rewritten as ((a + b) / c) * ((a + b) * d) I imagine it would be quite difficult to easily infer during compilation that a divide and a multiply could be performed simultaneously. Part of it is that statically analyzing the stack effect can be difficult, because conditionals are a thing. Being able to do that for all possible words would, I imagine, be quite difficult. It might be doable if you outlaw variable stack effects, though. The way I always thought of handling concurrent threads running in a forth system is to just have each thread have its own data stack and return stack. Is that what you mean by "scratch stacks"? 
&gt; This is the chip you are working with? http://www.cypress.com/products/32-bit-arm-cortex-m3-psoc-5lp That's the one. &gt; And you are writing a Forth to program the field-gate arrays on it? Yes. It was tethered over the SWD interface from gForth but it is soon to be running from the ARM core and synthesizing logic to the UDB array from there. I just need to finish the USB driver so I can have get a UART connection. The reverse engineering work is not entirely done and the UAB (Universal Analog Block) array has not even been started. &gt; Is this a hobby project or does your work entail this sort of thing? A hobby project I suppose, but I am looking into putting it into a Forth-based, open hardware/open software product. I'll be giving a talk on the Forth side of this at Forth Day in November. I'll also be giving a talk about the reverse engineering side of the project at [this meetup group](https://www.meetup.com/Mountain-View-Reverse-Engineering-Meetup/) but I'm not sure when.
No, you're missing the broader point. **execute** *itself* cannot possibly have a fixed stack effect, because its effect is the effect of whichever xt it's handed. So the compiler can't possibly know how many parameters **execute** will take. And once there's one word with that characteristic...
I'm inclined to agree with you on subroutine threading. As for the others, I don't know. I'd like to measure this some time.
Yeah, if it ineed does!
&gt; I'm sure. I realize I am moving quite far afield of the traditional Forth, but the underlying system will still retain all the fundamental characteristics of Forth. I'm curious: what characteristics of Forth do you consider important and which properties are you trying to maintain? :-)
&gt; "Call threading" - when the inner interpreter is a tight loop making subroutine calls to every word. Typically used when implementing Forth in a high-level language. In that vain we also have "Switch threading"
Yep. You are right. And I went on to talk about that problem. Maybe the solution to that will solve my scratch stack issue. I'm not sure. But I suspect it will be a bottle neck. If every concurrent process has to say, "Wait! The scratch stack is mine right now, the rest of you will have to wait until I am done" (basically a Mutex), all you other processes are going to be wasting time standing in line a lot. So I figure that scratch stacks are small enough that I could probably get away with not sharing them and avoid that bottle neck. I can't do that with memory in general though... well, I could, that's what Erlang does. But I think for a Forth that's not reasonable, so in that regard, you are right, I have to find a way to deal with it. 
&gt; But I think for a Forth that's not reasonable, so in that regard, you are right, I have to find a way to deal with it. And once you find a way to deal with that, you wont need your scratch stack.
What would a hypothetical program in High Stack look like that defaulted to concurrency at the word level?
I completely agree with you that most Forth code that I have seen need better comments. The language Forth is more vulnerable to bad commenting compared to non point-free languages and I think that might be one reason for it's bad reputation. But I must say that comments in other languages are not so illuminating either. It's certainly not often that I see code that meets your requirements. If you know of any language where this is common I consider using it.
Well, at least you didn't advocate things becoming object oriented. That's something positive.
Have you checked https://github.com/search?q=forth&amp;type=Repositories&amp;utf8=%E2%9C%93 ?
X-Post referenced from /r/reverseengineering by /u/pointfree [Using C Forth to reverse engineer the Milo Champions Band fitness tracker protocol [x-post /r/Forth]](https://www.reddit.com/r/ReverseEngineering/comments/58hic2/using_c_forth_to_reverse_engineer_the_milo/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
&gt; This is not what is a pure function. A pure function is a function that will always return the same value when called with the same parameters, without side effects. No matter it accesses RAM or not. Of course, but RAM is rather known for its volatility. Which is why shared memory is a problem and can cause functions to be impure. You can also access a disk drive, and as long as the sector you read never changes than you can have a pure function. But who expects that to happen? &gt; imo, concurrent programming should be explicit. I don't see what would be the benifit to have it be implicit (but I see the drawbacks... ). Perhap's you could also be interested by coroutines by continuation : https://groups.google.com/forum/#!topic/comp.lang.forth/3tdVnCVI1wo Thanks. I'll have a look. &gt; For single core processors, what you are talking about is parallelism, not concurrency. I understand, but that's splitting hairs for a casual discussion. If you are working with a single core it is better to turn off concurrent support, if possible, to remove the overhead involved. 
Perhaps, but any such system is probably going to involve *locks*/*waits*. For something as frequently used as a scratch stack that will probably be too much waiting. 
Oh, that's interesting. Thanks. I would have guessed in range of a 100 or more.
I use Forth for some of the work I do, not as the deliverable, but to facilitate my work. I design hardware and FPGAs. Currently I am manufacturing a board for a major networking company and have to fill some large orders. To make testing go more smoothly I built a test fixture that is controlled through Forth on a PC. I use Win32Forth and was able to get a lot of help with the interface to Windows. My main issues had to do with controlling the RS-232 port which is a bit clunky under Windows, but I got it to work. While I was trying to get help with handling potential errors, I was given some advise on how to copy text to a paste buffer which ended up being a huge time saver for recording the results of the testing. The data is copied to the paste buffer by the Forth test program and the operator can then directly paste all three values into a spread sheet with one operation! This actually saves a significant amount of time and saves the operator from tedious work selecting text to be copied from a window. Thanks Jos! To be honest, I am more proud of my test fixture, Forth program and process than I am of the board I sell that is being tested. :) 
Yes, sorry. Using the CPU stack pointer as the Forth virtual machine instruction pointer. (I haven't seen it called thread pointer, but sure.)
I suggest this: https://github.com/ForthStar?tab=stars These are repositories with a "significant mount" of Forth code. Of course this includes some implementations, but also many applications, tools, and libraries.
"Mako is a simple stack-based virtual game console, designed to be as simple as possible to implement. Maker is a compiler for a Forth-like language that targets the Mako VM." https://github.com/JohnEarnest/Mako 
Your **Q** will determine whether the number is even. This, however, will work: : Q 0= 0= ABS ; 
Have you looked at the x86 instruction set encoding? That's bytecode for sure, and an obnoxious one at that, but you don't hear people complaining that it's slow. :-)
&gt; `0= 0= ABS` How does that work?
Yeah, I realized that as soon as I woke up this morning. Felt pretty stupid.
I actually learn best by taking things apart and putting them back together. I've read a lot about Forth over the years including most of Starting Forth, Thinking Forth and and JonesForth code. But I haven't spent much time writing Forth. Which is part of the reason I am here now. But, the things is, as much as **I love Forth** conceptually, I would never write any end-user applications in it. Which is exactly why I want to "re-implement it" into a language that I would. As Forth presently stands it only seems particularly useful for embedded systems. You might disagree, but honestly I don't see how I can be too far off the mark when so few people use Forth anymore for anything else. 
I also read somewhere that it may have had to do with floating point hardware being implemented as a stack in some places and being able to take advantage of that. In theory if you're just looping over some floating-point array, doing something with each element each time, you should be able to just keep the index/address on the return stack, right? But then as soon as you try doing anything more complicated than that, the complexity probably explodes. Makes you miss a spare register or two. Actually, this brings up an interesting question: when is it better to have separate stacks, and when is it better to have less stacks? Suppose that I've got 100 cells' worth of high-speed hardware-stack. When would it be better to instead have two stacks of 50 cells each? Presumably I would need to either have some sort of way to control which stack is being operated on (which raises the question of how to move data between the stacks, though in the scenario with only 2 stacks it's not an issue) or duplicate the instruction set so that it can act on the second stack as well. So the downside appears to be that it adds complexity and takes space, and the upside seems to me to be that you can keep things "ready" in parallel. Based on this, the reason someone might want a string stack would seem to be that they like to be able to think about their strings in parallel to the rest of their data. Even for something as simple as searching a list for a node containing a string can be quite frustrating: you want to have the node pointer on the top of stack at the beginning and end of the loop, but you have to duplicate the string before you do tests for (in)equality, and you still want to have a node pointer on the top of stack so that you can get that node's string to compare to. So your options are to use the return stack for some stuff, pull a 3DUP out of nowhere, or use a string stack. Apparently the author of that forth system liked that last one enough to include it. String handling in general can be a bit tricky - including both the size and the address on the stack affords great flexibility, but it also makes it a pain to work with since doing anything to a string requires at a minimum 2 parameters, and most interesting things you do to strings require at least one other parameter. In short, strings in general are a hassle. 
Not sure. I'm gonna miss having someone to talk/debate Forth with though if he's done here. Also, I just noticed that nobody capitalizes Forth here. I'm gonna stop doing that, hehe. Floating point *only* Forth? Is it dynamically typed, where one `+` works for any type of number on the stack, or are there only floating-point numbers?
[Image](http://imgs.xkcd.com/comics/matrix_transform.png) [Mobile](https://m.xkcd.com/184/) **Title:** Matrix Transform **Title-text:** In fact, draw all your rotational matrices sideways\. Your professors will love it\! And then they'll go home and shrink\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/184#Explanation) **Stats:** This comic has been referenced 12 times, representing 0.0091% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d93vaho)
Lots of thoughts here! Firstly, the question of names. You're right - pushing them to the stack as a string would get awkward. However, what you could do is magic them into existence as null definitions when they're first encountered, and have all words deferred. Even native code can support this - on a modern x86, CALL [word] isn't much more expensive than CALL word, and has the benefit that you can move the chunk of code in which it appears around without recalculating the destination offset. Which helps with point 2. Probably the simplest way to add laziness to Forth is to add block structure - which, as I've mentioned before, is actually really easy to do, and with only about 4 lines of code, as long as you take advantage of the fact that memory has two ends. Essentially it amounts to making **:NONAME** nestable... but for now, let's give it a different name, say **[[** ... **]]**. So you can write **[[ 2 2 + 3 \* ]] execute .** *12 ok* Of course, if you do that, then a little anonymous fragment of code will be sat at the top of memory for the rest of the time the Forth is there, unless you reset it. But this is where it comes in handy to have absolute call destinations (whether direct or indirect - the x86 can only do the latter) and relative branch destinations; it means that you can scoot such fragments of code up to the top of memory without penalty. Threaded code does this by default, of course. It also means you can implement syntactic macros and combinatorial code structures. **10 [[ 2\* . ]] for** *18 16 14 12 10 8 4 2 0 ok* But as you say, that approaches being a reverse polish Lisp. So... implicit laziness in Forth. In theory, it's not that hard; after all, Forth is already a concatenative language, so you already compose functions by putting them next to each other. But then... traditionally lazy functions are those which don't evaluate their arguments, and Forth functions don't *take* arguments... or rather, every Forth function (and numbers are also Forth functions) has a single argument, the stack - and to borrow a term from another functional language, Clean, it's typed unique. So if you want to add laziness, I'd suggest that's where to start... but the problem is knowing where to force execution. I can't see a way of doing it without using some kind of delimiter, a bit like a cut in Prolog. But yes, let's go with it for now. For a start, the end of interactive input is a good place to force evaluation. So you can type **2 DUP + 3 \* .** and essentially the system starts out in compile mode, and when you press return the code compiled so far will be executed. That kind of achieves laziness. It also means you can say **SWAP DUP + \* =: twiddle** to define a new word, twiddle - it just takes the cumulative code compiled. (One could conceivably even add pattern matching here too.) But then, of course, **=:** has to be a word that uses the cumulative xt left on the stack, rather than being rolled into the mudball itself; so it has to be an immediate word. Which in the context of laziness, means "do not force execution; instead operate at compile time, with the xt at TOS". And yes, it's still suffixed by the word to define, rather than prefixed by a null word that springs into existence on not being recognised by the compiler. That's still possible, but then you have to disentangle it from the last code compiled if you're being lazy by default. Which is trivial if you're compiling threaded code, possible if you're compiling relatively unoptimised subroutine threading, and potentially a minefield with heavily optimised native code... because of course, **=:** has to work with *any* word, not just those that haven't been defined yet. And then you have **.** Extremely useful word in the context of a command line, not all that useful in definitions (where you probably want to format numbers before printing them). So define it as immediate too: **EXECUTE (.) =: . IMMEDIATE** Of course, we need one more word, which takes the xt currently accumulated and compiles it within another xt. Maybe **`** for that? But then you really do need brackets for that, because you might want some code before that... so we're back to [[ ... ]]. I don't think there's any getting away from the fact that at some point you will need to put some kind of delimiters around a chunk of code you want deferred until later. Even Haskell has parentheses. Anyway... I've met your essay with one of my own, but maybe you'll find it interesting?
Neither do I.
Although there was a little more to it, in the end I was accused of trolling /r/Forth with my posts, which was upsetting. I don't need that kind of aggravation. So I decided to take them down and work out my ideas on my own. But thanks to everyone who provided constructive comments. They have been helpful. And thanks /u/pointfree for this info. FYI I believe that is what Lua does too -- all numbers are floats. 
At least they should be something easy to type on a standard keyboard, or else they won't be used.
I made something of sorts one time. But remembering the APL/J/K debacle, i went with ASCII. https://groups.google.com/forum/#!topic/comp.lang.forth/BSiqhUolPC4
That doesn't need to be a limitation in this case, just as most math notations can't be written with a standard keyboard either. The notation would be useful for papers, rather than actual coding. At least at first. Eventually I think it will get easier to type some alternate characters on keyboards. The mechanical keyboard community is ahead of times in this regard using *layers*. It just needs one of the big companies (Apple, Google, etc) to push it as a standard. But then the question becomes what layers will be standard. If there are no standard stack operators by then, they are sure *not* to be included. 
Layers are standard on European keyboards, so you can write stuff like ←↓→ with just AltGr z u i for example.
Nice. I was just looking into sixel graphics the other week, but not in a Forth context. This looks like an idea that has been discovered in the scrap heap of computer history, and, incredibly, is now gaining in popularity. I'm not quite sure if I'm apalled or delighted. :-)
To be able to start painting anywhere on the screen, ensure that the XTerm `sixelScrolling` resource is set to `true`.
I'm sad that you felt the need to delete them. Do you have a blog or anything that you keep? Did you keep drafts of your posts? I had read all of them, but I can't thumb through them again on my own time.
The `swap` symbol makes a lot of sense, and `dup` too. I think `drop` would be a bit harder -- what does a "terminating string" look like exactly? 
Looks like I forgot to set PCICR and PCMR registers. I was way off! http://stackoverflow.com/questions/40188110/execute-flashforth-word-when-pin-changes/40297718#40297718 Thanks for all your help! 
I don't see mapping 1-to-1 to Unicode characters as being the best way to do string diagrams. Part of the idea of the diagram is that although it's got exactly the structure of any other Forth code, there's some visual flexibility in the layout, and the vertical dimension maps to stack depth. You can render it down to characters but you could just as well produce a graphical version from the same code. a─+─╥───┌──*── b─╜ ╙─÷─┘─*╜ c─╜ d─╜ Condensed version: a+╥─┌─*── b╜╙÷┘*╜ c╜d╜ 
**UPDATE:** I got them working. Thanks for everyone's help! http://stackoverflow.com/questions/40188110/execute-flashforth-word-when-pin-changes
&gt; I have to wonder, though - even if it is possible, is it worth the &gt; tradeoff in design complexity? Would it be better to take the &gt; GA144 approach (though perhaps not to such an extreme) and &gt; provide several parallel computers that can communicate very &gt; quickly and count on the software to make it parallel? This publication is rare in the sense, that there exist only a few others about that topic. Anyhow, one of these few is following publication: **Second-Generation Stack Computer Architecture** *Charles Eric LaForest* ^Independent ^Studies ^University ^of ^Waterloo ^Canada ^April ^2007 where the author discuss a prototype super-scalar stack architecture derived from the MIPS ISA against it register based counterpart. The result of these comparison is that both architectures archive the same IPC characteristic with a somewhat comparable logic effort. If you think about it, that makes sense because the architectural complexity of traditional out-of-order as in-order super-scalar designs is related to needed caches, branch prediction and scheduling. It is only secondary dependent on the ISA as the decoding effort may be a power relevant aspect and execution units. Finally the register file organization is mostly the least complex part of such designs because register access is always transformed and precessed out of order anyhow (in some cases this apply also to in-order designs, like early Intel Atom? processors demonstrate). So in my opinion, there exist no sufficient efficiency advantage for super-scalar stack architectures against register based designs at implementation level. However, stack based machine code can be very compact which naturally is advantageous because this lead to better cache usage.
I was considering something akin to this. We already do type-checking for built-in words, which is handy. What I don't see is how you can 'verify' a stack which is as deep or deeper than the max parameter list? You can only verify that the number of parameters is adequate. Or am I missing something?
Is equally unclear to me. I suspect the author means with validation the possibility to check up for stack compensation which is possible with the assumption that executed code sequences must result in the specific stack depth of the last word executed.
This is very interesting, unfortunately in trying to understand it I find Mr Chapman (who is clearly a very smart man) tending to gloss over the equations very quickly without a full breakdown, i.e. assuming the reader would already have some idea about how it must work. (Sort of like writing a Forth program without providing stack effects.) So as much as I wanted to understand the processing model, I could not garner it from a simple reading, and instead would have to spend a good deal of time studying and teasing it out (assuming all the information necessary to do so is in there somewhere), and I simply don't have the time to do so. If anyone else has a good understanding of it and can break it down more clearly, in particular the model of an NP and then how those NPs integrate, that would be awesome. 
I think it's supposed to be where to put the bits in case of an overflow. It would make sense. I'm going to test it. -edit- yep, when you unsigned multiply 0x34 and 0x0fffffffffffffff it overflows to the second bit of the higher bytes. This will leave the higher order byte with a 3.
Could you explain this more. I don't quite understand the diagrams.
First of all, make sure the diagrams are showing up in a fixed-width font and that the line-drawing characters are coming out right. Otherwise they're nonsense. Second, it may help to know that the code being diagrammed is `a b + dup c / swap d * *`. Ok, so here's another version of the diagram. All three are identical up to horizontal spacing. I increased the spacing on this one to hopefully make it easier to read. a───+──╥────────┌───────*── b─╜ ╙────÷───┘────*──╜ c──╜ d──╜ The symbols `a`, `b`, `+`, `c`, `d`, and `*` are the same as in the Forth code. `÷` is simply division (I used this symbol because my first diagram versions used `/` to represent part of a wire). There are two further symbols: ──╥── ──┌── ╙── ──┘── dup swap My concept is that each operator takes a number of items from the stack, represented by strings going into its left side, and leaves a number of items on the stack, represented by strings coming out its right side. Since `dup` takes one items and leaves two, it has one string coming in on the left, and two going out on the right. Since `swap` takes two and leaves two, it has two strings on each side. The math operators all take two and leave one. I used the vertical double line in an attempt to show that the operator is two "lines" high. So if I had an operator that took 3 stack items and left 2, it would appear like one of the following: ──?── ──╥── ──╫── ──?── ──╜ ──╜ (It's not important which one. That's just an aesthetic choice. I did some sketches on paper, and IMO the easiest-to-read design is to simply circle the operators and gently bend the strings to meet them.) Ok, symbols having been explained, notice that in my wide-spaced diagram in this post, all the symbols are horizontally in the same order as in the standard Forth code. That's the starting point. In fact, if I take out the lines you can see that, ignoring vertical position, it's exactly the Forth code. a + dup swap * b ÷ * c d But paying attention to vertical position again, the vertical positions are indicating stack depth relative to the start of this code. `a` is on the first line, meaning we've pushed one item onto the stack. `b` is on the second, meaning the stack depth is now two. `+` is back on the first line, meaning that there is now only one item on the stack again, and so on. Now I'll paste in the version with strings again: a───+──╥────────┌───────*── b─╜ ╙────÷───┘────*──╜ c──╜ d──╜ The strings simply connect each word to the one which consumes the stack items it leaves. This isn't a free-form connection of nodes, like you see in Pure Data for example. It's simply a way of depicting a stack language, which the computer mechanically derives from the stack effects of the words (we assume stack effects are known). Now that we know which word follows which, horizontal spacing isn't quite so important. Sometimes in a piece of Forth code one word will precede another, but the latter won't actually depend on the output of the former. `a` and `b` are like that in this code. So we can optionally adjust the spacing to neaten up the diagram like so: a──+──╥──────┌─────*── b──╜ ╙──÷───┘──*──╜ c──╜ d──╜ I wondered how compact it could go, so I tightened up the spacing to the maximum. I personally like to be able to fit a lot of code on-screen so I wanted to see how much screen space you'd lose this way as compared to standard Forth formatting. As a matter of fact, both this formatting and the standard formatting have an area of 24. a+╥─┌─*─ b╜╙÷┘*╜ c╜d╜ 
No, the Belt model is based on back indexing of the first and second operation parameter whereas in my proposal only the first parameter is indexed and the second one as well as destination location is always the top-of-stack position. It resembles an accumulator-stack model (more like the IA32 FPU stack is addressed).
I see. I was really just referring to the idea of the stack items "falling off" the back of the stack -- no `drop`. It's *like* a belt machine. Still, isn't there some difficulty in figuring out the subsequent picks if nothing is ever dropped? Maybe it is not so bad. I need to come up with a good example and try it out. 
The name `UM*` explains what it does, in a terse way. Let's break it down. * `U` means unsigned. No need to explain that, I guess. * `M` means mixed-precision. There are two single-precision inputs, and one double-precision result. * `*` means multiplication, of course. Most CPUs have this operation as a machine code instruction, because it's a useful building block. If you multiply e.g. two 32-bit numbers, the result will always fit in 64 bits. Now, in traditional Forth, double-precision numbers are represented on the stack as two items. The top item is the most significant part. If you multiply two smallish positive numbers, the most significant part will be 0.
Interesting. I've been looking for a way to simplify my metacompiler.
`bind` is how we do meta-compilation in our system :-) EDIT: the process we use is actually much simpler than the one you seem to be suggesting in the IRC transcript.
&gt; BIND implementations in various forths: http://hub.darcs.net/pointfree/forth-bind `bind` behaves slightly differently in our system. Because of how compilation works, `bind` only effects words that are compiled later. Once compiled, programs have no dependency on the wordlist. In the case that late binding is desired a call through the word list is compiled instead. `bind` then has the effect observed in your examples. Both have their uses but I prefer to preserve hyperstatic scope wherever possible :-). `bind` is nice enough to support both equally, but the default behaviour is reversed. Because `bind` effects the most recent word it finds with a given name it should be sufficient to create a new word with that name to get this behaviour in classic Forth[0]. In any case I'm happy you like my solution :-) [0] This is how I used it when I implemented `bind` for a more traditional Forth.
Am I right in thinking that BIND is not possible on subroutine threaded and native code compilers?
`bind` was developed in a headless subroutine threaded and native code compiled Forth-like language, and it works very well. See my previous comment. https://www.reddit.com/r/Forth/comments/5aas7t/i_have_udlyunds_bind_word_implemented_in_a_number/d9f77iu/ The main difference is that in subroutine threaded and native code compiled Forth, hyperstatic scope is preserved by default. Something I consider an advantage :-). In classic Forth you have to do a little more work to preserve hyperstatic scope but it becomes incredibly easy to do rebinding. In our system you have to do a bit more work to do late binding. Otherwise it's the exact same mechanism. The difference is in how the compiler and the word-list interact.
As Forth allows concatenate programming, it is possible to transform code sequences into sequences of word definitions which consume either zero up to 3 parameters, These are: 1. Nullary ( - ) 2. Unary ( ...-n ) 3. Binary ( ...-n1,n2 ) 4. Ternary ( ...-n1,n2-n3 ) words. The transformation can naturally be done at edit (alias parsing) time and is trivial implementable. As the number of remaining stack items is not important as long as stack growing is limited to a fixed depth, I think the easiest approach is simply restricting the number of return parameters to three.
If it was in the Loop, I would consider it.
I don't have any connections for meeting space in the loop (I was going to just use the makersapce I started in St. Charles). Do you know anyone out there who would be willing to host us?
The confusion comes from FORTH having an outer and inner interpreter, the outer interpreter acts only on an input stream of text, the inner interpreter executes a list of subroutines that are compiled into the dictionary as words by the outer interpreter. There are as many ways to build the inner interpreter as there are FORTH systems.
Thanks for sharing my article. Welcome to the community. 
I see UM* as the natural requirement of any program that is going to use integers but needs to manage numbers bigger than 1 CELL. It is especially useful on 16bit controllers like the MSP430 for example where if you multiply 2 numbers together that require a product that is bigger than 2^16 ie: 65535, the answer will overflow. 16 BIT Example: 12500 25 * . -15180 ok ( wrong answer) 12500 25 UM* 312599 D. ok ( correct answer) So by using UM* you can multiply your 16bit data by a multiplier and get a 32 bit result with much less worry about overflow. The same is true on a 32 bit Forth where your application's products might exceed 2^32. B
What order are they in on the stack? If a=30, b=20, and c=10, and you enter them as "a b c", i.e., 30 20 10, then you wind up with a stack that looks like 10 20 30 and you'll have to do stack manipulation to get what you want there.
That depends on the definition of stack manipulation. If *&gt;r* and *r&gt;* are said to manipulate the stack, then *-/* relies on stack manipulation.
Consider what b a - will give you in infix form. It will give you b - a (don't take my word for it, try it out!). d c / will give you, in infix form, d / c. So you have that part correct. You just have the subtraction backwards. It's usually pretty easy to do things without much stack manipulation if you are able to assume that the caller will conform to whatever works best for you - and this does make it quite easy to write code bottom-up - but it can make it hard to reuse words (you end up with PHP syndrome, never sure which order parameters go in). I think you'll find that the less general you make your words, the less stack manipulation you do (it usually ends up just consisting of dups or overs and, occasionally after loops, drops). Hope you enjoy the rest of the book!
One of the strengths of Forth is that you don't have to guess about things like this, as you might in a purely compiled language. Read the book, sure, think about it, sure, but then talk to Forth and it will talk back: 30 20 - . 10 ok .s &lt;0&gt; ok 10 10 / . 1 ok .s &lt;0&gt; ok 30 20 - 10 / . 1 ok .s &lt;0&gt; ok Looks like it works. The interpreter is your friend.
Yes! But when I did it said "swap is not unique", so I thought it would just ignore it, so writing that made "swap" into "rot"? 
Yes. You've just learned something else about Forth: Nothing is sacred. You can redefine *anything* in the language, and it'll let you; there are no reserved words. You can even say **: 2 3 ;** if you really want to, although you'll get upset when you try to do **2 3 + .** and Forth dutifully informs you that the answer is 6.
I can't make it work. Currently I have this in ~/.Xresources XTerm*allowWindowOps: true XTerm*decTerminalID: vt340 XTerm*sixelScrolling: true XTerm*regisScreenSize: 1920x1080 XTerm*numColorRegisters: 256 This is XQuartz. I start xterm with -ti vt340 and -tn vt340. If I start it with gforth examples.4th there's just nothing. If i just start gforth and type include examples.4th, the page clears but that's it.
Here is a concept that uses counted strings as a single linked list. They are frowned upon by some, but I have used them for years. \ you may already have a word like ," in your system : ," ( -- ) [CHAR] " WORD c@ 1+ ALLOT ; : [[ ( -- ) 0 C, ; \ these are just sugar : ]] ( -- ) [[ ; : nth ( n list -- addr) swap 0 do count + loop ; : items ( list -- n ) \ return the number of items in a list 0 begin 1+ 2dup swap Nth C@ 0= until nip 1- ; \ usage create mylist [[ ," This" ," is" ," a" ," list" ," of" ," strings" ]] \ example only : .print ( n list -- ) nth count type ; 1 mylist .print 2 mylist .print \ etc...
Forever FORTH! 
Nice. I prefer to have the colon in the left-column, and align subsequent lines with the start of the word. Then, indent the contents of 'if..then' blocks or similar. I try to have comments hanging in the middle of the screen (column 40 or so). I've taken to avoiding tabs, and setting tabs equivalent to 2 spaces (in Forth code).
Reminds me a bit of [Schematic Tables](http://www.subtext-lang.org/subtext2.html) from the [Subtext experiments](http://www.subtext-lang.org/). Would be interesting to put Forth in a spreadsheet. 
Hahas I've found that nobody else spelled it in all caps but me. Also, FORTH is not an acronym. I imagine older computers typed in all caps by default... and apparently had very limited filename lengths.
&gt; Would be interesting to put Forth in a spreadsheet. https://github.com/tiluser/Creole-Forth-For-Excel He gave two SV-FIG talks on the Forth in a spreadsheet. SV-FIG talks are on YouTube, but they are hard to find because the meeting agenda gets wiped clean after each meeting and the YouTube videos are named only by the date with no description. One has to go through the https://github.com/svfig/svfig.github.io commit log to get a glimpse of the old agendas. We're working on fixing these problems.
Ok, I dug through the `.ims` files (?) and found a [video from Nov 2016](https://youtu.be/ASgBoKisWac?t=4053) I was thinking specifically that each forth word would get its own cell and individual cells could be addressed by Forth code. 
It does look awful, but there's probably not much you can do short of factoring out the guts of it thusly: : (s?:) ( b c-addr u1 -- c-addr u1) rot if 2dup [CHAR] : scan nip - else [CHAR] : scan 1- swap 1+ swap then ; : ?:" [CHAR] " parse (s?:) ; : s:" [CHAR] " parse postpone SLiteral postpone (s?:) ; immediate 
so how to include " as character ?
Build a PARSE that skips over any character preceded with a \ (or your preferred quote symbol), and use that.
Thanks for the link!
Or indeed, just call it s?: and have it expect a leading character *and* a string delimited by that character: : [s?:] postpone [CHAR] parse postpone SLiteral postpone (s?:) ; immediate : s?: postpone [CHAR] parse (s?:) ; true s?: $ I said "yes"!:Nobody said so...$ **I said "yes"! ok** 
Glad to see a post with substantive content about 8th.
I would be interested to know, what implementation options you see ? To explain my question a bit: The signed magnitude as well as one complement format are able to represent four 'balanced' states in two bit: one, zero, minus zero and minus one. Because some recent memory types (most prominently special Flash and lesser known some MRAM configurations) can store two bits per circuit (one quart) this should theoretical allow the efficient implementation of L4 based processors (somehow). So at current, a processor based on Belnap's logic interest me more than a ternary one would, just because of the possibility to exploit established, high integrated standard components. However, probably I just oversee the possibility to implement ternary processors in a comparable way.
&gt; I would be interested to know, what implementation options you see? Well, imagine mapping +1v and -v1 to trit-value 1 and trit-value J, along with 0 to trit-value 0, and we have our three states in a single line. I'm reading some papers on how ternary can be dealt with in very few transistors -- on the order of three for a half-adder, six for full, IIRC.
Alright, I just finished the CENG paper; it's really interesting that such an addressing scheme could reduce bit-switches that much. &gt; Now, how would this work on a ternary computer? Perhaps you'd need a 3-ary Gray code. If we were to implement that addressing scheme, yes. -- And it sounds like it could be rather a good idea in a ternary CPU, especially a stack-machine sort of CPU. ([This paper](http://fpgacpu.ca/stack/Second-Generation_Stack_Computer_Architecture.pdf) references the c13, a processor that has a predicted *sustained* execution rate of 2400 MIPS.) &gt; Your instruction set would semantically need triangular symmetry. 3-way relationships such as the voltage, current, resistance relationship come to mind. I'm not sure what you mean by a triangular semantics -- could you elaborate on that? 
I think that you are un-forthly putting the cart before the horse. The whole point of Forth is not to bother with a language, but solve a practical problem instead. Have a problem first then conjure a language in a process of solving it. Also, only (1) is a requirement. Everything else is optional. Including stacks. 
It depends on what problem you are trying to solve. For myself, I was interested in writing cross-platform secure applications. So since I had to come up with my own tool anyway, I made 8th different from ANS Forth in a number of ways. For instance, ''higher level' constructs like containers (arrays, maps etc). But that level of generality is not needed by everyone. Indeed, the embedded folks want the very smallest footprint possible consistent with the features they need. That's where ANS Forth is very powerful.
&gt; to someone who is brand new to forth and programming it is very hard to learn Elizabeth Rather, who's been doing this longer than just about anyone else, frequently reports the contrary; it's actually much easier to teach people who are new to programming Forth. I'd guess that's because they get intuitively that each word is its own creature, taking from and leaving on the stack, and aren't necessarily expecting to write Fortran-type expressions with named parameters and locals sprinkled freely all over the place.
The authors of this paper basically make two virtual machines without implementing any optimizations and then conclude that stack based virtual machines are slower. Well, no shit. However, in real-world scenarios, you would typically have a number of optimizations in place to get rid of that speed disadvantages but the paper doesn't do that.
It is absolutely doable. Just use implicit registers. Yes, it is a bit less versatile, but if a situation calls for it (i.e. a hardware is limiting) you can do it.
Perhaps a better paper on the subject would be [Second-Generation Stack Computer Architecture](http://fpgacpu.ca/stack/Second-Generation_Stack_Computer_Architecture.pdf). You see, the performance of a virtual machine might be ***very*** different from the performance of the equivalent in-hardware. ***This*** is the subtle difference between emulation (a VM) and simulation. (See the [KDF9 Emulator](http://www.findlayw.plus.com/KDF9/#Emulator) as an example where the emulator runs ***much*** faster than the original 1964 hardware.) As a counterpoint, one of the processors in the Second-Generation paper, the c13, is predicted to have a sustained execution rate of 2400 MIPS for about 20mW. -- For comparison, Roy Longbottom's benchmarking of his own computer [[here](http://stackoverflow.com/a/19066131/608963)] was about 17500 MIPS, as he also says "*For a modern CPU at 2500 MHz, likely MIPS are between 1250 and 9000 using CPU/L1 cache but much less accessing data in RAM.*" (So it's quite impressive that something with the power-requirements of a [*laser-pointer*](http://www.laserpointerpro.com/attribute/power_20mw-lasers_20) can achieve about 26% of the computation rate of a 2,5 GHz processor.)
&gt; However, in real-world scenarios, you would typically have a number of optimizations in place to get rid of that speed disadvantages but the paper doesn't do that. Good points, though this last bit does raise the question of "How would you do these optimizations in software?" -- I suppose you could have a `Stack` type where the top two elements are variables and the rest of the stack is a real stack, trying to emulate how [some] stack machines have the top two items essentially as registers directly feeding into the ALU.
Usually there is a JIT translating the stack code into register code for the target.
That's true, but using Delayed Emission (aka JIT) just moves the 'when' of the question, not the how. (That is, the generation of the actual executable code.)
I haven't given that too much thought, since 8th runs on commodity OSes and hardware. If I could choose, I would want a processor which supported users-space per-thread stacks. That would make life easier...
The conclusions of these paper are understandable for me as logic result of comparing a naive stack- with a somewhat better designed register VM design. However, for Forth interpreters, this paper probably is of no relevance because following design advantages are ignored by the authors: 1. Stack VM designs allow very compact encodings. This **can** be of advantage for both memory as cache usage. In comparison, for register based designs the opposite is true without loosing the advantage of direct value referencing. 2. An efficient encoding of a stack VM allow fetching and execution of instruction combinations (static super instructions) within a single interpreter iteration and without additional effort whereby this optimization is only of limited use for a register equivalent because the resulting table offset will regular get to large to be efficient implementable. 3. Instruction bundling over compensate for the higher instruction count in my experience 4. A stack based VM can at least cache TOS in a physical register whereby register referencing make this near impossible without time consuming code transformation 5. The advantages of register based VM designs for JIT or AOT compilation are questionable in my opinion beside naive code generation 6. Forth is a stack based language and fit well to this execution model. Single primitives would likely require more instructions with a register based VM design.
Probably XMOS MCU's are a valid target conform to your requirements. In this case I recommended you take a look at the instruction-set architecture to figure out how to implement thread aware stacks (the documentation therefor is somewhat difficult to find). Another option would be the Parallax Propeller. For this MCU the common addressing schemes to control external memory will be important to you. There are all supported by the Gnu C compiler port to my knowledge.
Interesting information, thanks! I'll have to look into that. 
Well, it would stack overflow; gforth does not anticipate having a 10MB stack! However, the quick and dirty solution is to start gforth with the -d option, to give you enough stack space. It takes friendly values, like 64K or 32M. (If the numbers are floats, the -f option does the same for the float stack.) Of course, what you *do* with ten million numbers once they're all on the stack is a whole other matter... but **depth** is probably your first port of call.
gforth cannot read data into buffer? I have no idea, but I've found this: 11.6.1.2080 READ-FILE FILE ( c-addr u1 fileid -- u2 ior ) Read u1 consecutive characters to c-addr from the current position of the file identified by fileid. If u1 characters are read without an exception, ior is zero and u2 is equal to u1. Found here: http://lars.nocrew.org/dpans/dpans11.htm
Of course it can, but OP initially tried to read all the numbers onto the stack by loading the file; it failed because the stack overflowed. I just pointed out how to make that work. After all, why reimplement an interpreter if you can reuse the one that's there already?
If these papers are available on-line, please post the links.
I've been reading dozens of papers over the past week-and-a-half, hundreds of pages, in research for going into business of creating ternary computers -- I'm convinced of the need for formal methods proving at the lowest-levels, the OS, the network stack, and common libraries -- but I did keep some notes and one of the paper is [here](https://arxiv.org/ftp/arxiv/papers/1108/1108.5527.pdf). I am looking for a team, or rather will be, once I have the new new company organized (which requires good structuring and financial plans).
There's no question about Chuck Moore's genius. And he seems to be a very happy man who's been able to do what he loves for all of his life. If GA were perfectly happy doing hush-hush government contracts, good for them. But it seems to me that they are trying to reach out to common man. They have this strange schmartboard + GA144 offering. Why? Schmartboard is like soldering for kindergarten, do they want to say that GA144 is equally as accessible as those boards? I expected to find some tutorials, plenty of youtube videos. As much as I like hearing Chuck talking, seeing someone younger would also do good to the general appearance of GA and Forth. But there's nothing. Even their description of this unlikely alliance is quite lacking in self confidence. They haven't even tried building what they are offering: &gt; Although we have not built one yet, it appears that one way to build a minimal but complete system would be to assemble the above board, power it with a 1.8v power supply such as SchmartBoard P/N 710-0003-02 ($10.00), and for high speed serial communication use an FTDI Breakout Board from Sparkfun® Electronics ($14.95). This appears to be a complete, minimal system for about $60.00 in parts plus some bypass capacitors, wire, and labor. The bottom line: I'm a Forth newcomer, it's a hobby, I have no idea how long I will be able to sustain it because it requires quite a bit of attention. I'm also friends of PCB design toos, microcontrollers and a soldering iron. But even I'm hoding off from buying a GA chip because it's so weird and I don't hear about anything done with it ever.
I wish there were more people blogging about it. I would read such blogs with plenty of interest. I think GA is super cool, but I'm too average joe to just "get it".
Interesting. -- Your research would indeed be of interest to me. I do admit that I'm not *good* with the HW / EE, but I have a few friends in the field who are talented or might be able to point me in the direction of good HW/EE guys.
Very cool! Hadn't heard of Punyforth before.
Found through [this tweet](https://twitter.com/deech/status/810524484415451136) This video is killing me in weird ways. It's so "obvious" the way he thinks but there's no paradigm, it's all stack juggling, very cute (when you're used to it) but very implicit. Still magnificent, a one screen definition of an html editor. So small...
Fortunately, there exist already a flexible configurable open-source VLIW processor design: [ρ-VEX](https://github.com/tvanas/r-vex) Be aware that the current state does not implement pipelined execution (which can be quite essential for a VLIW processor). Anyhow, such additions do not require sophisticated effort for this class of architectures. My CPU designs are often characterizable by integrating a special software environment and an execution unit (the processor in this case) to a holistic unit. The software environment processed and decoded a compact, packed operation code of 128 bit, bundling 21 operations, whereby the first 64 bit encoded 9 bit wide function bundles (3 bit selectors x 3) for a specific code sequence to be executed. Please notice, that selectors encode the functional units of the VLIW processor to be addressed. The second 64 bit word then selecting the instructions of these operation sequences. The software environment interpret these packed operation codes and transform them between runtime into a very wide control word for the VLIW processor which directly initiate program execution. These control words are cached and replace the prior interpreted program path. This description resembles a traditional JIT compiler. However, I found a less complex way to realize the transformation which can be better described as dynamic initiated but otherwise static AOT compilation. As the slot values of an operation code utilized balanced, ternary encoding, a ternary VLIW processor would allow an even more compact operation-code package. However, my exception is that the VLIW core must be completely redesigned to make this efficient possible. I left out all details, which should raise up by reading. If you have questions, feel free to contact me. Addition: I started working on my current design and abandoned this concept after finishing the interpreter part, because I realized that the transformation to control sequences lead to a runtime decrease as result from decoding ternary slot values.
This is very cool Forth code and I love the workflow he uses (ecr).
Hopefully not. "Big" and "general" are two qualities entirely antithetical to the way of Forth.
[removed]
I've played with forth off and on over the years, and love the language. But some of the nuggets in this screencast make me wish there were more of these. That control flow manipulation using the return stack was really interesting. I did some searching -- does anyone know where some other forth screencasts might be?
and charlie forth is found here: http://forth.thi.ng/ Karsten begins talking about forth at 24:40 in the video. 
from the talk at 36:14: "Lisp is the ultimate high level language. Forth is the ultimate low-level language" -- Richard Jones
Regarding your points, I designed 8th with (2) and (3) and (4) in mind. I've considered the idea of treating code like a database for (4), e.g. where an 'include' or something would bring the code from a database. Currently, 8th uses a (sqlite) database for its help system. I have been considering making it easy for users to add their own help (e.g. for their own words), which would be a benefit. Regarding (1), you really mean an IDE rather than an editor, I think, because 'visualizing the stack' requires your editor to have knowledge of the state of the Forth instance. Or do you mean to keep track of how the stack *should* look?
I think that by keeping code in a database, word metadata that would normally be stored in the dictionary for the compiler's use would be in the database and thus available to the editor. Metadata such as stack diagrams could be quickly referenced and evaluated so the user could see the state of the stack at any point in their code (abstractly, independent of Forth dictionary or VM state), and the system could also check your code's effect at return(s) against the stack diagram you specified for you. A database would also allow words to be referenced by id rather than name, so that for instance you could ensure that a project-wide word rename is true to your intention. It could be much more than a simple catalog of text files. It would require a new kind of compiler and probably have some free bonuses, like definition order independence.
Good points, all. Stack-effect-diagram enforcement if the REPL were modified to do that is something I've been asked to implement, but think is not a great idea or universally useful. Allowing words to be referenced by unique id might have other uses as well, such as dead-code elimination or source tokenization etc.
At least in 2010 (and of course both will have seen development since), LuaJIT's *interpreter* beat V8's JIT ^[ref](http://lambda-the-ultimate.org/node/3851#comment-57761) - and that's without even invoking the compiler. Simplicity has its benefits. As regards 1, colorForth goes some way towards that, and Jeff Fox's proposed aha system gets even closer, although I don't know whether he ever implemented it. Peter Knaggs' thesis (should still be around somewhere) discusses 2, but given that much of Forth is built on the assumption that there are no data types, would it be useful? There are a few type-checked Forth dialects around, and my impression is that they haven't exactly taken off. Perhaps an editor that kept track of stack effects would be, in the long run, more effective than the false security of type checking... but then we're in the realm of hermetically sealed environments. 3 should have been provided by vocabularies, before ANS Forth meant you couldn't rely on their presence; in F83, the ONLY/ALSO words provided an elegant mechanism for building customised search paths and fine-grained control of which words you could see where, one that could easily have been extended to load vocabularies on demand. NEEDS is a poor substitute. The Forth Scientific Library was an attempt to provide something approaching 4; it's still around, but I don't get the impression it's actively cultivated any more, let alone seeded something broader. The problem with such an endeavour, I suspect, that Forth's remaining niches are so dingy that there's not much scope for standardised approaches to them.
Factor is a mess though. It doesn't really resemble Forth at all anymore too. I tried it and gave up, citing excessive complexity on my way out. Something like 6 ways to load and store different variables? And there were gotchas iirc . It's just too much. 
It is, no doubt.
&gt; A big part of the problem is that the hardware you are running your software on puts some very real constraints on simplicity. I will give a talk in January introducing a solution to this specific problem.
Very different. ANS compatibility requires a code translator for sure (good idea!).
Of course VARIABLEs and other "indirect" objects need a "pointed to" type. How you define that I don't know yet. There must be a generic "no type" fallback, and new code could have qualifiers maybe. INT BOOL etc that go after the declaration, like IMMEDIATE. I like your THE. I could see that idea being useful in a number of contexts, not just vocabularies. I see a future in which Forth code is highly context dependent so you're not using such words as THE for what you described but the other way around, i.e. simple, generic sounding words are "domain specific" as I feel that big applications are best broken up into simpler idioms and this is the direction Forth should go to distinguish itself. I just don't see good Forth code coming out of constantly plucking words from other vocabularies. I also don't see the letter prefixes for floats and other data types as a big problem, so long as their use is moderate. Proliferation of such words is bad. I solved the problem of precision in my codebase by making the interpreter interpret integers as fixed point numbers by default. Cut back on the need for floats by a lot. I guess in theory if your application needs to rely on floats, and you don't want to see all those f's, you could define an idiom that redefines + - like you say and import that. Here's the draft description of idioms from my talk: https://www.notion.so/Idioms-b0143b6807324241a24887f3498c219f Fascinating info about type-segregating stacks! In my game engine I have segregated all game objects into their own stack and "current object" and given the right API (it needs to be air-tight) it's successful. It has to be thought-free for it to be worthwhile. Managing 2 stacks is enough trouble.
I will write something together
[removed]
Thank you.
[Done.](https://www.reddit.com/r/programming/comments/5l9zh1/c_as_an_intermediate_language_xpost_rforth/)
[removed]
Forth's high-degree of factoring has been noted to lead to a "logarithmic growth in complexity". I've often argued that it's better to just write the code, then abbreviate, creating new definitions as useful sequences emerge. Forth makes this process incredibly enjoyable. In most cases you can take any common sequence of words and name it. This process is exactly what the author terms "Semantic Compression" :-). I agree with you that problem-oriented languages are a powerful technique but I wouldn't say that custom parser's factor into how I program in Forth. In fact the Forth that we developed and use professionally explicitly eschews parsing words; as Mr. Moore once put it, "Forth has a perfectly good interpreter if you will just accept the word order." Now the names that you choose should ideally form a problem-oriented language, but it isn't necessary to start by designing such a language. I find that it's very hard *not* to end up with a problem-oriented language when working in Forth. EDIT: In case you thought that this compression metaphore hasn't been applied to Forth before, &gt; Another aspect of Forth is analogous to Ziff compression. Where you scan your problem you find a string which appears in several places and you factor it out. You factor out the largest string you can and then smaller strings. And eventually you get whatever it was, the text file, compressed to arguably what is about as tightly compressed as it can be. &gt; And in the factoring you do to a Forth problem you are doing exactly the same the thing. You are taking, discovering the concepts which if you factor them out leaves the problem with the simplest description. If you do that recursively you end up with, I claim, arguably, the most compact representation of that problem that you can achieve. Source: http://www.ultratechnology.com/moore4th.htm 
You don't have to overwrite the standard parser just because you have built a DSL. But you can.
Lisp and Forth are like twin brothers, which are quite different. http://wiki.c2.com/?ForthVsLisp
I don't see how that's possible. If you define a parsing word for anything more than a single whitespace delimited token (aka a word) then you are by definition taking over control of parsing from the interpreter. This is an exceptionally powerful tool and it can be used to great effect but at this point what of forth remains? You can write an SQL parser and then just slip off into SQL land and never come back. Again, it's very cool that you can do that and there's a good argument to be made that this is more powerful than Lisp macro's but you've lost the core strengths of Forth e.g. simplicity and composition. If you want to make more than basic use of parsing words, you'll have to reimplement almost everything from scratch; you can do anything but nothing is particularly easy. Lisp macro's and Forth immediate execution are arguably preferable because a lot of the grunt work is done for you. If you can live with the word order, then I see no reason for parsing words, and I think their use should be limited to implementing new leximes. At which point there are better ways of doing it e.g. recognizers.
The Lisp macros can't change the Lisp syntax, but few find that limiting in practice. Likewise, if you can live with RPN there's no point in radical surgery.
[removed]
&gt; so gradually Lisp evolved into having macros and functions, just like Forth. It seems to be convergent evolution. Other languages are also feeling the drag of that attractor, but are much further on the periphery, and move much slower. Plus, there is a lot of churn.
The HOPL articles about Lisp ([McCarthy's](http://jmc.stanford.edu/articles/lisp/lisp.pdf), from HOPL I, and [Gabriel &amp; Steele's](https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf), from HOPL II) provide some clues, as well as making for fascinating reading. It seems that fexprs always required special treatment by the compiler, and couldn't be defined in terms of each other; by adding **defmacro** as an analogue of **defun** whose result was evaluated but whose arguments were not, the semantics were cleanly (-ish!) separated into compile-time and run-time respectively. On the other hand, using fexprs for everything does suggest a lazy programming language, deferring evaluation until the last possible moment. [Lispkit](https://en.wikipedia.org/wiki/Lispkit_Lisp) might be considered such a language.