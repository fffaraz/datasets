I think it did a good job, sort of. It was good for what it had to work with, but I'm not sure that it was the best option. I don't think browsers were where they needed to be to make something like JSF a success (from an implementation/experience standpoint) when they tried it. I think if they had tried that approach maybe... 5 years later? Yeah, they probably would've done a lot better.
Ha, you haven't worked with text parsing and statistics before have you? I have [another one](https://github.com/uniVocity/univocity-parsers/blob/master/src/main/java/com/univocity/parsers/csv/CsvParser.java#L167) for you. This is arguably more complex as it is also recursive. Sometimes the problems you have at hand are complicated and require complex algorithms. Additionally, there's one thing that you are missing: this is the FASTEST parser you'll find. Many design decisons were based on performance. Try to refactor this code and make it run 5% faster without making it look way worse. Give it a chance and look at how the entire project is structured.
I've seen plenty of high performance code that didn't have to be that unwieldy. Refactoring even to a readability standard doesn't have a huge performance hit due to the way modern JVM's optimize code. In the end it'll end up as the same (or very similar) byte code, but you'll gain the fact that a developer can work on your code a lot more quickly. Perhaps you don't care about that? It sounds like you should familiarize yourself with the optimization work put into the JVM over the last decade. A lot of the premature source code optimizations that used to make sense are rendered pointless with JIT improvements. Try refactoring your code, run it in hotspot, and profile it. You'll see the difference. If you are going for true performance, are you using unsafe? Usually that is where performance gains are made to avoid GC pauses.
That's true. Raspberry Pi is an embedded device that human beings actually use directly. So I guess 32-bit ARM Java is still useful.
After I realized that I can easily install the Python and PHP plugins, this is technically all I need in an IDE. :-)
Bintray doesn't support snapshots, so you'd use Sonatype's snapshot repository instead. I use the Nexus plugin which is [almost as easy](https://github.com/ben-manes/caffeine/blob/master/gradle/publish.gradle) to use as the article's plugin. For travis just export the nexus user/pwd as hidden environmental variables prior to triggering the uploadArchives task.
Brilliant. It is another article that seems to editorialize conflict where I am not sure there is. Is there significant numbers using node.js at an enterprise level where JavaEE lives?
i think jsfers are finally fleeing for angularjs. jsf has its plusses but in the end only one or two component libs dont make your eyes bleed while angular easily leverages the node world without horrible jsf quirks. jpa i dont see going away anytime soon. good skill to know if you advertise yourself as a java web guy.
Thanks a lot for the info, it should give me a lot to go on. Also, at current, I don't think there's going to be any manipulation, merely retrieval. Might change later, but I don't suspect it, as the project is simply changing physical lookup to electronic lookup. I even offered to look into making the project hook into the programs they were using it in conjunction with and I was told not to bother.
Nope, with other editors like Atom or Eclipse, I tend to switch across tab using simple key combinations, ALT-1, ALT-5, ALT-1, ALT-4, etc.
Thanks, nice to see there's some work done in that direction. Still some years of patience and we'll get there :-).
&gt;A ton of apps are written with JSF + JPA but not so much public web sites. You're be surprised really, it are more than you probably think. Zeef.com, bmw.de, eBay, Hardvard's Dataverse, ... just a few examples of public sites.
So was I the only one having trouble pushing stuff to Maven Central :D ? I should have looked sooner for similar tools. Still, it is a bit awkward to open a ticket for each project to be pushed on Sonatype. Are you aware of any alternative?
You're right.
Agree, I look into IntelliJ sources a lot while implementing plugins, and finding something in about 50 000 classes is not a problem. You just try to guess the name of a class or method - and unlike in Eclipse, searching by name is totally awesome. If I find nothing, then I can try fulltext for some text which I see... Then there is nothing better then debugging and clicking through frames up to see where it was called from, or navigating by class hiearchy... In all that, the project tree is useful only after I find what I want and want to see what is around. I don't remember ever going through countless unknown modules and packages to find something.
Or just stop living in the past and start using @Rule...
Your plugin looks nice. Thankfully it and others exist because Gradle's maven plugin appears scary at first sight. I really like how you infer the metadata. Central is a mess, but reliable. Luckily if projects use the same root (e.g. github account) then you don't need a new ticket each time.
This gets me excited, but only because I know functional programming more than object oriented
no, not really. for some it is, so try it out. for most it isnt.
this was fixed in 2008 for HQL, according to the support ticket. And would be easy to implement in a criteria query (without using a join directly). So bit of a daft blog post, imho. People want all of the functionality of SQL, with as close syntax to it as possible - why even bother with an ORM framework then ? Just run some prepared statements and populate some model objects/dto's.
Wait until they incorporate CLion into Intellij IDEA ultimate. It will be the real ultimate IDE!
Maven is independent of JSF or JPA. It is a pain to get started in JAVA regardless of frameworks because there is a lack of complete tutorials for building more than just a sample web application. There should be very minimal XML outside of Maven for a JSF/JPA web application.
Google has already announced that AngularJS is getting depricated. It is popular on blogs and mostly smaller systems but a mess on a large corporate web application. It is just the latest fad that was going to take over the world but failed to be really practical. There are some uses for sure but is no threat to JSF. You can even build JSF applications with Angular if that is what you want to do but most of us do not want to deal with the headaches and extra time required to build an Angular application.
You are backwards. JSF sucked in 2002. It was when JSF 2.0 came out that is because a great way to build web applications. You have a theoretical objection because it does not do thing the way you like. For those of us who have to produce something it is a great framework to use.
Disclaimer: it is not my plugin, just sharing it :)
Eclipse is free, so corporations use it. They really don't like buying enterprise licenses for software with features that can be had for free. You may like the way IntelliJ provides those features more than Eclipse, but in-task productivity is the developer's problem. If the company provides industry-standard tools, there's no reason the developer should not meet industry standards for productivity. This is how the logic usually goes, anyway. I've only worked at one IntelliJ shop and they had a more academic hard science culture where the heads had PhDs and didn't think exclusively about money.
After using Java for 15 years (since version 1.3) I wonder how much version 8 will change what is considered idiomatic Java. In many of the examples I have seen people use lambdas and streams "just because" and not because it makes sense. But there are so many of them that I am curious about what their impact will be. I consider anything version 8 added to be nice syntactic sugar and in the right situation very convenient. But the way people talk about these changes makes it seem Java became a whole new language, which I just don't see. Lambdas are great if they contain one or two lines, streams are a nice way to remove a lot of nested loops. That's a level of excitement I can understand. I guess it's just part of my inability to understand what's so great about functional programming.
OK, seriously? http://imgur.com/n4IXhS1 public static List&lt;Integer&gt; filterUnderThreshold(final List&lt;Integer&gt; values, final int threshold) { List&lt;Integer&gt; returnValues = new ArrayList&lt;&gt;(values); for (int i = 0; i &lt; returnValues.size(); i++) { if (returnValues.get(i) &gt;= threshold) { returnValues.remove(i); } } return returnValues; } There are multiple problems with this code, none of which are are in the options. Yes, "under threshold" means less than the parameter named `threshold`, god dammit. Doesn't compile, no shit, its not a complete compilation unit... if that's the correct answer, come on!
My biggest problem with the game is that it doesn't let you know what the answer was if you get it incorrect. Leading you to never learn to get better at it
grammar
Even in small projects (like scripting a simple-ish web page, like JS was originally for), dynamic typing is terrible. So many ways to create a bug, and only extremely thorough unit tests can hope to find it. So much for increased productivity. Static typing is essential, period. Programming without it is like parachuting without a parachute.
An example of static duck typing is Scala's structural types.
I was with you until Netbeans. :D I think everything you said is correct. I'm not sure about TomEE though. Wildfly has the full weight of Red Hat and JBoss behind it and the underlying webserver (Undertow) is [pretty nice](https://www.techempower.com/blog/2015/04/21/framework-benchmarks-round-10/).
For people switching from Eclipse to IntelliJ IDEA, my [shortcut mapping](http://eclectide.com/blog/2014/02/27/intellij-idea-shortcuts-for-eclipse-users/) might be very useful. Also, check out my [Monokai/Sublime color scheme](http://eclectide.com/blog/2014/11/23/monokai-theme-intellij/). 
One IDE to rule them all :)
Yeah, there's good money in boring, blue collar, making it work coding. The world runs on this code and there's a huge variety of jobs available and company cultures for people who want to do it for a living. As for Android, if you can code on Android you can take those skills elsewhere. You won't become irrelevant if in 5 years Android goes away. The main thing as a programmer is that you continue to push yourself and learn new things. 
I wonder what's replacing them. Possibly phone gap for mobile and nothing on the desktop as more apps move into the browser? 
Also: No way to report code that has multiple errors (one of which might be one of the answers), or stuff where there are like 2 methods, and the text one the left asks what happens, when you do &lt;2 lines of code&gt; - this is ridiculous - a code game should show me the code in the code window, not part of it in the question. edit: To clarify: http://i.imgur.com/rLZpp8r.png - this example would be "doesn't compile/does nothing", unless you think of adding a psvm and making the p1 and p2 static (and both classes too). Aside from that, I'd guess the correct answer should be "RickiMaru", but this isn't considered correct? WTF? (It considers "Rickinull" correct - I think the author meant to write super.name in the toString of the Student class) 
C just won't die.
If you want to dynamically scale microservices based on load then you should go for a messaging architecture. This way you can easily spin up new instances of the modules required during load and just have them all consume from the same queue. Keep the front end as light as possible and load balance. The load should be just handed off as an event on to a queue anyway. It's really easy to setup with RabbitMQ and Spring AMQP/Integration. Also have a look at Spring Cloud for remote property injection. So I would have a VM per service, have them all running in tomcat regardless of whether they needed to be in a servlet container or not. You then need to add redundancy so having several instances consuming from an individual queue will solve this issue. Redundant RabbitMQ exchanges and also one for federation of non critical events. Monitoring queue sizes is going to be the way to go manage the dynamic scaling. Generally I'd go for a scalable datastore like Mongo DB and make sure I'm running in a replica set of minimum 3 but this is going to be down to your requirements. Oracle might be a better choice. 
The Netbeans thing is just ribbing. I don't like it very much but you're right that it has no bearing. I like the JBoss/Red Hat kickstarts but they won't really help with Spring here.
There is tomcat embedded but it isn't as easy to work with, is there a reason you would use it over Wildly? As far as using a swarm, you add the maven dependencies for the Wildly modules you use, add the swarm plug in and configure the mojo to run during the package phase which will create a -swarm.jar ready to be run.
Lambdas in combination with quasi final variables are huge imho. They remove so much boilerplate code. I'm very disenchanted with the Stream API though. It's just clunky to use. I'm sure I haven't grokked it all yet but all the calls to `stream()` and especially `collect()` sometimes negate all positive benefits of map, filter, et. al. which have been sorely missing indeed for quite some time. So no, of course Java 8 does not turn Java into a new language. It gets some influences from functional programming but what modern language doesn't?
There are a number of reactive toolkits/frameworks which can support horizontal scalability. If I were going to deploy a fault tolerant ReSTful service, I would probably use something like [Quasar](http://docs.paralleluniverse.co/quasar/) or [Vert.x](http://vertx.io/) with clustering enabled. I lean more towards Vert.x because of the robustness of the clustering and HA features. Also, version 3.x of Vert.x will support deployment of Verticles directly from a Maven artifact repository for continuous delivery. If you haven't tried it yet, I highly recommend it... I currently have several microservices deployed in an HA configuration with Vert.x and scaling it is as simple as changing the "Quorum" value to increase the number of cluster members running a given service.
I find a JEE application server to have some disadvantages: If a new dev checks out the code, he should be able to run all the test &amp; code, right? Not so. He needs a JEE server running &amp; configured beforehand. Both for running integration tests and for running a war. Whereas with spring all you need is a jetty or tomcat (which both can be easily included in the maven pom, and needs almost no configuration) and you're good to go. What's the correct way to solve this issue for JEE? Include the full JEE server config in your version control system (with the modules, which are jars, this can become quite big)? I prefer Spring. It also gives you access to advanced options like spring data jpa (nice with querydsl), spring integration and so forth.
Here's a link to the [write-up](http://www.reddit.com/r/startups/comments/37chcv/how_we_built_gurufoocom_lessons_learned_from_our/) I did on our launch... 
Uncheck "Save files on frame deactivation" and "Save files automatically" in the settings. My files are never saved unless I do so explicitly. You can also run broken code: "To be able to run code with errors, you should select the Eclipse compiler and turn on the Proceed on errors option on the Compiler | Java Compiler page in the Settings / Preferences dialog. You should also make sure that the Make, no error check option (rather than the Make option) is included in the Before launch task list for the corresponding run configuration." ([Source](https://www.jetbrains.com/idea/documentation/migration_faq.html)). It works as described, I've just tried it (IntelliJ IDEA 14). I highly recommend going though the [Web Help](https://www.jetbrains.com/idea/help/intellij-idea.html). And if there is one must-see IntelliJ video, [this is it](https://www.parleys.com/tutorial/543f9f45e4b06e1184ae41bd/about). It's a lot of "wait what, an IDE can do that?!" when you first encounter IntelliJ. 
It's gonna skip entries - List has 3 Entries i = 0 -&gt; delete entry, list has now 2 entries, i is incremented i = 1 -&gt; delete entry, list has now 1 entry, i is incremeneted i = 2 -&gt; i is &lt; list size -&gt; end iteration we now have a list of size 1, even though our loop should have deleted every entry. If you want it to work, you have to use list.iterator(), or start decrementing from the end down to &gt;= 0
Fuck man, I just want c++ to die already. Whenever I start a project in that language I fucking cringe.
Hey, since C++11^the^language^is^getting^really^nice...
&gt; It doesn't sound cool. It sounds fucking depressing, It does, but people sometimes find it cool to say depressing things about other tech I guess. &gt;I had a front row seat to the whole affair in a very real way. Please elaborate. Since early days, and increasingly so ever since things have been decided by the community. Take a look at all the JSF issues in the public spec and impl. trackers. 2.0 specifically was solely driven by community demands and things for which users had filed issues. 2.3 looks like to be the next step where it's almost handed over to the community, and community members are directly implementing the new features for 2.3.
Really great story, could have been a blog post!
As I mentioned in the other comment, great story. Really loved reading it. I think people here are not really used to articles in self posts. The usual format here is more to have the above story in a blog post, then post the link here (but be aware that you need to have your own domain, blogger.com and wordpress.com etc are unfortunately blocked here)
p.s. if I can make one comment, I see you're using URLs like this one: http://www.gurufoo.com/index.xhtml?cat=InfoSec To me there's a lot of unnecessary noise there. Why do you add "www.", what does it add to your URL these days? And "index.xhtml", is that really needed in the URL, especially with the extension? You should be able to remove the "www." via your server config, and since you're already using OmniFaces getting rid of the .xhtml extension should be easy. But I also saw that /login and /users/register don't have the extension, so maybe you are already doing that. 
Message Bus is a total anti-pattern to microservices, which are about distributed command and control, not centralized.
Did you know that NetFlix, the pioneer of microservices, runs their microservice architecture in Java and Spring Boot? http://www.oraclejavamagazine-digital.com/javamagazine_facebook/20150304#pg1
If I had to guess my hunch would be that people are moving away from Obj-C and using other toolkit/languages for IOS as alternatives have matured. With Java/Android there's a big pool of Java devs out there and Java isn't really a hard language to work with. So using Java isn't that big of a deal, the skills are around and translate into other projects(desktop, web, server side). But no one really wakes up and goes "Gee, I want to switch my career over to Obj-C today." It's just that IOS uses it so you use it if you want to target the iPhone. But as alternatives come up and mature into giving you a solid native look and feel they probably become a lot more attractive for developers to use. Personally I think Swift has the same problem. As a developer, do you really want to invest in a language that'll be locked to a specific platform?
On the horizon is wildfly swarm https://www.voxxed.com/blog/2015/05/wildfly-swarm-building-microservices-with-java-ee/ http://wildfly.org/news/2015/05/05/WildFly-Swarm-Released/
Wow thanks for the detailed response. I really appreciate that. I'll give this a go.
Why did this comment give me the spidey senses that you go to Northeastern?
What other school do you know of teaches their first cs course in racket? :P
Wildfly Swarm is really exciting
This is a really amazing post. I appreciate you sharing with us your experience. I am definitely going to use your experiences in my future apps. Keycloak 1.2 should hopefully be the last release with a lot of "churn". Keycloak 1.3 is shaping up to be mostly polishing for the eventual Keycloak 2.0 release. That release will be productized by Red Hat. I am curious. How has Wildfly held up? Did you run into any bugs? 
Thanks! Is VPS a special type of hosting or its just the basic one that one can get on DigitalOcean.com?
I mean, I'm writing a "fuck you RTC converter" in Java during my free time. 
&gt; functional way and &gt; setGlobalPath("jokes"); ...
I am not following. Are you trying to run the application on a different server for different developers? I would suggest do not do that. Just pick a server to develop and use in production. The simplest solution is to just choose a Java EE server with everything included. If you do not want to do that than you can include the Java EE libraries in your project. If you want to run it on different servers than there will be some minor configuration differences. I am not sure why you would want to do that though. 
Thankfully, otherwise hackers, virus writers and security tool vendors would be out of job and we don't want that.
Say I'd like to use WildFly with some custom modules. I'd want each dev to be able to checkout the code and run the app on his workstation. So they can work independently. So this leads to the following: -each dev has its own WildFly instance (config &amp; custom modules need to go in version control system?) or -Each dev uses its own tomcat and we include the libs in the artifact (dependency in maven pom (not provided)). This causes conflict with the artifacts (modules) present in Wildfly (jpa/hibernate/JTA,..)
Thanks for the input. Your option b seems a nice workaround.
&gt; On the other hand, outside of work, I don't know anyone who still does java. Has to be your circles, it's not the most popular language for nothing. I see it used everywhere. So many big sites use it. Facebook uses it, Google too, Twitter uses it, Netflix does... I mean is there any big site that does not use Java these days?
how is it compre to bootfaces?
More importantly: *I* use it ! My friends tell me I'm stuck in the 90's :-)
In a couple weeks Java EE 7 will be 2 years old..."new"?
Yes, that is on the roadmap and will be taken care of very soon. We'd originally planned on putting it in place before our launch, but got caught up in other things. (Oddly enough, however, we do self-signed SSL between all of our servers)
Spring Security is nice, but it comes with a lot of baggage: Spring. We couldn't justify adding that many more dependencies to our code, especially given that we are not using Spring anywhere within our site.
They must be missing a join to the content table.
✈ ☹
You mean *feces right?
JSF may be popular as in "widely used", but it was never popular as in "widely liked". Got any evidence to backup this claim of JSF's popularity, because I haven't heard of any new projects choosing JSF for about 5 years.
&gt; Got any evidence to backup this claim of JSF's popularity, because I haven't heard of any new projects choosing JSF for about 5 years. Startups: * http://www.adam-bien.com/roller/abien/entry/a_java_ee_startup_filtering * http://www.reddit.com/r/java/comments/37cfrz/how_we_built_gurufoocom_lessons_learned_from_our/ * http://www.adam-bien.com/roller/abien/entry/a_java_ee_startup_getting * http://www.adam-bien.com/roller/abien/entry/a_java_ee_7_startup1 * http://www.adam-bien.com/roller/abien/entry/a_java_ee_7_startup Popularity: * https://henk53.wordpress.com/2011/10/12/reply-to-comparing-java-web-frameworks/ Take a good look at the fact that some of the surveys mentioned there also ask for what people *like* before you say it's only what people *use* ;) 
&gt; I wonder what's replacing them [Java for IOS](http://robovm.com/). JK. :)
hahahahahaha
More like 2005.
Unless your employer is footing the bill I wouldn't waste the money. It's a ton of fun, but there isn't anything going on there that you cannot read about online. 
I have started two new Systems in JSF in the past 5 years. I never have trouble finding work. There are some people who tried it early on and did not like it because well version 1.0 sucked. It is rare to find someone who has actually used version 2.0 and did not enjoy it. It is a lot more common to find amatures on reddit who are pushing the flavor of the month and never tried it taking pot shots.
&gt; People want all of the functionality of SQL, with as close syntax to it as possible - why even bother with an ORM framework then ? Just run some prepared statements and populate some model objects/dto's. [There's a parallel reddit discussion about that in fact](http://redd.it/37fs5o), doing precisely that, but populating JPA entities again from native SQL.
You've got a point there I'm afraid, but not posting to r/programming only enforces the silly idea that Java doesn't belong there, but Python &amp; Ruby do. 
Yeah didn't they figure the existing APIs were better than what they could come up with and so wasn't worth the effort? Still I think a decent JSON API belongs in the Java framework, like we have JAXB for XML. For a lot of more "advanced" stuff it seems that they just make the specs with a reference implementation and this could have been used for the JSON API as well I think. Also it seems that they wanted to introduce other features first which the JSON API would build on (generics over primitive types).
Thanks for the reply. That is how I'm looking at it as well, a bonus. But I will have to foot some of the bill though... I does look like a good time.
Fortran's actually better than C for certain applications. I guess Cobol would be a better example: However when i checked I discovered there was a Cobol 2014 standard ...
 Thank you!
I think jigsaw is gonna be a nightmare for upgrades to 9.
No I don't. Also if you're going to spam your stuff on Reddit, how about checking which Subreddit you post your ***Javascript*** library to?
I like http://openjdk.java.net/jeps/243 best. Paves the way for really fast dynamic languages on the JVM.
&gt; I prefer SPA frameworks SPA is great for some things, not so great for others. I don't want GMail as anything else than a SPA, but StackOverflow as SPA would not be nice.
If there are many articles about that, it must mean the language is worth describing how to migrate away from, which means it's AT THAT point still popular. I designed a language in uni once, called it Mikey97 (don't ask, but it was really called that). Nobody ever wrote about how to migrate away from that since guess what, nobody was using it :X If those articles are indeed about migrating away then at some point the migration is done and no new articles will appear. Tiobe should reflect that. But if more articles about how to migrate away from that dying language keep appearing, then clearly that language is still not deed and very much used, so Tiobe is still right then one way or the other.
My winner so far is `inputStream.transferTo(outputStream)` (it took 20 years to add 10 lines of code ;p)
I didn't like it - examples are simplistic
Just get the code signed.
Ya here we go with Oracle bashing for the next few days. Ya let's all defend an advertising company over a tech company but whatever. 
Citation? Sorry but your anus doesn't count.
I think that's an extra couple million dollars.
Doesn't really work that way with copyright. If I write a book with the phrase "it was the best of time" somewhere in it I'm not breaking copyright. There are limits in copyright law. 
I had to look at this a little closer, Google did just copy the entire java stack and rename it, I remember now that Sun could have gone after them for this, but didn't want to go all SCO on everyone, especially someone like Google that has deep pockets and also contributes to the world in many ways. I am a little surprised java has survived so well given the fragmentation with .Net and then Android. Your point is good, I read this article and didn't think fully of the context. I do hope Oracle doesn't totally mess java up though. 
As much as I wish Google had just made a jdk that was compatible with all the others, and avoided all this nonsense, I still support them in this. It's ridiculous to think an api should be copyrightable. 
Java REPL!? that is very cool
Was a 200$ tucows certificate last time I checked, though you can probably go cheaper if you look.
Even if that is true, you can now be sued for having similar API calls, and you just don't know if your use is fair use till a court makes a ruling. That alone will stifle software development. This will become a legal weapon to kill open source projects.
It is like any conference.... The content can be found online. It is the hallway conversions and meetings which make it invaluable. You can also pack a lot into 4 days at JavaOne (talks, expo, parties, meetings) so more like an intensive boot camp. It also gives you a chance to step away from daily activities and look at things from a new angle
I went to Devoxx (Europe, Antwerp) a couple of times. It's interesting and fun, although crowded. Most talks give you a quick ramp up on a certain subject/technology. But you can, no surprise here, get the same and more if you take the time to read about it on the internet. In 2013 I didn't go to Devoxx (although my employer offered it), but took some time off work to read on the internet &amp; experiment at my own pace. It paid off a lot more than last years visit to Devoxx, but requires more discipline (in a conference you just sit down and listen, there's no active input required from you). One additional advantage for a conference is that it gives you the opportunity to connect irl with other programmers. I've had some interesting conversations, but this didn't result in longer lasting acquaintances. I'd recommend joining a JUG, it's a lot cheaper and imo you can gain more from it (also on a personal level).
Really great post, and really good job. Working with java a lot, i very often run into some of the misconceptions you have mentioned. The best way to clear those is creating things such as your project, proving that Java EE is not really what it used to be. I am curious about the OpenSessionInView, how did you go about implementing things without it? How did it work out in terms of development time? Again, good job, really
Google: Become an ambulance driver 873,000 hits Become a jihadi 969,000 hits But there are a lot more ambulance drivers right? Like, there's at least 40K ambulances in the USA. Great methodology there Tiobe. And what are these searches even counting?
We must never forget that “facebook” spelled backwards is “koobecaf” which makes as much sense as your post.
[More info with screenshots](https://translate.google.com/translate?sl=pl&amp;tl=en&amp;js=y&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;u=http%3A%2F%2Fniebezpiecznik.pl%2Fpost%2Fnie-wpisuj-to-jest-na-facebooku%2F&amp;edit-text=&amp;act=url) (autotranslated)
No matter how good or bad you do an some test, you'll always have 'alot of reading to do'. It comes with our field; constant learning. Don't stress about the test. Comparing yourself to the rest of the world isn't going to do you any good either. Use the test to your advantage now; figure out where you went wrong and improve. That really should have been the only purpose of it. Look, I completely know where you're coming from; imposter syndrome has this effect on anyone. You need to get past that by determining if Java is something you have a passion for and if so, realize it's something you need to continually be willing to learn and use. However, don't treat my advice to learning in the same way as school; learn incrementally. You don't have an exam at the end of the 'term', so don't rush. Find books, blogs, podcasts, Twitter accounts, subreddits, and whatever else is trying to teach you some aspect of Java. Enjoy what you're learning at your own pace. Talk to your co-workers about Java, have discussion groups, presentations, mini-conferences, and demos. All this and more will make you a better Java developer. When future job prospects come along, besides some testing (i.e. coding), a reflection of your interest and knowledge in Java will be easy to show. Any job worth your time will see this passion and know your desire to use and improve your Java skills will benefit them.
The article itself admits that you still need an application server, so no Docker isn't spelling doom for app servers. Docker is great if you want easy deployment and makes a lot of sense when you have microservice deployments but it doesn't make the app server irrelevant - startup time, memory footprint and performance are all important areas the application server is responsible for (in addition to the technologies supported, ease of configuration, ease in development etc). 
The main gist is that you won't have to deploy (a new verson of) an application to a live application server, but rather just bring up a Docker image with the application server and application installed and running.
Why does this JEP make dynamic languages faster on the JVM? 
Does anybody have an example of how jigsaw will actually change things? I don't understand how things will change from a building and deployment perspective. It's always the same generic bla bla.
The fact that googling "Java IKM certification" hardly brings up anything useful indicates to me that this cert is probably a useless piece of paper. Pretty sure at competitive tech companies no one gives a shit about what certifications you have anyways. 
Startup time? I may be misunderstanding. Weblogic takes a dogs age.
I'm joking... kind of. We've payed a certain contracting company with a big D in it's name and now are bringing this to their attention. The rep is saying this prompt wasn't occurring in the dev environment (it most certainly was) and now they are trying to wash their hands of it. I'm thinking they will try to pass this off as out of scope and it will need to be additional non-contract hours to resolve.
I think you might be able get away with dynamic duck typing in a functional language at scale. Function doesn't care if it's a duck, function cares if you got it's args and are looking for what it returns, function don't give a fuck. 
All good info, thanks. Taking some time to do some training on my own is an interesting idea. I'll have to give that some thought. I do go to my local JUG, but it is not very active and the topics can be very hit and miss. I know there is some great JUGs out there. 
The [b:table](http://www.butterfaces.org/butterfaces-showcase/table.jsf) component demo gives an "Internal Server Error". 
i wish there were a benchmark showing developer adoption, ease of implementation and projected cost of code maintenance.
For what it's worth, it's not a good post. For starters, it is on the Takipi blog, which should be an immediate warning sign since most of their posts are notoriously bad, especially those involving any kind of benchmarking. Continuing, it tests only four libraries, leaves out much faster ones, doesn't include enough file sizes, includes file I/O in the benchmarks, doesn't account for proper warm-up to ensure that HotSpot kicks in and does anything interesting _before_ the timing starts, etc. There are other much better benchmark collections out there for the googling. I'm on mobile now so no link handy, but the Boon project benchmarks make for a better example, and as I recall the fastjson folks might have some good ones too.
Like many large conferences there's a lot of talks and sessions that you can attend to get a great introduction to new ideas and technologies, and if you attend a session on a specific spec or JSR that you find interesting it can be very good to talk with the speaker afterwards (or during a Q&amp;A). Saying that like everyone else is suggesting a lot of the content is available online, so the real value is speaking to people 1:1 or in smaller groups. I go to a lot of conferences from a presenting/stand manning point of view and much prefer to be talking to people in corridors or at a product stand than talking at people in a session (which is why that's the majority of work I do these days). I also prefer the smaller, third party organised events as you get a broader range of ideas and discussions (something like a QCon or Devoxx conference).
Especially after you layer on Oracle Fusion Middleware
Well, I only care about JSON libraries that handle POJO serialization well and I found only GSON to be able to do that the way I like it. So even if it takes longer, I'm still going to use it. My point being: A feature comparison is more useful than a lame benchmark.
Ever try MOXy? I'd suggest that you give it a try if you haven't.
I think that issue is pretty over stated. Consider this icon pack: http://www.iconarchive.com/show/farm-fresh-icons-by-fatcow.html Should I be worried if I create an application that has a thumbs up icon in it that this person may sue me because he also has a thumbs up icon in his licensed icon pack? Most applications have a new file icon or a folder icon or a save file icon that looks like every other icon out there that does the same thing, yet we're not seeing lawsuits stifling app development even though icons are covered under copyright law. 
You can write messy code in any language, or you can write beautiful code in any language. It's all in the culture of your development team.
We had to take a hard look at where our transactional boundaries were, and where we were inadvertently relying OpenSessionInView. For example, we were iterating over a lazy-loaded collection in our article category list in JSF. That is obviously a problem. To combat that, we changed our query to do a JOIN FETCH when necessary. At other points, we made use of the @Transactional annotation to ensure the code executed within a transaction. In a few rare instances we need to have stricter control over our transactions, so we injected the UserTransaction as a @Resource and did our begin/commit/rollback calls manually. 
&gt; It's all in the culture of your development team. No, the tools you give your team matters just as much. I'm sure many amazing programmers can write really nice 500k line Perl applications without it becoming a mess. But Java was written the way it was precisely because average programmers can't. 
i can recommend this tutorial. its quite detailed: http://www.vogella.com/tutorials/JUnit/article.html 
The tools your team uses are determined by the culture of the team.
Sorry to tell you that this post does absolutely not belong here as it has nothing to do with: &gt; **News, Technical discussions, research papers and assorted things of interest related to the Java programming language** **Post removed:** Completely off topic.
I agree, picking a somewhat newer framework over a more mature one definitely has its drawbacks and is much more riskier. But at least in my case, since it's for an after-work sideproject, I was really just looking for something that had the lowest learning curve possible. 
Umm, no, I have to totally disagree with that. Microservices connected by a light weight message bus architecture is a very typical pattern.
&gt;Your popularity link is from 4 years ago, and I think a lot has changed since then. Did you actually read it? It has updates going into 2014. All the stories of startups using JSF are very recent. &gt;JSF near the back of the pack Of course, because it's by Matt Raible, a well known JSF basher, who always puts JSF at bottom. You could as well ask Rod Johnson to rank Spring, Guice, EJB, and HK. Guess one will be at 1 and which will be a the bottom.
I loved .NET the couple of years I programmed with it, but its Windows-only compatibility was a huge drawback. Personally, I'd rather use .NET with C# if I were to start fresh (maybe Visual Studio is a big factor), but everything we do at our current company is based on Java and I'm okay with Java, just not over the moon. But then again we do mostly backends with SOAP/REST interfaces and with Java EE that's a breeze, with .NET WCF it's blegh. I don't think .NET will have a big impact as long as its maturity in areas like SOAP/REST backends is abysmal.
https://www.mongodb.com/mongodb-scale Have a read. As with everything that scales you have eventual consistency, in that you may write to an instance and that data will eventually be copied to all other nodes. Generally if I'm just going with a 3 node cluster then I'll have one node for writes and 2 nodes for reads.
This tutorial (also available as PDF) is also pretty good: http://www.javacodegeeks.com/2014/11/junit-tutorial-unit-testing.html
Had MS embraced cross platform from the start they may have had some traction. It's arguably been the more progressive language to work with, but there's no way I'll trust Windows to run my production processes. 
Could you elaborate more? I am a bit confused, since last time I checked Resharper had basically everything Intellij had in terms of functionality + few extras (at least two years ago). VS, apart from functionality aspect when coding, I believe is much more intuitive IDE in the sense, that you don't have to remember a lot of stuff (settings for project, adding something to the project...). For Intellij, I have my notes with many things I need to set, how to fix common problems and so on, because I never remember that and always need to check my notes. 
And in 2 - 4 years java will surely growth into better language. Competition is good.
It's actually better at code analysis than IntelliJ, unfortunately.
not saying it won't, but even if java stagnated, it'll be a while before any .net impact is felt in formerly java-based strongholds. Most java-orgs don't move terribly quickly. Even someone who wanted to push .net adoption right now in a large org would likely face months before any significant changes were implemented (largely anecdotal experience - my own and that of some colleagues). 
The automatic solution-wide analysis is lacking in IntelliJ
I whole heartily agree this as someone who forced to work on C# interim. As a long term Java user, this is what I'm feeling after working with C#/VS 2k12 for the last 7 months. C# is better than Java as a language. But in terms of IDE and ecosystem, Java is miles ahead. I truly hate working with VS 2012. Its just suck. 
Wat ? This is the only thing your server CPU acutally does besides shuffling blocked (waiting for io) threads. In data streaming apps, encoding is the major bottleneck and can make the difference between poor 20k msg per second and some million msg/second.
&gt; the only thing your server CPU acutally does besides shuffling blocked (waiting for io) threads. Not for me, everything I've worked on the bottleneck was the business logic, then data access. XML/JSON converters/serializers never been anywhere near the bottleneck
IN the realtime area its almost always decoding. I don't know your applications, however frequently cost of "business logic" in reality means waiting for data from a cache/database/file system. Unless you are doing computation heavy stuff 99% of business logic is waiting for the data.
OK, Google. Now is the time. Drop the mandatory Java. Expose a native C/C++ SDK and an optional C# layer. Maintain a compatibility layer for Java for a transition period. Show Oracle what happens when it behaves like this and asserts ownership over interop.
They made the problem in the first place by not wanting to pay Sun. And they continue to stress the problem by focusing on Java 6 ( with a bit of 7) without alternatives. Instead at each Google IO, change of IDE, build tools, API only available in new devices keep getting shown.
Yeah, as if Java UI is so nice and pleasant :)
In an interview with Charles Nutter (Co-lead JRuby project) after his talk on the future of the JVM at GOTO Chicago 2015 we briefly touched on the impact that recent strategic changes towards making .NET cross-platform will have on JRuby and the essentially abandoned IronRuby project. https://www.youtube.com/watch?v=Ooj-TlZ622w Another interview to be published with Mads Torgensen of the C# project will also touch on this topic. :)
Oracle does have a certain track record but in this specific case, Google simply valued time-to-market (competing with Apple) over compliance. I think Google made a good deal, and so did Oracle. Everyone won, in the end, even consumers...
C# and .Net is lying MIT licenced, open source on github, not to mention registered as an ecma standard. I think it's pretty safe to touch at this point.
I had a similar set of notes for Visual Studio 2012 until I memorised the various key commands. There are a bunch of quick fixes, intellisense, code completion, and minor things that make Resharper not as complete, or as smooth to use, as IntelliJ. It's close, though. 
If you're European, it's totally not worth the money and effort, travelling a long way with 9h jet-lag to hear the same talks you can hear at any other conference but for perhaps 3-4x the price. Yes, it is a great conference, tons of great speakers, possibility to go also to OOW, hear Aerosmith and Larry. But frankly, if you don't have a more compelling stake there (meet customers, do sales, go on vacation anyway), stay in Europe and save time and money. Oh, I don't even think it's a good place for networking. With so many people, I've found people extremely stressed out, always looking for opportunities to talk to someone else (and I don't mean that as a reproach. It's just too big to take it easy, I guess) YMMV of course
Google used Apache Harmony as it's Java. Harmony is an open source project developed independently of Oracle / Sun's Java. (Developed largely by IBM contributions.) No Oracle code was used in Android. Oracle's Java is open source. So how can they want to be restricting its API? (Other than the fact that Google is making money and Oracle wants it.) Why isn't Oracle suing the Apache Foundation? IBM? 
Probably this would fit better in /r/learnjava than here. /r/Java is for: **News, Technical discussions, research papers and assorted things of interest related to the Java programming language** As is stated in the sidebar.
&gt; Yeah, as if Java UI is so nice and pleasant :) As opposed to? wxWidgets? There are so many things you lose going to C++.
Honestly I feel Oracle has been a much better steward than Sun was for probably the last 5-10 years they were running the show. 
The Java APIs are GPL licensed. Oracle is going after them on copyright grounds for using the api with a different implementation. Google would have to do that with the dot net api as well. 
Strings are for human debugging only, machines prefer bytes :). The byte array is utf 8 encoded internally. This is more efficient as one can directly sent/copy the byte[] e.g. to a network or file buffer (char[] will need additional converting). In addition, application code for serialization is completely identical regardless of wire encoding (Json, native serialization, ..), so the interface naturally is byte[]. BTW you can safely assume the author of an up to 10 times faster fully JDK-compliant serialization is aware of the 8 bit limit ;P
I don't see .NET spreading out all that much until major changes happen to it. I mean, where's the new use case for it? Web apps on Linux servers? Rails, PHP, Python and Java has this locked up and NET doesn't offer anything new here. If I want power/corporate I can go with Java(or Go, or Rust, or Nim, or any other 20 languages). If I want ease of use I have PHP, Rails, Node, Dart, Python, etc etc. Mobile development? NET doesn't exist there. Cross platform desktop development? There's no good cross platform GUI here for this. C++/Python can target Qt for this or with Java I can write FX/Swing once and have it run on Windows, Mac or Linux with nothing needed on their end. Game devs are using engines like Unity and unreal to target back end platforms. NET dominates the Windows desktop because it's so damn good for GUI work there. If we saw an awesome UI lib that was cross platform come out for NET(and no, GTK doesn't cut it) or MS went nuts and released cross platform 3d game dev libs for it. Then I'd say the language would take off like a rocket. But it looks like MS just wants NET on the server market and Linux already has more languages for that then it knows what to do with. So small shops are probably not going to move off Rails/Python/PHP to it and big corporations have so much tooling and legacy code on Java it'd make zero sense to switch out.
&gt; Why isn't Oracle suing the Apache Foundation? What can you possibly win from such a lawsuit?
 /r/Java is not for requesting help with Java programming, it is about **News, Technical discussions, research papers and assorted things of interest related to the Java programming language.** Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints.)
As I said, the only reason Oracle is suing Google is for money. Not because Google actually did anything wrong.
["wrong"](http://www.droid-life.com/wp-content/uploads/2012/01/Web-of-Lawsuits-2-650x492.jpg). Interesting point of view :) (why would you take sides anyway...)
I think we got a code signing certificate for about $130 a few years ago. I have it on my calender for sometime next year when we need to buy another one good for several more years.
First: fast serialization is fully JDK-Serialization compliant (support readObject/writeObject/readResolve etc.)). It uses a binary protocol internally and is very fast. It currently powers the middleware of a large stock exchange. Second: The JSON codec is an addition as the wire encoding is pluggable. So you can serve highly efficient to java clients (~2 million async remote calls per second) and serve jsonized objects to clients/backoffice systems written in other languages or without knowledge of serialized classes. All this can be achieved without any change of application code. FSTConfiguration conf = FSTConfiguration.createJsonConfiguration(); System.out.println(conf.asObject(conf.asByteArray("∂ √ ∞ ∑ ≈ ≠ ≡ ≤ ≥ ∆ ∏ ∩ ⌠ ⌡ │ ∫ Ω ⅓ ⅔ ⅛ ⅜ ⅝ ⅞ ♭ ♮ ♯ ♩ ♪ © ® ™"))); delivers: "∂ √ ∞ ∑ ≈ ≠ ≡ ≤ ≥ ∆ ∏ ∩ ⌠ ⌡ │ ∫ Ω ⅓ ⅔ ⅛ ⅜ ⅝ ⅞ ♭ ♮ ♯ ♩ ♪ © ® ™" Being from europe I have testcases involving german+french special chars as well as kyrillic (russia) strings. Edit: I added a section to the documentation clarifying encoding. So in the end your complaint was helpful as this was not mentioned.
JavaFX8 is really nice.
&gt; Great methodology there Tiobe. The best I'd say, but because your favorite languages are not on top it's maybe not the best for you. But even if your language is not ranked favorably by Tiobe, you can use it as just a data point. Cross check it with other sources. As it appears, it's not THAT different. If you take clusters, say groups of 3 languages in ranking order, you'll find they strongly resemble other sources. No matter source you use (langpop, redmonk, SO, GitHub, jobs), Java and C are pretty much always in the first cluster. C++/Python/C#/Objective C are in the second cluster, etc. In some sources Java is the second cluster, some have Python in the first, but in general it matches quite well. 
&gt; Android can't support 100% of the standard libraries and still be as fast and small as it is. Oh so that is why Dalvik and ART are so much faster than any JVM JIT/AOT out there....
JavaFX is actually quite nice and since Java 8 it's definitely ready for production use. It's been long overdue because swing really sucks.
Did they ask? And if where's the reference? I'm pretty sure a deal could have been worked out, with the only restriction that they would not be able to call it "Java".
&gt; Mobile development? NET doesn't exist there. Xamarin Studio allows cross-platform building of Windows Mobile, Desktop, iOS, and Android applications.
So, something like Go? Honestly, though, Go has a long way to go before it becomes a good choice for a framework language. It's a little spartan at the moment. Threading is basically the only thing it excels at. EDIT: Also... I can't help it. I tried... Also... &gt; No idea why this is getting downvoted, other than perhaps some sort of Java fanboy-ness. C# is superior[1] , from a language standpoint, to Java Accusing people of fanboyism, then immediately engaging in it yourself? That's a paddlin'. &gt; and unlike Java, C# is open-source Java is open-source, too. This is a copyright issue, not a software license issue. Two different kinds of animal. &gt; Plus, C# enums are VASTLY better than Java's implementation, especially in regard to C/C++ interop. [Oh yeah?](https://imgur.com/ivzkevK). I've implemented entire state machines (complete with transition logic) using Java enums alone. Do that with your integral constant enums in C# :-P I'll give you the improved C++ interoperability. I don't consider that all that important, though. If you are using something like C# or Java, and you find yourself reaching for C++ interoperability, you may have wandered into interesting and dangerous places, indeed. Or you're wasting too much time on optimization. Either or.
Over the last five years, I haven't seen any new public sector (that's where my current clients are) development projects use application servers heavier than Jetty / Tomcat. Docker is the new hotness, and various projects have Dockerfiles for setting up their development environments, complete with development databases and AMQP messaging servers.
AFAIK the UK is the only place this applies.
Is this because nobody would know what the google version does, compared to the official version? Is the thing that google is doing also open?
I can see the appeal of this project for specialized purposes, like dumping internal structures to file for persistence, but I feel like vanilla Jackson (with JaxB for xml-y stuff) covers 95% of use cases :( 
As the other people have said, JavaFX 8 is astoundingly good; it is however of course a bit too late to the game to make much of a difference (As most stuff is web-centric these days; although FX does have embeddable web stuff as well) but it still is useful if you have to have crossplatform UI.
Well, they are already taking some money from phone manufacturers due to some patentes, so it's not crazy to think they may go to the same direction as Oracle giving the chance.
Well AFAIK there is a little bit of the Sun JVM code inside Dalvik, but that's not the point of the lawsuit.
I just started a job at an e-commerce company and all of the webstores they build and maintain are JSF+Seam based. It's a fun framework to work with.
Have you looked at JavaFX?
You're not the only one who thinks so it seems.. Got at least 3 down votes.. Interesting. Technology use is VERY different throughout the WORLD, so I find your stance a bit off.. E.g. in China they have many operating systems that almost no one even has heard of for instance.. In Russia VK is more used than Facebook.. You would be ridiculed and wrong to claim that Java is king in SOME places, including my own country (as mostly a Java developer, I do know this pretty well, given that it's a very small European country without too many development/consultancy shops).. It's a dangerous and naive attitude to assume that your opinion is shared throughout the world, so I was just trying to give a small fun fact.. Anyways, seems like I'm speaking to a "cool story bro" kind of guy, so fun fact time is over :) 
&gt; You're not the only one who thinks so it seems.. Got at least 3 down votes.. Interesting. FYI: I downvoted your comment because you're contradicting yourself. Yes I aggree it's country-specific, but how can you jump from there to "everywhere else .net is king"? That's the very same fallacy that you point out in the first sentence. &gt; It's a dangerous and naive attitude to assume that your opinion is shared throughout the world Again: agreed. But on what basis did you point out "in other countries, .NET is king by far"?
JavaFX8 includes full featured 2d and 3d rendering classes.
The main challenge would be implementing this using only the constructs available on the JVM, because changing the bytecode is super hard. I would also add the requirement that adding an extension method to a class should not require a recompilation of that class. How would you encode the extension method with bytecode? One way to do this is used in Scala, with the `implicit` keyword. Here is how it is used (for the above use case only): implicit class SomeStringExtension(str: String) { def myExtension() = { ... } } This is the way to add a method to the String class (which is `final`) and it is used extensively in the standard library to make the String class behave more like other Scala collections, specifically Array[Character]. The class declaration above is still an ordinary class declaration, subject to all the normal rules regarding namespacing, type hierarchy and semantics. You can also use it normally, like so: val normalString = "Hello" val extendedString = new SomeStringExtension(normalString) extendedString.myExtension() In this regard, it is no different than a wrapper class often used in Java. In fact, it compiles into an ordinary JVM class, with its own classfile. It can even be used from Java, like any ordinary Java class. What makes it work as a class extension mechanism is the `implicit` keyword, which allows the compiler to do a number of thing. The `implicit` mechanism works like this. Suppose that the compiler encounters an expression like so: `someA.methodF()` where `methodF` is not a member of class A, but is instead a member method of class B. Before the compilers stops and throws a type error, it will first search the current scope for any function marked with `implicit` which convert A to B: `implicit def implicitAtoB(a: A): B`. If such a function is found, a wrapping is inserted like so: `(new B(someA)).methodF()`. In the original example, assuming the extension class definition is in scope, this method call: "An ordinary Java String".myExtension() is converted to: new SomeStringExtension("An ordinary Java String").myExtension() This is the way to do extension method purely in the compiler, without changing anything in the bytecode format or the JVM. I believe that it is possible to do in Java as well. P.S: A constructor for a class Monkey which takes one argument of type Leaf (`class Monkey(l: Leaf)`) is a function from type Leaf to type Monkey (`Leaf =&gt; Monkey`).
Just experimenting with java8 and nashorn, running a unchanged javascript file and rendering to graphics2d.
I'm also curious as to why. Visual Studio Code is closer to sublime/atom/notepad ++ than eclipse or even visual studio itself. It's written in JavaScript so I'm sure you could find a way to add in all the things you want but you'll spend months (years?) doing so. If you want to do this as a learning opportunity then more power to you but I just want to see if you understand the challenges
VSC is not an IDE like VS or say Eclipse so it would take lots of custom plugins (not yet written) to get something that would be hardly comparable to tested alternatives.
Last I read, I think Linq was not implemented in mono, and I think MFC was also only partially implemented.
Having both should have no way of causing slow downs. The game is only going to run with one or the other. It might just be Java 7 that is slower. There were some low level changes in the way thing work that can make some specific workloads slower. For example, the substring method in 7 has to copy part of the original string, while in java 6 it just used an index into the original string's data.
With a bit of customization you can get the feel of IntelliJ pretty close to Visual Studio 
&gt; But even if your language is not ranked favorably by Tiobe I don't care what the language is ranked. I want to know what the fuck the ranking MEANS.
&gt; No. Google needs to fight this if you plan on maintaining your career as a programmer. It always entertains me to see the idiots pointing a finger at Java and not realizing the implications this has. Fucking Verizon could come after people for JavaScript, Microsoft could come after everybody leveraging any of their APIs outside of uses they like. 
awt is heavyweight. javafx should have its own canvas. 
Careful, that's likely to undo the fabric of the universe.
Totally agree, although I can see their reason for parameters. A lot of people use parameters as pages.
So, obviously, new and cool features are getting added in Java 9. My question is, what's getting deprecated in Java 9 that wasn't in Java 8, and is there anything getting fully removed in Java 9 that was in a deprecated state in Java 8?
Why would you want to substitute GWT? If you are looking for more flexibility with GWT, check out SmartGWT, Vaadin and GWT-Ext?
I dont want to use it OVER the tried and true alternatives. I want to use it along with the alternatives. VSC is light-weight and I enjoy using it. If possible, I would like to get it working with java.
you're not coding simultaneously in two editors, and you didn't really answer my question besides "because I like it". are there any real reasons?
Author of the post is a former Google engineer who is fairly well known in the open source community so I'm not sure you can say he "doesn't know what he's doing" although your criticisms are mostly valid and you're free to disagree with him
Groovy has this via its various meta-programming methods. In this particular case you could use an extension module: &gt;An extension module allows you to add new methods to existing classes, including classes which are precompiled, like classes from the JDK. [http://groovy-lang.org/metaprogramming.html](http://groovy-lang.org/metaprogramming.html)
I'm pretty sure "don't reinvent the wheel" applies here, especially if your wheel is square instead of round.
javascript :) teavm might be interesting for you
There's that. I wasn't fully aware 5 minutes ago that VSC was technically more close to sublime than a IDE.
There is no such thing as an “HTTP URL”. [HTTP](https://tools.ietf.org/html/rfc7230) deals in standard URIs (except in the [request-target](https://tools.ietf.org/html/rfc7230#section-5.3), which can accept URIs with certain parts stripped off). The empty string is not accepted by HTTP because it is not a URI. Instead, it is a [relative URI-reference](https://tools.ietf.org/html/rfc3986#section-4.2). Each instance of `java.net.URI` represents a URI-reference. Its `isAbsolute` method can be used to verify that a parsed URI-reference is a valid URI by itself, and its `resolve` method can be used to construct a valid URI from the URI-reference. (There is unfortunately no subclass representing a complete, absolute URI.) As for parsing URIs like browsers do, constructing them using the builder pattern, and canonicalizing them, that should probably be done by some other routine that returns a `java.net.URI`. There's no need to throw the baby out with the bathwater.
I would really hate this in java - it would make reading code (and reasoning about it) much harder: 1. String.print() - wtf it does? it could vary from project to project how such method is defined and you'd always need to check 2. behavior of a method using such extension would depend on stuff on the classpath 3. whole concept of encapsulation goes to shit For fun - sure. But keep this away from production code.
1. IDEs can show you where a method is defined. And you just have to be responsible, as with all things programming. If you go around using inheritance poorly, you end up with code that's ridiculously hard to understand. Same thing here. Use it poorly, get poor results. Use it well, and you're not going to have such problems. 2. As with everything Java? Using anything requires it to be on the classpath. 3. How does it ruin encapsulation? You can't add fields, and you can't access private fields. The extension methods have essentially the same access as a subclass, except it's not a subclass. Objective C and Swift have made extensive use of extensions, and they have only been a good thing for those languages. I don't think it's bad for production code.
Looks like [this guy's company has an exciting new toolkit](http://www.reddit.com/r/badcode/comments/37mc1c/this_is_how_my_company_writes_frontend_code/). Maybe send a PM?
Nice work! 
Seems kind of wasteful to give examples of how to use the version of Jersey that isn't the primary stream of code.
Hey, if you want extension functions in Java you should check out [Kotlin](http://kotlinlang.org/docs/reference/extensions.html)!
Thanks! Would appreciate any help you can provide, there are many ways it can be improved.
Isn't this the same concept as Java Apects (from 2007ish) or Traits in PHP and Scala and whatever else they are called in other dynamic languages?
I've read about it, but currently I'm restricted to java7 and it appears support for 3D graphics was added to JavaFX in JavaFX 8.
In my opinion, extension are kinda like macros: Awesome when I write them. Absolutely awful when I have to read them. So would Java benefit from it? I don't think so. The are are enough option for the JVM, e.g., Scala, Kotlin, that allow you to indulge in these kinds of DSL shenanigans. Java is extremely verbose, that's true, but that's also part of its value: When you see a method, you know it's a goddamn method.
LWJGL uses one of the best licensing: BSD http://wiki.lwjgl.org/index.php?title=General_FAQ#Can_I_use_LWJGL_in_commercial_projects.3F Using lwjgl is something you have to get used to though. so do the tutorials and read up on some math stuff: http://www.math.utah.edu/~treiberg/Perspect/Perspect.htm you will need all this to get a simple shader going to render your objects to the screen, so this really will take a lot of time to understand
Thanks! We need 8 projects though (one without any template engine, and one for each template engine), and they should have some helpful comments in them. It shouldn't take very long, but we have our hands full with tasks that are not as easily handed off, so we wanted to see if the community could chip in :)
I’m the author of the post and the code. We used [WHATWG’s URL spec](https://url.spec.whatwg.org), which says this: &gt; Standardize on the term URL. URI and IRI are just confusing. In practice a single algorithm is used for both so keeping them distinct is not helping anyone. URL also easily wins the search result popularity contest. I didn't set out to implement the obsolete URI spec you prefer. It's too strict, and fails to cover real-world inputs like the Google Maps URL referenced in the post. That spec also gets weighed down in generality necessary for opaque URLs like `mailto:`. I hadn’t anticipated the outcry that would be caused by returning null for invalid inputs, but the API was very carefully considered. Throwing exceptions is computationally expensive, and this code is intended to be efficient. In particular, it should be efficient to write tools like feed parsers and web crawlers with this class; in such applications many invalid URLs are expected. You might even use this class to detect and linkify URLs in plain text.
You assume the goal of the design is to pedantically match a RFC of your choice. But the goal is to provide a practical implementation that matches a real-world domain based on common use cases. Different goals, different results. Specs aren't perfect, BTW. Don't put them on a pedestal.
There is definitely something wrong here... http://i.gyazo.com/2f2112ea991ce5cad025e393035e46d3.png
One thing - the fact "Z" is capitalized is probably what's confusing it. Capitalization should only be used for a "placeholder" parameter when defining a new function, eg. &gt; double X = X*2
what about the third line though? y should equal 5, not 20
A big use case for this would be `Stream&lt;T&gt;`. Right now there's no way to write a custom pipeline that looks nice, you have to do custom(list.stream() .filter(item::isCool)) .collect(Collectors.toList()) instead of list.stream() .filter(item::isCool) .custom() .collect(Collectors.toList()) Actually, you could even add list.stream() .filter(item::isCool) .custom() .toList() as sugar for `...collect(Collectors.toList())`.
I'm not an expert in mobile development although I did some Android apps in the past. I think at the moment [RoboVM](http://robovm.com/) is the way to go for java iOS development, it also seems to be free for open source development. Check out their tutorials to see how to set up a cross-platform project. This does require you to know java and related tools like gradle/maven a bit, so you might want to start with some simple tinkering in (desktop) java first before diving into RoboVM. It might just be a bit overwhelming.
You should probably add that for parenthesis too http://gyazo.com/2bfb3975c5dbf64ab7a8e2861e0107cf
I've generalized it so it should also handle this and other cases.
If you want to learn Java, I personally wouldn't recommend starting with Android. I would start by learning learning regular plain Java, and then moving over to android if you feel like it. If you have decided you want to learn android anyways you should start by writing regular android apps and not use the hacky tools that allows cross platform mobile development. Lastly if you want help with mobile development I think you'll have better luck over at /r/androiddev ... Good luck :) 
You can use the free, open-source version of RoboVM for unlimited commercial apps as well.
If you want to go with just Java, I'd recommend ignoring iOS and just sticking with Android. You're just not going to get the same experience without using the main languages for the mobile platform you're developing for. Basically, without using Swift or Obj-C you're not going to get direct access to the constantly updating APIs on iOS, and it will probably end up taking more time to make a less functional app. Even if you just learn Java and Android, you'll still be very set in the current job market, and it's not *that* difficult to jump over and pick up iOS afterward (just don't expect a real parallel experience). Edit to give context: I've been leading Android teams for 4 years and have always worked very closely with our iOS teams. Almost anybody with a decent amount of experience on mobile is going to tell you the same thing I just did, but if you want to be sure you can ask on /r/androiddev or /r/iosdev. It's fairly common for people to try out unified languages when they're starting out with mobile development, but it's just not comparable yet so people generally don't stick with it.
You should do something that requires no skill, so that my game looks wayyyy better than yours when we hand it in. &gt;:D
I made my final in [env3d](http://env3d.org/beta/), it turned out pretty sweet, I'm present tommorow. I made a FPS, everyone else in my class made basic 2d games.
Yeah I wanted to try minesweeper but I got overwhelmed haha. I'm still a beginner
Thanks for the advice, I will do just that 
http://pastebin.com/Jh77Z7ZE
That is the Source Code 
Maybe an easy text adventure or better: A text adventure engine. Think of a short story, create a xml-file (or whatever you think works) for the text and possible decisions and write an interpreter for that.
And what's the question?
Not really seeing the point of a tutorial for this particular framework. I think you're better off just reading the [Spring Data JPA documentation](http://docs.spring.io/spring-data/jpa/docs/1.8.0.RELEASE/reference/html/). It covers the same content but in a single document and not spread around multiple tutorials. It's well structured and easy to read.
The same Google produces Guava. In Guava docs they give some tips about avoiding using null https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained . I'm just saying…
If you are looking for an example game in Java, checkout Notch's submission to Lumum Dare 18. There is an awesome timelapse video along with the final Java source here: http://ludumdare.com/compo/ludum-dare-18/?action=preview&amp;uid=398
We don't know what your updates are and we still can't see the source of your humanoid class. But in general: All you have right now is one loop that counts to your deathage, so actually everything you could do would make the simulation better. Examples: * Count days, not years * Have more status variables (health, dexterity, strength, intelligence, etc.) * Don't set a fixed death age, but let it calculate by the variables * Have things that influence the variables (work, love, sickness, etc.)
Minesweeper, Tic Tac Toe or Tetris. I personly coded a simple Pacman-clone in 12^th grade. Do you know the game "Deus Ex: Human Revolution"? In this game there is an Hacking Minigame; maybee try that (http://deusex.wikia.com/wiki/Hacking_%28DX3%29)
Good luck!
Tic tac toe is a good choice because the graphics are no problem and the AI portion of the program can be as simple or complicated as you want it to be. You can get something "done" in a short time and then extend as you have time, so it's an easy program to beat a deadline with. 
vsc is just an editor ... works fine only for hello world ... u need a proper ide netbeans/eclipse/intellij to be productive 
Sorry to tell you, but you are in the wrong subreddit. /r/Java is not for requesting help with Java programming, it is about **News, Technical discussions, research papers and assorted things of interest related to the Java programming language.** Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints.) Since you already have multiple replies, the post will be kept, but for future, please post code help questions in /r/Javahelp. Please, when posting next time, also obey the [Code Posting Guidelines](http://www.reddit.com/r/javahelp/wiki/code_guides) as are outlined in /r/Javahelp, as well as the [General Posting Guidelines there](http://www.reddit.com/r/javahelp/wiki/posting_guides).
Connect four is very simple too. 
I have never used the Spark framework but if you have some example projects that you would like to be converted into archetypes, then I would be more than happy to do that for you. However, I would advise against attempting to provide any useful customisations of those archetypes due to the following limitations: * You can't validate user input so it is almost impossible to provide much customisation, without resulting in a broken prototype * You can't mutate user input so you must ask for lots of repeated information (for example, you can't take a string and turn it into a class name, then turn it into a method name). * You can't provide guidance notes for user input so you must put this on a separate web page and hope that your users refer to these notes when they are entering input. * You must know the group ID, artifact ID and version of an archetype in order to run it (presuming your archetype is on maven central) which makes archetypes quite verbose and unfriendly to run. Yo is a much better choice for generators but suffers, in my opinion, from the need to install additional dependencies i.e. node.js. Given that I don't believe that Maven archetypes can be usefully customised and given that you will likely want to offer a very low barrier to entry (i.e. no extra dependencies to install) then I would recommend that you just provide example projects and encourage your users to clone those repos and customise as needed.
Not sure why you are getting downvoted so much. Yo is a much better experience as a code generator and is used at least a little bit by the .net community (as far as I can see, as an outsider) so it is not exclusively for generating JS projects. I think you have the right idea that Maven archetypes are dead (or at least need a major overhaul to become relevant) and there is no good Java based alternative. Given that Yo is beginning to be used for non-JS projects, it could become quite a widespread code generator tool.
You are a misunderstood genious.
A game that's fairly simple but challenging as well is Connect 4.
Why would you use hibernate in the first place?
It seems there are no precompiled JavaFX Scene Builder packages available? /edit solved it via googeling "javafx_scenebuilder-2_0-windows.msi", the Oracle site doesn't link to it when searching for JavaFX Scene Builder (http://www.oracle.com/technetwork/java/javafxscenebuilder-1x-archive-2199384.html#javafx-scenebuilder-2.0-oth-JPR).
Oh look, our resident troll is here, too. Still didn't learn how to discuss stuff without resorting to foul language?
Thank you very much for this answer, you make some excellent points. Maybe maven itself is actually too much of a barrier, and creating example repos is better. Would be a lot easier to maintain too. ... Maybe we could write a simple Java program to do the job? Not sure how people would feel about that though. 
Nah, my studies include GUI design and the app is for personal use.
Oh better. Have a great day :D 
This was discounted by the language maintainers. [Brian Goetz](http://stackoverflow.com/a/29494337)'s rationale: &gt;&gt; API designers should control their APIs. While externally injecting methods into APIs is surely convenient, it undermines an API designers control over their API.
There is an in-built GUI builder for eclipse that is pretty great. It uses swt and swing.
Gluon is building them for Oracle: [site](http://gluonhq.com/products/scene-builder/)
Java GUI has historically...sucked. JavaFX looks to be a little better, but compared to scripters like XML, it still really sucks. The good news is thar JavaFX is not that hard to learn.
https://www.youtube.com/watch?v=a5_Pc1ZK7aw
You are checking for what you expect to be wrong. Your exercises will be designed in a way to force these errors. Nothing to do with debugging in my opinion. I don't suppose anyone will submit a code that does not do its job or does not compile. You should check 4 pillars and SOLID principles, because that's what you will be teaching first. Hope that helps.
Fixed it, Eclipse made the .fxml one layer higher in the "src" package, not in the "application" package. src -&gt; application -&gt; Sample.fxml and IT WORKS. Now I need to make the functions but ... I feel so proud now to have my first GUI since I experimented with RubyFX 1.6 when I was ~12 around 15 years ago :&gt;.
Yeah... but "trivial" is something really hard to put inside some people's minds.
I like [windowbuilder](http://www.eclipse.org/windowbuilder/) It does the job pretty darn well. Way easier than doing it by hand.. And you can go back and forth between the GUI editor and the code smoothly. I think google wrote it
&gt; Swing is a perfectly good GUI toolkit, a little verbose but seriously powerful. Swing is obsolete, and in my opinion (and many other people's) it is very ugly compared to contemporary UIs. &gt; You only have to deal with XML if you want to use the SceneBuilder and even then SceneBuilder deals with the XML and you shouldn't have to touch it. If you hand code your GUI you don't have to mess with XML at all. That's good to know. I think the biggest issue is that Java is now perceived as a security threat on the desktop, which seriously hurts its viability for desktop apps.
Just read a dot file. What are you trying to pass in?
Sometimes we have to write apps for people well below our pay scale. I like to keep them off the keyboard as much as possible. It doesn't always have to be pretty.
Honestly, you're best bet for GUI development is to go with web development. And if you're looking for a Java-based technology for it, you can pretty much do the entire stack with Java (any DB + JPA + EJB/Web services + JSF).
In the Android world we use XML, for inside of the Android world Java GUI definitely still sucks. Lol
I played around with JavaFX, and it's got some neat improvements over swing and such. Lately though I've been building web interfaces with Spark.
I get downvoted every time I say this. But don't waste your time doing desktop Java GUI applications. The career prospects for doing Swing development nowadays are few and far between. Sure, there are Swing jobs out there, but they're all maintaining legacy systems. I say this as someone who was doing Swing development up until 2014, and I had a lot of catching up to do when I started looking for a new job. Downvote if you must.
&gt; JavaFX is the Oracle way to go , but it still raw in places. Still best out of 3 default ways. As for webpage way - wouldn't it limit you in the way of bindings, event listeners and operations you can perform on each element?
I'm not really a fan of spring boot. It's not clear progress like Java 8 is. It makes spring a more opinionated and automatic framework. That's a different direction from the manual less opinionated non boot spring. It's not progress it's just another choice. 
You're right, there are definitely transferable skills. I did Swing on and off for almost a decade. There are transferable skills for people who have done Swing development, but my point is that you shouldn't be bothering to learn it *now*. Its time has come and gone. 
upvote
If you want a really responsive frontend I would go with a JavaScript single page application backed by a spring boot rest based app. Spring boot comes with a embedded container (tomcat by default), really fast to get started and you can package the Javascript code into the app if you want to run as a desktop app. 
JavaFX and then Scene Builder :)
The answer you are looking for is JavaFX, but the answer to the question you should ask is HTML5 and JavaScript.
For common mistakes you can use static analysis. IIRC FindBugs was even started for that exact reason: Checking students' submissions.
As of JavaFX2.2 (8u40) JavaFX has a canvas component, exposing a graphics context. https://docs.oracle.com/javafx/2/api/javafx/scene/canvas/GraphicsContext.html I have been using it for a while now and I'm really liking it! 
I would also say JavaFX, but there's one more thing to consider. If you're building a large application that will have multiple windows/views, customization, possible plugins, navigation trees etc., I would strongly recommend you give the [NetBeans Platform](https://platform.netbeans.org/screenshots.html) a look, as it will save you *a lot* of work. It's mostly based on Swing, but I understand it is perfectly possible to use JavaFX widgets with it, too.
What's your stand on JavaFX?
Thanks for your answer, I upvoted you. But it has to be a Java desktop app with a GUI, a friend needs to finish a project for his schooling (there doesn't seem to be a proper word in english for the german word). And it has to be made till friday so I need a modern and easy to use solution to build a GUI because he can't program at all . so I save his ass No career paths are planned making Java GUIs or programming at all :).
Some aspects of Boot are indeed a bit more opinionated, but they do get out of the way when you need them to. And other aspects don't go in this "convention over configuration" direction at all. All in all, it's an interesting addition and definitely something fresh and fast moving in the Spring ecosystem. 
So that's Swing? 
Yes, It depends on what you want to do. (Assuming you cannot do "complex" stuff with the web)
Thank you, finally someone who gets it.
If you want to use JavaFX, I suggest fxexperience.com. I used JavaFX in a project once and this blog really helped me. There are lots of useful stuff about all sort of things related to JavaFX there.
I would never use Java for a desktop app. If I wanted platform-independent I would go with any other language. JavaScript is pretty nice with electron.
&gt; WindowBuilder is composed of SWT Designer and Swing Designer Seems so
I'd opt for the UI/daemon structure.. That way one can have a UI prototyped and implemented in any language (or framework). Java is not the UI language, it's the one for writing the daemon. One would save time by writing the UI in a scripting language, such as Python... NASA once made a talk about why they moved from c++ to tcl for UI and why would they want python for the new (java) backend... 
What aspects aren't convention over configuration? 
Can you give concrete examples of why Java GUI sucks?
Which part of building UIs in Java do you find "crappy"?
There are situations where it does nothing but add more work. The projects I've worked on force me to override everything that boot sets up automatically and I would have to do workarounds because I don't have an actual main method. It doesn't provide me with anything for these projects. That's why I said it's a different direction or choice. It's not clear progress. 
Standalone Java apps are not a security threat on the desktop. The security concerns come from the java browser plugin that lets you run applets (mostly obsolete except for special proprietary use cases in the corporate world) and launch applications deployed with Java Web Start. It is hard to call Swing ugly when you see apps like IntelliJ which look great.
Why are these two things mutually exclusive.
Depends on what you want to be making as a developer ..
I want to make Android apps, but I see like the triple amount of jobs for Java EE at least in my area. 
http://www.jessrules.com/ is another one. It is not actively developed anymore though. It is also not free (except for academic purpose).
I am big fan of drools. It has great eco system. Documentation is pretty good. There is even a GUI based rule designer which can be used to generate rules by non dev (business) folks. The only problem is that it doesn't scale out so you need oodles of memory. 
Our graph database, http://stardog.com/, is pure Java and contains a rules engine based on SWRL.
I know, and I love it. Still there was not propaganda.
Yes, of course. I know SmartGwt and Vaadin with Liferay ;) You prefer SmartGwt ? My new video with Haxe, if you want is very cool, i did a code benchmark: https://www.youtube.com/watch?v=6jitX6Bq21M 
Learn java fundamentals to get the job then focus on the specialization at the job. 
lol, the "native" desktop apps guys be hating. na for real though, I love javafx, it has the WebView class :p
Try developing something small in both platform and see what you like, the likeness of your doing is going to get you the answer that you are looking for.
Is not crap but most application written in it are.
You might want to consider whether you want forward-chaining or backward-chaining rules. Basically, with backward-chaining you ask whether some specific assertion is true, and the system tries to decide. Or you ask what values would fit the assertion to make it true. So you might ask employed-by(george, acmeinc) and the system would say whether or not george is employed there. Or you could say employed-by(george, EMPLOYER) and the system would return all of george's employers. With forward-chaining a new statement will arrive, and you add it to the system, getting back all the new statements implied by it. Some systems have both. Drools, for example, is both forward- and backward-chaining. As far as I can tell Ilog is forward-chaining only, but that could be wrong. Jess Rules is forward only.
Jamocha - http://sourceforge.net/projects/jamocha/ It's written by people who know a lot more about RETE rule engines than the Drools folks.
JavaFX for sure &gt; Swing &gt; &gt; &gt; &gt; AWT. I use ScalaFX, which is a light wrapper around JavaFX for doing GUIs in Scala.
Not that I don't like the idea, but how's that different from "sbt run"?
Well, I think it depends what you mean by "better". Having done HTML, Swing and JavaFX, I prefer JavaFX by a long way. The productivity difference is just huge. Basic things like layout management STILL don't work right in HTML/CSS for applications, even after decades. About six months ago I was chatting to a guy who works for a local financial institution. He told me that they had both web guys and JavaFX guys and the latter were dramatically more productive. What's more the traders preferred the desktop Java apps because they could do things like pop open lots of windows and easily arrange them, they had tons of hotkey support etc, whereas the web versions of things would inevitably not support this.
Hi Lars!
You submitted the exact same project just 11 days ago. Reddit is not a release blog. Its also not the place to publish every move &amp; project of your Github account. Please stop.
I suggest using oracle tutorials- that and look up some open source simple game projects to learn about collisions and game engines- Just try looking at others FX projects- you can start here http://docs.oracle.com/javafx/2/get_started/jfxpub-get_started.htm (Also I wouldnt waste time with swing unless you plan on fixing up old swing programs- its dead now)
You are right that there might be different versions of libc on the same machine, but if two apps use the same version, they refer to the same file (that was my point, sorry for not being clear). diet4j inherits the Maven dependency mechanisms, and in Maven you can be very specific (or less specific) which specific version you want, so it's the developer's choice.
Ok, so my original question then is how are you expected to get the right version onto the machine? Does diet4j do this for you? So, for example, let's say `App A` requires `guava-15.0.jar` and `App B` requires `guava-17.0.jar` Let's say the machine already has `App A` on it. What would the install process be for `App B`? Also, what do you mean by "you can be less specific with maven"? I thought you had to call out the exact version of a library you are using in maven for things to work (or some parent pom somewhere has to).
Interesting, didn't know you could do that sort of versioning with maven (did some more digging. Definitely not a feature we use at my company). The main issue I have with this is that it doesn't do any package management for you. That means that for every app deploy you do you also need to make sure that the dependencies are in sync. Once you get to that point, a fat jar/war starts to look much more appealing. Perhaps for mobile platforms where space is at a premium this might be be appealing. However, you would still need to figure out how to do package management there. For a server application I don't see the draw. Our somewhat large application clocks in at roughly 150mb. That is peanuts in the grand scheme of things.
If you want quick and easy start-up, download NetBeans 6.x and create a new Swing application. Super easy to get started. If you want to aim for future compatability, download NetBeans 8.x and create a new JavaFX application. Swing has more features (for now), but JavaFX is more portable (including mobile devices). 
I wholeheartedly agree with you here. It took some cajoling getting Drools running with a Spring Boot app but once it was setup, writing rules and managing a relatively complex knowledge base was pretty easy and exceeded my expectations on performance and debugging difficulties. I found that with Drools, unit testing made everything 100x easier after the initial learning curve was overcome. 
Nice Job seems like you are on track. Just a few points : 1) Spring Boot is built to be an ultra productive framework. So while things like DAOS and having impls of interfaces are can be beneficial. I find most Spring Boot projects tend to go for simplicity and having independent small services work together (i.e microservice architecture). Doesn't really mean what you did is wrong though, just an opinion. 2) You might want to not put usernames/passwords of your databases in public github repos. Just better to be safe. 3) I am not sure you need the two Album/Photo factories, they just delegate to the Album constructor. Again, this is more of an opinion as it comes back to the idea of keeping things simple with these "productive" frameworks like Spring Boot.
I like my fat jar or war because I can easily look inside and see what's really packaged. Especially with Maven and it's transitive dependencies it's really needed. As for downoading libraries at runtime I say: hell no! Being dependant on network during build is acceptable, during runtime it's nightmare. Also it would be problem with version range as somebody else already mentioned.
Do you like flamewars? Because this is how you get flamewars. Honestly, the best one, for you, is the one you use to finish your project. Just pick one. Preferrably a popular one so you have a reasonable shot of finding documentation and getting questions answered. They're all pretty good. Really.
[DropWizard](http://www.dropwizard.io/) is pretty great, the [Getting Started Guide](http://www.dropwizard.io/getting-started.html) gives some good insight into why it might be a good fit for you.
Cool! I'd been thinking about how nice it would be to run things from the local Maven repo, and here we are: a way to do so. Definitely going to look into it later. Edit: Note that Jigsaw may render your project obsolete, depending on what it ends up being capable of. That's years away, though, and this exists now, so...
 mvn dependency:list This doesn't have to be difficult.
Not sure which Linux distributions you're using, but on my Debian machines, there is usually only one `libc` installed at a time, and it is mapped into shared memory for use by every process that requires it (which is pretty much all of them). OP is correct in trying to do the same for the JVM.
Looks good and easy readable! I like to group the classes by feature. So: photo/PhotoController photo/PhotoRepo photo/Photo album/AlbumController album/AlbumRepo album/Album This creates in larger project less clicking and a better overview.
Hi there. :-)
&gt; In the Map.get() case it means the key you passed wasn’t present in the map. I was sure someone was going to comment on this, but since not here goes. This is one of everyones Optional poster-child methods. Map.get() might _also_ return null because it has a key, whose _value_ is null. ( ImmutableMap from guava disallows null values - thankfully ) but there is still a case where _sometimes_ that differentiation _may_ be important. I think you mentioned earlier that throwing an exception is an expensive operation, one could use a custom exception that's configured to not pull in the stracktrace and thus not expensive, but that itself becomes almost pointless if it ever bleeds out where you'd want said trace. null is a trade off. Returning an Optional&lt;HttpUrl&gt; would probably be preferably for me, but not if Optional was the ONLY guava dependency used, if Java 8 only - JDK8's Optional _maybe_, preferably via maybe a tryParse() method. 
Patches appreciated :-)
Bad for companies but good for developers? If the case is ruled in favor of Oracle and everyone has to write their own APIs, a lot of programmers are going to be employed. Just looking for a silver lining
Architecture is really nice, packaging also quite fine. I have only few points regarding your DAO layer: 1) You could further simplify it using Spring Data JPA. 2) If you really like to use JPA this way then I highly advise you not to hardcode your JPQL queries inside methods as in getAlbumList(). Also, String sql = "select a from Album as a"; -&gt; this is not SQL it's JPQL :) SQL is created using createNativeQuery method of entity manager, but the main point was to externalize queries. 3) In Photo domain class, if name of a property is same as a name of column in DB, you can leave out @Column annotation, it will get mapped automatically ("title" for instance). Also, as an opinion, I prefer annotating getters rather than fields because it leaves fields more readable and easier to reason about, having in mind they're the first thing you see when you open your domain class. 4) Not regarding DAO, why do you access your services with this.service.bla? You can access it directly without this keyword. I actually see now you do it for all methods and fields in your classes, I think it really isn't necessary. Boxsc2's comments are also correct. All in all, good job :)
I was being facetious, but was somewhat serious. Having a job is never a bad thing...
I'm actually a little confused.. I've never developed for Android, I'm taking a free course online in Android development now. It only just begun, and the first steps are to download the JDK. If Google uses it's own version of Java with it's own API, based on Java's (but not Java), why does one need the JDK to develop for Android?
Again, I'll repeat, law things aside, using only common sense and objective judgement - Google copied Java the language (almost 100% so couldn't agree to speculation of it being different language) and Java the library and broke compatibility promise. That was vision of Sun. Google broke this vision. Was this vision valid from law perspective - that's another question, but philosophically I just cannot be on Google side on this one. 
thanks
implementing and plain copying is something entirely different. Specifically when the source code is open. Google copied methods almost 1:1. IMO I don't know where I Stand. I'm torn, on one hand I'm against copyright shit and on the other I can see where Java is coming from. They worked so hard to be completely copied and avoided licensing. That's just evil.
The "best" for me might not be the best for you or anyone else... so I see this as a kind of opinion poll. My vote goes to [Play](https://www.playframework.com). I like the quick turnaround, the none-JEE character (no servlet container), and the async architecture makes sense to me. If you don't know it, read [Play philosophy](https://www.playframework.com/documentation/2.4.x/Philosophy) and [Why Play is fast](http://www.typesafe.com/blog/why-is-play-framework-so-fast)
This requires lawyers not programmers. I don't see how this will work positively for programmers. 
Google copied INTERFACES (API) 1:1. Google used most method IMPLEMENTATIONS from Apache Harmony. Google did NOT copy IMPLEMENTATIONS from Sun/Oracle.
&gt; Google used most method IMPLEMENTATIONS from Apache Harmony. &gt; Google did NOT copy IMPLEMENTATIONS from Sun/Oracle. But Apache Harmony is bind to Sun/Oracle license - can copy/improve as long as its compatible.
You need to be more specific about the application that you want to develop. The full Java EE stack is very comprehensive.
Correct. Google implemented the Java API on the mobile device. On the desktop for development, they recommend Oracle.
I opted for having factories as that seems to be a good design practice in principle. Do you have an example of what a spring boot microservice collection should look like? Thanks for the tips!
Thats a fantastic idea, thanks!
I actually run a startup with 100% control of all variables. I change packages too much to try and set up some base packages in a VM or something... think not a week goes by without at least 1 dep changing. Would be awful to go move jars around every week... Here is another difference of static vs dynamic linking. My Linux box has 1000s of programs. If each program was static linked, it would be many GB of overlap. My boxes tend to use 1 Java app, usually more along the lines of a microservice. WIth only 1 java app, there is no net wasted linked jars that a common set of deps would solve. I know some people do &gt; 1 app per server, but with docker and such the trend is to move towards 1 app per "server", whatever the server may be. I see each server as a building block, little to no point to cram a bunch of stuff on one.
The outcome of rewriting everything ever written in Android to new APIs is not feasible. The only outcome if Oracle wins is a fist full of cash from Google for Oracle to create the new "Java Nano Edition" based on Androids implementation and license it to Google officially. 
Correct in what way? Why would I not want each build to have it's own set of exact deps, vs some fuzzy matching of what it finds on the box?
I guess this answer might be a bit outside the "norm", but I would actually consider web interfaces the best way to interact with a java application these days, unless you need certain functionality that is hard to do with a server/client-based HTML set up. It's not too difficult to set up a Spring Boot application that lets you try out making a web application. I guess it kinda depends on how much of the standard "web techs" you know already though. If you want to look into web application its handy to know the basics of how a http request and response works etc.
Maven dependency resolution is not “fuzzy”. That's the point: builds should be repeatable. This also means runs of the built artifacts, using the same dependency resolution mechanism, are also repeatable. Maven is actually stricter in that regard than typical Linux library loading is. Linux executables usually specify only the major version of the libraries they require, and use whatever actual version happens to be installed. Maven, on the other hand, will fetch *exact* versions of a project's dependencies, and will gladly keep several versions of a library in `~/.m2/repository` if different versions are needed by different projects. So, if diet4j uses the same dependency resolution mechanism, it will be *more* predictable than normal Linux programs.
Sure but a fat jar does this already. 
(Information from Norway, Java consultant with a few years experience) I don't really know of any official "endorsement", but in my circles, the trend is to move away from big "one size fits all" solutions such as [Spring](http://spring.io/) and [Play](https://www.playframework.com/), towards smaller and more customisable solutions such as [Spark](http://sparkjava.com/) and [Dropwizard](http://www.dropwizard.io/). [Play](https://www.playframework.com/) was on its way to become the go-to framework, like [Spring](http://spring.io/) used to be, but poor IntelliJ support and a shift towards Scala scared some people off. This might not hold true for other people in other parts of the world, but it's the impression I get from my colleagues.
&gt; Having a job is never a bad thing... It is when it’s a shitty job with all sorts of unnecessary legal pitfalls that you can only avoid by having total omniscience of every codebase and codebase license ever. The stress would never be worth the money.
Very good point, thanks for the input. Great to see some opinions from Europe as I would love to get an idea from all around the world (primarily concerned with US and Europe)
Let's imagine for a second that Oracle ends up winning and that copying an API is now copyright infringement. What is an API ? It is a very general term but for example interfaces are part of the API of some library. To implement an interface, you must copy it, and then fill in the blanks. So if the license of the library does not explicitly state that you can do so, you would now be breaking the law. Since it is so evident for programmers that this should be a right, no license that I know makes such mention. Practically 100% of developers would become criminals overnight. Another example, let's say a company makes a music composition software and sells additional instruments in the form of DLLs. It would be illegal for another company to sell compatible instruments without license form the original developer. This would be catastrophic for software development, invalidating decades of work based on interoperability principles, in the name of greed. edit: if you downvote me then tell me why. If you take this ruling literally then what I'm saying above are just logical consequences.
Oh, right, let's all reinvent the wheel, everyone in their little corner, you're not allowed to talk to each other. I guess nobody told lawyers about DRY. And good luck coming up with APIs for everything that are different from everybody else's.
I get fixed disk space. Free to use more. A few MB of network is not even a blip on my radar. Way under a penny. In fact in Datacenter network is free. 
Edit: next sentence is full of crap But Oracle is not attacking Open JDK so I guess Google did a little bit more than making something similar
I think PrimeFaces is far more popular and frankly it is better. RichFaces is still used by a lot of projects. ADF faces is more used in "secure" places where they will not let you use the others. Basically some government bodies and companies are more comfortable since it come from Oracle. As with everything there are a bunch of component libraries out there that are not used as much. OmniFaces and PrettyFaces are a couple others that also have their uses.
Thanks again for the input, seems like Spring plays a major role in both the US and European marketplace. If there's anything else you feel like adding feel free to. It's nice to see various inputs from around the world.
Then I suppose you don't really need diet4j. Fair enough.
Well, Oracle owns the OpenJDK...
buggy tools -- which tools are buggy? You can code Swing with VI if you want, but an IDE of course makes it much easier. Buggy tools is nonsense time consuming -- Coding a HTML/JS application is way slower than doing a Swing application and the desktop application, for most use cases, will provide a much better user experience. The stateless nature of HTTP can make writing web applications a tedious and slow process. hard to get L&amp;F desired -- your only valid point for Swing. However, JavaFX provides styling via a stylesheet.
Isn't the problem that Google claims to support Java but doesn't implement the entire standard. I thought Oracle was attacking the fact that Google doesn't comply with the Java standard or something like that. **Note**: instead of just downvoting me, point me to any source which accurately states _what the lawsuit is actually about_. Because I'm reading [articles](http://www.javaworld.com/article/2929808/open-source-tools/oracle-v-google-were-not-screwed-yet.html) which confirm my thoughts.
Sometimes, there's only one way of doing something though. In that case, what can they have done?
Vaadin is a GWT flavor. I think ZK is too.
the full API is not "one way of doing it" it was exactly their way of doing it. of course all methods will look the same when the basic structure is the same. As I said, I can't decide who to support, there are arguments for both sides. Why invest so much into developing such a huge API when in the end someone comes along and copies the whole thing and you gained nothing.
Did they copy the whole language 1:1, or parts of it? I'm not saying it's better or worse that way, in any case, I'm just trying to get up to speed!
&gt; Another example, let's say a company makes a music composition software and sells additional instruments in the form of DLLs. It would be illegal for another company to sell compatible instruments without license form the original developer. &gt; Isn't this illegal anyway when they state in the EULA that you can't modify the software or the runtime without prior approval? If the company that made the music software didn't provide any public API I would say it's a legal grey area at best.
Definitely. I've worked on two Play projects that started at play 2.0, but which have been updated to 2.3. For some of the releases the migration was really clunky (also, each release seems to break something for the plugin in IntelliJ). I'm pretty sure I will not be updating them to 2.4, and I'm sure I won't be using Play again for anything that has to live for more than a year.
I would look here and evaluate for your needs: https://github.com/akullpp/awesome-java#web-frameworks
The Oracle tutorials are actually a great set of documentation. You really can't go wrong those those: Swing: https://docs.oracle.com/javase/tutorial/uiswing/index.html JavaFX: http://docs.oracle.com/javase/8/javase-clienttechnologies.htm I find the Swing documentation to be much better than JavaFX, which makes sense since Swing has been around for many years. If you start with Swing and learn it learning JavaFX is trivial as they are similar. You might want to start with Swing since it has better documentation. However, JavaFX is Swing's replacement so you may want to just start there. Your choice.
Well TIL
If I recall, in the beginning google made a decision between c# and java for the android platform and ultimately settled on java because they thought it was more open... Well... well then... Edit* I dont, understand why I'm being downvoted... The android team DID consider using the microsoft CLR as an option, as is referenced here: http://www.fosspatents.com/2011/07/judge-orders-overhaul-of-oracles.html#sovietstyle Edit2* Oh. Im in r/java... sorry guys... I thought I was in r/programming... I would never have mentioned the clr and .net if I had paid attention to the subreddit. Its not relevant at all. 
I don't know how many issues I've had in the past with generic wild cards in Java... One of the most interesting bits has been written by Ross Tate: "Taming Wildcards in Java's Type System": http://www.cs.cornell.edu/~ross/publications/tamewild/tamewild-tate-pldi11.pdf
Violating a EULA isn't criminal(yet). Copyright Infringement unfortunately is.
Dalvik is not the Oracle JVM. The JVM has certain aspects that allow you to make a call in Java that will communicate with the OS at a lower level. Basically what Dalvik is doing is allowing you to make those same exact calls and translating them to the Android OS version of the communication. So in the context provided, Oracle is arguing that it is against the rules to allow you to make the same calls that Java normally makes to do normal things in Android and that Google should have either worked with Oracle on making a JVM, or licensed the way that they did it. Or just implement a whole different way of doing it.
&gt; Google implemented *part of* the Java API on the mobile device. If they'd implemented the entire Java API, Sun/Oracle would have allowed them to license it. Anyone is free to build a JVM, but if you do, you have to support the standard libraries. (This is Sun's effort to avoid fragmentation.) 
[Twelve hours ago](http://www.reddit.com/r/java/comments/38bnm0/oracle_vs_google_case_threatens_foundations_of/).
on the bright side, maybe everyone will start publishing open source to save other people from the pain of copyright?
This is not just Oracle/Google. This is anybody coding to an API that isn't explicitly put in the public domain. DirectX, etc...
I realize it pertains to API copyright in general, but I don't think it would prove as catastrophic as the article makes out if Oracle won the case.
Not sure what your comfort level is with Java, but the controversy is mostly over Java interfaces. If someone writes code for the Oracle JDK and uses, let's say, java.util.List, it would be pretty reasonable for them to expect that code to keep working if they ported it to Android. Why? Because java.util.List describes "something list-like", rather than a specific implementation. All lists (ever) would have a "length" method, for example. So Google, being the nice people they are, decide to adhere to those interfaces rather than invent their own. Lots of reasons to do this including user convenience, portability, lower learning curve, and instant recognition by third party tools (code analysis tools would immediately know "that's a list!" and not have to be reprogrammed just for Google). But now the courts are saying (for this example) that Oracle officially owns the interface for java.util.List. And anyone who names their methods the same has to go talk to Oracle now. Even though they may implement an *actual* list very differently, the fact that they say "I have a length method just like Oracle" is now a problem.
Depends on what kind of animations... Swing used to be good, but I haven't looked in a while.
I made no mention of such EULA in my example, but the way this works usually is that you export predefined function names in your DLL and drop it somewhere for the program to detect it and load it up as an addon. You don't modify the program at all, and by exporting predefined function names you are effectively implementing a non-public interface.
Well, actually I need it to update a property of an object, but it would also be sufficient to give some callback. It should be possible to start, pause and stop the animation. edit: I'm using Java 8
&gt; What is an API ? It is a very general term That is what makes this all the worse. Not only do you have to tread carefully. You must tread carefully in the worst case imaginable way. The lawyers in an organization will ask if something could possibly be construed to be an API. If so, then you can't use it without a license allowing its use. Etc. Not the same thing as asking more precise questions like: * Is this compatible with 110 volts AC 60 cycle? * Was this done by a licensed plumber? The fact that API doesn't have a precise formal definition really means this will have a profound effect on the industry. Nobody wants to get sued or have their business disrupted. Thank you Oracle for this inventive new novel legal argument to your ridiculous lawsuit where you were previously losing every other single argument. I suppose judges have small enough minds that something trivial to us seems like a gigantic big deal to them.
It may be a disaster. It inverts a very basic assumption of the software industry for the last three and a half decades.
But what kind of precedent will it set? Oracle is arguing that apis are copyrightable as a whole, not piecemeal. A lot of people seem to be under the impression that this would make using toString or having a method with the same name copyright infringement. That's not the case. Copying a large portion and structure of an API would be, like with how google used the java api with their java-like language. And even in cases where a huge portion or all of the API was copied, there are fair-use defenses if you did it for interoperability purposes. The only reason Google can get nailed with this is they did not copy the java language's API for interoperability. They copied just enough to allow their android ecosystem to benefit from pre-existing java software and libraries, but not enough that the opposite really happens. To be honest, I don't see much downside to allowing apis to be copyrightable, and don't see why they shouldn't under the definition of copyright law, but other software should. Some people say it would be like copyrighting a table of contents (which is actually something you can do), but the APIs in question actually form some of the implementation themselves, since they not only describe an interface, but also relationships between different classes in the interface. TBH I don't see how an api can not be copyrightable, but declaratively programmed software can be. The downsides could be harsh (larger companies could try to bully people with copyright infringement claims even when there's a fair-use defense), but that's more an issue with the imbalances in our legal system (we really should have more funding for public defenders and public defenders/prosecutors for civil suits beyond a DA), and that won't be fixed by just ignoring current law and precedent.
Then “further” means crashing to the command line. This is correct behavior in an out-of-memory situation.
My understanding is that oracle claims that an api is copyrightable as a whole. Google infringed their copyright by copying the structure and naming of their api. Google could normally defend against this even if apis are found to be copyrightable by arguing they did it for interoperability purposes. However, that's a weak case for them, because the android ecosystem was pretty obviously made to be just compatible enough with the java ecosystem to benefit from java software and libraries, but not compatible enough to allow the reverse to happen. One thing that could save google in this case is if dalvik and their java-like implementation was gpl. OpenJDK is gpl and therefore so is the api. However, gpl derivative code cannot be relicensed, it must be gpl too. In this case, google built their java-like platform off of apache harmony, which carries the apache license. It too doesn't allow derivative works to relicense themselves. Thus apache harmony and dalvik would both be violating the gpl and therefore infringing oracle's copyright (should apis be found to be copyrightable). However, like I said, interoperability is considered fair-use, which would defend harmony. Google doesn't have this excuse and so finds themselves in between a rock and a hard place.
There are other opensource JVMs though, such as avian. They are fine because they are gpl, and cause they copied the api for compatibility.
Yeah I was just wondering if it would be legal for the other company to _sell_ plugins for the original software. Of course nobody would sue if they would just distribute it for free because there would be no money gained. 
To extend on that, it isn't specifically about *Interfaces* like the Java language knows them. Its generally about API design, where the "API" is what the class exposes (class name, public members like methods and possibly fields) - basically the stuff you see in Javadocs. Google copied, like you said, the method names and what they do for a lot of Oracle-owned classes, but not the specific implementation behind it. They have their own implementation of, say, ArrayList, which conveniently lives in the same package as Oracles ArrayList, which in turn causes compatibility with a lot of programs that weren't written with Android in mind. The JDK is required by the Android SDK due to the way Android apps are compiled. First Oracles own compiler (javac) is let loose on your program which produces Java bytecode. Then, the Dalvik compiler combines all your bytecode to one (or more if you have a *lot* of methods) Dalvik .dex file.
http://docs.oracle.com/javase/7/docs/api/java/awt/Component.html#addMouseListener(java.awt.event.MouseListener) The MouseListener will give you access to the mouse events. Furthermore, the MouseEvent will have the button pressed accessible through MouseEvent.getButton() http://docs.oracle.com/javase/7/docs/api/java/awt/event/MouseEvent.html#getButton()
SwingUtilities has a "isRightMouseButton" method which takes the mouse event as input. http://docs.oracle.com/javase/7/docs/api/javax/swing/SwingUtilities.html#isRightMouseButton(java.awt.event.MouseEvent)
I read that, but I'm still not sure how to implement it. Or rather, I tried to implement it, but I'm certainly doing something wrong, as the following code does not work: public void mousePressed( MouseEvent me){ if(SwingUtilities.isRightMouseButton(me)){ System.out.println("blah"); } } If I can use actionlistener to react to a left mouse click, can't I make it react to a right mouse one?
http://developerlife.com/tutorials/?p=17 ...an intro to animated transitions using swingx and a timing framework.
Play is a modern day tapestry. It's crap and until you've experienced the limitations it burdens you with, you'll think it's the greatest thing ever.
It's fine, people just like to hate on popular things.
"There are only two kinds of languages: the ones people complain about and the ones nobody uses" -Bjarne Stroustrup
WindowBuilder Pro is the exception to that rule desrtfx as it can be used to create bi-directional edits to a swing UI unlike the craptastic one that netbeans includes that requires your code to be structured a certain way. 
 public void mousePressed(MouseEvent me) { if (me.getButton() == MouseEvent.BUTTON3) { //do stuff } }
I actually believe that no one has really understood wildcards yet. Otherwise, we wouldn't still be fixing compiler bugs 11 years after generics introduction.
Hard to take them seriously when they say Clojure is preferred over Java.
I think Functional Programming concepts work excellently when it comes to working with data and collections of data. But I think Objects work best when modeling business entities. I wish there was a decent middle ground.
Truly, nobody complain about what they don't use.
That's true. WindowBuilder Pro is also the only Swing Builder that I know that produces somewhat legible code. The bi-directional editing feature is one of the absolute highlights. 
Copyright infringement is a [criminal offense](http://www.copyright.gov/title17/92chap5.html#506).
Stop that.
Actually, we're both right: http://en.wikipedia.org/wiki/Criminal_Copyright_Law_in_the_United_States#Civil_vs._criminal_copyright_infringement Civil copyright infringement is much more common than criminal though because the latter is much more narrowly defined.
I do love me some static typing with true type inference. Dynamic typing seems like a necessary evil of the past: you only needed it because static typing wasn't worth the hassle in those primitive languages. No longer a problem with today's knowledge! Now, if only the languages could catch up to the knowledge. I'm super excited to see what Microsoft comes up with to rival Swift.
My explanation is quite similar. Lets say Microsoft invented a door. Lets say you run a business and people need to get into a building. Better fucking hope you can invent a transporter because no way you can use a fucking door because those assholes at microsoft own that entire goddamn idea. 
Out of these three, only Scala has anything resembling mainstream popularity. Haskell is mostly fine but still has a few practical problems I don't like (record syntax name collisions for one thing). And Rust doesn't allow me to omit low-level details when I want to only talk in higher-level language. That's why I still use things like Ruby.
Scala's really not overcomplex imo. It's grammar is pretty simple. About the only part of it that is can be slightly scary is implicit conversions, and they can't hurt you if you don't import them.
Cool :), there's a couple in there I've been interested in learning myself. Namely Go, and I've been intrigued by Clojure... I'm mainly looking for something for web development that's just different to what I normally work with, which is PHP!
Scala actually borrows a lot from OCaml. Not as much as Haskell or F# mind you, but the influences are very obviously there. And lol at ruby not being "overcomplex" with it's monkey patching.
Section 5.4 seems to be missing. The link goes to a blank webpage. 
Forget about Go. You have to rewrite "map", "filter", "reduce" etc. for every new type you create. The whole Go community's answer to this is "just use a for-loop" and "seriously it's not that hard just use a for-loop". Forget about Go. Forget it fast.
I've been doing web dev with scala and scalatra (sinatra-like scala lib). It's pretty nice, plus I love strong typing.
I have really enjoyed the Scala I've done thus far. I've not been working with any frameworks, I'm just trying to make little components that do things. Coming from PHP there's a lot to learn, more advanced data structures to play around with, etc.
Well with Clojure at work it's already ridiculously slow for me. Running our test suite from scratch of a mere 500 tests with an in-memory database takes about 1 minute from pressing enter to completing. Compiling the whole website into an uberjar for deployment takes about 2 minutes. Can Scala really be slower than that?
Haha, I see. Actually, Rust is another one I've had my eye on before. There are just too many choices!
Right, but it's clearly usable in spite of not being mainstream. Why is popularity important to you?
I suppose that's true to an extent. Most web development is very straightforward, as most websites are simply content-based. 
I would argue that you are definitely in an anomalous bubble, then. 
Could be.
You would ask [/u/agleiv2](https://www.reddit.com/user/agleiv2) for that :)
Args4J: https://github.com/kohsuke/args4j/blob/master/args4j/examples/SampleMain.java Apache Commons CLI: http://commons.apache.org/proper/commons-cli/usage.html
&gt;Actually, we're both right: You were not right. &gt; Copyright infringement is not criminal, it's a civil violation. Is patently false. &gt; Civil copyright infringement is much more common than criminal though because the latter is much more narrowly defined. And is irrelevant to the legal difference between EULA violations and Copyright infringement.
Good question. I haven't used Commons-cli, so I guess I don't know. I just googled for java parse command line arguments and noticed Kohsuke.org was one of the options, so I opened that one first.
That's why Clojure provides OO analogous features like [protocols](http://clojure.org/protocols).
They're paranoid as fuck about a race condition on those resources for some reason. I'd need to see the context of how this is called to tell.
I still think that JCommander makes more sense to me. 
Not really. They just didn't have the resources to defend it against Google. If you think that's Ok then well....
No you don't provide a citation for your random blithering that's probably why ppl downvoted you - but I didn't. I assume at some point you'll provide a citation and then I'll click the up arrow button.
There's a whole number of problems in Java compared to other languages. Lack of first class functions means that you have to jump through hoops to do simple things. You have things like the DI pattern for what's otherwise known as passing arguments. That's partially addressed by Java 8 now with its lambdas. Pervasive mutability makes it difficult to reason about code as it's difficult to guarantee what the scope of a change will be. This is especially problematic when dealing with threading or writing large applications where you wish to be able to compartmentalize things. With Java the burden is squarely on the developer. Java lacks expressiveness. This means that it's difficult to abstract things and make DSLs that express your problem domain. This translates into writing more repetitive code by hand. The object oriented nature of the language creates further problems. By marrying code and data together you actually make code reuse more difficult. If you write some methods in one class and you then need to use those in a different one you have to start creating inheritance hierarchies. By contrast when you have a small number of data structures that all functions operate on you can compose them any way you like. This way you have code reuse at function level. To quote Alan J. Perlis: "It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures." This also means that you have to do null checks everywhere, since if you're calling a method on an object you first have to check that it exists. In a functional language this problem doesn't exist. Comparisons of data are again made unnecessarily difficult due to mutability. In a language with immutable data you can always compare any two data structures by value, even if they're nested structures. In Java you have to manually write comparators and handle null checks for any nested structures. Java has very poor support of writing declarative code. This means that you're often mixing the intent with implementation details. This makes it more difficult to understand and refactor code. All that said, Java has its place and obviously lots of people use it just fine. However, that doesn't mean you shouldn't learn other languages or that there aren't any problems with it. Languages are tools and the more tools you have in your toolbox the more problems you can solve effectively. 
Yes, I totally agree. I love being able to use `-&gt;&gt;` and `map` and `reduce` and `filter` and `complement` and `juxt` and `comp` and all these things. But when dealing with objects from a database, having actual objects *really helps*.
&gt; This also means that you have to do null checks everywhere, since if you're calling a method on an object you first have to check that it exists. In a functional language this problem doesn't exist. Not true. Clojure still has nil, and NullPointerExceptions. It's really annoying too. Nil isn't specific to OOP and FP isn't immune to nil. Also, a better solution to nil is the Maybe type. I really like Maybe. And with pattern matching (like in Haskell or OCaml or to a lesser extent Swift), Maybe is really easy to work with.
They didn't copy Java, they created an alternate compatible implementation. The only thing they copied are the method signatures, because it is *necessary for interoperability*. Are you a programmer? If so think one second about how much our industry relies on the idea of interoperability and how you can swap compatible implementations at will without explicit consent from each author involved, and how different it would look if we didn't have that. 
I find it to be the opposite myself. I'd much rather get lists of maps from the database that I can use directly instead of having to map relational data to an object system. The fact of the matter is that they don't really map well to each other and once you go down the ORM route then it becomes very difficult to reason about what's actually happening with your queries. Every project that I've seen working with things like Hibernate always ran into performance problems as soon as it hit any real world data and tuning the ORM is far more painful than just writing the actual queries yourself. Libraries like [Yesql](https://github.com/krisajenkins/yesql/tree/devel) and [Korma](http://sqlkorma.com/) are a breath of fresh air compared to stuff like Hibernate.
For very simple databases, it may be fine to just get data straight from the database as native Clojure types and operate on them with Clojure functions. But most real life databases already *contain* implementation details. For example, many of my database types have a `sort-position` attribute, since they're unordered collections. Before giving it to the consumer of my internal API, I have to sort based on this attribute. But that's just a small example. Several other aspects of my database should be *hidden* from the API's consumer, and *interpreted* first by my own code before given to the consumer. Objects make this very obvious and easy to do. With free-floating functions it feels significantly more clunky and ad-hoc.
I'm not sure what you mean by that at all. Clojure has an incredibly powerful macro system that makes it trivial to write DSLs like [Korma](http://sqlkorma.com/), [core.async](https://clojure.github.io/core.async/) or [Compojure](https://github.com/weavejester/compojure) for expressing domain specific problems. There's no equivalent of that in a language like Ruby.
Macros are usually a terrible idea for domain-level code because they're not composable or flexible at all. They're best used for language-level features like `-&gt;&gt;` or `core.async`. Most people I know have lamented the use of macros in both Korma and Compojure.
Clojure has nil, but functions themselves cannot be nil as they're static and you can always safely call a function. Since vast majority of code is written by function composition, nils simply bubble up to the top level in most cases. I can safely chain any data transformation functions such as `map`, `reduce`, `filter`, and `interpose` without having to pepper nil checks all over the place. With OOP you always have to check whether the object exists before you can call a method on it. So, if you have something like `person.getAddress().getStreet()` then you can get a null pointer at each step. Meanwhile writing `(-&gt; person :address :street)` in Clojure is perfectly safe. In fact, the only time you see NPE in Clojure is when you're doing Java interop. &gt;Also, a better solution to nil is the Maybe type. I really like Maybe. And with pattern matching (like in Haskell or OCaml or to a lesser extent Swift), Maybe is really easy to work with. And if you want static typing then Clojure has [core.typed](https://github.com/clojure/core.typed) which actually provides a more sound type system than Java and prevents NPE errors.
Protocols may help with polymorphism as your example shows. But I will often get a map out of my database that has attributes which the user should never directly read, because they're implementation details, and instead I need to provide functions that interpret this map correctly. For example a `:sort-position` key to provide ordering to a collection. I don't want every consumer of my collection of maps to have to sort by this key. That's too low-level of an implementation detail. They should just get back an ordered collection of things.
Generics + subtyping = headhurt, and wildcards just amplify the pain. Let's put it this way: despite the reputation, Haskell's type system is actually way, way easier to understand than Java's. The difference really is that Java lets you get away without understanding it.
Only for lukaseder who hacks at it all day long in an attempt to make jooq relevant. 
Oh damn, glad to see this get out there. Ages ago I had a DB guy tell me to use deletedAt as a field instead of a flag or just outright deleting it. From then on, I started using UTC timestamps for as many things as I can. Also just putting in as much context for values as possible. Ie, instead of having say a count, having a begin and end. Sometimes though, you need a count, so for that putting a cache_count in and updating it. .:Edit:: Sometimes even deconstructing the data into a journal of changes, rather than a snapshot of data, depending on need. 
&gt; I realize it pertains to API copyright in general, but I don't think it would prove as catastrophic as the article makes out if Oracle won the case. Wait until AOL (Verizon) try to fuck us all on JavaScript. that's probably the peak, but bootstrap, angular, etc... will all be something you have to observe through the rear-view
Kohuske also wrote JAXB. He's a human dynamo.
Well I don't like Compojure specifically because of its macros.
&gt;Sometimes it's really helpful for a class's implementation to generate its own data and hide it from its consumers. Sure, and Clojure provides many ways of doing that. The simplest is to make a closure which acts the exact same way as a constructor in OO languages. Then you have things like [deftype](http://conj.io/store/v1/org.clojure/clojure/1.7.0-alpha4/clj/clojure.core/deftype/), [defrecord](http://conj.io/store/v1/org.clojure/clojure/1.7.0-alpha4/clj/clojure.core/defrecord/), and [defprotocol](http://conj.io/store/v1/org.clojure/clojure/1.7.0-alpha4/clj/clojure.core/defprotocol/). The [component](https://github.com/stuartsierra/component) pattern is a great example of how you can encapsulate things without having to mix data and logic together. &gt;But the idiomatic Clojure way is to just pass all data as parameters and hope no consumers start to rely on any of the implementation details that the data happens to carry on it. Like :sort-position. That's really not the case in practice though. This seems to be simply a misconception you have about how to structure applications in Clojure.
The standard approach here is to have a persistence layer that manages the DB and exposes the API you want to the rest of the application. Managing that is no different than setting up the ORM mappings.
I much prefer args4j's annotation approach. But that's just my personal preference.
Is the link not a valid citation?
Let me repeat myself "the new OOM will hide the original one". Yes, the JVM process will terminate the same way. But if you have diagnostic tools, it will mess up with them. Even the simple built-in heap dump at OOM will be affected. Especially in this case. Lots of stuff is allocated in the call chain inside that try-catch block in main. In the catch block JVM will see a request to allocate a new object (in the log invokation) and will attempt another GC. It may cleanup some of those objects that caused the initial OOM. Then there are two possible scenarios: * there is enough memory, no new OOM. Goodbye heap dump, goodbye any chance to fix the error. All you get is a "something went terribly wrong" in the log * there is another OOM, but the heap is distorted, some of the references can be collected, but were not collected by the GC. It will mess up with your heap dump analysis tool. The pitfalls of catching Throwable have been covered well already. Just pick any blog post or SO question that comes up in the search.
Why would you ask that here? 
I tried the page and it is displaying properly for me. May be something to do with cache, please try in alternate browser.
&gt; Well, I got really ~~good~~ answers, didn't I? Well, I got really bias answers, didn't I?
Please do give an example of a popular Clojure library that exposes its implementation details in the API. Passing data around doesn't imply that you should leak internal details of how something is done in any way. 
I'm not sure what prevents you from doing that using namespaces. A namespace behaves exactly the same way a class with static methods.
All opinions are biased.
I understand them quite well, you hack. They behave exactly as they should.
The most accurate way I've ever heard to describe PHP. 
Thanks for the additional advertising of jOOQ, which is greatly appreciated. This particular case doesn't have anything to do with jOOQ, though, just with a very peculiar and interesting edge case of generic type inference in Java, which has become all the more relevant now that... 1. Lambdas heavily depend on it 2. JEP-101 has introduced [generalized target-type inference](http://openjdk.java.net/jeps/101) in Java 8 Of course, perhaps you're still working on JDK 1.4, so this might indeed not be relevant to you. Otherwise, I wish you happy rawtype casting.
The type inference algorithm is well specified... I recently created a working implementation myself. Compiler bugs exist because it is a complex algorithm, but if you break any given example down it is certainly possible to determine whether it will compile, and why. People are still fixing all sorts of bugs in code based on decades old algorithms and principles, even quite simple ones... That doesn't mean those things aren't well understood. I'm not even that much of an expert myself, but I enough experience at least to recognise that it's silly to suggest that type systems in general - and java's specifically - are not well understood academically.
&gt; I'm not even that much of an expert myself Me neither &gt; but I enough experience at least to recognise that it's silly to suggest [...] You call it silly. I call it pessimistic. But you're right. *"No one has really understood..."* is applying a dramatic quantifier that is certainly incorrect. Academically, wild cards are probably decently understood - although understanding is still evolving, and they certainly weren't unanimously understood when they were introduced. I wonder, though, how many real world APIs have been produced by said academia. I, for one, have often relied on intuition and compilers telling me what's right and wrong. That's obviously not a precise approach, but I simply don't have time to hit the JLS every time I add a new method to an API. Also, the JLS is not the ultimate source of type system truth. It is just the type system implementation of Java, which takes into account of a lot of legacy. The price for my approach is to realise that my intuition is (still) very wrong.
What information are you looking for exactly? Your question is a bit vague. In my current (small) project, we each have our own development server running locally (started via the gretty plugin for gradle). This contains stuff like JRebel so that classes are reloaded automatically without having to continously restart the server. Whenever someone commits changes to our repo, then our Continuous Integration tool picks this up. It checks out the repo, builds it and then deploys the application to our Staging environment. This is just a unix box where a Tomcat instance is running. It stops tomcat, removes the existing version of the app, uploads the new version, and restarts tomcat. For production we just manually deploy the war file to Production server. Which is the same unix box but using a different Tomcat instance. If you're looking to learn how to set up server (install Java, Tomcat, a database, ...) then I suggest to rent a VPS from DigitalOcean or something and follow the tutorials they provide on how to install various services.
I would recommend that install Virtualbox and some Unix/Linux image there (depending what OS you want to learn to use). You can also download ready-made images from virtualboxes.org/images/. When you have OS running on your Virtualbox, you can play and set up anything what you find interesting (app servers, dbs, version control etc). It's a safe and easy way to play around. Web is full of tutorials how to setup environments, e.g. Tomcat+Mongo+GIT+Jenkins on Ubuntu.
Thanks for replying. Now I read my question again, it's a bit vague indeed, sorry about that. I was asking for tutorials or books that explains this process. For example, a (step-by-step) guide to setup a Java Spring development, staging and production environment. I know that there is not just one way, but my problem is that I don't know where to begin. How do I have to configure git? What branches should I make and how do I configure the CI for this process. I know how to setup a basic server, but without the dev. staging and production stages. I hope that I have explained it better now and thanks in advance! :)
Sorry to tell you, but you are in the wrong subreddit. /r/Java is not for requesting help with Java programming, it is about **News, Technical discussions, research papers and assorted things of interest related to the Java programming language.** Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints.) Since you already have multiple replies, the post will be kept, but for future, please post code help questions in /r/Javahelp. Please, when posting next time, also obey the [Code Posting Guidelines](http://www.reddit.com/r/javahelp/wiki/code_guides) as are outlined in /r/Javahelp, as well as the [General Posting Guidelines there](http://www.reddit.com/r/javahelp/wiki/posting_guides).
Well, the difference between Development, Staging and Production is typically just that they are different machines, with each their own database and application server (f.e. Tomcat). Production may be a bit more complicated I guess (multiple servers, load balancer, etc... this I can't help you with as I don't have that experience either). Our repositories are hosted on a central git server. I haven't set this up myself yet as I typically use Github for my own work, but you could have a look at this tutorial on how to set up a Git server on DigitalOcean: https://www.digitalocean.com/community/tutorials/how-to-set-up-a-private-git-server-on-a-vps As far as CI goes, you could use something like CI Jenkins. You typically define your (git) repository, and a couple of build steps (there are tons of plugins available for doing all kinds of gradle/maven/tomcat related tasks). Then whenever you push to your repo, CI Jenkins kicks in and executes those tasks. I'm not sure there are any books on this topic, but I guess what you want to look for is "Development Operations" (devops)
That sounds more like a disadvantage over resolving the dependencies at startup time.
Just use Runtime.getRuntime().exec("iexplorer.exe") ... to launch your Angular app like everyone else
You may enjoy this link :) https://wiki.theory.org/YourLanguageSucks 
[The tutorial](https://docs.oracle.com/javase/tutorial/extra/generics/) is nowhere near 100 pages long. Look, you're not going to impress me. Java's type system ain't shit. I'm a Scala programmer; that language has a type system whose complexity and power would make you rank amateurs shit your pants and cry for your mothers. Java is basically “statically-typed programming for dummies”, and even that is too much for you?! Sad.
Sadly I've already tried this and it didn't resolve the ambiguity problem. I may still do something like this for clarity though.
I think choosing meaningful names is the only option that is going to work. The trouble is I can't find anything totally satisfactory. Currently I have methods like caseSome/caseNone, case2 (matching Case-like classes of arity 2), caseNil/caseHeadNil/caseHeadTail (cons like matching of lists), caseInt/caseLong/etc. I need to come up with a naming scheme that can work in all of these cases and anymore that could be added in the future.
Sometimes it's best to have a language specialize in one thing. The nice thing about Clojure is that it's a JVM language and you can do FP with it and if need be you can do OOP with Java. 
Ofcourse this must be trolling, there is no other way to interpre it...no other.
Thank you. I know got a better view with just a simple explaining. When I'm home, I'll take my research to a higher level :)
Interesting. Yeah, I was just a little confused because I glanced at the stackoverflow answer that got accepted and took it at face value (in other words I didn't RTFA, i.e. your post, properly, sorry). In that case my idea might have worked. But yeah, it is different.
I thought I just said it resolves all dependencies recursively at startup time. The app does have the opportunity to later dynamically look up and load additional modules (like a web browser might, if it encounters a new content type)
Why not use them as return types? I often do this to specify the returned list is read only. I use it for local variables to indicate I don't intend on modifying them. 
Did you doublecheck what version of Java you're actually using?
Java 8u45.
Your production environment should 100% match your development, qa, and staging environments. Otherwise how do you guarantee promotion is the same? You are also misusing the staging convention, you are treating it as a qa environment. Typically stage is not volatile, and runs the releasable artifact, not a snapshot. IhsanF1, you are dabbling into devops realm, which is an entire monster all to itself. Typically people specialize in the skills you are talking about and they end up doing little java coding. I would suggest you look at tools like puppet, ansible, vagrant, chef, docker. Like I said, it's a massive learning curve so I doubt anyone can just explain it to you via a reddit reply, you need to dig in for the long haul and start learning.
It isn't, but it works better than wrapping it in another layer of reference indirection (Collections.unmodifiableList). Not to mention the runtime exceptions when you assume the list isn't read only. All final does is prevent me from changing the reference. not modifying it. Using an extends wouldn't prevent null insertion or deletion but it would make it pretty clear that regular insertion is not allowed/possible. So, yeah, while I can understand that using List&lt;? extends E&gt; for read-only lists isn't what it was meant for, it does a far better job than what standard Java provides. Why can't I have something like const in C++?
&gt; How? Collections.unmodifiableList returns a wrapper, therefore every call has to go through that first. No such issue with List&lt;? extends T&gt;. The performance impact might be minimal, but I started programming with C over a decade ago and this just bothers me. &gt; That's a failing of the Java Collections API design. Yup... Doesn't mean I can convince my colleagues to include any alternative Collection APIs in their work.
I don't think Oracle knows how to do this. Is this supposed to be about helping Java promoters achieve greater visibility, or is it supposed to be some kind of reward? If the former, they should really look at Microsoft's MVP program if they want to know how to raise the visibility and therefore reward their key contributors. If the latter, then they really need to put a wee bit more effort into this. I mean, look at this: &gt; David is a member of the Apache Software Foundation and co-founder of the OpenEJB (1999), Geronimo (2003), and TomEE (2011) projects. He founded the company Tomitribe (2012), encouraging developers to contribute to the Open Source communities he created. He is a veteran of Open Source Java EE for both the implementation and definition of Java EE specifications for over 10 years in order to make Java EE as simple, testable and as light as Java SE. &gt; &gt;As a member of the EJB 3.0, 3.1, 3.2 and Java EE 6 and 7 Expert Groups, David has contributed new APIs, enhancements and provided in-depth feedback to JSRs. Key contributions include the Embedded EJB Container API, the inclusion of EJBs in Wars, Web Profile support, and MDB/Connector model. In addition to Java EE 8, David has joined the CDI 2.0, JMS 2.1, and Java EE Security JSRs. David is a regular speaker on Open Source and Java EE at JavaOne, Devoxx BE, Devoxx UK, Devoxx FR, ApacheCon, JavaLand, JAX London, JAXConf, W-JAX, O'Reilly Open Source conference and a JavaOne RockStar. David is also a contributing author to Component-Based Software Engineering: Putting the Pieces Together from Addison Wesley. In his personal blog, David wrote on popular topics such as the Connector Architecture, and Meta-Annotations. Follow him at @dblevins And they're just NOW getting around to promoting him with this? That makes them kind of irrelevant. The promotion page for this program is also horrible: https://java.net/website/java-champions/ And the bios page is also completely flaccid: https://java.net/website/java-champions/bios.html. If you actually click on one of those bios, there's less information there than there is in the blog announcement. If this is supposed to show gratitude to Champions, then it's a bit shameful. 
I'm only a Java newb but I bookmarked this... Hope its of use https://github.com/dell-oss/Mensa
Also enjoyed this one: &gt; Since Waratek executes in the JVM, there is no user discernible impact on application response times. I don't understand what executing in the JVM has to do with it.
I think it's a great idea. I don't think a lot of the people that dedicate their lives do it for a fancy website with their name on it. The people that matter in the community understand his contributions anyway.
It's a point of acknowledging their contributions and building something that showcases their work. The site is a poorly executed after thought. Sure *they* don't do the work for their name to appear on a website but if you're a multi-billion dollar company who puts up a single page that loads like crap and has had about zero effort put into it then what's the point? It's like... here's a pat on the head and a nickel. Don't spend it all in one place kid. 
&gt;Collections.unmodifiableList returns a wrapper, therefore every call has to go through that first. No such issue with List&lt;? extends T&gt;. The performance impact might be minimal, but I started programming with C over a decade ago and this just bothers me. Then you'll be pleased to learn that the JIT compiler will inline the calls anyway. The performance impact isn't merely minimal; it's nonexistent (other than the time taken by the JIT compiler itself).
Javazone needs to make this movie.
I don't know about the politics around MVP. I suppose it's unavoidable if that's the case. What I do know about it though is that everyone I know who has been an MVP, and I have known a few, have worked their butts off for it. The only complaint I have about the MVP program is that it's a little too concentrated on Microsoft's flavor of the day technology-wise. 
I had a stab at a proof of concept of this about a year ago and came up with a similar API in case it is useful http://benjiweber.co.uk/blog/2014/08/26/deep-pattern-matching-in-java/ http://benjiweber.co.uk/blog/2014/05/03/pattern-matching-in-java/ 
The MVP swings wide and there are definitely hard won MVP's the are well deserved. But the way they are associated with a product can be absurd. As a MSFT Dev Evangelist explained to me, there are only so many MVP's that can go around and they are tied to product teams. So a product team like C# has a lot of them and can dole them out pretty much at will but for other products with less clout there are less MVP's to go around. Then there are other considerations about connections and being the squeakiest wheel to get selected. You're correct about the "flavor of the day" as well. When I chatted with the DE there was no way for them to recognize generalized work or work within the community *without* tying the work to a product. :(
so those models - does the end user (me) do any of the training, or is that model you loaded a static resource that usually doesn't change?
It depends. Most apps use pre-trained models, e.g. the one found on the OpenNLP page, and those never change. However, that usually results in poor performace cause the training domain may have been different to the domain the model ismapplied to. More robust systems train on the same domain as the models should be applied to. They may also incorporate feedback from end-users (e.g. was this detected entity correct or not) which may be fed back into the system, resulting in iteratively improving models. Most users will not give feedback though, or give wrong feedback, so ymmv :) Just using those libs and hoping for the best most often results in terrible end user experience and a general sense that this kind of tech ismquite useless in real life :)
Yes, that's ths gist of it. Put your system through end user(-like) testing before wasting time on creating training data and training new models though. Pre-canned stuff can be good enough if you don't need 100% precision/recall.
ok. thanks for the assistance. one more question - do the trained models stack on top of that base model, or do you have to replace it wholesale?
oh. so if it's "kind of ok" you can't make it better. man. that is really terrible. 
Off the top of my head, a good thread problem would be this: Make a function that accepts 1 char, prints it to sout, then waits 1 second. Then using that function, print "Hello World!" in less than 5 seconds. Optionally using a string instead of an array of chars or whatever.
If you're using Artifactory (and I believe Nexus has a similar feature), you can set them up to mirror and cache external repositories. If you're using a lot of projects that are doing this with github, you're going to find performance rapidly becoming a problem because maven wasn't intended to use repositories per artifact like this - it will search for any artifact starting with the first repo, then the second, then the third, etc. There may be plugins or solutions to that at the enterprise repo level (e.g. in artifactory / nexus), though it hasn't really come up for us so I'm not sure. And of course, you could just reupload these artifacts to your enterprise repo yourself too.
Ok, that's good to know. Cause I was sent to the redirector and it just navigated to the redirector GitHub which was kind of useless 
/r/dailyprogrammer. Does what it says on the tin (although IMO it's more like weeklyprogrammer if you follow just one of the tracks). All kinds of different things you can try in whatever language. It's what I use to practice... or did, until one prompt on there inspired me to work on this massive side project...
vee and pee on semaphores
Start learning about the Robot class. A simple but useful one would be make a class using a robot to move the mouse to a certain pixel on the screen and click. Virtual robots seem like a good thing to start learning about asap and trust me its pretty basic. Next learn threading, try starting a single official thread, then try multi threading. Use stackoverload.com as much as you can. 
I'm not sure I'm going to find time to take it further. Code generation can work up to about 10-tuples but then you run into class and method size limits.
I think learning about design patterns is a great help too if you're not already familiar with any of them. I'm on my phone, so I'll have to provide a link later, but there is a gentleman on YouTube with great tutorials on software design patterns. Two common ones that are very useful are the Bridge Pattern and the Strategy Pattern. As far as Threaded programs go, I'd say try to write a program to simulate bank transactions. Learning how to prevent Deadlock and data loss and so forth.
I am not a big fan of coding puzzles to improve your actual skills as a developer. So my tip would be: Find a general problem **you** have and solve it with a program. Just think of things you usually do manually or that just take a long time.
Sure, but the first hit for "java generics faq" is a monster. I'm just saying that for Java the costs outweigh the benefits. I don't know the Scala type system, but I have done a bit of Haskell which was very interesting. Interestingly I've heard of Scala coders complaining that they end up with workmates who cast everything to whatever the most permissive type is to get around the error messages. Having no experience with Scala I can't judge the cost/benefit ratio but I'm quite convinced for Java that it wasn't worth it.
That's a great mnemonic, thanks.
&gt; Admittedly, it is a bit math oriented This to my mind is one of its strengths because it forces you to think very carefully about algorithms and data structures, although I do agree, sometimes you have to have a pretty good understanding of the maths in some of the problems in order to be able to develop an efficient algorithm.
Without a doubt HP is still offers the best and most complete testing solution out there.
These sites should give you enough material to practice. https://projecteuler.net/ http://programmingbydoing.com/ http://codingbat.com/ http://www.programmr.com/index.php?q=zone/java http://www.codeabbey.com/index/task_list https://www.reddit.com/r/dailyprogrammer
We use pure Java EE in production, are we really one of the few? Also: Official "production support" is highly overrated, it's perfectly fine to use Glassfish/Payara or Wildfly in production.
In my experience, it also helps if you want to go beyond all the copy-paste code slash library use that is mainstream Java usage. Don't get me wrong, I'm using Java professionally since 1999, and worked for both academia and corporations - 80-95% of Java usage is glueing existing building blocks together.
Just imagine if there was no Java EE. Never existed. It would mean that spring would have a monopoly on Java enterprise development, Much to their delight! So, they will post blogs like this, to dis and instil doubt about Java EE at every opportunity. Well, they would - Java EE is a competitor. Pivotal are as bad as Microsoft. 
This is like an anti-Linux post on a Microsoft blog.
Notice how in the article they specifically don't mention Payara which has commercial support.
Well. Basically HP provides a programmatically interface to the UFT. It is something that they should have done years ago. The question is, I think, if most of the services that I get are from a free testing frameworks like TestNG, JUnit, MSTest or NUnit and from my IDE, why should I pay so much money to HP if all I get from them is a tool that recognizes and perform actions on Windows GUI components. I think that they are trying to make the product more like Selenium WebDriver, but they forget that what is right for an open source tool is not always what we expect from a commercial and expensive solution.
If the line of business is one that requires security audits and 3rd party certification, such as PCI, using a non-production application server might be flagged as problem. Larger organizations also tend to like the comfort (read: finger pointing ability) of having commercial support contracts for infrastructure platforms.
Set the scope to "test" then
pictorial description, I liked it
And that is what programming should be and it is not exclusive for Java. Classes are made of methods and data (primitives and other classes), libraries are made of classes, frameworks are made of libraries etc. I would always advise new commers to read some source code and study it. Mainstream open source projects, as OpenJDK, are good sources for code quality.
If you would like to learn Java and multithreading (concurrency) Effective Java and Java Concurrency in Practice are must reads. They have very nice code snippets, too. However if you want to try something big, then you may read source codes of some mainstream open source projects, take a look at Tomcat's source for example.
www.hackerrank.com
Extra funny btw that this is posted while we still have the following post on the first page of /r/java http://www.reddit.com/r/java/comments/38e9px/hitachi_cosminexus_now_java_ee_7_compatible/ :X
I don't think there's any problem with larger organizations that require heavy certification or support contracts lagging a couple years behind. When I've designed architecture for these kinds of companies I've specifically stayed away from the "latest and greatest" precisely because tech that's been out there a couple years has had all the bugs worked out of it. In fact that these platforms do lag behind so much might indicate that their customers aren't clamoring for the latest and greatest, but rather are more interested in long term stability. 
GWT -ext is still used a lot in business. It is not totally abandoned.
Apache Tika?
I came in here to say don't try to parse a PDF. But since it looks like you have no choice, when I had to parse a PDF in the past, I converted it to HTML and then scraped it with the Beautiful Soup package in Python. It was pretty ugly but it got the job done, I'm hoping someone can tell me I'm an idiot and that there's a much easier way to do it, because it was a little tedious to do. If it helps, the PDF I scraped was a University Course Registrar so it was in table-like format. 
1) What's a class? 2) What has stuff and functionality?
I will share more information in my next blog 
I do not get why the owners of Spring are always so hostile towards the Java community. Hibernate is a great example of a framework that worked with the community and helped drive the standard.
Derek Banas?
&gt; In our quest for Java EE integration, we’re trying to actively embrace the latest generation of specifications such as JPA, Bean Validation and of course the Servlet and JMS APIs. As of Spring 4, we’re supporting the Java EE 6 and 7 level of specifications side by side. Or they're actively supporting it. The article is about why they're retaining compatibility with EE6 in Spring 5 while requiring JDK8.
tl;dr Spring says they're retaining compatibility with EE6 because vendors are slow to jump on EE7.
It might still be used, but last release was in 2008. So the GWT-Ext project itself is abandoned and obsolete. And if I had a business project that is still using it (I worked a project with GWT-Ext in ~2009-2010) I'd be looking to migrate to something else ASAP and nagging management about it.
Also, Oracle mentioned a couple of times it will be WebLogic 12.2.1, just shows how up to date this Juergen is.
No, vendors aren't particularly slow to jump on EE 7. Most have jumped on it already, but not everyone has a stable release out. Not jumped on implies that vendors have not even started looking at EE 7, which is completely wrong.
Hah: http://payara.co.uk/java_ee_7_doing_fine_in_production_this_spring
A five meg file. To do machine learning. The horror.
That doesn't contradict anything I said. Are you under the impression it does?
So they have very good reasons not to require Java EE 7.
why cant we all be friends :(
No. it wasn't a Nelson from the Simpson's style Hah hahhhh directed at you...it was a laugh at Payara reacting to it so quickly.
Its hard to learn for beginners, there are numerous different ways to accomplish the same thing. Over engineered and all encompassing. its become what it was originally a reaction, there is a bunch of new lightweight frameworks that I prefer. Its core principle was dependency injection, but thats so far removed from what it offers now. I find it so much easier to just roll my functionality instead of using one of the spring implementations, DefaultUserSecurityTokenProviderFactory or whatever. 
But you aren't creating multiple instances of the DAO's inside of your service, nor are you creating multiple instances of your services inside of your application. They are both singletons.
Not sure why I'm being downvoted for that comment, but I agree with you.
To Spring Boot?
All good points, but I don't think that necessarily means that Spring is going away any time soon. The type of person who hangs out in /r/java is going to be aware of and eager to try simpler frameworks as they come up, but most programmers just use what's popular or already in use on their projects, and that means Spring and JEE will be around for a long time. Also, Spring is taking steps to simplify some of the things mentioned here, especially with Boot. It's hard to provide so much functionality and also be super-simple at the same time. FWIW, I've really had a lot of fun using Grails on projects lately because it hides a lot of the Spring complexity from you while still offering powerful features from the underlying framework.
I am not sure either. I am equally surprised to see that agreeing with me is upvoted. :)
I'm sure there is some additional complexity added, but it seems like an elegant implementation. Are there any other downsides other than additional complexity and database storage? How about the fact that the db and object model are now different?
Not saying it's disappearing, but people have started migrating away... The first step. The other thing I don't like is the insanely deep exception traces, which end up at a proxy, that was built using complex reflection. Which causes an error, because I am using version x of something which is not compatible with version y of something else. No annotations (well fewer at least), no reflection, one way to implement things please. Dagger looks very interesting. They provide functionality, but they provide it in weird ways and it can be implemented in different ways as well. Each sub project is run by different people and some often break with new versions. I used to be a spring zealot, then it slowly dawned on me that it's all over blown and needlessly complex. I have no desire to use it again. 
How do you start your apps normally?
I probably should have just done a top level reply with the link...
Not at the bank I work for, open source is encouraged. 
lol well it is when it's gotta be spun up hundreds of times a day
There's one team in my company who is hardcore spring. The rest of us have moved to Wildfly. I feel like Java EE gives basically all the features Spring does with less dependency management. I guess I do see the advantages of bundling and launching a jar but I think Wildfly Swarm will allow for that soon enough. 
What do you dislike about spring, and how does Java EE fix it if it does? Also what other frameworks do you use?
Large companies still seem to prefer Spring tho.
For me it's been partially the other way around. Didn't work for a single shop that choose Spring. Each and every one from 2002 till now choose Java EE. That said, I too haven't seen a single shop that used JEE. Mind if I asked what JEE is? I've never heard of it.
When was the last time you tried it? I have never seen a Spring application that looks cleaner than a modern Java EE one.
I dislike all of the extra configuration required compared to Java EE. I do not like the lack of documentation or standard ways of doing things. I do not like the big learning curve for new developers. I dislike its lack of web components forcing developers to reinvent the wheel over and over again. I do not like the extremely long and cryptic error messages it creates in the logs. Basically it just takes more developer hours and frustration to do things that are simple in Java EE. I do not like the complicated web of dependencies it creates. You cannot even use Spring without Maven because it is impossible to figure out. There is plenty more but it is hard to put it in a simple post. Basically it adds a lot of complexity but no real gain for most development. I do believe there are probably some niche uses where is makes sense though. 
&gt; I have never seen a Spring application that looks cleaner than a modern Java EE one. When was the last time you tried Spring?
Your describing my experience with JavaEE
Wildfly has been stable for a while, IMO. It's just a rebranding of JBoss. Swarm is definitely in alpha but my main use case would be as a test service replacement to not have to use Arquillian. From there I'd see how it plays out to determine if I want to consider it for some future production usage. I don't really see the pain argument. I'm mainly building REST endpoints for internal backend services but CDI, Executor services, and Infinispan work with pretty minimal config. My main gripe is testing, ATM, and I think swarm could help. 
Do some of the Spring Boot 15 minute examples
https://spring.io/guides/gs/spring-boot/
But that's why one is _called_ Set and the other Collection - the distinction lies within the formal definition of each. The "guarantee" (as much as we can guarantee anything with an interface, which is nothing more than an outline of a contract) is implied by the name itself - if I call something a Set, I "promise" to implement it to follow the Set rules (unordered, unique elements). That comment you linked sounds a bit... weird :] That's the whole point of abstraction - even if the caller uses the same API for both structures, I can be (reasonably) sure that their internal implementation satisfies the rules by which they are defined. In this case, a method that takes a Collection and manipulates its elements does not need to worry about checking for duplicates or sorting or anything that can depend on an individual case - it relies on the "promise" that whatever type of Collection the caller provides, is going to be implemented in a way that preserves its integrity. or am I misunderstanding your question
Thanks! Indeed it was, I learned quite a bit through trial and error. Although, I feel I should read more about lexers and the sort. Maybe not so much choking on bad data as lazily throwing exceptions with vague messages... Very intuitive! I'll be writing up proper error handling shortly, as I'd like to make this into a handy (and viable) little tool.
Thanks
I would go so far as to say the request for an interface that is unique to set sounds like it would be from someone who doesn't know these data structures as has no desire to learn it before using it.
The best way to get started is to implement a system that you've already experienced and well familiar in real life. Anything like school / college management system, lecture scheduling etc, would be a good place to start. Cheers!
When you're just starting out (with OOP in particular), it's hard to come up with something fun. Like /u/ThalaDa said, modeling is really the most basic form of OOP. Class schedules, car parts, solar systems, etc. are all good practice. Until you grasp more advanced concepts like inheritance and polymorphism, OOP's feels kind of silly. I wouldn't recommend Android like /u/wuddersup, because its objects are much more complex. You seem to want to specifically learn OOP. Working on Android is going to teach you how to make apps, which is fun, but you're going to do so by abusing objects you don't understand. When I learned Java in high school, we used [GridWorld](http://apcentral.collegeboard.com/apc/public/courses/teachers_corner/151155.html), which might also be something to try. At the very least, there's a ton of documentation and it's designed for beginners. Under the hood, however, you're learning to write objects. Might not be so good for learning interface design, though.
In my opinion, this is a very good idea and could be a useful programming tool. But in my experience most programmers don't like tools like this, they prefer to use IDEs that quickly generate code for them in a visual way, with a fancy graphical user interface. 
Hey, don't down vote this guy for airing his opinion. Be nice, if you disagree, air your own opinion.
You're describing my experience with Spring. I made many full apps using JSF and PrimeFaces, and it was the best experience ever.
And where do you work, for Pivotal, SpringSource, or VMWare? Or, is that you, Rod? Is that really you? So nice to meet again! :)
Again? Have a look at these submissions: http://www.reddit.com/r/java/search?q=project+idea&amp;sort=new&amp;restrict_sr=on&amp;t=all. Same search over at /r/Javahelp: http://www.reddit.com/r/javahelp/search?q=project+idea&amp;sort=new&amp;restrict_sr=on&amp;t=all Some highlights: * For beginners, [here's a link](http://www.reddit.com/r/java/comments/369dl1/project_suggestions/crbwhw4) to a *huge* list of ideas for small projects, sorted by topic. * Related subreddits: /r/programmingprompts, /r/dailyprogrammer * Project "challanges": http://www.codeabbey.com 
I disagree entirely, but seeing as you seem to have more experience with JSF. I am confused about with just. how do you distribute load? Given I expect 5,000 users to be present on a site at anyone time how would you deal with spreading the load across multiple servers? That's one of the things that puts me off the JavaEE stack.
Create a scoring board for any game of your interest, baseball, bowling, golf, etc. First start with command line inputs (you usually will have created some interfaces by this point). Then when everything is ready and you're interested to write a gui, take your code base and change the input and output to your gui, you will need to create some interfaces here again, so that your programm now works with literally two interfaces.
Why should I use this over Jython? Which also means that you can use many pure python modules in your code if you so desire. (As I understand it, any python module that doesn't have any native components should be usable)
You're right, IDEs do provide a lot more tools than a simple translator would.
That's something I could never do in the workplace. What do you work on?
you could never use an ide at work ? java ee.
Why not just use Scala?
&gt; I love Java, but sometimes it's too verbose. I also don't like to write boilerplate code. That is what frameworks like Spring are for. If you can get past the lousy documentation and educational materials for Spring, it does accomplish on reducing verboisity and boiler plate code.
You can put Java objects and classes right into Jython. Write Python where you want Python and Java when you want Java. Then they can call each other. 
What kind of company and what kind of projects? I'm genuinely curious.
&gt; OP is using Python to generate Java code It's not generated though. It's a library that emulates Python's features, without Python involved anywhere. It's actually pretty neat. Some of these features are such a common need (like memoization or opening a fucking file!), that one ends up making utility methods anyway. Might as well model after Python then.
Are you kidding me? Spring is the plain definition of boiler plate code.
How do you start your app server? Answer: command line.
The only Gradle that I know in the Java world is the build system (https://gradle.org/). Don't you mean Guava (https://github.com/google/guava)?
No. I meant Groovy. Thanks for the heads up. 
ah... but he started with "in my opinion" and then used a very questionable "in my experience" to make a statement that sounds very demeaning... It's not very useful and somewhat inflammatory. *Oh, look at me, they want fancy... I'm better* In my opinion, Downvotes are fair edit: oh, but my post got downvoted and it's my opinion... So my point is proven. You guys are contradicting yourselves.
Sorry, I just didn't want to get more similar comments from people who wouldn't have read your reply :)
You sound like someone who has used only Spring for a Iong time. Back in 2002 Spring was a simpler option. Today it requires a lot more boilerplate and configuration than Java EE.
It's kind of silly/out of context to ask someone why they wouldn't just use another language when it isn't even directly related to the topic. I see you like compiled and/or JVM languages. Why don't you use Clojure? Why not Rust? 
Losing*
I know thats not the point I was making. I am happy to do lots of stuff from the command line. But with spring boot, last time I tried it, the first step of development was on the command line, which I found weird.
I second this. If you want the JVM, just use jython.
This is pretty cool, but I don't see how useful it is.
Because Scala is absolutely nothing like Python and what OP appears to want is Pythonic programming in the Java language.
Simply because a lot of the things Python offers that can be emulated in a library such as this are already built in to both Scala the language and the standard Scala library. If you want a better Java and stay on the JDK and not lose but gain in type safety, simply use Scala. It's already there, it's well tested, stable (unless of course you use bleeding edge features which usually in an "enterprise" environment you don't) and instead of a "half measures" solution you can stay 100% focused on transforming your thought process to code, instead of fighting with the language. Of course you can use any other JDK language as well, including Clojure, and surely you'll get a massive productivity boost in a JVM codebase and environment, but Scala has the benefit in it's syntax, which is both close to Java and also at least a tiny bit similar to other currently popular languages like Python or Ruby so it's easier to learn. A big advantage over the other JVM languages however is that it embraces type safety while minimising the amount of "ceremony" code that you need to write to remain type safe. 
Groovy has similar advantages to Python in that it radically reduces boilerplate and the Groovy JDK makes the JDK classes much more pleasant to work with, e.g. you can read a file with String content = new File('/tmp/foo.txt').text as opposed to all the messing about you have do with readers/streams in Java. However, OP seems to want to achieve this without switching to another language. Personally, I don't think this is a goal worth pursuing. There are several mature JVM languages that are much more concise than Java. Using one of those seems like a better idea than trying to shoehorn Python into the Java language
As I mentioned above there are situations when you have no choice but to use Java. In most private companies you cannot choose the language (and most of the time it's totally justified). This is why I programmed xpresso. 
I don't know any Python. Is there a library that does the opposite? Also, why would I need to? It's a language, like English or French. I mean I suppose because they're built on different platforms and stuff and they're sort of an arbitrary notation and sort of not...
Scala it's another language running in the JVM. xpresso it's just a normal library for Java.
An insurance company. Most of our systems were internally developed. Edit - some examples, member/contract management, claims, finance/billing, rating. We have both .NET and Java. We utilize Java batch quite heavily. Although we are migrating to compute intensive work because we really haven't used the recovery and restart features of the framework. We actually have quite a bit of Cobol too, but that is being rewritten in Java as new requirements are needed.
Valid concern. But even spring core or hibernate hides basic things like low level use of datasources to avoid connection leaks. Really, any high level programming language will obscure low level details. Does that make us worse programmers? Not really. Spring Boot is just one step up. A very common step is languages other than Java. Ruby, etc. In academia we all learned assembler or something similar so we appreciate the details, but it isn't really required in a normal job.
For debugging/profiling purposes that are close to the system-level, Solaris might come in really handy with dtrace. But it doesn't seem that Oracle stands behind Solaris as much as Sun did. So, for development, go with whatever you like, you're most comfortable with and lets you run your tools smoothly. 
This really isn't that pythonic, it's really just a fairly difficult to read wrapper over some annoying Java boiler plate, using inconsistent semantics that will make your Java code look a bit awkward. For example the `x` class. Just import static the things you want and make the class name actually descriptive. If you really want to emulate pythonic things, like open, then your open static method should be a class that implements auto closeable allowing thinks like: #python with open(myfile) as f: f.readline() #java try (HappyFile f = new Open(myfile)) { } Still, a bit awkward, but more resembling how you usually should use the file goodies. Edit: Added `new`, which makes it look even less pythonic. This could be a statically imported function that returns an auto-closable class I think (happy file?). Though I can't confirm that ATM. Looks like you implemented that though, nice work.
I have about 20 years in as a Unix systems guy and have worked with Solaris on more than one occasion. I'd pick Linux. It's much easier to administer and find employees to work with. There's low/no cost options for it so from an architecture point of view my only real cost is hardware. If I have a $100k hardware budget I can put that $100k on 4 systems or 40 with Linux and I don't have to worry about OS licensing as much. In regards to developers, as an admin my preference is that you target a VM whenever possible. I don't care if it's Xen, KVM, VMWare, Hyper-V, Docker or whatever. I do care that I can take images from prod, QA and dev and easily bounce them back and forth between environments. So if there are issues in prod I can just snapshot and push a prod image to QA and when dev releases a big revision I can just snapshot dev, push the server image through QA, test, then take the image and push into prod for release. The above also has the benefit that as a dev they can work in any environment(Windows, Linux, Mac) and just build to a local copy of the VM. 
But there's no value add there. Let the java expert work on java code with java paradigms, not python. You get the value add if the java expert can work on python code with java paradigms.
Wow thank you! I'd love to use it for rapid prototyping an android app.
&gt; Its hard to learn for beginners, there are numerous different ways to accomplish the same thing. Over engineered and all encompassing. Hasn't that been the case for most full-featured Java frameworks?
great point, thanks! I just implemented this.
I am perfectly able, thanks. I don't like being forced to when it is counter to all my other work.
That final python comment is absolutely incorrect. Python is production tool in a huge amount of companies, organizations and institutions 
STS (Eclipse plugin) has great Spring Boot support, you don't need to use command line at all.
We're Dockerizing our new apps at my company, and my team's SRE is basically jizzing every time he talks about Docker. I'm excited too, just not as much as he is.
This is a pretty cool hobby project. I do think its fun to do things just "to see if you can". But while its cool... I really don't see it being used in any production/scale capacity. Here's why: - A good Java IDE handles 90% of the verbosity of which you speak... and even if it doesn't its mostly 2nd nature anyway. A bulk of a developer's time does not go into this... it goes into planning, designing, debugging, testing. I don't see this helping with any of those things, and actually makes some of them more difficult. - Java is not python. Shocker I know. But Python has its benefits. Java has its benefits. Asking a developer to use the best tool for the job is not an inconvenience... its an expectation. - Adding syntactic sugar over Java does more harm than good. If I was on a team of mostly Java devs and we had 1 Python guy using this, I'd be absolutely pissed. Its adding another layer in which things can break, makes it less Java-like (even if Java is verbose... its easy for a Java dev to understand and skim over the verbosity), which would make it more difficult to understand and debug. - KISS principle (keep it simple, stupid)... this adds extra unnecessary layers over Java, making it more complex and confusing. That said... looks cool and congrats.
To be fair, I don't even see this saving much boilerplate code. So I don't even think that statement is accurate. - Instead of using methods on the String class... you create a str object. That has largely the same methods, just with python names instead of java. - x.print is just System.out.println. In intellij i just type "sout" and hit tab and it does the same thing. So IDEs can definitely give you shortcuts like these. - The only thing I see that actually reduces boilerplate is Open. But that is already handled by using apache commons or gauva, but those libraries have a lot of other useful methods as well.
That makes it sound like you haven't used Spring in a while either. After using Java EE and Spring... Neither is much easier to use than the other. Spring configs have come a very very very long way.
It was over a year ago, but I saw a demo of Groovy. I recall you can use it mixed in with Java code, just by including a library. So it seems similar if I remember correctly. Include a library, have the option of writing some things in a briefer way. 
src: http://linuxfr.org/news/modernisez-votre-code-java-en-un-clic-avec-autorefactor-v1-0-0 http://autorefactor.org/ "After years working in different large code bases, I (Jean-Noël Rouvignac) got tired of spending too much time applying the same code cleanups again and again. In addition, tools like SonarQube™ (aggregating FindBugs™, Checkstyle and PMD) are fantastic, but they do not not help fix the thousand warnings you can find in legacy code bases. "
There was a time when I would've said Solaris. To this day, it is a rock solid platform with a lot of great features. But, once Oracle purchased Sun and de-open sourced it, that was the end. I remember ordering Solaris 7 in college. That was the first time Sun made it available for free. I ran it on my home-built x86 box and it was great. I used Solaris at home for development up through Solaris 9. Solaris 10 and beyond are great, but the cost far outweighs the benefits. You would be better off with Linux at this point. 
Summed up as &gt;We are therefore publicly announcing that we are now changing our target time frame for the completion of [Java EE 8] to the first half of 2017.
Thanks for explaining the things in the right way, I could not do it better !
I really don't see much in the readme that I can't already do in guava. While there are some nice little things (negative indices), I'd personally rather see a library that implements these things in more natural java way instead of using python keywords. But by all means, keep evolving it and post updates here. Maybe it'll motivate me to write a similar one in guava-esque syntax :-)
The point I was trying to make is that moving from one Java EE vendor to the other may require a small amount of work, but ultimately it's negligible. If you have to move away from Spring, for instance because you don't longer agree with the direction the company is going in, some political reason, or whatever, you can't just go to another Spring. There IS no other Spring. .NET was just an example. It may be Play! or RoR, of anything else really. 
Because it pollutes your namespace pretty heavily and chances of collision go up a lot. Plus unless the context is obvious (unit test etc) a static import gets rid of a lot of context provided by the class name. Chances of collision for methods like get, print etc are way higher than chances for collision of a class name like x
&gt; How do you start your app server? Answer: command line. Eclipse: * Code Java EE app * Click run (on server) * [server starts] * Test &amp; debug all you like
Really scraping the barrel here aren't we.
This is the only good reason for this project.
Haha. Absolutely. Ide add: For production: the one the JVM runs best on. For developing/daily use: the one that has the best tools. 
I start my app servers and servlet containers using either Eclipse, NetBeans, or IntelliJ when I'm developing.
I'm a bit dense, but to me it seems that the type constraint is only relevant if randomHash is used as a LongHasher. In which case the compiler will scream anyways if the sig doesn't match. What am i missing? Summoning /u/lukaseder. Edit: refactoring would be a use case i guess. But other than that? Edit: also, /u/based2 is a bot O_o
Java 8 is a significant step forward in terms of reducing boilerplate, for example, processing collections is much more concise thanks to the introduction of lambdas, and the changes to the Java collections libraries that take advantage of them. However, even with the improvements introduced in Java 8, Groovy is still a vastly more concise language. For any given task, I reckon I could complete it half the time (or LOC), using Groovy instead of Java 8 (YMMV).
Don't forget that other things implement Collection as well: List&lt;E&gt;. Mathematically, you'd do well to note that any collection of values is technically a set, but a set proper will not have duplicates. That's why the two are so similar. 
Linux -- because a new application is almost certainly to be run in a virtual container or in the cloud. Solaris as a guest OS is fairly rare. Linux as a guest OS is what to expect by default. (Most of your Java code won't care obviously, but it's still a good idea to develop on Linux if you expect to deploy on Linux exclusively)
Linux. Why use Solaris? What is your application?
&gt; I love Java, but sometimes it's too verbose. I also don't like to write boilerplate code. Why not just learn Scala?
None that I've personally had to use, as a dev. I'm not sure if our SRE is using any 3rd-party tools, or if he's writing his own python scripts to manage things.
Probably intended as an early warning signal for those providing implementations for others to use, so libraries etc. I'm probably betting against it getting in though. 
I think most people would offer the LongHasher as a constant, if this was a concern. public static final LongHasher XOR = LongHashses::xorHash; It's not clear to me how ReferenceableAs would interact with non-static methods. interface Foo { Bar bar(); } Foo instance = ...; Function&lt;Foo, Bar&gt; a = Foo::bar; Supplier&lt;Bar&gt; b = instance::bar; What happens if the author annotates the bar() method with ReferenceableAs(Supplier.class)? Does that compile?
At least 1$ and a pint of beer, should we ever meet.
Great! I've been looking for something like this since Google announced (but didn't release yet) their Refaster.
why not jython ;)
The first example regarding braces is awesome, but some of the other ones, like CollapseIfStatements, show questionable refactoring, with loss of comments and blind merging of if conditions that were likely separated for better readability. I do specifically split long if conditions into multiple if conditions sometimes to aid readability. The most efficient expression of code in terms of letters and lines is not the most efficient expression for reading and editing. Also there are various transforms that are purely stylistic. I would suggest that hammering the codebase with stylistic edits is a very counterproductive thing to do as it makes it hard to see how productive code changes have evolved from before the style update and after the style update (diffing a commit before/after becomes so full of noise as to be useless). Style updates in commits are necessary at times, but they're best kept local and rare. Another example: CommonIfInIfElseSample and others, ignores that boolean conditions can have different computational cost, and sometimes one if check is a guard for a more computationally expensive if check. Changing their order ruins the purpose of the code. Not to mention an if check may have side effects, so their order can't be safely swapped automatically. It's still great to have a tool like that, if you still intend to manually inspect every line of the output for regressions. Can't completely eliminate the human, because only the human knows the purpose of the code.
Lol, no. Take the Java track if you want to learn Java. If you are smart enough to learn Java in a week after taking the C# track then you'd be further along with Java if you focus all your time on it. 
I may be wrong here as I have no industry experience but if I had a company that used Java as its development language and someone using Xpresso just because they prefer to use Python, I don't think I would be happy with them using it. Even if everyone on the current project is happy to do so, this would have a huge impact on future maintainability. Anyone joining the project at a later point would have been hired as a Java dev but for that project only would be expected to move to Python. This appears to have little added benefit for the company either. 
It's not even in Java.
Yes, but it is rather silly to do if you want to develop Java anyways. Teacher isn't that in programming anyways. You're the one that has to do the work, he can only show the way.
That really explains variance, not wild cards...
OP needs more Spock and less J*.
Maybe I was a bit too blunt, but I definitely don't like that validateRequest is called on every single request (even for static files if you have some) and of course the factory-factory-factory-provider-config-builder anti-pattern is pretty unusable. And the callbacks are a strange idea and.. well I could go on. The idea of JASPIC is pretty good and I do use it, but it needs to mature to be usable in the common scenarios we have today so I'm glad they're working on this.
Why not just use bintray? Also, as far as I understand, hosting maven artifacts on github pages violates the terms of service.
&gt; but I definitely don't like that validateRequest is called on every single request This is IMHO one of the best features of JASPIC. It enables pre-emptive authentication and stateless authentication. I agree that you should be able to say that your authentication module should only be called in certain situations. I would most want to see an option to only have the module called when there is no active authentication and indeed an option to exclude certain URL patterns and to exclude certain mappings. I'm sure that the Servlet container knows before it calls an authentication module what type of mapping it applied to the request (e.g. prefix matching, default mapping etc). Static resources are almost always default mapping (static resources are handled by the default servlet in most servlet containers). So if you could say that authentication modules should NOT be invoked for default mapping, then they will not be called for static resources. If that doesn't work, then the pattern should help you. &gt;factory-factory-factory-provider-config-builder anti-pattern is pretty unusable. 100% agree. This is nonsense that you program once, hide away in a utility method that just accepts a SAM class and then NEVER look at again. Every Java EE project that I've seen that used JASPIC created that same nonsense utility method. Some quick Googling revealed that every other blog and open source project does the same thing. JASPIC or Servlet or Java EE should provide this (and an annotation and maybe optionally a web.xml entry). &gt;And the callbacks are a strange idea and.. well I could go on. This is the low level universal method inherited from JAAS. I hate them too, but I understand why they used it. It makes the API universally extendible without adding much API methods. Just new callbacks, which can be vendor specific even. But in a user friendly API that's specific for web applications you should just have descriptive and discoverable API methods. The link that was shown above does uses these: httpMsgContext.notifyContainerAboutLogin( tokenAuthenticator.getUserName(), tokenAuthenticator.getApplicationRoles()); &gt;but it needs to mature to be usable in the common scenarios we have today so I'm glad they're working on this. Maybe not only mature, but a higher level usability layer should be provided. My take is that JASPIC as we have it now should have been present in J2EE 1.4. If you look at the JSR page (https://www.jcp.org/en/jsr/detail?id=196) this was the idea indeed. For reasons that Sun/Oracle never made clear it was put on ice till 2005 and then it progressed very slowly until it was finally included in Java EE 6. Then Java EE 7 only did a very small MR. But happy too that EE 8 is now finally working on it ;) 
I don't like questions where you show an obviously bad example and ask people the output of something that should never be allowed to exist. The only way to find out if someone is an "expert" is by talking to them, not by letting them fill in cutesy exercises like a chimpanzee trying to get the banana. I do interviews and my experience is: With two experts in the room, an interesting conversation about Java should happen within 10 minutes (after pleasantries and some obligatory introductory stuff), like "hey, what did you think about Java dropping JSON improvements for Java 9?" or "did you see that new security API for Java EE 8?" or "the new Money API is really awful, isn't it?" If that doesn't happen, there is at least one in the room who isn't an expert. I call myself an expert because my work requires a solid understanding of a large portion of the Java ecosystem: JAX-RS, JAX-WS, JAXB, JPA, JASPIC, JSON/GSON etc.. I also call myself an expert because I make real world Java EE applications for paying customers, not homebrew apps or side projects no one ever uses. I also call myself an expert because I partake in yearly hackathon sessions to test and validate my integration software. I'm not saying that I know every nook and cranny of the language and framework, I don't, but that isn't necessary to write working code that doesn't suck.
Absolutely, I just deployed a gradle plugin to jcenter and was really impressed with how easy it was. I suspect however that whatever the underlying reason for not deploying to maven central is involved, the only explanation for not doing that was: &gt; Option 1 involves signing up with Sonatype for access (something that is possible in the future once we become more stable and established)
Does it scale horizontally? Shouldn't you design your system so that the # of hosts is the limiting factor, where you can add arbitrarily many of them? 
Nice after the fact edit but downvote me anyway small penis loser.
New user + unhelpful title = no way I'm clicking that link. At least add a comment explaining what the site is about, which aspects of Java it explores, etc. 
A lot of people in this post seem to talk about languages that are already made for the JVM and saying that they are the same thing. While I agree that Swift is quite similar to a lot of things I must say that this is not really what OP is asking. If we had a compiler which turned swift into Java bytecode (and supported it's linking towards C as JNIs, and probably also Java with the same syntax) we would really be looking at cross platform mobile development. It would mean that you could set up projects using Swift and as long as you kept the OS integration abstracted you could easily compile for both iOS and Android (probably even Blackberry and Windows Phone). I for one would image that Swift would be great running in the JVM. The problem lies in that even the Java bytecode is partially object oriented. This would mean that Swift code (which is only partially object oriented if I've understood things right) would have to have some translation over to OO. Not that it should be too hard though.
Oh, I wish I we were moving to WAS 8.5. We're staying on 8.0 for the long term...
I tried to run JDT in headless mode before: technically you can but it is.... rather awkward :)
As Swift 2 has been open sourced I think that a JVM version will appear soon. 
What do you mean? Could you describe a bit more the experience please? I think I'll have to do it someday, so I prefer to know where I am going :)
I have a déjà vu. Didn't Siebel also justify their existence when Salesforce trolled them? Siebel ended up with Oracle in the end. But where will Oracle end up in the end?
That's actually a pretty good list with examples.
And Spring was saying again?
"Your homework must be done by Friday, or I'm fired."
Who said they were standard questions? If you're an expert, I expect you to be an expert. Having lots of experience doesn't make you an expert. The take away is that overselling youself can, and frequently does backfire. Making a great resume is kind of an art. You want to talk yourself up while also being truthful. For 99% of people, saying they are experts in any language is probably a lie.
Well, perhaps they're more at a Siebel vs. Siebel level :)
intellij
&gt; As a Java developer i can't understand why it takes 2 years to release an EE version of Java 7. It doesn't take 2 years. By definition it's 0 days. The Java EE specification and the implementation of it are released together. Always. This is a requirement of the JCP process. Not all specifications have this. For example, with C++ it used to take some 10 years for the entire spec was implemented, and the process by which the C++ spec is created doesn't have a requirement to simultaneously release an implementation. 
I also used to love NetBeans, but after I tried out IntelliJ I haven't been back to NetBeans. So I would say IntelliJ even tho I haven't tried out any Spring stuff in it yet. But I don't see why it wouldn't work since there is plugings.
Used Intellij and Eclipse but not netbeans, in my opinion for spring it doesn't matter. For Java development in general I prefer Intellij over others, but haven't used Netbeans for quite a while.
To be fair though, it's hard to tell from that search. Spring - 14,376 Spring Mvc - 3,944 Java EE - 2,563 Java J2EE - 11,378 
There's nothing complicated about Spring. A bad programmer will mess up any tool he/she uses.
If you have an edu email address, IntelliJ ultimate is free. It supports great highlighting for annotations and jumping straight to dependencies and aspects.
As a Red Hatter, this person doesn't know what is really going on with Wildfly and Red Hat EAP. Typical FUD.
Properties really ought to have been a part of the language, as they have always been in C#. I get why the designers of Java chose to forgo things such as operator overriding, etc, but turning adding a **property** keyword would have seriously eliminated half of the Java code that's ever been written.
You have to include j2ee in the search
Here's the scenario: you're working on a legacy system at a company. Pre-dependency management with manual inclusion of JARs, etc. Some of these libraries were manually created, renamed, modified/forked, and therefore harder to track or version. (Yikes, I know). You're tasked with moving them to a dependency managed framework (maven, gradle, sbt, what have you). You've got some of the dependencies moved to your new framework, but there's still a ton more that are almost impossible to determine if they are actually in use because the application is a massive monolithic mound of mud (let's say 250+ JARs). How can you efficiently determine what dependencies are not in use, bar brute force removal and waiting for compilation or runtime failure? One idea, an app that logs class loading over a period of time (eg 24hrs of the app running in production). This would then be diffed against the entire collection of included dependencies to at least target possible removals. Maybe this could even be run as Java agent. Looking at New Relic the other day, I was wondering if this was something that they could even do since they track class loading/unloading in real-time.
 A lot of the transformations seemed to make the code less readable, or else they were fixing problems I've never seen in a production code base, such as foo = !!bar; I appreciate your efforts, but most of these seem to be fixing problems I don't think I've ever seen in the wild, especially the dead code elimination and so on. Have you ran into a lot of code like this? I'm not a fan of sweeping stylistic changes in legacy code bases either, since nothing good can seem to come from it. It's a political challenge since a) bugs will be blamed on it, b) it makes diffs more difficult (the year end processing worked last year, now it fails with this stack trace and we can't figure it out since 28500 lines of code were changed by Runcible with that damn refactor tool and c) in any quantifiable sense that your boss could explain to his boss, the code isn't really "better". By better, I mean less bugs, more features, more value to the business. 
Good packaging and deployment that jives with default native installer behaviours on all platforms.
tldr; use LongAccumulator over AtomicLong if all you need is add, multiply, min or max
Thank you!
I feel this is a lost argument in much of Java culture. Much of the java world is built on libraries, standardization, and practices. I've noticed a trend where people who become sick of such restrictions tend to leave the Java space; perhaps for Scala, Haskell, C++, or some other language. I agree with the article, but I think it's a losing argument. The number of times I've written a perfectly good and tested utility, only to be 'forced' to re-write my code to use an existing library is sickening. Even today, I wrote a simple class designed around a specific problem, only to be told I needed to have an interface and builder. Not because it helps our application, but rather because "that's how we always do things around here." I would have debated, except I know our architect-level person agrees with the other guy, therefore losing argument. It's nothing against Java the language, but I find it unfortunate that creativity of any kind is often shunned.
Could you elaborate more on the overall landscape of Java web dev (modern frameworks, tooling, etc.) I've read about things like JSF, Maven, and Hibernate which all seem to be relatively current frameworks.
that currently only does csv to POJO though. I'm currently working on a CsvWriter, there are some code that would work in the last build but not very user friendly yet and does not deal with String escaping yet. http://static.javadoc.io/org.simpleflatmapper/simpleFlatMapper/1.9.1/org/sfm/csv/CsvWriterBuilder.html 
&gt; there has got to be something simpler than this Have a look at [easy batch](http://www.easybatch.org/), it could be a simple solution for your use case as it processes data one record at a time as you want it. To write your Pojo to csv you can also use the CsvBeanWriter of [super CSV](http://super-csv.github.io/super-csv/writers.html). SimpleFlatMapper is also great as suggested by harmonicPersistence. Hope it helps :-)
No they are not exclusive. In fact, a lot of traditional MVC frameworks worked something like this: Request =&gt; Servlet =&gt; JSP In this Servlet would deal with Controller/Model parts and it would forward to JSP to render the page (do the "View" bit of the architecture). The reason you don't want to write everything in JSP, is the architectural principle of separation of concerns. And if you are doing design, this is IMO most important principle out there. Your components should do one thing and thing well. If you need to do 2 things, write two components and have them interact via an interface. Don't pile everything into one big bowl of mud. In traditional web architecture, the "things" to be done are mostly defined as: * Controler- decides what to do with a request and does it. * Model- stores the business data * View- displays the business data to the user. http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller JSP is designed to display data to the user- deal with View. While you can pile Control and Model bits in there as well, it's much better to have separate classes/components dealing with that. P.S. Why the downvotes on the question? It's a newbie question, but it's OK to ask them here and to answer them, no? --Coder
&gt; Is using both considered a bad practice? In contrast, using both (in the correct way) IS a best practice. Servlets and JSPs should be used together. Servlets as controllers and JSPs as view, following the MVC pattern. Servlets and JSPs are not competitors, they are complementary. &gt; JSPs allow for embedding Java into HTML Don't do that, this is the bad practice! Not because you can you should. The Servlet should populate a model that is rendered in the JSP. Make the servlet intelligent and the JSP stupid.
Reminds me when I had to implement new webservice calls in a legacy component, I wanted to do it using a Spring WebServiceTemplate as we did in all new components, with a benefit of not needing to configure another EJB 2.1 bean and overall much cleaner code. I was told to follow patterns, this component used somehow customized Axis 1.1, and one other shitty 15 years old framework, because it would be then theoretically easier to migrate everything into a new component if it looked the same. Few years later, I had to reimplement some of these new calls using WebServiceTemplate, because Axis created invalid requests which our backends would not accept. And I had to migrate the other framework because it leaked memory. I have heard that phrase "follow patterns" many times, and it always resulted in a shitty code and wasted time...
If it really adds benefit then sure. If you are just adding another dependency for little gain then no. It is also important that the application has some consistency. If the rest of it works one way it is not good to do one little part with another framework.
Ohmzar. You're spreading Spring propaganda. Really... Using Servlet 3 / annotations you can get most of what Spring provides.... and much more. For example, With Spring, Can you access a spring bean from your JSP, without it being specifically populated in the view Model by the controller? You can with Java EE/Servlets/JSP. This is a big deal - lets say you have a new common component that needs to be shown in most (but not all) of your pages - You would be forced to update all your view models in spring, and all the controllers. with Java EE/Servlet/JSP, you can just add the component to the JSP, or the Template JSP. job done! Actually, how is Spring handling templates nowerdays? - JSP doesn't appear to be part of Spring Boot by default. What's the recommended way? How do you send a custom error in Spring.... Say send a response code of 404, but together with a page which actually shows why 404 was sent? These are things that have frustrated the fuck out of me when using Spring. And why I avoid it like the plague. 
Jackson has a CSV module. Useful for the more complex data.
Spring is the big non-standard gorilla in the room! - If you use that, you can use anything - the windows are already broken!! However, for me personally, I try very hard to stick with the standards.... (appart from JPA, as I personally hate ORM!... Mybatis all the way!) I just looked at Sparkjava. Tell me. 1) How do you configure it to serve SSL enabled pages? 2) Is there any kind of database pooling 3) What about security, how to force access of certain pages to go through authentication. 4) JSP 2 Templating http://stackoverflow.com/questions/1296235/jsp-tricks-to-make-templating-easier OR.... is all of this you have to bolt onto Spark, to make it work like tomcat does out of the box....... And then if you get into larger projects, what about Dependency injection?...WebSockets? Messageing (JMS), and all the other goodies that a JAVA EE server would provide? 
A have added a few of these Jackson guides on my todo list, thanks for the suggestion. Eugen. 
Check out [JSP model 2 architecture](http://en.wikipedia.org/wiki/JSP_model_2_architecture)
&gt; configure another EJB 2.1 bean Hah, Fuck EJBs! &gt; because it would be then theoretically easier to migrate everything into a new component if it looked the same. Cringe! I feel there needs to be a term for that. "Tech-Debt Inheritance" 
That's a shame, and a sign of a bad software architect, IMHO. A good component is one that does its job cleanly, and as efficiently as necessary for the application, balancing the lowest level of effort against the known set of future risks. A *lot* of software architects completely ignore the economics of development; unused abstractions and interfaces take time to write and reduce comprehensibility. &gt; "Why the hell is there an interface and a factory when there's only ever one implementation? Oh... 'just in case'. " Those cost *money*, and ignore the fact that any dev environment worth it's salt is capable of refactoring in an interface in a few clicks *when it's needed*.
&gt; A lot of the transformations seemed to make the code less readable Which ones? `foo = !!bar;`, is definitely not something I have seen in production code. Even though it could easily happen when inlining methods or variables. I have added it to the test samples for completeness. I'd like to point out this is only one line of code extracted out of a few thousands of lines of test code. &amp;nbsp; &gt; I don't think I've ever seen in the wild, especially the dead code elimination and so on. Have you ran into a lot of code like this? Yes I did, but maybe not all of them. Again some of the dead code elimination changes were added for completeness. &amp;nbsp; &gt; I'm not a fan of sweeping stylistic changes in legacy code bases either, since nothing good can seem to come from it. Fair enough, if you are not confident with such tools, then I'd suggest you do not use them. &amp;nbsp; &gt; a) bugs will be blamed on it, AutoRefactor is just a tool. No one should directly commit to a version control system the results of running AutoRefactor. Ultimately, the developer committing the code change is responsible for what he commits, even if done automatically. If people want to blame, all they need is a scapegoat. &amp;nbsp; &gt; b) it makes diffs more difficult (the year end processing worked last year, now it fails with this stack trace and we can't figure it out since 28500 lines of code were changed by Runcible with that damn refactor tool IMO the tool is not to blame. There are two things that should prevent such problems: 1. here it shows a lack of unit tests. Any refactoring - automated or not - can introduce problems, unit tests are a means to increase confidence in having a working software. At worst, functional tests should catch these. 1. if you were to use AutoRefactor, I would suggest to do single purpose commits (after reviewing the changes done by the tool). You could also do commit changes by smaller chunks to avoid one big splash commits. This makes it more manageable when a problem arises. My experience so far with the tool is that when bugs were introduced after using AutoRefactor, it was because I added some manual changes in it. Again do single purpose commits. If the commits are small enough (you're using a version control system, right?) it is easy to bisect the change, find the culprit revision and finally fix the problem or revert the whole revision. Tools for bisecting exists for git, svn and probably others. I don't think diffing code bases to understand regressions is sensible. Using bisect tools is the way to go. &amp;nbsp; &gt; c) in any quantifiable sense that your boss could explain to his boss, the code isn't really "better". By better, I mean less bugs, more features, more value to the business. Again this not a problem of using a tool for refactoring or not. This is a problem with refactoring, or even worse: an organizational / managerial issue: Are you trusted for doing a good job or not? I have never seen any metrics that could ultimately show a pointy haired boss that yes, the code is better. Refactoring is supposed to reduce time to market for features, bug fixes, value for the business. By making changes easy to add in, it makes the whole code base easier to work with and it is faster to add changes to it. This does not happen over night and is more a healthy practice, like "doing some sport", "eat vegetables" that must be done in the long run. I am arguing that AutoRefactor fixes small issues/annoyances like these and let you think about bigger issues, bigger and better refactorings. I often find that by refactoring one piece, it is calling for more refactorings down the line. Because of these changes, I get a better understanding of what the code is doing, I retrofit the knowledge back in the code, which allow me to better understand it in turn, which calls for more refactoring, etc. Here are some useful references: - http://martinfowler.com/articles/preparatory-refactoring-example.html - http://martinfowler.com/articles/workflowsOfRefactoring
There are sooooo many things in our applications that are over-engineered, or abstract for no reason. As much as I've learned from him, I feel he's a better architect for a larger Enterprise company Unfortunately, my disagreements are almost always a losing battle, because our other Java-dev on the team simply repeats, and agrees with whatever the architect does/says, and enforces it in code-reviews. Even though I get scolded every time I "create something," I do it anyway. Not in a reinvent the wheel sense, but in a create a more appropriate wheel designed for a specific use-case. "No, use Wheel.class, never roll a custom solution when others already exist" "But we're trying to make a racecar, and those wheels are heavy." I feel the reason I am so much faster than most of my coworkers is because I never give up on creating, while they continue writing the same boring boiler-plate over and over and over. I don't care if I get passed up on promotions because of it, because that's what I think is best for my long term career and mental-health. &gt; unused abstractions and interfaces take time to write and reduce comprehensibility. I'm a huge fan of using abstraction/interfaces, when there's a use-case for an interface (a.k.a. multiple similar use-cases). If there's only a single implementation, and no obvious future use-case that you're planning on developing, an interface is usually a waste of space, making the code more difficult to navigate for no reason. Our previous app is littered with these interfaces. &gt; ignore the fact that any dev environment worth it's salt is capable of refactoring in an interface in a few clicks when it's needed. So true.
This is probably my number one pet peeve. All the extra work rarely helps if it does change in the future because it rarely changes the way we anticipate it to.
I thought this looked familiar: http://www.reddit.com/r/java/comments/38s8t8/java_ee_8_roadmap_update/
* Why are all the "urlynkd.com" submissions of yours written by the same author "Trigma"? Coincident? * How did you manage to do 33 Submissions in just 6 days?
Pojo to CSV? You can't go wrong with [uniVocity-parsers](http://www.univocity.com/pages/parsers-tutorial) and it provides some annotations that allow you to handle all sorts of complex situations: Simple example: class TestBean { // if the value parsed in the quantity column is "?" or "-", it will be replaced by null. @NullString(nulls = { "?", "-" }) // if a value resolves to null, it will be converted to the String "0". @Parsed(defaultNullRead = "0") private Integer quantity; // The attribute type defines which conversion will be executed when processing the value. @Trim @LowerCase // the value for the comments attribute is in the column at index 4 (0 is the first column, so this means fifth column in the file) @Parsed(index = 4) private String comments; // you can also explicitly give the name of a column in the file. @Parsed(field = "amount") private BigDecimal amount; @Trim @LowerCase // values "no", "n" and "null" will be converted to false; values "yes" and "y" will be converted to true @BooleanString(falseStrings = { "no", "n", "null" }, trueStrings = { "yes", "y" }) @Parsed private Boolean pending; } Now, to parse your CSV: BeanListProcessor&lt;TestBean&gt; rowProcessor = new BeanListProcessor&lt;TestBean&gt;(TestBean.class); CsvParserSettings parserSettings = new CsvParserSettings(); parserSettings.setRowProcessor(rowProcessor); parserSettings.setHeaderExtractionEnabled(true); // to get headers from the CSV CsvParser parser = new CsvParser(parserSettings); parser.parse(new FileReader(new File("path/to/file.csv"))); List&lt;TestBean&gt; beans = rowProcessor.getBeans(); And to write: CsvWriterSettings writerSettings = new CsvWriterSettings(); settings.setHeaders("amount", "pending", "date", "quantity", "comments"); settings.setRowWriterProcessor(new BeanWriterProcessor&lt;TestBean&gt;(TestBean.class)); CsvWriter writer = new CsvWriter(new FileWriter(new File("/your/file.csv")), writerSettings); writer.writeHeaders("); // writes a row with empty values (as nothing was set in the TestBean instance). writer.processRecord(new TestBean()); TestBean bean = new TestBean(); bean.setAmount(new BigDecimal("500.33")); bean.setComments("Blah,blah"); bean.setPending(false); bean.setQuantity(100); writer.processRecord(bean); 
&gt;So what is CUBA and how is it different from tools and frameworks already available out there? In short, it is a full stack framework based on a number of Java technologies: Spring, Vaadin, OpenJPA, Lucene, jBPM, Gradle, etc. However, using these (or similar) technologies separately still requires too much effort to develop complex applications, so CUBA introduces tight integration between them.
&gt;The organization likewise declared Java ME Embedded 8.1 **early get to, including backing** for ARM Cortex M3/M4 microcontrollers and an engineer sneak peak for Freescale FRDM K64 sheets with mbed backing. Upgraded Raspberry Pi backing is included also This is your best author?
Do you mean 'Sneak Peek'?
Yep and that's why I can't consider programming a form of engineering
a lot of our rest resources are done using org.restlet so we are already a little fragmented between that and jaxrs.
I don't disagree with the title of this post, but the whole article is tilting at windmills. See the post OP's comment thread on his blog. His rail against the original tweet by Siva is there: &gt; Siva says &gt; June 10, 2015 at 8:44 am &gt; &gt; Well done Thorben Janssen. &gt; &gt;Firstly, I think this is a kind of over reaction to my tweet. And most importantly you ignored the main point I was trying to say and highlighting what you interpreted from my tweet. Obviously it seems I didn’t properly put my point in 140 chars. So here I would like say it clearly what I mean by that statement. &gt; &gt;My tweet: “We should never expose DB entities as REST endpoints unless it is a TodoList app stage demo.” &gt; &gt;Here my main focus is “Not to expose DB entities as REST endpoints” but you seems to be completely focused on “NEVER” part. &gt; &gt;There is no “Silver bullet”, there is no “One size fits all” and there is no “Do this way ALWAYS” or “NEVER do this way” in Software Development. I know it and I follow that all the times. &gt; &gt;Now coming back to the point I was trying to convey “Exposing DB (JPA) entities directly as REST endpoints leads to mess”, here is why I said that. &gt; &gt;For simple apps where you have maximum of dozen or so entities and all you need is basic CRUD operations then just go with Spring Data REST or JPARS and expose your Entities as REST services and you are done. But if your app is not just mere CRUD operations on top of database tables and you have some complex business processes then “Directly exposing your DB entities as REST endpoints is bad idea”. &gt; &gt;Why is it a bad idea? let me explain. &gt; &gt;Suppose we have JPA entities with bi-directional relationships. Then we will encounter the following pain points if we directly expose entities as REST endpoints: &gt; &gt;1. If the JPA entity is associated with Session/EntityManager then it may go into circular reference which results in StackOverflow exception. &gt;If the entity is detached from Session then you will get famous LazyLoadingException. &gt; &gt;2. If you try to fix the above mentioned problem by using Jackson annotations like @JsonIgnore/@JsonIgnoreProperties etc then at first sight it looks fine. Then problems arises when you have to expose the same entity with child collections in one case and without child collections in another case. &gt; &gt;3. If you don’t want to expose some sensitive data like passwords, creditcard details etc then you may think of putting @JsonIgnore for those properties. &gt;But this will result in problems while you try to post the same sensitive fields because the binding process may ignore those fields as it see @JsonIgnore. &gt; &gt;4. Now think of performing validations for the same entity in different ways in different screens. For example to create a new entity the auto-generated primary key is not mandatory. But while updating the same entity primary key value is mandatory. &gt;In order to put these kind of validations we start adding bean validation groups annotations. &gt; &gt;Now it is the time to take a step back and look at the code and tell me how clean your code is and this is just beginning of the mess that we are going to create!! &gt; &gt;Let me re-iterate my point. It’s not you, even I will argue for hours and hours why we should NOT stick to one approach for all the cases. We should definitely choose our approach based on the requirement we have in our hand. &gt; &gt;Please don’t respond to a tweet with a lengthy blog entry without confirming “what you understood is really what the tweet author is really trying to say”. &gt; &gt;So here, I still stand on my words. Don’t expose your database JPA entites directly as REST endpoints unless it is a toy application or a CRUD wrapper on your database tables. &gt; &gt;I would like to appreciate your efforts putting weekly new letter which really helps me to find nice blog articles and your articles on JPA stuff. &gt;Looking for much more useful stuff on your blog. &gt; &gt;Cheers, &gt;Siva. There may be some crappy cargo-cult architects and designers out there and we should argue against dogmatic practices for their own sake, but the OP has made missing the point an art form on this one.
I agree with both. I have seen DB entities used for API, and generated API classes serialized in DB. Would not recommend.
Do you mean 'Sneak Peek'?
Do you mean 'Sneak Peek'?
I think JBoss tattletale gives some of that info but not all -&gt; lists of unused jars, etc. -&gt; http://tattletale.jboss.org/
Cheers, will take a look at this asap
To summarize some guy doesn't like Java EE or Spring evangelist because he is an evangelist for some little known other framework that he wants to drum up support for.
I follow your concern, but I was not advocating for wasteful rewrites. There are perfectly legitimate reasons to recreate features that are available in core or third-party libraries; sometimes necessary evils. In code that *you* control, code reuse is good... but sometimes there is code that other people can't or won't adapt to new requirements. Most frustrating is when this happens within a single team.
&gt; I feel he's a better architect for a larger Enterprise company Probably not. "Enterprise systems" need well defined rationalized interfaces between systems that make sense and that folks are willing to work to maintain for the simple reason that if they didn't, everything would grind to a halt. The overuse of interfaces, patterns, and using big "enterprise frameworks" everywhere without reason just leaves behind systems that are difficult to change. After all, this interface exists for a reason, right? Someone here must be using DI to inject new implementations of this, right? I guess I better not change it because I don't want that one to stop working. Oh, I know, I'll inherit that, and add a new method with a new interface to let everyone know there's a new kid on the block and then they'll use that someday when they find it. ::sigh:: Not enough architects know about YAGNI and not enough of them actually practice the rigor required to keep well defined, loosely coupled, and highly cohesive services in working order for the long haul. Far too many of them allow their systems to lapse into dysfunction and then perversely get rewarded for rushing in to play the hero to prop up yet another failing subsystem. In short, any interface for which there's only ever going to be ONE implementation shouldn't exist. So.. I agree with you. :) /endrant
As the author of the article, I'll claim that that's not what the article says. 1. I like the mentioned evangelists, and I've met many of them personally. They're great people, and they're advertising great products. 2. True, the "other framework" is a niche product (clearly labelled as such in the article, btw.) like many niche products also mentioned in the article. In fact, like many niche components of JavaEE / Spring that would be about as niche as the "other framework", if they weren't part of a branded umbrella. 3. There's a point in the article, and the point is: The duopoly of JavaEE/Spring is stagnating, which leads to market fragmentation and many new players offering new niche solutions, which will be leading into very exciting times in the JVM ecosystem.
&gt; JSPs require a servlet container to run. On the other hand, a servlet is just a simple Java class. This makes working with the servlet so much easier. Umm, servlets require a servlet container which is why they are called servlet containers. 
Okay, I'm a little new to writing good rest api but what do you guys do for authentication? Basic auth? Oauth?
I think you missed the point.
That just ends up being marketing talk. Right now I can deploy Spring onto a Tomcat server and do development, deploy it, etc right away. I'm already familiar with it, it works. What JEE server would I use? There's some Tomcat EE thing that may or may not be the full spec. Oracle used to support Glassfish or something but they canned it and nixed it. And lets say I tried all this out and got everything working - as far as I can tell, I can now do - the same things I can already do in Spring. EJB has a long history of having backing in an empty popularity contest from major software companies and official logos, and it sucked. Maybe it's better now, but who cares? There's no motivation to switch, and a lot of uncertainty about what would and wouldn't work.
My problem with JAX-RS is the lack of hypermedia support.
Because it works and gives you everything you need to develop a professional application, I've had so many issues with Jersey and JAX-RS
You prefer more lines of code? Jax-rs is one small part of Java ee. Why do you like it ?
Not sure if you were actually wanting some answers or your questions were just rhetorical questions (I'm assuming rhetorical), however: TomEE Plus would be an implementation of the Full Spec. v1.7.x is Java EE 6, whereas TomEE 2.0 (aka TomEE 7.0 now) is Java EE 7. There's also Payara, WildFly, and WAS Liberty Profile (I doubt you want to deal with JEUS or Cosminexus). EJB 3.1 is actually pretty sweet. I had read so many negative things about EJB, stuff concerning experiences from the pre 3.0 days, before jumping into it. It turns out that it stupid easy to do what I needed to do. Most things can be done with a few simple annotations. Still, you have a technology that you're familiar with, and you've got it working for your needs. I agree with you that you don't have the motivation to switch.
JSF 1.0 was garbage. JSF 2.2 is actually pretty sweet, but its reputation has tainted its impression on people. Even then, there's JAX-RS + a JS framework such as Angular.
May I proudly present you our builder pattern? public abstract SomeService { //never extended, don't let 'abstract' confuse you @Autowired LocationDirector locationDirector; ... private URI buildLocation(String subscriptionId) { return locationDirector.buildLocation(subscriptionId, getUriBuilder()); } /** lookup method in spring xml, so that you get a prototype bean */ abstract protected getUriBuilder(); } - @Component public class LocationDirector { public &lt;T&gt; URI buildLocation(T o, UriBuilder&lt;T&gt; uriBuilder) { uriBuilder.buildPath(o); return uriBuilder.getLocation(); } } - public interface UriBuilder&lt;T&gt; { void buildPath(T o); URI getLocation(); } - //single implementation of UriBuilder @Component(BeanNamePool.SUBSCRIPTION_URI_BUILDER) @Scope("prototype") public class SubscriptionUriBuilder implements UriBuilder&lt;String&gt; { private URI location; @Override public void buildPath(String subscriptionId) { location = UriBuilder.fromPath(SubscriptionEndpoint.ENDPOINT_PATH + SubscriptionEndpoint.SUBSCRIPTION_PATH) .build(subscriptionId); } @Override public URI getLocation() { return location; } } ...because we might later want to build more different locations... after a year replaced just by the one liner UriBuilder#fromPath after the author(most high ranking senior developer/designer) finally admitted it was useless... Of course every class had its own unittest with mocked dependencies and 100% code coverage.
&gt; Not sure if you were actually wanting some answers or your questions were just rhetorical questions (I'm assuming rhetorical), however: It was somewhere in the middle, while I'd love reliable answers there's a lot of unreliable answers on the internet at well. It's the kind of thing where to actually know for sure I'd have to use it myself, you know? I've seen both honest and accurate claims and wildly innacurate claims both put forward as "the truth". &gt; Still, you have a technology that you're familiar with, and you've got it working for your needs. I agree with you that you don't have the motivation to switch. Sure, great, I mean that's what it is. I suspect this latest version is vastly better and may or may not be just as good as Spring Mvc. I don't tell anyone it's "crap" or anything, there's just no motivation to switch, Spring Mvc has worked very well for me. (One of the few frameworks that has, to be honest, could rant on about a whole bunch that have been a case of "this would be easier without the framework").
I don't seem to be having any trouble ignoring it, actually.
Aw, jesus christ! lol That is terrible, like I said though the "use different frameworks and tools and be creative" philosophy is the reason why crap like that was added to projects that I was on, so you can we why I'm often against the philosophy...
None of that is true. Whether one is more streamlined than the other is completely subjective. I was a Java EE developer for the last 4 years and now I use Spring, both are fine. Spring also has just as much industry support. Especially since it is based off the Java EE standards. Also, you can use NO xml in Spring if you want. Configuration and bean declaration can all be done in code. I've noticed that people in this sub are very pro Java EE and against Spring. I don't know why that is but it seems to be the trend here.
How I feel when someone says they want to add creativity and new frameworks into our project and I have absolutely no doubt they're an idiot: http://img3.wikia.nocookie.net/__cb20090106162153/jurassicpark/images/5/57/Jurassic_park_tyrannosaurus.jpg
But what do you say about using 15 years old frameworks and EJB 2.1? I was also forced to not use a 'new' framework, and produce tons of shitty boilerplate :(
As a person who is currently coding in Jersey, I'd have to disagree. It took may DAYS to figure out how to configure a Jersey web service with the latest version of Jersey and Jackson. And this was using Glassfish 4 and JEE7. Configuring the POM and the Application "just right" was frustrating as hell...
You only need to include the javaee7 Maven dependency with scope="provided". Very difficult indeed...
I'd say people dislike Java EE out of ignorance. They see the appserver requirement as "bloat" because there's a lot of JARs bundled with it. Nevermind the fact that the WildFly, Glassfish, etc. start up in two seconds and don't load anything you don't use. No, people would rather build fat JARs that end up including dozens of dependencies in order to build what essentially amounts to a not-as-good-as-the-real-thing EE server.
That's not support for hypermedia. Spring has [real support](https://spring.io/guides/gs/rest-hateoas/?utm_source=InfoQ&amp;utm_medium=topic-sponsorship&amp;utm_campaign=spring-Q42013&amp;utm_content=lp-getting-started-Building-a-Hypermedia-Driven-RESTful-Web-Service) for hypermedia. But never fear, there are [extension libraries](https://code.google.com/p/jax-rs-hateoas/) out there that add on proper hypermedia support to JAX-RS.
Well, never mind then!
Anyone mind explaining the downvotes? I'm not wrong about how easy it is to set up a Java EE project using Maven.
With any technology, one isn't inherently "better" than the other. It all comes down to what you need the technology to do for you. If you have an existing application written in JEE, there is very little value in rewriting in Spring, or vice versa. 
While I don't know how easy or how much a nightmare that would be (I know, I know, someone always claims it's so easy whether it is or isn't), I haven't seen anything I would gain by doing so.
I think Spring is good for using CDI outside of an actual container (such as not running in an EE app server environment) where as if you're in an app server environment built on EE, you might as well use EE over Spring becuase of potential conflicts. Just my 2 cents.
Not exactly. Not all features play well together outside of a proper Java EE environment. For example, CDI and container managed transactions (@Transactional annotation). Weld is [quite clear](http://docs.jboss.org/weld/reference/latest-2.2/en-US/html_single/#weld-servlet) about the limitations of running inside Tomcat. On the other hand, DeltaSpike lets you get around some of these problems, but it requires [a few hacks](https://deltaspike.apache.org/documentation/jpa.html) to get it to work (you have to provide your own producer for EntityManager instances, and @Transactional classes must inject an EntityManager).
I've tried to make a Neither-JEE-Nor-Spring app, using Guice, JDBI, Spark. The thing I've missed the most: Nice declarative transaction management. And SpringBatch.
Thank you for the thoughtful answer. Actually, to be clear, my current employer is willing to bring me on as a Jr. Java developer after the training. There is at least one other person in a position to hire at a company who has extended the same offer, except his is a Rails shop. One suggested going the Java route, the other suggested just learning enough to be dangerous because I will need to learn on the job anyway. In the end, I think I will learn best from the better guidance of a good teacher. Suffice it to say I don't really know how good the Java instructor is -- he may be the better teacher (but I can't afford that $10k risk!).
/me goes back to /r/scala
The parent isn't wrong though. API management really should be handled at a higher level, otherwise you will complicate your application with details that are better handled by a more robust solution. This is not something that strictly enterprise-grade software is concerned with.
I don't disagree, in a perfect world, yes, authentication should be maintained outside of the application. But, there are plenty of times that getting a minimum viable product together that having it at the application level saves time and money. Designed correctly, swapping out authentication layers within the application should be a non-issue if it does move to the correct software layer.
&gt; The duopoly of JavaEE/Spring is stagnating Or maturing to the point where we don't need to constantly chasing after new frameworks. It's not always "up up up" it's often a bell curve where at a certain point things reach maturity and you hit severely diminishing returns.
An action oriented framework is also a huge turnoff for a lot of people. It is not really about that though. With the component model you are free to write all your own javascript if your client has money to burn and you think its fun. You just do not have too. Spring data does not offer any value to me. Spring Boot is just an additional framework trying to make up for complexity of Spring by adding another framwork on top of it. Remember how Roo was supposed to do the same thing but that was last year. I think there are cases where Spring can be helpful and Spring batch might be a good example of that. It is just that for most web application development it is just a lot more work.
CDI runs fine on standard Tomcat. If you want EJB then use TomEE or add OpenEJB to your project.
Could someone explain what he means exactly? I have no idea how to "push auth out to the dmz"...
Just because the solution is simple doesn't mean it's easy to discover.
If it's significantly different I'd say go for it. Like it would be weird to use Spring Mvc in a Java EE application, but I wouldn't hesitate to use Spring Jdbc (you write normal sql just wraps the repetitive stuff). 
This is a non-sensical post. Servlets get the incoming request, then forward them to a jsp. You'd do things like calls to the service layer which calls the database from the servlet. Most people don't use servlets because they're using a framework that's replaced servlets, like Struts, Spring Mvc, or I believe Java EE. Those apps usually still use jsp's though. 
What a fucking shit article. This explained nothing, taught nothing, and added nothing to the examples he provided. 
Because testing/debugging in a running application server is annoying as hell. If I want to set up proper automated integration testing, with Jetty all the drivers are all POJO's, so my test can fork off the necessary drivers and get them working against each other. Easy. Trivial to get working in CI. If I'm using an application server though, I'm either at the mercy of whatever the application server gives me (remembering all of Spring's non-portable JUnit3 tests here gives me such a shudder), or trying to jury-rig some kind of console script (which always unintentionally becomes non-portable and slow) to run the application servers and run the tests against them. And then, when shit fails, if it's a Jetty POJO, then debugging is a piece of cake. Debugging on application servers involves running remote debuggers and setting remote breakpoints, and monitoring all their remote logs. Modern IDE's help with this, but it's pretty fundamentally broken from a modern standpoint. Application servers can take their transaction management and session pooling and brouhaha and shove it. None of that is cool if wrestling with the framework slows down development by an order of magnitude, or if you find yourself writing frameworks to deal with frameworks - the road to hell is made one-way by refusing to write portable code.
&gt; Not all features play well together outside of a proper Java EE environment CMT isn't EJB.
&gt; An action oriented framework is also a huge turnoff for a lot of people. Some people like option A, some people like option B. What's the problem? &gt; Spring data does not offer any value to me. So? It clearly offers value to others. &gt; Spring Boot is just an additional framework trying to make up for &gt; complexity of Spring by adding another framwork on top of it. Spring Boot is another way of delivering Spring applications for microservices. It isn't a framework to "make up for the complexity of Spring", it's a new way to deliver applications. &gt; Remember how Roo was supposed to do the same thing but that was last &gt; year. Spring Roo doesn't remotely do the same thing as Spring Boot. Spring Roo does code generation, and is more like Rails scaffolding. It's a far more sophisticated version of the wizards provided by NetBeans. &gt; It is just that for most web application development it is just a lot more work. What you call more work, others call more control. People have different needs for different frameworks. TL;DR - you personally don't find Spring products useful, have different ideas about what is "more work" for web application development, and seem to misinformed about the purpose of several Spring products. You're projecting your own preferences and requirements onto others.
I'm sorry what "subscription thing" are you talking about?
I tried to get myself familiar with Java EE and its derivatives but it is just to damn overwhelming by yourself. If you have someone to guide, you can leverage on them hard and it will fall in place but from books, I don't know where to start. You got the IDEs, the applications server, frameworks, methodologies, etc that it is just overwhelming. So we got Eclipse (by ext. RAD), Netbeans, IntelliJ for IDEs. Application Servers we have Catalina, Websphere, Weblogic and JBoss. Frameworks we have Standard Java EE, Spring, &lt;add framework, can't recall&gt;. Methodologies we have Maven, Faces, JAX-WS, etc. Then you need to learn about all the xml and mappings. Deployment descriptors. Not hijacking a maven project, you need to get a grasp of above before you even create a hello world program. Too many permutations to achieve the optimal workflow. Java creates too much technological debt.
Download an IDE like NetBeans and take apart all the example projects.
Meh to "the truth". That mentality bothers me. I'm with you in regard to knowing for sure by using a technology. Via being sick with dealing with WebSphere 8.0 and its classloading issues and bugs messing with our Spring apps that ran in WAS 6.1, I finally decided to play ball with it and start using Java EE 6. I ended up liking it and look forward to using Java EE 7 whenever I'm able to target WAS Liberty Profile... However, that doesn't mean that I'll only stick with Java EE 7. I've been wanting to check out other modern stacks or frameworks for a while beyond Spring and Java EE: Play, Spark, Vaadin, etc. Spring MVC is very nice. I've used it in the past for projects along with WebFlow.
I think this does happen and I can relate to it. It is just like all the post about JSF from those who used version 1.0 when JSF 2 has been out more than 5 years. It is frustrating because it prevents a useful dialog. I think part o the problem is the majority of Spring tutorials out there seem to use XML.
Also, the first example * doesn’t even compile. * uses a raw type. Seriously, *who does that?*
Technology evolution usually goes in cycles. Java EE/Spring are currently stagnating/maturing (same thing) but even now it's clear they are far from ideal and there's a lot of room for significant improvement. I too look forward to the next generation frameworks.
For me, big disadvantage of Java EE is that you are constrained by your application server which is not controlled by developers but by OPS - by using Java EE you effectively give up control. In corporate environment you usually use one particular app server - in our case its WebSphere because we have some super contract with IBM. Even our OPS hate it, but they had no choice - it wasn't technical decision to use it, rather business one. So we're lucky we're running relatively recent WebSphere version which supports hot tech Java EE 6 from 2009. Other devs are not so lucky and must develop for older one with Java EE 5 (2006 baby). So you're usually developing against quite old tech. That's not even saying that Java EE standards are usually behind - standards usually adopt "proven" technology - see e.g. revolutionary MVC from Java EE 8 scheduled for release in 2017. If you use Spring (or other non-Java EE tech) with e.g. Tomcat, you're much more free from corporate and OPS bullshit ...
You can put your plain HTML (5), and CSS and JavaScript directly on your page. There's no need to do everything with component. And if you just put yout HTML etc in a file that ends with .xhtml and put into a special directory it's automatically a component. How much easier can it get?
I run Eclipse on an acer c720 (celeron/2gb model). You'll probably be fine. 
ok, you're right. Here is a better answer. If you are in a small company and new to authentication and authorization then you can go ahead an do basic auth in the application. Use a framework like Apache Shiro so you can replace the Basic Auth Filter when the time comes. Eventually your organization will want to stop invalid users before they get access to applications in your internal network. If you are in a large company, then you should have a couple load balancers in your DMZ. These will be making calls out to your single sign on or OAuth identity management solution that protects resources in your internal network. Unathenticated traffic (bad user/pass) gets rejected as well as unauthorized traffic (user doesn't have role to access resource). Since Basic Auth is less intrusive in your application than an OAuth solution and your long term goal should be to remove it, I would go ahead and use basic auth. Basic Auth does have the drawback of sending the user/pass with every request whereas OAuth does not.
It's just yet another spam account. [Reported](https://www.reddit.com/r/spam/comments/39fl72/overview_for_devixgp/) and now deleted.
Did you go in your Java settings and unblock the URL of the site?
Yep, point to JEE. CDI is an step forward. I have only used to inject loggers, and some people freak out when they NOT see a private static final LOGGER = LoggerFactory.get... Spring should totally stole that. 
You are right, I was wrong. Technology blindness at its finest
Sadly, this seems to be some sort of professional blog for [these guys](http://www.devixgroup.com/index.html).
&gt; App server vendors create it themselves by targeting not developers or ops, That's a bit... old school. JBoss, arguably the biggest vendor out there, targets developers. Even IBM with their Liberty is now very much developer oriented. TomEE, Resin, and GlassFish have never been targeted to business people. &gt;I don't really see how developers (unless they are devops) control the Java EE server as there's a lot of purely OPS-related stuff. No, that's not necessarily the case. I am a developer and I control the Java EE server. There's nothing really special in our setup. If I can do it, and the companies were I worked before could do it, I don't see why other's can do it either. We do devops and have a few stages where we deploy against. We use as many things from standard Java EE as possible. There's barely nothing that needs to be configured outside Java EE itself. Of course different stages have different databases, but the configuration for these is put inside the project and inside the ear. At runtime a single parameter selects the right stage. This means that all members of our devops team look at the same source tree. People we are more into coding look more at the .java files, while people who have more ops responsibilities look more at the configuration files per stage. For the few things that do need to be configured outside Java EE, we indeed configure them there at the container level, but the container itself is just code in our own git repo. &gt;We ask ops Let me stop you right there. This is where it goes wrong already. You don't ask ops who know nothing about the project. Ops is already part of the team, and the team knows if an upgrade of the AS is needed or not. Just as not a single junior developer decides by himself to update the major Spring version in pom.xml, a single developer doesn't just decide to update the AS. This is nearly almost a team decision, maybe vetoed by a lead developer but that's about it. When it's decided, the team works to make it happen. When it happens, the thing is pushed into production (after rigorous testing, just as you would test major new dependencies added to a .war). At no point is there a dev team begging an ops team who doesn't have a direct interest in doing what's being asked. If you go that route then nothing ever happens. It's a recipe for disaster. &gt;OPS, bosses don't care about it because it doesn't affect them in any way. With a good working development process this works exactly the same with Java EE. You may have an overarching ops team (in our company we call them system administrators), but they ONLY care about things such as load balancers, network switches, firewalls and the host (Linux) OS and XEN installations. What gets installed to the virtual server is the concern of the devops team. For them the entire virtual sever is basically just an app. All it needs is memory and cpu allocation and outside ports (as few as possible). And please don't fall into the 4:00 AM trap. A general ops guy who has no knowledge about the application is NOT going to fix issues with the app. AT MOST such ops guy can restart the server, but for that it's NOT necessary that such person knows if it's JBoss or GlassFish or whatever. Now the devops team, they DO know the app in and out. THEY indeed have the 4 AM duty and the responsibility to deploy what they created (or at the very least be present when what they created goes into production). The entire setup of dev team who doesn't contact with an ops team and then at some points throws a .war over the wall, which then at some time in the future gets deployed by ops who doesn't have a clue what the .war is about, but guards an application server that's just a bunch of libraries they have no idea about but because it's called "server" must somehow guard... It's wrong... it doesn't work, it hasn't ever worked, and it will never work. 
ClassNotFoundException looks like it's their fault, not yours.
http://www.typesafe.com/subscription I looked into it more a bit after I had posted this comment. Seems like it's just a support package. The tutorial video I watched has peaked my interest though!
I used to think so, too, but recently I contributed a big chunk to an open source project, using only Vim and the command line. The maintainer used some homebrewed build system that was not supported by NetBeans, which is my preferred IDE. So, rather than running Eclipse or IntelliJ, I just cut it with Vim and Ant*. Which worked great and was kinda refreshing after relying heavily on automation for so long. 
Embedding Java into JSP/HTML is considered a bad practice. Using servlets and JSPs together is fine, if a little old-fashioned compared to using one of the many web frameworks out there. The JSP should basically display data. Servlets should handle most other things or call other Java code that handles it. Throwing a bunch of Java into JSPs is how you end up with a maintenance nightmare like some of the code I work on at my job--several thousand-line-long JSPs with Java, Javascript, HTML, CSS and SQL all in one file, interspersed throughout.
Make sure you upgrade your laptop ram. 8GB is enough but might hit hiccup sometimes. 16GB is better.
Thnx a lot. Good to hear it supports Linux well.
ITT: People who complain about EE7 because they haven't looked at EE in years.
From the specs it seems the UX305 supports a maximun of 8GB of ram. Did I read them wrong?
Yep, both sides need to shut up unless they're going to stay informed. For the record, I have no issues with JEE, but all the people who complain about XML configuration in Spring just make themselves look stupid. It would be like a Spring advocate complaining today about how much JEE sucks because you have to implement both home and remote interfaces in EJBs.
All the projects I've worked, operations did not want to hear about it, they had their own separate schedule of upgrading the server that had to do with licenses, renewals, support contracts. Projects had to comply by making sure the code works on their server and that version. JBoss and Glassfish are OK to run locally, but try to run a WAS locally for development. It makes for a super slow development cycle just crawls you to an halt. Usually devs in those projects run either Jetty or tomcat, at least it was the case everywhere I went. 
Why do people keep saying this? You can use Java EE in tomcat. All you have to do is add the jars. Same with Spring. You do not have to use Wildfly, Websphere, or any other application server. TomEE is just Tomcat with the Java EE jars pre packaged. You can download Tomcat and do it yourself.
Let's assume you've obtained this error by launching an applet or a java web start executable. There are many possible causes to such an exception. 1. Did it work for *anyone* else than you ? It may be buggy code on the server side, basically. 2. Are you running the *advised* java version from the site ? Java6/java7/java8 ? 3. If all this is correct - and let's presume you've asked the question after checking the obvious - the most probable [imho] cause of classnotfound arising from a *presumably sane* application is the Applet and Java Web Start security rules ! Let me explain If we suppose the developer and webmaster *did* check their application before exposing it to the outer world, then it must be a difference of environment from their tests to your 'real life' situation. The rules [RIA rules] https://docs.oracle.com/javase/tutorial/deployment/doingMoreWithRIA/security.html for such applications have changed frequently those past 2 years and it is likely that you have reached a situation where : - part of the code is ill-packaged regarding those security rules - the applet tries to call this code - it is in a non-secured, so non-granted codebase - .. which ends up in ClassNotFoundException Some hints though: 1. If i imagined properly the case (server-side, client-executed app) may you click on "Details" and join further information 2. Else it is a standalone application and you *do* have a 'standard' classpath problem .. i mean you wouldn't have asked that way if it was some custom classloader/osgi class resolution issue. 2 cents.
 What do you think gwtbootstrap?
Google "JAX-RS hypermedia". You know, like you would if you were curious if JAX-RS supported hypermedia or not. First link is from java.net. Others are 3rd party blogs, tutorials, etc. I'm not sure what more you expect. Do you want Oracle to beam Java EE updates directly into your brain? Do a little Googling.
I have no love for eclipse for Java development. So, with that as a premise... half of the things being called out here are only worth mentioning because one uses Eclipse rather than something that comes with those things properly integrated in the first place: * JUnit: [Integrated in netbeans](https://netbeans.org/kb/docs/java/junit-intro.html) in the box * FindBugs: [Just one of several](https://netbeans.org/kb/docs/java/code-inspect.html) analysis tools included in netbeans * VisualVM: Yes, it's a good tool. Netbeans comes with a [great, properly integrated, profiler](https://profiler.netbeans.org/) [that I think might actually use some of VisualVM in the background] * Groovy: [also in the box](https://netbeans.org/features/groovy/) Being said, more tools is always good, and I do crack open eclipse for some things. I also have an IntelliJ license, and I could have made this same list with intellij links. Eclipse users can safely answer this post with "Eclipse has multiple plugins to do all of these things". What frustrates me is that, out of the box, Eclipse doesn't do these things and more. And then, when I need some of them, I have to trawl through fifty alternative plugins, none of which magically work correctly, or first time [profilers especially, I'm looking at you].
really? you call Spring Boot + beating out Apache Camel with spring integration+ spring xd data pipeline platform, + spring cloud/netflixoss resting on laurels? You clearly haven't looked at spring in last 3 years. Spring made DI mainstream in Java so welcome to 2004 - Java EE with your not - portable DI impl that has a drastically narrower scope and none of the portablility
perhaps engineering leads at netflix can address your question https://youtu.be/xU267-YHN5c 
I wonder why it's considered the #1 web framework and JSF is generally reviled by anyone that's had to use it, and now, like always, they are copying spring with the MVC 1.0 JSR, just like they copied spring batch, Spring DI, etc etc Slide 2 http://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-for-2014/
Very nice 
The problem with the whole "Eclipse sucks" crowd is that they just haven't bumped into something that their IDE can't do yet. Each IDE has its own strong points and its own weak points. Its infuriating to see "DAE IDEA masterrace?" everywhere because it's not always the right tool for the job. For me, the reason why I use Eclipse is that when some feature is missing, I can just go get that feature in the form of a plugin, while with other IDEs I am out of luck. I would rather spend 30 minutes installing plugins the first time than deal with what happens when there are no plugins at all.
8 tools for every Java developer's toolkit... ...that you probably already know about.
its so sad it's funny
&gt; Spring invented DI They'd wish, oh boy did they wish that. DI was available long before Spring even existed. In the Java enterprise context JSF and Spring both featured DI and had their 1.0 release at exactly the same time. Spring didn't really improve its DI much, while Java EE took it to the next level by taking the best ideas from JSF's DI system (scopes) and EJB's (annotations and proxies), and then drawing further inspiration from Guice, to come out with a vastly superior solution. CDI is *contextual*, *fully type-safe*, and build from the ground up to be *annotation/no-XML* based. Those are all things that Spring didn't implement because the thought they were at the top of the game with no competition in sight. And nobody was talking about Spring boot or data, but DI as a core value asset was mentioned and I agree that Spring dropped the ball there by not providing any significant updates for a long time.
What features have you found missing in IntelliJ IDEA exactly that you found in an Eclipse plugin?
The problem is not in the Java EE as in the specifications, like you say most Spring apps use several Java EE specs - usually Servlet API, JPA etc. Difference is - where are the jars for Java EE stored and who controls them - with app server (OPS controlled) or in wars (dev controlled)?
I remember there being issues with run configurations not being customizable enough. I haven't used IntelliJ for a while though, so I don't remember the particular things I was missing.
Java EE often doesn't even need a Servlet container. You can deploy it anywhere where there is a JDK installed ;)
I'm sorry, but until a year or two ago that's actually what Spring advocates said. Look back at some of Rod Johnson's presentations from around 2009 and you'll see he did say stuff like that, years after EJB 3 came out. You'll also still see Spring advocates somewhat trying to paint a picture of Java EE being exclusively about expensive and closed source servets, while in reality there are many free and open source alternatives (which are in fact the most often used solutions). I agree that complaining about XML in Spring today is ill informed, but both parties are guilty here I'm afraid. And I haven't even began to point out the FUD that's spread about JSF, where people complain about things in JSF 1.0 from 2004 that were solved ages ago.
Ok Malcolm. And like dinosaurs, it will EAT YOU ALIVE!
I'd say find a new job, because that one is going to set you up for unemployment when you finally hit the job market and can't get an interview because your skills are so out of date. 
These aren't hard, black-magic level questions, they are just dumb. They won't verify anything even remotely practical and interviewer won't know if the person is an expert as they don't touch the essence and don't allow to elaborate. If someone answers correctly/incorrectly the interviewer still knows nothing - just that the candidate knows/doesn't know this very tiny semantic. The remaining 99.99% remains a mystery. I see absolutely no purpose for these. They are simply a waste of time for both sides.
that's right -- nobody in Java EE is talking about noSQL, containerless apps, android/ios, big data, microservices because Java EE has nothing to say about it whatsoever! they ship ZERO production ready specs or impls to address modern Java. At least JBoss had the sense to copy dropwizard/boot with wildfly swarm.
&gt; with app server (OPS controlled) It's been said in this thread already, but let me also say that an app server DOES NOT need to be OPS controlled. I know so many organizations using Java EE and the app server is always a dev or devops concern. Pure OPS is NOT going to rewire EJB beans or JMS queues in production during an outage. This is utterly ridiculous. 
I'm not sure what you're problem is, this isn't personal. I evaluated JAX-RS, it did not have hypermedia support therefore I did not use it. That it took until 2.0 to get support is disappointing in the first place and a major contributing factor to my not using Jersey at this time. That ought to be all there is to it. However, even with 2.0 it's very clear that hypermedia support is not a priority. The expert group members aren't talking about it, the JavaEE hype machine isn't talking about it, the Google results should make it obvious the community largely isn't using it. So going forward I have little reason to look at JAX-RS. Why would I invest in a framework for building REST services where core constraints of REST aren't supported in 1.0 and even in 2.0 obviously isn't a priority? Most of you aren't building REST services, it doesn't matter to you, I get it. You want to call them REST services anyway, I'm not sure why, but I don't really care about that either. All I care about is whether or not the framework does what I need and JAX-RS didn't.
While I'm in the "eclipse sucks" crowd, I feel like my post is more in the "perhaps other tools are better" crowd. I have yet to bump into anything that I can't do in netbeans or intellij, and I've been doing this for ... a while. And, both actually have a lot of plugins
When I see gradle code, my mind just goes blank. 
Spring Boot has some decent Vaadin support. Also works great with angular. check start.spring.io for vaadin support, and this about Angular https://spring.io/guides/tutorials/spring-security-and-angular-js
Reloading classes or beans or whatever in JBoss is pretty nice and you don't get that with debug mode.
yeah you do, the only things you don't get are method sig changes, and completely new classes. The config jrebel doesn't look worth the effort
I'm no expert but just today I had to restart my JBoss numerous times because eclipse was unable to hotplug my relatively simple changes, inside functions. Perhaps because it's a really old JBoss version, I dunno. If everything works fine for you, great. Btw, usually JRebel needs nearly zero configuration, when I tried it out I just enabled a project via the plugin and enabled it for the server and I was good to go.
Last time I checked: Mylyn - ie. context switching.
I really like the idea of Spring boot and micro-services. To tell you the truth Spring boot I only see it being used for local development, at least in the companies I've been working. There is no way that the ops would let anything run on Spring boot. Not that it would be such a bad idea as it is, is just that all their tooling, monitoring and alarming systems are commercial products targeting their web server of choice. Maybe in a few years when the devops trend becomes more of a trend in these companies, right now at least where I work its Websphere for the foreseable future (with no liberty profile)
Did you actually check this? http://www.indeed.com/jobtrends?q=spring+java%2C+%22java+ee%22%2C+j2ee&amp;l= Then for Java EE jobs you actually have to add jobs for "Java EE", j2ee, jboss, websphere, weblogic and a bunch of smaller implementations of Java EE, since all of that boils down to the same thing, a job using Java EE. Just "j2ee" already has a small edge over "spring java", but when you add the other term the distance gets bigger. Still, even with adding those other terms the distance doesn't get huge. For practical intends and purposes I'd say Java EE and Spring have approximately as many jobs available.
Well IntelliJ IDEA is a Java IDE so I don't really find that reasonable. There's always CLion though and a plugin for that might be coming soon.
Why would I be kidding? You don't seem to be fully up to date with history. JSF introduced DI and the managed bean concept in March 2004. Whatever JSF's faults were at the time, the DI system and the managed bean concept became super popular and were used by legions of developers. There's no way Spring invented DI. It came out 13 days *after* JSF 1.0 was released, so JSF and therefor Java EE was first. And Spring was not -the- basis for the JSR. Read it yourself please. And Spring Batch is JSR 352 conpatible, it implements the spec. If parts of the documentation were blatantly copied without permission, don't you think Pivotal would have noticed and started a big row? EE's is indeed to standardise things that have been done by OSS, closed source or otherwise. This is true. It's part of the official mission statement even. Therefor it's so funny that CDI is technically ahead of Spring's DI, when it's not even a goal of Java EE to be ahead! 
Jurgen is IMHO not fully correct there. If Java EE has supposedly so utterly failed to be adopted, why is IBM then launching its new EE 7 server in 2 weeks? Why has Hitachi already released a Java EE 7 server? And if you compare it to Java EE 6 adoption, which we all know is an immense success, Java EE 7 adoption is not slower at all despite being bigger. The problems with Juergen's post are: * He stupidly forgot that Hitachi, a major commercial vendor, exists. * He failed to see how close IBM is to releasing a Java EE 7 offering * He conveniently forgot how long it took vendors to release Java EE 6 servers Then he writes a post that's pure FUD, somehow trying to create the illusion that while Java EE 6 was a success, Java EE 7 is now failing since it hasn't been adopted and implicitly tries to make you think that companies have barely started with their attempts to implement Java EE 7, or maybe did but aborted it. All of that is completely nonsense, and I'm pretty sure Juergen must know this. He could have created a great blog post, maybe complaining about the fact vendors still aren't implementing Java EE 7 faster than the normal pace. There are valid points to be made. But instead, Juergen writes a cheap piece of FUD that any junior Spring zealot could have written. A shame, since we all know Juergen can do much better.
IDEA has context switching https://www.jetbrains.com/idea/help/switching-between-contexts.html A context saves your open/position pane state, which files are open etc.
There are so many bugs in many of eclipse plugins (and that horrid install process)... They still can't get WST plugin to correctly recognize ROOT context as / on tomcat or to get the deployment to synchronize correctly. I have spent way too much time wrestling with the plugin settings and completely deleting deploy directories. I have never had to do that with IDEA since I switched. I only regret is that I stayed with eclipse for over 10 years and did not switch sooner.
Juergen's point is quite simple: no production support for EE7 from a major vendor (sorry, Hitachi doesn't really count) until two days after his post when IBM announced it (he ameded his post by the way, which you apparently missed). While there may be some prod ee7 somewhere, enterprise isn't generally buying with no support. He also didn't forget how long it took to release EE6 servers -- that's the point! it takes YEARS - a it's broken process that ensures irrelevance. As such, we'll have to drag along EE6 into spring framework 5. Even the most rabid EE zealot would appreciate a viable EE7, after all, there were some improvements.
This is my last month there... But don't get me wrong, we used new frameworks, Spring 4, Camel, Hibernate, CXF... But the discrepancy between developing new stuff into a legacy app and into new apps was just mind boggling. For example new apps had to have 100% code coverage(with tons of useless and harmful tests), but legacy one had zero tests even though it was the core of the business. Big plans about migration/rewrite of the legacy app, but no allocation of time for that or for improving of what was already there (I have made the code base much more readable just by applying boy scout rule - small things like renaming methods, removing duplicate code...). Spending time rewriting spring xml into javaconfig on places where it had no benefit, but never even trying to get rid of boiler plate configuration in the legacy app, which would actually save some time later... 
While there's also not a single vendor having a Spring implementation out (sorry, Pivotal doesn't really count). And if only he indeed has made the simple point that at the moment there are only 4 implementations out, and only one with commercial support from a very well known and reputable company. Then people would have even applauded him for it. Many Java EE users also think there should have been at least 7 implementations and 4 offering commercial support. No, the problem is that Juergen tried to create the illusion that Java EE 7 has failed this time and that nobody is working on implementations. Not that it *generally* takes a long time, no that it downright failed *this time*, which is nonsense and not true. &gt;that's the point! NO! That's not the point mr Juergen was making. His point was that Java EE 7 specifically was somehow a botched release that vendors are supposedly ignoring. I think mr Juergen is a very clever guy who chose his words very carefully. If only he complained about the cycle being too long normally, then it would be an understandable post. Still a stab at Java EE, but not FUD. It's currently about 3 years between major releases, and also 3 years between releases for each vendor (they all just shift at exactly their pace, e.g. JBoss is often ~2.5 years after the spec is released, but that means the time between JBoss EAP 6 and JBoss EAP 7 is exactly the same time as between the spec release of Java EE 6 and Java EE 7). &gt;it takes YEARS It takes the same amount of YEARS between major versions of Spring... &gt;a it's broken process that ensures irrelevance. It works extremely well. There's a wide industry adoption, a really great open source ecosystem, and thousands of contributions by the community for each Java EE release. 
Got an android phone? Go grab the dev kit and do something that solves a problem you personally are having.
&gt; but even now it's clear they are far from ideal and there's a lot of room for significant improvement. That is a personal opinion. I do not agree, I think it's converged on the most efficient solution given other factors, and the only way to improve would be to change how browsers and web pages work. I think it's about as efficient as it can get, given the architecture of how the web works.
&gt; It's not fun, and I certainly don't recommend it if you can avoid it. &gt; I think Spring is king when it comes to Tomcat. Yeah, that's the way it's seemed.
I don't find it reasonable to expect C++ support from IntelliJ IDEA which markets itself as a Java IDE. It's something nice to have. Eclipse can have the greatest C++ support in the world but if it lags behind in features for Java development then it's not a very good Java IDE.
I went through this same problem while rescuing a whole suite of company applications whose source had been lost by the previous company. 1.) Take the customized JAR and rename it .zip. Unzip it into a folder with nested subfolders. 2.) Find the nearest commercial version of that same JAR and unzip it too. 3.) Buy or trial a copy of Scooter Software's BeyondCompare software and use it to perform a side by side compare of the class files. Any differences should show. To deduce what those observed differences are, you're off in JAD land. Have fun..
Yes, it can, using specific frameworks, or specific jars with specific configurations run a SE environment. However, that's a lot of extra work for injected objects, and some extra dependencies. I personally would want to slim down dependencies where it makes sense.
Create a Spring configured RESTful microservice using Jersey that talks to a Redis server for data. Add container request/response filters to handle errors and use the builder pattern to return pretty JSON payloads in a response. If you can implement this full stack (and have a general idea of what you're doing and why) then you could pretty much get an entry level Java Developer job anywhere.
Start by something simple that you actually really use: * Your own portfolio / resume website. Try to use java for the whole backend. You may use something like [Spring Boot](http://projects.spring.io/spring-boot/) as a starting point. You can host it for free in [openshift](https://www.openshift.com/) * I've created a personal expenses monitoring web app (backbonejs + spring boot + spring batch with jasper report to generate report monthly) and android app. I use this app daily to help me live frugally. * Currently in the progress creating GTD app for personal use to increase my productivity.
I'm very happy (and somewhat surprised) with the excellent performance of Linux as opposed to the stock Windows 7 Home Premium Asus ships on the zenbook.
&gt; "both parties are guilty here I'm afraid" Agreed!
Because it's independent of the syntax, and rightfully so
One that I really got into was creating a database and desktop application to record and produce stats for the video game tournaments my friends and I run every so often. This is primarily the latest version of FIFA, so the application tracks things like players, teams, goals scored/conceded, final standings etc. Pick something you find interesting and just build away. Its much easier to put the time into something you enjoy rather than creating something just because it would look good on a CV.
Giving you the benefit of the doubt, I updated this comment to read "Made DI mainstream" and not "invented" until I have time to waste verifying this factoid, which changes nothing about who made DI mainstream in Java.
Do you really think that it's not possible to create something better, to come with some new revolutionary approach to solving old problems? History proved this opinion wrong many times and I'm very surprised to see it in such dynamic field as is IT ... Take for example DI in Spring and Java EE and compare how it is done in Dagger 2 which brings innovative approach which brings a lot of significant benefits (especially speed and static verification).
Is there a list of the available Certified Test Centres?
Yeah, I get that - again I have no problem with Java EE specs or their implementations - I have problem with application containers which come bundled with these implementations because I have no control over them (OPS control them).
We're looking for help on [JALSE](https://github.com/Ellzord/JALSE) (Java Artificial Life Simulation Engine)! Feel like contributing? See our [examples](https://github.com/Ellzord/JALSE/wiki/Example-projects) and let me know if you're interested.
Thanks for the info. I'll have to give the Idea second look.
Gradle builds are a groovy dsl, not JSON. Maven builds are harder to do something confusing with, but I find Gradle's flexibility significantly more useful, especially if you use the API properly. 
Why not have a look around [Oracle's website](http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=317) yourself? It really contains a lot of useful information about the certification, the process, even the syllabus.
If Ubuntu is working for you I really don't see the point of switching. However, there is no harm in trying something new. Who knows, you might like it even more.
I'm not. After starting the server netbeans can't see it.
That's the IntelliJ Platform. IntelliJ IDEA's page title, header, and description on Google are all: "The Most Intelligent Java IDE"
Difference between List, Set and Map ? Difference between int and Integer ? What is the MVC pattern ?
OMG what they have done with admin panel
&gt; statistically irrelevant sample sizes As far as I can see all sample sizes are statistically valid. They're in the same range of most every online poll and they're from reputable well known sites. &gt;/no sources cited I think he cites the source for every survey. Take for example "Welches ist Ihr präferiertes Webframework?", it has 1463 people who voted and it's from jaxenter. JSF is with 16% at the number 2 position. Poor Spring MVC is at position 7 with only 6% of the votes. In the zeroturnaround surveys from 2012 and 2014 the sample sizes and sources are clearly listed. They're 1100+ and 2164. Your remark about no sources and irrelevant sample sizes is not correct. In those two surveys Spring MVC is the number one, but JSF is still at number two, winning from a lot of other frameworks. There's more analysis of the Henk53 post and some extra added sources here: https://java.net/projects/jax-rs-spec/lists/users/archive/2014-06/message/35 I specifically like these two observations: * http://stackoverflow.com/questions/tagged/jsf+or+jsf-2+or+primefaces * http://stackoverflow.com/questions/tagged/spring-mvc Among StackOverflow users JSF is clearly more popular than Spring MVC. 
Is Java pass-by-reference or pass-by-value ?
Well, while it is correct to say that the code is not in the comment, javac itself is not helpful: public class Uni { public static void main(String[] args) { // \u000d System.out.printl("error"); } } yields this compiler error: Uni.java:3: error: cannot find symbol // \u000d System.out.printl("error"); ^ symbol: method printl(String) location: variable out of type PrintStream 1 error Notice that it says line 3 for the error, which is the comment.
Don't blame IDEs. Any text editor 'misrepresents' this code equally well. Even using a command line tool such as 'more' or 'less' to view the source code misrepresents it. Actually it is not misrepresented. That is what the source code says. It is merely the rules of the compiler that the unicode expansions are done first, BEFORE even the lexical analyzer or parser get to see it. This rule makes it possible to do very tricky things in the source code -- or to create the ultimate obfuscated Java contest.
There is NOTHING WRONG with your IDE. This is a rule built in to the Java Language and honored by the compiler. Unicode expansion happens PRIOR to the lexical analyzer and parser. Try this line of code, which actually prints out something. /* \u002A\u002F System.out.println( "Hello Whirrled!" ); \u002F\u002A */ Edit: from your comment below, I would say that I agree that the IDE should *highlight* the fact that the System.out.println is not commented text.
This
PermGen became METAspace, not MEATspace -- but considering the similarity of what goes into both spaces, confusion is understandable.
All new projects on my company are starting with Spring Boot now. Also Newrelic gives all the information we need about the application, even in the free account and it's simple easy to integrate with your jar, just pass an argument. Or even with zabbix, SpringBoot actuator can give it so much information, and all you have to do in your app is add a dependency. That said we have major projects running with Spring Boot, 100% uptime and had no issues so far. Spring Boot is such a step forward to help developers, it feels so good to just build your jar, run it and then you have an web server up in a matter of seconds.
Yea I think he is trying to say that the IDE should show that this will happen by showing it in its post processed state ie on a new line.
The IDE displays it as a comment when it isn't a comment. Personally I think the IDE should perform some partial or full unicode expansion to show what will actually read the compiler. Your code simply confirms my point. An IDE will show that whole line as one comment, but in reality it is ```/* */ System.out.println( "Hello Whirrled!" ); /* */``` which is valid code. So what the IDE display shows and what compiler sees are two different things. I'd say the IDE needs to handle this because it's incredibly misleading.
Bytes are not the same thing as Characters. What is the difference between a Reader and an InputStream? Reader reads characters. InputStream reads bytes. A Charset object can convert the bytes into characters. There is a Reader that takes an InputStream and a Charset and adapts it to a Reader. What is the difference between a Writer and an OutputStream? A writer writes chracters. An outputstream writes bytes. A Charset can convert from characters into bytes. Similarly there is a Writer that can convert characters into bytes and pass those bytes to the outputstream. Not all characters occupy one byte. Some characters occupy multiple bytes. Using a Charset object to convert between bytes and characters always does the conversion correctly. Similarly, a String is not the same as a byte[] array. But it is possible to convert between the two using a Charset.
Stupid question for a beginner; it rarely (if at all?) has an affect on job performance. I honestly can't remember one time in my entire career where this distinction had any bearing. That said, it's a question I got asked when I was interviewing a few years back.
interface vs abstract class, map vs list, some string == some other string vs .equals, what is : encapsulation/polymorphism/inheritance/abstraction 
You pass a list into a method. Your method adds stuff to the list. Has the caller's list changed? Similarly, you pass in an int and the method increments it. Does the caller's int change? These are things a beginning developer should know, and that's what the question is getting at.
&gt; In a JAR file, how many main() methods is it possible to have? What's your expected answer to that?
You need the Java equivalent of these useful C preprocessor directives: #define while if // makes code run faster #define struct union // makes data structures use less memory 
Maybe a little too deep for a beginner, but I like to ask, "what is type erasure and what are its implications?" especially if I see they also have C# or C++ on their resume.
Actually, you'd get that question wrong. You're inferring that objects are pass by reference and primitives are pass by value with your explanation. I'll go ahead and assume that's what you're saying. Wrong. Your explanation is correct (which is why this whole question is stupid) and you are indeed right that all beginning java programmers should know this distinction. That said, ALL PARAMETERS ARE PASS BY VALUE IN JAVA. Again, it's stupid. You say "but, but, but... I can modify my objects!" "aha!" the pedantic interview says, "All parameters are pass by value. The 'objects' you refer to are simply pointers to the actual objects. Thus, the pointers are passed by value and when you call to them, the object is itself referenced." Like I said, it's a stupid question -- especially for a beginner.
MEATSpace, a butchers ? No idea what you are talking about (10 yrs java experience).
I'm currently using JPA 2.0 with OpenJPA on a pretty large project.
Honestly Hibernate is still probably the best choice, although Spring's RowMapper/JDBC template is what I use for most everything beyond CRUD. Even for CRUD, I like Spring Data JPA, which is a wrapper over Hibernate. I really can only handle ORMs for CRUD - every thing else seems like a giant hack and usually results in an unmaintainable mess of annotations and spaghetti code. Just write native SQL queries and be done with it. While I've not personally used them, I've seen a decent amount of use in the community of JOOQ and QueryDSL as well. They look pretty interesting - I'd love to try JOOQ but it's licensed software, and our team has yet to come up with a reason to buy it yet.
I'd consider anything up to and including rusty spoons in my eyes. But I hear Play is pretty good or EBean which it actually uses.
[EclipseLink](http://www.eclipse.org/eclipselink/) is an alternative to Hibernate.
That's sort of a trick question. Everything is passed by value, but objects are passed by reference, and those references are passed by value. You might think that that's pedantic, but it's really not. For example: public void passByReferenceCheck(SomeObject object){ object = new SomeObject() } public void passByValueCheck(SomeObject object){ object.someMember = SOME_VALUE; } If Java were pass-by-reference then the outer scope of "object" would reflect the new object creation in "passByReferenceCheck". If Java passed objects by value then the outer scope of "object" would not reflect the change in "passByValueCheck". I really wouldn't expect a Junior Java Developer to know that, and in fact, if they were to say that Java were pass-by-reference, I'd be impressed even if technically that answer is wrong. This is really one of those questions that are "I don't expect you to know this but...".
10 years and you don't know what permgen was? Oh dear 
no, MEATspace
Every junior Java interview will ask that question. You answer it using the Java definition of pass by reference. 
+1 for EclipseLink as JPA provider. Especially for all cases where your mapping and/or queries no longer have the triviality of a pet store.
I suspect it was a typo that has since been corrected. There is no such thing as meatspace.
Your two code examples don't really demonstrate what you're trying to say. For example, your second check implies that you're checking for "pass by value": either you're modifying the object "outer scope" as you put it or you're referencing a value (copy) of the object. This is the wrong check. You're effectively implying that it's pass by reference (the "outer scope" is indeed modified, but in fact java is "by value" due to the fact that you're passing a pointer to the object. Again, not really trying to argue your point, but this is why it's a stupid question for a beginner. If you think of a Jr. dev on the job, the only thing he needs to know is that the object being passed in, if mutable, will be changed for all references to it and that by assigning a new object to that variable, it doesn't overwrite the old one. Both of those things are askable without the trick question.
I've been asked this question twice in interviews (about 2 dozen of them over my career -- I don't switch jobs often), both times the whole interview process was littered with lots of these "Gems". Now, I can reliably say that these sorts of questions are a waste of everyone's time. Maybe not as much of a waste of time as "how many marbles could you fit in the empire state building", but it almost assuredly just figures out if the interviewee read some job interview question board/prep sheet. Same goes with stringbuilder/stringbuffer. Also, if you answer it "pass by reference", you'll get it "wrong" to the interviewer without explaining this whole conversation to qualify your answer.
It's actually a simple question to answer when asked the way it's always asked. It's also a very important question. Anyone who can't answer it, and that's a large portion of the unqualified applicants you'll get for a junior role, isn't someone you want to work with. "are objects in Java pass by reference or pass by value? " There's only one answer to that question. Pass by reference. You can't pass an object by value. 
I've really been liking Spring Data JPA
Read up on conversion functions on the primitive wrappers (e.g., Integer), especially valueOf(). Getting in yhe habbit of reading and referring to the standard library docs is vital.
Actually... you are wrong. Java is completely pass-by-value. See http://www.javaranch.com/campfire/StoryPassBy.jsp and various other explanations on the topic. But because in Java, Objects are always references, so when you pass the value of an Object, you are actually passing the value of that reference. If Java was pass-by-reference, then when you pass an object to a method, and in this method you initialize a new instance, then the original value would be overridden. This is not the case. Imagine something like this, where Cat constructor takes a name. (Full example:http://pastebin.com/UzcQWNXm) - but the article above explains it pretty good. Cat cat = new Cat("MyCat"); changeCat(cat); // print "myCat" -- if Java were pass-by-reference, this would print "yourCat" System.out.println(cat.getName()); public void changeCat(Cat cat) { cat = new Cat("yourCat"); }
Strongly depends on where do you put your resume. Expect questions based around the vacancy. You might get questions about SQL, about JSTL and JSP, about Servlet lifecycle, might get some questions about Spring's beanFactory or Spring configuration, or the way some of the modules work. There might be some questions on JPA or Hibernate's HQL/criteria.
Heard of it but if you use a licensed database, you have to buy a subscription for the jOOQ driver as well.
In that case, [JDBI](http://jdbi.org/) is very nice, too. It isn't type-safe like jOOQ, but it's very simple and fun to use. I don't know, however, how appropriate you'll find it for very complex schemas/queries, but for simple stuff it rocks.
If you're always passing the value of a reference when passing an object then you're passing a reference to the object and therefore passing by reference. Java doesn't allow you to choose a target address for memory allocation. The doesn't mean references aren't references. Edit: you can say that java is pass by value. It is. But you cant say that objects are pass by value. There's no way to pass an object by value.
Thank you I'll look it. And yes I have a system right now that has extensive use of NamedQueries and it's starting to be PITA, even thought I like the NamedQueries, the problem is to manage them all. Also I'm looking for an alternative for a new project but will connect to SQLServer. :edit The SQL Object API seems pretty sweet, but I think Spring Data is easier on that right?
Yep. Not a bad question, IMHO, because if you don't think that's what you're going to say. Correct answer is of course "one per class".
I love [mybatis!] (https://mybatis.github.io/mybatis-3/)
We live in meatspace, dude. 
C/C++ are horrible for everything that is not low level system programming. C and C++ are great for that. But nothing else. It is a horrible accident of history that people thought they should start writing applications in C, and then later C++. But no better compilers existed at the time -- that were reasonably cross platform. And at that time, you could even say C++ wasn't cross platform because every C++ compiler in the early 1990's implemented *different* subsets of C++. Horrors. 
Yep, I learned this the hard way. I was passing 'copies' objects through a method and storing them in an ArrayList. When I checked the values of all the objects they were all exactly the same. That's when I realized that it's all references and pointers and new objects don't get created unless you specifically state it, otherwise it's pointing back to an object you previously created. So I had to make a new object every single time. 
ok sure! how about this? I'm thinking the plummeting is largely due to: (1) the inability to address modern Java: big data, nosql, microservices, Oauth, iOS/Android, to name just few things. (2) the utter lack of investment by ORCL in EE. (3) Java EE is very difficult to be made cloud native, 12factor http://www.indeed.com/jobtrends?q=JEE%2C+J2EE%2C+%22Java+EE%22%2C+Spring&amp;l= 
In my opinion, most Java EE job postings are to maintain existing legacy enterprise systems. New systems tend to be Spring based. Spring is the future.
What is the scenario where you would have multiple entry points but only use one in a deployment?
Just make it an Object array Object[] disBitch = new Object[disSize];
I often write simple self-tests in random classes' main methods...
Persistence :D
LOL not even remotely accurate since Spring RUNS on jBoss, Websphere, Weblogic J2EE and Java EE have to be combined to even show how badly they are losing. Revenue numbers for app servers have been flat to declining for a long time. Go look at # of questions tagged on SO, google trends, spring's youtube channel beats the JAVA channel for views by a wide margin despite a 6 year head start. http://www.google.com/trends/explore#q=JEE%20AND%20Java%2C%20%20J2EE%20AND%20Java%2C%20%20Spring%20AND%20Java&amp;cmpt=q http://www.indeed.com/jobtrends?q=JEE%2C+J2EE%2C+%22Java+EE%22%2C+Spring&amp;l= 
I also love mybatis. It is to JDBC what JSPs are to servlets. You get to avoid a lot of boilerplate, and it doesn't force or even expect you to use a CRUD pattern. Mybatis lets you write markup specifically for SQL, like you would use velocity or freemarker to markup html, (grouped within xml documents). It lets you call the SQL in your XML with a gateway interface (method name = xml entry), with annotated parameters, that feel just like using spring MVC annotations. It handles your session management/works with spring transactions/makes it easy to do batch operations etc etc. Not the right tool for CRUD but fits the JDBC case very nicely.
Really? What should I do instead? 
I tried that, but I get a NoClassDefFoundError and if I look inside the jar, only my classes are found, none of the dependencies. Anything special I need to put in the pom.xml?
wait, did you even list all your dependencies inside pom.xml? Each dependency listed in your pom gets downloaded when building. Have a maven project, list all dependencies it uses, run mvn clean install on the project to build and deploy.
Get meaningful job experience 
My team was using OpenJPA with pretty good success. We switched to Hibernate though because it validates our NamedQueries on startup and ended up finding bugs we didn't know we have. Pure JPA is nice because we were able to make that change.
jOOQ is free and open source on open source databases. I use it regularly with PostgreSQL and MySQL. 
You can use a plugin like [appassembler](http://www.mojohaus.org/appassembler/appassembler-maven-plugin/) to create a distribution zip.
Yes, all the dependencies are listed in the pom, e.g.: &lt;dependencies&gt; &lt;!-- Netty handles the networking --&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.0.28.Final&lt;/version&gt; &lt;/dependency&gt; ... etc ... &lt;/dependencies&gt; I assume that the dependencies are correct, because I can run/debug the app from Eclipse without errors.
I'll second JDBI as an alternative to Hibernate. 
I did find maven-shade in my googling and will check it out. I guess I'm confused by the fact that there are plugins (as opposed to something Maven does out of the box) suggests to me that this is not the typical usage. Non-rhetorical question: what are people using Maven for, if not creating deployable jars? 
Spring is so common I'd recommend learning it even if the position won't require it. It was the tech that took me to the next level in java when I was still learning. It still teaches me new stuff almost weekly.
Um they uhh hmm do they make strings?
Dependency management, creating war or ear-files
Custom proprietary ORM which is wildly different to any java ORM I'm aware of.
MyBatis is the only way to go. I've worked with almost everything and nothing beats it.
can you make some examples please?
then delete your comments and put your money where your apology is. I'm seriously considering making it my personal mission to brute force my way thru every thread you've posted on this forum and respond to every other piece of misinformation you've posted. You're going to have a hard time outsmarting me, because I work for Pivotal, and worked at Oracle doing Java EE / WebLogic marketing and I know *exactly* where the bodies are buried. And, thank you for the apology. It felt genuine, and for that you have my respect. Maybe you aren't just a psuedonym for some Jave EE fanboi / employee and you are a real person. 
Personal experience of my first interview, was very basic but still my experience. What is Object Orientated Programming? And what are some (at least 4) of the aspects that make it different from other kinds of programming? Everything else has been said in other questions that I can think of! DJDavio done good.
I'd give you a mini coding question/project and let you work on it. Then, I'd ask you what you'd do if you had more time, etc. I'd look for the little things like java docs and/or unit/integration tests. If you're going to put effort in to complete the project to a high quality it gives me insight as to how you'd work on the job. 
Programming, duh! Nothing beats practice, and with practice I don’t mean “having worked as a programmer.” Participate in open source projects in your free time! Get to know the tools that are currently in use! Solve some (your?) problems by programming an application that you then actually use every day! Release said application to a wider audience! There are many ways to become a better programmer and that’s basically what companies are looking for. Oracle’s (and other’s) certificates, however, have nothing to do with being a good programmer, they only check for a small amount of things that you can easily memorize — which is why the certificates are basically useless.
[Plugins](https://maven.apache.org/plugins/index.html) are how Maven gets its work done. There are core plugins (which provide common basic functions of the build lifecycle) which are included by default, but it's pretty common that projects use many plugins, depending on its needs. At its core, Maven provides the ability to define modules (projects) and their interdependencies. When you are working on a big application, and you need to have several teams building different aspects of the system, it is ideal to develop and build these features into non-executable JARs, because at that level, they are only acting as buckets of classes *used* by other classes (which are, eventually, used by an executable application). It's really about being able to easily specify and comprehend the relationships/dependencies between different projects/modules. The more projects/modules you are dependent upon, the more messy it can get if you didn't have a tool like Maven to manage your dependencies and build your project (it used to be **really really** ugly before Maven). So, really, the majority of projects that use Maven have many dependencies on *non-executable* JARs, which are in many cases themselves defined and built using Maven. Of course, at the end of the day, you will need to create an executable application, which is where the WAR, EAR, and Shade/Assembly plugins come in, but this is just the tip of the iceberg of what Maven provides. HTH!
Me too. Works without a hitch. 