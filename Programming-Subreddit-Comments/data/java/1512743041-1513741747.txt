I would never add an external dependency over such a trivial issue as I don‚Äôt understand people‚Äôs obsessions with finding a solution to null. Null is not a problem, it‚Äôs a language feature. Ambiguous method returns were a problem, and now we have optional. If you want to write in a completely stream and functional way without nulls, then maybe you should use a different language. There‚Äôs nothing that irritates me more than people who try to force other language paradigms into Java projects at the expense of readability, following standard community conventions, or long term maintenance. I‚Äôm talking about: putting Optionals in every single class, method and field, or trying to create total immutability even when it‚Äôs not needed, or writing everything in a functional style no matter how cryptic the outcome. Please stop. 
We had great success with it some 6 years ago. It really spead up development, but the framework above gwt was properly done .. 
Learn to use the IDE debugger and the stack trace, try to follow your project when it goes outside of your own source code and see if you can figure out how that code is working. I think this will be easier and more productive than picking projects at random from github. For example, if you have a web framework you are using, place a breakpoint in what you think is your earliest startup class, and then look into the stack trace to see how the framework went about initializing your application. Make sure you have told your build tool to download the source files for your dependencies though, otherwise it will be too difficult to read through these files.
You articulated exactly what I was wanting to say. If I only had more than one upvote to give... &gt; or writing everything in a functional style no matter how cryptic the outcome. Please stop. +100 to this
TBH everything should return `null` all the time. It makes it easier to implement: public User getUser(String name) { return null; }
I actually never heard of such thing , in a global perspective, but for a local server, you can make a REST-full service as a mod(plugin) on the server side, maybe make a web app that will process data from this rest service, Or you can make it with jetty already with a web interface, and not REST-full.
It's actually crazy how much exp you can get just from modding and solving issues around it.Like i only learned by the book the basics like assigns, class stuff and etc, other stuff just, came by while reading the code. 
I thought it was going to be about this: class A { class B { } private B b; public A() { b = this.new B(); } }
You can definitely practice reading code, but I would say the best way to learn to read code is by both reading and writing code. Writing code will give you better insight into how code works, why things are written in a certain way, and will force you to learn certain design patterns. This will allow you to see past just syntax and understand what's actually happening in the code and why. 
Somebody give this man a job
But how will we fit in with all the cool people working in a Starbucks and writing code on Node if we don't do that? I've considered learning Rust just so I can fit in better there.
I just have almost 0 java experience other than configuring server plugins My question is how and where can I learn more?
I think a great way to practice this would be to try to build off of an already existing project that you didn't create. I wish I had a good example for you to start with but find a relatively simple project on GitHub and figure out something you want to change or add onto it. In order to make that addition/change you're going to have to read through the codebase to figure out what you're working with
**Sidebar** -&gt; NO programming help, NO learning Java related questions!
I'd recommend homebrew for package management in general and [sdkman](http://sdkman.io/) for java (and related ecosystem) development tools.
Android dev, I get it from Oracle
i jump between JDK's brew is great. also you might find SDKman useful http://www.lonecpluspluscoder.com/2017/04/27/installing-java-8-jdk-os-x-using-homebrew/ http://sdkman.io
Write unit test for pieces of code you did not author to affirm your assumptions about what the code block is doing.
What Tichus was trying to say is that you may get more response for learning java questions in /r/learnjava than here
Coursera? Did you tryed to google it? :) the internet is full of various study materials. 
My previous project was moving an application from GWT to Angular. I mostly didn't like GWT because I already knew css and translating what would be simple and uniform in css to GWT was painful. Coding wise it became very easy to create bad code by mixing the V and C parts of MVC (updating the data of the chart as your drawing it, or basing one chart on the other instead of the underlying data). Separating things into Javascript HTTP calls and an API naturally created the separation of UI and actions that produced nicer code. 
This article written by someone who has not yet heard of POJOs and clearly hasn't done any Enterprise software development. 
The problem with Dictionary is that it's a class, not an interface. In order to subclass dictionary, you would have to eliminate the possibility of subclassing another possibly more appropriate class. With the introduction of default method implementations in Java 8, it is no longer necessary to use a class to bundle implemented behavior with the type. You can use an interface instead. This is a pattern across many older Java core abstractions, like Observable.
This is wrong. He ignores the advantages and dismisses them, just because he doesn't like them. For one, most ORMs will search for setters and getters, so you can break functionality. Secondly, randomly allow attribution in the code can lead to a world of nightmares. Just the fact I can debug on the setter and look at the the stack to find the culprit (instead of having to check every place where it is called) its invaluable. This is especially true in systems that work on 'magic' (eg: reflection to invoke methods or other applications using your library). Bah. Besides the accessibility good practices, he's just pretentious and wrong.
Seems pretty straightforward from a quick Google. Dictionary was created as an abstract class but with nothing concrete in it; a better approach for that is to use an Interface, to avoid breaking existing code a new Interface (Map) was created, and Dictionary was deprecated. See the answers at https://stackoverflow.com/questions/25900226/what-is-the-difference-between-the-dictionary-class-and-the-map-class-in-java for more details.
Indeed.. such a waste of time and effort.
I took the answers in that SO as guesses at what happened, not references to facts
This is spot on! Really good read!
Yeah, it was already proposed as project Loom http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html
with *io.vavr*, the example with *Map* filtering is more simpler and elegant: Map&lt;Integer, String&gt; nums = API.Map(1, "one", 2, "two",3, "three"); Map&lt;Integer, String&gt; even = numsVavr.filterKeys( k -&gt; k % 2 == 0); 
I see, now we are playing word games. Maybe it is a side effect of my life experience working with big sharks, in real life oath means nothing until you get sued for perjury. And since you like so much of the pasting quotations game. "My reasoning is that either a) we‚Äôll partner with Sun as contemplated in our most recent discussions or b) we‚Äôll take a license. I think a clean-room implementation is unlikely because of the team[']s prior knowledge, and it would be uncharacteristically aggressive of us to position ourselves against the industry." [...] "My proposal is that we take a license that specifically grants the right for us to Open Source our product. We'll pay Sun for the license and the TCK. Before we release our product to the open source community we'll make sure our JVM passes all TCK certification tests so that we don't create fragmentation." -- Andy Rubin in 2005 They knew the harm they were going to do to Java community
I second this. Go for Vaadin in you need Java for the front end. GWT is still "low level" in terms of what a web framework should offer. GWT basically substitute vanilla javascript and do not impose a metaphor for a UI design. This means more work and scaffolding to do. 
Don't worry there is still Scala, it's never too late to become a Haskell Zealot in Scala land.
&gt; You're confused again. This is just a small representation of the vestigial Java garbage Google didn't want to put on a mobile OS. It's also why Oracle has repeated failed to develop a worthwhile smartphone OS. Java was doing pretty fine on Sony, Nokia flagship devices and SavaJe OS was getting lots of attention before Google came into town. &gt; C/C++ are ISO standards and, thus, royalty free. Not really. As an example ANSI C++14 costs $133.00 and ANSI C++ 17 costs $232.00. Compiler vendors are required to buy the actual standards for submission it ISO certification. &gt; Google doesn't use any Java trademarks nor do they use any Java IP and why should they care? They don't even use a JVM so your ludicrous argument that they're breaking Java's WORA feature is hilarious. They should care to implement Java as defined by the Java standard specification. https://docs.oracle.com/javase/specs/ &gt; It's their OS and runtime. They can pick and choose whatever they want. IBM, Unisys, PTG, Aicas, Aonix, MicroEJ, Azul, JControl, and many others selling commercial JDKs also have their bare metal Java OS for embedded development and mainframe (IBM, Unisys), with their own bytecodes and class formats, in addition to the standard tooling. Guess what, neither Sun nor Oracle ever sued any of them, because they play by the rules. &gt; Why would Android use a VM that's not optimized for memory constrained smartphone devices? Because there are plenty of commercial JVMs that prove whatever Google says are just excuses for ripping off Sun. Aonix, now part of PTG, was selling JVMs for soft real time automation in memory constrained military and mechatronic devices long before Google decided to buy Android. &gt; Well, it was invented by IBM so unless the patents, copyrights and trademarks were all donated they could go after Oracle. No, because it is an ISO standard, anything that is given to ISO, becomes part of ISO and are available to anyone that pays for being a board member, the standards and certification processes. Magic word here, which Google seems to have some problems understanding, *pays*. &gt; So do the customers they rip off. Usually when we take something from someone else without paying, it is called stealing. 
I am sure there are plenty of workarounds. However there is no point in fixing a problem that should not exist in the first place. Just use liquibase which does not suffer from this "filename-defines-version" design.
Yes that is one of the problems I was thinking. It just one of the cases.
I looked at the issue and unless I missed something it does not solve the root problem. Having the filename itself somehow affect the version of the migration is bad design. The filename should not matter at all (like in liquibase) Don't get me wrong. I really like flyway, but this particular problem is a deal breaker and is the only thing that is keeping me back with liquibase.
Meh. Where I work almost all new code is written using immutables and vavr. It‚Äôs so much nicer. 
[Jabba](https://github.com/shyiko/jabba) is really nice for making multiple Java versions: ``` # install Oracle JDK jabba install 1.8 # install Oracle Server JRE jabba install sjre@1.8 # install Adopt OpenJDK (Hotspot) jabba install adopt@1.8-0 # switch to a different version of JDK (it must be already `install`ed) jabba use adopt@1.8 jabba use zulu@~1.6.97 ```
homebrew. not just JDK but all the useful tools.
I started a proof of concept project using a git repo for migrations, one migration per commit, which let you do branch/merge traversal for migrations, which also solved a problem I had with customer-site specific migrations, environment specific migrations etc. The project never went anywhere but showed a bit of potential, I have video up on YouTube somewhere of it I should dig out.
There's no benefit to using an abstract class when an interface will do. Interfaces can be implemented multiple and once and interfaces can also be dynamically proxied. These probably aren't the reasons in the concrete case but it's why it makes sense in general to use a more general solution.
Homebrew all the way! [JDK 8](http://www.lonecpluspluscoder.com/2017/10/08/installing-other-versions-of-the-java-jdk-via-homebrew/) [JDK 9](http://www.lonecpluspluscoder.com/2017/04/27/installing-java-8-jdk-os-x-using-homebrew/) it says 8 but will install 9 instead.
Thanks but what is the history? Any references? I completely agree that an interface is the way to go, but why did they make Dictionary an abstract class in the first place? Then once creating the Map interface, why deprecate Dictionary? What did the conversation look like at Sun when this all went down?
/thread
For switching between different JDK versions, using the java_home command is good enough for me: export JAVA_HOME=`/usr/libexec/java_home -v 1.8` export JAVA_HOME=`/usr/libexec/java_home -v 9`
I'm surprised no one has mentioned jenv for managing your different versions http://www.jenv.be/
Well you keep calling the code fluent when it's not, so I'm assuming you think it's fluent just because it's shorter.
Backwards compatibility is incredibly important in Java. They accepted their failure and went with map to move forward. 
I made [switch-jdk](https://github.com/paul-hammant/switchjdk) because I didn‚Äôt like jenv. 
&gt;Java was doing pretty fine on Sony, Nokia flagship devices and SavaJe OS was getting lots of attention before Google came into town. Java was a failure on smartphones and SaveJe was the poster child and the only people paying attention to it was Sun when they wasted their money buying it. &gt;Not really. As an example ANSI C++14 costs $133.00 and ANSI C++ 17 costs $232.00. That seems like a fair price. Certainly lower then the 9 billion those clowns at Oracle are asking for. &gt;They should care to implement Java as defined by the Java standard specification. Since they don't call it Java, use the JVM, and don't use any of the trademarks that would be irrelevant. &gt;Because there are plenty of commercial JVMs that prove whatever Google says are just excuses for ripping off Sun.Aonix, now part of PTG, was selling JVMs for soft real time automation in memory constrained military and mechatronic devices long before Google decided to buy Android. Your ridiculous arguments are getting very pathetic. Google doesn't use the JVM, they don't use any of Oracle's IP, they've never forked Oracle's JVM or SDK codebases so there was nothing to rip off. &gt;No, because it is an ISO standard, anything that is given to ISO, becomes part of ISO and are available to anyone that pays for being a board member, the standards and certification processes. Oracle should consider making Java an ISO standard instead of being an embarrassing and ridiculed steward that thinks they can copying API headers. &gt;Usually when we take something from someone else without paying that isn't neither gratis nor offered to us, it is called stealing. Usually when something is open sourced, like the 37 Java API headers, there is no payment required. 
&gt;I see, now we are playing word games. You mean like your continued and incorrect usage of the term "forked"? &gt;Maybe it is a side effect of my life experience working with big sharks, in real life oath means nothing until you get sued for perjury. Using your definition of the word "forked" is cause for perjury. &gt;They knew the harm they were going to do to Java community What part of Schwartz's testimony wasn't clear to you? I'll repeat it so that it's burned into your brain. &gt;**Google didn't infringe on any Java intellectual property and didn't require any license from Sun as long as Android was not branded Java in any way.** 
I like this solution too
Not all nulls
Because there are no users!
Me too!
I have no idea why Java started with both Dictionary and Hashtable. With Java 1.2, they decided things were a mess and added in the Java Collections Framework: https://en.wikipedia.org/wiki/Java_collections_framework I believe that's when they depreciated Dictionary. &gt; Collection implementations in pre-JDK 1.2 versions of the Java platform included few data structure classes, but did not contain a collections framework.[3] The standard methods for grouping Java objects were via the array, the Vector, and the Hashtable classes, which unfortunately were not easy to extend, and did not implement a standard member interface.[4]
**Java collections framework** The Java collections framework (JCF) is a set of classes and interfaces that implement commonly reusable collection data structures. Although referred to as a framework, it works in a manner of a library. The JCF provides both interfaces that define various collections and classes that implement them. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Others have said it, but I'll say it too. [Homebrew](https://brew.sh/)
https://spring.io/guides
I just found this interesting because I just saw Hashtable for the first time at work today in some Java code written by a a C# developer.
++1 for Immutables (both the library with this name and the concept in general). I haven't adopted Vavr yet though -- just poked at it a bit.
I'm running 2.0 M6 in prod now and M7 in dev. Upgrading between milestone releases has been a mild PIA. Stability seems fine overall. I did run into a race condition in Micrometer (RC3) that caused a single transaction to fail. That's been the worst thing that wasn't apparent after my somewhat sketchy integration tests.
Homebrew is the best thing in the world. I love it. I love the homebrew. Mmmmm. Homebrew.
You can try to learn vaadin framework, however I do not know if there is any fun course but you can find tutorials on their official site
I'm also interested. have done a decent amount with node, but want to mess around with java some as well
Return `Optional&lt;Void&gt;` to ensure safety
`Optional&lt;Boolean&gt;` is nice when you need to represent four possible states
##*stabstabstabStabSTABSTAB****STABSTABSTABSTABSTAB*** # KILL IT WITH FIRE
&gt; may become more main stream when value types arrive on the scene What this actually means? &gt;A data type is a value type if it holds a data value within its own memory space. It means variables of these data types directly contain their values. Primitives?
&gt;What this actually mean? Have you heard of Project Valhalla? More specifically, [JEP 169](http://openjdk.java.net/jeps/169)? A value type does not have object identity, and is not nullable. This means there will have to be some other way to represent a value that is not present.
Now you are contradicting yourself. These are your words: &gt; There's already a dozen utilities for fluently creating collections like that. The word "fluent" is not mentioned at all on essentials4j's web site. I only mentioned it in this comment: &gt; similar expression would be easy / fluent to read Please try to understand that "expression that is easy / fluent to read" is not the same as "fluent API". If I knew there is some respected software engineer hiding behind the username "Aellus", I would take your comments more seriously. So, I would be interested in seeing some of your code (if you have a GitHub account)...
Yeah C# uses Dictionary in their collections.
[removed]
It all makes sense now. It was in a stub they provided for writing a plugin for a C# program. I went to find out what libraries I needed, lo and behold "Hashtable" was already in the JDK. I'd never seen it before, but that explains why they would make such an odd choice. C# just has to do everything backwards from Java, maybe it was to avoid lawsuits?
Why that name? I thought the project was something about Android.
In your rationale you state that it doesn't work properly for maven, does the maven plugin not work for you for jenv? jenv enable-plugin maven
Honestly, I can't remember. I didn't work for me (by some definition) a few years ago and I thought, fuck it Imma writing a shell script, which blew up into a little more than that incl. a spoonful of Homebrew (where I broke some rules too).
Necessity is the mother of invention!
Nah, C# is just designed by incompetents. ;)
I really don‚Äôt think so. That language had a lot of Java‚Äôs new features, and several still in the pipeline, ten years ago. Mostly because it was designed and implemented by an incredibly competent team.
Probably because it's so rapid :) 
Exactly! :)
I dont want to deal with procurement ;)
Yes. Oracle transitioned Netbeans to the Apache Foundation back in September. No. I do not think it will become super bloated like eclipse.
Yeah C# implemented some features first - poorly. And Java avoided the most retarded ones like partial classes. 
Bloated may not be the precise adjective, but nonetheless, eclipse has always seemed more complex and less intuitive than netbeans when trying to do much of anything. Netbeans seems to be fairly straightforward with just about anything I've had to use it for.
Netbeans if my favourite IDE, and while I used to bash Eclipse, using Android Studio made me love Eclipse.
&gt; If I knew there is some respected software engineer hiding behind the username "Aellus", I would take your comments more seriously. I don't know what you're looking for, I'm just commenting on these apis as I see them and based on the up votes at this point I'm guessing the other Java devs in this sub agree with me. Not that it means much overall, but it's a reflection of your audience here on reddit at least (which surprises me based on past experience on this sub). I don't really feel the need to validate myself so I'm not going to bite on your ad hominem. You can take my feedback if you want it, or just brush me off as a random reddit troll. Either way I feel like I've adequately explained specifically what I think is wrong with the "findIn()" method and how I suggest you could improve it. ¬Ø\_(„ÉÑ)_/¬Ø
I'm not sure how anyone can use an IntelliJ-based IDE and say it made them "appreciate Eclipse", but I guess this is why different IDEs exist... 
I've never worked on android, so I haven't seen that benefit. But as far as a Java IDE, it's tough to beat Netbeans. It just works, pretty much every single time.
Plus Maintaining a huge app in GWT is mush easier than React or Angular those need constant work to update your code to the latest version which has a lots of breaking changes, i've worked on big ERP project that was using GWT more than 9 years and still.
You rock!
I think he means the old Android Studio which was based off of eclipse 
Hahahahaha. Becuase they're not drinking the kool-aid like a bunch of people seem to. That's all there is to it. When you take a hard , cold look at jetbrains' java IDEs, compare them with the alternatives, they have absolutely no leg to stand on. If you drinkl the kool-aid before though, jetbrains is god and intellij is the second coming. 
That was never called Android Studio. It was just the Android plugin for Eclipse. Android Studio has only ever been used for the IntelliJ based IDE. 
If you actually try using the JB IDEs before you start to judge them for making you change your workflow from eclipse, you'd realize that they're superior in every way. Better inspections, syntax highlighting, plugin ecosystem, language support (especially for Kotlin, which I assume you hate without having given it a real chance, similar to your hatred of IntelliJ, but also for Scala and even other non-JVM languages), and a far more intuitive UI overall. 
TIL. I thought that was called studio too sorry. He could still have meant that ;) 
&gt;Yes. Oracle transitioned Netbeans to the Apache Foundation back in September. &gt;No. I do not think it will become super bloated like Eclipse. Up voted! &gt;Not that I agree that Eclipse is "super bloated". Up vote, denied! 
I simply cannot disagree more, I was a diehard Eclipse user for about 5-6 years of my career, transitioned to IntelliJ after using PyCharm at a couple of companies and I the ONLY feature I miss from Eclipse is the ability to save customised arrangements of windows/panes when I switch between my 3-monitor setup at work to purely using my laptop to my single monitor at home. This is the ONLY thing, everything else is far superior on IntelliJ.
If you‚Äôre open to Docker, docker-compose is pretty nice for this eg run Postgres and any supporting services in containers so all your developers don‚Äôt have to mess around with installing and configuring each. Then the same docker-compose stack gets used during integration tests for CI, easy spin up and tear down of the stack. Basically this makes it so for the most part the only tool dependency for developers and the CI server/nodes is Docker. Allows me to jump between PHP and Java based projects pretty easily without having to mess with configuring Apache and such. You can even run your builds under Docker to remove the need to install Java/maven locally but if you‚Äôre on a non Linux platform the file system performance could end up not being that great. So, usually on OSX I build and run Spring boot locally and just point that to containerized backing services eg MySQL, Elasticsearch etc that have been launched via docker-compose. Note we don‚Äôt actually run our stateful services in production in containers (using RDS instead) but it does help improve parity between development and production and reduces some of the ‚Äúwell it worked on my machine‚Äù. 
It also doesn't look like shit with dark theme, which is a huuuge plus.
Edgy bandwagon comment.
Eclupse is super bloated? I really dont think so. Infact its the most used IDE for java development.
Keep up the good work, I am a huge fan of rapidoid.
Any estimated NetBeans 9 release date? [Roadmap says](https://netbeans.org/community/releases/roadmap.html): Release Date TBD
Eclipse bloated? Do you work for JetBrains by any chance, just curious?
"Apache is where software goes to die." By transitioning NetBeans to the ASF Oracle basically said that assigning resources to Netbeans is a waste. And they are right. The Netbeans market share in the IDE market is neglible. - IntelliJ IDEA is the superior IDE in the Java ecosystem anyway, it is very hard to catch up with them.
As the case for the Eclipse Foundation.
Yea, but ... why? It is true that running docker nowadays means just installing it and then running your script, but if you can get away from that, why bother? I am not against docker at all, I just haven't seen its use in what I do. There is nowhere that docker can help me at the moment. I am keeping an eye on it (solution in the search of a problem), but until i have a use for it I am not touching it.
Wouldn't you know it. I have tried to use them, I am using them (not my choice) and I will use them (if i must). I actually am in a much better position than all these kids to properly make a judgement call on it: There are things that intellij does better than eclipse, things that it does worse and the 99% of things are the same (there's only so much you can do in an IDE). Depending on what you do and care about (programming in Kotlin for example is clearly in intellij's favour) the things that intellij does better are worth the money. For the majority of people out there though, when you do a clearheaded, cold comparison of feature by feature and then you also add the free vs cost measurement, intellij does not stand a chance. The only reason to use intellij is because you want to, despite all the evidence to the contrary. At which point you are on the same level of flat-earthers or trump supporters. 
Is lucene dying? :(
&gt; I actually am in a much better position than all these kids to properly make a judgement call on it LOL. Being older doesn't give you the right to condescend against anyone. I know some phenomenal engineers in their 20s whose opinions are worth so much more than some lackluster senior engineers. &gt;and then you also add the free vs cost measurement Uh, I use the community edition of IntelliJ. &gt;At which point you are on the same level of flat-earthers or trump supporters. I dunno, you just shared some "fake news" about IntelliJ with us. Maybe you're the Trump supporter. 
You could also do `Optional&lt;Optional&lt;Optional&lt;Optional&lt;Void&gt;&gt;&gt;&gt;` for more consistency and flexibility in your APIs. Just change the number of Optionals if you need more or less states.
&gt; It seems weird that most languages use Dictionary and Java uses "Map" Minor, but map is probably the most common amongst the most popular languages - C++, Java, Javascript - as well as being used by Haskell, Scala and Go. 
Do you have any actual points to make M$ shill?
That if you use that thing on your shoulders, you can see behind the jetbrains marketing. if you don't (as you seem to not to), you can buy into that bullshit. and "M$ shill"? really? like a 5 year old? i guess that explains everything.
Still waiting for a point. I guess you can't make one being a fucking retard.
/u/ndroock1 the writing style of that comment was reminiscently maoist propaganda sounding.
lol, indeed hahahaha.
Vaadin 10 will be replacing GWT with web components.
Apache has many important software projects under it. They may not not be the newest or the most hyped projects. But rather mature software projects that make up the foundation for many critical services running today.
I love Netbeans.
What makes things better on the Eclipse side, more specifically?
It‚Äôs always good to see a master at work
Video here: https://www.youtube.com/watch?v=zFL6ohRIf_A
GWT is dead, not sure why anyone would learn it these days if the goal is to be employable 
It's a fair question, considering how much JetBrains seems to spend on buying reddit marketingbots.
Because Android Studio requires a dual Xeon with 16 GB and a SSD to work without feeling I have a proper airplane getting ready to take off.
No, I really do mean Android Studio and did prefer the Eclipse based IDE and Ant SDK.
Performance for starters. Android Studio requires a gaming rig to be usable or turn off almost everything.
I envy your hardware then.
Nice project and well documented. üëè I'd probably be able to figure this out, but do have any quick-start-hints for incorporating this into a JSP application?
That isn't IntelliJ's fault at all. That's the Android build toolchain. Normal Java projects feel at least as speedy in IntelliJ as they do in Eclipse. Android is notoriously slow to build for and the build integration is not nearly as good as with Java. For example, you don't have to "Sync Now" when you change one thing in Gradle with desktop Java, it just auto syncs. Even building android from the command line is intensive. I will say IntelliJ uses more RAM than Eclipse, but I would rather have 16GB or even more RAM in this day and age, with Chrome tabs, Android emulators, Gradle daemons, and then IntelliJ. 
I don't have an example of integrating it in a JSP application, but it may be helpful to have a look at the [text-io-web-example](http://text-io-web-example.beryx.org/), which incorporates Text-IO in a web application built with npm and webpack.
I was just asking because (as I understood so far that) I need to expose an additional port for each terminal instance. Your project may be easier to implement into existing Java web applications if it would support the Servlet API (e.g. via a WebConsoleServlet class extending [GenericServlet](https://docs.oracle.com/javaee/7/api/javax/servlet/GenericServlet.html)). Maybe that's a reasonable milestone for version 4.0 or 5.0? :) Thanks for sharing, I have the project stared!
Thanks for the suggestion. I will add this to the todo list for the next release.
Eclipse compiler is miles ahead of whatever intllij uses. I know one csm configure idea to use the eclipse compiler, but I never got it to work as it does with eclipse. I really miss the instant compilation feedback. 
I don't think so. As far as I know, collections that return weakly-consistent iterators rely on compare-and-swap operation. "may (but are not guaranteed to) reflect any modifications subsequent to construction" - I believe that word 'modifications' is not used in the documentation accidentally - I assume that if your assumption was correct, they would state explicitly 'insertion' instead of 'modification'.
&gt; they are guaranteed to traverse elements as they existed upon construction exactly once I agree with you, but if what you're saying is true, the above guarantee is violated? I suppose the 2nd part of the sentence could be interpreted as an exception to the above guarantee, but if so, I wish they had worded it more explicitly.
Check out libgdx. It will make it much easier. 
A very shallow talk. If you worked with Kafka for more than 2 days, there will be nothing new for you. Out of 3 production failure scenarios, two are the sales pitch in two parts "homegrown automation sucks" - "buy our commercial automation".
I liked the video because it cleared up a few things. Message queuing is faster at receiving and delivering data to hundreds of millions of sources and targets because it disposes of the concept of atomic operations and atomicity. The "Giant mess" image is a bit of a lie, because everyone has access to the database in the same way as everyone has access to the message queue, what Kafka does is eliminate the holdups caused by column indices and timing guarantees of relational databases. So if you're consuming and producing terabytes of data from millions of customers on cellphones, message queuing is the way to go. Otherwise for an internal app, databases are more than adequate. You don't need to use a ten thousand PSI firehose to put out a campfire.
yeah, I feel exactly the same 45 minutes wasted - I was expecting some uncommon failures and wise lessons, but all I've got was Confluence commercials :(
None. Work experience trumps all this 
&gt; hundreds of millions of &lt;...&gt; targets Just be aware that it is not a Kafka use case. Kafka is great with a ton of producers and a very limited number of consumers. Ideal Kafka consumer is a batch processor which wakes up rarely (daily) consumes everything that happened since the last time and goes away. If you do not believe me, try this on your own: 1. Set up a small cluster with 10K topics/partitions per node. 2. Don't have any producers at all 3. Start adding consumers. Each consumer should subscribe to each ad every of topics you have (and all partitions). 4. Watch Kafka burn CPU and hog the network like crazy, delivering absolutely nothing of value. It is simply not a case for it.
I can say I used this for the functional BDD tests. Worked great and has good docs. Top tip make any timeouts a config value, so when you locally run tests vs say staging the don't have to take say 30 secs for external systems.
JavaFX was not that bad when I learned them a few years ago, maybe a bit cumbersome with collections and observables.
Looks nice, this should be in [awesome-java](https://github.com/akullpp/awesome-java).
What would you go for, when you have a few producers and many consumers? I'm looking for something and current I have the choice between Kafka and (IBM)... 
&gt; everyone has access to the database Lol... Currently working in a microservice system (&gt;500 distinct microservices) where no database is shared (beyond some R/O replicas with very specific reasons). Message busses, Kafka, REST APIs and if you need batch access, EDW. 
I work for a company that produces a (commercial) product that addresses precisely this usecase; we have customers running hundreds of thousands of topics with nearly 2 million subscribers at peak times. It doesn't offer the same transactional guarantees as Kafka, but it does fit a complementary role for large-scale broadcast. Happy to give more information over PM (I don't want to spam this sub with unsolicited sales pitches)
* Partition the topics across different Kafka clusters. Maybe add some middleware to do filtering? * Rethink your architecture if you need to have 10k topics accessed by every consumer. Maybe aggregating everything into one topic works? 
*Confluent, Confluence is a wiki-like product by Atlassian for managing knowlege
It really depends on many factors. Not knowing any other requirements you face, I would start with anything using AMPQ protocol. Something like Apache Qpid may be a good choice, but if you look at it you'll see there are so many options to choose from regarding the cluster configuration. RabbitMQ is great as well. Finally, it also depends on the volume of messages you are expecting to see. If you have a few producers and those are not producing too much, you may even be better of with Postgres (or something like TimescaleDB). Every high-scale solution comes down to an optimization problem. Where variables are number of queues, actors, messages and their size. One thing I do not like about Kafka is that it is not flexible. They solved the optimization problem for the one case - the one they had in LinkedIn - and if your case is not like that, the Kafka-based solution would not be optimal. If it is though, it'll work great. Kafka scales on one axis - the number of messages produced. Which is all they talk about when they talk performance - the ingestion throughput. If you try to scale it on any other axis, you will suffer. If you are looking at Kafka, it sounds like you are ok with loosing some small percentage of your messages. If that is true, this opens a door to so many creative performance optimizations...
yes
woops 
No-one‚Äôs mentioned [Apache Artemis](https://activemq.apache.org/artemis/) yet. It‚Äôs the rewrite of ActiveMQ using the HornetQ core and is proving to be much more performant and scaleable than its predecessor IMHO. There‚Äôs also the [QPID Dispatch Router ](https://qpid.apache.org/components/dispatch-router/overview.html) which might be interesting depending on your use case - it‚Äôs not a broker, it never owns messages - it gives an AMQP connection point into wider router / broker topologies and uses pathing redundancy rather than explicit HA to provide message resilience rather than persistence. If you‚Äôre working on the enterprise context and need support, Artemis is productised by Red Hat as AMQ7, and the Dispatch Router is AMQ7 Interconnect. 
Interesting - Actually, I was under the impression that you can set Kafka up so that you actually have reliable messaging. Was that pure marketing then? Thank you for the insight! 
Thank you!
Nah... I have 8GB and 128GB SSD macbook pro 2015 and it does alright... I never run the emulator though, I run directly on the device. Builds are pretty speedy on the device. Emulator on the other hand... I also am using Kotln. I would agree that overall, Android Studio is slow and takes up a lot of memory. IntelliJ is fast on both my mac and linux machines so I don't believe it is an IntelliJ issue. 
True. I'm on a 1TB 54000rpm HDD with 4GB of RAM, and I can't afford to have Android Studio and FireFox running at the same time. This is not considering that I have to run Photoshop to edit the image resources. It sucks. I'm saving for an upgrade, but should I go for SSD first or upgrade the RAM first?
People always request things :) But I'm assuming you saw a market for this database, otherwise the cost/benefit ratio of supporting it in the long run might not be worth it. Can you share some insight on what kind of market you think Cockroach will occupy?
Hi!
If you already have some programming experience, I can think of worst places to start.
I made this! This was my first attempt at a guest lecture/talk for a local audience of CS students. Don't judge too hard. :-)
Love the sign language on "Safe Harbor Statement" slide :) 
Maybe should've used less colorful words there... No ragrets!
If that means that it shows my preference for IntelliJ... yes. 
Doesn't seem like a bad place to start. Although it seems to miss some Java 8 features which I would consider essential for any intermediate Java-Programmer (namely the Stream-Api).
I think you'd be better off reading the Oracle tutorials.
Can you recommend a specific link to start?
Do you think I should read it and then supplement it with something else like the java 8 documentation from Oracle? Or can you recommend a better resource?
https://docs.oracle.com/javase/tutorial/ Go through Getting Started, Learning the Java Language, Essential Java Classes and Collections, you'll be in good shape to pick whatever you need after that.
RAM, Gradle eats lots of it, specially with the background daemon.
Not everyone is lucky to have SSDs on their work laptops. Pure InteliJ experience doesn't feel much different than Android Studio, specially with indexing keeping the CPU and HDD busy.
I heard Google still has open positions on Android team.
&gt; &gt;500 distinct microservices wtf?
Thank you!
&gt; Java was a failure on smartphones and SaveJe was the poster child and the only people paying attention to it was Sun when they wasted their money buying it. It was pretty successful in European market with Nokia and Sony mobile handsets. &gt; Since they don't call it Java, use the JVM, and don't use any of the trademarks that would be irrelevant. i must be blind then. &gt; Android Studio 3.0 and later supports all Java 7 language features and a subset of Java 8 language features that vary by platform version. https://developer.android.com/studio/write/java8-support.html Java is Java, trademark or not. &gt; Your ridiculous arguments are getting very pathetic. Google doesn't use the JVM, they don't use any of Oracle's IP, they've never forked Oracle's JVM or SDK codebases so there was nothing to rip off. And they should be squashed just like Microsoft was because of J++. No difference here. &gt; Oracle should consider making Java an ISO standard instead of being an embarrassing and ridiculed steward that thinks they can copright API headers. Google would still don't care about doing the right thing, "do no evil" is long forgotten. &gt; Usually when something is open sourced, like the 37 Java API headers, there is no payment required. The open source license wasn't available for embedded use. 
Another resource I can recommend is [Jenkov's tutorials](http://tutorials.jenkov.com/). For Java proper: http://tutorials.jenkov.com/java/index.html
It's a bit dated on desktop stuff.
I prefer to use POJOs
Yeah, you should probably be able to just follow that until the Exceptions part and then search for a Java-Streams tutorial on Google. There should be plenty.
Jeez, what's up with the ugly font? I can bear slides in Comic Sans pretty well, but this...
Having just had to work on a codebase that used JSONObject then POJO's is far easier to work with.
Data-binding hands down. I only ever use JSONObjects if I'm only interested in a sub tree and even then I typically databind the sub-tree into a POJO. 
I would always suggest to use Optional anyway because that way you have you can return null (as in Optional.empty()) or really REALLY null. A bit like enum Boolean { TRUE, FALSE, FILE_NOT_FOUND }.
he forgot JsonPath! use your JSON as data source and query it with JsonPath üòÄ just kidding... a little bit... 
[removed]
[removed]
Until you hit [an API which is not mappable](https://www.reddit.com/r/redditdev/comments/7im6xs/reddit_i_hate_you_for_this/).
&gt; Ambiguous method returns were a problem, and now we have optional. And now we have two problems... You definitely need an annotation + checker solution like null4j to get Optional to be useful without manual code inspection. And if you have such a solution, you don't need Optional, outside streams. 
&gt; Static typing is seen as more verbose and difficult for developers. It's Java developers you're talking about, verbosity is kind of unavoidable, be it the need to define new classes or use a dozen `get` calls on some `JSONObject` to get something out of a deep JSON structure, not to mention null-handling. &gt; JSON parsing library to load the data into HashMaps and ArrayLists. So `Map&lt;String, Object&gt;` and `List&lt;Object&gt;`? The contained element type may vary so you can't use anything better than `Object`. Might as well time travel to 2000 and use a raw `List` then. Not sure how you imagine such data structure would be navigated without being completely overrun by `instanceof` and casting? Using library-specific collections at least provides less ugly looking ways to navigate the same structure dynamically. --- All in all, I find POJOs superior to the alternatives. They at least provide type-safety within the bounds of my code, making only the data binding possibly problematic if the class doesn't match. Using the other approaches just builds on top of magic string constants all throughout the codebase that must match what the incoming JSON contains so when there's an error, it happens somewhere deep in my code, not at the edge of it. Also, POJOs make code completion etc possible, which is incredibly useful compared to having to look up some API responses to check what is there.
just HashMaps 
I know it's not pretty, but you can write a `TypeAdapterFactory` that handles one of the types separately and delegates the other type to the default factory. See https://stackoverflow.com/a/41724342/615306
use a Json encoding typeclass, while Java support for typeclasses isn't great, I don't see why one wouldn't be a great fit for this specific instance.
jet fuel can't melt steel beams
To be fair, using org.json in the first place is a mistake. There are much nicer json apis than that
By default Kafka does not flush to disk at all. Meaning that all the messages it ack'ed to producers are kept in memory and if you loose all of your ISR for a partition, you loose messages. There are two way to mitigate it. One is to enable the flush-to-disk via "log.flush.interval.*" settings. This takes away a lot of Kafka performance and makes it worse then other solutions. For example, Cassandra and Postgres and many others have a separate WAL file, while Kafka does not. Meaning that you can not set it up on a dedicated partition with a faster fsync. If you set "log.flush.interval.*" to flush to disk after each message, performance would suffer greatly. If you don't, there is still a chance to loose messages. Another option is to make sure there is no chance for all of your ISRs to go down. This means to up the number of replicas. You should also make sure that unclean leader election is not enabled (I think that's the default). Than configure your partitions to have quorum writes (Kafka does not have the quorum out of the box, so you have to do that math yourself and set the number of replicas required for a successful write). Going this way incurs smaller performance penalty (the messages are still in RAM, but on many boxes) and you can lower the probability of a message loss to as small number as you comfortable with.
Whether POJOs, JSONObjects, or collections, the main danger I've seen is when an application starts passing these objects around. It creates a situation where any change in the JSON body forces changes on the many paths these objects take through the application. It's good if you can think of a way to decouple the application from the JSON. Maybe the JSON comes in through one package, but other packages with a small interface surface then takes specific data from the JSON to perform specific tasks. 
There are some industries where Oracle Certifications are valued. For a while, I was working for a contractor that migrated companies to the Oracle Retail software suite. One of the selling points that the company used was that all of its employees were Oracle certified (and while the company preferred it being in specific products in the suite, they were okay with OCPJP since that meant certification in *something*). Of course, that also meant the company paid for the certification. At my current job, I am the only Java developer out of about 40 who has OCPJP 7. I know of two employees who have older certifications like for Java 5 (back when it was a Sun certification), but have no interest in updating. And this is even in the education sector where you'd think they'd really value services like this. I still choose to keep it up though since I find it personally motivating to help learn the features (others may have ways that work for them). Personally, I think the questions to ask are, in order: 1. Is this something that will personally motivate me to learn what I want to know. 1. Does the industry I work in value these certifications. 1. Does my company offer partial or complete reimbursement for these certifications (if the above is yes, then probably). If the answers are yes, then probably just go with whichever will be most valuable for the industry, or the Java EE / master certifications if you think that they will personally motivating to you. All that said, work experience is usually more valued in development. If you are unsure if it will be worth your time and money, I think it's probably not worth doing.
POJOs.
Yeah you have to work around that and it can get very, very frustrating like you have to make sense about something which is suddently a String and sometimes you can't do that. Well you can, if your model contains a SomethingOrString class, but man this is a mess.
The answer, like the answer for almost all abstraction, is "it depends". But mostly, the answer is POJOs. Unless you're a java self-hater and wish you were using javascript.
&gt;Null is not a problem, it‚Äôs a language feature. It can be both, and is. People don't toss around terms like "billion dollar mistake" for language features that aren't considered problems. Same goes for adding a null handling monad to the language's standard library - that's not an action you'd take if null worked great with Java. Java has a pretty robust static type system - until you run into null and everything falls down around your ears. That's a catastrophic design failure no matter how you slice it. I don't care if you use an Option monad like Scala or encode null as a true part of the type system like Kotlin, it should be a compile time concern just like any other typing issue in Java. &gt;If you want to write in a completely stream and functional way without nulls, then maybe you should use a different language. You mean like a language with a batteries-included Stream library, support for lambdas, method references, and higher order functions, and a monad explicitly designed to represent nullable elements? Java is now undeniably an "object-functional" programming language, and from what we know about the features due to be introduced Java 10/11/etc., it's only going to get more so over time. &gt;putting Optionals in every single class, method and field Well, that's obviously a bad idea. But everytime you need to represent "value may be missing", you should be using Optional to do it. Otherwise, you've just decided to turn what should be a compile time issue into a runtime issue. &gt;trying to create total immutability even when it‚Äôs not needed Java Concurrency in Practice says you should default to immutability. Why is Brian Goetz wrong? &gt;writing everything in a functional style no matter how cryptic the outcome Sure, defining typeclass instances or using monad transformers is not idiomatic Java. But using higher order functions and plain old monads now is - the standard library is full of both. And we're getting pattern matching against sealed record types soon, which is another classic part of functional programming. It sounds like your problem isn't with people who write Java in an object-functional manner, it's with Java's language designers who are deliberately pushing functional features into the language. And I don't think that's a fight you're going to win.
&gt; Well you can, if your model contains a SomethingOrString class, but &gt; man this is a mess. Doesn't sound like a mess, it sounds like exactly what you are supposed to do. Except I wouldn't call it `SomethingOrString`, but give the type a name that represents what the value is supposed to mean. Unless the API has no rhyme or reason, in which case mapping troubles are the least of your worries.
&gt; This may require the creation of a hierarchy of transfer objects in &gt; case your domain model can itself not be directly serialized to JSON &gt; format. I always do this. I don't want my domain model to be worried about the details of its persistence, and I don't want to expose internal details which would be required for it to be effectively deserialized/serialized. A DTO is perfect because it only has data and no behavior, and represents a snapshot of the domain object state that can be used for serialization.
&gt;It was pretty successful in European market with Nokia and Sony mobile handsets. No it wasn't. It was always destined to die due to the horrible software experience and OS. &gt;i must be blind then. You are blind. That's Android Studio, not the OS. &gt;Java is Java, trademark or not. Java is Java because of the trademark. Which is probably why they protect the trademark so much. &gt;And they should be squashed just like Microsoft was because of J++. No difference here. The only company that needs to be squashed and put out of its misery is Oracle. How many times do they need to lose before they get the picture? &gt;Google would still don't care about doing the right thing, "do no evil" is long forgotten. Oracle gives a new definition to the word Evil. Larry Ellison is also the devil incarnated. &gt;The open source license wasn't available for embedded use. Stop lying. The GPL license does not exclude embedded use. 
How many times have you used this tired line on Hacker News and Reddit? You're like a broken record. 
Truth never gets old.
&gt; No it wasn't. It was always destined to die due to the horrible software experience and OS. Says the Oracle/Sun hater. &gt; You are blind. That's Android Studio, not the OS. The OS looks a lot like Java to me. https://github.com/aosp-mirror/platform_frameworks_base &gt; **Java 91.7%** C++ 7.7% Makefile 0.4% C 0.1% HTML 0.1% Python 0.0% &gt; The only company that needs to be squashed and put out of its misery is Oracle. How many times do they need to lose before they get the picture? Until Google pays for what they stole from Sun. &gt; Oracle gives a new definition to the word Evil. Larry Ellison is also the devil incarnated. The guy has its charms. &gt; Stop lying. The GPL license does not exclude embedded use. It is a fact. Sun only allowed GPL with classpath exception for desktop and server use. Apparently you never learned about this concept of dual licensing. 
&gt;Says the Oracle/Sun hater. I liked Sun. It's amusing and embarrassing that you're an Oracle fanboy, though. &gt;The OS looks a lot like Java to me. It uses the Java language. Did anyone ever dispute this? Or are you confusing the Java language with the JVM and JVM IP that Android doesn't use again? &gt;Until Google pays for what they stole from Sun. Do I need to quote Jonathan Schwartz again? &gt;The guy has its charms. Hopefully dying soon is one of them. &gt;It is a fact. Sun only allowed GPL with classpath exception for desktop and server use. That's odd, the GPL license doesn't seem to mention that. Can you cite the exact lines in the GPL license where this is mentioned for the 37 Java API headers? Additionally, the court case is about copyright, which seems to invalidate your ludicrous claims. &gt;Apparently you never learned about this concept of dual licensing. Why hasn't this been brought up in the court case? It seems it would have been a good defense. Oh, that's right - it was never relevant. 
And your lies are gold.
Such as?
Aah OK, that makes sense. Thank you! I was playing around with aurea SonicMQ. I think it outperforms most current jms / mq implementations still. And it does sync to disk - usually that's the bottleneck. 
This comment is as useful as those, "I found the fix." forums posts. Please provide the "nicer json apis" that you are referring to.
Jackson, gson, basically anything else
Jackson is the most popular one
Just saw Joshua Bloch's tweet and jumped on this deal. Total with tax came to $35.30
Picked it up for $32.13 when there was [the pre-pre-order deal](https://www.reddit.com/r/java/comments/74x9gv/finally_effective_java_3rd_edition/do20p98/), but figured I would spread the news about this one too :)
Thanks! $26.39 for the electronic edition
65$ for international shipping.. well
Is this a good book to have for reference or for learning?
Once you've got a handle on the syntax and structure of Java, this book is a good resource* for best practices. You know--how to write *Effective Java*. *At least the 2nd edition was, hence the excitement about the 3rd edition.
If it's anything like the second edition you'll want it for bed time reading!
Same. Hopefully the watermark won't be annoying
Huh, I preordered in October and paid $38
Is it really worth getting this if I've already read the 2nd edition like 4 times. I imagine there can't be much more important stuff in it to justify buying the next edition.
Streams and lambdas added a lot of places to be ineffective. There'll probably be a chapter on just Optional.
Yes. The 2nd edition was written for Java 6. There have been substantial changes to the language since then. Personally, I'm excited to see what best practices make it in for streams and lambdas.
After doing a brief search I see this is a common problem. I thought I had heard they had some fixes for that, but I can't find any evidence. You can get a good deal on laptops if you look around... I have a dell xps that is basically the same specs as my mac that I got for $150 off some guy on LetGo. I run Ubuntu and it does pretty well and IntelliJ runs great. A lot of hardware is pretty cheap if purchased second hand. I don't see IDE developers really concerning themselves with worrying about ram, etc. too much in the future. Things will probably only get worse. Ideally, every dev would have 16-32 gb machine and a shit ton of storage. 
54000rpm hold this beast tight ;-) 
54000rpm hold this beast tight ;-)
The ebook is also available (now) as part of an O‚ÄôReilly Safari subscription.
Chapter 7 is on Lambdas and Streams.
i only have the 1st edition, so i went for the jump
Will wait for cheaper Indian subcontinent edition. no idea why US edition are 5 times costier + shipping. 
Yeah, that works. Qpid has its own broker. I like it, because Qpid as a whole is a set of building blocks which one can put together in whatever topology suits their needs the best. One can even emulate Kafka using Apache Qpid components and I would not be surprised if it would yield a better performance. And thanks to using standard protocols, it combines well with other components, such as Artemis. Which I also like, but never had an opportunity to use in real code.
Waiting to have indian paperback edition.
Thank you so much!
Thank you!
Any option to buy ch. 7 only? :) 
Only topped by your Google fanboyism, I cannot really top that. Surely on the good path for the best job evaluation review.
When doing contracting we always get customer assigned machines from their IT pool, so we need to live with what we get.
Yes, I am always a firm advocate of a standards-based approach. Especially if your architecture has several moving parts, it makes working with / replacing parts as required a much simpler proposition. 
&gt; I liked Sun. It's amusing and embarrassing that you're an Oracle fanboy, though. I am a fanboy alright. A fanboy of any company that happens to respect Java compatibility story, something that Google clearly isn‚Äôt doing it. The day Google does ship Android with full Java compatibility I shut up. &gt; It uses the Java language. Did anyone ever dispute this? Or are you confusing the Java language with the JVM and JVM IP that Android doesn't use again? You certainly are. Java the language implies Java the library, just like C implies libc, C++ implies libc++, .... Apparently taking you are doing bare metal programming without standard library! There is no separation of a language and it‚Äôs library. The moment it happens it is another dialect, no longer compatible with its official specification. Forbidding developers the freedom of taking any random library of the language, instead everyone needs to hunt for platform compatible libraries. &gt; That's odd, the GPL license doesn't seem to mention that. Can you cite the exact lines in the GPL license where this is mentioned for the 37 Java API headers? Additionally, the court case is about copyright, which seems to invalidate your ludicrous claims. Copyright holder can decide on what cases a given license is allowed to. If you think you are entitled to do whatever you feel like it with a GPL license, just try to sell software without paying for Qt‚Äôs commercial license, then argue at the court that it is your right, just because they dual license it with GPL and LGPL for open source non-commercial uses. Maybe you get lucky. &gt; Why hasn't this been brought up in the court case? It seems it would have been a good defense. Oh, that's right, it was never relevant. What is relevant or not, lies in the hands of the lawyers on each side.
Ah yeah. I've experienced problems with intellij that are rather easy on eclipse and visa versa. When I first started learning to code I used eclipse and then was made to switch to NetBeans and then made to switch to intellij. Intellij has been my favorite so far, but I'm also on an educational license. When I actually have to work, who knows what the story will be. NetBeans was my least favorite.
&gt; US edition should be available overseas in mid-January. International editions will be available later. My from UK amazon is coming in the next 2 weeks.
Oh nice, I'll check it out then. Thanks!
Well, stuff in the second edition is used as a reference in Spring and some official Java APIs (as in the APIs used in Java itself), so yeah.
Because it's carried by himself
POJOs :) 
A collegue bought this edition accidentally and it didn't contain all chapters and was printed on pretty thin paper.
that is 2nd edition, 3rd not yet out.
there's still lots of java applications that are 1.6, those that use struts are still alive. at least I was just interviewed with one multi-national retail company. so before you disagree, try to investigate why people are motivated for this. listen first, before you conclude.
Is there a proposal that makes `if else` and `try catch` to become statements?
Yes please! I find myself wanting this about 50% of the time I use a switch statement. 
I'm not sure what you mean. They're already statements.
Sorry I meant expression
Currently, no. They seem to be focusing only on `switch` right now, since it will be used with pattern matching.
That's true. However, it could be similar with the 3rd edition.
in 2nd edition there was some extra items later added which was not added to book but was free download for the buys. for 3rd edition that wont happen first few months, extra stuff may get added later.
The ternary operator is the if else expression.
I like the JEP, but this statement made me cringe: &gt; can be replaced with switch expressions which are clearer, safer, and faster: Massive opinionreason there... I can read if/else statements just fine. Not that I dislike the syntactic sugar suggested by the JEP.
Is it just me getting old and crumpy, or are the examples really not the best ones? &gt; int result = 0; &gt; if (month == 1) { &gt; if (day == 31) result = 100; &gt; else result = 200; &gt; } else if (month == 2) { &gt; if (day == 28) result = 300; &gt; else result = 400; &gt; } else result = 500; &gt; &gt; can be replaced with switch expressions which are clearer, safer, and faster: &gt; &gt; int result = switch (month) { &gt; case 1 -&gt; switch (day) { case 31 -&gt; 100; default -&gt; 200; } &gt; case 2 -&gt; switch (day) { case 28 -&gt; 300; default -&gt; 400; } &gt; default -&gt; 500; &gt; } The first code seems unnecessary hard to read. public int function getResult(int month, int day) { if (month == 1) { if (day == 31) { return 100; } else { return 200; } } else if (month == 2) { if (day == 28) { return 300; } else { return 400; } } else { return 500; } } Or if you you like ternary operators: public int function getResult(int month, int day) { if (month == 1) { return day == 31 ? 100 : 200; } else if (month == 2) { return day == 28 ? 300 : 400; } else { result = 500; } } Seems quite manageable. &gt; As we prepare to enhance the Java Language to support pattern matching, several irregularities of the existing switch statement -- which were always an irritation to users -- become impediments. These include handling of nulls (a switch statement throws NullPointerException if its argument is null) and that the current switch works only as a statement, but it is frequently more natural to express multi-way conditionals as expressions. So, the `switch` statement is going to be *replaced* instead of improved? I mean, fixing that `NullPointerException` would already go a long way...now if we also could something like this: switch (value) { case "something": return true; case "otherthing": return true; case null: return true; default: return false; } That would be great. Now if we could treat the cases like ifs, that would be awesome: switch (enumValue) { case VALUE_A &amp;&amp; isCorrect(): // Some logic. break; case VALUE_B &amp;&amp; !isCorrect(): // Some other logic with fallthrough. case VALUE_C: // More logic. } Hot damn, that would even allow abuse like this: switch (true) { case isSomeOption(): // Some logic. break; case isSomeUser(): // Some logic. break; case isStupid(): // Some logic. break; } I mean, I see that the `switch` expression really adds something, but can't we fix and improve the `switch` statement first? 
Is thay existent in java? If so what is the syntax?
&lt;waits patiently for the paperback&gt;
The proposed JEP would certainly be safer, and likely faster in most instances (O(1) v. O(n), etc). One of the things they have discussed is definite assignment, which can be a source of bugs when using an overly general language construct like `if-then-else`.
Your getResult() is 100x clearer than the switch
Same as other C based languages: (expr) ? trueAction : falseAction; 
What's the name of the font in ur webpage?
This isn't my webpage. It is a message sent in one of the OpenJDK mailing lists.
Possibly the result of familiarity. I didn't like stream operations the first few times I saw them. Now I prefer them.
&gt; In the years we have spent building &lt;LinkToOurApplication&gt;, we have detected and solved so many &lt;LinkToOurApplication&gt;s, and &lt;LinkToOurApplication&gt; with &lt;LinkToOurApplication&gt; will &lt;LinkToOurApplication&gt;. &gt; Being proud of my own craft, I can definitely recommend our very own &lt;LinkToOurApplication&gt; for the job. etc... 
Maybe. Its also useful that you can give a function meaningful name. Helps people reading the code. Of course getResult() isn't so good. The same can be said for functions vs lambdas.
If this could be used to verify if a list is empty, contains one element or contains more tha one element, it could become very useful, if paired with tail recursion. We could do Haskell-style programming in Java.
I think examples are not the best but this "new switch" is just a starting point. Look at examples given by Brian Goetz that combines this "new switch", data types, var keyword and improved pattern matching (with object deconstruction): sealed interface Shape { } datum Point (int x, int y); datum Circle(Point center, int radius) implements Shape; datum Rectangle(Point lowerLeft, Point upperRight) implements Shape; Shape shape = ... //Circle or Rectangle double area = switch(shape) { case Circle(var center, var r) -&gt; Math.PI * r * r; case Rectangle(var ll, var ur) -&gt; (ur.x - ll.x) * (ur.y - ll.y); } more in this presentation: https://youtu.be/qul2B8iPC-o
It looks like courier (im on mobile sorry)
The "switch as expression" were just pulled out from the [Pattern Matching JEP](http://openjdk.java.net/jeps/305) as independent, releaseable JEP
Oh, thx. It looks like a font in Mac's terminal.
Pattern matching is what I really want
If the switch gets changed as you propose ("treat like if"), it's really something else entirely. As is, the compiler can decide the case branch; if you allow functions, they can only be decided at runtime and may even have side effects, so it would need to define an evaluation order.
Sorry, I forget to post the link, here is: http://mail.openjdk.java.net/pipermail/amber-spec-observers/2017-December/000239.html
it will be whatever your browser's default font is for monospace (fixed width). I am viewing it in Chrome so it is Consolas. 
Why not store the entered numbers in a HashSet, that way you get O(1) look up times for each entry?
boolean contains = false; for (int i = 0; i &lt; array.length; i++) { If (array[i] == myNumber) contains = true; } If (contains == false) { // insert number }
There‚Äôs other ways to do it but that‚Äôs a way without calling any other methods
* Don't yell. * Read the sidebar &amp; posting rules.
&gt; If (contains == false) Ew.
Sorry
How can I do it with calling methods? 
what if you fill the array with numbers from 0 to 9 in order and then you scramble the array?
if(!contains) dude Jesus
But it does not handle blocks of code, right? I can write String s = a == b ? "same" : "different"; but I can't write String s = a == b ? {String paramWs = "xx" + a ; callWebService(paramWs);} : {String paramDb = "yy" + b ; callDb(paramDb);}; of course, that was a horrible design, but....
Helpful response üíØ
It's going to be released step by step I guess.
It's clear by now that the Oracle / OpenJDK guys mix up "readability" with "that feature that is currently hip".
Unfortunately my teacher would roast me for that. He wants it done just a specific way. We haven‚Äôt learned the shuffle function yet either
Holy shit that website will give your computer popup herpes for fuck's sakes.
True, but I guess one could implement two different code paths for that.
While I understand the basic point, I have no idea what's going on in that example.
This subreddit is **clearly** not for programming help as the plenty hints on the page indicate. **Post removed**
Yup. I wish they would publish an "incremental updates" for that kind of books. To read the diff if you've read the previous version.
No, 28th December is the release date. They will ship them later on (like they did clean architecture for instance). I've also pre-ordered from Amazon.co.uk.
More than the book from Amazon.co.uk and shipping to another EU country.
They must have changed the date, I'm sure it said 22nd before :( now I won't get it before my holiday
Yup, the changed it from mid-November IIRC to something, and then to 28th. It's a bummer, I pre-ordered in early October.
Does anyone know if this includes the additional chapter he was considering (related to threading IIRC?)? It's hard to go through his twitter due to the US politics.
This is interesting, but Scala had this implemented like a decade ago. Why not go all the way and implement all the features that Scala already supports? For example, [guards are very useful](https://alvinalexander.com/scala/how-to-use-if-then-expressions-guards-in-case-statements-scala)
The architects are looking into adding guards. It is being discussed on the OpenJDK mailing list.
That's what the full pattern matching JEP provides, this is just extracting the switch expression aspect as a standalone spec.
I know I am a little late to the party but in case somebody is still readying, you will save couple more bucks with discount code IUGD45.
it doesn't do blocks, but it does expressions. Using a block would kinda defeat the purpose of the ternary operator. String s = (a == b ? callWebService("xx" + a) : callDb("yy" + b));
Destructuring.
Your last example seems kind of pointless since one of the purposes of switch statements is to be faster than if/else if chains. You can't speed up ambiguous method calls.
Just your frequent reminder that SQL had `CASE` expressions before everyone else thought they were cool.
I think you are being overdramatic, the concept of null predates Java, so its inclusion by the designers wasn't a "mistake" but rather one of balancing competing priorities (like everything else in Software Development). Java is more than 20 years old by now, has included null the whole time, and has done just fine: there are conventions in place to deal with it, libraries that depend on it, etc. &gt; But everytime you need to represent "value may be missing", you should be using Optional to do it. Optional is not a general purpose null "solution" it was added for a very specific use case: API method return values. Use it elsewhere, and you will eventually find yourself getting into ridiculous situations as you start to find out other standard libraries and developers either DEPEND on values initialized to null or you start hitting the edge cases associated with those naive implementations (try to serialize an object model full of optionals, good luck). &gt; Java Concurrency in Practice says you should default to immutability. Why is Brian Goetz wrong? Did I not say, "even when it‚Äôs not needed"? Does your Rest endpoint model need to be immutable? Does your JSON pojo? The answer is no, and EMPHATICALLY NO when trying to be immutable is not only *not needed*, but *also* forces you to write a workaround because some standard external library does not support immutable objects, or you start to break conventions, or you otherwise decrease readability. &gt; It sounds like your problem isn't with people who write Java in an object-functional manner, it's with Java's language designers who are deliberately pushing functional features into the language. And I don't think that's a fight you're going to win. No, my problem is with the autists in this field who care more about language and CS purity over writing software that solves business problems cheaply and efficiently. 
Sweet! Would use a lot. 
Even better than: int result = switch (month) { case 1 -&gt; switch (day) { case 31 -&gt; 100; default -&gt; 200; } case 2 -&gt; switch (day) { case 28 -&gt; 300; default -&gt; 400; } default -&gt; 500; } Is to combine with the ternary: int result = switch (month) { case 1 -&gt; day == 31 ? 100 : 200; case 2 -&gt; day == 28 ? 300 : 400; default -&gt; 500; } Hopefully that works as well!
&gt;I think you are being overdramatic, the concept of null predates Java, so its inclusion by the designers wasn't a "mistake" but rather one of balancing competing priorities (like everything else in Software Development). "Billion dollar mistake" is a direct quote from the person who was responsible for the implementation of null in Java. So, we have it from one of the designers that it in fact is considered a mistake. &gt;Optional is not a general purpose null "solution" it was added for a very specific use case: API method return values. Use it elsewhere, and you will eventually find yourself getting into ridiculous situations as you start to find out other standard libraries and developers either DEPEND on values initialized to null or you start hitting the edge cases associated with those naive implementations (try to serialize an object model full of optionals, good luck). We use it everywhere, and have no issues with that. We use libraries like Immutables for our value classes, which automatically makes the fields of the class nullable references that can be serialized. However, the interface we're exposed to is completely safe, and all parameters are validated to ensure they exist if the attribute is not Optional. I recommend checking it out. We don't use any libraries that are so badly designed as to depend on null. &gt;Did I not say, "even when it‚Äôs not needed"? Does your Rest endpoint model need to be immutable? Does your JSON pojo? That is what immutable by default means - everything is immutable unless there is a strong and pressing reason not to be. Note that the data classes that will be introduced in a later version will also likely default to immutability, so if you have an issue with that this may not be the language for you. &gt;autists Very nice. --- In summary, if you object to object-functional programming you might want to switch languages. You don't seem willing to confront the fact that Java is becoming an increasingly functional language, monads and all. You're either going to have to roll with those changes or abandon Java for something more procedural - but continuing to fight the trend is just going to cause you a lot of pain as libraries increasingly adopt these features. Have you considered looking at Go? It seems like a language more in line with your approach, and one you might get more mileage out of than Java 8/9/10+.
Yes, I open it in my iPad then.
or poor-mans polymorphism
Ahrm...I meant syntax wise (`datum`? `Rectangle(var ll, var ur)`?). Also: [`var ll`](https://m.popkey.co/0be49d/DyR4M.gif?c=popkey-web&amp;p=popkey&amp;i=mrw-reactions&amp;l=direct&amp;f=.gif)
No, just you.
I don't really understand the issue here. Are you suggesting that languages shouldn't improve incrementally?
The ‚Äòdatum‚Äô keyword is a temporary name for data classes. They defined a simple data class Point that has an x and y field. The vars are the destructured data from the Rectangle class. Personally I hate the idea of data classes and destructuring but it looks lik they a pretty much confirmed to be added at this point.
Ahhh, I see, thanks for the explanation. 
Yeah, a *lot* of people are going to appreciate having data classes , more than there are people like me who dislike it :)
Right. Scala has that kind of thing.
It‚Äôs usually in the bottom gutter of each page.
There‚Äôs nothing on threading in the current rough cut version.
They're just standard zip archives. If you have a JRE/JDK installed and you're okay with the command line, then you can use: `jar -xf foo.jar` to extract them. If you're not comfortable with a command line, rename the extension to .zip and open then in what ever application OSX uses to support zip files.
I tried simply changing the extension, and all I got was a folder filled with the game files. I'm currently installing JRE, and I'm fine using command line, so once it's installed will I be able to use that to play the game?
Hold onto it...it will work for future Informit orders as well!
That's a shame. I've also heard that Java Concurrency in Practice is not likely to be updated any time soon, either.
It‚Äôs still easier and more intuitive to flip through a physical book than an ebook. When someone comes up with a solution to that I‚Äôll gladly get rid of most of my physical books.
As long as the island has power.
See my update.
You should look into Goetz presentation on Project Amber for Java 10. Some really good quality of life stuff coming! https://www.youtube.com/watch?v=qul2B8iPC-o
Generally speaking, currency should be modeled as an integer/BigInteger with an additional attribute denomination (USD, yen, etc). This makes it simpler to do most math and conversion that way if required as well. 
Why not long primitive?
What do you dislike about data classes?
Everytime I've ever dealt with money, BigInteger or BigDecimal have always worked best for rounding and calculating.
It just seems like they're a "quick and easy" way to make a class, when there is no need for anything to be "quick and easy". If you're going to be writing code that lasts, you shouldn't have anything that's just a fast solution. As soon as you need to start adding stuff to the class it will probably start looking pretty messy, but I'm not really qualified to say that that's actually the case.
You shouldn‚Äôt be rounding - the value should be a long consisting of the amount of the currency in the smallest unit, for example, USD should be the number of cents. If you‚Äôre dealing with amounts that would overflow a 64-bit value, then my hats off to you. That‚Äôs a lot of money.
you can find some open source minecraft plugins in [github](https://github.com/topics/minecraft-plugin), and learn from them. It will be a good way to start.
Makes it easier to accidentally convert into a float through a calculation and lose precision.
As soon as you do any calculations with the values you end up needing to round. 
&gt;I am a fanboy alright. A fanboy of any company that happens to respect Java compatibility story, something that Google clearly isn‚Äôt doing it. No, you're just an Oracle shill that can't accept the failure of the JVM on smartphones. &gt;The day Google does ship Android with full Java compatibility I shut up. Since more and more developers are transitioning to Kotlin hopefully that day is soon. I'd also like to see them deprecate Java. &gt;Forbidding developers the freedom of taking any random library of the language, instead everyone needs to hunt for platform compatible libraries. Have you ever developed an Android application? Because I'm sensing a lot of ignorance here. &gt;Copyright holder can decide on what cases a given license is allowed to. So you're not going to cite the exact lines in the GPL license to prove it was only applicable for desktop and server use? Did you have trouble finding it? It must be difficult finding something that doesn't exist. &gt;What is relevant or not, lies in the hands of the lawyers on each side. Well, it wasn't relevant because it had no merit which is why Oracle went for the hail ludicrous copyright claim on the SSO of 37 Java API's that Sun open sourced. 
Well, that's certainly better than being an Oracle fanboy. In terms of fanboy hierarchy there is nothing lower than a Oracle fanboy. It's the lowest and dirtiest you can go. Congratulations on getting there.
why?
It isn't uncommon to deal with fractions of cents.
Is your application going to perform calculations with the price? Then use BigInteger. Is it going to display the price without any calculations? Then use String. 
Floating point types generally aren't a good idea to use for currency. In JSON I would probably use a formatted string. I think in most cases the currency value will just be used as a display field and it'd probably be much too complicated to support internationalizing currency values in the UI.
&gt; If you‚Äôre dealing with amounts that would overflow a 64-bit value, then my hats off to you. That‚Äôs a lot of money. Depends on the currency. If you're using old Zimbabwean dollars, Z$9 quintillion was less than $300 USD when Zimbabwe switched to the US dollar. ATMs did allegedly encounter overflow errors in Zimbabwe in the late 2000s. 
What about https://javamoney.github.io/
Wouldn't you just use the integer to use units of whatever grain you need? For example, let the integer hold thousandths of cents if that is what you need. (I'm using integer generally, not implying a data size here.)
Sorry that advice is not helpful! If you are doing simplest invoice calculations with taxes and probably discount, you will get into the rounding trouble quite early: what do you show as sum for one position of an invoice and what as total sum? It is impossible to always get the total equivalent to the sum of independent calculated positions! It is easy to get differences in Cent. Just try it yourself üòâ BTW: there are even laws how to deal with rounding for financial transactions - at least here in Germany... But we are still the *masters* of tax rules üëø
I think you misunderstood, he meant that instead of measuring money in dollars and using the decimals for cent you only measure in cents So for instance $150 is 15000 and $34.56 is 3456 The benefit of this is that you don‚Äôt have to work with wonky rounding problems because you only use Long
A .jar file is a Java ARchive, hence the extension. If your .jar file is executable, the JRE (Java Runtime Engine) is what executes, or runs, it.
Why what?
No you haven't grasped it yet! You simply cannot overcome the fact, that you need to take care of fractional values. If you use some kind of integer values, you will have lots of differences between positions and the total sum. The best you can do is using a datatype that enables you to have a large precision and that enables you to deal with *decimal* based fractions. 
Unless you‚Äôre working with units smaller than cents (or your currency‚Äôs equivalent) then it works, you‚Äôll just always have to have the zeros there. It‚Äôs a bit awkward initially but it‚Äôs a really nice way once you get used to it :)
+1
Javascript can't do long. If you send a long to the frontend they can only consume it as an Integer afaik.
As the sidebar clearly says: &gt; **No programming help questions here!** &gt; These should be posted in /r/javahelp Also, it's unclear what JSON (referenced in the title) has to do with your question (representing money quantities in Java).
No it does not! To make it clear to you, imagine the following constraints for an invoice: amount position net tax gross 1 foo ? 19% 100 3 bar ? 19% 300 ------------------------------------------- total 400 tax: ? net: ? Show me the integer values you could use (with *cent precision* as you are preaching) in order to fill the "?" fields ;-) As a dealer I really want the integer alike values in the *gross* column, in order to make the client happy! Now it's your turn!
Convert into cents and you can just use an integer. Let the client convert the cents back to dollars if necessary.
I know it's a common case, so why not interface CaseHandler&lt;T&gt; { public boolean canHandle(T t); public void handle(T t); static &lt;T&gt; void switchCases(T t, CaseHandler&lt;T&gt;... ts) { Arrays.stream(ts) .filter(h -&gt; h.canHandle(t)) .findFirst() .ifPresent(h -&gt; h.handle(t)); } static class CaseHandler&lt;T&gt; of(Predicate&lt;T&gt; p, Consumer&lt;T&gt; c) { return new CaseHandler() { public boolean canHandle(T t) { return p.test(t); } public boolean handle(T t) { return c.accept(t); } } } } and you get CaseHandler.switchCases(enumValue, CaseHandler.of(val -&gt; val == VALUE_A &amp;&amp; isCorrect(), () -&gt; // some logic), CaseHandler.of(val -&gt; val == VALUE_B &amp;&amp; !isCorrect(), () -&gt; // some logic), CaseHandler.of(val -&gt; val == VALUE_C, () -&gt; // some logic)); } Which I initially started to write just for the joke but now think really doesn't look that much worse than your switch.
And a "number decimal places" field. Yen has no cents.
it'll be a glorious day when the reddit admins crack down on programming blogspam
In the case where 100 == $1, you can still parse through this. amount position net tax gross 1 foo 81 19% 100 3 bar 243 19% 300 ------------------------------------------- total 400 tax: 76 net: 324 To display it to a user, insert your currency symbols where needed. 400 becomes $4.00, 76 becomes $.76, and 324 become $3.24. This can be extended to fractions of a cent, but you must keep your decimal places consistent. If you needed thousandths of a cent ($.00001), then you're transpose the decimal to the right 5 places. Four dollars and 1 thousandth of a cent ($4.00001) would have an integer representation of 400001. The biggest drawback is that you must know how small of a denomination you are working with, or you will need to make conversions. 
I agree with the fact that plenty of work requires fractions of a cent, but your example doesn't. The only way it would is if you changed around net and gross.
Is there a JEP for JSR-354? I can't find one.
Thanks for responding faster and more elegantly than I would've
It doesn't define any font, so your browser probably defaults to the `monospace` font defined on your OS. 
How many places are you going to hold? Sometimes you'll have results with 6,7 or 12 places. And then you need to do math on them. That's why if you don't know the granularity BigDecimal is the right way to go. IIRC that was what we used in most places in a trading platform. If you know your granularity in advance you can choose long or big int, but you better pray to the right deity so that it doesn't change.
The BigDecimal type does not exist in JSON. So if you are using BigDecimals in your code (which you MUST if you are manipulating monetary values), your mapper (Jackson ?) will do the conversion for you.
Because you would have to multiply and divide by 100 many times making your code unecessarily complex.
You should not use normal 'numbers' in JSON for currencies. They are typically interpreted as floats in many languages and that will give rounding problems. In our API we use bigdecimals everywhere. They get (de)serialized to/from Strings.
&gt; Generally speaking, currency should be modeled as an integer/BigInteger Just use bigdecimal. What's the point of using a biginteger instead?
Wouldn't switching on floats and doubles suffer from the same problems as equating floats and doubles, though? I often use `if (f &gt;= x - epsilon &amp;&amp; f &lt;= x + epsilon)` instead of `if (f==x)` (or just ‚â§ or ‚â• depending on use case)... It would be nice if a switch on floats and doubles could convey a range of values: switch (f) { case 0.0 .. 0.15: // do something break; case 0.15 .. 0.6: // something else break; } Of course there will have to be a definition of inclusiveness/exclusiveness of range and maybe shorthand for one-sided ranges (i.e. `case &gt;=1.0` ~ `case 1.0 .. Double.POSITIVE_INFINITY`). 
This is how you write code that works instead of having a clean design, leading to complex code and lot of bugs. In OOP, one should always seek to represent things as they are instead of relying on the developer to mentally do conversions each time he has to think about it.
I would certainly think so. The semantics would have to address this.
&gt; If you needed thousandths of a cent ($.00001), then you're transpose the decimal to the right 5 places. Sorry but this is going to lead to a really complex code where your developer will not know what he is manipulating. 
We use BigDecimal in an app we built for a currency exchange company. No real issues. However if you're not doing any significant calculations then storing it as an integer (i.e. $123.45 = 12345) is a pretty safe way of avoiding floating point errors. I wouldn't use a String. You'd end up formatting / parsing in places where you need to do any calculations which is error prone in itself.
Why would you say that null is a problem in Java?
There's this thing about programing and CS in general, if you can't even find information by yourself then you are not fit to do it.
Watch Stanford 106A-Programming Methodology . And do the assignments . You could also try taking courses from Udemy , coursera. ... Another way you could teach yourself is by getting a java book. Start somewhere and stick with it . That‚Äôs my advice . There is a lot of good resources on the internet . Hope you find what you are looking for ! 
Try this http://mooc.fi/courses/2013/programming-part-1/ 
&gt; do u guys have websites that help me understand java better ???? This page's sidebar.
What *really* in the end made me learn java was making a game with libgdx. It's a game library which isnt too low level abs handles a lot of magic for you. But it makes you write code which means there is a huge learning effect. And immediately seeing things move around on the screen is also incredibly rewarding. Check it out: [libgdx](https://libgdx.badlogicgames.com/) 
That's an incredibly elitist and *wrong* point of view. Yea, maybe it holds up for seasoned developers. But for beginners, this is just BS
If you do not know the (upper bound of the) precision you need at compile time, then you should ask your client. Or make it configurable. Arbitrary precise decimal representations do not exist.
&gt; Arbitrary precise decimal representations do not exist. Hi. My name is BigDecimal and this is my documentation page : https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html First sentence of my Javadoc page : &gt; Immutable, arbitrary-precision signed decimal numbers.
Not a silver bullet though. java&gt; new BigDecimal(2).divide(new BigDecimal(3)) java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
Agree. I did part 1 &amp; part 2 of the course and it was very helpful. Part 2 is much more challenging though (in my opinion).
Many financial applications just use integer numbers for currencies, in one ten thousands units. so 1 EUR = 10000. In Javascript numbers you have Number.MAX_SAFE_INTEGER safe values which leads to a safe value range of currency values to up to ~ 90 trillion.
We use http://www.joda.org/joda-money/ It's basically a "wrapper" around big decimal, but it provides addiitonal currency and precision checks. 
What a horrible answer to give. Rubbish attitude
Many financial applications just use integer numbers for currencies, in one ten thousands units. so 1 EUR = 10000. In Java you could use a long for safe monetary values up to 10^17. 
You should read the documentation completely, not stop thinking after the first sentence. &gt; In the case of divide, the exact quotient could have an infinitely long decimal expansion; for example, 1 divided by 3. If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an ArithmeticException is thrown. java&gt; new BigDecimal(1).divide(new BigDecimal(3)) java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result. It is impossible to store a number with infinite decimal expansion (e.g. œÄ or 1/3) in decimal form without loosing precision or running out of memory.
As rude as it may be it's the truth. Work on your google-fu and self-study skills and then try again.
He doesn't meet the basic requirement that's just it. It's ok to not understand things but not being able to locate even the mainstream info on anything means he can't work independently.
`java -jar [path to JAR]` but Im not sure if thatll work for mobile games.
What's the point in putting such emphasis on their gender? Aren't we supposed to treat professionals and specialists according to their skills and achievements, not other factors like sex, age, race, etc.? 
Although they may appear to just be a more concise declaration syntax, the proposal says they will be treated more like aggregates. Will that come with trade-offs? Sure, but the use of data classes will also eliminate a source of bugs and discontinuity. Some developers are lazy, and don't implement methods like `hashCode()`, `equals()`, and `toString()`. Or even worse, some don't implement them correctly. This feature addresses that issue, and also addresses some users complaints about language ceremony. This feature is not meant to be used in every situation, just ones where you are using pure data aggregates, like `Point`.
We're not talking about hunting down bugs or learning a very specific framework or anything. OP is asking about the basics. Do you think it's too much to ask from a beginner to google "java tutorial"? Besides which, this has been asked thousand of times on Reddit, too. In fact, so many times that it is explicitly mentioned _in this sub_ multiple times that there are more specialised Subreddits for this very reason, and which list plenty of resources already. And for more there is always the search function..
that's why you need to define your rounding method and precision.
Stanford class seconded...
Because that number is a real number but not a decimal number lol so you are off topic
Rather than saving values in, say, dollars you can store them in cents. That way, generally speaking, you won't be needing BigDecimal. 
And instead you have to convert them. A previous project I worked on (also a bank) just used longs but IMHO just using a BigDecimal is much more convenient. 
The point is to increase the visibility of the women in our field, because let's be honest from the outside it looks like a boys club. These women are indisputably talented, which makes them good role models for the next generation of professionals and because they're good at their jobs, the toxic elements within our field can't do the whole "they're good... for women" bullshit.
Highlighting women specifically is meant to create visibility for other women in the community or women who might be thinking about getting involved in a community. It's almost as if you have no idea what it's like to be a woman in the tech industry and how much stigma and bullshit women have to deal with, compared to men.
I learned programming by doing it badly. I did it so badly yet so enthusiastically for so many years, that eventually I got quite good at it. Learning Java is just learning programming, but in a different language. So, build some programs you want to build. Doing this will take a long time and be very frustrating. You'll have to Google lots of things. But eventually you'll learn the natural ways to express ideas, and the mistakes you make will become harder to explain, but you'll be ready to understand the harder things. I repeat, it will take a long time - in my case, 35 years so far* - but it will be wonderfully fulfilling and you'll have a lot of fun along the way. * - 35 years programming, that is, only 21 in Java.
It looks like the answer is [no](https://github.com/JavaMoney/jsr354-api/issues/64), though a couple of the JSR voters [wanted to see a JEP targeted for Java 10](https://jcp.org/en/jsr/results?id=5782).
That's a shame. Without even a JEP at this point, we're not going to see it in 10. 
From the javadoc: &gt; The BigDecimal class gives its user complete control over rounding behavior. If no rounding mode is specified and the exact result cannot be represented, an exception is thrown; otherwise, calculations can be carried out to a chosen precision and rounding mode by supplying an appropriate MathContext object to the operation. In either case, eight rounding modes are provided for the control of rounding. Using the integer fields in this class (such as ROUND_HALF_UP) to represent rounding mode is largely obsolete; the enumeration values of the RoundingMode enum, (such as RoundingMode.HALF_UP) should be used instead. In other words RTFM.
&gt;It's almost as if you have no idea what it's like to be a woman in the tech industry and how much stigma and bullshit women have to deal with, compared to men. I can't say for all the world. It's quite possible that there are places with harassment problems. So I can only tell about my experience. I was born in and I live in Russia. In many aspects its rather.. "patriarchal" country. But I never experienced such attitude in science- or tech- related fields. In school, I was in "math class", a special group of children with intense math and algorithmic training. We had IT lessons too, there were even programming sessions. There were plenty of girls here (roughly a half). Among them the were "high achievers" who received best grades. Guess what? None of them went to IT. When I asked them why, they said it just wasn't their interest. After that I went to local university which was considered "IT specialist forge" at the time, to a Computer Security specialty, basically the "hardest" academic program. Again, there was plenty of girls here, including ones who achieved remarkable results. A lot of IT companies were "hunting" for students and even provided internship, and I know for sure that multiple girls from my group were interns there. Again, most of them chose not continue their career as an IT specialist. It was "boring" for them (I was suprised to hear this word as a reason, so I remembered it perfectly - "boring"). Funny thing is - I didn't pass the internship exam, but I persisted and eventually found work in another company. So those girls had a better starting opportunities than me and yet chose not to continue. Two girls who actually decided to continue in IT became great specialists - a programmer and computer security auditor. So from my experience, the reason why we don't have 50/50 women/men ratio in IT is because naturally women find different things interesting for them, even when given absolutely equal opportunities. 
Thanks @rellbits, I'll add this resource to https://github.com/neomatrix369/awesome-graal, unless you beat me to it. Happy to have such Graal / GraalVM related resources added to the above repo, look forward to pull requests.
Use a String, and do not use any formatting. This is especially so if you're communicating with Javascript. 
I looked into it and it said I would need a Java Emulator to run it. Do you know of one that exists for macs?
Arbitrary precision code is even more complex than this, and that's the other readily accepted solution. Here's the [source for BigDecimal](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/math/BigDecimal.java?av=f). &gt;Sorry but this is going to lead to a really complex code where your developer will not know what he is manipulating. I don't understand this. If you're working with numbers in a code base where precision is necessary, then the developer *has* to know what the required precision is. If it's arbitrary, that needs to be specified. This isn't complex, because there are two states of a number: the actual representation ($4.05) and the integer representation (405). &gt;Also you are assuming that we know the precision we need at compile time. You don't have to know the precision at compile time. You will need helper functions to deal with arbitrary precision is that is the case. However, real software is written with constraints and arbitrary decisions. It is feasible to write software to two decimal places and specify that the precision of the software does not extend beyond two decimal places. It is then up to the buyer to choose if the software fits their use case. If it doesn't, look elsewhere. Integer representation of decimal numbers is not a tough concept. There are three basic things needed. An extra value for precision, a [rounding scheme](https://en.wikipedia.org/wiki/Rounding#Tie-breaking), and conversion functions. The first is a choice, the second is a setting, and the third is a few lines of code. You don't need any additional math functions, because you're doing integer math with the provided operators. The first function is converting front-end representation to integer representation. Strip currency symbols, and append a `0` to help manage precision. That's it. Once the currency symbols are gone, you're left with the integer representation. To convert from integer representation, remove the precision placeholder, insert the decimal where necessary (based on precision), insert separators (if necessary), add your currency symbol, and you're back. 
Some people in this thread are trying _really_ hard not to use BigDecimal even though it's the right tool for the job
OP never suggested floating points. The question is between BigDecimal and String, neither which are floating point numbers 
In general, the convention is to use a number type when you need to do calculations and string when you don't. But in general, you always do it with money. Without knowing your use case, I would go with BigDecimal (best) or double.
Fact is that Java supports multithreading *and* non-blocking IO. That is why Kafka, Spark, Storm, and other frameworks where performance really matters are implemented in Java technology. 
Personally I download it from Oracle and install it from them and just set JAVA_HOME in my .bashrc. LATEST_JAVA=/Library/Java/JavaVirtualMachines/latest/Contents/Home export JAVA8_HOME=/Library/Java/JavaVirtualMachines/1.8/Contents/Home export JAVA7_HOME=/Library/Java/JavaVirtualMachines/1.7/Contents/Home export JAVA6_HOME=/Library/Java/JavaVirtualMachines/1.6/Contents/Home Then I have some aliases setup in case I want to switch java home to an earlier version: alias jsetL='export JAVA_HOME=$LATEST_JAVA' alias jset8='export JAVA_HOME=$JAVA8_HOME' alias jset7='export JAVA_HOME=$JAVA7_HOME' I use symbolic links to I can just change the link when a new update comes out: lrwxr-xr-x 1 root wheel 21 Nov 13 19:55 1.6 -&gt; 1.6.0_27-b07-395.jdk/ drwxr-xr-x 3 root wheel 96 Nov 13 19:55 1.6.0_27-b07-395.jdk lrwxr-xr-x 1 root wheel 16 Nov 13 19:55 1.7 -&gt; jdk1.7.0_79.jdk/ lrwxr-xr-x 1 root wheel 17 Nov 14 12:34 1.8 -&gt; jdk1.8.0_151.jdk/ lrwxr-xr-x 1 root wheel 14 Nov 13 19:55 1.9 -&gt; jdk-9.0.1.jdk/ drwxr-xr-x 3 root wheel 96 Nov 13 19:55 jdk-9.0.1.jdk drwxr-xr-x 3 root wheel 96 Nov 13 19:55 jdk1.7.0_79.jdk drwxr-xr-x 3 root wheel 96 Nov 14 12:34 jdk1.8.0_151.jdk lrwxr-xr-x 1 root wheel 3 Nov 13 19:55 latest -&gt; 1.9 
I see some nice pictures, but weird looking results. Is this worth reading?
I had to dig a bit but the Java benchmark is pretty dumb (and yes, it's a JSP page): &lt;%@ page import="java.nio.file.Files,java.nio.file.FileSystems,java.security.MessageDigest" %&gt; &lt;%! public static String bytesToHex(byte[] in) { final StringBuilder builder = new StringBuilder(); for(byte b : in) { builder.append(String.format("%02x", b)); } return builder.toString(); } %&gt; &lt;% String nstr = request.getParameter("n"); int n = Integer.parseInt(nstr); String s = ""; byte[] b = Files.readAllBytes(FileSystems.getDefault().getPath("/tmp/data")); for (int i = 0; i &lt; n; i++) { MessageDigest md = MessageDigest.getInstance("SHA-256"); md.update(b); byte[] d = md.digest(); s = bytesToHex(d); } out.print(s); %&gt; So no, it's a useless article. 
this is so sexist
We have a **dedicated subreddit** for this as is **clearly mentioned** in our **sidebar**: **/r/learnjava**. The **sidebar** there contains a wealth of learning resources, of which some of the best are listed under **Free Tutorials**. The rules here clearly state not to ask questions about *learning Java* or *programming help* and that is the main reason for the negative comments here. **Post removed**: learning Java
Because it's not captured by the type system, and therefore there's no type safe way to integrate null checking at compile time. Java's `Optional&lt;String&gt;`, Scala's `Option[String]`, Kotlin's `String?`, and Ceylon's `String || Null` all serve the same purpose despite different implementations - they give you a way to define which values are missing and which exist in a way that can be caught and verified at compile time. That means that Java, normally a strongly and statically typed language, suddenly loses all of that type safety the second you start passing around null values. We wouldn't accept if Strings suddenly lost all type safety when they were empty, so why is it okay that the "empty" case of other objects is completely unsafe? Note that I'm actually pretty agnostic on *how* you go about fixing this problem. I don't care if it's a Maybe/Option monad, Ceylon's true sum typing, or Kotlin's special hack just for nulls (well, I guess I do prefer the first two). What's important is that I get a way to say "this variable isn't null" that the *compiler* can verify for me, the same way I can say "this variable is a String" and the compiler verifies that. Let me know if any of that is unclear.
&gt; So from my experience, the reason why we don't have 50/50 women/men ratio in IT is because naturally women find different things interesting for them, even when given absolutely equal opportunities. Just look at the marketing for toys. Kids from a really young age are the 'victim' of gendered marketing. A lot of sciency or computer stuff gets marketed heavily towards boys. If you're taught from a very young age that computers are boys toys and this gets cemented in further at a later age by a lack of girls role models in CS, it makes perfect sense that by the time these girls turn 18 they move towards other types of careers. Claiming there is a 'nature' cause over a 'nurture' cause is incredibly short sighted.
&gt; FYI, this bean will use as response in my REST api. 
tl;dr &gt; "it‚Äôs appropriate for me to disclose that I am a Go fanboy" some good * the observation that concurrency is paramount * the use of hashing for "some consistent I/O and a controlled way to increase CPU usage" the bad: * doesn't use [kilim (my fork)](https://github.com/nqzero/kilim) or quasar for java - these libraries provide semantics very similar to golang * hashing 1000s of times (makes results very sensitive to a non-representative feature) * reading the same file each time (could allow unrealistic caching) net result is a cherry-picked benchmark and bad implementations in the non-golang languages to get the result he wanted. and a full page popup ad to boot 
This looks really interesting, but the format is really rough to read. I see each paragraph as a single, long line. Is there a nicer way to read these mailing lists?
On the mailing list, Gil reposted it to try and make the format better but it was the same as before. I copied and pasted it into a text file to make it easier to read.
&gt; Claiming there is a 'nature' cause over a 'nurture' cause is incredibly short sighted. That's mostly BS. My wife and I encouraged our daughter to pursue a carrier in engineering. She always had a computer and is very technical minded. One day, I noticed she was stressed out and I could tell that she was pursuing engineering to please us and not because she would be happy in that field. I told her to do what would make her happy and earn a living. She much happier now and she doesn't work in IT. 
How about `var yolo = someMethod();`. So readable. Or everything wrapped into Optionals... So much more readable.
I must say, I kinda hate myself for this but I could not resist .... but .... Would not bang
Nope.
Java emulator? Again, you need a JRE... Install one in your machine: https://support.apple.com/kb/dl1572?locale=en_US
That link is for the Apple-bundled Java 6. They got out of bundling Java years ago. You should download a [JRE from Oracle](https://java.com/en/download/), where you can get Java 8 or Java 9.
Are you trying to open the game to see its file contents (e.g. examine its pictures, music, etc) or to *run* the games? If you just want to look at the file contents, rename the Jar file from `.jar` to `.zip` in the Finder and open it up that way. If you want to *run* the mobile games, that's a different story. iOS doesn't use .jar for its apps, so I'm guessing these are Android. Neither macOS nor iOS are able to run Android apps natively. There are [Android emulators](https://www.androidauthority.com/best-android-emulators-for-pc-655308/) that are available for macOS, but I've never used them and don't know about the quality.
So, apart from one anecdotal example, what is your stance on nature vs nurture?
That the argument is over used.
Actually, it was possible to perform atomic operations directly on volatile fields using Atomic*FieldUpdater family starting from Java 5, Java 9 just gave us a better tool for that.
This 100%, the answers on here seem like they didn't even read the question. My Opinion: Financial Companies tend to use some form of 1 or 2 integers (Integers in the mathematical sense). Where if there is ahead of time known finite decimal places they use just one, and 2 when there can be differing values (I want to say NASDAQ uses 2 on their feeds I think) Everyone else AFAIK, use strings as the JSON representation of BigDecimals 
I think it's worth noting that until Java 5 reordering operations on volatile fields was allowed - this led to the infamous double-checked locking problem, in which the value of the object could be published before its constructor was invoked (it could have only been partially initialized).
You're spot on, even Juergen says pretty much the same thing in the comments [here](https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework), that to see benefits you'll need a reactive data store and most applications will most likely continue using mvc.
Reactive programming has been getting a lot of attention. It is the new and cool way to develop applications, mostly targeting scalability. That doesn‚Äôt necessarily mean you will see any benefits from using. It depends on the application, requirements, user base / load, performance SLA that may be in place, among other things. As you mentioned JDBC is blocking and that isn‚Äôt likely to change anytime soon. There has been talks of Async JDBC but who knows when that will come if ever, and what database vendors will support it. Non Blocking + Blocking =Blocking. If an application is mostly performing blocking I/O operations (such as JDBC) you may not see any benefit from the reactive programming model. You should always do blocking operations on a separate thread / thread pool with reactive programming, or you defeat the purpose of being reactive. You should ask yourself and team does it make sense for us to use reactive programming model? If it does by all means use it, but I wouldn‚Äôt recommend it just because it is new and all the rave. The thread per request model has served us well and for the majority of applications is perfectly fine.
Maybe you should‚Äôve chosen a better variable name üòä That‚Äôs one of the most important parts.
Mh, interesting. You could shorten that by assuming that the additional condition always is an `and` condition (anything else wouldn't make much sense, I'd guess). static CaseHandler&lt;T&gt; of(T value, Predicate&lt;T&gt; p, Consumer&lt;T&gt; c) { return new CaseHandler() { public boolean canHandle(T t) { return t == value &amp;&amp; p.test(t); } public boolean handle(T t) { c.accept(t); } } } CaseHandler.switchCases(enumValue, CaseHandler.of(VALUE_A, val -&gt; isCorrect(), () -&gt; /* some logic */), CaseHandler.of(VALUE_B, val -&gt; !isCorrect(), () -&gt; /* some logic */), CaseHandler.of(VALUE_C, null /* Or however you write an empty lambda */, () -&gt; /* some logic */)) ); 
Show me how it does not! 
The road to hell is paved with articles on "Introduction to Concurrency". Here is a list of 5 good books on the topic worth a look: https://javarevisited.blogspot.com/2016/06/5-books-to-learn-concurrent-programming-multithreading-java.html Brian Goetz one is pretty good, as is the one by Doug Lea. 
&gt; Substrate VM is a framework that allows ahead-of-time (AOT) compilation of Java applications into executable images or shared objects (ELF-64 or 64-bit Mach-O).
Role-models are important. Making everyone feel welcome or at least accepted in a community is also important. Use upvotes generously, and downvotes with greater care.
BigDecimal combined with java.util.Currency is a better practice. Here's a good resource about it. http://javapractices.com/topic/TopicAction.do;jsessionid=322310A8999F2251A405CDEDBAC711EB?Id=13
I think the comments here are self-evident examples of the sexism in our industry. People came here to disparage this article based on the headline alone.
In every example, they read a file into user space. If you're service a static file, nothing is going to beat using the `sendfile()` syscall. If you're copying a file from an input stream to an output stream in your code and performance is important to you, then you're doing it wrong.
As far as I can tell, mongo is the most common non blocking data store, though I'm sure there are others
Holy fuck, byte by byte copy? Nope, nope, nope.
You're right, having the JDBC be blocking does take away form the win, but I think there are still benefits. With Scala/Play Framework and ANORM or SLICK the tactic is to use a dedicated thread pool for blocking IO. https://www.playframework.com/documentation/2.6.x/ThreadPools And yeah, there are other nonblocking datastores out there. Cassandra. ElasticSearch. Several AWS and Google products. 
What this guy said. I don't own apple anything ^_^
Thank you, I'll look into them.
java
Awesome guys
I am curious why Oracle releases graal and related things under GPLv2 rather than more liberal licenses. Anyway, cool project.
**SPAM**
I think ALGOL 68 had case expressions before SQL. :-)
https://wiki.haskell.org/Software_transactional_memory
Does this work with any kind of java application? How about for example my application uses native libraries through jni? How about anything gui related like swing/javafx?
The RxJava 2 library and the Spring 5.0 framework are not really comparable as they serve different purposes. If you want to compare [RxJava 2](https://github.com/ReactiveX/RxJava) to something then that should be [Reactor (3.1.x)](https://github.com/reactor/reactor-core). Both libraries can be used for reactive programming in java. Both implement the same specification which is called [Reactive Streams](http://www.reactive-streams.org) so they are interoperable. The same specification is also part of the standard JDK 9 - but under a different package/namespace: [java.util.concurrent.Flow](https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html) RxJava is the more mature library - requires only Java 6 to work. Reactor is the newer library - developed by the same team who works on Spring. It requires Java 8 to work. Spring 5.0 introduced a new web framework called [WebFlux](https://docs.spring.io/spring-framework/docs/5.0.x/spring-framework-reference/web-reactive.html#spring-webflux) to make it easy to develop Reactive web applications. WebFlux works with Reactor by default. If you need more info a while ago I collected some stuff on this [here](https://github.com/akiraly/playing-reactor/blob/master/README.md) - including a bunch of links at the bottom.
Try your browsers reading mode.
http://javamoney.github.io/ri.html
If you're building 'new' stuff if you'd go for the reactive route backed by JDBC you'd end up with a 'blocking' implementation yes. But if it turns out that that particular service has performance issues you can solve by using a different data store (like Cassandra) that does offer async IO or a more native client to your current database that does, you don't have to rewrite the entire application. Aside from that the move to 'reactive' is really nothing special if you're already used to using Java 8 streams or Kotlin.
See https://github.com/graalvm/graal/blob/master/substratevm/JNI.md But your mileage may vary. So far, we did not use that for any gui related libraries. Give it a try and let us know :-)
My little little guess: they want to avoid licensing issues they had recently and fix their public image (in the end it might be good for us users)
I will try to give it a shot if I get bored over the christmas holidays. Do you have any preferred way to get a heads up?
That's ok, the point is to calculate sha sum from it, so you must read the file. But what's wrong with that is that it doesn't really exercise threads/asyncio. And in case of PHP, it just tests how fast the PHP can pump the data into a native function (nodejs probably too). Also with slightly larger files, this implementation will run out of memory, but that's probably not the point of the benchmark.
Touch√©
The first thing you should ask yourself is: What is the benefit of "reactive" in the first place? If you don't know the answer, then you probably don't need that benefit. Keep on blocking.
Assuming you are a professional and are using a competent IDE, I can bet that you let the IDE generate 90% of getter, setter. `hashCode`, and `equals` implementations. And if we as developers already rely so much on IDEs to generate this boilerplate, instead of writing it ourselves, why not just let the compiler do it for us and enjoy having our code much easier to read and maintain? And in the rare cases that we need to write a class that has a non-trivial equality and hash method, we can just fall back to the old ways and write it ourselves, since this is completely optional.
funny thing is, from what I found, java doesn't have optimized native implementation of sha, but manages to autovectorize it without much effort (-XX:-UseSuperWord is slower)
They talk about it in the documentation here https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web-reactive.html#webflux-framework-choice and they say: &gt; A simple way to evaluate an application is to check its dependencies. If you have blocking persistence APIs (JPA, JDBC), or networking APIs to use, then Spring MVC is the best choice for common architectures at least. It is technically feasible with both Reactor and RxJava to perform blocking calls on a separate thread but you wouldn‚Äôt be making the most of a non-blocking web stack.
The README.md should get you started. Start with building the HelloWorld image described there.
To make sure competitors using the code will have to release their modifications?
So that you need to pay them for a license if you want to use it commercially. Most companies are not willing to build commercial products using GPL.
&gt; I have to handle a bunch alerts from a system, monitor logs, and execute procedures based on the alert type. From your description it sounds like you may just want to use some existing tool like [Nagios](https://www.nagios.org/) but maybe your case is more specific or you just want to build something... If you're looking into building your own software for this look into [message queue](https://en.wikipedia.org/wiki/Message_queue) architecture / systems instead of building a single application to handle it (reactive or otherwise).
I've been wondering about this... Why not use phantom types to track currencies? Sure, sometimes you'll have to use wildcards, but then you're essentially back where you were without phantom types. But in many cases, you can tell at compile time if you're mixing up currencies by accident. 
You got me wrong! My example was in ‚Ç¨ or $ - NOT CENTS! The taxes are percents, not absolute values. So in other words, you have one position with a gross of 100 ‚Ç¨ and 19% taxes. The other should be 300 ‚Ç¨ with 19% taxes for three items. The total should be 400‚Ç¨ including taxes. Try to find a way to make this possible, if you only use two more digits for the *Cent* level (So 10000, 30000 and 40000 for the grosses)!
Side note : JSON and Javascript don't have integers. You can only have floating point numbers, (apart from some new fancy int arrays IIRC which isn't I JSON anyway) It probably won't matter, but it's worth noting that you can't just transfer any Java long as a "long" or an "int" to Javascript via JSON and expect to get the same value. 
I think the word you are looking for is "closed source" not "commercial". You can have open source software for commercial use under the GPL. That's why Android is using the Linux kernel without issues. If Android was closed source - not releasing their modifications to the kernel - they couldn't use the Linux kernel under the GPL.
the problem is if you initially use a data class, then realize you need a normal class. How do you switch without making breaking changes? It seems like an all-or-nothing type of system.
I don't know the implementation details of data classes in Java, but judging by what I've seen in Kotlin, it really shouldn't pose any issues. In fact, in Kotlin, you can just override the `equals` or `hashCode` implementation of a data class, if that's what you need. Now, I've heard that Java's `datum` classes may end up being just simple aggregates of `public final` fields, with `equals` and `hashCode` generated for you. So the only difference between a classic data class and a `datum` class is that you're not writing those two methods yourself. If the `datum` classes do not allow overriding those methods, you could simply just convert them to normal classes and write them yourself, the outside code would see no difference as you'd still have those `public final` fields. And if your class was not meant to be immutable in the first place, then you'd be having breaking changes regardless of the use of `datum` keyword. However, I really do hope they end up being more powerful and closer to Kotlin's data classes.
Learning how to do programming with Java is easy. &amp;nbsp; However, learning how to * configure and use Maven * use a web framework (e.g., Spring, Spring Boot, DropWizard, etc) * configure your application settings (e.g., database connection string, etc) * configure and operate a Java web application server &amp;nbsp; That is the difficult part even for a veteran programmer coming from another language platform/ecosystem (e.g., Python, .NET).
if you're open to an alternative to jdbc, [db4j](https://github.com/db4j/db4j) is a transactional database with java as the query language that features non-blocking queries
It's been some time since I've done concurrency in any serious way, but in volatile ordering example wouldn't it be possible for thread A to stop after write to x inside setter, then thread B does full getter, sees v==false, then thread A resumes set? Makes the example rather a poor one. 
Not only are you **spamming**, but you are also spamming in the **wrong subreddit**. This subreddit has a **clear** "**No learning Java**" policy. **Post removed**
This is really great to see. SVM is pretty magical: you give it a Java app in, and it spits out a tiny binary as the output (few megabytes for normal sized programs) in just a few seconds. The resulting program has no startup time overhead and starts as quickly as a C program would! But wait, that trick doesn't just work for Java programs. If you feed a Truffle interpreter into it, you get a JIT-compiling VM for your target language that also starts as fast as the best competitors. The entire thing is written in Java and from a quick browse of the code seems very cleanly done. Lots of comments, logical code structure, good use of annotations and compiler-recognised types. This could quickly become a force to reckon with, it should open JVM hacking up to a much larger developer pool than Hotspot can reach. And it should be a major competitive win vs Go, as now Go-style statically linked and minified binaries are easy to produce. A few ideas for projects that spring to mind: * IDE plugins to create native binaries out of a project without having to leave your editor. * Make the GC aggressively collect in the background when idle and free memory back to the OS. Java programs aren't as memory hungry as people tend to believe but HotSpot hardly wants to give memory back to the OS (because it's optimised for runtime benchmarks), so heap usage can bloat up and up until it uses huge amounts of RAM for no good reason. * Add support for a thin desktop toolkit like SWT. Combined with the idea above, now you can make managed, standalone desktop apps with minimal memory usage too. * Experiment with new GC designs like per-thread GCs for very low latency desktop/mobile oriented collectors. * Bind to Cocoa and use it to make iOS apps.
I am new to this functional thing, but I like ramda.js use of curry and the philosophy of functions first, data last. Looks like ravr is doing the same here: map(compose(add(1), multiply(2), subtract(__, 1)), List(1, 2, 3)); Any comments on what is hard/easy porting this ? Nice work! 
The variable name is rarely ever fitting. You only get the complete picture with types present.
OpenJDK uses GPL 2 and the long term plan is to incorporate all of the Graal related bits in to OpenJDK. Using a different license would probably create integration problems.
Hi marcolinux, The difficulty is mostly related to Java's type system. For example, it would be great to have a generic "map" function but I couldn't figure out how to do that so the regular "map" only works for lists; if you want to map something else you have to use "map_Either", "map_Option" etc. Also, doing partial function application by leaving parameters empty by using the "__" placeholder or by omitting the parameters entirely is only achieved by having exponentially many method overloads, which get generated by a custom macro system I wrote. Same goes for functions that use type aligned sequences as parameters. For example "doWith", which works like Clojure's thread last macro "-&gt;&gt;" (not originally included in Ramda, I just added it because I was missing it. E.g. doWith(someNumbers, map(add(4)), flatMap(repeat(7)), join(", "), System.out::println); The first parameter can be any value, then you get a vararg number of type aligned functions and the last parameter can be a function or a consumer. This is actually a bit tricky and gets generated by this macro: static Macro DO_WITH = Macro.of( List(), academicGenerics, Macro.MORE_GENERICS, (macro, i, max) -&gt; macro.getGenericNames().get(i), "doWith", List("A value"), (macro, i, max) -&gt; { String in = macro.getGenericNames().get(i); String out = macro.getGenericNames().get(i + 1); return "Function&lt;? super " + in + ", " + out + "&gt; f_" + in + "_" + out; }, (macro, i, max) -&gt; List(), (macro, i, max) -&gt; Tuple.of("\t\treturn ", ";\n"), "value", (macro, i, max) -&gt; { String in = macro.getGenericNames().get(i); String out = macro.getGenericNames().get(i + 1); return Tuple.of("f_" + in + "_" + out + ".apply(", ")"); } ); The rule of thumb is that the less idiomatic your code is the more difficult it is to implement the machinery that makes it possible and Ravr with the parameter placeholders and partial application is probably the least idiomatic Java code I know of.
I didn't say they can't. Doubles in Java can handle whole numbers, too. In Javascript, all numbers are doubles. 
See [RxJava vs Reactor](https://www.reddit.com/r/java/comments/6acxe3/spring_reactor_vs_rxjava/?st=jb6y8z4i&amp;sh=a662591b). Spring itself supports reactive programming on all layers, but the tool you would use for the actual async programming would be Reactor then, which can be plugged into the Spring framework. A very nice and powerful combination, by the way.
#2 really hits home for me. My (non-hacky) workaround is replacing lambdas with method references that either throw unchecked exceptions or handle exceptions themselves. It makes the streams a lot more readable, but leads to a bunch of extra methods.
Is it bad that I pretty much literally never use lambda expressions? Am I missing out?
Stream.parallel was a mistake. It's a rare use case, often needs special consideration anyway and makes streams so much more complex. It should have been a separate api, if at all in the stdlib.
Yeah big time dude check out streams
I've got a `Collector` for this, which I find to be a pretty handy way to go about it. Sure would be nice if there was one in the std lib though.
I mean I've used a few of them a bit in the past, especially when using interfaces, but.. is there actually a real reason to use them over writing things out? Is there a specific type of operation that can only be done using lambda expressions?
Agreed. The fact that Java 9 adds a Reactive Streams API makes it all the worse, since that can provide parallel execution of tasks with a way better API and fewer foot guns.
It does support basic networking using sockets. We are working on supporting netty out of the box.
I prefer thenCombine over zip for some cases, or stage.thenCombine(Pair::of) if I'm desperate. Real tuples would be neat though.
I'm in the same boat, never use them. (But that might be because everything at work is still on jdk1.6)
[Extract](http://tika.apache.org/) The Apache Tika‚Ñ¢ toolkit detects and extracts metadata and text from over a thousand different file types (such as PPT, XLS, and PDF). All of these file types can be parsed through a single interface, making Tika useful for search engine indexing, content analysis, translation, and much more. 
While it is a rare use case (*never* make a stream parallel unless you have a damn good reason to), it's kind of the whole point of streams. If you write your data processing pipelines idiomatically (no side-effects, no mutating elements in the pipeline, etc.), then you can parallelize the computation merely by adding `.parallel()`, and you have achieved the dream of streams.
If anybody is using ab to do the performance test, then you can just skip it. You need dozens desktops to generate enough load to challenge high performance servers. https://www.techempower.com/benchmarks/previews/round15/
The answer to trying to use checked exceptions in lambdas with streams is to go back to basics. It's almost always more readable to use Java&lt;7 loops for those cases.
You could statically import Collectors.toList() so you could just reference toList() if you wanted
What creates the brevity in your example is streams, not the lambda. The lambda replaces but does not eliminate the one line of test, everything else is done by the stream. 
I understand, but the whole point of the collect method is to generalize the action and prevent filling the steam API with a ton of extra specific reduction methods. It's not perfect but you can already do a static import and just write .collect(toList()) to shorten how much you have to read and write
I get that, but I would also be interested in knowing how many streams end with .collect(Collectors.toList()) I would be surprised if it isn't the most common ending.
While that may be the case, Streams API was designed to be functional, which is declarative. While adding "toList()" to Stream would be convenient from an imperative approach, it's an antipattern to what streams represent. With declarative features, you could easily swap out your collector, whereas having toList on the stream interface, it locks you into a more specific type of collection.
While I completely agree with you, it's noted that running streams in parallel isn't necessarily more performant. And actually, in all my benchmark tests, it's been slower.
I'm not suggesting removing .collect() just add a convenient way to collect as the most common way. .count() is a convenience as well --- mapToLong(e -&gt; 1L).sum();
Yeah, that's really my point, which is why I extremely rarely use them. "Regular" programmers don't deal with many situations where [N is big enough](http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html). "Regular" programmers also don't write code that is CPU-bound, which is also where streams shine. I could easily write code where a parallel stream wins by a mile, but such use cases (in my experience) aren't found in the bulk of real-world production systems.
reinstall windows will solve your problem
Do you have the latest version of Java for your platform (presumably Windows)? If not, download and install that. The Oracle page for this error indicates it might be a conflict with video drivers. If the update to the latest version of Java doesn't fix the problem, make sure your video drivers are up-to-date. 
A lot of applications only talk to their jdbc database. For such applications there might not be much to gain. Applications that talk to other applications in the course of serving their responses though, stand a lot to gain even if they use jdbc for storage.
Yea,both Java and graphics card driver are up to date. I even just reinstalled the graphics driver.. And yes I have Win10 
I understand the *idea* but in practice this is much less useful. Most stream processing is too small for it to matter, sometimes you'll have side-effects or relying on behavior only present in sequential streams. Also, when it does matter, you typically want to distribute the computation even further which streams don't help with at all.
This pattern of going from a collection of CompletableFutures/Optionals/Streams to a CompletableFuture/Optional/Stream that returns a collection of results is called [traverse](https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:traverse) in Haskell.
I am not all that fussed writing it the long way purely due to how good intellij's smart auto complete is otherwise it would get so annoying. It might not seem like a big change but after playing around in kotlin its ergonomically a nice touch to have `toX` methods at the end of a sequence chain. 
Why not? Because they didn't know how to type ‚Ñµ?
In FP (stream API is inspired from it), that's usually a bad practice to use exceptions. They came with Null Object pattern, Either or Maybe types. 90% of the time that's better to avoid throwing exceptions :)
 SELECT 'amen' FROM dual
And possibly saved us that `.stream()` call?
No.
Especially if you statically import `Collectors.toList()`.
He didn't mention my biggest gripe, debugging a single entry in a loop (ex: conditional debugging) becomes next to impossible.
The problem is that you often need to interface with libraries which throw checked exceptions.
I seem to not even be able to get past the first line of the example. mx build in the substratevm directory tries to build truffel, which seems reasonable to me. But this fails at the step '''Compiling com.oracle.truffel.api.dsl.test ''' With a stacktrace containing a few 'NoClassDefFoundError' for the class 'com.oracle.truffel.api.TruffleOptions' and 100 compiler errors about missing packages for the factories for the tests. What a I missing here? 
I'm not sure that extra methods is necessarily bad. As you mention, it makes the stream operation more readable. Even in situations where I don't have to worry about check exceptions I prefer to use at least a named lambda if the lambda is even slightly complicated.
More like: .collect(Collectors.counting)) ;) 
I use `.collect(joining (','))` surprisingly frequently.
I like this subtle, ironic snark: &gt; ‚ÄúJust because you don‚Äôt like the rules, doesn‚Äôt mean its a good idea to take the law into your own hands. Your advice is irresponsible because it places the convenience of the code writer over the far more important considerations of transparency and maintainability of the program.‚Äù &gt; &gt; Brian Goetz on StackOverflow It ironically places the convenience of not touching this part of the language design over the unanimous long term wish by the community to finally get rid of checked exceptions. :-) While we're at it: ^Can ^^I ^^^have ^^^^multiline-strings ^^^^^btw?
IntelliJ has a really nice streams explorer. It'll run the entire stream and show you the values at each step and how they map into the next stage. https://www.jetbrains.com/idea/whatsnew/img/2017.2/image101.png No idea if Eclipse or NetBeans has anything similar.
That must be recent, I looked for it late last year and didn't find it. Or I might have not looked well enough. But since then I learned my lesson and stopped using streams and use classic iterators, to avoid the problem altogether.
Use labsjdk-8u151-jvmci-0.39-linux-amd64.tar.gz instead (it's at the bottom of the page)
It can be used as a library, or started as a server and accessed from other programming languages as well (e.g. Python). The server approach is also nice if you don't want to pull Tikas giant dependency graph into your project. -&gt; Tika was a microservice before it was cool.
Why? It won't be idiomatic and a pain for new devs. Just use a functional language for the jvm.
Local type inference will make that even more concise Predicate&lt;Integer&gt; isOne = (i) -&gt; i == 1; Vs var isOne = (i) -&gt; i == 1; (Anyone new to streams, you'd use it like: List&lt;Integer&gt; list = List.of(1,2,3,4,5,1); int numberOfOnes = list.stream() .filter(isOne) .count(); assertThat(numberOfOnes, is(2));
I was just trying to make it as short as possible without using a stream, I didn't say it was a good idea. In addition to all that it's hard to read.
It would be nice if these issues were addressed, but if you are writing a lot of streaming/reactive/async/completableFuture type code, then it's probably worth looking libraries like RxJava which offer much more complete streaming API's.
Thanks that was a good read.
Yes, but mostly people use `Map` for caches and they don't check `Map.containsKey()`, so they run into this problem.
&lt;3
My impression was that ALGOL 68 was mostly designed on paper, and was very complex and difficult to implement. Full implementations didn't appear until much later and were never very popular. I guess one might think ALGOL 68 were cool if one likes backwards keywords, such as `do` and `od` or `case` and `esac`. Fortunately there is no `erudecorp` keyword.
Right not caching null is as a valid result is a common mistake. People also often forget that exceptions thrown from mehods are also a 'result' and should be subject to being cached as well. 
And when you try to use it to your advantage, you get pricked by JDK bugs! ([issue](https://github.com/ben-manes/caffeine/issues/176), [JDK-8186171](https://bugs.openjdk.java.net/browse/JDK-8186171))
And end up back at square one
And pray tell tell... if you don't throw where do all the exceptions you caught go then? Also its really not much fun writing wrappers for all the libraries you use to somehow make all their checked exceptions go away.
Sounds good, I need to try it out.
It is nice for the swing example. If you have you gui as a pure view in a mvc pattern this is a nice way to push indo from the model to the view
initially the OP states 2 requirements: * RDMS, which db4j provides * JDBC, which db4j doesn't support so if the OP is open to an alternative, ie non-JDBC, communication protocol then db4j may allow OP to benefit from the Reactive Web framework. but if JDBC is truly a requirement, then db4j isn't something that can be considered specifically, the OP wrote (emphasis mine): &gt; Am I missing something or is reactive really only beneficial for those how have the option to use reactive drivers for **NoSQL databases**? which suggests that he might be open to reactive drivers for RDMS databases, ie something like db4j 
No idea, why are you asking? ^^/s
How do I run the script and do you have a link to the full script? 
People are correct about using BigDecimal WITHIN your code. However if you need to serialize that value to JSON, you should be quite careful. The JSON representation is a string, meaning there are literally ascii digits there. But the serializers on either end will usually serialize these things to float/double unless told to do something else. So you CAN use the JSON number type, but there be dragons on either end. If you use a string, then someone will have to force conversion and that may actually force the conversation about money representation. On a side note. the problem with float/double and money has to do with fractions of value where the float/double system cannot precisely represent the values. BigDecimal works around this problem and also has rounding systems (if you set it up properly) which follow the same rules that banks use.
&gt; I'd merely suggest that some name with better semantics than PSEUDO_NULL be used, perhaps NOT_FOUND You're right, the `PSEUDO_NULL` name isn't optimal, but I think `NOT_FOUND` isn't much better either in this case. I've fixed the post to use the name that ultimately made it into Eclipse: `NO_MODULE`. &gt; And finally, thank you for not suggesting that the cache store Optional values. :-) Egh. That didn't even occur to me :)
Yikes. That looks subtle! Thanks for sharing
Good point. In fact the actual Eclipse code that is being discussed here suffers from that specific problem as well: static IModuleDescription getModuleDescription(IPackageFragmentRoot root, Map&lt;IPackageFragmentRoot,IModuleDescription&gt; cache, Function&lt;IPackageFragmentRoot,IClasspathEntry&gt; rootToEntry) { IModuleDescription module = cache.get(root); if (module != null) return module; try { if (root.getKind() == IPackageFragmentRoot.K_SOURCE) module = root.getJavaProject().getModuleDescription(); else module = root.getModuleDescription(); } catch (JavaModelException e) { return null; // Exception not cached! } if (module == null) { // 2nd attempt: try automatic module: IClasspathEntry classpathEntry = rootToEntry.apply(root); if (classpathEntry instanceof ClasspathEntry) { if (((ClasspathEntry) classpathEntry).isModular()) { // modular but no module-info implies this is an automatic module module = ((PackageFragmentRoot) root).getAutomaticModuleDescription(classpathEntry); } } } if (module != null) cache.put(root, module); return module; }
Agreed. Seems like there's a lot of low-hanging fruit for performance optimization that hasn't been picked. Do we know if there are any plans to use the Spliterator characteristics more aggressively in the future?
&gt;And finally, thank you for not suggesting that the cache store Optional values. :-) Hmm, why not? Is there a known issue around Optional values?
Yeah, same is true for Scala. I've seen `gather` used alongside `sequence` for lazy IO monads though, where `gather` is explicitly parallel and `sequence` is sequential (AKA calling fold with flatMap). ScalaZ and Monix both use the gather/sequence distinction.
True, I forgot about `thenCombine`. Thanks for the reminder.
Not sure I follow? `Flux.fromIterable(list)` doesn't really save a lot of characters over `list.stream().parallel()`, but it does provide you a lot more control over degree of parallelism, when and if you block, buffering, etc.
While I think I agree with you, I really don't think this is a case of declarative vs imperative. Both `toList()` and `collect(Collectors.toList())` are declarative - saying what they do rather than how they do it.
I believe we have `stream()` so we can have `parallelStream()`. If we didn't have the latter, we could have had calls directly on `Collection` instead.
&gt; web3j is a lightweight, highly modular, reactive, type safe Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network From Wikipedia: &gt; Ethereum is an open-source, public, blockchain-based distributed computing platform featuring smart contract (scripting) functionality.
My bad, thanks for clearing that up.
I hadn't heard or seen anything that was unanimous or long-term about getting rid of checked exceptions. Can you point me to the discussion?
Sure. [Here you go](http://lmgtfy.com/?q=java+checked+exceptions+mistake)
&gt; Nice, good example of a problem that can occur when null is used for different purposes. Wasn't that one of the reasons that the null object pattern was invented, so you could tell which of the two it was?
...and that would explain why C# made their `Dictionary&lt;T&gt;` throw a `KeyNotFoundException` instead of returning `null`. Ah, the benefit of learning from another language's mistakes.
No cause you handled the exception transforming into a special type that contains the error. You should never let outside libraries pollute your codebase with their way of working. If they change their interface, that impacts you in a way that you need to change every place in your code base... it should only change in the boundaries of your codebase. You really should look into functional programming, it changed the way I code today in object oriented.
You really should look into functional programming. They don't like exceptions and their code is really more readable. Read about that too : https://en.wikipedia.org/wiki/Null_object_pattern The naming isn't really good in that example, but that pattern is a lot better than throwing exceptions.
**Null object pattern** In object-oriented computer programming, a Null Object is an object with no referenced value or with defined neutral ("null") behavior. The Null Object design pattern describes the uses of such objects and their behavior (or lack thereof). It was first published in the Pattern Languages of Program Design book series. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Why..... why do this to you self
Philosophical differences perhaps? An IOException is an IOException, why should i hide a network issue from client code?
No, it's Bedrooms.
Or Scala e.g. Try / Either ?
BTW I'm not sure if you're trying to be a dick, but generally linking to "Let me google that for you" is a dick move
Yah, I thought the suggested solution was a bit hackity. Pushing an actual null instead of a magic object and then checking containsKey seems less surprising.
You should look at http://sparkjava.com/ Its a micro framework and you can get a fun project up and started in no time.
I can see where you're coming from, but the Try or Either monads aren't quite like the null object pattern. Optional is probably a better analogy, being a monad as well and one in Java's stdlib.
"You can include (and configure) Spring Integration by simply adding" - not really, security autoconfig doesn't do anything useful. 
Most of this if garbage (node, TS, angular, yarn...)
Working with Jackson on a daily basis, so this article has been much appreciated. Thank you!
A better service wrapper for Windows is JSL http://jslwin.sourceforge.net/
That looks cool. I've been using JSL forever which I love but good to see something else to try.
The problem is lack of parameterization. This isn't a fundamental problem with checked exceptions; it could be fixed with some additions to the Java language. First, allow a type-parameter to be a set of exceptions rather than a single type. This kind of type-parameter would only be allowed in a throws clause, not as a variable type. Second, allow a type parameter to have a default value. Stream would look something like this: public interface Stream&lt;T, X = {}&gt; { ... &lt;R, Y&gt; Stream&lt;R, X | Y&gt; map(Function&lt;? super T, ? extends R, ? extends Y&gt; mapper); ... &lt;Y&gt; void forEach(Consumer&lt;? super T, ? extends Y&gt; consumer) throws X, Y; ... } 
Never use `x-y` as an integer comparator. It's incorrect when the difference overflows.
In the actual Google search that leads to, right now the featured result is an article called "Checked vs. Unchecked Exceptions: The Debate Is Not Over". This doesn't sound like unanimity. I'm guessing you're mainly a server/backend programming kind of guy. I've found the utility of checked exceptions is most easily seen in client programming, where you don't control the environment your program is running in. If the user mistypes a filename or something, you don't want to shove a 40-line stacktrace in their face. This means you have to catch that IOException. Which, if it's not a checked exception, most programmers will almost always forget to do. On the server side, I'll admit that checked exceptions are less often useful - you can give the user a nice friendly error message when connecting to the database fails, but they still can't do anything about it. Reply to side note: Union types are semantically the same as checked exceptions, just less convenient since you need a bit of boilerplate per *call* rather than per method. Also, an error union is easy to ignore accidentally when you don't need the normal return value.
It depends on the constraints of the problem, of course. If your data is well within limits, it is perfectly alright using it. In any case, it was meant as an example, not as an example of production code.
You could have a map search return an iterator and then iterator.get() gives the value, but the map returns no iterator (null) if it doesn't exist.
Remember the adage that said "never trust the client"? Well, allowing the client to specify the input data type is precisely that.
Yes, the issue is that Optional sucks if you store them in a data structure. :-) Seriously, doing this is often evidence of a modeling issue. An empty Optional is a somewhat better way of representing the absence of a value than a null, but it still has no semantics. The null object pattern (as suggested in the article) is a much better way to go.
Yes, one of the reasons. Another is so that you can treat "null objects" uniformly with "non-null" objects without having to add a bunch of checks all over.
`NO_MODULE` sounds perfect for this case.
You can get memory leaks in any language, for what it‚Äôs worth. If you don‚Äôt have leaks, your program will keep running just fine.
I see, then with a programming language with automatic memory management, is there really any way to avoid memory leaks? Woudn't the fact that you don't have control over memory allocation make your program less reliable as far as memory leaks as opposed to making a program that you are certain will not have any in a more manual language such as c++?
It is good at long running processes? It's the only thing is good at. :) More seriously, the JVM has a relatively long start up time compared to the like C, Go or Rust. Additionally, the JIT process means that code performs better after it's been running for a short while. This means that Java is almost certainly not the right language for running processes that run for seconds (and possibly minutes). But for processes that run for hours, days or months, it's perfect. One of the places where Java is popular is on the server. Applications like Tomcat/JBoss or ElasticSearch are Java's bread and butter.
I think the person you are replying to probably means you can create memory leaks where you hold a reference to an object that you don't really need any more. So the GC is correct, but your application logic itself is too conservative.
Yes. I worked on a very big Java project, doing very complex stuff controlling machinery, and we had average uptimes of over a month. We were pretty much at the point of restarting only to install patches.
&gt; More seriously, the JVM has a relatively long start up time compared to the like C, Go or Rust. That's a little bit outdated, Java have improved over time. They've worked on reducing the amount of work Java needs to do at startup, so if you don't load up lots of dependencies the startup is pretty fast. I tried this (on a admittedly fast laptop): $ java --version java 9 Java(TM) SE Runtime Environment (build 9+181) Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode) $ cat HelloWorld.java public class HelloWorld { public static void main(String[] args) { System.out.println("Hello World!"); } } $ time javac HelloWorld.java real 0m0.653s user 0m1.413s sys 0m0.095s $ time java HelloWorld Hello World! real 0m0.181s user 0m0.169s sys 0m0.046s If you compare that to node, the startup difference is actually only 90ms which is pretty good for Java: $ node -v v8.5.0 $ cat helloworld.js console.log('Hello World!'); $ time node helloworld.js Hello World! real 0m0.091s user 0m0.068s sys 0m0.016s 
Compare that to /bin/true?
You think you can write better memory management than Java's GC? Drop Google or Amazon an e-mail, they'll hire you and throw loads of money at you. &gt; I see, then with a programming language with automatic memory management, is there really any way to avoid memory leaks? Yes &gt; Woudn't the fact that you don't have control over memory allocation make your program less reliable No Unless your program is trivial, you will fuck up your "manual" memory allocation. You'll forget to free something. Or you'll use something that was initialized incorrectly. Or you'll allocate less than what you need and start writing out of bounds. Pretty much any non-trivial program has at least one of these bugs. Languages with GC eliminate a lot of this uncertainty. You still have to think about memory, because only unreferenced items will be collected. But it's a lot easier to reason about "reachability" than it is to perform memory accounting every time you go off stack.
I've had internet-facing Liferay portal applications that have run unattended for over a year. Liferay is written in Java and is far from trivial. However, Java is a complex environment, not just a programming language, it will take you some time to master it.
/r/javahelp
I see, so if I'm understanding this correctly, as long as you don't have an unused reference being generated (ie. you don't set your reference to null when your done with it or something) java's GC is pretty much sure to return memory correctly. Do you happen to know of any tools off the top of your head to check for java memory leaks? I would assume it's different from non GC languages in that you won't know if you have a leak until after the gc cleans things up.
If you can say, what was the level of hardware on the machinery? just curious as to what kind of specs run the stuff at high up-times.
Yup! I definitely don't plan on doing anything perfectly, just curious about peoples experience with java as I'v been working with c++ most of the time and am relatively new to the automatic garbage collection java offers. Just being cautious before committing to my next program in java as it will need to be up for a very long period of time and I can't afford it to crash.
you don't even hate to set them to null. Many variables onli live in "scopes" and die as soon as the scope is closed. Static variables live only "once" per class, not once per object initialisation. As a general rule = as soon as there is no reference on stack to an object in heap, the object in heap will be deleted automaticly.
You could also check it with using `jaotc`, Java 9 new Ahead-of-time-compiler
Exactly. In OP's example, the compiler has no way to know what the type of `i` is, and the whole expression is most likely ambiguous anyway (which functional interface does this lambda expression represent?). All these issues are resolved by having the LHS declare the types.
Like 90% of the financial industry is built on Java. Amazon is built on Java. Google is built largely on java. Like any language you can write make it unstable. But java is pretty hard to do that.
You can ask Java what its heap size is, so by monitoring that you can observe that there's a memory leak. We logged it every minute, and graphed it later to see whether we were leaking.
I have used visualvm to debug memory leaks.
So you compare a compiled language against a scripting language and think it's good Java is only twice as slow? The fact the scripting language wins is absurd. 
Well the ecosystem also encourages longer startup times. You typically load many more classes at start than you would in other languages.
Memory leaks are programmer mistakes both in automatic and manually managed languages. Automatic memory management removes load from the programmer making memory leaks *less* common.
Apparently jaotc is not available for Mac yet :(
Memory leaks are unreferenceable memory. You can't do that in Java. Some people expanded the definition to holding onto objects you don't need any more with clickbait headlines. Don't let those clicbait blogs redefine what a amemory leak is.
Good stuff in this thread, but I want to say use a container like JBoss or Spring Boot. These programs are designed to run long term and host your code inside the container.
&gt;you don't set your reference to null when your done with it or something It's the other way around. Java is constantly checking to see if the object in memory has something pointing to it. Set the only variable that is referencing it to null and the object will be cleaned up next time the garbage collector is run. Memory leaks in Java are rare because the GC is so good at what it does that most devs, even on large complex systems, don't have to think about cleaning up memeory ever. To create a leak in Java you need to leave objects you no longer need referenced by an existing long lived structure. The best example of this I can think of is a home made cache that was made by someone who didn't use [Phantom Reference](https://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html)
You don't hide it, you let your software handle it properly. Is it really exceptional to have network issue? Or that is something your soft is expecting and knows how to handle it?
Most Java applications have a huge number of classes, on a very long class path. This is what causes slow startup time, and your hello-world example doesn't demonstrate this.
I've heard that explicitly setting references to null can impede some collection algorithms. Also it muddied up the code.
Depends. I would not trust it if it needs to run a year guaranteed. You have no control over memory deallocation and it is pretty easy to mess up by leaving a circular reference or something. It could totally work but you don't know until it goes wrong a few weeks in and you have to restart the application. 
Yep in case I would have to handle exceptions, I would prefer to use a Null Object pattern or an optional. I tried to explain that functional programming has a lot of concepts that are really great and when you know them, you don't write code the same way. Obviously I still have a lot to learn in that domain, but I think every one should try to learn it :) My point is : go find some meetups in your city talking about Haskell, Clojure or else and learn those languages :)
The GC handles cleaning up unused references, you don't to set it to null or anything. But you can still create "memory leaks" by keeping references you don't actually need, e.g. piling up data in a hash map.
Also note this is running a server VM with no tuning, and as such it's tuned for peak performance with little consideration for quick startup. There are a few ways to cut this in more than half if you're so inclined, see for example this write-up: https://mjg123.github.io/2017/10/02/JVM-startup.html JDK 10, which is now going into stabilization, is set to shave off another chunk for free, i.e., independently of what other tunings you apply. Try out the EA builds available here: http://jdk.java.net/10/ 
Actually a complex Java programm does even become faster the longer it runs. The VM gathers runtime statistics and optimizes accordingly and aggressively (e.g. object livecycles or branch predictions). The problem is when you restart the application, you normally loose all the previously made optimizations. Well, there are 3rd party tools / runtimes that allow you to store a profile and recently also HotSpot will open source something similar, so I heared.
Pretty easy to make create leaks in Java. Class A holds a reference on an instance of class B. Class B holds a reference on an instance of class C. Class C holds a reference on the previous instance of class B. Now replace the reference in A to another instance of B. B and C still refer to each other, so they won't be caught by the GC. 
Except js isn't a language they had mentioned. It's something else with a very a fair amount of start up overhead. For something on the list to put it in perspective: $ cat src/main.rs fn main(){println!("Hello World");} $ time ./target/release/hello Hello World real 0m0.001s user 0m0.001s sys 0m0.000s $ rustc --version rustc 1.21.0 (3b72af97e 2017-10-09)
They will still get collected, if there isn't a path to the GC root.
By experience, they don't. I had to figure it the hard way in prod. 
Obviously I don't know what JVM or GC method your prod is using, but mark-and-sweep GC should collect the memory occupied by the circular referenced objects. Java GC is difficult and often not predictable‚Äìmaybe the objects weren't collected YET in your test? Or perhaps there was another forgotten reference. But in general, Java GC is defined by mark-and-sweep from the GC root. Reference counting would be susceptible to the circular references without special cases, but I don't know any JVMs that use reference counting.
G1GC and even ConcMarkSweep handle this case. What's your test case for this?
I'm not entirely sure. It had to do with replacing a ScheduledExecutorService (which had a circular reference with its tasks). Maybe it came from the task itself... Still the root cause was the circular reference. 
That would be caught by gc.
In Java, `Dictionary` was already badly implemented, so they had to go with `Map`, but undoubtedly made some mistakes with it as well. If `Map` could have waited until Java 8, we could at least have had `Map.find(K key)` returning an `Optional&lt;V&gt; value`.
The null object pattern has a different goal than hiding exceptions. It's irrelevant to this discussion really.
No, i don't need to handle it, the code calling *my* code does. It's up to *them* to figure out what is wrong with the network in thus context. Which, again, brings us back to square one: the intolerance to checked exceptions in the `Stream` interface is extremely frustrating. *Especially* considering that `Stream` is an abstraction over a source that may be local or remote, finite or infinite.
Lambdas by themselves are not the issue. You can very well define your own functional interface that declares a checked exception; passing a lambda of that type to a method that accepts it poses no issues. The issue is that all `Stream` operations explicitly *forbid* checked exceptions.
Your root cause was the GC root which was likely the thread/pool attached to the ScheduledExecutorService implementation having references to the other objects. I don't think this is a circular reference or at least not as it is usually defined in the Java community.
&gt; You still have to think about memory This isn't a great strategy from a performance standpoint.
Not really. Scripting languages are tuned for fast start times, not the complex modular loading of something like Java. They also have a lot less code to deal with, as there is only a handful of types period. How many types are loaded in Java just to run Hello World?
&gt; Memory leaks are unreferenceable allocated memory. No, memory leaks are allocations that are not de-allocated when they are no longer used. You can definitely end up with such situations in Java, it's just harder to make happen than in a language like C++.
This actually looks ok, and nicely engineered. A lot of the JavaDocs are in Chinese which is an obvious issue in the West, although I acknowledge that China has the same population as Europe + U.S. + Canada and then some... The util (called *Kit) classes don't stand up to today's modern standards anymore. Some are simply outdated, some are ambiguous, but in general they do their job. What is the intended scope and/or audience of this project? If you mean this for general use and production, then no, sorry, absolutely not yet. There are better and more mature alternatives. Or do you have any unique features that other Java framework lacks? As a personal learning project this looks very good, though.
That's a re-definition that diljtes the meaning of the term memory leak 
I'm not sure what you just said.
&gt; How do I run the script If there is an icon to the app on the desktop right click and see what the 'target' is pointing to. If it's a bat/sh I'd look at the contents of the file. You should see where it builds up the java command to start the app. Usually in such scripts they cater for something like JAVA_OPTS which can be overridden via the terminal. So SET JAVA_OPTS="-verbose" run-my-app.bat or you can invoke manually: java -verbose -cp ..\libs -jar ..\libs\app.jar 
Also something else I see that impacts start up time is the insane amount of reflection some projects do
&gt; as soon as there is no reference on stack to an object in heap, the object in heap will be deleted automaticly. Real nitpick here. It's more like "if there is no reference on the stack to an object in the heap, the object in the heap will *eventually* be deleted automatically." The Java GC makes no promises about how quickly things get garbage collected, and there can be a meaningful delay between when no references remain, and when the object is cleaned up. It's usually a total non-issue, but it's worth noting.
from wikipedia: https://en.wikipedia.org/wiki/Memory_leak and form oracle: https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html nice try though
Yes, the most popular commercial controls platform ([Niagara](https://www.google.com/search?q=tridium+niagara)) is built on it. Their controllers can run for years.
Thank you for your comment. About the end of Kit as a standard tool, which I may not understand enough, really can work, I hope more good developers launched PullRequests. I did reference the existing framework before doing this project, for example Spring, as well as lightweight Spark, was designed to allow individual developers to quickly develop small and medium-sized applications. I can now describe some good features: it can be run directly as a JAR package without a web server, and from the outset do not want to add too much Lai, comes with JDBC Operation (class ActiveRecord) Conforms to the simple design. Most of the Web framework from the architectural point of view are similar, it is difficult to generate greater replacement, even if there are also users need to understand the design idea (which may be more difficult), my brain cells are hard to come up with some better characteristic, So, two years later today (released in 2015) will be released again on social networks in the hope that more people can get their opinions. I do not want to stop there.
Uh... Erlang ?
This is ridiculous. The scripting language has to parse and compile the program before starting up. The Java code is already compiled to binary bytecode, which is really fast to load. &gt; How many types are loaded in Java just to run Hello World? You don't load types. They're built into the language. And scripting languages have the same types. Int/string/boolean etc etc exist in both languages. The "types" that Java spends time loading are the language libraries. But the scripting language has a standard library, too. So he's completely right. The fact the scripting language wins *is* absurd.
You are not hiding exception with that pattern.... so whatever stay with your convictions I won't change your mind.
Yes I would use Java for long running applications without hesitation. Have many applications that have run for more than a year with no intervention. All languages give you enough rope to hang yourself.
What?
**UH... ERLANG ?**
Let me be a little harsh. The API is just fine in that case. The problem does not come from the API, it comes from your way of writing code. :) When you propose an API, you never accept modifying it because some people don't use it the right way.
/r/reddithelp
I probably deserved that.
Yes I would use Java for long running applications without hesitation. Have many applications that have run for more than a year with no intervention. All languages give you enough rope to hang yourself. EDIT: moved to right place. Sorry mobile app was confusing.
In my 10 years of programming in Java, I have not seen the GC not do its job. The GC‚Äôs job is to free all memory that is not used by the application anymore. Circular references among garbage objects do not present a problem. There are also no dangling pointers. In Java, a memory leak is an object graph that grows unboundedly because elements are continuously added but not removed. An area that is somewhat prone to this kind of programmer error is some sort of registry: An application no longer references an object, but the data structure serving as the registry still references that object. So, even in Java a memory leak is possible but in my experience it is much easier to find and fix than a memory problem in C/C++ code. 
&gt;Many variables onli live in "scopes" and die as soon as the scope is closed. Only primitives. &gt;as soon as there is no reference on stack to an object in heap, the object in heap will be deleted automaticly. Not really true, either. When an object is allocated, it is almost always allocated on the heap, and the garbage collector can only reclaim its memory when no *other* objects have references to it (unless there's a circular reference).
It's okay if you have a limited set of known, trusted data classes without any logic or side effects in them. That's what jackson actually recommends. But allowing a client to specify arbitrary class names is a disaster waiting to happen. &gt; More modern versions of jackson have a blacklist with known dangerous classes that it refuses to deserialize here. Never trust a blacklist to be complete. Whitelist known classes after careful evaluation or don't do client defined types at all.
In a high-level language, memory that is unreachable through application logic (but not unreachable for the GC), the term ‚Äúmemory leak‚Äù is a fair equivalent in my view. I seem to have forgotten that that‚Äôs mainly my own view and not convention, but it‚Äôs certainly not something I picked up from clickbait blogs.
I suggest putting some comparison code between plain Appium (for example) and coteafs-appium to demonstrate why users should use this over Appium, as it's not immediately clear to me.
&gt; When an object is allocated, it is almost always allocated on the heap Not really true, either ;) in a world with HotSpot escape analysis.
I was thinking if the following is possible? If you could preload the jvm in memory as a service, then theoretically you wouldn't have to load the jvm and in this case just load the Hello world class and run. I think that would make allow for insane speedups. 
Guys, this not mongo DB. This is the language/environment known for supposedly running 9 9s. https://stackoverflow.com/questions/8426897/erlangs-99-9999999-nine-nines-reliability don't get me wrong I love the JVM, but it was not setup like erlang WRT long running reliability.
Circular references: https://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references Any examples of "something"?
You should read up on Java bytecode and JIT.
They want to run it on a raspberry pi; I don't think nine nines is a goal.
Yes. I work on the Liquid Robotics WaveGlider a Java powered robot that spends months at sea without a reboot. Our shore side services have similar uptimes though they would be less impacted by reboots. Our older generation hardware is comparable to a pi and our newer hardware is more akin to a current gen smartphone. I will be presenting on exactly this topic at the [LavaOne conference](http://events.eventzilla.net/e/lavaone-2018-2138921167) next month in Oahu.
False. Java was not the first language to have managed memory and the term "memory leak" applied to the improper deallocation of memory long before Java existed.
lol yes ‚Ä¶ for systems that don't need revisions, it's not uncommon for one process to have been chugging along just fine for years, in steady high-volume operation. Yes, we should probably pre-emptively restart things, upgrade machines, etc. and not run one process for that long. But "if it ain't broke, ‚Ä¶". 
You can interrogate a java process at any time for a list of its objects. Simple tools include jmap (extract statistics and full heap dumps) and jhat (explore object reference graphs, or differences between heap dumps taken at different times), but there are many more sophisticated tools out there.
I'm pretty familiar with Java bytecode, thank you very much. Currently working on making my JSON transformation/query language compile to Java bytecode. If you have an actual argument to make, feel free to present it.
That's what appservers do.
I think the comments here are self-evident examples of the sexism in our industry. ~~Men~~People came here to disparage ~~this~~ ~~article~~the people commenting on this article based on ~~the headline~~their (male) gender alone. Fixed it.
I know that our Java application does sometimes have abnormal memory consumption that is solved by restarting. This is not a problem you usually have with php (which rebuilds the whole app on each request). How they are caused In our case i don't know but there are some articles about this phenomenon https://www.toptal.com/java/hunting-memory-leaks-in-java. 
If you do almost anything with an object ut has to be heap allocated.
Methinks you could benefit from reading about escape-analysis-based stack allocation. 
&gt; Never trust a blacklist to be complete. This is solid advise :) Even if the endpoint you are talking to is another of your internal services it's a pretty bad thing to give anyone who manages to hack that service the ability to infect more systems.
I know about escape analysis, but if you‚Äôre going to do anything like putting an object in a data structure, or synchronizing on it, it needs to be on the heap.
&gt; I know about escape analysis Apparently not, given the words that followed.
I've got an app that get hits by around 10k users per min and hasn't been restarted in over two years (last update). Java seems to hold up
I thought appservers were for hosting a service and you communicate with them via tcp, rmi, etc. I was thinking in line of -- when you do 'run &gt; java helloworld' in a console, it would run in a preloaded jvm and output the result to console. and not spawn a new jvm for the purpose of running helloworld
What you're describing is basically an appserver that allows a local client to submit code to run. And it would not be difficult to implement as a client for a mainstream appserver. There simply isn't much demand for this kind of thing, though I'd bet that someone somewhere has in fact already implemented it.
Check out findbugs or sonarqube for Java memory leak detection. You **can** set a reference to null when you're done with an object, and the GC will find it and clean it up. But you don't have to. As long as there is nothing pointing at an object, it will be garbage collected. 
Yes, it runs as long and stable as you need it. Same with .Net, C and C++ programs (latter two coded right). If you're keeping the OS updated, you'll be rebooting long before any memory issues come up. I don't know about spliced kernels, how long they run and how long a JVM would need to run in that case.
Small nitpick, static is one per class per classloader.
78x worse startup time seems like a bad thing, but in real life use 80ms difference has very little effect in most scenarios. Yes, Java has major overhead over Rust/C/etc but for long running processes 80ms startup shouldn't matter. Also, Java has improved tremendously. There was a time when the startup time was counted in seconds, but since things have improved it's no longer a valid claim. 
90% of finance and insurance still runs on cobol and rpg. Java has 90% of the left overs.
Cobol is definitely the back end eventually. Transaction systems, databases, trades, etc are cobol. But the webservices and business logic above that is usually Java. I would say 90% hits Java AND cobol.
So does anyone here know why @Converter just...doesn't work? If it worked you could just use that to handle POJO-&gt;string-&gt;POJO conversion. Hibernate is AMAZING but it's limitations are very frustrating. Not being able to nest embeddables, and not being able to have them in collections is crippling. If it had that it'd be a million times better. I do gamedev, and have very complex objects. I'd like to map them in a single session factory instead of defining joins in each DAO. I love, love, love hibernate I just wish it was a teeny bit better.
No one? is my question dumb? how's that?
And they do it terribly (IMHO). Never had more stability since I stopped using container-managed application designs. Spring Boot conceptually not so bad since it‚Äôs basically what I do (not really a container, just automagic config of embedded web server and respective servlets) But those traditional ‚Äúapplication servers‚Äù, sure, if you like hobbled together chained classloaders running your app
&gt; but that pattern is a lot better than throwing exceptions. Gee, what exactly is it you're trying to say.....? 
Here, you're welcome: http://mail.openjdk.java.net/pipermail/lambda-dev/2010-June/001484.html
you are pretty wrong about this. for a specific problem ANYONE can do better than the jvm. there are two major downsides to their garbage collection: 1. it's non deterministic. your program might be stopped at any time, and you don't know when and for how long. 2. java's object model is incredibly memory hungry. even basic stuff often consumes 5-10x the amount that it would in c++. 3. amazon DOES hire a lot of c++ devs. so does google. you are so far out with that statement, it's like you haven't even checked out their respective github accounts. 
I've got a Tomcat 7.0.41 on Java 7.21 started 2014-10-06 serving hundreds to thousands requests per minute. It is connected to an equally old Cassandra db. Hardware is a quad core Intel Xeon E5504 @ 2.00GHz and 12 GB memory. The hardware is shared with 3 Jboss 4 server instances started 2015, June and September 2017. It is a Debian 5...
I think the better question is if the programmer is good at writing solid, reliable code.
what is wrong anout what I said?
Good, as you know, Java bytecode is an intermediate step that is converted to the hosts native code at runtime when needed. Optimizations are done after gathering insight about what is actually going on and when things change it is even deoptimized again. The basics are not much different of how "interpreters" work. See how Python or V8 does it. There are rarely any true interpreted languages these days.
Bytecode isn't machine code, it still needs to be interpreted and converted. And that probably includes a rather expensive optimizer pass. Meanwhile scripting languages are often read and executed line by line. No JIT compiling, no optimization, just read and go. 
&gt; You don't load types. Uh, what the fuck a "class" is? 
You seem to be confusing an example of a memory leak for the definition of a memory leak. A common mistake, but one that's easily overcome with experience.
Perhaps he's really using an ancient version of Visual Basic and got confused.
For a start, there is frankly nothing about putting an object in a data structure which precludes stack allocation, whether as a result of escape-analysis-based optimizations or otherwise, which tells me right off the bat that you're talking beyond your expertise. I frankly don't want to spend more of my Saturday helping you that wasn't already covered by my original suggestion that you should learn about escape analysis. Go do that. 
If there a github for the docs? There are a lot of translation errors... Might want to code version the docs so someone can help with translating. 
Also realize Java is running interrupted when it starts. So 1000x worse perf than C. Will take several seconds for some serious jit to happen.
Another classic problem area is having a buffering scheme where slices are just implemented as bounded regions of the original buffer. This approach has the advantage that you don't have to allocate or copy any of the buffered data when creating a slice, but for example if you read an entire file into memory and grab a couple small slices from it, the slices will hold references to the entire thing and none of it can be collected if even a single tiny slice still exists. That's exactly how Java String.substring() worked for many years, and having just a tiny substring could keep a giant string stuck in memory even when there were no more direct references to it. Somewhere in the middle of (I think) Java 7 they decided that this was enough of a problem in practice that it was better for substring() to make a copy instead (this also had the advantage of making the String class itself smaller and simpler, since it no longer had to keep track of a region).
Why Java instead of another lang? Like Go for example
Memory fragmentation is another reason why managed languages like Java can offer benefits in long running processes. Specifically, the GC can dramatically reduce the effects of memory fragmentation by compacting memory. However, in languages like C/C++ you often have to work quite hard to avoid fragmentation issues. It does depend a lot on what the program does, however, as to whether it's really an issue.
A couple of reasons. 1. The project was founded by James Gosling, the creator of Java. 2. Go did not really exist in 2011 as production ready. 3. Go seems most viable for small to medium sized programs along the lines of the Unix model; do one thing well. Go seems less interested in larger composed programs with many services running in the same process. A knock on neither Java or Go.
*cough cough* Spring *cough*
Depending on your use-case I'd look at your architecture at a higher level than that. There are any number of reasons that a single-long running process might fail: programming bug, hardware failure, OS bug, power failure, etc. You can't rely on a process to run for that long without any issues in any of those components. You also may have difficulty installing OS or JVM updates, which could expose you to critical security vulnerabilities if you can't restart to patch them. While Java itself will have no issue creating a program that can run for an arbitrary period of time, I'd look a little more closely about *why* you want to do that and how you can mitigate possible failures. This will depend on how 'critical' your use-case is and what the consequences of failure are.
Cool! I had missed mjg123's article when it was posted. How did that happen? ... Oh, it was during JavaOne. That explains it. :-)
In Java's case, the problem is making a finalizer to set things to null (or just having finalizers at all really). Setting things to null is just unnecessary (and opens you up to problems if you do it too early by mistake, defeating one of the advantages of GC), but having a finalizer is what can kill your program.
Check out Nailgun[Nailgun](https://github.com/facebook/nailgun). Does exactly that. For example IntelliJ starts a Nailgun server for Scala compilation. 
How do you avoid SQL injections? https://github.com/creactiviti/graffiti/blob/master/src/main/java/com/creactiviti/graffiti/graph/sql/SelectBuilder.java#L40
Also that whole block can be replaced with String whereClause = where.stream() .map(this::sanitize) .collect(joining(" AND ")); Embrace the stream API.
Yes it is. I have written a set of Java applications that run 24/7/365 since 2012 with no restart. They route/process all invoices of a company I worked for at that time.
&gt; Not being able to nest embeddables, and not being able to have them in collections is crippling. Are you using a old version of Hibernate? Both of these are supported in JPA 2.1. I think that's Hibernate 4.3 and up. 
hibernate 5.0 throws errors I will eoaborate later. It'd be SO USEFUL if you're right!
https://hastebin.com/enifupiriw.java https://hastebin.com/yihuqesote.java throws this exception on startup https://hastebin.com/uriwefilon.cs I get that error when calling org.hibernate.cfg.Configuration.buildSessionFactory() 2 self proclaimed hibernate experts have told me this is due to it not being JPA compliant. Also a few posts I've googled. If they're wrong that'd be super sweet.
Entity: https://hastebin.com/xigacuzasu.java Embeddable: https://hastebin.com/urizerarij.java throws this exception on startup https://hastebin.com/hufubiheqi.cs I get that error when calling org.hibernate.cfg.Configuration.buildSessionFactory() 2 self proclaimed hibernate experts have told me this is due to it not being JPA compliant. Also a few posts I've googled. If they're wrong that'd be super sweet. 
Okay so I never investigated my problem since I was told it wasn't JPA compliant! Turns out I had annotated a Map with @ElementCollection! It all works now! You have no idea how happy I am to discover I was just screwing up. 
I‚Äôve never heard of start.nemesis.io
That's great, and I'm currently writing a document on the README and https://lets-blade.com, and if there are any mistakes I want, I would like to thank all those who helped to grow it.
The answer is - you don‚Äôt. Only the weak are afraid of SQL injection!
You deliberately omitted this: &gt; The "types" that Java spends time loading are the classes containing the language libraries. 
As an outside observer, I'll have to say that you're an arrogant ass, and it is you who needs to learn about escape analysis - and to think a little more before you post.
The only bad part of Java8 are default methods in interfaces, which actually is in contradiction with interfaces idea.
&gt; Bytecode isn't machine code, it still needs to be interpreted and converted. It needs to be interpreted, but it does not need to be converted. You load the byte array containing the bytecode and then the constant pools into the virtual machine (very, very fast operation), allocate the stack, make a stack frame, and then you start executing. That's all. (I've built bytecode interpreters before. Last time was two weeks ago.) And the scripting language is doing the exact same thing. Python 2.7.13 (default, Apr 4 2017, 08:47:57) [GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.38)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; def test(n, m): ... return n + m ... &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis(test) 2 0 LOAD_FAST 0 (n) 3 LOAD_FAST 1 (m) 6 BINARY_ADD 7 RETURN_VALUE The `.pyc` files that Python saves are basically the same as Java `.class` files. &gt; And that probably includes a rather expensive optimizer pass. There's absolutely no reason to optimize bytecode on load. Do it when compiling, or not at all. &gt; Meanwhile scripting languages are often read and executed line by line. No JIT compiling, no optimization, just read and go. Parsing is much more expensive than loading bytecode and interpreting it. And as you know Java doesn't do JIT until after the code has run for a while.
Exactly. So what excuse does Java have for being slow when starting from compiled bytecode, compared to a scripting language that has to first parse and compile to bytecode before it can even get to the same starting point as Java?
&gt; it's non deterministic. your program might be stopped at any time, and you don't know when and for how long. That's not entirely true. The GC can be tuned to a fair extent. You can tell it how long it can pause, how frequently it should attempt to collect garbage, and various other implementation specific options. &gt; java's object model is incredibly memory hungry. even basic stuff often consumes 5-10x the amount that it would in c++. That's not what this is about, at all. We're talking about OP's worry that the GC will miss cleaning up unreferenced objects. We're not talking about the size of these objects of their overhead. &gt; also: amazon DOES hire a lot of c++ devs. so does google. you are so far out with that statement, it's like you haven't even checked out their respective github accounts. I wasn't saying that they don't. I was saying that if OP thinks he's able to out-memory-manage the JVM in general use, he's got a good shot at landing a Google/Amazon job. My point being that I don't think OP is able to outsmart the JVM's GC. &gt; oh, one final note, because you seem in desperate need of some learning. Ah yes, let's get personal for no reason whatsoever. I'm aware of GC projects in C++, and I'm aware that Bjarne Stroustrup is in favour of adding GC to core C++. But again, that's not what this is about. 
&gt; That's not entirely true. The GC can be tuned to a fair extent. the GC is not part of the language, so you have very little control over it in the long run. the problems i'm talking about (high memory usage, indeterministic) are structural problems and directly related to java's GC -- they're impossible to work around, especially not by tuning command line parameters. don't get me wrong, i've been using java for a long time and i still do and it's great for many problems. but there's a whole other world of programming out there where people live without garbage collection and they do just fine. &gt;I'm aware that Bjarne Stroustrup is in favour of adding GC to core C++ From his FAQ: "I consider garbage collection a last choice and an imperfect way of handling for resource management. That does not mean that it is never useful, just hat there are better approaches in many situations. " &gt; Ah yes, let's get personal for no reason whatsoever. sorry, not sure why i wrote that. but you're acting like the GC is some magical bean and it's impossible for us to do better. that's such utter rubbish. we can do better, just not in java. 
Username checks out
Unless that pi is up to something very important!
I was saying, that the JVM has an additional compilation step to make and is not entirely pre-compiled like C++. To come back to your question. The slow startup of the JVM has a lot to do with its size , statically typing and additional verification it has to do. (See [link](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html)). Some differences: * The platform itself is huge. It is to provide a complex GC, memory handling, platform-independent OS functions and threading environment * Security access control * Type verification * Loading the platform [class libraries](https://en.wikipedia.org/wiki/Java_Class_Library) (not all in that list is loaded). Java's standard library is magnitude bigger especially compared to the anemic JS standard library * Initializing the class-loader and verification for application code and dependencies * Gather class meta-information for reflection and other
**Java Class Library** The Java Class Library (JCL) is a set of dynamically loadable libraries that Java applications can call at run time. Because the Java Platform is not dependent on a specific operating system, applications cannot rely on any of the platform-native libraries. Instead, the Java Platform provides a comprehensive set of standard class libraries, containing the functions common to modern operating systems. JCL serves three purposes within the Java Platform: Like other standard code libraries, they provide the programmer a well-known set of useful facilities, such as container classes and regular expression processing. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I don't have a proposal myself, but I don't like how yours introduces so much distance between the declaration of `X` and the site with sufficient context to deduce that `X` is a throwable. If you're interested, this topic was discussed at extreme depths back when lambdas were still a proposal [here](mail.openjdk.java.net/pipermail/lambda-dev/2010-June/001484.html).
What is CMS?
Content Management System 
Thanks for posting this! I start a new job in a few weeks where Postman is heavily used, and I have been looking for a good primer.
Best of luck to you, it is really an extraordinarily useful tool while working with REST APIs.
Postman is a fantastic tool! I'm actually working on a project that will consume Postman collections and use them in dynamic vulnerability analysis testing using HP/Micro Focus WebInspect.
It looks like Entity is an interface or Abstract class. You can't use 'new' with incomplete types.
Haven‚Äôt had the time to explore Postman to this depth. Will definitely improve productivity!
so what do i do? sorry im new with this java script stuff heres the file: package engineTester; import org.lwjgl.opengl.Display; import org.lwjgl.util.vector.Vector3f; import com.sun.xml.internal.stream.Entity; import models.RawModel; import models.TexturedModel; import renderEngine.DisplayManager; import renderEngine.Loader; import renderEngine.Renderer; import shaders.StaticShader; import textures.ModelTexture; public class MainGameLoop { public static void main(String[] args) { DisplayManager.createDisplay(); Loader loader = new Loader(); Renderer renderer = new Renderer(); StaticShader shader = new StaticShader(); float[] vertices = { -0.5f, 0.5f, 0, -0.5f,-0.5f, 0, 0.5f,-0.5f, 0, 0.5f, 0.5f, 0, }; float[]textureCoords = { 0,0, 0,1, 1,1, 1,0 }; int[] indices = { 0,1,3, 3,1,2 }; RawModel model = loader.loadtoVAO(vertices,textureCoords,indices); TexturedModel staticModel = new TexturedModel(model,new ModelTexture(loader.loadTexture("image"))); Entity entity = new Entity(staticModel, new Vector3f(-1,0,0),0,0,0,1); while(!Display.isCloseRequested()) { renderer.prepare(); //game logic renderer.prepare(); shader.start(); renderer.render(entity, shader); shader.stop(); DisplayManager.updateDisplay(); }; shader.cleanUp(); loader.cleanUp(); DisplayManager.closeDisplay(); } }
From the sidebar: &gt; No programming help questions here! These should be posted in /r/javahelp
1. Since this is help with *Java programming* it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. 2. In order for us to be able to help you, we need *far more information*. We cannot guess the problems from this snippets. Before reposting in /r/javahelp, please read the [**posting guidelines**](https://redd.it/48eykt) there. **Post removed** programming help
Yea had a fellow dev introduce me to this tool. Amazing...really cuts down on testing cycle time. Just wish I could get everyone to buy in and use the collaborative/sharing features
I'm just gonna leave this here... https://httpie.org
I've been trying to push it a bit on my team as well, with environments it makes it really easy to share collections among team members. Everyone just has to set up their environment variables and then they are good to go. Especially useful when introducing new developers as well, and can serve as a documentation tool for your API as well.
&gt; Callable is not a Supplier The author suggests that both have the same interface. A callable is allowed to throw, a supplier is not. 
Postman is a great tool for interactive testing. But for completely automated testing it is better if you use a framework (e.g. Rest assured) https://semaphoreci.com/community/tutorials/testing-rest-endpoints-using-rest-assured
There's a fairly simple work-around: use a method reference. For example executorService.submit(supplier::get); will compile fine. Supplier is not a Callable. Predicate is not a Function. But the method references are the same. Since you can access the methods in that way, it's probably correct not to mess around with the existing class hierarchy.
I love rest assured. I use it for all trying spring boot APIs I build. Makes testing so simple and allows for great iterative testing as I develop. Never have to mess with JSON, just build the Java object and post it. Also the matching and response validation is great. Two thumbs up on rest assured from me.
This wouldn't have helped because `Optional` is implemented incorrectly, and has exactly the same issue as returning a naked `null`: You can't tell whether the `Optional` is empty because the value was `null` or because the key did not exist.
We all use this in the office, it's great. The downside is that whenever it is mentioned we all get that song in our heads.
We use PostMan for manual test/debugging, and RestAssured for automation.
That looks great but can it assert API responses? 
Been using Apache Jmeter to test API's for years. 
Postman is my jamsauce
Comprehensive coverage of the fundamentals 
It's a simple http client just like curl or wget... Just a lot better
Tika does what it does and does it really well. Big fan. Thanks to the devs for the update and OP for sharing the news. 
IntelliJ 2017.3 rest api tool is much more convenient and better IMO
Just so everyone knows, the proper term for this is "negative caching" https://en.wikipedia.org/wiki/Negative_cache 
**Negative cache** In computer programming, negative cache is a cache that also stores "negative" responses, i.e. failures. This means that a program remembers the result indicating a failure even after the cause has been corrected. Usually negative cache is a design choice, but it can also be a software bug. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
You got a GitHub repository for that?
Soon. The project has to go through an approval process before I can open source it.
Do you mean invoking a java program from windows command prompt? 
Ok Linux its... echo $1 
Use the normal Runtime.exec command to get/run a Process object. You can use Process.exitValue() or Process.waitFor() to get the exit value of the subprocess.
*Thanks for the post, man!
This is a really good write up. I've seen it mentioned that you should use G1 if your heap is large (over 4GB? over 6GB?) but G1 is still a bit new to me. It also seems like the tuning options have changed quite a bit in Java 9.
üëç
Modules aren't just about dependencies, but even with respect to dependencies, you would gain *runtime* dependency guarantees that help ensure your code has the proper libs and avoid class path problems from conflicting libs. In addition, you get better encapsulation by restricting which packages get exported to other modules. This gives you the ability to guarantee that only the API you want to exposed will be used by other libs. In other words, modules aren't meant to be a replacement for Maven/Gradle or any such systems. They are fundamentally about building, well, a module system which, by its nature, happens to make it easy to analyze static dependencies as well. 
Another subreddit seemed to find [insomnia](https://insomnia.rest/) a better tool, thought I'd share it here, too! It can consume Postman tests, apparently (ymmv, though). 
Care to explain some reasons why?
Your asking about the exit status. mac terminal: echo $?
This - although I believe it's a better practice these days to use a ProcessBuilder to obtain the Process rather than Running.exec. https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html
i was asked to elaborate on this since it's easy to misinterpret what i was saying. apologies for the slow response first, this wasn't intended as a knock against lukas - i haven't used his software, but he appears to have made something that used to be hard to do in java much easier, and he's come up with a business model that makes open source profitable for him. both of these are hard to do and commendable second, the survey is garbage. doing a full analysis would take an expert a week or two and i'm neither an expert nor inclined to waste my time with it, but here are some red flags: * participation was voluntary * vendors were allowed rally their users, further skewing the results * there wasn't a demographic model to normalize results * there's no prediction that can be tested year to year that can be used to validate the survey (this is how 538 analyzes political polls) * there are no error bars or margins in the results. the author tries to work around this by presenting the data directly instead of conclusions, but this only encourages the reader to make the mistake in his place * since effectively none of us have the expertise nor the willingness to do the proper analysis of this very limited and non-independent data, there's effectively no conclusions that can be drawn from this i concluded that lukas, while being a very bright programmer and businessman working in the database space, isn't particularly knowledgeable of advanced statistics or random processes. and i think he would agree with this. this isn't a problem, because his database work doesn't require that expertise we've been using databases for 60 years and SQL for 40 years. we have postgres and big table and sqlite and everything in between, and collectively databases store a large portion of all human knowledge - an amazing feat and yet, our databases are still limited to storing and querying facts - keys and values. there's no context to the data, no semantics, no probabilistic representation. our brightest minds (and both lukas and i, on opposite ends of the spectrum) are struggling not to solve those questions, but with the basics of accessing the key-value store and object-relational mappings the age of big data, electronic medical records, [satellites](https://en.wikipedia.org/wiki/Weather_satellite) and the panama papers, is also the age of climate change debate, [flat earthers](https://www.si.com/nba/2017/11/01/kyrie-irving-celtics-flat-earth-theory), fake news and [trump banning the term "evidence based"](http://thehill.com/news-by-subject/healthcare/365204-trump-admin-bans-cdc-from-using-evidence-based-and-science-based) we're drowning in data and doubt, and we're both busy writing ORMs and that's scary 
**Weather satellite** The weather satellite is a type of satellite that is primarily used to monitor the weather and climate of the Earth. Satellites can be polar orbiting, covering the entire Earth asynchronously, or geostationary, hovering over the same spot on the equator. Meteorological satellites see more than clouds and cloud systems. City lights, fires, effects of pollution, auroras, sand and dust storms, snow cover, ice mapping, boundaries of ocean currents, energy flows, etc. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Oh yeah, I guess it has the same problem; I mean, it could return an `Optional&lt;Optional&lt;T&gt;&gt;` where the first `Optional` is present if the key is present and the second `Optional` is present if the key is mapped to a non-null value. But that looks way too hacky.
java9 modules allow for greater permissions controls on code than private/protected/public allow. for example, you have have ```org.mypackage.api.*``` and ```org.mypackage.impl.*```, and only export org.mypackage.api and code using your module would be restricted from using your impl classes.
Very nice write up, thanks for sharing.
I'm not interested in the library but I appreciate that you included in the title what it actually does. Too often new releases of libraries are posted and neither the link nor the changelog say anything what the library is for.
No, I mean what I wrote. Companies specifically do not want to use *GPL*, even if they are doing open source, because of the fear of contagion from GPL. Lawyers in most software companies are just not going to let them use GPL. That's why it is a very common business model to release GPL and offer a commercial license (open source or closed) for companies. Practically all companies that do open source do so with permissive licenses. And that's why Android is still stuck on Java 6 class libraries‚Äîthey wanted to build on Apache Harmony to avoid the GPL. Linux is an oddball because it is clearly self-contained (low risk of contagion) and hard to replace with something else (BSDs lack behind in functionality and development resources). But even then Google are building a permissively licensed new kernel Fuchsia, presumably for Android.
[This](https://hackr.io/tutorials/learn-java)could help you 
Cool, thank you very much. I have added a reference to your comment to the article.
This subreddit is **English ONLY**.
&gt; In the actual Google search that leads to, right now the featured result is an article called "Checked vs. Unchecked Exceptions: The Debate Is Not Over". This doesn't sound like unanimity. My point is that whenever exceptions are checked, then they would have been much better implemented as ordinary union types, not exceptions, which can also be passed to functions, not just returned by them. Whenever someone says that they like checked exceptions ("the debate is not over"), I'm quite convinced that they would really prefer union types if they had them. In other words, (almost) no one misses checked exceptions when working with a language that has union types. In fact, the Java language designers even admitted to union types and (checked) exceptions being related by supporting union types in the language (not in the runtime) in Java 7+ catch blocks. They even used the appropriate syntax for them. &gt; Reply to side note: Union types are semantically the same as checked exceptions, just less convenient since you need a bit of boilerplate per call rather than per method. What do you mean by that? &gt; Also, an error union is easy to ignore accidentally when you don't need the normal return value. That depends on the language design. In Ceylon, you cannot ignore it accidentally, because you have to "unbox" the normal return value explicitly. So the syntactic ceremony is about the same as that of checked exceptions - except for the fact that no weird control flow transfer is being made, of course. And, speaking of Ceylon, they also got nullable types right, with them being just syntax sugar for the `SomeType|Null` union type. &gt; If the user mistypes a filename or something, you don't want to shove a 40-line stacktrace in their face. This means you have to catch that IOException. Which, if it's not a checked exception, most programmers will almost always forget to do. The very location where that exception is thrown is usually the wrong place to handle it (as with all system exceptions), because it's far too low down the call stack, far away from the UI logic where a meaningful error translation can take place. Besides, what's an IOException after all? Will you be sure to take care of the possibility that a disk block is physically corrupted every time you access the next byte from an `InputStream`?
That's a matter of taste I suspect, but surely, the single `Map.get()` call is faster than a `Map.get()` call followed by a `Map.containsKey()` call. Perhaps not a significant difference in most cases, but this is compiler logic, so every nano second might count.
Yeah. I was just feeling snarky. After all, if I had to put in perspective every silly hyperbole I ever make to make a point, I would never get to the end of it. Just accept the hyperbole as a hyperbole.
That isn't strictly the same thing. The best way to represent the concept are language-supported (and ideally runtime-supported) union types. Whenever a language feature is lacking, of course, we can emulate it with some design pattern or boxing API types, such as `Either`. In Java, that's how we got tons of overengineered things, such as the visitor pattern (which is is much better represented through language-supported pattern matching)
From a performance perspective: Do you really want to allocate an additional instance on the heap to box every value?
Exactly what I thought of! Thanks, will keep in mind for times when this will could be useful. 
`Optional`s issue is that it tries to be both a structure to represent an optional value and to convey nullability information and supports those cases by making them interchangeable. As a result, it does both rather poorly.
With Maven you can structure your codebase in multiple modules at *build-time*. Modules in Java 9 bring the notion of module boundaries to the language and platform, meaning the module system also carries over to run-time. Furthermore, as noted in another comment, Java modules also enable strong encapsulation in addition to explicit dependencies. That's something Maven can't offer. Gradle has something that's a bit similar (https://docs.gradle.org/current/userguide/java_library_plugin.html), but still bolted on after-the-fact. Shameless plug: I've also written an [O'Reilly book](https://javamodularity.com) on this topic, providing a more in-depth discussion of these topics!
Is it time to switch to a groovy script?
Not surprised. The `Stream` interface is just *[huge](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)*.
Huge by what standards? :)
A bit late posting, but thought I'd comment as well. I personally groovy. I've been developing in Java for a few years now and love how easy it is to integrate some useful groovy scripts. I would say my framework consists of 80% Java code and the rest Groovy scripts. The initial hurdle of getting both Java and Groovy to work on my Maven based framework was worth it in the end. 
&gt;Apache Kafka is an open source data streaming platform, designed with high-throughput and low-latency in mind. Can someone tell me where this would be useful in a real world scenario? Is it a good idea to use this if you want to create a video streaming service?
This [presentation](https://youtu.be/6lz_UWW-mqw?list=PLYj3Bx1JM6Y6wNFtj6OAKkRlWAZmCFbTI) explains it fairly well.
This book seems good Introduction to Programming Using Java, Seventh Edition Please anyone with experience help me? I 
Not sure about creating a video steaming service with it but if you wanted to analyze the video yes. It‚Äôs also good when you have a high volume of data such as click stream data from a website. 
Good write up, but the article does overlook the fact that you can run java applications on a server that are not web applications. Also, the "snowflakes" moving across the background of that web page are toxic. Made it very difficult to read.
Wrong kind of streaming. It's a pub/sub messaging system, much like ActiveMQ or RabbitMQ. We use it for communicating events between services and asynchronously sending certain kinds of data to sinks such as hadoop and postgres.
/r/mentors You can always post your questions in /r/javahelp or in /r/learnjava.
We use it to process millions of -redacted- per day
Each person has his preferable methods to acquire knowledge. For me, by far the quickest method to understanding the language is books. I set my own pace, books are written usually from easier material to difficult. And are much more understandable than reference pages. Plus, mentors are way more pricey
Kafka is a gigantic, distributed log aggregator with some extra bits. It works best with message sizes of ~1KB, that amongst other reasons means it's not appropriate for a video streaming service at all. What it is useful for is having a central platform which inhales messaging from lots of different sources and makes them available for services to read. It is intentionally 'dumb' and forces the senders and receivers of data to check their data is processed correctly by reading it back. Imagine an organisation like WhatsApp who receive oodles and oodles of tiny text messages which need to be reliably stored for a long time and then read reliably to all defined clients. That's what Kafka is good for.
What application server (if any) is stable enough for it to never need to be restarted?
&gt; I was saying, that the JVM has an additional compilation step to make and is not entirely pre-compiled like C++. So there's a translation step between bytecode and machine code. For a simple program like "Hello world" there is no extra step. JIT doesn't happen. &gt; The slow startup of the JVM has a lot to do with its size, statically typing and additional verification it has to do The static typing was done at compile-time, and makes the JVM faster, not slower. The stuff you link to in chapter 5 is stuff other languages must do, too. Some do it at runtime, others to some of it at compile-time (linking). Most other languages also have GC and memory handling. Platform-independent OS functions don't make anything appreciably slower, and in any case the scripting languages have the same things. Quite frankly, this is ridiculous. For some reason this thread is making people spout nonsense like possessed. If you have no idea what you are talking about, why do you go on about it? Explain to me how a "threading environment" makes Java startup times slow. I wish you luck with that.
i am 99,99% sure, that also Objects will die after scope is closed :) example of what i mean. private void createPersonJustToDie(){ Person person = new Person(); } When i call that function, the Object will be created in heap and a refference in stack will be linked to it. After the function is over, the reference will "die", and that Object in Heap will lose all efferences in stack. Then the garbage collector will delete it from Heap automaticly. As long as even one refference is alive, the HeapObject will live, you pointet that out corectly. My Question is, why do you say "only Primitives" ?
The best way to start learning is to contribute to projects on github: - Understand what the project is trying to achieve. What problem it fixes. - Understand how the project is architectured. Look through the code and try to understand what's going on there; - Look at the opened issues and try to help with those. - Start your own project that is addressing some problem. If you are in the learning phase it's ok to reinvent the wheel a few times. 
Processing queues, actually. Let's say you're pulling in data from Twitter and want to have a number of instances of your system process individual tweets. You'd push the tweets as they're seen on Twitter into Kafka, where they'd sit until one of your processing instances retrieves the tweets and processes them. This has a number of different benefits - it provides a buffer, for example, if your ingestion of tweets exceeds the rate of processing. Tweets can lay at rest in Kafka until you can sufficiently increase your processing to match the rate of ingestion into Kafka.
Internships. They are paid, look great on your resume, and if you find a decent one (read: not just a big company or a high paying one), like an actually decent one doing something you are interested in. You will probably find mentors at work.
Wouldn't I just use package level private encapsulation to achieve same thing? Using maven with maven-assembly, maven-exec, maven-capsule are all ways in which maven helps during runtime ?
So it looks like enhanced switch and pattern matching won't make Java 10? That's very sad.
No, they will not. Features like that will take time, and will be released in parts. Brian Goetz said they will likely start with type test patterns, and go deeper from there. I, for one, would like them to take the time to get things right. If you‚Äôre interested, there is a lot of good discussion about pattern matching on the [amber-spec-observers mailing list](http://mail.openjdk.java.net/mailman/listinfo/amber-spec-observers).
Ah, it's that high performance. I'm usually well over on the safety side of the safety vs. performance tradeoff. What about once Vahalla is released and an `Optional&lt;T&gt;` is allocated as a `T`? Would you use it then?
&gt;The null object pattern (as suggested in the article) is a much better way to go. Isn't Optional literally just the generic version of the null object pattern, parameterized for any type `T`? I guess the difference is where you declare the semantics of the absent case, but I think that doing it at the last possible second is way better than baking a meaning into the object model - it's usually the caller who knows what missing should mean, not the object itself. &gt;Yes, the issue is that Optional sucks if you store them in a data structure. :-) I agree that something like `List&lt;Optional&lt;T&gt;&gt;` is just asking to be flatmapped, but `Map&lt;K, Optional&lt;V&gt;&gt;` strikes me as a very reasonable type signature - perfect for when you want to distinguish between "item not in map" and "item marked as missing in map". In fact, this has been one of the classic justifications for Optional types by people who are scared of monads - I believe Guava explicitly called it out as the reason they added Optional to their library before Java 8 provided a standard implementation.
I subscribe to the mailing list. But, I thought they'd have something for 10. Hopefully, it will make it soon after in one of the mini-releases (I forget what they're calling them). 
Well, local variable type inference is a part of Project Amber, and that will be released in 10. We might see something when 11 comes in September!
That's good to know in case this happens again in the future. I ended up reinstalling Windows 10 which fixed my issue. Really weird. Thank you so much!
It is one level deeper in granularity. At the moment everybody that downloads your JAR file can access ANYTHING that is public. With Java 9 modules you can restrict yourself what needs to be exported and what not. Of course if your Maven jar files are already really small, then this might not be interesting to you... 
I was using Tomcat, but the app server is only one part of the equation. You have to make sure that the application itself does not have memory leaks (otherwise it will bring down the app server after some time)
Not for a CS masters....
11 in September? I'm confused now. I need to go re-read the release schedules.
Yes. There will be a new release every six months, starting in March.
I have a CS/Electronics degree and I've learnt all I know from projects on sourceforge and Google Code (the github equivalents of "my era")... But I don't know people learn different things in different ways. 
But the releases will be 10, 11, 12, etc? What are major releases called then? Do you have a link for this?
Yep! See [here](http://openjdk.java.net/jeps/322).
Well it might help to know what concentrations/focus this person is doing for their degree, but the bottom line is it's not a software engineering degree. Open source projects are great for learning the nuances of particular languages but that's pretty much irrelevant to a computer science education.
Benefit of releasing small parts is getting feedback from the community so they can improve things for the next release. Only problem is that 11 will be an LTS release so I'm anxious to see how language constructs will get added incrementally.
&gt; For a simple program like "Hello world" there is no extra step. JIT doesn't happen. Of course it happens. It takes the class which contains the "Hello World" and all it needs like String and System and translates the bytecode to machine code and before all that, the VM needs to boot containing many things it never needs for the "Hello World" (prior Java 9 jlink) &gt; The static typing was done at compile-time, and makes the JVM faster, not slower. Static typing allows for better optimization and therefor execution performance and memory footprint. At compile time the compiler checks the types of the source code that the developer writes, at starttime it does verify constraints of the resulting bytecode. E.g. see [preparation](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.2). 
&gt; Of course it happens. From [Oracle docs](http://www.oracle.com/technetwork/articles/java/architect-evans-pt1-2266278.html): &gt; Java HotSpot VM automatically monitors which methods are being executed. Once a method has become eligible (by meeting some criteria, such as being called often), it is scheduled for compilation into machine code, and it is then known as a hot method. There are no "hot methods" in Hello world. &gt; at starttime it does verify constraints of the resulting bytecode True, but so do other VMs. Try adding a number and a boolean in a scripting language, or calling a method that doesn't exist.
&gt; Ah, it's that high performance. I'm usually well over on the safety side of the safety vs. performance tradeoff. Yeah. I'm a library dev who reported a compiler bug to Eclipse (thus the article). A bit biased :) In "classic" business logic, I didn't care about that level of performance either... &gt; What about once Vahalla is released and an Optional&lt;T&gt; is allocated as a T Let's hope that that's what's going to happen. We'll see. I'm not too much of a fan of the concept. I wish arity was not encoded in a wrapper type.
Anyone have an idea what changes to the language will support this?
Have you seen any of the talks by Brian Goetz and/or John Rose? They discuss what‚Äôs needed in the Language and VM.
&gt; Wouldn't I just use package level private encapsulation to achieve same thing? In part. The problem arises when you want to share code across packages, but not outside your module. "Just put everything in a single package and use package private encapsulation" hardly is an attractive proposition. &gt; Using maven with maven-assembly, maven-exec, maven-capsule are all ways in which maven helps during runtime ? Sure, kinda. These tools provide workarounds for the deficiencies of the classpath. However, the module system (through the module path and module descriptors) solves this problem at the root.
&gt; Wouldn't I just use package level private encapsulation to achieve same thing? As long as all of your classes are in the same package. As soon as you need to reference an internal class/method that's in a different package then it needs to be public.
For Java projects, I prefer [Swagger](https://swagger.io/), because it automatically scans your Java code for `@RestController` and such and then generates an interactive webpage to test your REST API. This means that you don't have to bother with typing in your URL and such; Swagger just figures it out for you. It doesn't do assertions, but it does verify that your Java code is properly set up to create an API, which Postman can.
have you looked for any existing source-available webapps that you could replace the backend of and have an operating system ? mattermost is the only one that i've found so far, but it's a big api - lot of stuff to implement 
Just a reminder that this will not be in Java 10. 11 is the earliest we might see it.
Yes, it is still packaged in the Oracle Labs JDK (available from http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/index.html) as native-image.
I wish we could use this tool but my company's legal department has issue with indemnities of the licensing agreement. If it were only Apache or MIT license it would've been OK to use. Looking at other suggestions and Insomnia looks real good and promising. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/learnjava] [What are the best Java libraries for data analysis and machine learning?](https://www.reddit.com/r/learnjava/comments/7kp7ue/what_are_the_best_java_libraries_for_data/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Why on Earth would you want to even consider React over PrimeFaces?
Some are not Java but run-on the JVM https://spark.apache.org/ https://software.intel.com/en-us/intel-daal http://mxnet.incubator.apache.org/ https://mahout.apache.org/ https://flink.apache.org/ http://ranksys.org/ https://deeplearning4j.org/ https://www.h2o.ai/
Great blog, started reading from the beginning. Cheers!
TensorFlow
Union types would be lovely, but I don't think we'll ever see them properly done in Java. The algebraic data types we're getting at some point should work in a pinch, but it'll have to be Scala 3 for something like `Null || String`.
Good observation. I wasn't trying to focus on web apps (some of the advice is generic), but yes I do make that assumption in places. I will make that clearer.
It's probably a laziness thing... they're developing in intellij and can't be bothered opening another app, ie: postman. (I work with a few devs that think the same way)
[JSAT](https://github.com/EdwardRaff/JSAT/tree/master) is totally the indisputably best ML library for Java. I'm not 1000% biased because I wrote it or anything. 
I‚Äôd recommend spark 
Yep, and we'll be upgrading to Java 9 early next year. 
You could get stuck at company that won't upgrade to Java 8 for some time now. I probably won't be on any Java 8 work for at least another year. It just depends.
I work at Amazon and its used all over. We really love our streams. 
Absolutely. Both my current workplace and previous workplace use Java 8. I led the charge to upgrade to Java 8 at my previous workplace.
Have you tried out 9? 10 will be here in March!
For our new projects, we do. I'm precisely working on porting a barebones JSP+servlet project to Spring 4 MVC with Java 8. Only one or two Java 6 projects left, but in those the decision to upgrade isn't ours.
We create microservices, java version is 8 but hardly anyone in the team is using its features, still people code old school way, there is absolutely no excitement about 9 or 10
You know that it's a big big field with lots of different algos and needs? Can you narrow down your question or is it a case that you have no clue what you are doing/asking?
i work for two companies. One will migrate to Java 9 ASAP next year ( probably between Feb/March ); in the other one we have branch Java 8 ready but we are still unable to migrate away from Java 6 for messy operational processes.
All of our projects are currently on Java 8. I think we'll skip 9, maybe 10 because both of those are non-LTS and get back in with 11.
Here's a toy example to demonstrate what I'm talking about: int load(File file) throws IOException { try (InputStream in = new FileInputStream(file)) { int b0 = in.read(); int b1 = in.read(); int b2 = in.read(); int b3 = in.read(); if (b3 &lt; 0) throw new IOException("Premature end of file"); return b0 &lt;&lt; 24 | b1 &lt;&lt; 16 | b2 &lt;&lt; 8 | b3; } } void save(File file, int value) throws IOException { try (OutputStream out = new FileOutputStream(file)) { out.write(value &gt;&gt; 24); out.write(value &gt;&gt; 16); out.write(value &gt;&gt; 8); out.write(value &gt;&gt; 0); } } // Called with user input; must handle all expected exceptions and give nice error messages void handleCommand(String command, String[] args) { if (command.equals("load")) { if (args.length != 1) { System.out.println("Usage: load &lt;filename&gt;"); return; } try { System.out.println("Value is: " + load(new File(args[0]))); } catch (IOException e) { // Having checked exceptions ensures we don't forget this catch block System.out.println("Error reading " + args[0] + ": " + e.getMessage()); } } else if (command.equals("save")) { if (args.length != 2) { System.out.println("Usage: save &lt;filename&gt; &lt;value&gt;"); return; } try { save(new File(args[0]), Integer.parseInt(args[1])); } catch (IOException e) { System.out.println("Error writing " + args[0] + ": " + e.getMessage()); } catch (NumberFormatException e) { System.out.println("Not a valid number: " + args[1]); } } // ... else ... } There are 10 different places that an IOException could be thrown by library code (and one more where I throw it explicitly). Because IOException is a checked exception, I can't accidentally ignore it. But I only have to put "throws IOException" in 2 places. If IO errors were reported with union types instead, with InputStream.read returning `int | IOException` and such, I would have to unbox these unions in 10 places. The code gets a whole lot uglier: int|IOException load(File file) { FileInputStream|IOException in = openFileInputStream(file); if (is IOException in) return in; try { int|IOException b0 = in.read(); if (is IOException b0) return b0; int|IOException b1 = in.read(); if (is IOException b1) return b1; int|IOException b2 = in.read(); if (is IOException b2) return b2; int|IOException b3 = in.read(); if (is IOException b3) return b3; if (b3 &lt; 0) return new IOException("Premature end of file"); return b0 &lt;&lt; 24 | b1 &lt;&lt; 16 | b2 &lt;&lt; 8 | b3; } finally { in.close(); } } From looking at Ceylon's docs, they don't actually provide this kind of API in their standard `ceylon.file` library - they just let everything throw IOException without any compiler checking. &gt;In Ceylon, you cannot ignore it accidentally, because you have to "unbox" the normal return value explicitly. That only works if there *is* a normal return value. Consider the `save` method. If it returns a `void|IOException`, it's going to be very easy to accidentally ignore that and silently ignore errors! &gt;The very location where that exception is thrown is usually the wrong place to handle it (as with all system exceptions), because it's far too low down the call stack, far away from the UI logic where a meaningful error translation can take place. Right - exceptions usually need to pass through a few levels. But that's much easier using checked exceptions ("throws FooException" on each intermediate method) than using unions ("|FooException" on each method return value AND unpack-and-return on each *call*) &gt;Will you be sure to take care of the possibility that a disk block is physically corrupted every time you access the next byte from an `InputStream`? My `load` method does just that, without my even having to think about it. That's the beauty of checked exceptions.
We have moved to Java 8 about one and a half years ago (even though there was some pain because of old infrastructure) and we're currently experimenting with upgrading to java 9. I believe Java 8 was an essential upgrade to the language and I'd be really bothered if the company I worked for wouldn't have upgraded. We're using streams and lambdas extensively in any newly designed code. 
Thanks for sharing. I have saved it. Will love going through latest and greatest puff spring boot. 
I can recommend [Weka](https://www.cs.waikato.ac.nz/ml/weka/) or [Knime](https://www.knime.com/) for both Data Science and Machine Learning. They have lots of useful tools and ML classifiers included.
Does Tensorflow have Java bindings? I thought it was only Python
I don't fully understand the point of your example. You're mixing two types of `IOException` and handle them uniformly. How is that going to help the user? Yes, your custom checked exception is reasonable, because it is strictly related to your program semantics, possibly even related to a bug. The `IOException` thrown by the `read()` calls seem to be ignored by you by passing it on and merging it into your own type. So either: - The `read()` exception should be unchecked and caught in some top level handler that simply displays "something went wrong" - You should catch each individual `read()` exception and deal with it explicitly, just like you did in the Ceylon example with union types But yes. I understand that there's a bit more ceremony with union types now (which wouldn't be used in the `read()` case, as those shouldn't throw checked exceptions in the first place).
Just in time for Java 10 :)
Man, you're really missing out by not using streams. Once you get used to them, they're so much clearer as to the intention than loops and if statements are.
We've been using Java 8 JREs for a few years now. We've been migrating to Java 8 language features over the last year.
&gt; You're mixing two types of `IOException` and handle them uniformly. How is that going to help the user? Every `IOException` has a human-readable description in `getMessage()`. This, combined with the general context the error occurred in ("reading file 'foo'", "writing file 'bar'"), suffices to make a good error message. Knowing exactly which line number threw the exception is not important. From the program's point of view all that matters is whether the whole operation succeeded or failed, so there's no good reason to proliferate different exception classes. 
I've seen this too. Using Java 8 and then proceed to code like it's 2003, and import libraries from around that time too... yikes.. 
Yup. And frankly I have zero interest in doing pre-8 projects anymore. You can pry those lambda's from my cold dead hands!
A while ago I gave a presentation on AWS Kinesis Streams and compared it to RabbitMQ. Kafka and Kinesis Streams are solutions for handling streaming data and RabbitMQ, ActiveMQ, etc. are solutions for handling messaging between distributed systems but nothing prevents you from using Kafka for messaging or RabbitMQ for handling streaming data. But there are some fundamental differences between streaming data and messaging. Messaging and message brokers are usually used in distributed systems to decouple them. For example, in a banking environment, a system that handles transactions can put messages into a message queue so that other systems in the bank can process those transactions at their own pace. However streaming data is data that naturally happens frequently by one or many independent systems. For example sensors attached to solar panels/inverters can continuously send data to a streaming data backend (e.g. a Kafka topic) and an application can consume data from the topic to calculate things such as average energy captured grouped by city, state, country, hour of day, etc. Other examples of systems that can generate streaming data are: traffic speed cameras, earthquake sensors, website click streams, information about page visits for a web site (e.g. eBay), tweets, car locations continuously transmitted by Uber Driver apps, etc. 
And you've just made the perfect argument for passing on random unchecked exceptions to the UI handler :)
Yep, streams all throughout the projects.
It starts very interesting, but the quality of grammar and language soon deteriorates so much that I can hardly follow what he's trying to say... 
We use whatever is shipped with the latest stable Debian/Ubuntu distribution, which is Java 8 for a long time now.
I am looking for a Python replacement in general, that's why my question does not go into details. Python is OK, but I wish it was faster, had support for concurrency and better type system. I have narrowed my choices to several languages (including Java/Scala/Kotlin) and now trying to get the gist of what is available in each language. 
Only an API to use with preconfigured networks so no
Fair enough. Keep in mind that the core algorithms themselves is what will dictate the performance, switching for sake of 1-5% speed difference is rarely worth it.
We're currently upgrading to Java 9 where possible and will evaluate Java 10 as soon as possible.
I would decouple the response: - client sends request to server, server acknowledges it received the request and starts - the client polls the server to query for the response OR: - client sends request to server, passing a response URL where the server can notify the client that the server has completed the request - the server performs the request, and once done calls the client on the previous URL For the last one to work, the client and server must be able to reach each other in both directions. Another possibility: Use WebSockets - the client connects to the server using a websocket, the client sends the request over the websocket, the server keeps track which client sent which request and responsds on the open connection. Should the connection drop, the server know the ID of the client, so waits for the client to reconnect and resends the response. 
Thank you! :)
OpenCV
The stream api needs .completedExceptionally like completablefuture! 
[removed]
Same. As an FP fan, it sucks
You sure this is the right spot for javascript? 
You're looking for /r/javascript
Just add Scala to the stack.
Haha, that‚Äôd go over well with the dinosaurs I work with
I missed that! I even have the repo starred :/
Well, this is old..
Yes, but still relevant. I couldn‚Äôt find it posted anywhere on this sub.
Deja vu?
With the advent of lambdas checked exceptions are even worse.
People can rationalize and justify them, but checked exceptions are a mistake. Especially when using the Java 8 features. And I doubt they'll ever budge on this outdated stance.
We switched our main app over to java 8 about a year or so ago. Haven't looked back since, and been enjoying the streams and lambdas.
Not sure if this is top comment because of good library or because it is funny.
Why not get rid of them. It wouldn't break backward compatibility. 
Despite a lot of opposition from the experts group they got in. Thankfully with lambdas we can start to get around them.
https://i.imgur.com/s4eamxv_d.jpg?maxwidth=640&amp;shape=thumb&amp;fidelity=medium
It is pretty much the number one language used to build software the days... Primarily software used by business applications. It is not a systems programming language so you won't see operating systems or microcontrollers using it much, but definitely a language you can build a career on. 
Can you elaborate a bit plz?
Spam in the proper subreddits. This is not the subreddit you are looking for.
https://dzone.com/articles/java-8-the-bad-parts This shows it well, it's a mess with streams
Thx!
I love checked exceptions. They let you write something like this, separating the happy path from the error handling cases: @GetMapping("/user/{id}") public RequestEntity&lt;User&gt; findById(@PathParam int id) { try { return ResponseEntity.ok(userRepository.findUserById(id)); } catch(UserNotFoundException ex) { return ResponseEntity.notFound().build(); } } Since `UserNotFoundException` is part of the type signature, the compiler can verify that error case is handled. The alternative is to return `null`, which requires an `if` statement (obscuring the happy path), or to use an unchecked exception (no help from the compiler). With checked exceptions, you get a way to avoid returning `null` and get static verification. Unchecked exceptions are meant for fatal errors, where program continuation is unsafe because the program is in an undefined state. There are errors which are best handled by letting them bubble up to the top of the call stack. Note that this usage is *not* using exceptions for flow control, by which Josh Bloch means using exceptions to terminate a loop (like `ArrayOutOfBoundsException`), which depends on a side-effect and obscures the termination condition of the loop. Java 8 is provides an *alternative* set of operations to achieve the same goal, which *do not mix* with checked exceptions. @GetMapping("/user/{id}") public RequestEntity&lt;User&gt; findById(@PathParam int id) { return userRepository.findUserById(id) .map(Response::ok) .orElse(ResponseEntity.notFound().build()); } But this is okay. Java is a multi-paradigm language. Just because Java 8 has functional features does not mean that Java 8 is a functional programming language and that older procedural constructs are suddenly obsolete.
Wow. I find it useful that people were figuring out 13 years ago that checked exceptions are a bad influence on code. Some people still haven't figured it out.
Unexpected exceptions, that indicate bugs in the program, (e.g. NullPointerException, ArrayIndexOutOfBoundsException, etc) usually need a stack trace in order to make a useful bug report. Expected exceptions, that indicate user error or problems with the environment the program is running in, (e.g. often IOException) should result in a concise error message that tells what the program was trying to do (at an level meaningful to the user), and why it couldn't do it (`getMessage()`). A top-level handler can't do this because it lacks context - if InputStream.read() throws an IOException, it doesn't say what file it came from (or even if it was from a file). These two distinct requirements mean expected exceptions have to be caught separately from the top-level "catch-all". But you can't catch only the *expected* exceptions thrown by a method if you don't know what they are. That's the problem with making them unchecked.
I may have a stream addiction. I use it almost everywhere I can, always with one line lambdas (otherwise I create a new method). It gets really ugly when dealing with JAXB pojos though if you're 3rd party XSD is pretty complicated, lots of filters with instanceof followed by a simple cast map, some flatMaps with nested stuff etc.
Yes, all work is done in Java 8 where I work.
&gt; I think that doing it at the last possible second is way better than baking a meaning into the object model - it's usually the caller who knows what missing should mean, not the object itself. Well I don't know about "usually." It depends on what the code and the object model is trying to do. The advantage of a null object is that it can provide behavior that makes sense in the context of whatever type of object is. Far from "baking in" behaviors, this provides a better abstraction. Callers don't have to care whether it's a null object or an ordinary instance; they just call whatever methods and deal with whatever results are provided. Sometimes you want to special-case "null" or "absent" behavior, in which case `Optional` might be better. But this might lead to having the policy for handling such cases be left up to the caller thus potentially spread throughout the code. That sounds dangerous to me. Anyway, this is really difficult to discuss in the absence of any concrete example. It's quite easy to come up with toy examples and hypotheticals. For the case Lukas raised, I think the null object is clearly preferable. In fact, I don't think it was taken far enough. In the code in question, if no module is found, it returns null. This forces all callers to check for null and figure out what to do. Perhaps it would be better to substitute a `NullModuleDescription` or some such that represents the absence of module, the unnamed module, or some such. (But I don't know this code, so it might not be appropriate.) &gt; `Map&lt;K, Optional&lt;V&gt;&gt;` strikes me as a very reasonable type signature - perfect for when you want to distinguish between "item not in map" and "item marked as missing in map". Sure, it's well-defined, and you could certainly use it for something. But the issue is that it has no semantics; it's merely a better, less error-prone way of explicitly representing absence. Given a choice between the following mappings: * (K, null) * (K, Optional&lt;V&gt;) the second gives you an API to deal with absence (`map`, `filter`, `orElse`, etc.) as opposed to forcing you to write out explicit logic like `if (v != null)`. Thus, given these two choices, I'd certainly prefer the second. But neither tells you what absence **means**. All they say is that there is no module description. They don't distinguish among the following possibilities: * we haven't looked for a description yet * we looked for a description and got a fatal error * we looked for a description and got a transient error that might resolve if retried (and we're on retry 2 out of 5, after which the transient error is considered fatal) * we looked for a description and found nothing * we looked for a description and found the unnamed module Sometimes explicit absence is all you need. But whenever I see `Optional` in a field or in a collection, it usually causes me to start thinking about what semantics are being conflated and whether there's a better way to represent them. On Guava, my reference for this issue is the article [Using and Avoiding Null Explained](https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained#optional). They mention `Optional` (originally the Guava version, but mostly it applies to the JDK 8 version as well) and how it's quite useful as a return value for something that might not be present. This echoes the advice from the JDK team. (No surprise, as there was a lot of discussion between the Oracle JDK team and the Guava team on this topic during Java 8 development.) The article doesn't discuss use of `Optional` in Map values, though I seem to recall the issue having come up elsewhere, e.g., on mailing lists. It could be that the Guava team is divided on this issue.
Rather, the linked article points out the rationale for exceptions and appropriate uses, and criticizes those who think checked exceptions are bad. Direct quote: &gt; My opinion is that, while properly using exceptions certainly has its challenges and that bad examples of exception usage abound, most of the people who agree with [Bruce Eckel] are doing so for the wrong reason, in the same way that a politician who ran on a platform of universal subsidized access to chocolate would get a lot of votes from 10-year-olds.
/u/Tridzo -- when you are interviewing, you could try asking what version of Java they use and make sure they use Java 8, before you accept an offer there. I asked this question during the interviewing process at the last three places I worked at.
yeah the article says that, but it talks about people who are coming to another conclusion. Given the designers of C# and Kotlin decided against checked exceptions, I think there were a lot of those people.
Checked exceptions make sense sense in theory. But in practice, they are criticized because people throw checked exceptions for the most absurd things. Heck, even the standard library (atleast the older methods) is guilty of this. If it gets misused in the real world (especially if it happens a lot), then it's a bad tool. It does not matter if you keep pointing to an ideal scenario and justifying this bad tool through that.
&gt; If it gets misused in the real world so, basically everything.
 jshell -R-XX:+UnlockExperimentalVMOptions \ -R-XX:+EnableJVMCI \ -R-XX:+UseJVMCICompiler \ -R-XX:+EnableMVT I just spent a long time trying to figure out Value Classes, really fun to do with JShell. It's like they're arrays and POJO's at the same time, still learning more. There's also a new kind of method handle I think? Called `DirectMethodHandle`, still trying to learn more about that one.
You'll want to observe the garbage collection patterns of your process, especially if you are close to the max performance envelope and the processors have difficulty performing major GC compaction. If a load test doesn't produce excessive GC pauses you should be ok.
With Go rattling around I'd have thought this was whether they should or should not be in a programming language. Checked vs unchecked has been basically settled: use unchecked with application or service exception walls. At the exception walls are a point where you can enforce a checked exception or just repackage all errors into a standard unchecked exception.
Probably not the best subreddit to ask this question as Java was constructed as OO language. Maybe this fits better in /r/learnprogramming as this is a language agnostic subreddit.
Sure, but the consequence of misusing these checked exceptions is that it creates bloated, hard to follow, and unmaintainable code. Other misused tools don't have such severe repercussions.
There's a difference between *can be misused and sometimes is* with *easy to misuse and lends itself to it*. Also, there are a few alternatives out there that fill a similar goal, forcing errors and logic to be handled. 
c pointer arithmetic? scala operator overloading? there's plenty of fun stuff that seem worse to me.
I've embraced checked exceptions. I want my code to fail fast and fail hard. The moment something is off, bail out. Checked exceptions also make it clear when using a library for example, at what points that library can fail (assuming the library's author took the time to throw meaningful exceptions).
Agree with all of the above, but one thing surprised me: &gt;But whenever I see Optional in a field or in a collection, it usually causes me to start thinking about what semantics are being conflated and whether there's a better way to represent them. As noted above, I agree that `Collection&lt;Optional&lt;T&gt;&gt;` is almost always a bad idea - but why do you feel that way about fields? How else would you go about, say, encoding cardinality 0/1 into the fields of an object meant to be sent/read as JSON without making them `Optional`? The only example I've seen is when Java developers desperate to represent a natural sum type (eg. SuccessfulResponse, SoftErrorResponse, HardErrorResponse) completely overload the semantics of `Optional` (or, more often, null) to represent all of the sum types in a single POJO. That's obviously a terrible idea, but it strikes me that optionality is a very common situation for data, and one that `Optional` seems perfectly designed to address once you combine it with something like Immutables.io.
&gt;Just because Java 8 has functional features does not mean that Java 8 is a functional programming language and that older procedural constructs are suddenly obsolete. Until we get `Try` in the standard library. Then they'll be obsolete. ;)
&gt; so if you don't load up lots of dependencies the startup is pretty fast.
There were people fighting against checked exceptions when Java was still called Oak. 
I'm the same way haha. I think most computer science courses don't really teach java 8 / streams yet but I taught myself them when Java 8 came out. I cannot code without them, they are just satisfying for some reason haha.
Article is from 2004. Should indicate this in the post. 
Checked exceptions are great because you know exactly why, and at what point in the code, something breaks. I cannot even begin to understand people who not only don‚Äôt use checked exceptions, but also do no unit testing. So not only are you not sure where the code might break, you‚Äôre also not handling the many potential points of failure in the code that inevitably arises because checked exceptions are annoying and unit testing code slows you down. Yeah, right. 
'the difference' seems like didactic handwaving; do primitive types "lend themselves to misuse" because people return ints which are effectively unbounded?
That's a good point to keep in mind, thanks!
&gt; A top-level handler can't do this because it lacks context - if InputStream.read() throws an IOException, it doesn't say what file it came from (or even if it was from a file). I agree, but your example didn't even do that! :) Anyway. You seem to be working as a Swing programmer or similar, so these things might make more sense to you. Whenever I opened files for the last 10 years, it was some config file or what not inside of some ear file inside of some big server application. There was really no point in those exceptions being checked. The stack trace was actually the most meaningful information, usually not the message. Every single such exception was a bug, not "expected". So those `IOException` and `SQLException` being checked were just PITAs that ended up being wrapped in some runtime exception inside some library.
&gt; I love checked exceptions. They let you write something like this, separating the happy path from the error handling cases: I can't help but feel like this isn't more gracefully handled using a Tuple (if you don't want to use Optional, as you pointed out). Throwing an exception is expensive (Extremely expensive, as it turns out, as you're having to fetch the entire call stack), but returning a Tuple&lt;Status, User&gt; (while expensive because you're creating an object) avoids that cost. Yes, you lose compile-time safety, but if it's an expected case I'd rather take the hit of having to make sure my code checks for the appropriate statuses then throw an exception.
NumberFormatException I'm looking at you!
Might as well use $PHP 
 Result/Either type is a much closer mapping to checked exceptions
True (I'd lean towards Either personally), though the point stands that throwing an exception is less performant that returning a monadic type of some sort (Sure, Tuple2 isn't a monad, but it was acting in place of an Either monad in my original description).
You could look at rust. It's fast, great concurrency support and a good community. The good part here is you can write your complicated hard and fast algorithms in rust, and link them to python as a library very easily.
&gt;do primitive types "lend themselves to misuse" because people return ints which are effectively unbounded? ...yes? I mean yes, primitives being handled separately from other types in the object inheritance tree is something that's universally agreed to be inconvenient at best and one of the parts of Java that was there because performance mattered in 1994, not because it's preferable. A proper numeric tower with contracts on bounding would be ideal though that brings in another set of tradeoffs when you try to implement it. It's not as common a complaint as checked exceptions because less people know about the alternatives but it's something I don't like too much 
This is only true if the "bad tool" was meant for the purpose at hand. If most people are bent on nailing everything with a wrench it doesn't mean we should ban all wrenches. We should just hand them a hammer and point out what a wrench is for.
Yeah and they were wrong.
I've briefly considered Rust but it seems to be lacking statistical and ML libraries. Can Rust call C++ libs directly? That would solve the problem
Rust can very easily call c and c++ libraries, it is trivial honestly. 
Whoa!
TBH checked exceptions have little to do with unit testing. Using them to support checked exceptions seems like a straw man to me. 
&gt; (My opinion is that, while properly using exceptions certainly has its challenges and that bad examples of exception usage abound, most of the people who agree with him are doing so for the wrong reason, in the same way that a politician who ran on a platform of universal subsidized access to chocolate would get a lot of votes from 10-year-olds. pretty good roast. I cant throw stones I think exceptions should be dramatic.
While I largely agree with many of the recommendations presented in Clean Code, one of the stranger ones to me was to prefer runtime exceptions because checked exceptions can violate the open closed principle - however you'd have thought that with a sort of sensible exception hierarchy design that wouldn't be true.
With fields of a POJO, I come back to the same issue: what does it mean for a field to be optional? If we have semantics for the absence of a value, then it's possible to have a discussion about alternative ways to represent that absence, possibly encoding a reason for the absence, or something similar. Maybe we'd end up with `Optional` or maybe we wouldn't. As you say, overloading a bunch of distinct semantics into `Optional` is a terrible idea, just as terrible as overloading null. If we have no semantics, then we're left with choosing a representation (`Optional` or nullable reference are the obvious choices) based on cleanliness of code, the number of objects created, convenience of dealing with libraries for JSON processing, likelihood of errors, etc. I have a feeling that most discussions end up here because people have forgotten to think about the semantics, or because thinking about semantics is hard, or because the semantics are ill-defined and need to be clarified in the business rules, or something. So most questions like, "Is it better to represent absence of data as null or an empty Optional?" are barking up the wrong tree.
Learn the core topics, not frameworks. Spring isn't all that different from JavaEE. They do pretty much the same thing they just have different API's. From a completely high level, spring has a more "complete" stack in that there is a "Spring Way" to do everything. With JavaEE you tend to glue smaller libraries together a bit more. Both have pro's and cons. when you weigh vendor lock in vs more flexibility. I can say that I've learned the most by ignoring frameworks and implementing them my self. Need a routing layer? Implement it from the core servlet API up. You will learn (and fail) a lot, but it really drives the core problems that each of these frameworks solve. After you have an understanding of the actual problems JEE/Spring solve it should be easy for you to dive right into any mainstream framework and learn it much more quickly because you've solved the same problem and learned what worked and what didn't. Now that last bit is **great** for learning but don't do that for mission critical production level code unless you have a very good reason to. 
Nice
Am I being paid to do it? If so, I'd probably go with Spring. But if it's my own thing, I'd like to spend some time with Vert.x.
Yeah, unit testing doesn‚Äôt directly have anything to do with checked exceptions, but I mention it because it‚Äôs the only other way I know to validate that code that doesn‚Äôt check for, let‚Äôs say FileNotFoundException, InterruptedException, or IOException in Java, without actually catching the exception and doing something sensible in the catch like retrying the call or at least logging the exception, works. In my experience people who complain about checked exception don‚Äôt unit test. 
Yes, it's a contract. Possibly pretty long term.
I'd go with something more popular, then. No need to waste your employer's time blazing trails. Spring Boot is a decent choice.
Hey, just wanted to let you know I really like the idea of implementing a routing layer from the bottom up. I've been a bit frustrated at my lack of understanding of some of the lower level code. Any chance you have a good resource for learning? (If not, I'll just google, just curious if you had any recommendations).
I feel you there.... 
I really like spring! Back in the days I really enjoyed messing with, among other stuff, various obscure linux distributions. Granted I did learn a lot but often I spend waste amounts of time fiddling with buggy software. Now a days I favor productivity over the joy of bleeding edge. Spring is stable and very feature full and that's why it's my weapon of choice.
Well argued.
1.6 here..
Not off hand but it wouldn't be hard to find. In general if you want to go really low level start out with just embedding Jetty. Manually create a servlet that handles requests. After you learn about servlets then the next thing to do would be to create an abstraction that sits on top of a servlet that's better than a giant conditional in the servlet it self. You start asking questions how would I model code that takes a request like ``` /my/api/login/?search=my+search+query ``` And map that to code that is cleaner and does a lot of the ground work for you. I.e, logically routes GET/POST/PUT/DELETE to some abstraction layer? 
http://www.eclipse.org/jetty/documentation/current/embedding-jetty.html