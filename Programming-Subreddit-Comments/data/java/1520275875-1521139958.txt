Yup.
&gt; use null checks when appropriate. Or use null conditional operators when appropriate. Could you translate this simple piece of code to Java for me? if (object?.field == 2 || object2?.field == 2 || object3?.field ==2) { // do stuff }
 Number 5 will lead to errors being silently discarded, your programm will probably blow up later and you will have troubles finding out why, because you didn't fail early. Number 3 is stupid, imo. You cannot possible anticipate breaking changes like that. What if the method is changed to return -2 if the input string is "Never gonna give you up"?. If you cannot trust the contract of one of the most basic methods, you're fucked anyway. 
Thanks for the vid! Not really sure I'm following his logic though. Elvis operator is just a sintatic sugar for `if (object is not null or empty) { // do something } `which is nowhere near optional types. Slippery slope, eh? C# did it, JS did it, Java will do it. 
I wouldn’t be so sure of that, haha. They already have quite a bit in the pipeline.
After starting a project, I now see that. Though I'm finding it extremely difficult to get my application up and running :( I have tried several tutorials but there are still pieces missing and it's frustrsting me a lot.
For the `final` part, you can encode that rule in your IDE. In my previous workplace, that rule was inserted into Eclipse, and all variables and function declarations (where it made sense) were converted to `final`. If one needed to, one could then remove that qualifier.
&gt; Any experienced developer who can reflect on his experience with &gt; Spring and other frameworks, e.g. jee, will avoid Spring like a &gt; plague. I think there are plenty of counterexamples to that claim.
Yes, Yes, Yes. I agree but I do a lot of contracting and I see just about everything you can imagine and fight every code war you can imagine. It gets tiresome.
Agreed... on both counts. I use the `final` part only on internal code that will not be exposed as an API.
Really the first search hit for "java user group berlin": http://jug-berlin-brandenburg.de/ Last meeting was today.
I second that! Especially the “final” case. In some scenarios it even breaks your implementation because your runtime environment fails to inject proxies where needed.
 if (object != null &amp;&amp; object.field == 2 || object2 != null &amp;&amp; object2.field == 2 || object3 != null &amp;&amp; object3.field == 2) { // do something } Big deal. I would rather argue that having to learn the special cases and conditions of those ghastly-looking operators is even worse than a bit of boilerplate. You will have to find a more convincing argument that simply reducing boilerplate. If that were the only reason, we might as well all be writing Haskell.
&gt; grow tired of not being able to overload methods in code (that I don't control, aka, a library) because of a stupid bug. final is especially useful for you then, if it "forces" you to actually fix the bug at the right place, i.e. upstream. &gt; But, if you're a library maintainer. Please, just stop. No, the moment a class is not final, this fact becomes part of the public API. As a library maintainer you want to keep your public API as small as possible. A small public API means more possibilities to change code, less possibilitie to break client's code and you can keep your library longer backward compatible. As a user you do like stable libraries, don't you? 
&gt; Just let me override what I want already [Nope](https://blog.jooq.org/2017/03/20/the-open-closed-principle-is-often-not-what-you-think-it-is/)
Nothing in my experience has agreed with the claim that immutability is usually a benefit. People writing crappy code tend to write even crappier code when they start mixing in immutability. People writing well written code rarely or never see advantage from immutability - I'm not sure I've ever seen a bug fixed or avoided by making a value immutable in practice. I have seen one situation where someone made everything immutable by default, then years later it was a real pain to deal with as we needed to change one of the values but couldn't. And we were given a compiled jar file with no source code so we couldn't modify it. 
The current web app is being developed using php but when I had a full time job as a software developer we developed a web app using Java and it seemed so much cleaner and easier to maintain on a larger scale. So I'm trying to redo the php web aplp in Java but I'm finding it so confusing. I don't remember everything I did off by heart from when I worked back in 2015/2016 and I don't think I have any code extracts to look at so I can jolt my memory :( I'll have to check. 
0.0076 ms is a good opportunity to get a coffee while waiting for the response ;-) Thanks for reminding me how useless a benchmark without appropriate context can be.
Spring contains some "magic", that is true. But that is true for most other complex technologies, too. Compared to pure Java EE, Spring has a more coherent set of principles. Spring introduced one, and only one (!), way of dependency injection, whereas Java has several. Or take a look what Spring does with AOP, what is realized with different approaches in Java EE. The popularity of Spring is in contrast to your statement: ![Spring popularity](http://redmonk.com/fryan/files/2017/06/Java-fw-stars-20170619-logo.png) [Source](http://redmonk.com/fryan/2017/06/22/language-framework-popularity-a-look-at-java-june-2017/)
Totally agree with `final` methods. This won't make your code fool-proof; fools will just copy-paste, which is hundred times worse.
This is the kind of answer I hoped for.
I switch between java and C a lot and always miss being able to type If (var)
i haven't used jodd at all, so i can't speak to the implementation. but generally speaking, taking monolithic tools and breaking them up into composable portions gives a developer a lot more power. and this is one area in which java really suffers - we have incredible frameworks, but most of them expose very little of the internals by way of example, i had a byte array that represented the contents of an http request body, and i wanted to parse it as a multi part file. there are dozens of java tools that will do this internally, but in an afternoon of searching, i didn't find one that exposed the functionality i don't know that jodd has gone far enough in this regard, but it looks like at least a step in the right direction 
Forgot pretoect those private constructors: **Bad:** public class UtilityFoo() { private UtilityFoo() { /* prevent instantiation */ } } **Good:** public class UtilityFoo() { // prevent instantiation private UtilityFoo() { throw new AssertionError("HANDS OFF MY PRIVATE CONSTRUCTOR!"); } }
Because then, most importantly, you'll loose all references to original implementation. What you want to change the original and all the places where it's supposed to be used? You are screwed and all you've got is "Find everywhere" and regex. From my experience on larger projects, this leads to terrible and unmanageable code. Especially with multiple programmers and a lot of bug-fixing. Typical scenario: - one programmer implements some things with copy-pasting - some things he did does not work, another programmer fixes it in one place - same thing still does not work in some other place, another programmer fixes it there, but differently - somebody decides the behavior needs to be somewhat different. You cry because you need to do the same change everywhere but slightly differently. Or spend a few days rewriting the whole thing. This totally did not happen to me.
`final` would just make much worse.
Any extra 5 letters added to that code base would make it much worse, so I'm not sure if I see the point of this argument.
So if I am spinning up servers on demand, spring is just as good ?
I knew it ;-)
That just irks me and makes me wanna take out ByteBuddy.
&gt; 9 - I disagree on always throwing an exception. I'd change this to "handle the default" instead of "throw on default". There's plenty of times to have default: actually be the default result if there's no other match. For this, I find the throw on default is more useful for enum switches, and explicitly handling all the enum cases. That way, if you add a new value to the enum, you'll get an error in that switch if you forget to update it. That's better than the new value being handled in a potentially unexpected manner.
&gt; i haven't used jodd at all, so i can't speak to the implementation. but generally speaking, taking monolithic tools and breaking them up into composable portions gives a developer a lot more power. and this is one area in which java really suffers - we have incredible frameworks, but most of them expose very little of the internals I get that, but it looks like Jodd users are tied to/encouraged to use Jodd's eco-system rather than the JVM eco-system itself. Any knowledge you get from working with Jodd's modules won't transfer well if you want to use a different framework. I make [Javalin](https://javalin.io/), which is a web/routing library. I encourage people to use other libraries if they need to solve something other than web/routing when working in a Javalin-app. If people need to make a outgoing request, I encourage them to use OkHttp, if they need serialize JSON, I suggest using Jackson. These libraries will be useful for people to know even when they stop using Javalin. I don't think that's the case for Jodd's toolkit. &gt; by way of example, i had a byte array that represented the contents of an http request body, and i wanted to parse it as a multi part file. there are dozens of java tools that will do this internally, but in an afternoon of searching, i didn't find one that exposed the functionality Apache Commons FileUpload? It's a library dedicated to doing these things: https://commons.apache.org/proper/commons-fileupload/apidocs/org/apache/commons/fileupload/MultipartStream.html 
Exactly.
Unfortunately only var is.
For enums, I agree... I think that's how I generally do it anyway; however, for all switch/case statements, it seems like a gross generalization of a rule.
It's not that it happens often, but in the last 6 months I've had to override 2x final methods in Spring and OpenSAML. In each case, making the method final was a PITA. I think I C/P the whole class (I had other edits) in the OpenSAML situation and used reflection to fuck shit up in the Spring situation. I completely understand why those methods were final. But it was an error in the logic within those methods that caused me (the actual programmer responsible for the feature working) to have to mess around with a library author who thought they knew best. 9/10, they're right. Hell, 99/100, they're right - but there's always those situations where they're not. That's why I don't like `final`.
I didn't write most of the code I end up having to read.
The best argument around. 
`var` is coming in 10. The architects chose not to include `val`, and I don’t think they’ll change their mind anytime soon.
it would make sense that someone with the username "farageishero" wouldn't know what prototypal inheritance is &gt; Am I a genius or something? no, you're a fucking idiot
Making everything final except interfaces seems extreme: there are cases for abstract base classes. But if it isn’t in either of those categories, finalizing everything is probably correct. 
&gt; modern code should be using `Optional&lt;T&gt;` as much as possible I tend to agree, but most of the Java community favors using `Optional` sparingly, notably Brian Goetz of Oracle. See https://stackoverflow.com/a/26328555/714009
They're already checking that the returned result is not `null` for 4, as per the docs. What's the point of adding another check?
Since he's not talking about Kotlin, I'll allow it. ;)
&gt; Never trust the docs What docs are we not trusting? Did you expect the docs for Java 7 to apply to Java 8? It's probably bad for backwards compatibility, but otherwise it's just a change. Also, the example involves a *third party library*, not the default ones with the JDK itself.
It depends. One fastest server instance like minihttp replace hundreds spring servers for the same amount of users with the same latency. If you are OK with that then Spring might be your thing. 
&gt; final is especially useful for you then, if it "forces" you to actually fix the bug at the right place, i.e. upstream. True, but you need the fix for the deployment later this afternoon and not 2 weeks later when bugfix is released by the maintainer. Oh, and when the release finally comes there are 50+ other fixes, and 15 of them makes your tests look like a christmas tree. Well shit, and now your boss storms in asking why we're not in production yet. Ok, so you githubfork the library and apply only that particular fix. Ah crap, it uses a Gradle build with hackish build-environment requirements, which takes a whole day to sort out. And once building the bloody tests fail because you need to download 2 gigabytes of test-data from a site that requires registration and a license if the datafiles is used in a commercial setting. Then you quit and tell the junior developer "Good Luck", but he's happy because now he see a chance to rewrite everything in ReactJS that he learned over the last weekend. 
So explain this to me. Let's say I'm writing a method that finds the maximum value in a list of integers by iterating the list. The integer variable tracking the maximum can't be final because I need to update it. Yeah I know this is a stupid example but you get my point, there are times when you want to update a variable. Are we saying that the rule should be: Always make everything final unless you know that you have a reason to change it?
I see these practices a lot from programmers who are still in the 90s. Please get with the times.
I think the idea is that variables should only be mutable because the algorithm requires it so. Your logic requires a mutable variable so you would manually define that as mutable while leaving everything else immutable (until you need it otherwise of course).
If you need to pay for compute resources, and you can reduce your utilization by half by picking something other that spring, id say it's not a bad idea to at least consider it. I don't think anyone is worried about an individual user having to wait for data. That's a silly argument.
Exactly, it's about cost, not user wait time.
If that were true it would have done better in this benchmark.
Yes spring is slow, no matter what people here will tell you ("it doesn't matter in the real world"). It matters very much once you want to scale out. Give a reactive toolkit like vert.x a chance, you can do much more and better things with it than spring, as far as scaling out is concerned.
Have an upvote because you are absolutely right. Spring sacrifices performance for convenience, and it sacrifices a lot for it.
How to build a todo list using spring boot of course! ;)
1. Calm down. 2. The Spring implementation of the app they are testing.
However, Spring 5 is reactive as well. 
This is cool. Does any one have a Javalin version of this Grocery List application?
I just don't believe that. After all especially in a strongly typed language any sane linter worth its name will catch issues like this. It doesn't make sense to do an assignment in an if statement for example (in the comparison clause) 
ughhh! If its your own code - DO NOT CHECK FOR NULLS! Don't. Dont do it. If there's a null pointer - your code should CRASH! because you should never have returned a null, or assigned a null, or if you have done, that variable is not ready to be used in calculations. So, a null pointer check will be papering over the cracks - hiding logical errors, that will come back and bite you in the ass.
&gt; Ok, so you githubfork the library and apply only that particular fix. Ah crap, it uses a Gradle If it is about one particular broken class, you can provide that fixed class in your class path as well. Also make a PR upstream, create a ticket to remove the work-around when upstream is released. Upstream will appreciate your contribution, as will many other library users. That's how OSS works. Sorry, I'm not convinced by your argument against final.
&gt; Jodd is oriented around simpler libraries for doing what people have often times used heavyweight frameworks for: not in terms of performance though necessarily, but in terms of mental efforts and scaffolding required to get an MVP out the door. The very point of minimalism from a reliability perspective is to reduce points of failure in code with simply fewer parts. Author should read the cathedral and the bazaar IMHO. Reliability comes from having small specialised tools that a lot of people use. Not from "being small". I really don't understand the need to implement everything and the kitchen sink yourself instead of reusing existing well tested and popular libraries. For example in it's documentation I can't find any examples of doing Mutual TLS with Jodds own HTTP library. 
The downside is extra effort reading. I find the line noise of final variables more awkward than helpful, especially since Java tends towards long lines of code anyway, and most methods are short enough that it's already obvious if a variable is reassigned.
Of course I agree with that. As the old saying goes, *caveat emptor*. As a related example, when the (new) `auto` feature came out in C++11, it was a great move in the right direction of reducing boilerplate, and while it is used well in most circumstances, we still find many places where it is abused to the point of rendering the code nigh unreadable. So, it must all be taken with a grain of salt. At its core, languages like C++ and Java are still pretty much imperative and concepts like optionals et al should be used with caution and should mesh well together with the rest of the codebase and not unduly inconvenience external users of the API. Though, it is still a very good move in the right direction, and given enough time, best practices should arise that may *effectful programming* (to borrow the Haskell term) more natural and smoother in languages like Java and C++ as well!
yes right, but some meetups by JUG seem to be in German.
SonarQube will detect all copy-pasted code and flag it. Even link to all copied occurances. 
Thank's for the link. I will try it.
This is *almost* good again to show as prime example how rotten the Internet can be...
It looks like in your [submission](https://www.reddit.com/r/java/comments/82dvuz/java_debug/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Blindly using Yoda comparisons can lead to other problems. The 2nd object being a non-equal value and it being null have (potentially) two different meanings, which are lost by a Yoda comparison unless you write an accompanying null check.
Quite honestly, most of these were somewhere between misled and plain dangerous. 1) Also known as a "Yoda condition". That's just ugly. And also I'll argue that for most methods, the nullness of `variable` is unrelated to the equality to `"literal"`. 2) Use static code analysis. 3) I do this one as well, but simply because `&gt;= 0` translates to "found" in my head while `!= -1` translates to "not not found". Not trusting the Java API the worst reason to do this. 4) Use static code analysis. Any tool worth a damn will blow up in your face if it sees an assignment in a condition. 5) Again, nullness is an entirely different concern. If I call a method like `Arrays.find` on a null argument, I want that method to tell me "you're not supposed to put null here" instead of "not found". 6) Are you insane? What this leads to is programmers copying your class to the same package in their own library and messing around with that one _relying on the fact that their version on the class probably shows up before yours in the class path_. If your library can't be extended well it's a shit library. 8) Are you _high_? There is a reason why `Collection` specifies `add` and `addAll`. Just _imagine_ that `Colleciton.add` sneakily called `addAll` if you passed a `Collection`. Holy moly, you created a _horrible_ API in your example! The fact that this person throws `ThreadDeath` best underlines the value of this article. I mean don't get me wrong. It's great that you're thinking about these problems, because they are problems that we all have. But please don't broadcast your half-baked solutions.
Shows what a stupid microbenchmark it is. It doesn't matter a bit if your webserver can send a static HTML response a few milliseconds faster, in real life you want to do stuff. 99% of all applications need to talk to database or other services, it will need lots of CPU work to prepare responses etc pp, dwarfing anything measured here. 
There are two database query tests and a json encoding test in it. Regardless they are trying to make apples to apples comparisons. That means all other things like database access being equal spring is slower than many competitors. No one is saying don’t use spring. But you need to have the maturity to accept that it isn’t necessarily a fast framework for whatever that’s worth. It’s not a stupid benchmark. 
Think mockito added mocking finals in the latest version. 
&gt; There are two database query tests and a json encoding test in it. Looks really weird, too. Why does the "JSON test" test web frameworks? Wouldn't it make more sense to test JSON-libraries? Only some of the tests seem to mention even one. Database queries look weird too. Hammering the in-memory cache of a single table gives you *zero* insight into real life database performance. &gt; Regardless they are trying to make apples to apples comparisons. The main difference in speed is whether a framework is using async IO or not. That alone makes the comparison not really a apple vs apple comparison. &gt; That means all other things like database access being equal spring is slower than many competitors. With a difference of 100% performance to 100.002% performance. For that your team just has to learn a a totally different approach of developing etc pp. &gt; fast framework What is a fast framework? The one that most successfully makes you believe their minimal workload somehow constitutes something you can extract meaningful results from? Microbenchmarks like this are mostly a dick-waving contest of the performance-fetishists with zero applicability to anything. 
&gt; Having it's own JDateTime instead of just using Java 8 java.time packages is IMHO just a really bad idea. To be fair (Jodd being far from new), that has probably been added to replace the awful `java.util.Calendar`. It should be removed, today.
That was precisely the point of the article. It *might* change in a future version of Java. So, again, essentially, you agree. Cheers
This should fit nicely with Spring 5 to create an entirely async stream from data storage to frontend.
The value of `final` far outweighs your pain. You could have just patched the library in those 2 cases, which you admitted were rare. It would have resulted in the same workaround, and you would have hoped for the library to ship an *actual fix* just the same. It's like SQL. These days, we need to tune maybe 1 / 1000 SQL queries and because we're so used to having such excellent optimisers, we're completely surprised by those really rare cases. But yet, our own bias and lack of intuitive understanding of statistics leads to us outweighing the very rare painful occasions compared to the frequent experience of quality. In other words: You're obviously exaggerating.
If you can reduce cpu utilization of a busy site by 50 percent by switching frameworks then it is not Dick waving. If you have no users, then I agree, who cares. 
&gt; If you can reduce cpu utilization of a busy site by 50 percent by switching frameworks If you could, then yes, maybe, depending on the changes in development environment / methodology / skill set in your team and a thousand other factors. But the difference is not 50% -- it's not even 5% in most cases.
That's the thing - I have something to do for my job. Shipping something as a fix (which I do 3/4 of the time) to the upstream version isn't going to help me now. So, in that sense, no - it does not outweigh my pain. Keeping a method final doesn't help me at all. You're trying to tell me "hey, I'm going to give you access to less stuff and you are going to be better off" to which I can't agree, fundamentally. Sure, if I'm a shitty dev I might break stuff - to which I argue: let the shitty devs break stuff. They're going to do it anyway, why hide behind a language construct which restricts usage for everyone. My great hate for `final` is really focused around methods and classes. I goes right up there with `protected` methods for things that are useful as `public` methods (I'm looking at you JSCH!)
&gt; and not 2 weeks later when bugfix is released by the maintainer. 2 weeks would be heaven in most cases. My experience is waiting many months for a maintainer to get around to merging my fix in and releasing a GA version of "whatever lib".
Agreed, that one is a little excessive.
2 instances in 6 months. Surely, you could have worked around those cases using instrumentation, patching, etc. It didn't hurt you. You're exaggerating your pain. 2 instances doesn't even warrant for something like "great hate" (I don't know you of course, perhaps it does in your case). &gt; I'm looking at you JSCH! Now, I'm curious. What's that?
There is at least one vendor who I'd be _very_ surprised to see not supporting it immediately: Oracle itself. 
As I said above, final for all methods is a little excessive. OTOH, I like final for all method parameters. It is also applicable for some fields and local variables.
The problem is the sort of shops most likely to embrace asynchronous/reactive programming models are the least likely to use Oracle... while Oracle shops are the least likely to embrace cutting-edge programming models. There are plenty of databases which already support asynchronous calls today. But they are for niche use cases (e.g. Cassandra) and/or have issues (e.g. Mongo). For small projects, or "version 1" of applications where you're not really sure how they're going to grow (i.e. 95% of projects that anyone will ever build in the real world)... people just need a relational database, even if we go through hype phases of pretending that we don't. So in a nutshell... I don't think any of this will REALLY start to matter until PostgreSQL and MySQL have async drivers, with support for a standard API layer such as what's described in this post. We're probably at least 2-3 years away, honestly.
&gt; If you could, then yes, maybe, depending on the changes in development environment / methodology / skill set in your team and a thousand other factors. Those factors apply to Spring as it does any other framework -- Spring does not occupy some de facto high ground. &gt; E.g. it increase slash your development speed considerably costing you more in the end over the lifetime of the application than adding another server. Or it could reduce it, or it could remain the same. &gt; But the difference is not 50% -- it's not even 5% in most cases. In many of those benchmarks it is 50% or more between Spring and the leading JVM solution. Your affinity for Spring, and internet hype about the same, is causing you to assume a starting position for your argument that isn't necessarily true. Thus benchmarks and studies are needed. In this single instance Spring did not fare well. Doesn't mean it's bad, but proving that an API makes you more productive is a very hard thing to demonstrate, so often tests like this and our own anecdotal experiences is all we have to go on.
As a contractor yea, don't fight code wars. Let them die by their sword. Just do your thing and get out of there.
Take a step back and see where some of the other popular frameworks land in those benchmarks. E.g Python libs, Rails and even PHP. There are plenty of very large websites using these libraries just fine. There are ways to optimize if needed, but don't bother until you actually have enough users that you need to. What these benchmarks also don't take into account is developer productivity. Hardware is cheap, developers are expensive. I would bet Spring ranks extremely well in terms of productivity compared to a lot of the other libraries in there appearing near the top. If you implement it well then it shouldn't be hard to run a few more servers under a load balancer and scale nicely. I would much prefer to get the project done on time. As others have said it would be interesting to see how Spring performs if the test used a more recent version.
When I reworked some Postgres code in framework benchmarks to use the async Postgres driver, it was much worse, both latency and throughput. I will continue to think this async hype is just hype until I see this on top of framework benchmarks or some other such metric... [github repo](https://github.com/libliflin/async-postgres-benchmark/blob/master/README.md) 
Original: https://www.reddit.com/r/java/comments/3gliut/top_10_useful_yet_paranoid_java_programming/
Also can't really see it getting that popular until Spring is able to integrate it. Admittedly I think they would get their pretty fast but I bet they will be waiting for driver support from most of the main vendors before shipping it.
Immutable doesn't mean no mutators; only that mutators give you back a new object. Look at `java.time` for an example. Or even `java.math.BigInteger` that's been in the JDK since 1.1.
re1) Okay, maybe a little exaggeration. I mean, there's always reflection if it's critical. I guess I just don't see the need for `final` is all. I've worked with folks who litter `final` everywhere and it was just a pain when it came to mocks. I never saw a benefit. When you'd want to override something (maybe rarely) you'd just edit final out. It was no gain and simply 1 more code change that was unnecessary. When you control the code, adding `final` isn't a big deal, it's just annoying... like a gnat. When it's in a library - it's just more annoying because you can't just edit `final` out (or now you're arguing with the maintainer of the project as to why you need to edit it out -- when it really doesn't matter if you could just @Override to begin with) &gt; Now, I'm curious. What's that? We use JSCH for audit purposes. There's methods in there that are package protected so I have a project written in jsch packages just because of the package protected methods. The pain comes with code signing... the lib is in a "different" project than jsch and should conceptually be signed by our company and not jsch, but it can't be because java's "classes in a package must be signed the same" rule. If only those methods were public... it wouldn't be an issue. For a consumer of JSCH, you'd never use those methods, but if you're doing mitm work, you would.
Then don't use `var`. It's not difficult. Either it's obvious, or make it explicit.
&gt; You don't trust me not to incorrectly override your method That's because there is no "correct" way to override my method, unless I explicitly designed it to be overriden (which I most likely didn't because you should be using composition and not inheritance). I might at any point change the internals of my class, and now your "correctly" overriden method blows everything up with its incorrect assumptions about the internal implementation details of my class.
There are some issues with that library. Also, the benefit is the reuse of threads in many cases. For many sync JDBC will remain just fine, but in theory with a properly developed library the async one will have advantages with very few performance downsides in most cases.
But if you have a variable called `customers` I'm going to assume that it's a `Collection&lt;Customer&gt;`. If it's not, then you might want to rethink your variable names. If it's a `Map` you probably want to call it something like `customersByAccountId`. Now I'm going to assume it's `Map&lt;String, Customer&gt;` or `Map&lt;Long, Customer&gt;`. But where you've used `var`, you've either used: var customers = new ArrayList&lt;Customer&gt;(); or var customers = customerManager.findCustomers(); The first is obvious. The second requires that your method names are sensible.
That functionality is already in Java 8.
Given that almost everyone hitting a database is using connection pooling, what's the actual advantage of an async DB driver? Aren't you always strictly limited to some N, whether that's the ceiling of your connection pool or the threads allotted to blocking on JDBC connections? Given that most pools should have well under a hundred connections, it seems like blocking I/O wouldn't be the limiting factor for even very high concurrency web applications.
Not so sure. I have problems with [three](https://github.com/mauricio/postgresql-async) [other](https://github.com/alaisi/postgres-async-driver) [postgres](https://github.com/vietj/reactive-pg-client) async libs and it has annoyed me to the point that I might write it here soon. I am reviewing the API now. While I would try to backport it, but there are Java 9 API libs in use that may permeate my lib (e.g. java.util.concurrent.Flow).
&gt; In many of those benchmarks it is 50% or more between Spring and the leading JVM solution. 50% difference in a meaningless slice of functionality with arbitrary criteria. Who decided what the spring Database access method is. According to their benchmark, there is only JPA. What if you use oldschool hibernate instead? What if you use JOOQ instead? What if you use any of the new async IO DB-drivers alternatives? What JSON library do you use with Spring? In general they ignore all the reactive stuff in Spring 5/spring boot 2.0. They ignore the all async stuff you already could use with spring before. Of course you can use vert.x and spring together, works just fine, but "vertx" is fast (91.4%) but everyone just knows that when you add big bad "spring" it suddenly drops to 4.8% (newsflash: it doesn't, because the spring overhead is negligible). To this myriad of different options, the benchmark choses one, calls it "spring" and pretends that the results are meaningful. &gt; In many of those benchmarks it is 50% or more between Spring and the leading JVM solution. *in a meaningless microbenchmark*. This whole thing is fractally retarded -- stupid on so many levels. 
And then there's of course the cardinal mistake of it all: premature optimization. You optimize a complex application system based on stupid meaningless microbenchmarks without really measuring the performance of an actual application. Without an actual application or a really well-done benchmark that measures something akin to an actual application load, every performance measurement is pure wankery. Why uproot everything and move into new obscure frameworks if you can just implement the most naive and slow spring solution and slap a reverse proxy like varnish in front and call it a day while having similar or even superior performance?
You still have to block whilst you're waiting for a connection from the pool or more significantly waiting for the result set from the db. A large portion of the time spent processing a request is waiting for IO. There is always an upper limit, but the point being that async web servers don't like you blocking threads waiting for IO.
You didn't read the spec. It's not a reserved keyword; it's a reserved type. And provided you've been following the Java style guide, you're not going to have a type called `var`. Secondly, `(Foo &amp; Bar)object` syntax has been in Java 8. 
Huh, it looks like it's just a way to have a clearer code. Instead of writing String name = "Luke"; you just say var name = "Luke"; On both situations it seems you have a String variable called "name" whose value is "Luke." 
Various frameworks are represented multiple times with varying solutions. Undertow has no fewer than 6 variations utilizing different databases and json support. And that being said, and ignoring the fact that no one apparently cares to provide a variant for Spring that performs well for these extremely generic and vanilla use cases, I looked at the source for the Spring entry and it was pretty straight forward. It really just seems like intentional obfuscation to me. I can't for the life of me tell if Spring proponents are saying that Spring is really fast, and the benchmark/implementation is bad (at which point we could start getting specific), of if they are saying that CPU-bound time simply doesn't matter (which is demonstrably false for non-trivial use cases). Or perhaps they are saying that the productivity of the developer is going to save you as much or more than what you will lose in compute inefficiency -- at which point i would say "prove it".
This is why construction injection is awesome. The more dependencies an class has, the harder it is to create. Also, the constructor method signature advertises the class's dependencies, which are hidden by fields or setters. Finally, any method with a large number of parameters suggests that a refactoring is in order. Furthermore, I would highly recommend Uncle Bob's [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html). One of the biggest culprits I see for dependency madness is "service classes" that do everything, and which require pulling in dependencies from everywhere. The Clean Architecture alternative is having classes separated by "use cases" rather than monolithic service classes.
I could use a linked list instead of a hashed map, and cache lookups for individual elements to amortize the inefficiency of my data structure selection at the cost of complexity and memory efficiency -- but that would not make me a good developer. And this is the same logic used by people who say use python instead of java, or people who say use java instead of C++, etc. etc. etc. At some point performance concerns, and good design decisions, have to matter. And to me, Spring is obscure. You don't get to assume everyone comes into existence knowing Spring. 
It seems that PostgreSQL has supported async connections on the server side, and in libpq, for a long time, so it requires an async driver to be written. There are multiple async drivers at the moment, but none of them are written to a standard API. Hopefully that will change soon, and that the existing drivers are easy to adapt to the new API. I think you're a little pessimistic on time scales, but probably not by much. 
Slide 35: &gt; Prototype Oracle Database driver implements much of the API &gt; - uses nio Selector so non-blocking all the way down
Maybe you have two unrelated queries. Why not do them in parallel rather than waiting for the first before requesting the second?
The real advantage comes then you have a long typename. The real question is, can you use it with Factory methods as in var x = SomeFactory.createInstance(...) that would really be good. But already the for loop is nice to have. This looks in features pretty close to what C++ had with `auto`, and that was a real game changer there.
&gt; The fact that this person throws ThreadDeath best underlines the value of this article. Must. Take. Everything. Seriously. On. The. Internet.
This is just the spec, the db vendors will need to actually implement it first.
I'd also suggest that because the benchmark uses a simple SELECT * from Table where id = ?; query, the overhead is bigger than the query duration. I imagine longer queries would benefit more from async calls.
&gt; Then you quit and tell the junior developer "Good Luck", but he's happy because now he see a chance to rewrite everything in ReactJS that he learned over the last weekend. At least, there's not final in JavaScript. Au contraire, there's prototypes. We can now even override `String.substring`. FREEDOM!
 &gt; final is especially useful for you then, if it "forces" you to actually fix the bug at the right place, i.e. upstream. Assuming that upstream cares about your needs/fixes and actually wants them, or the process of getting them upstream is so tedious that you might as well not do it. Or your use-case does not warrant a change upstream but still all you want to do is make that function return something different for your application. &gt; As a user you do like stable libraries, don't you? What I also like is libraries that I can actually use...and build upon. And `final` is the very opposite of that. If something is *designed* to be an immutable container, *always*, then yes, by all means, make it final. But if you make getters/setters/classes final just because you *can*, I'm going to hate you at some point. 
The spec should still implement SPI methods. I am one of those people wanting to write an implementation. Not even asking for a full conformance test suite, just finished code.
Not exactly. Yes it has reactive streams etc. but once you access the DB your reactiveness is over because jdbc is still synchronous. Vert.x on the other hand has complete async io, both to file system and several databases (postgresql and mysql among them). Having reactiveness built into your application from top to bottom (vert.x) is entirely different than only having the top layer reactive (spring). 
Deciding against a framework that does not perform well is not premature optimization. As a developer you need to use the right tool for the job, and spring with its default implementation (tomcat, hibernate, jdbc) is definitely NOT the way to go if you want to create a webapp that goes beyond a few users. I get it, developing with spring is easy, because the heavy lifting is done for you, but that comes at significant cost. Too many developers start using spring without having any clue wtf it is actually doing, so you end up with shit software that can't even handle 1k users properly. Spring is NOT a silver bullet and the sooner you stop using it by default and actually get back to writing software instead of gluing spring components together, following the same pattern each time, the better.
&gt; Or perhaps they are saying that the productivity of the developer is going to save you as much or more than what you will lose in compute inefficiency -- at which point i would say "prove it". Productivity is often very subjective. It's mostly how good something "feels" given what you're used to and how the development culture in your organization is. Interoperability, integration concerns, knowledge transfer, knowledge acquisition, organizational standards are often much harder, much less subjective. 
&gt; spring with its default implementation (tomcat, hibernate, jdbc) Nothing in that list is a spring default.
I like that we keep reinventing a different design of callback functions every 5 years and calling them cutting-edge. Also remember that Oracle also owns MySQL.
When I was reading through the original discussion on OpenJDK, var name = "Luke"; is effectively final String name = "Luke"; I'll see if I can find that again but I don't actually remember :p - so you may be right
And sorry, repeating "overhead" over and over doesn't make it true. The differences we see here are because of different IO strategies. Nothing about spring says "you must use sync IO" in any way. It never has and it especially doesn't with Spring 5. &gt; Spring is NOT a silver bullet Spring is glue code. Glue code glues, it is no silver bullet. Nothing is a silver bullet -- including Async IO. &gt; sooner you stop using it by default and actually get back to writing software instead of gluing spring components together, following the same pattern each time, the better. Why do these spring-hater posts always leave me with the feeling that the people involved have no clue about spring, about working with spring or even about any kind of real software architecture? What has the Spring glue code to do with "real programming"? 
Developer productivity is a poor argument. Yes spring is easy, it's so easy you can put any brainlet junior dev behind it and they can write software that 'works', because all they need to do is follow a pattern. This however will just bite you and your team in the ass down the line, once you need your application to scale or need to build more complex software. Spring is not a silver bullet and shouldn't be used for web applications targeted at an audience that goes beyond a few users. There's other frameworks/libraries in the java space other than spring which are similarly easy to develop in, but fare much better in these benchmarks (which btw aren't synthetic, the 1 query and multi query benchmarks are exactly the kind of typical workload you speak of). People need to stop shilling spring to every developer just because it's easy. That comfort comes at a heavy price. From reading this thread it almost seems as if spring is like a cult, unwilling to face the facts.
Postgres already has an async driver. It works well in combination with vert.x
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Should you really be mocking concrete classes If I'm using a concrete class, then yes - I should be mocking a concrete class in my unit test. I don't want to create an interface layer just for testing. Mind you, I'm not talking about JOOQ specific things here. I would never try to mock a JOOQ or Hibernate class for a unit test (MUCH more suitable to test that stuff in an integration test and mock at the Dao layer for unit tests). But you're applying one school of thought for one thing to ALL unit testing situations and all methods. That doesn't make sense to me.
&gt; That's because there is no "correct" way to override my method, unless I explicitly designed it to be overriden That's exactly the presumption I'm talking about. If you write a method in your class called `.equalsIgnoreCase` and the implementation is incorrect (NPE, for example). I'd rather just extend your otherwise good class and fix the single broken method. If your method is `final` I can't do that. That's obviously a hypothetical that wouldn't happen, but that's the type of thing I'm talking about here. Why do you care if I @Override your library method?
There was some question about introducing a `val` type as well as `var`. In the end they decided that we already have the `final` keyword. 
&gt; can you use it with Factory methods Yes. In fact you can *only* use it when there's an rvalue, whether that's a new object, the result of an expression or the return from a method.
I don't see how that changes here. You can just as easily do that with a blocking API and a thread pool configured to hold the same number of threads as you have DB connections in your connection pool. The only advantage async drivers seem to give is not having to use a thread pool - but when the pool size is inherently capped at such a small value, that doesn't seem like much of an advantage.
&gt; This however will just bite you and your team in the ass down the line, once you need your application to scale or need to build more complex software. Spring is not a silver bullet and shouldn't be used for web applications targeted at an audience that goes beyond a few users. Care to back this up? Because there's tons and tons of Spring based software that serves quite a bit more than a 'few' users. &gt; That comfort comes at a heavy price. What price? And what do you suggest we use instead?
A bare bones Spring Boot REST service uses 35MB memory. I don't see how that's a 'resource hog'.
Believe it or not there are still Java developers out there that know how to write code and don't need Spring to hold their hand to accomplish the simplest things. Spring != Java. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Because, like I said, you're now depending on the implementation details of my class, which may change at any point. Maybe another method ```foo()``` in my code (possibly in some future version) uses ```equalsIgnoreCase()``` and assumes it to behave in a certain way (for example w.r.t. thread safety) and your version behaves differently. Now you call ```foo()``` and everything blows up because it's calling *your* ```equalsIgnoreCase()``` instead of mine. For details, see Effective Java (2017) Item 18 &amp; 19.
Which one? Is it regularly updated and maintained and respond to bug requests? Having tried them all, "it works well" is completely dependent upon use case.
 list.stream() .filter(Objects::nonNull) .filter(((Predicate&lt;String&gt;) String::isEmpty).negate()) .collect(toList()); Yeah, that's not pleasant. The thing is that you can use any method as a filter, so you could do: list.stream() .filter(org.apache.commons.lang3.StringUtils::isEmpty) .collect(toList()); You don't need a library of `Predicates`. You just need a library that has static methods for your object. If it takes your object and returns a `boolean`, you have a `Predicate`. 
Very very cool! I actually thought of doing the same thing once ADBA stabilises
Consider the case with many databases and 100 connections to each database. It's easy to end up with thousands of connections. That's a lot of thread switching. We have plenty of evidence that minimizing the number of threads in cases like this is a win. Since most of the connections are waiting on the database most of the time, thread per connection is wasteful.
&gt; which btw aren't synthetic, the 1 query and multi query benchmarks are ... utter bullshit, too. Hammering the database page cache with a single database table (10000 elements, an id and number, so roughly 44k?) is ridiculous as a real world scenario. 
Spring is potentially full reactive, but you're right, not with JDBC. Oracle plans to change that, but for the moment JDBC is still blocking. With other databases like MongoDB, you can have completely reactive applications.
&gt; Costs are the downside here, of course. Are they? A single developer can work a day or two for price of a server instance, even if you add in the overhead of electricity and server maintainance, 2 days are wasted sooo quickly.
You don't need a thread per connection, only a thread per active database query in today's synchronous model. I have to agree with the parent comment. I think the async model is of little use in the general case. There are no doubt a few cases where it is useful but it seems to me this is more a case of introducing a new API because being async is seen as modern and cool...
Here's the current SPI code. This is DataSourceFactory.forName. /** * Uses SPI to find a {@link DataSourceFactory} with the requested name or * {@code null} if one is not found. * * @param name the name of the class that implements the factory * @return a {@link DataSourceFactory} for {@code name} or {@code null} if one * is not found */ public static DataSourceFactory forName(String name) { if (name == null) throw new IllegalArgumentException("DataSourceFactory name is null"); return ServiceLoader.load(DataSourceFactory.class).stream() .filter(p -&gt; p.type().getName().equals(name)).findFirst().get().get(); } 
&gt; bare bones Spring Boot heh
There's lots of async database drivers, regrettfully all small projects supporting on or two databases, no common standard like JDBC. ([pgjdbc-ng](https://github.com/impossibl/pgjdbc-ng) e.g.) That's a general problem with async IO on Java though and not something specific to Spring. 
You are correct. There are many use cases where ADBA will be of no value. Probably most. We have tried to be very clear that ADBA is not a replacement for JDBC. But there absolutely are a large number of use cases where ADBA will be a big win. These are large scale high throughput apps. I can guarantee you that we are not doing this to be cool. We are doing it to meet real customer needs. I don't have the spare cycles to be doing things just because it is cool.
Yes. JDBC is still fully synchronous so there isn't any other choice. We will upload the code as soon as we can, but no promises as to when. As I said we want to get ParameterizedCountOperation and Transactions working. And we need to write some tests. Given how much free time we have to work on it, ...
There are intrinsics in java. That is, a direct function of the CPU can be called. This is the case for popcnt. Have a look at http://vanillajava.blogspot.fr/2012/11/java-intrinsics-and-performance.html for instance 
&gt; If I'm using a concrete class, then yes - I should be mocking a &gt; concrete class in my unit test. Why not just instantiate the concrete class? &gt; I don't want to create an interface layer just for testing. You create an interface for layer separation. Like a DAO interface. The DAO interface describes what the application needs for data access, and the DAO implementation fulfills the need. An interface creates a logical and compile time firewall between layers. Mocks ideally serve the purpose of defining what the system under test needs from its dependencies. An interface is a contract describing that need. A concrete class has its own reasons for changing, and if you mock the concrete class, you could make the mock tests invalid and mocks can't tell you that your tests are now nonsense.
Is this not clear in the article?
Thanks for your feedback. You're more likely to want to count bits in a long, for use in things like indexes. If you index data with bits, counting the bits can allow you to quickly compute the distinct count. I used integers to make the examples half as long to write.
&gt; bug requests
And we are talking about a reduction in cpu load. I don't think any DI was used in these examples.
You ignore the fact that I need the "fix" in this case right now. I'm the developer of my software. I'm responsible for how it works. That includes all the little bugs that sneak in because of someone else's code. I'm not saying we should all subscribe to the 'not invented here' line of thinking, but ultimately a bug in Apache StringUtils is a bug in RockMeetHardPlaces_APP. I am responsible for fixing it when I ship. Not when Apache decides to release the "fixed" version.
*Meaningful* amounts of CPU load. The stuff that happens outside of the frameworks. 
I'm not saying that productivity isnt real, or that having lanes for developers to live in doesn't make their lives easier. I'm just saying that you can't throw out a productivity claim as a blanket statement in order to fend off performance deficiencies without at least eluding to what you mean. It's a diversion meant to derail the discussion.
[removed]
That's one of the benefits of var. If you did have some factory method, if you changed the return type of your factory, you wouldn't have to go around changing every single reference to match your return type!
MySQL is owned by Oracle too, so I was including it.
"performance deficiencies"
This is just the productivity argument rewrapped. It's all about comparing the frameworks with all things being equal -- assume all of those apps are using databases and doing calculations. So if they are all dealing with similar out-of-framework loads, why then do you pick framework A or B? I put it out there that you can argue that CPU doesn't matter, and that it comes down to productivity concerns, and that would be a different conversation. It doesn't change the fact that Spring does poorly in this benchmark when compared against alternatives, and it's fair to ask why, even if you don't feel it's important to your workload.
&gt; So if they are all dealing with similar out-of-framework loads, why then do you pick framework A or B? Certainly not because of 2% overall difference. &gt; and that it comes down to productivity concerns, and that would be a different conversation. As I said: Productivity is subjective. That doesn't mean that it isn't important (it certainly is) or that it varies for one person which different frameworks (which it does), just that it is hard to really quantify. Hardly anyone does meaningful studies on productivity. I tried to list other organizational concerns. Spring is well-established, well-documented, there are heaps of resources to learn every aspect of it. How well knowledge of a technology is established within a company is a huge factor. No matter how fast your exotic framework is, someone has to maintain it, maybe even need extend it (woe onto whoever runs into the limits of your framework of the week). What happens if you leave / get hit by a bus? &gt; It doesn't change the fact that Spring does poorly in this benchmark arbitrary choice of (partially slow) technologies called "spring" here. Spring could just as well be Spring+vert.x and be up there.
Measure first, then optimize. Don't avoid polymorphism because you are afraid of it negatively impacting the hot path. In many cases, java will optimize away the virtual call (for example, if the method is usually called with the same object) and even in cases where it can't, you are usually talking about 2 extra pointer lookups. Not great, but also not the worst in the world (especially since the cost is generally payed once and cached the rest of the time).
The MVT model is out of date, they are currently looking at a much simpler model referred to as "l-world".
Can't wait til project loom gives us continuations and makes all this ugly async API stuff obsolete from a performance perspective.
I don't get why IntelliJ is so beloved and people give strange looks to anyone still using Eclipse.
Lucky you, we still fix Java 6 project in my company.
Probably. They're always 5 years behind!
Yeah, I'm trying to find where Rose talks about it.
Then again somebody has to take a look at Sonar to see this. Integration with code review tools varies.
I would also argue that queries generating smaller result sets benefit more than "select *" queries. All of the win in a truly async driver comes from sharing the heavy resource (a thread) to multiplex the cheap resource (connection I/O).
There is a good chance you got some drive by downvotes because of the title alone. I would guess the term "population count" doesn't come up very often for java developers (I didn't know what it meant). So it's possible people thought this was a post about the population of the java island that was posted in the wrong subreddit i stead of bit twiddling. :) If the target audience is people who don't know what a population count is or what it might be useful for, maybe intruduce the term in the article and call it something like "Efficiently counting bits"? Anyway, I found the article itself was well written, keep it up!
Sure, if you have multiple databases and 100 connections to each then obviously you don't want to be allocating hundreds of MBs worth of threads if you could instead go async. I guess I'm surprised to hear that there are applications which have 100 concurrent connections to a database. I would assume you would saturate the DB's CPU and hard drive well before that point. Most guides end up recommending under 10 connections for most DB setups, so that number really jumps out at me.
I think that's connection multiplexing, which is another issue altogether. DBs would have to support HTTP2 or something to support that.
Still gonna need it for parallelism.
Just because database [vendors recommend limiting the total number of connections](https://youtu.be/Oo-tBpVewP4) doesn't mean customers listen. "But my servlet is waiting for a connection to be returned to the pool." Yep. The alternative is for all your code to sit idle while the machine does endless context switches. 
Is oversaturating your DB server really going to improve anything?
&gt; why not [do this very esoteric, non-intuitive thing]? Well yeah, I was planning on it, of course... I just, you know, wanted to see if you knew about it...
That's exactly the point. It doesn't. But for some reasons many customers seem to think waiting at the pool for a connection is worse than waiting for the oversaturated DB.
Apache PDFBox should get you in the right direction. It requires you to know the names of the form fields, which can be a little tricky if you're not the one that created it, but should be doable.
link or ban
so you're saying that int and byte aren't keywords? and 'Foo &amp; Bar' is multiple (class) inheritance, not prototypical inheritance.
From a DBA perspective this will be mostly transparent. The efficiency is on the OS layer. You will see less RAM consumed and less CPU time used on both, the client and the server. The asynchronous mode is more efficient, because it replaces threads with more efficient, application specific constructs (depending on the implementation these could be co-routines, actors, flux, ...)
&gt; Is it considered a very good practice? No. It's just the latest fad frim the same people who brought us: - Ruby on Rails is going to make Java obsolete! - Object/document databases are going to make sql databases obsolete! - Dynamic languages are going to make Java obsolete! - Groovy is going to make Java obsol...well you get the idea Adding in the extra overhead - in typing, in reading through longer messier method signatures, in dealing with needing to change a value and not having it available - is particularly absurd in java where final just makes the reference immutable but not the object itself. Final makes "int index" immutable but "List indexes" is still a changeable list. Every decade someone rediscovers immutable-by-default. And languages that are **not** that way are the ones that get popular because they're a lot easier to use with a lot less frustrating overhead.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You are right about connection pooling and it solves most of the problem. But it does not mean that JDBC should not evolve and provide new features.
I have reviewed quite a few resumes' lately and a lot of devs actually list it as J2EE as well. 
Since this is the second "version" of Jakarta, they had the chance to resurrect that acronym with Jakarta 2 EE. The with the next version?
I fully agree that they should use native API for date and time. Otherwise, they reinvent the wheel. BTW. Nice library.
I can't speak to the quality or performance of the async postgres library, but the benchmark is flawed since the calls to the async implementation are all wrapped in blocking countdown latches. Forcing an async API to be blocking is not going to be any faster than a regular blocking API.
Some time ago I wrote this: https://www.jetbrains.com/help/idea/eclipse.html
It has tons of value for anyone wanting to support the new API in an upstream API without having to wait for "real" implementations. I, myself, have a particular interest in that :-)
I am coming from C++, so it is not hard for me. Intrinsics are common in C/C++ compiler. Intrinsics are instructions of CPUs. The advantage is that they clearly speed up equivalent function because there are hard coded (i.e. in the CPU). The drawback is that they are CPU dependant. In C++ the compiler manage them In java, the code has to be independant from the CPU but this does not mean that the JVM cannot use some them. Like C++, the JVM manages the use of them. However, in order to use them you have to use the library function, because the compiler will not recognize the meaning of the code, it will just replace some predefined function by intrinsics More information: https://en.wikipedia.org/wiki/Intrinsic_function 
**Intrinsic function** In computer software, in compiler theory, an intrinsic function (or builtin function) is a function (subroutine) available for use in a given programming language which implementation is handled specially by the compiler. Typically, it may substitute a sequence of automatically generated instructions for the original function call, similar to an inline function. Unlike an inline function, the compiler has an intimate knowledge of an intrinsic function and can thus better integrate and optimize it for a given situation. Compilers that implement intrinsic functions generally enable them only when a program requests optimization, otherwise falling back to a default implementation provided by the language runtime system (environment). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Right, but I’m trying to establish if you read the article before commenting, because it is made abundantly clear that you should use intrinsics in Java. One of the the benchmarks is even called “intrinsic”. Are you adding context to the discussion or did you get an impression from the article that there are no intrinsics?
Also, how confident are you with English?
&gt; Are you adding context to the discussion or did you get an impression from the article that there are no intrinsics? I get the impression from the article that there are no intrinsics, so a I mention them BTW, i you like this kind of computation, I recommend you to read https://graphics.stanford.edu/~seander/bithacks.html 
Thanks for clarifying that. I'm now convinced you didn't read the article beyond the first sentence. Moreover, the text below hasn't been edited since publishing &gt;The code above is intrinsified to the instruction popcntd and this method is the only way to access the instruction from Java. If it’s not already obvious, the power of having this access can be shown with a comparative benchmark. `Benchmark Mode Threads Samples Score Score Error (99.9%) Unit` `intrinsic thrpt 1 10 341.572057 1.983535 ops/us` `lookupTable thrpt 1 10 205.373131 0.557472 ops/us` `masks thrpt 1 10 191.744272 1.942700 ops/us` `naive thrpt 1 10 26.651332 0.101285 ops/us` `skipUnsetBits thrpt 1 10 94.125249 0.559893 ops/us` &gt;Despite its power, since no vectorisation of this operation is possible prior to the AVX-512 VPOPCNTD/VPOPCNTQ extension (available virtually nowhere), loops containing popcnt can quickly become bottlenecks. Looking beneath the surface is intriguing. I’m sure with explicit vectorisation the lookup approach could be powerful.
your text is clear now. 
I came here for feedback but it's frankly amazing how willing some people can be to comment without reading.
To be honest: I know very well this problem and I also know that people forget (or don't know) intrinsics in Java. Thus, I read very quickly the post and I didn't see the reference to intrinsics. Sorry for that 
To me it greatly reduces the effort of reading. When I see ```final``` I know the thing is constant and cannot change. That greatly reduces cognitive load while reading and trying to figure out how the thing works because it reduces the number of moving pieces -- i.e., most of the thing is static and it's obviously clear which parts are mutating.
Most often with concurrent access. Due to the lack of formal "happens-before" relationship without final, one thread can create an instance and e.g. put it into a concurrent hash map. Another thread can read the instance from the map before the field initialization happened for it. [See this stackoverflow](https://stackoverflow.com/questions/6457109/java-concurrency-is-final-field-initialized-in-constructor-thread-safe), [hrere](https://www.javaworld.com/article/2076747/core-java/design-for-thread-safety.html) or [here](http://bruceeckel.github.io/2017/01/13/constructors-are-not-thread-safe/).
I actually just found this annotation yesterday while working on a work project using Spring, JPA, and Hibernate. I am new to all of this stuff, so am working my way through it slowly but surely. I actually was able to use a Set in another spot without the @ElementCollection annotation and am now wondering why it worked. I did end up using Hibernate’s @ManyToOne(or @OneToMany, can’t remember which had to go where) annotation, so maybe that includes the same functionality? I did still experience some issues with that column, so maybe if I provided this collection annotation as well it might solve some of them. 
Cool, I needed an appetizer
Change Java version in project.... or company ᕕ(ᐛ)ᕗ
OK - thanks for sharing.
Could you share some pointers (maybe an example ) for how you would integrate a similar async library into a web server so that I may learn how you think it should have been done?
This one: https://github.com/mauricio/postgresql-async 
Couldn't seem to find the perfect link. As I said: it boils down to the lack of "happens-before" guarantees without the "final" assignment. Is it just me or is it increasingly difficult to find older stuff? Back in the day, every google-search would have turned up the right results, now it's hidden in a gazillion articles teaching other things. On further research, the behavior was formalized in the Java Memory Model with JSR 133. [Here's another article](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong). 
Why would my fix even get near your stuff?
time to dedup
Good read, though very dense in parts. Feedback (2c worth, just my opinion): * Need better title, maybe the prefix "Bit hacks:" or some other indicator of the general area. * The headers for the results table at the end are not aligned. * Some intermediate subheaders could help. Also the blog format has no width limit, making reading in neutral zoom hard (long long sentences). * The precision of the results is unhelpful. it would be clearer and easier to read if you trimmed to a single digit (e.g. 341.572057 -&gt; 341.6) * Splitting hairs: The article refers to intrinsics in 2 ways that are confusing: "a single instruction, popcntd, which is exposed as an intrinsic"; "code above is intrinsified to the instruction popcntd" I'm sure you know what an intrinsic is, but the article fails to express that clearly. A link to the wiki article, or OpenJDK wiki might have helped. I would prefer "generated by the compiler via an intrinsic" to "exposed", and replace "code above" with "method above". I like the blog and the quantitative approach, well done :-)
Thanks for the additional link. I'm aware of the theory and how `final` and `volatile` influence things. I've just never seen this happen in the context of initialisation itself. I mean the example from your article seems extreme: // bad construction - allowing this to escape global.obj = this; And I tend to agree that if a constructor leaks `this` then its object's contents are not guaranteed to be visible as expected. But few constructors leak `this` in such a way, so I wonder if this is really an issue in most code, specifically in [your own code](https://www.reddit.com/r/java/comments/826deq/top_10_useful_yet_paranoid_java_programming/dvaerax/), where no one is reading or modifying the `id`. Granted, in your example, adding `final` is a no-brainer...
yes 
Ah, I see. Thanks for the clarification. I think we're in agreement.
I only see phrasing that occur for the lookup table, which is one of the most obvious things to try. 
It's that at a certain point, your database hardware's resources will be completely saturated. CPU usage will be at or near 100%, the hard drive will be constantly seeking and reading, and any new queries that get sent to the DB will just result in you waiting just as if you'd never sent them at all.
&gt; Are there any good books you or others can recommend that could help me with this sort of thing? Yes, Effective Java by Joshua Bloch. It deals exactly with these types of issues and it is so highly regarded by expert Java developers that, e.g., Google's Guava code/design docs explicitly refer to items from that book when justifying designs. Come to think of it, reading Guava code and design docs is also great for learning high quality Java development practices.
I've had issues with this in production systems. with ConcurrentHashMap cached internal data. Sometimes you can just handle things fine with some well-placed synchronized blocks, but often, I want to write highly concurrent code. This is something to definitely keep in mind. It's also something that makes me favor immutable classes even more. 
Good to know. Thanks for taking the time to explain!
Lmao crickets 
Back up man. I'm talking about me using a library or some other externalized piece of code that I don't control (aka, not in my organization). If I can fix the actual bug, I'll fix the damned thing and not @Override anything. The issue I have, specifically with `final` methods and classes is twofold. 1) testing with mocks -- they're handy and final makes it more difficult (2) if I need to @Override something (which I admit happens rarely, but it does happen) I'm forced to use hacky (aka reflection or C/P) to fix the issue when I could have easily just extended the ***external*** library and made it my own via a single @Override method. As I mentioned above -- I've had to do this twice in the last 6 months. So yea, it's uncommon, but it's not exceptionally rare. How is doing this going to affect anything of "yours" blowing up? Answer: it's not. If I fuck something up, MY software blows up. It's MY bug. Not yours.
Read the fucking spec: &gt; The identifier var is not a keyword; instead it is a reserved type name. That means you can do: var var = 1;
@OneToMany and similar works fine with Set but for entities. @ElementCollection is needed when you want Set of simple types like Integer, String, Long or embeddables.
Ah yes, the one with no commit in over a year. It has several bugs.
Immutability is a nice property and should be preferred unless one has a really good reason not to do so. Scala does this right, the decision of mutability / non-mutability can be made without extra syntax noise in most scenarios. In java, the final modifier on each variable bumps the noise quite a bit. If the language was created today, it wouldn't go for the same design for sure. I tend to do following compromise: make object fields final, local variables non final - but write the code without mutating them. 
Main point for Jakarta EE was to keep JEE so it is not goodbye :) in fact thats the point ;) lol
Thanks, that's great feedback.
I build my jar outside Docker, I also use openjdk:alpine.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Swing lives on in it's awful horrible state.
To bad that the new Java Control panel (bin/jcontrol) is written in JavaFX ;p
uhhh...it's **NOT** being ended: &gt;Starting with JDK 11, Oracle is making JavaFX easier to adopt by making the technology available as a separate module, decoupled from the JDK. These changes clear the way for new contributors to engage in the open source OpenJFX community. Meanwhile, Oracle customers can benefit from continued commercial support for JavaFX in the Oracle JDK 8 through at least 2022. and &gt;With the Java Platform Module System in place since Java SE 9, it now makes sense to decouple JavaFX from the JDK, in order to make it available as a separate module. This will make it easier for developers using JavaFX to have more freedom and flexibility with the framework. Moreover, with our focus on increasing the release cadence of OpenJDK, JavaFX needs to be able to move forward at a pace driven by the contributions from Oracle and others in the OpenJFX community. Oracle plans to implement this decoupling starting with Java 11 (18.9 LTS). 
Well to me javafx was a bad experience. I'm no expert on the subject and I dont like Electron(true abomination who can like that? its a mistery). Still it is good to go.
Better article on the subject: https://blogs.oracle.com/java-platform-group/the-future-of-javafx-and-other-java-client-roadmap-updates. &gt; Starting with JDK 11, Oracle is making JavaFX easier to adopt by making the technology available as a separate module, decoupled from the JDK. These changes clear the way for new contributors to engage in the open source OpenJFX community. 
Thank god
:D
Sure, I read all that. And I'm sure that it will "live on". Just like Netbeans, Java EE(clipse), and most other commercial codebases jettisoned to "proceed at their own pace". What that means is that one or two small players (probably Gluon in this case) will step in to eek out a living providing support for legacy customers. But the pace of new feature growth (and resulting adoption), which was stagnant to begin with, will probably grind to a halt. If you couldn't convince your boss to use JFX before, good luck with that sales pitch now.
Sure, I read all that. And I'm sure that it will "live on". Just like Netbeans, Java EE(clipse), and most other commercial codebases jettisoned to "proceed at their own pace". What that means is that one or two small players (probably Gluon in this case) will step in to eek out a living providing support for legacy customers. But the pace of new feature growth (and resulting adoption), which was stagnant to begin with, will probably grind to a halt. If you couldn't convince your boss to use JFX before, good luck with that sales pitch now. 
What didn't you like about JavaFX? Genuinely curious. Back when it tried to be this new web media thing, I sure didn't like it much either. But as a desktop GUI toolkit, it's actually quite good.
Don't worry - they'll still be embedding SWT like they do for some of other tooling they ship ( unless that's already all gone? )
JavaFX was OK, but honestly, the biggest problem with it IMO was that it always felt incomplete. It had partial CSS and partial HTML (FXML) support while missing really common things (like setting width with css style). And simply a lot of common widgets and widget features (like sorting a table). Couple that with the fact that I never felt like there was a whole lot of community support around it. AFAIK, there was no React/Angular for JavaFX. As a result it was like working with bare metal all the time. The model was, IMO, good, but just incomplete with low adoption.
Well there's also https://github.com/vietj/reactive-pg-client I haven't noticed any bugs yet in a production environment
I think 9 just came out, I'd probably wait a year before trying it.
Then there will be 2 major releases (10 &amp; 11) out before you try it ;)
Why does everyone think this spells the end of JavaFX? Breaking JavaFX out into its own module seems like a great thing in every way to me: - The JDK gets leaner. Most people using the JDK don't need JavaFX - JavaFX can be developed at its own pace, with updates and bugfixes independent from JDK updates - Users who can't update their entire JDK can continue to take JavaFX updates as long as the JavaFX module doesn't require a newer JDK version This is something that we did on Android with support libraries and it works so much better than embedding all of these non-core classes right into the core SDK itself.
The new model will let them update more regularly, so I'm might actually address a lot of your concerns. 
What future?
Yeah, I just opened a bug on that last week: https://github.com/vietj/reactive-pg-client/issues/61. Though they solved that one problem, there are many others I point out in that issue. It definitely depends on your use case, but they all have problems. I'm gonna write my own using NIO I think, stay tuned.
Why do you say so about electron?
Well, they fired me for poor performance. Problem solved, I guess ? At least at their end. Now I face hell of constant change. Everyone wants Java 8/Spring/JS/Hibernate/SQL developer at least a mid level. Yeah, right. It's kinda funny how recruiters on LinkedIn get fooled by my years of experience. They see 5+, woah, let's try to sell him as Senior Java Developer. Senior my ass...I don't think I'm full-blown junior after 5 years, let alone Mid or Senior.
rest in peace, javafx, we hardly knew ye
The link to the mailing list was fixed a day or two ago.
The Future of JavaFX, of course
So far I have only seen talk about removing JavaFX from the JDK, but not the JRE. Did I miss something?
Please just bring back original JavaFX. The script was so clean and easy to work with. Building it into Java itself and redoing it all in pure java killed it.
JavaFX is that really cool technology that should have conquered the world, but somehow, for some reason, did not
Logins and passwords: http://bugmenot.com/view/oracle.com (the page is buggy and adds leading spaces to selected password - paste it elsewhere first to verify the copied text)
That would make no sense. The JDK is essentially a superset of the JRE. If you look at how OpenJDK is built, the JDK is JRE plus a bunch of other stuff. The JDK is a strict super-set. If you remove something from the JDK, it will not be part of the JRE either. Even the article makes it quite clear when it says: &gt; will be broken out of standard Java as of JDK 11 "Standard Java" here means Java SE, essentially the JRE. The term "JDK 11" here represents the Java version, not that JavaFX will be removed from the JDK only.
Yeah I have an account, I just can't find a download link for 7u171. Everything turns into a dead in requiring a support contract.
Yeah I've tried several of these in the past with no luck. I'll give it another shot.
Which ones did that happen to? Were they truly useful libraries that were only abandoned because they were no longer bundled with the JDK? Or did better alternatives just crop up?
Take a look at TornadoFX (https://github.com/edvin/tornadofx). Kotlin with JavaFX: Looks very, very similar to the old JavaFX script. But works a lot better. 
I may have misunderstood.
Do you have to have Oracle? Zulu has pure OpenJDK 7u171 downloads at https://www.azul.com/downloads/zulu/ (which of course contains the JRE in it) for all platforms. I use Zulu downloads at least until https://adoptopenjdk.net/ no longer says it's a work in progress.
So... You're looking to avoid having a support contract?
https://github.com/threerings/getdown/
Yeah, [this](http://mail.openjdk.java.net/pipermail/valhalla-spec-observers/2017-November/000388.html) is what it was.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thank you very much. 
Some examples that come to my mind - Java3D - JOGL - Java Desktop Integration - Java Media Framework
Ahh ok. It was, in fact, a Set of another entity. Thank you for clarifying. 
Not arguing with that. I agree its not really accurate to claim it runs on 'bare metal'. Theoretchicall maybe there are ways to compile Java to bare metal but that's not really how its done in practice. I was just saying, even though it doesn't really run on bare-metal. It is not something that will really should worry about since you can pretty much run you Java code on just about anything you'd like.
Not sure that what they are saying. It sounds more like they are saying "The JDK is going speed up release cadence... and we can't be bothered with releasing JavaFX at the same cadence". To me that is saying. There are no resources to release JavaFX fast enough to keep up with the JDK release cadence. In other words... this is so that JavaFX can release at a slower pace. That... honestly... sounds pretty bad to me. Because if they can't at least keep up with the JRE / JDK releases that means it may not even run properly on the latest JRE.
TIL it had a present.
It is really cool, but JavaScript supplanted it.
This document says they are looking to outsource AWT and Swing after JDK11 (technically supported through 2026): [http://www.oracle.com/technetwork/java/javase/javaclientroadmapupdate2018mar-4414431.pdf](http://www.oracle.com/technetwork/java/javase/javaclientroadmapupdate2018mar-4414431.pdf) Goodbye, desktop UI era. Although, I guess I have more confidence someone will keep the lights on for Swing apps than I do for JavaFX.
Desktop application have largely died with the web improvements lately. 
Encapsulation? :) Not all fields has accessors.
It's being developed in a farm upstate
How big is it? With the size of applications these days it's probably irrelevant.
As a practical matter it makes absolutely no difference
Where all developers are incredibly young, happy, and motivated to keep the platform alive. 
Still ugly clutter
&gt; distributed programs/packages heavier... But the JDK will be leaner *everywhere*. And now if you wanted to use a newer UI library, then you had the old JavaFX in the JRE and you also had to ship your new shiny thing.
The down-o-crats would like to have a word with you: https://entertainment.theonion.com/national-funk-congress-deadlocked-on-get-up-get-down-is-1819565355
Those are good examples, haha. I've never used any of those in any way. :) I can't really speak to the scenarios around any of them. All I can say, I guess, is that moving stuff out of the core SDK and putting it into support libraries has been one of the greatest changes to the Android ecosystem in a very long time. I hope that, since JavaFX really is quite good, we can get similar benefits by moving it out of the JDK.
Yup. You are right. JDK is X. JRE is Y. X is a superset of Y. If JavaFX is in Y (as the parent claims) then it must be in X as well. If JavaFX was in X, it could be that it was not in Y, as you say.
:D
I don't see where that doc says that they are dropping Swing and AWT at all, only that they are committed to them continuing to be a part of Java SE at least through Java 11 (i.e., until at least 2026).
Last bullet point of the summary on the first page says: &gt;Oracle has begun conversations with interested parties in the Java ecosystem on the stewardship of JavaFX, Swing and AWT beyond the above referenced timeframes.
It's a bit of a change for the Java standard library, sure. But then again, most languages I know do not ship a desktop UI toolkit in the standard library to begin with. Maybe they are just trying to lighten their distributions while also hopping on the open source bandwagon? That comment you pointed out makes me wonder if we'll see "OpenSwing" and "OpenAWT" soon. :)
I love java
Yes. Doesn't work with `abstract` though.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Have you been waiting 19 years to use this article in a reddit comment?
I've even thought about how I could embed webstart into a lightweight desktop app with embed jvm that exists to just load webstart.
Which certainly means looking to square off with Oracle's army of ~~the dead~~ lawyers.
JavaFX was not part of the JDK in 1.7. Nobody used it. We're likely going to see the same thing happen here - people will go back to Swing, as it'll ease installs, rather than try to bundle a third-party library into a desktop application (since distributing Java on the desktop is already a nightmare.)
That stuff's been moved to Swing.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Does anyone have a reliable for the replacement of webstart?
Reminds me of project lombok.
disagreed. doing anything remotely complicated still needs a decent desktop app, and I can make those easily for all platforms with java + javafx. writing programs for uploading, convertings and manipulating gigabytes of images would not have gone as well in an electron + javascript setup, considering how much ram mere text-editors in js need to function...
Their other point about missing features in javafx is valid though. It's also quite buggy in places.
:D
We're using PDFbox as well. Works good for most cases.
&gt;distributing Java on the desktop is already a nightmare. WTF? No it isn't. Just bundle a JRE with your app, same as any other dependency.
&gt; missing really common things (like setting width with css style). That's a feature, not a bug. Layout in CSS is awful.
I can't, because we have `jlink` now.
MariaDB and LibreOffice seem to be doing fine. There is no vastly superior alternative to JavaFX like there is for NetBeans and JEE.
MicroProfile has a spec too, see for example; https://github.com/eclipse/microprofile-health/tree/master/spec/src/main/asciidoc It’s not done via the JCP, so there’s no JSR. And don’t forget that Java EE implementations have always provided functionality that went beyond the specs.
Depends on what you mean by missing features. Setting width in css is not a missing feature but rather a consequence of how the layout model of JavaFX works (you can't set width for most components directly from java code either). This layout model is very different from HTML (for better or worse) so css-width is not coming. However there are quite a few other missing features that could be useful. Unfortunately because of JavaFX rather limited success there aren't many additional libraries around. Many bugs got fixed in Java 8. Prior to that it was a PITA to use. Nowadays it's ok. I believe that decoupling JavaFX from Java SE release cycle is a good thing for both sides. This should have been done long time ago.
By principle I also favor a set small specialized, commonly used tools over a readily-plumbed framework. Potentially better documentation/references, security, maybe most importantly the flexibility to choose, switch, upgrade any part of it. That being said, there is context. The organization, team composition, how critical / complex / long term / volatile the system is, the number of (micro)services etc. Going with a framework may be a reasonable choice in many scenarios. But even then I would prefer a framework combining "standard" tools, not own implementations.
I was referring to this: &gt; And simply a lot of common widgets and widget features (like sorting a table). In my (limited) experience with javafx (on java 8) I already found a few app-breaking bugs (scroll panes were broken with custom progress models...) and general issues (can't put a table in a vertical splitpane?!). I assume that with further development you'd come across more of them. They probably aren't too bad for a simple crud-style GUI but they are really annoying if not a deal breaker for more complicated UIs. Yes, they're working on fixing those, but javafx progress is unfortunately still too slow to really replace swing. I totally agree that decoupling it can only help. It's not like oracle was doing much for it in the first place and having multiple different versions in different stages of bug-fixing and features doesn't help its usability at all.
From my experience, don't rely on what Oracle are supposed to do. I'm assuming that any day now customers will phone about how our app (which doesn't yet run on java 9) just stopped working.
My company switched from flash to javafx. Of course it has a future!
&gt; distributing Java on the desktop is already a nightmare [**That's not just wrong...**](https://www.youtube.com/watch?v=RqeDhE-d918) https://www.youtube.com/watch?v=2fWyhJ2nhjw&amp;feature=youtu.be 
I had to add it, a recruiter told me I didn't have the required experience in J2EE, even though I had JEE listed (on another occasion I had some lady tell me that I didn't have any J2SE experience, even though I had 15 years of Java listed)
JavaFX is already not part of the OpenJDK JRE/JDK, so most Linux users have been needing to separately install OpenJFX since, well... ever. This sucks, but it may also lead to less confusion, as at the moment someone developing/running against a Oracle's version would assume JavaFX is always available (at least in 8-10), but it isn't.
The article discusses ways to concatenate streams. Union, difference, intersection are operations on sets, how do you want to define them on streams, arrays, (nonset) collections? 
A better title would have mentioned that this video is for IntelliJ users.
If we get rid of AWT, then how will our IDEs have fun trolling us by importing `java.awt.List` when we clearly wanted `java.util.List`?
? I am not talking about electron (what a fucking piece of shit). I am talking about this: if your application can be done as a web application, one would be stupid to not do it as such. There are still and probably will ever be applications that simply cannot be done as a web applications, for any reason. Electron doesn't count. Electron is just there for retards to make a desktop application without having to learn anything else than javascript. 
I think what bothers me is that I try to use the keyboard as much as possible, as the change between mouse and keyboard kind of interrupts the flow. And using hotkeys for this feels risky...in a way. Like I don't have complete control over what I'm pushing/commiting etc. Anyone else feel like this? 
&gt; The fact that the application "is complicated" is not one of them. The fact that the application is "manipulating gigabytes of images " is not one of them (on the contrary, it perfectly fits the web world not the desktop world). i dunno where you work, but uploading and downloading gigabytes of data is still a decently slow operation where I work, even with 600-700Mb/s upload/download speed. manipulating that data is best kept client side until it's ready to be uploaded, and no, a web client is not particularly well suited to the task. when i'm talking about gigabytes of data, i'm talking at a time, not "user downloads a megabyte of images, does some work, and reuploads it". and we're moving into terabytes now. if I used a web client for this kind of work it would be too laggy on the connections available to us.
I found it myself: http://www.oracle.com/technetwork/java/javase/javaclientroadmapupdate2018mar-4414431.pdf
I like using the menu to commit in intellij. It makes it easy to control what you are committing .
That's where you're mistaken. The entire design is wrong. Instead of uploading/downloading gigabytes of data, figure out a way to not have to do that and be able to use the power of multiple servers to accelerate its processing. "But the data is on the client" - &gt; Wrong. The data is where you want it to be and there's no reason for it to not be on the server in the first place where the processing can occur. If the server absolutely must have data uploaded/downloaded to and from it, put the servers on the internal LAN. You can have 10Gbps speed, but even 1Gbps would still work. For massive processing of data, to do it otherwise than on a server farm, sorry, you're doing it wrong. The client just needs results, or pieces of data at the time, no need to have the entire thing. I mean, what the hell, each client of yours will have a 24 core machines with 128GB of RAM just so they don't have to wait until the death of the universe to complete their stuff? This exact scenario you described is where the client-server architecture works best. And the client can be a dumb web page.
Java EE is a base on which other things can build. Nowhere did it (or I) say everything has to be a spec.
Partial commit support for Git will be in the next release 2018.1
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If distributing Java on the desktop is a nightmare, I want to see what you think is elegant. I use Gradle, and I can just add the `application` plugin and generate a zip and OS-specific start scripts, with all dependencies bundled up. I'm sure there's something for Maven to generate fat JARs to distribute, or something similar with launcher scripts like what Gradle gives me.
My man, Zulu worked great, thank you for the suggestion. I just had to reconfigure Apache to look at the new path for the jvm.dll. No more vulnerability. Thankfully this is my only application that requires Java 7 and is no longer maintained. As long as zulu is around I'm g2g :). Thanks again.
I wasn't trying to avoid having a support contract necessarily, I just needed to see if there were any free options available to me first before pursuing that path.
Agree, 3-way merge and recent magic merge resolve tool is a killer feature to me, but their gut integration is so weak! I use source tree as a help tool to work with something more complex then commit and push.
Agree, 3-way merge and recent magic merge resolve tool is a killer feature to me, but their gut integration is so weak! I use source tree as a help tool to work with something more complex then commit and push.
What troubles did you have? The CXF component is the preferred way to use SOAP with Camel.
&gt; That's where you're mistaken. The entire design is wrong. Instead of uploading/downloading gigabytes of data, figure out a way to not have to do that and be able to use the power of multiple servers to accelerate its processing. The processing has to be managed by the user, and the payload is literally gigabytes of data, so yes it has to be uploaded. &gt; "But the data is on the client" - &gt; Wrong. The data is where you want it to be and there's no reason for it to not be on the server in the first place where the processing can occur. If the server absolutely must have data uploaded/downloaded to and from it, put the servers on the internal LAN. You can have 10Gbps speed, but even 1Gbps would still work. No, the data is initially on the client, and it has to be uploaded. Sorry. &gt; For massive processing of data, to do it otherwise than on a server farm, sorry, you're doing it wrong. The client just needs results, or pieces of data at the time, no need to have the entire thing. For the rest of the processing, it's done on the servers. There is initial processing that has to be done with adjustment by the user before the data is uploaded. Sorry, you do not understand the problem space for this application. &gt; I mean, what the hell, each client of yours will have a 24 core machines with 128GB of RAM just so they don't have to wait until the death of the universe to complete their stuff? That's not needed for the initial processing. But at the same time, it doesn't make sense to do that initial processing since the gigabytes of data are on the client machine and redownloading pieces for this initial processing only introduces lag. &gt; This exact scenario you described is where the client-server architecture works best. And the client can be a dumb web page. No, what follows is where the client-server architecture works best, and we use a dumb webpage for the rest. The preprocessing of the image data is best done on the client machine while it's still there though. 
The command line is just an alt-tab away...
Ya source tree is a great tool. Makes advanced or complex features trivial 
Ya source tree is a great tool. Makes advanced or complex features trivial 
"We call it caring a lot"
So I remember reading this when it came out. And interestingly enough it becomes relevant somehow every 2-3 years. Mostly when you're pointing out how absurd two sides of argument are. So this IS a unique instance of it being relevant. There was also this one, but it doesn't become relevant so often: https://politics.theonion.com/clinton-threatens-to-drop-da-bomb-on-iraq-1819564617
JavaScript has no GUI capabilities. It manipulates a text based document which is then rendered by a web browser. Web browsers don't offer any kind of standard GUI components beyond textfields and buttons. It is a dirty hack at best.
What do you exactly mean by „recent magic merge resolve tool”? Did I miss something lately?
&gt; -1, which is – in a way – an alternative null for primitive type int In another, more accurate way, it is not.
this is a weird place to shitpost
Or a ctrl-alt-t :)
It's somewhat disappointing that all the technologies mentioned in that paper don't yet have standard replacements.
A colleague of mine put this [contract first example](https://github.com/petenorth/camel-cxf-wsdl-first-spring-boot) together. It should give you enough of a look at the components and their relationship to each other to get going. 
It is a more community-oriented place it seems. It also has both Hotspot and OpenJ9 JVM options. Just a simpler place to point people to and easier for myself.
Very funny. In case you aren't joking, mathematically defined a set is just a collection of unique elements. There's no reason why a java.util.Set is the only data structure that can hold one. Very often in practice a set of objects will be held in a data structure implementing java.util.Stream, java.util.Collection not inheriting java.util.Set, or an array; or we want to view the collection as a set of objects for a given use case. There are plenty of use cases where we want to view collections containing duplicate elements as a set and perform set operations on such collections. For example, marketing asks for prospective customers for a new product based on customers already currently using both product X and product Y. Even though both lists probably have duplicates even within themselves, the result you want is still called the intersection. Another way to think about it: there's a reason (e.g. use cases exist) why sets can be converted into streams, streams have functions like "distinct" and even if a stream came from a list or array, there's a set collector in the Collectors class. https://www.mathsisfun.com/definitions/set.html
It’s both useful **and** pretty, actually. The entire Netflix stack is driven by “[functional reactive prograbecausemming](https://medium.com/netflix-techblog/optimizing-the-netflix-api-5c9ac715cf19)” (they may have recently given that term a new moniker) and they [evangelize this architectural approach](https://medium.com/netflix-techblog/reactive-programming-in-the-netflix-api-with-rxjava-7811c3a1496a) quite a bit. They were/are a major proponent (and I believe contributor) of the reactivex project, specifically RxJava, and are probably a huge reason why this paradigm has gone mainstream (and subsequently ported to other platforms, eg RxJS). Functional code tends to be easier to reason about it ultimately describes **what you’re trying to do** (as opposed to imperative, which describes “how you’re doing it”) and due to functional operators (map, flatMap, reduce, etc.) operations are almost always more succinct than their imperative counterparts (conditionals, loops, etc.). Functional approach is taking the programming world by storm. It’s definitely a mindset switch but once you’re familiar with it, it’s both addicting and productive. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
And how would I write a test case for this? Does this have something like Rest or Netty-Http DSL where I can mock the service? 
You can use [MockServer](http://www.mock-server.com/) if you like. SOAP calls are really just Http underneath and can be called like a REST call, so you can certainly mock them. For example here's how you'd make a SOAP call with Postman: http://blog.getpostman.com/2014/08/22/making-soap-requests-using-postman/
I mean do your own stuff not use the existing stuff.
https://www.codenotfound.com/apache-cxf-spring-boot-soap-web-service-client-server-example.html
Yes, I do it all the time. So much faster and more succinct for searching through lists and stuff. Lambdas and streams everywhere!
But do you use the utils.function stuff to make your own etc? 
[Obligatory Vert.x plug](http://vertx.io)
I use the fluent stream API quite often. Wen you got used to it, it is very readable in most cases. But you can easily do too much of it.. Other things are some (bin) functions as parameters to "inject" some behavior. But this is not very often. 
Ah, gotcha. Once or twice maybe. I haven't used it a whole lot. You really need the right use-case for that and they seem to be a bit rare.
? You use the existing stuff **to** do your own stuff. Most of that stuff are just helpers to facilitate functional programming. Sure you could rewrite some of for learning purposes, but why reinvent the wheel?
IME, `git add -i` does a much better job. And `git diff` / SourceTree are much better at visualizing everything at once.
When it makes the code simpler and better, yes. It doesn't always. "Lambdas and streams everywhere" is simply wrong. "Almost everywhere" is right.
It's true it is complicated. The knowledge required is very esoteric as finding help online is very limited. However once you have it up and running it's pretty maintenance free. I thought the whole plugin architecture for alfresco was hard. Especially those amps and having to restart the entire server process everytime it was updated.
Always remeber that the reactive manifesto talks about reactive-systems not reactive-programming(i.e. RX). Both have reactive in their name, but are completly orthogonal and different things. About the point of JSON streams and back-pressure. There should be no need for some custom back-pressure signalling over the HTTP protocol, every TCP connection has back-pressure already build in. Setting the ThreadLocal context should be avoided in when using RX framework. Take a look at http://projectreactor.io/docs/core/release/reference/#context (used by Spring Security) 
Much less than I'd like to.
No argument there, it's part of the big reason that the community is thrashing around OpenJDK, Zulu, etc.
&gt; Java EE is a base on which other things can build By that definition, Spring Core is a base on which other things can build. No? &gt;Nowhere did it (or I) say everything has to be a spec. Exactly! So can we agree that the argument "Do not use Spring because it does not follow the JavaEE spec" is officially dead? Next time a JavaEE vs Spring discussion pops up in this subreddit can we focus on technical merits instead of rumbling about JavaEE standards?
Unless you have good reason to, you should use the functional interfaces in `java.util.function` rather than creating your own. (See Effective Java 3rd Ed. Item 44.)
&gt;MicroProfile has a spec too That might be a "spec", but it is certainly not a JavaEE standard' &gt;And don’t forget that Java EE implementations have always provided functionality that went beyond the specs. Can I quote on this next time a JavaEE advocate talks about following standards? Can I finally use both @Inject and @Autowire, both @Bean and @Resource in my code without any guilt that I am not fully following standards?
Yeah that's what i mean do you use those interfaces? And what do you do with them on a bog standard enterprise app without crud etc?
It's much more painful in Java, than in languages that had support for higher-order functions built in from the get-to. [I find myself doing a lot of converting between streams and lists, in Java.] But at this point, `map`, `filter`, and `reduce` are essentials for me, esp. with the `-&gt;` function notation. I think the biggest (related) win is using a lot more immutable data: it meshes well with the higher-order and stream operations, but it's a huge in itself, reducing the interaction between distant parts of code.
https://en.wikipedia.org/wiki/Functional_programming In a word: lambdas.
**Functional programming** In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. It is a declarative programming paradigm, which means programming is done with expressions or declarations instead of statements. In functional code, the output value of a function depends only on the arguments that are passed to the function, so calling a function f twice with the same value for an argument x produces the same result f(x) each time; this is in contrast to procedures depending on a local or global state, which may produce different results at different times when called with the same arguments but a different program state. Eliminating side effects, i.e., changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
These interfaces are used indirectly in most cases, since the lambda syntax is expanded to these interfaces at compile time. Thanks to these interfaces you can use one APIs with lambdas. In other languages like Kotlin or Scala you wouldn't need such interfaces. 
Doing something as you just wrote (assigning function to functional interface) is actually something you need only in very specific cases where you need to pass anonymous function somewhere (as parameter to method for example). Using functional approach, in my experience, is mostly about using StreamAPI (map, filter, collect). 
Yea so basically whenever you need a simple task done. Lambdas are just a shortened form of using delegates. They're still functions at their core. 
Surely new features will require learning, but modules simplified dependencies in the JDK, and allowed for the encapsulation of internal APIs. With the new six-month release cadence, be ready to quickly adapt to changes in the language and platform.
I think I can see where your confusion is coming from - you're wondering about the use-cases rather than what is available, right? A quick answer to this would be to not use it unnecessarily. If you are writing a project from scratch, then it makes sense to use as much of it as needed, especially in your own code while keeping your interfaces sane. The other factor is that functional programming is more of a style than available features. You could still do functional programming in plain old Java 1.4, but that would (probably) be much more inefficient than using the new-fangled support in Java 8 and above. The final point here is that Java was not really built for functional programming in the way that, say, Haskell was. So, don't sweat over trying to modify your entire project into a functional style, which is most likely not even the proper way to use these few functional features. Streams and lambdas generally provide a nice way to reduce boilerplate, but be warned that this support is not perfect, especially when it comes to exception handling (which, last I checked, was horrible when it came to checked exceptions meaning that it could not be done directly). 
My experience to date (anecdotal) is that it's used in a limited fashion, and most java devs are still coding imperatively. I like it, and I think the reactive style has a lot to offer in many scenarios. I still think java land has a ways to go before we can get a full reactive stack (reactive jdbc for instance) but a lot of progress is being made rather quickly. I would expect this to become more normal over the next 2-5 years or so.
In addition to Adopt Open JDK, look at: https://github.com/ojdkbuild/ojdkbuild 
Yes, especially for lazy loading. Instead of setting the objects or overriding methods it’s a lot easy to pass a lambda and let the class that needs load and reload it as needed by just calling the load data methods. Saves a good amount of ceremony code. 
Java 9 is EOL this month http://www.oracle.com/technetwork/java/eol-135779.html
There are situations where I've had to undo functional style due to abuse. Take for example this snippet I found in a method: final List&lt;SomeType&gt; things = getThings(); final AtomicInteger count = new AtomicInteger(0); things.forEach(thing -&gt; { [various bits of processing] count.incrementAndGet(); }); return count.get(); This is bad because any gains from the internalised foreach are arguably outweighed by the synchronisation on count, so while it may read nicely, ithere's not really any point. You may as well just do a standard foreach and increment. On the whole though I use 'functional style' quite a lot, it results in much nicer code to write and read.
As someone who writes Scala all day at work and Java for my side business - most things in Java can be done functionally but not all things. There are some things about Java that make doing things functionally tough such as: * no Optional streams, which is fixed in Java 9 * lack of expressions (can't assign result of if/else) * no partial functions/pattern matching * you can avoid reassignment but you have to go out of your way to mark things final (no vals). I'll generally mark things final however when it's not a single inline assignment. Among other things but these are what come to mind immediately.
In 95% of cases where you can/could use stream it will decrease performance of the method. Just because it looks nice and "modern" (Lips is from 1950s) doesn't mean it's the right way to write that piece of code.
&gt; it will decrease performance of the method. true, but it looks nice. and we write code that looks nice, not one that performs well, or fast or is even correct. hell, if it doesn't format your hard drive in the first 5 seconds of usage, we call it a win.
Yes, but if you have 10000 objects and you want to filter them by distinct, using stream you will have `array.stream().distinct().collect()`, using java7 you would do `ArrayList(new HashSet(array))`, one of them is almost 3x faster. You also pay for CPU and memory usage for your deployment, sometimes it matters to make the method to run 3x faster than the other one, especially if you run FaaS where performance is primary concern.
I would say, be aware of the changes, but in most jobs you would not have to adapt to the changes quite so quickly, unless you are writing mass-consumed libraries
The readability of this would not be improved by a stream: for (String user : users) { // do stuff } 
Yes, but still a lot of people do it.
I mean full functional programming so not just standard java with some streams and lambdas, but just apply functions everywhere like you would in haskell. 
Whatever programmer wrote that garbage needs to get re-educated. That's hilariously bad.
If you're using a stream for the sole purpose of filtering non-distinct elements, then yes, I agree that it doesn't make sense. Additionally, you can always do things like `new HashSet&lt;&gt;(myCollection).stream().map(...) ...`
Perhaps this is simply due to how you had to reduce (redact maybe?) the code sample, but why wouldn't this return things.size()? There must be more going on here than counting elements in a collection.
I can attest to this, but it still doesn't stop me from doing Rx 99% of the time, when performance doesn't matter. As an example, I was working on a game and many of the functional/rx constructs I added were notably slower. However, at work, where I don't have a game loop and don't care about garbage collection or my flame chart, I totally use RX almost all the time, and only take it out if there is a concrete reason. 
:D
&gt; I would love to hear some comments on this /u/henk53 and /u/CopperHeadBlue especially since the main argument against Spring so far, is that it is not part of any standard. Josh, is that you? 
No, Java is not a functional language. It has some functional features and you use them when it's appropriate.
Post on stackoverflow with more details.
Short of Haskell, I don't see any mainstream language doing that, or even being capable of it. That's no surprise though since Haskell was designed for it from scratch. In Java, not only is it infeasible, but it wouldn't be a good idea as well since it wouldn't mesh well with the rest of the language. Also, performance would definitely suffer.
It really depends on what you're doing with your list of users.
I've defined named lambdas before a stream operation to add a little extra readability. That way, the name of the lambda describes what your lambda is doing. Predicate&lt;User&gt; ifActiveUser = (u) -&gt; !u.isDisabled() &amp;&amp; !u.isLocked(); List&lt;String&gt; activeUserNames = allUsers.stream() .filter(ifActiveUser) .map(User::getUsername) .collect(toList()); I probably could have found a better example, but you see what I mean. (I'm a little disappointed that I won't be able to use `var` to get rid of the `Predicate&lt;User&gt;` declaration, but I understand why.)
I can't remember which article it was that I was reading, but it basically said "If you are reaching for `.forEach()` you're not thinking functionally." Now I think about it, I think it was a video from a conference late last year. Java One? 
That's normal, most new applications are web-based that adopt SaaS model. 
FP is only every necessary if you do a lot of complex concurrent programming. In the enterprise world, that's seldom the case, especially since web frameworks typically handle thread management for you. 
I really like using lambdas, streams and filters for looking for objects in lists especially when lists of lists or lists of objects containing lists etc... are involved. I find it so much more readable and intuitive than loads of nested for loops. I tend to shy away from writing to much actual code inside the lambdas though (I'd prefer to use a normal for loop than the stream version) as I've found that the resulting stacktraces of any errors that may occur I'm the lambda to be difficult to diagnose.
Not yet! I have an app that I'm working on that would benefit though. I'll look into the new Java features already lol
Wouldn't `var` still work if you declare the type of `u`, e.g. `var ifActiveUser = (u: User) -&gt; !u.isDisabled() &amp;&amp; !u.isLocked();`?
No, you can't use `var` with lambdas, because it doesn't know what the type of the lambda is until you use it. That could be a `Predicate&lt;User&gt;`, but it might also be a `Consumer&lt;User&gt;` or a `Function&lt;User,Boolean&gt;`. The compiler wouldn't know until you use it in a `filter()`, `peek()` or `map()` function.
There is an app called SoloLearn on android, (not sure if on iOs), and it has a good selection of tutorials for html, css, javascript, jQuery, MySQL, python, java, ruby etc... It's free so its worth checking out. You also get a certificate of completion for each of the topics.
Yeah, I see that now. It's a bit unfortunate that functions aren't first-class types :/
AWT is the foundation for Swing, and even JavaFX needs to use AWT classes for some functionality. AWT will not go away completely until either replacements for its non-widget functionality are created, or Swing itself goes away. More to the point, the doc referenced in this sub-thread says: &gt; Swing and AWT will continue to be supported on Java SE 8 through at least March 2025, and on Java SE 11 (18.9 LTS) through at least September 2026.
&gt;JavaScript has no GUI capabilities. I don't think you understand how JavaFX works. The widgets in JavaFX are native code. FX simply places them and provides logic in the same way JS does for Web interfaces and JS frameworks. The fact that JS was universal but its execution engine was built into the browser (so not requiring a JVM to be loaded) definitely was a key factor in it displacing JavaFX. 
Looking back at it, I think I must have read about then plans of all the toolkits being removed from the JRE with a lot of advance and didn't realize they were just being separated and not entirely shelved. Although it does look like Oracle is looking for someone to take over their development, which is as much being retired as AWT/Swing can be retired at all, for the same reasons your stated.
I started doing FP in Java for a couple years. There's quite a lot that can be achieved which is far less verbose than the equivalent in non-FP Java. Unfortunately, I found that once you get past Lamdas and Streams, there's not much depth. I started working on several FP libraries for Java, including some testing libraries and one which did something similar to Scala's match-case statements. The problem I consistently faced was a lot of the stuff I wanted to do, and most of the FP libraries I was trying to create, were features natively supported in Scala and dome much better than I could hope to achieve in Java. I currently work mostly in Scala, so I haven't really looked back much since. &gt; I've used little bits here and there but it doesn't seem all that useful or pretty. I've taught a good number of people how to use a lot of Java's FP features. The people I have run into who say similar things to what you said, I've always given up on teaching fairly quickly. If you're looking for reasons to hate it, you'll find them. Java FP is a tool; it's better or worse at accomplishing different tasks and it's easy to misuse. There wouldn't have been any point for the FP tools to be added to Java if they didn't have legitimate uses. Given Java's history, they're actually extremely biased towards the "don't add things" when it comes thing things like functional programming or advanced language features.
GUI programmer here. It also cuts down a lot of boilerplate for event listeners.
Ouch, that is some absolutely terrible .... I mean you can't even call that bad functional programming. Putting a lambda inside a for-each is imperative programming. I mean props to them for learning how to write a lambda, presuming they even learned that and it's not just copy+pasted from somewhere.
Yessssss… Let the object-functional flow through you…
&gt; "If you are reaching for .forEach() you're not thinking functionally." There's no need to find it; I'm sure there are many thousands of articles saying that. Anyone who knows anything about functional programming will tell you that. 
Yep, great point. No more anonymous classes for every single call.
It is a bit of a mentality change to get comfortable using it, but it is very clean and quick when used correctly. I did learn the hard way that streams do not play well with lazy loading. 
That's not even written in a functional style. That's imperative style but with excessive use of fancy new features. A functional style would be `getThings().size()` or `getThings().stream().count()` is you want to pretend size doesn't exist for the sake of the example.
Do those event handler callbacks handle backpressure? That’s another key aspect of reactive streams.
Could you provide an example of if/else assignment? 
I wish blocks in general could become statements. I would love things like `x = if(y) { 0 } else { 1 }` or similar in Java. 
Write one yourself! 
Terse in a good way or terse in a bad way?
Microsoft created and popularised Rx and RxJS. Netflix did create RxJava but it was based on Microsoft's Rx.NET API. They did improve it by adding support for back pressure and singular/maybe types that could have exactly 1 or 0/1 values. 
SoloLearn is just a *vocabulary book* for programming languages. It does not teach *actual programming*.
There is an IDE available on Android: [AIDE](https://play.google.com/store/apps/details?id=com.aide.ui)
man, I'd love to have this in java 
Let me put it another way: Anonymous inner classes were considerably more verbose than lambdas. Collections.sort(personList, new Comparator&lt;Person&gt;(){ public int compare(Person p1, Person p2){ return p1.firstName.compareTo(p2.firstName); } }); vs Collections.sort(personList, (Person p1, Person p2) -&gt; p1.firstName.compareTo(p2.firstName)); Although you should probably write: Collections.sort(personList, comparing(Person::getFirstName));
You could tell the compiler: *Predicate*\&lt;*User*\&gt; ifActiveUser = \(*\(Predicat*e\&lt;User\&gt;\)User::isDisabled\).negate\(\) .and\(\(\(Predicate\&lt;User\&gt;\)User::isLocked\).negate\(\)*\)********* but it's not particularly readable.
It looks like in your [submission](https://www.reddit.com/r/java/comments/835fqf/apache_camel_exchange_not_delievering/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Well it teaches you the basics and the syntax of the languages. He was looking for an app which teaches you to program, which technically, sololearn does, it even has a built in ide to let you test your code. Unless you just intend on watching tutorial videos on apps such as udemy, treehouse or even YouTube. Regardless it's a free app that contains a lot of useful programming information and help. 
`String s = boolValue ? foo() : bar();`
Well it depends how they publish the modules doesn't it? Possibly we can just manage it like literally any other dependency... Do you have to build an extra installer for every third-party jar you currently distribute with your software? Haha.
&gt; Lombak can help with this! How does it help in this case?
I can't stand that syntax (I always get confused) and i was thinking (although i wasn't explicit in what i wrote) to inline methods for each branch like this: ` String s = boolValue ? {() -&gt; return "true"} : {() -&gt; return "false"}; ` but clearer, with this structure ` String s = if(boolValue) {() -&gt; return "true";} else {() -&gt; return "false";} `
Author here: Errm, you're right. Noted for next time.
cordev, i'd like to get your input on the other episodes from that series (especially when it comes to merging, the commit history etc)! I personally find git diff / SourceTree to be much more complex once you are used to IntelliJs overview, hence I'd like to get some differing views :)
I wouldn't be that drastic. I think there's some things missing from the IDE that are in the CLI (like --force-with-lease), but for more than 80% of day-to-day work the IDE just works fine. In any case, I'll be trying to cover these differences as well...so bear with the series for a while :D Regarding Stash and Shelf...you I can feel you. Keeping that straight takes too many stackoverflow searches... 
&gt; Stash and Shelf - Stash is what IntelliJ automatically uses for everything or git-related (updates, branch switching, etc.). - Shelf is what I do by hand when I want to save a specific set of changes which I might or might not need later (usually when I'm trying several ways of doing the same thing). Just do it like that, no way to ever get the two mixed up.
Stash for automatic IDE things, Shelve for manually saving some changes for later. And line staging is coming in the next release. However, just yesterday I wasn't able to cherry pick a commit because it was a merge commit (from a PR) and IntelliJ didn't let me include the -m option. I had to open a terminal and do the cherry pick by hand. Seems kind of silly.
Never knew about that, really cool thanks.
I try to avoid shared (or, worse, global) mutable state as far as possible. Local mutable state is fine. for (int i=0; array.length; ++i) { sum += array[i]; } // sum is locally mutable ArrayList&lt;Foo&gt; tmp = new ArrayList(); // initialise tmp for (Foo elem : tmp) { elem.doStuff(); } // tmp doesn't leak anywhere return; I get very nervous when all of these are true: - an object is mutable - an object is shared between objects (or referenced from a `static` field, etc) - at least two of the referencing objects interact with the object (for instance, a collection that holds mutable objects won't call any methods on them) # Semantically Thinking about the semantics of mutability, I believe that the ideal choice between immutability or mutability is often apparent by thinking about **information flow**: a mutable object can be seen as an object that can transmit information between all objects that share it -- it's an N-to-N communication channel. Example: class MutableInt { int x; } class Foo { MutableInt mInt; Foo (MutableInt mInt) { this.mInt = mInt; } void inc() { mInt.x++; } void print() { System.out.println(mInt.x); } } I can now use aliasing to implement communication: MutableInt theInt = new MutableInt(); Foo f1 = new Foo(theInt); Foo f2 = new Foo(theInt); // send message from f1 to all holders of theInt: f1.inc(); f2.print(); // send message from f2 to all holders of theInt: f2.inc(); f1.print(); Problems arise when you "send" informations to recipients that you did not intend. In Java practise, there are two good ways to deal with that issue: - keep N as small as possible (in other words: keep mutable state unaliased or local) - use immutable objects to prevent sending of messages
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; This is bad because any gains from the internalised foreach are arguably outweighed by the synchronisation on count, so while it may read nicely, there's not really any point. I'm actually not sure whether you're right there. IMHO, the JIT would: 1. inline `forEach` 2. inline the lambda 3. recognise that `count` is a local object, and therefore stack-allocate it 4. remove synchronisation on a local, unshared object. That being said, I'd definitely use a standard foreach here. One advantage of that would be nicer stack traces in case an exception gets thrown.
Deeplearaning
That's entirely possible, yeah. I was more concerned with why the author believed writing (or not fully refactoring) this code was better than a standard foreach. Misunderstandings about this often reveal more fundamental gaps in understanding about functional/parallel-ready code.
Nice to see DL in java, mostly i come across python versions
Very helpfull post, cleared up a few kinks. Thanks!
I am using http4 to make SOAP calls. This is done by creating a class that returns soap messages. For example we send the customerID from the header to the method1 of bean "ConstructSOAP" and get the SOAP message. Then make a post request with this SOAP message. `.setHeader(Exchange.CONTENT_TYPE, constant("text/xml")) .setHeader(Exchange.HTTP_URI, constant("https://thesoapsevice.asmx?wsdl")) .setHeader(Exchange.HTTP_METHOD, HttpMethods.POST) .bean(ConstructSOAP.class, "method1(${header[H_CUSTOMERID]})") // Construct SOAP message .to("http4://API") .convertBodyTo(String.class, "UTF-8") .log("${body}") //Print response`
Yes, I know that the ternary operator is a thing, but I find it much more unpleasant to use. 
This is definitely a blunder. But a decent programmer under stress can produce something like that easily. Mocking code is in the way of writing good code as a team, eventually people will start hiding the code they're not confident about.
In 95% of cases, performance isn't the problem you're solving.
&gt; That's entirely possible, yeah. Look at my edits if you haven't seen them :-) I checked, and my assumptions don't hold.
Except that JavaFX was designed with the sole purpose of creating rich desktop applications. JavaScript+DOM was not. JavaFX also has a built-in library of common GUI components like split panes, tab panes, trees, file choosers, color pickers, date pickers, web view, lists, menus, etc. All of them are designed to work with the same general principals and all can work together with no issues and all are styled to look the same by default. In addition to the GUI components JavaFX also has several sane GUI layout panes built-in. JavaScript+DOM had none until very recently with CSS Grid and Flexbox. Prior to that layout in web apps was a complete and utter nightmare. Saying JavaFX and JavaScript+DOM is the same thing is nonsense.
that would be a problem regardless of using functional stuff or not. You should design your code in a way that have taken that into account. 
I'm not following. If you're only using functional stuff (I'm assuming the means the stream API, and internal iteration like `.forEach`), you're not doing functional programming. In other words, adding a few lambdas to an imperative program does make it functional. Making your data immutable does.
🙄
Everyone writes "hello world" just to please java gods :) I wrote java first time in my life when I started in a company after college and been doing so for last 8 years. I remember first thing I did was to refactor a 100 class monolithic package into 3 packages. I can still see my first code review and has been using it as inspiration whenever I feel like I have not learnt anything... :D
looks like UserAccountDto just has a method isHidden that returns a predicate. 
I mean, they certainly *could*. The Observer pattern strictly does not permit communication in that direction, but almost nobody strictly uses design patterns. This is just a third layer mediating interaction between the observers and the observables, which you could program however you want. You could add a buffer in various forms, or you could drop a subset of events, or you could detect duplicates, or whatever. None of these are new ideas. They're just packaged up into a neat framework. The availability of dynamically scaling hardware clusters is the real "new thing" here, not the new programming models that can take advantage of them. Reactive programming is a fad. In ten years, it will seem hopelessly outdated, like someone bragging about their Java code using generics. I've seen a dozen of these come and go in the twenty years I've been a developer. Functional programming, meanwhile, has been around for seventy years. I can't remember which, but notoriously, either Expedia's or Travelocity's systems are written in LISP. It's cool that it's available in Java now, but it's certainly not some amazing new paradigm (except, again, insofar as stream processing can be distributed to dynamic clusters).
My first app was a simple for inventory management by storing data in a database and implementing Java swing as a front end to interact with the user
it returns a boolean.
Then you're not returning Strings. `Supplier&lt;String&gt; s = boolValue ? () -&gt; foo() : () -&gt; bar();`
Then what's this all about? Predicate&lt;? super E&gt; filter
from [stackoverflow](https://stackoverflow.com/questions/5713142/green-threads-vs-non-green-threads): Green threads are "user-level threads". They are scheduled by an "ordinary" user-level process, not by the kernel. So they can be used to simulate multi-threading on platforms that don't provide that capability. Green threads were abandoned in the Sun JVM for Linux as of the release of version 1.3 For Solaris, native threads were available from JDK 1.2. That dates back to 1998. I don't even think there ever was a green thread implementation for Windows, but I can't find a reference for that.
Lombok has a [built in](https://projectlombok.org/features/val) `val` type that marks values as final and figures out the type. It's pretty useful :)
Sure, but it will be something that's just used in projects where needed. That's my point. Something like this has already been used for many years, with various designs, in projects that required it, just not with this name. Even some of the terminology, debounce, is from more native electronics projects where unwanted button press events - from the physical button's spring bouncing up and down - are ignored. This is like 1972-level event management. The new thing is the standardized design and the usefulness of that design across very large clusters. The fad is making it a full-project design philosophy, like "everything is XML" was in 2003.
A lot of my personal stuff, both early and current, has been simple programs to automate stuff I don't want to do manually. An early one I took great pleasure in was to prove one of my math teachers wrong... She claimed that we couldn't use calculators to solve a particular type of problem because she wanted to see the answer in fraction form with our work shown, and a calculator would only give us the final answer and in decimal. So I wrote a program on my calculator that solved the problem, and output each step of the way in fraction form. Another early one was a solver for the "computer hacking" in Fallout 3, which was very tedious until I improved that skill. Find things you don't want to do manually, and automate them. It doesn't have to be fancy, and it doesn't have to have a beautiful UI which can be very intimidating when you're new. 
Very nice, have a well deserved upvote!
One of my first programs was a periodic table. You entered the atomic number of an element, and you would receive it's name. This was my first program using arrays.
Think of something you do often, can you automate it? How would you do that. Make this your first major checkpoint. Before then learn the syntax of java and how to execute a program and how to print to the console. Follow any structure of any java guide or text book and learn about that thing and what you can do with it
There is practically no real-world info in that tutorial. Basically just a link to a code example (and related technologies) with no explanation.
Hence why I said I don't understand the JavaDoc. Some type of runtime type inference magic is happening I guess.
The first program I felt proud about was console based and was about visualizing binary trees and allow you to interactively add/remove/search nodes in the tree, everything was text-based but it looked pretty good, even I was surprised I could have coded that application. I wrote this program in C, I wish I still had the source code somewhere =(
Java 9 is EOL sometime this month, so they probably won't. My guess is they'll wait for Java 11 which is LTS and to be released in September.
I can't understand how Java didn't have lambdas and streams. I can't imagine doing what they do without them. Would suck pretty bad. 
Make a lottery simulator using swing Java
Agreed. [This link](http://www.oracle.com/technetwork/java/eol-135779.html) says: "Java SE 9 will be a short term release, and users should immediately transition to the next release (18.3) when available."
Thanks for the detailed explanation. &gt;The move to the Eclipse foundation began shortly after, so moving other specs to be part of Jakarta EE may happen rather differently. I see. Ok waiting for the Jakarta EE transition then.
NetBeans won’t work with Java SE 9. You’ll have to use 8, or get the beta from Apache.
Do you know about Kotlin? It has exactly that :)
 Hello everyone, Jodds author here. Besides the JDateTime (that is just a calculator for astronomical Julian time, but, hey, everyone seems to think that is a replacement for the Joda Time :) I had a good reason why Jodd library was made. Sometimes it's just a significant difference in performances. Sometimes it's a feature not existing in 'mainstream' framework. For example, Spring was not using annotations (in that time). Aspect syntax is ugly. I don't need Hibernate managing relations, I just need mapping to database. I had enough of Http Commons complex syntax. I wanted to parse html as jQuery. At one point Commons BeanUtils had a bug, and they didn't fix it for some time. And so on. Let me repeat: every single time I had a pretty good reason why some library was made. Of course, I am open that my reasons maybe are not good enough. Or that I carried away and went too far. I do not want to convince anyone that Jodd, in general, is good, as I believe it is. Like anything, it probably has some good sides. In the end, it was built mostly by a single person and this is definitely not the best way of doing things. In fact, this thread has put me from the clouds to the ground. And I have to be man enough to admit that you guys are right. Even though there might be good things, I am not able to communicate that neither you see people are using it. And that is fine. Tonight I am going to release the latest version of Jodd, at least in this form. I just want to ask for a favor. Would you be so kind to list the alternatives here for each framework? I just feel responsible to my users to provide the alternative, and your feedback would be very helpful. Thank you and goodbye :)
I have to agree with this. I used Getdown for the first time about 9 months ago for a project since I've grown to hate WebStart and wanted something that felt like a more "normal" update mechanism. Getdown feels a bit like it hasn't had a lot of love in a while, but I must say it's worked really well. I'd love to see the community run with something like this and really make it a great update mechanism.
Sure - if I have a chance, I'll watch them all / try them out this weekend. 
I can't speak with any authority on this. I stopped using java in my personal projects as soon as Kotlin 1.0 went live, and we don't use Lombok at work :x
I have tried JDK 8, and I still get the same result. Or do you mean I'll have to use Java EE or something? 
Writing FP in Java is like trying to build a water pipeline using water bottles and parcel shipping.
The biggest thing about Electron is how much more bloated it seems in terms of running desktop applications. I know Java isn't known for it's amazingly "green" footprint, but When Slack eats up half a gig of RAM for my one work team I think something is wrong. At least if they used JavaFX for this stuff you'd still get a decent cross platform experience where you are only drawing the widgets you need rather than first spinning up a browser and then drawing widgets..
Nice. And since there is now a default method sort() on List, you can even do: personList.sort(comparing(Person::getFirstName); 
10 print [myname] is the best 20 goto 10 Yea I’m old :D
No, it should work with SE 8, not EE. It must be some other issue.
Well it'd be nice to be able to return strings from that construct, that's what I was saying in the first place.. sheesh
Maybe try /r/javahelp 
I'm 40 years old. I've coded professionally in Java, Smalltalk, JS, and Ruby. My first program was written when I was 10, and it was done in Commodore 64 basic. It was a simple input/response program that had specific output for the name that was used as input. So for example, if my mom typed in her name, a personalised msg world get printed for her. These were fun days, and led me to my career. Good luck, mate.
From your terminal what do you see for java -version ? &gt; $ java -version &gt; java version "1.8.0_66" &gt; Java(TM) SE Runtime Environment (build 1.8.0_66-b17) &gt; Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode) What happens if you execute: &gt; $ $ /Applications/NetBeans/NetBeans\ 8.2.app/Contents/MacOS/netbeans --jdkhome `/usr/libexec/java_home -v 1.8` If JDK 8 is installed, your path should be &gt; $ /usr/libexec/java_home -v 1.8 &gt; /Library/Java/JavaVirtualMachines/jdk1.8.0_66.jdk/Contents/Home 
Good. Java 9 introduced new stuff, but also broke a lot of other stuff without giving the world time to gain experience with the fixes and work-arounds (all of which are the new stuff). They ought to have introduced the new stuff in 9, and made the bad stuff emit warnings but still work by default. Java 10 could then make the bad stuff break by default, but continue to work with funky JVM options or the use of the entirely new language features added in 9. Then 11 could remove the funky transition JVM options. Instead, they skipped the compatibility step, and went with "these classes the ivory tower doesn't like but never have caused any warnings before are now broken. Unless you use these new module language features which you've never seen before, and which only a subset of the userbase wanted, and which your enterprise-wide tools don't recognize. Support for the previous way of doing things will be forcibly removed in 5... 4... 3..." 
I got it working perfectly now, but thank you so much! :) Just reinstalled a bunch of times, idk what did it but maybe because I properly removed all jdk stuff through terminal before installing this java version: *java version "1.8.0_161" Java(TM) SE Runtime Environment (build 1.8.0_161-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)* Again thanks! 
&gt; This link Oh. There are two versions lined up Java 10 &amp; 11. Then probably they plan any certification after Java 11. 
I've never used graphQL before, but this looks awesome.
Why don't you tell us what the features are to get the conversation started, since you're the person who created the post?
http://openjdk.java.net/projects/jdk/11/ &gt;JEPs targeted to JDK 11, so far &gt;309: Dynamic Class-File Constants &gt;318: Epsilon: An Arbitrarily Low-Overhead Garbage Collector &gt;320: Remove the Java EE and CORBA Modules &gt;323: Local-Variable Syntax for Lambda Parameters &gt;what is your favorite features in that release I guess 323, but I'm not super hyped about any of those so far. I hope they keep adding more to the list.
I do, but I'm not really a fan of the syntax, which I find very off-putting :c
The features that actually make it into the release aren't determined until three months before it's released.
yeah, it’s 6 month releases starting with Java 10 in March. Whatever features are ready to be released are what get released each update.
Thanks for the answer and i think you are right but don't you think that Electron could be worth for small projects?
323 is useful but not huge. The good news is every 6 months Java will get a little bit better. That will add up very quickly.
This is good development to Java community. We have to catch up with other emerging technologies.
It will be minimal features planned for every release.
Thank you for the response. That's cool!
It should!. Java has a lot more to improve compared with other technologies!
Oracle's Java tutorials are always good for the beginners. If you want to learn the Java fundamentals, it is a good place to start. If you would like to buy a good book, I would recommend to go for OCAJP and OCPJP certification preparation book by Mala Gupta. That gives you good fundamental knowledge on Java programming.
It also includes the Full Parallel collector for G1 GC. Another thing is the refactoring in the GC source code in Hot Spot which will make it easier to plug a custom GC. With ZGC coming up, this would be great.
That's cool. Improvements in GC makes JVM faster.
Wow, this new release train is sure going fast. I still wonder if I should switch to Java 9.
How deep does oracle's tutorial go? For example, I'm currently looking at the Interfaces and Inheritance page of the oracle java tutorial, how deep does it cover these two topics? Is there anything else that I should know about these two topics besides what's covered in the tutorial?
JPMS is still a bit new for me, could you outline what possibilities you have with MethodHandle and VarHandle without needing to open a module?
I've always thought the Oracle tutorials are awful for new developers. They're fine for an experience dev like myself for looking up an API can't quite remember - like how to start up a new thread or the difference in protected vs default (no label) class variables. But like a previous commenter replied, you're much better off with one of the well rated books of you're new to Java and especially if it's your first programming language. 
In this case I think they are both closely related to the fact they make developer's lives easier. I currently have a Spring Boot app with an integration test I can run from my IDE which automatically starts and stops a Docker postgres container. It's amazing.
I understand that Oracle is entitled to license royalties when using Java on embedded and IoT devices. Maybe Java isn't the best tool for the job. That's an argument for another day. But, specifically because of this skim I wouldn't choose Java to run on sensory devices if I were to say write a stream processing application that can predict when something might happen. also, relevant to your question: https://www.youtube.com/watch?v=OMk5KoUIOy4&amp;feature=youtu.be
Video linked by /u/djihe: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Your next JVM: Panama, Valhalla, Metropolis by John Rose](https://youtube.com/watch?v=OMk5KoUIOy4&amp;feature=youtu.be)|Devoxx|2017-04-14|0:50:33|140+ (97%)|8,049 $quote Strap in for a high-speed deep dive into JVM features now... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/djihe ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
If you are looking for very deep knowledge, oracle documents are not good enough. Oracle documents cover fundamental that too with their own style. If you want to know about interfaces, oracle documents are enough. But, if you want to know real examples on how to use those in real time and more explaining on what is the advantage, this is not sufficient. I would recommend you to buy a good book for serious study. 
You could skip it and go to 10. 8 to 9 or 10 is about the same jump.
With Java 10, also following this 6-month release cycle, they continued to add features to the list until at least half-way through the cycle. They only add features that are ready though - so lots of features are being worked on, but exactly which might be ready in time to add to Java 11 is yet to be seen. Personally I'd reallly like to see a list of in-the-works features and maybe even the occasional 'might be in Java X' update on progress. This would only ever be indicative information for a road map though as some features are abandoned (wholly or partially), some are delivered in stages and some simply fall on the unfortunate side of the estimation curve. &amp;nbsp; Regardless I think there'll be more added to Java 11 than the current list and as it has already been said, with a release every six-months, changes will add up quickly. 
The longer I've been in the industry and the more I experience other languages and frameworks like Node, Python, Scala, the more convinced I am that Java is still the gold standard for the majority of dev work. It is far easier to read than Scala and other elegant languages which goes a long way for less experienced devs. It is just safer than dynamic languages like Node and Python. It is fast enough for pretty much everything beyond low level code and games that really do require C. Its tooling (Maven, Ant, etc) is stable and works well, unlike other ecosystems (i.e. Node) where things are constantly changing, often times for little gain. Since Java 8, a lot of the *cool* features of other languages are now included - functional programming, decent aync APIs, try with resources, lambdas. For some of the rough edges, there are plenty of well supported libs like Guava and Apache Commons. Awesome IDE support (IntelliJ) that just can't be matched with dynamic languages. By far the best 3rd party library support - Spring, Jackson, tons of Apache libs, Guava, Hibernate. I'm really excited for Kotlin as its very compatible and easy to mix with Java and really cleans up some of the legacy issues. And of course Closure , Scala, Groovy are all on the JVm and mostly interoperable. The only true competitors to Java I see are Go and C#, but I honestly don't think either has enough momentum nor large advantages to dethrone Java and its ecosystem.
Last time I checked Lombok had hard time running on Java 9 and our codebase is riddled with its annotations. So its Java 8 for me.
Java's seemingly slower pace is on purpose because Java is an *enterprise language*. There are codebases with several million lines that handle business critical applications. Having a fast release/feature cycle can way too easily break such applications and administrators of large organizations would need to constantly update - which is near impossible for the places where Java really shines. Most people only see Java as a consumer language, but that point of view is completely wrong. 99% of Java are used where "normal" people don't get anywhere near. In large corporations and enterprises; on servers in high security areas. Exactly these use cases benefit from the slower pace of Java. Code written for previous versions will run with newer versions without breaking anything. If you want a language with a faster pace, stay away from Java. Java is a stable, mature, well established enterprise grade language with probably the largest ecosystem available. It's not going to become obsolete in the near future. Java also does in no way need to "compete with other programming languages" because it targets an entirely different market.
Very well explained. Yes. Java is for enterprise development. If I have to develop a website for internet, obviously Java is less preferred option. But, if I have to build an app for enterprise customers, Java is the best language. 
Why would a faster release cycle break things? You aren’t forced to upgrade when a new release comes out.
While enterprise applications have considerable backend-functionality the user facing interface are nearly always based on web-technology even if the application is not accessible beyond the company intranet. Workplace software maintenance is a considerable portion of IT work, web applications allow the introduction of new functionality on a set of servers without having to update thousands of work places.
I think it might be a step 0 for value types or better object initializers.
IntelliJ IDEA. I've been using it since it was invented, and it just keeps getting better and better. I could never make head or tail of Eclipse.
RSA b/c i have to (work). At home, i have them all, but somewhat i prefer netbeans (i find them aesthetically pleasing, kill me yea)
I really like Intellij, but I honestly never used Netbeans
return if (something) { "something" } else { " something else" } 
As I wrote on Quora many years ago (https://www.quora.com/What-are-the-best-IDEs-for-Java-programmers/answer/Jordan-Zimmerman): "Moses came down from Mount Sinai and he held aloft two stone tablets and a copy of IntelliJ IDEA."
IntelliJ, but still infuriating is that there's no instant list of errors the IDE has detected without running a build or code analyzer. I miss that from Eclipse. I'm mostly using IntelliJ because of Android Studio.
Another vote for IntelliJ IDEA. Tons of great features and the dark color scheme they use is pure eye candy. I started out using Eclipse, but once I started using IDEA, there was no going back. 
I wonder; maybe this is due to the many things IntelliJ could report?
Eclipse is pretty good,its free and does java really well. I never liked how Intellij handles projects. If you also have to work on javascript visual studio code has a great editor. 
Eclipse because I hate myself
I use NetBeans but I may have to move to IntelliJ if NetBeans aren’t going to keep up support with new Java releases
IntelliJ is really nice for java however i usually use vscode nowadys for javascript
The best part is that you don't have to wear a suit all day anymore.
There are indeed many markers in the margin but a list of them could have filtering/grouping/sorting like Eclipse does.
We're using Eclipse at work. Incredible frustrating at times. I don't think it is meant to work with git. Every time you switch to a release branch it has to rebuild many of our 250+ modules (idk if thats any better with IntelliJ). The installation and update also requires atleast a half-day of effort. Many plugins are broken or not the exact right version and you can't work without plugins effectively. Dark theme is broken and ugly. There are a few good parts though and that are subjectively better than in IntelliJ. Its free, OSGi integration is solid, searching and discovery of classes / types / resources is better, cross-language integration aswell. I c an copy the Eclipse IDE folder onto an USB stick and run it anywhere without installation.
It's easier to adopt by other technology stacks, not necessarily by users. This means that there's probably an effort going on for people to use the whole of JavaFX without needing to be a JVM-based language or relying on the JRE. I figure that as far as deploying desktop applications go, all the developers need to do is add JavaFX as a library to their classpath. Yeah that's a bit more complicated but also standard procedure for as long as programming has existed, pretty much... This little bit of nuisance is probably worth all the benefits that the article and others here already talked about. What worries me is that this hasn't made it clear if Oracle is giving up on JavaFX or not. You wouldn't think they would but considering it was a big investment that never paid off the way they hoped it would, it could just as well be the case and it raises the question of whether JavaFX will be working with Java updates to all OSs in 5, 10 or 20 years from now. It doesn't look good.
https://www.techrepublic.com/article/so-you-want-to-develop-on-a-chromebook/
&gt;We have to catch up with other emerging technologies. &gt;Java has a lot more to improve compared with other technologies! Java as a language is intentionally not a fast moving language. Discussion: https://www.reddit.com/r/java/comments/83di6i/how_do_you_compare_java_with_other_emerging/ Brian Goetz sharing his view about the language: https://youtu.be/qul2B8iPC-o?t=6m28s That is of course not to say, that you shouldn't move forward at all, but it's nice to let others make mistakes first and then cherry-pick the best parts for your own language. If you move too fast, you might end up like C# where you are a feature landfill that no one can read (very subjective and only imo). Was it Hickey or Bob who said, language design is often not about what feature to include, but more importantly, what not to include? 
[Eclipse Che](https://www.eclipse.org/che/) is an IDE that runs on Docker and has a Web-GUI. You can either run your own image or use [CodeEnvy's SaaS](https://www.eclipse.org/che/getting-started/cloud/).
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Guilty as charged. 😉
In my **opinion** it is very bloated. I have written a small app I sold in Electron for a side hustle a couple of years ago so I have done it as well because I was more comfortable with doing HTML/CSS/Javascript than I was with sitting down and learning a desktop oriented framework like JavaFX. What I ended up with was a deployment that rivaled the size of the JVM anf was a very small local crud app. If you feel the tradeoff is worth it then my opinion is a bsd one. In the end we all have to ship stuff. I just worry that if I ship an Electron app my competition may ship something written in Qt that is pretty snappy and uses 3 megs of ram. Maybe it would have been a better tradeoff to take my backend Java devs spend some time with JavaFX combine them with the web designers and you get a cross platform app that runs in 60 megs of ram which is larger, but still smaller than Electron.
We use Eclipse for Java programming. So far this seems to be good enough.
Spring Boot is a Microservices where Docker is a container for running microservices? Docker exists before Spring Boot has been introduced. Infact, Docker's popularity is much more than Spring Boot. I have worked on Spring Boot, love it. 
intellij or bust
i mostly use netbeans for java on linux, and i prefer to do most non-coding work on the command line, eg git, and to a degree even building and running with maven. things i like about netbeans: * handles having dozens of java projects open at the same time seamlessly * core editor is rock solid, eg i have a macro to scroll up 10 lines that's much faster in netbeans than intellij * great maven support and most maven projects generate zero ide-specific files * decent support for other languages (though if i'm doing serious javascript for a few days i use webstorm - the code understanding tools are better than in nb) * i don't use it often, i love the code diff/merge tool when i need it (though i've never compared with intellij on this) tbh, i've never given eclipse an honest try - the couple times i've installed it i've gotten frustrated configuring it and given up. intellij has more bells and whistles than netbeans, but for the core features that i use (basic editor, maven, find usages, navigation, opening maven projects) 99% of the time i find netbeans to be a bit faster / smoother 
It’s one thing I never care about, new releases of maven. Yet I do for most other things.. I really should take a look at any features released in the last while! Pull my dependencies, run my tests and upload to nexus. I don’t care for much else, I wonder what if any I’m missing. 
For me, Gradle build files are much more readable, much more concise (not 4 lines for one dependency declaration) and the console output is nicer.
Have you looked at crouton? It transforms your Chromebook to an Ubuntu machine. From there you can get eclipse
I have but I was just looking for some alternatives to going Linux
I used IntelliJ a lot when I was in school, and I got it for free. But now work has me using Eclipse and I've gotten quite good at it, so I use it at home, too. Added bonus is that you can't get it to work with about a dozen other languages. So yeah, I have become more an Eclipse guy lately. Still prefer PyCharm for python dev.
Linux is awesome, especially Ubuntu. What's your apprehension?
You Can use yml for maven also
I understand your point, i think now i see the things different but of course the technology you use could depend of the situation, thanks for the answers! Have nice day.
Yep no problem. I enjoyed the discussion 
Really? Do you have an example? 
Does that Gradle incremental build feature work in practice?
I've tried out many build tools for Java and other JVM languages - gradle, ant, SBT, kobalt, lein - and time after time I go back to Maven. Yes, it's verbose, but it works. And it works well with all the other tools. And once you've got your build working you rarely need to touch it. 
That's the kind of build tool stability I'm interested in.... when I just care that I'm 3.x and not 3.x.x to make my build work. Hell, 90% of my build would work with 2.x+
You can quote me whenever you want ;)
The project is called polyglot maven, and there is support for multiple build file languages.
I don't think I ever used that. I used the continuous build feature maybe a week ago though and it was pretty nice.
I’m using gradle’s build cache and incremental building together with kotlin, and it works actually surprisingly well.
So I've been using Java for a few years now, but never really worked on anything large enough to use Maven or Gradle. What are they used for? It's similar to automake but for Java Bytecode, right?
The size of your project doesn't really matter. Both are great tools to manage dependencies (so no downloading JAR files and adding to your classpath) - and updating your dependency version is trivial.
C# is well on its way to become the next Perl.
They're the latest reinvention of build systems. And just like all programming languages and all other build systems, some of them are designed to solve a particular problem, others are designed to prove a point. Find a build system that helps *you* solve *your* problems, instead of trying to adopt one because it's convinced you that you have a new problem and it's the best solution. Those build systems will then *become* your *actual* new problem.
They automate compiling and packaging your application or library, basically replacing command line calls to javac and jar. Their killer feature is dependency management, you can specify which other libraries you use and it will download them and make them available. It will also try to resolve dependency conflicts so you only end up with 1 version of a library.
It's not another extention (just another post about the one from a few weeks ago): "public availability of Java SE 8 updates from Oracle has been extended to at least January 2019" 
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/javahelp: General subreddit for helping with **Java** code. --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)
There’s a great one called Linux
Yes, it does. 
I did something similar in the past. I just saved job definitions on the database, and when I started the scheduler, I added a "LoadJobs" job to the scheduler, that started every 5 minutes to get job definitions from the database, and this job was responsible to schedule jobs, remove jobs that were inactive, and so on. 
By save job definitions to the database I'm assuming you mean *not* in the quartz tables but in a separate table/as a separate entity? So this automatic loadjobs job would query your new table and get jobs from there. I'm guessing it also would check which jobs were already in quartz or triggered? Or did you not use the JDBC jobstore at all? That was something else I was thinking might work.
If you want support and security updates and such, yes, you do. 
Because Maven describes my project and Gradle is a Groovy program that builds my project. This is important if you want to inspect your project with another application. In Maven you have to parse an xml file and you get most of the information you will need. In Gradle you have to write a plug-in that runs in your system Gradle to start your projects Gradle. Your plugin has to be compatible with system Gradle, project Grade, and the Gradle plugins you are using in your project. Also Gradle is a lot harder to maintain than Maven imho. Simple things like "How do I assign this value" are deeply difficult to figure out because it depends on if the underlying value is implemented as a map, property, closure, etc. 
The Epilson GC/Disable GC will be very useful for the low latency space
This had been fixed I believe.
Used Eclipse for about 15 years (mylyn and egit rock), then made the switch to Intellij because of ‘their’ ideavim, refactoring and code insights. From within Intellij, I open files in external editors like Vim and Emacs for fast/efficient text editing. Always have those editors open anyway. Emacs is open for at least orgmode + magit and Vim is open for all kind of files. Do not believe there is such a thing as “best IDE”, it is more a combination of tools. For example, I’m using AppCode to write code, but I debug code in XCode. For me the great thing about Vim and Emacs is the freedom to customize really everything. We are all programmers right, so why not extend your editor with your own code?
How do you go about making a mobile app with it?
Maybe it's a matter of time now until java interfaces are actually c++ classes with multiple inheritance.
um i guess. that's not really that bad as far as I can see.
&gt;By save job definitions to the database I'm assuming you mean *not* in the quartz tables but in a separate table/as a separate entity? Yes. I had an interface where operators would save/edit job definitions (class, parameters, cron expression), and those would be save to the database. It was a simple mysql table. &gt; &gt;So this automatic loadjobs job would query your new table and get jobs from there. I'm guessing it also would check which jobs were already in quartz or triggered? Or did you not use the JDBC jobstore at all? That's basically it. The loadjobs job had a reference to the scheduler, so it could add and remove jobs from quartz. The only thing it didn't do was interrupt jobs that were already running (this was not a requirement, and I'm not even sure it was possible) &gt; &gt;That was something else I was thinking might work. Good luck. This worked like a charm for us for many years. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
How much of that changes under Cradle with Kotlin based builds?
I'm sorry, but I don't buy it. There may be valid reasons to prefer Maven over Gradle, but I cannot believe that anyone finds this: &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;24.0-jre&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; easier to read than this: compile "com.google.guava:guava:24.0-jre" Before I'd used either Maven or Gradle I'd spent years working with XML, but had never used Groovy so you'd think I'd have a bias towards preferring Maven's syntax over Gradle's. I used Maven for a couple of years, but despite my familiarity with XML I couldn't stand the awful syntax. I ended up switching to Gradle. I'm not a fan of Groovy's syntax either, to be honest, but it's still leagues better than the verbosity of XML. Again, you might have valid reasons to prefer Maven, but readability is not one of them.
When I look at the XML, I know instantly what the groupid and artifact id and version are. With Gradle, I'm mental parsing for `:` which is a difficult character to parse between `.`s quite often found in group ids. If I used Gradle on a day-to-day basis, I'm sure my mind would get better at it. I'm not trying to convince you that Maven is better/more readable/etc, all I'm saying is my experience is not yours and vice versa.
Could some exaplin why one would use this and in what context? I’m having a hard time understanding where this could be used in practice. (Ps I’m still a fairly new java developer, and sometimes can’t see why/when/how certain things are used). 
It should become easier to write build files with an IDE. I haven't worked much on Kradle yet but it is on my radar and I am excited to work with it. 
I primarily use IntelliJ, but VSCode now has a google doc-like pair programming feature (it's still in early release, but I have used it) and it's a great alternative when working from home or someone else is WFH and you need to collaborate easily. I hope JetBrains has something similar on their roadmap.
NbAndroid had decent support for Gradle based Android projects. If you feel adventures you can is the Maven Android plug-in to make a Maven based Android app. For boring things you can use Java FX and gluon. For really boring things you use Cordova. For hating yourself there is j2me. 
Professionally? If so, I find it hard to believe you've never used Maven/Gradle, what the heck are you building? :P They both do pretty much the same thing: Manage dependencies, plugins and build systems. Used for CI on build servers, too. 
it's mostly for library writers. it enables really deep introspection and manipulation without runtime bytecode manipulation (I think, didn't actually dig into the code). So think things like spring, junit, gradle, and other jvm languages like jython, scala, etc. 
Thanks. I tried JavaFX and Gluon recently, and I'm not a fan of Gluon at all.
It allows you to call atomic operations like compare and set on a variable. All modern CPU provide instructions to atomically compare and set or increment and get values. So it is useful if you want to write multithreaded java without using locks. Before varhandles you could call those operations using sun.misc.Unsafe or through classes in the package java.util.concurrent.atomic. The classes in the package java.util.concurrent.atomic are a little bit slower than calling sun.misc.Unsafe directly. My understanding is that varhandlesshould make the calls faster than the classes in java .util.concurrent.atomic but probably not as fas as calling sun.misc.Unsafe directly.
I dont want to start a flamewar, but can anyone explain to me why would you use maven over gradle? I always use gradle and everything I read about it was that its superior compare to maven. I know ... I'm just curius.
Could be stuck with a large legacy Ant project. Or god\-forbid, something using \`Makefile\`s :\)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
i will be very grateful to help you guys
Code is all open source and includes Java APIs so you can code in just about any language, then plug your work into the blockchain with ease. Check out the code and get started. There is even a Developers Guide included. Official repository: https://bitbucket.org/Jelurida/ardor/src/65dff8f1e782c6db67c66609fc2754546cb61890?at=master Github repository (mirror of the official Bitbucket repository): https://github.com/mrv777/Ardor
None of this was the tools fault.
It looks like in your [submission](https://www.reddit.com/r/java/comments/83me12/help_for_rock_paper_scissors_in_java/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Every project I ever tried building which used Maven - simply compiled. Every project I ever tried building which used Gradle - I had to get the exact Gradle version used by the version I tried building (down to patch number), and even that wasn't always enough. From my own (very personal) experience Maven=just works, while Gradle=headache. 
No
Any pre-release? I want to start codding my new project using Project Loom, don't want to involve myself with callback hell and stuff.
One of the advantages not described very well is that get/set params/returns are sig-poly which means they don't have to build the object array to pass the varargs and don't need boxing in either direction. The compiler inlined the varargs and assumes the response cast is the actual type. 
It's the variable analog to MethodHandle. Provides a more direct API for accessing that has much fewer runtime penalties than reflection. 
I find vscode's static analysis to be better, particular of non-typescript projects. That being said, webstorm is still pretty great.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No, I don't use Java professionally. I'm paid to write JavaScript. Java was one of the first languages I felt comfortable in, though, since I had learned it in college.
Tbh even for hobby projects Maven or Gradle are a no brainier 
Pathetic spam-post. Fuck off.
I think CQRS kind of comes naturally with Event-Sourcing, that's why I tried to link interesting articles that explore that much more in depth. From InfoQ and Eventuate.
I disagree; Java and Kotlin (and probably Lombok) can coexist fine, you can use them in the same project with a simple POM setup. This allows you to slowly move existing classes to Kotlin, preferably POJOs. This lets you get comfortable with Kotlin without immediately having to convert your entire codebase.
I don't know a concrete example, but loosely speaking the DI framework asks a module to look up implementations instead of doing it itself (as far as I understand). Unfortunately there is nearly no information about this topic available. (also not for other DI frameworks).
The Microsoft [article on CQRS](https://msdn.microsoft.com/en-us/library/jj591573.aspx#sec4) does a good job. The problem with a lot of architectural advice is that the answer depends on what you're doing, and examples tend to be contrived for demo purposes. CQRS is good for situations where you need to independently scale reads and writes. Especially these days where it is becoming more common to host read models in non-relational data stores and write models in traditional relational databases. CQRS provides architectural patterns for this kind of thing. I would guess that a good number of applications are probably not going to face scalability problems, and dead simple CRUD will probably be fine.
Thanks for mentioning Oomph, looks really useful. 
When I pull up the intellij 'about' dialog, it's a jumbled unreadable mess for this very reason. :(
+1 for its elegance and smart reference!
&gt;by removing some of the strict type safety. In Java 10 the language is not going to be as strict about type safety when working with local variables I feel like this is a bit misleading. No type safety is being removed. Everything will be as statically type safe as ever, but for local variables with initializers, the compiler will infer the type (and complain if you use it wrongly later). 
Java has always had multiple-inheritance. Of types; that's what interfaces allow us to do, implement many types for one class. Default and static methods in interfaces add multiple-inheritance of behaviour. Yes, this is a bit controversial but it is the only way to easily solve the problem of maintaining backwards compatibility while allowing existing interfaces to have new methods added. What's not in Java (and likely never will be) is multiple inheritance of state. 
Why isn't a free hackathon for a blockchain based in Java a legit thing to post? I am a community member who believes in the tech and we need to get word out about it so I posted across 2-3 relevant subreddits witht he announcement. If you don't want to participate, that's fine but I fail to see how it is spam. 
It's not just misleading; it's outright wrong.
It's a shame that it's an in-place sort, as it means you can't sort an immutable collection. 
Some people think that Blockchain is so hyped that it starts being harmful to the tech society. A lot of time and money is wasted on start-ups and projects that only exist because they have 'blockchain' in their name despite their obvious lack of technical sustainability. Advertising a hyped buzzword tech to young developers who don't have the experience to differentiate between hype and actual potential is like selling young kids cigarettes and telling them they should start smoking because it us cool and everyone else is doing it too.
Java 3,628,800? I must have been asleep a lot longer than I thought. 
I completely agree that the blockchain stuff has been crazy and overblown. Most blockchain projects have nothing to show for it - just like you said. They mention the word and mislead people. I would kindly ask you to familiarize yourself with the particular blockchain technology I posted here. This is owned by a private company, registered in the Netherlands, who were just the ONLY blockchain finalist at 4YFN startup competition at Mobile World Congress. They had a live platform called NXT for 5 years (the first proof of stake so no more energy intensive "mining") - and now Ardor is the version 2.0 to bring it to businesses which went live on January 1. 
&gt; If I have to develop a website for internet, obviously Java is less preferred option. That's what most enterprise software is though; a web or mobile application for internet/intranet. 
That's not "functional style": it's just someone not understanding collections. They would probably have made the same mistake with a procedural approach. 
Because it has nothing to with Java. Java is a coincidence for this particular coolaid occurrence. Legit or not as a tech it's spam. The others have explained it in detail already.
&gt; I would kindly ask you to familiarize yourself with the particular blockchain technology I posted here. I'm not criticizing the blockchain technology itself. There are really nice developments and new ideas in this field. But I do doubt the usefulness and significance of blockchain technology outside of crypto currency and perhaps some very narrow special fields. I think this tech is sold to people not knowing enough about it to confidently make an informed decision and the "everyone else is using it" peer-pressure is way to high. It's also self-enforcing. The only argument I ever her is "X is using blockchain for Y. We should try using it for Z too.". This hype is burning lots of time, money and in some years will end some careers and kill a lot of companies, I'd bet. &gt; This is owned by a private company [..] who were just the ONLY blockchain finalist at 4YFN startup competition at Mobile World Congress. Investors in start-ups have an interest in keeping the hype alive and inflate the bubble they have invested in. Winning a money-grab competition is not really an indicator for technical significance. To use the tobacco analogy again: That company was a finalist in a 'smoothest taste' competition sponsored by big tobacco. And they lost against an e-zig (being a finalist is not winning). &gt; They had a live platform called NXT for 5 years. [...] From nearly a year of research, this is one of the only blockchain platforms I consider to be legit. Again, it's not the blockchain per se I am sceptically of, but its usefulness for the use cases it is often sold for, or the sheer lack of use cases. Are there any companies using blockchain for profit (excluding investment money)? Why do they actually need blockchain and could not do the same with a plain old database? Which problems did they encounter any how do they solve them using a blockchain? These are the questions I actually want to hear and answer for, but strangely this is never covered on the shiny websites or in the press releases. 
seem like you wrote nice article like thousand other articles in web also without example. I think that 70% of 'java' blogger never implemented this in real life. 
Jesus that code base is structured so messily. 
I heard a story about a developer that slowly increased a System.wait() loop in a deprecated library to encourage users to upgrade to the newer version. Can't find the link now though.
You are right, my intention here was to give people enough background to explore the topic further, hence the ‘simple explanation’. Thanks for the feedback.
&gt; Everything will be as statically type safe as ever, but for local variables with initializers, the compiler will infer the type (and complain if you use it wrongly later). I used to work with a codebase using var absolutely everywhere in C#(we used Stylecop). Ok, it make refactoring easier when changing the type of a field(rare occurrence) and copy/paste is get even easier for redundant code, but the ide went slower since it had to infer everything. Also, the debugging can be more tedious on specific use case. Bottom line, I wouldn't recommend to use the var feature everywhere, despite you work on a small codebase... doing this kind of stuff is probably why the author talk this particular issue. 
Nope, just another new versioning system. It was Java 18.3 then it was Java 10, now it's Java 3628800, actually I've heard rumours it's getting renamed to Java -π/4.
I remember years ago that the general consensus was to avoid using multiple concatenation operators in favor of StringBuffer for performance reasons. Is this still valid? You can change the code style in the dialog box to get different methods of building the string. I used the String Format recently on a project and I liked the result.
I'm one of the developers of the Ardor project, coding in Java for almost 20 years, building various enterprise software. Can you explain why you consider this code of one of the leading blockchain projects which is already in production for more than 4 years in hacker infested territory and represents a set of tokens valued at around $500M a "structured so messily"?
2016?
I do not want to come across as spamming or condescending, so I will keep this short and end with 2 examples of use cases on this platform. The key difference between blockchain and a central database is the fact information is immutable. It can't be undone, changed, hacked, etc. Using it just for money is silly, I agree - that use case is limited. But there are major use cases for this technology. 2 examples of how this particular tech is being used are: NXT private ledger and Cash Without Borders Project at BNP Paribas: http://www.revue-banque.fr/banque-investissement-marches-gestion-actifs/article/il-faut-deceler-les-cas-usage-les-plus-pertinen Ardor voting modules, which can be used in board rooms/municipal elections/etc. being demoed at Accenture (back before the full launch on January 1 2018): https://youtu.be/lZZWKzAO3ik 
"how to start up a new thread or the difference in protected vs default (no label) class variables." wow! Then i should be kind of super senior dev. I tihnk Oracle have most simple and easy tutorials. 
Every one have the right to their own opinion but in a community like this, you will need to make your statement constructive and not insulting. Lets be civil here please. More so, I see no reason this post is considered such. This is a first of its kind and a big step in shaping the future of Blockchain. If there is anything you do not understand, feel free to ask and of course in a civil way. Thank you.
In particular, the compiler will almost certainly create a new StringBuilder for each iteration of the loop, while you are smart enough to use the same StringBuilder. I wouldn't be surprised if this was not something that the compiler could figure out itself though, so maybe that advice will change too at some point.
Criticism is good for developments but needs to be constructive and backed up with points. If you can specify or explained further on why you feel the code base is structured "So messily" it will be appreciated. Otherwise, this will be considered another antagonizing statement for no reason by an opposition which I hope its not.
It is a bit dated, but there are not that much of theses benchmarks available ... There is some [newer benchmark](https://github.com/akarnokd/akarnokd-misc/issues/5), but it is not as comprehensive as the one linked above.
I am sorry, but I don't think the link is comprehensive. If you don't know what RxJava or Reactor are you don't understand anything 
/r/javahelp is more suitable for these types of questions What fits best as the 'server' component depends a lot on what type of game it is. Can you (preferably on that sub) explain a bit more about what you're trying to do?
I'd honestly recommend an actual networking library such as Netty or Vert.x - Spring is for more web based application, if your game worked in a browser, great use spring or if you're going to use http for networking then go for it. 
Oracle's tutorials rarely give practical examples. They seem like they're written by really smart academics who aren't able to empathize with a general dev who is looking for a StackExchange solution of the necessary code to paste. BTW, the reason I can't remember the seemingly simple things like threads and protected vars is because it has been so long since I actually read a *beginning in Java* type academic book, and a lot of these simple things just aren't used much. In practice, class variables are 90% of the time private with bean methods due to all the frameworks expecting that. The only time I used package scoped vars or methods is when I need a unit test to obtain a private var. And threads - nobody uses the original thread / runnable model since Java 8 lambdas. Not to mention I jump in between Scala, Python, Javascript, perl, shell, and about 10 devops frameworks throughout the day - all with subtle differences in syntax and semantics. Hard to keep track of everything :) 
It's a native DB that stores Java objects (@Entity) without SQL/ORM overhead.
I'm saying that as a framework javafx is incomplete and really only has primitive components. There doesn't appear to be third party extensions readily available. What is available is about a half step up from what is in HTML and CSS today.
The big watershed question is how do you want this game to work? 1. The players must each have some local software which connects over the network to either a central server, or to other players. 2. The payers simply use a web browser to connect to a central web server. The game is played in the browser. If 2 is the answer, then you definitely need to learn web development. There are many choices. For an interactive game, it seems inescapable that you would need to learn JavaScript (or other language that executes in the web browser) and how to program the web browser to do interactive things. Either by manipulating the DOM, or using SVG, or drawing pixels into a Canvas. For any new development I would absolutely avoid Java Applets. While they are appealing if you already know Java, the whole idea of browser plugins (Applets, ActiveX, Flash, Silverlight) are going away. A technology family whose time has passed.
That's a good question about Software Architecture. I'm developing a game like this too and I'm implementing using Spring, JavaScript and all the logic in Java. I recommend you to read the GoF book about Design Patterns and some Udemy courses about game development. And on the internet, there are plenty of articles about that.
You sound a bit sceptical in general about new technical innovations. There are loads of use-cases for blockchain tech, but you might want to educate yourself a bit. Peer-to-peer networks are working successfully for over 15 years and blockchain is not that different. Even in nature you can observe this kind of information sharing. It might be the more natural solution than a centralized database. The company, that produced above mentioned code, is there to lower the entrybarrier for companies. They built a framework, that allows simple and fast integration of a customized blockchain for specific applications. No company will choose this approach, if a conventional database was more efficient, just because there might be some hype about blockchain. Moreover Jelurida is not dependant on the actual value of their coins. They earn money by building solutions, that are asked for. 
Java is the COBOL of the 21st century. And for the same reason. It's mature. Stable. But mostly, there is a huge number of huge applications written in Java. It would take years, maybe decades to rewrite them all. And for no immediate obvious benefit or reason. The sheer economic value of the corporate codebases in Java is enormous. There is no reason to change from Java (or from the JVM even if you add new languages) because the platform is stable, mature and industrial-strength. Call me when your Python or Node.js garbage collector can handle terabytes of memory with GC cycles under 100 ms. 
Even modern mental health care has great difficulty helping people to achieve complete recovery from having programmed in Perl.
Assuming you are doing short lived apps. Such as AWS lambda.
If suggest building with 9/10 today even if you want to jump to 11. 8-&gt;11 stinks.
C# for a while now has been playing the game of "oh you want that feature? DONE!". To the point of maybe being a bit reckless. I mean, out variables with tuples in the same release? The language is quite complex at this point. Java has been the polar opposite. "You want lambdas? We'll think about it". It's to the point where even C++ is grabbing features faster.
Enterprise websites are much different than common websites that built for high amount of traffic.
You may enjoy this article: https://www.oreilly.com/ideas/handling-dependency-injection-using-java9-modularity (I'm one of the co-authors of [Java 9 Modularity](https://javamodularity.com), which also contains an in-depth discussion of Java modules and DI)
No, equities trading actually
I'm a little surprised HFT systems would be written in Java and not c/c++/Rust/D. Are you interested in ZGC and Shenandoah? And what are the plans when you run out of memory? Restart the app? Have you carved away a custom runnable?
&gt; The key difference between blockchain and a central database is the fact information is immutable. It can't be undone, changed, hacked, etc. I disagree: The unique selling point of blockchain technology is not immutability, but decentralized consensus. You can store cryptographically signed payload in a (distributed) database and get most of the features of a blockchain easily. Any git repository would be a blockchain if you define it that way. Decentralized consensus is the hard problem that blockchains actually try to solve. I have the feeling that lots of people do not understand that, or underestimate how hard this problem actually is. And this is exactly what I'm talking about: If you have a use-case with only a small number of participants, or any need of central control, then blockchain is the wrong technology. In most other cases, a blockchain might work but it's hard to get it secure and scalable at the same time while keeping its benefits. Good use-cases for blockchain are very hard to find outside of crypto currencies. &gt; But there are major use cases for this technology. 2 examples of how this particular tech is being used are I do not understand French, but the first one looks like a crypto currency project (a very good use-case for blockchain, I'm not denying that) and the second one (voting) does not really need or support decentralized consensus. It might actually be really dangerous to allow forks of the blockchain in a voting system. Finding a proof-of-work concept that is easy to do for valid citizens but hard to fake for a government might be tricky, too. 
&gt; There are loads of use-cases for blockchain tech, but you might want to educate yourself a bit. I did, and I could not find any convincing use-cases outside of crypto currencies or very similar topics. &gt; Peer-to-peer networks are working successfully for over 15 years and blockchain is not that different. Exactly. So why use blockchain if other technologies might be better suited for the job? This is what I'm criticizing: Using blockchain just because it's hip or gets funded, not because it is the best choice for a specific problem. &gt; No company will choose this approach, if a conventional database was more efficient, just because there might be some hype about blockchain. I disagree. A lot of highly funded start-ups and research projects are doing exactly this. &gt; Moreover Jelurida is not dependant on the actual value of their coins. They earn money by building solutions, that are asked for. I'm not criticizing this company, its tech or its business model.
I'm confused about what exactly 323 gives you. Why would it be beneficial to do (var x, var y) -&gt; x.operation(y) over just (x, y) -&gt; x.operation(y)? I thought the whole reason people wanted var was to type less characters, so wouldn't not typing a keyword at all be better?
I agree Java applications to face large traffic. I have worked on Java for a decade. We have developed a web application using JSF, Spring. But, however, I felt Java applications are not giving good performance. I am not sure if I am right or wrong. That's my opinion. But with other languages like PHP, it's easy to achieve. 
Apart from what others have said: Very large commits with meaningless messages make it hard to audit/review changes from the outside and easy to slip in malicious bugs/backdoors, which is bad practice or security related open source software. 
&gt; I did, and I could not find any convincing use-cases outside of crypto currencies or very similar topics. The blockchain guarantees the integrity of the system. In bitcoin it prevents double spending, but more broadly viewed it maintaines data consistancy in a P2P network. Let's think about copyright applications, where you need a publicly editable and accessible database, that can't be tempered with. The Ardor-platform or Nxt, what it is based on, was the first to implement Proof-of-Stake (PoS), instead of Proof-of-Work. This eliminates the need of massive computational ressources to provide security. The Ardor-platform also solves scalibility issues through it's parent-childchain architecture, since the parent chain is responsible to secure all childchains and a huge amount of data in every childchain can be pruned. 
Tanks! Actually the little text box on page 121 of this book raised the question :-)
&gt; if you aren't sure you need it, then don't use it. And they are right.
Good for unit testing? 
It's not about me, it's about what the team decides. I don't like the idea of a Frankenstein application with multiple languages in the mix. 
No, Java was doing just fine in 7. Nothing in 8 or later really helps Java. There's nothing to catch up to, Java was and remains the leader. Rapid fire updates are going to screw up Java like it screwed up Firefox until they pulled their collective heads out of their arses and went back to a sane update schedule.
&gt; Many programmers here (myself included), are working on existing large scale Java applications and Lombok is extremely convenient. Yes to the first part and no to the second part. Lombok just adds unnecessary complexity and a lot of flakiness.
I don't see the advantage of including Docker client support in Spring? Is it for places that want to build a custom orchestration application? Why do that instead of just using standard Docker orchestration tools like Kubernetes or Docker Swarm? It would quickly become technical debt with no or little manifest ROI.
Eclipse 99% of the time, IntelliJ rarely.
If religious blasphemy is integral to your rationalization process then your opinion is rendered irrelevant.
I love it so much that whenever I'm learning/working in another language I default to using one of IntelliJ's IDEs. 
What? Java 8 was one of the best things to happen to Java in a long time.
Definitely interested in those pauseless GCs once they're widely available. Currently the system is painstakingly architected to avoid needing any GC at all, but it would be nice if that was not necessary.
C++ is really bad at this recently. It's now becoming difficult to develop in for a whole different reason as the language itself has become extremely convoluted. So much new crazily intricate syntax keeps getting added.
Ha, fair enough ;) Hope the post addresses some of your questions!
Don't you already have that though? We've been gradually converting all our test cases over to Kotlin and writing new ones in it. Took some time initially to lay the groundwork, but in general I think developers like the change and are keen to do more.
The article mentions a needlessly complicated way to get the DPI when using Swing/AWT. This is much easier and has always worked for me: int dpi = Toolkit.getDefaultToolkit().getScreenResolution(); Maybe there is some benefit to the more complicated way the author did things?
The scala problem in many ways. Feature density and configurability negatively impacting maintainability. It does make me more appreciative of how much java has fought against adding new syntax extensions to the language.
GalliumOS is a fantastic solution for most Chromebooks. It's Ubuntu specifically built to be compatible with most models.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The licence is a maze of twisty tunnels, some of which are pretty snoopy. What's the business model?
The compiler looks at removeIf, sees it wants a Predicate&lt;? super UserAccountInfo&gt;. Predicate is an interface with a single method with missing implementation (single abstract method), so decides that the isHiddenMethod on UserAccountDto can provide that missing impl, if the UserAccountDto is considered the first and only argument. Ie. UserAccountDto::isHidden stands for dto -&gt; dto.isHidden(). That matches the signature of the abstract method of Predicate, so the compiler can make a nameless Predicate impl from this and we're done.
I don't believe Windows implemented it either, I think Solaris did. 
I am very disappointed that they didn't decide on `val` instead of `var` as a way to get a `final` type-inferred variable. While mutation has been a key in the history of Java, it hasn't served any codebase I've been in any good. I believe this was a good chance to make a push towards immutable-first (at least for references) like so many languages do today. 
to further make the difference between interfaces and abstract classes pointless.
A tiny hard coded web server in 1995. I told my boss, this new Java language is going to be hot. It took a lot of pain out of TCP/IP socket handling. The original 1.0 packages: http://web.mit.edu/java_v1.0.2/www/javadoc/packages.html 
Agreed. This is exciting, but the license made me take pause. 
Where do you read that from? Of course those usages are allowed. Nobody will get sued.
I have generally assumed that the HM style is better, and that the Array[] style is just simpler for discursive needs (demonstrating in a video presentation). One issue I have come across is trying to make any functional comparison. Given a JVM, I cannot find a meaningful way to make any actual comparison of memory. Would you agree that trying to have a "bake-off" between methods is not substantially meaningful?
Your solution to having a verbose language is to write a wrapper for everything? 
looking forward to using some of the other complicated object structure comparisons. doesn't JUnit now support `assertThat` mixed with Hamcrest matchers?
You could do the same thing before Docker came along. Especially for Java application which are self-contained this was already possible with the tomcat/jetty plugins.
yes was absolutely referring to `isEqualToComparingFieldByField`, that seems awesome and I want to check that out when I go into work tomorrow! 
Awesome, glad I showed you something new and applicable to what you are doing! 
&gt;* Java3D &gt;* JOGL Java-based alternatives are available. &gt;* Java Desktop Integration Mostly merged into Java 6. &gt;* Java Media Framework Does `javafx.scene.media` suit your needs?
Have you tried Java on VSCode? If yes, what do you think? If not, what is missing for that to happen?
Have you tried Java on VS Code? 
Lol
Post in r/domyhomework
This is more philosophical 
Yeah I use var in C# (with VS and ReSharper) for complex types (usually templated) that would be a pain in the ass to write out. I never noticed it making VS slower, but I agree that it's good to use sparingly. 
In that case post in r/domyphilosphyhomework
is there a subject reddit does not have a community for
There are already libraries that are less verbose than that. And if you want one exactly as you describe you can write your own and share it, languages are powered by their communities. But I certainly won't be using JavaScript hahaha.
https://www.callicoder.com/assets/images/post/large/spring-boot-spring-security-jwt-mysql-react-full-stack-polling-app.png
JUnit does support Hamcrest's, however Hamcrest suffers from some unfortunate choices of generic parameters on some matchers--particularly for list element matchers. Some matchers are virtually unusable as a result. AssertJ got their generics right by only accepting a single generic parameter, and returning a matcher over that parameter, resulting in zero type ambiguity. AssertJ's fluent method chaining style and exception matching (via `assertThatThrownBy(Callable)`) are also loads more readable than Hamcrest.
No have not tried it I think intellij or even eclipse is better for Java. You get a lot of help with auto imports and autocomplete in those
On GitHub, there's an ASL 2.0 license. Does it not apply?
You can't use it everywhere--only on local variables, where inference should be trivially easy for the IDE. It's a shame the post doesn't mention that it's for local variables only. 
I've just kicked the "competitive analysis" part (and hey I'm just the tech guy). I did not even know it was in there (that's how serious we are about this license). Again, we were never happy this that license, and will replace it once we find a better license/lawyer. One important thing: this license is about the native lib of ObjectBox, which you will never touch directly. The Java API thing you touch is [open source under Apache 2](https://github.com/objectbox/objectbox-java/). Again, once we have the time for that legal stuff, we will replace that nonsense thingy.
Who said anything about Spring? The article is just talking about the Docker Java library.
There's only one sensible answer and it's Kubernetes.
Yep, I've had some trouble with Hamcrest and struggling to get types to work correctly.
Yes, yes, somebody has to spent time on it... We just preferred to prioritize development and hiring. Nobody cared about that license anyway so far, and thus it was not a priority to get it fixed. We've learnt and will reconsider and make it more approachable soon. Please, there's nothing in the current license that could harm you unless you decompile the native library (C/C++) to make a competitive product. Don't let that legal nonsense hold you back. We will fix it. Promise.
I was not. Thanks! 
I understand your viewpoint, I would use Kotlin POJO conversion as a stepping stone, but if you don't intend to use it for more complex handling, it might not be worth the jump.
&gt; Maybe it is worth researching Nxt/Ardor before stating about "messy" code. You can research anything you want but that does not change the fact that it's one big monster repo with a lot of different sub projects in it. It should have been split into it's components. If I want to use it as a library why would I want to have a bunch of client application code for example? Secondly; if you want people to contribute having a single self-contained well documented and well tested project that follows general conventions is important. The project is none of that; like I said it doesn't even use Maven or Gradle, API documentation is spare at best and test coverage is barely present. 
 &gt; How do I find the "pain-point" where simply allocating enough memory for ALL possible ns, becomes cumbersome relative to using a more-memory-intensive data-structure? If you have to ask this question, there is a 99.999% chance that you don't need it. Is it going to run on a server? Use a HashMap. Is it going to run on a desktop? Use a HashMap. Do you have specialized needs which require fine-tuned memory and CPU utilization (just in case: In most cases, you don't), then profile the application with different settings. If this question is of academic nature, the best way is to profile it to find out which options do perform better. You could *calculate* the memory usage of the HashMap and the array by hand, but it is quite cumbersome and error prone, also it might differ between JVMs.
What are you trying to do? Maybe we can suggest a better alternative over what you're trying to achieve.
`val` doesn't do much for you if the values/objects your binding are still _mutable_ themselves. I look forward to using this along side something like [vavr](http://www.vavr.io/).
I use both of AssertJ and Spock in different projects and while AssertJ is nicer than Hamcrest, it still is not as concise and elegant as Spock. From the blog: assertAll( () -&gt; assertThat(repoCustomer.getFirstName()).isEqualTo("Princess"), () -&gt; assertThat(repoCustomer.getLastName()).isEqualTo("Caroline"), () -&gt; assertThat(repoCustomer.getMiddleName()).isEuqalTo("Cat"), () -&gt; assertThat(repoCustomer.getId() &gt; 0L).isTrue(), () -&gt; assertThat(repoCustomer.getDateOfLastStay()).isNull(), () -&gt; assertThat(repoCustomer.getSuffix()).isNull() ) In Spock: then: repoCustomer.firstName == "Princess" repoCustomer.lastName == "Caroline" repoCustomer.middleName == "Cat" repoCustomer.id &gt; 0L repoCustomer.dateofLastStay == null repoCustomer.suffix == null 
yep, not ready. The tooling doesn't compare to either intellij or eclipse.
There's absolutely no reason why a Java API couldn't do the same, the more verbose builder you show would be far more useful in scenarios where you need to specify HTTP request headers, customise/control timeouts. Forcing you to pass in a `URI` rather than an arbitrary `String` is a stylistic choice, it does provide a typed contract around what's accepted, which could be useful if you were also using URI Template's - having a contract of something like a `processTemplate` method that goes `String-&gt;Map-&gt;URI` would work well with that. That could lead to something using `CompleatableFuture` (and Java 10) like: ``` var result = HttpRequest.fetch(UriTemplate.process("https://postman-echo.com/get{?name}", values)) .orTimeOut(1, TimeUnit.MINUTES) .thenApply(res -&gt; res.getBodyAsString()) .get(); ``` ( and yes, you really do want to handle timeouts, you don't just leave things hanging around forever now do you? ). 
Slides are in English, if you know Russian - there is a video as well https://www.youtube.com/watch?v=hUqN4-MzK2U&amp;feature=youtu.be&amp;list=PLLDLomdYBk9YDu5EbnVVbXqj7Tqty4YWQ 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://ant.apache.org/) - Previous text "Ant" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
It's still used by some projects at my company :/
Commit size is not a good measurement of anything. There can be simple code change which touch many files. The way to protect against back doors is code review and we don't accept any contribution without extensive code review.
We have extensive API documentation in our Wiki https://nxtwiki.org/wiki/Main_Page
lol I did the same thing
Guys! Just to clarify, Ant here is **not** the build system. It's [Ant Design](https://ant.design/), A UI design language based on React.
Yeah, I find gradle "above the hood" (i.e groovy) too flexible for a build system. I'd like to see a more reactive/event based build scripting.
Actually, this is what I'm trying to do. The project is incidental (basically a practice problem). The idea is to start with a brute-force O(n^2)-Time; O(1)-Space solution and to improve it. One approach is to use a cache—trading some Space complexity to ease the Time complexity. I chose a HashMap, since I couldn't really know how many items I would need to cache. The solution offered used an Array with the maximum number of possible elements. I was looking for some way to compare those two solutions (using various input scenarios). e.g. Given n=2, the Array solution is superior. It is simpler, less code, less work and the allotted space is incidental. However, given n=Integer.MAX_VALUE, the HM approach is FAR superior, since the best case might require only 4 items to be cached, and the worst case would be a few thousand. 
One question I would ask: &gt;Do you have specialized needs which require fine-tuned memory and CPU utilization (just in case: In most cases, you don't), then profile the application with different settings. I have profiled code for Time complexity, but never for Space. I recognize the pitfalls, but in this case I feel it is something I would like more granularity for. Is there "standard" approach when trying to do this type of profile? I recognize the JVM and other issues come up, but so long as I'm comparing Apples-to-Apples, it might be worth it for me. 
&gt; I just wish Groovy was a pervasively type inferring concise statically typed language. Kotlin? 
&gt; I just wish Groovy was a pervasively type inferring concise statically typed language. Kotlin? 
Can you explain a little more? What type of items are you caching? What is the brute force for? Are you just trying to a lookup? 
Packages are signed by their respective developers. We don't want the users of the code to trust each individual dependency developer. Probably there is some workaround like we to sign the dependencies, but that's more trouble than benefit. The most secure approach would be to include the sources of the dependencies in the package and compile them together with the sources. That's the opposite to what you want. Also with maven we depend on the maven protocol for distribution. So if maven central is down, we must use some other maven repo, we cannot e.g. use torrent to distribute the package. 
&gt; Also with maven we depend on the maven protocol for distribution. So if maven central is down, we must use some other maven repo, we cannot e.g. use torrent to distribute the package. Sure you can. That's what the maven assembly plugin is for. Just let maven build your distribution tar/zip with all dependencies included and upload it to s3/torrent/whatever.
Really need to take a gander at how you handled the JWT/security part. Have an application that's been giving me some weird 401s after my upgrade to Spring Boot 2. Mind If I shoot you a few questions after that, op? 
&gt; There can be simple code change which touch many files. Sure, but you are squashing your (smaller) internal commits into a single, large release commit and intentionally hiding your internal development process. Why? The only reason I can think of is that you are afraid of others reading your commit messages or noticing your fuck-ups. Or you want to prevent forks, because these large commits make it really hard to keep a fork up to date. This is not open source development. You just release your sources. Big difference in my opinion.
I agree. It's something new we do. I'll check why.
&gt; but it’s so much more flexible That's the problem with it. I want something that my IDE can reason about. &gt; and it’s what Gradle uses under the hood anyway. WUT? 
The `ant` object is available by default in Gradle, and you can entirely use Gradle as a better Ant syntax engine, if you want. This is sort of an accident, because the base AntBuilder itself is packaged with Groovy. Gradle also packages its own Gradle-y extensions of basically the entire Ant subsystem so that data can be passed back and forth transparently. Some plugins [lean on Ant entirely](https://github.com/gradle/gradle/blob/master/subprojects/language-groovy/src/main/java/org/gradle/api/tasks/javadoc/Groovydoc.java) to do their thing, though. &gt; That's the problem with it. I want something that my IDE can reason about. That's *your* problem with it. I have no such problem. :) How do you use your IDE to help you with Gradle or Maven?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It's actually a series of problems, but I can offer an example. Imagine I have three types of containers: 10oz., 6oz., and 1oz. Given n ounces of fluid, I want to find the minimum numbers of containers to handle that fluid, AND each final container MUST be full to capacity. This type of problem is often solved using a greedy algorithm, but if I start with 24oz., the greedy approach yields 6 containers (10 x 2 + 1 x 4) while the minimum is 4 (6 x 4). There is a recursive solution (as well as others), but the time complexity gets out-of-hand. That can be mitigated by using a cache. Rather than calculating each subproblem, the results of any given function call can be stored, and retrieve for any successive call. Consider a recursive fibonacci solution. fib(n) = fib(n-1) + fib(n-2). If n=10, fib(5) is called multiple times. Caching the result means fib(5) need only be called once. As I mentioned upthread, this is "academic" in nature.
Sorry but it *still* looks awful. Black arrows on a dark theme? Only partly themed (i.e. no scroll bar theme), etc. 
Having the ability to run ant tasks is not the same thing as "what Gradle uses under the hood". Maven can run ant tasks (although arguably the resulting pom.xml would be worse than just having a build.xml). You can compile Java code without using any Ant. &gt; How do you use your IDE to help you with Gradle or Maven? You have it the wrong way around. It's how I use Gradle or Maven to help me with my IDE. Maven or Gradle is my IDE project. I import a project and my IDE knows exactly how to build it. 
Thanks for this! I am going to read it a couple of more times...
Commence Eclipse vs IntelliJ flamewar, 3...2...1...
Sure! Would be happy to help. 
You shouldnt have to rely on a third party library for something as simple as sending http requests 
Eclipse has been TLTL for a decade now. It’s practically an institution of Haters Gonna Hate at this point.
What's a better alternative? 
Intellij if you can afford the license. Tue community edition is good if you do vanilla java, but as soon there is spring, js html, etc involved you're better off with eclipse. 
IntelliJ. When Eclipse started to piss me off (Juno release) I decided to give it a shot and opened the wallet. This was 2013, and I'm still a subscriber...
But can you change the color of the scrollbar?
Bounce between both for various projects. Find intellij inconsistent in it's menu and abstractions. On eclipse side, grade/maven/ivy support blows ass. HiDPI blows on both. Anything not Java I have been turning to Visual Studio Code
&gt; In fact, in that previous interview, they used an Array[Integer.MAX_VALUE] as a type of cache. \*cringe\* Ohkay...my first question when hearing this would be "Why?" and let them explain to me why they need that. Because there is obviously much more at work than the simple question they've asked. Then I'd simply brainstorm ideas on how to do it differently based on that...but at this point I have to say I have been lucky and were in very, very interviews throughout my time. And yes, "I'd profile that" is, in my opinion, a valid answer. Though, I can't speak for the interviewer.
How cares.... I use NetBeans 😂
&gt; Is there "standard" approach when trying to do this type of profile? Get out your favorite profiler (VisualVM, for example, or JProfiler) and come up with a case you can test. From there, do iterations and see how it changes. There really is not more to this, you need a use-case, you need a working code sample and a profiler, and then you make your way from there. Also, when somebody tells you "just create an array with Integer.MAX_VALUEs", I'd question whether this really needs to hold 2 billion entries. I mean, it *can* be the best solution, but as I said before, it is highly unlikely that you will be working on something that actually has such a requirement (and if you do, I pray for your sanity that there are others who know all this inside and out and can directly advise you on it).
Thanks for making my point that the original ones were abandoned, forcing us to look for alternatives.
In general I find Martin's "Clean Code" philosophy to be anything but clean. 
This is great that you are reviewing books. But, personally I don't see how this review will help anyone... As said the book is already in any list possible.. Fact you didn't have any disagreements or opposite opinions to what presented in the book makes me a bit suspicious about the review (in terms of how judgmental you were when reading the book). Anyhow, good job and thanks
For the examples you've provided it would be best to just do the calculation each time. We'll use this fibonacci one as an example for now: Let's say you do fib(5) very often and want to cache this, sure you can store it into an array or a map whatever then do a lookup. Your problem is that, if you have a million records in your cache, the lookup process can take a long time? So the question is that, what's a time effective lookup algorithm you can use with your cache? Google around, find some benchmarks on search/lookup algos. In experience, if you had a cache that's Integer.MAX_VALUE in size - it will take flipping ages even in O(n)
With the darkest dark theme plugin you can
Except the beta for Netbeans v9 is out. 
A more detailed, less-enthused [review](http://binstock.blogspot.com/2008/11/bob-martins-clean-code-reviewed.html) by one of the Jolt Award judges.
Unless you install a plugin, Eclipse still uses the OS scrollbars.
&gt; Intellij if you can afford the license Any professional developer should be able to afford an IntelliJ license, if not you are seriously underpaid. 
fetch isn't a third party library. it's part of JavaScript
I use Ctrl-Alt a lot in IntelliJ with M for extract method, V for extract variable and C for extract constant. And a lot of shift f6 to rename.
Its not about method length. It is about what is expressed by that method. If you have a long list of platonic actions. I expect to see that in the code. If that breaks down to two line methods. Fine. If it's 200 line methods. Fine. Usually for longer methods there are more concepts that can be extracted into methods. They might not all be reuseable. Not a problem. Most concepts only show up only once anyway.
I will look into JProfiler et. al. Good suggestion. I suspect that using the Array[Integer.MAX_VALUE] was something they wanted me to discuss as being completely unnecessary. I never would have implemented it that way, and I'm sure they wouldn't have either. It was a "spot-the-bugs" type whiteboard problem, and I focussed on those bugs that prevented the code from working. I overlooked those that were sub-optimal. : (
See my response to Bobby_Bonsaimind
Obviously, this sub was a REALLY poor choice to discuss this type of issue. I truly understand that whiteboard interview questions are likely to be "academic" and far-removed from the type of issues that come up IRL. I still want to do well at interviews, and rarely find being combative with interviewers to be a good tack. Likewise, I offered examples not because I wanted to solve those problems, but to give some idea of why I asked in the first place.
Thanks, that’s what I was looking for.
Aka Windows Phone of IDEs
It's too late for me. My brain has learned the hot key shortcuts on Eclipse. I know fossilized neurons when I feel them. Run, youngsters, run to IntelliJ or what-have-you. Leave me here in Eclipse.
What flame war? IntelliJ ftw!
I jumped from Netbeans to IntelliJ when they had their end of the world sale in 2012 and the license was 75% off. I haven't regretted the move.
Can you give some examples of both? In my mind IntelliJ is head and shoulders ahead here.
yes, you are probably right about me missing the points. CQRS is a complicated subject though. I've listened to/watched/and read about it, but can't seem to understand what a real life scenario of 80/20 read/write scenario.
Amen, brother.
Oh, it is. But i'm so fed up with all those problems Eclipse has that i'd go for an enhanced text editor instead. The only problem with IntelliJ is that i prefer OSS aaand my employer won't pay for it :(
Community edition is open source :)
Student edition is free. https://www.jetbrains.com/idea/buy/#edition=discounts &gt; Students and teaching staff members are eligible to use all JetBrains tools for free upon verification based on domain or ISIC card.
Why? I use them all the time.
Eclipse user for a long time here. I was fed up in the past but support for Maven has greatly improved and is a breeze nowadays. I even tried IntelliJ when some colleagues switched but did not found any killer feature, both have some pro/cons. I'm excited by this new release because it include an improvement I requested myself: being able to delete child Maven modules when deleting the parent. It's a huge improvement (thanks M. Istria !). This release will also feature a parallel build mode that I'm eager to test for Maven projects. ProTip: talking about the Maven support, please, if you're not aware, use the "project explorer" and select the "hierarchical view" (I'm not talking about the packages "hierarchical view" but the modules one). Also make sure to always "Automatically update Maven projects" and to ALWAYS configure the pom.xml and only the pom.xml. Do not configure the classpath manually if you have a Maven project in Eclipse or bas things will happen ;)
Exactly. ^IntelliJ
Because you can run Eclipse on a calculator from the 80's right?
Totally for your benefit, I'll "sell" you eclipse for $1000/yr (to the eclipse foundation) if it makes you feel better! 
IntelliJ Ultimate FTW. Use it at work and use it at home. 
has it stopped suddenly being able to start due to a plugin, or typing text right to left ? Or using its own compiler that is not the same as the standard jdk ? Or looking nasty ? My expenditure was $150 once.
I like the if-block because if, say, it extends into being really big for some reason, it's SIGNIFICANTLY easier to read that the ternary operator. Sure, it probably shouldn't end up like that, but I've seen it happen enough :/
Good 
Honestly, it is one of those products that is worth purchasing under a personal license so you can use it at work. Is that fair? Well, maybe not. But, think of it as your secret weapon. You're always in competition with co-workers, whether this is acknowledged or not. It makes you more productive, and probably happier at work, no? So, license it already. It's worth it. Right? Or maybe not. You decide. Either way, employers are going to be what they are: lazy. They're not cheap. IBM has proved that time and again by convincing companies to pay 10's of 1000's of dollars (if not millions in some cases) per year on their products, and they have the sales team to make this easier. And managers are lazy. Why lazy? Well, buying software is hard; that is it requires a justification and forms to fill out for the capital depreciation. They would rather not deal with it. Big vendors like IBM can afford to make this easier; Eclipse cannot and IntelliJ (without becoming significantly more expensive) cannot. So, in the the meantime, you deal with Eclipse. Or seem to at least. But maybe you're really using IntelliJ all along? You decide.
Fair point!
I haven't had any of those problems, I've had other problems with eclipse. However, I can tell you that I've also had problems with IntelliJ. You sound like a zealot to me, so you can ignore my joke, and use your favorite editor.
A calculator that can handle VS 2017, Eclipse and Netbeans without problems, yet it goes into takeoff mode when Android Studio or InteliJ get used. Somehow I see a pattern there.
I don't think either of us come out looking well from this to be honest. Maybe I'll go back to Emacs.
Is there anything in Ultimate that warrants buying it?
But vim is way better :-P
CleanSheet does
Right. Forgot about multilanguage support sinc its been some time since I needed it.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That's just bad: * Mutable class-level state, making it inherently thread-unsafe, when it's an obvious candidate for using object-level fields (or even just method local variables). * It leaks memory in that the arrays are not cleaned up after the call completes. * Some of the methods are confusingly named - notCrossed sounds llike a question but actually changes the "crossed-out" state. You can simplify the implementation to just `return !crossedOut[i]`, which is so self-descriptive that putting it in its own method is clearly redundant. * as you point out, none of these methods are reuseable. * The selling point of the Sieve of Eratosthenes algorithm is it's simplicity, however here it's rendered unrecogniseable. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Why would "modifying immutable state consists of copying the immutable object"? Immutable state enables structural sharing, i.e., just reusing the existing state and adding on the delta from the modification. it depends on the immutable object and how you modify it. for example, immutable singly linked lists don't require a copy if you add to the head of the list, but do if you add to the tail. 
&gt; immutable singly linked lists don't require a copy if you add to the head of the list, but do if you add to the tail You can quite easily make an immutable *list* where you can add to the end. Obviously if you've implemented a specific a mutable data structure, like a standard linked list, you cannot just magically make it immutable.
I'd be interested in an immutable list data structure that does not need a copy for append/perpend operations and is not a linked-list. It's easy you say?
but then you invoke a copy penalty on prepend
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Using patterns of functional programming fails if you insert random side effects in methods that must be pure. Shocker.
How do you mean? How do you develop a system that doesn't need any GC? 
In other news: Objects with overriden equals() but not hashCode() does not work properly when used as keys in HashMaps.
Google it
If you go to Help-&gt;Productivity Guide it will show you exactly what you use and how many times you have used them.
I honestly thing SPA apps with all the necessary front-end libs like gulp, babel, npm, bower, etc are overkill for smaller apps. Really, if you are already used to Spring and JSPs, you'll have an easy time using 'progessive' front-end improvements by just returning JSPs as normal for the main create, edit, view pages and then adding a bit of JQuery for things like interactive tables, form validation, etc. But for the main page changes, use tried and true request response, redirect forwards on submits, back to spring. 
Way to edit your post with out noteing the fact, making follow up posts seem misguided or wrong.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
So this uses PSKs not PKI certificates? 1-to-1 trust management?
JavaFX is ended...didn't you get the memo? /s
By restricting object creation and hence not creating any garbage to collect.
Thats what i did and it didnt help
The article is worth reading. However, it doesn't answer the question how `MethodHandles` and `VarHandles` could be leveraged. The service aproach is fine. But what do you do if your service needs some parameter to be instantiated? Let's say the whole application would use a special `Clock` implementation that should be used in all services? How would you pass it to a service? Passing it to the constructor would be impossible. So the best approach is probably a setter, but you would need your object mutable then only to be modular.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I was so ready to switch from base Wildfly to Swarm until I saw they were not supporting Gradle. That was a while ago, so maybe things have changed? I think they have Gradle samples now. Is anyone using this with Gradle in production?
The article wrongly states `-XX:+UseAppCDS` isn't available on Oracle JDK, while in fact it's been available there since 8u40. What's new is that the feature has been open sourced and integrated into OpenJDK and will be available in OpenJDK 10 and forward. I'd expect them to be interchangeable in terms of startup gains etc. The caveat is that on Oracle JDK the flag is still (also in 10) guarded by the `-XX:+UnlockCommercialFeatures` flag, which may or may not prohibit its use in production environments (depending on licensing agreements).
Then at best, you don't have a clue on how to setup your environments whatsoever, or at worst you're a complete moron. Best of luck to you either way.
Great, then a paupers budget should serve you just fine, don't worry.
&gt; But modifying immutable state consists of copying the immutable object. A good immutable collection implementation works without copying. See vavr.io collections
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Should I give you my account number for the transfer? Much appreciated. 
I guess I touched a nerve, uuu. 
It doesn't look like this: http://wildfly-swarm.io/generator/ Java EE has some real nice APIs, but I think that Spring Boot offers the better development experience. 
That's rather the point of it using SWT.
Honestly, you don't know anything about my work environment. Not all competition is "toxic" or negative.
Looks promising!
The name is unfortunate. My brain see it as "OpenJDK9 with typo"...
How do you get around without generating garbage with Strings?
I mean, do they go well together? In terms of someone chasing a remote career
They go as well as any other tech, although like most remote work, its hard to find
I haven't worked with other languages professionally so I can't compare. I imagine other languages are just like java - the main problem is that there's a lot of "tribal knowledge" - things that people in the group know, but it's not written down anywhere. The problem is - it's a LOT harder to get that info when people are working remotely. It's not easy in person either, but it becomes absurdly difficult when you're remote. Things like how to setup the project, the nitpocky details pf thr new stuff, etc.
I work remotely on a Java stack and it's not really an issue. I'd say it did take me longer to get up to speed than new hires within the office, but I think that would be true on any stack.
That seems to be linked to what @GhostBond said. Was it hard to find this position? Do you think its easier in other stacks?
&gt; Not at all a fan of that second "clean" implementation. While i'm neither agreeing nor disagreeing with you, I'm curious to see how you might refactor it.
Distance makes working on something together harder. Java isn't any different there. 
Welp I moved and kept my job, I didn't get hired remotely. 
I do not believe I edited this post--certainly not after there were replies to it. What are you talking about?
&gt; Any professional developer should be able to afford an IntelliJ license Of course people can financially afford it, just not mentally. It's why people order beer after beer in the local pub, but spent hours of research on whether that €1 app in the App Store is really worth it...
Businesses are still trying to figure out how to deal with remote workers in general. Some companies have no office and everyone is "remote", but those places are the exception rather than the rule. In general, a business doesn't even need to consider hiring remote workers until they have exhausted the local talent pool. Only then would these types of places put up ads to hire remote workers to broaden their search. It's usually a last resort, so there aren't as many remote jobs as compared to local jobs. Even then, not everyone is cut out for remote work. It's great for those of us that are good communicators, highly disciplined, and do not need a lot of social interaction. Many people over-estimate their own abilities in these areas. The choice of technology doesn't even come into this, really.
Very true. Though it depends on the business and how "ready" they are for remote workers. I spent about a decade doing the contractor thing, and most of my work was done in my home office for clients on the other end of the country. Telephone and video calls can work wonders over e-mail / instant messages for transferring that "tribal knowledge". But sometimes just getting someone to pick up can be a challenge! :)
I’ve worked remotely and in the same room. I work slower when everyone is in the same room. As did everyone else.
I don't know how relevant the tech stack is, but as to working remotely, one of the long list of benefits is that I make New York / Los Angeles / Boston money from my home office in suburban Denver. The downsides are real, but definitely worth it.
I'm pretty sure thay Eclipse on Windows is what is used to develop in-house applications in hell. I'll have to see if I can get it to run IntelliJ on osx or linux.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I use Intellj daily on OSX and once in a while on Linux. Works just fine.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I’ve been working as a remote java dev for most of the last ten years. Works for me. :)
When I'm at my computer and doing "alone at my computer stuff" I work faster alone too. That's not the point. Software development is basically a communication problem when communication is needed (which is often on large projects) distances make communication hard. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It’s 100000x harder to find a remote Java job because the language is dying at an alarming rate
I run IntelliJ on linux. Works great. 
&gt; Jeddict is an open source graphical tool that enhances productivity and simplifies development tasks of creating complex entity relationship models. Using it developers can create JPA class, visualize &amp; modify Database and automates **Java EE 8** code generation. I just highlighted the important part for you --- https://jeddict.github.io/
This. Eclipse has a bit of an image problem but to date it's my favorite IDE. IntelliJ is nice and all, but it still feels a bit limited compared to Eclipse. Especially considering the insane number of plugins that are available for Eclipse and how modular/extensible the platform is. Sure, it has it's quirks but I'm still a lot more productive in Eclipse than in IntelliJ.
Yes, off the top of my head: ``` public final class ImmutableList &lt;T&gt; { private final T pre; private final ImmutableList &lt;T&gt; mid; private final T post; public ImmutableList(T pre, ImmutableList &lt;T&gt; mid, T post) { this.pre = pre; this.mid = mid; this.post = post; } public final ImmutableList&lt;T&gt; append(T item) { return new ImmutableList(item, this, null); } public final ImmutableList&lt;T&gt; prepend(T item) { return new ImmutableList(null, this, item); } }
Like I said, you can't just magically make a mutable data structure (e.g., a double-linked list) immutable. You *can*, however, make an immutable *list* that doesn't need to copy.
please describe your immutable list for which copying is no longer necessary on either append or prepend. as far as I'm aware, the immutable implementations require a copy for one or the other since you need a link to construct a list and adding data at the wrong end requires new links, which require a copy.
And requires you to be a very specific type of person. I would never be able to work remotely by myself, I would get depressed really fast. 
first of all, this datastructure is expensive to traverse, even compared to normal lists, and second, i doubt it can even be considered a list considering it injects valid data (null) to indicate that there is no data, when append(null) would in fact be a valid argument.
&gt; this datastructure is expensive to traverse It's O(n) like a linked list. &gt; i doubt it can even be considered a list considering it injects valid data (null) to indicate that there is no data There is no law that says ```null``` must always be a valid value. If you want it to be, just use ```Optional &lt;T&gt;``` instead of T.
&gt; There is no law that says null must always be a valid value. If you want it to be, just use Optional &lt;T&gt; instead of T, or you could have two sub classes (one for prepend one for append). We're talking java here, where null is a valid value for any generic value. So yeah, you have to take that into account. 
Will J9 come to mac? Right now it's pretty limited on this OS.
Check out Spring Boot :) Josh Long has some geat talks on this on youtube.
I think the way you'd do this is have the 'service' be a factory, that takes the constructor parameters and uses that to produce the real thing. If you want to inject something like a clock, you'd use: ServiceLoader.load(Clock::class).findFirst().get() in order to obtain it from the application environment. Of course your module would need to specify that it uses a clock service.
That irrelevant. The question is whether ```null``` is a valid value as a List member. The Java List does not need to accept null: "Some list implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements". So my implementation is in fact completely compliant with the Collections API from that perspective.
&gt; Saying it's O(n) like a linked list is disingenuous, since O notation only describes the rate at which the difficulty of an operation grows. Traversal is much more complicated than a linked list, and requires constructing another (temporary) datastructure to do in one pass or requires 2 passes through the nodes. What on earth are you talking about? There is nothing complicated about traversal nor does it require constructing any temporary structures or multiple passes: public final void traverse() { if (this.pre != null) System.out.println(this.pre); if (this.mid != null) mid.traverse(); if (this.port != null) System.out.println(this.post); }
Spring Boot with Spring Web MVC and Spring Data is more or less the de facto standard. If you want something with a little bit less magic I'd suggest [SparkJava](http://sparkjava.com/) and [JDBI](http://jdbi.org/)
I think Spring would be overkill for this. Jersey, based on JAX-RS seems more suitable. It's probably the fastest and simplest one to set up. 
&gt; You might remember from your high school CS class that recursion can always be turned into iteration, so this is not a fundamental issue. do it please
I would recommend dropwizard - it's simple and fast or play framework - it has hot reload built in, so you don't have to rebuild whole project to see changes. It is very helpful at beginning or when debugging.
It's standard tree traversal, I'm sure you can do it yourself in your head. If not, then it's a good exercise to learn about basic data structures anyway.
do it without a temporary datastructure. i can't, but you supposedly can. Also, standard tree traversal isn't quite as bad as what you have here because trees don't have a strict limit of one element per level.
Amazing that people straight away shout 'Spring'... Guys, its simple. The spec is this: 1) Receive a HTTP request, gets the SQL 2) Applys this SQL against various databases 3) Responds with a return code that describes if the SQL was valid or not So, maybe just a simple servlet application running under tomcat is all that's needed. 
Whether you manage to do it or not is not the point here (and it doesn't even matter since it's still O(n) runtime). This is just an ad-hoc example of an immutable list data structure without copying. You were not aware that it's possible to do, and I've now given you an example. If you want to see a production quality example, look at Clojure that implements various immutable data structures.
But magicbos the fun part :c
... or better yet just a simple http server like: import com.sun.net.httpserver.HttpContext; import com.sun.net.httpserver.HttpServer; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; String payload = "duke"; HttpServer server = HttpServer.create(new InetSocketAddress(4250), 0); HttpContext context = server.createContext("/java"); context.setHandler((he) -&gt; { he.sendResponseHeaders(200, payload.getBytes().length); final OutputStream output = he.getResponseBody(); output.write(payload.getBytes()); output.flush(); he.close(); }); server.start(); &amp;nbsp; Then call it with http://localhost:4250/java &amp;nbsp; 
I don’t see how this would be much faster then using spring initializer and bang your ready to go watch a YouTube video about the controller annotations and then how to run spring boot. Sure perhaps your right it might be faster if your learning everything from scratch but what’s a more marketable skill? I would argue that having spring knowledge is more marketable...this based on job postings in my area. Ymmv.
More info: https://azure.microsoft.com/en-us/blog/build-spring-boot-2-0-apps-with-azure-starters-and-new-vscode-extensions/
What's wrong with deploying a servlet container? If he's new and wants to learn, it's valuable to understand the process. He could use Spring Boot and abstract that all away, but will he even understand he's deploying to a Tomcat container anyway?
Yeah, I use JavaFX in %60 of my projects. Clicked on a “JAVAFX IS DEAD” article, read it, then remembered that clickbait exists everywhere now.
What does this have to do with Java you shill?
I could get a tons of downvotes for this, but I'll say it. Do not use Spring Boot! Nothing against it as technology and in fact I think it's quite cool, but given your use case that you never used Java before and that you will work alone on the project, I think Spring Boot will only mess your project up. Use simple servlets if you can and simple stuff in general. Your goal is to deliver a project and it's totally fine if it does not use the *latest and greatest* in the tech field.
Well, they'll probably need to do some http payload serialization, so a dependency on bJackson and integration would be needed. And to connect to a DB, so some basic jdbc code. They'll probably need to externalize configuration of the connection parameters, so a small engine to manage that and providing the values to consumers. If they're executing SQL they'll probably need some transaction management, so a small piece to do that. Maybe a nice reusable aspect would be best, so they'd need to pull in some aop technology and incorporate it into their application lifecycle. Then, finally maybe a nice light DI framework to help avoid tight coupling. Perhaps they could just handroll a simple type based one, easy enough. Or they could use Spring Boot.
Because it is a platform that runs Java apps? [Deploy a Java Spring Boot Application](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-quickstart-java-spring-boot) [Deploy a Java Service Fabric reliable services application](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-quickstart-java-reliable-services) Used to be a closed source runtime on Azure. Now it is open source. 
SparkJava is straightforward enough that Kotlin isn't necessary. Simple Java 8 Lambda's as callbacks and you're good to go. Raw JDBC is definitely doable, but I've started playing with Apache DbUtils to help with that. Very light, not an ORM, best of both worlds.
I recently got into REST APIs and the first thing I did was get a Jersey API up and running because it was “easier”. Ended up rewriting the API in Spring Boot. It is definitely the way to go.
Spring Boot or Dropwizard can be okay, but for a beginner I HIGHLY recommend you stick to very defined tutorials. Ignore the magic for now - details will slowly emerge as you learn. That said, I think /u/castor_polox's comment below is the best move. Make the most simple of HTTP servers and mess around that way. As you need/want to do more, the need for a framework can arise and then you can move to something more full featured.
None of which is relevant to the discussion here: Immutable data structures, including lists, can be done without copying with the expected runtime complexities for the relevant ADTs.
I meant with the OpenJ9 JVM. Unless tbat's what you meant, and does it have any noticeable improvement?
I meant with the OpenJ9 JVM. Unless tbat's what you meant, and does it have any noticeable improvement?
Every time you say this you make it less true.
Also because mongodb is technological cancer. It spreads and makes everything worse.
Holy shit balls people here are making shit way more complicated than it needs to be. 1. Pick one of Javalin (javalin.io) or Spark (http://sparkjava.com/). Personally I lean towards Javalin these days as the developer is also a Spark maintainer but he's integrating lessons learned into Javalin. 2. Use JDBI for database queries: http://jdbi.org/ 3. Use Gradle or Maven and have them produce a a fat jar that you can just `java -jar &lt;jar-file&gt;` and you're off to the races. For Gradle you'll want this task in your `build.gradle`. task fatJar(type: Jar) { manifest { attributes 'Implementation-Title': 'Your App Name Here', 'Implementation-Version': version, 'Main-Class': 'path.to.your.mainclass' } baseName = project.name + '-fat' from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } with jar } 
Lots of devs are lazy. Lots of devs don't want to deal with and think about their data properly in terms of limits, relationships, constraints. &gt; Hey, just dump it in a document store and we are cool! A year later... &gt; So, to figure out all this corrupted data we need to switch to 100 shards, add 20 micro services trying to get a semi-coherent picture of it and we really can't guarantee you that your nudes won't end up on the news.
1. start.spring.io 2. pick Gradle and Kotlin 3. add Hibernate 4. be an enlightened human being.
Couldn’t that be said of any database though?? I’ve seen plenty of horrible legacy relational databases. However it would be way messier to tangle if you didn’t have any application to reference. 
You don't need Spring Boot to embed tomcat. Embedding tomcat into an application just takes a few lines of code. Building a fatjar is just a single line in a Gradle build file. Spring is mostly redundant these days, Java EE 6+ is a great framework. Spring is too magically for my tastes, great when it works, sucks to figure out what is wrong when it doesn't.
Brain + fingers + keyboard is the best code generator you have at your disposal.
True, there's horror everywhere. With mongodb it's institutionalised. Therefore the ... less than positive feelings about it.
So would you never go with a NoSQL/Doc database or you’d only use it sparingly 
NoSQL is not bad. Not taking the time to design your db because "Hey I can put anything in my db" is bad.
I don't think there's a general answer to your question - and if it's an interview question, you're better off asking the interviewer for more details. For instance, imagine a cache for storing ints (both as cache keys and values), and your jvm has pointer size P and word size W so the object header size will be O = P + W (bytes) ( I'm figuring as I go, so don't expect much structure to my answer ) If you know an aproximation of your cache keys (say, all within a bound from N to M), the array is gonna cost you: O + 4 {array length field} + (M-N) * 4 {array content} For hashmaps, the cost is not so easy to calculate, but here goes an aproximation (for jdk8): Object Header: O AbstractMap: P {keyset pointer} + P {values collection pointer} HashMap: P {entryset pointer} + 4 {load factor - a float} + 4 {mod count} + 4 {size field} + 4 (threshold field) + P { entries array } Each entry on the entry array will be: O + 4 { hash field } + W { key field } + W { value field } + W { next field } However, because each key and value are boxed ints, their size is: O + 4 { value field } The entries array (its size will be 1.3 * (M-N) in the default 0.75 load factor): O+4{array length field} + (M-N)*P*1.3 + (M-N) * ( (O + 4 + W + W +W) + (O + 4) + ( O + 4 ) ) putting it all together for a 32bit jvm (W = P = 4) and using X=(M-N) cache array total size: O + 4 + (M-N) * 4 12 + X * 4 hashmap array total size aproximates to: O + 4*P + 4 * 4 + O+4 + (M-N)*4*1.3 + (M-N) * ( (O + 4 + W + W +W) + (O + 4) + ( O + 4 ) ) 52 + ceil(X*5.2) + X * 48 ~&gt; 52 + 53*K (i didnt proof any of these, but with this information you know how to calculate) For 64bit jvms, W is 8 and P is either 4 or 8, depending on wheter or not you have CompressedOOPS enabled and working Basically, for fully populated caches within a certain bound, its not worth it to use HashMaps. In general, the size function for hashmaps is looks like this: 2 * O + 4*P + 20 + ceiling ( 1.3333 * ( X ) * ( P ) ) + ( X ) * ( (O + 4 + W + W +W) + K + V) where X is the number of entries, K is the size of the keys (boxed if primitives) and V is the size of the values (again, boxed if using primitives) ( at this point, I'm not really sure if my post makes you even more confused, but its too late now ) 
For spring 1.5, the property is named server.context-path https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#common-application-properties
Spring boot is a great suggestion if you just need to get a backend going. If you're interested in learning more about servers though, it can be fun to try to write an HTTP server from scratch. The basic pattern you would use is to make a SocketServer, and read more messages that following the [HTTP spec](https://tools.ietf.org/html/rfc2616) - "HTTP 1.1\nGET /mything" and such. For bonus points - use a ThreadPool so you can handle multiple incoming requests at once!
&gt; if you don’t trust your developers Never trust developers. They are not bad people, but we all have seen enough horror programming. It only takes one person and one commit to fuck something up. &gt; is more fool proof Exactly. Being fool proof is one of the best feature a framework or tool can offer.
&gt; I want to write an API which receives a SQL querry and check this querry for failures (like parsing it [...] [I actually did this](https://www.jooq.org/translate) (probably for entirely different reasons than you did). The API is here: https://www.jooq.org/translate/translate?sql=SELECT%201&amp;to-dialect=ORACLE This will just parse the query and re-render it again in a different dialect. It will most certainly not execute it. &gt; , using it on examples, ...). So it does not have to be super secure, since the whole application will only work with sandbox databases o_O. Ehm. No. Unless you really really really know how to configure your "sandbox" database, chances are that it's not so sandbox after all. You're planning on using H2, for instance? An attacker could (maybe) create an `ALIAS` for any random Java method, oh, let's say `File.delete()` and then possibly call it from a SQL query: http://h2database.com/html/grammar.html#create_alias I'm not saying it isn't possible. http://sqlfiddle.com is an example where this has been done. But I'm sure, it is really well configured and sandboxed correctly. Given your questions, you probably don't know how to do this. Given, however, your mentioning security, I'm assuming you're planning on putting this sandbox on the internet. Please, don't :-)
And I thought these people would go to /r/funny or something.
I dont want spring, i tried jhipster 
I agree and am a big fan of Spring Boot. I have one remaining large legacy application running under J2EE and Wildfly that I was interested in using Swarm for. Looks like I will skip it without first class Gradle support.
If I thought OP was describing an XY problem, I would have said so. By OPs own admission, he doesn't know what he's doing in the backend space. Do you think he described a service that verifies SQL statements?
If you like annotation and their magic behavior like for example PostConstructor use Spring. But if you want play with pure java without annotation check this: https://ratpack.io/ 
&gt; in fact, sometime exacerbate the problem as there are no written records of the decisions made. That's completely up to you. It's not like a slack chat is a great written record either.
https://insights.stackoverflow.com/survey/2018/ Most Popular Technologies - Java 45%
&gt; it cannot be done on a singly linked list without copying. and the original discussion was with regards to an alternative to a singly linked list. Nobody has claimed that it can. Like I pointed out before, you are mixing two different concepts, abstract data types (ADT, e.g., list) and concrete data types (e.g., singly linked list). Nobody has claimed that you can take an arbitrary mutable concrete data type (e.g., singly linked list) and make it immutable. The claim is that you can create an immutable concrete data type for the list ADT with the expected complexity—and I proved this with an example. &gt; i was looking for an example that would meet their performance needs ... you also provided an immutable list that is slow as hell It has the same complexity, a.k.a. the same performance or speed at this level of analysis. Your claim is simply provably false—append and prepend are O(1) and iteration O(n) in both cases. If you want to talk about specific implementation performance, you need to look at production quality implementations. I pointed you to Clojure immutable data structures as examples. Bitching about details of a toy example designed to show that you don't need to copy is just you trying to desperately defend your ego. &gt; i don't know why i'd bother with clojure ... and i wouldn't waste time with dynamically typed garbage. Because Clojure has production quality implementations of immutable data structures without, something you did not seem to know could exist. This has nothing to do with the quality of the language, just the data structure design, which you can replicate in your language of choice. &gt; the problem is that you seem to think that useless solutions are worthwhile They are useful, as proven by the fact that they are, you know, actually being used in production (again, see Clojure as one example).
I've only found a handful of use cases for NoSQL solutions. Basically, if your schema is constantly in flux, then NoSQL is the way to go, however, that doesn't mean you can just throw data at the database. 
I'd say first do as the top poster says, don't do what the OP wants to do as it's a recipe for SQL injection attacks.
Interesting you say that. I found the second version vastly more clear than the first one. Because each method is small and accomplishes one very particular subtask, I can easily debug and make sense of it in isolation. I can similarly reason about the top level method easily, by considering how it integrates together the 4 sub methods. Everyone has an opinion, and it would be cool to back it up with some real data. I'd love to see people inject some deliberate bugs into the program, show it to some random programmers who've never seen it before, and measure how long it takes them to identify/fix the bug. That would be an interesting and objective way of comparing code-styles.
&gt; I want to write an API which receives a SQL querry and check this querry for failures (like parsing it, using it on examples, ...). Yes
I hadn't heard of JDBI, I looked it up, it looks like the same thing I can do with straight JDBC annotations: http://www.java2s.com/Tutorial/Java/0340__Database/JDBCAnnotations.htm So if I were to eschew an ORM I'd probably go with straight JDBC and its annotations. Or possibly the Spring JDBC Template, I've heard good things about it but never used it.
Or email, or Jira, but it is searchable and FARRR less fallible then human memory.
I do shtick wherever I am. Don't forget to tip your waiter.
Ok, first question - why? Is this some sort of school assignment? Second - if you're using sandbox databases or something, why not use something simple like sqlite? Third - Spring jdbc allows you to write queries with parameters, putting ?s instead of the values; and it allows you to use named parameters instead. But I think I have an idea of what you're trying to do - do you want to make a SQL console, by any chance?
&gt; Nobody has claimed that it can. Like I pointed out before, you are mixing two different concepts, abstract data types (ADT, e.g., list) and concrete data types (e.g., singly linked list). Nobody has claimed that you can take an arbitrary mutable concrete data type (e.g., singly linked list) and make it immutable. The claim is that you can create an immutable concrete data type for the list ADT with the expected complexity—and I proved this with an example. singly linked list is not inherently mutable. further, it was what was being discussed already so there's a reason i was discussing with it in mind. that you would choose a much less performant implementation to solve the issues brought up in the article is kind of silly. &gt; It has the same complexity, a.k.a. the same performance or speed at this level of analysis. Your claim is simply provably false—append and prepend are O(1) and iteration O(n) in both cases. no, that's not what O(n) complexity analysis means. I thought you were the big datastructure expert here. &gt; Because Clojure has production quality implementations of immutable data structures without copying, something you did not seem to know could exist. This has nothing to do with the quality of the language, just the data structure design, which you can replicate in your language of choice. i did know they could exist. the question is if they are performant, and that's not always the case, as you clearly showed. when performance is key, you often have to use less ideal datastructures as an optimization, and there's just no escaping that. &gt; They are useful, as proven by the fact that they are, you know, actually being used in production (again, see Clojure as one example). oh, they certainly are, but they are useful for *other* situations. not the situation at hand where performance is key. 
There is a free course on this site " Spring Boot Essential Training" https://www.amigoscode.com
&gt; you would choose a much less performant implementation I have suggested no such thing. I showed you a toy example with the same performance (at this level of analysis). You can keep claiming it's "much less performant", but that is a provably false statement. If you want to look at more detailed performance, you must consider a full production implementation, the workload, the system architecture, etc. etc. Then it might turn out that simply copying is actually the most performant solution rather than a linked list or a tree-based immutable list (this is in fact the case in many real-world cases). But you cannot handwave about some hypothetical linked list implementation against a toy example of immutable list and make any coherent arguments.
You are correct. The point is, 100 threads is only about 100MB of stack space - and most applications will likely have way fewer threads/DB connections to prevent saturation. Really, we're likely looking at something like five to ten dedicated DB threads. Eliminating those in favor of the reactor pattern doesn't buy you a lot. Where the reactor pattern has value is when you can eliminate hundreds or even thousands of potential threads, such as when doing inbound and outbound HTTP I/O.
Yes, it's just as ugly and non-functional on Linux as on Windows, compared to Eclipse.
I've worked remotely and with nearly all remotely distributed teams the past several years. If anything, we're more available than people "in the office" because you can never find the person in the office, they're at their desk but headphones on so don't want to be disturbed, maybe they're not at their desk and in the bathroom, or down at the break room, or out for a short walk, or who knows. I have to wonder if people who push the myth that remote people are less available are managers who are using social engineering to try and discourage people from going remote. 
In the year 2018 there about a billion communication tools and the entire worldwide Internet available for communications.
&gt; In general, a business doesn't even need to consider hiring remote workers until they have exhausted the local talent pool. It is a myth that plays well into control freak manager's desire for tight control of people; it has nothing to do with reality. 
If you want to parse queries, learn ANTLR and find a grammar file for your target DBMS. 
Since OP says the purpose is to parse queries, then OP will probably have to receive queries. 
My favourite is "writes fail silently." MongoDB takes your data, asynchronously writes it when it's ready, and does absolutely nothing if it fails for whatever reason. Your data will just be silently discarded while your application happily goes about its business.
This may be one of the few things I'd consider to be truly useful in Java 9.
That's wrong. Yes, it hides a lot of stuff, but for his needs that's perfectly ok. when he will want to learn he can. what now, you're suggesting writing assembler before you can write your first C program? this is not 1970 anymore.
"Reactive programming is non-blocking applications that are asynchronous and event-driven and require a small number of threads to scale vertically (i.e. within the JVM) rather than horizontally (i.e. through clustering)." I learned a long time ago to think proactively, not reactively. React oriented development seems like backwards thinking to me. 
Blockchain doesn't scale, by its very nature, it has no real future. Stop gap measures like role monitor points help but also contradict and fight the very purpose of the design and any advantage it has standalone.
I you don't want either Spring or JEE I doubt you can find a good code generator. The amount of code to generate (classes for domain objects, DAOs, services, security, routing, etc) without any framework would be too big. That said, maybe you could use the code jhipster or jeddict generates for your domain classes as a starting point. Anyway, if you find a good framework free code generator, please post it! P.S: I'm mostly a Spring guy, but JEE is not such a big deal nowadays, if jeddict works, give it a try!
Wtf are you talking about? Do you actually know what you are talking about or are you just tossing around buzzwords? Are you trying to tell me SQL Injections are not easily preventable?
Should take about a minute in [Javalin](https://javalin.io): // create and start server on port 7000 Javalin app = Javalin.start(7000); // add a handler for POST requests to "/check-query" app.post("/check-query", ctx -&gt; { String query = ctx.formParam("query"); // ... do your thing ctx.result("your query was great, good job"); }); // create a frontend which posts to "/check-query" &lt;form method="post" action="/check-query"&gt; &lt;textarea name="query"&gt;&lt;/textarea&gt; &lt;button&gt;submit&lt;/button&gt; &lt;form&gt;
So you think extension methods could help here? They would give the convenience of dot notation and the possibility to split functionality from interfaces.
Yeah we know, but its not funny. And other people will just see this again and again and think its true.
Why not Ant (you said you use Gradle or Maven)? Just curious.
Why ANTLR over BISON? And can you point me to where to find grammar files for PostgreSQL or SQLite?
Not a fan of spring. I really like Vertx.io-- great documentation and apis.
No, you don't need a framework. JavaEE (so base java packages) can take care of your basic needs. However, spring boot makes it even easier, especially with not having to wrestle with deploying to app server... albeit that's not much of an effort but simply saves time and effort in an area you don't care about right meow. quick google: [java ee](https://docs.oracle.com/javaee/6/tutorial/doc/giepu.html) [spring boot](https://spring.io/guides/gs/rest-service/)
A fat jar just means a JAR with all dependencies included so you just ship it around as a single file without having to do anything like archive the JAR with a sibling `lib/` directory. As for Ant vs. Gradle vs. Maven. I have a strong preference for declarative build systems (Maven and Gradle). I prefer Gradle these days because it's easier to tweak and the Groovy is easier to read than Maven's XML... both are fine though really. 
Gradle &gt; Maven &gt; Ant Don't use legacy software if you don't have to. Except for GNU Make. 