Both python and java are fine to learn programming. Both python and java are ok to find a job to apply your knowledge. I'm a Java guy who occasionally writes python scripts to support specific use cases (e.g. deploy scripts), so I will naturally say you are better off learning Java in depth, but take that with a grain of salt. In practice though you will get job on basis of Java or C# knowledge (or C[++] if you are shooting for well paid experienced senior positions). But please don't go into C# darkness. That way lies madness.
&gt; I wouldn't say that it's a particularly fun or interesting language Particularly fun or interesting is the last thing I am looking for when trying to optimise execution of 3 hour batch job computing *jada jada jada something nlp something big data*...
&gt; first - there are no superior languages There are inferior ones though. Node.js ;-)
don't get me started on an anti javascript rant 
Agreed! So it really depends on why OP is learning programming :) 
As a counter point, Python is big in machine learning. If you know Python already then TensorFlow might be a good niche/future industry. Groovy is a great JVM language that has a better syntax than Java but can give you JDK experience. Kotlin if you are interested in Android dev; or Scala and Clojure are decent functional languages that tie to the Java job market. Personally, I'm trying to get a handle on Elixir at the moment. 
I tend to cringe myself when i meet these kinds of articles. However, I will say that I understand what Lightbend is trying to do with Lagom. I've been experimenting with deploying akka clusters in kubernetes lately and a framework like lagom tries to solve a great many challenges you tend to have when building solutions using these strategies. Akka itself is actually pretty damn cool. It was my first exposure to the actor model of concurrency and finite state machines. If you've not messed around with it, don't let this article stop you from exploring further Lightbend offerings. After doing some initial analysis of lagom, we decided it was too opinionated for our purposes. We've decided to use a combination of helm and istio within k8s to implement some of the same pieces of functionality. This allows us to not tightly couple the "service mesh" (that phrase is still a bit cringey to me) framework to the actual application code.
If you're the author...this is worded bad: &gt;And we should ask a question, **could we don't using** these separated solutions for service discovery and reuse Marathon or another orchestrator for solving this problem?
I know that but for the hardest part for me would be getting the syntax down to a point where I know it perfectly.
We do have a an Observable pattern in place right now where a user's GUI will be updated if another user has made a change to the underlying data. I would not call this a requirement though. RxJS seems to have an IntervalObservable which might handle keeping the GUI updated if the underlying data changes assuming two-way binding is being used. Mind if I shoot you a PM regarding Tomcat?
Sure :)
I've been messing around with jade mostly, if my memory serves me well, first time around was about a decade ago. Which is actually my main issue about everyone reinventing each piece of technology every dozen years or so. 
I get that you're paid to promote Intellij here. I wish they put as much effort into actually writing the IDE as they did in promoting it. Recently (about a year ago) having to deal with Intellij not working with maven was not fun.
&gt; This [lazy evaluation] optimisation is an implementation detail [...] Not entirely true. The [API specification](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html) says "Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.". Laziness is not an implementation detail, but actually well defined behavior. For most operations it is kind of obvious what 'as needed' or 'terminal' means: Stuff like `sorted()` or `distinct()` cannot operate on lazily evaluated (or parallelized) streams. `flatMap()` is not that obvious, but still behaves correctly according to the spec. Edit: I was wrong. `flatMap()` is really strange and there is no spec backing its strangeness. More details in the nested comments.
I've seen plenty of Eclipse bugs, so don't get me wrong. But Intellij bugs are just so...stupid. I saw one (admittedly over a decade ago) where if you deleted a class, the IDE would delete the generated class - but not an inner class declared in that class. More recently Intellij would say it ran maven, but it just didn't. I had to run it from the command line. Intellij bugs are so show stopping and basic, I wondered if they even actually tested their own IDE before releasing it. Not that eclipse was necessarily better, but it wasn't worse. Though come to think of it I've never seen a show stopper bug in eclipse... 
Problems listed with the java way of doing things: &gt; * Going back and forth between collections and streams. &gt; * Handling checked exceptions in lambdas. &gt; * Casting explicitly. First two are because of bad use of java, and as to the third - there was no casting!
&gt; to promote the speakers And now guess why OP submitted this promotional "article".
I see your point. (Although: Why can't `distinct()` ~~not~~ operate "lazily"?) API specifications are subject to change, though, [even drastic change](https://blog.jooq.org/2015/12/02/a-subtle-autocloseable-contract-change-between-java-7-and-java-8/) :)
`Stream.of("").flatMap(x -&gt; Stream.iterate(1, i -&gt; i + 1)).limit(1).forEach(System.out::println);` http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8079264 ;)
I've seen mocking, unit tests (not integration tests), etc on several projects. I've never seen them be useful. They mostly seem to exist as a vehicle for someone to use to schmooze with the boss, then assign the rest of the team "sounds interesting at first but turns out to be awful and useless" work (sorry but that's my repeated experience). There are a lot of claims made about unit testing and how it will help "in the long run", but what **always** happens is that after a few months unit test fatigue sets in. This combines with the corporate-politics need to appear to as fast or faster than everyone else. People start writing short useless tests that are the minimum required to pass. People who need to change code don't use the already-written tests for anything, if the test fails they comment it out. No one can afford to take 3x longer than anyone else to complete their tasks - and it's hard to blame them as they don't seem very useful anyways. There's only 1 kind of testing I've seen be useful: - Automated user-role tests (integration tests). "User does step_a, step_b, and step_c, then the page returns this". I've seen these written using JUnit + Selenium, though a tool that would let run through the steps live in the browser would be better. If someone got the bosses ear with JUnit tests, I've not seen a way to talk them out of it. It's like the idea of a flying car, very appealing in theory, far less in reality (fuel costs, crashes, driving in 3d, etc). What happens is that either management starts to believe it's a waste of time after a few months and drops the requirement to write them, or more often management stops paying attention to it and the team quietly transitions to writing short low-effort useless tests that technically fulfill the "write unit tests" requirement. So I see possible value in automated user-role (integration) tests if you have consistent management support, but not in unit tests. My several experiences has been similar to yours. 
I wonder how Spring 5 WebFlux and maybe Spring Cloud (I'm not sure Flux is supported yet) compares with Lagom. I made some effort to understand it but maybe someone more experienced can answer this.
&gt; and he has to get out of bed and fix it I've not seen unit tests fix this, mock tests are even worse. Integration tests - "user does step_a, step_b, and step_c, then they get result_1" - those can be useful. But not unit tests. 
Yes, author here. Thanks for your nice words. It is hard for a blog talking mostly about Java and SQL not to fall into the "trap" of covering some less recent topics. Java is 22 years old, SQL has been around for 40 years, yet I still get to explain [things](https://blog.jooq.org/2016/12/09/a-beginners-guide-to-the-true-order-of-sql-operations/) [like](https://blog.jooq.org/2014/12/04/do-you-really-understand-sqls-group-by-and-having-clauses/) [these](https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/). See it from the bright side. There's always a huge amount of interesting topic to cover. At the same time, I'm learning a lot of things from a variety of people, be they trivial or non trivial. Perhaps, your judgement of "quality" and "complexity" in this case is supposed to indicate that your level of expertise is far beyond mine (not unlikely), in case of which I would be delighted to learn from you as well. Unfortunately, this seems to be the first comment you've left on reddit, so I'm left here wondering what wisdoms you may have been hiding behind your previous user handles. Meanwhile, I do hope you understand that I don't just write for you, but for the vast majority of our community out there, many of whom may not yet have seen this caveat (despite the countless documentation) Do keep in touch. Lukas
Wow. That's horrible.
Neat. I guess I can kind of understand why this is happening, but it is certainly unexpected. That it is a 1 year old known issue is somewhat discouraging. I don't have a lot of hope it will be corrected. The more I hear about infinite streams, the more it sounds like booby traps abound.
I appreciate your contributions. I enjoy reading the views of someone else who is passionate about something to a level far beyond my own. TLDR; Ignore this prick.
thank for suggestion :) 
Java - for jobs
Refactor it as `\u005FprivateFields` ;)
They both work, fairly similar languages; I've known python devs that take jobs as java devs and vice versa. Not really many new paradigms to learn hopping between the two, but they both make money. I mean your on the java board though, do you expect us to not say learn java?
While he recommends jhat, he should have mentioned that it has been deprecated and is not part of JDK 9. 
I would look at Aurelia I liked it a lot better than Angular, it has paid support if you need it. I would set up 2 Spring Boot Projects 1 that forwards your your REST requests to the RMI server, that has a version header, 2nd is an incremental port of your rest requests, that doesn't require the version header. That way there you can port over the existing application and the URL's don't have to be changed.
unless things have changed a lot in python in the last couple years, they may be superficially similar, but their performance characteristics are quite different - ie, with python you're doing your heavy lifting in c
You're doing some real heavy lifting before that matters.
Damn man hatsh haha I think /u0007 is plenty. It annoys them as much as their _ annoys me. I might have to start doing that lol
Why not just learn both of them? 
Thanks for the kind words! I think there are many people who would use hot standbys for more regular query load if they could, but are currently limited to historical report queries etc because of replication lag. My current goal is to show that there could be (1) demand for synchronous_replay and (2) simple, practical ways to use it, even if a bit of extra infrastructure is required. Your feedback helps, so thanks :-) The logic required is quite straightforward and I think the right person could get this working very easily, especially if a v1 implementation aims low and doesn't try to get the 'whole transaction retry' logic working (ie only support retry if the error occurs on the first statement in a transaction, and tell users to use REPEATABLE READ to avoid having the error ever bubble up to the app). One idea for how to structure a v1 is that there could be a new connection pooler LoadBalancingDatasource that manages a set of connection pools -- one per database server -- so that it can implement the blacklisting. I'm not sure if it would need to wrap the underlying connection pools' connections, so that it could remember which source (and therefore server) each one came from. I'm also looking into getting pgpool to manage this stuff automatically: http://www.sraoss.jp/pipermail/pgpool-hackers/2017-July/002418.html But for Java apps I think it'd be better to push the load balancing back into the application server and skip a network hop if possible.
I've said, one nail, not all the nails.
the kotlin bad-posting continues &gt; The complete source code for this post can be found on GitHub in Maven format the github includes only the kotlin example, not the java one (which based on the snippets in the blog post might be for the best - the guy is either obtuse or intentionally writing bad java) 
&gt; Why can't `distinct()` not operate "lazily"? Because it's a (stateful) intermediate operation, and intermediate operations are always lazy.
Something I have learned is that 99% of the problems with Java, are because of bad Java programmers. Many people do things that would be considered bad in any language, but somehow they are still doing them years into their career. 
Underrated comment. O(logN) will outperform O(N2) pretty much always regardless of language. And O(N) is the king.
Underrated comment. It's been a while since "knowing a language" was about knowing what the compiler will accept. For last couple of decades it is all about proficiency with libraries and ecosystem.
Didn't even have to read the article, title is a truism. Might refute the point by saying "if you care about the runtime performance, don't abstract your execution through iterative interfaces"
The jOOQ blog is so good
I'm curious too
We really need better tools for debugging highly concurrent code. Async completions/reactive streams are a bear to debug: non informative stacks, timing issues, etc. 
the entire post is built on a misunderstanding. [flatMap](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-) returns a new stream and terminates the old one, both of which are evaluated lazily i'm also not sure that laziness means what luka thinks it means, but i'm not enough of a spec lawyer to argue this point from reading the spec and the source, it's not clear if implementations are allowed flexibility in the order that they eval the pipelines, eg in the case of a parallel stream. however, in many cases i'd like to be able to force a portion of a pipeline to be completed prior to starting the remainder, ie column-wise instead of row-wise, and i haven't found an elegant means of doing so i ported java 8 streams to a coroutine library and based on that work my feeling is that streams are half-baked, and mired in so much spec language that i think it's going to be hard to improve them 
Learning Kotlin and C# has really opened my eyes as to what Java is missing. So I can second that. 
Absolutely.
Yes, argon2-jvm is just a JNA interface to the C libraries.
&gt; i'm also not sure that laziness means what luka thinks it means, but i'm not enough of a spec lawyer to argue this point Oh, that's perfectly possible. But see, there's no point of being a spec lawyer. I'm a user of an API and I have *expectations*. Take a SQL JOIN for instance, [which is somewhat similar to a Java Stream `flatMap()`](https://blog.jooq.org/2015/08/13/common-sql-clauses-and-their-equivalents-in-java-8-streams/) (technically, `flatMap()` is more like `CROSS APPLY`). My expectation for the RDBMS is to evaluate this JOIN as lazily as possible, producing as little I/O and CPU load as needed given all the information it has about the query. If I add a `FETCH NEXT 5 ROWS ONLY` clause, I expect that a sophisticated RDBMS will figure out that: - Nested loops beat hash joins - Index range scans beat index full scans beat full table scans (mostly) - Most importantly (duh): It can stop *all* operations once 5 rows have been found The SQL standard (the spec) doesn't talk about these optimisations. It only talks about the semantics of a `JOIN`. It doesn't care if your database is dumb enough to actually materialise 100s of billions of rows in memory prior to remembering, "oh crud, we only needed 5" Whether the Stream spec specifies this is really irrelevant to me. Specs can change ([drastically](https://blog.jooq.org/2015/12/02/a-subtle-autocloseable-contract-change-between-java-7-and-java-8/)) when the designers see such change is suitable. Specs (in Java) are more of a formal way to express what the designer intended to do, not some eternal law. Look at the `Collection` specs. They're so complicated and weird in many ways. `Set` depends on `hashCode()` and `equals()`, but a subtype of `Set` (`SortedSet`) depends on `Comparable` / `Comparator` semantics. That's nuts! It was a drastic design mistake ([Lishkov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)), which will probably not be rectified ever (nor does it bother most people). The question is really about: - What do users expect - Is it reasonable to implement this for users I don't know about the latter point, because I have never thought about Stream parallelisation thoroughly. But then again, I'm also not too big a fan of parallel streams. Streams could be [much more powerful and useful to a majority of users](https://twitter.com/lukaseder/status/778153514300272640) if they were sequential only. Likewise, the SQL parallelisation features are completely transparent to the SQL language and they're implementation details, not API design (assuming you don't think of e.g. Oracle `/*+parallel*/` hints et al. as being part of the "ordinary" API). Yet, SQL `JOIN` operations (and many others) are as *implemented* (not *specified*) as "lazily" as possible, according to my intuitive (not formal) definition of "lazy". &gt; i ported java 8 streams to a coroutine library and based on that work my feeling is that streams are half-baked See? You actually agree with me :) Did you open source your work? I'd love to have a look.
Ok, too much "lazy" in this discussion, we need a definition :) By "lazy", I mean that `distinct()` will not collect all upstream values prior to passing them downstream. It will collect one upstream value at a time and if the value has not yet been seen (stateful as you said), it will be passed on. So, that's lazy, yet it will "eagerly" fetch all upstream values until a not-yet-seen value appears. Unlike `sorted()`, which has to find the first value from the upstream values in a sorted manner, meaning it has to consume all the upstream values to decide which one is the first. That's less "lazy" in my intuitive understanding. Likewise, `flatMap()` *could* be implemented more lazily meaning that it would consume upstream values as it does, and flatmapped streams as well, e.g. using an `Iterator` rather than just `forEach()`. I certainly think this would be better for sequential streams (not sure about parallel ones), regardless of spec. In fact, there's a comment in the sources which hints at using a spliterator: // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it Although I'm not convinced that this is the same as what I mean.
&gt; title is a truism Yes it sounds like it. But then again, have you worked with enterprise code? It appears that not everyone finds this as obvious as they should. &gt; "if you care about the runtime performance, don't abstract your execution through iterative interfaces" There are different levels of performance. You're advocating improving constant overheads (more or less). The article is advocating improving algorithmic complexity. Both improvements have their place, although the latter is more generally applicable, whereas the former might be premature optimisation.
Why has this been downvoted so heavily? I think that would be a really interesting static code analysis tool, it might even be possible to do so, to turn runtime exceptions into effectively checked exceptions in an alternative language model. Some research would be needed to know what kinds of runtime exceptions are really interesting (e.g. `NumberFormatException`) and in what context...
And it would be even more useful if ported for languages without checked exceptions! (all other OO languages except Java). But exceptions like NullPointer, ArrayIndexOutOfBounds probably should not be listed / only explicit throw statements are listed. But I'm not sure if I'm being downvoted or if it's just Reddit's vote fuzzing at work.
&gt; But exceptions like NullPointer, ArrayIndexOutOfBounds probably should not be listed / only explicit throw statements are listed. You're right. Exceptions like NullPointer, ArrayIndexOutOfBounds, which can be thrown without explicit throw statement, probably should not be listed / only explicit throw statements are listed.
But the Java compiler forces you to catch checked exceptions. But RuntimeException / unchecked exceptions is not required to be caught so you can forget to handle them
Eclipse does not list unchecked exceptions / RuntimeExceptions that are not declared in a method's throws section. See the discussion under TheRedmanCometh's post.
Thanks for your feedback. Unfortunately, everyone makes mistakes. Especially me cause I'm not a native speaker :)
Yes. You can use the following config properties to control minimum and maximum pool size. **minimumIdle** This property controls the minimum number of idle connections that HikariCP tries to maintain in the pool. If the idle connections dip below this value and total connections in the pool are less than maximumPoolSize, HikariCP will make a best effort to add additional connections quickly and efficiently. However, for maximum performance and responsiveness to spike demands, we recommend not setting this value and instead allowing HikariCP to act as a fixed size connection pool. Default: same as maximumPoolSize. &amp;nbsp; **maximumPoolSize** This property controls the maximum size that the pool is allowed to reach, including both idle and in-use connections. Basically this value will determine the maximum number of actual connections to the database backend. A reasonable value for this is best determined by your execution environment. When the pool reaches this size, and no idle connections are available, calls to getConnection() will block for up to connectionTimeout milliseconds before timing out. Default: 10. &amp;nbsp; This is a great article about pool sizing [https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)
Sure, replace className with the name of your class, and create an array with `arrayName = new className[size]`, where size is the size of the new array.
Thanks a bunch, much appreciate! :D
Since this is help with *Java programming* it should be, as the *plenty hints on the page* indicate, posted in **/r/Javahelp**. Please, be sure to *read* and *follow* the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. **Post removed** programming help
Ah, sorry, I should've read it before posting. My apologies!
I think there was a misunderstanding because of the double negative in lukasenders reply. I said "distinct() cannot be lazy", which is wrong. I'm sure lukasender noticed that and wanted to ask "Why can't distinct() be lazy?" 
&gt; But exceptions like NullPointer, ArrayIndexOutOfBounds probably should not be listed / only explicit throw statements are listed. At some point inside some library, there is an explicit throw statement, so it won't be very easy to discover the exact distinction between more and less interesting exceptions. Which is why I said "more research would be needed". But with sufficient research and IDE configuration, this would definitely be an interesting tool. I think you're being downvoted. [52% upvotes](http://i.imgur.com/USz1zsB.png). The reason is probably disagreement and misunderstanding, which is an unfortunate reason for downvoting. But oh well. Might be people not having drunk their coffee yet :)
&gt; Set depends on hashCode() and equals(), but a subtype of Set (SortedSet) depends on Comparable / Comparator semantics Are you sure you aren't confusing `Set` with `HashSet`? There's no requirement for a `Set` implementation to use `hashCode`. The main requirement is that "*sets contain no pair of elements `e1` and `e2` such that `e1.equals(e2)`*". In a HashSet this is satisifed through the use of `hashCode` and `equals` whereas in `TreeSet` it's satsified via either `Comparable` or `Comparator` either of which "*must be consistent with `equals` if it is to correctly implement the `Set` interface*".
`Stream.distinct` is lazy though, right? The [Javadocs for Stream.distinct](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#distinct--) state that it's a "*stateful intermediate operation.*", and that: &gt; Intermediate operations return a new stream. They are always lazy 
&gt; Likewise, flatMap() could be implemented more lazily meaning that it would consume upstream values as it does [...] I may be wrong again, but `flatMap()` does indeed consume upstream one by one, as you'd expect. (edit: Okay, it actually has two 'upstreams'. One is consumed lazily, one is not. See below.) The strange stuff happens in or after `flatMap()`. I actually see two Problems: 1) `flatMap()` consumes the entire stream returned by the map-function, even if only a couple of elements are needed. This causes the bug mentioned above (Streams don't terminate if `flatMap()` tries to flatten an infinite stream) and is caused by the `forEach()` in its implementation. 2) The items consumed from the sub-stream in `flatMap()` are pushed downstream, in a way that reversed the usual nature of streams (streams should pull, not push). This is what you showed in your blog post: `limit(5)` seems to pull more than 5 elements from the stream, because they are actually pushed, not pulled and `limit()` cannot prevent upstream from pushing more items. It can only discard them. To sum it up: `flatMap()` pushes entire groups of items downstream, which is wrong or at least suboptimal. Also, Java streams are messy.
&gt; I may be wrong again, but flatMap() does indeed consume upstream one by one, as you'd expect Thus my wording *"as it does"*. The emphasis should've been on "as it does ***and***" &gt; 1) flatMap() consumes the entire stream [...] Yes, that's exactly my criticism here. &gt; 2) The items consumed from the sub-stream in [...] Hmm, I would have thought this to be two times the same problem, but you're right. This is a subtly different, more interesting point of view.
Yes, `distinct()` is lazy. I was wrong :)
The little details ;) Interesting topic, though. I learned a lot from your blog post any my own experiments that followed. Thanks for the inspiration!
[From `java.util.Set`](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html) &gt; The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and ***hashCode*** methods. Of course, given the fact that `Set` depends on `equals()`: &gt; More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2) And then looking at the contract of [`Object.equals()`](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-) &gt; Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, *which states that equal objects must have equal hash codes*. We can indeed conclude that `Set` "depends" on `hashCode()` as well. But I see your point. It doesn't have to use `hashCode()`. &gt; "must be consistent with equals if it is to correctly implement the Set interface". Exactly. Now, go look at `BigDecimal` and how it behaves for values `1.0` and `1.00` in either `HashSet` or `TreeSet`. For your convenience: import java.math.BigDecimal; import java.util.Arrays; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.TreeSet; public class Liskov { public static void main(String[] args) { Set&lt;BigDecimal&gt; s1 = new HashSet&lt;&gt;(); Set&lt;BigDecimal&gt; s2 = new TreeSet&lt;&gt;(); magic(s1, s2); } private static void magic(Set&lt;BigDecimal&gt; s1, Set&lt;BigDecimal&gt; s2) { // Yay, I get Sets. So equals() matters only, not Comparable, right? List&lt;BigDecimal&gt; list = Arrays.asList(new BigDecimal("1.0"), new BigDecimal("1.00")); s1.addAll(list); s2.addAll(list); // Oops System.out.println(s1); System.out.println(s2); System.out.println(s1.contains(new BigDecimal("1.00"))); System.out.println(s2.contains(new BigDecimal("1.00"))); } } Output: [1.0, 1.00] [1.0] true true That's ridiculous :) Especially the [contains](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#contains-java.lang.Object-) logic: &gt; More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)). *if and only if* - except if this type is subtyped, LOL. I know that there are many consistency contracts, but why even bother if the JDK itself is so inconsistent? It's just all plain wrong. A `Set` and a `SortedSet` are not proper subtypes according to the Liskov substitution principle, just as `java.sql.Date` is not a proper subtype of `java.util.Date`. 
* Tonnes of real-world business code is written in Java, they aren't going to suddently want to invest time/money/risk in rewriting it in trendy.io * Java and the JVM ecosystem is stable/mature and "good enough" for pretty much anything Main reasons for me. I didnt like this bit: &gt; Code written for a particular version of Java will perform without hiccups across newer versions This is almost always *not* the case in large real-world enterprise applications. Moving a version of java/your app server/spring/maven/whatever, nearly always involves work.
&gt; But RuntimeException / unchecked exceptions is not required to be caught so you can forget to handle them Which is OK since they usually signify programmer errors so should be caught during testing or severe conditions in the case of Error and subclasses which are mostly not recoverable.
Thanks for the nice words! And well, I learned too about this push/pull distinction inside of `flatMap()`
&gt; The single most irritating c# convention that pops up a lot is _ prefixing private fields. Tbf that started as a C++ thing, I think. (I used to work on a large Qt codebase which did that throughout)
it was a a common convention in some C++ shops long before, I think
This seems relevant: https://plugins.jetbrains.com/plugin/9696-java-stream-debugger
&gt; This is almost always not the case in large real-world enterprise applications. Moving a version of java/your app server/spring/maven/whatever, nearly always involves work. Name one alternative language / platform, where, in the context of "large real-world enterprise applications" your expression of *"nearly always involves work"* wouldn't be translate to *"that's utterly impossible"*. PHP or Python, perhaps? OK, "without hiccups" may be an understatement. There will be hiccups. But only hiccups, not breaking bones.
&gt; I think there was a misunderstanding because of the double negative in lukasenders reply. Ooops, thanks. My bad.
Regarding `Set` and `hashCode`, I thought you were referring to a contract placed on the elements within the set, which is what I was (irrelevantly) discussing. On the issue with `BigDecimal` and sets, isn't that a failure of `BigDecimal` because: final BigDecimal bd1 = new BigDecimal("1.0"); final BigDecimal bd2 = new BigDecimal("1.00"); final boolean t1 = bd1.equals(bd2); // == false final int cmp = bd1.compareTo(bd2); // == 0 breaks the requirement that `Comparable` is consistent with `equals`? &gt; A Set and a SortedSet are not proper subtypes I still don't see this. As long as the element type for a `SortedSet` satisfies the requirements then is there still an issue? In an ideal world we would have type systems that could capture these constraints and a compiler which could enforce them. Then, `BigDecimal` as it stands would be a compile error.
Same here using Reddit is fun browser and Firefox mobile. Android.
I like the article, there is just one bit I strongly disagree with: &gt; A great number of systems in blue-collar IT organizations are probably fine as monoliths. Such systems may even be in the comfortable majority. The benefits of microservices do not outweigh the costs for these systems. **It is wise to start systems as monoliths and grow them to microservices when necessary**. If modularity is always kept in mind in a monolith, natural module boundaries are far easier to identify. Modularity can be enforced within monoliths using simple Java package names before the time becomes right for distributed modules. The bold part. While I do agree that this would be the right approach in theory, my experience is that this never ever actually happens for two main reasons: * Even when a monolith was intended to be properly modularised from the start it almost never actualy gets done. A simple example is that most developers, even in a monolith that was supposed to be modular, use a sock-drawer approach and just stuff every REST controller in a .controllers package, every service in a .service package, etc. * Even if you do have a modular monolith it take a lot of time to split them up. I think we all have experience how hard it is to explain to the 'business' that you're going to spend 2 days refactoring something that doesn't add "value". How well do you think your PO is going to take the suggestion that you're going to take 3 iterations of 1 week to split up your monolith? And I think that's incredibly optimistic. So in practice I'm against the idea that you can split a monolith later. The few attempts I saw tended to fail half-way through and ended with some kind of distributed monolith monstrosity. 
Please disregard that sad, sad man and go on with your excellent contributions, both here and in github! (I'm going to copy paste part of your answer, because is pretty much the perfect answer to some replays) 
alright, here you go https://github.com/andreas1327250/argon2-java feel free to fork, contribute, do whatever you want please inform me if you find some major fuckup or performance improvements
Um, how about 1. Because it would be too expensive/time consuming Ppl still use Windows xp Ppl still program in languages that aren't taught by any college programs for so many reasons, yet the companies don't bother upgrading their software. 
That's cool that they are supporting kotlin as a functional programming solution. For a more detailed list of changes in spring 5 check out [here](https://github.com/spring-projects/spring-framework/wiki/What's-New-in-the-Spring-Framework):
If it is serverless where is the code executing?
&gt; I am using polymorphism in this method. It returns any BillingService, any class that implements it. public BillingService getService() { BillingEnum billingEnum = BillingEnum.parse(command); switch (billingEnum) { case PRE_CALCULATION: return new BillingPreCalculation(); case CALCULATION: return new BillingCalculation(); default: throw new IllegalArgumentException("The service does not exist."); } } Am I missing the polymorphism?
The converse is, how possible is it to build an Enterprise out of bits and pieces of logic strewn about.
Thanks for your nice words, I appreciate it. Hey, no worries about that other comment. I take everyone seriously, because even if the account is now deleted, perhaps my answer convinced them to be a bit more positive in their social media lives... And there *was* a slight 0.1% chance that a follow-up answer would point to something actually interesting ;)
In the cloud, of course. It doesn't count if it's somebody else's server.
That's fine, just pointing it out for you to fix. Like you said, nobody's perfect.
&gt; Regarding Set and hashCode, I thought you were referring to a contract placed on the elements within the set, which is what I was (irrelevantly) discussing. Hmm, yes that's what I meant. But you were right. My claim was inaccurate. While the contracts are interdependent, `Set` is not required to depend on `hashCode()` &gt; breaks the requirement that Comparable is consistent with equals? That's not a requirement, [but a recommendation](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html): &gt; It is strongly recommended (though not required) that natural orderings be consistent with equals. So, even if `BigDecimal` is weird and warns about being put in `SortedSet`, I think this is a design flaw, not an implementation problem. &gt;&gt; A Set and a SortedSet are not proper subtypes &gt; &gt; I still don't see this. As long as the element type for a SortedSet satisfies the requirements then is there still an issue? Then, why does `SortedSet` return true for an element for which there exists no element in the `Set` for which `o.equals(e)`? `SortedSet` breaks the contracts made in `Set` and the use-site cannot know this if it expects a `Set`, but thanks to subtyping, a `SortedSet` is passed in. &gt; In an ideal world we would have type systems that could capture these constraints and a compiler which could enforce them. Then, BigDecimal as it stands would be a compile error. Oh yes, absolutely. In an ideal world, we'd re-implement the collection APIs from scratch, too, keeping in mind that not every type should be an `Object` (with identity, monitors, and equality checks)
Yeah, "serverless" is a dubious term, as there are clearly still servers, (VMs, and containers) involved in executing the function. However, we don't have to manage the servers... (hence "less" ops!)
&gt; not every type should be an Object Going off-topic now, but Java would be immeasurably improved if `Object`, as a base class for everything, were removed.
Exactly what I need, accessing it in and out of drive
Don't. Use an actual source control tool like [Git](https://git-scm.com/) and push your code to [Github](https://github.com/), [Bitbucket](https://bitbucket.org), or [Gitlab](https://gitlab.com/).
This works fine unless you're constantly switching between computers and you want to keep your non-commit-worthy changes too.
I'm doing JavaEE green field development. Why? Because it's the right choice: reasonable performance, amazing tooling, repeatable deployments, high availability, and it's incredibly easy to modify. No other language comes close. No, not even Scala, which is beastly to maintain. Yes, you have to maintain Scala. Business needs change. Regulatory changes happen, which require code updates. And modifying Scala is painful. 
branch and commit
Node.js is not a language.
Totally agree. We have a project with about 20 microservices and 1 monolith. There are plans to split up the monolith... for about 1 1/2 years now.
I wasn't aware anyone thought java was retiring 
Commit and squash
Yeah man, everyone is switching to nodejs Edit: it was a joke, people
precisely.
`@NotNull` and `@Nullable` are not compile time errors. They're static checker hints. Javac will ignore them.
Is Webflux supposed to replace MVC?
Sure but error-prone, findbugs, pmd, checker framework, etc. will enforce it at compile time.
Articles like this just raise my blood pressure. Let's take 9 random people and ask them to comment on the state of the Java ecosystem. Of course, let's not ask 9 people who might actually know anything about it. As a simple data point I clicked on each of the links of the websites of theses 'executives' who are (apparently) "familiar with the ecosystem". Aside from Liferay the remaining eight web pages mentioned the word Java precisely once (that would be Andela a recruitment company). How precisely do these people know squat about the Java ecosystem?
No, it's complementary (you can configure a Spring Boot project with one or the other). I suspect that webflux will be a niche thing. It's a powerful tool for certain use cases, but completely unnecessary added complexity in others.
Shhhh! Reactive programming is the solution to every problem ever! (I agree with you, but don't tell anyone)
Lol Java is backwards compatable "without hiccups."
You don't provision a server, you just provide code. Hence the process is serverless for the customer. That's like complaining about people who say that there isn't any code, because they used a couple of annotations.
&gt; Despite it's industry age You serious? 
Java has a reputation for not deprecating anything.
DUDE... Don't... Over**react** ;)
&gt; Java has evolved into a functional programming language Err, no
sql and java are very different languages - i know that you've managed to marry them, but assume there was a shotgun involved my port is open source, though unmaintained. i also made no attempt at parallel streams (i'd need to spend a fair amount of time thinking about what a parallel stream means in the context of coroutines and i wasn't willing to make that investment till i found a use case) https://github.com/nqzero/kilim-streams if you're interested in coroutines, check out [my fork of kilim](https://github.com/nqzero/kilim) which is lambda friendly and (in some regards) easier to embed than quasar 
Should better be asked in /r/javahelp. Still, that is a design choice that many languages share. It avoids implicit data type conversion. Integer arithmetic is generally faster than floating point arithmetic and thus the choice to have int/int yield an int has been made. This choice can use a completely different approach internally that performs lots faster than floating point arithmetic would.
It is a tip of Kotlin integration.
Doesn't serverless mean there are no constantly running servers (like Tomcat constantly running)? Instead your code is started only when there are request &amp; stopped as soon as possible. Not familiar with this stuff
&gt; This choice can use a completely different approach internally that performs lots faster than floating point arithmetic would. I know this isn't Java, but it's pretty illustrative: https://godbolt.org/g/5uhgjz Instead of a single div in the integer version, a C++ optimizer can turn it into a bunch of instructions that end up being faster than one div. Of course this can be a problem for decompilers, and there's [an article with some explanation](https://zneak.github.io/fcd/2017/02/19/divisions.html). There's also a [paper](https://gmplib.org/~tege/divcnst-pldi94.pdf) on this technique.
Does it make sense to make this choice for performance considerations when most people would expect int/int to be a long or double? Edit : float or double
Only if you enable those tools. They're optional.
Why would anyone expect it to be a *long*??
Ctrl-Y should in fact work for eclipse if it's set to the default key bindings. But there should also be a redo entry in the dropdown menu, and it might even show the hotkey.
When you divide integers in binary the integer result plus remainders is more evident. So when you divide int/int in some statically typed languages, you get back the result, which would be the type of the two inputs, and if you need the remainder you ask for the modulus. Think of int a/int b as short hand for: func divide&lt;int&gt;(a, b) Which further translates to: int divide(int a, int b); Edit: I didn't mean to reply to your comment. Sorry. You are right.
… even when it should. 
Self contained API (not necessarily web). For isntance, you can have a library, app, binary, or web app that's basically an independent program that takes requests for info (params) and returns back values. When you do it this way, it doesn't matter if it's an local app, a webservice, or a library. You can always wrap it later in a thin layer of interface code that turns one into the other (examples: a library into a webservice or a webservice into a local app) Edit: you get there by keeping areas of the monolith or mocroservices independent, not too many dependencies or interdependencies across layers.
Correct, which is exactly what the post refers to. The ability to optionally deal with the problem at compile time.
Well it's the euclidean division and modulus is the remainder. It's what is written when you do a division on paper without knowing about decimal numbers.
I guess we just have different opinions on what is compile time. Seems I have a stricter definition.
Thanks. 
What the hell is up with scrolling up and down on that site? Scrolling feels overly sensitive and un-natural.
Ctrl+shift+z should work too.
Click the 'Edit' tab at the top near where 'file' is and select redo. The shortcut for it should be to the right
It helps to know that processors have two types of math units: * Arithmetic Logic Units (ALUs) that do math on whole numbers and bit-shifting. * Floating Point Units (FPUs) that do math on floating point numbers. Which is why they have different performance characteristics.
Well as error-prone replaces javac with superior functionality such as said null enforcement it seems very succinctly to fit into "compile-time", but I'll admit that findbugs, pmd, and checker are within 1 second post-compile so don't fit the description. They are both miles away from runtime, though.
You mean like why doesn't Java internally promote x and y to floating point numerics then return the floating point result? Because it wasn't designed that way. It could have been, but it wasn't. Purely integer division has advantages so it was built in to Java to let you.
http://www.oracle.com/technetwork/java/embedded/javame/javame-sdk/downloads/javamesdkdownloads-2166598.html
ELI5?
I wish we had something better than Chronon.
Shoo meme developer
Thanks. I don't mean to be a bother but do you know if I could put anything I create with JME to a flip phone? Seems like a good device for a starter like me.
many comments below regarding compiler optimizations etc. tbh i doubt the language designers designed it that way because of compiler optimizations. my best guess since i have not communicated with the original language designers is that in all likely hood it was designed this way with this general principle: "any arithmetic performed with the same type for the operands will yield a result of that same type". so this is not exclusive to int/int .. int*int, long/long, double+double will all yield the same type as the operands. why is it this way? any other way would seem .. illogical. what else would a int/int yield? 4/3 yielding a double could be argued to make sense .. however 4/2 yielding a double wouldn't really make any sense. so what does make sense for the general case? same type as operands .. makes sense.
Using SLF4J, people working with your project can choose from multiple logging frameworks (including java.util.logging). 
&gt; The JVM serves as the foundation of a lot of cool things like scalability, performance, and concurrency. It’s obvious the developers been thinking about the JVM for a long time.
Wow the quality Of this article. 
Ehh it almost doesn't even matter. In the real world for things that matter, like with money you are using biginteger and bigdecimal. ints are going to be used for things like array indeces, where when you divide them, getting an int back is preferable since which way it rounds won't matter. While if you need it to matter you'll just cast.
Java borrows a lot of language ideas from C/C++. Division of integers is just one of those conventions. It was probably a deliberate choice to make it less confronting for C++ programmers to transition to Java. 
It's also a possibility that the original spec didn't have the compiler technology at the time to make it feasible across multiple platforms. I know there's been a few things I've asked about in Java that I've been given that reason from Java expert group members 
I was about to post this exact comment. Even with the rise of C#, a sister language if you will, Java still hasn't come close to being forgotten.
I Googled it for you only because I expected the JME to be a non-free option. I was curious enough to dig it up. I am a Java developer by trade but I'm not overly familiar with the JME. I suggest editing your post or making a new post. Explain what it is you want to do or learn. It seems like your actual question or need or interest goes way beyond needing a download link. Are you looking for a tutorial? Looking for advice? Got an idea to toss around? Keep hacking and inventing and trying things. I'm not trying to be rude or drag you down. You'll get farther and have more fun if you get specific with what you want to do and what you need help with. HTH.
To tell you the truth I'm trying to learn using a Java app. I'm currently looking into modding a flip phone with a game. Nothing fancy just a simple little game I could download onto a flip phone. So basically my goal is to make a small game and put it onto a flip phone (not selling it, just on my personal flip phone). Also thanks for the long response, people normally don't help me as much as you have been.
I suppose it's nice to keep types consistent. If you want float you world cast your variables as so.
&gt; "good enough" for pretty much anything Except for high load. You cannot write really fast http server in Java, you have big memory issues developing a database in Java. 
Why bother with the phone? If your intention is to learn Java (not quite sure what "I'm trying to learn using a Java app" means?), you can download the JDK for free and make applications for your desktop/laptop.
A great response can be found here, by the author of log4j and slf4j: https://stackoverflow.com/questions/11359187/why-not-use-java-util-logging 
Cassandra is written in java, that's a db. There are also a dozen performant production read http servers 
eh, idea treats project different than eclipse. I have multiple "projects" open in the same editor window by adding the pom of other projects in the maven window.
Cassandra uses offheap memory which looks more like C then Java, and has lots of problems with GC. None of these http servers are comparable to ngnix. 
I'd rather not live on the streets with ticks. 
I'm just learning from the app. I know that I could put it on PC I just think it might be kind of cool to put it on a flip phone so I can take it anywhere with me. I would put it on my PC too but why not both?
I found out in Linux, for me it defaulted to ctrl-shift-z, not ctrl-y.
A couple of reasons: 1. What most people in this thread have been answering: Speed. 2. The concept 'integer division' is useful for various things. Let's say int/int produced a double.. what kinda syntax do you propose if you actually need integer division? Backslash? Ugh. For plenty of jobs, integer division is what you would 'expect'. 3. Java copied tons from C, in particular such that algorithmic code (such as a crypto library) pretty much works verbatim. One can question the wisdom of this today, but back when java got started, it seems rather obvious that the C-like syntax has helped java reached the popularity that it has. 4. Consistency: int*int will fit in a long, but might not fit in an int. So, do you define int*int to be long? Except, 99% of the time when people multiply ints the expectation is that the result also fits in an int. So, you have 3 options: [A] `int*int` makes int, but `int/int` makes double. This is weird and inconsistent, and while it might fit the most basic 'eh, it's what people expect', SOME people expect different things, and by making things work in a consistent fashion, it's a lot easier once you're used to the language. B and C are consistent (B is: Go to the type that is most capable of encompassing the result space, and C is: The result is the same type as the types of the inputs). This is a bad option because it lacks consistency. [B] `int*int` makes long, `int/int` makes double. This means you need separate syntax for `int*int` makes int, and `int/int` makes int, and the `int*int` makes long is slow AND unexpected. [C] `int*int` makes int, `int/int` makes int. This sounds like the best choice to me and its the one java made. 
&gt; most people would expect int/int to be a ~~long~~float or double? I think this is your main misunderstanding here. If your sole exposure to computer arithmetic comes from a calculator or Excel or Javascript (all languages where there's no concept of an `integer`), then maybe you'd expect this. Otherwise, if you've spent any time in a programming class or context, you assume `int` / `int` == `int`, and are shocked when that isn't the case.
Enjoy your inferior java salary
Each intelliJ window will have only one project. If you go to file -&gt; recent projects, your other projects should be there. You can also click close project to see the home window.
I don't think people are saying java did integer division this way for performance reasons, or if they are, they are wrong. I think the point is that a major reason int/int = int became canonical in programming was for performance reasons (well, for many different reasons all related to mapping to a particular assembly instruction/CPU structure, performance included.) This convention being well established when java was designed, java went with it.
Java has pretty strong static typing. By Type System rules alone, you would expect an int divided by an int to be another int. 
Someone has gotten eclipse null annotation analisis to work for real? I disable it because gives dozen of bogus errors like: if (this.field != null) { doSomething(this.field); //error, this.field could change uder your feet } 
This. But a Intellij project is an eclipse workspace. 
It's just that JME is a very cut-down version of Java. If your intention is to eventually write desktop/server or Android applications then you may be harming your education by picking up JME first.
They way I look at it you're saying I'm challenging myself. Look, I don't know why but I have somewhat of an obsession with flip/slide phones, or dumb phones in general. I don't know why but I do. So I wanna put a game on one. I'm just looking for advice, not torture about the software I wanna consider using. Does normal, stock Java allow me to do such a thing (putting the game on a dumbphone?).
Shift+a key to bring up global prompt, search for idea.max.recent.project. Or Help-&gt;Find Action-&gt;Registry then find idea.max.recent.project. 
&gt;Does normal, stock Java allow me to do such a thing No it doesn't. Absolutely fine if your passion is flip phone development, I was just making sure you weren't trying to start out your professional Java career by learning skills not useful in 99.9% of Java development shops. Sounds like fun actually, I still remember being mesmerised by Java games on my (then) very advanced [Motorola SLVR](https://en.wikipedia.org/wiki/Motorola_Slvr#L7). Good luck!
**Motorola Slvr: L7** The L7 was released at the same time as the L6 (early 2005), but the L7 is more professional, and is one of a few non-Apple branded phones released featuring iTunes support, allowing the user to play up to 100 downloaded songs that are stored on the phone's removable microSD card. It is known for its dedicated web browser and web video downloader which critics have said is the main feature of the Slvr. The Slvr L7 also features Bluetooth connectivity, a digital camera with 4x digital zoom and has a speakerphone. Carried in the United States by Cingular Wireless, Metro PCS, and Cricket Communications, and carried in Canada by Rogers Wireless, it superseded the earlier Motorola ROKR E1, which was withdrawn from the market due to lackluster sales. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Thanks Just a note, not necessarily my passion just something that sounds like a good way to start off learning. Of course I know practically nothing right now so this might not be the brightest idea but I'm gonna try. Thanks for your time
It's not a problem, it's a feature, I came from Eclipse, grew used to IntelliJ and now I love it. I have tons of small test projects and projects I rarely need to touch that I sometimes have to open for few days, work on it, develop some integration test based on this or figure out an issue, and then never touch that project again. IntelliJ window works like a nice sandbox where I can create configurations, import other projects and sources from 3rd party, and when I'm done I can just delete that project or set it aside for the next 2 years I don't need to touch it, with all it's meta files and configurations and "done"... open the next project with fresh view, nothing left behind from the last project.
Doesn't mention one of the reasons which has kept me using Java: it has IDEs which are more powerful than for any other language there are, especially when it comes to refactoring and such. JetBrains is heading in a direction to change this but IDEA is still far ahead of others they have. In IDEA refactorings almost always work as expected but in other languages there's always weird edge cases where they don't and it's become really frustrating having used them in Java that long.
Have you tried Undertow?
Who are these most people? Not developers, I'm sure.
It's not a bogus error. It could change under you in a separate thread. Assign to a local variable, test and then use and you'll be fine.
&gt; most people Who are these 'most people'?
I was confused when I first used Python and JavaScript because they default to float. Maybe this is where op comes from.
it depends on your definition of high. for most people's high, it is good enough The codebase I work on (large enterprise API gateway/integration service based on a popular Java-based ESB, banking sector) scales *really* well - We do use a few tricks though, such as some direct (offheap) memory, and a lot of JVM tuning. A reasonable pool (16 active instances) of those is handling ~800 million transactions a day. Thats a sustained ~600tps per instance. Which for something that is doing routing, logging, security and validation, XSL transforms, REST-&gt;SOAP, XML-&gt;JSON, schema validation, various callouts, etc... is really very fast. Definitely "fast enough". You wouldn't use a java application server on its own to host static assets, for a large website, though, for sure. For that, sure, you would reverse proxy it behind nginx, and have that serve or cache the static assets.
IDEAs debugger is also nice, too.
Welcome to uh ...1990?
It's not so much about constantly running servers, and more about not having to provision and manage servers -&gt; https://aws.amazon.com/lambda/faqs/#general Although we don't typically use Tomcat with serverless, you certainly can try and keep the function "warm", which means that it stays passively available (running within a Linux container) without the need to initialise to serve each request. You're only charged for the function/request execution time though
Its different in linux
If that's what you're wanting to do, then why are you storing them as `int`s instead of `float` or `double`?
Nice to see that they've dropped support for Portal and Portlets, just as RedHat/JBoss have done. Bane of my working life, Portals...
&gt; sql and java are very different languages - i know that you've managed to marry them, but assume there was a shotgun involved That would've made my life easier, I guess. I chose duct tape. Thanks for those links!
The `ReferencePipeline.flatMap()` implementation looks like this: try (Stream&lt;? extends R&gt; result = mapper.apply(u)) { if (result != null) result.sequential().forEach(downstream); } In the example from the linked bug, `result` will be an infinite stream `Stream.iterate(1, i -&gt; i + 1)`, which is pushed "downstream" (i.e. to the `limit()` operation) using `forEach()`. Because of this, the stream's terminal operation `forEach(System.out::println)` never actually terminates, it will simply iterate the flatmapped infinite stream forever.
It is technically correct, but then all fields are nullable because you can change them via introspection. At least there would exist a setting to disable it. It is not reasonable and a hurdle. I'd expect it if the field is volatile. This way I'll continue with the old findbugs.
I'd whish that Spring would introduce a DSL like that of Guice instead of introducing something like text files ("spring.components") to list all classes to be handled by spring. Guice's `bind(x).to(y)` is concise, readable and fast.
Why would most people expect that?? Anyone coming from a C-family language wouldn't.
For future reference there is also local history which gives you all the changes to the file. Right click on the file to get to it. 
In some languages backslash is integer division.
You must be new around here. [People have been claiming "Java is ded!" for like the past 20 years](https://www.google.com/search?q="java+is+dead"&amp;tbs=cdr%3A1%2Ccd_min%3A1%2F1%2F1992%2Ccd_max%3A1997). ^And ^will ^still ^be ^doing ^so ^for ^the ^next ^20 ^:D
Try, Ctrl+Shift+L It should open a window with all your keybindings
Yup. But, if we go with the [B] option, you also need to conjure up an operator for `int*int=int`. Also, backslash as integer division isn't 'expected either', so no matter how you slice this chicken, someone needs to read a manual before they get to use the language. If we're going to posit that as a requirement, I'll take the java way any day of the week. 
Am I the only one who finds the title a bit misleading? I was expecting the article to be about why the JVM is a better choice for serverless (or Lambda in particular) than other options, or at the very least elaborations on common concerns about Java's alleged disadvantages in this field. It seems to me this is more like tips on how to use Java correctly on AWS Lambda, not so much about why it is a good choice in the first place.
&gt;Am I the only one Probably not
Thank you! I was indeed feeling a bit lonely :D
Performance aside, it makes some number trickery possible when the result of the division is an int as well. For instance, when you have a flattened 2D array (an array representing a 2D grid), you can convert the indexes to XY coordinates doing this: // Our 9x9 grid, rows laid out one after another String[] grid = ...; int index = 42; // Convert running index to XY coords int x = index % 9; int y = index / 9; This is just a single example; I've used the division trickery plenty of times, especially in game programming.
OP and his two friends.
&gt; sock-drawer approach Seems like an argument for "package by feature, not by layer".
I recommend that you first check if community edition covers your needs, and if it does, no need to convince anyone anyway. Now assuming that you checked it, and decided that you need the Ultimate Edition, here are some arguments: - It is faster than Eclipse in general - Provides better tools for analysing your code - Has better refactoring tools - Makes management of common settings easier, which helps if you are in a large team - (personal opinion) Generally has higher usability, thanks to it's immense amount of keyboard shortcuts and configurability All of these factors result in better developer performance, saving the company money. So I think it is a good investment. But as I said, check if community edition covers your needs first.
Definitely, but it was just one example. Hopefully with Java 9 it becomes easier to enforce modularity. 
Closed a popup, another popped up, closed the page.
FYI: IntellIJ CE is free to use. So you can always just try it out and see if Ultimate has features you miss.
* integration * linting * bug detection * productivity * speed * commerical support (I am waiting for several years, that as it seems a simple bug fix to be merged in eclipse) * there are several other features, but you can't overload the management with those words. this is a no brainer if you ask me. A developer is much more expensive and if he is just a tiny bit more productive then it is already totally worth it. It is just simple math, no need to convince them.
https://www.jetbrains.com/help/idea/opening-reopening-and-closing-projects.html
&gt; better refactoring tools Can you give me examples, what refactoring tools are better? 
&gt; productivity What exactly makes you more productive?
You don't need to convince anyone to spend money. If you don't do JavaScript (or web frameworks), you can use Intellij community edition that is free to use (even for your company, it's open source and apache 2). Just look at [the comparison matrix](https://www.jetbrains.com/idea/features/editions_comparison_matrix.html) if you really need ultimate.
What I like about the ultimate edition is that I very rarely need to use a tool outside of it.
By the way [language injections](https://www.jetbrains.com/help/idea/using-language-injections.html) are a cool feature that Eclipse doesn't have.
The languages I'm thinking of use * for integer multiplication. It's only division that has the integer/floating point option. They do, however, have exponents in the form of 2^4.
For some reason people like SLF4J even though it doesn't really have much of a reason to exist. A best practice is to write your own simple log wrapper classes so the all the import statements refer to your classes. That way you'd only have to change your code in one place to implement a different logging framework.
You may want to try NetBeans. It is also free/open source and IMHO better than Eclipse. NetBeans is also soon to become an Apache project. http://incubator.apache.org/projects/netbeans.html
The result of arithmetic on various types in Java takes the type of the "best fit". For 2 ints, the "best fit" is an integer because the result will always fit in (or be squeezed into) an integer; it doesn't look at whether you're adding, subtracting, dividing or multiplying. Integer.MAX_VALUE + 1 = Integer.MIN_VALUE, not a long. If you change one of the ints to a long, the result is a long: Integer.MAX_VALUE + 1L = 2147483648L. If you change one of the ints to a double, the result is a double, etc. I guess it's easier for the compiler / processor and produces the least amount of surprises for developers. If you would do x/y * y and there's a double involved, there is no guarantee that the result equals x.
Not OP but * Postfix code complete * Search for symbol - such as method name * Git merge view - see your copy, the server copy and the merge all side by side * In debug view the values are shown inline * Live templates * Their "smart auto complete" that narrows down autocomplete to only the types that make sense * Typescript/Grunt/NPM integration * Code suggestions * Consistent dark theme * Can do all the mySQL things I need without needing another tool (e.g. MySqlWorkbench).
I buy my own tools. It's under my name, and they come with me when I change job.
Wow I didn't even know about this! That's great!
Maybe have a look at their blog. For each release, they make an article where there are details about this kind of feature. For example, see the [2017.2 public preview](https://blog.jetbrains.com/idea/2017/06/intellij-idea-2017-2-public-preview/) one.
Same here, easier than having to convince management or anyone else to buy it for me.
that would be inconsistent; if you're going to go with the notion that the result type of an operation is the most logical type that can contain all possible results as best as possible, then `int*int` should produce a `long`. I bet in these languages you speak of, that distinction does not exist, but it does in java. 
Is it allowed to install IntelliJ on more than one computer (but for a single developer)?
As others said, try the community edition. You can also use CE plus Webstorm if you want to do Front-ends (mainly Js). Webstorm license is pretty cheap. I have the perpetual Ultimate license. I see it as a way to support the devs of such a great product. Maybe I would use CE if I was contributing to the open-source more. I used to be an Eclipse person, until my company recommended switching to IntelliJ. Apart from standard tools, it is really good at sorting context help in a way it always recommends to use something that is perfectly relevant for the situation. Same with refactoring - it even recommends names that I use like 90% of the times. I highly recommend this recently updated plugin: https://plugins.jetbrains.com/plugin/4455-key-promoter With this plugin, I became very quickly productive.
Yes. "With the new subscription model started November 2015, you can run multiple personal licensed copies at the same time (like on laptop and desktop for remote debugging client/server apps)." -- https://intellij-support.jetbrains.com/hc/en-us/articles/207241005-Using-IDE-on-different-machines-and-operating-systems-with-the-same-license
For a personal license - yes: https://sales.jetbrains.com/hc/en-gb/articles/206544319-Can-I-use-my-personal-license-on-multiple-machines- (I would assume this means you can't do that with commercial one, but I didn't dig too far into the FAQ / EULA )
Why write your own when you can use SLF4J?
&gt; What are the reasons you prefer IntelliJ IDEA over Eclipse? 1. It doesn't crash all the time. (this was happening a lot before I switched) 2. It is much faster for things like refactoring. 3. My files don't get out of sync. &gt; What are your favorite features? Built-in code coverage, better refactoring, searching, regex support. &gt; How do you convince management to spend money for IntelliJ? You don't need to, community edition is perfectly fine. I've been using it for a couple years now, and I do web development without the bells and whistles.
Have you even tried it? The community edition is free so give it a go. I don't see a single other reason than "I like this IDE better and feel more productive using it" which is hard to say if you haven't used it before. It costs like 40 bucks a month for a single developer for business. How much convincing is needed at that price point? Or, don't even make this thread. For an individual developer it costs less than 15 bucks a month. It will cost you more to read through these responses a click through the links.
Emacs is a text editor. They’re looking to adopt an IDE.
I know IntelliJ and feel much more productive with it, but I want to make a compilation of reasons why IntelliJ is worth it to convince the management to buy it as a general tool for the whole company.
If you code in multiple languages you might need it. Half of our prjoects are PHP, half Java. Ive tried intellij ultimate for PHP development - but it turned out to be pretty slow and bloated for my taste so I reverted to komodo for non-java projects.
I don't. I just buy my own license, so I can use it at work and on my personal projects at home, and not worry about losing my license when I change jobs. If you have a personal license over the long haul, then it drops to $89 a year. That's two or three fidget spinners, or whatever crap people would otherwise be wasting their money on these days. Look, we do this for a living. For most of us, it's a life's vocation. And compared to society at large, we're paid on the far upper-hand of the salary spectrum to do it. So feeling like you have to be beholden to an employer for access to what's probably the single most productive tool in our profession... that's crazy. It's like a master carpenter, not having a hammer in his own home garage because, "*What? Who's gonna buy it for me?*". My current employer has actually started provisioning commercial licenses for IntelliJ, but I still haven't requested one. Because I don't want to discontinue my personal license, and have to go back to the "new customer" rate when I inevitably change jobs in a year or two. But anyway, as others here have pointed out, you can probably get by with Community Edition if the alternative is Eclipse or NetBeans. The support for Spring and other frameworks is a bit overrated, IMHO. If it weren't for the Chronon Debugger, then I probably wouldn't have a license at all.
Code I don't write is code I don't have to maintain.
But the CE doesn't support Java EE?
That sounds like too much work to save $150 a year for you. Just ask and if they say no, buy it yourself. If you are concerned about tooling, that's a nice thing. That being said, there is nothing inherently better about IntelliJ if somebody is used to their own IDE or editor so there is no reason to introduce some guide of guideline for what software people use to write code. That being said, judging from the interface used for obtaining the company license, you don't buy N licenses from JetBrains for your company. It looks like you register an account there to which people then sign in with your company's email or something and you can get your company license. The company then gets charged for whatever number of developers are using it. That means, you can make the claim that you believe it's a better tool that you (and possibly your colleagues) would like to use. Either they will or won't, there's no waste.
The reason to switch to paid for myself was plugin support for JS flavors (Angular) and (better) Spring support. For a company with 30+ IT folks, paying for a lot of Microsoft tools, the cost for IntelliJ was insignificant, so they happily paid. I've since bought my own license, as I do a lot of work in my free time. 
Oh dear, I've been using IntelliJ and MySQL WorkBench together for up to 10 years... Thanks to you, I have just found DB Navigator. Thank you!
Eh? Front end web developers are the lowest paid by far you meme because literally anyone can replace you. Even women.
Sure it does. Java EE is just Java. Does it support some additional JavaEE features/code refactorings? Maybe not, but you can code JavaEE in IntelliJCE just fine.
In all fairness, it's because it's bundled with every tool under the sun. I find myself in Netbeans a lot just cause it's not quite as bloated. Don't get me wrong, I love IntelliJ - it just isn't perfect.
I don't really know, I don't use Java EE. I suppose you will have java language support, but not all the helping (refactor, intentions, inspections...)
You can combine that with SQL language injections and get completion and linting for your SQL queries.
Once you connect it up it'll also give you autocomplete in your SQL files based on table schemas.
The title may have changed, but it reads: "Why Java and JVM is a **Good Choice** for Severless Computing..." It didn't say "Better Choice" or "Best Choice" I did however thought the same thing as you, but it was my own bias influencing the comprehension and not the title itself.
The CE doesn't allow you to work with Application Servers inside of Intellij (Start/Deploy/etc), if I remember correctly.
you could look at phpstorm....? for basic stuff it's not necessary, but shines for complex projects (just like intellij for java stuff). having a more consistent interface between projects helps me (I took switch between java and php a lot).
&gt;And modifying Scala is painful. Can you explain?
Why the downvotes? What is the opinion of Netbeans? I rather like it and think it deserves attention.
&gt; phpstorm yeah - Ive looked into that as well. my understanding was that it phpstorm is a cut-down version of intellij ultimate. Performance was inadequate for my taste.
Because I don't want the extra dependencies maybe? 
And when SLF4J changes their API you'll have to update the logging code on every file in your project. Good for you.
I do the same.
It has excellent out-of-the-box integration with a large number of tools/products (aka. bloat). Specifically, how has this been detrimental to your development process?
Some reasons to prefer Eclipse: * It is free, no need to buy anything or keep up to date on paid licenses and the like. * It is fully open source, unlike for IntelliJ where only its Community Edition and various plug-ins are open source, as far as I can tell at least. * It has a foundation with support from many different corporations, such as IBM, Red Hat, Inc., Ericsson, SAP and Oracle. * You don't have to worry about (paid?) promoters for certain alternatives to Eclipse on reddit and elsewhere :). 
The community edition is free and will be very useful for most java development. However if you are using Spring or JavaEE there are some extra integrations that only come with the commercial version. As a Spring developer I sprung (pun intended) for the commercial version, but I don't find myself using the features that much. However it is nice to know where your injected beans are coming from. I think what everyone else is saying is good advice: see if the community edition works for you, if not, buy it yourself so you can use it at home, at your next job, etc.
I kind of get a tiny bit of an impression that there may be certain promoters, in theory paid, that somewhat prefer certain tools, so to say.
OP Asked about intellij idea vs eclipse, not netbeans. This is like asking if you should get a honda or a toyota after having done your research, and then some VW nut comes in and says you should get a GTI.
Probably because it doesn't answer OP's original question.
That's perfectly valid and no one is stopping you personally from writing your own logging facade framework. I think most people would rather use a mature, proven library like SLF4J instead of reinventing the wheel. This way I don't have to change my code **at all** to use a new logging framework.
Correct. You can still administer your application server from command line or set up tasks to do it via your build tool, gradle etc.
OP also gave no compelling reasons as to why one should be used over the other. That is, is cost the only thing to consider here? If so, perhaps Netbeans had been overlooked. It could be also that Netbeans is not the right product because of some reason not given. In a straight up Java environment, it's (IMO) great. But once you start doing DB stuff, I don't know (I don't do that).
That's not quite a useful IDE then if you have to implement boilerplate for web applications/services and their deployment to your servlet container/AS entirely by hand, unless there are some community plugins which allow to do so. This is also the reason I went entirely with NetBeans, because my employer has decided against purchasing IDEA licenses.
That's not his job nor the point of this post though. He wants to know about intellij vs eclipse. Not how the 3 IDEs stack up.
not "cut down", just tailored for php (as rubymine is tailored for ruby, etc). I've not noticed any diff in performance between intellij and phpstorm, and I run both daily (and have for the past several years)
1. I won't update a dependency like SLF4J on a project ever. Unless there is a security issue or a massive performance problem that can't be worked around slf4j-api will be locked at whatever version we started the project with. 2. SLF4J has a pretty minimal API and it's highly unlikely they'd change something like `Logger.info()`. If on the off chance the developer did change something hopefully older methods would be marked as @Deprecated so I'd have a few cycles to change my code.
A little variation of my original question: What features of IntelliJ are not existent in Eclipse?
Correct, the point of this post seems to be "do my research so I can have my work pay for intellij for me".
How's their support of Groovy these days? Or Scala?
Developers should provide their own tools. Maybe some of your teammates want to use Eclipse? Why force them to use IntelliJ? It irks me to no end when I hear of a company that forces a particular IDE on developers. We are professionals so should be able to pick the tools we use, and purchase them ourselves. I buy my own IntelliJ license since that is the IDE I want to use.
I don't add a dependency unless I really have to, I am not one of those people that add a 4 meg dependency to call a single method and even I use slf4j, it is 41K, hardly worth worrying about.
As a general tip for everyone else reading: JetBrain offers an education license for all their products for free if you have a valid university address. https://www.jetbrains.com/student/
Well, I cannot name a comparison, since I haven't touched Eclipse for quite a long time now, but basically: - Not directly a refactoring tool, but flow analysis is something I use a lot when refactoring, to make decisions - It is better at generating delegates - When you add/remove annotations on an interface method, you can reflect this to its implementations - It is pretty practical to extract method objects - In many cases, it suggests refactorings automatically (like converting lambdas to method references, rewriting loops as streams etc...)
To be clear: I don't want to force anyone to use a certain tool. To the point who pays for it: I think that the employer should pay since it is his responsiblity to provide the means of production. Buying it as an employee is only the path of least resistance.
Nice new functionnalities ! I'm always impressed by the efficience of Spring. Kotlin support is really awesome, but what really interest me is Reactor . I just complete their handson: https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/ , and it seems pretty cool. 
The fact that it takes 48 seconds to load for starters.
totally agree, but that's a far cry from saying "it doesn't support JEE"
Don't know about you, but I restart my IDE maybe twice a week. But, yeah. Get a SSD.
I have intelliJ installed on my VMs, macbook and Windows. No problems for me thus far.
You can disable any plugins you don't use.
&gt; I think that the employer should pay since it is his responsiblity to provide the means of production. I couldn't disagree more, a professional developer should be willing to provide their own toolset. 
This. I used to move between different sites/projects and had to always chase the PMs for licences. Sometimes the wait was months, so I just bought the entire dev suite for myself. (even though I mostly use IntelliJ only). Haven't had to chase anyone for 2 years now and I'll renew the whole suite again this year in a heartbeat. 
&gt; What are the reasons you prefer IntelliJ IDEA over Eclipse? It doesn't have that "building workspaces" bullshit where it would lock up my machine to run off with the fairies for 30mins.
That's what I thought as well, until I needed an ide which understood Swift 
&gt; What exactly makes you more productive? [ALT]+[RETURN] all the things!!
I mostly experience the slowness switching between projects, not starting the IDE from scratch. Yes, a SSD would be faster; however, then Netbeans would also be even faster. It doesn't change the relative speed and performance of the IDE as a whole. IntelliJ is a pig. Again, I don't mean to demean the sacred /r/java cow - I like IntelliJ Ultimate, it just isn't the right tool for every job.
That's the thing, I use the plugins when I use IntelliJ. I like the fact that I can mass refactor Spring Beans. But it doesn't mean that it's fast. Maybe it needs "profiles" so I can start up with #X plugins enabled for "day-to-day" work and then maybe a #X+100 plugins profile for my "refactor shit" work. Instead, I just use Netbeans for my day-to-day and IntelliJ when I need the extra stuff. But then that'd be 1 more feature to bog it down with, heh - the irony.
I am really interested by the new features of Reactor . I just complete their handson: https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/ , and it seems pretty cool.
+1 for cutting away marketing-speak
No. It doesn't matter, because Java has inherent overhead compared to C/C++ (or Rust): mandatory GC, lack of value types. (Speaking from my experience of developer of high-load apps in Java and C++ for last 10 years).
if fidget spinners cost more than 5 bucks I'm gonna lose my shit. 
Building workspaces..... *forever*
"High" means you need to reach nearly 100% of theoretically possible utilization of available resources.
Can any existing users tell me what the application server support is like in IntelliJ? With Eclipse WTP I can run large applications in application servers like Tomcat directly from my workspace (without deploying them at all). This saves lots of time during development. I've looked a few times at the IntelliJ docs but it looks like the only option is to deploy the full app.
it's refactoring &amp; code inspection abilities. 
If you're trying to influence code quality in your overall organization, then I would recommend attacking that in the continuous integration / DevOps instead. Trying to attack it through the IDE choice is a losing battle and ineffective. Also, you shouldn't expect that everyone will like IntelliJ as much as you; many don't.
&gt; I think that the employer should pay since it is his responsiblity to provide the means of production. But that's the thing here: You can get the job done without it. There is NOT a good business case for having it in a shop. It's not like .NET development on Windows, which you basically HAVE to have Visual Studio for if you're going to be productive. You can mutter about "efficiency" all you want here; any non-technical manager is just going to hear that you want to blow money on a yearly basis for something that you already have in the form of Eclipse, Netbeans, or even other choices like vim/emacs.
I've done it under linux and windows. I assume it would work the same under OSX. One warning is if you are watching a remote drive, file events may not be passed along depending on setup. 
What does git have to do with configurations? Is author assuming that people manage configurations for deployment in git? Is this a reasonable thing to do?
Does this article have anything to do with the cloud or does author just want to use a buzzword?
* IntelliJ has an extremely nice design that brings to the forefront what I care about and doesn't require you *(or at least, strongly nudge you)* to go into some odd "profile" mechanism to change the whole layout just to do certain tasks. * IntelliJ has support for full-stack development out of the box (from database, to back-end with Java/Scala/NodeJS/etc, to front-end) without having to learn the nuances of each plugin because there is a design consistency that runs across all of the plugins. * IntelliJ gets very frequent updates * IntelliJ's shortcuts feel like they make more sense, to me, and it seems as if much more thought has gone into its UX. As for convincing management. Either they're willing to spend money for developers or they're not. There is usually no in between. Simply state that you need it to get your job done and be much more productive. If that's not enough, then they are already against spending any money on your position beyond the basics (a computer). A good manager will know that you don't typically get something for nothing and salary + computer doesn't always cut it. I use Linux to be much more productive. It happens to save them money (on Windows license), but I use it because it helps me get my job done faster and better. The same is said for IntelliJ over Eclipse, for me.
You're thinking about it the wrong way. The decision between using `/` or `\` is whether you want decimal values or the closest whole number, not what type you want. Or in other words, it is designed around semantics rather than the technical details about ranges for types. 
Yes, and where I hated Eclipse for it, because everything was a broken plugin, it works a lot better in IntelliJ. I use IntelliJ for coding, but also for building with the Maven plugin, version control with the Git plugin, database queries with the DB plugin etc..
Sure. That's one way of thinking about it. I posit that this has reached the point where it is no longer the obvious 'least surprising way'.
Also, download the trial and use it for the time period. When I did that with AppCode, JetBrains sent me a coupon code a few weeks in that basically dropped it to the second year price.
It's the best java IDE imo. I use it for all my java projects. I don't have any specific reasons why it's better than eclipse aside from the pure joy I feel not having to use eclipse anymore lol
I love it for MySQL snippets
When it comes to such investments, buck stops with the management. One thing management understands is numbers. So I used numbers, what is the minimum number of minutes that Intellij would have to save per developer to break even. Usually it is pretty low, once you put a perspective it should become pretty clear that Intellij is a steal at its price. ironically if you use the same logic, you will find that the approval process (meetings, forms, research) would be costlier than getting the license. Be careful about which numbers you give, if you say it helps with testing or something measurable, they would love to monitor it. You can also try analogies. Every company wants the best developer they can get, but stop short on investing in what enables them to be better. Think of it as hiring Micheal Schumacher to drive for you, but giving him a Fiat Punto to drive. Gets the job done, but are you utilizing him correctly? 
Haha... I have people in my office who have bought some at $50 and up. They tend to be the ones who complain the loudest when the break room runs out of their favorite brand of free soda. I can't imagine what some of them would say if you suggested they spend $89 of personal money on something related to career development...
You can start them programmatically or via Maven, at least Tomcat and Jetty...
It does have "indexing resources" which similarly locks up my machine, but it is much less frequent than eclipse. 
IMO it really shines for Enterprise Dev when you're using JPA, Spring and friends. It has a lot of more features that eclipse in that case. You can compare them yourself buy using a free trial.
Something to keep in mind is that not all languages even have such a strong concept of types. Many of the languages that predate C just had "numbers" and "strings", with the actual type being more of an implementation detail.
IntelliJ is extremely slow and bloated, especially when loading new projects. Things that are lightning fast in Eclipse take forever in IntelliJ.
So you're not doing this for a living then.
You wouldn't be bothered by 2 seconds difference as you are bothered by 20 (or whatever) seconds. It takes me 15s to start with intellij-community project or 5s to open that project in already started instance... 
That's not the only point at which the application is a hog in my experience. I just pointed out the first thing that came to mind. I'm not here to justify my opinion to you.
I think I get it. Wow, that’s weird. Thanks. 
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: https://www.reddit.com/r/Serendipity/comments/6lgjb7/reasons_to_buy_intellij_idea_xpost_from_rjava/
Well of course, if you do not have an adequate hardware...
On Eclipse Oxygen, they changed it, now Ctrl+Shift+L opens the Quick Search tool when you're at the main Eclipse window; now the Key Bindings popup opens in Dialogs when Ctrl+Shift+L is pressed. It can be changed in Window &gt; Preferences &gt; Keys 
Idea Pros: - Better refactoring/code generation tools - Better Maven integration - Dark theme is significantly more refined - Multi-row Editor tabs yay! - Better code-completion - Better lookup tools once you learn the shortcuts - Much better git integration Idea Cons: - Multi-threaded debugging sucks - View management is not great compared to Eclipse perspectives 
I don't understand your comment.
I keep all my (linux) config in a git repository, so that i can keep track of my changes - and/or use this with my puppet installation to configure many services and servers. (unless i forgot to commit my changes .... upsi) I think, if you dont keep your config of your servers and services for production and testing under some kind of versioncontroll, it will get messy - very fast. Just add more servers/services or people to handle your configs, to see a glimpse of the comming chaos ;)
Notepad should open project faster than any of this two. Does it make Notepad superior? Maybe you have inadequate hardware. For me Idea is lighting fast.
It's cheaper to buy better hardware than waste time by using worse tool, but it depends of usage
IntelliJ IDEA is an excellent product. I use it and Android Studio everyday and there's still plenty of features I've yet to discover, but the core functionality is excellent and fast. It integrates well with Gradle, has great debugging, testing, etc. It's always getting updates, which to me is the #1 sign of a healthy project. The argument to management is simple: a couple hundred bucks / year is nothing compared to the cost of a developer for a year, so you might as well empower the dev to be maximally productive (also a good argument for a nice computer :). Any such product I think is worth supporting and IntelliJ - even before the multiyear discounts - is less than the cost of Netflix. Go JetBrains!
We convinced our management to buy PHPStorm (JetBrains PHP IDE) licenses for us because we were already plowing through the trials, and learned to love it. We made sure we documented every productivity upgrade it offered us over other IDEs, and management signed off on it. Importantly, we made sure it was recognized as a *time-saver*, which to the ears of management translates to *money-saver*.
Did I mention I use Arch?
You don't even need that, they accept anything that proved you're a student, for example a student card.
The name of the product they're describing is [Spring Cloud Config Server](https://cloud.spring.io/spring-cloud-config/).
As far as I am aware Scala is not supported. Groovy is supported, but I have not used it with a modern spring version so can not speak to that experience. Kotlin is supported, and I have recently used that for a few projects. Support for kotlin seems to be really good. I love being able to make data classes for entities and such without having to add getters, setters, and constructors. [Kotlin CRUD app example] (https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin) [Groovy Rest controller example](https://spring.io/guides/gs/spring-boot/#_jar_support_and_groovy_support)
Im aware but nothing abt the scenario is specific to cloud?
Wow, it's that fast for you?
Entreprise fidget spinners.
To me this feels like an echo-chamber response. In the years I've used it...I haven't found myself frustrated with their inability to do so. Not saying that it's an untrue statement, but is there an actual issue you are suffering due to their inability to deprecate?
I paid for my own license...eventually you get to the point where you want to start streamlining your workflow on everything. I have a budget for my own "work" related things including dropbox, github, license fees and side-projects. I considered it an investment in myself and it has paid off. Think VIM mixed with Eclipse (Which you can literally do, but I don't prefer it). I've gone almost entirely mouse-less and my productivity workflow has gone through the roof.
I actually think there's more trouble due to inability to remove (after deprecation) than to tag as deprecated. However, here's an example of delayed deprecation that I'm surprised to still encounter now: thy haven't deprecated java.util.Enumeration, so lots of libraries still use it … and yet its lack of support for Iterable prevents its use in many contexts (mainly for-each loops). For years, they couldn't give it a default implementation of Iterable.iterate() or hasNext() / next() / remove() because that would require making it an abstract class (breaking all existing use of it). However, with Java 8 they could have done so using interface's default implementations, and yet they left it in its half-supported state. Either deprecate Enumeration (starting the move towards removal) or else support it better (implementing Iterable). Don't leave it half-way. 
If you develop for a living and your philosophy is that you don't add a dependency unless you really have to, you will go bankrupt ! - More code to maintain - More time spend developing 
Why are you being downvoted? That's exactly right. https://www.jetbrains.com/help/idea/eclipse.html
Thank you! Exactly what I needed 
The specific scenario is about microservices, but configuration management is useful not only locally hosted microservices (like with Docker) but cloud hosted microservices as well. I've used Spring Cloud in an actual cloud. It's pretty cool. Spring Cloud is a suite of tools that simplify writing [Cloud Native](http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_cloud_native_applications) applications.
I am cautiously optimistic. One of the nice things with Java has been with very little effort (if any) stuff just works from one version to the next. I am not getting that vibe here.
try out the ultimate edition for yourself, if you like it buy it with your own cash (so much cheaper). I don't regret it. 
doesn't the license entitle you to use their swift plugin for clion or appcode ?
I've never had issues with intellij being slow - have you got a dodgy third party plugin installed ?
20 seconds for me and my big project. Its the indexing that takes a while, but means its quicker to use ... ssd or no ssd ?
I sometimes use notepad++, but thats it. Get an ssd man, its the best single upgrade I have ever purchased in 20yrs.
'serverless' is not about 'where the code is executing' as such. it's about deployment and execution model.
if I rename a table on my schema all reference in sql strings in my java dao's are updated. If eclipse can do that I'll eat my hat.
None of those reasons are related to its everyday use being better. 
Hmm.. Didn't occur to me that it might. It's a different product though 
If your only contributions to reddit are links, you can be considered a *spammer*. Most of your contributions got 0 or very little recognition (karma) which is against the *reddit spamming rules*. Either you become an *active participant* who also involves in discussions, or you have to stop spamming, or face consequences in the form of a ban.
If your only contributions to reddit are links, you can be considered a *spammer*. Most of your contributions got 0 or very little recognition (karma) which is against the *reddit spamming rules*. Either you become an *active participant* who also involves in discussions, or you have to stop spamming, or face consequences in the form of a ban.
Are you going to spam Reactor now? This is the *second time* you promote *exactly the same*. If so, *stop it immediately*, otherwise you will face consequences in the form of a ban.
If your only contributions to reddit are links, you can be considered a *spammer*. Most of your contributions got 0 or very little recognition (karma) which is against the *reddit spamming rules*. Either you become an *active participant* who also involves in discussions, or you have to stop spamming, or face consequences in the form of a ban.
If your only contributions to reddit are links, you can be considered a *spammer*. Most of your contributions got 0 or very little recognition (karma) which is against the *reddit spamming rules*. Either you become an *active participant* who also involves in discussions, or you have to stop spamming, or face consequences in the form of a ban.
I think some of the new licenses do
...or you could just use Spring and forget about EJBs altogether along with application server specific settings and hacks...
&gt; The JetBrains representatives on the Executive Committee are Anna Kozlova and me, Trisha Gee. really good representatives, I respect their work a lot. &gt; two vacant ratified seats on the Executive Committee (EC) anyone a clue which was the other elected member?
They are great. When I see there is a new talk of them available, I always try to eventually watch them.
Can a fidget spinner be webscale?
I would absolutely love a yields keyword in java and proper generator/coroutine support. Generators are basically iterators with a small state mashine inside, automatically generated by the compiler. It's syntactic sugar. Given that with lambdas we already have some of the needed functionality on the compiler-side, we can perhaps hope for it. Unfortunately there is no language support yet. This library has to fire up a separate thread for each generator and pump items through blocking queues to achieve a similar coding style. The greatest benefit of generators and coroutines is that they do *not* have the overhead of threads. Java8 streams and a manually written iterator would perform significantly better. 
Will we have Kotlin support in Java EE?
I hate remote EJB, I've never been in a project where they have worked well
&gt; **support**: assist, help. Saying that CE supports Java EE because it can write and compile it, is like saying that it supports x86 assembly because I can write assembly code in a new text file and compile it from within the IDE by invoking external tools on build. If the IDE is not helping you with it, the IDE does not support it.
I haven't seen the other post was a repost so I report it here, I didn't know that was a problem: as you can see I am new here
But obviously I'd like to have feedback about it, it's not the right place, I'd happy to exchange about it on another place :) 
It's not that the post was a repost. You commented *exactly the same link twice*. Yet, even worse the link is not even related to either topic of the threads. You cannot just throw links in that you may or may not have done promoting something completely different in other people's threads. First comment: &gt; Kotlin support is really awesome, but what really interest me is Reactor . I just complete their handson: https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/ , and it seems pretty cool. Second comment here: &gt; I am really interested by the new features of Reactor . I just complete their handson: https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/ , and it seems pretty cool. Twice the same link, twice nearly the same text. This is absolutely not okay. If you want to present something interesting, do so in a **single post** but do not try to hijack other people's threads.
Unlikely, not in foreseeable future, imho. JetBrains in JCP is a really good news for everyone on JVM space.
Your posting history shows **zero actual participation** other than posting links to youtube that are self-promotion. This is not acceptable according to the **reddit rules for spam and self promotion**. Either you become an active participant who also comments on other threads and participates actively without self-promotion through comments, or you are not welcome here and thus will face a ban.
Ok my bad, as reactor is an important part of the spring framework 5, I thank I was on the right topic. 
EJB's can be exposed as RESTful web services. I haven't seen direct remote invocations in a long time.
&gt; That's two or three fidget spinners more like 89 
That's really great news!
Do you bring your own laptop to work?
Wait, so all environments point to the same centralised config server? And each service has to be configured (i.e. hard coded url in the config file) to point to the config server to get more config?
Wow, useful plugin.
&gt;If you've ever lost your hair over Remote EJB issues, this one is for you.. This one hair?
I disagree 100%. And the reasons I mention are extremely relevant. The remark you come with here is really, really weird, when it comes to it. While I have used both, I have not personally used both extensively recently on the same project, and that makes it difficult for me to make honest comparisons about it. And the fact that JetBrains have a very strong commercial interest in IntelliJ being preferred may (depending on JetBrains) result in less than honest claims regarding usage and comparisons, as I argue - and that in itself is extremely relevant as well. Especially the part about it being fully open source is important in my opinion. It has a large number of consequences. And as we all should know and be aware of, being dependent on proprietary tools can end really, really badly (ie. vendor lock-in), though I would argue that the potential vendor lock-in with IntelliJ is much less severe than it could be (though I could be wrong about that; but still, being dependent on a proprietary IDE seems much less worse than being dependent on a proprietary language and compiler). One scenario is if it becomes the only worthwhile IDE offering around, and it is strictly necessary to use an IDE to have any kind of productivity for the projects you work with (for instance if the languages the given project uses require an IDE to be productive), the vendor could set up prices by a large or very large amount, and the only option would be to pay (or to try to scramble to switch and help create/improve another IDE). While I remember very active discussions on /r/programming regarding changes in licensing and pricing regarding IntelliJ and other related products from JetBrains, I do not recall how significant they were. There is one example [here named "How JetBrains lost years of customer loyalty in just a few hours"](https://www.reddit.com/r/programming/comments/3jl662/how_jetbrains_lost_years_of_customer_loyalty_in/), with more than 2000 points and more than 800 comments.
Nice article. Shame about the crappy website on which it's published. I use copy constructors all over my projects. The clone method I have implemented once, in a project that relies heavily on reflection, where my JPA implementation doesn't necessarily know about the data class constructors, but does know whether a class is cloneable. My implementation uses the clone method for in-memory undo-redo functionality. It needs a copy of old values, detached from the (Beans-bound) current data, so any changes a user makes can be undone and redone at will. A regular copy constructor doesn't work in this case, and neither does a shallow clone. It requires that each value has its own, new, independent object instance reference. That was "fun" to figure out. Not.
they changed the licensing after the feedback. I've used both, a lot. Intellij kicks ass when it comes to everyday use.
It may also help that back in the early days of desktop computing, a FPU was an option that some computers didn't have. This gave integer division a huge speed advantage.
What would we this mean to you, exactly? I mean, Kotlin code can interop with pretty much anything in Java EE today. What additional convenience-wrapper-DSL-thingys are you looking for down at the library level, to say that Java EE "has Kotlin support"?
I have to imagine that the overlap between "actual corporate Java EE users" and "alternate JVM language users" is vanishingly small. If you're bold enough to adopt an entirely different language, just to pick up some syntactic sugar and trendy functional goodies... then why in the world would you nevertheless still be using Java EE, instead of Spring or something else more light and nimble and modern? I've yet to run across a Java EE shop that even uses Lombok.
or you could work on a project where they use Spring AND EJBs... and slowly die on the inside a little more every day...
I use Java EE and Lombok but I am not sure what that proves. What makes Spring more light and Nimble? You cannot even put a Spring project together without something like maven because of all the interdependencies. Hell, they even built an addition framework just to configure the original framework. 
I have this scenario in my mind: there is a huge company, they spend thousands of euros in Java EE application servers because a lot of programmers know Java EE. In this huge company, there are some programmers who want to try new things, but they have to produce something deployable to their Java EE application servers. What they need are some guidelines and gurantees about how to implement Kotlin applications using Java EE libraries. Believe me, there are a lot of people like that.
Right. Pretty much anything. What are the common gotchas? What are the mistakes to avoid? Which application servers, which commonly used libraries are better suited for Kotlin development?
Spring has the @Bean annotation for that. Classpath scanning is just one of many possibilities in Spring (for the lazy) to define DI candidates.
&gt; What they need are some guidelines and gurantees about how to implement Kotlin applications using Java EE libraries. Here's the thing: programmers that are smart enough to use Java EE without despairing about its complexity are more than smart enough to figure out how to use Kotlin in that environment too. Would using Kotlin with JPA, EJB, JMS, etc. really be any more complex that it is for Java? Really? The APIs don't change just because you're using Kotlin. The configuration details for those don't change just because you're using Kotlin. Take my opinion with a grain of salt here because I haven't used Kotlin with Java EE, and probably won't any time soon, but I really don't see where the difficulty would arise. Now if you were asking how to use Scala with Java EE and you also wanted to seamless integrate Play &amp; Akka with Java EE... well, good luck with that. 
save() executes an insert if no record exists with the same @Id or an update if the record does already exist. You can think of it like the save function in a text editor.
Who here uses Kotlin? What are your opinions?
To be honest, you'd be stupid to work on any java project bigger than one .java file and not have something like maven at hand.
Aww, shucks. You brought a caffeinated tier to my eye... 
This is something i should have posted to /r/offmychestjava (lol) really, but i think more people here would appreciate it. I have changed how i think about programming languages. Natural selection would have culled Java many years ago unless it was useful. Same goes for all of them. It's just so useful.
You're right, I wasn't there and I don't know what the usage profiles of JavaFX vs Swing looked like. I have used some of the features you listed as overreach - the packager tool and the media/WebKit support seem crucial for so many use cases. If they'd improved on Swing in just a few areas, I think the bleed away from it would have continued just as fast. As I said, I think the web won because it had better deployment. Sun never understood desktops. JavaFX is good technology but even now the default skin is kind of drab. The javapackager tool has been essential for me to consider using JavaFX for GUIs in the past - if it was JNLP only I'd not have bothered with the platform at all. And WebKit gives you a good "out" if you suddenly need web stuff in a part of the UI. I don't know if there was a way to avoid the shift to the web. Other platforms like .NET and Qt have bled users too. I think it'd have required mounting serious, focused competition to the web browser as a tool for apps itself - doing an "app browser" for example, with web style silent download/upgrade deployment.
One aspect your seem to oversee is that not explicitly invoking the method assumes exactly something like a session in place. An assumptions that just doesn't hold true for anything except JPA but IMO is also far worse than exposing a dedicated operation to basically express: "I want to persist all changes made to the aggregate" as it very implicitly ties the client code to the inner workings of the underlying persistence mechanism. How would a plain JDBC based repository implement this behavior? It's not only leaky abstraction, it's implicit leaky abstraction. If all you care about is JPA, fine. But you're basically overloading "repository" to a particular persistence technology, which — ironically — is what you want to avoid by thinking in repositories in the first place. As to the case with add(…) — the point here is, that in exactly the case I described above — you don't want to add the aggregate to the collection again, you want to persist its state. Not sure I get the aspect about a "technical operation". Adding is not a single bit less technical than saving IYAM. The session concept implemented in JPA causes a lot of trouble in a wide range of scenarios as the callback mechanisms provided are very limited (no way to inject components into lifecycle listeners etc.), which makes an explicit call so much more favorable as it can be intercepted explicitly.
I would like to point out this excellent article by Venkat on Object Cloning. https://www.agiledeveloper.com/articles/cloning072002.htm
One of the thing I heard the most about Java is "It's slower than other language". It nice to read another opinion. I saw a good talk about it this winter by Martin Thompson: https://youtu.be/Pz-4co8IaI8 
Too bad. I really thought they could help turn JC Penny around.
Points for loyalty. I'd use it in a heartbeat if it supported react instead.
+1 for dislike of remote EJBs. 
I'm not sure why alot of "legacy" shops still use it, but I come across it quite a bit :/
Then you should have read our release notes :-) React is next :-)
Nice. Having spent the last week evaluating react boilerplate projects, good luck. Neither create-react-app nor electrode met my needs and they're both very mature. If you bake in support for SSR, Sass and Jest you'll be my hero.
Perhaps slightly off topic, but something that I've wondered occasionally: Why do repositories not distinguish between persisting a new entity and updating an existing entity? In the business layer I usually know which of the two operations I want to perform.
I'm expecting the same trouble as with Angular (we spent more than 1 year on this!!). But this time it looks like we have good corporate sponsors, so it should be easier for us.
Why they discontinued JasperReports?
Either a massive coincidence, or already posted as a direct link rather than through dzone: https://www.reddit.com/r/java/comments/6l0hjb/are_java_8_streams_truly_lazy_not_completely/?st=j4sis0f7&amp;sh=a12b0a12
Unless something has changed recently the OSX version doesn't use native hooks and just polls the file system on an interval (think it's 10 seconds by default but I thought there's a way to configure that interval). On Windows and Linux they both have native implementations that use file system events. Also as the other poster mentioned this won't work on remote drives.
&gt; One of the thing I heard the most about Java is "It's slower than other language". I think that perception was formed in the initial days when it *was* slow - and stuck. Also, nowadays since the general computing power of all our hardware has significantly increased more often the focus is on engineering productivity vs. raw speed of the application and there Java has some advantages over languages that can easily produce core dumps. ;-)
There are other considerations, I deploy several desktop Swing application to our clients via java web start over the public internet. Download size is a consideration if a site has 200-300 people that need to download the app when an update occurs. Especially if it is an offshore site that doesn't have bandwidth to spare. For example, I like using JAXB annotations to produce/consume both XML and JSON, the reference implementation of JAXB in the JDK can't produce/consume JSON. However, the Eclipselink Moxy JAXB implementation can, it is a 6 meg dependency. In my server applications I use Moxy to produce XML/JSON because dependency size isn't a consideration. In my desktop applications, if the API supports it, I request a XML response so I can use the reference implementation of JAXB since it is in the JDK. If the API only supports JSON then I use Jackson as it is only 1.2 megs. Likewise, I like using Groovy to configure Logback. However, you have to add groovy-all.jar as a dependency, this is a little over 5 megs. Again, not an issue for a server application. However, for my desktop applications I just use XML to configure logback so I don't have to include the 5 meg or so groovy-all jar. I use the HTTP support built into the JDK for my desktop apps, instead of using one of the HTTP libraries (like apache HttpComponents). Sure it is clunky as hell to use but it still does the job. (and the HTTP support is greatly improved in Java 9) I am not saying I don't use libraries, I am saying I carefully consider the dependencies I am using, especially in my desktop applications. 
Not really looking for the 10,000th "Java EE vs. Spring" boring debate thread. Just pointing out that there's probably little or no overlap between: 1. Java EE shops (especially those who reject what has been the de facto standard build system for over a decade now), and 2. Shops that embrace hipster alternative JVM languages. Yeah, I can picture a lot of side-arguments branching off from that assertion. But the core assertion itself is pretty obvious.
I thought maybe Java 9 would have this implemented natively for OSX but doesn't look like. See here: https://github.com/openjdk-mirror/jdk/blob/harfbuzz/jdk9/master/src/java.base/macosx/classes/sun/nio/fs/BsdFileSystem.java#L49 Outstanding issue - https://bugs.openjdk.java.net/browse/JDK-7133447 There may be an implementation that is open source outside of standard java though.
I use logback because it has automatic compression of the daily files at rollover and because you can tell it to keep X days of logs, so you don't need an external log purge script. I don't believe JUL does this, although I honestly haven't paid attention to JUL improvements since it was added in 1.4 so maybe it has been added. slf4j is of course only important if you are creating a library to be used by other projects; however, I use slf4j as a facade just for consistency sake even in my non-library projects.
The other contributor to this reputation is the fact that it is slower in trivial benchmarks. Java is (for lack of imagination) the slowest option for a hello world program I can think of, simply because of the JVM startup. I suspect that a lot of people hear the Java is slow, then if they go as far as testing that, do some trivial benchmark that is dominated by JVM startup time, which confirms that Java is slow.
I've used it a bunch and I like it. It solves a lot of the nuisance issues with Java. I still like Java a lot too, but I don't reach for it as often anymore as my primary programming language. FYI: I've used Kotlin in both commercial and personal projects.
How did you go from Java to C++ without a pointer...
Spring only solves some of the problems EJB solves, such as CMP and CMT. The Spring application context doesn't cluster or cache (passivate) Spring beans and also does not make Spring beans accessible over RMI. Also, unlike the a Java EE application server, the Spring application context doesn't guarantee thread safe access to Spring beans, which also makes things like extended JPA persistence contexts a lot less safe and transparent than with EJBs. Although, these days you'd probably just use web services instead of RMI, and leverage http sessions instead of a dedicated EJB cache. For the conversational aspect of EJBs, you'd probably use something like [Spring Web Flow](http://projects.spring.io/spring-webflow/) and a [flow-managed persistence context](http://docs.spring.io/spring-webflow/docs/current/reference/html/flow-managed-persistence.html) or go full on REST (conversational state as an actual identified resource).
Google finally has influence over Java, through their pals.
References.
Java is pretty awesome. The Sun/Oracle Virtual machine is near damn magic. Java programmers not necessarily so. There is a little bit too much "enterprise" wankery in a lot of Java code but it's not inherent to the language. It's just that 90% of programmers have no taste. I can write concise, clear Java code (almost) as much as I can do that in say, Clojure. With Java 8 lambdas I'm 80% there.
It can be easy to get carried away with over-engineering OOP design principles. Practice YAGNI and some of that goes away. Sometimes it's a necessary evil but I've found that a lot of times it's not. 
A lot of the enterprisey practices were as a result of missing features in the Java language I think. Some of these will go away with the new features in Java 8+.
Just today, I have told you to stop spamming and become an active participant in discussions. Yet, you continue as if nothing has happened. You receive a 10 day ban where you can contemplate about your future participation in reddit. Should you then continue like that, the ban will be final without further warning.
Just today, I have told you to stop spamming and become an active participant in discussions. Yet, you continue as if nothing has happened. You receive a 10 day ban where you can contemplate about your future participation in reddit. Should you then continue like that, the ban will be final without further warning.
I don't need to monitor remote drives, just local folders but I do need something that works well on Windows and OSX.
Yeah, that's what I'm talking about. The enterprise fizzbuzz is a great parody of that style. Sometimes I come across real life Java that makes me think they used EFB as the best practices template.
Some of it was that. But even before lambdas it was possible to write good Java code without needless abstractions. The bad overuse of OOP practices in a lot of third party Java application and frameworks was a fad adopted by people who wanted to look and sound smart in meetings.
I see this a lot. Java's bread and butter is long running apps. Yet so many people measure from start to stop of something that takes milliseconds with zero warm-up. Further, they look at total heap size and say "oo, java's such a hog!". When the heap utilization could be very low.
IntelliJ doesn't have incremental compilation and a problems views. Without that I will never use IntelliJ. 
Yeah. No wonder, my lead asked me to change from using WatchService to simply poll the directory for changes. When I asked why, he said he didn't like it and forgot the reason. 
&gt; Now i know how much work has been put into the JVM and just how efficient it is. This is really the important point. With a less awesome VM, Java could be a pretty cruddy language from a real-world usefulness standpoint. But the JVM (and the people who built it) are freakin' awesome. Java owes *so* *much* of its real-world success to the killer VM that runs it. I've often said that the Hotspot JVM is easily the best piece of software from the early 2000s. It just plain kicks ass.
&gt; while it is easy to convert Java to Kotlin, a lot of additional work must be done to make Kotlin Java EE compatible. It is manual work and it is error-prone, mostly due to friction between JavaBeans specification and Kotlin. JavaBeans is an old standard, literally from the last millennium. It was conceived to make component manipulation in RAD visual editors possible. For example, the user would drag and drop a text field from the toolbar to the form, and then set the text, color, and other properties. The component had to be constructed in an uninitialized state and configured step-by-step. Read this: * https://dzone.com/articles/kotlin-jee-part-one-from-java-to-kotlin * https://dzone.com/articles/kotlin-and-java-ee-part-2-having-fun-with-plugins * https://dzone.com/articles/kotlin-and-java-ee-part-3-making-it-idiomatic
I don't hate Java, in fact, in recent versions, I have even grown to love it. However, what I really love about Java is the performance characteristics of a long-running JVM. It can't be beat (at least, for most scenarios it would seem).
http://benchmarksgame.alioth.debian.org/u64q/csharp.html
I primarily develop in C# for my day job, but I keep up with the JVM. It's always great to see some benchmarks for .NET Core. Although, these tests are a bit deceptive: the JVM's strength comes from long-running processes that the JVM has been able to memoize and optimize. I'd like to see the same benchmarks in half-hour and hour testing sessions.
The packager tool is horribly broken and half baked. Even for simple cases. It discards WORA as you need a Mac for the Mac build and Windows for the Windows build and don't get me started on 32bit Windows (arguably that's MS's fault but this is f'ing Java it should be easy). This is a symptomatic problem with desktop Java. A new generation comes in, looks at everything that was done before and decides to throw everything away and start from scratch... Java webstart was "rewritten" 4 times and often made worse. There were countless other efforts in play but deployment in Java SE is still crap. Did you go to production with javafxpackager? We have it in production and use it in our desktop port, since we have Macs and Windows machines in the cloud it works in a cross platform way. We had so many issues we actually have a drawer plan to use electron with our JavaScript port (transpile Java Bytecode to JavaScript and package with Electron). I'm not talking about natural bleeding to the web. I'm talking about bad corporate culture at Sun that was replaced with a stifling corporate culture at Oracle. Both spelled doom to FX. 
yeah the JVM is a fine piece of software engineering. an optimizing compiler it is
ELI9 difference between "opens" vs "exports"?
I'll see your JVM startup, and raise you PHP from a cold Apache start. Or, hell, Rails.
What, you've never been paid per line of code? /s
I've been working with Java and .NET C# for years and Java outperforms .NET everywhere. 
Don't assume a slow apache means a slow PHP: $ time php &lt;&lt;&lt;'&lt;?php echo "Hello, world!\n"; ?&gt;' Hello, world! php &lt;&lt;&lt; '&lt;?php echo "Hello, world!\n"; ?&gt;' 0.00s user 0.00s system 53% cpu 0.007 total Or ruby: $ time ruby &lt;&lt;&lt;'print "Hello, world!\n"' Hello, world! ruby &lt;&lt;&lt; 'print "Hello, world!\n"' 0.02s user 0.00s system 96% cpu 0.025 total Just for comparison; and I'm surprised how fast this was: $ echo 'public class Main { public static void main(String[] args){System.out.println("Hello, world!");}}' &gt; Main.java $ javac Main.java $ java Main $ time java Main Hello, world! java Main 0.04s user 0.00s system 97% cpu 0.041 total We can clearly see here that in all cases, php is 6 times faster than java, and ruby is twice as fast as java.
This issue caused us some pain today after a kernel upgrade on RedHat. Thought this post might save some other people some hair pulling.
You mainly use C++ but you're just starting to warm up to Java? Are you a time-traveler from the '90s?
[Here](https://stackoverflow.com/questions/20630686/when-does-spring-data-jpa-actually-call-insert-on-the-database) is another example of issues caused by the session concept: delayed inserts, constraint violation exceptions issued on query execution etc.
Again, because it's logic that belongs *into* the repository, not into repository clients. Changes to aggregates need to be persisted, completely independent of whether they're initially created or their state has changed. In fact, persisting that state (change) doesn't have to mean that inserts or updates are issued, but a could be a list of events written to an event store. So to repository clients, that needs to be transparent. So while this makes sense on even lower level APIs (e.g. a Hibernate Session) it must not leak outside the boundaries of a repository.
I dunno guys. It seems like we're letting him off too easy. He needs to serve his Java penance to receive his virtual forgiveness. I propose: 3 Our Father Gosling prayers followed by 2 Holy Java prayers 
&gt; How do you convince management to spend money for IntelliJ? I managed to convince my company to get this. What you need to do is present the spend in a way that management will understand. So you have to prove that it will lead to either cost reduction over the medium to long term, or by a longshot developer retention. There are also negotiations that can be made here. So we started with 10 licenses for interested developers and that grew over time. You could take the same approach as well. You can even ask management how many developers will it take to get licenses, and fill up the numbers. ---------------------------- In terms of why IntelliJ over eclipse. Basically when I used eclipse, I found it to be unstable and unreliable. It also always used to freeze on me. Things are probably better for eclipse, but that's how I started using IntelliJ
True, but on Intel processors, every chip since the 486DX has had an on die FPU.
What advanced features does the CLR have over the JVM? As for the JVM not needing any more significant new development, well that's just one person's myopic opinion. I consider Project Valhalla, Project Panama, Graal to be significant new developments for the JVM. 
I hear you. Though the generator here will at least execute on a fork-join task thread from the common pool. Presumably there will be a set of threads kept pre-allocated there, ready for any miscellaneous async operation. Also, on a multicore device the generator may execute in parallel to the consumer - the buffering of the queue can be adjusted to facilitate this. For instance, I have used this kind of construct to read rows from a Postgres table using it's Java bulk download API and then loaded the rows into Redis cache. In this case the generator is retrieve the data from Postgres and then the consumer is taking output and inserting into Redis. With this construct, where there is true parallel processing, I can load tables of millions of rows into Redis cache in a few seconds. There is not a very large foot print in the Java process for doing this either, because the producer and consumer are interleaved in execution and so not very much data has to reside in Java process at any given time. Now I have actually started an implementation that has an almost identical Runner class as this implementation but uses a different generator helper class. It is in progress but it will be a true coroutine implementation where the generator producer and the consumer execute on the same thread - in true interleaved manner. The generator helper class (a class that manages the execution of the supplied generator lambda) needs to be generated using Javassist because it's methods are coded directly in Java bytecode assembler. Also, it's most complicated feature is the ability to save the call stack of the generator lambda when it calls the yield operation. Saving a call stack means having to implement a **continuation feature**. How is this done? Well, it's no too bad: The Thread class has a method that returns the call stack for trace information. The trace info is certainly not sufficient by itself for serializing the call stack, but the array it returns can be walked from tip of call stack, backward to the point where the consumer called next() on the iterator. Each element in this trace info array has class and method name, and a nice hash value that uniquely represents the stack frame. Once can use the class and method name to go and use Javassist to look up method info from the class file. The method info will have info on the parameters passed to the method when it's called and it has attributes info on the local variables established in its stack frame when called. From this info it is possible to code generate (using bytecode assembler) the serialization and deserialization methods that can save or restore this method's stack frame. So while walking the stack, code generate these methods (caching them using that unique hash key I mentioned for latter lookup retrieval), invoke the right operation (either save the stack frame or restore it). Naturally the act of saving a stack frame will actively be popping the frame. Later when the stack frame needs to be put back, then the load effectively pushes a frame back on the stack. So every time yield is called, the call stack will be saved off, and then will return back to the consumer that called next(). When next is called again, then the saved call stack will be put back on the stack and then return from the yield call that the generator previously made. The advantage of a true coroutine approach will be no thread context switching and no thread blocking. But consider the case I described where retrieving data from Postgres. The generator lambda for that case may block on its i/o operations and hence the thread of the consumer is blocked. The implementation using a thread pool thread for the generator and queue buffering can mitigate this, with tuned buffer capacity the consumer could be kept busy constantly. I should have a week in August coming up where I will be able to get back to the coroutine version. Will probably add it to this library so that users can choose with implementation works best for their scenario.
Wish more people knew this.
As someone who doesn't know c# well.. what is Java missing?
Well, it's not part of the Java JVM per se, but I coded a replacement (using C++11) of the Java program launcher. I designed it especially for running Java programs as a service on Linux, it is possible to easily directly execute commands on the bash command line that the service responds to, and the service can make use of Java child processes (one may have noticed that many complex programs - MySQL, Postgres, many, many others - make use of child processes - executed off of their own code via forking). The new Java launcher is called Spartan. It makes use of Javassist to examine Java class files for annotations. The places where one wants to have methods be command-line commands or entry points of child process commands are marked with annotations. Spartan uses a Linux fork API to initiate a new child process. The parent Java process is enabled by Spartan with easy mechanisms to keep track of children processes. A standard command that every Spartan Java service has is status - which will list on the console the active child processes, their start times, their command lines, and their pids. The status command can be overridden and emit other useful information. Now mind you one can't fork an active JVM, so after a fork the JVM is cleanly initialized per each child. It's really great because the same jar file program can be accessed for child process activation on its various methods and the security model is all kept the same as the parent process. This alone makes it vastly simpler to work with child processes in Java. It really makes this a breeze. It's much easier to build robust services when child processes can be used in such an easy, convenient fashion - a process can be much more robust to work with than mere Java threads and sometime robustness and strict process encapsulation is exactly what is needed - plus the very clean scavenging that happens when a temporary child process goes away. Want to build services in Java that never fall down, that can truly run 24/7 under heavy, punishing loads? Spartan is the way to do that. I've used Spartan for a couple of years now, but am going to get permission to open source it. It's really strange that no innovation has happened on the Java launcher since year 2000 - it's been completely stagnant all that time. **EDIT:** Because all the child processes are executing off of the same Java jar file code, marshaling data between processes (using the inter process pipes provided) can make use of native Java serialization. This makes everything super simple to marshal, is very performant, and you don't have to even worry about versioning the data because it's all the same version of Java code serializing data to different parts of itself to be acted on within some child process (or parent process) context.
I love using IntelliJ IDEA by JetBrains. It’s free (for the Community edition), has a beautiful user interface, and has awesome features!
And sing the Java Posse [RIP] theme song.
I'm glad to hear about react. I like angular as a frontend application framework, but it's usually overkill. I've recently grown to like react as a presentation layer, and that's it. A lot of the stuff in angular, I just don't need. 
"it has a huge array of potential applications" Nice
I've become fond of NetBeans recently its very nice but I'd recommend inteliJ or NetBeans
IntelliJ is the only contender, none other stack up as of now; and why has been explained in this sub plenty of times.
486DX was expensive when it first came out, not to mention there were still a very large number of i386s still in use. I remember when Intel made the 486SX and offered a 487SX coprocessor as an upgrade (It was really a 486DX that disabled the 486SX). 
Java wins half the tests and by more significant margins overall, the results are just listed at the bottom and not highlighted the same ... There's only one test which C# has a significant advantage in.
I think that is mostly MSes fault. I don't think there is anything inherently javay that makes it better to optimize, I think that the CLR is just suffering from years of being closed source. Java has had so much blood, sweet, and tears poured into it to make it as fast as it is. The CLR has seen a fraction of that just because the only interested party in making it fast has been MS.
It certainly gives almost everything a run for its money. The JVM is just so incredibly well tuned (and well tunable). I think you have to look no further than to Dalvik to see the crazy performance difference.
Yeah, the benchmark game does a bad job of representing java really. It pretty much lines Java up with the worst case scenario for java and then measures all the wrong things (like total memory usage). I imagine it is a similar story for many of the other VMed languages (such as JavaScript V8).
I've always been jealous of C++ programmers' ability to manage memory. I feel so lazy leaving objects lying around for the garbage collector.
IIRC in one place i worked at speed was crucial so the application used no GC, all objects were preallocated, and they did some crazy drive IO customizations. 
&gt; What advanced features does the CLR have over the JVM? i think valhalla will include this, but the clr has runtime specialization (codegen) features which is used by .net generics.
&gt; This is something i should have posted to /r/offmychestjava I assume you're making that up since there doesn't seem to be such a subreddit? :P
kinda but no; in my(somewhat limited) experience, java is most commonly(aside from android apps) used for data persistence/business logic in web applications, and as such, tends to be somewhat separated from the "view" component. the same is for the most part true of Android apps as well, though there is a little more crossover in terms of ui programming. that having been said, almost all of my college courses focused on swing and awt, and it sounds like that's pretty common, since swing simplifies the ui development process, and allows developers to focus more on the business logic component of things. so no, you haven't wasted your time. you already have 3 years of experience under your belt, and you've got a much deeper understanding of swing than almost any of your classmates--and if we're being honest, your professors too-- will have. And the thing is, you didn't just learn swing, you were definitely learning java in a broader scope, which again, puts you well ahead of your peers in terms of experience with java development. don't rest on your laurels, though. you'll be able to breeze through most of your lower level java classes, so use that time to explore higher level concepts, design patterns and implementations. by the time you're into your upper level coursework, you'll be well ahead of your peers when it comes time to apply for internships, and that's where you'll see your work pay off. getting a few semesters of intern work under your belt makes you wayyy more desirable to employers, meaning you'll have more power when it comes time to ask for 20k more than you deserve. 
&gt; Any recommendations? Sure, try reading the sidebar to find links to subreddits where the question about learning resources has been asked and answered thousands of times.
https://www.techempower.com/benchmarks/
&gt; C++ is my language of choice for the most part, always will be i suspect Have you tried Rust? I also played Java down. I was a Ruby on Rails fanboy bored to death by Java but now with JHipster, Lombok and a few other tools you can really build stuff with Java. I like most about Java the refactoring tools. It blows away anything else I used. There are a lot of languages that are easy to write but Java is easy to change and refactor.
For people not versed in these terms, [Project Valhalla](https://en.wikipedia.org/wiki/Project_Valhalla_(Java_language\)) is experimental features: * Value Types; highly-efficient small 'objects' without inheritance. * Generic Specialization; List&lt;int&gt; for example * Reified Generics; retaining actual type at runtime. * Improved 'volatile' support. [Project Panama](http://openjdk.java.net/projects/panama/) is improving support for calling non-Java libraries. In particular native library calls. [Graal](https://en.wikipedia.org/wiki/Graal_(compiler\)) is a compiler project. 
**Project Valhalla (Java language)** Project Valhalla is an experimental OpenJDK project to develop major new language features for Java 10 and beyond. The project was announced in July 2014 and is an experimental effort by Oracle, led by engineer Brian Goetz. *** **Graal (compiler)** Graal is an Oracle project aiming to implement a high performance Java dynamic compiler and interpreter. The objective of Graal is to improve the performance of Java virtual machine-based languages to match the performance of native languages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Which is why it is ridiculous to state that Dalvik was required for improving Java performance on mobile devices. Even J2ME on flagship Nokia and Sony-Ericsson devices had better performance than Dalvik.
In particular before the JVM got a JIT. 1.2 added HotSpot as an option and became the default in 1.3.
JavaEE didn't really help that. The fact that *Spring* was a lightweight response to EE shows how bad it was. 
The thing is that Dalvik used a completely different module to the JVM. The JVM is stack based, while Dalvik was register-based. I'm guessing this means they used a completely different instruction set.
Don't be. It's far too easy to fuck up memory management in C++. 
That's completely false. First of all, there were many Java ME implementations. All different. Even on the same brand of phones. Second, they were all dog slow, implemented the spec as they saw fit and were all basically a nightmare to work with. Even the early versions of Dalvik (pre JIT) were markedly faster than the fastest Java ME implementation you could find.
You are not really measuring how much time it takes for Java to execute that program, but rather how long it takes for the JVM to start up. If you tried to execute this piece of code in an already running virtual machine you would get a different result
I would say start with :head first java Then scjp 6 I highly recommend keeping your IDE next to the pdf and trying everything you read 
Maybe, but some years ago I worked for high performance trading and everything was done in java. Garbage config and vm optimisation can have some really good results.
Extensions, Generics that aren't erased (idk what exactly they're called), infered types, (better) functional support, just from the top of my head. Not saying C# is better, but more convient and code is more readable, imo. Although I hate that they use CamelCase as opposed to camelCase.
You have certainly not wasted your time. Although Java is mostly used as the backend language for webapplications, most courses still include Swing or JavaFX in some way. If you're interested in building desktop Java applications, do check out JavaFX. It is considered an improvement over Swing. 
I also think the browser plugin didn't do it any favors. I had a manager who didn't like that I was using java because his only direct experience with it was slowing down/locking up his browser. Fortunately he trusted me to make the technical decisions, but I'm sure that kind of impression didn't help the "java is slow" perception. 
(Runs a Hello World example, once, from scratch) &gt; We can clearly see here that in all cases LOL You should probably add a "sarcasm warning" somewhere in there, just in case ;) 
They know. That's exactly the point they are making (read the parent comments).
You can use the EAP version for free. Never had any issues with it. https://confluence.jetbrains.com/display/IDEADEV/EAP
They are using smart pointers anyway
Bullshit. The JVM uses stack, heap, and registers as it sees fit. 
None of my applications run long, nor are they intended to do so. The longest-running takes 1.5 hours and that's due to network throttling 9000 remote calls. All of my applications start, act, close, on a timed schedule. They read from a central data store, read one or more files from disk, archive that, then process their contents. The longest wait usually is accessing the data store. Layers upon layers of security make for pseudo-arbitrary delays. My applications are so fast that it's unlikely the JVM gets sufficient time to warm up to reach its most effective compilation. 
The JVM has "local variables", but operations happen to values on the stack. If you want to manipulate the values in the local variables you have to put them on the stack. Obviously, native code uses registers.
I was J2ME developer once upon a time, and worked for that little unknown company in Finland, maybe you heard of them. &gt; First of all, there were many Java ME implementations. All different. Even on the same brand of phones. I guess you never had the fun of making android apps work across Samsung devices, or unknown Chinese brands. &gt; Even the early versions of Dalvik (pre JIT) were markedly faster than the fastest Java ME implementation you could find. Spoken as a truly Google apologist, our benchmarks at the time said something totally different.
I will bow to your experience. Recently I read an interview with Brian Goetz on the IBM developers web site. In it, he addressed and debunked several JVM myths. The myth about stack, heap, and registers, was addressed, too. The myth perpetuates the fallacy that large objects are stored on the heap, the access of which is slow, small objects and primitives on the stack, the access of which is fast, so we should keep our data types small and prefer primitives. Brian says (and I pull this from my own fallible memory, feel free to correct me): the JVM uses all three memory spaces as it deems fit. There is no hard rule for a data type to be used here or there. What matters instead, is density: memory closer together can be accessed faster, and based on the application algorithmic behaviour, the JVM decides where it places what data. But even so, indicates the interview, the JVM has many, many optimization techniques, which makes it nearly impossible for a Java programmer to predict which memory space is used when. A JVM expert might be able to provide more insight, but basically Brian says that Java programmers shouldn't bother too much with the distinction between memory spaces. TL;DR: the JVM isn't just stack-based. It uses all the memory spaces it can, and does so in ways a regular programmer can't predict.
Oh interesting. And I didn't know there was any variation of camelCase.. I mean isn't that why it's called camelCase? Because of the hump in the middle? It seems weird that anyone would modify that.
if you have question about J2ME dev ask me. I think learning J2ME is a good thing. It teaches you memory management and small screen dev. Download the SDK for your phone. For example Sony-Erickson. Using Eclipse is fine. I know it works. use J2ME Polish build files and process Write your code in Eclipse. Build with J2ME Polish ant build that launches the Emulator located in the J2ME SDK. If you want an example build file, PM me. You could use the Eclipse J2ME plug in for quick tests of a small project. Using the J2ME Polish build process is better in the end.
CamelCase is a no go for me... makes the code hard to read... just like Kotlin var and a few other idiotic syntaxic stuff. Besides Microsoft is evil. I am not investing in their tech.
The better language is worth it though.
I think the issue is that you're confusing memory usage with instruction set architectures. One is a lower level than the other.
&gt; So every time yield is called, the call stack will be saved off, and then will return back to the consumer that called next(). Messing with the stack is not necessary if you only want to get coroutines and a 'yield' statement. It may be a valuable performance optimization, but you can reach the same goals with code generation and without touching the call stack at all. Similar to how lambdas are solved in Java 8: Pure code generation. Any function with 'yield' statements can be re-written as a state-mashine. This shate-mashine would implement the iterator interface and stores all local variables in private fields (no stack). It should also bind the parent class (just like lambdas) to access fields of the outer class. The function body is split into chunks and the state-mashine remembers which chunk should be executed next. The chunk borders are the yield statements. Loops, conditionals or try-blocks that contain 'yield' need special treatment, but its possible. The split-operation would be easier on bytecode-level actually. Every time the generated code is called, it jumps to the current chunk and executes it, updates the internal chunk-pointer and returns the result of the yield-statement. All local variables are private fields on the state-mashine, so there is no need to fiddle with the stack. The JVM should be able to optimize the overhead away pretty easily, and keep most stuff in registers anyway. 
I think a much better fit for modern Spring development is Kotlin, since it is explicitly supported by Spring. There are several [Kotlin APIs for Spring](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0) directly from Pivotal.
Nice ~~idea~~ IDEA!
No.
If performance or start-up time ever grows into an issue: This is a perfect use case for long-running worker processes and job queues.
Actually, the heap thing is a real problem if you have multiple services on a single host and don't want the overhead of an JavaEE Application Server. Luckily the new G1 GC (introduced in Java 8, default in java 9) is *way* better at freeing unused heap memory. A single full GC reduces the total heap size of my service to ~20MB (~10MB are actually used) while the old GC would sit on hundreds of MB of unused heap for hours.
I can't praise the new G1 garbage collector highly enough.
This might help you with the Java-Database interactions. http://www.postgresqltutorial.com/postgresql-jdbc/ To make a webpage with Java, you can try this one: http://stacktips.com/tutorials/java/servlets/java-servlet-helloworld-example 
I've found this sort of project is a lot easier if you don't let the OS control the tools you're using. What I'm suggesting is not necessary; I've just found it easier. Personally, I would download a copy of Tomcat from the apache website and run that manually. Then $CATALINA_HOME/lib will exist and you'll be able to follow the instructions. Once you add the postgres jdbc jar, you will be able to access it from your classes as normal. You may want to check out TomEE, also by apache. It's basically tomcat, with a few other enterprise components integrated, like JPA. 
Indeed. My applications did start out like that. We dismantled that in favor of O-scheduled execution: it is fast enough and more easily scalable.
Used it on some Android pet projects - thanks to the Kotlin Koans it's pretty easy to pick up. Not overly wild about companion objects as a thing - I just don't find it as clear.
Point me to a source so I can learn about that, please?
&gt; I guess you never had the fun of making android apps work across Samsung devices, or unknown Chinese brands. I've been developing Android apps since 2009. I've probably shipped apps on hundreds of different devices by now, including native bits. &gt; Spoken as a truly Google apologist, our benchmarks at the time said something totally different. First of all, let's keep this civil and stay away from ad hominem, shall we? Maybe you had a few implementations at Nokia that were faster, but I can tell you as someone who's shipped Java ME apps on hundreds of different devices since 2005: a crushing majority of Java ME VM's were completely outpaced by Dalvik even after 1.0. 
That ship has sailed, we've finally moved on from Scala.
https://en.wikipedia.org/wiki/Stack_machine vs https://en.wikipedia.org/wiki/Register_machine Hopefully that should give you enough to go on.
**Stack machine** In computer science, computer engineering and programming language implementations, a stack machine is a type of computer. In some cases, the term refers to a software scheme that simulates a stack machine. The main difference from other computers is that most of its instructions operate on a pushdown stack of numbers rather than numbers in registers. A stack computer is programmed with a reverse Polish notation instruction set. *** **Register machine** In mathematical logic and theoretical computer science a register machine is a generic class of abstract machines used in a manner similar to a Turing machine. All the models are Turing equivalent. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I had no idea you could download it on your phone. I couldn't find it on the App Store or safari so should I just use my PC? 
not ON your phone. Use your PC and download the SDK. every phone manufacturer had a SDK to develop J2ME applications for their phones. what's the target phone for your game?
Edit the tomcat startup script in /etc/init.d/ and set CATALINA_HOME there.
&gt; I do have to do java work as well at my job, and recently was wondering if there is a similar set of tools for java. Check out CheckStyle and FindBugs.
When I say I would like to make games I mean as a hobby. Not trying for App Store type of games. I'm trying to make a small game to start out, just for practice. Something like Tic-Tac-Toe. I would like to transport it to a flip phone. If that works then I'd just keep doing harder things.
There's a sonarlint plugin for intelliJ, which points out code smells, among others. Might be a bit more than what you're looking for though. I also recommend turning off the auto scan thingy, as it's fairly heavy.
In addition to the two above there are also [PMD](https://pmd.github.io/) and [SonarQube](https://www.sonarqube.org/).
i got that. it's pretty easy to do with J2ME once you are set up with the build and deployment process.
In German we say, "was sich neckt, das liebt sich". In English: "Teasing is a sign of affection"
Intellij already comes with real-time linting (pay version at least.) You can access the entire list of inspections as well as save/load configs by clicking bottom right face icon.
Exporting a package lets other modules access the types of that package at compile time. Opening a package (or an entire module) lets other modules access the types of that package reflectively at runtime.
How is C# "better"? You mean "has more language features", right? That doesn't necessarily mean better. 
Im a seasoned Java developer - 10 years+ experience... I recently started messing around with c++ on arduino.... Aghhhhhh!...I hate it so much. Give me java anyday.
It's only heavy if your code is full of bugs. ;)
....Use it at your peril http://mydailyjava.blogspot.co.uk/2013/12/sunmiscunsafe.html
Or you have 200K LoC over 2000~ classes. Even changing branch can take a while sometimes.
Python doesn't default to float.
[Checkstyle](http://checkstyle.sourceforge.net/) [FindBugs](http://findbugs.sourceforge.net/) [PMD](https://pmd.github.io/) [Error Prone](http://errorprone.info/) Also, run the compiler with the [-Xlint:all -Werror](https://stuartmarks.wordpress.com/2012/10/09/javaone-2012-dare-to-compile-your-code-with-xlintall-werror/) options. They're all complementary, focusing on slightly different aspects of correctness and doing their work in slightly different ways.
Points for loyalty. I'd use it in a heartbeat if it supported vue.js instead.
FWIW - I didn't downvote you, but it does seem like you've proved what I said above: "programmers that are smart enough to use Java EE without despairing about its complexity are more than smart enough to figure out how to use Kotlin in that environment too". Anyway, I understand what I think you're getting at here; which is that it isn't necessarily that easy, so your question is a good one despite my own statement. Hopefully JetBrains takes full advantage of their new position to smooth the way for Kotlin into areas like JEE. It would be a shame for it to be niched as a mobile only technology.
&gt; don't let the OS control the tools you're using There is a major downside to this approach: you won't automatically get security updates. Honestly there are major downsides to both approaches, but automatic security updates pushes me to (very often) use the tools that come with my OS. Notable exceptions being IntelliJ and more obscure tools like the android sdk, grails, gradle, etc. Tomcat is a tool where I sometimes go either way.
I don't think that the pay version has much more linting type options than the free version. OP is an admitted JavaScript developer though, so the pay version is probably worth it.
It's amazing how far the compiler goes with just -Xlint:all.
It does!? e:\projects\&gt;python Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 25 2016, 22:18:55) [MSC v.1900 64 bit (AMD64)] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; 3/2 1.5
C# has a way better type system. Generics were done right. Value types are a godsend. Java has _terrible_ design.
Oh right, they changed that for python 3. Python 2.7.10 (default, Feb 7 2017, 00:08:15) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.34)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; 5/3 1 
So, if I get it right: I need to open my entity class modules to serialization and persistence libraries, but I don't have to (or even shouldn't) export them?
Yes, exactly. Although not even opening your entity class packages or modules will be needed in Java 9: as of the recent preview builds, the new option "--illegal-access" allows deep reflection by default. You'll just see a warning for now, with the plan being to disallow deep reflection by default in Java 10. Yet another option is that such libraries migrate away from using reflection to using method or var handles to access the state of your entities. This will require no open access at all, but instead to pass a "lookup" object with private access from your code into the library. I've blogged about this a while ago: http://in.relation.to/2017/04/11/accessing-private-state-of-java-9-modules/
My apologies on the title as well. I meant to say web app and Android
And not to forget that Java compilers usually catch quite a few suspicious or even erroneous coding patterns.
JavaFX is very much an improvement over Swing. However the "JFrame knowledge" can very well be used for JavaFX.
Also noteworthy: [Arrays 2.0](http://cr.openjdk.java.net/~jrose/pres/201207-Arrays-2.pdf) &gt; Reified Generics; retaining actual type at runtime. I think this was discussed but it will probably not be applied for all Generics, if at all. Unfortunately. 
Like with any other language: "it depends"
do you mean at the same time (web apps together with / for Android) or you want to know about those two seperately? 
&gt; I'd like to see the same benchmarks in half-hour and hour testing sessions. OK: The example JMH testing sessions were half-hour and a-couple-of-hours spectral-norm # Run complete. Total time: 00:27:05 n-body # Run complete. Total time: 02:35:55 and those example JMH averages were [**pretty much the same**](http://benchmarksgame.alioth.debian.org/sometimes-people-just-make-up-stuff.html#jvm-startup-time) as the time shown on the benchmarks game pages. Care to revise your comment?
SonarQube is pretty good
Wins / Loses? When there's so much overlap? (C# pages highlight better C# programs, [Java pages highlight…](http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=java&amp;lang2=csharpcore))
Separately, unless you have any suggestions on frameworks that work well for both?
/r/dailyprogrammer is pretty good for this stuff.
This Spring Cloud stuff looks cool. http://cloud.spring.io/spring-cloud-config/ Some places I've been, config was spread across properties files and the database. With their Cloud Config, you have a Git (!) :-) backed, config server running on localhost:8888. Git is so fast and solid I use it for far more than just source code change management tasks. I use it to maintain a history of my all my survival game saves, my /etc directory on my server, my Windows Documents folder, etc. This is brilliant, a Git based config (key/value) server right in Spring. 
 * Well for the web app and back end [Spring Boot](https://projects.spring.io/spring-boot/) is often a good option. There is [Spring Mobile](http://projects.spring.io/spring-mobile/) and [Spring Android](http://projects.spring.io/spring-android/), but I don't know how good they are. [Jooby](http://jooby.org/) or [Spark Java](http://sparkjava.com/) are more lightweight options. * As for native Android I'm not sure if there even are any notable frameworks. Normally people just go with the [Android SDK](https://developer.android.com/reference/packages.html) and maybe add some [library](https://github.com/codepath/android_guides/wiki/Must-Have-Libraries) that helps certain type of app development.
No -- worst-case is millisecond program run-times -- because JVM start-up, JIT, OSR… *will* take a few tenths of a second. &gt; measures all the wrong things Like elapsed time, program size, cpu time ? Please say why you think "total memory usage" is *a wrong thing* to measure. &gt; I imagine it is a similar story… An imaginary story :-) 
/r/Kotlin/
Thank you for your comment. I've seen several posts about projects written in Scala in this subreddit, so I thought it's acceptable to mention something that's designed for the JVM even though it's written in Kotlin.
Awesome! Thanks for linking to the additional resources as well! I'll do some digging around on it!
&gt; the slowest option for a hello world program There's always a way to write a slower program :-) http://web.archive.org/web/20080802030311/http://shootout.alioth.debian.org:80/gp4/benchmark.php?test=hello&amp;lang=all
I can't get this to run. Any idea what I'm doing wrong? I tried: https://repl.it/JSP3 
It's not a big deal, actually it's fine here too. Maybe just mention in the title next time
I prefer running it locally but I've seen it go both ways with Tomcat. 
https://projecteuler.net/ let's you work in whatever language you like but it's more math based. 
In such cases I sometimes just open smaller portions of the project. If you use Maven (and Gradle probably), you can just open a pom.xml file with IntelliJ and it will load the module as a standalone project.
I'm a fan of [CodeWars](http://www.codewars.com)
&gt; Care to revise your comment? I bet you're often highly regarded as an elite socialite. I'm on to you.
seen it in bash, might come from c/c++.
Every IDE does this. I call them yellow squigglies (even though they're not yellow in all IDEs)
Cool. I've just learnt about TDD and Mockito this week, that shit's really useful.
&gt; C# has a way better type system. Marginally, maybe. &gt;Generics were done right. True but implemented only in 2.0 where M$ didn't give a shit about breaking compatibility. &gt;Value types are a godsend. Java will have Value types done right in that they will be immutable like they should have been in C#. &gt;Java has terrible design. LOL. From the people who brought us partial types - the worst language feature ever invented. If C# is so great and M$ has shat so much money into its promotion, why does Java still dominate? Tough question, I know.
This is the text I used to learn elementary Java programming: https://www.amazon.com/Introduction-Java-Programming-Comprehensive-Version/dp/0132936526 at the end of each chapter is a set of exercises... we're talking about 20-30 or more exercises. I'm actually re-studying basic java because I have an advanced java course this fall. I'm just going back to each chapter, read through it, and doing every.single.exercise. It gets repetitive very quickly, but that's what I want: to know the basics so thoroughly that I don't have to think in order to type or use them in basic scenarios. The main point for me is to do the basic exercises so much that when I start this advanced Java course this fall, i'm not re-learning any of the basics. if you're willing to spend $15 to get an old copy, it might be worth it. Or find a pdf online if you don't care about paying for it. That works, too, I guess.
Yeah, so do I when possible, but on my current project I usually need to make changes to multiple projects at once (It's a microservice arch, and some larger features span multiple assets). opening them separately will end up being more of a hassle. If you have a build server and run sonarqube online as well you can attach the plugin to the sonarqube server, which is a good solution. I usually just manually scan the files I changed and fix the issues there, if any.
Xamarin C#/XAML. 
There's https://leetcode.com/ as well.
I believe it's just the code duplication detection but I'm way too lazy to look it up. 
Yes, but their latest pricing model is a subscription model where when your year runs out Intellij will no longer run at all unless you buy another year. 
&gt; If C# is so great and M$ has shat so much money into its promotion, why does Java still dominate? Tough question, I know. Not really. Java powers Android, and M$ only began reducing its stupidity in recent years. You should know better than to equate popularity with quality. I suppose you like PHP as well. Having .NET Core (instead of Mono) is wonderful in Linux. Being able to toss out the crusty Java and replace it with C# is fantastic. If I am ever forced to return to the Java ecosystem, I'll be using Kotlin.
I've also used both, and both eclipse and intellij are a wash. They both have slightly quirky interfaces, both have bugs, both are decent IDE's and certainly immensely more productive than editing with notepad and compiling from the command line. I wish Intellij was a superior solution, but I didn't find it to be. Last time I used it it had a bug where it would say maven ran when it it didn't, that was pretty awful on a project where I was the only person have a problem (because I had the latest edition and everyone else was on the older edition).
Swing (what JFrames are from) is not widely used nowadays, no. Sorry. To be fair not a lot of apps use any client side gui at all nowadays either, it's mostly web apps now. Java **is** widely used in web apps though.
* findbugs * pmd * errorprone You can plug all three into your build (first two in the `verify` maven step, last one as a compiler plugin). As far as formatting goes i find that committing a intellij code formatter settings into the repo and letting the IDE pick it up is far better than using CheckStyle. You will still need to deal with *that guy* in your team, but you won't get so many false positives.
Your posting history shows **zero actual participation** other than posting links to your domain that are self-promotion. This is not acceptable according to the **reddit rules for spam and self promotion**. Either you become an active participant who also comments on other threads and participates actively without self-promotion through comments, or you are not welcome here and thus will face a ban.
https://www.hackerrank.com 
I think they are referring more to tooling like sonarlint. The yellow squiggles that show say bad casts or bad use of diamond operators are compiler warnings. but this won't catch things like using string buffer instead of string builder, cyclomatic complexity, too many nested loops, or use of string concatenations.
that would require control of the Java compiler implementation - so that it would give special treatment to methods that use a yield mechanism I've seen Brian Goetz floating a paper on adding value types to Java (which would just be highly excellent), but I haven't seen any proposals for adding true coroutines to Java. Have you seen any such proposals from the serious movers and shakers of Java? I suppose I could try to take the approach of reading an existing method that is invoking yield and re-write it - but that would require getting a much, much more intimate understanding of bytecode assembler so could see the code execution flows and do a 100% correct job of breaking the method up into fragments. I will ruminate on this but am thinking it might be a harder problem for me personally to solve than implementing a Java continuation feature.
Will you revise your prior opinion to incorporate the new information? Will you reject the new information to safeguard your prior opinion? 
Of course I'll revise my opinion based on new information. I'm not a religious zealot.
I suspect we generally believe what we prefer to believe.
IDEs don't do everything sonarlint/PMD does, but they check a lot. Including usage of StringBuffer, too many nested loops, and in some (not all) cases, string concatenation. It also depends on the IDE. I know IntelliJ does more than Netbeans/Eclipse. 
Not really what you want but more a tip, I found that writing stuff to an idea was beneficial when learning. Writing your own gtalk client, facebook client or something will teach you many other skills like understanding an api, using data and that please please why wont you work moment. 
I like the other answers here, specifically project euler, but I'll add one more that I enjoy is [google foobar](http://www.google.com/foobar/). It's a recruiting device, for sure, but is also useful intrinsically. (Decades ago I enjoyed topcoder programming competitions, but those no longer exist)
Are there solutions to each exercise in the book to help me check my answers?
You could have a look on how Lombok implements var/val.
That is not true. You get a perpetual fall-back license for the last paid version. https://sales.jetbrains.com/hc/en-gb/articles/206544229-Can-I-purchase-a-perpetual-license-
Thanks for the link, if they changed it back that's cool. 
I'd look at /r/androiddev for Android suggestions. There are quite a few libraries people generally use e.g. RxJava, ButterKnife, Retrofit. Realm had a presentation talking about tools &amp; libraries for common Android problems - [worth a read](http://news.realm.io/news/tools-and-libraries-for-common-android-problems/) even with wonky formatting.
+1
This has to be one of the valuable threads I have seen on /r/java recently. Thanks for the useful question and all of the useful replies. I am saving this thread.
Write something you want to write. Nothing will keep skills sharper than if you use it to create something you want. Come up with a hobby project for yourself to work on in your spare time. Doesn't matter if its a game, graphics demo, web app, or whatever.
I'm a fan of [exercism.io](www.exercism.io) . They have problems in tonnes of languages (not just java) that start with simple things and can get pretty tricky (depending on your definition of tricky) It also has the benefit of needing to submit your solution before you view other people's. Although there is nothing stopping you from submitting junk code. Otherwise developers can suggest changes or improvements and you can iterate on previous solutions. Edit: corrected spelling
Points for loyalty. I'd use it in a heartbeat if it supported Ember.js instead.
Not really, it has to check for possible errors/warnings and using "all" options adds a lot more checks. Whether there is a bug or not shouldn't impact the heaviness. It's more on how much code there is to check.
Pretty cool, big fan of both projects, have made JSF development a pleasure.
Interesting project. This also addresses (or tries to, from what I can see) shortcomings in JPA wrt the age old paging, filtering, searching in tables. 
Points for loyalty. I'd use it in a heartbeat if it supported RxJS instead.
Yeah but only if you're stupid.
Doesn't Payara uses Lombok?
[CodinGame](http://codingame.com)
Effective Java, item 11: override clone judiciously. Still great advice!
why is this getting downvoted? Legitimate question. I've used it in the past and thought it was fine. 
I am not going to debug your own program. You can debug this like any other program, with the added caveat that its *a lot* harder to read. But its easiest to write compiling java code, and then just convert it to unicode escapes. I wrote in an earlier comment how that can be automated.
What are the legal ramifications of using an education license to develop commercial products for a company?
Caution! It uses an old version of omnifaces. 
That's a great question and I'd really like to know the answer. If you decide to ask this question in any of the appropriate subreddits I would love to get a link.
Yeah I didn't expect you to debug it. I was just wondering if you have a running example because I did exactly what you wrote ("Put this into main method") and it doesn't seem to work.
*sigh* public class ReallyReallyEvil { public static void main (String[] args) { // FIXME this crashed with the following mem-dump: \u000A\u0074\u0072\u0079\u0020\u007b\u0043\u006c\u0061\u0073\u0073\u003c\u003f\u003e\u0020\u0063\u0020\u003d\u0020\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u002e\u0063\u006c\u0061\u0073\u0073\u002e\u0067\u0065\u0074\u0044\u0065\u0063\u006c\u0061\u0072\u0065\u0064\u0043\u006c\u0061\u0073\u0073\u0065\u0073\u0028\u0029\u005b\u0030\u005d\u003b\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0072\u0065\u0066\u006c\u0065\u0063\u0074\u002e\u0046\u0069\u0065\u006c\u0064\u0020\u0066\u0020\u003d\u0020\u0063\u002e\u0067\u0065\u0074\u0044\u0065\u0063\u006c\u0061\u0072\u0065\u0064\u0046\u0069\u0065\u006c\u0064\u0028\u0022\u0063\u0061\u0063\u0068\u0065\u0022\u0029\u003b\u0066\u002e\u0073\u0065\u0074\u0041\u0063\u0063\u0065\u0073\u0073\u0069\u0062\u006c\u0065\u0028\u0074\u0072\u0075\u0065\u0029\u003b\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u005b\u005d\u0020\u0061\u0020\u003d\u0020\u0028\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u005b\u005d\u0029\u0020\u0066\u002e\u0067\u0065\u0074\u0028\u0063\u0029\u003b\u0069\u006e\u0074\u0020\u004e\u0020\u003d\u0020\u0061\u002e\u006c\u0065\u006e\u0067\u0074\u0068\u003b\u0066\u006f\u0072\u0020\u0028\u0069\u006e\u0074\u0020\u0069\u0020\u003d\u0020\u0030\u003b\u0020\u0069\u0020\u003c\u0020\u004e\u003b\u0020\u0069\u002b\u002b\u0029\u0020\u007b\u0069\u006e\u0074\u0020\u0072\u0020\u003d\u0020\u0069\u0020\u002b\u0020\u0028\u0069\u006e\u0074\u0029\u0020\u0028\u004d\u0061\u0074\u0068\u002e\u0072\u0061\u006e\u0064\u006f\u006d\u0028\u0029\u0020\u002a\u0020\u0028\u004e\u0020\u002d\u0020\u0069\u0029\u0029\u003b\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0073\u0020\u003d\u0020\u0061\u005b\u0072\u005d\u003b\u0061\u005b\u0072\u005d\u0020\u003d\u0020\u0061\u005b\u0069\u005d\u003b\u0061\u005b\u0069\u005d\u0020\u003d\u0020\u0073\u003b\u007d\u007d\u0063\u0061\u0074\u0063\u0068\u0020\u0028\u0045\u0078\u0063\u0065\u0070\u0074\u0069\u006f\u006e\u0020\u0065\u0029\u0020\u007b\u007d Integer a = 3; Integer b = 5; System.out.println(a + b); } }
It's great for learning to design efficient algorithms. The only reason I'm as familiar with Big O notation as I am is due figuring out what order my methods are so I can avoid the common runtime-will-exceed-the-runtime-of-the-universe problems that crop up from the more obvious solutions.
Here is an interesting excerpt from a JSR on coroutines: 2.7 Please give a short description of the underlying technology or technologies: Coroutines as a programming concept have been around since the early days of computer science, the term "coroutine" itself was coined in 1963 by Melvin Conway (http://dx.doi.org/10.1145%2F366663.366704). They are available in numerous programming languages and runtime environments. From a language design perspective, coroutines are a generalization of subroutines. When they are invoked, they start execution at their first statement and they can subsequently transfer control to some other coroutine (via an operation often called yield). **The state of the local variables and the expression stack at the transfer point is preserved.** When control is transferred back, the coroutine resumes the preserved state and continues to run from the point where it relinquished control. **Coroutines can also be seen as a limited form of continuations, called one-shot continuations.** ### [CoroutineJSR](https://wiki.openjdk.java.net/display/mlvm/CoroutineJSR) **EDIT:** This is an even better, more thorough discussion (and touches on the state machine approach too); especially note section *2.1.1 Stackful vs. Stackless*: ### [Coroutines in Java](http://ssw.jku.at/General/Staff/LS/coro/CoroIntroduction.pdf)
This works, thanks! By the way this is different than what you posted above (`\u000A\u0072\u0079\u0020\u007b\u0043\u006c\u0061...`) which is why it didn't work for me. sigh...
https://www.reddit.com/r/legaladvice/comments/6lxmqb/legal_ramifications_of_using_education_licenses/
Oh, my above code was missing one char. I updated the original post (and I am somewhat glad you are the first who found out, it means not many people *actually* try to put this to work somewhere). btw, here is the original code 8with newlines and indentation intactm both are stripped for conversion): try { Class&lt;?&gt; c = Integer.class.getDeclaredClasses()[0]; java.lang.reflect.Field f = c.getDeclaredField("cache"); f.setAccessible(true); Integer[] a = (Integer[]) f.get(c); int N = a.length; for (int i = 0; i &lt; N; i++) { int r = i + (int) (Math.random() * (N - i)); Integer s = a[r]; a[r] = a[i]; a[i] = s; } } catch (Exception e) {}
great, thanks!
I can't remember, but they are easy, especially the first dozen or so chapters. If you still remember basic java somewhat well, you might even be able to do the first 2-3 chapters' worth of exercises in your head, character by character. I'm going through and doing each exercise without a template of any kind. Imagine going into an advanced programming course, and on day one, timing how long it took each student to write a 'hello world' program without help of any kind. I've seen it, and it's horrible. I want to be the guy who can do it as fast as I can type without thinking, and like I said, the initial chapters' exercises are a BORE. Extremely easy, but important if you want to get enough practice to memorize all of the basics.
Deliver on interesting real world potentially useful projects and show them to the community with github, video talk, pdf writeup and demos. You'll grow 10 to 100 times faster than empty programming exercises. Ad Astra, Teach to the task, not to the tool. Stupid: "Hey kids here's a box of tools lets see what they do! ooh jimmy I see you swinging the hammer around over your head, Good job!" Smart: "Hey kids, we need to take off this car tire, here's a box of tools, which tool is best for this job and who can show us what to do? Ooh jimmy I see the tire is off, tell us what you did and what went through your mind". Be smart, not stupid. Teach yourself to the task, not the tool. 
I think it's great. It is difficult to use but it forces you to learn the details. Plus a lot of hiring managers use it to test applicants.
Or Wildfly :D
I am using SonarQube now. One of the best things is that it shows you a problem and also a quote from a source why is this (not) recommended. E.g. when you put a constant in an interface, it will mark it and the quote will be from Bloch's Effective Java.
Check if there's a /opt/tomcat/bin/startup.sh or try looking for a file namned tomcat.service - either of those should work.
File an issue ;)
[removed]
Would like to see some tail call optimization and some additional support for immutability like in more functional systems that make "copies" of data structures that are references to others but not true object copies until the original is changed then a deep copy is made. Garbage collection is nice to have but if you can minimize object creation/collection like we do with object pools you can get some nice performance boosts.
Serious question: What are the shortcomings of Xamarin?
[removed]
Remember that Pivotal supported also Groovy. But now Groovy is almost dead. The was also a [spring-scala](https://github.com/spring-projects/spring-scala) project, now defunct.
Code duplication and warnings about Spring beans not being autowired correctly are the only two extra that I've noticed.
Use a ReferenceQueue.
I have used Sonar. I prefer PMD: it's configurable beyond SonarLint (if, like me, you use it without the Qube).
FindBugs no longer is maintained, and last time I checked I was unable to download older versions. Use PMD instead.
Good to know; thanks.
Use IntelliJ, and get the SonarLint plugin (which applies all the SonarQube rules) while you work. Its not quite flawless, but its pretty darned close. Probably available for other IDE's - you'd have to kill me to get me using something other than IntelliJ though. If you set up a SonarQube server (its not required) then your issues, get logged and tracked over time. You can mark false positives etc. There are some inspections that can only be done by SonarQube rather than the SonarLint plugin (In particular code coverage of your tests etc.) - so its worth setting up if your serious about using static code analysis. However - SonarQube USED to have a really nice dashboard that summarised your project and displayed all sorts of info about it. The SonarQube team removed the dashboard in a recent 'upgrade' though - seems the product is moving away from what I liked about it. They have no plans to put it back, and are oddly dismissive of people saying it was useful. If there was an alternative, I'd switch - but I haven't found one. For now, I'm just not upgrading - so eventually SonarQube will have to drop out of my toolset.
I'm a big fan of Project Euler, don't let the math part scare you away, the problems are some neat puzzles that you need to create a program to solve. Some people like Sudoku, others like crossword puzzles, and others like solving Project Euler problems. :)
Only superficially related but one feature that I'd hope is expanded is the AOT support. Being able to create native executables from any platform for any platform, similar to golang, would be a huge accomplishment for the Java ecosystem.
It's self explanatory if you take a few minutes and look at Scale code.
As a cross platform solution they're 10 years behind Java and since Microsoft bought them I don't know how high a priority it would be to improve it. I would recommend to anyone playing with WPF/XAML to spend some time with JavaFX and you'd realize how much superior JavaFX is. 
I don't it was language features just IBMs influences. We use WPF with Prism and it's fucking monstrous. The thing is most of this shit is there to try to protect the end product you're building from the shitty developers on the team. 
2015 called and wants it opinion back. 
**Sidebar** -&gt; **No tutorials!**
I thought it went here: https://github.com/findbugsproject/findbugs Atleast I see commits on it and a pre-release for Java 9
The compiler is pretty fast. I bet if you check you'll find that JITC activity dies down after a minute or so at most, quite possibly less.
I'm a little puzzled by why it's so controversial. From what I've skimmed at a high level, it seems like a great idea. What are the supposed downsides that the naysayers were worried about? 
Hackerrank. I've heard of Amazon using this in their interview process.
I find that asking and answering questions on [codereview.stackexchange.com](https://codereview.stackexchange.com/questions/tagged/java) helps to keep in touch with my programming skills.
-8 apparently 
Meant +1 for the parent comment, which resulted with -8 points for my own.
Sometimes they fix bugs in the compiler, but they never add language features as far as I know.
They can improve optimizations in the byte code
I've had bugs where some type inference in lambdas compiled locally, but failed on our build server, because of a difference in the minor version of the JDK.
Oracle's commitment to JavaFX is very questionable IMO. I wouldn't bet on JavaFX still being relevant in five years to be honest. Correct me if I'm wrong but I don't know of any tool or framework that allows rendering JavaFX as native components on different mobile platforms.
&gt; Correct me if I'm wrong but I don't know of any tool or framework that allows rendering JavaFX as native components on different mobile platforms. Gluon [Mobile](http://gluonhq.com/products/mobile/) / [FXPorts](http://gluonhq.com/products/mobile/javafxports/) do. Apart from that there is [Codename One](https://www.codenameone.com/), [Intel Multi OS Engine](https://software.intel.com/en-us/multi-os-engine) (libGDX), [TotalCross](http://www.totalcross.com/) for cross-platform development. Probably others I don't know of (e.g. RoboVM forks, Tabris, Spring Mobile). Xamarin's problem is that you still need to do parts in Java / Objective-C (therefore XCode and license). The code that can be shared is limited (some say even 10% only, depending on the app). Additionally Xamarin is - like with pretty much everything in the C# ecosystem - the only available choice and it also comes from Microsoft or was aquired from them. Thats vendor-lockin. The Java cross-platform tools face the same problematics to various degree, but only on the iOS side and if you need a complete native iOS look-and-feel, which is not the case for e.g. games.
they changed quite a bit with java 8 to make lamdas work. Edit: didn't read the post careful enough sry
Are you suggesting this was as a minor update? I don't think anything other than optimizations/bugfixes are in the minor updates (eg. 8u111, 8u122)
Small correction as a guy from Codename One (thanks for the mention). We have true WORA. No custom or OS specific code (unless you want to in which case you can). We are 100% WORA. 
Well to pass job interviews, most students these days do Cracking the Coding Interview, then after you make your way through that, get an account on leetcode.com. It's good to get a headstart, but you'll want to study data structures and algorithms before that.
Well I never used the Gluon stuff myself but I talked to some people that did and as far as I understood components are painted by the framework and not natively. Also there seem to be some dependency issues. Again: I don't know for sure about this and might be completely wrong. I personally gave up on looking for Java based frameworks for cross platform mobile development. I'm currently giving NativeScript a try. Looks promising to me. As far as Xamarin goes, I never tried that either. But some people unaffiliated with Microsoft recommended it to me.
Realizing that op meant minor when they wrote major would have required reading the text of the post, which it seems like the poster you replied to did not. 
I was being nice saying "I don't think" :)
I wouldn't expect to see any difference because javac doesn't really optimize things, it's up to the JVM.
As far as I can tell, people are general in favour of the idea, it's getting it right that's the tricky part. 
&gt; NativeScript Kay, as long as you're aware that **"**truely native**"** in NativeScript means running in a [V8 based](http://docs.nativescript.org/runtimes/android/overview) runtime on top of the Android runtime that translates JavaScript calls to Android API Java calls =&gt; marshalling and class generation at runtime in an interpreted and pseudo-JIT fashion =&gt; run in Android runtime with no further optimizations. So **"**truely native**"** = not running HTML5 in a browser. Similarly for [iOS](http://docs.nativescript.org/runtimes/ios/Overview). Also JavaScript...
I work on a Scala project. ;)
I guess as usual it really depends on what you're trying to achieve. I'm focusing on lightweight user interfaces with as little logic as possible. I think JavaScript is absolutely OK for that. ES6 really brought some major improvements. 
The JLS changed quite a bit for Java 8. One major (overlooked) reason was [JEP-101](http://openjdk.java.net/jeps/101). This meant that early Java 8 compiler versions (including update 45) were full of bugs including: - Rejecting code that should have been fine - Compiling code that should have been rejected So, yes. Upgrading from 45 to 131 certainly changes compiler behaviour.
You can also checkout Topcoder or Codeforces like site. But their problem is kinda puzzle. It is like somewhat solving puzzle with programming. But to solve those problem you have to know lot of thinks like algorithm, number theory. Nevertheless I must say give that a try. It will increase your overall programming capability as well as logical, analysis and solving problem. 
This ^^
I feel like this requires a better explanation. Byte code isn't really optimized in the normal "compiler optimization" sense. Java byte code isn't really executable by a machine. It's interpreted by the JVM, which in turn will execute machine code. This two step process means compiling Java to byte code is relatively simple. There are currently only 202 opcodes in use in the JVM instruction set. x86-64 assembly has thousands of them. When new instructions are introduced to the JVM, the java-to-bytecode compiler (javac) can use those instructions where it makes sense. For instance, back in Java 7, *invokedynamic* was introduced, which made it lot easier to build dynamic languages on top of the JVM. The really interesting stuff is done by the JVM at runtime. The JVM will "interpret" your bytecode and execute it, or at least that's what it looks like. In reality, the JVM will take your byte code and compile it to actual machine code.This is what's known as "Just In Time" compilation (**JIT**). As your program runs, the JVM will keep track of which bits are important for performance. It can recompile and reoptimize bits of your code **while it's running** in an attempt to make it faster. The optimizations performed by the JIT can vary *heavily* between different Java versions. Newer versions of the JVM generally have better optimizations. Sometimes they contain bugs, which may be fixed in even newer versions. You could run Oracle javac bytecode on an IBM JVM and things would work, but the performance characteristics might be different because different JVM implementations can behave differently in regards to optimizations. 
Wow I had no idea the compiler had such serious bugs!
Project Jigsaw began in 2009. The OSGi alliance already had a solution for modularity. The key players at Sun/Oracle and OSGi had a different vision and have battled for years. It would be an entire 60 minute presentation to explain the history but in a nutshell: OSGi (and Red Hat) felt that they have a mature, well-engineered solution and that Oracle's solution is too simple (and that their suggestions were not respected). By contrast, Oracle maintains they have a different problem (modularizing the JDK itself) and that their audience (i.e. the entire Java community) is so large that it merits being highly conservative. An analogy is the OSGi solution is a high-end [Mercedes-Benz 6x6 truck](https://en.wikipedia.org/wiki/Mercedes-Benz_G63_AMG_6x6) (a tremendous feat of engineering) and Oracle feels they are the product manager for the Ford F-150 (hugely popular franchise with impossible constraints). The reason JDK 9 is big news is: (a) it is the culmination of a decade of effort (b) all sides have managed to find consensus despite deep divisions and different world-views.
Also quite recently (beginning of this year, if I recall correctly) a serious XML serialization/marshalling bug was fixed, that would allow an attacker to execute arbitrary code. That problem has existed for several in most XML marshalling implementations, not just in Java, and was the reason for me to avoid serialization and marshalling for the past 3 years. Gotta love having to implement my own solutions for things that are touted staple.
Ended up using node hosted react redux app with backend services in a separate spring boot app
Cool, looks like it's time to upgrade then!
Updates within major version mean updates within java 8, java 7, like java 8 update 45 vs java 8 update 60.
They certainly fix security bugs over time, if that's important to you. JRE: https://www.cvedetails.com/vulnerability-list/vendor_id-93/product_id-19117/Oracle-JRE.html JDK: https://www.cvedetails.com/product/19116/Oracle-JDK.html?vendor_id=93
If you edit startup.sh, you should add something like this early in the file (not the first line though): **CATALINA_HOME=/opt/tomcat** The purpose of it is to let Tomcat know where it has been installed (you can have multiple installations, for example).
Actually to interject, lightweight in the Java world has a clearly defined meaning of the platform drawing its own widgets as is the case with Swing, JavaFX, QT, Flash, Codename One etc. What you are talking about is "heavyweight" which means you need to communicate between native and the high level abstraction but have native peers. This is embodied in frameworks like AWT, SWT, Xamarin, NativeScript etc. Heavyweight vs. lightweight is a primarily religious debate (obviously I'm on the lightweight side as I work for Codename One). So if you don't think lightweight is the right way there isn't anything I can say that will convince you. - Heavyweight looks more native - Lightweight is more customizable - Performance is different - heavyweight is sometimes faster for simple UI's but it's really difficult to get it right across platforms with varying behaviors (e.g. list on Android &amp; iOS plus constant crossing of the JNI bridge in Android). So while heavyweight fans claim this, the facts aren't as obvious - Lightweight is FAR more portable by miles - that's indisputable 
JRE is everything you need to run compiled java programs. JDK is JRE plus everything you need to build (compile) java programs.
project euler?
And ... why would anyone want to do that?
Same here. And I think I was on 8_45 when I had that bug. The build server had gotten stuck on that version because the newer versions were in the Debian backports repo, and I only had the main repo enabled.
New spam account for websparrow? Were the others banned?
Why would you blindly copy a page, insert it here, not care about layout etc and post it as is? 
I was using the term "lightweight" meaning I don't want any business logic in the frontend. 
That's not javac
That's not a javac thing though.
Well, the "seriousness" of those bugs depends on how much you strain your usage of the Java language. Let's say, I tend to go a bit further combining overloading, generics, varargs, and lambdas, than what the average enterprise application does :)
In general it shouldn't but, like other comments have said, it's not perfect and there are edge cases.
I think the biggest concern was over handling of legacy JARs that don't include a module declaration: http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html?m=1
As [durple](https://www.reddit.com/r/java/comments/6m2li7/do_jdk_updates_within_major_version_actually/djz2m2s/) said and easier to memorize when written out: JDK: Java Development Kit JRE: Java Runtime Environment
&gt; Like elapsed time, program size, cpu time ? Yes, Yes, and Yes. The JVM was built for long running applications. Most benchmarks look at stats for short running apps. The antitheses of what the JVM was meant to be used for. But in order * elapsed time - Bad because they usually perform no warmup on the code in test. Bad because they usually don't write their microbenchmarks correctly (the JVM can in some cases optimize away running the code). Bad because they include JVM startup time in code runtime. * Program size - Usually a silly measurement. Perhaps if you are talking about embedded systems, then it matters. However, Why does a 10kb vs 100mb executable matter in this point in history? Gigabytes cost pennies, worrying about MBs is a waste of time. * CPU time - See number 1. However, usually the CPU time measurement is simply too course to really be of any value. What does it cover? Optimization passes? Startup time? Heap allocation time? All of those things go down in long running processes. &gt; Please say why you think "total memory usage" is a wrong thing to measure. Because the JVM was meant to run on servers first and foremost. As such, it aggressively allocates heap in order to avoid spending time allocating memory to try and reduce GC time. You want to reduce the memory usage? Set the max heap size smaller. To know how much smaller you should know about the runtime characteristics of your application. &gt; An imaginary story :-) JavaScript and PyPy do very similar things to the JVM. However, they are tuned differently. They target short running applications over long running ones. Further, they don't have as big a class space to load up as Java does. The story is similar for them, because they also do hotspot optimizations. However, I'm only familiar with those two VMs (Ok, JavaScript has many VMs, but they have pretty much all adopted the same strategies).
Any advice on how to improve the design or relationships between objects would be appreciated.
You have things backwards. Every arch that I'm familiar with needs to first load things into registers before it can do anything. Whether those values come from the heap or stack doesn't matter. They certainly don't have to make a trip to either the heap or stack before hitting the registers. The JVM is no different from other VMs. It puts stuff in the heap, stack, or even just the registers. Generally, most stuff ends up on the heap. However, the JVM tries to promote things to the stack when possible. And if something is relatively well contained (like an index variable), it is likely never to hit either the heap or the stack but instead live in a register for its entire life. At very least, the JVM uses the stack much like C/C++ does, for the "call stack" that is, it pushes the method return address onto the stack and pops it off of the stack when a "return" or end of method is reached. Beyond that, it uses escape analyse to try and figure out if variables in a method (or methods as the case may be) ever "leak" out. if they don't, then it keeps them entirely on the stack.
I really don't. Look at java byte code. Each instruction operates on values on a stack and returns the results to the stack. If you're discussing heap vs stack you're not talking about the same thing I am.
I used eclipse for a long time and sometimes it was slow and, but I changed to IntelliJ and it is faster than eclipse to me.
A job. I got so much better at loops and arrays when I was given tasks at my job that required me to use these concepts. They even pay me in cash for completing these challenges!
Java's byte code is an intermediate step. The end result after the JIT runs is as I describe. They do operations on a stack because it is easier to turn that stack into n number of registers on whatever the target architecture is. LLVM does something similar with their IL.
kilim is a continuation library for java that uses bytecode weaving (either runtime or AOT) and it [includes a generator class](https://github.com/nqzero/kilim/blob/master/src/kilim/Generator.java) (that's my fork, which is likely to become kilim 2.0) here's an example implementing [XorShift](https://github.com/nqzero/kilim/blob/master/src/kilim/examples/Xorshift.java) public static class X1 extends Generator&lt;Long&gt; implements Loop { public void execute() throws Pausable,Exception { long x, y, s0=103, s1=17; while (true) { x = s0; y = s1; s0 = y; x ^= (x &lt;&lt; 23); s1 = x ^ y ^ (x &gt;&gt; 17) ^ (y &gt;&gt; 26); yield(s1 + y); } } public long loop(long num) { long val = 0; for (int ii=0; ii &lt; num; ii++) val = val ^ next(); return val; } } quasar is a similar library and it may provide something similar too 
see [my comment about kilim](https://www.reddit.com/r/java/comments/6lif41/curious_about_those_javascript_generator/dk0fz8n/). both kilim and quasar do something similar to what you're asking for using byte weaving
After the JIT runs you have native code, which obviously uses what ever the underlying architecture is (and I'm not aware of any mainstream CPU that isn't register based). But hotspot doesn't turn all java bytecode into native code. Java byte code is not an IL. 
The future of the Kotlin APIs will of cource depend on the prevalence of Kotlin. Groovy had some hype (especially with Grails), but never really took off in general programming. Scala's preference of functional programming and the classic Java programming in Spring were never a good fit, in my opionion. Scala programmers prefer (in general) Slick over Hibernate, Akka HTTP over Spring MVC and so on. Kotlin is more like an improved Java, closer to Java than Scala and Groovy. So, it is likely that Kotlin is here to stay. But we will see ...
Wut.
TL;DR? Use method references instead of lambda expressions. But then you could have read the article to discover that.
&gt; If coroutines can yield from subsequently called methods, they are called stackful. Just a note: "Stackful" does not mean that you need to manipulate the call stack to get it working. State-Mashines are fully capable to call nested methods or generators. Calling non-generator methods is trivial, because the call would be atomic and no state would have to be preserved. Calling a genetator-method would create a new state-machine which manages its own state on the heap, not the stack. "Stackful" here means that actually getting a value out of a sub-sub-sub-generator involves calling each one recursively, which is in the end limited by the maximum stack size. But this can be optimized away in certain situations. In Python for example there is a `yield from` statement which yields all items from an iterator (and also throws exceptions directly to the caller, which is an important detail). For normal iterators it is just syntactic sugar and a little faster than a for-loop. If the iterator is a generator, however, the python runtime can optimize away a lot of the call-overhead by accessing the currently active sub-generator directly, no matter how deep they are nested. This way, recursive `yield from` calls are no longer limited by the stack size and there is very little overhead per level of recursion. An implementation of `next()` would first check if there is an active child generator, but instead of calling `next()` recursively it would follow the child-chain until it hits the end, then invoke the state-machine of the deepest generator directly.
If developers at IBM used IntelliJ they wouldn't have to write an article about something that is automatically corrected by modern IDEs.
I think it's fair to say that the majority of the controversy over the JPMS (Jigsaw) is around backwards compatibility. The encapsulation of internal APIs (like sun.misc.Unsafe) has been a particularly big deal. Although developers were never supposed to use these APIs many did and even those who don't use them directly may well be using them indirectly, through frameworks like Spring. The JPMS team have softened their approach to this a LOT since they started. JDK 9 now has the --illegal-access option set to permit by default so if you leave all your jars on the classpath it's a lot easier to run older code unchanged on JDK 9. That's not to say that there are not other changes that might catch you out...
&gt;automatically corrected by modern IDEs. Can you elaborate? Are you saying intelliJ automatically changes full lambda definitions containing only a single method call to method references?
 Not but it offers to replace lambda expressions with method references. 
That's actually pretty cool. Last time I checked IntelliJ didn't support a particular OSGi implementation I needed, so I had to stick with eclipse, but maybe I should see if it's supported now.
I'm not so sure method references improve readability over lambda expressions. It would be true if we have type inference in method reference and we could write something like list.sort(::getName) But since we need to write list.sort(User::getName) I rather read list.sort(u -&gt; u.getName()) And since enterprise Java class names tend to be rather long, I don't like how it looks list.sort(AbstractTransactionalUserSorter::sortByName) 
&gt; Are you saying intelliJ automatically changes full lambda definitions containing only a single method call to method references? It doesn't automatically do it, but it marks the code with a warning and if you ask it for more information it gives you the option to convert the lambda to a method reference.
I like code fights https://codefights.com
Of course, that makes sense, cool.
Thanks Lukas! v2 could be summarized as being * More reactive : more reactive types - Xtended Collections are reactive, Eval, Maybe, Try &amp; Either are all now reactive too. That is you can define a pipeline of execution that is triggered when incoming data arrives . An Xtended List or an error handling Try can both be populated asynchronously. * More functional : v2 introduces simulated higher kinded types, typeclasses such as Monad, Applicative, Functor, Foldable, Unfoldable, and provides Instances for relevant data types. And having a custom, faster, more powerful suite of streaming engines * That allows much faster replayable sequential Streams * Deeper integration with 3rd party libraries. v2 of cyclops-react comes with native Observable (style) &amp; reactive-stream Streaming implementations. Which in turn facilitates much deeper integrations with libraries like Reactor and RxJava2 (in particular with regard to reactive data types and advanced functional data types in cyclops-react). 
One Java EE approach I've been looking at lately for some new development, at least for the back-end, is the Boundary-Controller-Entity (BCE) pattern which is a resurrection of an older pattern and is described in this video by Adam Bien. It feels kinda like MVC except used for the back-end. This structure allows a way to create components based on high-level business concepts. Organizing packages technically I think is fine when first developing a project or for a project that will remain small but when things get bigger and more complicated organizing by business concept seems more reasonable. https://www.youtube.com/watch?v=JWcoiXNoKxk 
Just a public service announcement - this is not what mocks are for. I would recommend anyone interested in the subject of effective mocking to read [Growing Object Oriented Software Guided by Tests](https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627) by Pryce and Freeman, the authors of the [jMock](http://www.jmock.org/) framework. From the OP, the way to test "monolithic" applications using mocks *is exactly the same way* you should test HTTP endpoints as well. As far as the application is concerned, it should not matter that the endpoint is a microservice, a remote HTTP API or otherwise. This lets you set a service contract for your expectations of the remote service specified using a service interface. The implementation contains the details of the HTTP interaction, which you can test *for real*, separately and in isolation from the rest of the application to verify that it meets the needs of the application as specified in the service contract. Otherwise, this mock isn't really testing anything other than you are using an HTTP *connection* API correctly, which doesn't tell you if the REST service *actually* behaves the way you expect.
[removed]
I don't use BCE but I've been migrating to similar packaging. It's easy to work on a piece of the application when the pieces are closer together.
[Been there, done that](https://www.reddit.com/r/java/comments/6lubux/mocking_http_mockito_style/)
Using git for your game saves is one of the more brilliant ideas I've seen. It has never occurred to me to do that. 
Well there are probably plugins fir neovim and the like. But the thing is, javas big ides (eclipse and intellij) are so much superior, that those other plugins always sucked for me. That could be caused by me beeing influenced by the comfort from these before i tried others tho
To be fair, the article headline is somewhat cryptic - "passing through" doesn't mean much without further context.
That's why you read the article
Thanks, it works great, wish that game companies would incorporate it into their products, it wouldn't be all that hard to do.
You may want to consider running a local IDE. You can connect to a remove JVM instance to do the debugging. 
I'm tempted to agree. There are many things which could be done 'the Java 8 way' that I think get in the way of readability. `xs.forEach(() -&gt; {...})` comes to mind, I don't think I have ever thought that made my code more legible than a normal `for (X x : xs) {}` loop
Thanks for the reply! Just now I could connect (sync) via SCP using intelliJ! It works great! 
I like method references a lot. BUT - it makes debugging harder. I don't think you can set a breakpoint at the call site when there's a method reference. Of course you can put the break in the method itself but it's not as convenient. Debugging and lambdas (and rx/java et al) need some new functionality.
I have a solution, avoid Java 8 functional style completely and enjoy many years of maintainable, understandable, debuggable software in the years to come.
In my personal experience, I believe this is something that you'll get used to. Certain things you can do with streams map nicely to &lt; java 8 constructs, and it feels like clutter and reduces readability to do this in a different way. However, streams are much more expressive, allowing concepts that wouldn't map nicely to code, without using steams. I've experienced frustration at specific cases where I felt streams complicated things, and did little for readability. There are still some cases where I dislike how streams work, but usually this have been more my fault than anything else. Generally, I find, if you can use steams instead, it doesn't hurt readability. Even the forEach instead of a regular loop. Works well with other constructs like Optionals, filtering availability, or what not. 
Uh? In IntelliJ IDEA: If you press shift-f7 while in the breakpoint of a function with a lambda, like x.sort((p1, p2) -&gt; p1.compareTo(p2)); it'll ask you if you want to step into the sort-function, the lambda or directly into the compareTo: Screenshot: http://i.imgur.com/ghw2nHO.png edit: And if you use a reference (String::compareTo), you'll get asked if you want to step into sort, or compareTo.
If you're hoping to get a job, I'd go to a job searching site (like glassdoor.com or dice.com) and search for your language there. If there's no listings for python, that might be an impediment.
&gt; Most benchmarks … You did not comment about *most* benchmarks. [Your comment](https://www.reddit.com/r/java/comments/6lldus/apology_to_java_fanboy_rant/djvnicm/) was specifically about the benchmarks game. &gt; Bad because they usually perform no warmup on the code in test. "JVM start-up, JIT, OSR… are quickly effective and typical cold / warmed-up comparison at most of these workloads will show [miniscule difference](http://benchmarksgame.alioth.debian.org/sometimes-people-just-make-up-stuff.html#jvm-startup-time)." &gt; Program size - Usually a silly measurement. … Why does a 10kb vs 100mb executable matter in this point in history? Your comment was about the benchmarks game, but you don't even seem to know what measurements are shown as [program size](http://benchmarksgame.alioth.debian.org/how-programs-are-measured.html#source-code) on the benchmarks game. &gt; All of those things go down in long running processes. 'In stark contrast to the traditional expectation of "warmup", some benchmarks exhibit ["slowdown"](https://arxiv.org/abs/1602.00602), where the performance of in-process iterations drops over time.' &gt; Because the JVM was meant to run on servers first and foremost. https://www.oracle.com/java/duke.html &gt; … in order to avoid spending time allocating memory to try and reduce GC time … Comparisons of program performance must show *memory usage* so we can check for time / space trade-offs.
That's not a method reference. That's a normal lambda. This is a method reference: l.stream().filter(this::test).collect(Collectors.toList()); You cannot set a breakpoint on the "this::test" method reference. You'd have to set the breakpoint in the method itself. Not a big deal but a bit inconvenient.
No, it asks you if you if you want to step into the compareTo or the sort: https://i.imgur.com/MN2uKBs.png 
Yes, I'm making a more subtle point. With a normal lambda I can make this decision when I set the breakpoint. With a method reference I can only do it when the program is run.
Ah, yes - that makes sense. I think this could (and should) be solved by the Jetbrains team though.
I noticed while using method references, that you rarely only apply a single lambda, but rather use multiple maps and flatmap operations which modify the returned type. Just having `u` there and not even `user` as the variable will protect you against refactoring. This will maybe also incline a paradigm shift wrapping the logic differently
I like it semantically. With the method reference it's like saying "sort this list using each element's getName method." With the lambda it's like "sort this list using the result of applying this function to each element that takes the element and returns its name." Of course it depends upon the circumstance, and sometimes the lambda is more readable.
I'm not sure it is solvable, I think the JVM only supports line level breakpoints. Maybe with some smart hacking....
IntelliJ Idea has. Cheers
It should be possible to set a breakpoint on the filter(...) call, let that breakpoint activate a condition, which then allows a second breakpoint (inside the method-lambda) to trigger (These details shouldn't be hidden by the IDE though).
Good headlines draw you in. "An alternative to passing through" is utterly insipid. &gt; That's why you read the article Presumably you would advocate having all article headlines simply saying "Read the Following Article".
I really disagree with their choice to mark it as a warning. There's nothing wrong with a lambda, often they're clearer, but devs overuse method references because IntelliJ tells them to :/
ARM: https://jcp.org/aboutJava/communityprocess/elections/2017-special.html
I agree, but technically it's an Inspection and you are able to configure which inspections to use and how aggressively it should suggest them so it's user preference. This particular inspection is pretty cut-and-dry so I don't really see how it could be abused as it is only ever going to eliminate an unused variable which is a good thing. I guess it can make the code a bit more verbose e.g. .filter(x -&gt; x.isFrob()) becomes .filter(FrobbableFooBarInstanceFactoryImpl::isFrob)
https://github.com/omnifaces/optimusfaces/commit/ac994d0a8403c24ae7a97248c07f9e42181ee3e0
It can also make the line less consistent with the surrounding code, and less clear by removing helpful variable names. Not a big deal, just annoys me when I see teammates "helpfully" changing them.
Sure thing. There are definitely cases where the suggestions go to far, like when it almost always suggests a single-line `foreach` loop becomes a `.stream().forEach(lambda)` call, which can really impact readability. While I'm on a rant, I would love Java to have C#'s extension methods so `List&lt;&gt;` could directly have `filter`, `map` methods etc., rather than having to always lose one line to `.stream()`.
but but but using the 2 colons :: makes me feel smart
So does eclipse, be sure it is enabled.
Here are some of my bookmarks: * https://edabit.com * https://www.hackerrank.com * https://projecteuler.net * http://ludumdare.com * https://www.reddit.com/r/dailyprogrammer * https://www.hackerearth.com * https://www.codewars.com * https://www.reddit.com/r/NerdyChallenge * https://codecombat.com * http://www.dreamincode.net/forums/topic/78802-martyr2s-mega-project-ideas-list
- In my case I'm not going to assume that I'm the Java compiler implementer (am not, of course). - Nor am I going to attempt to parse the bytecode of the generator method and attempt to rewrite it into a state machine around calls to yield. - What is very feasible for me to do is implement the one-shot-continuation style of coroutine - Since the 50 version of the Java .class file format (Java 5) there is a StackMapTable attribute emitted into the Code attribute of methods. This is used by the JVM for type validation purposes. It provides sufficient info for my purposes too. - My approach will be to code-generate save and load methods per each method found in a call stack when a generator method calls yield(). - the call stack will be saved down to where next() was called, the stack will be cut back to next() (as it is being saved it is being popped), and then will return to the next() caller (returning the newest generator value) - when next() is called again, the saved stack is restored, and then control returns to the generator where it last called yield() - with this approach, the generator method will be able to call into arbitrary call depths where yield() can be called from those subsidiary method calls (all the action no longer has to take place in the body of the generator method) - the code-generated save and load methods will be in a class that remains cached in memory for reuse during the program run session - one has to be careful to code-generate a class to hold the saved stack frame to where Object references are saved in Object fields - that way when Object references are removed from the stack they still remain visible to the garbage collector because the references are now stored in fields in heap objects. A one-shot-continuation coroutine still has significant advantages over the multi-threaded async generator. Native thread context switching involves transitions from user mode to kernel mode. Because now all the action is on a single thread, execution can stay entirely in user mode. Nor is there any blocking - at least as due to switching between generator execution and iterator consumer execution. The typical case will usually be 2 to 3 call stack frames having to be saved and loaded - not that much really. But the implementation will be robust enough to allow arbitrary call stack depths. I did investigation of feasibility and its all doable - at least for code compiled by a Java compiler of the last several years that generates the 50 version and later StackMapTable attribute (will throw a runtime exception if it's not present - the fix: recompile the code with a late model javac).
I think this would be better served by calling 'functional style' 'declarative style'. Move beyond the fp hype. Java sucks at fp. But, no matter what language you're programming at the api level, especially) letting your users focus on 'what' and not 'how' is always a win. 
Code and Decode a Caesar Square cipher. Requires a bit of thought and a good test of what you know.
Free easy &amp; simple way to learn java online and much more..
&gt; exorcism.io Should be [exErcism.io](http://exercism.io).
These are two different things, both of which help you evolve in different ways. Think of sports: you do countless "empty exercises" *and* you do practice/friendly matches etc.
...and now there's "Project development continues here: https://github.com/spotbugs/spotbugs"
&gt; Did you go to production with javafxpackager? I shipped an app with it for about 6 months. I closed down the app and company for non-Java related reasons, but it worked OK. I had to write my own auto-update engine for it, but as it happened the app was somewhat security sensitive so this gave me a chance to do a new engine that fitted my requirements better (in particular used hardware signing devices to control the update flow and let users downgrade if anything went wrong). javapackager is not by any means an ideal deployment tool. JWS has quite a few benefits, except that it got blocked by browsers for a long time (fixed in the very latest releases I think, via a new URL handler). If you look at the competition though, it's not like any of them have anything radically better. The web has the best deployment story of all as long as you don't care about offline usage at all (often people do). &gt; We had so many issues we actually have a drawer plan to use electron with our JavaScript port That's pretty extreme. What issues did you have? The biggest one I had was the fact that, lacking any auto update framework, I had to write one, but it couldn't update the JRE. So on the occasions I chose to require a newer JRE I had to push an update that downloaded the installer and ran it. Not a big pile of work to code but not an excellent UX. For pure-Java updates my engine did background updates like Chrome. Otherwise I had a relatively straightforward time with the packager and was pleasantly surprised by it. However, perhaps my expectations were different to yours. Requiring a Mac to build a Mac image did not bother me because I wanted to test my app on each platform I shipped it on anyway - Java's OS abstractions are pretty good but not quite perfect, so you probably don't want to ship code on a platform you don't have/can't test on anyway. I put Windows and Linux in a VM on my development Mac. A few wrapper scripts and it didn't take long to spin new installers.
Reddit is no **self promotion** platform. Your posting history only shows posts from a **single domain** without any other contribution. According to the reddit terms this constitutes as **spam** and is **strictly forbidden**. Continuing like that will quickly lead to a **reddit wide ban**. Reddit lives from active contributors who participate in other threads and promote information without trying to only push self promotion. Should you continue like that, you will be banned from /r/java.
Which means Eclipse is a modern IDE.
There are several reasons for using java. One is Microsoft. 
Their comment: &gt; We do not feel comfortable voting "yes" on the public review ballot for JSR, 375, given the lack of clarity in the documentation, missing support for other valuable technologies like OpenID, and outstanding issues such as issue #76 on hardcoded values in the code. While we know it's not possible to get everything perfect in one step, security is an enormously important topic (one that has frequently given Java a bad name) and we would like to see a specification which reflects this. &gt; We appreciate it is very late in the process to give such feedback, and also understand that much more specific feedback and suggested actions will be required by the Expert Group in order to address our concerns. We are working on a more detailed response and will be reaching out to the EG directly shortly.
I could also shoot myself in the foot...
I think the point of GOOSGB is that you start with a thin slice end-to-end test, and work your way down, mocking the collaborators until you eventually have everything tested. When you do this, then at some point you are supposed to have to tested all the "real" code in isolation, right down to the network calls with an external service. What OP is suggesting is testing this with *network level* stubs as opposed to mocking, and opposed to using the real external dependency. This provides a middle ground of being able to test close to real interaction with the external dependency at the unit or integration test level. If he had opted for mocks then he would end up finding problems with the HTTP client far too late in the feedback cycle (when it's tested for the first time in a higher test, which could involve waiting for deployment) If he opted for the real service, there might be lots of constraints preventing that from being possible, such as deployment overhead, managing its state, cost, third party ownership, and in OP's example verification. In other words, if you're going to unit test most often, you might as well make sure those unit tests give you the best feedback they can, which isn't with mocking and isn't easy to do with a real external dependency.
&gt; and outstanding issues such as issue #76 on hardcoded values in the code. If you follow the EE list at https://javaee.groups.io/g/javaee-security-spec/topics you'd see that this has been solved already, but the vote was purely based on what was presented in the public review I think, where that wasn't the case yet.
Folk around here were asking for more Java podcasts - we just pushed out our latest EP the other day, hopefully we can get outselves back into a more regular rotation of episodes...
You're exactly right, I've corrected it. Thanks!
Alternately, you can run your IDE remotely over an SSH Xwindows tunnel.
I hated Java myself. But there were reasons, now Java is a lot better, it evolved. Back in Java 1.3 it was slow as fuck and language lacked many features, you had to write shit tons of boilerplate and everyone was using XML configs which were bigger than your business logic. These days are long gone, I'm happy now!
"On 2017-07-10 JetBrains s.r.o. voted No with the following comment: We do not feel comfortable voting "yes" on the public review ballot for JSR, 375, given the lack of clarity in the documentation, missing support for other valuable technologies like OpenID, and outstanding issues such as issue #76 on hardcoded values in the code. While we know it's not possible to get everything perfect in one step, security is an enormously important topic (one that has frequently given Java a bad name) and we would like to see a specification which reflects this. We appreciate it is very late in the process to give such feedback, and also understand that much more specific feedback and suggested actions will be required by the Expert Group in order to address our concerns. We are working on a more detailed response and will be reaching out to the EG directly shortly." 
https://www.reddit.com/r/java/comments/6ml38o/java_ee_security_api_passes_public_review/dk2dpto/
A clean link without all the tracking info: https://docs.microsoft.com/en-us/java/azure/
&gt; I think the point of GOOSGB is that you start with a thin slice &gt; end-to-end test That's TDD, which the GOOS book also describes very well. &gt; mocking the collaborators until you eventually have everything &gt; tested. The GOOS book describes testing using user acceptance tests first, which are functional tests and integration tests. Mocks come at the end, during unit testing. That's where the GOOS book provides specific advice about mocking with interfaces which describe application level protocols, which are grown organically using mock driven testing. &gt; What OP is suggesting is testing this with network level stubs as &gt; opposed to mocking, and opposed to using the real external &gt; dependency. It is a very bad idea to mock network stubs at the HTTP level, which makes the mocks useless. Imagine the service provider changes the API from HTTP GET to HTTP POST. By mocking at the network level, you wouldn't catch this change, because you don't own the change vector, and the mocks are useless. If you mock at the application level, you are setting application level expectations, for example querying for widgets. The implementation of the interface must meet those expectations, such as using HTTP GET /widgets to query for widgets. The test of the implementation is a real integration test, so a test failure would catch the API change, while the rest of the application is undisturbed. &gt; If he had opted for mocks then he would end up finding &gt; problems with the HTTP client far too late in the feedback cycle Not if you write the functional tests first, as advocated by the GOOS book. Also, if you're writing integration tests, you have isolated tests which use the real service, so you catch problems now and in the future. Also, you're not catching any problems with the HTTP client using mocks, because a mock doesn't do anything except set expectations &gt; If he opted for the real service, there might be lots of constraints That's a broader point not covered by mocking, but incremental development in general. The GOOS book addresses this point through the "walking skeleton", the minimum necessary functionality required to fully engage the feature's dependencies, so you are addressing issues by integrating early and often. &gt; if you're going to unit test most often Unit tests aren't the only kind of test, and you should run the other kinds of tests often too. &gt; you might as well make sure those unit tests give you the best &gt; feedback they can The best feedback unit tests give is for logical consistency. Integration and functional tests give best feedback for interoperability with other systems. &gt; which isn't with mocking Mocking is for unit tests to specify expectations of external dependencies in application terms... &gt; isn't easy to do with a real external dependency ...so that the complexity of dealing with an external dependency can be isolated away from the unit, and that complexity can be isolated to its own module which has the single responsibility of meeting the application expectations. This makes things a lot easier. 
So long as Microsoft restrict themselves to their own projects, they can do whatever they want.
The reason why "@Autowired" is not required in the Kotlin CustomerController is because it is not actually required in the Scala or Java versions either. This has [not been necessary in Spring since 4.3](https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3), as long as your class has a single constructor. The controller annotations can also be made significantly shorter (again since Spring 4.3). For example: @RequestMapping( value = "/{id}", method = arrayOf(RequestMethod.GET), produces = arrayOf("application/json") ) can be written just as: @GetMapping("/{id}") The method is now part of the annotation (which is meta-annotated with @RequestMapping) and there are equivalents for each HTTP verb. In addition, the produces/consumes does not seem to be necessary for me. My application produces and consumes JSON just fine without needing to specify this.
nice catch
Right, it's been some time since I've played with setting up a Spring app, things seem to have changed (for better). I'll try this tomorrow and amend accordingly, thanks :)
If you need full compiler experience with ide then go for Vadin / GWT, otherwise its not worthy to start learning it. Google developed Angular to override GWT (Vadin is based on GWT) :::: a clear message that GWT as a web front end framework was not good development decision.
I wouldnt learn it if I were you. If you really want to do something else than using the great javascript frameworks (like Angular or React) just go with JSF2/PrimeFaces. Just gives you better/more job opportunities 
Vaadin is rad. I recommend it.
I would go with Vue for fun, JSF for jobs. 
The nice thing about Vaadin is that it tries to make the browser-server divide invisible. Unfortunately, it's a fairly heavyweight framework, incorporating its own UI elements and other things. I haven't seen it widely used "in the wild", especially in recent years. At the risk of shamelessly plugging my own library, [kweb](http://kweb.io/) is similar, but a much lighter-weight. You can use it with any JavaScript library or CSS framework. Oh, and you use it with [Kotlin](http://kotlinlang.org/), an excellent programming language with full bi-directional interoperability with Java. It's still experimental but I'm making good progress on it, looking for volunteers to help with it.
Thank you for producing such a useful comparison of these languages at this level. Its a great idea and one that I will probably adopt when recommending Kotlin to others. You might also be interested in the enhanced Kotlin support coming in Spring 5 which should make the Kotlin examples even nicer: https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0
No
And we all know how great Angular is /s Vaadin is fantastic, and GWT is a live open source project, so I wouldn't worry about that.
I love Vaadin. I got to use it in a couple of internal projects. It's so wonderful to stay in Java and not have to context switch to Javascript. To answer your question, it's definitely worth learning, but if the purpose for learning it is for a job, then no, no it's not worth it. Best to pick one of the hundreds of Javascript frameworks that exist. But Vaadin is awesome. Dammit...
Hopefully I'll never have to write jsf or jsp again. But I know I will at some point. Jsf is painful compared to pure client side ui frameworks.
Some of the Java ugliness is fundamental to the language, at least with current versions. Using standard layout, not squishing things that are normally spread across multiple lines into a single line, an object "Person" with instance variables "first" (String), "last" (String), and "dob" (Date) with a convenient constructor so you can do Person bob = new Person("bob", "smith", new Date()); will be 11 lines long. If you use idiomatic getters and setters - which are handy for injecting validation - it will be 29 lines long. If you implement hashCode() and equals() so it works properly with sets, lists, and maps, you're up to 35 lines long. Even if you wanted to represent the same information with a simple map, before Java 8 you had to import a third party library, or write your own helper, or else do: Map&lt;String,Object&gt; person = new HashMap&lt;&gt;(); person.put("first", "bob"); person.put... four lines of code plus two import statements. Java 8 has some syntactic niceness to simplify it, but it's still an import statement. That's all but unavoidable wankery. Contrast that to dozens of languages in which you would do something like var person = { "first" : "bob", "last" : "smith", ... } and go on your merry way. Java has a lot to recommend it, but it's inescapably verbose. Major surgery to the language would be needed to fix it. (Edit: take any Java program that's 1000 lines or longer and written in an idiomatic style and rewrite it into Scala, Kotlin, Clojure, or Groovy. You'll probably shave 500 lines. You might shave 900.)
Even the best get it wrong often enough for it to be a problem. Hence the monthly security updates for Firefox, Chrome, or for that matter the JVM. :)
Maybe a Groovy version too?
As far as I know Google doesn't even use angular themselves much. I am not a fan of angular, I purposefully left them out in favor of react/Vue which I think are better. I looked at gwt in the past. But I don't see many people using that still today. Vaadin looked like an interesting project, but I also don't see anyone using it.
Neither I am in favor of angular (no more), after delivering few applications with angular I have realized that selecting angular was a mistake. . Worst development experience . Poor performance . Large bundle size (even after gziped) I wonder what was in the mind of people who brought the idea of angular on google's table :) , and this was after the failure of GWT. (Sorry no offense). 
Nice write up, I'm definitely curious about if there is some tricks to make Scala work better with the underlying Java API in these cases. From my own experience, this is the cost of having to interop with Java at the POJO level, where you give the framework access to your objects. It really is dissatisfing. And I agree with the conclusion, if you want a better Java and you want to use Spring/Spring Boot, stick to Kotlin, Scala just isn't a good fit for the Java frameworks. I really appreciate the clarification in the conclusion, where you mention tradeoffs and mention that if you were to use Scala, stick to the Scala frameworks like Play. Very nuanced view, and nice and objective reasoning. Thank for a nice informative post. Sincerely a Scala developer/enthusiast. 
It depends on what kinds of jobs are you looking for. There are many enterprises that write every internal application in Java and for them tools like Vaadin or Spring are always in demand. On the other hand, a modern all JS shop that hates java would not touch Vaadin at all. 
My biggest take away is that Goldman-Sachs is on the JCP. I had no idea.
I can't find anywhere the Glassfish 5 release date. Any idea of when will it be?
try http://codingbat.com/java 
It depends what you want out of it. If money, just pick what the stats say on the job boards. If experience, learn GWT. I think Vaadin is a bad idea, but I think GWT is the best browser technology out there. It has a very steep learning curve though, which is why engineers abandon it. If you do pull through however, you're rewarded with a deep understanding of the fundamentals of how browsers work, which you wouldn't get with other tools. With GWT all you really have is a compiler and the guts of the browser. I enjoyed working in it thoroughly and to this day can always answer others when they have a problem with browser events or dom manipulation. 
Well, I've been working with it the last year, in a some kind of small company, so maybe this could provide a bit of insight: I've never really liked front end development, but always been dragged towards HTML/Javascript and whatnot. Not having to switch language and being able to "learn a tool" in my "native" language is a BIG pro for me, and possibly the best part of the framework. Taking into account that I did not set up the Vaadin component in our project (That was the Analyst's job, and it seems he used the same approach used on an old application) and that I've "only" created views (pages) like there's no tomorrow and messed around a bit with other components, I wouldn't say that Vaadin is complex or hard to "get" and begin making stuff with it, at least on the most "front" part. It works, feels and writes like bad old swing, just with CSS to make your life more miserable. Yeah, I hate CSS too. For the rest, well, our company has been more than a decade with their "vaadin legacy big application" in production. The new development went live some months ago, and both apps are maintained and worked on with ease. Vaadin launched some time ago Vaadin 8, although we are using 7 for our development, so it seems that the framework is still being worked on, and their documentaiton, without being top notch, is good enough to not having to ask our "know it alls" continously. Actually, the source of most problems is in old, legacy design and architecture decissions only one person understands. So, the tl;dr could be: Hey, at least my company uses it, it works quite well and is not specially complex to learn, specially if you know Java. I'm most possibly in a different continent than you, so I can't really talk about the potential public outside, but at least you got this. 
Jasypt 1.9.2 RELEASED! (February 25th, 2014) http://www.jasypt.org/
Probably with the release of JEE 8. Does that have a release date?
For JEE 8 [there is a proposed final draft](https://javaee.groups.io/g/javaee-spec/topic/java_ee_8_proposed_final/5433704?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,5433704), but it looks like [nobody knows](https://javaee.groups.io/g/javaee-spec/topic/java_ee_8_release_date/5143806?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,5143806) if it will support Java 9 and be released in September or just be released in July as planned. 
Did you know that Fujitsu has a Java EE 7 AS?
X-Post referenced from [/r/kotlin](http://np.reddit.com/r/kotlin) by /u/shyiko [A human-friendly alternative to cron written in Kotlin](http://np.reddit.com/r/Kotlin/comments/6mjwbw/a_humanfriendly_alternative_to_cron_written_in/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
As far as I can see , kotlin provides no benefits whatsoever. Is a bit different, but if you have to **not** use java but be on the jvm, I guess kotlin will have to do.
Thanks for the thorough response. It's some what assuring that people at least are using it. Difficulty of swing isn't too much of a good sign though.
I've never heard of anyone who HAS to use the JVM but NOT java... I guess in this example Kotlin doesn't 'shine' but for the stuff I do, I 100% prefer writing Kotlin over Java. I like that its less verbose, I like the stuff they're doing with co-routines and I love data classes.
Kotlin is nice.. i work with gosu from time to time... I still prefer java at the end of the day for reasons I cannot explain. 
sigh, here it comes again: "less verbose" when 99% of that crap gets written by the ide anyways. is this idiocy a millennial thingy? or just some people are that stupid?
As configured, you basically just prevent the client from requesting XML instead of JSON. If you don't specify, both are available.
Regardless of what writes it, you still gotta read it later.
Why would that be a problem?
I only had a quick glance, but really imho not much point to this. Like you said, it is very basic and too narrow of an example for any kind of sensible comparison. Only for newbies to learn from maybe, which I wouldn't advise either since it didn't look like the author had much knowledge in any of the languages either. Like that stream to concatenate firstName/lastName in Java. Like what. Just use projections and map it to a virtual property annotated with a simple spel expression.
I haven't worked with kotlin or Scala, but if Java would scrap backward compatibility to fix type erasure, add generic enhanced enums, and syntactic sugar for less verbosity, I would be happy. Also, binding arrays/collections on annotations would be nice along with repeatable annotations that cdi could support for qualifiers... And standardized immutability for all object types... And an inheritance model for the newly added static methods on interfaces... And support for anonymous tuples... And union typing... And probably a lot more. There's actually a lot that Java falls short on. Now I'm sad. I actually love how Ceylon handles typing. Pretty robust. Hopefully a future trendy jvm language will adopt the lessons from Ceylon typing.
&gt;I'm sad [Here's a picture/gif of a cat,](http://random.cat/i/Oxn8G.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
[removed]
Nice write-up. But this is a simple CRUD application, which will be more or less identical in any language. I'd rather see some business logic expressed in different languages. Also, what's missing is Java+Lombok which makes writing POJOs much more sane. Thing that turns me off Scala at the moment is atrocious compile times, even with incremental compiler. And second-class citizen IDE support as well. I'm on Eclipse. Netbeans doesn't even support it any more. And I cannot use IntelliJ where I work.
That would depend on your use case. In general, it's not a problem.
&gt; One annoying thing that needs to be pointed out is the necessity to use arrayOf() inside the annotations if they take more than one parameter (except for the default value). in kotlin 1.2 there will be array literals for annotations so that at worst it is then as verbose as java to use annotations source: https://blog.jetbrains.com/kotlin/2017/06/early-access-program-for-kotlin-1-2-has-been-started/
I think your assumptions about not being good at Scala are correct, and thus they made your code longer. A case class should have worked. You could have also used the Scala Long and not the java long. 
Why can't you use IntelliJ? Do you have custom plugins people wrote for eclipse that you need to use?
Why are you reading generated code though? 
Ah, 3 years to late I guess. 
Stupid big corporation rules. No real reason, it's just blocked.
It depends, but for example if you don't follow best practices and use @JsonIgnore, you might be surprised that XML doesn't honor it and sends the attribute to client :-) (for XML you would have to use @XmlTransient or even best don't use these annotations at all). 
Cause you can't tell later if it was generated or intentional 
JWS had a lot of issues. Javafxpackager has a very painful deployment process with multiple tools and really complex signing support. But that's just our pain as developers (not end user pain). I had some issues with some users where apps installed one on top of the other. Another pain is the 64 bit Windows binary which is "arguably" Microsoft's fault. The resulting app/installer process looks bad/amateurish. In Mac OS you need to customize a few things (window sizes, background images etc.) to make it look decent. On Windows I didn't find a way to make it feel elegant. App size was ridiculous due to our need of JavaFX (for media and webview). Shockingly cross compiling to JavaScript and packaging with Electron resulted in a usable, smaller app... In both Mac &amp; Windows submitting to the stores is problematic and AFAIK impossible on Windows. .net apps have a better deployment story for Windows and sadly so does Electron. Right now we have a UWP build target that builds native .net apps from Codename One Java apps, so we can build a native UWP app that we can distribute thru the Windows store for desktop and mobile. It's only Windows 10+ but that's probably good enough for the top tier of developers.
I could've, and I tried that, and it compiled fine - but there were errors on runtime as the underlying ORM complained about the entity class. I was sure that a case class would work as well. Maybe I'll give it another go.
I dislike Lombok [because it's a hack](http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html) so I try to avoid it as much as possible but accept it when necessary.
One book to rule them all? No, doesn't exist. Not sure what level of knowledge you are at, so following advice assumes beginner. First decision you might have to make, Java EE or Spring. Both are valid in my opinion and have their pros and cons. My recommendation, start with Java EE and progress to Spring. It is easier for Java EE knowledge to be carried over to Spring, not the other way round though. But no problem if you start with spring and want to be a spring specialist. Regarding books. Always start with official documentation or tutorials, they explain the concepts the best. That should give you an idea of the building blocks and how your application may look like. Now you should've started having some targeted questions for maybe JPA, or Webservices or performance etc. Now you can look for books or blogs that solve that problem. I would highly recommend taking a look at https://www.safaribooksonline.com/ they have a great collection, have video courses and now even live training. I think they offer a free trial, give it a shot. 
right. so? just a bunch of gets and sets. wtf are you reading about it? and how can you say that it takes more than 500ms to skim through 100 of those. I mean, it would take me good amount of seconds to read simple ObjectiveC code, simply because it's wierd and i never wrote a line of ObjectiveC in my life. But ... java? the damn old gets/sets? WTF?
&gt; Like that stream to concatenate firstName/lastName in Java. Like what. Just use projections and map it to a virtual property annotated with a simple spel expression. Yeah, or use an `AbstractFactoryFactory` to build a `StringFactory` and then provide the `String` through that :) Sorry for being mean, but I believe you're overcomplicating what is **intentionally** supposed to be a **basic example**. And yes, the post is aimed at newbies.
Meh, one man's hack is another man's clever use of forward looking compiler feature. As long as it doesn't cause problems- and I haven't run into situations where it does (yet), I think it's OK. And I'd argue it's more maintainable than boilerplate code generated by an IDE. And that's what matters. Because I've seen many many times where hashcode and equals were generated, then properties were added, and hashcode and equals were not updated. Lombok at least solves that.
Kotlin is supposed to provide modern language features that Java can't just simply throw in due to all the legacy luggage. My post isn't aimed at exposing Kotlin's advantages so it doesn't really show them. I like Kotlin personally, though, and I believe it does [improve on Java quite a bit](https://github.com/MindorksOpenSource/from-java-to-kotlin).
Thanks for your opinion and for actually reading the post, many people seem to not do that and yet comment :) It seems that the Scala interop with Java in this example can indeed be done better as few people have pointed out to me. Some kind soul even submitted a [pull request](https://github.com/rskupnik/pet-clinic-jvm/pull/1/commits/aaff1e297d7673d009800c7788e638d88db59cce) to improve my atrocious Scala code and it looks much better (not tested if it works yet, though). I still think it should be possible to create an entity class with a `case class` in Scala, just as it was possible to create one with a `data class` in Kotlin, but it keeps breaking at runtime.
Good to know :)
Yes, I agree it's very helpful, but you have to consider it uses an internal API to achieve what it does and as such it can simply stop working with new versions of the JDK. As far as I'm aware though, Lombok plugs in at compile phase, so at least it won't break at runtime if you decide to upgrade the JRE on your production machine. I'm keen to use it in my personal projects but I just can't throw it into some client's project without informing the product owner first about the potential danger. On the other hand, there's delombok if you ever need to go back to classic. On yet another hand :) I've never used delombok on a huge, enterprise class application, so I don't know if it would handle the potential disaster.
&gt; Difficulty of swing isn't too much of a good sign though. Sorry, but english is not my first language, what do you mean with this? 
Are you talking about the old AngularJS (1) or about the new Angular? Because with Angular 2+ development experience and setup is actually much much better/easier than any React project i have ever seen, thanks to AngularCLI. Bundle size is bigger, that's true, but you shouldn't forget that Angular is more like a "full-stack-framework" with everything you need, while React truly only handles the frontend part. So measuring bundle size is like comparing a full car to an engine. OF COURSE the car is heavier, who on earth would expect something different? Performance of Angular is pretty impressive. Just take a look at angular.io. That page is about the fastest webapp i have ever seen. Now they use webworkers and clever bundling + lazy loading, but its still a living proof for how good Angular is.
This underscore thingie... Why not recycle the `?` character instead? ? -&gt; foo() (a, ?) -&gt; foo(a) After all, it's a wild card...
At first glance it does seem more consistent with the use of wildcards in generics. I can think of three reasons to not use it: 1. There is a difference between this (proposed) use of ? and the existing use for wildcards. Here ? would mean simply a parameter that has no name as it doesn't get used. The ? wildcard in generics denotes any type that satisfies the constraints. To me they feel like fundamentally different concepts - something that's nameless vs a match on something. 1. Scala has already established a convention of using underscore. 1. It's a smaller change to the language syntax. Underscore is already a valid parameter character, so this way they simply make the small subset of programs that are currently using a single underscore as a param name invalid. Then, as a second step, underscore is allowed to denote a name-less parameter. Your alternative of using ? would entail changing the language syntax to allow it.
yea, i've seen articles like that. from where i stand is at best a huge, big yawn, followed by a meh. had it come 8 years ago (when groovy had all of this and more) sure . but now if i want that, there's groovy and to be fair, i don't even care that much even about groovy's features. it's a .... meh.
I'm not sure what you mean by "articles like that". I'm not trying to advocate "Kotlin/Scala will replace Java" or sigh in wonder for any of those languages - it's just a simple experiment as both languages claim Java interop so I was curious how that actually works in practice (basic practice, but still).
I don't think you will see Vaadin usage on the internet a lot, because Vaadin is not much used for web sites or as a framework for OSS projects. In my experience, it's mainly used for in-house projects and admin UIs. Vaadin as a company seems to be growing quite nicely, they have 140 employees and $11M revenue these days. I've developed a [complex UI](https://www.ej-technologies.com/products/perfino/demo.html) myself with it and the experience overall was very good. Btw, if you do not want to use the server side part, you can still use Vaadin as web components: https://vaadin.com/elements
&gt;Scala, on the other hand, is integrated via a plugin All language support is implemented via plugins. Java support is also a plugin. Kotlin has been designed to be tooling friendly. JetBrains spends a lot of time and effort on their Scala plugin, but it's just harder to do. The commit history of https://github.com/JetBrains/intellij-scala is quite impressive.
Sorry but I think you might be misunderstanding the suggestion. Whilst I understand that it is intentionally written to be basic, if it is aimed at newbies, I would not want you to teach them bad habits. What I proposed is pretty much a go to for what you are implementing yourself when used spring data jpa, with vast benefits over the current code. It would not have complicated an example, it would be 1-2 lines of extra code, for this simplicity case could've kept the projection interface within repository. Benefits are that it would've kept your service layer clean (or controller layer in your case since you skipped it for simplicity's sake) and make the code reusable. Not to mention it would've optimised the query and you would've pulled back only the fields you needed and wanted to display. A lot more efficient and quicker. Its just a standard for things like this.
**Sidebar**: + **Do not post tutorials here!**
I don't know much about the Windows app store. I believe there are JavaFX packaged apps on the Mac app store, but I didn't want to distribute through that platform anyway. It's clearly not a priority for Apple, and I wanted something that would do updates on Windows and Linux in a unified way. I thought the default appearances of the installers were plain but acceptable. You see the Mac DMG background for a few seconds at most, so I put my visuals work elsewhere, and JavaFX was quite good for that with all its support for animations and effects. The installers are very large, yes. I hope Java 9 will help with that a bit, but I doubt it'll make a big difference as you can't separate AWT, Swing and JavaFX unfortunately. Perhaps they will modularise more in future. I sometimes did manually strip code out of the JRE that I was sure I wouldn't use to make a smaller download, but none of my users complained about download sizes in the end. Perhaps with more users I'd have noticed some difference in conversion rates with a smaller installer, but my app was niche and that wasn't really an issue. I can imagine that if you need WebView, which is most of Electron anyway, then Java+WebView would be larger than Electron yes. It's more frameworks.
If it's as hard to use as swing, it's not a good sign of it's overall usability.
If it's as hard to use as swing, it's not a good sign of it's overall usability.
so instead of the cron grammar you have a different grammar. Which, to me looks more complex and error prone since you don't seem to have a NLP in there. Or do you?
&gt; To me they feel like fundamentally different concepts - something that's nameless vs a match on something. You mean like recycling `super` for contravariant generic type bounds? Or like recycling `static` for nested classes? Or like recycling `&lt;` and `&gt;` for generics (when they were comparison operators before)? :) &gt; Scala has already established a convention of using underscore. Scala also uses the underscore for generic wildcards... &gt; It's a smaller change to the language syntax But they made the underscore a keyword in Java 9, from what I understood. So I'm not sure if that's a reasonable argument here. In any case, it's just a parser token that is replaced by a semantic token in an early parser phase (I think). So. I rest my case. At second glance, `?` would still be more consistent with the use of wildcards in generics...
Doesn't seem to be a very useful article.
Huh, I never saw Swing as a "hard to use Framework" (save, now that I remember, some stupid shit with inner classes on tablets). You got some classes to "act as" CSS divs, then some specific "layouts" to distribute your stuff, and that's all. For instance, you can have something like that: CssLayout example = new CssLayout(); example.addStyleName("nameOfACSSStyleSomewhereElse"); Label label = new Label("Hello World"); example.addComponent(label); //This should be in another element that is initialized when the view is called, and blah blah. More complex elements or distributions imply more complex use of this basics, but in the end, it's just stack stuff on divs to get what you want and create some listeners for clicks or text changes. Also, at work we have an Abstract class to manage all the "more weird" stuff, so you only have to put stuff in a child, specific class and that's all. I've gone a bit further and created a "template" class for new views that covers the basic elements the Abstract class initializes. Also, take into account that the generated HTML is all but optimal. The idea behind Vaadin is not making it super efficient but keep the developer working in Java, so if you know a bit of actual HTML chances are that you get a heart attack weh
Well if your pojo code is generated just mark it with an annotation or a comment 
I'm currently working on a Vaadin project that will essentially be a customer facing portal for existing clients of ours. I don't think that it has a particularly complex learning curve if you already know Java, and ties in with Spring fairly nicely (which is what we wanted). I don't know if there is a particular benefit in learning how to use it unless you are working for a company that already uses it as a framework (or is planning to use it), but I also don't think that it's really something that you need to "learn" to be able to use, it's all just Java code (and some CSS), so if you are a Java dev already then I don't think that you will find much of a learning curve to it. (Compared to being a Java dev and wanting to use something like React, where you may have to learn how to use JavaScript). 
Apologies. Did not read.
&gt; You mean like [...] No reason to repeat past mistakes. &gt; Scala also uses the underscore for generic wildcards... Underscore is generally regarded as overused in Scala.
Can I ask you why?
centralised IDE configuration is one of the reasons because Eclipse stores that on your workspace so every time you change workspace you have to reconfigure your ide (or copy the config files from your previous WS which is not very elegant IMO).
Yeah, well Scala has mixed-site variance, Java only use-site variance, so I can certainly understand why it's regarded as overused. That might change if we get [mixed-site variance too](http://openjdk.java.net/jeps/300)
Not a fan. What if the API provider changes this GET request: Client client = ClientBuilder.newClient(); Response response = client.target("http://openlibrary.org/api/books") .queryParam("bibkeys", "ISBN:" + isbn) .queryParam("format", "json") .queryParam("jscmd", "data") .request().buildGet().invoke(); to a POST? All the mocks you set up have become completely useless, and worse than useless, your tests are now *lying to you*. Instead, what if you did this: private BookService bookService; @GET @Path("/get") public Response getBook(@NotNull @QueryParam("isbn") String isbn) { Map&lt;String, Object&gt; book = books.get(isbn); if (book == null) { System.out.println("MISS: " + isbn); books.put(isbn, bookService.findByIsbn(isbn)); } else { System.out.println("HIT: " + isbn); } return Response.ok().entity(book).build(); } and: public class OpenBookService implements BookService { public Book findByIsbn(String isbn) { Client client = ClientBuilder.newClient(); Response response = client.target("http://openlibrary.org/api/books") .queryParam("bibkeys", "ISBN:" + isbn) .queryParam("format", "json") .queryParam("jscmd", "data") .request().buildGet().invoke(); book = response.readEntity(Book.class); } } Now, you can mock `BookService` to your heart's content without hitting a real web service, with zero cost. Better, how the HTTP API is implemented is of no interest to the application. Since `BookService` is *your* interface, it won't *lie to you*. This means, you can test the `OpenBookService` in an integration test, in isolation and a different run profile (run much less frequently than the unit tests to avoid hammering the remote server). Most importantly, if the API changes, the integration test *will fail*, allowing you to *actually catch the API change*. You can change the implementation in one place to conform to the *application's requirement*. Another benefit, you can do this, and let your middleware do the caching (or use a decorator), instead of a bunch of ad-hoc, in-place caches: public class OpenBookService implements BookService { @Cache public Book findByIsbn(String isbn) { // ... } } So the REST controller becomes just this: @GET @Path("/get") public Response getBook(@NotNull @QueryParam("isbn") String isbn) { return Response.ok().entity(bookService.findByIsbn(isbn)).build(); }
Checkout out Immutables or AutoValue if you like the idea behind Lombok, but hate the implementation.
The grammar is pretty strict (and is fully compatible with [GAE](https://cloud.google.com/appengine/docs/standard/java/config/cronref#schedule_format)'s). Having NLP wasn't the goal here. What we needed was a way to express some of the schedules that are not possible or too complex with cron, e.g. "every 45 minutes", "1st monday of january,april,july,october 12:00" in a human-readable way.
That is just a date in ISO 8601 (ZonedDateTime is part of standard java API). Examples are listed [here](https://github.com/shyiko/skedule#format), e.g. `every 5 minutes from 10:00 to 14:00` (which is the same as arguably less readable `*/5 10-13 * * *` cron expression).
Which is yet more work that should be avoided by simply allowing a bean syntax in the language proper rather than forcing you to use boilerplate / generated code. Any code at all that one must write to solve a problem is a necessary evil and generated code is no exception.
Interesting but it hasn't seen any activity in a year.
Didn't we see one of these, like, a week ago? There was discussion about how they plan to break the browser sandbox, and the utility within the context of Node.js...
wiremock? 
I'd start with a classic: [Patterns of Enterprise Application Architecture](https://martinfowler.com/books/eaa.html) by Martin Fowler. He [blogs](https://martinfowler.com/tags/application%20architecture.html) a lot on topics related to enterprise architecture. I'd follow up with another classic: [Domain Driven Design](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) by Eric Evans. Martin Fowler has a [lot to say](https://martinfowler.com/tags/domain%20driven%20design.html) about DDD as well
I'm loving WebFlux.fn It's bringing me back from using Vert.x for my rest APIs
meh just use consul :P 
&gt; consul It's kind of ironic to me that service discovery was solved in SOAP but FE devs couldn't stand yukky XML so now we have REST (which is not contract based, purely guidelines only), JSON (not ugly I guess), tons of KV systems, etc. to solve what SOAP and its surrounding ecosystem (mostly courtesy Microsoft and approved WS standards - can't stand to admit that) had already solved.
If it just holds properties, why not make the fields public? 
https://stackoverflow.com/questions/11071407/advantage-of-set-and-get-methods-vs-public-variable That said, both getters/setters and public fields are highly overused. If you're going to have a design with proper encapsulation, then not every member needs to be publicly visible. That should not be the default.
if you fire up the demo ,they talk about running javascript with nashhorn... like, javascript running on java running on javascript. JAVA(script) INCEPTION 
I added a comment on the article itself, regarding the thread safety issues of the cache/counters for the books.
if only there was some sort of way I could have found that out - like an announcement or something... oh wait, another apache project fail.... it's too funny 2/3 of these apache projects I've never heard of announcing releases and such... every time, I wonder WTF is that. So, I thank you /u/i_got_jiggy_with_it for doing the heavy lifting!
[Cheerpj?](https://www.reddit.com/r/java/comments/6i6ht8/cheerpj_a_java_bytecode_to_javascript_compiler/)
I'm one of the 10 people who uses this project so I'm excited
And thankfully there's a Tika In Action book to help me. 
&gt; Are you talking about the old AngularJS (1) or about the new Angular? Do you crazies listen to yourselves? 
Yup... that was the one.
I'm one of the others, so I'm excited too :) 
Also, you can do away with the actual OpenBookService by using something like retrofit. Makes testing so much easier.
We must go deeper. Run DoppioJVM in nashhorn which runs in DoppioJVM which runs in nashhorn which runs ...
I have just tried Tika 1.16 in a 'search for text in documents' application and the performance is much worse than Tika 1.14. Searching for 'Einstein' in $COMMON_TEXT_DIR (2nd search): tika-app-1.14.jar: 292 Found, 0 Failed, 29.79 s. tika-app-1.16.jar: 292 Found, 0 Failed, 160.08 s. 
What you mean by full stack (in context of angular), is there some new concept full stack front end framework ? lol
I'm reading this example: DataFrame.read().csv(options -&gt; { options.setResource("http://zavtech.com/data/samples/cars93.csv"); options.setExcludeColumnIndexes(0); }).rows().select(row -&gt; { double weightKG = row.getDouble("Weight") * 0.453592d; double horsepower = row.getDouble("Horsepower"); return horsepower / weightKG &gt; 0.1d; }).cols().add("MPG(Highway/City)", Double.class, v -&gt; { double cityMpg = v.row().getDouble("MPG.city"); double highwayMpg = v.row().getDouble("MPG.highway"); return highwayMpg / cityMpg; }).rows().sort(false, "MPG(Highway/City)").write().csv(options -&gt; { options.setFile("/Users/witdxav/cars93m.csv"); options.setTitle("DataFrame"); }); And I'm thinking: INSERT INTO cars39m SELECT cars93.*, "MPG.highway" / "MPG.city" AS "MPG(Highway/City)" FROM cars93 WHERE Horsepower / (Weight * 0.453592) &gt; 0.1 ORDER BY "MPG(Highway/City)" Great. What have we gained from this SQL-esque DSL?
Writing a non-optimising bytecode interpreter is pretty easy. There's around [200 byte code operands](https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings) and is stack based, but many of them do very simple things. For example, you have about 20 that just put constant values on the stack. `iconst_0` for example just puts a int 0 constant on the stack. It's one of those 80/20 rule things where 80% of the time is spent implementing 20% of the functionality. Of couse, HotSpot does so so so much more than just interpreting java byte code. And of course, you need to implement enough of the runtime library to work on your JVM. https://github.com/plasma-umass/doppio/blob/master/src/opcodes.ts is their opcode processing stuff, but as you can see, it's a tiny fraction of the whole JVM.
**Java bytecode instruction listings** This is a list of the instructions that make up the Java bytecode, an abstract machine language that is ultimately executed by the Java virtual machine. The Java bytecode is generated by language compilers targeting the Java Platform, most notably the Java programming language. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
There are some similarities. But Hoverfly-Java runs in proxy mode by default and lets you simulate and verify multiple services without bootstrapping multiple mock servers, and there is no need to maintain the configs of the external endpoints for testing. It more resembles Mockito in terms of mocking multiple dependencies. 
&gt; I was actually disappointed in Scala in this case - the implementation is almost as verbose as Java, it only avoid defining getters and setters explicitly, at the cost of additional field annotation (@BeanProperty). &gt; I tried to use a case class that should theoretically shorten the implementation quite a lot, but I could not get it working (perhaps my low Scala skills are to blame here). So, disappointed because of low Scala skills? In the end, you skip Java getters/setters for some reason, don't use case classes, and after that claim that Scala is verbose as Java? &gt; customer -&gt; customer.getFirstName()+" "+customer.getLastName() Why not `toString()` here?
That is a trivial example simply to demonstrate the functional nature of the API. Morpheus enables much more complex analysis than simple data transformations that goes well beyond the capabilities of SQL. Also, it is designed to do everything in memory, so for very large datasets, it will be much faster than SQL even for simple transformations.
Cool vid. Here's his previous one to give some more background. Modules in One Lesson by Mark Reinhold https://www.youtube.com/watch?v=rFhhLXcOBsk 
I posted something similar, some time ago, and nobody was interested: Zero curiosity or questions. The thread was filled with comments on what each one was using and how it was better than any other parser. Good luck!
The Kotlin example can be made a bit simpler and safer by using the no-arg compiler plugin; with this you can auto-generate an empty constructor for every class annotated with @Entity that is only available through reflection. This works perfectly fine even if you use vals for certain fields as JPA. For example, you can define an entity like this: @Entity data class Customer private constructor( @Id @GeneratedValue(strategy = GenerationType.AUTO) var id: Long, val firstName, val lastName, @JsonIgnore @OneToMany(mappedBy = "owner") val pets: List&lt;Pet&gt; ) { override fun toString(): String = "$firstName $lastName" constructor(val firstName: String, val lastName: String) : this(0, firstName, lastName, new ArrayList&lt;&gt;()); } The biggest win you make here is that (parts of) the entities can be immutable.
It's hard to come up with a new CLI parsing library that would be interesting enough to try / use. There's so many good choices already that a new player must have something unique. Clio is a good example, the same library implemented in multiple languages definitely might be interesting for multilingual teams/people/projects. Otherwise it's tough to come up with something new. More implicit converters? Plugin-like / service-provider-like architecture that allows arbitrary modules to provide new commands ... those are things that might be perhaps interesting. Even then I'm sure some library already does that, and obviously the use-case for such complex CLI is very niche.
&gt;"There's so many good choices already" That's a way to stagnate. Perhaps 'Clio' or my 'ArgsParser' are as good and probably simpler (to use, learn...) than the rest but they are condemned from the start. 
You sound kinda pissed off. There are loads of mature and easy to use arg parsers. If you want people to go "whoo awesome adding to pom.xml yesterday!!!" creating something that has an actual demand is a better bet. 
Make sure it's on maven central or otherwise no one is going to even try it. P.s.: https://github.com/dmulholland/clio/tree/master/java/lib Ouch.
Nice post. I wrote [a blog post](https://niels.nu/blog/2017/spring-cassandra-integration-tests.html) a while ago on integration testing with Cassandra where I discussed 3 different methods, TestContainers being one of them. TestContainers would've been my favourite if it weren't so darn slow. For them to not impact your test times too much you will probably have to write your tests around Suites so the container only gets spun up once. 
I've actually used TestContainers a few days ago to test against a TimeScale DB (extension for Postgres for time series data). From zero knowledge about TestContainers to full integration took about 30 minutes. Really impressive
I skipped the getters and setters because I felt the code was too long for a post and we all know how these look like, but on a second thought now I believe it might create a false impression when skimming over the snippets and comparing them visually and judging the verbosity of each language, so I'm considering bringing them back. I was disappointed because Kotlin's data class just simply worked while Scala's case class gave me issues - runtime errors as the underlying ORM could not cope with the entity class properly. The wording might be slightly unfair towards the language though, so I might rephrase it tomorrow. An oversight, I actually have it as `toString()` in the local code but forgot to copy it over to the post, gonna fix that tomorrow as well. Thanks for your input :)
That's interesting, but if I understand you correctly, won't that make it impossible to retrieve an entity from the database, change the fields (since it's immutable) and save it ? On the other hand, as you said, **parts** of it can be immutable so you could control which fields can be changed and which cannot; and I might imagine a few use cases for such a scenario.
True, you cannot change the value later on. This is mostly interesting for value objects and collections. 
I see der dat you've got a bit of hate in youze ain'cha.
Resolving Library Conflicts **in Payara** with Class Whitelisting
You need to understand that for people to switch your alternative it needs to be much, much better.
Fat chance when nobody cares to even look at it. EDIT: It pissed me some time ago, when I decided to share it, but not any more. I wrote it to use in my projects, not to become rich and famous ;-) .
Oh now /r/java is cool with containers?
Have you looked at [The Java EE Tutorial](https://docs.oracle.com/javaee/7/tutorial/) from Oracle? It's a little dry but it's clear and covers most everything.
It's really hard to compete when there's an Apache Commons package that does the same thing.
One of the notable changes in the release was the change of stance on the json license by the Apache foundation and thus Tika's removal of it https://lists.apache.org/thread.html/9627a9278d263378a2045d4bffccb6e83b9f01bb783c6dd6fa325faf@%3Clegal-discuss.apache.org%3E
While I understand the intention of using Spring as a baseline comparison, I would encourage people to consider [http4s](http://http4s.org/) for a Scala web library. It's a delight to use and supremely well-architected.
Why wouldn't it be? Edit: Oh wait; it's you.
Code looks like a 1 to 1 copy from the C source. It's not iodiomatic Java or does any best practices e.g. project structure, using JavaDoc or replaceable out channels / logging instead of System.out.
A bachelors degree. It's not needed from a technical standpoint but you're going to have a hard time succeeding without it
I don't think you ned a book (ofc unless you prefer a written copy), there's tons of free online resources. Also in the Java ecosystem you can't get around having someone mention [Spring](https://spring.io/) as an [alternative](https://zeroturnaround.com/rebellabs/spring-vs-java-ee-survey-results/) to Java EE. Though of course the Java EE specifications come in handy even when doing Spring.
You can either read [this book bout Java EE 7](https://www.amazon.com/Beginning-Java-EE-Expert-Voice/dp/143024626X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1499981722&amp;sr=1-1&amp;keywords=goncalves+java+ee) or wait for [some new books about Java EE 8](https://www.amazon.com/Java-EE-8-Application-Development/dp/1788293673/ref=sr_1_5?s=books&amp;ie=UTF8&amp;qid=1499981789&amp;sr=1-5&amp;keywords=java+ee+8).
Darn. Started hacking together something [somewhat similar](https://github.com/fabzo/kraken) without knowing about TestContainers :O I really like the idea of them using modules for the different containers. Seems to be easy to use.
what's maven? is it minimalist? Edit: tfw ArgStream class is not even a stream and ArgParser class cannot even parse(). Sorry, pls forgive me, op. 
Here's a fun project I found recently and got a lot out of it: https://www.youtube.com/watch?v=6_06zcDisNg https://trishagee.github.io/presentation/java8_in_anger/ 
Lmao
no hate. just disappointed at the world.
question is: which human? the manager who is using my product who is probably technically inept or the developer? the technically inept user will still need to read the documentation (and we all know how much they love to do that). The developer ... doesnt need a human readable string, just a concise one. shorter the better.
dunno, you kinda seem like you've entitled yourself to other peoples' time. don't blame people for being uninterested in what's unfortunately a pretty uninteresting project in the scheme of things. finding a new CLI arg parsing abstraction isn't at the top of most people's lists.
He already has a career in .NET. Whatever education he has is probably fine. ;) 
Can I ask why are you jumping ship? I am in the same boat and my reasons are .Net Core isn't really going any where till now.
Other other guy checking in.
TC's member is here :) Check our last release, 1.4.1, where we improved environment discovery (read - faster start of TestContainers itself), and also added an option to disable startup checks (i.e. when you don't need a help of TestContainers to verify that your computer works fine with Docker) On my machine I removed 5-6s of startup time thanks for that. Also, it's up to you how to start containers with TestContainers. Suites are not mandatory, you can just use ClassRule, or even no rules and just do static { myContainer.start(); } block in your base class to implement singleton-like behavior. I'll also write a couple of articles how to do that :)
ant checking in.
It's also something that most developers probably have written themselves at least once in their lives.
[removed]
Well don't be. Just because others see value in something you don't is no reason for disappointment. Be thankful you don't face the issues they do that necessitates their beliefs.
Someone nominated David M Lloyd for _For resisting the autocratic tendencies of Oracle's spec lead._ Clearly a jab at Mark Reinhold. That is brutal. I guess props to the JCP for letting that go through re: transparency. I was relatively neutral on the issues/personalities surrounding Java modularity when I began studying it in Feb 2017. In lieu of a nomination for Outstanding Spec Lead, let me say that Mark Reinhold has done a Herculean achievement with JSR 376. A massive effort for nearly a decade, with relentless criticism and high drama near the end. I don't know Mark, and have no affiliation with Oracle, but in an attempt to balance the criticism, consider this poignant, humanizing [excerpt](https://youtu.be/ac1v5kF_FGs?t=21m36s) from an interview at Devoxx UK.
I have dabbled into it for a demo project involving server-sent events. Worked as expected. I have not been able to benchmark the concurrency levels achievable, though; which was my original goal. I wanted to compare it with Erlang's concurrency levels and see if the number of message throughput could be beaten (Whatsapp servers maintain 2.8M connections each, but only 200k messages/s). They have a mailing-list here: https://groups.google.com/forum/#!forum/quasar-pulsar-user, where you'll find more answers to your questions. Reading from the mailing list from time to time, one recurring problem is people try to use blocking services with it. Also, lots of things to do with transforming blocking services to non-blocking ones. People seem to be using it in production as well.
&gt; For resisting the autocratic tendencies of Oracle's spec lead. Just when I had wished again that Oracle became a bit more autocratic with Java, similar to Microsoft with C# / .NET ...
Yep. Tried this handy snipped, worked correctly: interface Type&lt;T&gt; {} class C implements Type&lt;Type&lt;? super C&gt;&gt; {} class D&lt;P&gt; implements Type&lt;Type&lt;? super D&lt;D&lt;P&gt;&gt;&gt;&gt; {} class Test { Type&lt;? super C&gt; c = new C(); Type&lt;? super D&lt;Byte&gt;&gt; d = new D&lt;Byte&gt;(); }
**Sidebar** -&gt; **Do not post tutorials here!**
Lol.....
Yeah... No
Too slow
To me it's kind of hard to beat JCommander. This looks like a lot of calls, far apart from their landing variables.
Hey hey hey, don't give those greedy net neutrality enemies any clues now!
&gt;one recurring problem is people try to use blocking services with it I thought that was the whole appeal of green threads, though. You can just block, with no need for NIO.
sweet sweet boilerplate writing here i come
Yeah, I can create a whole new project with a maven archetype, import it into IntelliJ and then compile it in less time that this takes. Great proof on concept, but essentially useless. Actually, it's still running. Heck I could probably import my new project into github too. Ok, still running. I think I can go get my daily cardio by running just like it appears too. 