Reread the post you responded to. Command is defined in terms of Command/Query separation.
That capability has been around since Java 5 (and that's exactly what [Project Lombok](http://projectlombok.org/) has been doing for a long time). Again, those annotations don't do anything. But the annotation processor -- or Java agent, if those annotations are retained at runtime -- can do whatever it wants. You can (very easily!) write a Java agent that takes any type annotated with `@Foo` and add a `foo()` method to it. You don't need Java 8 for that, because you could annotate type declarations since Java 5. What you couldn't do prior to Java 8 was to use annotations as pluggable types, because Java didn't allow you to place annotations in all the necessary places. 
As someone brand new to programming who is self-learning java I'm sort of worried that because java is so established with a massive workforce behind it that I'm going to find it hard to get my foot in the door. Do you think there is any truth to that?
AFAIK, all three major Java IDEs support annotation processors (this isn't new). [Here's](https://netbeans.org/kb/73/java/annotations-lombok.html) an example with NetBeans.
Lombock seems to use annotations as generators to change the class. I was talking about adding methods to the class instance, so that they are a "new" type.
And grails.org by extension. It's still got a few bugs to be worked out an enterprise platform, but it's pretty amazing once you get it all set up.
Strong typing, maven, and JavaFX!
I like to think of Runescape as more of a... "..the *oldest* java game thats been kinda successful.."
Not to contradict your experience; just chipping-in my own for the benefit of new-comers: I find Eclipse more stable and fast. Also, the vim plugin for Eclipse that I use is much more mature than Intellij's vim plugin.
I really like that I can pack complex applications including all dependencies, database drivers etc. into a JAR or EAR that works everywhere, even under "Enterprise Circumstances" like people running AIX or horrible policies that don't allow you to install anything that's not an official RHEL package. I tried writing stuff in Perl or Node.js, and I had a really bad time in some environments. 
You must be fun at parties. 
Very minor, but I wish we could do substrings like Python with a negative index to indicate characters from the end. So you could say `str.substring(-3);` to get 'com' from "www.blah.com" And, of course, the oft-requested default parameters for methods, implemented like: public String foo(int bar, boolean flag = false) so if you didn't pass a parameter for `flag` it would default to false.
I've not used groovy before. What's to be gained from using it instead of regular java?
thank you for adding this Jonno
Eclipse performance and stability has massively improved in the last few years. However, I have switched to IntelliJ a month ago and wouldn't go back... 
maven is also a consistent build system with its own rich ecosystem. Hell, most devs I know don't even use stuff like the 'mvn site' feature, much less customizing the site. 
not at all. it makes it easier, because more companies will be hiring. i was a principal at a company and we switched tech stacks because we just couldn't find people who could work on ours, competently. we switched to Java, and the project was awesome after that. 
It's great if you're used to more dynamic languages. It's like a significantly gentler intro to Java. However, after a while, you switch back to Java. There's too much crap in there that makes it painful for a large application. Mostly stuff around metaclass manipulation and runtime monkey-patching of jdk classes.. 
There's yet another approach to creating builders which is much more consise where you effectively just want to use it to implement named method parameters http://benjiweber.co.uk/blog/2014/11/02/builder-pattern-with-java-8-lambdas/ Advantages: Consise, Immutable, Forces you to enter all required params Disadvantages: Brittle
Java has had full compiler support for annotation processors since Java 5, and most IDEs support them automatically (NetBeans, e.g. will run the annotation processors as you type/save).
Know a good site that would have a list/link to all these goodies? I'm guessing suns javadocs
See my [Post](http://www.reddit.com/r/java/comments/1xw148/what_aspect_of_your_java_programming_do_you_like/) from a while ago.
Exactly. And not only for legacy code, but also for customized solutions. When I worked as a consultant, mocks have saved my [insert favorite word for backside here] a lot.
what is a feature you would need?
Wow, very sorry to hear that. Codehaus was a great community. I will follow OP's lead and raise my glass tonight.
See the Java Tutorial's [chapter on lambdas](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html).
It may be more... "..the oldest java game that was very successful at one point.."
Does it mean that this is the end of Groovy as well? I loved Groovy, it just felt like Java on steroids
Streams aren't syntactic sugar, they are an API. Lambdas, on the other hand, might *seem* like syntactic sugar for anonymous inner classes (you can substitute a lambda expression for an anonymous implementation of the functional interface), but [that is not how lambdas are implemented](http://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood), which has significant functional and performance consequences. Also, lambdas are lexically scoped, and do not inherit scope from the enclosing class (which means no `this` from the outside dragged inside). Still, I wouldn't expect an order of magnitude difference, especially for this example.
This tutorial helped me getting into streams and lambdas : [part 1](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html) [part 2](http://www.oracle.com/technetwork/articles/java/architect-streams-pt2-2227132.html)
A great place to get started with groovy is in unit tests. The spock testing framework for Groovy simply put is amazing.
I was just reading [this](http://bartoszmilewski.com/2009/01/18/java-pluggable-types/) and it says that the type checker cannot modify the AST. Did this change in Java 8? I can't seem to find any type annotations that do anything other than add restrictions. As an example, could you show how it's possible to create a @JsonString annotation that can be applied to any type inheriting from Collection, and overrides the toString() method to output pretty JSON?
You do realize that this is only helpful if you have a single threaded application? If your application is already heavily multi-threaded (e.g. a web server responding to multiple REST calls simultaneously), this will just cause multiple threads to fight with each other over CPU resources. parallelStream() is something that is a great win for single-threaded apps, but needs to be evaluated for multi-threaded apps. It may cause more harm than good, especially under heavy load.
I remember reading in the documentation that it wasn't the same. I think that in your case it would mindlessly launch as many threads as there are words while whith parallel streams it would adapt to the number of cores or something like that...
My post attempting to make sense of generics. I wanted to write much more but felt I had way too much for a blog post. Might consider adding more parts if you guys like it. Also obviously throwaway account for security reasons.
Yes it is ! It removes the pain associated to conversion of arrays of primitive to lists of objects...
Have you even tried formatting that code? Because if you try formatting it with proper indenting and brace matching the error is obvious.
How are Scalaz monads more reusable? From what I can tell, you can't supply them new values.
it looks like the jquery foreach...... 
too me a while. but this heavy computation problem have the usal thread problem with syncronization and what not.
The examples dealing with IO are not well chosen - especially with IO related stuff you often do not earn much, but often can easily loose performance! You can gain much from computation within the RAM. (But there are other drawbacks for multi threaded apps as others allready have pointed out.)
The only thing I really knew about codehaus was from seeing the name scattered about in endless, cryptic maven stack traces, but it's still sad to see a widely used platform close it's doors
You're right, but again this post was more of a heads up about a quick win introduced by java 8 in not-so-specific circonstances. + if it can bring more people to learn about streams and lambdas...
I don't disagree with most of what you are saying, but even if mocking is introduced with good intentions, I have yet to see a circumstance where it wasn't eventually abused to follow the ideology I outline in the article.
Hammers can be used as a murder weapon. That doesn't mean that hammers shouldn't be used. It means you shouldn't murder people.
How exactly did you come to that conclusion? Here's one fairly strightfoward example of a [Task monad composed with Kleisli](http://timperrett.com/2014/07/20/scalaz-task-the-missing-documentation/).
Interesting how some countries are skewed toward Scala. And that Most of the articles it list for Scala are 404s, or have actually nothing to do with Scala the language but some musical thing? I think perhaps these results are not very strong.
This thread has been linked to from elsewhere on reddit. - [/r/ProgrammerHumor] [TIL that some programming languages try to give you advice for your sex life](http://np.reddit.com/r/ProgrammerHumor/comments/2xe66k/til_that_some_programming_languages_try_to_give/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
This thread has been linked to from elsewhere on reddit. - [/r/programming] [Codehaus, birthplace of many Java OSS projects, coming to an end](http://np.reddit.com/r/programming/comments/2xe857/codehaus_birthplace_of_many_java_oss_projects/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
Be mindful of some recent history: There have been high-profile security problems with applets in the past few years, the kind of thing that let attackers hack/root/p0wn your computer using a malicious Java applet. Oracle would like people to feel safe using Java, so Oracle added new security rules: applets must be signed. Unsigned applets won't run. Disabling this security would make you more vulnerable to malicious applets. Learning Java is still good, but you should not try to use Java applets in web browsers. Browser applets are mostly dead, and your time would be better spent in other ways: - learn Java desktop programming techniques, if you want to write GUIs in Java - learn JavaScript, if you want to write browser apps 
Thanks for the detailed reply, I'm excited to dig into this! 
again, I am not trying to confirm with certainty that the global trend is away from groovy. I know it is the local trend, and I can give reasons that it is not that exciting (such as lack of type safety, similar terseness as scala with a much worse type system, trading compile time errors for runtime errors)... but I suspect you have skin in the groovy game and are not that interested in reasons ;)
sourceforge was never terrible. been using it since 2001, it was always awesome. yes, there were always things that could be improved (even now), but terrible is not what i'd call it.
:)
I was part of the community. I really cut my teeth in the world of open source thanks to the community. I have a lot to thank it for.
This isn't terrible? http://blog.gluster.org/2013/08/how-far-the-once-mighty-sourceforge-has-fallen/ Or the revenue generating ads they allow on the download page that pretend to be download buttons and bait users into downloading malware? Or the fact that I once got an email from them saying they had a data issue and they lost the last few weeks of my projects source code history. Back before DVCS system, when the only history was on the server. "Sorry". It was terrible. 
that's a shitty thing, i agree. but it was never forced down my throat. i never used it (for the few projects that i released there over time). and ... is a new thing (relatively). using it since 2001 and i was not even aware of this, but i was aware of the "donate" button they added few years back. but, as you can see, it's not forcing it down on people, it's "suggesting" it. it is, as always, up to the developer to be evil or not. download page, revenue generating ads? aaaa .... wtf? never seen any. i just go there, click download on the latest release , get on a page that (it's shitty true) makes me wait 5 seconds, then the download starts. but i've never seen any fake download buttons. dunno what you're talking about. &gt; lost the last few weeks of my projects source code history that's shitty, true, but it could happen to anyone. with dvcs you don't worry about it, but it doesn't mean that github (or whoever is the darling nowadays) is perfect either. 
Here's what it looks like: http://marcdurdin.com/wp-content/uploads/blogger/-zJSjjBYd4jo/UDGLYPaKkBI/AAAAAAAABSc/5PnPniXS8EU/s1600/Download-Fake-4-InkScape-SourceForge.PNG See those big green download buttons. They are NOT the code you're looking for - they're malware. The actual download link is the tiny blue text. SourceForge announced in 2010 that they'd start addressing the issue, but it's still rampant. In fact, I just went to SourceForge (like 1 minute ago) and clicked on the top project and Chrome showed me this: https://dl.dropboxusercontent.com/s/9o2as1gfmc8h8pg/2015-02-27%20at%206.15%20PM.png?dl=0 For fun, I ignored Chrome's helpful warnings and this is what the download page looked like: https://dl.dropboxusercontent.com/s/11awuxkyf2rd8ry/2015-02-27%20at%206.17%20PM.png?dl=0 To be clear, not a single one of those download buttons is the real download link. It's all third party bait. SourceForge is terrible and shitty. 
&gt; Covariant, Invariant, and Contravariant. Java generics implement all of these. `T` is invariant, `? extends T` is covariant (? &lt;= T) , and `? super T` is contravariant (? &gt;= T).
That's awful. Here's what i see : http://i.imgur.com/CnH3PYs.png just downloading cppcms, some project, nothing to worry about. it looks fine to me, then again, maybe adblock is what's helping here. and here's what i see when browsing the download list: http://i.imgur.com/rNgGXJd.png 
I feel I've derailed the point of my original post. I meant to celebrate Codehaus, not dis' SourceForge. My bad - it has no place here.
I think you've just been arguing against Groovy with the project lead (who seems to have just resurrected a long dormant account, judging by history and username). Good luck, /u/glaforge; big fan of Groovy here!
Pleased to hear! XStream would never have happened without the support of the Codehaus community.
Ya. I know he can't be convinced but that is ok. Room for many languages. Cool concepts come from many of them.
I'd argue the popularity of desktop applications regardless of platform is diing. Right now it's about mobile and web. That means Java, ObjectiveC (yuk!) and a potperri of otehr languges including java. Unless you're writing a video game that needs to bleed every ounce of performance, it just isn't necessary.
of course i do. i'd never leave my private network without one (you shouldn't too, there are bad people out there).
SourceForge went to hell a while back
I truly thank you, both for the post, and for being part of that wonderful community. Hope you continue becoming part of other OS communities. May the code be with you. :)
I think you are correct. Essentially, this code sends a series of requests to an external provider, and then waits for all of the results, and combines those results into a single list. The reason for this is the external service can only handle batches of about 100 or so.
Essentially, the purpose is to split a request into blocks of about 100 items, send an external service that request, and then collect all of those items into a single list-style-object. 
My thoughts as well; debuggers tend to have a lot of nice features, whereas print-statements are more of a last-result and make a giant mess of your code.
Seriously, if Groovy was losing to Scala, we wouldn't nearly double downloads every year. And also, you forget all the work done on static type checking and static compilation since Groovy 2.0, so saying lack of type safety, runtime errors, etc, is really just spreading FUD.
This is a perfect example of why I've been recommending to my geeky friends that they shouldn't run ad block. A lot of people turn to geeks for advice on websites to trust etc, but get false recommendations due to the geeks running ad block and end up with nasties in their system. I wish ad-block wouldn't remove the ads and instead would shadow them or hide them or somehow tint them, and make them unclickable. So not only would it train its users on what sites are using manipulatable ads, but also not mess up page layouts.
You can look at [one of my own](https://github.com/puniverse/capsule). Note that it's not idiomatic: Its entire core is a [single class](https://github.com/puniverse/capsule/blob/master/capsule/src/main/java/Capsule.java), and it operates with the requirement that that class must compile to a single class file (so no use of inner classes whatsoever) *and* support Java 7 (at least for now). But it's small, single threaded, and easy to understand.
&gt; You need a type system better than what Java offers. You mean richer, not better. Whether richer type systems are better or worse is a matter of personal preference. Besides, you don't even need a rich type system. Clojure has a poorer type system than Java's, but offers transducers (also [available for Java](https://github.com/cognitect-labs/transducers-java)) which are as generic a form of reusable transformation as you can get (and are more general than monadic operations, as they don't depend on the type of the monad).
Great memories. I had a hand in helping with the Codehaus Manifesto and am cursed with an enthusiasm for "memory lane", and had/have a few projects there, as Joe mentions. I'll attempt to dive in with some history. I'm sure Bob, Ben and figures like Jason van Zyl and James Strachan had already discussed a portal like Codehaus for a month or two, but I was super keen as soon as I heard about it. Lots of London based ThoughtWorkers were too. Reasons? 1. Was not Apache, would not be constrained by The Apache Way (tm) 2. Would use Subversion, even though it was only v0.6 or thereabouts at the time. 3. Would use JIRA, because it was a billion time better than Bugzilla, and anything else. 4. Confluence, as a choice for project documentation, came soon after. Ben and Bob turned out to be fantastic benevolent overlords for the platform. A referral system worked well to bring new projects in. That would be 'from SourceForge' if the project existed already, but far more started on Codehaus. I can look back at Codehaus and state that I had zero complaints. Git was created later - Git became a choice on the platform. Projects wanted both Subversion and Git on Codehaus - they got both. A pragmatic "sure thing" attitude prevailed there. Codehaus leaped into being before blogging really took off. I mean before everyone decided to start their own blog. There were a collection of people with previous OSS experience all gathered on Codehaus who were active bloggers. There were a short could of years, where those bloggers were a significant channel of information for at least the Java community. Another factor that was prevalent for Codehaus people from the early days was direct rejection of Sun's J2EE stuff. Perhaps that was mostly EJB, but the wish for "lightweight" was string amongst Hausmates, and the willingness to make components that were the antithesis of the J2EE doctrine was strong too. Martin Fowler later blogged about Dependency Injection as lightweight (http://martinfowler.com/articles/injection.html), but Codehaus activities to sidestep Sun, were at full force at that stage. Being invited to be a Hausmate and meeting (mostly electronically) dozens of other hard-core OSS people, was a privilege. I've many lasting friendships that started on Codehaus. 
Sorry if you interpret it that way, my intention was a release announcement.
Guillaume, you guys have created a kick-ass language. Thank you for all your hard work. 
Why would I need it ? Can you give me a usecase ?
That news is totally unrelated to Codehaus. Groovy had been sponsored by Spring/Pivotal for years. The end to that arrangement is what is causing the move, not the Codehaus news.
How do you know Scala is not growing 3x a year? Citing one stat is pretty worthless
I guess in any case you don't want to know the maximum of a value, but the element(s) where such maximum is attained. Suppose you want the best songs in a playlist (w.r.t. the number of starts). While there will be clearly just *one* value for the maximum number of stars, there will probably be *many* songs with that number of stars. Suppose you want to list the lowest priced items in a e-shop (perhaps satisfying some search)… again of course there will be just *one* minimum price, but probably *many* items with that price. It's so common that is hard to think "specific" use cases…
Sort of. A new foundation means new hosting infrastructure. In the post I linked, the Groovy team said they wanted to find a new foundation ASAP both because of Pivotal's decision and because they're losing the Codehaus hosting.
While this sounds interesting academically, if I were releasing code with a target of &lt;1.8, I'd rather include Guava and use their implementations. The boilerplate is autogennable, so the shorthand isn't a huge time saver.
You are the author, right? I think it's a cool idea but dude, it's not a toy project. You need to provide proper documentation beyond just a small explanation. No, saying "it will come" or "check the wiki" is not enough to convince people to look into your endeavor.
There are so many directions you could go with this it's ridiculous. Start reading up on Enterprise java and N-tier architecture if you want to do it right. The core model for the state of the game and players will only be hosted in one place (either a player's PC or the central server). Each player will essentially just have a client that displays graphics based on changes in the game state and that can communicate with the host to know the actions of each player. So you need two applications, the client and the server. To start simple I'd recommend checking out RMI (Remote Method Invocation). It's built into Java and allows an application to call a method on a different remote application. Alternatively you could communicate with web calls through http, which would work better if you're planning something web-based or that uses javascript. For this you're likely going to want to make use of an existing framework or web server, such as an Apache Server and Tomcat or something like Spring.
&gt;Whether richer type systems are better or worse a matter of personal preference. Better or worst in a type system is decided by the number of good programs you can express using them. &gt; Clojure has a poorer type system than Java's I think you mean weaker here, and the problem isn't if the type system isn't strong or weak. Clojure's sexp's are still more expressive than Java's nominal subtyping. &gt; transducers (also available for Java[1] ) which are as generic a form of reusable transformation Transducers are great, but aren't reusable in the general sense. They're polymorphic foldables, and limited in the type of computations to type that can be folded, unlike say some kind of free monad, which can even represent stateful computations with pure functions.
This. If it isn't documented it isn't there.
Just so you know, what you've proposed is not really a "simple" game. If you are an experienced computer programmer who is starting to learn Java, then fine. But if Java is your first programming language, you will probably need to start with something a LOT simpler.
Sourceforge?
Well, it was really a joke since I said he'd get anally pounded by hardcore C++ devs. So, as a joke, I was trying to imply that std = sexual transmitted disease rather than the standard.
&gt; A program is not made "better" by having the type system prove more or less of its correctness. I never said anything about proving correctness, only expressions. Which there are a large number of good programs that cannot be expressed using Java's type checker. As a result, Java's type checker is routinely subverted with annotations and reflection in practice. &gt; Now, don't get me wrong, I prefer statically typed languages As do I &gt; but the richness of the type system is a tradeoff. This is false. &gt; As no type system can be built to prove every program correct (if the language is Turing complete) Self proving languages already exist, even practical ones with Turing complete type systems. Scala is an example of one. You can axiomatically prove anything in Scala that you can do with propsitionial or first order logic(that doesn't mean Scala makes it easy to do so, or that compiler bugs don't prevent you so). You can prove even more things if you use dependent types in scala to implement constructs from intuitionistic logic. &gt; the ideal of a "provably correct" language is impossible to achieve anyway patently false &gt; so languages differ only in measure of how many properties can be proved even more patently false EDIT: I should add that there are many things(for some vague definition of things, like partial type application) that are hard(but not impossible) to prove in Scala that are easy in dedicated theorem proving languages like Coq, or dependently typed language like Agda and Idris.
Even then, wildcard imports are frowned upon in the Java community (at least that's been my experience).
I'm learning using Head First Java... I think its slightly out of date when it comes to using the latest features, but the pacing and style is really good...
True, the organization is constrained by requirements. But the code is clear, short and useful, if not idiomatic (limited to one class, no inner classes, and no third-party libraries). It also combines a lot of basic stuff with some advanced tricks (like reified generics and clever method dispatch).
[JLayer](http://www.javazoom.net/javalayer/javalayer.html) is a PCM decoder, sounds exactly like what you're looking for.
C+++? Well, it's one louder, isn't it?
They figured out users *really* wanted adware bundled with installers. [DevShare, they call it.](http://sourceforge.net/blog/today-we-offer-devshare-beta-a-sustainable-way-to-fund-open-source-software/)
Uses a modified JLayer from libGDX. Output is PCM. https://github.com/kovertopz/Framework-GL/blob/master/src/main/java/net/smert/frameworkgl/openal/codecs/mp3/Mp3InputStream.java
Javascript actually has native [Array.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).
Head First Java is definitely the best book for beginners. They have a really good teaching style and you can get a free pdf by googling the book.
I believe you should be posting this to /r/javahelp, and when you're doing that, you should format your code properly and tell us about the error messages the compiler generates.
Hmm.. So what's the point? If you want to code like in Java why not just code in Java? 
**Java: A Beginner's Guide by Herbert Schildt (Author)** www.amazon.com/Java-Beginners-Guide-Herbert-Schildt/dp/0071809252/ 
http://docs.oracle.com/javase/tutorial/java/IandI/
Silly -- you don't *read* mp3 files, you *listen* to them!
Casual.
Cool story bro 
&gt; I was saying Groovy had too much crap. A lot of the static analysis tools don't work on it, and when you can modify classes at run-time, all bets are off. Sorry for misreading your post :)
Sometimes you don't have the option. 
Get yourself a copy of Head Fist Java book. Get an older edition, a pdf, whatever, don't overpay - the concepts haven't changed over the years. This book can teach OOP to a squirrel with ADHD and make it stick. edit: you will find more help in /r/javahelp and /r/learnprogramming by the way
I get around that by making sure that anyone who asks me for advice is *also* running adblock. More users, not fewer. 
I'm using License4J. I'm pretty happy with it actually.
Java offers many powerful ways how to shoot yourself in the foot. &gt; Values stored in ThreadLocal are globally accessible to the thread. Meaning that if you have access to ThreadLocal reference within your code, then the values stored in it can be accessed from anywhere inside that thread. If a thread calls methods from several classes, then all the methods can see the ThreadLocal variable set by other methods (because they are executing in same thread). The value need not be passed explicitly. It’s like how you would use global variables. So if you make your ThreadLocal globally accessible then it will behave as a global variable - no shit Sherlock! The solution is quite simple: **don't make your ThreadLocal variables public static**. In fact you shouldn't make anything public static unless it's final (=constant).
Which ends up bankrupting the good sites, which drives them to malware installers.
nope - but just dropping this comment in as I'm interested too.
Intellij also lets you disable wildcard imports, so you still don't have to worry about it once you make that change.
No, I've never had to, but I'd guess using it for debugging/logging in a context where you have a lot of beans using the same class.
Hey thank you all for the help. I am in spring break and am using this time to play some catch up so will definitely be using these sources. Thanks again I'll be sure to try those other subreddits in the future. 
Never. 
I think I can understand the intent. One enjoys the convenience of Java, but wants to take advantage of C++? I suppose you could just use JNI, but that's quite a bit of overhead. Though, I'm not sure if this lib would make any difference there.
about the garbage collection, can't you just use this: http://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one
It depends on your usecase. The nice thing about a logger per class file is that (depending on how it is configured) whenever anything happens you automatically get the class that did it. Think about your example. What if, in the code, we had 100 places where the message "a serious problem has occured" shows up. Wouldn't it be nice if those messages also provided the class that this happened at? Now for that "Why log4j vs standard logger". It depends, but I'll link you to [this](http://java.sys-con.com/node/48541?page=0,1). We have found in my workplace that the nice thing about Log4j is how easy it is to swap in and out appenders. We have switched logging platforms a couple of times and didn't have to change a single line of code (our product has millions of lines of code). I don't think you could (easily) do that with the standard logger.
Yet another reason why private and immutable should be prefered.
Well, I used it with conjunction of ApplicationContextAware to inject a proxy of self, so I can use @Async or @Transactional (mainly propagation = REQUIRES_NEW) annotated methods from the inside of the bean. EDIT: fixed annotations
This. A very simple design principle yet so many developers don't get it.
Interesting... I've always been annoyed at not being able to follow annotations within the same bean (usually end up making separate beans so I can gain @Cacheable sometimes) - Sounds like I could use this same technique to do so.
Opening a mp3 file in notepad is reading it... But never do that.
There's a media library from some professors at Georgia Tech, but it's only for uncompressed audio (WAV and AIFF files)
ThreadLocals are one of those things that is powerful, but rarely the right tool for the job. We use them at work to manage metrics objects until they are flushed to disk and that model works well, but I can't think of a ton of other uses
Give LIBGDX a look.
The REST interface is pretty transparent though w.r.t. the entity classes. I wouldn't be gaining much by introducing an additional layer of abstraction over the REST endpoints.
You could always give [lombok](http://projectlombok.org/features/Log.html) a shot. Here you only have to add the @Log annotation to a class to get a logger per class. Many like lombok, however, I would just ask that you think twice before using it in a project you mean to be a library. It is a dependency that can have nasty consequences (like not being compatible with newer versions of the JVM).
Well your mileage may vary, but you might be able to add logic to the server side entities to hide fields by nulling them, for instance. Like I say, it's just what I'd do.
I saw this too, thanks! Part of the reason for this post was that even though I *know* the annotations aren't there in the compiled code, it felt a little weird to be shipping them in the JAR if the 3rd party developer isn't using JPA. And if they are using JPA, I wouldn't want to cause issues if they wanted to use just one or two classes in their own schema.
I have thought about using a XML mapping file. I may go that route. Some 3rd party developers may be using JPA and I don't want to "infect" their schema with my JPA annotated classes if the schema they are using is different.
Looks interesting. I have a large project with unrealistic deadlines (don't we all) and this might be something that could really help. Thanks!
Collabedit may be what you are looking for.
JavaFX - built-in.
There are various online IDEs that allow collaborating on code, such as Codenvy and Cloud9. If you jdon't need live collaboration, you can use Ideone. (I can add a similar feature to http://Learneroo.com if there's interest.)
Thanks! Looks like what I was looking for!
Doc Share for eclipse http://wiki.eclipse.org/DocShare_Plugin Also Etherpad
Here you go: public abstract class AbstractRunner implements Runner, BeanNameAware, ApplicationContextAware { private String beanName; private ApplicationContext applicationContext; protected Runner self; @PostConstruct private void init() { self = applicationContext.getBean(beanName, Runner.class); } @Override public void setApplicationContext(ApplicationContext applicationContext) { this.applicationContext = applicationContext; } @Override public void setBeanName(String name) { this.beanName = name; } } EDIT: Made init() private
&gt;effectively deprecated Although Oracle didn't officially deprecate Swing, they encourage using JavaFx for the same use cases Swing is used for. 
Writing Java 8 source compatible code and expecting it to run on a Java 7 runtime is not the best idea in general. The amount of new JDK API is huge, you'll have `ClassDefNotFoundError` and `NoSuchMethodError` all over the place (in production). I remember the good old days like yesterday, when I was accidentally using a JDK 6 to develop but the runtime was a JDK 5, and silly me was using `String.contains()` all over the place... I'm missing a section in the article, explaining how to prevent that. The article only lists compilation options. I guess the IDE might then choose a JDK 8 as a backing implementation.
Parallelism seems to be the new holy grail everyone hails. When my IntelliJ fires up (and boy do they embrace parallelism), my CPU is 100% busy doing IntelliJ stuff. Makes me look at that beautiful splash screen with undivided attention. Please, don't default to doing stuff in parallel. Parallelism is a very dangerous tool. The fact that it is so centrally present in the JDK API will be a great source of regrets in the future. As a rule of thumb: - Using `parallelStream()` in batch jobs is probably OK - Using `parallelStream()` in desktop applications (e.g. Swing, JavaFX, etc.) is dangerous - Using `parallelStream()` in classic Servlets is *very* dangerous, just like using `Threads`
True. I changed my comment to say `Thread` instead of `Runnable`. Funny I missed that.
The builder is present only *at construction time* to help build a Engine instance with a fluent API (Note that all components are optional which makes sense to use the builder pattern). At runtime, if something goes wrong, you will get a precise log from the Engine about which component has failed. I'm not sure you will have a hell time tracing the root cause.
Check out https://floobits.com/ It has some nice features that really help with working remotely. 
There's a blog post here by the CEO of Restlet with a bit more info about the connection of Groovy and API platform and language development http://restlet.com/blog/2015/03/02/head-of-groovy-project-joins-restlet-to-lead-api-development-tools/
Félicitations, Guillaume! I've always been impressed with his work, and I'm sure that he'll continue to be a power for good in his new role.
None that I'm aware of after using it for 2-3 years in production grade code (first used this code in spring 2.x and it works fine today with spring 4.x without any changes, so I dont think there are any "gotchas"). It's not like it's a hack of some sort, you do the same thing that @Autowire does, just instead injecting other bean proxies you inject your "own" proxy. Maybe the only thing you should be aware of is that you dont need this code if you have properly configured aspectj load time weaver, as there are no proxies involved (spring rewrites your own class methods instead of injecting proxies), because then calling this.method() will work just as fine. In the ordinary approach you should always inject an interface proxy, like in my example i inject Runner (not AbstractRunner) which is the interface that has the methods that i want to use on self. PS: If you want a pure interface based approach, you can replace @PostConstruct with InitializingBean interface.
Yes, that's it.
&gt;TLDR: JavaFX got faster. And Geertjan got excited. and Leon's getting LAAAARRRRRGER!!!! 
That doesn't quite work, you would have to return a non-null value in the map. But yes, I understand your point.
You still can use an utility method public static &lt;T&gt; void caseOf(Optional&lt;T&gt; opt, Consumer&lt;? super T&gt; present, Runnable absent) { if (opt.isPresent()) present.accept(opt.get()); else absent.run(); } Example: Optional&lt;String&gt; optA = Optional.of("Hello World"); Optional&lt;String&gt; optB = Optional.empty(); Runnable action = () -&gt; System.out.println("Nothing to see here"); caseOf(optA, System.out::println, action); caseOf(optB, System.out::println, action);
You can't infect their schema. They'd have to opt-in to your schema by adding a &lt;jar-file&gt; element to their persistence.xml.
I've found Dropwizard can't be beat for a micro services. The learning curve is way smaller than Spring Boot. But if your app starts to grow large or you're doing something that isn't exactly an out of the box integration into Dropwizard's workflow, things start to get hairy and it might be worth looking into Spring Boot.
Nine times out of ten, an array list is exactly what you need, so you're doing fine already. The Java Collections trail at http://docs.oracle.com/javase/tutorial/collections/ is pretty comprehensive. I've never seen a book on the topic, as it's relatively small, but I do see that there's a "Java Generics and Collections" by Oreilly. You might want to start there.
yeah, we've been moving away from it in favor of the boot approach in the last several years. Roo is still around for folks that have need of it.
This is super clunky in Java for sure. I don't think there is a good way to express this with the standard map, foreach, filter, type constructs. I guess scala I would do action match { case Some(a) =&gt; a.doAction1() case None =&gt; doAction2() } Or something.. hum
That sounds interesting. I have seen other projects fold when the lead guy leaves. I hope Groovy survives.
http://blog.takipi.com/java-bootstrap-dropwizard-vs-spring-boot/
I see a lot of nice stuff with [api-grab-bag](https://bugs.openjdk.java.net/issues/?jql=labels%20%3D%20api-grab-bag) label :)
I've been working as a developer for the past year. It's my first developer position out of college and so far I love it, most of it. I work for a somewhat small but rapidly expanding company that is fun, exciting and generous, all major reasons why I enjoy my job so much. My employer develops a Java API to encode/decode session control protocols for telecommunications which I use to develop custom Routing Engines for different companies. Things I don't like are setting up test environments and customers who try to tell me what to do rather than what it is they want.
Live comfortably? Yes, I get a great salary. I fucking hate it. You have never seen such a maintenance nightmare as Java code that has passed through the hands of more than one team of developers. Let alone three or four. Every freaking retard thinks they can do the basics better than X, and every other retard wants to prove them wrong. Last bit of Java code I had to update to use Oracle wallets was written in 2012, it used old style JDBC connections, SQL statements, and not a single interface to be found anywhere. But that is what I get paid the big bucks for, making other peoples nightmares in Java go away or at least run in a repeatable and stable fashion.
Damn, this is the kind of thing that would have me ripping my hair out for days. 
Meanwhile, no open-sourced implementation of JDK8(such as IcedTea) has started any relevant works.
And the people who come after you will say the same things. It's the circle of life and not only true for Java. That's one of the things 20 years in IT have taught me.
You're thinking entirely in terms of (probably web) UI, but the article is not. It's about non-blocking on the server-side.
I would probably do something like this public class OptExample { public static void main(String... args) { Optional&lt;String&gt; foo = Optional.of("foo"); Optional&lt;String&gt; bar = Optional.empty(); ifPresent(foo) .then(System.out::println) .otherwise(() -&gt; System.out.println("missing")); ifPresent(bar) .then(System.out::println) .otherwise(() -&gt; System.out.println("missing")); } public static &lt;T&gt; IfPresent&lt;T&gt; ifPresent(Optional&lt;T&gt; optional) { return ifPresent -&gt; otherwise -&gt; { if (optional.isPresent()) { ifPresent.accept(optional.get()); } else { otherwise.run(); } }; } public interface Otherwise { void otherwise(Runnable action); } public interface IfPresent&lt;T&gt; { Otherwise then(Consumer&lt;T&gt; consumer); } } 
You can kind of do pattern matching like this in Java. Type erasure makes it a bit of a pain. https://github.com/benjiman/expressions/blob/master/src/test/java/uk/co/benjiweber/expressions/caseclass/CaseSomeNoneTest.java http://benjiweber.co.uk/blog/2014/05/03/pattern-matching-in-java/ You can also do decomposition http://benjiweber.co.uk/blog/2014/08/26/deep-pattern-matching-in-java/
We have dark and dusty corners of our application that have not been touched since Java 1.3 was the new thing... :(
Thanks for sharing. Interesting read.
The real world is asynchronous so at some point we ultimately always need some form of asynchronicity. I don't think "synchronous" versus "asynchronous" is a matter of choice (unfortunately). Synchronous stuff is almost always easier but may lead to poor user experience / performance or poor "representativity" of the real-world system.
Is it common practice to put the db properties in the project itself? How do you switch between dev/test/production environments? &lt;Noob question, but does anybody have some pointers in the right direction&gt;
Thanks!
Coding in Java allows me to support my wife and two kids. I have a ball optimizing the living hell out of stuff, and am a valued contributor at my company. I don't think anyone would *regret* learning anything (except perhaps bad news).
The asynchronicity of the world is completely unrelated to your coding style. Erlang, Go and Java's Quasar all handle asynchronous events quite well (much better than callbacks or monads, IMO), while keeping the programming style simple and blocking, by simply eliminating the problem of thread overhead with fibers. 
It's okay.
The real world is neither synchronous nor asynchronous. It's just immensely parallel and chaotic. The notion of synchronous or asynchronous is strongly related to the fact that we humans try to model things in some sort of discrete sequence of events, to at least understand and predict 0.000001% of the real world. In the synchronous model, the discrete sequence is not interrupted (which makes it easier). In the asynchronous model, the discrete sequence is interrupted (which makes it harder, but still not "real"). (not that this meta-discussion would lead anywhere, btw...)
Any becnhmarks out there? Does it actually scale to more volume than a single PG instance? It didn't before.
I dunno. It'd be interesting to see comparisons like that, but the other side of things is that MongoDB and postgres are not the same; at some point it's apples to oranges (IMO). I'd use mongodb for mongodb-like needs, and postgres for postgres-like needs. 
Guillaume! Content de lire ca. Une fois qu'on goute a Groovy, il n'est plus possible de revenir a Java.
But once you have lightweight threads you can use simple blocking code no matter what the requirements are. 
The right topic is data structures... http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures
The current ecosystem (Spring, Grails, Apache) is pretty interesting. At my current job, I've built stuff from scratch using open source librararies as well as supported a 5 year old app written using a 10+ year old software package by a large vendor. The open source stuff is easy to develop in and very productive. However, there is a lot of old stuff that is a headache to maintain and frankly, a lot of jobs involve those old code bases.
ArrayList is a good default. There's a lovely flowchart here: http://stackoverflow.com/questions/21974361/what-java-collection-should-i-use More advanced use cases are covered by the standard [concurrent collections](http://docs.oracle.com/javase/tutorial/essential/concurrency/collections.html) and [Guava's collections](https://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained).
A data store doesn't have relevance to Java? I'd think it does - I certainly use Mongo from Java.
Semantic versioning takes care of this. Major (x.0.0) Breaking changes Minor (0.x.0) Api changes, non breaking Revision (0.0.x) No Api Changes, bug fixes only It's ridiculous to think you can never delete a field. It's better to have mechanism to force upgrade if old API is detected. Otherwise you end up with a Shit API where everything is duplicated or incorrectly spelled.
i've been developing, professionally, in java for 15 years, and it's had its ups and downs. i started learning java in late 1996, after teaching myself perl... yeah that was a major culture clash to say the least. the down years were those years i was forced to work with ibm's websphere. java in that kind of environment is a painful drudgery of daily painful red tape just to get anything done. the most fun is right now. just about three years ago a friend and myself started a side project and i chose java using the play framework (1.x) and about a year ago we got enough paying customers and investors so i left my day job and am now doing this job full time. yeah i'm the only developer, and there's a shit ton to do, but the environment i work in, and the problems we are solving is quite fun and using java lets me express solutions with very little "red tape" to get in the way. so yeah, being a java developer has provided me with a healthy paycheck and has paved the way (in part) to my current job, which is, to me, much more than just another day job. i'm a co-founder with a real day to day impact on our product, and the company itself. 
Using content-negotiation as a versioning strategy takes care of a bunch of problems, even deleted fields. Use semantic media types to describe the request and response bodies (i.e., representations). Then you can respond based on the version of the media-type that comes in.
I live more than comfortably after one year of working in Java, and I definitely don't regret learning it (but then, I didn't exactly choose since I graduated from college just over a year ago).
As per the numerous hints in the sidebar, help requests like this should be submitted to /r/javahelp.
&gt; Whatsapp support over a million concurrent connections per server. Yes but that is the perfect situation. A chat app doesn't need filesystem or database access. It doesn't need to interact with other subsystems or resources. It scales perfectly with processes or threadpools.
Ok, thanks. I had seen the archive downloads before, but I assumed oracle wasn't keeping the latest version in archive, so I skipped over it.
no problem dude, good luck with JavaFX...it's a bit raw but give it a chance...it's a very capable framework! I just finished 7 months of development with it. Overall, I was very satisfied. Going to try and do a write up on it at some point...
Especially noteworthy are the deprecation of `java.endorsed.dirs` and `java.ext.dirs`, which I have seen used (and abused) in the past, and of the `-version` switch of the Java launcher, which allowed to select which JRE to run when several were installed on the machine.
The wealth of enhancements to Nashorn please me a lot.
Okay, I will remove this post. Sorry.
dude come on it takes a few seconds to fix your path bro.
Ha yeah I know, it is just that I literally downloaded and installed u31 like 2 hours before I saw this post. I just decided to learn Java so I had everything installed and setup for u31. Oh well. 
Hurray! Been waiting for this for a while, will have to repackage our software again with the non-EA version now
Been working as a Java developer for around 6 years now, I really enjoy it. The pay is good and my tasks are challenging
Its just a normal implementation of quick sort with a functional swapper interface. http://en.wikipedia.org/wiki/Quicksort this page has an animation and several explanations
Is it possible that Oracle have pulled this upgrade? We had several customers upgrade, then they were unable to use our software (Swing text fields became non-enterable on OSX). They rolled back to the previous build and now update 40 is no longer being offered as an upgrade option.
Typical Oracle: not completely senseless, but pretty baroque: http://www.oracle.com/technetwork/java/javase/overview/jdk-version-number-scheme-1918258.html
If you're just starting to learn, the difference is absolutely negligible.
Thanks a lot! Can you give more detail on that swapper interface? And this one..what 'oleft' and 'oright' variable mean? I really can't understand that.
I don't know maybe. A guy from the group gave me that code and I have to figure it out if that's what they need. Do you understand what 'oleft' and 'oright' variables mean? I mean, what is their purpose?
And spinners, and formatted text fields! I've got a planned future project that will need those. Good thing I had other things to do first.
Okay, thank you, that makes sense. Can you one more line please. I understand the previous but this one is giving me the headaches. while (mid.compareTo((String)(values.elementAt(right))) &lt; 0) 
I wonder if *Cooperative Memory Management* will ever become a non-commercial feature :(
That's a deployment issue then. 
The point I am making is that if you have multiple versions running and you have no way to route requests from clients, then you have a real problem; its not hand-waving. With content negotiation as a versioning strategy, you can have multiple versions of representations coexisting on a single instance. That's the whole point. Otherwise you need some sort of routing layer to route requests to the right server. 
Follow up question: What should be my focus if I want to get a job eventually? I've done some front-end before, so I am guessing Spring would be the next thing for me to look into?
Was your work a migration from swing? I'm just now thinning about whether we should take the plunge or wait for other people to find all the bugs.
Include private JRE in your app, e.g. using [javapackager](http://docs.oracle.com/javase/8/docs/technotes/guides/deploy/self-contained-packaging.html)...
No, it was new development. If you guys are using fairly typical controls (read: not a lot of fancy stuff) it should be a pretty simple migration. If you guys are really dependent on the platform look and feel you get from swing you may want to hold off as JavaFX doesn't really have equivalents yet. If you have time, download the demo/sample apps. Run Modena and Ensemble and see if there are any useful controls or features you might want to leverage. Otherwise, no harm in holding off for a little longer, it is still a bit raw. I didn't encounter an abnormal amount of issues in my time with it though.
The difference between this and the normal quick sort is that you can create your own way of swapping the values. This I'd think was more of an academic exercise than a practical implementation. The main concept to gather from this is to note the ability to invert control of behavior inside the class from outside it. I would try to implement a Swapper class that swaps the integers but perhaps prints out "swapped" every time it is called. You can then call sortStrings with your fancy new swapper.
18 years of java has bought me a house, car, numerous trips overseas and financially supported a wife and 4 kids. I really have nothing to complain about and definitely do not regret learning Java. It's a flexible and popular language. Really can't go wrong with it.
what? https://docs.oracle.com/javase/8/docs/api/java/awt/Robot.html
It's not really comparable with Adobe AIR mostly because you can write everything in Java. It's a better Swing, yes, with a lot of modern APIs (Webkit based engine to render Web Content, a media player, a charts API, 3D views, etc.) and GPU acceleration. The main limitation is the lack of native look and feel. It should replace Swing when Java 9 is released and JavaFX is fully merged into OpenJDK (right now, it's just an optional module) and when its API gets stable. 
And yet still no simple and efficient way to either A) run DOS commands or B) Just clear the bloody console.
Well, when I found out that the JavaFX folder/file dialogs are *proper* as opposed to the garbage that's built into Swing, I wrote a little class that allows to use them easily from anywhere. Simple version: https://www.reddit.com/r/javahelp/comments/2lypn4/trying_to_use_javafxstagefilechooser_in_a_swing/cm07xyo More elaborate version: https://www.reddit.com/r/learnjava/comments/2ojauc/saveread_files_question/cmnnwor I think these are only for the file dialog, but changing/extending that to (also) support the folder dialog is very easy.
Still waiting for a decent cross-platform system tray support. ARE YOU LISTENING TO ME, ORACLE? How many years will it take for you to give a shit to the system tray?
I'll be glad if I never have to work with JBoss again.
Your employer or the project will dictate coding style/conventions. Learning new core language features is never detrimental.
It's been developed by the same team (the initial ControlsFX contributors are members of the Oracle JavaFX team) but it's not API compatible. The newly included classes have been available for a few month [as a standalone library](https://bitbucket.org/controlsfx/openjfx-dialogs) so they could get feedback on the new API.
Nope, your choice is completely fine and personally, I feel the same. The addition of lambdas itself was a huge controversy, so I'd say it's going to be 50:50.
&gt;Well, the package will be much larger, but probably more reliable. Wouldn't it also completely defy the point of Java? Write once, run anywhere, except actually that's only because I'm including binaries for absolutely every possible system. &gt;JRE included in your package will be used only by your app and it will not affect other software. Which means I can't fix others' broken software. If program A works on jre7 but breaks with jre8 and program B requires jre8, I have to use a deprecated flag to get them to work on the same computer.
Yeah, I think Spring Mvc is the most widely used framework for the ui side. Obviously html, javascript, css, etc as well. "Spring" and "Spring Mvc" are two different things, I mean they're tied together but it's Spring Mvc that ties together the front end stuff.
Your should blame your development/maintenance, testing and QA process, not the java evolution. There is nothing in your defense - your must move in direction of continuous delivery, otherwise you won't survive.
Most of those are just play languages people get excited about, then next year there's a new one - Ruby on Rails, Django. Javascript is not a competitor to java - javascript lets you write code that runs inside the browser, rather than running on the server. If you write web stuff with Java, you will also need to know javascript. Python is (as far as I can tell) is the only sorta-exception, apparently it's what's used as a beginning language in colleges now so it's used some places. If you want to get an idea of what to use for a job, try going to a job site like dice.com and putting in the language, doing a search, and see how many results come back for your area. If you want to get an actual paying job, Java is at the top.
I am not "blaming java evolution", in fact I appreciate the updates. I understand that ideally, we have 100% automated QA such that we can just click a button and the every last feature of the app is tested without any intervention necessary. I'll be the first to admit we have not achieved this goal and I suspect we are not the only ones. So I am only asking if it's reasonable for clients to expect vendors to certify their products in this kind of timeframe. I would point out that, for example, IBM Websphere AS, itself a J2EE container, does not seem to support java 8 yet: http://en.wikipedia.org/wiki/IBM_WebSphere_Application_Server#Version_history So, should their clients also demand that they do so, and potentially roll out a new release, before 4/15/2015? 
You are on Java EE, not Java SE. Refer to your support contract with your application server vendor. I doubt they have an eol for Java 7. 
Lambdas themselves are a lot less spooky when you realize they're largely just a shorthand for anonymous classes that fit the definition of "functional interface" (ex. Runnable). The Streams API is the "big new thing" in Java 8, in my opinion. But you can use the lambda syntax all over your code without ever touching that.
Not only that, there *is* such a query mechanism: collection streams, filters, and caches for indices. This does *not* need to be a special feature of the API itself.
http://vigilance.fr/vulnerability/Bouncy-Castle-vulnerability-of-CTR-DRBG-16289
We've been working with a pure OSGi container for years after taking out JBoss. Productivity has increased and stress has decreased since there is no JEE server to fight with.
Thank you
All Java developers should learn them IMO. Lambdas go hand in hand with Java 8 streams. In a lot of cases using streams you can manipulate data in a less error prone and more readable way. It is not coincidence that functional programming is becoming increasingly popular. String delimitedPhoneNumbers = people.stream() .filter(Person::hasPhoneNumber) .map(Person::getPhoneNumber) .reduce((acc, curr) -&gt; String.format("%s,%s", acc, curr)) //combine phone numbers, each time adding the current one onto all the previous with a delimiter
check with /r/libgdx users. 
There is a standard called jBpm that has a few tools already built if you want to buy a solution. Otherwise you can use activiti in the backend and write your own front end 
I picked up "Java in a Nutshell, 2nd edition" at a used book store, and sat down at the computer for a few years. Lots of books came after that one, but that's how I got started.
I recently bought a Java book and am really excited to start reading it. 
I don't understand though how you teach yourself. 
Watch youtube java beginner tutorials. Keep struggling with the tutorials to get them to work until you get some stuff to work. If you can't get them to work, ask a friend or try a different tutorial series. After doing 100 hours of tutorials you will need a more thorough understanding of the language to progress, so pick up a beginner book on java. Do that book, then get intermediate book. Then get expert level book. You can take it as far as you want to.
College.
Google "Helsinki Java MOOC", that is a great course you can use to learn online. Personally I did that course and supplemented with Head First Java (book). They go well together and give a good framework to then look up other things as you go. Most people learn programming by doing, so once you get the basics, find a project you want to make and start googling how to do things (make sure to learn why they are done that way), and eventually you'll know a lot.
After two years of misery, we finally got a jboss 4.x cluster reasonably stable. Then upgraded to the latest major version (6.x at the time). Major disaster. At a medium sized company ($300 million in sales) the site going down every damn week was a major black eye for IT. We paid Redhat for premium support, paid to have consultants on site during the upgrade. They sent a junior dev who didn't know jack, was zero help for the issues we faced. Never again. I left for greener pastures, but they never recovered. They eventually hired a VP who fired all the devs, and hired in a bunch of consultants. Company tanked. Still in business, but last I heard revenue was well below $100M.
I've been using anonymous inner classes, and instantiating interfaces for years before java 8. They don't change anything for me.
Intermediate Programming class in high school
You think of something you want to build, and then start building it. For example a mailbomer, or a card game. Start with little projects and make them bigger as you advance. In the end you'll feel like you can handle anything, with enough time. If you're confident you can start helping opensource projects, these will help you understand a lot about how big projects are managed. Remember, Google is your friend!
After knowing any other C-like language, they all start to feel fairly similar if you understand the basic programming and problem solving pieces, the trick is then to learn the nuances of the language. After that, I just started writing it and then somehow landed a job doing it as a newbie, read effective java, and am now still doing it (hopefully better than before I read that book). If you're really new, hold off on that book until you have a little experience writing Java. But the best advice is to just write it, be willing to do it wrong and learn from that and do better next time. Try to never get too emotionally attached to code, if you can learn to take feedback well and think through that feedback - it'll be a huge boost to your skills if you are open to learning from people that know more! Don't over engineer, getting something working and then fixing it is much better than trying to get it 100% the first time (usually this bogs you down too much to eventually either give up or just lose interest in the project).
Agreed! Though it was stripped of all its fun generics when run through a decompiler. 
Doesn't account for type hierarchy. If the object is an instance of `HashMap` but the key is of type `Map`, you would be mapping at the wrong level of the type hierarchy. Inserting another object which is an instance of `TreeMap` should replace the first object.
Which book, if you don't mind me asking? 
For me and for a long time, it was task based. I would constantly find things I wanted that I could tell a computer to do, then set out on how to complete that after getting a basic idea of the syntax. for example, lets say I did all of code academy's lessons on python. I would ask myself: how can i use python to change my desktop background the NASAs astronomy picture of the day automatically every day. Then I start researching. Because I know the syntax its easier for me to complete my goals and understand the help out there.
Watch videos or read books until reading docs becomes more efficient. Then try making and XML parser or play around with sockets and web APIs. If you're becoming really overwhelmed, take a few weeks off and practice Python. You'll have strong OO skills coming from Java (I hope) and you'll find it quicker to implement your ideas with less boilerplate. Once you're comfortable with that, go back to Java and rest easily knowing that you have type safety.
I taught myself. My first exposure to Java was through Java applets, which were in vogue at the time on the web. Applets are bit more simplistic than full applications. I also started with 1.0 and back then the language and standard library were notably simpler. Programming languages are a lot easier to learn if you already know another programming language. Java isn't the easiest. If you just want to do basic command-line stuff, you might want to try Python instead. Through if you want to do GUI stuff, maybe Java is a better choice then. Anyway, for learning a language you need to not only study the "grammar" you also have to use it. For Java or also Python, study the basic syntax then try this site: http://codingbat.com/
I agree with you, Books are better than the YouTube tutorials. 
When I was in high school, the school district would pay for students to take two college classes each semester so since my high school was located on the campus of a community college, I signed up for a Java class.
I took college courses for C, C++, and C#. My first programming job used Java. It took a couple days to get used to it. It took months to feel really confident. The projects I'm on require I switch between C# and Java so I keep mixing up string and String. Edit: I worked with C# a lot on my own. The college courses alone would not have been enough. Learn the basics then experiment. Worst thing that will happen is your code doesn't work. On the other hand there is no better feeling than to see your code do something cool for the first time. I can remember the first time i got some code to communicate over a network. Who care if it was simple and mostly useless, it worked and I wrote it.
College, still in it. My college teaches you Java to grasp OOP and well learn to program. The higher level classes we dive into C, C++, FORTRAN, Python, etc, we learn different languages and the history/reason they became what they are today. Also assembly. God damn assembly was a struggle.
I have made a good living out of Java over the last eighteen years. It has been good to me.
Try the following books: 1- "Head First Java", it is very good at getting you the basics, in an organized way. Then when you are comfortable enough with the language, check out 2-"Effective Java 2nd Edition" book.
Wow. Were the consultants helpful at least? I'm surprised Red Hat would send an inexperienced dev out, considering the service contracts were the main reason they acquired JBoss.
Scala does functional programming much better, however Scala was designed with functional programming in mind. That said, Lambdas and Java8 features are here to stay. How Java8 features are used? Well, that's up to you and everyone else; I've seen them done right, done ok, and done VERY wrong. Clean-code standards STILL apply. If your (or other's) Java8 code doesn't look clean, or is difficult to debug, you're doing it wrong. Don't chain too many method calls. Refactor code and functions into their own methods/definitions. Use sensible names. Keep methods moderately-short. Good news is Java8 works with all (I believe) of the old Java7 stuff, so there's probably no harm in migrating. Whether you use the new features is up to you.
YouTube a bit and then school
Currently working on a project with someone who knows way more than I do. He's pushing me a lot to keep up. There is pressure thus I am doing more. There is motivation. You have to find you own motivation.
Sweet baby Gosling, ***why?!***
basic(82)-&gt;pascal(85)-&gt;assemby(86)-&gt;c(90-94)-&gt;c++(94-99)-&gt;java(2000-now)
College, 1996 via Java in 21 Days. My first program was an applet.
&gt; Oh, and tons of "factory" shit, too. It's enterprise ready.
I know C has a cult following by some, but memory management is the number one reason I can't stand using C. I don't mind the simplicity, and sometimes even prefer it, but the memory management is where I say no. 
I have a similar problem right now also. I keep switching between Java and Python, and keep forgetting my semi colons. 
Fuck assembly
This. Well, I started on Pascal at College (UK College, not US). Then University moved us on to Java. I found I needed that initial push of actual structured tuition before I could really get into programming, before that I just wanted to try it out but ultimately had no end goal so I had no motivation to carry on. Uni/College gave me those tasks, goals, etc. I needed to push myself. Now I work as a software dev and I'm often thinking of new tasks and challenges based on the stuff I do at work/find online.
For those stuck with Eclipse, you can do the same through Preferences &gt; Java &gt; Editor &gt; Templates. Don't forget the auto import directive for Collectors: collect(Collectors.toList()) ${imp:import(java.util.stream.Collectors)}
I understand why it would make sense to have ".toList()" directly working on streams. But I think it would be confusing since collectors are not used exclusively as terminal operations, but also as part of other terminal operations such as groupingBy and mapping.
Well, I don't see anything confusing here. Collectors are used exclusively by the collect() operation, as the name suggest, and a toList() method would just be a terminal operation, just like the existing count(). I'm using collectors in 90% of my streams, this would really make sense.
Except that the equivalent to .count() is collect.(Collectors.counting()).
I once learned Java at university. But I really learned Java by crawling a java forum over month, solving every problem someone posted by myself. You only learn a programming language by actually programming stuff. Solving common problems is a great way in case you don't have a project at hand which teaches you all the things while working on that project.
I don't see how something that trivial can be seen as "confusing", even slightly. I was actually astonished that this toList didn't exist when i read the javadoc. The explicit ending collector is 100% pure boilerplate, that will be repeated hundred of thousands of times. Calling it "confusing" makes no sense - what's exactly the risk if you choose one instead of the other ? This reminds me of people who said lambdas would be waaay too confusing in java (making us wait a full decade for nothing) : "but we have anonymous classes ! what's the point ?" 
Fine, then a successor to Swing.
Yep. I was even more astonished after realizing there's Stream#toArray but no Stream#toList. Who actually uses Arrays over Lists in non-performance critical code?
`toArray` is slightly more general, in a way. IntStream returns an int[] array from toArray but cannot return a List&lt;int&gt; from a hypthetical toList terminal op.
Wasn't aware that option existed, thanks
I've added this info to the blog post. Thought it was the default option. Thanks for pointing that out. :)
Thats right. But IntStream is a separated interface, so Brian Goetz or whoever maintains this API could add List&lt;Integer&gt; toList() to IntStream and List&lt;T&gt; toList() to the Stream interface. The latter is used for non-primitive streams.
I second the Helsinki course, especially the first part. Gives you a good explanation of object oriented programming and involves a lot of learning by doing.
This thread has been linked to from another place on reddit. - [/r/programming] [Implementing a 30-day trial for a Java library [X-Post from /r/java]](http://np.reddit.com/r/programming/comments/2y0utu/implementing_a_30day_trial_for_a_java_library/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote. ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Cs106a on iTunes university
jar = easy to decompile java is meant to be free
I've come across one library that did this too. I didn't use it. Are you sure your work is strong enough to warrant a licence for continued usage?
How did you like that one?
I think so. It has customers using both the free and paid versions today. The challenge is that some big companies (who can easily afford the paid version) had no need pay since the Express option had the features they needed. One big bank told me just that :-( Now that I'm moving more features onto the paid side, I need a way for them to try it...and not forget and push the trial to Production.
You have to think who the customer is and if the software is worth paying for. If this is just a jar you add to an existing application them you might be better taking the route of making a free version and a paid for version. This means that you can give someone a feel for it and if they want the "killer features" then they have to pay. 
I also like the Sublime Text method of nagging the user every N saves (20 saves with Sublime Text). It is minimally intrusive but it serves as a good reminder when I am using the program. Other than the nag it is fully functional. I bought it which is something I did not really expect to do after using it for a few months and realised I was using it so much I should really buy it now to save on that ½ second every 20 saves. 
thanks for the tips!
Both of these options work well for desktop apps or apps with a GUI. No sure how well they work on the back-end where no one's looking unless it breaks. I'll think about the 30 days. If it consistently needs to be extended, then I'll just raise it.
I'm hoping this means they got a new GC, and not something more sinister. This reads like an action/porn movie hybrid subtitle.
Throw random exceptions with adds in them!
Because the website is still new, envision is the theme we're using that we bought from themeforest, verify it if you want. i admit, there's a couple of errors and typos, but that doesn't mean it's a scam, i mean why would that be a scam and we're offering the training for FREE ? think and do your research more deeply before you judge next time. if you took time to actually have a look at the course's content, you won't care about other typos in the website like other did. Thank you for your notes though, we'll make sure to fix asap good luck
Maybe you should consider putting no software limitation at all, and specify everything in your license terms. Big companies, and generally people who actually pay for licenses care about those terms. Some other people will ignore them but then they probably would not ever pay for a license. Then put sufficiently high prices for organizations to compensate.
Insert Nag messages into random varchar fields in their database. In all seriousness though, have the library log the nag message to console, most developers will see it while they are working on their software when they start up their project. Heck, ehCache has been nagging me to update to the latest version for months now.
I'd consider a dual-license strategy. GPL your library and offer a paid version. Unless they use it on Open Source projects they are obligated to pay for the commercial license. Make it very clear on your marketing that if you want to use it in your closed source software a license is a one time fee of $X dollars, or whatever works for you. I'd chose to not use your library if it had baked in limitations like that.
College. Java 1.4 back then, quite different to 1.8. Dropped java for a while, just got back into it recently. Have an interview tomorrow. Hoping it goes well.
What you describe sounds fine. If the market for your tool is corporate and "for profit" customers, then your approach is perfectly reasonable. Of course you know hackers will break if it they want to, but those people won't pay you for your work anyway. And the "free software" zealots and cheap managers will choose to ignore your tool (at least, initially, until they determine the alternative is too much pain).
Also, what does the utility do? I'm genuinely curious!
I am not entirely sure what you were responding to, but my main points were that 1) a type system does not increase the expressivity of a language (proof: original lambda calculus is untyped) 2) Turing complete languages are impossible to (decidably) verify (proof: Halting, Gödel), and 3) type systems carry tradeoffs (proof or, rather, evidence: languages differ in their choice of type systems, and HM type systems have been consistently rejected by most languages for decades now). I don't think any of my points is even slightly contentious. In a related discussion, someone mentioned efforts to reduce language domain to "total FP", which would then make the language not Turing complete, but decidably verifiable (though, I believe, with no upper bound on verification time, but I may be wrong on this). I also don't know what issue you have with Java 8's addition of pluggable types, but pluggable types are, by definition, pluggable. Java 8 has made them not like any general compiler plugin, but a specific, [officially supported hook](http://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html). There was a full Java language JSR that changed the language in order to support pluggable types, and the current offering is quite rich. They also come complete with automatic IDE support. The annotation processors that implement those types are called *after* parsing, and work on ASTs, so they're more like Scala macros than traditional compiler plugins (that do their own parsing). Now, I see that you're very enthusiastic about rich type systems, and that's great. But you should know it would be some time yet before they are made generally useful in practice. Just to give you a few examples: I now work on concurrent data structures for databases. The kind of thing I want verified is "a lock in a tree is never acquired unless its parent's lock is held", or that "this variable always changes either under a lock or via an atomic operation". Those things are extremely hard with current type systems, and when they're possible they require a lot of work *and* reduce performance (mutation is required for efficiency here). Another example is from a previous field of mine: safety critical, hard real-time defense software. There we needed to verify stuff like "signal X is never emitted within one second of signal Y". Esterel is sometimes helpful with this kind of things, but is way too limited, so we ended up choosing realtime Java, verified with NASA's model checker. The final example is just from last week, when researchers uncovered a bug in Java's Object-array sorting algorithm. The bug was found and the fix verified not with a type system but with a verifier employing symbolic execution. Preventing this bug with a type system would have probably required dependent types at the very least (the logic depends on the input size), and the number of production-quality languages with dependent types is currently zero. Of the non-production-quality implementations, they would have either been able to prevent it *or* execute it efficiently, but probably not both (again, mutation is mandatory). As efficiency is the sole purpose of this algorithm, this would have made those approaches non-pragmatic. OTOH, finding this bug with a software verifier required less work than expressing the constraints with a type system, and had no effect at all on performance. So yes, rich type systems can be great, but *to date* they fall short of being generally useful for various reasons (including those I mentioned above, as well as added burden and other tradeoffs). To say that *today* a language with as rich a type-system as possible is always preferable to one with a poorer type system is just not true.
+1 because I like the simplicity from a user PoV, no second file to add. I'll call this plan "B" because it requires more work for me.
Users really need all the features in the trial, otherwise, they can just grab the free Express version with limited features.
Traditional answer: It's not always better. Explanation: If your hash function is computationally expensive and guaranteed to be used, you can calculate it and store it when the class is initialized and caches are hot. If it's not guaranteed to be used, calculate it on the fly, unless it's horribly expensive, and then you first try to calculate a smarter hash. You usually don't need to include everything in the hash calculation, only enough to spread entries out to balance hash tables. Caching hashCode lazily is only really good for the rarely used, but horribly expensive use case. Mostly because hashCode needs to be threadsafe, and that adds complexity in a place where you really don't want it, in an innocent looking method which is used everywhere.
&gt; 1) a type system does not increase the expressivity of a language (proof: original lambda calculus is untyped) Of course not, type systems restrict which expressions are valid, Which maks your point irrelevant to the original topic about Java's being too restrictive. &gt; 2) Turing complete languages are impossible to (decidably) verify (proof: Halting, Gödel) This is true, though not entirely relevant. &gt; 3) type systems carry tradeoffs (proof or, rather, evidence: languages differ in their choice of type systems, and HM type systems have been consistently rejected by most languages for decades now). I'm not sure why you're bringing up HM, or tradeoffs, we were discussing what makes a type system objectively better or worst. Which as I argued, is decided by the number of good and bad programs a type system will respectively allow and reject. Any emphasis on bounding more towards allowing or rejecting(as is the dichotomy set up by traditional Weak vs Strongly typed system debates) is opinion. I used Scala as an example of a strong type system, with few limits on the kinds of good programs it can check(You are more constrained by practicality and implementation than the type system itself). &gt; I also don't know what issue you have with Java 8's addition of pluggable types, but pluggable types are, by definition, pluggable. Java 8 has made them not like any general compiler plugin, but a specific, officially supported hook[1] . There was a full Java language JSR that changed the language in order to support pluggable types, and the current offering is quite rich. They also come complete with automatic IDE support. The checker framework has been around long before Java 8 and the addition of a compiler hook to make their implementation easier doesn't really change much. It's not a type system, it is a tool for meta-programming, no different from macro tools in other languages. The `@NonNull` Annotation is a perfect exmaple of this, `@NonNull` is not a type, it's an invariant check. You can't abstract over Non-null values, extend Non-null, take a Non-Null as a type parameter, or anything the other things you normally do with types.
Optimization to the G1 GC, yes.
&gt; "a lock in a tree is never acquired unless its parent's lock is held", or that "this variable always changes either under a lock or via an atomic operation" These problems are exactly the kind of problems dependently type languages are for. &gt; Those things are extremely hard with current type systems, and when they're possible they require a lot of work and reduce performance (mutation is required for efficiency here). Being well typed doesn't exclude your values from being mutable. &gt; Another example is from a previous field of mine: safety critical, hard real-time defense software. There we needed to verify stuff like "signal X is never emitted within one second of signal Y". Esterel is sometimes helpful with this kind of things, but is way too limited, so we ended up choosing realtime Java, verified with NASA's model checker. Expressing the complexity of a function via the type system was actually going to be a side project of mine. &gt; The bug was found and the fix verified not with a type system but with a verifier employing symbolic execution. Or he reads /r/programming where that same bug was posted to when netflix found it last week as well. &gt; and the number of production-quality languages with dependent types is currently zero. This is true, but is an unfortunate circumstance of a industry that would benefit the most form dependently typed languages. &gt; As efficiency is the sole purpose of this algorithm, this would have made those approaches non-pragmatic. OTOH, finding this bug with a software verifier required less work than expressing the constraints with a type system, and had no effect at all on performance. I'd argue this is the result of the world still primarily working with bad number types that represent it's width in memory, instead of any interesting mathematical properties . Type systems don't save you from bad abstractions. Only incorrect programs.
And the .reduce(...) call, arguably the most complicated part of this code example, can be replaced with .collect(Collectors.joining(","))
Loads instantly. disregard, I cant get the netbeans or robotics to load fast.
Could it be the server it's trying to put me on? I tried it using my school WiFi too and it still took an insanely long time.
Maybe, They are probably using a CDN and your local server is under high load or something.
Just make it free for non-commercial use. They can use it in testing, but when they deploy it to production, you can sue them if they don't pay you.
When reading your resources make sure you use getResourceAsStream(), because you can't access them directly as files once they've been packaged in a jar.
I'm so jealous. Any word on when us Linux users will finally be able to install Ask Toolbar? Seriously though, what's wrong with Oracle that they would even consider this?
Derek Banas Java Tutors
You could use JSP and keep a lot of your code, but you'd have to redo the GUI (assuming you have a GUI). Even if you can convert it to JS, you'd have to rewrite the GUI in HTML. 
I thought Oracle position was that they were bound with past agreements made by Sun, but if they're now extending it to new platforms, it sounds like that's just a BS reason. Personally having adware bundled with Java (like Flash) has always negatively affected the reputation of the product and makes me want to avoid it when possible.
I just don't see how ask could possibly pay enough to make this worth it. Such a bad look. 
Uhm because java swing does not exist in html
Money. I bet the cost of developing Java is largely supported by Ask Toolbar revenues. It's not like sales of Java SE Advanced are setting the world on fire.
Look at AquaFX.
&gt; Heck, ehCache has been nagging me to update to the latest version for months now. Proving the nag messages are useless...
Thank you, I will.
One issue I had with any VFS and "in-memory FS" library is the ability to get the URI from a Virtual File. I'm still unsure if this is possible.
Everytime "How to hack hotmail" is asked, java development receives 0.01$, that was the secret of java8 success.
&gt; I bet the cost of developing Java is largely supported by Ask Toolbar revenues. Because it can't possibly be supported by the billions they make in the enterprise world, where Java is king?
[License4j](http://www.license4j.com/) can do what you want and a lot more. It isn't free, but it's quite cheap (certainly cheaper than developing and maintaining that code yourself).
You can disable this for updates in Java Control Panel (accessible via Mac OSX System Settings).
Adware in my browser, yaaay! I can ask for all the things! XD XD XD
Looks clunky.
If you have a backend library your "nag message" could be in form of an artificial delay. The further away from the trial expiration date the more delay the features have. You could even log the added time inside the console nag message so that the devs that use the lib know why it is so slow.
Yay!
I've worked in enterprise java for 10 years, I can't think of a single time we've given oracle money that wasn't for their database... where's the money? certifications? are people *actually* paying them for support?
Rewrite your program in Scala, use http://www.scala-js.org to compile to JavaScript. 
What app server you using? 
This is apparently only if you install the JRE. If you install the JDK you don't get any extensions. I installed the JDK update yesterday and nothing unexpected got installed. 
Interesting framework. It claims it can automatically set up your web application to display well for mobile and desktop. It is worth a look.
websphere
If you're using Standalone mode, [this documentation](http://spark.apache.org/docs/1.2.0/spark-standalone.html#high-availability) describes how to make Spark highly available. If you're running Spark on YARN, there is no SPOF in YARN itself but you should still carefully design the spark-submit script to retry upon failure, etc. 
**[Icedtea](http://icedtea.classpath.org/wiki/Main_Page)**
Also, there are fully open-source builds of JDK available from Azul Systems: http://www.azulsystems.com/products/zulu/downloads (on all platforms)
Vaadin is [built on GWT](https://vaadin.com/introduction#how-works).
Screenshot?
Sreenshot of what exactly? The code?
I really don't get this cricle jerk, I have never seen this when i'm installing java.
Show it to her in person, or screen sharing. You can get a feel to then if you feel like they're genuinely curious to complete the assignment, or just using you to copy. I doubt many professors have a problem with students working together, provided that the above is the case. 
Screenshot of your cat. 
By the fact you're on /r/java, you're likely installing the JDK, which has never had the toolbar. It's the JRE-only installer that includes the toolbar.
&gt; Obviously the convention for static finals is uppercase (with underscores). Only for constants. In the case of objects, that's immutables. I would really dislike a `private static final String[] NAMES;`. It's mutable, therefore it's not a constant, it should be `names`. Were it a `private static final ImmutableList&lt;String&gt;`, I'd happily name that as `NAMES`. In the case of logging, I exclusively use "logger", mostly because both the [slf4j](http://www.slf4j.org/manual.html) and [log4j2](http://logging.apache.org/log4j/2.x/manual/api.html) pages suggest so, and because of consistency. Some of the Logger implementations out there are mutable, some are not. And when they are (slf4j), you can still usually change something down below, like the log level, or the appender pattern during runtime (e.g. via JMX). Or the underlying Appender can be buffering (aggregating errors before sending out an email). That does not _feel_ like an immutable constant. Also, all the "LOGGER" calls always hit me right in the face. Having "logger" is much more subtle. --- Anyway, this will always be at least partially subjective. Use whatever you like, but use it consistently. Oh, and there's [a SO question on the topic](http://stackoverflow.com/questions/1417190/should-a-static-final-logger-be-declared-in-upper-case).
 private static final Logger LOG = LoggerFactory.getLogger( Clazz.class ); "static final" things are in all caps IMO Sometimes in an abstract class I'll do: protected final Logger LOG = LoggerFactory.getLogger(getClass()); It breaks my rule, but it follows my logger pattern. I have great hate for things like: private Logger _log = LoggerFactory.getLogger( "ClassName" ); It just breaks my style-heart.
Only jre not jdk.. You've survived. 
This is what I do as well. I used [Project Lombok](http://projectlombok.org/) for a while, which lets you annotate the class (like [@Log or @Slf4j](http://projectlombok.org/features/Log.html)) and then it gives you a Logger named log. Once I got used to that I just stuck with it.
I never bind it to a ~~static~~ variable.
I prefer LOG because it's static final. But I guess I could also live with "log" or "logger" or any other variant if one of my team mates really insisted on it **as long as it is consistently used across the whole project**.
&gt; private Logger _log = LoggerFactory.getLogger( "ClassName" ); &gt; It just breaks my style-heart. Imo _ should be removed as valid char for variable names, especially as first char.
I know but it's a plug n play after changing your swing windows. Plus these backend goodies: http://www.quora.com/What-are-the-benefits-of-using-Vaadin-over-plain-GWT
In the NAMES case, for me it's the intent that matters, and the naming style is a way of self-documenting the intent, especially as java doesn't have immutable arrays. NAMES is for an array that you should leave alone, names for an array you can edit. I didn't know about the slf4j and log4j2 pages, it would be nice if they explained why they go lowercase. The mutable argument is an interesting one, but I've never thought of loggers as mutable - I don't intend to modify any state by calling "debug", which is often all that my class does with the object. Thanks for linking SO, I got excited by the second answer but then I realised it was quoting a style guide from some random school. Oracle appear to have abandoned their own guide: http://www.oracle.com/technetwork/java/codeconvtoc-136057.html 
Rationale?
Most likely the case, also does Chrome come with Java pre installed or something? On the pre installed linux browsers It always says I don't have java installed, but if I download chrome, it doesn't. Does firefox not support html5 or something?
Essentially what you're describing is a [CMS](https://en.wikipedia.org/wiki/Content_management_system). I don't think something like GWT would help here. If you don't want to use an off-the-shelf solution I propose the following workflow: **Adding an article** 1) User logs in to private area of website for content creators 2) User creates a new article 3) User inputs information 4) User saves article 5) Information is stored. (This can be on disk as some format like JSON or XML in a DB or Keystore, whatever.) **Rendering an article** 1) The application will get the article URL somehow. The servlet or REST endpoint would handle this 2) That URL is translated into the name of the article (name/id/short name, whatever) 3) The article is looked up in the database by name/id 4) The data from the article is merged into the template to create HTML 5) The output HTML is sent to the user It is also possible that you could just create the HTML in step #5 of the workflow for #5 and then look it up from the disk path (or wherever) later. This would make it harder to change the site's template later. A hybrid approach, where pre-rendering is used and regenerated when the site is changed would be pretty good, but might be a premature optimization. Some things you might want to look at: * [Spring](https://spring.io/) - Not my favorite but good for MVC apps like this one. Will help you out with some of the concepts especially if you use [Spring Boot](http://projects.spring.io/spring-boot/). If you go with this approach then [Spring Security](http://projects.spring.io/spring-security/) is a must. * If you want REST endpoints then you might want to look at [JAX-RS](https://jax-rs-spec.java.net/) and some of the implementing projects like [Resteasy](http://resteasy.jboss.org/) or Jersey. This could make it easier to write the service for retrieving rendered templates much easier. * Personally I'd look at EE6 over Spring, but that's because I'm more familiar with EE. For security/authentication/authorization I've had some success with [Apache Shiro](https://shiro.apache.org/). * For templating in Java I like [FreeMarker](http://freemarker.org/). This would allow you to take the data input by the user and render it in the template without having to mash up your own files. The template can be changed irrespective of the content. Just some thoughts. I don't think leveraging GWT is going to help you out much here.
The logger is generally static so there is no real performance impact. The cost of a pointer in the object is low. I like the static final myself, but to each his or her own.
I don't think so. https://support.google.com/chrome/answer/1247383?hl=en
You don't even have to use javascript really, it could just be a form that gets submitted. A more "modern" way to do it is with javascript submitting the form to a REST service but that's not required. The rest is correct. You could have it work on a webpage but directly converting it... probably not.
Exactly
Sssh don't give them ideas, but the joke is on them, I use zsh, and my dotfiles are in a git repo. Git reset head - - hard. Nuff said. 
&gt; I never bind it to a static variable. This is bad. * You can't log from static methods otherwise * You waste 8 bytes of memory for EACH instance (would suck if you're trying to model a large 3D object) * static is the right thing to do * You initialize access data on instance creation instead of class load 
&gt; * You can't log from static methods otherwise I can. Maybe with some logging frameworks you can't. &gt; * You waste 8 bytes of memory for EACH instance (would suck if you're trying to model a large 3D object) No. I also have only 1 logger per class and not per instance. I just don't tack it onto the class. &gt; * static is the right thing to do Maybe. &gt; * You initialize access data on instance creation instead of class load I might initialize it never. Its really only a problem if 2 or more thread try to initialize the logger at the same time which is really not a problem. It's not like I bind it to any variable. I always use LogManager.getLogger(this). warn( .... ); using a IDE macro. 
It's like they really don't want me to use java for any consumer applications. I know it's already a maligned market, but why make it worse? 
we got html5 for web, now we just need some new sexy language for computer programs in fact, I wouldn't even need to install that security hole at all if my jetbrains ide would use some another language
This is true, but they will usually echo a disclaimer when you run the updater for those programs. Cask isn't perfect (installing GUI tools from a command-line is admittedly messy), but I've found it's far better than doing it the manual way. At least for me.
&gt;Java on the desktop has been sad for many years, no signs of it signing. Java on the desktop has been *working* for many years. You may not notice it, but that doesn't mean it isn't there. If you make desktop apps, you ship a bundled JRE with the app. App works great, the user doesn't have to install anything separately, and the user's browser doesn't get touched at all. My employer ships several products like that, has been since around 2004, and I doubt any of our customers even know (or care) that the thing is written in Java. Also, JavaFX looks awesome. Can't wait to develop something serious with it. &gt;yay project Jigsaw will make it load 50% faster... but too little too late. Jigsaw will do a hell of a lot more than that. It defines a proper module system (like OSGi, only sane), most notably.
&gt; I wouldn't even need to install that security hole wat?
Nice. This has autodetection of input format (which can be overridden), a greater degree of customisability, and the Name type itself as a representation of parsed names which can then be manipulated in various ways, e.g, String propertyName = "date_of_birth"; String setterMethodName = Name.of(propertyName).withPrefix("set").toLowerCamelCase(); assertThat(setterMethodName, equalTo("setDateOfBirth")); How does guava handle TLA's, e.g. XMLReader?
Didn't they say that they had to keep the Ask toolbar due to contractual obligations, but they would remove it when they could ? (edit: I probably dreamt it) I can't image what kind of insane deal they must have with Ask to undermine their arguably very important product like that. Java's reputation is not exactly stellar.
yum update VirtualBox-*
After when oracle java has been blocked selfsigned certificates I was dissapointed/(
Sad day indeed. 
.Net to the rescue
Presumably you could create your own Logger which passes the logging to a logger for the calling class. 
JAX-WS for SOAP, JAX-RS for RESTful
I think the most important thing is finding out what technologies your group is using and become proficient with them. Are they using Spring? EJBs? Hibernate? JPA? What application server are they using? Knowing a bit about that could be useful. Also important...what IDE are they using? Do they support an environment that supports 1 or multiple? Learning your way around an IDE is invaluable.
i just want to access the class file from the jar file 
- Maven can't bootstrap itself. You must have Maven installed and configured on every developer's machine in order to use it - Maven requires all dependencies to be in a remote or local repository. You can't just say use this JAR. - Maven doesn't handle multi-module projects very easily - One-off custom logic can be a huge pain to accomplish in Maven Those are my biggest problems with it. 
Apache Wink is the JAX-RS implementation provided by WAS 8.0+.
I'm not sure what is exactly the problem you have, but maybe this can help. http://docs.oracle.com/javase/tutorial/essential/environment/paths.html
Sure you can put in absolute paths in maven too. There's nothing specific to maven that makes it portable. Just use a relative path with your build tree. This is quite common and even preferred in some cases, yet maven doesn't even allow it. With maven you either need to create a script that sets up everyone's local repository correctly or you have to install and configure an artifact server. Both solutions are heavy weight for such a simple task.
Here is an extremely efficient hashCode implementation that always meets the equals/hashCode [contract](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object): @Override public int hashCode() { return 0; } However, this implementation would be poor for a hash-based collection (like *HashSet* or *HashMap* keys). No single implementation will always be better. It depends on how and when the *hashCode* method will be called.
I've found Spring MVC (endpoints) and RestTemplate (client) with Jackson as a serializer/deserializer are simpler to use than the JAX-RS libraries. SOAP is the devil but if you must use it then JAX-WS is ok. 
I'm a bit picky, but one thing I really dislike with the module system is the notion of "parent", since it usually require bidirectional reference between the parent and the child project. Let's say you have multiple sibling project in one folder: -MyFolderProject --Project A (Depends on B, C) --Project B (Depends on E) --Project C (Depends on E with possible integration with F later, but not included yet) --Project D (Depends on A, C, E) --Project E (Depends on nothing) --Project F (Depends on G) --Project G (Depends on nothing) Then I want to run to a my "project D", how to do this without a parent project or a custom script? Does it exist a way to tell maven to search for which dependency to install in a folder? In Eclipse with the M2Eclipse plugin, if I have open project that aren't install yet in my workspace, the missing dependencies will be resolved, but not with maven alone.
I totally agree, Spring MVC and Jackson is easy production ready combo.
[Yatspec](https://code.google.com/p/yatspec/); all java, all good Concordion was great in its time, but yatspec is a far better, more modern alternative
&gt; preferred in some cases depends on if you're doing it right or want to produce some throwaway project. Either your dependencies are in your source as a dependant module, or you have them someplace accessable ~/.m2 if you're a lone wolf, or trivial nexus/artifactory repo. Another [hacky] option is to give everybody instructions on using something like http://maven.apache.org/guides/mini/guide-3rd-party-jars-local.html
&gt; Then I want to run to a my "project D", how to do this without a parent project or a custom script? Does it exist a way to tell maven to search for which dependency to install in a folder? Not sure what you're asking, could you elaborate?
Restlet and DeltaSpike
SOAPUI will save your life....
or just spring boot, with the web starter :)
I believe aggregators can do exactly what you want. Create a pom in your MyFolderProject folder that just has a modules node, with each module folder listed: &lt;modules&gt; &lt;module&gt;project-a&lt;/module&gt; // etc Now if you build that pom, all the modules will be built in the correct order, taking account of the dependencies between them. To just build project D along with the dependencies it has, run mvn -am -pl project-d Note that the aggregator is not a parent as none of your other modules need to reference. I think it's a good idea to split a shared parent from an aggregator exactly so you can avoid the circular references.
People are restricted by ide? Wtf
Maybe it's because I'm in publishing and have been using XML (and SGML) for the last 10 years, but I don't understand why people hate it so much. The tooling around XML is vastly superior to any supposed alternative I have come across, in particular JSON. XML also brings semantics along with structure and the ability to apply a schema. Now, I do agree that you should always use the right tool for the job and Maven can be particularly verbose. But I've written Maven plugins and know how the XML translates into objects, so I never had a problem with it. Maven is certainly not perfect, but it's still the best around.
guava and jackson. 
&gt; Because the latency imposed by the Java Garbage Collector (i.e. GC) is unacceptable for high-performance systems and because it is impossible to turn off the GC, the best option for real-time systems in Java is to not produce any garbage at all so that the GC never kicks in No, the best option is not using java. There are plenty of good real time languages around. Java is a wonderful language, it's good for many purpose but not for all of them. Violating his nature to bend it for something it shouldn't do is not good
Or use a proper real time JVM like Aonix offerings.
There was a discussion on IRC (freenode network in the ##c++-social or ##c++-general channel) a few days ago where a guy said that his company was using C# without GC. Essentially the reason for not using C or C++ was because his company thinks that "C/C++ devs cost too much". I can see that some companies will do anything with that mentality but use the right tool for the right job...
Or Azul Zing, or get enough heap to survive a business day without GC and then do one GC at night, or...
&gt; the best option for real-time systems in Java &gt; No, the best option is not using java. Actually, it sounds like "the best option for real-time systems *in Java* is indeed to disable the GC. I thought it was clear that the purpose of the article is to consider an answer strictly within Java. Clearly, alternative languages are part of a different discussion.
What about Dop wizard? 
The GC is an integral part of Java and Java development, that's why you can't disable it. If you're needing to disable it for whatever reason, you shouldn't be using Java. 
Zing isn't for hard realtime or super-low latencies. It's for latencies of up to 20ms (I think), and comes at the cost of lowered throughput. IBM's [WebSphere Real Time](http://www-03.ibm.com/software/products/en/real-time) (or Atego, formerly Aonix, PERC) is an actual hard realtime JVM, that guarantees latencies of a few *micro*seconds. It implements RTSJ (Real Time Specification for Java) the very first JSR, that has "scoped memory", i.e. arena collectors, for those threads that require zero GC pauses. Other non-realtime threads may use the GCed heap freely, and will never affect the realtime threads in any way. Of course, hard realtime also usually costs lowered throughput because that's what realtime is -- sacrificing average throughput (or even average latency) for guaranteed worst-case latency.
Because c#/java/etc developers capable of doing that kind of work (0 gc) are a dime a dozen, right? 
Good article, but the text color of light grey on white makes it almost unreadable on mobile. 
Remind me when .NET has nearly 100% feature parity and library parity between Mac, Windows, Linux, and runs on Linux under ARM, PowerPC, x86, x86_64, RISC, SPARC, and others. Currently, I can install Debian on any of those architectures, and do sudo apt-get install openjdk-jre-7 Then all I do? java -jar jarfilehere.jar And it works. Remind me when .NET can do that.
Well, that's the only (though huge) advantage of Java over .NET which Microsoft is going to hopefully close out soon.
"soon." Is that soon soon, Valve soon, or what? With Java, I can do it now. Now now. No waiting for "soon."
Sure, I personally agree with you, but that's another discussion entirely.
I won't work the solution, but I can try to point you in the right path. One core compsci principles is breaking a problem down into manageable parts. Write on paper each part from simpler to more complex that you are trying to accomplish. 
Try [r/javahelp](http://www.reddit.com/r/javahelp) or [r/learnprogramming](http://www.reddit.com/r/learnprogramming).
He needs to give credit where credit is due. That exact base strategy presented for open hashing is lifted right from Knuth's TAOCP Volume 3, including the initial 2 optimizations. EDIT: Also, its very disingenuous to talk about HashMap performance and *not* talk about collisions. A negative of the power of 2 approach and the hash = value is that you can very easily get degenerate performance. I quickly modified a bit of my code and ran it against theirs using their benchmark suit. I get these numbers &gt;Results for 'put': ,1000,10000,100000,1000000 tests.maptests.article_examples.IntIntMap4aTest,"41","45","52","107" tests.maptests.article_examples.RaffMapTest,"76","96","140","394" Now, if I just modify the random keys to be an evil sequence, the performance of their code goes to hell. &gt; Results for 'put': ,1000,10000,100000,1000000 tests.maptests.article_examples.IntIntMap4aTest,"1645","14080","21995","3285" tests.maptests.article_examples.RaffMapTest,"96","90","102","112" Which would definitely no longer qualify for "fastest hash map". 
not clear what your problem is. reading the input? understanding the equation you're supposed to compute? You can factor division by N out of the summation since it's a constant. Looks like you read N numbers, add them up, divide by N squared, then add 1. 
I found Dropwizard to be the most approachable RESTful framework, and I highly recommend checking it out if you're interested in building a REST service.
Have you checked out Spring Boot?
Have you checked out Java EE?
Dropwizard is great! I've been using it since 0.6.x. If you're curious to see some extra sample code with good explanations, check out [XDropWizard](https://github.com/timmolter/XDropWizard) on Github.
Congratulations for ignoring: + the **big red button** saying **"Seek Programming Help"** + the **big red banner** when **hovering** over the **"Submit Text"** Button, saying **"Please seek help with programming in /r/Javahelp"** + the **big red box** in the **sidebar** saying **"Please seek help with programming in /r/Javahelp"** + the **"?"** icon in the **blue "Related Sub-Reddits"** box in the **sidebar** with the text **"Java Help ← Seek help here"** **Post removed** wrong subreddit.
I think that an article and the code was updated a few hours ago. Unscrambled hash is no longer used and a pretty obvious explanation was given.
It is still very popular although harder to use and not as productive as Java EE these days. I think career wise it is an old tech but likely to be around for a while.
i've been ignoring spring for several years. last month i had to add a complex-but-standard feature to a web service. i thought "i wonder if spring has an out of the box solution for this?" turns out, there was and it saved me days/weeks of development time. 
Spring is hugely less annoying than it used to be, provided: a) You use only Java config (no more XML), and b) You use Spring Boot. Given these constraints, it's pretty decent.
No. Though I admit that I'm quite proud to be approximately on par with Koloboke in my benchmarks ;-)
I think sometimes people will go really far to avoid writing 1 line of code.
Spring is good but it depends what will u use Spring for. JavaEE can handle everything Spring can do. But in some cases, Spring is better. For example, web service or Spring mvc. 
I'm curious what it was in case I'll run into the same problem... One problem I've run in to with Java EE JAX-WS Soap webservices is that it's hard to manage stuff like custom Addressing. For some reason I needed to add "mustUnderstand=true" to the ReplyTo header and ended up doing it in a Handler after it inserted the Addressing-headers with a `getElementsByTagName`-kind of thing, yuck...
Spring Boot is pretty awesome. No XML crap: I really like it to quickly create a (mock) REST api for a single page application for example. 
:)
Having never tried Dropwizard, nor Spring Boot, what are the major benefits in comparison to latest JEE on say Wildfly 8.2? 
Dropwizard is ok. Multitenancy (especially the 1 tenant per schema approach) was our biggest hurdle. We had to recreate a lot of the Dropwizard "glue" to get it working. I haven't tried with the released version of 0.8.0, but one of the RC had conflicts between Swagger, and the Static Asset module. 
Ya, I also did a lot of Spring back in the day when it was literally 100s of pages of XML... hum why is this code doing Y.. better do a search through 600 pages of XML to find out what could do something.. of course we should define a bunch of aspects in there too, to run on top of all the spring transactions aspects..
You should look at Spring Boot. Much simpler than Java EE.
You should look at Spring Boot. Definitely not old tech and I would say more productive than Java EE.
Is the client facing API a rest service? Assuming it is, use something like [swagger](http://swagger.io/) (standard generation available for many languages) or [MireDot](http://www.miredot.com/) (Java specific, very quick to get started). Both of these take the exposed Java web service methods and create very nice looking documentation. Swagger requires extra documentation. Miredot reuses existing Javadoc tags.
Hmm, I didn't find anything that uses bootstrap (but that's probably overkill anyway?) I did find a couple of CSS files though. https://proxy-vole.kenai.com/release/current/javadoc/stylesheet.css http://docs.mockito.googlecode.com/hg/stylesheet.css https://code.google.com/p/guava-libraries/source/browse/javadoc-stylesheet.css?r=87c758892b137a647fdb975c79443519ff25828e 
Guava has some cool testing features. I am a big fan of the tester that covers null inputs for methods and constructors as well
Ha Spring transactions... I can remember the first time I truly raged at Spring, the @Transactional aspect only works if your calling from outside into the class, blah blah proxy nonsense you shouldn't need to worry about. A Junior dev made the mistake of calling within the class, which is a perfectly acceptable thing to do but it lead to major mess as it didn't rollback properly. It took us the better part of a day to figure out what went wrong because its not an obvious problem when scanning the code. Of course you can fix it by doing stuff like load time weaving but now your adding complexity ontop of complexity and it seems to be the first thing that breaks when you upgrade from Java 1.x to Java 1.{x+1}. It also can cause problems with your code coverage tools.
Having used RestEasy, Jersey, and Spring on production products, Spring is much easier to support because of the massive community. Spring Boot even lets you use JAX-RS instead of spring mvc if you want to. Spring gives you all the tools to prevent from reinventing the wheel and focus on your business problems.
Scaladoc is pretty sexy, as far as I know, you can run it on Java without any scala in the picture.
Another idea, put the artifacts up on a maven repository and have them use credentials of some form (username/password or SSL cert) to access it. Won't stop naughty people from just downloading the JAR, especially as some enterprises do not like having artifacts that aren't checked in, but it would block them from downloading the binaries if you disable their access after a specified period. This ends up working to your advantage if you are planning an annual maintenance &amp; updates model as well, you could in theory limit them to only accessing the artifacts they should if they decide to not renew their subscription. Again, it can still be easily broken but you already realize that a determined scummy company or developer isn't going to let trivial protections stop them anyway.
PaaS will be the eventual downfall of the current spring projects. Their boot times are horrendous for certain paradigms.
Spring is pretty much the standard now. May make sense to familiarize yourself with struts as well. A lot of code has been written in that over the past ten years so enterprise shops value it.
This is a banal reply. Manual memory management has it's own can of worms, namely, the malloc implementation. It's not a given that allocation/deallocation in a manual environment is faster than garbage collection, and the same techniques are used ie object pooling.
This seems to be the right answer if you just need the API documented for public use, javadoc is NOT the way to go.
If you are documenting the REST API then JavaDoc is the wrong tool for the job: use Swagger as others have mentioned, especially if you have the luxury of a green field. 
I'm not really sure what your assignment is. And I can't really see what is says on the screen. But here is a really simple prototype that you can use as an example. public class PriceGenerator { public static void main(String[] args) { int price; int width = 11; int length = 5; while(width &lt;= 20) { price = width * length + 19; //Not really sure what the screen says System.out.println(" " + price); width++; length += 5; } } } 
I thought I knew quite a bit (hey, look at this cool program I did for an assignment!) Then I got to work in real dev position and realized I knew *nothing*. The most useful practical coding knowledge I learned from school is probably how to write loops and conditional statements. (There are many valuable things you learn from an academic setting ... You learn how to think critically, problem solving, etc as well from school)
So I guess it would be good idea giving a look at Play after learning Spring in order to be employable.
IMHO, yes, I'd become familiar with Spring first (Spring Boot is a great start), as it is more widely used.
A lot of people tell me you need "practical" knowledge which you can only gain from experience on the job. Given that I only know how to code in an academic setting, how do I break through and gain that needed experience? 
Thanks a lot! One last question: what book would you recommend for starting with Spring?
http://www.infoq.com/research/api-documentation give a pretty decent overview over the options. Personally I'd just stick to javadoc with an improved CSS File. I'm not aware of any "read to use, beautiful results, just plug in" solution, though.
I would suggest doing this Java EE example from oracle. [Your First Cup: An Introduction to the Java EE Platform](http://docs.oracle.com/javaee/7/firstcup/) I liked it because it's simple and very hands on, try to understand to the architecture and the different tiers also as much as possible while you're coding it up. It's also nice that after you code it, the different tiers are explained in 'depth'. It should take you maybe a couple hours or a workday or so. Then you could check out slide 3 and 4 of [Java EE and Spring side by side comparison](http://www.slideshare.net/reza_rahman/java-ee-and-spring-sidebyside-34320697) To get a feel of what the differences are and it gives you a good feel of the global picture in a fast amount of time. Doing the first cup of Java EE made me understand Spring better. And it worked for me to get me started. 
I've been working on [translator generator plugin for IntelliJ](https://github.com/krasa/translator-generator-intellij-plugin). It is still work in progress and it is not in the plugin repository, there are still quite a few edge cases, but it can generate translators quite well already, and it saved me a lot of pain with things that Dozer just could not do nicely (inheritance stuff). It is not some dumb script, it uses the PSI from IntelliJ, so it understands types and stuff... demo: http://i.imgur.com/DOMa9FN.gif generating setter calls demo: http://i.imgur.com/mDnEmPj.gif
I don't understand what you are saying.
&gt; How much do you mean by "quite a bit"? Did you have any experience with some of the more advanced enterprise design patterns, and frameworks/tools like Spring/Hibernate, Angular.js, maven/ant/jUnit? I think you need to re-read what I wrote ....
Even the phone apps all allow reading of the sidebar which is considered common rediquette. The message you got is the standard message that everybody gets and I am not inclined to change it. It is any user's responsibility to familiarize themselves with the specific rules of any subreddit they are visiting and even more so if they are going to post there.
Doxygen,
Most of the languages you will need to learn, you will probably have an intro class for. I would recommend learning Java and C++, as those seem to be the most common for professors to ask for. Also, it couldn't hurt to look into C# and you are going to want to at least understand how Assembly works (which is a lower-level language than things like Java). TLDR: Learn some Java, C++, and touch on Assembly.
&gt; Let's get back to class names. When you add the "-er" suffix to your class name, you're immediately turning it into a dumb imperative executor of your will. You do not allow it to think and improvise. You expect it to do exactly what you want ...and what's wrong with that?! When I call a writer I expect it to write. I expect a listener to listen. I expect a reader to read. Implementation details can still change, it's not set in stone what a writer is writing to, etc, but fundamentally I want it to carry out a specific type of behaviour. When the point of the class is a term which ends in "-er", then some daft blog post saying this is wrong is going to be chucked out of the window in favour of common sense.
Sounds like OOP zealotry. I kind of need a slam dunk example, because it sounds like genericized operations code is "bad". Um.... no 
seriously, the current version looks pretty good, much better then the ancient java6 one. why do we need to inject horrible amounts of javascript into everything
From college (1997-2001), I learned VB, C/C++, SPARC Assembly, Lisp, Ada, SQL, and Javascript. In my free time while in college I learned Perl, PHP, Java, and ASP. I also did personal projects ranging from games (word and 2D) to web development (my favorite!)) using all of these languages (except Assembly, Ada, and Lisp because meh) and one or two libraries/frameworks per project. Ninja edit: Forgot Assembly...and the know-how to program in it!
Boot time for spring in my experience is one or two minutes with hibernate and all its luggage. Not enough to hurt Paas much but its a drag for development sometimes.
Doclets are the preferred way to customize JavaDoc output. Additionally, there are MANY custom doclets out there to not only make your docs look better, but also make them easier to write. I recently started using a [Markdown doclet](https://code.google.com/p/markdown-doclet/) for JavaDocs.
What have you mostly worked in since you began your career? 
I've just started Vaadin, but how I think of it is that Vaadin is about solving problems (thus, making money) quickly; not about saving bandwidth or memory. Having a sticky session load-balancer is all you need to deal with horizontal scaling. As far as MVC is concerned, I use [MVP](https://vaadin.com/book/-/page/advanced.architecture.html#advanced.architecture.mvp). As another benefit I was thankful for today, composition was the hardest part about grokking a framework (&lt;a4j:include; &lt;jsp:include; transclusion; ruby partials....) but since this is Java it makes decomposing and reusing as simple as you do in all your other backend services, which was a really big breath of fresh air. 
95% Java.
Are you using spring-ws? I'm using it these days on a second project and have nothing bad to say about it. I used a custom header as well on both projects that I had to send, if you are still interested I can post my code sample.
ASK EDWIN
Well, I was thinking in the lines of more traditional, server generated pages. I thought Play Framework was at least partially oriented in that direction too. I mean, the possibilty of using a client side JS framework like Angular. 
Have to be honest; while I'm employed in Web, I'm not really the kind of thing where I go home at night thinking about how to make the web better. Dropwizard is a collection of libraries, and as such anything I critique is easily diverted to the library responsible. Most of my gripes are little things, but probably my biggest gripe is that the documentation is just plain terrible. Perhaps that's to be expected, since it's job is to pull together these libraries, but being a complete newbie on the subject 6 months ago, I found the experience to be quite painful. Perhaps the other reason I was unimpressed is because I didn't have any great example-code to work with; the lead-dev pushing dropwizard just kind dropped it in my lap and said "here, figure it out." Maybe in a more established application designed around the way dropwizard was meant to be used would have left me with a better impression. Perhaps if I was more experienced or interested in web, I'd have a better reply. Yes, I'm quite aware this reply sucks. :P edit: http://sparkjava.com/documentation.html I found this a couple months ago; the API looks very clean, though I don't know how production-ready it is.
You might look into some of the structured courses being offered by edx.org https://www.edx.org/course/introduction-programming-java-part-1-uc3mx-it-1-1x#.VP57No7F__w Also, much to what Yawn_Z is saying taking courses that are more language agnostic and more forces you to think critically and analytically can be very helpful. https://www.edx.org/course/introduction-computational-thinking-data-mitx-6-00-2x-0#.VP57eo7F__w
Have used doxygen a few times for REST API documentation and it was extremely easy to learn and use, as well as functionally deep 
I know this probably is a bad question, but can someone give me a really short definition of what spring is? I've read about it so often and I've even used features of it in the past, but I never had a short description, what spring is meant to do over all. I did not get good explanations when using it the first time and so I just autowired some beans and injected some default-values to them. 
I'm also a Java programmer. What kinds of things have you worked in your career? Web, app development? 
Marketing + 'The Dream merchants' .. basically, we both know why it doesn't change.
Cheers.. Will have a play
Perfect.. Thanks :)
I'm not extremely familiar with using spring boot extensively but one issue could be that the predefined configuration isn't really production ready but it's very portable and decent for starting which is basically the entire mantra of the setup. 
Well to me personally the main downside is that it is complex. We all know that Java project setup is somewhat always been complex task, but many Spring Boot advocates try to sell it as simple. I don't agree with that, I tried it 3 times over the last year or so (last attempt was very recent) and I have a feeling that it is easier to setup Spring project manually. My specific painpoints were - jsp support, it is easy to setup first controller but anything else requires troubleshooting as you always end up with all kinds of exceptions. IMHO Dropwizard is a lot better in this regard.
Congratulations for ignoring: + the **big red button** saying **"Seek Programming Help"** + the **big red banner** when **hovering** over the **"Submit Text"** Button, saying **"Please seek help with programming in /r/Javahelp"** + the **big red box** in the **sidebar** saying **"Please seek help with programming in /r/Javahelp"** + the **"?"** icon in the **blue "Related Sub-Reddits"** box in the **sidebar** with the text **"Java Help ← Seek help here"** **Post removed** wrong subreddit. 
My biggest problem with it is the amount of magic behind it. I love Spring, and Spring Boot makes it really quick and easy to get something working quickly, but there's so much magic involved that when something goes wrong, or wants changing then it *can* be a real pain to work out how to sort it out...
&gt; I personally like Eclipse. But I can't imagine a project with multiple developers not using something like Maven to avoid this situation. There are other reasons that you may have to use a specific IDE. It's quite possible that your job may involve custom frameworks or tools, and to use them, a specific plugin has been written for Eclipse/IntelliJ/Netbeans. This would tie you to the IDE while still meaning that your project could be built by anyone. The plugin might not strictly be mandatory, but lacking it could hinder development enough to make it virtually essential.
Slower start of an application server, customizing anything is a task for google. 
I really like it so far, just need to run it past a few people
If you are a Java developer, then the Java EE Framework will and should be your bread and butter. Learn it!
[start.spring.io](http://start.spring.io/) seems to work fine to get yourself started with a spring boot project.
That's way to slow for correct auto-scaling. Correct auto-scaling should include only starting up additional instances when needed. However, with a 10 second boot time, your users are going to sit there waiting at a blank white screen because you delegated them to the new instance but spring is sitting there building the object graph. In a PaaS, spring is awful.
In my experience it's more then enough to cripple a PaaS. Most PaaS will auto-scale with creating/destroying instances on demand. If I have to wait 1-2 minutes for your server to start before my page will even load, I'm outta there.
I won't deny that quick-start is better than slow, it helps from iterative development on my pc all the way to PaaS deployment. But I don't think being 2 minutes longer on spin up is enough to be a major hit. You just have to adjust your auto-scale parameters to take into account that slower startup.
Check out doclava, its the docklet system the android documentation is based on. https://code.google.com/p/doclava/ 
This is a very impressive project! I looked into using this for a project and we did go with [JaCoP](http://www.jacop.eu/) instead at the time because we needed a more focused CP solution, but this was still an impressive package and I could happily focus on just this for a customer for a good long time and be happy with it. 
I don't understand the desire to use a List instead of an Array. To me, I would use an array for a non-mutating collection and a List for a mutating one. Since it's a list of constructors, I'd assume it's immutable. If it's hotswapped and recompiled, the result of the get call will just return a different array. It just doesn't make sense to me to provide a mutable list of constructors. 
App Engine is popular but I've had problems with it and spring projects, it works but the long boot time is problematic for their paradigm. Heroku and AWS are also popular options.
Most `REST` services simply aren't. I'm not sure what to call them but Swagger is great for those.
As the collection is being returned to a client, the designer of the API doesn't know what the client is going to do with it. APIs should maximize flexibility and not make limiting assumptions. Collection classes are generally more flexible than arrays. Real example: A developer of an IDE will want to get the non-synthetic constructors of a class to display to the IDE user in code insight. With a List&lt;Constructor&gt; he could simply traverse the list removing constructor.isSynthetic() entries. With an array, he'd need to find out how many synthetic entries there are, then allocate an array of that size, then copy them over.
I'm no expert, but as long as you don't call it Java (because it won't be Java because of these modifications) you should be OK . Not calling it Java will of course limit your potential audience.
But then you're left to wonder if mutating that list of constructors will propagate to any other part of the code. What if get constructors doesn't return a clone of the list but the underlying list itself. Then a mutation at one point will propagate to other parts that are unaware of such mutations. My making an immutable array, you're making it more constricting but more explicit that to mutate this list, you have to explicitly clone the data. Yes I'm being more restricting but to express a concern about mutation propagation.
APIs should always return defensive copies of internal mutable state, otherwise they're breaking encapsulation and leaving themselves open to external classes modifying their internal state. Passing out immutable objects is safe, however passing out shared mutable objects like Lists and arrays (how can arrays be made immutable?) seems like a bad idea as clients will be open to concurrent modifications of these objects as different clients change their contents at the same time. Clients can't make their own defensive copies as it is too late as another client may already have modified it. In the few cases where a shared instance of something absolutely has to be passed out, I'd make it incredibly clear to the client developer what and why they have to deal with this complication. 
I see Comsat (your Quasar based library) supports Spring security and security annotations. These operate by storing state in ThreadLocals. Is it possible to use Springs @Transactional annotations? Transaction managers and transaction manager aware datasources also use ThreadLocals if i'm not mistaking.
Fantastic response.
I think you may have misunderstood me. I was just providing a valid reason that a specific IDE is required that isn't tied to the dependency management or build tool. I'm all for Maven/Gradle in my projects. 
The Comsat-Spring integration includes the port of Spring Boot tests and e.g. this one https://github.com/puniverse/comsat/tree/master/comsat-spring/comsat-spring-boot/comsat-spring-boot-sample-data-jpa uses @Transactional. ThreadLocals in Quasar fibers just work as expected, the special support for Spring Security is needed just to let request-processing fibers inherit threadlocal-bound security context from threads.
Opps, I'm dumb. For some reason, I thought arrays were immutable. Not sure why.
Oh cool! Follow-up question: When running inside a @Transactional boundary, the JDBC queries are executed on the same io thread dedicated to that JDBC connection. Are non-jdbc function calls inside the transactional boundary run on Fibers or are they scheduled on the db IO thead? example: begin_tr do_query_1() transform_query_result_1() &lt;-- does this normal function run in a fiber? do_some_other work() &lt;-- does this suspendable method call run in the IO thread also or in a fiber? do_query_2() transform_query_result_2() commit_work 
http://tapestry.apache.org/tapestry5/apidocs/stylesheet.css
Downvotes
see my reply above; it would be interesting to see.
This pretty much already exists. And it is called groovy.
Bare in mind that code is from pre 2006. Nowadays they use natives for opengl/DX rendering
Runescape 
Isn't minecraft written in java?
use a loop. something like this for (int i = 0; i &lt; userInput; i++) { System.out.print(myString); } 
Life saver thank you
Do you by any chance know how to make it print like this, for example if I put in the number 4 it would bring like this. lets say my thing is () if I put in the number 4 it would print like this. () ()() ()()() ()()()() but on top of each other
I don't see why you couldn't at a language level too based on the storage class of the return type. The only problem would be a sudden rise in ambiguous calls.
At present the Comsat-Spring integration concentrates on the web part, i.e. it lets you run your web requests in fibers rather than threads. Comsat also separately provides JDBC integration but it's currently not (yet) being used in the Comsat-Spring integration, which means you can still call into JDBC from Comsat-Spring controllers but that will be less efficient than it could be (it'll block the thread the fiber is running on rather than just the fiber itself). That said, according to my understanding of @Transactional (e.g. http://java.dzone.com/articles/how-does-spring-transactional), at annotated method start the transaction manager (if so advised by the aspect) will put the entity manager and connection in the ThreadLocals during fiber's execution, so they'll become fiber-bound ThreadLocals rather than thread-bound ThreadLocals. Fibers behave mostly just like normal threads, so every method you invoke in their context will be executed as part of the fiber (and suspendable ones will be able to suspend the fiber). So non-JDBC calls will still be executed in the fiber's context.
Sidebar rules: &gt; Please seek help with Java programming in /r/Javahelp!
Well I play around with this and I still prefer good old Jersey wirt my JavaEE+hibernate stack. But as said before, it's all about context.
Yep.
libGDX: http://libgdx.badlogicgames.com/ Also check out the forums at http://java-gaming.org
ya! but i think the latest version doesnt require java anymore o.o i think my question was badly worded, im more looking for code to read of well-made games
Playing it right now :P
Thank you, i will check this out! Links like these are more what i was looking for, i think i worded my question poorly.
This is awesome, thank you and whoever made the repository.
;)
Great rep. Take my upvote young lad.
Congratulations on being the most unprofessional moderator I have ever seen on any subreddit. You could have easily told me "Hey its the wrong subreddit man, I'm going to remove your post" See how easy it is? Calm, Professional, and you do not come off as a douche-bag, but no you had to go the extra mile, and come off as a condescending ass-hole and for what reason? None. 
The message you got is the standard message that everybody gets and I am not inclined to change it. It is any user's responsibility to familiarize themselves with the specific rules of any subreddit they are visiting and even more so if they are going to post there. There are more than enough hints on the website that rectify my actions.
This again shows the value of adhering to standard interfaces. You can even get a good number of tests for a very small upfront cost.
Thanks!
Use JOL: http://openjdk.java.net/projects/code-tools/jol/ Read this: http://psy-lob-saw.blogspot.com/2013/05/know-thy-java-object-memory-layout.html
I don't keep up with minecraft, but the last article I saw said that minecraft was being bundled with it's own jre so that the users don't have to keep a standard java install on their machine.
Truly amazing, thank you.
I'm amazed too, thank you!
This is more of a business question than a technology question. The higher ups* in the company should be discussing this as a business issue. Your clients ARE justified in asking for this. At the same time, they have to expect that they will pay for it -- somehow. You've got a business to run. They may pay for the certification process itself. Or they may simply pay in higher ongoing maintenance or update costs. Your business must also face that fact that you must charge enough to make money on the work that is necessary to do to produce the product. Customers must also face that fact, or they won't have any vendors remaining in business. If the market cannot sustain the higher costs, then the customers must recognize that they may not be able to have everything they want if the customers cannot pay for the cost to develop, maintain, certify and whatever else the vendor must do. *Question: *how many managers does it take to reach a decision to begin a study to determine whether a light bulb should be replaced?*
Thank you this is great!
I work for Azul Systems (who make Zing), so feel free to accuse me of bias. Not sure why you claim: 1. "It's for latencies of up to 20ms" - it's hard to quote numbers without an application in mind. I can say some of our clients experience a worse case latency of 1-2ms. The OS configuration required to get these sort of worst case latencies (as a hard requirement) is a challenge entirely separate from Java and the JVM. 2. "and comes at the cost of lowered throughput" - Not sure why you'd think that. Applications performance is different between Oracle and Zing, depends on how much each compiler 'likes' your code. Some applications have better throughput, some worse, the differences are usually minor either way when you look at a full scale application.
I'm surprised you should say that, opinions I've heard thus far claim G1 to be less predictable than CMS if anything. Can you share a relevant link?
Thank you very much. I have been wanting to learn this concepts for a long time and this is a great source for that. Thank you again for sharing this.
Right, defending your self from condiscending comments is a crime, and I do not care for getting banned from this sub-reddit considering its modded by ass-holes.
I don't have a link. But the algorithm is designed to be more predictable than cms, and in practice I've found it to be much more predictable. Cms on long running processes with large heaps can get to be very unpredictable. Cms in those situations can cause minutes long gc pauses. I'm interested in seeing cases where g1 doesn't work though. Do you have links? 
Oh, sorry Nitsan (Gil told me you're working there now -- cool!). I thought those were the worst-case guarantees you're making, as the discussion is about real-time and worst case latencies (as to the throughput cost, I figured the read barrier on references has an impact). RTSJ makes different guarantees of, I think 1-2us of worst case latencies on realtime threads (and comes with a whole different set of tradeoffs). I love Azul, and I'm sorry if I've misrepresented the facts. 
Then what are waiting for? Create that fork today ;)
The real problem is finding time, energy and knowledge. But heck, if my original post inspires someone to do it... well that'd be awesome. 
Just - grow - up. The only one who is biased, full of self righteousness, and self importance is you.
Everybody always things someone will create that fork, report that bug or send that patch. After all, it's always really easy and just 5 minutes of work. But of some estimated 9 million Java developers alone, a few dozen at most actually do this stuff. The percentage is incredibly small.
:) no offence taken, and I will send your love to the guys. Real time as in hard real time OS/JVM is not the market Zing is in. Zing deploys on regular linux, and shines in the soft real time space. I mixed the post context and the root comment context, apologies. The read barrier is a difference between JVMs but it makes little difference to most real world applications. So an object array copy might be slightly slower on Zing, but for most applications that's not where the hot spot lies.
Thanks to that repos I passed my OOP exam yesterday.
Oh congratulations!
Hate to be that guy but this really does nothing you can't do without googling 'speed up Eclipse' and seems to be a way to get users to install a trial for $365 per year live-reloading software. Now to uninstall this junk...
Definitely not. But I am looking from a neutral point of view as opposed to your opinionated POV. You feel mistreated and misunderstood where in reality you are just upset that somebody finally told you your place. Plus, you are not even able to carry a simple conversation without either getting abusive, calling names and falling into racial slur. All good indications on your overall level.
I think you are giving a false sense of hope to college students and others. Yes, there is hope, but not nearly as much as you claim there to be.
Reddit killed our server, here's a [mirror](http://www.badlogicgames.com/wordpress/?p=3640). Everyone's asleep except me. Guess who has no access to the web server :)
I don't understand. How are you supposed to run more recent versions from oracle? Or have oracle dropped support entirely?
Minecraft Pocket Edition is written in C++ iirc. The Java-based desktop client assumes desktop heaps and GPUs, so just dropping that code on iOS via RoboVM won't work. Furthermore, mods on the desktop rely on dynamically loading bytecode at runtime, something RoboVM can't support on iOS due to restrictions by Apple. It's the same reason why V8 and LuaJIT aren't on iOS: memory pages can't be made executable.
&gt; * Reified types. Many people are unaware of this, but Java's use of erasure turned out to be a very lucky break. Reified generics force you to bake the variance model into the runtime, while variance models should really vary by language (in fact, pretty much each of the languages you listed has a different variance model, yet they all -- except Ceylon -- share collections) -- there is no one "right" variance model. If you have reified generics (like in the CLR), all languages must either adopt the same variance rules or not be able to share collections, or any other generic types, among them. The downsides to generic type erasure are few and minor in comparison. So, in these polyglot times, reified generics are actually a bad idea. Specialized generics for value types only, however, are a necessity and coming in Java 10. My preferred design -- if made possible by new JIT optimizations -- is that the public API, even of specialized generics, be erased too, and the JIT will elide boxing. Work is being done to try to achieve this goal.
It is! Because you are hauling along all the stuff to do server side pages, the framework will be bigger. 
The last thing the world needs is more negativity.
Ah thanks. Looked for something like this in the sidebar of several subreddits but was somehow unable to see it. Seems to be pretty slim on the Java side (only head first) but eh, better than nothing EDIT: oh, it's from 2005. I dunno, I think it wouldn't be bad if Hava 8 stuff was in it from the beginning..
I have heard good things about the 'head first' book, though I find them needlessly wordy. But if you have net access, there's a lot of material available. Start with the Java tutorial at Oracle's site.
Just some food for thought for you: If everyone else is wrong, the truth is that the problem is probably you... The people you insult in the anonymity of the internet might be your current, or future teachers or employers...
Just 5 hours before yours there was [this submission](http://www.reddit.com/r/java/comments/2yq05y/best_book_for_programming_newbies/). In short: check the "learning" related subreddits linked in the sidebar (or the other post), read it's FAQs and sidebars. Search for "book threads" in these subreddits, this question has been asked – and answered! – a thousand times.
Thanks for noticing. Feel free to mark those as spam in the future. It'll help us mods to remove them faster.
Spring or Spring Mvc? Spring Mvc is imo the best java framework for doing java web development right now. A project I was on used to use Struts, we looked at all the alternatives but nothing was genuinely definitely better. Then we did Spring Mvc, and finally something that actually improved things rather than just adding complexity on and pretending it "helped". We did convert our stuff to Spring Mvc, and it was very good. Now "Spring" by itself - it's worth learning for career reasons, but personally I find it next to useless. Mostly it's just another way to do things you can already do. It seems to be used a lot though, for reasons I cannot understand. 
Depends on your experience of programming in general and the amount of hand holding that you want. If you are a programming beginner, you might want to get the [Dietel &amp; Dietel Java book](http://www.deitel.com/Books/Java/JavaHowtoProgram9e/tabid/3622/Default.aspx). On the other hand, if you already have some programming experience, then I would recommend [Cay Horstmann's Core Java](http://www.horstmann.com/corejava.html) books.
I might be cynical but ... 1) You can configure this yourself 3) Can be fixed by restarting Eclipse (which probably resets the cache) 4) You can’t always use the latest greatest JDK 5) You can’t always use the latest greatest IDE **6) This is an absolute beauty ... it’s always going to “suggest” you install JRebel (and oh by the way, it costs you money...)** Only #2 sounds like it’s doing something useful but you could just turn off verification yourself by using -Xverify:none as a startup argument.
4.3% according to http://www.studentsreview.com/unemployment_by_major.php3 So you need to not be the worst one out of 23 people. Not bad. That said, I also don't trust the quality of data obtained from that survey.
4) You can run Eclipse on Java 8 and still develop apps for whatever version of Java (as long as you have that other version also installed on your machine and configured Eclipse to find it). I'd recommend you to give Java 8 a try ;-) 5) yeah, some out-of-date plugins can be a problem. 6) Cool :-) Maybe you can drop a hint at sales@zeroturnaround.com with your manager name and contact info and ZT sales people will be more than happy to do the convincing for you. ;-) Yeah, expectations matter a lot. :-) And, if you want to draw such comparisons then ZT does offer a free version of JRebel for non-commercial use, just check out https://my.jrebel.com/ BTW, Simon also published a detailed under-the-hood blog post about the optimizations that the Optimizer performs and why they are important. Check it out: http://zeroturnaround.com/rebellabs/eclipse-having-a-slow-day-speed-it-up-in-a-few-clicks/
I don't trust it either, 4.3% sounds unreasonably low. The study doesn't tell us what type of job the person got. It also does not tell us if they are only counting people that have not given up on finding work, as other unemployment figures use. How long it takes to find a job in the field of study after graduation is also a factor. It could be that they count someone who studied computer science, was unemployed for 2 years, then found a job at a fast food restaurant, and they flaunt it as a success story for the university. Who really knows?
I think i'd rather use TeaVM for this.
Then you should not be in this subreddit...
...or what?
Oh noes! My internet points! Whatever shall I do?
The official OSGi doc is a specification only, there are mamy implementations, I recommend getting your hands on a good book, there are a few out there, don't remember exact titles off the top of my head though
Check out the [tutorials section on the /r/Javahelp wiki](http://www.reddit.com/r/javahelp/wiki/tutorial_list). How long would it take? Well that cannot be directly answered because it depends on you: + The time you can allocate + Your ability to grasp new concepts + Your ability to retain vocabulary + The efforts (not only time) you put into learning + Your creativity And most important of all: *Programming* is not only about learning a *programming language*. Learning the language is the *easy* part. The *language* is only a *tool*, a way to *express* one's thoughts in a way that a computer can understand. *Programming* is about creating solutions, solving problems. It's about being able to think in a very specialized way (algorithmic thinking), it's about abstraction. Everything but learning the language requires *practice*. Only the basic concepts can be acquired through learning, the rest is acquired by working hard, time, and practice.
Maybe a bit big for your needs but these projects allow your first two requirements: - camel/fabric8: http://fabric8.io/ - Spring Integration: http://projects.spring.io/spring-integration/ - vert.x: http://vertx.io Regarding your third requirement, you'll have to deal with http://flywaydb.org/ or http://www.liquibase.org/ Other alternative could be http://www.dropwizard.io , but it won't give you the hotdeployment. Really seems impossible :-/ this reminds me this chart: http://www.bjheinley.com/wp-content/uploads/2013/12/goodfastcheap1.png you can get two of them but not all three. 
I will. "Tomorrow"
Well said. It takes a different type of thinking than what some people are used to. Personally I feel like you kind of have to like to solve problems to become a decent programmer, hehe.
- What's in your `WebConfig` class? How does your controller look like, and what does it do? - If you select "JPA" and want a web application, then you probably also want to select "Web". There are applications that use JPA and don't need a web frontend or REST endpoints. - "Web" adds `spring-boot-starter-web` as a project dependency, which pulls in all the dependencies you need for a Spring-backed web application. Adding `servlet-api` and `jsp-api` dependencies manually, without making sure to pull in all other Spring-required components, is probably why you got smacked in the face by the validation exception. As explained everywhere in the docs, Spring Boot bases configuration on what's available in the classpath. `spring-boot-starter-web` pulls in Hibernate Validator, so if Spring Boot checked for `servlet-api` and found it's there, it might've assumed that Validator is available, too. - How should autoconfigured database abstraction work if there is no database to work with? Are you aware that Spring Data JPA does a little more than just to make JPA available? - Why are you accessing `/boot01/WEB-INF/jsp/index.jsp`? No matter whether you use Java EE or Spring, the `WEB-INF` directory [is not supposed to be publicly accessible](http://stackoverflow.com/a/19786283/2104717). Also, your application is not running on an application server. There is no context path, so drop the "boot01" prefix. - If you want to add JSP support, [read the docs](http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#view-jsp). It boils down to just making a view resolver bean available in the application context. I don't work with JSPs myself, but all effort I had to expend on finding this information was pressing Ctrl+F and entering "JSP". &gt; Of course you can always say I did something wrong, but then in my view this only proves that Spring boot is complex to setup new project, otherwise everyone would get it right. "Otherwise, everyone would get it right" is a broad statement. Is swimming complex because there are so many people who can't swim? 
Yeah microservices might be something to consider too. Thanks!
How far away is this from supporting also Mac OS X? I would like to be able to create ahead of time compiled desktop applications for OS X in Java and would love to be able to use Robo-VMs greatly simplified access to Objective-C code. 
No book is better than "thinking In Java" if you are starting. Bruce Eckel's books are a pleasure to read and the examples are easy to follow. I learnt both programming and English by translating his books (thinking in c &amp; thinking in c++). Also, his books are free.
Tomorrow never comes ;)
I mean, I think flyway is older than RoR.. too lazy to double check dates though ;)
Why not just deploy the whole application? You should have a load balancer, and at least 2 instances running, then you can just shutdown one and deploy a new version... Rolling restart. Microservices are nice, but you will need more RAM for all that overhead, and I find developing monolith to be easier and faster.
I don't have any experience with either of these. So, sadly, I cannot answer your question. However, I am quite interested in why you chose to not use Spring. I'm very curious about this design decision and if you would be willing to share your reasoning, it'd be much appreciated!
[Teach Yourself Programming in Ten Years](http://www.norvig.com/21-days.html) I was an experienced Cobol developer, and it took me 3 years (6,000 working days) to really learn Java SE and Swing development.
There really wasn't any point to it. There are a couple of nice things within Spring -- JDBCTemplate, etc. -- but they're not so nice that they're a game-changer. Spring Security is a decent framework, but it is not compelling enough to get us to move over to Spring. I can't really think of anything that Spring provides that we don't get with standard JavaEE and a couple of CDI libraries. There was no point to us introducing this gigantic new application framework, only to get a few insignificant benefits from it.
We are familiar with Keycloak, and are intrigued by the thought of the two projects combining. So far, Shiro seems rather intuitive. We'll have to build in some utility classes to make it play a little bit nicer with CDI, but other than that it seems pretty straightforward.
I used Shiro many years ago (3 or so, been a while) so it may have changed in the meantime. What I loved about it was the ease of use. What i hated about it was the limited ... power that it had. Have since moved to spring security and cannot be happier.
Forgive me senpai.
I used Shiro to do attribute based ACLs on a complex content management app for fine grained authz. Was pretty good. Authentication, SSO and course grained authz was outsourced to an enterprise stack though (Oracle access manager with OVD/OID). I think PicketLink is role based access control where Shiro is attribute based. 
If I was doing the analysis I would have to decide what Picketlink + Keycloak brought to the table. It looks like Keycloak has Remember Me functionality built in if that means anything.
3 years = 6000 working days? On which planet are you? ;P
So in college I learned C++ but I actually got my first job in Aerospace because I had taken a course on the Ada programming language and there was a need at this company for people who knew it. I was lucky that I had this in my back pocket because I had the misfortune to graduate right around the time the first dot com crash happened. So from having dreams of working on Web applications I started working on Flight control system software. That said I have been programming from a pretty young age. I was fortunate enough to have a Computer in my life since I was a kid. That computer was a commodore 128 and the best part about that computer was that when you powered it up, it immediately just put you into the Basic programming environment. So by the time I entered college, I had been programming for a while and I think what I had that many of my friends in college didn’t was a better understanding of how all the different pieces fit together that make a system work. I was familiar with version Control, with different Compilers for different languages, debugging, networking, troubleshooting etc. I can name you so many people who were great coders, who can describe to you in full mathematical detail p=np but couldn’t do the most basic of trouble shooting to see if you can ping another computer on the network. Everything else I picked up on the job and I’ve been with this company for almost 13 years now I’ve had the chance to bounce around doing development in C, C++ and recently Java hence I peruse this subreddit. 
Useful. Don't use defaults. It's a silly hack added for compatability and otherwise only exists to be abused. Consider it harmful. 
Abstract classes can have state, can override equals/hashCode/toString, and can have final or non-public methods, so there's still plenty of use cases for them that aren't covered by interfaces.
Free version = no line numbers in stack traces... seems a little bit strange?
Hm.. people skip this now and use Platform-as-a-Service solutions like OpenShift, Heroku, Google App Engine and Amazon AWS OpsWorks
Can you explain why you say that? I've heard it the other way around too, that classes should always be either interfaces ("I'm broken, fix me") or final ("I'm perfect, use me"). Therefore meaning that abstract classes with defaults are quite useless. 
I wouldn't recommend learning java as a first language. Go with something easy to pick up like groovy or python. You can learn the same basic concepts with far fewer headaches . Source : I make my living as a java developer
I'm sorry, I don't understand. Backwards compatibility with what?
Thanks for your comment. I will bring your thought to the next post.
I don't really like using abstract whatsoever - I know it's a bit extreme but composition almost always has worked out better for me
Interfaces with default methods are great for compositions I believe
They mention binary compatibility only. Default methods can still cause runtime error or compilation error (both happened to me).
As I mentioned the wonderful thing about the commodore was that it would dump you into basically the programming environment and you could just start typing basic. I think everyone has at one time or another done the basic stuff like 10 Print "Hello world" 20 goto 10 and watched the infinite loop happen. For me I was fortunate my dad was an Electrical Engineer so he also had some interest in programming and so he would get different kinds of books and magazines and some of them actually had programs you could sit there and type in. I learned a lot from that by seeing how changing those programs would affect the games. There were some games I got that were written in basic and I used them to make my own games. Really simple stuff like a variant of snake etc. I think it was just pure curiosity that drove me, the best part I liked was I didnt need any additional stuff, didn't need to buy parts or things to make something, i think thats what drew me to programming in the first place. So Ada is really a wonderful language. I went in with a negative attitude about it but when i started working in it and was involved in the flight control system software, I realized how amazing it is for these types of projects. Its incredibly easy to read and forces a programmer to write and spell out exactly what they are doing which is a God send when your maintaining and modifying existing code. The only real down side is that there isn't a lot of support for it or tons of existing libraries and frameworks so you can't do what a lot of programming today is about which is grab existing components and write the glue. Overall i highly recommend it and glad your university is still teaching it. 
&gt; "Otherwise, everyone would get it right" is a broad statement. Is swimming complex because there are so many people who can't swim? Since I am not native English speaker, I don't know how to translate this, but we have a saying along the lines of - it all sounds like playing with words. What do you want to prove? * That I don't know Spring Boot well enough? (true) * That project generation tool that does not generate working project according to my standards is actually good tool? * That my project standards are wrong? I look at this simple way - Spring Boot is a "product" and I am the "customer" shopping for easy project creation technology with very open mind. I tried it 3 times, read tutorials, even watched course on Pluralsight, but I am unhappy customer that won't use it and won't recommend it. From this perspective, IMHO, trying to prove that I was wrong somewhere just makes no sense. So I'll stick to my current easiest way to create new Spring MVC project: Open STS and generate Maven MVC project, close STS, open IDEA, change all versions in pom. &amp;nbsp; In short, Boot is not the tool I could rely on if I have only 5 minutes to ganerate Hello world project of any kind - REST, JSP. I was shopping for that! &amp;nbsp; P.S.: WebConfig contains only view resolver. I had selected "Web", although forgot to mentioned that. Regarding JSP - I did the same thing that worked before and the same thing that was recomended before by few sources which includes setting up /main/webapp/WEB-INF/ folder. 
Composition is all about inheriting contracts rather than behaviours. When you have a default implementation you are kind of weakening the strictness of that contract. That said though, I've never actually tried using defaults so it might actually be quite useful, considering statefulness isn't achievable.
Yet the interfaces added in Java 8 do use default methods for things other than backwards compatibility, like making optional methods in iterators or defining behavior that that can be specified in terms of other interface methods in functional interfaces.
Whats the name of the book?
There are dozens of patterns that defailt implementations wont account for, including anything that requires instance state. For all those saying "composition composition"... one of the best use of abstract classes I know of is paired with composition in the delegate pattern. The base class is there to delegate all method calls defined in the interface to a delegated instance. The delegating concrete classes inherit from the base class, initialize it with the delegate instance, and override whatever methods it needs to, w/o having to implement every method in the interface. So for example in pseudo java: interface X { int getInt1 int getInt2 } abstract Base implements X { private X delegated Base(X delegated) { this.delegated = delegated } int getInt1 { return delegated.getInt1 } int getInt2 { return delegated.getInt2 } } MyInt1Class extends Base { MyInt1Class(X delegated) { super(delegated) } int getInt1 { return 7 } } So in this example, MyInt1Class doesn't need to write the boilerplate that Base provides. Very helpful for larger interfaces.
Yeah, thats the first thing the tool adjusts. Increases the heap size.
Not quite accurate. [Here's](http://stackoverflow.com/questions/28681737/java-8-default-methods-as-traits-safe) Brian Goetz's (Java's chief architect) take. Excerpt: &gt; The proximate reason for adding default methods to interfaces was to support interface evolution, but we were well aware that we were going beyond that. Whether you consider that to be "interface evolution++" or "traits--" is a matter of personal interpretation.
"Head first Java" as /u/HanJammer posted.
These are very interesting thoughts - I have never thought about it this way. Deserves a blog post of its own...
Oh, I see. Basically, backwards compatibility with collection implementations.
What about when you want to make an abstract derived class descended from an abstract base? Usually as part of a abstract heirarchy.
I'm kind of curious to know what kind of problems supporting both systems would cause. For example, having the javac spit out reified generic information in its bytecode. After all, it isn't often that you as a programmer even need that information. If the java added a mirror based reflection system for when you want that information, you could then limit/eliminate the need for the refied information to be anything more than a "nice to have" rather than a need to have.
javac already does that wherever possible. If you have a field of type `List&lt;String&gt;` -- that information is there and available through reflection; if you have a method parameter of type `List&lt;String&gt;` -- that information is there and available through reflection; if you have a class `A` extending `List&lt;String&gt;` -- that information is there and available through reflection (that's how [type tokens](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/reflect/TypeToken.html) work). The only type information that's erased is if you have an *object* of type `List&lt;String&gt;`, because where would you write that type? If in the class, then `List&lt;String&gt;` would need to be a different class from, say, `List&lt;Integer&gt;`, and you have full blown reified generics (with baked-in variance, because the runtime would be required to decide on the inheritance relationship between the two classes). If on the object itself -- well, I'm sure everyone would agree that the slight added convenience isn't worth all that overhead.
Generics are reified and accessible on the method? So if I had public &lt;T&gt; void doThings(List&lt;T&gt; things) { } I could figure out what T is through reflection?
I think the opposite is true, personally. Java is my first language and I feel like it's helped me be far more verbose in going into things like Python. Static typing really helps you to appreciate dynamic typing when you use it; you also learn how to better manage memory when writing code.
I wonder what their reasoning for this is. This is not good for JavaFX adoption :(. Even if this third party company is maintaining and distributing their own version, it just looks bad. I wonder if they just lack the resources or what--it can't be that hard to create installables if they've already done it before. Weird decision on Oracle's part.
Why did this get down voted? I've worked with Shiro and I think it's awful in comparison to Spring Security.
if not flyway, liquibase certainly is older :) 
It's about damn time! Good job, Liberty team.
Thanks! Yeah it seems I'm gonna look up some libraries just to see what's out there. And I'm already trying to learn C# which is pretty cool too. 
You are misinformed. You certainly can use a Java EE Server if you choose. Or you can just include the parts you want in your application. If you just want CDI it is a single Jar file. The same with JSF.
Define "noisier"? There is no casting in the above code. Pass an Object or make the message an Interface. I don't find the dispatcher implementation easier to read, I find it more difficult. Here we are using language primitives instead of introducing a new class which you must infer its use. Not all of the projects I work on are able to target Java 8, mostly due to institutional inertia. Let me ask you this, under load, which do you think would perform better?
One advantage of OP's solution is that if designed properly one can enforce the definition of a fallback. In a sense the instanceof testing (and subsequent casting which you often will need to do) is a low-level implementation of pattern matching whereas OP's though clumsy it may seem to people who hate fluent APIs, is a more high-level solution. Then again in OOP one should avoid this kind of dispatch anyway and choose a Visitor By the way there is another way to solve this using a so-called Walkabout or Runabout, also reflective (and the latter fast) Visitor solutions. I would still say that OP's way (or something more advanced for data type decomposition) is nicer.
I like your solution (in fact I have also experimented with this before) but he is probably right about the performance. I may test it later. He does not need casting in the instance check cascade if he only works with Object types in the dispatch methods or if he casts there. But you are right that that is usually the case and expected.
Not true. I've said it before and I'll say it again. Want a good reason for default methods in Java? Look at the InputStream abstract class, and ponder on exactly why it was made an abstract class instead of an interface.
&gt; Also, if a user opens the code of an application created with WindowBuilder, will they know it was created with WindowBuilder? The code itself will not directly tell. However, there are hints that a builder was used. By default, WindowBuilder throws the whole GUI code into a single class. An experienced programmer will see that way that some form of Builder was used. GUIs designed without a builder usually split the code into separate classes (each of the panels used would be it's own class and so on) With careful use of the gui builder and some code workover the fact that a builder was used can be completely obscured.
I 100% agree! The article is from the spec lead of both "MVC" and JSF, so that guy probably knows. But still, the name is really really unfortunate!
WildFly is simply the beta version of the next EAP in a given branch ;)
Quite a number of Java EE servers are smaller than the size of a war with all those hundreds of Spring dependencies.
I think the main advantage of this approach vs the if-instanceof-then-else approach is it's more declarative - you're simply expressing the behaviour to take for each type and encapsulating the implementation details. It looks like the code has a few typos as it stands: * Missing constructor. * `cast` not defined. * Call to `match` should be prefixed with the class name - `ClassMatcher.match`. The `clazz` member is never used so that can be removed as far as I can see. Also it would be more efficient to construct the chain once and then re-use it, rather than construct it each time it's used. I don't think the class itself is a combinator, though the `with` method could be. Also, why is it doing a "monadic check" - I don't see a monad here?
Definitely not simpler.
I'm not attacking it or saying it is useless. I'm trying to understand the tradeoffs involved in these implementation choices, because it is not obvious to me. And the original article is light on explanation.
Cast isn't defined but should be easy enough to The constructor is missing, should've noted that it's being created with the Lombok annotation to make it an immutable data class. The clazz is used in the target matching, though I think you are right in that it can be safely removed since it closes over the target class at invocation As for combinator it's combining multiple callback chains into one function that is passed to the next object. This is exactly how combinators work (see parsec). For the monad it's applying a maybe style monad bind using the Boolean return to determine if it should continue the chain or not. All good points though, thanks for the feedback Edit: I cleaned up the class to explicitly show the constructor and remove the unused field. You don't need to qualify the match function with the class name because it can be statically imported
I co-wrote a textbook called Building Java Programs. Our web site has lots of resources you can look at: http://www.buildingjavaprograms.com/
This will not work... public class Dispatcher { public static void main(String[] args) { new Dispatcher().doStuff(); } void doStuff() { dispatch(new BarEvent()); dispatch(new FooEvent()); } void dispatch(Object o) { doEvent(o); } void doEvent(FooEvent event) { System.out.println("FooEvent"); } void doEvent(BarEvent event) { System.out.println("BarEvent"); } void doEvent(Object event) { System.out.println("Other event type"); } class FooEvent {} class BarEvent {} } Will print &gt;Other event type &gt;Other event type 
Exactly. The point is specifically dealing with covariant object types passed in from akka (or other runtime erased mechanisms). This is the same reason a visitor pattern won't work because you need to do casting on your object anyways (and conflate a simple dto with a traversable state)
Yes... of course that will work... but the point is that the starting point is public void onReceive(Object message){ Therefore I added dispatch(Object o) Pleae read http://stackoverflow.com/questions/19017258/static-vs-dynamic-binding-in-java why your code will not work 
&gt;&gt; The point is specifically dealing with covariant object types passed in from akka (or other runtime erased mechanisms). Ah. That's what I was missing. Not sure how the hell I missed the context, since the article's first paragraph states that clearly. Reading comprehension failure on my part -- sorry!
Slightly unrelated, but i really don't like when methods assume what to do if they don't find something. In this case, raising an exeption in the get() : public Person findStream(String email, Collection&lt;Person&gt; people) { return people.stream() .filter(person -&gt; email.equalsIgnoreCase(person.getEmail())) .findFirst().get(); } There are 2 problems: - It may be a perfectly valid scenario to NOT find an email in the collection, and using an exception to handle that is not a good thing. - This requires extensive documentation of the behaviour in the javadoc so users are not surprised. It's way better to return an optional and let the client code decide what to do.
It sucks that you can't easily extend stream pipelining and have to encapsulate default logic like this, since it would be nice to be able to put this filter in anywhere in a stream chain
I agree! I was mirroring the unchecked exception approach that JOOL does, to allow converting checked exceptions into unchecked exceptions in conjunction with the primary functional interfaces (such as Consumer, Supplier, etc.). I wanted to have a way to extend the Stream interface with a way to wrap it and re-throw the unchecked exception, and I have some abomination of code that could work, but it feels so unclean and likely to be error-filled that I all but abandoned the approach. I wish the Stream interface were just slightly improved and that decorating it was a little more approachable.
I fail to see how this improves anything. In fact: throwing a generic RuntimeException whenever data is not what you expect is a really bad idea. As soon as a user changes the data source to something you as a developer have not anticipated your application will simply terminate. How is that a good idea? And your fellow developer will hate you because neither is this exception declared to be thrown anywhere nor will the compiler force you to implement a try-catch-block. Or am I missing something here?
AFAIK, you can use JavaFX components *in* the NetBeans Platform. JavaFX is a GUI toolkit; the Netbeans platform isn't -- it uses Swing but also supports JavaFX. So, if you like everything NBP gives you -- plugin architecture with auto-update, project model, customizable actions, just use it *with* JavaFX.
I would argue that throwing a runtime exception whenever data is not what you expect is an excellent idea - the alternative, which is to carry on, will either lead to an error occurring later which will be difficult to trace to it's source, or the operation completing but with a potentially incorrect result. See http://en.wikipedia.org/wiki/Fail-fast Throwing a runtime exception does not necessarily mean the application will terminate, although that would still be better than a incorrect result. Most non-trivial applications will have an uncaught exception strategy, for instance server-side apps dealing with queues of requests will typically log the error and move the request to a hospital queue to be dealt with by the support team. You should definitely not be catching the specific exception thrown from the "only" method in order to implement logic to handle the various cases - this would mean that you know that there is the potential for zero/many results, in which case you should not be calling "only" to being with.
Yeah, I know, I even explored that route, but... it kinda feels a mixup I would like to avoid. Not to mention that Swing and JavaFX operates on two different threads, and all the problems that could arise are scaring me a bit...
Thanks for sharing. I wonder what the use case would be of having this. I can see the point in combining the test for uniqueness with the actual retrieval, but I wouldn't throw an exception there. You say it is for fail fast behavior. Fair enough, but why would you then even allow your collection to contain duplicates? Wouldn't a fail fast philosophy require you to provide a method "addUnique" or similar that checks for existence in the collections before adding? Of course this would be slower, but adding a bunch of things to a collection and then later retrieving the "only" element which may or may not cause an exception does not really seem fail-fast. More like "check later, then fail". I would personally prefer an Optional solution here, but Highlander provides that too, right? Anyway, nice little project. Optional or Exception, it seems useful, though I haven't encountered the use case before.
99% of the time, Maven works as expected. But that last 1% is a nightmare to figure out what's going wrong, why it's going wrong and how to fix it. With inflexibility should come a slew of debugging tools. It makes sense that a flexible system would be difficult to debug. It doesn't make sense to me that an inflexible system should be difficult to debug. &gt;Writing Maven plugins sucks, so you'll exhaust the possibilities of finding a standard way off doing something before writing a one-off everyone is going to have to live with for years. Or, more often, I just convince myself that what I think needs to be done doesn't actually need to be done.
It would be easier to help you if you told us what the actual task is.
The program is correct, 266333 is the correct answer. Edit: Explanation: - Sum of all multiples of 3 &lt;= 1000 + sum of all multiples of 5 &lt;= 1000 - = 3 * sum i from i=1 to 333 + 5 * sum i from i=1 to 199 - = 3 * (333*(333+1)/2) + 5 * (199*(199+1)/2) - = 3 * 55611 + 5 * 19900 - = 166833 + 99500 - = 266333
Thank you. Thought I was going crazy for a second when two websites told me the answer was 233168.
All I got to say is yay for gradle. I like gradle, I've done some complicated structures on it and I think it's easy to understand the build files and all customization has come out pretty clean and easy right in my gradle files.
Intro to Java 10th Edition is quite up to date. It is updated with JavaFX instead of old fashioned Swing. As I remember Oracle's book both have Swing and JavaFX examples. 
Interesting points. I think my poor examples confuse the issue - passing in a collection is only the simplest case, a more typical case is dealing with a stream of results produced by an external source. I would definitely favour preventing invalid data from entering the system, eg via a database constraint. However there are circumstances where this is not possible, for instance when reading from an untrusted external source or when the data is a result of complex and possibly buggy manipulations. Also, using "only" acts both as an assertion and documentation - maintainers of the code will know that the author meant that there should be only one element returned, not null, and not the first element if there are multiple. It's also part of a defence in depth approach, that is to say even if you trust your datasource you may be wrong or your assumption may be broken in future. Regarding Optional: "only" is to be used where there must be exactly one item. "optionalOnly" is to be used where there may be zero or one items, and the caller has provided logic to cater for the zero case (perhaps by providing a default value). But in both cases if there is more than one item this is an error, usually a bug in the data retrieval logic, which is why a runtime exception is thrown. If it's anticipated that more than one item is a legitimate case, then "only" or "optionalOnly" should not have been used in the first place. 
You have been told **twice** so far that this is neither /r/Javahelp, nor /r/learnjava. This sub is about **"News, Technical discussions, research papers and assorted things of interest related to the Java programming language"** You have your **third** warning now. Next similar post and you will be banned. BTW: Simple googling for **"Java aggregation and composition"** would have given you the following: + http://stackoverflow.com/questions/11881552/implementation-difference-between-aggregation-and-composition-in-java + http://stackoverflow.com/questions/734891/aggregation-versus-composition + http://www.codeproject.com/Articles/330447/Understanding-Association-Aggregation-and-Composit + http://javapapers.com/oops/association-aggregation-composition-abstraction-generalization-realization-dependency/ Learn to google, learn to read documentation. They are invaluable skills for each and every programmer. **Post removed:** wrong subreddit (repeated offence). 
I agree with driv338 here. Many s/w be it front-end or backend stuff use this method. For eg. Insightly.com is a CRM that is useful with many features. They offer a completely free version of it. According to their website it "allows up to 2 users, up to 2500 records and up to 200 MB storage" and according to their claim - "is perfect for small business". I agree. But I am currently working temp for a small business here and the owner / manager - once he heard of this says: a) free? is it dependable ? what is the catch AND b) of the 2 user limit - it is NOT enough, we'l buy if it is proven useful. This coming from a man who is normally frugal wherever possible :) The 2 user limit was a definite issue for him, he being a not techie person. For me - it was the "2500 records and up to 200 MB storage". Dele - I am sure with the knowhow of the internals, you can enforce some limits without restricting users / potential "paying customers" from exploring everything.
I've been doing Java for nearly three years and if someone put me on the spot about checked vs unchecked exceptions I will still mix them up!
This misses the key concept behind check vs unchecked: &gt;[Here's the bottom line guideline: If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.](http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html)
That isn't a key concept of exceptions. That's a beginner guideline for using them, in the articles own word. What is the definition of "recover". Is that limiting a service? The code you're writing (ie framework code) usually does not even have the responsibiltiy of making that decision. Your quote there is an introductory guideline, but it isn't that simple unfortunately in larger real world projects. Let's look at application in the JDK. Do you think an application can't recover from Integer.valueOf? Uh oh, your guideline is falling apart. Not so simple, is it?
By using either "only" or "optionalOnly", the developer is asserting/documenting that "I expect this iterable/array/stream to contain at most one element. If there is more than one element, that is an unanticipated situation/bug, and processing should abort". I'm not sure Scala's try would be of any use here, since we would not want to use "only" or "optionalOnly" where more than one element *is* an anticipated and supported situation.
Right. There would be multiple implementations of X in this system.
&gt;If you're designing a framework or Api it isn't your job to make that decision (can the user of my framework recover from this failure) and thus that definition rapidly starts falling apart That's more of an argument against checked exceptions in general. My point is about the distinction and reasoning behind having both checked and unchecked. In that context any article about checked vs unchecked that doesn't mention the concept of "recoverability" is incomplete. When you declare a method as throwing a checked exception, you are making an assumption that the client is in a position to do something about this exception and you are *forcing* them to deal with it. How they deal with it is not up to you (they could ignore it, or rethrow it as unchecked, or whatever). That's what is meant by "recover" in this context. The client has to do *something* to handle this exception. 
&gt;Throwing a checked exception is a means of delegating the decision of "can I recover from this" to the user. Throwing *any* exception is a means of delegating that decision. &gt;They aren't forced to do anything with it, just accept that it exists. Yes, they are! Their code won't compile unless they do something about checked exceptions. &gt;The only time an API should throw an unchecked exception is if it knows for sure that they cannot they cannot what?
&gt;Throwing any exception is a means of delegating that decision. That isn't entirely true. Throwing a runtime exception is associated with a default behavior if they're not acknowledged. Which is fine if it is due to a programmer error. &gt;Yes, they are! Their code won't compile unless they do something about checked exceptions. There is a difference in doing something with it and acknowledging it. You can write an empty catch clause, and you can rethrow checked exceptions. That is simply acknowledging their existence.
&gt; They may also fail to understand one of the core abilities of an Exception [wrapping.] This kind of wrapping didn't exist when Java first came out. It didn't even enter as a Throwable constructor until version 1.4, about 3+ years after J2EE was out and people were getting annoyed with 50+ levels deep exception stack traces with the original cause long lost behind a CORBA/RMI serialization wall. It's a bit rich now to claim that wrapping was part of the "core" of the Exception philosophy. 
What happens when an unchecked exception isn't caught? That is not a decision the user of your implementation makes and it isn't a decision that you make. It just crashes and its up in the air for the jvm. The decision is delegated to your runtime. Ie, default behavior for unacknowledged runtime exceptions. I personally don't define doing something with an exception to any meaningful extent if its just wrapping them in a runtime exception and begging the application to crash (unless god forbid you're catching runtime exceptions somewhere.)
&gt;What happens when an unchecked exception isn't caught? That is not a decision the user of your implementation makes and it isn't a decision that you make. It just crashes and its up in the air for the jvm. The decision is delegated to your runtime. How does that contradict what I said? "Throwing any exception is a means of delegating that decision." &gt;I personally don't define doing something with an exception to any meaningful extent if its just wrapping them in a runtime exception You're welcome to your personal definition of words. However, I stand by my initial comment.
&gt; How does that contradict what I said? "Throwing any exception is a means of delegating that decision." You said you didn't understand what I meant, so I clarified. Yes, but defaulting the delegation to something that always crashes your entire application is something that should be done when explicitly stated or when it is due to programming error. Hence checked exceptions.
+ Adhere to commonly used coding standards as set by Oracle, Eclipse, or Google. All major IDEs can format code according to the standards. + Use "speaking" (i.e. self explanatory) names (variables, classes, and methods). + Use constants (static final variables) instead of "Magic numbers". Whenever a number has a special meaning other than a simple counter, create a constant that explains the meaning of the number and use only the constant. + Use comments to explain *why* something was coded in a certain way, not to explain *how* something was coded, or what the code does. + Use *JavaDoc* to document your code.
In Java 8, using [protonpack](http://github.com/poetix/protonpack): assertThat(Stream.of(1, 2, 3).filter(i -&gt; i &gt; 3).collect(unique()), equalTo(Optional.empty())); assertThat(Stream.of(1, 2, 3).filter(i -&gt; i &gt; 2).collect(unique()), equalTo(Optional.of(3))); // Throws NonUniqueValueException Stream.of(1, 2, 3).filter(i -&gt; i &gt; 1).collect(unique());
But you *are* making the decision when you make the exception checked... With a checked exception, you're leveraging the compiler to *force* the client to do something about the exception (your definition of "something" not withstanding). With an unchecked exception, the client is free to do something about the exception or not.
- Clean object-oriented design patterns. All kinds of things can be objects that you don't think of because Java makes it seem like such a big deal to write classes. Coming from a scripting language like Ruby, it is much easier to spot refactoring opportunities. Read a book on design patterns. - Use functional conventions when writing methods. Never return null; always try to return a value or an object. Never write side effects. Never write methods that mutate their arguments; copy if you have to change. Java can make copying "feel" expensive because object allocation and class definition is so verbose, when it really is not. If you still can't get around it, or copying would be way too heavy, make sure the mutating is really explicit and obvious to an idiot. - Favor composition over inheritance. Inheritance should always be considered suspect, as it splits behavior of one object between multiple files, making it harder to see and debug. Inheritance is definitely useful, but the uses are more limited than people new to OOP usually think. If you want to create a fancier version of an object, wrap it - don't extend it. - Single Responsibility Principle. Every class and method should do only one thing, and do it well. This is a particularly "doable" habit to adopt that will work wonders for your code. Writing tests will force you to work this way as well, so learn to write tests. - Avoid highly static classes, unless they would normally be singletons, or contain primarily simple utility methods like squishing Strings. - Don't use XML, jesus christ old Java web frameworks are like the dark ages where everyone was working on finding new ways for web development to suck. Also JSP and JSTL are so absurdly awful I wonder if they are supposed to be a joke sometimes.
That's just a really awkward and confusing way of saying the same thing...
First off, read `Effective Java`, it's for an old Java version but still entirely relevant for someone who has a little experience with Java and wants to take it further and improve. * less abuse of inheritance ("favor composition") * consistent formatting, match the file you're in. Ideally you'd follow a standard so the project is the same, but that doesn't always happen (as silly as it is) * enum/const usage * docs! My work is awful about that and we are building a monolith, unfortunately. * intelligent exception usage, declaring "throws Exception" drives me nuts * type safety. Much of the code base in my work passes "Object" around... What's the freaking point? We may as well write our server in Node so the front end people can do silly stuff too.
- Styling should be consistent with the rest of the project and should follow appropriate standards for the language. - Don't overuse whitespace (I'm thinking of a recent code review where a fellow programmer had spaces and tabs AFTER each line of code). - No magic strings or magic numbers - Keep methods small and testable - Try to keep things generic and re-use existing code - Use comments intelligently. Don't over comment, don't under comment. 
I hope you're not the same kind of guy that deals with exceptions by doing this. try { someMethod(); } catch(Exception e){ e.printStackTrace(); } Or the infinitely worse: try { someMethod(); } catch(Exception e){ }
At the start of the method? Declare variables as early as you can! Why clutter your methods when you can just declare them all at the top of your class. 
Naming conventions. I hate seeing methods like "int SomeInt = 1". Proper casing, please!
Make classes immutable unless it's necessary for their state to change post construction. In general actually use final wherever possible (that goes for classes too).
some off the top of my head... * adding javadoc to any public or non-trivial code * keeping methods small (&lt; 15 LoC ideally) * avoiding calling inherited methods in derived classes * minimizing state kept in classes and object instances * using primitives whenever objects aren't necessary * using `static` and `final` as much as possible * copying function arguments and using copies by default * favoring composition over inheritance * factoring code that doesn't depend on object state or strictly uses public methods into a separate classes * not using exceptions to convey or encode state * generally minimizing scope for things
Something like this: https://play.google.com/store/apps/details?id=com.aor.droidedit.pro ?
Get a fucking computer. No real developer programs on a damn phone
Small methods that do small things. Other methods that leverage small methods. The number one biggest complaint I have with shitty code is large methods that do too much and are too hard to read, test, and reuse. It's a sign of an amateur 
A magic number is an arbitrary number inline with code. Using a constant makes the number's meaning clear. Compare: for(int i=0; i&lt;52; i++) { .... } with for(int i=0; i&lt;CARDS_IN_PACK; i++) { .... } In the first case, it _might_ be the number of cards in a pack, or it could be the number of weeks in a year. Who knows. Second case, it's obvious.
* All work must be represented by a ticket * Design your tickets and get a review before you start coding. * Write tests * Get all code reviewed before it is pushed to the main branch * Adhere to same indentation style for entire project 
Had a coworker who thought $_ was a perfectly good variable name. He doesn't work with us any longer. Luckily he never did much either so it was easy to get rid of the mess. 
One simple thing anyone can do to improve, not only the readability but the quality of, their code is to use a tool like [SonarQube](http://sonarqube.org)
Most of the comments address the point. However, I've started focusing on longevity of the code base /project. So some points from that perspective : 1. Don't write code - somebody said "the only bug free code is the code you don't write". Minimize ruthlessly. Earlier I used to feel good after writing some especially neat piece of code. Now I get the same rush deleting large chunks of my code :) 2. Write tests: others who have the misfortune of reading your code later (including your future self) will thank you for it. If you hope others to contribute, tests are the only thing that'll help you 3. Write good tests : what's worse than no tests? Bad tests. Tests should be simple to read, convey intent and trivial to reason about. Test the interface so that you don't end up with brittle tests. 4. Don't stress over code coverage 5. Document the high level flow /abstractions somewhere. Once again, your future self will thank you for it. Again, this doesn't address the Op's question directly. 
One word (or rather one acronym): SOLID
no singletons. no object hierarchies matching product hierarchies (generally). terminate fn as early as possible. more than 2 joined params use an object... hust off top of my head.
I don't understand the hatred of tabs. They work exactly as they should. You set the tab width and the left side of everything falls into nice columns. Obviously if you're making two different lines try to line up on a specific character you're doing it wrong. Space alignment just makes me facepalm.
final methods make me cry.
Point 1 — YES! If it's not in JIRA, we're not doing it.
Maybe if you change *number* and *sum* to **double**, and use the *nextDouble()* method instead of *nextInt()*, you should get what you're after - which is 53.5 
&gt; Use "speaking" (i.e. self explanatory) names (variables, classes, and methods). As someone coming from a math/physics background but trying to get into a professional development position, I cannot say how poorly every class I had emphasized this at my university. Variables just named things like x, z, y were the rule, and I was actually told things like "That variable name is super long to type multiple times." It has been maddening having to take advice from people that clearly never worked in industry. Ugh, just thinking about this and other things makes me so glad to be nearly done with school. Edit: Just to be clear, I meant classes where we specifically had to program (usually in Matlab or Mathematica...just shoot me). I wasn't referring to lectures, where obviously you just use variables such as x, y, and z when working with equations and what not.
Would you be able to elaborate on the the last point with XML please. I'm fairly new to the language and have been writing various projects to get familiar with the language and was considering tackling XML soon. Do you have recommendations for something better I should study? Thanks!
Do you know of any good resources for learning to create javadocs?
We have banned tabs at work. Spaces all the way.
avoid literals
That's exactly why I find tabs work great. I don't have to accept 2 space indentation, I can use 8 or whatever and the left side aligns perfectly (assuming you don't line break at 80 characters or something dumb).
Terrific example, will remember that one!
Generally agree, except for no wildcard imports - I think they are neater than explicitly importing 20 random class names from each package. Also not sure what you mean by overuse of static methods - you shouldn't force something to be object orientated just because you can. In fact when rapid prototyping I tend to use a lot of static methods and only once I see the recurring patterns do I start to push things into encapsulated classes.
Try not to mix changes for different issues in the same commits.
Or you could declare an interface with the single method you wanted, and then require the user to subclass it in some way.
They really shouldn't. If it's final, it's clear that it wasn't designed for inheritance and therefore overriding it would be a big mistake. Make all your public methods final by default, and design for inheritance explicitly by giving a set of non-final methods to override (and of course try to avoid inheritance as much as possible).
Mostly this and anonymous objects: final Thread callback = new Thread(new Runnable() { @Override public void run() { System.out.println("Hello more_exercise"); } });
Exactly!
Well, since Xtend is transpiled into plain Java, you won't have any additional runtime dependencies (as Scala would have). Say you're developing an android app and try to keep your apk as small as possible, are you really willing to add &gt; 20 MB of scala deps?
oh man, i could write a book on this. for now, i think the single most valuable thing that's helped the look of my code is constructor injection with picocontainer. it means i don't have to write any (typically quite messy) code to wire things together, i can concentrate on code that actually does stuff. you can use guice if you want, but i find it needlessly complicated.
&gt; Comments can really muck up your code. I try not to use them. i actually agree with this - often i'm writing a comment and then realise i can say the same thing by renaming some methods/variables. it's more concise, and more valuable as some colleagues don't read the comments anyway.
I don't think that this is so great. The code is longer than before and it's just using Java 8's fancy streams for the sake of it. Edit: removed stupid code example that didn't work All this notion of using functional programming in Java just for the sake of it is bad and leads to bad code. Use the right stuff at the right time. This is not the time for it. Optional can be a great tool when it is being used correctly. The example in the blog post, however, is just silly. 
Going against many common coding standards, use spaces to line things up: public static final int ARMSMASTER = 100; public static final int BARBARIAN = 80; public static final int COMMANDO = 60; public static final int DRAGOON = 40; public static final int ESCORT = 20;
Honest question: Why not JSF?
Looks good!
Can't stand that
Most IDEs have some good custom rules built-in for writing good code and you cna also use tools like FindBug and PMD to improve your code style.
I fully agree with you. I really don't see any advantage of spaces over tabs. At least with tabs people can choose how big the indentation is.
Not to mention Handlers
Can't help you, but here are other subreddits where this should have success: /r/javahelp /r/learnjava /r/learnprogramming
Red/Blue eagle? Rly? 
Hah, the project I'm working on relies on a product which has xml configuration that looks like this: &lt;StartConfig [everything in attributes here] /&gt; &lt;startParam x /&gt; ... &lt;endParam x /&gt; ... &lt;EndConfig /&gt; I want to cry every time I have to edit those files or look for a bug there.
Along the KISS line, avoid reflection unless you absolutely need it (you probably don't).
Your proposed solution doesn't even work. It throws NPE when some token in the nested path is null.
Not if you specify the arguments in the right order.
1. Keep it simple 2. Documentation - the more the better! Each method should have at least few description of what it does and how to use it. 3. Not to use complex features of the language when its not **really** needed. For example C++ operator overloading, abusing virtual classes, overriding methods somewhere in the middle of code, using lambda just for fun. Some of those techniques are common but they can often be described as "hacks" - as its hard for not perfect programmer to understand such code... 4. Simple classes/methods/functions, with clear documented role.
You think that's bad...? Oh I've seen a lot worse including things like non-standard XML that was written to conform to a parser written 16-17 years ago in C because the XML specification hadn't yet been ratified at the time. Still in production by the way and completely non-fixable at this point because it's built into customer's field products. 
Congratulations for ignoring: + the **big red button** saying **"Seek Programming Help"** + the **big red banner** when **hovering** over the **"Submit Text"** Button, saying **"Please seek help with programming in /r/Javahelp"** + the **big red box** in the **sidebar** saying **"Please seek help with programming in /r/Javahelp"** + the **"?"** icon in the **blue "Related Sub-Reddits"** box in the **sidebar** with the text **"Java Help ← Seek help here"** **Post removed** wrong subreddit. 
Congratulations for ignoring: + the **big red button** saying **"Seek Programming Help"** + the **big red banner** when **hovering** over the **"Submit Text"** Button, saying **"Please seek help with programming in /r/Javahelp"** + the **big red box** in the **sidebar** saying **"Please seek help with programming in /r/Javahelp"** + the **"?"** icon in the **blue "Related Sub-Reddits"** box in the **sidebar** with the text **"Java Help ← Seek help here"** **Post removed** wrong subreddit. **Also:** for future, please mark crossposts as such to avoid duplicate help.
The order doesn't matter. Your code doesn't work.
of course you can, and i actually did, but it's not the same as having it directly in the stream. You can't have it in the middle and it won't take advantages of parallel streams, for example. It would be nice to be able to define new stream operations.
What a very condescending way to tell folks they didn't get it right posting in this subreddit. 
&gt; Tabs are awesome to allow different people their own preferred indentation width. They are only ever a problem when you mix tabs and spaces in the same file. Every IDE I have used has had the ability to remap the tab character to any number of spaces, even on pasted code.
I'm so bad about this... &gt; Ah, almost done with issue 57! But hey look, someone just opened issue 58, which is caused by this line right here! Well I'll just fix that, then finish 57 and commit! Oh wait there's a new ... My commit ends up being "Fix #57, 58, 60, 61; add #59,62"
&gt; Hello **former** coworker! I can see why.
Well, let's put it that way: There are more than enough hints that should have directed you to the right sub. The current text is the standard reply to all people ignoring those hints in hope they understand the "hammer method". All the hints are more than prominent which should actually suffice. 
The line I wrote - just add it before the print statement. 
May be somebody already said so, but my personal experience is that coding practices are conveniently considered separate from logging. Please consider what the log file might look like when you add log. 'RC=ffaab7' is not useful to me as INFO log.
Well, I appreciate the response.
Try running it through PMD
I think they meant how to create Java docs from their code.
Final is considered best practice for parameters and variables, mutability is to be avoided when possible.
No. Reflection is too slow for that. You used polymorphism, as you do now, except that you created the (usually anonymous) callback classes explicitly, instead of using the shorter lambda syntax to have them generated.
"delegating it to the user" = "force the client to do something about the exception" delegating it to the runtime = "client is free to do something about the exception or not" I'm saying thinking in terms of this "delegation model" is awkward and confusing. 
You're absolutely right. How could I miss that? I'll update the post accordingly. Thanks for pointing that out.
Never mind. :)
Oh yeah absolutely, I am being a little hyperbolic. But I don't think staying pure in my current app has really affected the number of allocations because it is mainly string manipulation at the end of the day. It depends what you are doing.
I don't like the view first approach of JSF. I can still technically use it as just a view engine the same way I do JSPs and tiles but it doesn't work very well in practice. If there was a way to use facelets more sanely with an action oriented MVC pattern I would do so in a heartbeat.
Up vote for you because of this: &gt; it's just using Java 8's fancy streams for the sake of it And [this](http://www.reddit.com/r/java/comments/2x47wy/java_8_code_style/) is my reasoning. Abusing the functional Java 8 stuff for "just because" can lead to ugly code. /u/winterbe
I agree that abusing streams can lead to ugly code which is painful to read and hard to debug. However in many cases replacing arbitrary foreach blocks with unified stream operations improve code readability. The great part about streams is that you usually don't have to read the whole code in order to get a clue what the code actually does. Often it's sufficient to just look at what stream operations are being used. E.g. a filter - sort - map - collect stream is trivial to read while the traditional foreach solution usually is extremely cumbersome and looks a bit different every time.
Yes, if you use JSP 2.0 tagfiles it's really easy. Stash your tags in WEB-INF and use a declaration like this &gt; &lt;%@ taglib prefix="tags" tagdir="/WEB-INF/tags" %&gt; I still write TLD files out of habit, but they aren't necessary. 
True, but when you are writing tests it gets exponentially more complicated to cover all the code paths on a complicated method. I feel like experiencing this frustration would be good for anyone. :)
&gt; They are only ever a problem when you mix tabs and spaces in the same file. Which _always_ happens at some point.
When practical, write your code to solve the general problem, not the specific instance of it that is in front of you. A short method is a happy method. For trivial code, _do_ repeat yourself. The benefits of code reuse in such cases are small, and are quickly gobbled up by issues of library and dependency management and less "intimate" code. _Date_ "ToDo" comments in your code. Write your code with idioms. *Festina lente.* Take your time to do it right the first time and you won't need the time to do it over.
I understand your point and am all for a fail-fast strategy. I just think it doesn't improve anything in the sense that this has to be used with great care by developers so that it won't be used as a one-stop solution without thinking about the implications. I'd also argue it would be far more important to use a data structure that doesn't allow these cases if your application can't handle it.
Makes sense. So lambda expressions basically get rid of that extra tedium then?
&gt; Also agreed Tiles is definitely mandatory, but quite a pain with the XML crap (unless my info is outdated, which would be nice). Unfortunately the XML is still mandatory, although with the use of wildcards you can significantly minimize the amount that is necessary. It'd be nice if you could avoid it entirely, but since tiles handles the request before it starts rendering your JSP's I can't really think of a better way to handle it (I mean, could just add to the annotation soup, but I don't really think that would work well for tiles). &gt; and it should definitely not execute a bunch of Java code You could make the same argument about partial views any any other template engine. I avoid this trap by limiting myself to a small amount of JSTL tags where some logic is unfortunately needed in my templates, and using tagfiles for my own components (which end up just being HTML). I can understand not liking things like c:if, but I much prefer them to having some wildly different syntax just for flow control and logic. Then again, I also like XSLT, so I may be a little nuts.
Ah, that's good to know. JSP remains the better solution for quick web sites.
And this is how you get unmaintainable spaghetti code. The way you prevent spaghetti is that when you deal with something external, you do so through an explicitly defined contract. By overriding a public method, you're changing the implementation of an external object, in the process making implicit assumptions about how it works internally. The moment you do that is the moment your codebase becomes unmaintainable, since any internal change can now potentially break any number of subclasses. I'm not sure what you're referring to with "final and mocking objects for tests". The way our codebase is structured, is that every object takes its dependencies in the constructor (as interfaces). In tests you simply pass mocked dependencies to the constructor.
My teacher, throughout high school, could not emphasize enough how important variable names were. I didn't take him seriously for the longest time, same with classes and planning things out. It took one really large project for me to get my shit together. Naming your variables is a minor annoyance that in the long run is something so simple you could have, and should have, done to make your life ten times easier and your work ten times faster.
I usually go by "Use what works best for the task", so if it makes sense to be immutable make it so, if it makes sense to be mutable do that, otherwise treat each component individually. My average class has a good mix of final and nonfinal fields, getters/setters and public fields, static methods and instance methods, etc. I don't force my code to conform to any one style unless it makes sense that way.
Exactly that. The better the design and engineering is, the shorter and easier is the programming. Fact is that in my line of business, you mostly get one attempt testing. If that one fails, there is either some major equipment damage, outages, or danger to lives. So, we spend great deals of effort and time to get the design right from the beginning thus avoiding errors and danger. I really wish that the "normal" software industry would also follow that standards...
&gt; So does that mean Java application servers are dead? No. There will be cases when using docker/spring-boot/whatever else will make sense and will be better. There will be cases when using an application server will be better. There are good reasons to use an app server, as there are good reasons to use docker&amp;friends. Questions like then one you just asked makes me seriously doubt your competence and ability to make an informed decision when choosing a/the platform to base your next application.
rather than implementing serialization manually, use a decent fast standard serialization such as https://github.com/RuedigerMoeller/fast-serialization. It will outperform Externalizable for most cases.
There might even be cases where docker containers contain preconfigured java application server based stacks. 
True, but in android you can scope them better than this demonstrates. Specifically, get a specific view (say button1) and add an event lister directly to it only responding to the particular things you care about (e.g. OnClickListener has both long press and short press separately). Verses what's demonstrated here is listen for all events and find out where they belong. The awful check the ID of the thing seem to be fairly limited (in my limited experience, action bar menus are the only place I see the really poorly scoped things like this).
Thanks for replying on my account. I was really busy today, so I couldn't do it myself. Excellent reply! I was actually thinking about something as boring and mundane as INCHES_TO_CENTIMETRES. You beat my with your originality!
You don't. Use [WebSocket](http://en.wikipedia.org/wiki/WebSocket). Here's an example: http://blog.databasepatterns.com/2014/04/postgresql-nofify-websocket-spring-mvc.html
I think that actually [How to Write Doc Comments for the Javadoc Tool from Oracle](http://www.oracle.com/technetwork/articles/java/index-137868.html) is a very good resource for starters. The source of the SDK is a good resource to see how well-written Javadoc is done.
Can you please explain the benefits of using a WebSocket vs. a cache?
Yup. I did this comsci problem a few weeks ago and unnecessarily made a 2D array to store letters I would print later. This caused a lot of out of bounds problems and weirdness. All I had to do was print using a nested for loop and a cascading if else inside... I would have saved 50 lines and had much fewer problems. Think simple is great advice 
I don't think the long-poll would suit me well seeing that I the browser has to be updated every 5 seconds
When you start doing a project, you will find libraries after research or looking through similar github projects. For me I found slick2d doing a game project and found sikulix when looking for a way to do screen detection for a runescape bot.
Answers like yours make me doubt your maturity level, alonjit. Dismissing an entire article because you don't like (or get) a one-sentence literary device makes you sound petty and intellectually-fradulent. That you got a few asshats to upvote your bullshit comment signifies everything that's wrong with reddit developer forums.
But I am, and /u/TheHorribleTruth is right. Watch your language. Post removed. Wrong sub. More street lingo = ban.
He might not be a mod, but he is right. This is NOT the correct sub to ask your question.
Just read up on WebSockets and it does seem like the tool that I should use. Is there any specific framework I should use to prevent myself from reinventing the wheel? 
They are fairly similar languages, and while it's a good one to know if you're in the MS-osphere, you may want to pick up something a little bit different if you have the time for it, depending on your interests there are lots of options.
Oh, alright. Noted. Also, I currently have a Struts2 web application. Would creating the WebSocket inside the Struts2 project work fine? Or would it be best if I created a separate WebSocket web service? I'm not really concerned about traffic because, at most, the web application will be used by around 10 people simultaneously.
I know almost nothing about docker, but what's the alternative to application servers? Do people run an embeddable server like jetty instead?
He was being petty and intellectually fraudulent. It's not immature to call that out. You could ding me on the word "asshat" but sometimes a little vulgarity gets the point across and sometimes one needs to communicate in the parlance of the people to connect. But hey, if you thought he had a fair criticism of the author what more can I do? I stand by my comment. 
Yup. That's what we do. If you just need a few features of an app server easy to just embed it (if you are just running a rest server or something)
It's unfortunate you can't see insulting the author as incompetent by taking one phrase out of context and ignoring the actual content is dishonest. You've made it clear you're ever so upset at how I chided the author of the comment but I'm satisfied that at least some of my point made it past your indignation. My guess is that you'll be thinking about the low level of top-voted comments for a while regardless of what you think of me. Mission Accomplished. 
&gt; Don't use XML I generally agree, but I've found that the IDE support for XML files tends to be very good, especially if there is a proper schema defined. It'll flag errors and allow autocomplete of element/attribute names, for example.
I'd start w a SaaS solution like pusher.com or similar
take a peek at Atmosphere
Preach it, brother.
They are completely unrelated things. You put the data in a cache once you get it over a websocket or via ajax. websocket is push, ajax is pull. If you want data when it's updated you want push, if you want to waste bandwidth on a bunch of empty responses and bog down your server you want pull + polling.
Application server in a Docker may make sense for development purposes. Zero configuration, platform agnostic, and you're on the same stack as what's eventually going to production. It can be a cleaner alternative to a full build chain from checkout... especially useful if outside teams need to use your component or you want to test something on a tagged release (assuming a docker container was also built against the release). Obviously those benefits go out the door if you're actively developing on the server itself, since you need to rebuild the docker image after any change has been made. The same use cases could be fulfilled with vagrant.
So, if ever I create my own WebSocket server, would you still recommend that I use a cache? What I'm planning is to create a WebSocket server that would be responsible for interacting with the database every 20 seconds and keep all this data in some Collection (HashTable?) so that every client could just retrieve/pull the data from the WebSocket server when I want to. I'm really not sure if this is how it should work though. I'm still a bit confused on how it should work altogether.
That was awesome !
 else if(desiredFib &lt; lastFib){ Shouldn't that condition in line 25 be &lt;= not &lt;? Currently if you call it twice with same index the memoization doesn't trigger. Also after the change it wouldn't still be perfect as if you call 5000 1 5000 it would still calculate second 5000. Actually that whole thing would break...
hahha cool!
Deleting again, this has already been on reddit...
Spring boot is just a pre configured embedded tomcat/jetty/undertow. But totally agree... If it's working fine don't break it
I'm currently creating a database and statistics system for the video game tournaments my friends and I run quarterly. If you do it for something that you actually find interest in, I find that it keeps you interested and motivated. Plus you then have your friends, that will become your clients and end users so you can spend time gathering requirements, doing designs and mock ups etc - can really get a feel for the whole project lifeccyle 
~~There is a GIGANTIC banner on the top of your screen about /r/javahelp when you try to submit a text post. There is a sidebar mention. There is a text when you try to submiit. How many ****ing hints do you need?~~ ~~Sorry for rant. But you'll get more help over there.~~ Aaand I snapped too early.
Oh. I snapped a bit early then, sorry. Guess it fits under technical discussion then. You may want to ask over at stackoverflow, too. The folks over there might be a bit more experienced when it comes to the actual architecture.
It was driven by the combination of two different things: 1) a desire to do pretty xterm behavior without resorting to (n)curses, and 2) a network appliance somewhat like a mashup of Mystic BBS+rtorrent that would need a usable mini-UI for telnet/ssh connections. As I thought through the uses cases for the ssh console I kept coming back to progress bars, text fields, a menu bar, windows, etc., so Turbo Vision came to mind. The "real" Turbo Vision unfortunately is license-muddled (at least Debian thinks so and they will never include it) and any derivatives will also be hampered, so if I wanted something that looked like it I would have to write it new. So now that it's here, I have a perverse desire to get an HTML5 backend running, perhaps with [Webswing](http://webswing.org/). :) 
Looks like Norwegians will go a long way to make a joke.
I can understand the usefulness of Docker to Python/Ruby apps, that rely a lot on the OS and the environment. How useful is Docker for JVM software?
This `Optional` madness has to stop. Java 8 does have a new mechanism for enforcing null-safety, and it isn't `Optional` (which is intended for streams only), but the newly added [pluggable type systems](http://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html), and, in particular, the [nullness checker](http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#nullness-checker).
Because it's based on UNIX. http://en.m.wikipedia.org/wiki/OS_X
Non-mobile: [http://en.wikipedia.org/wiki/OS_X](http://en.wikipedia.org/wiki/OS_X) ^That's ^why ^I'm ^here, ^I ^don't ^judge ^you. ^PM ^/u/xl0 ^if ^I'm ^causing ^any ^trouble. [^WUT?](https://github.com/xl0/LittleHelperRobot/wiki/What's-this-all-about%3F)
But they're a .NET (Windows) house, so he should have a PC to fit with the story. 
It's personal preference /thread That being said, give IntelliJ a shot. I was a former Eclipse user, and was hesitant to jump ship to a new IDE. It's taken a bit over a month to feel comfortable using. The biggest advantage for me, is how much more hotkey centric IntelliJ feels.
IntelliJ hands down, just try it, there is nothing more to say.
https://www.jetbrains.com/idea/features/editions_comparison_matrix.html
"Mona Lisa Harddrive" made me spilling my coffee the first time I saw that video ;) EDIT: Reference, if needed: http://en.wikipedia.org/wiki/Mona_Lisa_Overdrive
&gt;If you put all your services (deployment units) into the same JVM; then if you need to upgrade one of those services you have to take down the JVM which can affect all the other services. So its less risky and more agile to deploy each service in a different JVM process so you can upgrade any service at any point in time without affecting any of the other services. Not necessarily. Although the author then goes on to mention optional solutions such as JRebel's Zero Turnaround there are also application servers that can update individual services/applications at runtime without necessarily needing to restart any of the other running modules in the JVM. Some of the advantages of docker such as easy, rapid deployment are great to have but others can be solved within the Java EE runtime itself, without needing at add extra layers around it (only loading the resources you need to keep memory usage low, updating applications rapidly without impacting other deployed applications are a couple of points the EE runtime itself could do). That's not to say that docker isn't necessary - it really helps in some circumstances but let's not say that Java EE app servers are these brittle things that need to be restarted to update anything when that's not the case with all of them.
While it really is a matter of taste, and no one wants to change the IDE he's been using 3 years... I will leave here the main reason why I think IntelliJ IDEA is faaaar more usefull: [Evaluate expression](http://blog.jetbrains.com/idea/2009/09/debugger-evaluate-expression-enhancements/) Why? Ever had doubts about an XPath expresion, or which method of a PDFObject returns the text, or if you have to add +1 or not to the result of .indexof()? Try and try and try while your program is paused in debug, using the scope at the breakpoint, and evaluate until you get the right code line(or lines), and then paste in your code.
Thanks. Nothing I need in ultimate edition so. And I remotely debug tomcat all day via free version (page indicates that not in free version)
As others have said try it and see which you prefer - I have used Eclipse for years and gave IntelliJ a try and really didn't like it (I minimized a couple of UI elements and never found them again, so it is different to Eclipse in that sense at least), but my colleague tried it and loves IntelliJ - it's really down to personal preference.
Ah that brings back memories. It's similar to [Lanterna](https://code.google.com/p/lanterna/).
"Despite being known as the Java Desktop System, it is not actually written in Java"
To be fair, current Evaluate expression is much better and can handle whole code blocks, on top of that, a future version will give you common editor actions as introducing variables, quick fixes for casting and more... Traversing through unknown and untyped trees will be a pleasure.
Yep, true. I was just trying to introduce the feature to Eclipse peasants :D
Some personal preferences are better than others.
Had I known about lantera at the beginning I might have looked at it a bit for inspiration. Ah well, the more the merrier. :) 
I really liked Eclipse for the most part until I was forced to use IntelliJ for a project and now I prefer it to Eclipse. I often found the debugger in Eclipse to be a crap-shoot whether or not it would work for TestNG tests. I have had no issues with the debugger in IntelliJ. I still use Eclipse for one project I work on, because I'm using Spring and a Tomcat server. I'm not running any TestNG tests in that project, though.
Thanks man :)
IntelliJ is better by light years
Oracle themselves [recommend](http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html) it though. I fail to see the abuse you see here. OP shows one use case for Optional. Maybe it's not as fast or maybe it's weird to someone who is used to null checks but once you get used to the pattern it's pretty easy to use and immediately recognize. Don't tell me null checks are prettier. You could argue that a different system design would maybe not necessitate the sort of use case OP describes, but IMO that is a different issue. OP says, assuming we would need null checks, this solution is better / more readable.
It's designed to collaberate with developers(i'm a dev), developer adds a class that says to screenshot it, and then a data-attribute to say what type of screenshot interaction you want(click, hover, field input, etc). That way you load in a list of urls you want screenshotted, it loops through the pages, for each page loops through the hooks, for each hook takes a screenshot after applying the hook's required action. So the tl:dr; is that you input a csv of pages, and it takes a bunch of screenshots and currently saves them to the drive. If i make this a web service of some variety, how would it save the files to the users computer, etc etc. How do i even make it a web accessible service. 
you could host a [simple spring app](http://spring.io/guides/gs/spring-boot/) on a server that takes the input file as you suggested, performs all the existing logic, then routes the user to another page with a list of the file names. then you could do something [like this](http://stackoverflow.com/questions/5673260/downloading-a-file-from-spring-controllers) to allow the user to download the files. you will end up having to store the files on the server itself, so keep in mind it could become a maintenance burden down the road
Call up some charities or volunteer companies and ask them if they need any website/webapp help
Best maven and IMO the best UI of the three.
That was the most interesting 15 minutes of my life.
Make it 19 minutes. I forgot one video earlier but added it now.
I made the same switch. I love sublime text for the hotkey centric UI. IntelliJ feels like sublime text on steroids.
If the choice is between something that needs an additional external tool and involves annotations or a simple object, already in the standard library at that, I'm picking the latter.
OK, but, at least for now, it seems like the JDK is not going to follow that route, so your code would not be idiomatic (and you'd still have to do all those null checks when working with the JDK or third-party libraries). The nullness checker has you covered, as the code is both idiomatic *and* interoperates well with the JDK. As to annotations, these isn't Hibernate magic or any such thing. In Java 8 you have type annotations, so the annotation is just a part of the type, so for example, you can have `List&lt;@Nullable String&gt;`, which allows null values, or `List&lt;@Nullable String&gt;`, which doesn't. Instead of options you have: void foo(List&lt;@Nullable String&gt; xs) { // String x = xs.get(0); // &lt;--- doesn't compile @Nullable String x = xs.get(0); if (x != null) { String y = x; // this compiles // .... } } So, like options, it forces you to handle nulls if necessary, or just not use @Nullable types, in which case you don't need null checks at all.
&gt; Then, are the new Stream operations un-idiomatic Java? The Streams API has special needs, and you'll note that no other API makes use of `Optional` (at least not yet). &gt; I'd rather have all variables be guaranteed as non-null How do you guarantee that? You'll have `Optional`s in your code -- that can have a value or be empty -- and plain references, that can also be either null or not. So `Optional&lt;String&gt;` is an optional string, and `String` is also an optional string. What's the use of Optional if every reference returned by the JDK or third-party libraries may be null? The clearest example is the `Map` interface. `Map.get` on a `Map&lt;String&gt;` doesn't return an `Optional&lt;String&gt;`. It returns a `String` that may be null. If, on the other hand, you need to store empty values in a map and distinguish between an empty value and a not-found result, *that* would be a good use of optional, and `Map&lt;Optional&lt;String&gt;&gt;` clearly describes that -- a null result on `Map.get` means "not found" while an `Optional` result means a value (empty or not). But you'll still have to do that null check because `Map.get` might return null whether or not you like `Optional`. &gt; and use Optional where it makes sense rather than tagging some things as nullable. Why? Not only are the pluggable types more concise than `Optional`, they apply to *everything* -- your code, JDK code, third-party code. So `Map.get` on a `Map&lt;String&gt;` really does return a `@Nullable String` (if you turn on the nullness checker), and you'll get a compiler error if you neglect the null check.
They will donate 50p to charity for every survey filled in.
&gt; But not every reference returned may be null because when you write a method you take care not to haphazardly return null. One of the things I like about Java, is that I don't write 98% of the methods I use, and I don't have control over the API of those methods. For the time being, it seems that Optional is not going to be a big part of libraries' APIs. &gt; I still prefer Optional because it not only represent something that might not be there, it also has the operations to deal with that. It's not that I'm philosophically opposed to Optional. It's just that I don't see much value in it being used in 0.1% of the places where it should have been used if it had really been the way chosen by Java to handle null values. Pluggable nullable types may or may not be nicer aesthetically, but they can cover 100% of the cases. So it's not an argument over aesthetics (although personally I do aesthetically prefer nullable types over Optional), but over usefulness. If your goal is to handle nulls -- Optional just doesn't help much by solving 0.1% of the problem.
Maybe I'm inexperienced with libraries but even the APIs I don't write myself rarely throw out unexpected nulls, they use null in very specific places, like when retrieving a value from a map. In my view, not having nulls at all is superior to any method of handling them. I view Optional not as a way to handle null, but as a way to avoid them completely. Not in the general case but in one very specific area, return values where "nothing" is a valid answer. Even if other APIs don't use them, those specific points where null is a valid return are rare enough that handling them is not that big of a deal. In all other cases, not putting null in there in the first place is the way to go, because again, no nulls is superior to any way of handling nulls.
parallels, boot camp, vmware fusion . . .
I am already working with JDBC... Just to learn the framework we want to use hibernate
Good idea 
It's your call obviously, those are just my thoughts on having used it. Not worth it for me.
dang it. You've let me down.
Yes, probably some limitation of design, in have its commonly used but this limitation is very bad.
This is why I am working in netbeans right now. The maven support in Eclipse is so fucking broken.
Something along the lines of: public final class MyClass { private final String foo; private final int bar; private MyClass(final Builder builder) { // Validate builder parameters here... this.foo = builder.foo; this.bar = builder.bar; } public static builder() { return new Builder(); } public static final class Builder { private String foo = "default"; private int bar; public final Builder foo(final String foo) { this.foo = foo; return this; } public final Builder bar(final int bar) { this.bar = bar; return this; } public final MyClass build() { return new MyClass(this); } } } This lets you do instantiation via: MyClass myClass = MyClass.builder().bar(5) .foo("baz") .build(); You can give default values to all optional parameters, and can enforce required parameters by requiring them in the Builder constructor (not shown in the example). This way you don't need to build a million different constructors for MyClass even if you have multiple optional parameters for its construction.
[Part 1] (http://nosoftskills.com/2015/02/primitives-in-generics-part-1/)
What's the status of the AngularJS plugin? Last time I checked (~ 1 year ago), it didn't do much except allowing "ng-"-style attributes in the markup. Back then the Netbeans plugin seemed more capable (e.g. one could jump from an injected parameter to its definition - at least in some cases...).
NetBeans has a great Community behind it as well.
&gt; It provides a pretty inconsistent layout if you open the code in another editor that defines tabs as a different width. Just out of curiosity - can you give an example of editors with this issue? Tabs are a consistent with within an editor. They might be configured to be a different width in a different editor, but it will still be consistent *in that editor*, and will still be a single tab character. If people have tab set to different amounts of spaces (someone has 4, someone 3, someone 2), then you'll have different amount of indentation that can't be controlled by setting tab width.
I don't think I will ever understand why someone chooses to use vim to write projects that contain more than one code file. I'm not saying that it doesn't work for them, but I just cannot fathom why it does.
(shrug) I won't argue version numbers.
This time, unfortunately, the version number is important as JavaFX and ~~JavaFX2~~ JavaFX8 are not even fully compatible.
I'm still using SWT with JFace. Then again, I don't do much GUI development, but I find the native look aesthetically pleasing. It doesn't allow much styling though. 
thanks I think soon ill look at some JavaFX examples because i've never used it
Brain Goetz also said: &gt; There's nothing wrong with Optional that it should be avoided, it's just not what many people wish it were, and accordingly we were fairly concerned about the risk of zealous over-use By zealous over-use he meant people using Optional as return type or parameter type all over the place. Either way, you are right that the goal was a different one, but they *did* end up introducing it as a concept into the JDK as a reusable component for use cases like theirs or new ones. So sure, it was not intended to be used like OP presents and hey, maybe the creators think it shouldn't, but it cannot really be considered abuse. It's just there and used and I can tell you already that "the madness" won't stop. Use case: You need to work with an old API that returns null for "no result" all over the place AND you hate manual null checks (I know you don't but OP apparently does). Then why not? The pluggable types don't help you there. You still have to write the null guards. I would say what OP is a nice workaround, not the solution for null-checks in general or more than that, but that doesn't make it madness.
:)
/u/desrtfx is trying to educate you, not argue. 
&gt;I find the native look aesthetically pleasing &gt;It doesn't allow much styling though If you are able to change the native look drastically, it is no longer the native look.
Thanks. 
What styling do you want? I'd recommend using MigLayout. It looks like you are using a default JFrame form - what about creating your own? You can make your own coloured buttons, etc. To get things looking even better, use JavaFX. It allows you to use CSS styling I believe. Personally, I wouldn't bother putting a lot of time into learning something just to get it looking better, unless that is a really important part of your product. I'd rather learn how to program better (but then I am not at all interested in graphic design). Using Graphics2D on the Swing paintComponent() lets you do a bunch of cool things too. (gradient shading, transformations, antialiasing, ...) 
True. I wrote it to inform the OP, since he wanted to do some styling on a window.
There are some really nice documented examples built into NetBeans as example projects.
Yup, there's a lovely Scene Builder out there. It integrates nicely enough with NetBeans.
jesus you all need to calm down. Whats with the down votes on this guy?
Like with everything else Java of couse JavaFX**2** is now JavaFX**8** :) At least if you're looking for JavaDocs. I really hope they get their stuff together and implement a NumberField that allows binding to Integer/Float/Double Properties and based on the type provides feedback for invalid input!
JavaFX2 may be shiny and new, but it is unfortunately not included in OpenJDK 8. That means Linux users have to download the Oracle JDK for JavaFX2 applications to work. This will apparently be fixed in OpenJDK 9. For plain old Swing Applications, I recommend using a declarative language to build Forms. I like the approach of the [Javabuilders library](https://github.com/jacek99/javabuilders), but I have not used it for a real application.
I use Qt a lot in my C++ work -- and it's excellent. Has anyone got any experience of the Java bindings, Qt Jambi?
I use a vim plugin for my IDE, it's the best of both worlds.
I knew there had to be at least one other person that uses SWT/JFace besides me *waves* We use SWT because the native look seems much more professional than Swing, and JFace is awesome as the Controller in MVC. Trees, tables, and tree tables (trees with columns) are very simple to use. This helps us greatly since these advanced controls are mandatory for our product.
Personally I prefer GWT. You write web apps in java, your web application backend can share the same code. You can export to native mobile app, or just wrap with phonegap. You get a really consistent UI without much cross platform headaches. Looks really promising. It's what the new Google Inbox is built with. 
[Apache Pivot](http://pivot.apache.org/) looks interesting.
You are aware that you are asking for programming help? So, obviously you did not notice the various hints: + the **big red button** saying **"Seek Programming Help"** + the **big red banner** when **hovering** over the **"Submit Text"** Button, saying **"Please seek help with programming in /r/Javahelp"** + the **big red box** in the **sidebar** saying **"Please seek help with programming in /r/Javahelp"** + the **"?"** icon in the **blue "Related Sub-Reddits"** box in the **sidebar** with the text **"Java Help ← Seek help here"** **Post removed:** Wrong subreddit &amp; already x-posted to /r/Javahelp
Saving this, thank you very much.
Take a look at the [Hashmap Sourcecode](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/HashMap.java#HashMap.get%28java.lang.Object%29) and see for yourself that it only distinguishes between *empty* and *non empty*, but not between one and many.
:)
Hashcodes don't guarantee uniqueness - the bucket could contain different objects which give the same hashcode, so even with one object in the bucket an equality check is still required.
We just use an Ant build system, so I'm of no help. Sorry :(
Apache PDFBox and Apache POI should help you.
Is this a bot? Spamming multiple subreddits with anecdotal, minor versions releases does not add much value, if at all.
sts got so slow I moved to Intellij
Good to see the Java world in pretty great shape
It's not only styling. Using SceneBuilder and all the language improvements from Java 8 you simply write a lot less code. Especially glue code. That being said there are of course a lot of things that need to be improved. Like I mentioned in another reply: the lack of a number field with proper bindings. And additionaly the fact that there seems to be no common strategy to create an application with mulpiple windows and dialogs. This tends to get very messy very quickly.
Terrorists won :/
We're still working on it. /u/desrtfx has added a rule to our AutoModerator that should help us block code help messages and ask the poster to re-post on /r/javahelp.
The advent of functional reactive programming on the JVM, combined with the syntax improvements of java 8 make the java ecosystem exciting to work with again. Even if you don't develop high-traffic web/mobile apps and don't need radical scalability (yet), the paradigm shift caused by these programming techniques is, IMO, a huge leap forward from the OO/imperative way. It has the potential of revolutionizing the way developers think, bringing FP concepts like monads and higher order functions to the "masses".
+1 for using TimeUnit :-) Our implementation doesn't create any Date instances, but follows very a similar approach. 
Where can we find your new library?
Well *that* sucks... I'd planned to build a little information radiatior for my dev shop on embedded FX using a RasPi this summer. Is it still in the JDK9 EA?
Google also has an interesting PNG library but it works at low level so not ideal for BufferedImage handling.
We got Subreddit of the day.
Similar to crapet's implementation, but I prefer to work in milliseconds throughout and generalised to allow input values outside of [0-59]. I suppose I could have used **TimeUnit** for calculating the constants, but it seems a bit overkill. private static final int MS_PER_MINUTE = 60 * 1000; private static final int MS_PER_HOUR = 60 * MS_PER_MINUTE; // Scheduled time-points, in milliseconds past whole hour private final long[] msPastHour; public HourlySchedulerTest(int ... minutesPastHour) { msPastHour = new long[ minutesPastHour.length ]; for( int i = 0; i &lt; minutesPastHour.length; ++i ) { msPastHour[i] = toMsPastHour( minutesPastHour[i] ); } Arrays.sort(msPastHour); } private static long toMsPastHour(int minutesPast) { minutesPast = minutesPast % 60; if( minutesPast &lt; 0 ) { minutesPast = minutesPast + 60; } return minutesPast * MS_PER_MINUTE; } public long getNextTime(long nowMillis) { // Round to the start of the current hour long baseHour = (nowMillis / MS_PER_HOUR) * MS_PER_HOUR; for( int i = 0; i &lt; msPastHour.length; ++i) { long scheduledTime = baseHour + msPastHour[i]; if( scheduledTime &gt;= nowMillis ) { return scheduledTime; } } // First scheduled time-point in the next hour return baseHour + MS_PER_HOUR + msPastHour[0]; } 
Java is a good lang for academics; * x-platform , do where you like * x-doamin, do what you like * hi performance, do it fast * handles data well mathematically and in language , do it well 
From the article: &gt; So far, it's shaping up to be a very different beast compared to the versions that came before it. Jigsaw will certainly be a boon for operations, but with value types delayed to Java 10, I don't see the big difference for everyday coding.
&gt; Is it still in the JDK9 EA? No idea, sorry. OpenJFX may be to the rescue.
Because mobile?
I'm one of those looking for better modularization.. Lots of shared pieces of code, customizations for n systems on separate projects.. 
&gt; So what is your experience of image support in Java. Yay! We can use JPEG images again in OpenJDK! (after 8 months) - https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=760926
Where would you put logic to handle the list being empty?
It's not just about modularizing the JDK, but replacing JARs/classpath with a true module system that takes care of version conflicts (today handled with shadowing, which is tricky and very error-prone), allows embedding native libraries, and makes packaging as a native executable a lot easier. Also, it opens the way (though I'm not sure that's on the Java 9 roadmap) to JIT caching, which would solve the JVM warmup problem. This is a very big, very important enhancement.
Thanks. Yes, that's always been a royal pain in the rear.
&gt; t can also solve the Java class path issues, which gives a path for the Java runtime environment to find classes and resource files. What does this mean? What issues?
It looks interesting. First. The GPLv3 license makes it a total non starter. For something that I would use as a library, as soon as I see the GPL license, I immediately stop looking. Look no further. The license is a total deal breaker. In this case, I thought it was interesting enough to look a bit deeper, despite knowing that I can never use this due to the license. Second make the constructor of TApplication private so that it cannot be directly called. Instead offer multiple public static methods such as: public static TApplication create( final InputStream input, final OutputStream output) throws UnsupportedEncodingException ); This way you don't limit the possible argument lists. For instance, you could then offer three methods: create, createGui, createText, all with the same arguments. The difference being that create makes the choice, based on various factors, whether to call createGui or createText. But the user of your library might have other ways of making that determination for themselves, and could then directly call createText or createGui. You can offer as many public static methods to create a TApplication as you want as long as you do not offer an actual constructor. Interesting work. Sorry I cannot look any closer at it. 
It looks like Yesterday, when I join this reddit and it had around 6K subscriber .... comes a long way. Go /r/java
&gt; more important Ok, let's play a thought experiment. Let's say you are the typical Java dev and as of tomorrow you can use Jigsaw. How will your workflow change? Take your time, I'll wait ⋮ that wasn't much, was it? Yeah, a few manifests here and there, and probably your build tool will evolve to take care of it without needing your intervention. Now about that value types... Being able to use *really* big ArrayList&lt;int&gt; instead of having to use TIntList or other third-party hacks should be reason enough to get excited. Every Java developer who remotely cares about performance (a minority, but not a small one) will celebrate. I will personally bake a cake and mark that day in my calendar. :-) Edit: Spelling
Just on monday I changed to 8. As of today our server has it (though not by default). Don't envy me too much; it will still take some time until all colleagues are migrated, and only then can we use the new features.
Not trolling (really, it's nice to discuss stuff with you in particular) What's your opinion on the fact that .Net has been modular from the ground up, never suffered the "classpath" problem (because of 1 - the GAC and 2 - local assembly resolution), allows packaging as a native executable transparent, and has been doing JIT caching (Ngen) for years since (I believe) .Net 2.0? And What's your opinion on the current state of .Net Core where even the base library itself will be distributed as a series of Nuget packages? I know I'll get a bunch of downvotes here because of my trolling history, but I really want to discuss stuff with you in particular.
Is there an article anywhere with *specifics* on this and how it will affect Java programmers?
Hi friend, .Net has quite the different target audience than Java. The latter is far more concerned with the server space, whereas the former is more often found client-sides. In the server space, byte code caching often has negligible benefits, on the other hand it doesn't mesh well with the system integrity side of things. Also .Net has the mercy of a more recent birth, and thus carries (presumably) less backward-compatibility ballast (type erasure anyone). There are some attempts at reducing the classpath problem (e.g. OSGI), and I've seen java programs distributed as binaries (e.g. the game Edna's Escape is apparently written in Java). Finally, I ask everyone on this thread not to downvote /u/agleiv2 on behalf of his past trolling. The comment on its own will probably attract enough deserved downvotes already.
&gt; How will your workflow change? Take your time, I'll wait No more shadowing; no more weird hacks for native libs; no more hair-pulling about classpath issues. I think this will immediately lower the cost of Java (and JVM) development, because those things are very time consuming. &gt; Being able to use really big ArrayList&lt;int&gt; instead of having to use TIntList You don't have to convince me because I'm also doing high-performance stuff and eagerly waiting for value types, but most Java developers don't care much about the difference between ArrayList&lt;Integer&gt; and ArrayList&lt;int&gt;.
&gt; .Net has been modular from the ground up Excellent. &gt; never suffered the "classpath" problem (because of 1 - the GAC and 2 - local assembly resolution) I am not [entirely sure about that](http://devproconnections.com/net-framework/net-framework-and-dll-hell). I personally remember some hairy assembly resolution issues. Java resolves dependencies without issue 99% of the time, too. The problem is how annoying that 1% is. &gt; allows packaging as a native executable transparent That's easy when you're only doing windows, and baking dlls into the OS. Let's see how that turns out on Linux. There are JVMs [that do just that for multiple platforms](http://www.excelsiorjet.com/), but not OpenJDK. &gt; has been doing JIT caching (Ngen) for years since (I believe) .Net 2.0? That's not the same thing. I am not too familiar with that, but it seems to be more like AOT compilation, which is a minor thing for .NET as that's pretty much how their JIT works; it just slightly changes the time it's run. HotSpot's JIT, OTOH, is a true, state-of-the-art, profile-guided optimizing JIT. The advantage of the .NET approach is that it's easy to reduce warmup time with stuff like that; HotSpot's advantage is that it is able to achieve higher performance once it's all warmed up. Again -- just tradeoffs. With .NET getting a better JIT, and HotSpot getting caching, both will be converging. (I say HotSpot rather that "the JVM" as there are many JVMs, some of them -- like Excelsior JET or RoboVM -- do AOT compilation) &gt; What's your opinion on the current state of .Net Core where even the base library itself will be distributed as a series of Nuget packages? No opinion, as I'm not too familiar with it, but it sounds great! But Java 9 is already modular, too. Also, obviously both ecosystems started out concentrating on different features and making different tradeoffs, and are both slowly converging (it seems). I don't see the point in arguing which had which feature first (neither will win). Frankly, even though the two platforms have a different focus, I think that if you're happy with .NET there's little reason to switch to the JVM, and if you're happy with the JVM, there's little reason to switch to .NET. There are, of course, reasons to switch from one to the other, but those are very domain specific and dependent on your particular needs. Both are excellent runtimes.
I'll believe it when I see it
When I first looked there was no link to the release notes. It always makes me smile that the Maven site is an incomplete Maven generated site just like every other Maven project.
Hey OP, good job ! Colleagues and I have been looking at a bunch of similar projects recently (Lombok, FreeBuilder, Auto*, ...). So far I like Jackdaw (I'm just hoping it's not needed at runtime, despite your doc clarifying that, but if it is, I'll patch it if I end up using it;)) Could you just explain why you need an APT plugin in a Maven build ? What do you mean in your pom by "disable APT for normal compilation" ? Isn't Jackdaw using the regular javax.annotation.processing.Processor service registry ?
A lot of it is NetBeans specific so I would thought you are better off with Eclipse tutorials.
And where exactly are they ?
Library A requires Library C v1.6. Library B requires Library C v1.4. Library C v1.5 introduced APIs that Library A relies on and removed APIs that Library B relies on. How can you build an application using Library A and Library B? Both want incompatible versions of Library C loaded.
The constructor in our case. I can see use-cases where you might want to allow an empty scheduler, but not in ours.
I think the solution now is to use something like JarJar to repackage Jar's into your own namespace, sloppy but it works. 
I think that version conflicts on the class path are the big one. It basically does something similar to OSGi, allowing each package to declare the libraries and versions that it depends on. This would let you use two different libraries which depend on two different and incompatible versions of some third library.
That is correct. The large amount of work was to untangle the existing Java libraries so that the runtime libraries could be modularized.
Yeah, that was my thinking when I joined the mods here. However, for a number of reasons, it's currently not feasible. That said, our current approach appears to have comparable results and is possible now.
classloader tricks, osgi style.
More for IoT and microservices deployment, I presume. You can shrink the JRE a lot alread using the compact profiles. If I get it Jigsaw should be allow to create "custom profiles" tailored on single application. https://blogs.oracle.com/jtc/entry/a_first_look_at_compact
Which is funny (ironic?) because Java (and .Net) was supposed to be the end of Dependency hell.
That's neat and all, but I don't understand crazy pricing like this. I'd much prefer to see a solid $X00/yr price for a tool per dev. My choices with this are: 'meh' version that does some cool stuff for essentially free/$10/$50 OR pay $1500/3000/$4800 for 1 developer on 1 platform WUUUUUT ? Uhhh, just a little disparity? I get it that folks want to get paid for stuff, and this seems like a neat tool and it has value. Maybe charge a "fair" price for it and the company won't have to resort to the 'give away crippled version for free and hope they like/need it enough to suck em in to pay more' strategy. It probably works, but I dislike it so much I won't even bother with the $10 charity version because it seems like too much of a headache when I need/want a new version.
Throw an exception. This would indicate a bug for us.
Didn't know you can name your projects after crows now. ^^I ^^kid ^^I ^^kid. Interesting idea to bind class generation to processing phase. Definitely going to check this out, might be useful for home projects. Thanks for sharing!
Wow I wish I asked you this when I was in college. 
Sure you can if a lot of the concepts there assume you have more basic computer science knowledge than you do. Of course it's the most comprehensive source though.
Please don't become Python.
I have questions: 1. Would it be useful to learn Mercurial first? I feel like Mercurial is Git for dummies. I've used Git as an Ops Admin, mostly for pulls. But as someone going back to school to get a real CS degree, I feel like I am ahead of the curve using Bitbucket and Mercurial for my projects (now in Java Data Structures.) 2. Another question about baby steps. I could set up MySQL/PostgreSQL in my sleep, but I've started most of my Java database projects in SQLite, for the sake of portability. Is this valuable? Btw: great answer to a question I never thought to ask.
This means more JAR hell, as now you also need to account for situations where parts of the JVM are missing and/or different versions than you expect
NGEN was there since day 1.
&gt; There are some small additions, like JSON Oracle wanted to [drop it](http://mail.openjdk.java.net/pipermail/jdk9-dev/2014-December/001670.html) at some point, did they change their minds?
It will also allow most of us who never use Legacy features (corba support?) to jetison the baggage without breaking Java
&gt; What's the point of having an IDE if you still need to switch to command prompts? agreed netbeans and intellij work painlessly with maven/gradle in comparison to eclipse.
thx
Basically, use popular Java frameworks to power web servers, connect to databases, and communicate with each other. It's simpler than you think but more challenging than it seems. Learn soap and rest. Learn how to use maven, learn how to use servlet containers, learn testing via junit and selenium, with jacoco thrown in. Hard mode use distributed caching via hazelcast or coherence. Only use oracle. These are things that matter to java software factories.
Misko Hevry one the major designers of angular was a java dev, he has a lot of experience in it. The first thing I saw when I looked at angular was how much it resembles the java web frameworks. It feels a lot like Struts or Spring MVC, especially in the area of dependency injection and controllers. The new angular 2 which will have annotations looks even more like Java.