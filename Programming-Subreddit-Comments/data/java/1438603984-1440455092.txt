One reason to use events outside of threading: [CQRS with Event Sourcing](http://cqrs.nu/Faq/event-sourcing)
Has nothing to do with Java. **Post removed:** completely off topic
The application will eventually become much more, the main reason for JavaFX was I need to produce Graphs from the data collected.
Somehow you can't use Eclipse's own source generating features after installing Lombok, that bothers me. Goodbye "create getters/setters" or other such features.
&gt; I thought MongoDB was the best thing ever [Anyone remember these books?](http://i.imgur.com/WhPcLdE.png)
This seems to be similar to another library that I saw today: [JOOL](https://github.com/jOOQ/jOOL).
I've been programming Java since V1.0 in 1996, just took the IKM 1.6 test and whilst the result is confidential I doubt it's fantastic. I thought a lot of the questions were irrelevant to someone being a good Java programmer or not. 
I personally don't know any good ones, I've never used tutorials for IDEA, I've always been able to figure everything out (after some derping around of course). You try [this](https://www.jetbrains.com/idea/documentation/) though.
Using JavaFX 3d capabilities will be better, true. But the tutorial was intended to explain low-level inner working of 3d engines, not building real apps using high-level api. Also, JavaFX 3d uses OpenGL, and it doesn't work for everyone (fails to start on my machine).
Awesome! Thank you!
All maven functionality is available through "plugins". Gradle uses "plugins" for pretty much the same things (they're just interacted with via a Groovy DSL instead of set up in XML), and Ant's based around "tasks" (which are a little different, but still fulfill the same need). If you *just* need to modify the manifest file of the JAR file you're creating in Maven you can do that through the [maven-jar-plugin](https://maven.apache.org/plugins/maven-jar-plugin/examples/manifest-customization.html) that's standard in Maven. The shade plugin does a lot more to support building an "uber-JAR" of your program and all its dependencies.
For example, I [seem to trust publications from O'reilly](http://archive.oreilly.com/pub/a/onjava/2003/11/19/exceptions.html) though I have no real basis for that. I found the following article and have been reading it, but I wonder if there is a more complete picture that is also a bit more up to date (O'Reilly article is from 2003).
Just my opinion, but I always find starting a small project, or getting involved in an another person's project is a good way to learn new languages.
I have ghostery and ublock installed on firefox with referers disabled. Opening the link in a new tab disables all the scroll bars. Opening in a new window is fine. You should consider not relying on referer header tag and/or whatever it is you are doing with scroll bars.
Explore the basics further. Learn what data types Java supports, How to write if statements, looping statements, then the OOP concepts of Java. If you're following the Java documentation /tutorial in Oracle, it should lead you to those. Oh and program by doing. The best way to learn a programming language is to actually write code yourself and experiment why and how things work. http://programmingbydoing.com/
Seems like it would be relatively straightforward to fork it if that became an issue.
Very cool. It reminds me of the book Developing Games In Java (http://www.brackeen.com/javagamebook/) it also has a home grown 3D engine which works quite well.
I agree. Can only learn so much from reading books. Just pick a project and go. Even something as simple as tic-tac-toe
Use a global exception handler as a catch-all. http://www.nomachetejuggling.com/2006/06/13/java-5-global-exception-handling/ Then you don't need to worry about TRYing everything. 
http://www.google.com 
Wish I could take credit for it. Found it handy when doing a project for deciding what collection to use and thought it'd be help ful for others.
Jumping straight into a project is the best way to learn. Of course you don't know how to do it, but you *do* know what you need to learn. Break down the project into smaller problems and then search the web how to achieve each of them. Then do more projects. All that experience builds up and you'll be doing things without any help at all. Also use http://www.stackoverflow.com. However, always search and investigate before asking. Some basic projects to start with: - A program that numerates all the files in a directory. - A program that can copy &amp; paste a file. - A program that writes files and then reads them later (like a reminder app). Afterwards, try to make a game using an existing framework like libGDX. Yes, there is a substantial learning curve, but videogames are by nature very dynamic and fairly challenging: hence excellent tools to learn. Making a game will force you to explore concepts such as memory management, flow control, user input, efficiency, collections, frame update and data persistence. Good luck.
Damn man, thanks for this! I just realised it's better to do it in Terminal (Linux Ubuntu) than with the IDE, simply because you learn faster and it's more fun. This website is amazing!
I'm sorry that happened to you. Unfortunately, I'm using blogger.com as blog engine &amp; blog theme, and it will be hard to fix this problems (Google *really* wants to send referer tags, very hard to convince them otherwise).
Also produces garbage.
What makes me wonder is how the upgrade path from Maven POMs to Jigsaw Modules will look like. Will they just co-exist side by side?
[uniVocity-parsers](https://github.com/uniVocity/univocity-parsers) has 300+ tests. This includes a few [example test cases](https://github.com/uniVocity/univocity-parsers/tree/master/src/test/java/com/univocity/parsers/examples) which produce and validate output for demonstration purposes and to build the tutorials. These are very easy to read and contain lots of documentation. [Jsoup](https://github.com/jhy/jsoup) is another good project with many test cases (400+) which cover a lot of interesting stuff.
Out of curiosity, why not a game? why no heavy lambda use?
Not a game to give it a more serious sciency enterprisy context. A game distracts people, I tried that in the past (either they are more interested in the game than in the results, or they don't take your results serious) No lambdas because the Java code analysis tools that I've built upon are still struggling with Java 8.
I was about to ask a similar question. Will Jigsaw replace Maven/Gradle/Ivy? If not, how will they interact?
Eclipse itself (the various main plug-ins) has a lot of tests.
They obviously have to imitate everything Spring did.
You could try the MongoDB Driver for Java, although it is for programmers. There are unit, acceptance and funcional tests. MongoDB Driver on Github: https://github.com/mongodb/mongo-java-driver/tree/master/driver/src/test
Ho hum trying to think. For general perf stuff these guys are nice: http://mechanical-sympathy.blogspot.com/ For most true 0 GC work I would write code, set my GC to print out when it fired.. and run a few millions iterations of my code. If I made garbage I would start over.. Starting point is avoid all libraries, and avoid passing objects around. If you need some shared state, put it in a global final variable of some kind. 
&gt; mitate everyth Nothing wrong with picking up good ideas, obviously there are weaknesses in the construct. Still a very useful feature for parallel processing. 
We started off with JGroups and improved our model of cluster communication over time. We made customized solutions for our clustering techniques to have the most reliable, and an extremely scalable, architecture (e.g. it can support 100 nodes and more)
I doubt it will replace it. These systems do more than just put things together, they also go out and fetch dependencies. Likely, what this will mean for them is that they will now be able to support building a tree with multiple versions of the same library. Currently these systems do their best to resolve this to a single version of the library. Now they will be able to just pull them all in at the same time.
You can take a look at druid.io. There's comprehensive unit and integration tests. It is a distributed system though and there's some overhead to understanding what is going on.
Great news, and a sound decision (which IMHO is typical of the Java team, contrary to all the whining on the web). I'm especially glad they didn't go the route of adding a -XX switch to allow access to the now hidden APIs. Hopefully this will put an end to the wave of "Oh no! Java is dooooomed! No one will ever use anything beyond Java 8!" articles we've been seeing of late.
I'd also venture a guess that build systems will be able to pull dependency information from module configuration. At least it would make sense.
actually you can make legitimate arguments that java has continually been hindered by a rigid adherence to maintaining backwards compatibility. if they'd broken a few eggs earlier in its lifetime we might have a better omelette. 
i've always wanted to see an android app with really good tests. I honestly don't think they exist
I mean, you're still using Java, then... You're still using compilers and runtime environments with these Oracle designed features included, and almost certainly utilised by your dependencies... But okay, whatever makes you happy.
I thought the actual module system was deferred to 10, and 9 would only modularize the JDK itself?
Caller sensitivity is a pain point in Java I run up against every so often. Ideally IMO there would be no caller sensitivity in the language, but that ship has sailed due to APIs like `Class.forName()` and `System.loadLibrary()`. Currently Java is in this weird middle ground where JDK APIs can be properly caller-sensitive but nothing else can. For example, it's impossible to write a correct wrapper for `System.loadLibrary()` because the library will be loaded into your `ClassLoader` instead of the caller's. As well, the `MethodHandle` infrastructure [respects caller-sensitivity](https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandles.Lookup.html#callsens) by looking for the `@sun.reflect.CallerSensitive` annotation, but of course you can't apply it to your own methods without referencing the internal `sun` namespace. This JEP won't solve those issues, but it's a step in the right direction I guess. It did teach me about `SecurityManager::getClassContext()`, which looks like a nice way to get the `Class` instances in the current stack trace (`Throwable::getStackTrace()` will only get you the class *names*).
Anything you want. Lots of languages are good and it all depends on what you do. Since Java is such a universal language, just knowing Java doesn't really say anything about what you do with it. JavaScript is always a good choice. Just like Java in the sense that it runs anywhere, but that's where the similarities stop. 
On top of this, in my experience Java developer often have to work more or less directly with JavaScript at times, so it's a bonus to have strong understanding of it. 
Unsafe is used to do low-level program functions that would be considered unsafe within Java proper. A lot of popular frameworks rely on its usage for performance and some of their features. Think of Unsafe as an extension of reflection, at least as far as what it enables in terms of lower-level functionality.
C or Javascript
That counts as extending Thread. I always use an executor service if I want something to happen in another Thread.
You are overthinking this. The inferred type is simply the type of the expression on the right-hand side. No more, no less.
I did it the other way around, learnt Haskell first then Java.
I learnt python after java, a lot of the skills carry over since both are object oriented.
C# because it was needed for a course in my degree. But any language is recommended, learning is never bad at all! I also programmed a little bit in Python but nothing serious, not even covered all the intermediate stuff with it. I would recommend you to go with C# due to it being very similar to Java, and then jump into C++ to see some unreal and serious stuff with it.
SQL. After that I'd learn JavaScript.
It's kinda weird to me that Java was your first language...it's almost too easy. My first was BASIC, technically, but I did a lot with Calculator Basic (TI) in high school. After that it was Pascal, then C++, then Dr. Scheme in college, and more C++ &amp; PL/SQL and some PIC Assembly. Then after college a crash course in C (no plusses) because I worked on machines for which there is no C++ compiler (Open VMS can die in a fire), and oddly Visual Basic. I don't know why I felt like writing that all out, but it wasn't until after that job I got to Java and it's so. much. easier. But I knew what it was doing at least conceptually under the hood before I started using it because of my time in the C/assembler trenches. Now I'm oddly considered an Intellij IDEA expert after having been using it for 10 years doing almost pure java. I would recommend purely for learning you hit a low level language like C++ and fiddle with some bits. Write your own linked list or something so you get to play with `malloc` &amp; `free` and fully appreciate all the stuff Java does for you. Maybe shell scripting? Get your grep/awk/sed skills up to where you can write shitty one liner hacks to automate small tasks?
This is an excellent post, I highly recommend everything listed here.
What was my second language after Java? PHP. I dont' recommened learning this unless you like boring piece work and a significant hit to your pay. What do I recommend? Depends. * Something similar? C# isn't a bad choice. * Something challenging? C/C++ would work * Something in the same family? Scala's a good one. * Something to pad the resume? All of the above. Some common javscript languages like node, angular, and jquery wouldn't hurt either if you feel the need for web dev.
Swift
Go. It's fun. Not the best for jobs, yet, but it's a great fit for a former Java programmer.
javascript could be the best because there are many positions where you will use them in tandem. As others have said C# is also good because despite the vitriol going back in forth it is practically the same language and easy to learn if you know java well. I once ported a C# application that had been written in about two months by a group in less than a day. A jvm scripting language like groovy or jython would be another strong candidate.
Outside of academics, Java was my 3rd language. 1st was PHP, then C#. 7 years later, still in Java :) Not that I don't know other languages, just not my day to day language. Currently dabbling with JavaScript. Lots you can do...front end, and now backend with Node.js. Python to be next. 
Check this issue discussing about `$`: https://github.com/wapatesh/fig/issues/20
Not only the license, but Fig has also a big difference with JOOL, that JOOL is extending Stream, while Fig is not.
Choose a language based on what you want to do and what it can offer you, and don't be afraid to change tracks if you decide it's not working out. * Want to get ideas spun up real quick? Learn Ruby and Rails. * Want to get into graphics? Learn C++ or C# with Unity. * Want to stretch your brain and learn a whole new way of writing code? Learn Clojure. * Want to get into system-level programming? Learn C. (Note that not all of these may be accurate, but you get the idea.)
JOOQ https://github.com/jOOQ/jOOQ has decent amount of non trivial tests.
If you like fiddling with low level stuff I would suggest Bash/Python. If you are looking for making your resume shiny go for Scala.
I recommend a script language: Groovy, JavaScrip or Python
Kotlin
Similar syntax, sure, but it is definitely not pretty much the same language.
Could you tell me the way you learned bash? Did you buy any books? I'd like to learn bash (not 2nd language, though), but I can't find good resource.
Semi jokingly here - I don't think Java platform would be hurt too much if those frameworks went out of business. Including Spring.
*follow-up post in 6.5 years* 
I really like this book, The Command Line and Shell Scripting Bible. http://docs.linuxtone.org/ebooks/Shell/Wiley.Linux.Command.Line.and.Shell.Scripting.Bible.May.2008.pdf
Scala
Java and any other programming language is a tool in your toolbox. So the question you asked is like a mechanic asking, when can I say, "I know hammer" (or maybe slightly more complicated tool). What makes a good mechanic or good programmer not knowing the tools and checking off achievements but their ability to build awesome stuff with those tools. If I were you, I would worry less about language itself, but about applying it to actually make programs. Start small, make mistakes, learn from them and try a little bigger. 10 years later maybe you still won't be able to claim you know java 100% (I don't and I've been coding for 20+ years) but you'll be able to build some cool things. 
Ok, but again, you're still going to be using java APIs. You might not think its an *ignorant* anti-corporate rant, I'm just pointing out it's a completely *impotent* one. Also, you seriously did not understand the result of the case, haha... So yes, it is a little ignorant.
Python. It's the perfect language for things you don't want to turn into full-blown applications, being extremely convenient to work with and having an enormous set of libraries. It's also perfect for prototyping, since with Jython you can write the same language yet import your Java code. I've prototyped a lot of stuff in Jython (a query language, a graph visualization tool, NLP auto-classification software) that later were turned into Java products. Python is also great for web applications. So great I often find myself wondering why anyone would ever write smaller webapps in anything else.
How does Java look to a Haskell developer?
This might be good advice in general and specifically if you are working on small project with very few people (or only yourself). But from my experience, in larger, enterprise projects, you have to know Language and libraries (even third party) quite well, since you'll be constant drag on code reviews.
I missed the simplicity and how easy it was to write correct and generic code. Also no pattern matching and list comprehensions was a bummer. Java was easy to write though once you get the hang of it.
&gt; Oh no! Java is dooooomed! No one will ever use anything beyond Java 8! There are too many different ways to claim Java doomsday, though
While these examples certainly work, a more modern opinion on object-oriented software suggests that you should implement runnable and pass that to a thread, rather than extending thread with additional behaviour. This opinion is commonly labelled ["composition over inheritance"](https://en.wikipedia.org/wiki/Composition_over_inheritance). I.e. it is generally "better" to model a thread that *has* a runnable, rather than a thread that *is* a runnable. In addition to this, in more modern versions of Java, you will probably not make direct references to individual threads, but pass your runnable to an `ExecutorService` [as was mentioned before](https://www.reddit.com/r/java/comments/3fsqjg/anonymous_threads/ctrol03)
I came here to say this! I started with Java and then moved to Python. Python was nasty, nasty, nasty, and way too open-ended with hundreds of libraries for me as a beginner. Go's simplicity and batteries-included philosophy have taught me a lot!
Javascript is useful professionally, as you usually mix Java as a backend with JS as a frontend. It's the language of the future, whatever the grumpy C++ grandads or Python hippies or COBOL hermites tell you. You want a job, you want JS.
There is a huge difference between knowing *a programming language* and knowing *how to program*. The former is only vocabulary and grammar. This is the easy part to learn. Plenty tutorials around; most languages have very good documentation, etc. The latter requires analytic thinking or thinking in algorithms. This is the difficult to learn skill. Mostly, this skill can only be acquired through practice. Also, this skill is basically language independent as the concepts (loops, conditionals, algorithms) apply to nearly every language. Every programmer needs to hone the skill of converting problems or tasks into computer programs. &gt; I feel pretty confident with the basics of it Means that you know *the programming language*. &gt; but can't do anything really complicated by myself. Means that you don't know *how to program*. In this case, you should write plenty programs. Practice, practice, practice. Tackle some of the programs listed under [Programming Challenges](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) in the /r/learnprogramming wiki. The only way that you can become a programmer is through writing programs, plenty of programs. As long as you have not climbed that hurdle, it's too early to move on to another language because you will run into the same problem as with Java. You *know the language*, but lack the skill *to program*. ---- During my time as instructor, I gave the following advice to my students: + Pick an activity that you do every day, like making breakfast or something similar. It should be not too easy, but also not too difficult. + Write down the steps that you should do for the activity, but do it *out of memory* in a different time to when you actually perform the activity. (Write the steps to make breakfast down in the afternoon.) + The next time you perform the activity take your notes and try to follow the steps religiously. Try not to deviate from your written down steps and if you have to, note the differences down. + Improve your algorithm until you are satisfied. + Try this with different activities. The tasks become easier and easier. As stupid as it may sound, it works. The goal of this exercise is to sharpen you skill of converting problems/tasks into steps that can later be programmed. The most essential skill of a programmer.
If you're a Java developer you're probably going to end up working on web applications at some point (most of our Swing based applications are slowing being replaced with web interfaces) so Javascript is always a good choice. Particularly getting familiar with libraries like JQuery.
Java is my second language. I started programming in Pascal and picked up Java in 2000 or so. I second /u/pathema's post, just pick something else. Everything that broadens your horizon and exposes you to different concepts is a good thing. I use Python next to Java the most, because I use IPython a lot. I've been planning on picking up Haskell and C++ forever, I just never had a good project to use them for.
What is your goal? * If you want to become a better programmer but stay on the JVM, I would suggest **Scala**, since it teaches you a lot of concepts and best practices. * If you want to do some web stuff, then learn **JavaScript**. * If you want to learn how to write secure / relieable application, try **Rust**. * If you want to become productive and happy, use **Python**.
Another vote for C.
It could also just be a crisis of confidence. Many people underestimate what they can do, especially when the task is open ended, like writing a large program. It's not that we all the sudden, as pros, we know how to solve every problem. The more we code, the more comfortable we become with the uncertainty of not knowing exactly how to solve a given problem from the outset.
I bought a book, but never used it. I started doing a build engineering job in addition to my Java dev job, and that required a ton of bash. It's so incredibly flexible and powerful that you could really just start using it. Really, just automate all the tasks you do regularly. Have to write the same three lines over and over? Script it. The three things that helped me learn most were need, google and [this blog post](http://www.kfirlavi.com/blog/2012/11/14/defensive-bash-programming/)
Considering the last update was in 2012, I had already assumed it was EOL. I guess it's good to make it official.
Look at my submitted history here. I've specifically looked at the question of whether we can have java without the JLS APIs.
groovy or python but not javascript (except if you want to do web stuff where it is inevitable) they will expand your eyes on how simple a program can be.
Short example with screenshot: https://www.reddit.com/r/java/comments/2out3f/did_you_know_pure_java_8_can_do_3d/
Your link does not back up your claim. Cite a paragraph.
Most of them are test dependencies. Still I do not see why they bother with developing log4j2 when there is slf4j + Logback.
Python is always a good choice since its just so damn common.
It may help if you read the [actual documentation](http://logging.apache.org/log4j/2.x/runtime-dependencies.html) on the runtime dependencies of a project. If you had done so, you would find that at runtime, all you need is the log4j2 API, and the implementation.
Sorry, but practically I don't agree with half of this list. First of all, where is Python? You know, the language that is virtually everywhere these days because of its versatility? Ruby is worth spending a few days in to bask in its beauty, but ultimately seems to be receding in popularity (partially due to being shackled to Rails, which is showing real signs of aging). PHP has shaken off a *bunch* of cruft in the last 5-10 years, and appears to be experiencing something of a renaissance. I'd pick that over Ruby at this point in time (and I have). The rest I agree with. And I totally agree that one should just keep picking up new things and aspire, at least, to learn everything. That said, for someone looking for just their *second* language, I think it makes sense to think practically here because they are making a large time investment. If I lose my job as a Java dev and I only have that and Erlang, Clojure, Rust, or Haskell in my locker, then my job search isn't going to go as well as if I had chops in C/++/#, JS/Node, Python, PHP, or even still Ruby/RoR.
It's a video...
FORTRAN. Definitely FORTRAN.
Common Lisp, without a doubt. It's a language with very rich history. Reading that history alone *will* make you understand better what you are doing and why, even as mainly Java programmer (I'm one), since so many things were pioneered in Lisp or at least implemented to it. It gives tremendously powerful perspective to just about everything. The other benefit is that you will learn to understand data structures much better without much effort, since it's all there plainly visible right in the code. The bad part is that after trawling through half Practical Common Lisp (free online) and making few toy applications, you are spoiled so much that programming in Java becomes a bit agonizing. Which is why I'm also looking at Clojure with great interest right now.
&gt;Well technically by definition you cannot have the Java Language without everything in the JLS Java language as defined by Oracle (JLS), no. Java as defined by the language syntax is what cannot be copyrighted. &gt; I don't think the JLS actually specifies core/platform API though does it? Though it does obviously refer to it in places. See previous discussion here: https://www.reddit.com/r/androiddev/comments/259zr7/37_java_api_packages_potentially_encumbered_by/ Yes, the JLS specifies the behavior of 3 packages covered by the decision and IMO project jigsaw will likely add to that list. &gt;Even if you *could* in some stunted sense, why would you? Using Java without using *any* Oracle API is just not a useful idea right now. Why use Java at all is an apt question for the majority of developers, but for someone with over a decade of specialized experience the choice to endorse libraries which shim the JLS packages may be more appropriate. I'll see you in the future when you arrive.
I was talking with my friend about something like this, and he said to me "I can read a book, but I can't write one" haha.
Yeah, I'm seeing I still have a long path to go, haha.
I haven't used it, but there is a Java frontend to Csound called [blue](http://blue.kunstmusik.com/). If you're interested in other JVM languages, the same author is working on pure Clojure libraries for sound synthesis called [pink](https://github.com/kunstmusik/pink) and [score](https://github.com/kunstmusik/score), and there is also [overtone](http://overtone.github.io/), which is a Clojure frontend to supercollider.
You could try making games with [libGDX](https://libgdx.badlogicgames.com/), a Java game framework. If you haven't made games before, it is very different than other kinds of programming, so it will definitely challenge you and expand your mind.
I'll never claim to have good inspiration or good ideas, I just start coding whatever comes to mind, and that's what's is important. My first "app" was a contact management application, the second one a (terrible) twitter clone. They were by no means *good* code, or ideas, but it continued my learning of Java.
Find a project you want to do and could say "yeah that would be really cool to make" Nothing motivates like something you want to see made. I'm learning by implementing a bunch of little utilities I could possibly need for my employer, but which are just bonus side benefits for them: https://github.com/BoiseITonCall/TestingUtilities In the course of writing these little utilities, I've learned: * firm grasp on why interfaces are used * Override toString so i can have better looking object output * DB connections (including the dreaded and hard to find: Java + MS SQL + Single-Sign-On) * Exception handling (still learning this) * Flat file IO * recursion for traversing complicated variable length multi-dimensional arrays of objects * performance testing &amp; program profiling * Good documentation practices * Ant building Fat Jars for dependency-free runnable jar applications * Probably some other things that escape my mind now **note** fixed overload vs override for toString
I should also mention that I *wanted* to have a study group that would progress through a series of examples at a set pace together..... https://www.reddit.com/r/learnjavaplayground But it looks like most others bailed or ran out of time to participate.
Alright, I will cite [the U.S. Department of Justice](http://www.fosspatents.com/2015/06/oracle-v-google-android-java-copyright.html) (from a later article): &gt; "The Android platform uses the Java programming language, but [Google] purposely designed Android not to be compatible with the Java platform or interoperable with Java programs." And also, from [the first article I linked](http://www.fosspatents.com/2014/05/refresher-q-on-oracle-v-google-after.html#fear): &gt; Don't be fooled by the fear, uncertainty and doubt (FUD) strategies of those who are outraged that the Federal Circuit declined their invitation to misread long-standing statutory and Ninth Circuit law. They are now drumming up support for Google's very likely petition for a full-court review and Google's potential petition to the Supreme Court for writ of certiorari. They employed FUD tactics before (during the district court trial and after Oracle appealed), misleading some people to believe that anyone using an API to write apps for a platform would have to worry, which was never the issue.
The DoJ amicus brief is NOT a legal ruling. This response is inaccurate to the point of being deceitful. The fosspatents opinion piece undermines that point in the very next paragraph: &gt; This doesn't mean to say that we app developers won't have to make some changes to our code if Google makes Android more Java-compatible as a result of all of this. **I obviously can't guarantee you that this won't ever be necessary.** I'm just saying that Android will continue to do well, and possibly even better, if Oracle becomes a strategic partner of Google's. I'm not at all following how the actual ruling connects to making Android "more java" -- which is not necessary. This opinion and its conclusions seem to follow the argument that Oracle put forward: Android is not an accepted JLS implementation and has additional APIs therefore it is fragmenting java. First, the ruling did not address that point, and second, we still don't have a certified Apache Harmony release so chasing the GPL Java license seems futile at this point: leaving the door open for further infringement claims by the entity who is the arbiter of JLS verification.
There are some others and also some other documentation and papers on the subject. https://www.google.com/search?q=Java+for+realtime+audio
The implementation drags in several transitive dependencies. But like another poster said, _most_ of the listed dependencies are test scoped.
Okay, so I've looked up the court proceedings. I now understand that some "merger doctrine" or other excludes use of the three core packages you mentioned from the class of "actionable infringing conduct". So, presumably, you advocate for use of Java without any interaction with the 34 *other* copyrightable packages which *are* actionable. Okay. &gt; Yes, the JLS specifies the behavior of 3 packages covered by the decision and IMO project jigsaw will likely add to that list. To clarify this point, I just looked this up, because being fairly familiar with the JLS it sounded wrong. It is, a little; in chapter 1.4 it is made clear that the JLS does *not* specify the behaviour of any classes - certainly not full packages - though it does partially *constrain* the behaviour by way of a number of references. This is basically what I said before. &gt; I'll see you in the future when you arrive. Haha, we will see. I think it's unlikely that Google will wipe out 99% of its app store by no longer providing implementation of those 34 packages. Not only would current store content be more than decimated, but new apps would not be able to leverage basically any of the Java ecosystem. "The future" isn't going to be based in some crappy backwards Java implementation, which will probably: - Always be playing catch up to new features. (Android is backed by *Google* and they *still* are stuck back in Java 6... It's possible that others would fare better, but I somewhat doubt it.) - Be unable to leverage the existing Java ecosystem. &gt; choice to endorse libraries which shim the JLS packages This is backwards right? It's the three "JLS" packages which you *need to* have in order to use/implement Java. It's the other 34 packages you need to avoid if you wish to stay off Oracle's radar. And again, Maven and OSGi don't do this, do they? I suppose I wouldn't be *terribly* surprised if they managed to completely avoid those 34 packages, but I kinda doubt it... Which is what I pointed out in the first place. &gt; Why use Java at all is an apt question for the majority of developers Sure, I guess. And one of the main reasons is the ecosystem, which you don't get if you don't play ball with Oracle.
Switching to HikariCP completely eliminated issues we were having when using Spring JDBC connections. Requests would often be delayed greatly due to delays in making the actual connection to the DB.
My god, the amount of pointless suggestion here is astonishing. 
Learn to program? Knowing the syntax isn't enough. Try making a tetris game from scratch. 
Yup. This is why I really like rust's approach towards language design. They knew they were going to get things wrong so they didn't release 1.0 until nearly 10 years of development, and even then, they severely limited what went into the standard library (while even adding things like "unstable" to allow them to continue experimentation on apis). I wish java had taken a similar approach. Instead they have been all too eager to include things a bunch of things into the standard library and language way before the nastiness was hammered out all while promising backwards compatibility making those apis untouchable. (java.util.date, Enumeration, CORBA). I mean, Brian Goetz talks about the mistakes of serialization and how horrible it is. So why don't they kill it in the next 2 versions? Deprecate it now, add a replacement that does the right thing, and then remove it in the next version. Heck, you don't even have to change the interface, it is possible to have two deserializers side by side under the hood. If the format, functionality, and implementation is truly unwieldy I don't think it is extreme to "gasp" require that old serialized java thing end up needed to go through a new round of serialization and stored off in the new format. Sounds like something that is totally acceptable especially given how rare it is for someone to store off a java serialized object long term.
About fucking time. I needed a reason to go to my app architect and prove that we are ready to move on to the 2000s. Yay. I love EOL! 
Same here, I swapped out log4j1+slf4j with log4j2 (still using slf4j bindings) in just an hour or two of fiddling with the pom and the log4j2.xml.. I just put it on the shelf since the config was somewhat basic, but now i've got the motivation to spend some time porting over the old config and pushing through the changes.
 seems OP is a beginner hence that advice. But that point I was going for is that to build an application, one language is only a small part. Our current app uses 4 major languages. But besides that there's a ton of libraries and other packages that one should be aware of. And there is so many of them, you will never learn everything or even 1% of what's out there. So outside of language itself, with app building experience, you pick up general skills and the most important one, ability to learn things. There is no shortcuts here. You just need to keep making things. 
You can check the README, it has some explanation about why not Stream: https://github.com/wapatesh/fig#not-stream Basically, the vast majority operations on List, Map, String don't need a Stream. Stream brings great merits on big data processing, but when we're not facing performance problem (operating a list of about 10x elements). It is an over kill. And Stream brings the 2 additional steps "Stream()" and "collect()", which is sometimes annoying to write. Also, I have done a test (not published yet) that if the size of data is small, Stream operations are slower than raw manipulation.
I tried to migrate from log4j1 to log4j2 and gave up. The new appender APIs seemed to be designed for consumption by machines rather than humans. Take SyslogAppender for example: http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/SyslogAppender.html I wanted to create a SyslogAppender in code, but its only public factory method takes about 30 arguments. Presumably the designers never envisioned anyone using this method -- that it was only to be invoked by the log4j2 internals that read config files. Using a log4j-specific, environment-specific config file was not appropriate in my situation, and actually calling that ~30-argument method in my code seemed like a bad joke. The other appenders I wanted had similar problems. This was new in log4j2; the log4j1-using code was relatively clean. I eventually switched to logback.
Oh dear. Has someone not heard of java.util.UUID? 
Its like quantum mechanics... anyone who says, "I know Java.", doesn't know Java.
Beads - http://www.beadsproject.net/ I found to be quite good, a well thought out API although a little tricky to understand sometimes. Being able to create your own generators and custom functions easily and compose them programatically was a big win for me. Effectively this allowed a small amount of customisation and the ability to 'refactor' the pipeline. It wasn't obvious to me that it was actively maintained though.
Personally I don't like JavaScript (the endless level of anonymous callbacks is ugly as hell). But nowadays JavaScript is quite spread, it is used on web, node.js, etc. So may the OP should try it.
You will need a reference to the thread in order to help manage it's life cycle or communicate with other threads. It helps if you have a name, but if you don't you'll see a lot of calls to `Thread.currentThread()`.
JavaScript and scala are what I have been focusing on for the past few years when I have time
My second personally was Ruby. I found it to be a good one for me as whilst I had a foundation of programming in Java to make me aware of constructs, types, OO and other fundamental concepts I now had a language with some more functional features that was less strict. I now use Ruby for scripting and prototyping, and then Java if I need any heavier lifting. Now that Java 8 is around some of the paradigms I learned in Ruby are making their way into my Java code (map, filter, reduce, lambda expressions)
Errrr. It definitely would.
&gt; For all I care you may claim technical victory I just think it's important to be clear about the details... &gt; as long as we both understand that the ruling in fact applies to the implementation of any JLS compliant JVM. Sure, but I don't think we exactly agree on what the ruling entails. &gt; p.s. Android Studio and Android 5.0 requires JDK7 Sorry, my mistake! But it *was* a couple of years late, and only partial... &gt; If enough open source libraries switch to a JLS shim (open -&gt; Oracle) then this is untrue. Good luck with that. Java has a lot of inertia. There are many many thousands of developers contributing to the Java ecosystem as I type this. How many are contributing to your vision? You cited OSGi as an example of something which more happily fits your needs, for example. I've already pointed out that by your own standards this is not the case... And going into the future, why would the OSGi Alliance care about this? &gt; By "java" do you mean the syntax or the JLS spec? Again, I don't think there is any real distinction. Not for me, not for other Java users, and critically, *not for Google, even*. Java is defined by the JLS, and the JLS references portions of those three packages. &gt; If Android implemented a syntax without these packages and the FOSS community provided the shim from java.io, java.lang, and java.util to talk to the hypithetical open.io, open.lang, and open.util then there is no such requirement. If I understand the current legal situation properly, those packages are safe from infringement claims, due to what I said above. Since the Java language is free, and those three are mentioned by the specification of the language, they are considered necessary to use Java and so they would have extra protection against copyright infringement claims. You keep bringing up those three packages specifically, but as far as I can see they're the only ones your arguments *don't* apply to. Google would probably be able to use them just fine, it's only the other copyrighted packages they'd have to get rid of.
[Updated version](https://gist.github.com/Moosemorals/4ffaf5c43b5486531ba0) that uses SecureRandom rather than messing around with the time and thread id to get a "random" seed. (By the way, current time is a very poor source of entropy, since the first half of the bits don't change. For example, the current (ish) unix time, as a 64 bit binary number: 0000 0000 0000 0000 0000 0000 0010 0001 1000 0000 0100 0010 1101 0111 1010 1000 Notice all the zero bits at the start. They're not going to change very often....) But yeh, just use java.util.UUID.randomUUID() if you need a random id.
Alright. You obviously have much more legal knowledge than me, since you seem to know the rulings as well as fosspatents. Of course, if you want to avoid all copyright/patent infringement, you might as well stop IT altogether because there are probably so many patents that no one knows about. I personally trust that Oracle won't start antagonizing the bulk of its customers.
Take a look at [this project](https://github.com/puniverse/extended-stacktrace) we've just open-sourced, which lets you get the actual class, the actual method and more.
Oh, my bad! I only saw the name-based implementation, that makes it much more useful :)
Good stuff. From glancing over the code I would suggest a few stylistic improvements: * none of your global variables need to be global as far as I can tell * readLogFile and readGZFile are almost identical so I would suggest chaining them (same for extractEmail, extractIp) * IO operations could be shortened a little by using [try-with-resources statements](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)
&gt;You keep bringing up those three packages specifically, but as far as I can see they're the only ones your arguments *don't* apply to. Google would probably be able to use them just fine, it's only the other copyrighted packages they'd have to get rid of. These 3 are part of the asserted copyright in the ruling. I agree that the non-JLS packages are largely unnecessary.
Few recommendations: * Don't check in your .idea dir, .iml files or anything else ide specific * Add a .gitignore file; https://www.gitignore.io/ will generate you one - I'd say get it to generate one for eclipse, intellij, java, windows, osx and linux * You have a few warnings regarding generics which would be worth fixing. eg PlayGamesDialog.java cmbTournaments.setModel(new DefaultComboBoxModel(tournaments.toArray())); // produces unchecked assignment warning // could be changed to cmbTournaments.setModel(new DefaultComboBoxModel&lt;&gt;(tournaments.toArray(new String[tournaments.size()]))); // compiles without warning Also checking out the project and doing mvn clean install is not sufficient to build the project - [log here](http://pastebin.com/tb4CGmVC). ~~In your README.md you should probably document the steps required to set up so you can build, or update the build so these are done as part of the build~~ edit: Bleh, it would appear I can't read. Your description under installation is not quite accurate for a fresh machine; the schema and tables need to be created before performing mvn package (or clean install or test or whatever). Also none of the sql files create the required schema 'TDB' - this needs to happen before the first existing sql file is executed
Lukas here, from the jOOQ team. Our integration test suite is not open source / publicly available, so I'm not sure if that's really a good example for this question... But the [H2](http://h2database.com/), [HSQLDB](http://hsqldb.org/), [Derby](http://db.apache.org/derby/) integration test suites are quite comprehensive
&gt;seems to be commonly accepted that those copyrights will not be *enforcible* to the same extent and in the same manner wrt infringement, due to their being necessary to the use of Java. Not precisely. You need to distinguish between the implementation of Java application code and the implementation of a Java interpreter and the accompanying JLS classpath libraries. You can also use phrases containing "Collection" and individual method names as fair-use, but you can't express "public interface Collection" and the accompanying method signatures without infringing on Oracle's copyright. &gt;Java is free to use, therefore they must also be free to use regardless of copyright. You agree to terms of use when you download a JDK and when you install it. Precisely how free is it?
Gah, schema! Knew I'd forget something. Good spot. Also the generics :) Now assuming I have the create schema SQL sorted, how would I get the user to run them, as in my understanding the connection manager will create the database when it's run. Or would the user have to connect/create the database in their IDE so they can run the scripts? Edit: and good spot on my IDE junk I had checked in :( 
Yeah had a look at going to log4j2 and as I have done the configuration in the code, it seems to be rather different when compared to 1
Maybe extend the program a little; the creation of the schema and tables shouldn't need to be something done by the end user Ideally it wouldn't be a manual task before the program can be compiled/tests run either, but that is more acceptable than getting users to do it. There are, of course, ways to get around this too (but for now I'd recommend concentrating on getting it to a point where users don't need to run sql by hand)
This isn't really java per se
Yes I know about UUID but completely random 128 bits ID may become a hurdle to index for a database. This gist is not meant to replace or to be a better and safer alternative to UUID but a lighter, simpler and good enough alternative for some projects. Another advantage is that 64 bits databases can leverage Long data types natively. I based this implementation on this old article about the cost of pure random GUID and the proposed COMB alternative implementation. See http://www.informit.com/articles/article.aspx?p=25862. Either way, thanks for taking time to comment my link.
Makes sense, thanks
The use of current time shifted left by 16 bits insure an incremental id is generated every time, except when the counter is rolled back to 0 if an ID is requested in the same millisecond. The advantage of an native type incremental ID is a performance gain for the database upon insertion. This generator is 100% safe when used within the same process.
OP wanted to learn ONE technology. Java. Throwing in tons of other libraries makes life hell for learning.
I know people say not to check in your IDE files.... but just ignore them if you use a different IDE, and if you use the same one, then the person using your repo has EVERYTHING they need. Seems like a win for someone on the same IDE.
Many others but mainly using Javascript because of frontend development.
The appellate rulings did address the JLS APIs, but you don't have a source backing up the point that these were excluded from the SCotUS ruling.
The supreme court hasn't *made* a ruling, they've declined to hear the case haven't they? Pretty much everyone involved - including all courts which have heard the case so far, Oracle, and Google - agree regarding the use of those packages...
It has been with us since 7th grade Edit: I mean Version 7 of Java
Did you mean Java 7 instead of 7th grade?
After that benchmark came out, some guys did an appender for Logback based on the LMAX disruptor https://github.com/reactor/reactor/tree/master/reactor-logback 
Yes
very cool. It looks supremely well-defined in whiteboard and documentation. Let me forward this to my group's super senior architect-who-does-not-code.
So I came to Java with about a decades worth of software engineering experience and the first little pet project I took on and had fun with was implementing a graphical version of the towers of hanoi. It was a fun little thing to do and i was able to quickly do it and also keep enhancing it with additional features. Its amazing how even a small application like this forced me to touch so many aspects of java from threading to learning about java 2d graphics programming. Its been my experience that when learning a new language its better to take on a relatively simple problem but one that forces you to touch many different aspects of the language as possible. 
If you are really keen on learning more look into entry level courses on Coursera. I was going to suggest one of the Oracle Java certifications, but I'd suggest getting a little more practical experience first.
This is pretty cool! I'll look more into coursera, thanks!
iOS app development would be great (from what I know, seems a lot easier than android for new developers), but I don't have access to a Mac :( Android is the next best thing, so I think I'll look into that. Thanks for the advice!
Learn some functional programming with Scala. Languages like Scala and Apple's similar language Swift are gaining in importance. Scala also has excellent integration with Java code. You may find that it enhances the way you think about Java. Give it a try. Mark Lewis has an extensive series of video lectures on Scala. See https://www.youtube.com/user/drmarkclewis Another course, though I don't know when he'll offer it again, is: https://www.coursera.org/course/progfun 
First of all I would say if you want to get better... code code code. That is always a good way to get better. Even if it seems trivial it can probably help. For example, I started at places like: * http://codingbat.com/ * http://projecteuler.net/index.php?section=problems&amp;page=1 IMO, I think it's best to try to understand the principles of programming without being stuck on one implementation. Then you can find languages that you find "fun" and stick with those. Like ohmzar mention Coursera is a great resource. One course I would recommend is "Algorithms, Part I" which focuses more on algorithmic thinking rather than the Java implementation. Finally, if you do find that you like Java [like me :) ] then I would recommend two books which I consider essential: 1) Thinking In Java by Bruce Eckel 2) Effective Java by Joshua Bloch Good luck!
Small point, but you override the toString method, not overload. That is something different.
128 bits.
Start with PSVM.
You're welcome!
Maybe it's just me, but I can't understand this article. A project with complete classes and test cases could help to understand.
i removed the global variable and shorted the readLogFile and readGZFile together, but now i think the try-with-resources is not applicable anymore. however i'll have a look later next week again. :) 
Here's a runnable example. Prints quack/waddle twice http://pastie.org/10335288
Only because the Anon interface is compatible with an identity lambda. You could use any other FunctionalInterface in place of Anon and it would still work
hmm i was not aware of this... any ideas how to overcome that?
Since I already use SLF4J for everything, I hope this won't be too painful. However, at work we depend on some custom appenders that we've written - they feed WARN and ERROR messages into our production incident reporting system - so I don't know if that's going to be a problem.
Good to know, thanks! Maybe we will give it a second look then.
i added now gradle and logging
So by casting into interfaces can you add methods at runtume?
Whoops, sorry, we weren't using Spring. Just looked at the commit history, and here's our bean as it was: &lt;bean id="writeDataSource" destroy-method="close" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;property name="driverClassName" value="org.postgresql.Driver"/&gt; &lt;property name="url" value="#{ 'jdbc:postgresql://' + @writeDbUrl.getHost() + ':' + @writeDbUrl.getPort() + @writeDbUrl.getPath() }"/&gt; &lt;property name="username" value="#{ @writeDbUrl.getUserInfo().split(':')[0] }"/&gt; &lt;property name="password" value="#{ @writeDbUrl.getUserInfo().split(':')[1] }"/&gt; &lt;property name="initialSize" value="2"/&gt; &lt;property name="minIdle" value="3"/&gt; &lt;property name="maxIdle" value="3"/&gt; &lt;property name="maxTotal" value="8"/&gt; &lt;/bean&gt; It wasn't respecting the minimum idle connections, and would drop back down to zero. Then, when initiating a new connection upon a request, it would sometimes take up to 8 seconds to create a new connection. Hosting an API, this was completely unacceptable. This is our current one: &lt;bean id="hikariWriteConfig" class="com.zaxxer.hikari.HikariConfig"&gt; &lt;property name="dataSourceProperties"&gt; &lt;props&gt; &lt;prop key="serverName"&gt;#{ @writeDbUrl.getHost() }&lt;/prop&gt; &lt;prop key="portNumber"&gt;#{ @writeDbUrl.getPort() }&lt;/prop&gt; &lt;prop key="databaseName"&gt;#{ @writeDbUrl.getPath().substring(1) }&lt;/prop&gt; &lt;prop key="user"&gt;#{ @writeDbUrl.getUserInfo().split(':')[0] }&lt;/prop&gt; &lt;prop key="password"&gt;#{ @writeDbUrl.getUserInfo().split(':')[1] }&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="readOnly" value="false" /&gt; &lt;property name="poolName" value="writePool" /&gt; &lt;property name="maximumPoolSize" value="10" /&gt; &lt;property name="dataSourceClassName" value="org.postgresql.ds.PGSimpleDataSource" /&gt; &lt;/bean&gt; I'm leaving out some ancillary connection information, but if anyone needs some more reference, please reply and I'll share the rest.
I love it, thanks.
What is the deal with people checking not only _libraries_ into git but their release jars, too? Damn. I actually just recently helped a repo switch from that model to using the Github releases mechanism and it slimmed their repo from 20MB to 3. *Update*: as a point of reference, I checked and this `.git` repo is **526M**. Ho-le-sheeeeeeet. 
Ah right. Overloading would be where the method has a few different declarations based on arguments, right? just used wrong word. bleargh
I think this is the more or less standard / "correct" way to do this. 
To be really pedantic, most of these tips for for configuring a spring boot *web* app. The basic Spring-Boot starter POM (`spring-boot-starter`) has no web features. 
Happy cake day!
System.exit(1)
The banner **should be** ick. So that it *really* hits the eyes of people. Yet, people still ignore it plenty of times. If anybody can come up with a better CSS, post it.
It functioned perfectly yesterday. I've tried removing and re-adding it to the exception list, to no avail.
You could get some inspiration from /r/Ooer
Yes! GREAT IDEA!
Yes. And Ceylon. And JavaScript, if you insist. And Xtend. And everyone else. But not Java :)
This subreddit is about java as a programming language / software development platform, not trouble-shooting IT issues, particularly for an OS that Apple end-of-life'd early last year.
&gt; And JavaScript This doesn't make sense in the context of a dynamically-typed language, does it? 
Why not? Check this out: if (typeof a == 'string') alert(a.length); No cast needed ;)
That's because it's for Javascript, that well known Java implementation.
Please accept my most sincere apologies.
Some subreddits make me feel like I'm back on myspace. Default style all the way.
Is there a reason you are refusing to do it the standard way using JAVA_HOME?
My apologies, I thought that would have been implicit. I'll clarify that in my OP. To respond: yes I am working on a RESTful API and webpages that access that API, all of which is in Spring. Edit: correction actually, I just remembered that we're using Angular on the front end to access the API data, so all I really need is to be able to make RESTful APIs with Spring and Mongo.
Thank you! Installed. Let's see if it has more effect ;)
.Net has nowhere near the ecosystem that Java enjoys. The popular scripting languages have competing ecosystems though.
So, Java now has structural typing even if the EG did *"everything"* to avoid it. Oh my... Tons of fun :) (and excellent discovery!)
Yes. A lot of people is lazy or not mature enough to explain why they disagree. This is common.
If it was somehow magically applied and could tell you which variable was null when an NPE was hit, sure. Beyond that, I'm not sure I can see it being worth the effort...I mean it's a non-offensive feature, but unless I'm missing something it seems like a shiny gimmick rather than anything overly helpful.
By default I wouldn't suggest such a feature as it's just not neccasarry. Keep it simple. But Java already has some great build envirnoments like manve or gradle. A plugin for such a debug feature would defenitly be nice.
Question: Why not just write public void aMethod(String aParam) { throw new NullPointerException("aParam"); }
Doesn't seem to be very useful to me. I'm not objecting really, but why would one need this? Example: A method outputs a debug text like "Variable aParam smells of elderberries." - the only possible use I can imagine for nameOf() now is this: The name of the variable got renamed, so the texts need to be changed, too. Is that what you have in mind? If yes: IntelliJ IDEA's refactoring by default renames String literal instances of names, too, so the variable would be renamed inside the debug text, too. It's not solid, of course, but it often works. With nameOf() this could be made solid. Or what else do you have in mind?
This. I don't understand the point of nameof.
If you rename the variable, you'll have to manually edit the exception message. With nameof(), this can be done automatically by the IDE.
Four spaces before each line of code: View Source to see Note that all lines of code must be preceded by four spaces
Ctrl-R, Ctrl-R, type in new name, click OK. That was so hard. I'd like to make a quick point that if you changed the name of the variable, _you'd have to change whatever was inside the Exception **anyway**_.
&gt; I'd like to make a quick point that if you changed the name of the variable, you'd have to change whatever was inside the Exception anyway. Many IDEs will do that automatically, but won't pick up on references in strings (for obvious reasons).
Java since 8 has a -parameters compiler flag that makes the parameter names available at runtime through reflection, so although you can't do exactly your example you can do benji@lcars:~&gt; javac -parameters ./NameOf.java benji@lcars:~&gt; java NameOf Exception in thread "main" java.lang.NullPointerException: aParam at NameOf.aMethod(NameOf.java:8) at NameOf.main(NameOf.java:5) Parameter now has a getName(). Here's a runnable example. You'd need some work to support methods with more parameters and cope with other things that mess with stack traces. import java.util.function.Consumer; public class NameOf { public static void main(String... args) { new NameOf().aMethod(null); } public void aMethod(String aParam) { throw new NullPointerException(nameof(this::aMethod, 0)); } public static &lt;T&gt; String nameof(NewableConsumer&lt;T&gt; method, int arg) { try { StackTraceElement caller = new Throwable().fillInStackTrace().getStackTrace()[1]; Class&lt;?&gt; cls = Class.forName(caller.getClassName()); return cls.getDeclaredMethod(caller.getMethodName(), method.type()).getParameters()[arg].getName(); } catch (Exception e) { throw new RuntimeException(e); } } } interface Newable&lt;T&gt; { Consumer&lt;T&gt; consumer(); static final class DummyType { private DummyType() {} }; default String className() { try { consumer().accept((T) new DummyType()); throw new UnableToGuessClassException(); } catch (ClassCastException e) { return e.getMessage().replaceAll(".*to ", ""); } } default Class&lt;T&gt; type() { try { return (Class&lt;T&gt;)Class.forName(className()); } catch (Exception e) { throw new UnableToGuessClassException(); } } default T newInstance() { try { return type().newInstance(); } catch (Exception e) { throw new RuntimeException(e); } } class UnableToGuessClassException extends RuntimeException {} } interface NewableConsumer&lt;T&gt; extends Consumer&lt;T&gt;, Newable&lt;T&gt; { default Consumer&lt;T&gt; consumer() { return this; } } 
IntelliJ will ask you if you want to rename text occurances of the variable name when you rename the variable
Can you give an example of this? It's not very clear to me.
Personally I don't think this feature would be big improvement. However, I think such argument above is either arrogant or very misguided. Similar to "is it so difficult to cleanup memory manually?" or "why we need static typing, you can just Ctrl+F". First of all, funny that such argument is often made by people who are supposed to be automating things and supposed to understand value of automation. Secondly - every manual step increases risk of introducing new and also increases overall amount of introduced issues. From my experience - there are always issues with logging incorrect class/method names that were not changed when renaming. Renaming often happens when class wasn't even opened. 
It's not so much casting, more like type assignment. `i-&gt;i` has no type, it will be either inferred from the context, or assigned manually using the cast operator. Java will then create a new class for the lambda, which satisfies all the constraints. `(X&amp;Y)i-&gt;f(i)` will create a class that for all intents and purposes looks like this class $lambda0001 implements X, Y { // implementation of the only abstract method public &lt;return type&gt; &lt;name&gt;(&lt;param type&gt; i) { return f(i); } } This class obviously gets all the default methods from X and Y as well.
Not necessarily. I tried: public class Duck { public void quack(){ System.out.println("Duck quack"); } public void waddle() { System.out.println("Duck waddle"); } } and with((Duck &amp; Anon &amp; Quacks &amp; Waddles) i -&gt; i, ducklike -&gt; { ducklike.quack(); ducklike.waddle(); }); failed to compile: Error:(41, 47) java: incompatible types: bad intersection type target for lambda or method reference component type Duck is not an interface
Because enterprise-y standards catering to large teams of low skill developers.
Be fair, Swing apps don't run well anywhere.
Alright well good thing Java is my primary programming language haha, any specific tutorials for MVC you prefer? 
My comment was meant to be sarcastic. Swing is terrible, as is most of java.
Sure, but to be safe developers still need to check manually if the IDE really renamed exactly the occurrences it was supposed to and nothing else. However, due to human nature developers will get sloppy with their manual checks if the automatic renaming works as it should 99% of the time. The 1% of the time where it doesn't quite work as it should, there's a good chance they won't notice it.
Without jumping on either side of the bandwaggon, being the most searched is not necessarily a good thing. https://www.google.com/trends/explore#q=java%2C%20c%2B%2B%2C%20javascript%2C%20html%2C%20css I suspect a major reason search volume for Java is huge is because a huge portion of Java programming is "use a library" is so popular in java.
How do you measure the problematicity of a language? &gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses.  Bjarne Stroustrup, The C++ Programming Language 
I'm assuming this is cause its usually the first language taught in school to computer science students (lots of questions would come up), as well as being the language people recommend to others who want to learn programming (alongside Python).
"How to uninstall Java" ;)
The one we use is an intellij feature, if you write this: public void f(@NotNull final String s) { ... } The compiler automatically inserts a null check, something like the following: public void f(@NotNull final String s) { if (s == null) { throw new NullPointerException( [sensible error message]) } ... } It also works on return types, fields, variables,... And the IDE uses it while performing static code analysis while you're typing, so you get immediate feedback if you violate the contract.
I believe that many people who search the Java programming language are just trying to install or update the Java Runtime Environment and not the Development Kit. Common queries are: * java * download * java download * java games * string java * java game * flash 
Got in trouble more than once because of that. I renamed a method from "match" to "matches" and it went on to suggest 1k replacements in the java docs of many unrelated classes, including other modules. If you are too quick to press the "do refactor" button you might end up with a lot of crap in modified code and will have to review all files, one by one, to keep changes made earlier.
This would add a huge load of bloat. The `nameof` operator just becomes a string constant upon compilation.
In my opinion that's a lazy ass approach that produces unclear error messages. I rather prefer to generate a descriptive message. I like to include a description of the parameter, not the name itself. I also prefer to build my own utility classes for validation as Null checking is rarely enough (I'm on my mobile - hopefully the code will be displayed properly): For example: public void selectFields(String entity, List&amp;amp;lt;String&gt; fields){ ArgumentChecks.notBlank(entity, "Name of entity"); // will throw an illegal argument exception with the message "name of entity cannot be blank" ArgumentChecks.notEmpty(fields, "selection of fields of entity {}", entity); // another illegal argument exception will be thrown, saying "selection of fields of entity 'blah' cannot be empty". ... } This is much more versatile and helpful in my opinion.
Well I would say major portion of those Java searches comes from [people looking for JRE installer](http://i.imgur.com/oBT5S6R.png)...
http://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.3
&gt; I think You forgot to add /s ... probably, depending what does /s mean...?
Why is HTML on this list?
isn't that the only time to browse reddit?
Please stop submitting your project over and over and over again. All of your Reddit submissions (edit: minus one) are about SimpleFlatMapper. This is considered spamming.
As someone who uses java to write Minecraft server plugins... Oops
Thanks for contributing to the problem
THIS. There's no need to add keywords like C# which are only added to break .net compatibility - again. 
It's kind of interesting the top comment and bottom comment are basically the same joke. Have an upvote
All of them.
In what way? It has its quirks, for sure, but it's a solid language with terrific tooling and library support. 
"Software Technologies"
Docker?
Didn't know webpages counted as software.
I don't know if I'd get it this title. I'd say 50-60% of the people searching for java just need to download it so they can play Minecraft (or some other application) :P
Thank you. Without people like you, many many people would be stuck playing vanilla Minecraft. And that gets boring or even annoying.
&lt;3
Intersection types have been around since Java 5 for generic type bounds, but they were allowed in casts starting in Java 8. The main purpose is to provide a target type for a lambda expression that is allowed to "mix in" Serializable. This is how you can opt for a lambda to be serializable, when none of the provided functional interfaces are serializable. See https://bugs.openjdk.java.net/browse/JDK-8002099 .
You can also annotate your class with @RestController instead of @Controller. Then you can leave out all of the @ResponseBody annotations.
The main issue is that there probably aren't "millions" of java developers who are knowledgeable enough to contribute in a beneficial way. People can already contribute and discuss features using JSRs, but your average dev simply doesn't have the background to do so.
Exactly this. The people who do know what they are talking about and doing have already found their way into the process. 
There is a [Java Community Process](https://www.jcp.org/en/home/index) to vote new Java features. There are [many Java User Groups around the world](https://jcp.org/en/participation/JUG_list) who joined the Java Community proces.
Mine is "what's the Java_opts debugging parameters" too long to remember
The toString example may have been a better one to lead with than the NPE example. Although others have cited IDE name-replace, there's always the chance it replaces a value in a string where the word just happened to be the same as your variable name, so removing that possibility's also a bonus. I still don't see it as a killer feature (not that you're selling it as one) which would be worth dedicating dev time to, when there are other areas of the core language which would benefit more from the investment.
[Reddit Enhancement Suite](http://redditenhancementsuite.com/) 
The JUG list seems to be ancient. I tried both of the Indian JUG websites and was directed to some unrelated websites. (The domains probably expired and are now being mis-appropriated). So although there has been some effort at community / process, it might not be as active as it seems at first glance.
Yes, I would totally appreciate such a community website. Although there are formal processes in place, I think there is an opportunity for some informal community discussion and feedback to happen prior to a formal proposal. In that light, uservoice is not appropriate IMO (because it is very simplified and biased towards end-users), but something like discourse would be fine. The web-standards community has recently started using one such site: http://discourse.wicg.io/ There are a lot of proposals there that get whetted between web-developers and browser-developers, and the good ones are then picked up for further work. Would be great to see something like this in the Java eco-system. In fact I think it is essential if Java has to stay relevant in the ever changing landscape.
[Google Trends](https://www.google.com/trends/explore#q=%2Fm%2F07sbkfb&amp;cmpt=q&amp;tz=Etc%2FGMT%2B7)
I use Java VisualVM. Can anyone suggest when (or whether) I should prefer Java Mission Control? 
That's because bunches'o ignants need /r/JavaScript help for their websites. Sorry ladz.
Another aspect of user voice, how to participate in the OpenJDK? Their bug tracker does not allow new account creation except for contributors, preventing watching and voting on issues such as: https://bugs.openjdk.java.net/browse/JDK-8030048
Maybe a mailing list like this could do: http://mail.openjdk.java.net/mailman/listinfo/jdk9-dev
[**@JugRoma**](https://twitter.com/JugRoma/) &gt; [2015-08-09 18:22 UTC](https://twitter.com/JugRoma/status/630444176883236865) &gt; @jcp\_org from Reddit they are asking an informal way to vote and discuss features https://www.np.reddit.com/r/java/comments/3gb49f/i_think_we_should_ask_oracle_to_create_a_user/ ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
We could distinguish two things: * knowing what could be improved and useful, which requires a middle or senior programmer; * knowing **how** to improve Java compiler and the JVM. This requires a huge knowledge.
http://mvnrepository.com/artifact/com.puppycrawl.tools/checkstyle/6.9
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Zest
Java is used for pretty much everything. Twitter and Google use Java heavily. So do probably 75% of enterprise IT departments. A lot of server-side web dev, some desktop apps, most Android apps. You name it.
Looks promising! Nice and neat UI. Good job 
I agree, thanks for the contribution. I'll have to install it and play with it a little when I get some time.
Well, I didn't expected to be posted here, author of the program here, if you have any questions, feel free to ask :)
Does it integrate with the Jira API?
At the moment not, but it's on the roadmap. edit: What kind of integration would you need?
Can it be self hosted with no auth providers?
Ok, I see, so full synchronization between lavagna and jira. This could be fun :).
With some of the shit I see on here and the other programming subreddits, I'd be kinda afraid of letting the community be too involved.
I'm a Lavagna dev and I work behind a firewall too, is there a reason to avoid LDAP / Active Directory? I used them successfully and without pain. Beside that a simple username / password auth in order to simplify a deploy is a great suggestion, thank you.
Last of lavagna devs joining in. By any chance, give it a try. /u/syjer wrote a nice guide on how to quickly deploy it on a free openshift gear: http://lavagna.io/help/openshift/ Btw, you can import boards and tasks from Trello too :)
You hammer yours out of solid blocks of granite? 
Why do you need it to be maintained? I still use jtidy, and that library hasn't seen an update this decade. 
Yes, it's one of the goal to provide a nice synchronization api :)
Jsoup.org
Thanks! How does the event emitter and message sending works?
are you kidding me? https://www.reddit.com/r/java/comments/2k7xzi/static_linking_in_osgi/ https://www.reddit.com/r/java/comments/2k4dk6/high_performance_libraries_in_java/ https://www.reddit.com/r/java/comments/2jy7x3/a_new_way_to_avoid_sql_in_java/ https://www.reddit.com/r/java/comments/2kgg6a/how_to_get_into_java_web_development/ https://www.reddit.com/r/java/comments/2kp8n3/what_are_your_opinions_on_apache_wink_jersey_and/ https://www.reddit.com/r/java/comments/2on7yt/whats_so_great_about_lamdas/ https://www.reddit.com/r/java/comments/3ebvzv/which_one_is_faster_in_java/ Most of the rest where under javahelp. Anyway that's fine. I don't get any money and dont sell consulting so. And got a job to do on the side.
Leave it to English not being my mother tongue ;-)
I'm sorry, but I'm not aware one any remarkably good resources. I would pick some really simple example how to do a CRUD application with Spring MVC. I believe you can find one that uses Mongo too.
Why did you add Alpha5 to the title?
Small in-joke ;) JBoss WildFly is the alpha/beta for JBoss EAP. Every WildFly release, even those marked "final" are alpha releases in the parallel EAP numbering. In the running up to EAP 7, there have been 5 WildFly releases with major version numbers; 8.0, 8.1, 8.2, 9.0 and now 10.0. Since each one is internally an alpha for EAP, I numbered them sequentially; JBoss WildFly 10 == Alpha5, JBoss WildFly 9 == Alpha4, etc. So a beta version of WildFly corresponds to a beta version of an alpha version in the somewhat peculiar 2d version numbering that Red Hat had adopted. 
How it compares with [Phabricator](http://phabricator.org)? 
I dont think they are really comparable (I've never used phabricator, so this is only an impression). Phabricator cover much much more of a project lifecycle. I think that trello or jira are more comparable to lavagna :). 
I don't need it to be, but if there's a well-maintained alternative to it, I would very much prefer that. I just moved to Java, so I'm not aware of the popular libraries out there; this is my own way of learning :)
I have to learn Spring for a new job myself. Their site seems to have some quick, straight forward guides: http://spring.io/guides
IMO one of the strengths of Java is the compatibility - both backwards and forwards. You can run code you wrote in 1999 on modern JVMs most of the time without modification. It's not a bad thing for stable libraries that do a single thing well. One other library you could use is JSoup, especially if you're coming from a frontend position.
&gt; Ok, I see, so full synchronization between lavagna and jira. This could be fun :). It would be awesome if it autolinks any reference to a Jira ticket.
Hence the split to Wildfly.
I've been using jtidy to create a DOM tree, then using XPATH / XSLT to query and transform it; have no idea if jsoup can do that. 
I'm going to propose that you learn a lightweight java server plus a good SPA framework for a javascript front end. There a number of possible combinations that might be used for this: Backend: Spring Boot or Dropwizard. Front End: Angular ( There are other's but I'm not familiar enough to personally recommend).
 static &lt;T, E extends Throwable&gt; T invoke(Nonchalantly&lt;T&gt; f) throws E { try { return f.run(); } catch (Throwable e) { throw (E)e; } } No wrapping needed!
Right, that too.
Non-Mobile link: https://en.wikipedia.org/wiki/Program_evaluation_and_review_technique *** ^HelperBot_ ^v1.0 ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^6654
This is very important, you never want to catch Errors. The code as posted is dangerous. According to the specification it is not (nescessarily) possible to recover from an OutOfMemoryError for example. 
This should never be used. Even if you "don't care" about the checked exception you should understand the contract of the method on why they are throwing it. You can then wrap the class to transform the checked exception to a runtime one AFTER you have satisfied the contract of the method. The method may need you to clean something up when exceptions are thrown 
Fixed, thanks both.
The London and Brazil JUGs are very active.
Or you can just nonchalantly do what the **** you want, because having to handle an XPathLosingMyShit exception when you pass a *constant* XPath expression that you *know* to be valid to XPath.compile is just ****ing lame.
I *did* write an adapter for a bad api. It's the class linked above. Works for all of 'em.
Here's some code: public static Object someMethodThatThrows() throws IOException { return null; } public static void main(String[] args) { try { invoke(Nonchalantly::someMethodThatThrows); } catch (IOException e) { } } This doesn't compile because I get an "Unreachable catch block" exception. I'm using the eclipse Java 8 compiler, which isn't always 100% compliant. Is the bug that I'm misunderstanding your response, or does ECJ have a bug?
A while ago I tried to emulate Scala's `Try` in Java to wrap code that throws checked exceptions and allow `map`, `flatMap`, `filter` etc. Try.doTry(() -&gt; ...).map(...) https://github.com/charithe/functional-java-plus 
There are times you really actually don't care. For instance the closeable interface throws a checked IOException and if you implement closeable you have to declare you throw it even if you never do. XPath as codepoetics is another great example of needless code bloat from checked exceptions. 99% of the time the only sensible thing to do in the case of a close failure or an xpath exception is to abort mission with a RuntimeException.
I work for one of the big aerospace firms in California as a Software Engineer and what you didn't specify in your question is if you are a recent college graduate or someone with more experience who is now learning Java. If you are a college graduate then our expectation for someone coming into the company is not so demanding in terms of knowledge of frameworks and design patterns. We like the person to have strong foundation in Computer Science and know a language reasonably well. It is a great bonus for you to have experience with Design patterns and/or Frameworks but it is never required and we usually give new grads plenty of opportunities to learn the specifics of the work they will be doing as almost universally you will first start off working on a preexisting system doing some type of software maintenance. Our company does do a pretty decent job employing paired programming and providing access to courses that help you come up to speed in the specific area you will be working. Now if you are coming as a more senior developer then definitely the expectations are much higher and having a good foundation in all the above things really helps. We have specific groups that deal with HMI vs backend, vs database vs external interfaces and If you can figure out the type of work your strengths lie in, that helps a lot to. 
I found a few, but I was really confused since they left out a lot of the moving parts that are needed or aren't thoroughly explained. They certainly helped though
It is probably not obvious to everyone that when you interact with a java.nio.file file system directly, although you lose the ability to "mock" or "stub" in the *usual* manner, you still have the ability to "fake" using Jimfs or I suppose this TestFS. Depending on what you're doing, it may be just as good and cut out the need for more layers.
Ah yes, you won't be able to catch the `IOException` explicitly like this. But you can't do that either if you wrap it inside a `RuntimeException`. But If you really must catch an undeclared `IOException` explicitly (although that kind of goes against the title of this thread), you can still do something like this: public static &lt;E extends Throwable&gt; void mayThrow(Class&lt;E&gt; clazz) throws E{ } public static Object someMethodThatThrows() throws IOException { return null; } public static void main(String[] args) { try { invoke(Nonchalantly::someMethodThatThrows); mayThrow(IOException.class); } catch (IOException e) { } }
Any book in particular? I ordered spring in action from Manning books. I couldn't find another current book.
Isn't that exactly the point? That invoke doesn't `throws IOException` anymore, but `throws RuntimeException`?
This is very well named. I can't think of any other interfaces with adverb names. 
Wow, that is very quality response. Thank you very much. And no, I don't have any experience with Java nor other programming languages, apart from basic knowledge.
https://gist.github.com/poetix/e95d562192994ab3f3da
Exactly. I thought (because it was throwing a generic E) that the author misunderstood how generics worked on exceptions. In actual fact, the author understands this much deeper than I do. However, this code relies on (imo) a tricky subtlety that changed between Java 7 and 8, so I prefer [something more explicit](https://github.com/diffplug/durian/blob/v3.1.1/src/com/diffplug/common/base/Errors.java?ts=4#L280-L296).
Obviously explicitness and readability wins over clever tricks any time. (except in performance-critical code where it is well documented why the "cleverness" was chosen) I thought this post was just to show off a weirdness of Java, with which it succeeded.
If they call it thru the interface. But you don't need to declare it in your implementation. Closeable is a good example, extends AutoCloseable and narrows the exception thrown from Exception to IOException.
Another example is StringBuilder implementing Appandable (removes IOException declarations completely)
I can see how it could be confusing but it makes sense to me. Any suggestions?
There's a whole number of problems in Java compared to other languages. Pervasive mutability makes it difficult to reason about code as it's difficult to guarantee what the scope of a change will be. This is especially problematic when dealing with threading or writing large applications where you wish to be able to compartmentalize things. With Java the burden is squarely on the developer. A great video discussing that [here](http://www.youtube.com/watch?v=VSdnJDO-xdg&amp;t=32m32s). Java lacks expressiveness. This means that it's difficult to abstract things and make DSLs that express your problem domain. This translates into writing more repetitive code by hand. The object oriented nature of the language creates further problems. By marrying code and data together you actually make code reuse more difficult. If you write some methods in one class and you then need to use those in a different one you have to start creating inheritance hierarchies. By contrast when you have a small number of data structures that all functions operate on you can compose them any way you like. This way you have code reuse at function level. To quote Alan J. Perlis: "It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures." This also means that you have to do null checks everywhere, since if you're calling a method on an object you first have to check that it exists. In a functional language this problem doesn't exist. Comparisons of data are again made unnecessarily difficult due to mutability. In a language with immutable data you can always compare any two data structures by value, even if they're nested structures. In Java you have to manually write comparators and handle null checks for any nested structures. 
But aren't these useful tools? For example, this is about something that lots of Java devs would live to have in their toolset.
Can you provide some information about the licence of your framework? I have not found any information regarding this topic with a quick view onto the page...
It's in the footer. Easy Batch is released under the terms of the MIT license. This information is also available on the github page of the project
you made my day! :)
Seems to be a bad URL, but [this one works](https://jstaffans.github.io/2015/05/21/clojure-spice.html).
I don't know why but I just can't enter a race, already logged in and still it tells me to login :( Does anyone have the same problem?
Determine if you prefer Eclipse or IntelliJ.
Never mind missed the section on that :)
Thanks for the response! Yeah, I did the login part with the popup window, but once logged in I just see the FB top bar and the rest is in blank, like no response at all. So I just close the window and the error pops up telling me that something went wrong. The thing is that if I close Eclipse and reopen it again, I appear as already logged in with my correct username without doing nothing. I proceed to race in the server (EU - username: edgraq12) and it tells me to login when apparently I'm already.
Yay ! Like that post, and I apply everything *apart* for number 3 which basically is trying to predict the next decade. And you know that the language might have changed so drastically after 5 years that it looks not only overkill, but also over-engineering to me. On a real life basis though, the 'constant before lvalue' rule #1 is a real life saver. FTR, C coder for 30 years, java for 17, python fo 15, and haskeller for 3 years
For the modern web browser doing all presentation in JavaScript (preferably TypeScript) makes a hell of a lot of sense. Just in case anybody is confused, the backend services not related to micro service aggregation or rendering are still all Java.
I'd personally rewrite #5 as 'default to apache collection and string utils for checking stuff. It is much easier to read CollectionUtils.isNotEmpty(myCollection) than having multiple tests inside your conditional.
Upvote because the author used a quote from "Dude, where's my car?" :-D 
I'm at the point now where I use Eclipse specifically to piss off people who use IntelliJ, because people who use IntelliJ seem to be the only ones who give a shit about which IDE you use. You're like the Apple users of IDEs.
That was a coincidence, then. Cheers, the author
Makes sense, Java is excellent at serving content, but not necessarily creating it. Combine that with the fact that computers now are pretty powerful on average and this system is pretty useful for a company with as much traffic add Netflix. 
And here I am on Netbeans
Java Anonymous
Wow! So many buzzkillers here  Keep cool man, of course the content is excellent - but sometimes one should be allowed to bring in some fun too, right? 
Surely #5 is redundant if you don't ever use null collections as a (pointless) optimisation for empty collections. Otherwise why end there - surely it's no different to suggesting one checks for null with every object before you call a method.
&gt; #4. Avoid the accidental assignment &gt; &gt; Yep. It happens to the best (although, not to me. See #7). &gt; &gt; (Assume this is JavaScript, but lets be paranoid about the language as well) &gt; &gt; // Ooops &gt; if (variable = 5) { ... } &gt; &gt; // Better (because causes an error) &gt; if (5 = variable) { ... } &gt; &gt; // Intent (remember. Paranoid JavaScript: ===) &gt; if (5 === variable) { ... } &gt; &gt; Again. If you have a literal in your expression, put it to the left side. You cant accidentally go wrong here, when you meant to add another = sign. Does this make sense in Java? `variable = 5` is only legal if `variable` is `int` (or `Integer` or a supertype), and then the expression is illegal as an `if` condition. AFAICT this is only legal if youre comparing with `true` or `false`, and then you can just omit the comparison anyways and use either the expression (`true`) or its negation (`false`).
You are right. For all the bits of C that did get copied, at least they didn't make a non-zero int into a true condition. None of those compile in Java.
Nope, just a bad experience with a bug in the commons collections. If you haven't noticed the bug, check again. It's subtle :)
Would you mind enlightening me about what the actual quote was?
Your link goes to line 1120, which is empty. The next 3 lines however contain the method "removeAll", to which I think you are referring. Although I didn't bother to browse the source of ListUtils, it appears that removeAll(collection, remove) does quite the opposite of what it should do.
Some of these are fine but 6 and 7 make me cringe. It "solves" a non-existant problem I never run into. I've never run into a problem with someone extending my class when I didn't want them to, or frankly even reassigning my variable (except for the ones I actually want non-changeable but those are static final already). I does make fixing bugs a gigantic pain in the ass, as well as adding new functionality, as well as just cluttering up trying to read the code. Now the code starts to read like: *It final "solves" a non-existant final problem I final never run final into.* It's messy, without solving anything that I've found to be any sort of regular problem. If someone is messing in my code that I don't want to be they just remove "final"'s they don't like anyways. 
I hear Larry Ellison and Emperor Palpatine race boats once a month.
Even in C, with all warnings on (which should be the default), the first conditional should generate a "conditional is always true" warning.
Ah, 4.0 has it fixed and they're at 4.1 stable now. Not sure why it's not in Maven central? Did it change coordinates? https://issues.apache.org/jira/browse/COLLECTIONS-349 http://stackoverflow.com/questions/8372576/java-commons-collections-removeall 
Don't trust old APIs? How about don't use them? Stick with `java.nio` for files and `myString.contains("substring")` instead of checking &gt;= 0.
Can you elaborate? I feel the exact opposite, so maybe its familiarity on both our parts.
but what if you or someone else wants to mock out methods on a class later for testing?
Yeah I'm assuming the author doesn't use mocks or stubs. I've seen code like that and it's a bitch to test.
Yeah, the webpage is a bit thin on the details... I was hoping to see a basic setup/example at least.. 
&gt; There just aren't very many good reason to reassign the same variable. 1\. for loop 2\. while loop 3\. Any algorithm at all that calculates or adds anything I take it you don't actually know how to code? This doesn't work: for(int i = 0; i &lt; collection.size(); i++) { "Adding final is a no-brainer" is for ivory tower people who don't write any code. It doesn't solve any actually common problem, all it does it clutter up your code with more unecessary statements that make it harder to read.
...except when null is a valid situation. That should have been clarified in the article.
Hm, I write a lot of java at a rather large company and I try my best to adhere to a "final wherever possible for variables" rule. It saves me many, many pains. Your points are pretty trivially addressed. 1. Use a for-each. If you actually need counting for whatever reason, don't do final. That's silly. 2. While what? While counting? Why not use a for? 3. Examples? I'd argue that a lot of algorithms could be addressed functionally, if speed is non-critical. Another benefit is that everything can automagically be used in lambdas / anonymous classes without any pains (as they're already final). For mutable state, use final objects (references) instead of value types. final methods are overkill unless you absolutely require them, as a previous commenter said, it makes mocks/ testing an absolute pain.
Yep. And at the rate of update of update of platforms like WLS, you can imagine how many applications out there still include 3.2...
You don't mock classes. You mock interfaces. Design for this approach!
I upvoted you. But see, this subreddit and especially the discussion around code quality is *extremely serious*. [This is really important](http://blog.jooq.org/2014/07/25/top-10-very-very-very-important-topics-to-discuss/), and you didn't show utmost respect. Cheers ;)
Better not use Java 4, just in case.
How is it there, in 2002? Just before PowerMock was created, I mean. If you ever going to have one implementation of the interface - you do not need an interface. That is design, not throwing an interface as a facade for every bean!
Just to make sure we're on the same page, final behaves similar to how const does in C++. For value types, that means their value cannot be changed. For reference types, that means their reference cannot be changed. final iterable references can be iterated over without any problems. final List&lt;T&gt; myList = // whatever for(final T : myList) { /* do a thing */ } and final List&lt;T&gt; myList = // whatever final Iterator&lt;T&gt; myListIterator = myList.iterator(); while(myListIterator.hasNext()) { /* loop stuff */ } are completely valid. So, going back to the initial point. The bugs that final has helped me catch are typically re-assignments &amp; never-assignments, mostly through legacy code. Cases like an object having a property that is only assigned in n of n+1 constructors, or reassigned in constructor x that calls constructor y and then does work. For methods, a particular branch was re-assigning an input argument without considering later code flow. Another case, a giant horrific mess was re-assigning the same reference multiple times through multiple branches. If java had C++'s notion of const-ness, as in const data as well as reference, I would be as much of a fan of slathering it everywhere that I could. Yes, in some cases you need mutability. Depending on the work being done, in the case of numerical algorithms, yea, sure, mutate state as much as you need. It sounds as if your work falls into this category. In other domains, the safety gaurantee that no part of the code could possibly be modifying state is a huge maintenance win.
Of course: Look at [google](https://www.google.de/search?q=a+device+whose+mystery+is+only+exceeded+by+its+power&amp;oq=a+device+whose+mystery+is+only+exceeded+by+its+power&amp;aqs=chrome..69i57j69i64.212j0j7&amp;sourceid=chrome&amp;es_sm=93&amp;ie=UTF-8) - you are listed in 10th position allready :-)
An alternative would be to set the @Column annotations on getters, returning a JPA-compatible datetime, instead of the LocalDate fields.
Thanks for *disciplining* me! ;)
Or you can use Hibernate 5.
The rumours about speed will have been about compilation of Scala (and that's gotten a lot better these days). SBT itself is very fast. I've experience bad slowdowns over time with Gradle when coupled with Android Studio, so perhaps that's influencing my opinion a bit.
I agree with you here. If you happen to be using an IDE that's making sure you don't slip up, it's impossible to mess this up. Quite honestly, it fucks with my head to think of something as "if 5 equals x" instead of as "if x equals 5", and just seems plain wrong.
I mean that when I have batch processing to do, I use a gradle script to control the processing. It looks like easybatch has some value to add here, but there aren't any examples for this. Gradle is way more than a build system for java components. It's a way to declare tasks and their dependencies too. For example, at my company, `gradlew docsPublish` does the following things: * make a list of all versions of the software * checkout each version from git, compile that version's docs * link older versions of the docs to newer versions (so old links don't change, but still point to the latest stuff) * upload the whole thing to Amazon S3 for static hosting It seems like EasyBatch has some overlap with a task such as this, but there's no prebuilt infrastructure to make a gradle task which easily takes advantage of EasyBatch's capabilities.
Awesome! What projects use this parser? Also what are the advantages of using this over the jdk compiler and ast apis?
It could've been - I do not usually throw such bold statements around. Next time, then. P.S. I enjoyed Scala references, Scalatra is my framework of choice more often than not. And it is not interface(trait)-heavy ;)
In my opinion, you shouldn't overburden a build tool, whether it's Gradle or Maven, as it leads to hacks and maintenance hell. I use Maven mainly to just get dependencies, compile and package my application into several WARs and JARs and this is very easy to do. But it's tempting to think to yourself: "Well, it could just deploy the WARs automatically!" So you start using obscure or outdated plugins and are tying different stages of development together. It's probably best to let a build tool do what it does best: Build the sources!
I see, gradle is in fact more appropriate to do such processing tasks. But I believe it is more targeted for project management tasks (checkout source code, compile, test, build, publish, etc). Easy Batch is more appropriate for data processing pipelines, think of use cases like ETL operations, data mining, etc.. It is easier to compare it to other batch processing frameworks like Spring Batch or JSR352 than gradle 
I can confirm that Gradle encourage ugly build scripts.
One thing Gradle doesn't have is **archetypes**. This is a very useful feature of Maven.
You don't have to - you can go directly to [ibm.co/coderally](http://ibm.co/coderally) and download the game from there without needing to register on InfoQ's website (although you need to register with them to be eligible to enter in the contest for the prizes at some point). Once you have the game installed you can import the coderally web app from the &lt;install dir&gt;/webapps directory and explore the source code.
Is that still a thing?
Of course the for/while loop is a case, though I would argue that it's a special case because the reassignment is somewhat implicit and it has a well defined (usually small) scope. In any event, I didn't say there were no cases, just that they weren't common. As for cluttering up the code, I don't see being explicit as clutter. Some people argue that explicit types are clutter - generally those people don't use Java. The point of final is that you can look at a variable and know that wherever it is used, you don't have to think about what the value might be. If your IDE can do all the work for you, why not leave some signposts to guide the next guy reading your code?
so you're saying that every class I ever create has to have an interface as well, just so that I can create a mock class for testing? Certainly in some situations that's the right approach but I don't see why you would need to stick with that approach 100% of the time
And to top it off, you'll use the framework better. If you can write your own ORM, then understanding what Hibernate is doing under the covers is a lot easier, and you are in a better position to evaluate different types of ORMs to decide which solution better fits your needs. I've seen Hibernate monstrosities where clearly the original programmers didn't understand how Hibernate actually works, and is full of [programming by coincidence](https://pragprog.com/the-pragmatic-programmer/extracts/coincidence) based on trying random things until Hibernate does what you think it should do.
Camel and ActiveMQ are separate projects, you can use them together though if you like. ActiveMQ does not by default come with Camel embedded, but you can embed it into your broker if you want. Apollo is a message broker written by a lot of the same people and is billed as the "next generation" of ActiveMQ. RabbitMQ is just a different message broker and is not related to ActiveMQ. RabbitMQ is actually written in Erlang. Artemis I'm not familiar with. Edit: Copy edited.
I don't care about any of those features. Maven works fine. 
Camel provides routing logic far beyond what ActiveMQ gives you. &gt; assuming one of our vendors has a REST API. Do I have to write a stand-alone program to, essentially, poll the API for relevant data and push it into a queue for processing? Well first you'd check the list of available [components](http://camel.apache.org/components.html) for Camel. If you couldn't do what you want there, then you could if needed [write your own component](http://camel.apache.org/writing-components.html). Presumably though in this case you could use the [http](http://camel.apache.org/http.html) component with a timer to do the polling though.
The post I was responding to said: &gt; There just aren't very many good reason to reassign the same variable. Don't worry we've got lots of names, I promise you won't use them all up. Other poster is suggesting whenever you need a new value, create a new variable. That's not how most coding works. For the areas where you don't need to reassign, you gain little or nothing by making the variable final because no code was going to try to reassign to it anyways. It's like putting a car cover on a car that's already in a garage every night - it's just a waste against a problem that doesn't happen. But there are a ton of places where you need to modify the variable value when you write code. 
There's also [Apache ServiceMix](http://servicemix.apache.org/), which is Camel + ActiveMQ + CXF + Karaf.
Honestly, they taught all of that in my comp eng undergrad courses. You're trying to exaggerate to make a point, but it does help. That kind of information influences your split second decision making and will serve to improve the quality of your code.
&gt; I think whatever level of abstraction you are working at, you need &gt; to understand enough about what is being hidden from you to &gt; know the constraints you are dealing with. That's exactly what the article is saying. The "every programmer should learn assembly" statement is an analogy. Actually, the article goes further. The point at the end is YAGNI applied to frameworks. Don't use a framework until you've proven that you need it. And don't buy into a big framework (like Hibernate) if you've proven that a small framework (like Apache DbUtils) is insufficient. If you're doing DB access, start from JDBC (the lowest level of abstraction available in Java) and work your way up. Taken to the extreme, this would mean discovering you are writing a mini-ORM before deciding to invest in a real one.
There are several things that I think SBT does better than Gradle: * The SBT console combined with triggered builds. This makes interacting with the build much more immediate and interactive. Many actions are almost instantaneous. It also gives you tab completion for all of the build tasks and lets you inspect intermediate task results. Gradle is starting to catch up here with its 'continuous mode' but it still has a long way to go. * I think SBT has a much more principled core. I think this makes complex builds in SBT easier to understand. For example, Grails separates the build process in to 'configuration phase' and the 'execution phase'. This results in at least 2 ways to some things (such as copying files). Some times you have to do something in 1 or the other because of when certain information is available. This becomes even more complicated once you start introducing things like 'doFirst' or 'doLast'. For the most part, with SBT, everything runs inside of tasks. I think this makes it much clearer when everything runs. Also, SBT tasks 'return' results. This means you don't have to worry about task side effects occurring in the correct order * Grails core plugins contain too much functionality. A lot of really basic functionality is in the Gradle Java plugin. Since a lot of basic functionality is in the Java plugin, other plugins assume that it is present in your build. Unfortunately, some plugins conflict with the Java plugin (such as Grails and Android). This means that it is more difficult to mix plugins than it should be. SBT gets around this by splitting up its core functionality in to smaller pieces and making it straightforward to swap out core functionality when necessary. * The Gradle ecosystem relies too much on ant. Gradle makes it really easy embed ant directly in your build. The downside of this is that frequently when there should be plugin for some functionality there isn't and everybody just recommends cobbling together something out of ant. For a long time this was the case for aspectj support (it might still be the case I just haven't looked in a while). SBT had a nice plugin. Gradle support consisted of copying and pasting some ant embeded in gradle that broke in a bunch of corner cases. Thats not to say that SBT does everything better than Gradle. However, for the above reasons, I prefer using SBT over Gradle. I hope that was useful or at least interesting. edit: formatting
I can give a rough qualitative comparison between all 3. I'm not sure I know any of the tools well enough to give a comparison as detailed as the one linked. I think of Java build tools as being on a continuum. At one end you have Ant where nothing is preconfigured and have to set everything up with thin wrappers around libraries. At the other end you have Maven where everything is configured for you and if you want to customize you do it with plugins that insert in to your build process. I see Gradle about half way between. Some things are configured for you and managed with plugins and somethings you roll yourself with libraries. SBT is about in the same place as gradle but slightly more towards the Maven side since it seems to favor plugins slightly more than code written around libraries. I think the big difference between Gradle and SBT largely mirrors the differences between the languages used to implement them. Gradle favors making things easy. SBT holds out in favor of more general solutions. This is is mirrored in how Groovy and Scala handle nulls. Groovy added a custom null safe operator '?.' to the language and Scala uses the more general 'Option' type. edit: disclaimer, I prefer SBT over Gradle and Gradle over Maven
According to the video. They are making a new unsafe package, jdk.internal.*, The only way to get values out of it is through the startup flag. For sun.misc.unsafe they are planning on adding a completely different flag to be able to access it (part of the jigsaw thing) but otherwise making it behave exactly the same. In otherwords, 1 extra flag to get at sun.misc.unsafe and 2 flags to get to jdk.internal.* (from the sounds of the video). The ultimate goal was to completely remove sun.misc.Unsafe. However, fear they are (ultimately) making jdk.internal.* just as accessible which will result in the same issues.
They are incomplete by necessity, not by design. If you could test your entire system while still making it relatively easy to change, you certainly would, given infinite time. But none of that justifies using mocks on concrete classes. If you need to mock an implemented method you've either violated SRP or you are pretending something isn't pluggable when it clearly needs to be (otherwise you wouldn't be plugging in the mock). Your code now looks like it operates on a single implementation but it really doesn't.
I guess - I think it helps to understand category theory when thinking about types. That doesn't mean everybody who programs with types should learn advanced abstract mathematics.
My experience has been that Camel not simple to debug. I ended up hating it, frankly.
Are you sure you just aren't being curmudgeonly?
&gt; Just to make sure we're on the same page, final behaves similar to how const does in C++. For value types, that means their value cannot be changed. For reference types, that means their reference cannot be changed. Not exactly though, the difference is in C++ you can pass an object as a value type. For objects really only has "const" for pointers and references. And that's where we get into the problem, using a final object to store you mutable variable is not actually any different than using a primitive. Adding final onto the reference doesn't add anything. But that's the workaroudns you've suggested with this: &gt; For mutable state, use final objects (references) instead of value types. That's trying to cheat your way around the philosphy. &gt; final iterable references can be iterated over without any problems. Because only your reference to the Iterator is final. If all of the instance variables inside Iterator were also final like was suggested, it wouldn't work at all. &gt; So, going back to the initial point. The bugs that final has helped me catch are typically re-assignments &amp; never-assignments, mostly through legacy code. Cases like an object having a property that is only assigned in n of n+1 constructors, or reassigned in constructor x that calls constructor y and then does work. For methods, a particular branch was re-assigning an input argument without considering later code flow. Another case, a giant horrific mess was re-assigning the same reference multiple times through multiple branches. I guess I haven't been working with legacy code that complex or that initially badly written. If it works for you great, but for the most part I suspect more would have been gained when it was written if it followed other better philosophies about writing clear and maintainable code, than declaring everything final. I mostly work on web apps. You're usually just shuttling data between the browser and the database, no one is trying to modify the data to begin with. &gt; If java had C++'s notion of const-ness, as in const data as well as reference, I would be as much of a fan of slathering it everywhere that I could. Yes, in some cases you need mutability. Depending on the work being done, in the case of numerical algorithms, yea, sure, mutate state as much as you need. It sounds as if your work falls into this category. In other domains, the safety guarantee that no part of the code could possibly be modifying state is a huge maintenance win. This week I happened to be working with javascript. About 50% of the variables were looping and counters that had to be mutable, the other 50% could have been "final" if javascript had the keyword but no one was going to be trying to reassign to them in the code anyways. No one is trying to reassign "checkbox5" to another value. I've been doing java development for over 10 years and am often the person cleaning up and fixing others code. That doesn't make me automatically right or anything like that, but it comes from experience seeing the half-baked fads come through. Now I ask myself "can I actually see the problem this is solving". And I can't. I think final everywhere would make it longer to write code, harder to read, and be more of an annoyance for maintenance than a help. Technically any language could make it's variables const by default, and require a special keyword to make them mutable. But I don't know any widely used languages where anyone thought that was really a good enough idea to do things that way either.
If you're talking about the version of Java on the server, don't ever change it without testing. If you're talking about the version of Java on the user's computer, replace all those apps because they use outdated technology.
Java as a language is always backwards compatible. If you're using weird cipher suites, those get deprecated regularly as vulns are found. SSL has been dead for a while.
If you go to the website in the browser and it complains about Java, the java is client side. That technology is outdated.
I agree on all points. For the work that I do, it makes maintanence easier if everything is as immutable as possible for the simple reason that it reduces cognitive load while debugging / adding new features, as the thing you are looking at will only ever be in one state. final is a step in the right direction for this, fully immutable class design is the next.
&gt; And the way they are moving forward sound about right, deprecate in one version when an alternative is available, remove in the next. I don't think that's a good idea with Java. One of the key selling points for me in Java is the compatibility and long term stability of the platform. This change would break both backwards and forwards compatibility.
&gt; It is bad because it locks down the implementation. It is *good* because it *does not* lock down the implementation. If you have users overriding your public methods, then your internal implementation is effectively locked down since any change you make could break someone's overriden method and you have no way of knowing. If there is a problem with the API, fix the API the right way. Which is usually not a problem if the API is well designed and maintained (following principles like "composition over inheritance"). Trying to "fix" a broken API by bubblegum hacking some method extensions is the path to completely unmaintainable code.
I completely disagree. In our codebases everything is final by default (and most methods private static, i.e., pure). If it has not been explicitly intended and designed to change, then it should be final so that the compiler can enforce that. What's "messy" is having everything mutable by default. The possible state space just explodes and it becomes impossible to reason about all the possible cases. When everything possible is final, you know they won't change and the state space is reduced to the few things that actually must change. However, I do agree that it would be cleaner if everything in Java was final by default instead of having to use the final keyword. Then you'd mark the few things that must mutate with "var" or whatever.
Java is the worst language for backwards compatibility, apart from all the other languages which have from time to time been used for development. The problem is most things in software work on the principle of constant pain; for any given practice, you do it until the pain becomes intolerable, and then you change. So a system being better at backwards compatibility doesn't mean you get less compatibility issues. It just means you leave it un-upgraded for longer, rely on a shared install instead of embedding, or skip testing on all potential versions. Java applets are the prime example of this; in any other web-facing language, the idea of something written in 1997 still being used today would be greeted with puzzled incomprehension. But in Java, they are still supported, still mostly work, so they are still out there causing pain to all the IT guys of the world. It's just that the corporations employing those IT guys consider it a tolerable level of pain, so they don't change anything.
He's probably talking about the back-end 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Aggregate data in Java without a database \[X-Post from /r/java\]](https://np.reddit.com/r/programming/comments/3gtwod/aggregate_data_in_java_without_a_database_xpost/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I vastly prefer that approach to method removal. I love being able to dig out some of my 10-15 year old code and be able to run it, usually without problems.
Java 8 is backwards compatible in 99.9% of all cases, so probably not. Never actually used netbeans, but eclipse supports using different JDKs for different projects. So you could have both jdk 7 and 8 installed at the same time.
Thanks. I really need to know about Netbeans as well. Thanks anyway.
The windows installer should hopefully set the environment variables correctly. Afterwards you might have to manually tell Eclipse where jdk 7 is, but this isn't too hard and is useful knowledge to have if you use java and eclipse often.
thank you very much.
Just say no! Event sourcing, not even once... CQRS in itself is great! And for god's sake no Axon Framework...
Do you have a tangible example? I'd love to hear of pitfalls before I embark on this journey, rather than when I am in the middle of the ocean. :)
Hey Tomas. First - yeah, CQRS is great. Also super simple. Event Sourcing isn't something that fits every type of system. I would even go as far as to say it doesn't a lot of them. However, having gone into my first Event Sourcing implementation skeptical, I came out, well, less skeptical. It's very powerful for the right kind of system. You can do things that simply aren't possible in state-based style of architecture. Finally - no, no Axon. I'm showing a Spring implementation on the webinar. Cheers, Eugen. 
And if it wasn't for Android, I wouldn't even care. Slower overall execution than Maven and hardly brings any improvements for those of us that don't have issues with XML. I use to disdain Maven over Ant, but any of them are way better than the current Gradle experience.
I think you have a good grasp of it. Camel is just a library and you can use it in any Java app. You can create a Camel service app and run it in a server like Fuse ESB. The best way to understand it is to download Fuse ESB and get your hands dirty. My team uses Java to configure Camel routes because we're all developers. For a 'no code' approach you can also configure a Camel route using Spring XML and drop it in Fuse ESB. There are lots of [examples](http://www.jboss.org/products/fuse/resources/#demos) on jboss.org. A couple years ago we moved from Dell Boomi to Camel because we wanted to have more control and better tests for our integrations. Boomi served us well for years and I think the product was the right one for where we were at the time. Camel takes both time and expertise to get it right, Boomi is a better tool for mere mortals (think clicks vs code). It took two solid developer years to migrate to Camel, but with what we know today we could redo it all in a month. SnapLogic and CastIron are both similar to Boomi, from what I've seen, but more powerful. It would be beneficial to take them seriously. Even if it is not the right technology for the long term, it more than makes up for it in the short term. I still believe we could benefit from using SnapLogic for the mundane stuff and Camel for the complex. MuleSoft had a lot of promise when we first evaluated it. It is scarily similar to Camel. We chose Camel over MuleSoft for two very good reasons: 1) Unit test support in MuleSoft was noticeably lacking. 2) Camel is entirely open source while MuleSoft Enterprise costs $$$. These are just my impressions, you should do your own due diligence. Maybe things are different, or maybe I missed something key during my evaluation. All in all my team is very happy with our choices, which is more important to me than choosing the 'best' technology. Happy developers = low attrition.
Jup, you didn't watch the presentation at all...
&gt; I completely disagree. In our codebases everything is final by default (and most methods private static, i.e., pure). If it has not been explicitly intended and designed to change, then it should be final so that the compiler can enforce that. In my last project they divided our project into 3 different projects so the project lead could feel like he was contributing something. It didn't change the numerous time wasting arguments when someone working in one of the projects needed to access code from one of the other projects, and the project lead told them they needed to get it down right away but also they couldn't change access from one project to another. I'm sure final everywhere is similar. &gt; What's "messy" is having everything mutable by default. The possible state space just explodes and it becomes impossible to reason about all the possible cases. When everything possible is final, you know they won't change and the state space is reduced to the few things that actually must change. In my experience people doing this don't have unit tests that cover their cod that would be a solution that takes that time investment and actually tests whether their code is working. &gt; However, I do agree that it would be cleaner if everything in Java was final by default instead of having to use the final keyword. Then you'd mark the few things that must mutate with "var" or whatever. Smart and more experienced people than you or I all looked at that and thought "that's a bad idea". Languages that make it difficult or impossible to change variable values haven't caught on either.
That just means you are over constraining Foo.bar. Clearly it doesn't actually need to take a Baz to do its work, because the test works with a mock. Just make Foo.bar take an interface and you can mock away that interface all you want. The problem with mocking concrete classes is that you not being clear about your dependencies. If you say Foo.bar(Baz) that should mean: I depend on exactly Baz, nothing else will do. If Foo.bar can do just fine with only 3 methods from Baz, then make an interface that has only those three methods. I think also your test case is a bit contrived. I don't generally write unit tests to catch unknown arbitrary errors in my program. Why are you allowing Baz to get in a bad state to begin with? Life would be much easier if Foo could depend on you not handing it garbage. You could easily verify this with unit tests on Baz and avoid the cross cutting.
Does anyone know what the plans are for JSR-305? The OP uses words like "cannot hold null in those fields" but without a way to tell that to the compiler you cannot guarantee it. JSR-308 enabled this behavior so it would be nice to get it in the standard javac. 
&gt; Just make Foo.bar take an interface and you can mock away that interface all you want. If I never plan on making a sub type of Baz, then I won't make an interface. But I think this is an area where reasonable developers can disagree. I've heard good arguments both ways. The test doesn't have to be Baz throws an exception. It will be any case where Baz will have a known, predetermined behavior.
I'm not sure how personal attacks and assumptions are relevant, but I apologize for having offended you. Like I've mentioned in previous posts, we've seen wins in both development and maintenance time. The largest bottleneck is never the time that it takes to type the code into the editor, but the time that it takes to truly understand what a system is doing (or what a new system should be doing), which is why things like descriptive variable names, comments, and keywords such as "final" exist. Just because a practice is popular does not necessitate that it is wrong. It appears that you have a strong personal style that works for you. That's great! I have a strong personal style that works for me. I'm sure that as I approach the mindset of ten years of experience such as someone like yourself, this style will have changed. At the very least, I'll make an attempt to understand and apply any popular fads that come along, to see if there is anything worthwhile to incorporate and use. 
But you are already making a subtype of Baz - what do you think a mock is?
The verbosity of Optional in an already verbose language makes me cry. @Nullable and @NotNull ftw!
From the video: 1. They made a prototype that didn't require VM changes to explore the design space (typesystem, semantics etc.) and what vm changes would be desirable. Throughout the presentation he constantly points out the problems with this approach (name mangling, no lightweight code loading, type system issues, ...) 2. For the next prototype they are proposing new bytecodes, changes to arrays and changes to the classfile format (a parameterizable constant pool). The specialization will be performed by the VM on a 'per method' basis so no classloader tricks or classfile rewriting. 3. How classes are specialized will be configurable (via some class bootstrap method I guess) so that other languages can use the specialization logic the way they want to (Scala, kotlin etc). Using this method you can even have full reification although java will not support that. I genuinely wonder what "moving everything to the vm" means to you?
welcome to the club :) checked exceptions are stupid and bad decision. 
The main point of the option type is that it forces the developer to *willfully* choose to write unsafe code. Without the option type, the default is to write shitty code and you have to make an effort to ensure that your usage of potentially null values is correct. In other words, without the option, if you forget to check for a null value somewhere, you won't know until there is an error. With the option, your code won't even compile *unless you have intentionally gone through the effort of handling the option*. So, of course, there is nothing preventing you from handling it in a stupid way, but the important factor is that you *have* to make a conscious decision when using options.
Please help me to review this article. Thanks guys.
It feels like you are afraid of changes. If I am making changes to my public and protected methods that could be overridden by someone and would cause the problem, I **know** I am safe. Because whoever overridden it will get a compile time error. On the other hand, if you do not allow users of your code to override your behaviour enough, you invite them to create copy-classes instead. That really limits your options to push an updated version of a class to those people. In my world, user will get a compiler error, reach out to me and will get an answer on how to solve it. In your world, user will still run on a copy of the older class until something behaves not the way it is described in the modern documentation. Then they will reach out to you with a cryptic and hard-to-reproduce problem description and you will spend days solving that problem. Final classes and method exist for a very good reason - when your runtime is doing something nasty with them. For example, you can not extend String, since String instances are not regular instances for the JVM. Hence String class is final. Please, do not assume users of your code are stupid. They are smart people. You don't want to fence away from them (us) by the wall of "finals" to keep your own little garden safe (and free you to change anything inside). You want to invite everybody in to collaborate and build the most beautiful structure **together**. Edit: fixed some typos
IMO you should really try to avoid stuff like bytecode manipulation in production code.
Yet another future of testing on the JVM? Just because physics theorizes all possible universes might exist, doesn't mean we have to try to create them all here.
Business server apps using bytecode manipulation. Yeah, why ***IS*** java so easily incompatible???
this guy is boring as fuck. I just want to read the slides. 
Wow, overreaction. 
A commercial feature. So, 99% of apps will never see any benefit from any of this. Lovely. Also, how the fuck do they expect anyone to test it if they aren't allowed to use it? Idiots.
&gt; It just means you leave it un-upgraded for longer Which means it's cheaper. Upgrading software which is not being actively developed is damn expensive.
I'm sorry, what? How did you get bravado from that? I'm just saying it's not hard to change a text literal, and that _nameof(variable)_ is a lot more complex than _"variable"_.
Java easily incompatible? Really? Have you tried building a ruby application?
Python 2 -&gt; 3 .... yea ok 
I think this is great - just backed it. Everybody's gotta pay their rent - it's awesome that people find time to contribute even without pay, but it's very difficult to be able to work on stuff like this fulltime. My own personal project made a big leap when I was able to devote my full-time attention and focus to it, I hope they are able to make a similar leap with the funding from [this indiegogo](https://www.indiegogo.com/projects/junit-lambda/#/story). I'm confused why people feel hostility when someone asks to be paid to work on a project for the common good. They're not demanding payment, just giving you the option. We all use so much open source infrastructure, it's very difficult to contribute back in equal measure to our consumption. I'm glad to have another venue through which to reinvest in the community.
On the other hand, it's also much easier to take that non-standard behavior and wrap it in a plugin, since the API available to plugins is the same one available to builds. If all you have is straightforward java projects, Maven is probably better, but that's actually surprisingly rare from what I've seen.
Ah, see we run into nonstandard stuff all the time. JNI code, flex, python/ruby scripts, Docker, etc. Maven would be infuriating to try and use for our projects.
This crowdfunding campaign does by no means intend to lock people out from future development of JUnit. Instead, everything we work on will be available on GitHub. In addition, we will reach out and ask the community for feedback as soon as we have initial versions of new APIs. However, in order to do so, we need some time and thus also some money. We will publicly account for how the money is spent.
You might want to fix your banner. It says CQRF :)
thanks. So do they old projects continue using the old version of java,i.e. 7 ? And do the newer ones that I build after I update, use 8? 
&gt; I genuinely wonder what "moving everything to the vm" means to you? Not everything... My proposal would be to add: * A tag for value types one can put on a class file. * Value-type tagged wrapper classes for all the primitives. * Add minimal meta-information {bci  specialization parameter} for relevant byte codes: `new`, `invoke*`. So the compiler can signal where specialization should happen. However, on the surface not much changes. Value types (including the new primitive wrappers as special cases) are just treated as if they were references, i.e. encoded as such in bytecode. However, internally the JVM analyses that bytecode anyway and knows which types are value types or not and can make decisions on what code can be shared and what parts are to be specialized. If specialization is an entirely internal concern, there is no need to ever actually generate specialized *bytecode*. \* It might make sense to consider new instructions for `new` and `invoke*`, but I don't see the need for `uload`, `ustore` etc. (\*) I do not know that much about the internals of the JVM, but I thought these days bytecode is really just a format, and the JVM turns that into something more pliable when it loads (like "sea of nodes" IR). If it still needs to actually interpret byte code (in interpreter mode) as-is then of course I am utterly wrong and what I said will not work. In that case it would only work when JIT compiled, because I am sure that uses a different IR. 
They should at least static import println(), considering how often it will be used in the REPL
What REPL for Java means for me? Yay, now I have a sane shell! Seriously, why use utilities with indescriptive names and parameters when I can use the properly named and typesafe Java API?
It sounds like it could do a lot for people learning, especially when they don't know how to operate those sorts of advanced features in an IDE. It also eliminates the tedious compile-run-debug cycle.
You don't typically print things in a REPL, because it just displays the return value of whatever expression you enter.
Thanks - that's what I get for not double checking :). Fixed. 
The articles has one example at the end that uses println().
True, in that example it was necessary because for loops aren't expressions in Java.
&gt;bytecode manipulation libraries Well, not to be rude, but no shit. They do ~~evil~~ sketchy things under the hood which can be fully expected to break between major revisions of the language.
&gt; Java is not going anywhere Well, actually with the new Jigsaw project, I wonder if it would be also possible to add/remove internal features, so we could mimic completely all the internal features available in the dalvik vm(I believe it does, since the main goal behind Jigsaw was to get rid of [Java ME](http://www.oracle.com/technetwork/java/embedded/javame/index.html)). Not that this would solve any issue, but I guess it could be a way to start working on the same ground. Then, eventually diminish the gap between the Oracle JDK and the dalvik vm.
&gt; Only space characters may be used for indentation. No tabs. Oh snap. It's official.
Neither side is completely honest here. Did Google duplicate code from Oracle? Of course - the interface definitions from parts of Java were duplicated in the interests of compatibility. Did Google destroy Java? Java ME certainly, but EE is going strong, and SE is still filling important roles. Was Oracle doing anything with ME that would satisfy the smartphone market? Hell naw. Google's move was the right one for the market, but could just as easily have been more closely aligned with the "spirit" of Java SE. There are no innocents here.
&gt; Wrapping Method Declarations &gt; Method declarations can be formatted by listing the arguments vertically, or by a new line and +8 extra spaces When I need to wrap, I've taken to styling the parentheses similar to how I style braces. That is, newline after the opening parenthesis and before closing parenthesis. Example: int someMethod( String aString, List&lt;Integer&gt; aList, Map&lt;String, String&gt; aMap, int anInt, long aLong, Set&lt;Number&gt; aSet, double aDouble ) {  } Does anyone else do it this way? Does anyone else like it this way?
Oracle should be fighting Apple to get Java on iPhone, instead of fighting Google to get Java off Android. 
Been doing this for a while - vertical lists are far easier to scan than horizontal ones, although I keep with the convention of having the leading brace at the line end, e.g.: int someMethod( String aString, List&lt;Integer&gt; aList, Map&lt;String, String&gt; aMap, int anInt, long aLong, Set&lt;Number&gt; aSet, double aDouble) {  } 
Please let's keep in mind that Oracle is a **big** corporation. They certainly don't act like a coherent person would and they're often hurting themselves in the process. Oracle, the tech company, while certainly driven by greed to some extent, has nonetheless grown into the mold to steer Java into a better position (at least compared to what late Sun did)  despite recent b*tching by their CSO, they actually fixed a lot of flaws that had lingered in 1.5 and 1.6. Then we have Oracle's law division...~~those guys have no idea of tech and wouldn't identify an API if you hit them over the head with a printout of the apidocs~~. Their goal is successful litigation  well in the sense of damages paid, not damage done. Note that when you'd meet any of them, you'd find mostly normal, fairly intelligent guys, which goes to show how much context shapes people's behavior.
OK, I'll retract that statement. I'm going to let their actions speak for themselves.
This: public Address(String addressLine, String city, String postcode) { ... } ... yet: public Optional&lt;String&gt; getPostcode() { ... } I really strongly object to this suggestion. `Optional` is an "all-in" type. You should never mix `Optional` and `null` semantics in the same type, *especially* not in a bean type. That's just utterly confusing.
Looks like I'm quitting java.
My go to is int someMethod( String aString, List&lt;Integer&gt; aList, Map&lt;String, String&gt; aMap, int anInt, long aLong, Set&lt;Number&gt; aSet, double aDouble) {  } I'm not so concerned with the literal number of spaces so much as the list lines up with the opening paren
Jeez, read the context: &gt; Android has now irreversibly destroyed Javas fundamental value proposition as a potential mobile device operating system They only mean mobile market. Which is still not really true. Oracle can compete for market share they just aren't able. Remember Java Brew? It's how you wrote shitty games for dumb phones. They had their chance and couldn't compete.
I haven't been following this case closely enough to claim to be familiar with who has done/said what. However, from some of the opinions of have heard expressed, Oracle's actions here have done more to destroy the Java market than Google has. This is certainly true for me as well. Technical and aesthetic merits and flaws of Java aside, why would I want to use a language developed by a corporation with as insane policies as Oracle's?
* RetroLambda works pretty OK for lambdas, method handles, and their's even a branch with default method support. Is it ideal? Nope, but sane people do use it to mimick Java 8. * Android's additional threading capabilities have nothing to do with the default threading classes, which are fully available. * Jupp, that's true. I do Android, Java SE, Java EE and even a little iOS flavored Java. Obviously i use platform specific libs, especially for UI. I also get to share a metric ton of code between all platforms and get to reuse a large set of 3rd party libraries across platforms (RxJava, JDBI, Lucene, ...). Is it perfect? Hell no, but it's a hell of a lot better than Oracle/Sun's shit shows called JavaME, JavaSE embedded or Oracle MAF. Android has gotten many things wrong, but it's still better and more "compatible" with the Java ecosystem at large than anything Oracle ever has and ever will come up with on mobile. Saying people coming to Java via Android is not giving them an insight into the Java ecosystem is ignorant at best and dishonest at worst.
* The language _is_ Java 1.7, there is no "kind of". With Retrolambda it's the same as 1.8. You read horror stories about people on old JVMs all the time so they are also stuck on old language levels. This point is only language level I'm talking about here, not the APIs or VM. Java 9 has almost no language features and Java 10 will have a few. The APIs and VM changes in 10 would be very interesting for mobile but not so much the language itself. * I'm not sure where you're getting this info. Threads are exactly the same, as are basically every core API. As someone who has done both JVM Java and Android Java for 8 years, 99% of the Java language and API skills I have learned apply to both. I'd be curious what you thought were vendor-locking APIs. I don't expect the Bluetooth LE APIs to work on the JVM or desktop Java. Why would anyone? * I not sure where you're going with this point. I could implement the Android APIs and toss them on the JVM bootclasspath. Is that Android then? My point was that the APIs Android exposes are just that, APIs. They are no different than any other library like Guava (which works perfectly fine on Android, by the way) or Java EE. Learning Android is just learning APIs like you would learn EE or Guava. Take them away and you suddenly haven't lost your ability to write Java. &gt; First it will throw any project into the dex function overflow bug. Guava has 14k methods, nowhere near the dex limit of 65k. Using multiple dex files has been possible since the birth of Android has recently been added to the tooling to happen automatically. Non-problem. &gt; Additionally, the Android Gradle plugin uses guava 15 and including guava 18 fucks up lint. The Gradle plugin runs on the JVM. Not relevant to discussion.
[You don't necessarily need Oracle for that.](http://robovm.com)
Man. How I miss Sun Microsystems... :(
Why shouldn't interfaces be copyrightable?
IT is not OP's fault. Misleading Title.
I know the bytecode is different, but only after compilation. Initially it builds as java bytecode using the Android.jar stubs as a placeholder so when you do convert to dex the functions exist on Android. I think the bytecode being different gives credence to the fair-use argument, but only if they strived for 1:1 compatibility. E.g. code written for android still runs in Java. All I really want is that google creates a Android.jar that has a implementation that runs in the JVM, so that Android code abides by the java philosophy "write once, run everywhere". I suppose anyone, including Oracle, is free to make their own copy of the Android api's and include them in the Java ecosystem though.
Because the entire point of an interface is to allow people who are otherwise not working closely together to "meet in the middle", so to speak, and write interoperable code without needing to organize anything beforehand. You just publish the specs or interface definitions and that's it. Imagine a typical trip to a bank. You drive to the bank. You get in line. You talk to a teller (or use an ATM). You do your business. You leave. Now imagine the first bank to be set up this way. They advertise heavily about how easy it is to do business at their bank. Now, other banks want to operate the same way. But the one bank says they've copyrighted this method of going to the bank. No other banks can allow you to drive to their location, get in line, and talk to a teller, unless they pay the first bank money. What? How does that make any sense? That's what Oracle is saying here. They're not saying that nobody else can steal their code and pass it off as their own--everyone agrees that's copyright infringement. They're saying that nobody can write code that works the same way as their existing code without paying them to do so.
&gt;It's also frequently used as an introductory language in schools, though personally I think that's a horrible practice that needs to end. I disagree with you here. Java is a very good language for introducing students to programming given the fact that it's statically-typed, object-oriented, and much easier to pick up than, say, something like C or C++ (which also offer the first two benefits). No student is going to do well with things like memory management if they're just starting out.
Why not something like python (or just go back to lisps)? Static typing is fantastic for larger code bases and long-term correctness, but I'm not convinced it's all that useful for people just learning the basics - and OO usually isn't introduced much at the basic level much either (and I would argue talking about concepts like reducing code responsibilities and encapsulation should be covered first, and aren't unique to OO). Obviously manual memory management languages like C/C++ should be considered more advanced, but there's a ton of GC'd languages to pick from.
&gt; But that seems like a bit of bogus, especially when you have some constant strings with foreign characters, like . Foreign characters do not belong in code. Code should be in the Lingua Franca (pun intended) of the comp sci world. Use resource bundles for using facing string anyway.
That analogy feels off to be a bit I guess but I don't know why. Is an entire language really an interface or is it something more? Can Microsoft sue the Mono project if they wanted to? If you design an entire language it feels like you should have some rights over it. 
&gt; The only reason many young developers still learn and program in java is for android dev. wut.
&gt; Oracle should sue themselves for including the Ask.com toolbar with the Java SE JVM. Sun did that before the purchase, and Oracle didn't have a choice in removing it since the contract stipulates a minimum time length. &gt;When I last touched Java you couldn't implement Windows Services without building components in other languages and you couldn't make use of the system-tray on Windows or Linux without having to make a binding with another language. When was the last time you did Java? Thats been in standard Java since 2007
You have a good post, and I am sad that you have been down voted simply because people are disagreeing with you.
Enterprise
The world would be a better place 
Doesn't matter who started it. More important that it is stopped. And stopping it was well within Oracles power. They should have put the kibosh on that shit from day 1.
Minecraft mods / Bukkit plugins / Sponge plugins. It's a fun thing.
&gt; Is an entire language really an interface or is it something more? No. A language is merely a description of syntax and how a certain sequence of characters (i.e. a program) should be understood. An interface is not a language, and a language is not an interface. An interface describes how something I write in a particular language can use a particular library for that language. In this case, Oracle claims that they have a copyright on the interface for the Java standard library. &gt;Can Microsoft sue the Mono project if they wanted to? Well, you can sue anyone for anything. The better question is whether you can win, and we don't even know if Oracle will win this case. But yes, it would apply to Mono as well--except for the fact that Microsoft has very explicitly claimed in the past it wouldn't sue the Mono project. &gt;If you design an entire language it feels like you should have some rights over it. That's like saying that if you write a book, nobody can tell their friends what's in the book, because when it comes down to it, that's what it is: Oracle publishes the Java language specification, and they distribute it for free. They also publish the interface for the Java standard library, and they distribute that for free. However, now they're claiming nobody is allowed to use that information to make their own implementation without a license. It's also worth noting that Oracle didn't invent Java; Sun did, and Sun never had a problem with any of this. Oracle is just milking their acquisition for all it's worth.
&gt;*Opening braces should be put on the end of the current line rather than on a line by its own.* Nope nope nope nope nope if (youDontDoItLikeThis) { you.areBad(); you.shouldFeel(BAD); }
Interfaces in Java are as interchangeable parts are to the world of machinery and automobiles... An interface is a way of specifying an open standard. Imagine if every time a part of your car broke you couldn't just go down to Pep Boys or Auto Zone or wherever and pick up an after market replacement part from your choice of manufacturer...It's because the parts specifications are publicized so that multiple parts makers can supply them. This gives consumers choices...options. What if every time you needed a new USB cable you could only get it from the company that invented the USB standard? That'd suck wouldn't it? But because the USB specification and form factor is a well defined standard, you have plenty of choices of companies to buy a USB cable from...cuz anybody who want's to manufacture a working one only has to follow the USB specification...Well Interfaces in Java are those specifications. They don't actually do anything in and of themselves. They merely describe functionality. Somebody has to come along and write code that actually implements them. And if the implementor follows the interface specification then their resulting code will be guaranteed to interoperate with the interface authors code.
Someone got a hold of the good weed.
Building quality software applications. 
GWT has many similar issues and fragments a code base, but it was never targeted for legal action. It would have been interesting had Android been a native GWT target instead.
&gt; Java's features that benefit large, long-lived code bases are worse than useless for the beginner student just trying to get started. Those features also don't give you a lot of rope to hang yourself with (unlike c/c++) which actually is pretty beneficial to beginning programmers. Having the compiler tell you you can't do something you probably don't want to do is way better than your program randomly crashing halfway through without any indication as to why.
I feel like we're getting a little off-track here. ^^/s
If Google switches android and systems programming languages then Java will be in serious trouble.
The same, just put the opening brace on its own line. Looks cleaner to me.
/r/nottheonion
Mostly web ERP (Enterprise Resource Planning) softwares and REST apis. 
You haven't found a reason, because you're a self-described amateur.
Spring MVC + Spring Data
Hence why I asked what the other reasons are. What's your point?
Object oriented is a terrible place to start. Pascal was designed as a teaching language and works well for that purpose.
Because as Sun clearly demonstrated, there was no big monetary gain in being the nice open source guy. Could you imagine the backlash if Google would have killed ZFS, Solaris, sold the hardware business, etc? To maintain the Google brand among devs, it would have to somehow keep all of this going. And that just was not happening. It would have been too expensive to continue doing what Sun failed to do.
Someone hand Oracle a bandaid, they sound kinda butthurt.
And 4 spaces! I find things pretty readable with just 2 spaces. 4 spaces is so wasteful and creates more whitespace clutter.
This must be joke, it is what c# does.
Plus consider Jersey (REST endpoints framework) and Dropwizard (a framework/blueprint for whole web server/application)
we're talking about frameworks like spring and hibernate here, are we?
why is object oriented a terrible place to start, but imperative is a good place? imo, functional should be where people start followed by object oriented and then imperative. functional seems to be a good starting point to me cause it teaches a lot of good best practices that imperative and object oriented languages don't really emphasize much (like pure functions, emphasis on usage of constants, etc). I started with imperative btw (logo, although it has functional elements, my teacher never covered those) and when I finally got around to learning functional programming the biggest challenge was unlearning the things I learned from and relied on in imperative languages. (btw, never programmed pascal, but the syntax and some of the constructs look nice to me).
Doesn't matter. If someone is foolish enough to use bytecode manipulation, you can hardly blame it on the makers of the jvm.
~~Lisps were *never* utilized as a **first** coding language in a computer science program.~~ Alright, fair enough, I was gearing my thinking towards software development oriented programs, not computer science programs that are more concerned with algebraic expressions and maths and whatnot... What I was thinking of isn't traditional computer science.
Many colleagues who work on various Google projects. Java is really big internally.
[This introductory course taught at MIT in the eighties suggests to me otherwise.](https://www.youtube.com/playlist?list=PLF4E3E1B72A58B492) 
I only remember J2ME!
The source would be Googling it. (If you really must have something, here's a Google dev commenting on [Python] (http://www.quora.com/Is-Python-still-hot-at-Google/answer/Robert-Love-1?srid=3h5J&amp;share=1), but a simple search will reveal more than I care to try and copy/paste on my phone) Google uses a mix of Java, C++, Python, and a little bit of Go. From what I've gathered they use Python for quick scripting and rapid prototyping, internal tools. The GApps stack is all Java, and probably most of the high level server side stuff too. I can't imagine them using Python for a lot of the backend, doesn't have the performance of C++, or even Java for that matter.
Lets wait until Python reaches at least half of Java's execution speed.
That's just like, your opinion, man.
&gt; C is a good language because it models how the hardware actually is. If your computer is a PDP-11, then yes.
NOTHING HAS CHANGED (with Java), People are still using Java6, Java7. Java8 didn't send a bunch of programmers to Java. The fact is, the other languages (which I suspected) lost popularity. Ruby disappeared. Python will never shoot into the Enterprise. So you are basically left with Java for modern development. C# is Microsoft Technology. ... With Java, the static type error checks at compile time is a big deal. The biggest contender right now is JavaScript which can replace a lot of Java code on the front end. It too doesn't have the compile step, but a more familiar syntax than Python. If you want to replace Java, I just want a language that has the compile time checks and runs on the Server side within the JVM. Maybe Scala is it. But even that runs on the JVM.
I don't like Python for most of my development. The speed is an issue. With Java, the static type error checks at compile time is a big deal. The biggest contender right now is JavaScript which can replace a lot of Java code on the front end. It too doesn't have the compile step, but a more familiar syntax than Python.
What do you have an issue with? Android for Java development. ObjC is losing to Swift for iphone development.
Please go troll somewhere else. Or rather: don't do it at all.
excellent point
I love perl. I use it for small utility scripts. But I would never dream of using it for large, enterprise projects. The same with Python. I use it too for simple to moderately-complex tools but nothing enterprisey.
Perl6, perl6
Have you heard of [Kotlin](http://kotlinlang.org)? It complies to JVM bytecode and Javascript, has fantastic tooling, static analysis and real-time/compile-time features like null safety. If I had to put my money on the next Java, it would be Kotlin.
Haven't heard of it. Why would I use that over Scala?
It's like Duke nukem forever! 
I will not lie, I do my "file parsing" in pure Java. You should try it. Hook it up to Derby and you have awesomeness.
I'll check it out!
Yeah well your mother is fat.
Imperative is closer to the hardware, which gives people good mental models of how the underlying implementation works. Introducing new developers to things like vtables unnecessarily complicates things.
&gt; Once-faltering Java is beginning to run away with the Tiobe language popularity index And I stopped reading. ... For $diety's sake Infoworld, you are "reporting" on search engine results here.
You had my curiosity, now you've got my attention. JetBrains developed some of the finest development tools i've ever seen in my career so if they created java dialect then it's definitely worth checking out.
Huh. I've missed Java's popularity declining.
This is one of those 'easier said than done' arguments. The obvious pitfalls in it are as follows: * Code should be in english, sure, but, anything shown to the user (part of the interface) should be in the intended language. This is usually either (A) english or (B) the product is i18ned and there are resource bundles, but sometimes code is written targeted only at a single locale, and adding resource bundles into it is a needless complication and a violation of the principle of avoiding lookups where possible. * Code might be modelling a concept that is primarily defined in non-english. For example, you might have a method to add a 'thingie', where 'thingie' is a foreign language jargon word that doesn't have a ready english translation. Even if you can come up with one, the code is now a lot more confusing: Everyone familiar with the domain knows exactly what &lt;jargon term&gt; means, but as there is no set english translation, they'd have to guess at its meaning, which is probably far worse than introducing non-english in identifiers. 
That's an argument for tabs*, isn't it? I'd be a bit of presumptious to decree that you are wrong on this and that you merely THINK that you like a 2-charwidth indent more than a 4-charwidth indent, and yet, it would be equally presumptuous to decree that all coders who prefer a 4-charwidth indent or even an 8-charwidth indent are simply morons who must be shown the light of this better god instead. That means we are stuck with only 3 options. 1. Use tabs for indent, spaces for everything else. Now everyone can pick their own favourite charwidth for indent levels. 2. The vast majority agrees that spaces are better than tabs AND the benefits of being consistent outweigh the benefit of having the 'right' charwidth. I bet 4-width is the most popular choice out there right now, so this would boil down to you, your 2-charwidth preferring brethren, and all who prefer 8 or even more exotic numbers, to agree that whilst 4-charwidth is NOT their preferred choice, a world where everyone uses the same indent is preferable. In other words, would you rather have 4-charwidth everywhere? 3. Every project decrees its charwidth preference up front, usually set by the initial coders. Get used to switching charwidth indent as you hop from project to project. Option #3 seems pretty dumb. As much hate as tabs get, #1 does sound pretty good to me... *) The tab style where, explicitly, all potential readers of your source file do NOT need to agree on tab stop size. You get this by decreeing that tabs can only appear at the start of a line and never anywhere else, i.e. that tabs are used for indentation and not for alignment anywhere else or spacing things out, ASCII-chart style, or trying to make a line of comments all appear aligned or somesuch.
Sorry, but this doesn't belong here, even though this is clearly a troll post from OP. No need to lower yourself down to OP's level. Stay classy.
Well, let's talk about the issues (let's posit for now that 'sod it, just make one humongous line and be done with it' isn't on the table): * We need a modicum of efficiency here; we ARE forced to multiline this thing, so there will be lots of arguments and/or long type and identifier names involved, so any style that wastes too much space is going to be annoying to read. * Visually separating the end of the list of arguments and the start of the body is a heck of a lot more difficult now; we have 2 separate ident-like concepts vying for visual identification: The notion that certain lines are a continuation of the signature, and the notion that the method body itself is a continuation of the definition itself. * Where possible, reduce diff noise. The style-guide's solution sucks at the second part, and kinda sucks at the first (throwing out 2 levels of indents when we're already pressed for space seems like a very strange idea). Your solution fails the first issue in a different way, because it adds A LOT of lines (in your example, that's 9 lines before you get to the method body proper instead of the more usual 1, and given a 100-char limit, it could have fit in 2). On the plus side, by dedenting the closing paren and opening brace, you've done a far better job on #2. I think the 2 viable alternatives are to group arguments together, and to try to be as succint as you can be, for example: int someMethod( String aString, List&lt;Integer&gt; aList, Map&lt;String, String&gt; aMap, int anInt, long aLong, Set&lt;Number&gt; aSet, double aDouble ) { ... } or even this: int someMethod(String aString, List&lt;Integer&gt; aList, Map&lt;String, String&gt; aMap, int anInt, long aLong, Set&lt;Number&gt; aSet, double aDouble) { ... } Where a blank newline is required between the signature and the body as a way to preserve visual separation between signature and body. That last one doesn't save a whole lot vs. the first. The first does, however, still keep things reasonably clean (not as 'clean' as what you do, but a close simile), whilst not blowing out your visual space. The problem with yours is: It looks clean like this, but in context, you've made it far more difficult to grok the whole method at-a-glance because you're not going to see the rest of the method now; the signature is taking up too much vertical space. Your style wins at #3. So much of this seems like busywork; the editor, compiler, diff engine ,and source control system should be doing this for us, realizing that what actually changed is that arg 3 and arg 2 switched places, for example, regardless of what line that occured on. 
&gt; Ruby disappeared. What does this even mean?
Go was neither intended as nor is a suitable alternative to Java or the JVM, and even if it were, Google is just one of many companies making heavy use of the JVM. The only ecosystem I'd place in the same category at this time is .NET - and while it's true that microsoft has open-sourced a lot of it, it's still a long way from the kind of broad platform compatibility and multiplatform maturity that the JVM enjoys. Even for systems programming, I'd argue Rust is a much better successor to C/C++ than Go.
Good design and simple functions can make a python codebase easy to maintain. People write ugly java code with dynamic properties all the time. Almost every enterprise spring app I have worked in involves a healthy helping of annotation proxies, complicated non-compile time wiring, and aspects that are far scarier than the average python code I work with. On the mispelling front a solid ide like PyCharm from the jetbrains guys will catch your function name mistakes, and do refactors much like Java. I also suspect with type annotations coming Python 3.5 that we'll see them checking those too. I think a lot of the misconceptions about python in the Java community is from people not giving it a fair try. Groovy isn't a good comparison because it feels like they shoved every feature they could in. Python on the otherhand has features that feel consistent and fit together. I found it surprisingly java like and both Java and Python are pleasant to write and maintain when done right.
Just GIL and version split (2.x/3.x) mean that python is not really taken seriously in enterprise. Scripting, tests, small quick &amp; dirty apps - yes. Large and/or performance-sensitive applications - big no no.
Why are you so ugly compared to John C. Reilly? You seem pretty useless to me. If it wasn't for anti-depressants I think you would have died already. Also slow as fuck
Oh don't think I am ragging on Python! I like writing Python code and I find it more readable than Java. I also agree that enterprisey Java code can be horrible with a nice helping of magic. My point is regarding static and dynamic languages in general. IMO you have to do a lot more testing and sanity checking in dynamic languages, that you get for free from a compiler in a statically typed language. This is especially true when you work in a large codebase with multiple programmers with varying standards of cleanliness and levels of expertise. I find that in such environments a statically typed language gives me a lot more confidence. 
There's no way to prove one way or the other, Oracle has been hush hush on the reasons behind it. It just seems odd they'd sign such a long contract when the previous crapware Sun packaged has a much shorter run.
&gt; I think Python/Ruby will die. Like Perl6 really die. Ruby? Maybe. It seems to have carved a niche as a non-enterprise web app language and is being squished by python, node, and php. Python isn't going anywhere anytime soon due to it's versatility, and neither of them aren't going away in the near future. Still lots of ruby and python work out there.
Writing desktop apps in JavaScript? That's the most horrifying thing I've read all day. Fuck that. I'll abandon JavaFX when something better comes along, and JS does *not* qualify.
http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html There's a graph about midway on the page - you can see it dipped to its lowest since at least 2002.
Not really, increased desperation would explain it perfectly. Regardless, this was suns doing, Oracle sucks but you can't blame this on them.
He left Google some time ago.
If you're speaking in terms of a programming language itself then I would say yes...but Interfaces can also be created by people who create their own programs and APIs in that language. It is simply a feature of several well known common Object Oriented programming languages...C# to name another one besides java which also has the exact same concept of interfaces. The core implementation of the programming language itself has many APIs which people who write programs in that language utilize. If you can't use the API's the language is essentially useless...Now if I come along and write a program in Java I will likely utilize many of the core java language interfaces in my own source code and at the same time I may well create my own public API for use by people who want to use my product. The difference is Java is a language, my product is written in that language (and perhaps I even made my product available in other programming languages as well for it to be easy for developers who know those languages to use my product as well) but it may or may not be a free/open/public product. I hope this makes sense.... Maybe it makes sense this way...you want to write a book, say a sci-fi story completely from your own imagination...You speak English. So you write your book in English. English language is the foundation for your product which is the story and you choose book interface to convey your story to people. You want other people from other countries around the world to be able to enjoy your book so you also publish it in Chinese, French, Spanish, Japanese, etc...whatever language you publish the story in, it's still the same story and the book is the interface you chose by which to convey your story to people. Now Oracle comes along and says, "hey we own the book interface and the grammatical syntax of the English language so you can't write that book without paying us." Seems absurd to say the least doesn't it? This is what Oracles arguments sound like to me using the best analogy I can think of...
Dalvik was jettisoned a long time ago. ART is the new runtime.
Top 1: That doing the thing for 1 instance is exactly as complex as doing it for 1 000 000.
interesting stuff. too bad it had to be about intellij and jetbrains, but i guess they're the ones paying the bills. one thing i have to say about intellij: dunno wtf the developers are smoking, but it must be some good stuff. the ide is one huge pile of wtfs.
... And that's part of it's problem. It's not going anywhere, at least - not going any where fast. The plans for Java 9/10/... look nice but they're also extremely hard things to change.
&gt; With Java, the static type error checks at compile time is a big deal Do you mean a big deal in a good way or a bad way? Compile-time static type checking is great. Type erasure is not as great but not a big problem afaik.
I don't get why anyone would prefer to use spaces. Any editor lets you configure the number of spaces the tab character represents, so if tab are used as the standard, users can make their editors display identation to the number of spaces of their preference. No matter if someone prefers to see 1, 2, 4, 8 or 200 spaces. Tabs should work for everyone. If you choose spaces, there's no such flexibility and people just have to suck it up if they don't like the standard.
Not always 100% true. I mean, at certain scale, you are just wrapped in a loop construct, but at higher volumes, you may have to implement something to distribute the cycles to other machines. Lots of libraries, so not super complex, but I would call it roughly, not exactly. Maybe I'm anal, but that's probably why I became a programmer to begin with.
Yep, have looked at that, non trivial
Java is taking the developers that used to develop in Objective-C.
Exact same thing, different names ;)
It is the only cross platform language left, so the market will decide. Honestly, client-side mvc in the browser is not much different to a desktop client. If you look at the latest version of the JavaScript standard, it looks pretty good, almost like java.
Because despite winning they are on a decline with cleft side java. It is deactivated in most browsers, only internal enterprise apps are written in swing our javafx, and JavaScript along with angular is the lingua franca across all platforms. It is also attacking the traditional java backend market. All of that can be traced back to investments by Google. And you tell me they have no reason to be butthurt.
&gt;Honestly, client-side mvc in the browser is not much different to a desktop client. Yeah, except for the part where you have a horrible language with a horrible GUI toolkit. Ugh. No *thank* you. &gt;If you look at the latest version of the JavaScript standard, it looks pretty good Horse shit! It still doesn't have static types, multiple inheritance, abstract classes/interfaces/protocols, user-defined operators, user-defined implicit conversions, serious pattern matching, serious list comprehensions, compiled and linked binary form, package manager that isn't crap, GUI toolkit that isn't crap, and a bunch of other things. ES6 is polish on a steaming turd. The whole language still desperately needs to die in a fire.
Yeah, I think you might have to take a cold shower.
Just to be clear, there is one important thing we would agree on. It is composition over inheritance. Done right, it renders that final-vs-non-final question invalid. 
If you lunatics get your way and wipe out all sane programming languages, yeah, I'm gonna need a lot of cold showers. Not least because that means you've reduced all computers to being fancy Facebook machines. All serious software (and all semblance of privacy) will have become extinct, replaced by your ugly, buggy, intrusive, slow web app garbage. That is not a world I want to live in.
That argument would be valid in a world where each developer used one tool to look at one set of source code. Or one where configuring all the the 8 different tools that happened to need to display source for each of the 12 codebases you need to do your job somehow just happened. Or one where it was practical to write code using only tabs, never spaces. Or, at the very least, one where failure to configure a particular case led to things merely looking slightly wrong, rather than either bouncing all over the screen at random or whispering false information into your ear. 
Because it's like Kotlin without the missing features. Scala's main attraction is **power**. Maybe that's scary for novices, but for those of us who know what we're doing, it's a godsend.
Noone yet made the obvious joke: &gt; The copyright notice must be put at the top of the file and follow the standard wording and format. In particular the first two lines should be /* * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
Still miles ahead of eclipse 
It's a lot simpler and cheaper to develop. Period. For internal small business apps with less than 1000 users you don't need the scalability of twitter. You need to get shit done with mediocre developers who will glue and extend the app over years. Do you have performance problems? Throw more hardware at it. 128GB of RAM and two Xeon processors are cheaper than programmers. I think there is a widespread disease in the programmer communities where we want to solve techincal problems most apps will never experience just to try out the newest technology and neglect the business problem we should be trying to solve in an appropriate manner. Of course you can develop a webapp with a stateless microservices-architecture, NoSQL and use a JS-Framework that will be obsolete in two years, but I will choose a Vaadin-App every day of the week.
On the other hand if you're a small operation and you can't afford to run your own servers, you're using a cloud provider and then stateless is arguably easier and cheaper, as a lot of their platforms have issues with stateful apps.
&gt; They break fundamental web browser features like bookmarking, sharing links, and the browser's back button. Not necessarily. JSF2 for example has support for all these things.
Yep, but now it is client side, so that's a huge improvement IMHO.
This is only the initial rendering so you can have working pages when the client doesn't support javascript. It can then get updated on the client side (if they have javascript enabled), which is the whole point.
The project importing is garbage compared to Eclipse. The keybinds also garbage. Most of the defaults are terrible. But I'm an IntelliJ user because it makes up for the quirks.
Sometimes what sounds like an easy task when phrased as a business requirement is difficult to implement in the code and vice versa. 
Exactly. It's a bunch of Indian guys in a room for seven days a week for three months. 
you're obviously joking. everything that intellij does eclipse does it too. eclipse tough, is the beneficiary of a sane platform for editing files. when the base is solid, the rest can follow. intellij fails at the most basic tasks: editing a text file. doesnt matter how cool it is what you build on top, it still stinks.
hahahaha, hahahahha. thanks for making my day. 
NP mate 
&gt;Java is a nice language Um, no, not really. It's outdated and there are no signs Oracle gives a fuck about it. Java 8 made things slightly better, but it still looks like an ancient language. 
I'd like to meet the five year old that understood anything you just said. 
You set it on a project basis. You can also define the default
Oh, I'm okay with tabs as long as I set my indent to 2. :) I also do not understand why spaces would be better than tabs. With tabs, I can press backspace once and it's aligned under a higher level.
Don't worry. I'm actually 5 .
With JSF, you can have many web servers with no problem, as long as you make sure your users don't switch from one to another while they're browsing.
And you can easily break this features with a shitty REST application as well :)
&gt; That makes no sense at all. These two are orthogonal things. In my experience the people who use finals are also the ones that tend to have the best testing, because they are the people that prioritize code quality. It's about making the compiler check as many things as possible, because it will catch and report them much more efficiently than tests. You've actually just pretty much written the series of excuses I see. "Well I don't need unit tests because I'm using final and (long dibatre about final) so that's plenty of testing". Or "we're totally going to write unit tests" then at the end of every project there's 3 they did at the beginning and no more. I don't think there's much more to add here - we're clearly not going to agree. I find final to be way down near the bottom of things that would help with any actual problems that I've actually seen in coding. If you disagree, then we disagree. &gt; That's a nonsense argument from authority. That's like saying "just because everyone used to use punch cards and now they don't use them any more doesn't suggest at all that punch cards are a less efficient way to program". It doesn't "prove" it but it does strongly suggest it. 
&gt; When tabs exist ONLY at the start of a line, and indents are always done with tabs, then 2 different views of the same file where one is using an 8-charwidth-per-tab configuration and another is using 2-per, won't make code look funny. This is of course not true. To maintain the relative position of the start of each code line, then if: - x is the tab width setting - A is the number of tabs - B the number of leading spaces Ax + B would need to be either greater than, equal to, or less than A'x + B' for all x &gt; 0. Try it: if one line starts with one tab, the next with a tab plus seven spaces to align with something on the first line, and the next is two tabs, then it only works if the tab setting is 8 (or more). Almost all[1] code that is written with 'configurable' tabs is only indented correctly for a single setting of the tab width. Best case is they document it somewhere. [1] quick experiment: I used http://repo-for.me/ to visit 10 random github repositories, and then clicked around until I found a sizable source file. **All 5** that used tab characters were already either wrongly indented, or would be if the tab setting was changed. Arguably the worst cases were not those which were 50% wrong, but the ones that were right for 332 lines of a 333 line file, and then moved just one bracket just one level to the left.
It is still heavily used, but whereas once it was used (and marketed) as an industry-wide, general purpose language, it is now a niche language (and marketed by its creator as a language for working close to hardware). That happened -- among other things -- not because of the language's flaws, but because of its power. Codebases became too different from one another (with style having a major effect), discipline was impossible to enforce (because the people enforcing it changed over the project's lifetime), and the result was too-clever, un-learnable and unmaintainable codebases that ended up costing the industry dearly after years of optimism. Java succeeded and caught on so quickly not just because of its safety, but partly because it decided to be less powerful and more verbose (it says so right in the design documents), and, as a result, dramatically lowered the cost of development (which turns out goes more to maintenance than initial development).
amazing.
That one I find particularly frustrating, because IDEs like IntelliJ act like it's guaranteed by throwing out a warning if you do a null check on an argument with a @NotNull annotation.
Because you already know JSF and found a job that pays you to do JSF. Things will be fine for another 5 years, but then you're screwed. Or maybe not. I hear COBOL programmer make decent cash these days.
It is still poplar today. It may not be as popular for web sites that are mostly for reading content but still the best method for database driven highly interactive web applications.
Here's my contradicting ELI5: You want to have as little state as possible. If you can, don't store state in the server web app. State in the web app makes scaling more difficult. Like other posters said, web app development has newer and more powerful tools. If you need to do stateful things because of performance reasons, you need to realize that you're either using statefulness as a read cache (with all the problems caching has) or you're not storing important user data in to the database.
That's exactly right. You CAN have as many users and web servers as you want with both stateless and stateful web applications. If one server can accommodate all your users then you're better off using stateful web applications. It will be faster to develop and easier to maintain as long as you need only one server. If you grow beyond one server then you're wasting time coming up with ways to keep users on the same server or figuring out a way to share state between multiple servers. You're just re-inventing stateless web applications at that point.
right, but i don't necessarily consider that the fault of the app developer. It's something that should have been caught on first boot-up.. 
so you don't use any libraries whatsoever, and you're calling *them* bad programmers? good luck with that. 
Maybe... but most major frameworks make use of it. Spring, Jetty, Tomcat, Hibernate, Guice, Guava... they're all using bytecode generation and bytecode manipulation at some point. The only way to be sure you're not using any bytecode modifiers is to write literally everything from scratch, and it should be understood by now that it's not a viable approach to software. 
https://www.youtube.com/watch?v=rDUVXQeN9wM
Not necessarily: the problem code might only be called under certain circumstances, in which case it would be harder to detect. That being said, it's *usually* a bad idea to use ASM in production code.
&gt; It happened because high-level, high-performance programming became feasible, with the introduction of increasingly sophisticated JIT compilers. Yes, that, too. But Java was designed like it was because we cried for a simpler, less powerful language. &gt; Deal with it. Yes, and as a CTO of an organization, one way of dealing with it was to use a "cruder" language. That wasn't just me, but many thousands of other decision-makers who became disillusioned with C++'s power, and began to see its long-term, disruptive effects. &gt; Define discipline. Discipline in this case means trying to wrangle a powerful language by restricting use of its features. It doesn't work because the average codebase lasts about a decade (usually more), and in that time team-leads change, and each of them has different ideas of which features should or shouldn't be used. &gt; That's the fault of incompetent programmers, not featureful languages. That's just not true. First, most programmers aren't incompetent but simply average. Second, some of the worst offenders were excellent programmers who were not aware of other concerns of project management, such as the fact the seven years down the line someone they don't know will have to learn and modify their code, and therefore it should be as unclever as possible. They were under the impressions that good programmers program with clever powerful abstractions, which, of course, frustrated both us managers, and them when we told them they have to take out their awesome operators and template tricks. But that's what it's like when different people see the project from different perspectives. For example, Java decided to exclude operator overloading because they didn't work, and it wasn't anybody's opinion -- it was a fact. Nobody cares if an individual programmer can make good, careful use of them. Java (and C++ before it) was designed for large projects. &gt; you get what you pay for That's true, but the goal of software tools and languages is to lower software costs -- not keep them the same. If no one were able to consistently reduce software costs across the industry, we'd have said maybe that's impossible, but Java has cut development costs *industry wide* by over 2x. A part of that is due to the language's intentional crudeness. &gt; If you try to bargain, cut corners, outsourceyou're going to get shit. Guaranteed. No exceptions. That's not how software project management works. 1/ You don't plan for the next ten-to-fifteen years assuming you'll always have the resources to hire the best-of-the-best. 2/ Even the best programmers don't always see the big picture (hence discipline is required). Besides, software is not measured by the beauty of its code, but by how costly it is to write, test, optimize, maintain and upgrade over the lifetime of the project (again, roughly ten years). Most of those are helped by good code, but good code is not always what many mavericks think it is. &gt; and there are plenty of atrocious Java codebases out there to prove it There are. However, none of them as bad as the atrocious 10-year-old C++ codebases we saw in the early oughts. &gt; The solution is not to straight-jacket your programmers with idiotic languages They're not idiotic if they work. Programmers don't have a wide-enough perspective to decide whether a language is idiotic, unless they're working on their own project, or a small one. The considerations of which language to use vary widely depending on the number of programmers involved over the lifetime of the project. &gt; the solution is to hire people who know what they're doing. If only that were that easy (or true). I think that people who really know what they're doing (i.e. not only developed by also managed large projects) will tell you that picking a simple, "crude" languages is at the very least good practice. That's how Google works, too, and they know what they're doing in terms of project management. They use C++, too, because sometimes they have no choice, but expend tremendous resources in enforcing discipline -- resources that most organizations can't spare. Yet, they eschew clever languages when they have the choice, because clever languages make projects more expensive rather than less. 
Or this: public Address(String addressLine, String city, Optional&lt;String&gt; postcode) { ... } Why should the bean care about what type `postcode` is? It wouldn't care either if it was a `List&lt;String&gt;`
That explains the difference of opinion. I'm mostly a lone coder. I must do my job without assistance, because there is no assistance to be had. That means powerful tools are invaluable.
&gt; That means powerful tools are invaluable. That just means that "powerful" means different things when the project is different. To a project manager, a powerful language is one that helps reduce costs even 7 and 10 years down the line, and one that can assist when programmers need to switch from one project to another based on shifting needs. There is no doubt that languages with more clever abstractions help lone developers write code faster, and there is some strong evidence to suggest that those same languages are detrimental to large projects. I am interested in those languages in between. Say Clojure and other lisps, that are clever but whose cleverness is contained in a single feature (which has the scope of a single expression). Or those like Kotlin, that are more clever than Java or Go but try to update Java's relative cleverness to current industry practices. I guess we'll see (well, at least with Kotlin; as much as I love Clojure, I'm not sure we'll ever have enough data to know for sure). 
This error is not related to Java. This is error of Microsoft's shitty installer. You better get rid of previous java8 installation, it might help.
In hindsight, the GoT/BB/HoC parodies were off the mark. They didn't have an awful lot to do with Java, and attempts to shoehorn it in were painful to watch. This little animated short was so much better. It did so much more for much less -- no talking, no expensive costumes, no actors -- with humour we can all relate to.
its a nice option to have. WTF is wrong charging for technology ? A dev in western europe is ~500 to 1000 euros a day, guess it pays off a lot to invest in productivity enhancements.
To align anything, all things that require alignment must have the same indent level first. Which, in practice, is always the case. 
I feel that the real story here is that the people in the 2014 survey would prefer, above all else, to code in C... The fuck is wrong with people? [Source](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)
I posted this in another thread on the same subject so I'm just going to repeat it here: Any article that's based on tiobe's index is complete and utter rubbish. I quickly threw together some metrics of my own for Tiobe's top 10: http://i.imgur.com/KdPCyVr.png It shows the amount of SO questions, github active repo's and indeed.com job listings. As you can see they don't match up **at all** with what Tiobe is claiming. I don't know how exactly they got the results but this shows that gathering counts for "X language" from a bunch of search engines is a rubbish way of getting meaningful statistics. Why on earth this is the most quoted source on language popularity is beyond me. 
Nice, but how performant is this? C# has this via expression trees, which aren't reflection oriented. They're used in Apis everywhere, and mostly to give you strong typed access to field names. Think about having a data access object to mongo, or some other nosql store, and you want it's fields to match the fields in the db. Right now everyone hardcodes the field names as strings, but if you refactor then you are now storing field "foo" as property "oldfoo". With a proper meta name api you build Apis that expect lambdas to extract field names etc. 
Don't underestimate the power of Java 8 parallel streams */jk*
&gt; The TIOBE index never ever matched up with other metrics like SO questions and answers, jobs or reddit posts. Well, Java is #1 [in those as well](http://sogrady-media.redmonk.com/sogrady/files/2015/01/lang.rank_.plot_.q1152.png), although C is below PHP and Python. This actually makes sense, as C programmers often write embedded software which isn't usually open-source, and embedded developers don't hang around SO so much. So TIOBE's ranking -- at least for the top 10 languages or so, actually seems reasonable.
&gt;All the supporting libraries, language features, are primarily in English. So? What makes you think that that suddenly makes the guideline "everything written in source code files must be 7bit ASCII" relevant? &gt;English is the Lingua Franca of programming, much as it is for aireline pilots. No it isn't. Proof of that is that most software out there developed in the countries I mentioned before don't use it as the Lingua Franca. &gt;To be able to onboard consultants whether engineers that are specialists or generalists, typically they can read/write English, your not guarenteed that if you choose spanish/portugese/ or any of the other 15 south american languages (you chose SA, but it's a uniform problem). And that's actually not a big problem because you can get consultants in those regions. So basically you are just stating the same over and over but again I'm still wating for evidence. I want you to mention real-world cases where the company faced negative consequences for not following those guidelines.
To expand it for the future: java "developers" typically have the title Engineer and sometimes architect, or solution architect. Also, you may want to include "android" developer.
What is this and why should I care?
Java just beat C in the tiobe index to be the most popular language... not sure why Oracle is claiming google destroyed it. Claiming that google destroyed their market is quite ambiguous
That would skew the results if I did that for only Java and not for other languages. Someone programming in C# for example might have the title "Xamarin Developer". It's also kinda besides the point; the goal is just to quickly show that the Tiobe index is rubbish.
Being stuck on Google's Java is a fate worse than death for Java on mobile, hence why they went full legal.
Which is exactly why it's considered more of a hobbyist or "IT Guy" language. It's easy to just mess around with without having to know what goes on in the back-end. I agree that programming classes should teach a *programming* language rather than a hobbyist scripting-language. To be fair, however, the Java standard library *does* also do a lot of work in the background that we don't typically see.
&gt;I agree that programming classes should teach a programming language rather than a hobbyist scripting-language. Well, I kind of agree there. I think programming classes should teaching how to program and what your programs are doing. If you understand that, then you can pick up any language easily. I feel like python does too much to make it effective as a teaching language. However, if I need to write a quick one-off script or something along those lines, it's great.
C, C++, etc languages are also not as library-dependent. Java culture is heavily in the camp of "use a pre-existing library," and as such, you're often doing more google-searching on how to use or debug a library than you are spending time trying to write your own source. In terms of cause vs correlation, [a lot of Java searches have nothing to do with programming.](https://www.google.com/trends/explore#q=java) The number of Java searches indicates something, but I wouldn't read too far into it. 
The only reason I began coding in Java in the first place was Android. Now I'm 'stuck' in Java web-server land. If Android depricates Java, or moves onto something else (i.e. how Apple moved to Swift), then I wouldn't be surprised to see Java drop in popularity over time.
Looks fairly new and not particularity different from other techs which just deploy a browser with your app to the phone. If you want native java to mobile then gluon looks like a much better approach. http://gluonhq.com/ https://www.voxxed.com/blog/2015/08/gluon-bids-to-pick-up-commercial-slack-on-javafx/ 
An ancient language? Compared to what? Pro-tip: don't list scripting languages, as they are a different class entirely.
Looks great! I like the easy integration with several monitoring dashboards. A side note, could you please tell me what tool have you used to draw diagrams like [this](http://kamon.io/assets/img/diagrams/metrics-module-overview.png)? Thx
Hey Tony. Yes, Servlets are very much in use, in Boot included. You don't necessarily interact with them directly, and so they're not in the forefront of the configuration, but they're definitely there. It's what each and every request hits before they reach the Spring library. So, a new Servlet spec is quite important and will open up some cool stuff, same as 3.1 did. Cheers, Eugen. 
This is great to know. I know plenty of places in the code that violate this style guide. May my fury at enforcing code style be ranted in blogs for the next month! Mua hah ha ha!!!
Servlets are the basis of just about everything web and Java. It is true they are not as often used directly by most web application developers anymore but the most popular Java Web frameworks such as JSF and Spring require them. 
Applets are effectively dead. Look into JavaEE and related frameworks.
I really like the database agnostic abstraction &amp; refactoring that Liquibase provides. This is where others like http://flywaydb.org/ falls short.
On the other hand if you're using Spring Boot all you need to do is pull in Liquibase as a dependency and drop the changelog in `db/changelog/db.changelog-master.yaml` on the classpath. Alternatively you can set `liquibase.change-log` to something like `db/changelog-master.xml` to override the location.
I have been using undertow which gives you the option of using servlet or their lower level API using HttpServerExchange. I use the latter and has worked ok so far. 
The problem is how to give a reasonably efficient implementation of a value-type interface (i.e. one where the only declared methods are getters and setters, and where equals, hashCode and toString are generated based on the set of property values) using dynamic proxies (rather than code generation). A relatively inefficient solution is given, then a relatively efficient one.
Asking even "silly" questions is fine, but why people tend to throw in "Spring" as if it was some rocket science that changed everything, I wonder... 
Well, the point is that you define *only* the interface, and this bit public static Person create() { return BeanProxy.proxying(Person.class); } magics up an implementation of that interface for you, at runtime.
Why is it any better than an embeddable servlet container like jetty? Seems like I have to pretty much re-invent the wheel vs just use a plethora of servlet standards.
No, over-engineering is dumb which is exactly what you're doing. If you need a stupid value type then create a simple bean. If you need many stupid value types then generate them from your model with code generation.
Or - import a library that gives you beans-from-interfaces, and just write an interface every time you need a stupid value type. The tricksy stuff only has to happen once, in the library...
The difference is the sheer amount of public String getFoo() { return foo; } public void setFoo(String foo) { this.foo = foo; } that clutters everything up (not to mention the faff of testing every field in the *equals* implementation). It's *making you care about irrelevant stuff*. Even if you can automate the task of generating it all away, it's still *there*. In your code. Expressing *nothing* of value.
I have the same problem. I get to that part of the interview and can't seem to organize my thoughts the way I can when I'm 30 minutes into a 2hour programming session. There are a few of things I've found useful. Tell them your problem. A lot of developers have this issue and it's likely that the interviewers are sympathetic. Don't make it an excuse. It's a feature not a bug if you spin it that way. Something like 'I'm used to solving these problems fairly quickly in isolation but it may take me longer with you all here distracting me' then smile. Practice by yourself and with an audience. Not only development issues but simple shit. Break the pattern of thinking of yourself as bad at this. Most of the interview can be positively influenced by confidence. Take a mental deep breath before you start. The tempation to jump right in is hard to resist but if you settle your thoughts you will be on the right track. Ask a lot of questions and give them a chance to help you. Most of the time they are more interested in how you solve the problem than whether you can solve it so use them. Take some notes. One thing that helps me is writing out the requirements. Use psuedo (?) code. I learned to write in basic so instead of remembering current coding contructs I write it out in psuedo code and look at them to see what they think. If it's good enough yay. If they seem to be looking for more you can refactor to your chosen language. The most important thing is confidence. You know what you know and you should have prepared for the interview by reading up on the 100 most asked interview questions in &lt;insert language here&gt; so they can't trip you up on simple 101 level shit. If they want more than you can do it wasn't a good fit for you and you should find something else.
android isn't java 8. Oracles actually been getting cranky about this, and I think they have a point on it. Android only does I think it's 6 or 7 and it's not the entire base api although it's a fair point not to, not all of it has meaning on a phone.
Google did not copy Oracle's code. Google used Apache Harmony as it's Java implementation. Apache Harmony is an independently developed Java implementation from the Apache Foundation. The contributions were largely from IBM. Furthermore, the OpenJDK is open source. It's APIs are available for anyone to use. This is nothing but a money grab by Oracle. "Hey, we want a chunk of money from the mobile market after Google's substantial investments in developing Android. Give it to us." 
My list of tips: * Unless your webapp is mostly static, don't do server-side rendering. Just serve and receive JSON (or form-data if you handle file uploads). * Spring Boot. Use it. * JPA. Forget about it. JPA is actually harder to develop in if you know what you are doing with SQL. Personally, I migrated from Spring Data JPA to jOOQ and I am much happier. I don't have to deal with Hibernate and there's a lot less magic involved. * If you are having trouble with finding out what the hell is going on, don't be afraid to use the debug log level. Spring MVC and Spring Boot log a lot of useful info. * Read about dependency injection carefully. Not understanding how it works and what its scope is can lead to a lot of frustration. * Use Spring Security for authentication and security. * Beware of the large amount of outdated tutorials on the internet. As far as everything else goes, just follow the documentation.
If you want a web page, consider Java EE, specifically something like JAX-RS that serves data to an HTML/CSS/JS web page. If you want a desktop client that interacts with a web service, then consider Java FX, which also lets you style the UI using CSS.
Huh... I thought Mars required Java 8.
Not disputing any of your main points. Oracle saw their market position damaged by Google, using a technology that Oracle spent a lot of money developing; I think that's the core of the argument.
My company uses flyway. From my research I like liquibase better since it supports rollbacks.
I was pretty sure that I chose /r/javahelp, sorry to post in main sub.
It does...I'm installing Java 8 JRE now so I can run Mars..Grr...
Not an easy read but definitely worth a try for object-thinkers - [Object Thinking](http://www.amazon.com/Object-Thinking-Developer-Reference-David/dp/0735619654)
Same here, and I highly recommend doing practice interviews with friends. It's a skill like any other, so practicing helps!
The SQLite implementation falls a bit short, though. I remember it not supporting unique keys and having trouble declaring the SQLite type for dates/timestamps.
Hey, we're currently looking for contributors to imcache. Check it out :) https://github.com/Cetsoft/imcache
When pair-programming, you get to solve problems on the spot with another person. Just seek out lots of pair-programming opportunities.
For greenfield webapp projects, [nobody really does front-end with java anymore](http://spring.io/blog/2015/08/19/migrating-a-spring-web-mvc-application-from-jsp-to-angularjs). It's mostly Angular and React nowadays. Java/Spring has been relegated to the server, serving up REST/JSON to the Angular/React front end. But for legacy projects, there's still a lot of server-side rendering of html out there using SpringMVC and JSF. If you want to work with legacy, learn server-side rendering with SpringMVC or JSF. Edit: I'm talking about webapps, not static brochure-ware cms-type websites.
Neon... I think my OSs default is Helios or Gallileo. I switched to Kepler then Luna, but I missed the Mars launch. I wish it was easier to upgrade major IDE versions - IntelliJ and Eclipse both force a reinstall.. 
[Growing Object-Oriented Systems](http://www.growing-object-oriented-software.com/). It also has a good community around it and the authors are active on the discussion group. 
&gt; Always think out loud when interviewing and state all of your assumptions. Yes. This is absolutely critical. I have actually asked candidates how they would solve a problem and had them sit silently for a bit then say, "I don't know." No answer could possibly be worse than this. When you are asked a question, no one really cares about how to solve it. What the interviewer cares about is *how you think*. Tell them your (possibly stupid) first guess. When they point out problems, come back with (possibly stupid) solutions, and repeat until you solve it or they move on. I actually took part in an interview once where the candidate literally did not get a single question right, but he demonstrated a good ability to decompose the problems, to ask good questions about the problems, and was at least close to solving them. We hired him without any hesitation and he has been quite successful in the industry since then.
IntelliJ is simple though. It installs to a different place, looks for your old install and asks to import settings. The old one is still there in case you want to go back. How much simpler could it be?
And you can back up all your settings to a single file.
Looks like you have the wrong version of Java installed. It requires 1.7 and you probably have another version installed.
Just because Eclipse uses Java 8, it doesn't mean the software that you output uses Java 8 instructions or libs. So a developer code run Java 8 and still support Java 6 deliverables.
It looks like a commercial program. What would be my part if I join?
&gt; It's mostly Angular and React nowadays Not for content sites. There's tons of cases where Angular or React add needless complication when you just want page templates. In those cases JSP or Freemarker are perfectly valid view languages.
Why the fuck is it not Neptune???? Holy shit. Maybe cause it's not a moon, but Mars isn't. 
Are you installing eclipse on your production servers....?
You're going to need it on your dev's machines if you want localhost testing.
Had no problems so far myself. What stability issues have you experienced?
What do you mean about losing modularity? You're free to override the default.
Not to worry, I'm not allowed to upgrade my ide anyways. 
Dukescript is a really nice way to develop code in Java and then be able to deploy to multiple platforms in a format each supports (it is not running Java on each client)
, and it doesn't occur at all with IntelliJ IDEA (which many incl. me deem to be the better Java development platform) because it brings its own JRE, so whatever JDK/JRE you intend to have or have not installed in your system: It wouldn't affect this IDE at all.
Well, it would be bad for the software economy if I'd win *every* Java dev (Why Java? Because the free Community Edition doesn't have all features, but it has the Java features.) over, because competition is important, and Eclipse would lose some Steam (I guess) if this happened. But from a the-world-ignoring developer perspective, I *do* want to win every Java dev over to IntelliJ. Two years of Eclipse, which had been great but not without flaws. Then one day of thoroughly testing IntelliJ. I don't think I even *started* the Eclipse IDE once ever since then (which is almost a year by now, I think). IntelliJ does have its flaws, too, but not only are those a lot less game-breaking, even the awesome coding-support features are a sufficient reason.
There are none. You'll have to assemble your app out of many examples available on spring.io.
Interesting. I've moved to Mars because its less painful for me.
Scala - I don't think so, it's too complicated for mere mortals. C# - better option, but .NET, potentially similar problems to what Google has with Java Go - agreed I think something like Kotlin would be great - it's like improved Java, developer transition is quite smooth, interoperability with Java (all the existing code and libraries) is great, Google already has good relations with JetBrains (Android Studio) ... If not Kotlin, then Groovy might be a decent alternative. By pushing Google to change language Oracle could actually help Android. Java is outdated - especially compared to its direct competitor (in mobile space) - Swift.
I I'd like to give my support for for html + JS aswell 
So is @RedirectScoped going to be part of CDI 2 or is it a costume extension only available in MVC? Because if its present in CDI, it could be used anywhere as long as the BeanManager is initialized with the correct context. Just like you can use @ConversationScoped in plain servlets or JAX-RS when you provide CDIConversationFilter (provided by CDI as off CDI 1.1/JEE 7).
"After all, who wants to work in his unpaid time with an outdated Java version?" Guess that is a fair point to make, and most will have JRE 8 runtime. I do wonder how many companies are still bound to JRE 6, let alone 7. Will be interesting to see if this slows down uptake, in comparisons to earlier versions. 
http://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-first-application.html Similar article, same goal, with maven.
&gt; "After all, who wants to work in his unpaid time with an outdated Java version? Who wants to work with eclipse ? /intellijmasterrace
No. The upgrade process for intellij is not good. The rest of it is great. Its tedious having to reinstall.
Download DMG. Double click. Drag. *whew* (If you're on Windows maybe it's more, I don't know, but I figure it's just "Double click, click some administrator allow button, Next x3, Done") Yeah, that's so tedious. :P Anyway, evidently a new install is a lot for some people, I'm not going to change that, but I'm just saying that as a developer I am glad they don't just "upgrade" on the off chance that something doesn't work right, that way I can go back to a working version and still get work done.
Mostly just a complete lock up of the UI, and after closing the window the process is still around and I have to kill it manually to start a new Eclipse in the same workspace. No exception or message in the logs. Haven't looked into it further but it is likely due to the fact that I run Linux or use [vrapper](http://vrapper.sourceforge.net/home/)
*Yawn* bad attempt at trolling. If you want to use a real IDE you have to use Netbeans ;) 
emacs or vi surely ?
As a developer I would prefer if the upgrade button just worked, like chrome etc. for intellij it does for the minor versions, so they obviously agree in the most common use case. If I am worried about backwards compatibility I can choose to do a fresh install myself. No one said it is a massive amount of work, but it is **more** work. To be frank its a bit weird you are arguing this point, why are you getting so defensive about it ? Its more work, less useability, there isn't really much argument about it. The only reason its not done is it hard to do well and it makes licensing a bit easier.
reduce boilerplate? Here's even smaller than what you propose using Project Lombok: [@Data](https://projectlombok.org/features/Data.html) [@Value](https://projectlombok.org/features/Value.html)
Cool video, I've been meaning to get into JavaFX as it wasn't around when I first started learning Java (awt and then SwingX)
Does it ship with its own JRE? This shouldn't be an issue right?
I think what he meant was: Manager says: I need you to figure out how to calculate this complex function. But I only need it calculated for one sample. Not all one million samples. It's just a hard to do for one as for one million. Once you've written the code, the computer can do it for one million. The human work is writing the code. The computer work is repeating it a million times. PHBs are incapable of understanding the difference.
I guess to me there's not really a difference, someone else is doing the work by writing the code for me.
Are those ReleaseNotes all there is to it, or is there a more detailed List somewhere? Especially api-addition wise. E.g. the function [setAlwaysOnTop()](https://docs.oracle.com/javase/8/javafx/api/javafx/stage/Stage.html#setAlwaysOnTop-boolean-) was added in Java(FX) 8u20 but the corresponding releasenotes does not mention it. Is there a list were those additions are bundled for each JDK update?
2 Java installations is no pain at all. I currently have about 20 different versions of Java SDKs on my computer. I have multiple service releases, from multiple vendors, of 32 &amp; 64 bit versions of 1.5 -&gt; 1.8. 
All you have to do is add the URL for the new release to your preferences "Install/Update &gt; Available Software Sites". Once you do that, check for updates should upgrade you to new releases provided the particular package you are running still exists in that release.
No! I am saying exactly the opposite! I really don't understand why are you having such a hard time understanding what I wrote :/ * JSP (or any server-side) templates - "hasRoleX" check will not be visible in generated HTML/JS. * HTML/JS - all "hasRoleX" checks are visible. 
&gt; I currently have about 20 different versions of Java SDKs on my computer. I have multiple service releases, from multiple vendors, of 32 &amp; 64 bit versions of 1.5 -&gt; 1.8. why don't you uninstall the older versions? They are backward compatible. Unless you're talking about VMs/containers that are configured for specific production enviornments.
I was writing some J2ME apps back in the day. For personal amusement, not commercial. But they worked. I did my own implementation of an Asteroids game, for example, that ran on my flip phone. I could install it to several friends' flip phones, etc. This is all before the iPhone ever was announced. It was obvious even then that there was a HUGE potential for J2ME apps that Sun was not exploiting. So it seems difficult to claim that Google somehow damaged Oracle's market position when Oracle's predecessor was not really capitalizing on it. Leaving the door wide open for other innovators like Apple and Google to see the obvious potential and run with it. Apple went in a different direction. But as for your question about why Google stepped away from the class file format, Google was very clear about that. The Dalvik VM and its bytecode was designed to run on mobile devices better than an interpreter for JVM bytecodes. Even the slimmed down compact J2ME profile.
I'm not disputing that Sun/Oracle dropped the ball with ME, either -- Whether or not Java ME was being used effectively in the marketplace doesn't change that Google took Sun's work in Java and used it as the foundation of a forked product, without paying the fees that Sun was asking of their licensees.
Mostly habit. I used to work on a product that didn't ship with its own JRE, so I needed to make sure things worked on any JRE &gt; 1.4.2. I also had to support multiple platforms, so I had a network share with vms for a number of different operating systems and architectures.
There's really not too much history here.
I'm not a big fan of Lombok but it is definitely preferable to this proxy magic.
If only Smalltalk was open source in early nineties... The [official Oracle timeline is here](http://oracle.com.edgesuite.net/timeline/java/).
And that decision will continue to get more expensive. Shit's poisonous to the larger ecosystem; we finally are starting to get easy multi threaded programming. The more of these people around, the more major libraries are stuck thinking what about support for the java version end of life'd 2 years ago. They do not deserve this consideration; they already decided they do not like new things. 
I did read everything you wrote. I still don't get what your freaking point is. What you are arguing for is generally known as security through obscurity. Now you are saying that it's not what you mean. Could you *please* explain the differences between what you are arguing for and security through obscurity?
I wanted a way to be able to use a large collection of existing methods as method references in streams, but many of the ones I wanted to use threw checked exceptions. Rather than rewrite a whole bunch of these utility classes to throw unchecked exceptions, I decided to write a utility that can wrap these method references and rethrow the checked exceptions as unchecked. Hopefully some of you may find this of use. **Code example:** import static uk.co.adambh.util.functions.MethodReferences.*; public final class FunctionThrowingException { public static String intToString(Integer theValue) throws Exception { return theValue.toString(); } } public final class ConsumerThrowingException { public static void consume(String theValue) throws Exception { System.out.println(theValue); } } public static void examples() { Stream.of(1, 2, 3, 4) .map(unchecked(FunctionThrowingException::intToString)) .forEach(unchecked(ConsumerThrowingException::consume, IllegalStateException::new)); Stream.of("java.lang.Object", "java.lang.String") .map(unchecked((String theValue) -&gt; Class.forName(theValue), IllegalArgumentException::new)); }
&gt; Any shop running java 6 still will do this. The development environment is typically different than the qa, stage, etc... environments (especially if they are fully containerized/deployed as needed). I thankfully haven't encountered this as a problem.
I'm terrible at interviewing. I too frequently go into stupid mode when trying to solve problems. 
Yup! 
http://www.amazon.com/Head-First-Java-2nd-Edition/dp/0596009208 Yeah, it was a good quick read (one week at the beach) and the exercises were not mundane. It's great for visual learners as well if you're into that sort of thing.
I ain't gonna lie, it's super adorable to watch the Java community finally embrace functional paradigms. 15 years behind everyone else, but better late than never. I'm hoping that this push makes languages like scala less scary for manager types when people start finding that switching between Java and scala is less "crazy"
Gov contracting; I wish I could say the environments typical for that are 1/10th as good. They claim it be on paper; but it don't, it really don't. That's all there is around here though, I need to move. 
Many Java programmers wanted these changes earlier. It simply wasn't available and Java standards are slow to change.
A handful of tutorials, then just start coding. Make things you want to make. Once you have an idea, it's just a matter of researching what things you need to get from here to there. Google isn't just your friend, it's your coworker that covers your ass and helps you accomplish the things you wouldn't be able to do on your own. Seriously. I majored in Film and landed a 3D modeling job where I had the opportunity to script some aspects of my work with python, so I picked it up bit by bit. The scripts got more and more complex and I graduated to general application development and then just made the leap over to Java. I've now been fulltime software dev for seven years. If you've worked with any other OOP language, Java is merely learning the syntax and you're off to the races. There are plenty of nuances to learn, but you'll pick them up as you go.
Same here, except I read the 3rd edition. I need to learn more that the book thought wasn't worth it to learn though. Great book for beginners though. 
I'd prefer to use a fully fledged caching solution, - ie Google Guava.
Company bought WebSphere, deadline for project, under duress, would not recommend. *Been doing development for 13+ years it wasn't that difficult to pick it up
@markee174 Dukescript *is* running Java on each client. One of the requirements we have to port to a new platform is that there is a JRE. Even in the browser we use a JRE (bck2brwsr or TeaVM). The requirements for the JRE are pretty minimal though, we only need some very basic APIs. @slartybartfast: It allows you end-to-end pure Java development. That's one of the differences. DukeScript apps on mobile phones are not running in a browser, but in a JVM -RoboVM on iOS, ART on Android- exactly like Gluon. The only difference is that Gluon uses a JavaFX rendering pipeline to render the UI, while we use a HTMLRenderer Component for that. Neither are native UIs. The benefit of DukeScript compared to JavaFX(Gluon) is that we have real declarative bindings allowing a cleaner separation of View and logic (ViewModel), so the ViewLogic is fully Unit-Testable out of the box without the need to launch the view (e.g. on an integration server). FXML(JavaFX/Gluon) only has a broken version of declarative bindings and still requires the Java Code to reference the View (@FXML Annotation). In DukeScript I only have to expose Properties in my ViewModel, while in JavaFX I need to expose UI-Components (like Button, TextField). This way View and ViewModel can never be fully separated in Gluon (JavaFX). That also means for example that in DukeScript you can replace a TextField with a TextArea in the View definition and you don't have to touch the Java Code. Another benefit compared to JavaFX/Gluon is the ability to deploy your app as a website to the browser (in that case we ship a JVM with the page that controls the browser and uses it to render the UI).. 
College, work for 10 years, and no I do not recommend it. You can pick it up easily after you learn 2 or 3 other languages. (Especially if one of those languages is in the C family)
Learned it in college. I'd recommend learning it because of its prevalence. I would also recommend learning a good scripting language and something functional. Functional languages are less prevalent but are more fun. Start TDD too.
This book by my professor (sorry its german): http://www.amazon.de/Grundkurs-Programmieren-Java-Programmierung-Objektorientierung/dp/3446228780/ My entire career can be traced back to reading this book outside of class. I can recommend learning Java, because Java has had its stable role for various years. Usually there is the new and cool solution and the robust/complex Java solution. Over the past years "new and cool" has changed. For example there was Rails ten years ago, which was supposed to kill Java, now it is basically fill clientside MVC in Javascript. But the role of the default choice of Java for lots of backend enterprise programming has not changed. You could get a job easily ten years ago with that knowledge and I am sure you will be able to in ten years time. Sometimes enterprises standardize on things that stay consistent even if it is more work/expensive in the short term. Having a consistent set of tools, languages, frameworks saves them money in the long term. Even today business decide pro Java despite its demise having been called for multiple times in the past.
Oh, hello! Lots of AfterHours LPMUD but some others as well. LPC is a very nice little language. I don't know what flavor of MUD you used. I guess LPC turned into Pike later. I have some fun stories from there that I don't get to tell nearly often enough. AfterHours lost hosting once (Cornell's media lab, on NeXT stations, after the DEC cluster at wwu.edu). I asked around all over the 'net trying to find hosting, and a finally made a connection with a Motorola higher-up named Andy Rubin who, as a job perk, had an ISDN line to home and a Sun 3. In game, he declared himself to be an android. I wonder if/suspect that George Reese from The Mud Institute is the same person who went on to write a lot of early Java books.
A I worked for a researcher at the University of Minnesota named Mark McCahill, the fellow who created the gopher hypertext system pre-dating HTTP/HTML. He had a business incubator operating there that he named Java and Web Services (JaWS), apparently established to master cutting edge technologies as they appeared to offer expertise to the UMN as well as corporate clients interested in bleeding edge stuff. Java 1.1 was current when I started working there. I knew C, LPC, AtariBASIC, 6502 assembly, Scheme, Forth, and probably other things already at that point, and picked up Java from _Java in a Nutshell_, 1st ed. I have four of those on my bookshelf now, each twice as large as the previous one. Fun trivia: gopher also has CGI-like dynamic content that was generally programmed in... you guessed it, Perl. I focused on Java a bit while it was mostly in its applet phase, doing multiplayer and single player games. Then I got roped in to other things during the dot com boom, when everyone wanted everything faster than fast and didn't care how unmaintainable it was. I went and got my certification somewhat recently, but I'm still trying to catch up with all of the changes and re-establishment myself as a Java programmer. So I guess you could say that, in a sense, I don't know Java even though I've used it on and off since forever. Edit: Yes, if you're already familiar with OO, permissions, events, lambda, exceptions, etc, etc, _Java in a Nutshell_ is a great way to learn. I also found bookmarking parts of the API reference to be faster than looking things up online, and a big part of it is API reference.
Nothing ever dies, but if a technology isn't growing faster than people are retiring, it's hard to find a job opening in it.
Read the javadocs for various apis and the jsrs, no other source has shit more java knowledge into my skull.
I was working as an almost exclusively C# developer the last years, I was tired of my old position so I was looking for something else and applied for a position as Java developer. Took a few days to figure out some java specifics, the rest is more or less the same as C#. Would I recommend it? Sure, if you get paid for it. :)
It may be hard for you to maintain, but it wouldn't be hard for someone fluent in Chinese. Also, the English literacy rate over there is [0.73%](https://en.wikipedia.org/wiki/List_of_countries_by_English-speaking_population), so English would be a poor choice.
I took a bit in university, then I bought a book and sat in bed for a few days reading, then I programmed a game as an applet and googled the crap out of everything.
https://learnjavathehardway.org/ First 16 chapters are free...... I would say the quickest way you're gonna get going with java.
* Learned Delphi in school (blargh) * Applied for 3 year internship * Company codes in Java * Been working for 4 years there now * I fell in love with backend programming and Java is the tits in that field. I love it. 10/10 would recommend (only if you use Java in Backend development or in App development)
On the last point, I wouldn't describe using Map.computeIfAbsent as "rolling your own"...
This isn't related to Java in particular, but to the fact that SSD allows for much better random access of data than HDD, because the mechanical latency that is inevitable with HDD is gone. If a database has any chance to know what the underlying storage technology is, it can make better choices regarding index layout, or join algorithms, or buffer caching strategies, etc. This blog post explains it nicely: http://use-the-index-luke.com/de/blog/2013-07/afraid-of-ssd
Me neither. I was referring to `Memoizer.memoize(Function)`.
I first learned Java at what we call TAFE here in Australia, I guess that's like a Community College in the US. I learned it in another subject at university. It is a very popular language and a lot of companies have existing software developed with Java. So it would be worth while to learn. Having said that, I'm currently spending my time learning C# in the .NET environment. But they say if you learn one you can easily pick up the other. By all means learn Java if you want too.
+1 for the Oracle tutorials. They were really helpful when I was just starting out.
My uni also only had one Java course. Then I chose servlets as my big senior study topic, and that basically landed me my first job, writing servlets. Yep, 2000. I learned Java in J++.
AWT
J2EE started its life as kind of copy of WebObjects, given Objective-C's influence on Java.
Python is not even close to being dead. It is used very heavily in the machine learning community. Edit: voice to text goes horribly wrong.
I started programming with QBasic. Then moved to Visual Basic 6. After that I loved Python. At the college i learnt C and Java. I didn't like Java, but used it at work after college. I cannot recommend that, because it is hard to find DOS 6 floppy disks and 486 computers (or even floppy disk drives).
Scala is the path our company decided for w/e reason, so I became a Scala developer, because I didn't want to leave. 
Smalltalk had a lot more issues than just not being open sourced. It's performance was poor and it was crazy difficult to maintain larger applications. 
I think these kind of articles should come with a strong disclaimer that they are meant for legacy code *only* (well at least 99% of the time). I am yet to see a good reason to use stored procedures in most new modern applications (exceptions might apply).
College courses primarily. It really helped me learn programming since I had problems learning C++ when it came to pointers and references. Unfortunately when I graduated, I couldn't find any java jobs so I had to fall back to web development with PHP, which I've been doing now for 5 years. Do I recommend it? Very much so. Just wish I did more with it earlier so I wasn't doing web development as my primary career. 
College + internship + work
The tons of python gigs vs the very few Go and Rust gigs would refute your statement strongly.
I learned from teach yourself Java books with lots of examples. Then I made some simple programs that use logic a lot (the basic stuff). Then I checked out the APIs to learn more of what is possible, and I learned a lot from sites like stackoverflow, because I made all the same mistakes as other people. I honestly didn't learn much from a person, mostly from my own research.
Java 8 integrated only lambdas. Some Scala features that are missing in Java 8 are: * [tail call optimization](http://stackoverflow.com/questions/1677419/does-scala-support-tail-recursion-optimization) * case classes and pattern matching * traits See [here](http://docs.scala-lang.org/tutorials/scala-for-java-programmers.html).
WAT
Lol, I will need it. I have no experience in programming. I'm more of the hardware fanatic. 
Can you please provide a more eloquent comment?
Can you please explain DOS floppy disks and 486 computers?
learn java
The only known QBasic compiler runs on the [DOS](https://en.wikipedia.org/wiki/DOS) 6 operating system. The easiest way to run a DOS 6 operating system was inside a computer that has an [Intel 80486 processor](https://en.wikipedia.org/wiki/Intel_80486). The way to install a DOS inside a computer is using [floppy disks](http://cdn2.goughlui.com/wp-content/uploads/2012/11/IMG_0065.jpg). Another way is to [run a virtual machine inside VMwave](http://www.qbasic.net/en/qbasic-downloads/DOS/DOS-622-vmware.htm). Now the best option is to switch to [FreeBASIC](http://www.freebasic.net/). Now I feel really old. :-D
Learned msx basic at a young age by manually entering basic listings from magazines. Then learned turbo pascal at programming club in highschool. I started with java by decompiling and manually de-obfuscating a java chat applet so i could make my own better version of it, checking the sun.com tutorials when needed. Was pretty fun but not recommended unless you have prior programming experience and lots of time. After that university and 10+ years of 'real' experience at various companies
I wouldn't say *legacy*, but I do feel like Hibernate and such made them less necessary. 
Yes! Let's spend thousands of dollars on the best enterprise databases available in the market and use only plain SELECT, INSERT, UPDATE and DELETE statements on them!
Except a semicolon is incorrect there. 
&gt; I'd say about 2230 months by now. So what's your secret to a long life? 
Got any guides or resources on using a web front end to a Java application? I'm a web developer by trade, but don't immediately understand how I would make the two work together.
A "learn java in 24 hours" (of work) book No, i got confused as hell and ended up learning python
It was more a bit of tounge in cheek, but as someone that has developed in both languages over the years, I've found that java positions are on average more varied, more challenging, more versatile(*), and offer better pay then their PHP counterparts. It's just a much better choice career wise. * - By this I mean that you're not only not piegonholed to just doing web work, but it's easier to switch languages. Having Java experience and applying for a PHP job won't be an issue. Having PHP experience applying for a Java job is worse then having no experience at all. EDIT: Small sample size of course.
It's not hard for me to maintain, and programming in Java requires a decent vocabulary in English. It's significantly harder to remember syntax if you have absolutely no idea what **English** words like public, static, void, null, etc mean. The idea is using Chinese would practically lock any developer that is not fluent in Chinese out, limiting your options for future maintenance. Why would any business want to limit their own future options?
Download [Apache Tomcat](http://tomcat.apache.org/download-80.cgi) to your laptop, then modify one of the example webapps and/or .jsp files that comes with it.
&gt; It's not hard for me to maintain, But...you stated in the previous comment that is *is* hard to maintain? &gt; programming in Java requires a decent vocabulary in English. It's significantly harder to remember syntax if you have absolutely no idea what English words like public, static, void, null, etc mean. It really doesn't, and there are quite a number of developers who have an extremely limited English vocabulary. Clearly this is anecdotal (as I can't find any stats), but the 0.73% English literacy rate in China should support this. The same is true in Japan, and various other countries. All you need is a few keywords, and knowing roughly what they mean. They can be explained easily in a different language, and then it's just recognising the phrase while developing. &gt; The idea is using Chinese would practically lock any developer that is not fluent in Chinese out, limiting your options for future maintenance. Why would any business want to limit their own future options? That's the thing - if your company is Chinese, and you're developing a product for China, then why on earth would you be concerned about limiting your maintenance options? You have millions of developers fluent in the language that your codebase is in, so replacing them is trivial. If your product also doesn't have a long lifespan (say under 10 years), then it would practically be wasted money to hire only developers fluent in English.
Not just you. It's verbose but not unpleasantly so, especially at the enterprise level where it truly shines.
It's hard for a majority of programmers to maintain. Enough of a majority that economic effects are significant. What I mean by the difficulty of vocabulary is that from a foreign perspective, the words don't make sense until AFTER you are proficient with the language. For English-fluent people, Java is much simpler to learn, even though in Java the words have specific and narrowly defined meanings, they are still borne of English. This is not true for the Chinese developer, or indeed the Russian mathematician either. For such people, there is only rout memorization, and that's a lot harder. Put yourself in their shoes, what if instead of public static void main, you had to type  every time? My point is simple. If you are not fluent in English, Java's syntax becomes much harder to memorize and use. The idea of a double or array is something that is language agnostic, but the syntax isn't. For English-fluent people, one only has to select the primitive, or class, or whatever, they want to use, and type it. For every other person, they must select the item they want to use, and then also recall the syntax for it as well as the spelling. And I never suggested using English fluent developers. I'm simply saying the code would be much served to use ASCII characters instead of Unicode. As even relatively gibberish names like int AAAAA or String user50 would be vastly easier to maintain while being just as easy to maintain for the Chinese-fluent developers. It's trivial and very advantageous to use ASCII over Unicode.
Java For Dummies. I hate to be critical, but I would not recommend it because it was missing a number if fundamental parts. I kind of think that the author's hands may have been tied by Wiley (publisher). I ended up relearning most Java through online tutorials, and I've decided that I'll go O'Reilly for future books, if not just online tutorials.
Mostly
JavaFX.
If you want something simpler and easier to start with and have working right out of the box, there's also Spark. It's especially good with Java 8. http://sparkjava.com
Very interesting. Do you have any links? I have tried by searching *smalltalk waterfall methodology* but found nothing interesting.
This. JavaFX with the Builder is a really great thing.
&gt; JavaFX with the builder Do you mean Window Builder? 
Most of the guides on the Spring website (if that is what you are using) assume you have a correctly configured development environment and have programmed in Java before. Do you have a JDK installed? Do you have Maven installed? Do you have Gradle installed (you should only use Maven or Gradle, not both). Are you using an IDE? Is your IDE configured correctly? Too many unknowns here to help you further. You may get more help posting in /r/javahelp and providing more information on what is going wrong (error messages, stack traces).
What kind of problems are you having? Have you tried some of the [spring.io](http://spring.io/guides) guides? [This one in particular](http://spring.io/guides/gs/spring-boot-cli-and-js/) covers all the points you mention.
I currently work with these, and they aren't as confusing if you walk through and take the time to learn them. An important thing to realize is what each of those things is. Spring and Spring-Boot shouldn't be used together, you should choose one over the other. The same works for Maven and Gradle. Personally, I like the simplicity of Spring-Boot with Maven, but I have coworkers who love Gradle and Spring. 
[For the record, here's the direct link to the library](http://www.jinq.org)
Yes, but how does this relates to Smalltalk?
My suggestion: download netbeans (of the 3 java ides; netbeans, eclipse, and intelli j, netbeans is the easiest to use) here: [https://netbeans.org/downloads/](https://netbeans.org/downloads/) grab the "Java EE" version. Then just create a new "java web" project, and use jsp for templating / html. Doesn't get any easier (in java land) than that.
&gt; why this is so complicated. The reason it's so complicated is because Java is heavily used in big companies, with big and/or complex projects and teams. The features that tools like Maven provide, and Java itself when it comes to dependency injection etc., make it possible to deal with the complexities of these projects and the environments they're developed in. But much of this stuff is huge enterprise-grade overkill if you're working on your own, or even in a small single team. You're basically asking why the Space Shuttle doesn't make a good commuter vehicle. That said, part of the point of tools like Spring Boot is to make it easier to get up and running, and hide the complexity from you until you need to deal with it. However, they can't completely eliminate that complexity. 
This is what I'd recommend for a newer developer. There are a lot of standards and stuff that you shouldn't be expected to know as a new guy. People using Java all day tend to forget that a lot of this stuff isn't common knowledge.
OMFG, I know, right? The platforms themselves seem simple enough, but then there's always a maze of bugs and dependencies and little things that don't work right, and non-sensical debug messages, and an incompatibility with this package, and a change that's not reflected in the current tutorial or documentation or example you're working with, or an assumption about your development environment that's left unstated, etc, etc, etc... 
Did JavaFX really ever get off the ground? I've never seen or even heard of it being used anywhere.
I'd do spring boot if I were you. It's a lot less configuration... it's basically spring with most of the configuration done for you with 'sensible' defaults. I doubt you want to make things more complicated. The spring boot reference guide is pretty good imo too. edit: also those spring boot guides have maven examples too, you mentioned you only saw gradle. That's a different topic though, if you like gradle go with that. 
mkyong.com has some good simple guides for Java web development.
NASA did. [Developing NASAs mission software with Java](https://jaxenter.com/developing-nasas-mission-software-with-java-108114.html)
I was going to say the same. There are plenty of languages where you can write a few lines of code and you're done. That's as complicated as the process gets. Mostly I'm replying to you though to complain about JavaScript. I've been using it for 10 years, and just within the past 2 years the ecosystem has gotten very complicated. We're getting to the point where it's hard to do something simple in the language without dealing with gulp/grunt, bower, npm, browserify/webpack, and a slew of other build tools. I feel bad for the young people who are just now learning the language.
I always hear this justification, yet plenty of enterprises rely on dynamic languages with simpler stacks to carry out their critical business, for example PayPal. I can appreciate that the JavaEE and Spring stacks are flexible, but that doesn't excuse the extremely jargon-heavy and unwieldy (and often times incomplete) documentation. The maxim "simple things should be simple, complex things should be possible" comes to mind. Also note here it's JavaEE that's the problem, not Java. Java the language is pretty straightforward and easy to grasp. It's the EE stack where things get difficult. There are other web frameworks in the Java ecosystem that aren't nearly as cumbersome, but JavaEE and Spring seem to have the biggest communities, yet are the most difficult to break into.
i came here to provide this exact same advice. i've been a pro java dev now for about 17 years and since i started using Play Framework (i haven't made the leap to 2.x yet) it's made java fun (again) -- i had been stuck in the horrible worlds of websphere/weblogic for many many years.
It's used in a lot of places. Wherever Swing was used where devs are upgrading. Although Desktop apps are not "cool" anymore, JavaFX is the nicest most modern GUI toolkit out there today.
Why? What's wrong with it? You mean in the past JavaFX didn't have one? True. But it does now.
To learn Java, I developed a java library and put it on github. Try to develop anything right away. All problems you'll have will teach you Java.
ahh. thanks for teaching my 20 year old self.
.. didn't work.
&gt; yet plenty of enterprises rely on dynamic languages with simpler stacks to carry out their critical business, for example PayPal. I would say that Java EE done by a skilled team that understands what they're doing will result in a much more elegant and easy-to-maintain system in the long run. There's just a LOT of plumbing to rig up beforehand. The real test with those "simple" stacks built on top of dynamic languages is 5, 10 years down the line when it ends up, more times than not, looking like a steaming pile of spaghetti code and one-off hacks.
Thank you, I never knew that was a thing. 
After 20 years, I still haven't worked out what Spring improves, but Maven is awesome. Download netbeans and use its integrated maven support to add all the libraries and dependencies you need. It's not a web project but my demo code for DBvolution at https://github.com/gregorydgraham/DBvolution-Demo might help with getting familiar with Maven.
I think from the bunch of suggestions for different frameworks and approaches (spring boot, maven vs gradle, play, servlet + jsp, etc) you can see there's a bunch of choices depending what you're looking for: configuration vs convention, frameworks that expect large apps that help manage complexity vs approaches that are simple to setup for smaller apps but get painful as they grow, etc. If you're working on a web app for a school project unless you really want to get into configuration for enterprisy apps it's best to pick something that is as simple as possible to setup so you can start building the app you want to make instead of sweating about config and environment setup. I think the simplest to get up and running is grails (using groovy for build + src, so not java but runs on the JVM) using a sample project like [this](https://github.com/grails-samples/grails-petclinic). If you're set on using java &amp; spring [this](http://spring.io/guides/gs/spring-boot/) is the tutorial you'll want to use to create a hello world web app using gradle/java/spring boot.
Cool! Any benchmarks to entertain people with? 
Other option would be Grails - very easy to get going, make simple forms, validations, etc. When you need more - there's same preconfigured Spring Framework under the hood. It is not exactly Java, but runs on JVM and Groovy understands 99% of Java syntax.
Check out jhipster
By "modern", I'm sure you mean [this](http://i.imgur.com/ODvxrHb.png)
Current version is 8.0.0. Oracle isn't distributing binaries anymore, but you can find them here: http://gluonhq.com/open-source/scene-builder/
Most of notably Java shop usually don't use JavaEE at all.
C# is a nice language. got some good features. But I found the build system and nuget and bit rubbish. But yeah, you'll get downvoted, I mean c'mon its the java thread.
I used to use eclipse when i did it. Most tutorials would walk you through the set up.
If you want to use Spring Boot, have you read the [Getting Started](https://spring.io/guides/gs/spring-boot/) page? The Spring documentation is fantastic, and you can get started literally by writing two files - one build script and one Application file. Once you've done those, you can then get on and write controllers, business logic, and so on.
there is a reason people use RoR/Python/PHP and whatever they can to avoid Java for web dev.
don't use spring, spring-boot, maven, and gradle... until you fell you have to... they generally create more problems than they solve. instead, start with standard servlet, jsp, jsf examples on a simple server like jetty, on an integrated ide like netbeans. 
Please take this discussion to /r/javahelp. This isn't the place.
If make one using FXML , youll find some really interesting glitches.
Dang, yes it is. That sucks, since it's the exception explicitly in place to wrap when you call another method that itself threw a checked exception that you weren't prepared to handle...
&gt; One does not simply run a Java EE application. Except you kind of do. Modern IDEs make it a point and click affair. &gt; But then you also get a lot of features that you rarely use. The current Generation of Java EE app servers start up in under a second in most cases and only enable the features as you use them. So this is completely not an issue unless you're worried about a few MB of jars just sitting on the hard drive. &gt; The web profile, consisting mainly of simple servlets, Uhhh..."simple servlets" are one of **17** APIs available in the EE 7 web profile. It's clear you're a Spring guy, and that's fine. But please don't spead mis-information about Java EE.
If Jetty is ok with you, but you just do not like the Java build systems and/or IDE's, I have here a todo-app example that builds with `make` and downloads its own dependencies: https://github.com/ysangkok/jax-rs-ng-todo If even Jetty is too heavyweight for you, I have written a short tutorial on making a FastCGI server in Java: http://stackoverflow.com/a/15033764/309483 The FastCGI URL is dead, use this instead: http://web.archive.org/web/20131012011650/http://www.fastcgi.com/devkit/java 
Amazing work!
A standard Rx-style API based on [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm) called `Flow` [will be part of JDK 9](http://gee.cs.oswego.edu/dl/jsr166/dist/docs/).
Ha, I'm not at all a Spring guy, I'm actually a Java EE guy. Deploying applications from an IDE is quite annoying, I usually just use build scripts or do it through Maven, although this isn't ideal as well. Under a second? I wonder where you get that number. A bare Wildfly install on my Windows 7 with SSD starts in 6,5 seconds. And I consider that fast, because I'm used to Glassfish. Simple Servlets is obviously a term to encapsulate servlets and things related to them, like JSTL and EL. Web profile has everything you need to make a "simple" web app with a Java-based frontend (JSP, JSF or REST-services) and some database underneath. Actually, EE 7 Web has only *16* APIs, but it boils down to these 5: - Common Java stuff (2) - Servlets and servlet-based front-end stuff (7) - Database stuff (2) - CDI stuff (2) - Bean stuff (3)
Ah a solution to a problem I never had. 
Ok, guess I exaggerated a little for this one: Info: Payara Server 4.1.153 #badassfish (225) startup time : Felix (1,170ms), startup services(1,469ms), total(2,639ms) Info: GlassFish Server Open Source Edition 4.1 (13) startup time : Felix (1,130ms), startup services(467ms), total(1,597ms) [We're both wrong](http://download.oracle.com/otn-pub/jcp/java_ee-7-fr-eval-spec/WebProfile.pdf), it's 18 APIs: * Servlet 3.1 * JavaServer Pages (JSP) 2.3 * Expression Language (EL) 3.0 * Debugging Support for Other Languages (JSR-45) 1.0 * Standard Tag Library for JavaServer Pages (JSTL) 1.2 * JavaServer Faces (JSF) 2.2 * Java API for RESTful Web Services (JAX-RS) 2.0 * Java API for WebSocket (WebSocket) 1.0 * Java API for JSON Processing (JSON-P) 1.0 * Common Annotations for the Java Platform (JSR-250) 1.2 * Enterprise JavaBeans (EJB) 3.2 Lite * Java Transaction API (JTA) 1.2 * Java Persistence API (JPA) 2.1 * Bean Validation 1.1 * Managed Beans 1.0 * Interceptors 1.2 * Contexts and Dependency Injection for the Java EE Platform 1.1 * Dependency Injection for Java 1.0 You can do a lot more than "simple" web app with that.
The code coverage tool?
Personally I'd *love* to see the Java world get to grips with higher-kinded types, implicits, monadic for-comprehensions, cokleisli instances, type-level programming and the cake pattern. If by "get to grips with" you mean "run around flailing and soiling itself in panic over"...
&gt; I always hear this justification, yet plenty of enterprises rely on dynamic languages with simpler stacks to carry out their critical business, for example PayPal. First, you're implicitly reversing the logic of what I wrote, which was "The reason it's so complicated is because Java is heavily used in big companies." In other words, its use in big companies has contributed to its complexity. That's an observable fact, not an opinion, and it doesn't conflict with the idea that "plenty of enterprises rely on dynamic languages with simpler stacks." Although as a separate issue, I would dispute "plenty of enterprises rely on dynamic languages with simpler stacks," since the claim depends greatly on what you mean by "plenty", what you mean by "rely on", and what size of enterprise you're talking about. &gt; plenty of enterprises rely on dynamic languages with simpler stacks to carry out their critical business, for example PayPal. Paypal is a baby enterprise at best. In many ways, it's an old and large startup. For comparison, the company I'm currently working at has 9 times the employees of Paypal, 28 times the revenue, and is 123 years older. Like PayPal, we use node.js on some projects, but we use Java much more heavily. One thing that enterprises value is stability. Java is 20 years old now. node.js is 6 years old. You can argue that Javascript is about as old as Java, but for most of its life it didn't have much serious use outside the browser, and as such its infrastructure is not that mature. Another feature that's important to enterprises is the commoditization of skills. You don't want the business to depend on being able to hire superstars, because that makes it hard to maintain an operation with tens or hundreds of billions in revenue. In Jeff Harrell's piece about [node.js at PayPal](https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/), he actually wrote "This model has fallen behind with the introduction of full-stack engineers, those capable of creating an awesome user interface and then building the application backing it. Call them unicorns, but thats what we want..." This is a startup mentality. Paypal can presumably get away with this (or thinks it can) because it doesn't have a very diverse business, it basically gets a lot of leverage from a relatively small software core. At my company, I work with a dozen product teams all working on different software products - and I'm just in one division, at one geographic location. From an enterprise perspective, what Paypal is doing is effectively an experiment, similar to our own use of node.js. It just has a relatively wider impact at Paypal because they're a much smaller company, and much more web-centric. So let's talk again in 10 years and see what Paypal is doing then. In the meantime, large enterprises will carry on doing what they do best, which is being risk-averse and holding on tight to existing proven models - and helping to add complexity to systems like Java to support their needs. 
&gt; 5-10 years down the line everything looks like rubbish. I would say that's a defining feature of the distinction between the kinds of systems that large enterprises strive to achieve, vs. smaller businesses. One of the systems I work with was implemented in the late '90s, so is coming up on 20 years old. It's not rubbish - it would stand up to any modern Java system in terms of its design and implementation. It was implemented in Java, and is maintained by upgrading to new Java versions periodically. That stability is part of why enterprises like Java. 
&gt; So I just fear that if Java community continues to accept and justify this complexity, competing platforms will win at the end. So what's wrong with that? It's the way it should work. You can't have it both ways - Java can't be a stable, slow-moving language for enterprises, but also be the coolest hot new thing. 
Congratulations! You've invented a poor man's Lisp. :-)
I think /r/programminghorror is leaking.
I didn't count Websocket and JSON-P, are they new in EE 8?
How well does this work with APIs that use JavaBean properties, e.g. person.name?
No, they're in EE 7. Tomcat even implements the Websocket JSR now.
JAX-RS, usually RESTeasy as I tend to run Wildfly more often than not.
I'll stick with Freemarker templates, thanks.
When I was in university, Java hadn't even come out yet. At that time, I was learning C and I transitioned into Java which was gaining a huge amount of momentum by reading Bruce Eckel's Thinking In Java books.
That's pretty cool. I didn't know that, still working here with the 2.0. Thanks!
I am glad this is a dying programming langauge. The last piece of shit to use this is autism blocks and hopefully from then on no one maeks anything popular in java ever again. im glad people are realizing this is an awful lanaauge to work with.
Fuck yeah, downloading maven at 10kb/s because thats the cap Eclipse will let you download it at. 10 fucking kilobytes a second wow. Its like they just love to waste as much of your fucking time as humanly possibly. I could type the raw 1's and 0's out by hand faster than this piece of shit downloads it
Its now 13 minutes since I made this reddit post and now I am just back to were I was when Eclipse decided nah I dont wanna work anymore 
Alright and NOW, I got the plugin compiled. 2 hours later. Fuck java
You really should not be using regex to parse HTML except for the most simple cases.
I've used DropWizard and Vert.x. 
That is horrible. An HTML generator based on string interpolation (like in Scala and Groovy), that uses actual HTML syntax, would be great.
Too bad those don't have static type checking and such.
One that, somehow, manages to be even uglier.
So... why not Moustache?
If you think Lisp is ugly you've missed out. I really recommend [this (now free) book](http://www.paulgraham.com/onlisp.html).
Ugh, I just decided to downgrade. At least I was able to figure out. 
All my import statements do not work. For JavaFX.
Just use IntelliJ IDEA.
If it is urgent download BlueJ or DrJava, and then try to find a solution.
Not sure if i've learned Java yet. But I learned C#/javascript on pluralsight. And am learning java there now. So far so good. They have a lot if videos on frameworks and best practices. Which I get a lot of value from
Jersey 2.x
Well, code like this -- while cool -- is really too magical. You realize this adds symbols and a sort-of macro system to a simple call-by-value language. It basically changes the semantics of the language. Other projects that are also magical, like Lombok and Checker, at least go through Java's official "macro" system -- annotation processing. This uses runtime reflection to introspect the compiler's symbols -- just like Lisp -- in a very non-Lisp language. It's a very clever hack, though.
why dont you use zencoder or AWS encoding services? ps http://developer.android.com/reference/android/media/MediaCodec.html
I just hope they do it right. They got the right people for the job though. Personally i wouldnt mind if they break backwards compatibly. It shouldnt be that hard to refactor existing code for a new version. Its also a worthy investment for a company. 
MP4 is only a container format, and jcodec already encodes h.264, so now all you need is a library that can encode MP3/AAC/etc. and another library that can mux together your audio and h.264 streams. jcodec might not support audio codecs but maybe its muxer supports a third party audio stream, or you could try this [mp4 demuxer/muxer lib](https://github.com/sannies/mp4parser).
But jcodec supports MP4 muxing, so your problem is not in the MP4 side. If the audio you want to add is already encoded as AAC, then jcodec works, so what you really need is to encode sound from some format to AAC, right? In the jcodec page, the maintainer says that AAC encoding is in the works, and in github, he has integrated JAAD to the project, so I suggest you give a try to that code before doing something more complex. Other than that, I would try to make LAME work with nestedvm or do a platform specific branch in the code and use javax.sound + MediaCodec + AudioQueue
This worked. Sorry if I seemed a bit short, I was hungover. 
Windows at work for primary machine, but we have Macs and Fedora machines for testing/build servers. Arch Linux at home.
My office is on 15" Macbook Pros with maxed out cpus and ram. Sometimes it's a bit much, but there's nothing more frustrating to me than typing lag because something is building or intellij decided to reindex the world in the background
:O Are we the same person?
I use Linux with IntelliJ. It's pretty much up to you. For me, I need the command line Linux has. Doesn't hurt that I like the FOSS principles too.
&gt; Today I have released Hibernate ORM 5.0 (5.0.0.Final). Reads like Steve Ebersole is the sole developer of Hibernate. Which would explain why it is taking so long to implement long-awaited features.
current state of affairs, I recommend against Lenovo as a laptop company. I would suggest Asus/dell/samsung/ Sony vaio over Lenovo. I think only dell gives a Linux options Also though pricier, a "work" series laptop is better than a home/home office part of a website Edit: reasons * [Malware](http://arstechnica.com/security/2015/02/lenovo-pcs-ship-with-man-in-the-middle-adware-that-breaks-https-connections/) &gt;https://support.lenovo.com/us/en/product_security/superfish * [Persistent Crapware](http://arstechnica.com/information-technology/2015/08/lenovo-used-windows-anti-theft-feature-to-install-persistent-crapware/) &gt; https://support.lenovo.com/us/en/product_security/lse_bios_notebook 
Thinkpads are still unbeatable, even if they are not as good as they used to be. Better yet, get an older Thinkpad and upgrade it with an SSD. I have an X230 and I love it.
At work I'm on a windows 7 laptop that is almost a real OS with chocolatey for a package manager and cygwin for a shell, servers are redhat linux &amp; AIX. At home I use either a linux desktop that I use for gaming/dev/home server or macbook pro with OSX for dev but mostly clojure in emacs, when I'm working with java for work or on the desktop it's in eclipse. The linux desktop is on ubuntu but I've been messing around with other distros and will likely change again soon. I've used fedora &amp; debian and a bunch of other based on the two in the past, and settled on ubuntu because it was simple to setup &amp; maintain and I was looking for a windows replacement. Now I'm looking to sacrifice some stability for something that is updated more frequently, either something on debian unstable or arch/arch-based.
At all my jobs it's been Windows desktops mostly with eclipse IDE, with Linux servers, sometimes Unix. Well now even some iSeries servers. 
CPM on a Z80 with 256kb of bank switched RAM with serial IO connected to a DEC video terminal.
ASUS laptop with Ubuntu provided by my employer (nice thing, 16GB, 2SSD's), pretty shitty HP Windows laptop supplied by the customer because what we're building depends on a Windows MATLAB runtime :( Downside of the ASUS: great specs but the build quality is shitty (my screen detached itself from it's casing). With knowing what I know now I would've requested a macbook and installed Linux on it.
Just curious: if the server ecosystem is all Linux why not use Linux on the desktops too? 
I've heard of security issues with manjaro when I was doing the same research a year ago. I went with antergos for some of these same reasons and am very happy with it after a year of use. I use it almost exclusively now. It's also arch based.
A 13 inch Apple MacBook Pro from 2011 with an 2.7 GHz Intel i7 and 16 GB of DDR3 RAM. The build-in graphics chipset isn't that great, but also not that important for Java development, so it generally quit a capable machine. I'm "still" running Mac OS 10.9.5 (with Mac OS 10.11 "El Capitan" releasing soon, that's almost two version behind), mainly because I haven't yet find a good reason to upgrade. For me, one of the best things of Mac OS X is that it's based on UNIX. This means that many of the powerful frameworks, software and CLI tools work just as they would on a Linux system, only without the hassle and DIY that Linux sometimes hinders you with. So my question is: what is currently hindering you in OS X that you think can be done better with a Linux distro like Ubuntu?
Lucky you. I have windows 7 at work. What a worthless piece of shit. *command line* is just a bad joke on it so I use cygwin. Hardware wise, it's Dell Latitude with i7 and 16GB of RAM.
JavaFX can play mp3 and some mp4 and is available in all 3 platforms.
At work an home both Linux and NetBeans.
The installation of Arch is easier than it looks and the pros are too good to pass up. 
Lenovo running Arch Linux.
Thinkpad x230. Fedora/Debian/CentOS. Wouldn't have it any other way.
Linux Mint Cinnamon + Oracle Java + Netbeans.
Win 10 IntelliJ. New Java programmer, anything I should know?
I don't have a job yet, so it's pretty much just up to me what I use. I'm still in university. If you wanted, you might be able to run a Linux distro in a VM. You definitely have the RAM to do it. Edit: I don't really care that I was downvoted. I'm just curious as to why. OP never mentions that it had to be work machines. Does the fact that I'm a university student detract from my experience? What difference does it make if I'm being paid for my coding versus not? Especially when it comes to what OS I use.
Thinkpads with Windows 7. Deployment into Windows, Red Hat and Ubuntu servers.
On my case, because Linux doesn't do the others applications required by the company. There is more to it than just Java coding.
xubuntu + netbeans at work, centos for deployment, ubuntu at home
Current model 15" macbook pro
Linux servers work very well with windows desktops so that doesn't force you to either side. Secondary requirements like specific software tend to be in favor of Windows. 
So you're a colleague of him?
No I'm not, don't know the guy. 
I don't get all the specific answers here. If it runs IntelliJ, it's fine for Java Development. If you have other/more requirements, I might have a recommendation, but for Java, it just don't matter really. 
I had a similar experience with them as well. So. Many. Calls. And more after I explicitly told them to stop contacting me in any way, shape, or form. I like to think there's a special place in hell reserved for their sales/marketing dept. 
Same with phone calls for me (received a fair few calls) - every call I said I wasn't interested and that I wanted to be removed from their contact list. Eventually they gave up, but it was a lot more hassle than it should have been.
I'm working on Lenovo Thinkpad too, I am very happy with it. About malware... my Employer provides me with a percect bundle of malware/spyware on their own, which makes me unmoved when it comes to additional "goodies".
You must buy a lot of Viagra :)
I had to block their phone number because of this. I had a license back when it was cheaper, great product, but yea...
At work we use computers running on windows, deploy on windows-vms and have the build-system, etc set up in a linux-environment (I never get to see any of that except the webpages). Since the applications we are building require a shitload of resources, we have relatively heavy machines, mine (I am just a student) already running on 8x4 GHz CPU, 16 GB of RAM and a 500 GB SSD and hell, I can get a coffee until the servlet-container is ready or maven has finished a build. It depends highly on what you want to do and what you want to develope for I think. Other than that it pretty much does not matter as java was originally designed to be platform independent ;-)
We don't really have a choice. We get Window's PC's as our main machines at work, 90+% of our clients are on some version of Windows so and being a Java application we don't have seperate Linux/Mac trunks so we just pop over to one of the common Mac or Fedora machines to test Linux/Mac specific issues or bugs. If I had a choice, I would certainly choose Linux to use at work. I miss having access to a shell (although I use PowerShell occasionally for some stuff), although we use SVN and the TortoiseSVN is a really really nice tool that doesn't really have a good counter part on Linux (RabbitVCS is ok I guess, and modeled after TortoiseSVN, but no where near as good). 
I am not the original commenter, but I am forced more or less by my employer to use windows. There is a process they say and you don't change that process just because you like something else better. We officially develope for windows-systems and are supposed to be 100% windows-compatible while other OSs are more or less ignored. I have never set up anything else than windows-vms for live-systems. 
I've used Arch for over 2 years and never had an update break anything. I think this is a huge myth about Arch. Manjaro really just gives you an easier install. 
Also not to forget that both Zeroturnaround and Takipi have multiple accounts spamming "blog entries" to Reddit.
why are you calling it a DSL ? it looks like a pure library, ie valid java. is there a preprocessor step that i'm missing ?
We have ~2 Java developers, meaning one main developer, something like a 3/4th developer (me) and a 1/4th developer. Our main developer uses Ubuntu and Vi. I use Windows 7 and Eclipse. And the other guy uses Mac and TextWrangler. We mainly deploy to CentOS machines centrally and to Windows Server 2012 on VMs at clients.
In fairness, ZeroTurnaround do some decent research for their whitepapers. But then you have to give them your email to get at the thing. 
We've gone back from pure knockout on the client with json from the server to rendering initial state on the server with GSPs and letting knockout take over. Pure client-side definitely reduces development complexity but on slow connections it can give an unacceptable user experience. 
at work MacBook Pro at home Windows 10 both with IntelliJ
Probably not what you want to hear, but just enjoy the downtime before your new job starts. Ask your colleagues what to read up on once you've settled in and your role in the team has been decided. You shouldn't have to cram before starting a new job (unless you gave them false expectations during the interview).
That is rediculous. Use a mailinator email address next time.
We ended up blocking their calls. They are WAY to aggressive in their marketing.
I have no idea, JAAD was merged 8 days ago, but I'm afraid that in your scenario, the new stuff will only be usable if all you want is to convert from one AAC format like AAC-LC to other like HE-AAC. If your source is a PCM stream (like, coming from the microphone) or a MP3, then jcodec doesn't do AAC encoding yet, but it will still do the muxing from you if you can do the audio encoding in some other way.
windows 3.11
Why? And report for what? For not being a comment about "News, Technical discussions, research papers and assorted things of interest related to the Java programming language"?
It's even less related to any of the points mentioned in the sidebar. Since you already have replied I take it that you have read my message and yet you haven't edited the threat out. You have one last chance 15minutes from the time of this post to correct your post. Otherwise it will be removed and you will be banned.
Boy, you hit the nail on the head with a sledgehammer. With me it was 1000 x worse: they somehow found my phone number, and would call me every other day. I started negotiating (on behalf of a previous employer) some licenses. Eventually, I could not secure the deal (due to reasons beyond my reach), and here is the mail I got ON MY PERSONAL ACCOUNT: "Hi Bubinha, I'm very disappointed to hear the most recent news after all of our discussions. From our conversations I was under the complete impression that once the migration was complete you had the green light to move forward with the JRebel purchase. What went wrong? I had my Director go to bat with my COO to get a substantial amount of discounting much to my COO's dismay and now I have to inform him you will no longer be moving forward. This just doesn't look good on me at all. I hope you understand. This is very devastating news and I strongly suggest you reconsider or even start with half the licenses you had intended to acquire as a proof of concept. Thanks, An Irritating Salesman" Fuck!!!!
That's not entirely true. I've had a working jee app on windows, which didn't work on a linux server. The cause?: wrong case in a jsf uri (linux is case sensitive, windows is not)
This subreddit is not for "help with programming questions" as is pointed out in numerous places. The post should be in /r/javahelp, but not directly linking to stackoverflow without any explanations. **Post removed:** code help / wrong subreddit
That seems to assume IntelliJ can handle *all* your dev tasks, which I find to be very far from reality. 
I don't doubt that for a second. And I'm positive there's many brilliant engineers working for them. It's just the shoving-it-in-your-face attitude that I can't stand.
Had a very similar experience with NewRelic
Try to make your own little/side project using these pieces of tech. Even when you start seriously your new job you can always go back to your testproject to expriment different configuration. 
Our experience as well. One of my coworkers was foolish enough to give them a try. They found out our company phone number and called him all the time. We are small enough that we eventually pulled in the director of development who told them, politely, to go to hell and stop calling us.
JRebel really pissed me off. I didn't give them a real phone number, but had to use a real email, which ended up being @companyname.com. They ended up calling company HQ asking for me several times, and I received several annoyed emails from the receptionist.
You can implement the guice integration yourself. It's not that hard actually. I have done it in the past but we switched to Resteasy and CDI meanwhile.
I had JRebel staff add me on LinkedIn to try to sell me shit. Like with anything, desperation is a major turn off.
Thanks for this! I had a colleague give one of these jrebel sales rep my contact info. I immediately started getting calls. I tend not to answer from area codes I don't know so I let it go to voice mail. They NEVER leave a message. They called almost 2x per day for weeks. I also got a linked in request which I ignored. I am tempted to try this product but the sales/marketing aggressive nature is a huge turn off. 
Im 1st Year running win7 but have used linux command line a bit for c programming
haha, no. use mailinator for a real spam-free email inbox. you just make one up as you go. and they have many domains should the main one be blocked.
Not trying to spread FUD about Arch, just from most of the people I've talked to in person or online at one point or another had a big headache trying to fix things after an update. Also from what I've read Manjaro holds Arch stable in Manjaro unstable/testing for around a month before releasing. I don't mind the delay for a little more stability since I'm coming from a distro+branch that is way slower, the risk comes in because they don't back port security patches so next time ssh or whatever has a security issue I'll probably be stuck waiting a month or at least a couple weeks for the patch. For most stuff that's fine but it seems a few times a year something pretty major has a security issue discovered. The other option is going straight Arch and I'm just not sure I want to put the time into it now. Another option I was looking at was openSUSE tumbleweed but I haven't had the chance to try a live boot or read into it too much to see if there's anything like the security issue with Manjaro.
I wonder if this counts private repos as well. We have a crapload of private github Java repos where I work. 
Zeroturnaround is famous among my colleagues to be PITA over the phone. Three of us evaluated the product and finally bought JRebel, XRebel or both. But that didn't stop the phone calls. Worst marketing nagging ever.
Sager laptop with 32GB RAM and Fedora. CentOS in production.
Java can say thanks to Android to be at this second position. There is a lot of Android projects in the total of Java language repositories.
I second to start your own little side or test project which uses both Spring and Hibernate. If possible, do note the different types of configuration options provided by both frameworks e.g. XML vs annotation. 
Windows 7 at work. Ubuntu at home. All deployments done on Linux servers.
It's a great product, but if you use your work email during the trial, they *will* phone your boss, if they can find them
Well, he's the sort of person who thinks he's above tools that help the developer, like syntax checking, auto complete, refactoring, code generation and style formatting. Anything that has a proper UI and isn't done by using a Linux command line combo is evil.
Wink and MOXy on WebSphere CXF on TomEE
Oh how I know it - I'm just glad I don't have a phone on my desk. Every so often someone walks over with "theres a call for you...." and it's ALWAYS JRebel.
Probably because of ms office and lots of other apps that only exist on Windows. I work in large companies which do quite a bit of dev, but software is not their business, do I suppose they are also trying to keep some homogeneity in the desktop environment.
Lol, this is a very common setup that works pretty well.
I like what you've done with that! It's a little more involved than the use case that I required at work. I suspect that I will make a small update to throw a specific exception (as in yours) to differentiate wrapped checked exceptions from other runtime exceptions thrown when not provided with an exception function.
I was asking that guy specifically why they choose to go all windows instead of letting people pick. I know you can dev on Windows; I'm currently doing it for a customer too unfortunately. 
If youre measuring coverage of your tests youre doing it wrong.
I would first find out what versions of Spring and Hibernate they are using before you start your cramming sessions. 
Make sure you know which version of Spring they are using, and which parts. If you're not familiar with inversion of control and dependency injection, I would suggest to look at that, and how Spring handles them.
Be consistent.
Thanks for posting this. As someone that is trying to learn the best practices for dev marketing this really helps and shows how aggressive sales really annoys developers, no matter how good the product is. I wonder though on how many developers this kind of marketing does work. 
*authentication
Well, we share whenever we have something new to share. And I'll have to disagree with you since I do not consider sharing knowledge as spamming. About Hazelcast you can read a full comparison [here](http://www.tayzgrid.com/resources/comparisons/hazelcast-vs-tayzgrid.html). 
The first email was actually pretty nice, but I had already moved on. The second was a little pushy, but I didn't mind much, I assumed that would be the end of it. The third one ignored the relationship the bot was trying to build, which felt insulting. The following emails were just annoying, especially the ones I got in the weekend, and the automated message when I finally replied was what made me post this here. If you're setting up bots like this, you should only run them for people who are available should the user/victim choose to reply. And please, don't run them outside of office hours :)
&gt; The Optional.of() will throw an NPE if the argument is null. I'm sure that was a mistake of the original author. They probably meant to use `Optional.ofNullable()` &gt; you would still have to make a null check to ensure that the optional itself isn't a null reference That would be [extremely defensive programming](http://blog.jooq.org/2015/08/11/top-10-useful-yet-paranoid-java-programming-techniques/) :-) but the article comments only on API technique not to implementation. &gt; If the intent is that null should remove the fullname, make that intent clear by having a method called "clearFullname" or "removeFullname". Do not change the setter to take an Optional. That is an entirely different, yet equally religious discussion. `Optional` (cardinality 0..1) is exactly the same type of container as `List` (cardinality 0..n). Your `setStudents(List&lt;Student&gt;)` example is perfectly fine, and `addStudent()` is useful. In fact, all sorts of `addStudent()` are useful, such as: public void addStudent(Student s); public void addStudent(Optional&lt;Student&gt; s); public void addStudents(List&lt;Student&gt; s); The difference between add (append) and set (replace) is only the verb. Not the argument type. Unfortunately, too many people focus on the absent/present semantics, rather than seeing things in terms of cardinalities. Once you look at `Optional` as a model for cardinalities, things just become a lot simpler. &gt; The only world in which that is more clear is one where JavaBean-patterns are considered good. One where we sacrifice abstractions for easy runtime introspection/reflection. Sure. The whole example is a JavaBeans based one. The discussion wouldn't happen (or it would be different) if we had an "ordinary" API.
As a developer and entrepreneur, I can see where both you and the sales person are coming from. Aggressive emailing and calling does get annoying. However, many sales people are trained to keep following up until they get a definite yes or no. They see a non-response as a maybe. In the case of a "no", they typically like to get a reason which might get feed back into product development. Since I'm facing a similar decision as ZeroTurnaround, can you shed any insight into what holds us back from replying to the first few emails? (BTW, thanks for posting this topic, it's been very enlightening.)
Make it springboot based please.
I'm writing a Boot webinar, but this is focusing on the basics of REST, so there's that much code in there. I'm going to cover HTTP semantics, a lot about error status codes, URL structure, verb semantics, idempotency - things like that. But, yes - the next one is going to be Boot focused. Cheers, Eugen. 
Yeah, sorry, you are right. I guess I believed in what I've wished was true. 
Also the spring udemy course is good.
Can you use this rules in a build within your CI server? Is this possible to embed them to the build pipeline?