Spring Boot (and associated libs), Apache Commons. And (slightly off topic), a front end library like AngularJS is also a good idea to at least know about.
Unless you pay for open source, you're not in any developer priority list.
I believe this exists in the Ibm rational version of eclipse and not in community Eclipse.
+1 for Spring Boot and Apache Commons. I'd suggest reactjs as a Front end library. 
Intellij got an option to turn all key bindings into eclipse ones. That was the point of no return for me. 
Or how about soft text wrap?
where is the article？could you give me the href?
yeah dude here it is: https://medium.com/@384924552/redux-inspired-springmvc-controller-coding-style-with-rxjava-11cf87bbee64#.6spjily0y
haha thanks
sidenote, this code does not look "better" to me at all.
Are you being sarcastic? I switched to IntelliJ a few years back specifically because its maven support was so much better. I considered it a killer feature, although there are numerous other smaller features that I consider significant now that I've spent time with both.
Yeah ，i agree. so i only consider the optimization of distinct business logic code
Yep, my workaround is to type to the end of a line in the editor to get the code completion, then cut and paste.
Spring Boot makes it a LOT easier to get started with the app / do stuff. I tried learning vanilla Spring a couple months ago and eventually gave up in favor of Play but I recently started learning it again using Spring boot and the process is 100 times friendlier. 
Whoa..... didn't know about this.
Why are you forced to use terrible development tools?
This sample didn't seem optimized to me. Probably cause I didn't see the u optimized version. 
Yeah, but there's only 11 votes.
I know this might not be huge, but Eclipse is free, even for commercial projects. 
http://reactivex.io/
No, I'm really not. Couple of specifics off the top of my head (on my phone): * No out of the box support for showing conflicting transitive dependencies * Tree view showing transitive dependencies does not show multiple origins * Profiles are not propagated down a project tree correctly * provided scope is not handled correctly * base directory when running unit tests via Maven in submodules is not consistent with the UI. * Doesn't properly respect maven settings from config when searching for artifacts from the UI, leading to issues with proxied repos My main complaint about Eclipse would be that error highlights could be a bit non-specific, and you did tend to need to edit the POM directly when adding deps. Compared with that laundry list of shit above, neither issues were biggies. Hope this helps... IJ is nice, but its devs really aren't that great at fixing corner cases. I can also bitch about shitty Git support and a bad incremental compiler if you like :-)
Yeah, I had similar issues. You can rebind individual keys, but differences in behaviour means that's never going to be that satisfying. And obviously different if you're leaning over to help someone on their IDE. I resolved to learn the default key bindings instead. Not such a big deal, but some relatively common options need some hand contortion. 
I guess everyone has their sweet spot of functionality. I never used plugins heavily (just the usuals), so the limited support in Eclipse was never much of an issue. By contrast, I found the maven issues I listed were very painful for Hadoop development, where you have to be very aware of the libraries already present in the environment. Literally never encountered malformed code from the Eclipse compiler - though I do believe it could happen. Constant manual rebuilds in IntelliJ though. Slightly moot point for me, since I switched to doing mostly Scala not long after. I like EGit. Complex, but you didn't have to drop to the prompt to do really trivial things. IntelliJ support is really minimal, which is good for basic usability, but not so much for power.
Doesn't that mean that it's actually not stable enough to be enabled by default?
Call me old-fashioned, but I just don't get/like the basic project structure in IJ: http://www.jetbrains.org/intellij/sdk/docs/basics/project_structure.html. Does the IJ's project map to Eclipse's workspace or not? Because opening distinct windows for all my projects seems like a big drawback to me.
Because you are being paid to work with Eclipse?
In my case, the support for build Tools like gradle is sooo good that I've never used the internal compilation. And I believe I'm not the only one who doesn't use that feature at all. 
&gt;The vendor mentioned that I was the first Java developer that he met since the beginning of the conference. This sent me a strong message. From that day on, just to keep ourselves marketable, we have started becoming acquaintances with other programming languages – PHP, Ruby, node.js. I can't comment on Ruby, but PHP and Javascript are not languages I particularly enjoy. Java definitely has its warts, but given the choice between Java, PHP and Javascript, I will choose Java every time. I think the industry is too enamored with startup culture and hipster technology. Ruby on Rails went through it's sexy period, same with MongoDB, and now Node.js is the latest craze. The hipsters will eventually move onto something else. Those at your company who demanded Node.js and Mongo have long since moved onto the next project that they can screw up, and your left with the bucket trying to save the sinking ship of technical debt they left behind. We used Javascript in the browser because we HAD to. Now that there are languages which compile to Javascript (and soon WebAssembly), people are excited to get off of Javascript. I'm not sure what would compel someone to want to write it on the server side as well. Upon first reading of Node.js, I thought it was a parody.
&gt;After IOC Factory the space has been saturated by Spring and Guice – and you are coming with the CDI specification for it I wouldn't quite put it like that. Spring rested on its laurels for far too long, thinking they didn't need to innovate anymore because they had the entire (Java) market. Then Guice and SEAM -did- innovate, and CDI evolved from that (and funnily, though people rarely recognize it, from the JSF managed bean system). It's true that CDI's mission is explicitly not to innovate, but it still was innovative and ahead of Spring when it came out (and some say it still is). 
I never blame the consumer for any vendor's lack of business acumen.
I would agree on the first 2 points, but personally I see eclipse compiler as one of it's biggest downfalls. - Autocompile project by default - this is awful, it should be turned off by default and turned on once you know it's safe to compile project - Compiling whole project with only error in log when some class doesn't compile. I want my whole compilation fail miserably on compile error by default, not silently whisper something was wrong. - Missing compile file/compile package - The way it works with cache. I have seen eclipse compiling project but it would still use whatever it had in memory and not the updated file or it didn't properly detect files to recompile. As a result to be 100% sure the project compiled properly with code that's actually in the source files one sometimes had to not only do "clean" but also restart Eclipse.
Geez, that's unfortunate =/
Display windows works for me. There is a surprisingly huge number of Eclipse users that never use the Display windows. I think it should be renamed to LiveCoding or DynamicCoding or something
Eclipse has much bigger, much more fundamental problems than that. Use IDEA or NetBeans.
It's too simple. Consumers always say producers should "just" (emphasis on just) find "alternative ways to make money". But that way really isn't there. And it's crazy when you think of it. What's wrong with just paying for your stuff? No, instead vendors need to jump through ridiculous hoops to find that magical and mythical alternative way to make money. And for a lot of products, that way really doesn't exist. So many companies, so many people have tried. Consumers are absolutely hooked on Facebook, but don't even want to pay a cent for it. So Facebook desperately tries to find that alternative way, but since it isn't there, they turn to ads that are getting increasingly aggressive, and they sell our data and what have you. Consumers just want everything for free, and want more and more of it. And in response the Internet turns to sh*t and gets littered with highly dubious ads trying to squeeze a few pennies out of people who as a rule of thumb don't want to pay. It's a race to the bottom. Consumers wanting to pay less and less, vendors littering and resorting to increasingly dubious practices, for which consumers (rightfully so) don't even want to *get* paid.
&gt; you now possess all of the features (aka complexities) that were part of C++ in the name of “flexibility” * _Operator Overloading_. Also `String` having `+` is not operator overloading it is syntactic sugar, there is a very large difference. Interviewers and interviewees get this wrong. * _Preprocessor_, the closest thing to the preprocessor in Java is the annotation processor. * _Template_, Java has generics but they are not templates. Each class only exists once and does not have a copy for every single template argument which is available. * _Unsigned Types_, with two's complement they are only needed for comparison and division. Unless you consider the Java 8 methods prefixed as `unsigned`. &gt; I attended a Web 2.0 conference... The vendor mentioned that I was the first Java developer that he met since the beginning of the conference. This sent me a strong message [to learn other languages]. Web 2.0 is CSS, HTML, and Javascript for the most part. If the vendor is a single person, it is highly likely that not everyone went to that vendor saying "Hello, I develop in _X_." to them, there are possibly other developers there but you would have been the first to say you program in Java. 
Facebook is not the best example, because that thing is now (finally) making a rather [decent amount of profits](http://www.wsj.com/articles/facebook-profit-tops-1-billion-1453929139). While the Eclipse Foundation... Well... [At least they have now been "embraced" by Microsoft](https://blogs.msdn.microsoft.com/visualstudio/2016/03/08/microsoft-joins-the-eclipse-foundation/). As in ["Embrace"](https://de.wikipedia.org/wiki/Embrace,_Extend_and_Extinguish) Meanwhile, [Karl Marx is laughing at us from his grave](https://en.wikipedia.org/wiki/Tendency_of_the_rate_of_profit_to_fall) as you have rightfully identified (t)his race to the bottom. Oh well. How did this escalate so quickly? It's just a trivial missing feature in Eclipse... ;-)
I would say that this article really has nothing to do with embedded Java. Today there are Java SE Embedded (which is really just compact1 profile) and Java ME 8 (formerly J2ME, consider Java ME 8 to be Java 7 made very tiny), mobile is considered embedded. &gt; 1. Java is slow. -- Java has a Hotspot In the embedded environment, there may still be interpreters in use or at least basic portable optimizations but still interpretation. Having a JIT may be too large for certain embedded platforms although it can exist provided there is enough CPU and memory to make it feasable. It is also possible to AOT compiler and combine classes already loaded into a ROM format that starts rather quickly. On an embedded system with perhaps say 1MiB of RAM and 8MiB of ROM, Hotspot will not be running on it. &gt; 2. Java is dead. -- TIOBE index The TIOBE index really only points out the most popular language people use internet searches for. So pretty much, the better someone gets at Java the less likely they may perform searches for it. &gt; 3. Java is open source. -- Java is not open source The desktop OpenJDK is open source under the GPLv2 only, however the __official__ embedded JVMs (that are officially Java, that is they passed the TCKs after purchasing them) are closed source and written in the most part in C. Embedded vendors would purchase the embedded JVM and modify it internally to suit the desired devices and compile it with their C compiler for example. &gt; 4. Java does not suffer from memory leaks. -- It does Memory leak prevention helps with the correct usage of `Reference` and its related classes. Previously J2ME (before Java ME 8) completely lacked `Reference`s, which meant that there could only be strong references. So these older classes were more likely to have unintended memory leaks if the references were not handled properly. However Java ME 8 has `Reference` now which makes memory management easier and more automatic as it should be. &gt; 5. Multi-threading in Java is hard. -- Streams, `java.util.concurrent.*` J2ME and Java ME do not have streams and there are no concurrency classes, you only have `Thread`, `synchronized`, `volatile`, and the `wait`/`notify` methods. For Java SE embedded, these would be in the compact1 profile so you can use them. &gt; 6. Java will be replaced by Scala. -- Will not. J2ME and Java ME lack reflection, so dynamically generated classes are impossible to load. Scala would need to operate without reflection. Java SE Embedded does have reflection however. &gt; 7. Java is too big for embedded applications. -- Java 8 made things smaller, Java 9 will make things even smaller. For the tinest of devices, even Java 8's compact1 is huge. Java ME 8 has far less classes and thus has a much smaller footprint. Even with Java 9's modularization, there would potentially be fundamental classes required which brings this number up. &gt; 8. Java user interfaces are horrible. -- AWT, Swing, and JavaFX Java SE Embedded does not have any GUI interface at all, everything uses standard input and output (barring third party libraries). Java ME 8 only has standard output and a line based interface, MIDP has the more commonly known LCDUI which provides richer graphics. &gt; 9. Java suffers from big pauses for garbage collection. -- Configure the JVM In embedded devices, you might not even be able to configure the JVM. Big garbage collection pauses may be there for simplicity, memory, and speed reasons. Stop the world GC may appear slow, but when it comes to devices which are weak compared to the powerful computers of today, it is quite fast. 
I think that depends more on what type of work youre interested in.
Nobody in the startup space does, which is what the article is focusing on. It's for enterprise companies with more money than sense.
&gt; It's just a trivial missing feature in Eclipse... ;-) Trivial in nature, but quite a good example :P
Not quite. It's still far more complicated and "magical" than Spark. In classic Spring fashion, even a Hello World with one goddamn endpoint is littered with annotations. How is anyone supposed to debug something like this? Why not just keep it simple and use Spark? What advantage does something like Spring Boot, with all of its reflection-based magic, provide for you?
I tend to agree, in the startup space Java EE seems to be more popular. Spring is quite often necessary in the enterprise since pretty much the whole AS can be shipped from within the war. In startups the restrictions of not being allowed to touch the installed server just doesn't apply.
JavaScript, SQL. Pick up a functional language too, and perhaps Python.
&gt;I've never seen a startup use Java EE zeef.com, dreamIt.de, safsms.com, stylight.com, youstice.com, ... &gt; It's overengineered! What's over-engineered exactly? 
Seems to be contradicotry: &gt; Unfortunately, as time passed on, you now possess all of the features ... that were part of C++. [**Note:** *Not even close to true.*] And &gt; Here is another thing that frustrates your friends, instead of driving innovation you are trailing. Which one is it?
That's not a lot of people. The culture of Java EE and Spring and whatnot are the reasons why Java gets such a bad rep. The things that make it overengineered are the massive amounts of magic through things like annotations and, even worse, all the config files. What makes Spark, Sinatra, Flask, etc all compelling is that you write your code and run a command and you have a webserver. Configuration is chaos and pain.
It's much, much faster when building and running unit tests than IntelliJ.
What configuration is needed for Java EE? I quite often build very tiny endpoints that consist of just a Servlet (or depending in the task, JAX-RS resource) that I annotate with the path it should listen to. I compile that one class and deploy it. There's no configuration there and it Just Works. Take a look at this one for a slightly bigger example with again zero config: http://jdevelopment.nl/minimal-3tier-java-ee-app-xml-config &gt; What makes Spark, Sinatra, Flask, etc all compelling is that you write your code and run a command and you have a webserver. And you think there's no massive amounts of magic underneath to make all of that just work? &gt;Configuration is chaos and pain. And Java EE needs very little or none of it. 
There is if you're a one-man team that gets to choose their own tech. Most of the time, this isn't the case. It's a really good idea to be strong at JavaScript first, before you pick up any of the transpiled languages.
In the last few months I've learned Elixir which has really helped to expand my horizons in how problems can be solved in different ways. To me Java and Elixir are so different in how they approach and solve problems that knowing both provides me with two languages that compliment each other very well IMO.
&gt; It's easier than I thought, I'll admit. That's something ;) &gt;But Spark is still just so much easier... Very unlikely, and even more unlikely that that supposed simplicity scales. Our shop has been burned by this before. The hipsters from 2006 telling us that RoR was so easy and so productive, that no company could afford not to use it. Making comparisons of transporting goods via a horse vs a big truck on a highway etc. So we bought into it, big time. Since hey, why bother working for 5 weeks on an application using Java EE, when RoR would only take a day? And yes, those numbers were based on some hello world blog type thing that the RoR hipster showed to only take a few minutes vs a few days using Java EE. Fast forward 5 weeks and the RoR application wasn't so simple anymore. 10 weeks in and people started to have serious doubts. A year in and people begged the PM to be put back on a solid Java EE project. Just saying... 
Althought your sentiment is very black and white, I do agree with it. Having used all technologies mentioned above, I can't fathom why the discussion is so focused on putting languages in a 'one-language-fits-all-categories' light and hand picking scenarios to praise and criticize. Some projects are small and the node stack is quite handy. Other projects are very much easier in hindsight to complete in Java. Just choose appropriately and you'll be fine. No need for a life defining crisis to blog about.
It doesn't sound like either of us are going to change our minds. I much prefer the manually wired up static methods I get using Spark. It seems you prefer a framework that handles the wiring up for you. We're gonna have to agree to disagree, it seems. 
more like the quick and dirty category
is this still true tho? article is over 4 years old 
&gt; I have always enjoyed Jetbrains. When I took my Java classes in college we used eclipse and I hated it. Yes, it is more complicated to pick up. &gt;Mainly, it was incredibly slow. If you downloaded a release that has more plugins than you need, this can be true. If you have the timers on things like code competition set too high, it seems like there is some perceived latency. &gt;In my Ruby/Python scripting class we started with eclipse, but once my instructor realized we all had free licenses for PyCharm/RubyMine he told the class we were welcome to switch to Jetbrains, and I never looked back. You'll learn that as you get more advanced what's good for beginners is not always good for advanced people. &gt;Launching projects is faster, running things seems faster, syntax highlighting is better by default. This is not my experience. I also have a universal subscription to IntelliJ Toolbox through work. &gt;Code completion seems smarter. The substring completion was added to eclipse recently, so I can see why you would say that. &gt;I mean, I hate to make this argument but, I mean, Google left eclipse for IntelliJ for official Android development for a reason, no? Yes, because it's easier to pick up (no workspaces, No [Mylyn](https://youtu.be/P34eFGdswOU?t=1m15s), etc..), and when you want a lot of people developing for your platform, you need to make it as easy as possible.
&gt; Autocompile project by default - this is awful, it should be turned off by default and turned on once you know it's safe to compile project Not sure what your objection is, is it a performance issue on your machine. I peresonally like all my errors to be surfaced to me, and have trained myself to ignore them while I'm slinging code to create a new app. &gt;Compiling whole project with only error in log when some class doesn't compile. I want my whole compilation fail miserably on compile error by default, not silently whisper something was wrong. Not sure what you're talking about here. &gt;Missing compile file/compile package Again, not sure what you're talking about. &gt;The way it works with cache. I have seen eclipse compiling project but it would still use whatever it had in memory and not the updated file or it didn't properly detect files to recompile. As a result to be 100% sure the project compiled properly with code that's actually in the source files one sometimes had to not only do "clean" but also restart Eclipse. Perhaps because I work on teams, we always have Maven underlying things and this hasn't been a problem for us?
IntelliJ has this.
Yes. I made a small web site using http://sparkjava.com/. It's smaller than Spring boot and with similar API
Autocompile - recent example - a colleague just imported an ant project from our repo with some stuff in "bin" folder. Eclipse happily erased everything in that folder and overwrote it with compilation results before my colleague changed compilation output path to something else. Git reset is not a problem but it adds to frustration and wasted time. Compiling project with errors - Eclipse does not fail hard on compilation of project with errors. Instead it puts shitty runtime exceptions in classes and methods it failed to compile (or at least it did last time I tried to work with it). Is there a command to tell eclipse "compile only this file or package for me now" ? I find myself in need of this very often when debugging and in need of hot-swapping the specific class. The problem with restarting Eclipse was in a particularly large projects but only people using eclipse faced it. I suspect strongly the compiler, probably using default java compiler would help. 
Have you considered that a startup with very few customers has slightly different needs than literally the most popular website on the internet? You wouldn't buy a $2500 Macbook Pro if you only go on Facebook. You wouldn't buy a Lamborghini if you drive to the supermarket and to church on Sundays. Why waste your time on configuring a server framework that provides nothing to you when the zero-config ones are more than sufficient?
Right, you asked why one would use JetBrains over eclipse other then "Reddit cheerleading". That's why. Because it's big, slow, and hard to pickup. I say it's a lot like trucks vs cars. Eclipse is a big ass semi-truck and Jetbrains IDE's are above average speed car with pretty good handling, we'll call it a Ford Taurus SHO. Its pretty fast. Has some cool features like a built in nav system, good speakers, fits the kids in the back, does pretty well on gas, it's all wheel drive for the winter. A semi truck is great if you need to haul a bunch of stuff cross country. But if I'm just dropping the kids off at school, it would be silly to drive them there in a semi. It's big, slow, hard to park, has like....an 18 speed transmission. Could easily run over other people's kids in the pickup line. Sure, semi trucks are useful, and belong on the road for many reasons, but just because they can haul more cargo does not make them better vehicles. Most of us are " just driving back and fourth to work, or dropping the kids off at school". So Jetbrains IDE's are what people are switching to. If you are hauling heavy loads that's cool, and I'm glad eclipse does what you need it to do, but I think you are becoming the minority and your last response proves that.
Why do you have a bin/ directory checked into source control? Why are you still using Ant for that matter? Yes, I understand legacy code still exists, but blaming Eclipse for not working cleanly with your legacy code is like complaining your CD player doesn't work with your 8 Track cassettes. The way Eclipse compiles individual units is a good thing. Having to fix things one by one as they crop up after a build wastes time. Remember, an IDE is not a build tool. Your build tool should stop when it encounters a compiler error. Your IDE should let you know all the problems it can find.
I have shell scripts used for starting the application in my bin folder. Because person who started the project used ant and mavenifying the thing will take too much of the time I don't have. IntelliJ can work cleanly with my legacy code and on top of that suggest refactoring into streams when working with new code. &gt; Having to fix things one by one as they crop up after a build wastes time. I had to fix not compiling code committed by Eclipse users a few times because "on their machine it compiled without problem". So I naturally have an aversion for IDE that doesn't slap into programmer's face a big "does not compute" sign. Not just some small red cross in the file browser window which doesn't always refresh properly.
What resources did you use to learn it? I also wanted to ger into Elixir recetly but did not find the time, yet.
I'm curious (because I'm a Java guy who doesn't much like Javascript). What are the alternatives you would suggest to Javascript?
I'm not even sure .net still exists as a development language outside of thick clients. I mostly work in finance, and noone uses it outside of developing windows stuff. I'm aware of F#, but I've seen projects in Scala and even heard of Haskell being used on pilot projects, but nothing about .net.
Let's help out OP; I'll start: [Please note: I am not making a judgment about whether these features *should* be included, only that they are not.] - Reified types. - Template meta-programming. - Multiple inheritance. - [SFINAE](http://en.cppreference.com/w/cpp/language/sfinae) - Move semantics - Ownership semantics (unique_ptr, shared_ptr) - [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) - Inferred types with auto variables. - [Lambda capture initializers.](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3610.html) - Operator overloading - [const expressions, including const member function expressions](https://msdn.microsoft.com/en-us/library/dn956974.aspx). - Functions not bound to classes. 
He is probably talking about ASP.NET MVC.
what is reified types?
I added an Edit to my post, I am talking about web / backend development primarily. 
I initially bought Elixir in Action and relied heavily on the Elixir API documentation. Though now I might also suggest Programming Elixir as well. The most helpful thing though I think was to go to to exercism.io and start doing the problems there and then review other people's solutions after having submitted your own. After about 10 problems or so I was finding myself more comfortable thinking about recursion as well as functional programming. After that I picked a simple card game to implement in Elixir to help me better understand stateful server processes and how to use GenServer. And after that I started a simple Elixir project to help me understand Plugs... which I have not finished yet. After that I hope to start learning about the Pheonix Framework so I can have a fuller tool-set for building web apps in Elixir.
Thanks! Didnt realize that there is a group for javahelp
I didn't realize that .net was still a thing
It is Java EE, not SE.
SQL, HTML, CSS, Javascript, Bash &amp; Scala
It is a very powerful feature used in generic programming. To me, it is the most important difference between Java and C# (and C++). A language that supports reified types will create a new type for each generic (or template) instantiation. Java has erasure instead, to ensure backward compatibility. IMHO this was a design mistake since it introduces *runtime* errors if the wrong parameterized type is passed by a client to a generic's method. This would be caught at compile time by languages that support reified types. Further, there are design limitations to consider in the absence of reification. Consider the contrived example: In c++: template&lt;typename T&gt; class A{ static int sCount; int mIndex; public: A():mIndex(++sCount){} }; template&lt;typename T&gt; int A&lt;T&gt;::sCount = 0; class Foo{}; class Bar{}; int main() { A&lt;Foo&gt; aFoo; A&lt;Foo&gt; anotherFoo; A&lt;Bar&gt; aBar; } ---------- In C#: public class A&lt;T&gt; { private static int sCount = 0; private int mIndex = ++sCount; } public class Foo { } public class Bar { } static class Program { static void Main() { var aFoo = new A&lt;Foo&gt;(); var anotherFoo = new A&lt;Foo&gt;(); var aBar = new A&lt;Bar&gt;(); } } In this example, there would be **two** sCount variables created. After main runs, `A&lt;Foo&gt;::sCount` would equal two, while `A&lt;Bar&gt;::sCount` would equal one. In Java, you cannot do this in an efficient, type-safe manner, since there would only be one static sCount shared between all instantiations of the generic type and the developer is forced to implement something like the following: import java.lang.reflect.Type; import java.util.HashMap; public class A&lt;T&gt; { private static HashMap&lt;Type,Integer&gt; sCountMap = new HashMap&lt;Type,Integer&gt;(); private int mIndex; public A(Class&lt;T&gt; t) { Integer i = sCountMap.getOrDefault(t,new Integer(0)); mIndex = ++i; sCountMap.put(t,i); } } --------- public class MainClass { public class Foo{} public class Bar{} public static void main(String [] args) { A&lt;Foo&gt; aFoo = new A&lt;Foo&gt;(Foo.class); A&lt;Foo&gt; anotherFoo = new A&lt;Foo&gt;(Foo.class); A&lt;Bar&gt; aBar = new A&lt;Bar&gt;(Bar.class); } } If you notice, type safety is abused in the Java version by having to pass in `Foo.class` or `Bar.class` in the constructor. Also there are inefficiencies introduced by having to lookup the count in the HashMap. **Edit**: I just realized the java version is **not** equivalent to the others above, because there are no class literals for concrete parameterized types, as in: A&lt;A&lt;Bar&gt;&gt; aBarBar = new A&lt;A&lt;Bar&gt;&gt;(A&lt;Bar&gt;.class); This is *impossible* as far as I can tell. 
Did you see the sidebar, banner, posting page? It's only mentioned in at least 5 places on the page.
Same boat, primary reasons being licensing costs and developer availability. After doing web in both, I much prefer Java's frameworks.
I still don't think that Spring is the right solution. The configuration-file-and-annotation-reflection-magic-heavy nature of it represents everything that's opaque and wrong with Java, in my opinion. Nothing can be statically analyzed. But if it works for you, feel free to use it. :)
I get your analogy, and agree with it to a limited degree. &gt; So Jetbrains IDE's are what people are switching to. I think you are becoming the minority and your last response proves that. Not sure what in my last release makes you feel that way. You're looking at it from the reddit cheerleadering perspective I was speaking about earlier: https://www.google.com/trends/explore#q=IntelliJ%20IDEA%2C%20%2Fm%2F01fs1d&amp;date=1%2F2016%2012m&amp;cmpt=q&amp;tz=Etc%2FGMT%2B7 I think you should step-back from the kool-aid 
&gt; Autocompile - recent example - a colleague just imported an ant project from our repo with some stuff in "bin" folder. Eclipse happily erased everything in that folder and overwrote it with compilation results before my colleague changed compilation output path to something else. Git reset is not a problem but it adds to frustration and wasted time. You can turn autocompile off, but I have to agree with /u/Northeastpaw this is not "bad" behavior from eclipse, this is just bad code. &gt;Eclipse does not fail hard on compilation of project with errors. Instead it puts shitty runtime exceptions in classes and methods it failed to compile (or at least it did last time I tried to work with it). You can force a complete compile just the way you would do it in IntelliJ. You are getting a bonus feature. Also, you're not using at least CI? &gt;Is there a command to tell eclipse "compile only this file or package for me now" ? I find myself in need of this very often when debugging and in need of hot-swapping the specific class. It should just do it for you. One of the places where this rule doesn't hold is if you try to change a loop you're already in (indirect calls still work) &gt;The problem with restarting Eclipse was in a particularly large projects but only people using eclipse faced it. I suspect strongly the compiler, probably using default java compiler would help. My experience is that they take roughly the same amount of time on the same hardware/configuration (heap, GC, etc..)
&gt;&gt; Typically the older dogs prefer this playground.. Why do you think that is?
This is the first time I've heard about SQL2O, so I can't say much about whether or not it is a good library to depend on. Here are my thoughts when it comes to dependency management. One of the worst things in the world is to run into a subdependency requirement mismatch. It really is pretty terrible when two things depend on incompatible lower level libraries. For libraries, you want to have as few dependencies as possible. In particular, you should avoid anything that will make your library break with a major java release (looking at you lombok :( ). If you have to reinvent a wheel, for gods sake, reinvent the wheel! The only time to bring in library is when you are getting a large amount of utility from that library. For projects, you can be more loose. Feel free to bring in Lombok, Dagger, AutoValue, Jersey, Dropwizard, Guice, Groovy. Do what you want. However, just realize that with every one of those dependencies you run into a potential that they have sub dependencies which fight with each other. You are often better off holding back on pulling something in if you can (especially as the project gets larger). For Spring, there is already a pretty low level SQL library on the level of SQL2O (JdbcTemplate). You may consider using that if you are already dependant on spring. That will avoid a second dependency which can be quite nice (though, looking at SQL2O, it looks like it is a pretty small thing to bring in). Be choosy about your dependencies. Don't pull something it if you aren't getting a lot of utility out of it. Do pull things in when their functionality significantly improves what you can do.
You're definitely right on all of that, it'll be interesting to see where this all goes. I've recently been pondering if Java is on the decline, and with Oracle at the helm it's definitely felt as though it may be.
Pure JDBC is OK unless you are doing anything with transactions and stored procs (especially if they return multiple result sets). At that point I strongly suggest using some wrapper library that gets it right. In particular, MS SQL server driver has a bunch of things which can be a real stinker if they are done incorrectly. Incorrectly consuming a statement can pollute your connection pool with hanging transactions (no fun!).
I use and like both .NET and Java, but I have wonder where all this "is Java really dying?" rhetoric coming from. Sure, there are some new job openings in .NET and as .NET Core/Mono/Azure and other .NET FOSS hits mainstream, we'll see some periodic bumps in popularity for .NET over time, which is probably the source of some of this perception. Also, let's just admit it right now: Java is in a precarious spot perception-wise right now. There definitely is a perception of weakness around Java EE in particular, and with Google looking for non-Java options for Android, Java mindshare could take a big hit in the coming years. Is that likely? I'd have to lean towards 'No', but we'll definitely have to wait and see. Beyond all that though, the FOSS and proprietary communities around Java development is more or less unrivaled in the enterprise so, even if Java started it's decline today, it would have a very long tail indeed; to the point where most of us could retire using it still and not worry too much about marketability.
I know this is /r/java, but seriously? It sounds like you're not staying current.
&gt; NO I agree, anecdotally &gt; TIOBE NO. I'm sure there are other sources to confirm your claim, but please don't suggest TIOBE. Their method for calculating popularity is fundamentally flawed.
TIOBE is like going to the super market to determine popular product based on the amount of missing product on the store shelf.
&gt;moreover Optional is nullable (like every other object). This is specified by the JVM, so I'm not sure what other solution exist.
You talk like if using transactions in JDBC were the most difficult thing in the world, is not that hard, but thanks for the advice.
Spring offers [some real value on top of JDBC](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html) without being an ORM. It's like fancy JDBC.
Java is just getting bigger, its not shrinking. But I think I should clarify that. Java as a stack is getting bigger. Even if you ignore the fact that programming itself is just getting bigger and bigger, Java usage is increasing. The first and obvious way is Android. Android applications are primarily Java, and it is probably the most popular development platform right now in pure numbers, and is only getting bigger. Every company out there wants to get their App, since they can get data, and have more control than with a website. The next way is that when you look at a lot of the devices out there that use code on it, Java is a big language there. A lot of camera systems, iptv set top boxes, dvrs, etc. is in Java. This and other middleware applications is only getting bigger with IoT becoming more of a thing. Then you have to look at the fact that the internet still runs on Java. If you are going to host a large web application, and you don't want it to crash and fail, you use Java still. You use Java because with things like Spring, JBoss, Glassfish, etc. you have a stable platform. Look at Twitter, they broke with Ruby, they are running good on Java. The next is that today, Java is not just Java. Java is the entire JVM ecosystem. Java is Scala, Java is Clojure, Java is Jruby, Groovy, Jython. Java as a platform means you can extend it with other languages that do different things well, and you can do it natively in the same stack. When you look at the fact that Scala with Spark basically won Machine Learning and Big Data for the moment, the Java environment is not slowing down anytime soon.
If you're doing it as an intern at some rando company than it MUST be thriving
Spring's jdbc template uses lambdas. RowMapper and ResultSetExtractor are functional interfaces.
JdbcTemplate predates Java 8, and they still have a backwards compatibility with Java 6 or 7, so they're limited in how much of Java 8 they can support. Spring 5 will use Java 8 as a minimum requirement, so you can expect more features like Lambdas in the framework. https://spring.io/blog/2015/08/03/coming-up-in-2016-spring-framework-4-3-5-0
Spring honestly doesn't care what you use to fetch data out of the database. You can do as little or as much as you want with the framework. You can use JDBC directly. You can use JdbcTemplate. You can use Hibernate directly. You can use JPA. You can use Spring's JPA abstraction. You can use Spring Data JPA. And yes, you can use SQL2O if you want. I've never heard of SQL2O before so I can't comment on its quality or how well it works in Spring, but there's no theoretical reason why it wouldn't work.
Well, there is stackoverflow and another couple of large sites that run on .net.
Couple of things I would consider before choosing any library, * Community support * Active development The advantage of choosing Spring like framework is, it has huge developer community and its very active development. So I can bet my long term project on these type of frameworks. This is the first time I am hearing about SQL2O, and had a look at their website. The latest version, 1.5.4, was released on Jan 16, 2015 i.e. almost more than an year. It would hesitate to choose this library. Edit: Typo.
You can use SpringTX with JDBCTemplate. Thats enough transnations for most usecases.
Not sure about "wrong", but why use sql2o when there is [jOOQ](http://www.jooq.org)? ;) (bias disclaimer: I work for the company behind jOOQ)
Looking on their Github page the do have commits, and they're just preparing for a 1.6 release so it does look like it's somewhat active. What I liked about them was the simplicity. Coming from Django/Laravel the whole Java web ecosystem (now looking at Spring) is overwhelming for me at the moment there are so many configurations that you need to do (which don't make sense to me yet) just to get something working.
To be fair, a library *that* simple doesn't need a daily release. There are hardly any bugs, and hardly any new features that need to be added.
&gt; jOOQ jOOQ always seemed awesome to me (even before I was interested in Java for webdev). And I also see it on http://start.spring.io/ which is even cooler.
Indeed, plus: https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-jooq.html
With `int` in general, you'd have to worry about overflow. Comparing `Integer.MIN_VALUE` with `1` should give a negative result, but it gives a positive result when using that subtraction trick. A reasonable objection to that objection might be: "Apples can't have negative weight, so that situation can't come up." Still, why use subtraction instead of "just" using `Integer.compare(a,b)`? That method says exactly what it does and is intended for exactly for this purpose. I don't think subtraction (even when it's correct) makes its intent as obvious to the reader.
PHP does have a bright future. Or is it bright_future()? Or BrightFuture()? Or maybe brightfuture()? Or future_bright()? Damn. Have to check the manuals again.
It's not an article. It's a video. Clicked hoping to learn something, left immediately because I can't watch a video while on a concall.
Clickbait titles at his best.
&gt; However its hard to deny in recent years .NET has gained popularity and has momentum behind it. No it's not hard to deny this at all. Where are you seeing this gain in popularity for .Net over Java? Exactly what does C# bring to the table over Java according to you? Why would a company choose C# over Java?
Then again, Google did not play fair or by the book, which is something they're doing a lot recently. Both giants were idiots in this story and the devs and end-users are the ones who'll pick up the tab &gt;.&gt;
I wouldn't take Google dropping support for Java libs as a signal for how the company feels about a language. Google is really big and they start and drop support for many projects in all languages.
Of all of my professional contacts in the past 25 years, I now know of only 2 guys working in Microsoft shops. One is supporting a legacy financial .net app written 10 years ago, and the other is working in a .net shop run by a CIO whose entire software development experience consists of 2 years of C programming in the early 90s. The server world, from my vantage point, has been moving strongly to Linux/JVM and the client world towards Javascript. I can't speak for other vantage points.
&gt; This is all about autobixing
If "fully object oriented" means giving up access to primitive data types, then I don't want it.
Any reason why they did that? I'm assuming they're throwing away all previous dev costs.
Seriously, almost 10 year now for me using Eclipse in some way and never once have I needed that feature. cue everyone losing their minds and babbling about Intellij.
Have you done much Java? Why wouldn't you want immediate knowledge you've broken a remote class with a series of your changes? It's part of what made IDEs revolutionary. It sounds like you just want a text editor.
Eclipse (even old version) is way better at understanding and suggesting generified code refactoring, Intellij doesn't come close. There's other stuff but I don't feel like arguing with the Converted.
Agreed. I think it's realistic too. If there's no will to make them competitive (which is not easy) why not just sunset instead of maintaining the charade. Everyone ends up on github or similar anyway.
Sometimes I wonder if this subreddit is moderated. Who am I kidding, it isn't. This is pure low effort blog spam.
Eclipse can't even get it's suggestions ordered by best match. I actually have one thing against IJ which is it will refactor so good and so much for the programmer that they might forget how to write code. Eclipse has it's upsides, from what I remember it works better with custom jdks like IBM jdk, has functionalities missing in the IJ Community Edition, and I guess quite a few other upsides but from my experience code analysis and refactoring sucked compared to what NetBeans offered. This was few years ago and maybe it changed but the ui still feels so bad to me that I'm not willing to try that. 
&gt; Any decent application concerned about int overflow is using long, that's why. You should then use `Long.compare` method to avoid ...overflow ;)
&gt; I have wonder where all this "is Java really dying?" rhetoric coming from. From idiots who post titles like the OP's with zero backing. Although To be honest, my experience with .NET only devs is typical with this behavior. They only are driven by marketing drivel from their MVP boards.
&gt; Java has mostly died completely in the startup space You must not be referring to startups that have anything to do with Big/Fast Data?
Some suggestions: * In your FileEditor.java comments, "disgression" should actually be "discretion" * I would recommend selecting either an MIT or Apache 2.0 license. Both require that your copyright and license notices be maintained but allows others to use the code at will. * some consistency in argument naming: location, line, lineNumber, ... -- just pick a favorite and stick to it. * instead of addLine(s), use insertLine(s) that takes a location/lineNumber and appendLine(s) that just appends to the end. If using java 1.7+: * instead of a new FileExistsException, you can use the FileAlreadyExistsException from the java.nio.file package. * as previously stated, look into try-with-resources 
&gt; Sometimes I wonder if this subreddit is moderated. &gt; &gt; Who am I kidding, it isn't. Just to make it clear for you: There is a fine line between **censorship** and **moderation**. **Moderation** gives the **community** the chance to express their opinion by means of **reporting** and thus allows free opinion where **censorship** oppresses that from the beginning. We **moderate**, but since we are in different time-zones and also have daily lives with jobs, we cannot be online 24 hours per day. In short: You have two means: downvoting and reporting. Use them instead of making stupid, offensive complaints.
I could've brought it a bit nicer, but I fully disagree that getting rid of clear cases of low effort spam content is censorship. Not a lot of people bother to vote on this sub and as a result I have to wade through almost literal crap to find a good informative post.
Sun wanted Google to use J2ME and pay a ton of money. Google didn't want to use J2ME, because even ignoring cost issues it simply wasn't competitive with other platforms. Until Oracle's lawsuit it wasn't considered possible to get copyright exclusivity on programming languages and APIs, so I don't see that it was wrong of Google to implement the programming language they wanted, with the API that Sun wouldn't sell them.
maybe someday eclipse will have a usable dark theme a la intellij.
 //Given these classes: public class Node&lt;T&gt; { private T data; public Node(T data) { this.data = data; } public void setData(T data) { this.data = data; } } public class MyNode extends Node&lt;Integer&gt; { public MyNode(Integer data) { super(data); } public void setData(Integer data) { super.setData(data); } } ------ //Now, if this code is called: MyNode m = new MyNode(3); Node n = m; n.setData("Hello"); // Causes a ClassCastException to be thrown. Integer x = m.data; Edit: I could have been more clear in my original comment. It probably should have read, "if an object of a type different than the parameterized type.." or something like that.
looks like both, actually. two versions of the same content.
&gt; Why use sql2o when there is jOOQ? ;) jOOQ's licensing is the primary reason not to (be able to) use it. I'd LOVE to use it, truly, but I work on proprietary software and we may only use liberally licensed opensource libraries. sql2o, fwiw, appears to be MIT licensed. Spring is Apache 2. MyBatis is Apache 2. etc. **Edit:** the stuff I work on uses proprietary (Oracle and SQLServer) databases, which puts us outside of being able to use the opensource version of jOOQ
Is java ee 8 MVC a new thing? 
Well, you're cheating with the raw type here. You just need to treat raw type warnings as type errors, and thus can avoid such runtime errors. This has nothing whatsoever to do with "reified" generics.
People using JetBrains by choice?
I would also add that Google didn't use any Sun code. They used Apache Harmony. The biggest contributor to Harmony was IBM. It did turn out that Harmony had one nine line function that was identical to the same function in Sun's implementation. So I would also agree with the view that Google did nothing wrong here to use a language, and parts of an API, with a different non-infringing implementation.
&gt; it can lead to too much memory being used as the same class is generated many times over again This is a naive assumption. In many cases, less code is generated that otherwise might be, especially combining template metaprogramming with constexpr.
&gt; so in a limited way Java does have MI. Not really, though. While one can achieve the same design goal as MI in Java using interfaces and managing the add'l state manually, it is an acrobatic feat that the language designers force upon developers. 
It's turing complete. Wanna argue!?
It's never a mistake to upgrade to a newer Spring version ;). Spring Data has historically required the last but one Spring Framework version as base line, i.e. when 4.1 was the most recent branch, Spring Data required at least 4.0 etc. This was mostly due to a lot more conservative users that for some reasons are not able to upgrade to the latest Spring version easily. So anticipating that Spring Framework 4.3 will be GA pretty soon, we "already" move to 4.2 as baseline, even if our general rule (the one just outlined) currently does not apply for a couple of weeks. Note, that Spring Data releases are always (and also always have been) tested against the most recent version of Spring Framework so that this compile time base line does not mean you're stuck with that particular version.
My 2 cents after a quick read: It should be broken up into several articles. This draft is currently 18 printed pages. Each article should cover one key practice or concept, and that's it. Some will disagree I'm sure, but just trying bookmarking your progress mid-way through that page, and you'll see my point. Also, I don't think we need to discuss 'unit testing' as a separate subject anymore. Personally, I think it should be 'this is how you write good Java', and then you introduce the unit testing concepts into the process as part and parcel of how to program in Java. You're either on the bus when it comes to TDD, or you're trying to write tests after you already think you're done; and the latter approach is clearly what we need to leave behind.
What's a unit test? EDIT: I quickly typed this on mobile and think the lack of context made OP think I was trolling. /u/david72486, you never define unit testing in your article. Your audience seems to be beginners, so clarifying what is a unit test is important. In the same vein, a little more of the motivation behind unit testing would give the article purpose. Right now, the only reason to unit test is that employers want it.
Videos would be awesome of course! Everyone appreciates content in digestible units but if you want to avoid making it feel too clicky, then maybe it would be better to try to limit each unit to a time or word limit. Each exercise could be separate too in that you could video the answer you compose to each exercise. A beginner watching a veteran walk through each example using typical development tools is invaluable for learning how to put the pieces of the puzzle together; which is probably one of the hardest things about learning to program. The point about TDD probably came across a bit strongly, but it's just my experience that people do not typically have time to add tests after the fact. So, if you make it part of the up front though process instead such that it takes the place of writing pseudo-code comments even, then I think that's a solid practice. It could become something for which you become known. I don't know that TDD as a central practice in coding Java is really taught successfully that often. Certainly, unit testing is quite common these days, but I really don't know that many people that practice real TDD even now. At some point, you'll have enough content to really put together a solid course you could offer through one of the portals for a fee. If this is your passion, you may as well get paid for it and I could see how each piece of this could take a lot of time to put together. It might be best to look around at the various offerings there are out there now (e.g. PluralSight, YouTube, Lynda) and see if there's a style or format that fits you best before you spend a lot of time on videos. Maybe a full-on eLearning approach isn't your goal, but it's food for thought about your goals in this. Last point: Don't forget your hard of hearing and low-vision/blind programmers-to-be! Making sure your content is accessible will make it stand out and potentially give you a new audience to help boost you to the next level of recognition. 
What a professional programmer ends up spending most of their time fixing.
Please send help.
This is pretty fascinating seeing how well Quasar performs. Has anyone used Quasar in production? 
My only feedback: Please include the import statements!
I'm curious as to why this is important to you - I did link a full github repo with all the working code (both pre-refactor and post-refactor), so I was thinking that would be even more useful for someone following along and running the examples. Is it just for people who want to copy/paste and type it in themselves, or was my github link too small/hidden to be noticed?
Thank you for the concrete and useful feedback! In my opinion, the DI refactoring is still useful in this example, and it's simple by nature of wanting to keep the code snippets tractable for a tutorial. (Curious: are you saying you wouldn't bother testing `Main` as it was, or that you'd refactor it differently that didn't use DI? I can see at least one option to the latter). Your other points make a lot of sense though - I'll be incorporating them into the post.
Didn't necessarily think you were trolling, but also wasn't sure what to make of it. Thanks for the clarification. I do have a post before this one that explains Unit, Integration, and End to end tests, but I see your point - I should probably put more context in this post.
Agreed! In fact I wrestled with including it in the article, but left it out for simplicity. I might mention it exists now though, just so they know there are better options out there.
Write a plugin for one of the Java IDEs. 
[This list of public APIs](https://github.com/toddmotto/public-apis) might give you an inspiration.
This might interest you: [Simon Brown - Software Architecture vs Code](https://www.youtube.com/watch?v=ehH3UGdSwPo)
I don't understand that, could someone explain please ? How is it different if I just create a new project and add angular2 into the assets pipeline ? 
Write a basic neural network, train it and run some out of sample data through it. 
Cool - The example shown on the page (app.js) has some very boilerplate code. Is there an option to have the service default to an impl that does simple assignment for us? At first glance it seems with a couple of config options that would handle the broad workflow of: call api -&gt; assign result to scope
try the sidebar and look at r/dailyprogrammer 
I'm a little bit confused as to what you mean when you say "build" vs. "compile" - can you carify?
I think what you may have meant is that you are recompile with the new JDK, then run with new JDK, and you are wondering if you can skip the compile step? If so that is the case, there is no need to recompile your code, as the bytecode format does not change between major JDK releases. In theory compiling you bytecode with different minor versions will give you the same bytecode, although in practice there may be slight variation (although there should be nothing security related).
The DI is likely just a matter of opinion. 
Yeah, this is one of the examples where it made me really appreciate the approach Brian Goetz and team working on Java 8 took with lambda expressions. Spring JDBCTemplate interfaces are around 10 years old and they supported lambda expressions without any changes.
Correct me if I am wrong. I was pretty sure that patches are for JRE itself. When you compile your source to .class files (often in jar). Your class has only code you wrote, without java "standard library". So for security patches you don't need to recompile anything - just update JRE on target machine and restart application. 
&gt; so I can't send any pictures of the code. Save your and our time and don't do this. It is impossible for us to compile an image file and edit it. Instead, if you wish to share your code, put it in a Pastbin or Gist. I say this because you'll have to show us the code and what the problem is since it isn't clear from the post. Even if the code doesn't compile, we can help steer you in the right direction.
JVM languages comparison, Java is simple but quite old ;)
You could write an emulator in Java.
You can do the same thing in C++, but you have other options as well.
This is terrifying proof of alternate reality theory. Somewhere, in a more secure alternate, this future came to pass. (You have to read the last paragraph)
*lol*
Of course you can, so C++ has more options for multiple inheritance, but that doesn't meant that Java has no multiple inheritance. As mentioned, it's just more limited.
- You might organize them as test groups. - You could use a IAnnotationTransformer to disable tests that don't match the runtime criteria. - You could inspect the test method in a `BeforeMethod` and throw a SkipException - You could use a DataProvider that inspects the metadata attached to a test method. Then use your build system to run multiple test tasks with different system properties, which configures your data provider. There are probably other ways I missed. Figuring out what works best requires experimenting with the TestNG apis. A good solution should leverage your build system and TestNG so that it fits in the normal lifecycle developers are used to. Here's my potentially useful [example](https://github.com/ben-manes/caffeine/tree/master/caffeine/src/test/java/com/github/benmanes/caffeine/cache). I use an annotation to specify the test's constraints and the DataProvider generates all of the permutations. A listener then runs common validation (inspecting internal state) after the test succeeds to detect corruption. The Gradle build splits this into multiple tasks so that TravisCI uses less memory and receives console feedback (otherwise kills the job).
I really like how simple Spark is and how easy it is to use but I wish they'd add more configuration options regarding the underlying Jetty instance. There were some issues opened on GitHub about allowing to configure the max size for upload (so you can upload files), external sessions (redis, db, etc), the ability to remove a header, etc.
This style is also possible with junit: https://github.com/junit-team/junit4/wiki/Assertions assertThat("good", allOf(equalTo("good"), startsWith("good"))); assertThat("good", not(allOf(equalTo("bad"), equalTo("good")))); assertThat("good", anyOf(equalTo("bad"), equalTo("good"))); assertThat(7, not(CombinableMatcher.&lt;Integer&gt; either(equalTo(3)).or(equalTo(4)))); assertThat(new Object(), not(sameInstance(new Object())));
I'm using multipart HTTP request to upload files. When I upload 5 or so ~20 MB files, my ram usage skyrockets to ~700 MB, is this normal? And is it possible to use https?
&gt; Instead of taking down sites that have some history, community goodwill, and even emotional attachment within the Java community, why don't you modernize them and make them competitive with the other sites competing for their attention? Because it's a needless investment of money. I've accidentally wandered into java.net in my work on Java maybe a handful of times over the past decade. Stackoverflow, however...
Can I override the default error page yet?
&gt; moving strongly to Linux/JVM and the client world towards Javascript I think you're right about that as a relative %'age, but as the total market size is still expanding, .NET adoption still continues and the total # of .NET developers continues to increase. Just look at TIOBE if you don't believe me: http://www.tiobe.com/tiobe_index Actually, with the current move towards FOSS and Cloud, I think we'll see C# adoption ramp back up as a %'age of developers, but time will tell.
Usually we try to write Spark Framework or Spark Web Framework when posting on reddit, but we forgot this time, sorry!
I like to refer to the [Mega Project List](https://github.com/karan/Projects) on such occasions.
Is there any support for http2? 
Lol his username ks just abhishek scrambled. 
Delbmarcs sa tnuoc neve desrever soed?
Thank you very much for that feedback. Indeed, the relationships with MS and Oracle are accompanied by a lot of sales, and that does matter to management. After all, the relationship is also more important, given that their products is where the critical data resides. I perfectly understand the argument. Some potential customers have chosen to build their own in-house "jOOQ" to keep a grip on the IP. Technically, that's not a better solution, but legally, it might be for the way some companies work. Too bad. But we'll stick around, get better, and in 2-3 years, things might change...
Not in 2.5, but planned for 2.6.
Windowframe?
Call of Java: Modern Windowframe.
Any game you designed to use this would probably work better as the same design, but using an in-game widget as the dragged window. Still, a fun design space.
Thankyou!! I have not heard of SQL2O before.... and my current project I was tearing my hair out with JPA....and I knew that MyBatis (my other favorite Database mapping framework), did have a few issues with large result sets... I have tried using SQL2O for the first time today..... and I am flying. So far so good. Thanks!
You use it with Spring right? Let me know how do you have your SQL. Do you have it as a string in your Java code? I find it ugly not being able to arrange it nicely due to Java not having multi line strings. I was thinking in having a XML file where each node would be a SQL query and then load that at app startup in a HashMap and then in the code just get the SQL query by id from that map. What do you think? This way in the XML you can arrange the SQL query string however you want.
Why not using MyBatis for this? http://www.mybatis.org/mybatis-3/ http://www.mybatis.org/spring/ 
Unless I missed it, I see any way for this to work with a local user DB of any kind.
I believe a newer jdk can always run code compiled by an older jdk. If you build with java 6 your can run it on java 8. But if you build with java 8 you need java 8 or better to run it. That's my understanding. 
I'm using a Filter in my spring boot application for authentication, A'm I doing it wrong? it Works fine though.
Is there any comparison of this project with Shiro and Spring Security?
I remember working on a project where pac4j &amp; buji was used to augment Shiro.
My thoughts on how this could be done- A canvas set to the desktop resolution, and a viewport that shows the part of the canvas it's currently over- positional reading of the canvas, not the OS display output. Any chance we could see the code?
Nice article. However, I didn't see a discussion of the _main_ reason (in my opinion) we should keep our domain model separate from the database. That reason is to keep the domain model as readable, maintainable, and most like the actual model of the business as possible. You don't want any external concerns distracting from the code that solves the real problems, and you don't want arbitrary constraints put on that code to prevent it from being maximally expressive and useful in every context needed for the business (caveat: not saying you have to have only one domain model for your business). For instance, what if you want more than one database (i.e. event sourced and multiple SQL projections). Or you want a reporting database for a certain subset of data. Same applies to UI - what if you want to render a web page, but also create PDFs for download, or support a text-only mode (for i dunno, a terminal back-office thing). The main point is, your domain should model the business processes in an abstract way, where invalid states are unrepresentable. All the inputs and outputs to the system should just be like "plugins", and that includes UI and DB (if you even choose to have one). You then need specialized adapters for each input/output, which can feel tedious, but you only have a handful for even a large system. And they will be dead simple to maintain. By coupling the business logic to the DB you're implicitly saying that it's the only data representation you want, or that this particular representation is _special_ and there will never be other specialized uses for it. The main reference I usually remember for this is [The Clean Architecture](https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) mainly for the diagram, but it's also known as the onion architecture or hexagonal architecture.
I solved all problems with any program that doesn't support NTLM proxies using [cntlm](http://cntlm.sourceforge.net/).
Definitely agree with this. IMO there should be abstraction between each of the Data Access, Business Logic, and UI layers of the application. With the caveat that the app is significantly large and complex 
Yes, you are correct. They do have commits, my bad, I overlooked it.
About the caveat, I always find it problematic, because projects that are small today might become big tomorrow. And if there is no person watching out.. We have a yet another 'messy, legacy project' coming :)
I suggest 'Spring+MyBatis'
Glad Instance API was implemented! That's one embedded jetty less in my platform (Spark was supporting REST, and Jetty the admin web site). I'm changing it ASAP. Thanks a lot. 
Will the sessions be recorded and then posted on the internet for anything which is missed?
Not an authoritative answer, but I'm pretty sure they will be, as all the other sessions: https://www.youtube.com/user/virtualJUG
Does it still have like 13 dependencies or is it more modular than in the past? I ask because I like Spring Security but am not working on a Spring project. My biggest issue with it is that it is so heavyweight and all the garbage you get in every stack trace once you add it to a project.
That stuff is really crazy. I only wish the tool support (e.g. in Eclipse) was better... EDIT: In fact, this post motivated me to [add checker framework support to jOOQ](https://blog.jooq.org/2016/05/09/jsr-308-and-the-checker-framework-add-even-more-typesafety-to-jooq-3-9/). Great stuff!
No updates, no security.
I forget the exact detail around this specific exploit, but most of these things exploit JMX or admin console ports in some way that you can get code to deploy in the container or send commands to it. All of these exploits access these admin ports over the internet. If you expose this type of functionality to the internet I can only say that you just about deserve what you are getting. It's basic application architecture 101 to put your app servers behind a firewall and leave a web tier in the DMZ that directs traffic into the app servers. I just simply don't understand why people would not do this.
not sure what SQL2O is, but we use hibernate jpa and not spring data in our spring apps, just persistence.xml and one @Inject EntityManager is all we need (very very simple)
crap title - security issues with JBoss result in the installation of backdoor malware.
Ideally, you wouldn't need to, because this stuff would require a certificate to access anyway. But, this being a web application, security is barely an afterthought...
Where can I read more about this web tier/DMZ architecture? Interested in understanding these types of infrastructure? Maybe you can tell me what best to google?
The term "multi-tier architecture" will yield some pretty good results on Google.
&gt;&gt; first detected by Microsoft oh &gt;&gt; crooks were exploiting vulnerabilities in older JBoss platforms oh &gt;&gt; 2,100 servers are still infected oh so not 3.2 million. Reddit needs moderators to fix blatantly false titles. 
This sounds very much like a clickbait headline, in which case the answer is categorically no
Because, obviously, people live only in the US! And then any given person is allowed to run only a single instance of the given server at a time! 
The sessions will be recorded and available on YouTube. This is authoritative answer :) 
They obviously should've used nodejs instead
I exploited a backdoor in reality, this means I can run three instances of a server at a time.
It would be nice if they mentioned what JBoss versions and products were affected.
[Is my JBoss / EAP Server Vulnerable to Samas Ransomware? If using community version, yes. Enterprise, no.](https://www.reddit.com/r/java/comments/4clj5q/is_my_jboss_eap_server_vulnerable_to_samas/) This was mentioned a month ago on this sub (~~and somewhere before then, but I can't seem to find that thread right now~~ [there it is](https://www.reddit.com/r/java/comments/3rvaha/what_do_weblogic_websphere_jboss_jenkins_opennms/)). My WildFly installations however didn't seem to be vulnerable, but they also don't expose JMX to the public.
The problem is that attackers don't go through the firewall -- they go around it and attack from the inside, using a compromised peer. These days, you have to assume breach of the firewall, and not blindly trust anything in your network. More on this here: https://tersesystems.com/2015/11/08/closing-the-open-door-of-java-object-serialization/
Wro4j for some website optimization stuff, Spring 3.2, Spring Security 3, Spring JDBC, Angular JS, and a sprinkle of Chaos :P
The [Agile Katas](https://agilekatas.co.uk) website is hosted on Google AppEngine. It uses Jersey 2 for routing the endpoints, Google Data store via Objectify for the database. Dependency injection is HK2 and the pages themselves are jsps.
cometd, zookeeper, jax-rs, mongo+orient+redis, kinesis. We're a little hipster.
This is awesome!
Axway API manager connected to Websphere and weblogic service engines with angular front-ends
nodejs, docker, google cloud sql, kubernetes, angular for the frontend. actually java is nowhere in our stack but i'm here and this is our web stack in production.
JAX-RS and Freemarker in Tomcat plus SQL DB and Redis.
Spring MVC, Spring 4, Spring Security, Hibernate, Tomcat, PostgreSQL, JSP/JSTL, Bootstrap
My company uses Dropwizard in a microservice architecture, assembled by Varnish and load balanced through ELB. The applications use PostgreSQL databases at their back.
Ubuntu, Jetty, Servlet 3.1, JQuery, and whatever communication/persistence rig makes sense for the app. I'm a huge believer in dead-simple, so I typically start with a MapDB-based implementation, and cut over to vendor-agnostic SQL, or Graph DB, or whatever is appropriate.
Lol IBM customer by chance?
yep, any tool is a crappy tool it seems so thats what i am using. Also, awesome username.
&gt; awesome username. It's always free. Unlike my real name.
Ok, let me elucidate you then. When doing smaller projects, it's overkill. You usually don't need it. But since I entered the enterprise world, it is invaluable, for very specific reasons. First, it's easier to show how everything works to newcomers in the diagram, than in the code. We're talking multi level 10 years in the making application, going through the whole code would take months. Second, I found that it's really easy to bridge the gap between the tech side and the functional side with uml. Most people that are business oriented don't really know or care about code, but they eat up diagrams. Many problems were solved by looking at power designer or enterprise architect (different companies) and showing were it might fail. And third, each hour spent (in complex applications, obviously) doing your diagram will save you 2 while coding. Many, many problems are found and troubleshooting starts way before we reach test environments, just because we found the problem while drawing the diagram. And this saves time, and time is usually money. Not saying that it can't be done without uml, or that there aren't other tools, but your comment is a bit short-sighted. 
Historical more then anything, not my decision, basically was originally built on basic servlets and jsp pages, then extended to spring 3 (4 wasn't released at that time) and although the update is fairly trivial, the main code base works directly with legacy code, and there is a general worry about going to spring 4. I also forgot to add camel to the stack, which is useful as all hell.
Spring Boot + Thymeleaf + Firebird SQL
MongoDB, Memcached, Dropwizard, AngularJS + bootstrap
You are right, we don't have much documentation at the moment. You can find some basic architecture documentation here https://github.com/micheljung/downlords-faf-client/wiki/Application-Design In terms of how someone could possibly contribute, you would be working alongside us, as we explain how and what to implement, how things work, etc. 
To give you a basic idea, it's using outdated technology, very poorly documented, very poorly written in terms of both style and just general code, there is no sane structure and has a lot of bugs.
I use yEd for all my post pen/paper diagramming. It's not amazing but it's free. https://www.yworks.com/products/yed 
Like in other cases where I've seen this happening, those who take the decision are usually not technical persons and just get "blinded" by marketing/sales team.
Are your applications dependent on using weblogic or that's just what your company uses?
One thing which would be interesting would be a FUSE bridge to Java's `FileSystem`. So rather than just a FS which only works with Java programs, they can be bridged with FUSE to permit other programs to use said filesystems.
Nowadays usually: PostgreSQL, OpenJPA, Undertow, Guice, Jax-RS, GWT/RequestFactory, GIN With some additions depending on need. I've been looking forward to use Atomix for instance.
JBoss EAP 5.2, JSF 1.2 + Richfaces 3 + Seam 2.2, Hibernate, MySQL, Elastic Search Yay for legacy code! 
For closing in on a decade now it's been ExtJS, DWR and bits and pieces of Spring as necessary (with an attempt to limit its use as much as possible) all running in Websphere (but now, thankfully, migrating to Tomcat). I suppose you could add various Apache Commons library to the list too, but that's about it. Oh, and of course: solid architectural principals... which is ultimately THE most important piece ANY stack. 
jQuery, Play, Akka, Scala, Slick, PostgreSQL. Oh, and nginx.
OMG, the JSF vote brigading here is worse than I thought :|
Debian, Grails 3, tomcat.
[UMLet](http://www.umlet.com/) is a free and functional drawing tool. No reverse or forward engineering as far as I know, though.
JAX-RS (Jersey) on Grizzly, Rythem Template Engine + JS, Bean Validation, Hibernate, PostgreSQL, Linux
Spring Boot + Spring MVC + Spring Security + jOOQ + Postgres + Angular (going to be switching to React, Angular sucks) + Webpack + Maven + Ansible.
I second this. My favorite program for diagrams and UML at the moment
My favorite is to use Plantuml code to do design docs. Fastest sequence diagrams ever. Can commit into git repo as well. http://plantuml.com/ There are eclipse plugins that give you realtime rendering. Downside is sometimes little harder to put things in specific places on a diagram, like far right. Worth a try though.
and even better you can use a "scopless" approach : see the example at http://www.beyondjava.net/blog/angularbeans-a-fresh-new-take-on-angularjs-and-javaee/ 
Field @injections reduce boiler plate code and make development and refactoring easier. I don't see why would field injection reduce testability, you can just write a simple parent class for your JUnit tests, which will inject what you need using reflection, or fail if you forget to inject something, whatever you need, it is so easy to implement. Or use existing solutions like http://stackoverflow.com/a/26638395/685796 
This kind of depends on your overall architecture. But generally I would lean toward yes, it makes sense to have one (or probably more) instances that are only workers. The benefits include 1) Independent scaling, maybe the workers need loads of resources but the web handlers really don't, 2) Fail over, if one piece goes down the whole system isn't compromised. Hopefully it would be a worker fails, but your API can still queue jobs for when it recovers (or additional instances come up). You'll want them reading from a shared queue so that each one can determine the work that needs to be done and not duplicate work someone else already took. Granted if you're doing a side project and fail over/resiliency isn't a primary concern yet - it's likely overkill and adds unnecessary complexity. Just be sure to keep the functional lines clear in your code so you could break out various components.
Yup. That or you end up needing some sort of message queue or some other central locking system. Overkill for a simple cron. Worth it if it's a big batch job you with a load you can distribute.
I should have said "in a txt file" thanks though man I might use this for a side project , I've never heard of this 
Why does it have to be in a text file?
Assignment lol. In not asking anyone to do it for me, just seeking some advice on the most efficient way of reading and writing data from a text file 
I am just going to try serializing I think that might be better then reading in the text contents and making that into an array 
I really depends on what the jobs are doing. If they're time critical (it's important Jobs run within a few seconds of each other (or are depending on each other)) than I would choose a single instance or a cluster. Keep in mind that the clocks suffer from something that's called 'clock skew'
&gt; If I may, a question for you: Why the interest in Java, coming from the .NET world? My guess would be wanting to save customers/employers money using open source stacks.
You are welcome :)
We run a system that has 4 load balanced servers, and runs thousands of quartz jobs every day. This is set up using the built in quartz clustering, which means that each job is guaranteed to only run on a single server without duplication, and it works well. We've had some problems with it, but they've generally been down to the jobs themselves rather than quartz itself.
Cool. Was Quartz's native support for clustering with JDBCJobStore not enough to meet your needs? If not, could you elaborate what more did the zookeeper approach offer?
Yep I was aware of that feature. But my question was more geared towards when is it necessary to have servers not serving web requests but just solely for running jobs. And is that a common/good practice?
Duplicate of https://www.reddit.com/r/programming/comments/4hvf7f/using_java_generics_to_express_variance_of/
This post should rather be in /r/javahelp as it is related to Java Programming. The various hints on the subreddit should have directed you there.
Project requirements - I couldn't use a database, but I was allowed to use zookeeper. Go figure.
Zookeeper is a faul-tolerant distributed locking service implementing the Paxos Algorithm (leader election). A ZK lock is like an inter process mutex.
I know that your pricing matches the market for these types of videos but I don't see myself ever spending over 200 euro on one of these courses.
I see your point, but those are overarching themes everyone (Java or not) should know and apply. The question was about java.. And I'd also say that they are in no way essential for entry level jobs. Nice to have, but declining a candidate because, even though he knows his programming, he didn't come from an it background at University, would be a mistake (especially because where I live the market is missing thousands of programmers and most companies now prefer to educate people with an engineering background to program. Those will not know REST or hear about design patterns, but^most turn out to be competent code monkeys. 
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
Hi and sorry for the late response! Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme
No problem. Thanks for reaching out.
Grails, hibernate, tomcat, postgres, mongo. And I'm working on my own web-framework in free time
socket-server based on epoll
web-server and framework based on it, and maybe json-parser
As a recent Java convert, I can recommend IntelliJ IDEA, Spring boot and Gradle as a pretty good setup. I was fortunate enough to transfer to another team internally, so I picked it up as I went. Now we're using Kotlin and loving it. 
If security is that important, it should be taught for a lower price.
Deploying, configuring and maintaining mesos/chronos is a lot more work than setting up clustering in quartz.
Especially if you are coming from .Net and have used recharger IntelliJ will make you feel like you never left Visual Studio.
1) You'll probably be able to find jobs with either language for at least the next couple of decades, probably longer. .NET is making a big bet with all of the Core stuff... and it's too soon to tell whether that will be successful, or if they'll walk back from it like they've done with half their new stuff lately. But "Microsoft shops" aren't going to disappear. 2) The Microsoft world looks to Microsoft for leadership in all things. The Java world has a rather distrusting relationship with Oracle, and embraces the open source ethos to a far greater degree. If that seems like a weakness to you rather than a strength, then Java's probably not for you. C# is (IMHO) actually a somewhat nicer language... its problem is that its ecosystem is shit, and few things get traction if they don't come directly from Microsoft. 3) Maven is basically Nuget and MSBuild combined into one, and does a better job than both. It's still widely used in larger more conservative shops, but in recent years Gradle has started to replace it. However, even Gradle pulls its dependencies from repositories that use the Maven format (pretty much every build and dependency-management tool does). That repository format is so entrenched that I can't imagine anything replacing it in the foreseeable future. 4) If you've ever used ReSharper, then you'd be fairly comfortable with IntelliJ. That's probably the best IDE out there today regardless, although some larger more conservative shops still use Eclipse (which would be kinda painful coming from VS). However, if a shop is using Maven or Gradle properly, then it shouldn't matter which IDE anyone uses. Committing IDE-specific files into source control is a terrible practice. 
Hi and sorry for the late response! Yes and no. The game engine is closed source, but a lot of the game's code is written in LUA and therefore can be modified as we like. Please have a look at https://github.com/micheljung/downlords-faf-client/wiki/Mentor-programme 
My team strives to make all of our data models immutable unless there is truly a need for mutability. The one problem I would have with getting rid of the accessor methods is it kind of throws encapsulation out the window. This makes it difficult to passively change your data model in the future. What if you decide you need to store these properties as some other object? With accessors you can do that and leave the old methods that return strings and just convert the new objects to strings for those methods. If your class is not being consumed by other teams or even other projects within your own team this is probably fine but that is rarely the case for my team. You could accomplish the same thing by adding new properties and setting all four in the constructor but then your storing the string objects all the time when you don't need them in the new design. 
http://immutables.github.io/
One way to reduce all the pointless boilerplate, BTW, is with Project Lombok. Add a @Value annotation on a value class and you get an all-args constructor, final properties, equals, hash code, toString, and getters automatically generated. Highly recommended :).
M7 fixed gtk3 issues??? 😮 M6 was still full of it, many rendering problems but above all crazy slow.
Well, I haven't had any problems after upgrading other than some mouse clicks affecting wrong items in the package explorer, and that is considering that I had a lot of problems with dirty components and EGit refusing to compare files without `SWT_GTK3=0`.
It's 2016 and you still need to get 'used to' immutable data structures in Java? People have preached this 15 years ago you know.
probably very little, if you use a global CDN provider, they get crazy hit hit rates from their transparent proxies, and are very tunable. source: worked for a CDN doing this.
Kotlin does that too, except instead of messing around with finicky annotation processor magic, you just replace `class` with `data class`. And it gives you a copy method that can take any number of the properties and return a copy of that object with all of the properties you didn't give it copied over from the old object. :)
Server(s): JBoss/Webshere for backend services, Tomcat for front end services, Mule ESB for middleware. Libraries: Spring, GWT, CXF/RestEasy, various other apache Database: Oracle. Thats Java5/6 on AIX and RHEL6, with oracle 10 - "legacy" . We have a zillion components (early 2000's style SOA with ESB and lots of XML, EJB, SOAP etc....). All in Java.
When doing JVM performance tuning, Jobs and Web Applications have different requirements. For web applications, I typically aim to minimizing latency at the expense of throughput for the best possible experience. Jobs usually have different requirements. With jobs, you want to maximize throughput. Therefore, the JVM configurations are opposite between web applications and scheduled jobs. edit: grammer
We deployed that exact architect at my last job. We have Quartz Jobs on a dedicated JVM inside of our JBoss EAP 6.4 architecture managed by QuartzDesk. The other JVM's are then dedicated to web applications. We then subsequently tuned each JVM to best fit its workload. We aimed for low latency for web applications whereas we aimed for high throughput for our jobs. 
the kotlin solution is pretty great, and interop with java is not too dificult.
I disagree with public fields in most cases, especially when you can just use: https://projectlombok.org/api/lombok/Getter.html Also, if you have an Immutable data structure, it would be nice if you add the https://github.com/typetools/checker-framework/blob/master/framework/src/org/jmlspecs/annotation/Pure.java or @Immutable annotations.
try xml. But i would go for mySQL or something familiar
Agreed! Liberty is only thing keeping me sane and we're slowly moving everything over to it. Unfortunately 80% of my time is spent developing in websphere integration developer for now, which means 75% of my time is spent watching progress bars crawl across my screen
In Java projects I usually choose HSQL over SQlite. I have a feeling that more Java tools supports HSQL.
X-Post referenced from /r/javascript by /u/Daniel15 [JavaPoly - Polyfills native JVM support in the browser](https://www.reddit.com/r/javascript/comments/4ih7yw/javapoly_polyfills_native_jvm_support_in_the/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Currently the only thing that happens for me is unresponsive script warnings that do not appear to go away along with 100% CPU usage.
Also [Google AutoValue](https://github.com/google/auto/tree/master/value).
This is an older thread, but thought as an outsider (C# guy) I might make a comment. At work, Im working more and more with Java and Eclipse. Its painful, but Im trudging through. The problem, I have in general is that (oddly enough), there are *too many* choices. The reason this is a problem is because when Im going for a C# / ASP.NET job, I know a great deal about their environment right away. They use Visual Studio. Likely use IIS and SQL Server. But with Java, I have to know about many of the various tools and libraries to even hold an intelligent conversation. Should I learn JEE or Swing? Do they use Ant, Maven or Gradle? JavaFX or SWT? Do they use Eclipse, IntelliJ, Netbeans or something else? The list is nearly endless. Wanting to be a competent developer in the Java world can make one become quite overloaded on what to learn. It often feels like you're spending more time learning a tool than actually applying yourself to the code problem you're supposed to be solving. I wont pretend that a Java person coming over the C# / Visual Studio doesnt face similar challenges. I dunno. But it just seems to me that the multitudes of options here makes it rather difficult to pin anything down and feel confident about it. Its definitely a different mindset.
Not a big fan of the GPL license.
Yeah, this is on their roadmap for 1.1.
Also, [Google FreeBuilder](https://github.com/google/FreeBuilder).
Scratch an itch. Add a feature you miss.
Depends a lot on where you are, at my company people use immutable stuff where it should be used while my previous work was full of setters
+1 for jhipster 
I work at a large Dutch bank. The back-end is, aside from Spring Config and DI, mostly 'custom'. Some serious NIH going on. Fortunately I'm going to move to another team soon that uses Spring Boot and it's associated goodies. For personal projects it's pretty much always a Spring Boot (so MVC, Config, JPA and DI mainly) REST service with an Angular 1.x (haven't moved my standard workflow to Angular 2 yet) client. Since I have different projects on my VPS I use Nginx as a reverse proxy. 
Basic Auth over HTTP? :)
Cool. Now make a Pong game where you control scheme is based on dragging the frame ;)
I would like to challenge this: &gt; A Video Course is the best way you'll learn coding and tactical know-how. With: No it isn't. Aside from this this is just commercial spam. 
Ok, I'll try m7 as soon as the EE version is available (which always lags several weeks behind)
Take a look at Eclipse MDT. http://wiki.eclipse.org/MDT/UML2
Neither am I, but BootsFaces is licensed under a dual license, which is currently LGPL (which is acceptable for commercial projects). However, for 0.9.0, a move to Apache License 2.0 is planned (see [License Clarification](https://github.com/TheCoder4eu/BootsFaces-OSP/issues/322).
Using Spring Boot with Kotlin at the moment. Kotlin complements Java, it does not replace it. Just Java is fine too, use whatever you're comfortable with.
My view is that learning *any* technology can be enjoyable, so you might as well enjoy yourself learning something that makes you employable while you are having fun. Do a mock job search in your area and see which technologies get mentioned the most frequently.
Personally I work in a Java shop so end of the day I stay comfortable in the jdk. New technologies come and go but end of day the jdk is going to be my foundation. As I build new applications I tend to use the thought works tech radar to help me decide which new technologies are worth digging into for new applications or to be retrofitted into old. https://www.thoughtworks.com/radar
You probably want spring-social for ready made OAuth integrations.
Memes and Jokes, as well as music videos are not allowed on this subreddit. **Post removed**
Yeah any reasonable modern language has support for these things. Scala case classes are basically the same. I'm not very familiar with Kotlin, but Scala also blurs the line between field access and method invocation since you can invoke methods without parens. But I'm not super thrilled with the approach most languages take, which is to make the syntax more complicated. I prefer we rethink it from the ground up, and so I prefer Clojure's syntax the most, which reasonably blurs the lines between functions, values, and maps. Because values can be thought of as functions that return a constant, and functions are just maps that are dynamically computed (and sets are maps from a value to itself, and vectors are maps from indexes to a value), so the syntax can be rather simple if we consider that these constructs (functions, values, data structures) can be semantically very similar. Clojure falls short because it is dynamically typed, but I think it's very interesting and refreshingly simple, semantically and syntactically.
Currently, we use path partitions and route everything through the load balanced proxy. The proxy routes requests to the backends. The backends are defined by infrastructure configuration. So the proxy stays dumb (dumb pipes, smart services). Everything HTTP-related is built with Hypermedia. For a single system, we have one link e.g. *https://platform.local/account/* that a client can start navigate on. If things move, we do redirect until the client has updated the home URI. So its basically how the web works. If the load grows, we can start to split the systems across proxy servers. So the callsite for such a service can then be like *https://account.platform.local/*. If we would implement service discovery, it should be a machine readable Google-like service. For lots of people, Google or Bing is the homepage. So we can adopt that. Right now, our systems implement a prerequisite for that through URNs for exposed resources (a user account is like mrn:account:1234). td:lr We do not have "service discovery" right now. Applications know links that are navigable.
The Voxxed Days Bucharest was a really good conference. 
I really dislike Scala's syntax. I think that it suffers from every issue you've described. It's too complicated and feels like it's being clever for the sake of cleverness. Scala was born out of academia and it shows. Kotlin was born out of the industry. It's pragmatic and only adds syntax constructs that increase readability. If you want a simple, lightweight, statically typed language that any Java dev should be able to feel comfortable with in under a week (especially if you have functional chops, coming from Clojure, as that's what most Java users suffer from when moving to Kotlin), I think you'd really enjoy Kotlin. 
[Here's another tech radar I'd like to refer to](http://i.imgur.com/3aav3iq.png). Original source: https://twitter.com/bodil/status/597766837548507136
The free tier of [Openshift](https://www.openshift.com/pricing/plan-comparison.html) lets you run three applications, each with their own subdomain of `rhcloud.com`. It does support Java too, so it should work for you.
Felicitari! Congrats!
What's your agenda here?
spring mvc
What type of projects were you writing? Web apps in play? I have a weird background. Did Java EE for six year and got bored. Moved onto node.js doing distributed backend systems where I fell in love with the whole functional paradigm thing. I picked up Scala and it's been super fun learning it but I can't think up of any projects really besides web apps. Thanks in advance. 
In the filter I check if for the url the user needs to be signed in, if is not I redirect the request to the login page.
First it's always good to learn new things, new ways of doing things. However if you were to choose what is most likely to get you a job, or a stable platform, I would say, learn things from other platforms and bring them into Java/JVM land. This is what happens, the other languages/frameworks are testing grounds, and the steady ones are what you put up for high-risk systems. If you're in a startup, most of them are much more tolerant to downtime, loss, etc... So play as you wish.
Screw hosting, it has too many limitations. Go with vps for example from digitalocean. 
&gt; Utilization of such data in the educational industry would lead to big gains almost from day one. I am not sure I agree. First, errors in itself are not bad. Rather they are usually a sign of progress, i.e., student does a mistake and by correcting it finds out how things are done correctly. If you never make mistakes, you never learn. Second, even assuming the reported errors could be removed then it is not guaranteed that students learn faster or write their programs quicker leaving more time for other topics to learn. Now, if it is about teaching efficiency, even then I am not sure. Sure, instructors could address known frequent bugs and use languages that make it easier to learn. But: these languages might not be used in the "real world" and, again, less mistakes does not necessary lead to a faster or better learning experience. Even more so, I suspect that quicker learning is also the type of learning that leaves less traces and thus is easier forgotten. I think there are a lot of questions open and I do not share the hope of "big gains" - even less "from day one".
Man, what is this `ț`. I started scrubbing my screen, thinking there was some dirt!! :p
Ah, your post makes sense, because in all honesty, I like the structure of a spring mvc/boot application, I just don't like the security part. Thats the only thing that bothers me. The other stuff is great. :) I think I will just implement a simple (non-oauth) stateless authentication for my application. 
It's the Romanian letter for the z in Pizza
https://www.voxxed.com/blog/2016/03/netflix-stack-using-spring-boot-part-3-feign/
Mul�umesc... Why not just use z, then? ;)
Nice preso, thanks!
Oh, I forgot versioning. Its simple: be backward compatible as much as possible (dont break clients). If that's not an option, we just use new resources, like https://platform.local/account/user/1234 and https://platform.local/user2/1234. All documents that contain the original link, will also contain the new link. If we have clients outside of our maintainance, we respond with an additional X-Deprecated header, with a date as value to determine a deadline for latest migration time. After a grace period, we remove the old resource. When clients navigate through links (as they should) we can then rename the resource back to the old one. But that's just cosmetics.
This was already posted here, but it appears the post was deleted due to the negative karma it obtained &lt;https://www.reddit.com/r/java/comments/4ih871/javapoly_polyfills_native_jvm_support_in_the/&gt;.
Well based on what he said it doesn't sound like he needs a full-fledged database.
change.org uses dropwizard for a few different backend services. 
Netflix
&gt; Moved onto node.js doing distributed backend systems certainly not boring, but honestly, JavaScript gives me nightmares.
&gt; Kotlin was born out of the industry. It's pragmatic and only adds syntax constructs that increase readability. I wish they never added the elvis operator, that increases readability at the expense of maintainability.
Yeah, and frankly, 15 years of people working on it, and it's never caught on because it's a pointlessly bad way to write web apps. When the data comes in from the database, it gets translated from db values to object values. So it isn't "immutable" there, things can go wrong. When you get a form submitted to your app, it's also translated from html string values into object values. That's the second place it's also not immutable. The bottom line is you go to a lot of extra work to make things "immutable" but it's just pretend. Encapsulation to the data is already impossible in 2 places that are used for nearly ever request. It's a solution looking for a problem, and 15 years of development have shown it's a poor solution. There's not 1 major, commonly, widely used language that does "immutable" data by default. There are several languages that do do it that way, but they've stayed small, niche, and not widely used. And there's a good reason - because it's a lot of extra work for little or no benefit. 
well, it appears to
Funny you chose to refer to the Thoughtworks tech radar, then. Given they hardly ever reference the same tech in consecutive editions, and never really refer to "enterprisey" tech at all...
Because the Z letter is associated with a different sound (it's equivalent to the Z sound in English).
Wicket is a little more mature so I'd start with that.
"xyz is broken" is the new "xyz considered harmful".
True enough, although for people new to the language (and even some veterans), IMHO the reminder that char no longer holds any char is useful.
The `char` type is by no means broken, and it behaves exactly as it says it does. It is, however, a (very reasonable) compromise. Getting a single unicode character from a string is not done using `String.charAt` -- which does exactly as it says: `Returns the char value at the specified index`; note "*char value*" not character -- but with the `String.codePointAt` method (which also does exactly what it says: `Returns the character (Unicode code point) at the specified index`; note "*character*".
So many false assumptions and terms in this article... author should have read the excellent [utf8everywhere](http://utf8everywhere.org/) *manifest*! Even if this is simply not feasible within the JVM environment, the article sharpens one's mind concerning the dealing with Unicode in general.
&gt; So many false assumptions and terms in this article... author should have read the excellent utf8everywhere manifest! &gt; Care to elaborate? I do not see any errors. Saying something is false does not help 
It is not a reasonable compromise if it does the wrong answer. char is no longer useful. an example of a reasonable compromise is utf8. it works both forward and backwards.
It may be that `char` is no longer useful (I believe `String`s are abandoning `char` in favor of `byte` in their internal representation), but utf8 is not a compromise for a character type anyway. I think `char` is still a bit useful in the places it is actually used, like parsers, that parse grammars only rarely (if ever) involve characters beyond the 16-bit range (but often use characters beyond the 8bit range). But it's true that parsers could work with `int` (how strings represent unicode characters) rather than `char` without any harm. They probably should. Still, "no longer as useful" or even "no longer useful" is not the same as "broken". "char should be retired" would have made for a much better headline, while still preserving its clickbatiness.
&gt; Even if this is simply not feasible within the JVM environment I think String is about to switch its internal representation from to use `byte` instead of `char` for its buffer (and maybe even switch to an internal encoding of UTF-8, although that has serious performance implications, so it may not be done). See [JEP-254](http://openjdk.java.net/jeps/254).
Glad to see that you've softened your stance on annotations. They can be misused, but they can also be put to great use.
&gt; For instance, the checker framework should be able to hook into first-class expression tree manipulation SPIs (similar to what C# is offering), not into annotation processors. Why? Annotations have a very clear spec, and annotation processors are a great place for pluggable type systems that ensure that the code would compile and run even when Checker isn't available. Annotations basically define optional syntactic elements that can be recognized and ignored. Nothing else can give you that. I agree that *runtime* annotations that are more than hints (i.e. the code no longer has similar semantics without them) should be used sparingly if at all, but source-level annotations? They're awesome, *especially* for pluggable type systems! Although, Checker isn't quite a "plain" annotation processor because it *does* use internal javac APIs, but perhaps those would be exposed one day.
Nothing in the checker really depends on annotations. Of course, I may choose to base my checkers on annotations (because I can), but that's not really a requirement. I could have implemented the jOOQ-checker based on method name conventions, for instance. Or on external configuration files.
Ok, no problem: The OP uses the term *unicode character* - what does he refer to? Code point? Code unit? (probably code point, but that is not clear at all) Further more he states that ``someString.charAt(0)`` breaks for a code point that requires two code units, which is simply not true at all, as a ``char`` is just a representation of code units! So his false assumptions lead to his judgement. Further more he also overemphasizes the importance of code points; what does he gain from accessing exactly one code point? Also he ignores the fact, that *index* access for code points is expensive (at least for memory efficient represantations), which means O(n). Last but not least he overestimates the capabilities of a compiler - how could that one know, if you break a grapheme cluster? I hope my initial concern is now understandable 😉
Sure: one of the cool things about checker is intersection types. E.g. you can have `@Tainted Integer` (or even `@Tainted int`), `@Tainted String` etc. Now, I don't know if the tainting type system supports that currently, but it could: `@Tainted Integer` and `@Tainted String` both subclass `@Tainted Object`. How can you do intersection types using plain classes, given that the Java type system does not support intersection types (neither does the Haskell type system, BTW)? Another cool example of intersection types is units. You can have `@m int` and `@m double`, both box-subclassing `@m Number`. 
`Tainted` could be an interface and then I could create the intersection type `Integer &amp; Tainted` (e.g. using Java generics, and hopefully in the future also as first-class citizens). Of course, this doesn't work with existing types, only with my own tailor-made types, which in my opinion is correct. I shouldn't be able to enhance types that aren't designed for such enhancement, but that's just an opinion. In any case, this is possible outside of annotations :) But I see your point, and it's a good one. While the Java language doesn't have extension methods, it has extension types. Weird, eh?
&gt; 😉 Is that one code point? ;)
http://unicode.org/emoji/charts/full-emoji-list.html#1f600
Interesting, thank you for the linkt to the JEP! &gt; and maybe even switch to an internal encoding of UTF-8, although that has serious performance implications Could you explain, what performance implications you mean?
[removed]
Do properties a la Groovy make private fields available publicly in the same way as getters? I think illhxc9 was suggesting to avoid using Getters were not 100% neccessary as exposing private fields makes refactoring later more difficult. Making your fields public seems like it might suffer the same issue. 
&gt; especially considering that such a feature would need a runtime counterpart As it stands right now, they might not need a runtime counterpart. The intersections can be erased and the casts hard-wired in byte code. Note that Java already has intersection type support when: - Using generics (since Java 5) - Casting (since Java 8) &gt; But that's precisely the whole point of intersection types. Limiting existing types without changing them. Yes, I know. But `Integer` is final, so those types are special. It shouldn't be possible to subtype them with tricks, such as annotations. But perhaps, that's a different story. &gt; I don't know. Is it? :) We'll know (as always) in hindsight :)
also "why you should[nt] do xyz" 
JEP-254 &amp; JEP-280 are already part of jdk 9, the gains are surprisingly big. [presentation](https://www.youtube.com/watch?v=wIyeOaitmWM) [slides](http://shipilev.net/talks/jfokus-Feb2016-lord-of-the-strings.pdf) [article](http://www.infoq.com/news/2016/02/compact-strings-Java-JDK9)
Can you show an example where compile-time intersection types (as we have them today) interfere with `instanceof`, or where they show inconsistent behaviour? In fact, I believe that `instanceof` is a very good argument in favour of what we have in terms of `A &amp; B`, and against using annotations for this. Annotated types and `instanceof` don't work together nicely, do they? &gt; You could say that they're final so they can't be subclassed, but they can still be intersected. You're right.
If you have basic knowledge about Spring MVC/Spring Security, you can just find working bits of configuration there. I just mentioned JHipster, because it uses exactly the same stack (Spring Boot/ Spring MVC/ Spring Security/ AngularJS) you mentioned, assuming you are already familiar with it. If you are not familiar with spring configuration/filters, bare examples won't help you, IMHO. Spring is quite a big piece of sh$t (in a good sense :) RTFM again then. :)
From the performance viewpoint UTF-16 is nearly equal or worse that UTF-8 (surrogate pairs, codepoints represent by two or more 16bit values, big/little endian checks, etc). At least UTF-8 needs less checks and the length of the codepoint on bytes are stored inside of each byte. Only UTF-32 would allow to keep the asumtion that a 4 byte value is always a codepoint, and work fast like on the old days of ASCII.
Yeah I know that. RPC is always a pain. I had some projects using RMI. It only works, if you control both, client and server applications and if you can force the client into updating before any RPC happens. That's why I like Hypermedia APIs. They defer maintenance on the client by being as friendly as possible. Best example is HTML. You still can open many pages in a Netscape browser and extract the important information.
&gt; The OP uses the term unicode character - what does he refer to? It's pretty clear that he means "code point". His complaint is that `char` represents code units, while people (quite reasonably) think of them as code points. (Which they confuse with the everyday concept of a character, which nobody really knows what is.) &gt; Further more he also overemphasizes the importance of code points That's true.
&gt; But I would expect x instaneof A to be true if x is of type A &amp; B if intersection types are part of the platform. Indeed, and that's precisely what happens today. public &lt;T extends A &amp; B&gt; void method(T arg) { // Always true if (arg instanceof A) ; } In fact, Eclipse will even issue a compiler warning, because the `instanceof` check isn't necessary. &gt; Checker's greatest contribution That's certainly true. Implementing a checker is already very easy. Now, if tooling (IDE) support works better, I'm sold!
Fully agree. I would always at least support that approach and also use a upgrade friendly format like JSON. You can always add a binary option using accept headers for performance critical calls. If you use Jackson switching from JSON to Smile is just a single line of code. 
Ok, so let's summarize: The OP complains that there is no *unicode* type, that enables one to represent a single **code point** and that the string type is not built upon such an imaginary type, so that one can iterate over code points and have random access to them. So he should really try to understand that this is an artificial problem for most use cases, as one cannot really work with code points! You cannot reason about how many bytes they occupy within a storage system (database, flat file and so on), you cannot reliable *count* in order to define a maximum length of an user input and so on... The most important fact about an enforced internal unicode representation within a string type is, that all APIs based upon that type are compatible! That is one important reason, why C++ ``std::string`` suck (and pages like utf8everywhere exist 😈)
Yes, that's pretty much it.
&gt; Unicode was 16-bit back then and Java used UCS-2. No! How can a **concept** have a bit depth 😉 And even if the code space had contained less than 65000 code points in 1995, what about surrogates, sequences of coded characters and so on - or were those things added later to the standard?
I'm personally not a fan of the `Optional&lt;T&gt;` route at all. That's exactly what `T?` is designed for. 
&gt; I'm personally not a fan of the Optional&lt;T&gt; route at all. That's exactly what T? is designed for. That's essentially what T? is for languages that support it.
It's for all platforms not just Android and it is applicable for desktop apps too.
Well 8-bit is not enough, and 32-bit is not enough if the galaxy is teeming with life and advanced civilizations each with their own equivalent of Unicode. So the only way for this to work would to have a 64-bit type for single characters. &gt; But char is a different story altogether. Let’s look at its official definition: To this site the "official definition" is a tutorial written by Sun/Oracle and not the Java Language Specification
Note also that combining characters are a thing, so even `int` cannot represent all possible characters.
Why not just make the char variable-length as well? By default Java will use one of its UTF encodings so if you need to represent a character that requires more than 16-bits, it'll do so. Likewise, stuff like 'a' and '1', will actually use less memory. I don't really see a backwards compatibility reason not to do this.
&gt; You cannot reason about how many bytes they occupy within a storage system Why not have a big enough type like 4 bytes and have the compiler determine that a character requires 2 or 4 bytes in the internal memory. database and files are a different topic. &gt; you cannot reliable count in order to define a maximum length of an user input and so on... How so? Given a unicode string in which some characters take 2 bytes and other take 4 bytes, we always reliably count the maximum length (bytes or number of characters)
another http client? how is this different better from okhttp, apache and ten others. need a tl;dr
&gt; 4) What's the best IDE coming from Visual Studio? Compared to VS they would all look very ugly. IntelliJ is the best one out there
I'd suggest [Jelastic](https://jelastic.cloud/), very easy to use, relatively cheap for cloud hosting, and some providers offer a free trial to test your software on the Jelastic cloud.
They have given an extra week.
https://www.reddit.com/r/javahelp/ visit that subreddit and/or google *HttpURLConnection* or *JAXRS http client*.
Spring [RestTemplate](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html) makes it pretty easy Put `spring-web` (702kB) on your classpath (ex. as a Maven dependency) RestTemplate restTemplate = new RestTemplate(); String s = restTemplate.getForObject("https://www.reddit.com/api/info.json", String.class); System.out.println(s); 
Haha, alright. Thank you for the tips! :)
This post should, if presented following the [**rules**](https://redd.it/48eykt) (which will require quite a lot more effort), be posted in **/r/javahelp** as the many hints on this subreddit indicate. **Post removed:** Programming help 
IntelliJ is good, much better than Eclipse, but it's still a far cry from Visual Studio.
even more accurate.. security issues with _older_ versions of JBoss...
This isn't the client, you can use various HTTP clients as the network layer but this provides a concrete implementation of an interface that simply outlines the contract of the API (a fake example since I'm on mobile, the annotations here are from spring, but others are valid too): interface GitHub { @RequestMapping("/api/v1/resources", HttpMethod.GET) List&lt;Resource&gt; getResources(); } Then you can just use Feign.create(Github.class) and have an implementation that does all the serialization and such for you. Personally I like Retrofit a little better, but feign is highly inspired by it and is pretty similar.
We are rolling out a lot of our stack in Spring Cloud Netflix, and feign plugs in really nicely (@FeignClient simplifies it even more). You can client side load balance if you're using Eureka, pretty great for back end service communication. But if I'm not integrated into spring already I usually reach for Retrofit. It's a little more flexible and longer in the tooth - so it feels a little bit better to me (part of that may be bias from me using it first). Both are solid.
So basically we need to change char from a ushort into uint and make some form of CharSequence subclass for UTF-8 and UTF-32 as part of the standard. UTF-8 for normal string use and UTF-32 for special cases where indexing a UTF8 string is simply costly. 
Out of curiosity, how does this compare to the usual free options like apache commons-daemon or YAJSW.
Where did you come up with that? Netflix is very open about how they run their stuff and I have never seen any mention of spring. http://netflix.github.io/
If you are implying that the original authors intended for char primitive type to properly hold UTF-16 code points then you clearly didn't read the article. The author clearly points out that it is a common misconception that all UTF-16 code points are 16 bits. In fact it is 4 bytes by default, except the first 65536 characters omit the first 16 0s, so they can be represented in 2 bytes String.charAt() returns a 2 byte value (char) so it is IMPOSSIBLE by contact to behave the way you seem to assume. And that's why String.codePointAt() returns an int (4 bytes). If anything I'd say the same to the author of the article. The only problematic thing I see is the way it's worded on the Java documentation. &gt; char: The char data type is a single 16-bit Unicode character. I agree that's a documentation bug. 
The main downside is that it can be slow -- turning on checker-framework changes my javac time from 20 seconds to 8 minutes. Because of the run time I only invoke it occasionally. Also some of its warnings are complicated and the workarounds may look very strange to developers who aren't familiar with it. For example if you want to create an array of @NonNull elements you have the problem that the JVM always pre-fills every array with null values, so checker won't let you just `new` a @NonNull array. Instead you have to create it as an array of @MonotonicNonNull, then fill it by touching every element exactly once, and then once you're confident that there are no nulls left you cast it to @NonNull -- which is still going to require a @SuppressWarnings somewhere nearby. I've also had it get confused about whether something is or isn't null, for example I check a final value against null and then go into a branch where it's not null, but then somewhere along the way checker can no longer infer the nullness and when I use the value it complains that it needs to be checked (this usually only happens in very large or very esoteric cases, such as referencing the value inside an anonymous inner class created somewhere after the null check). That said, I still use it. Be aware that you probably can't use both checker-framework *and* FindBugs on the same code base, because FindBugs (last I checked) doesn't understand type annotations and even encapsulating them in comments is not enough. Again arrays cause some weirdness because when you say: @NonNull Foo /*@Nullable*/ [] bar Checker-framework understands that to be a possibly-null reference to an array of non-null Foo references, but FindBugs will treat it as a non-null reference to an array of possibly-null Foo references.
From the Java tutorial: &gt; The `char` data type is a single 16-bit Unicode character. And from the Java Language Specification: &gt; `char`, whose values are 16-bit unsigned integers representing UTF-16 code units... The Unicode standard was originally designed as a fixed-width 16-bit character encoding. It has since been changed to allow for characters whose representation requires more than 16 bits... Characters whose code points are greater than U+FFFF are called supplementary characters. So `char` is a 16-bit Unicode code-unit, which can contain a 16-bit Unicode character, which can represent anything we normally call as a character in virtually any language, plus mathematical and other textual symbols. It does not represent "supplementary characters", which are things not normally thought of as text characters, such as 🐭, 🎭, 🂷 or 💉. So what has changed since Java's introduction isn't the definition of `char` but the definition of a character. Does that mean that the `char` type is no longer useful? I don't know. It is certainly no longer *as* useful. But it does exactly what it says it does -- which may not coincide with what people intuitively think it does when various pictograms are concerned -- because Unicode is complex, and people who deal with what has now become known as "text" should be aware of that, but it's not "broken".
"The author doesn't say "UTF-16 doesn't provide 65,536 possible characters"" I'm sorry, I understand this, just said it incorrectly thank you very much! :)
how i stopped worrying and learned to love xyz xyz is the new zyx oh how I hate those generic titles
Release notes: https://access.redhat.com/documentation/en/red-hat-jboss-enterprise-application-platform/version-7.0/700-release-notes
Said the freshly created account with is tooootally not a sockpuppet account.
Indian travel website Yatra.com is made in spring mvc (backend services) http://www.yatra.com
No, if you want you can compile it from source yourself. JBoss EAP is GPL and the GPL doesn't allow a production/dev discrimination. Of course, nothing against paying and the support contract is *well worth* it, but if you are an individual or small company and want to self support just compile it from source.
UR welcome :)
In order to download sources you must have an account, so I would guess, that Red Hat considers sources to be covered by that agreement too. And there is not any guarantee that other sources of source code provide patched version.
In my opinion the best / easiest way to get started is to start contributing to a project you use yourself. So what are your favorite libraries?
Be brave, contribute to OpenJDK
This is a great release. I am excited about the new graceful shutdown option. The only downside is the new web interface. 
I've never built a Java EE server from scratch. I think I'm going to try this out today. Thanks!
I'm not sure what lazystone meant, but in general he would be right. "WildFly" is Red Hat's open beta program, so bugs and missing or partially implemented functionality is expected. As soon as "WildFly" is deemed sufficiently stable it's renamed to "EAP". The mere fact that WildFly is called WildFly therefor means that Red Hat themselves consider it still too buggy for a final release.
We'are running WildFly in production. I did migrate our stack from JBoss4 to JBoss7/WildFly7 and eventually WildFly 8. I spent some time in their bug tracker in order to fix this and that. Memory leaks are the most annoying. We are running a bit patched 8.2.0. When I tried latest 8.2.1 it just ate up the whole heap after a some days and died. I consider this to be buggy.
I think Redhat does too. They do not recommend anyone using this version. But Wildfly 9.0.2 is very stable.
Ah, ok. Thank you very much. I will try my luck there.
Because of time - you have to migrate development environments first, all non-production environments and finally production. And since usage patterns in non-production and production usually different - you'll find some surprises in production only.
I think this was fixed in the latest Milestone for the Neon release. See the New and Noteworthy here: [http://www.eclipse.org/eclipse/news/4.6/M7/](http://www.eclipse.org/eclipse/news/4.6/M7/) I'm guessing you downloaded the Mars.2 release, which is the latest official release, but the Neon M7 milestone is considered stable. You can get it from here: [http://www.eclipse.org/downloads/index-developer.php](http://www.eclipse.org/downloads/index-developer.php).
Awesome! That solved my problem. Thank you very much!
What'd they say?
Preempting the next question, the article also contains the affected versions.
What is JEE monster?
So are they going to fix version 14 or do I have to upgrade to version 16? I'm using ultimate and can not buy a new version right now. Edit: 14.1.7 contains the fix. :) http://blog.jetbrains.com/blog/2016/05/11/security-update-for-intellij-based-ides-v2016-1-and-older-versions/#comment-254190
They fixed everything with the vuln, even back to 2013. Pretty well done of them
You should checkout Wildfly Swarm. It is a great evolution for Java EE. 
Not much, just "nice video" or some such.
 Massive Spring Cloud Brixton GA release train offers new discovery providers, stateful patterns, tracing, @NetflixOSS Atlas telemetry for Spring Boot 1.3 
Does this internal web server listen on localhost only?
but... I don't give a shit about supporting emojis :( and consider 👌👀👌👀👌👀👌👀👌👀 good shit go౦ԁ sHit👌 thats ✔ some good👌👌shit right👌👌there👌👌👌 right✔there ✔✔if i do ƽaү so my self 💯 i say so 💯 thats what im talking about right there right there (chorus: ʳᶦᵍʰᵗ ᵗʰᵉʳᵉ) mMMMMᎷМ💯 👌👌 👌НO0ОଠOOOOOОଠଠOoooᵒᵒᵒᵒᵒᵒᵒᵒᵒ👌 👌👌 👌 💯 👌 👀 👀 👀 👌👌Good shit being broken a feature.
First off, the IDE itself shouldn't matter. Secondly, you already made another post. Thirdly, post your code and tell us what you've tried. If you decide to do this all inside one class (not recommended but since it's so simple to make a hangman game, why not) then you could just add it all to your main method (or add it to a constructor and make the object on the workbench.) Here are some things to push you in the right direction: Note: See Java documentation and tutorials on how to use this stuff 1) The Scanner class to get user input or JOptionPane. 2) Swing in general 3) JFrame and JPanel and JOptionPane in particular (yes I know I said this twice). Also JButton for the buttons you mentioned. Simply get their input, check if the letter they entered is part of that particular word, if not add a piece to the hangman and if it is then update the particular sections for that word. As for organization, if you decide not to do it visually with something like a class extending Canvas and implementing Runnable - I'd look into layouts (Like BorderLayout) to help you organize this stuff inside the frame). Just stuff pushing you in the right direction, good luck.
You have angered the intellij marketing machine. A pox o downvotes on you!
Thanks! Also for my other post I think that was my friend sorry about that...
thanks im migrating to digitalocean!
This is a question about *Java programming* and as such this question should go in **/r/javahelp** as is indicated in many places on this subreddit. Please, before posting there, read the [**posting rules**](https://redd.it/48eykt) because as you have presented it your post will not be acceptable there either. **Post removed:** Programming help.
I don't have an agenda, I'm just talking about stuff that I spend a lot of time thinking about.
Yeah gotta agree. I prefer Eclipse in general, but the Maven support is pretty poor. The Gradle support is fantastic though, which is much more important to me personally.
Keeps being asked for? 12 years is less than a vote a year. It only got one more from this thread. I guess people don't actually care that much.
Interesting that they go out of their way to really randomize the iteration order.
Interesting. Is that documented somewhere?
https://github.com/google/guava/issues/1268
According to their G+ profile, "Spring Boot 1.3.5 released to address a significant #springintegration regression in Spring Boot 1.3.4 ". So it's a single issue fix.
BitBucket has had this since the beginning. And since they're private you don't have to worry about the shame of people thinking you use BitBucket. &lt;This is sarcasm because GitHub is cool and BB isn't...&gt;
Great step for them to get more devs to use them but a bad move for the businesses using it as it works out soo much more expensive now. 
Sorry. Schwartz's opinion became worthless once Sun was sold to Oracle. He had his chance to make the license more open and he didn't.
The truth hurts apparently.
According to James Gosling, the popular opinion at Sun was that Google "[totally slimed](http://www.cnet.com/news/java-creator-james-gosling-google-totally-slimed-sun/)" them with Android. At that point, Sun wasn't in a position to do anything about it. Jonathan Schwartz tried to turn lemons into lemonade, in what he called a "grit our teeth" strategy. 
The problem is that people could inadvertently depend on the iteration order. I've certainly seen such bugs before. Better that it changes from run to run (so that such bugs are picked up in development) than trying to figure out what on earth went long when a Java update breaks things later.
Currently and historically you need to purchase a license to the TCK, then once all the tests passed you had official an Java implementation.
Memes and Jokes, as well as music videos are not allowed on this subreddit. **Post removed**
[Implied License](https://en.wikipedia.org/wiki/Implied_license): &gt;An implied license is an unwritten license which permits a party (the licensee) to do something that would normally require the express permission of another party (the licensor). Implied licenses may arise by operation of law from actions by the licensor which lead the licensee to believe that it has the necessary permission. If The CEO of Sun said, "No, it's cool Google, do your thing." Google could very well have an implied license that would allow them to continue using the Java API's. This would have to be decided by the courts of course, but it does make his testimony valuable. It would also explain why Oracle is trying so hard to discredit him. Of course, have something written down is better, but it is by no means necessary.
You know, I'm not one of those guys who responds to all criticisms of some widespread problem with "if you don't have a solution shut the hell up." I'm making an exception for this one article; I really don't like the tone of it: &gt; If I may be so brash, it is my opinion that the `char` type in Java is broken and should be avoided. It’s not suitable for modern needs, makes debugging a nightmare and **should be retired**. No, dude, you don't get to adopt that tone unless you show us a decent proposal on how to retire the `char` type. And not just a theoretical one of how to design a system from scratch that lacks this problem (copying Rust might be a good start there), but a practical proposal on how to migrate to the new world. This is because strings and characters are one of the things that Java really excelled at from day one, and is still really good at. As the article hints at and insufficiently acknowledges, Java's `char` and `String` design was near-optimal given the time when it was designed. You really can't fault the designers for not following Unicode 2.0+ when **only Unicode 1.0 existed at the time**. But on the other hand there's plenty of forward thinking to credit them with: 1. Making a very clear distinction between byte-oriented and text-oriented I/O (`InputStream`/`OutputStream` vs. `Reader`/`Writer`), a distinction that many languages *still* have all jumbled up; 2. Providing an easy-to-use mechanism for granular control of the character encoding of text; 3. Standardizing on an internal representation of strings that is able to represent a large number of distinct scripts within the same string. These features mean that in Java, from day one, it has been fairly straightforward to, say: 1. Read a Greek-language text file encoded in ISO-8859-7 into a `String`; 2. Read a Japanese-language text file encoded in JIS into another `String`; 3. Concatenate the two `String`s in the ordinary manner, and **it just works**. Not many systems could claim this in the mid 1990s!
Well, android had no license at all, that's a risk they knowingly took. The avoided licensing and copied the API's without a license. The code was offered under licenses, and google would have had no problems if they initially stuck to the terms of the available licenses. They made Android under a different license, Apache. The closest valid license that Android had was the GPL (which they weren't using at the time). You can't take GPL code and just make it Apache. You also can't use the Java License and not maintain compatibility with the TCK. Giving them a 3rd license would have been a option to protect them, but neither sun nor oracle wanted to grant an alternative license. They wanted google to respect the TCK.
That's kind of irrelevant to the point. If this was what he believed as CEO then his actions are logical. Implying that his lack of action contradicts his testimony is what I take issue with.
**BECAUSE IT'S GOOGLE IT'S OK**
But that is not what was reported at least on the sites I read. Internally they may have decided to not pursue Google, but they didn't appear to communicate this publicly.
One way would be to have a standard Java specification (such as Java ME) designed for mobile devices which at the base would also work on desktop systems (desktop systems would require a JAR).
Happy cake day!
That only acknowledged the existence of the Android phone. It didn't make any references to any licensing. That post could have easily been made with the expectation of a license agreement.
&gt;To encourage Java's acceptance, Schmidt said, Sun released it under terms that would make it easier for other software developers to use it. Sun required developers to negotiate for a license if they wanted to use the Java trademark and be certified as compatible, he added. But Schmidt said it was always clear that developers could use the Java language to create their own programs -- which he said Google did -- as long as they did not copy Sun's proprietary programs. [Source](http://www.mercurynews.com/ci_20468671/oracle-google-patent-trial-eric-schmidt-infringement) Really though, this is for the courts to decide. Maybe they'll be done in my lifetime, maybe not. The SCO v IBM case is still going after 13 years and I don't think this one will be resolved any faster.
Is Oracle not able to make that same argument against Google in this case though? Or is Dalvik actually a fully conforming implementation?
It's good to get a taste of what it's like to write Java without any IDE assistance, and get some experience using javac. Anything more than this I wouldn't recommend. Your IDE will alert you of compile time errors, auto-generate boilerplate code, greatly help with refactoring, debugging.. You're at a disadvantage not learning to take full advantage of an IDE and it's tools.
said literally no one in here
We're dealing with Oracle here.
Oracle doesn't care about the public. Bundling the ask toolbar into the jdk is just one piece of evidence. They sell large enterprisy stuff on the golf course.
Context matters. &gt; "But Schmidt said it was always clear that developers could use the Java language to create their own programs" The argument being made in court isn't Google's ability to make a program using the Java language, but Google's ability to make an implementation of the actual Java language. Historically Sun placed restrictions on JVMs being used on specialized devices like TVs, Phones, DVD players, etc. 
Yahoo, the internet company of yesteryear. At least it is not Ask.
I second this, it will speed up the learning process exponentially 
There are some things the popular IDEs cannot do, such as having programmatically determined freeform project layouts. EDIT: I am not saying to not use IDEs and build systems such ant/maven, just that they are not the answer 100% of the time depending on the project. You should spend the time to think hard about whether such things are actually wrong for your intended goals, if you have bad reasons or cannot think of any then use the tools. 
A compiler is just a type of program .... You actually made me face-palm.
I work in a TDD shop. We all use Intellij. I've used Netbeans/Eclipse previously but have no desire to go back. Not sure how you are going to see compiler errors, test runners, console output, multi line refactoring without using a legit IDE.
For a project such as mine (a JVM intended to run on as many systems as possible while being purely Java), flexibility and simplicity is required otherwise the project would be far more difficult to maintain. My project currently consists of 51 modules totalling around 20,000 lines of code. Each modules is a library which simply depends on other modules. These modules are given a name and may depend on other modules. All of the required module information is stored within the standard JAR manifest, which means it is included in the JAR for the code that is running to know which JARs to use when performing its work. One major requirement I have set is that the system should be self hosting, the code that runs should be able to host and build itself without the need for a development system (if only compiled JARs are available). This forces the build system to be as simple as possible (use the least amount of memory, space, and time), because IDEs, Ant, Maven, and the rest are far too bloated for it to be viable on an extremely wide range of systems which have extreme power ranges. Not being self hosting would defeat the purpose of the project. Using XML is also comparable to pepper spraying your eyes. Source code and resources can be together, there is really no need to separate them into directories at all. Also, imagine if you were writing a Java program and you only had about 16KiB of RAM and perhaps 256KiB of ROM to work with. 
Yeah, I for one love the surprise and excitement of trying to understand how the next project I open hangs together!
while (true) new Lol();
Oracle is a litigation company. They'll probably only drop the case if their chance of winning reaches all the way to zero. 
I actually still agree with Oracle's stance because we're talking about an attempt by Google to Embrace-Extend-Extinguish the Java API. I assume most programmers agree that someone who claims to support an API should implement all of it and according to the rules of the standard (or reference implementation). Otherwise, you might as well say that Windows is implements POSIX because the CRT has quite a few POSIX functions. In fact, if Microsoft was involved in this trial people would be crying out anti-trust and "look at what they did in the past". But, you know, [don't be evil](https://en.wikipedia.org/wiki/Don%27t_be_evil).
They really need to change this asap, their reputation can't be clean if they do stuff like that, also please update your websites, they all look old and heavy
&gt; he says that it is better to go with a text editor and command line rather than a full IDE like Intellij or eclipse. Probably, he's not real Java-developer :)
Imho the article mixes up terminlogy - *Unit* test vs *JUnit*, which are totally different things. First is a concept, second a technology for enabling tests. The question arises, why he *limits* this advice to JUnit? There are other testing frameworks, that differ in no way concerning the overall advice. It would be far better, if the author would use common categories of (automated) software tests (which he later does within a graphical showcase): * Unit tests * Integration tests * System tests I would stick with Roy Ohserove's definition of unit tests from his [excellent book](http://artofunittesting.com/), that a unit test runs **quickly**, is **trustworthy** and **consistent** in its results as long as production code has not changed. Therefor everything that involves more than just the code (file system, web service, database and so on), is **not** a unit test. So just separate the test by category (best in different deployable packages) from the day you start writing them and there is no need to worry.
Go to control panel java advanced tab, scroll to the bottom. Click "Suppress sponsor offers when installing or updating java" ...to get rid of those messages.
except SUN is now dead and something much much more worse took its place.
Holy shit, is that real? I didn't think java would stoop to the level of malware/spamware 
I like to include simple build instructions and potentially instructions on how to reconfigure it if required.
Mr. Gosling is *tremendously* kind with these comments. Oracle's almost-singular focus on current-quarter profits is reflected in the way they treat their partners and user community. They're stewards in much the same way that a pimp is.
face-palm? really? Are you suggesting that Dalvik was written in Java?
Hello To answer all your points 1)There are a lot of different terminologies that cover unit tests. There are many one that are "correct". 2)I know that there are other testing frameworks. In fact I have even written a [book on Spock](https://www.manning.com/books/java-testing-with-spock) However, this was an introductory post and I assume that most readers are familiar with JUnit. 3)That distinction is already in the article as you say yourself 4)Why Roy Ohserove? What is so special about him? Why not Martin Fowler, or Gerard Meszaros or Kent Beck or &lt;insert your favourite person here&gt; ??? 5)Yes I agree with you. But sometimes you go to a company that has legacy code and you need to split the existing unit tests. Not everybody is lucky to start all new projects from scratch. Thank you for your feedback! 
&gt; They sell large enterprisy stuff on the golf course. Enterprise software sales, AKA scotch of the month club. 
&gt;They stopped bundling it for quite awhile now Now they bundle a yahoo toolbar. &gt;However, Oracle when it comes to Sun has just mostly kept the most profitable bits, which would be Java and SPARC. Not so much, the OpenOffice and Hudson teams just left because of onerous management.
&gt; you might as well say that Windows is implements POSIX So way off topic, but do they implement POSIX now? I am honestly asking this question because I have been trying to figure it out since they announced running Ubuntu userland stuff. Seems to me like they must have a rather complete POSIX implementation to do this.
What about location? Where is the company situated?
We are in Bethesda Maryland. Right outside of Washington DC. 
Adding to what everyone else has already said, spending a few days learning how to compile and execute hello-world from the command line is great. Use the IDE to do everything else, up to the point of deployment. Then use your command line knowledge to help script and streamline the build and deployment. They're complimentary techniques.
**EVERYONE'S SAYING IT BUT NOT WITH THOSE EXACT WORDS!**
Sadly, you're not the average developer; if you were, this wouldn't be as bad, but, it would still be far from ideal. Ultimately, it falls down to making a good choice for your needs. I see less and less reason to avoid maven, gradle, CMake etc, as 90% of people picking up the project are like to have the tool installed.
No, I'm pretty sure it was written in C++ (but I'm not going to bother looking that up). I'm providing quotes and I'm keeping them short for readability, but if you want to parse them, you should really look at the full article, otherwise you just end up looking foolish. The face-palm was because you were wrong on several levels that are only apparent if you bother to even look at the sources for the context. &gt;"You could use Java under a license or you could make your own version and not call it Java," he said. Which is to say you can make a JVM if you want, but if you want to actually call it Java, you need a license. Are you done wasting my time yet?
Does the JDK download ever include these "offers"?
Java is pretty much the only language which has several high-quality IDEs available. Maven is—despite its many faults—pretty much the single best build tool. Unless you feel like punishing yourself, use an IDE for Java.
Other than multi line refactoring, each of your examples are very simple on the command line. I'm not saying the command line is better, just that your examples were not the best to demonstrate that.
Both vim and Emacs can do completion of function names, but nowhere nearly as well as a dedicated IDE can.
Speed and plugins could be better. But I actually like the verbosity. Compare it to sbt, where you're reduced to playing "guess-the-sigil" way too often. The only tool that I liked better than Maven was Dart's pub. Shame that nobody is using Dart on the server.
Compare gradle's Dependencies section to maven. Wouldn't you prefer a single line per dependency? Hell, even using attributes instead of element bodies would reduce the verbosity considerably.
"Is Oracle gonna have to choke a bitch?"
https://youtu.be/K__bKr5mGXY?t=26m1s
so what?
It's the facebook generation, they have to announce things to strangers.
Agree, I really wish someone would create a simple authentication and authorization library for Java. Shiro and Spring security are honestly overkill for a lot of projects. If you look at the ruby on rails ecosystem, there are so many nice minimal libraries to handle it. 
Shoot for the A before the P. You don't need either but the learning challenge is useful. I studied for weeks. Sample test questions are available online, they are where the true value is and will give you an idea of what you are up against. What makes it hard is its full of gotchas of the edge conditions of JVM behavior and collections minutiae and such. What makes this leaning challenge valuable as you become much better prepared for the kind of questions you get in interviews.
Thanks. I am hoping to use the training in my work.
my company is moving away from oracle because they only care about money and are way too greedy. You don't get much help from them on issues
You could always write a game to figure out how things would work, it may be both eductional and fun.
Yes, I've done that a few times over the years, it is fun and a great way to learn a new thing.
True, but I think Gosling kind of embellishes a bit with the history of Sun. Example: &gt; At the end of days for Sun, our software business was really successful. It was really quite amazing how well we were doing. Except that it wasn't. Sun was doing well in the 90s, but they never really had a strategic plan after that. Were they a hardware or software company? Why did they focus on Solaris when Linux was becoming the clear leader? This wasn't exactly a surprise as people had pointed this out back in 2003. http://www.bearcave.com/misl/misl_tech/demise_of_sun.html https://slashdot.org/story/03/10/17/0419246/sun-posts-increasing-loss &gt; They have their app server, and everything is about making their app server as successful as possible. One (inaudible) spent on helping other app servers doesn't make any sense to them. Again, the reason why we ended up with tons of app servers was because everyone hated the complexity of J2EE. That's where struts and spring came about.
If I am looking at candidates, I am MUCH more impressed by someone that has some personal project checked into github that I can look at and they can discuss rather than a cert. I have hired several people with certs who turned out to be disasters. I don't even take certifications into account any more. ps: I have SCJP certification
Where do you move to? .net core? Kotlin? or you just move out the database (to postgre?) ?? or the app server from EE to Boot?
Generally I'd look for how this is adding value. If you get a tangible benefit from converting to groovy, it might be worth it. But if all you are getting out of this is that you have now the same file in groovy, then you're just wasting resources. Having worked with Java and groovy I'd say that groovy is nice, but rewriting existing Java code to groovy just for the sake of it is just silly. Aside from that groovy is quite neat.
Thanks.
Thanks.
Google saved it, now we have plenty of time to drink coffee between Android builds.
Thanks.
It wouldn't make sense in scala either. 
There is jwatch. https://github.com/royrusso/jwatch. Disclaimer, I have not tried it out.
&gt;he preferred the EqualsAndHashCode annotation to manually overriding the equals() and hashCode() methods. You can just use the EqualsAndHashCode annotation in Lombok. No need to convert just for things like that.
If he's just doing this for `EqualsAndHashCode`, that's just asinine. There are better solutions in Java. Like project Lombok or the Immutables library (both annotation-driven as well). I have no idea what the good arguments are for converting Java to Groovy, but at this point I think a stronger argument is "if it ain't broke don't fix it". He's just introducing a new language for the sake of introducing a new language. It should be on him to defend his changes by explaining in excruciating detail exactly what's so much better about Groovy and why those benefits outweigh the (very high) cost of rewriting all that code (don't forget to factor in learning curves and maintenance cost for everyone who has to maintain this after him - never ever assume that he'll always be around to fix things). The onus is on him, not you. 
We are actually moving the other way. After using groovy for years we all realized it was just getting in the way making refactoring harder and slowing down the code-&gt;test cycles by pushing basic error checking in some cases to the test phase. We also hit a few very annoying and hard-to find-the-cause-for groovy compiler bugs that consumed hours occasionally. We're more than 10 people with varying degrees of experience and we're very happy with the change.
Thank you.
Thanks.
That's my twitter password. 
&gt; I recently started learning Java and I was talking to a friend and he says that it is better to go with a text editor and command line rather than a full IDE like Intellij or eclipse. Is it faster/better? For _learning_ Java, I'm inclined to agree with him. The functionality provided by an IDE will just be a distraction at this point, and having a good understanding of how to compile, package and run Java programs with the command-line tools will be useful later when working with build systems and management. Once your java programs starts exceeding about 1 - 2000 lines of code, it's time to switch to an IDE.
Wait he does wat? Just renames them!? How does that make any sense? I thought he was porting them.
If it were me, trying to convert my Java code to Groovy, I'd think about putting the duplicated code in src/main/groovy and leave the Java code in src/main/java. It would require you to add a "groovy" package name into your object's packages (to allow for the same object names), but in the end this would also allow you to do side by side comparisons of both for performance and maintainability. It would also allow you to continue using pieces of Groovy and/or Java as you saw fit and make transitioning to an all Groovy or all Java solution a little easier. Then again, maintaining two code bases might turn into a nightmare. Just a thought.
&gt; new challenge I think this misses the point. In terms of personal development, sure, knock yourself out, but in terms of business value "new challenges" are a negative.
Which is why all the discussion here is pretty much moot... If they already had groovy set up on the project, this conversion probably took the same amount of time it took OP to post this to reddit...
We do the same. We have the traditional DTOs (data transfer objects) that get sent back and forth between the client and the server, and BOs (business objects) that are JPA-annotated and used for persistence. These simple classes, which usually are little more than data holders, could sometimes be hundreds of lines of constructor/get/set/hashCode/equals/toString boilerplate. We migrated all of these to Groovy, where get/set is free and hashCode/equals/toString are an annotation away -- saved us thousands of lines of mind-numbing code.
I don't see the benefit of groovy now that Kotlin is around, but maybe that's because I'm unfamiliar with groovy.
Hopefully they will fix the Retina Mac Screen lagging issue that makes Eclipse unusable ! https://bugs.eclipse.org/bugs/show_bug.cgi?id=366471 it is absurd to not be able to fix a bug in 6 years. Thats why everyone should use Swing or JavaFX and not SWT that is supported by one woman (for mac port) who was at parental leave. This is absurd and companies relaying on that... 
Well it's still true for him to a certain extent, to be fair. It's just that the benefits in his case are presumably hugely outweighed by a whole mess of other negatives. Such as, you know, the "new challenges" his choices present to everyone else who joins the team ;)
I can't think of any practical use cases to put underscores in numbers. How does it make your code more readible? Also, why would a phone number be stored as a long? You aren't doing any arithmetic or comparison with it, so why not just store it as a string? It also poses an issue if the phone number starts with a 0. It would get truncated if you're trying to print it out. 
I highly recommend [QuartzDesk](https://www.quartzdesk.com/). It isn't free but it is pretty cheap. We deployed it at my last job to manage our 100+ quartz jobs. It turned out to be easy to use for both the developers as well as the business users. It has functionality to send alerts through email, instant messages and more. 
34,816 MiB, although if you meant MB it would be 36,507MB. 
Ah fuck, you're right I mixed them up. That's what you get for trying to be sneaky. I meant to use the powers of 10 – which you're right should be "MB". [MiB is for powers of two](https://en.wikipedia.org/wiki/Mebibyte). I just always use "MB" for powers of two, because I'm an old fart :)
[removed]
I always hear people saying, "Scala is better. Groovy shouldn't exist." Yet I know of literally no one that actually uses Scala. By contrast, I know many, many developers that are using Groovy.
The asshole in me wants to suggest you create a `src/main/kotlin` directory.... Lots of good answers to your question. But how are you planning to address this conflict with your colleague? If you beat him over the head with anti-Groovy arguments he's likely to dig in his heels. My guess is he likes the syntax and expressiveness of Groovy and thinks that Groovy's "powerful features" make him more productive. But the costs of development extend far beyond the simple question of how long it takes to code a bit of logic *today*. Refactoring is much more effort with a dynamically typed language. And statically typed languages do work for us that dynamically typed languages require that we do in order to achieve the same level of quality in the code. The time you save today by being able to more quickly write a bit of code ends up costing you more time later in debugging and refactoring work. Your colleague most likely isn't considering this cost equation. I suggest you point out these considerations and see how he responds. And when he spends an hour fixing a bug that could have been prevented by sticking with Java (or Java+Lombok, or Kotlin) ask him how much time he's really saving. And hey, as a last resort, you can create a `src/main/kotlin` directory and start converting his Groovy to Kotlin. :-) 
You say there were no inaccuracies for me to address, but that his testimony has value, in contradiction to what you initially said. I think that's another face-palm ....
Your question is mostly nonsense, there's nothing special about `src/main` and if you're not interested in developing with Groovy, you should make the case to your coworkers against it, or find a new job.
Groovy's main benefit is turning Java into a highly extensible dynamically typed scripting language. That said, I would only use dynamic languages for things that don't go into production, where a runtime error is not going to ruin your day.
There are also the floppy MBs which are both combined!
you where wriying get/set manually? why D:
&gt; Java does not execute like a scripting language sooooonnnn https://blogs.oracle.com/java/entry/jshell_and_relp_in_java mmmyess 
Cool, thanks for info. Wasn't aware of this being on the roadmap.
Scala can fight Java tools (actually, they're mostly the same).
Java has a free get/set. It's called "public". Fine for a simple data holder.
i can understand legacy stuff, but do people still use jsf in greenfield development?
Groovy is slower than Java. I don't know for sure, but just converting to Groovy should just add slowness. The Gradle guys actually try to reduce their Groovy code base and replace it with Java because of its slowness. edit: Just FYI there is static compile mode for Groovy (disabled by default) otherwise it uses dynamic dispatch. Dynamic dispatch will always have an impact on performance. Without dynamic dispatch some cool features of Groovy are no working.
Solution: Put him on a performance critical piece of code. Don't tell him to convert it to Groovy. Just wait for him to hang himself by rewriting it to Groovy and then show him how stupid that decision was without understanding the implications of blindly converting Java -&gt; Groovy on the product (performance) and the business (wasted time, money etc.) If you really dislike this coworker you can take it one step further and let him ship it... then sell him out to management when shit hits the fan because of his rewrite. But... that's kind of a fucked up thing to do.
I'm kinda torn on this. Java is still really verbose compared to Groovy and in the scripting scenario I'll take conciseness over verbosity; especially when hacking on a REPL.
IMHO it comes down to using dynamic languages when you want to be quick and lazy, and static languages when you want to be strict and careful. 
Sort of agree. I tend to just think of using dynamic languages when you want to be lazy for no good reason. Both Kotlin and Scala are as expressive as Groovy and useful hacking something up.
&gt;Sorry. Schwartz's opinion became worthless once Sun was sold to Oracle. &gt; I wil agree that his testimony offers background that may influence the penalty phase if the case goes in Oracle's favor. Please square that circle.
Stop yelling.
Because it isn't a fork.
All decent IDE will generate getter and setter for you. Just select which private fields you want them for. Same with constructors and equals/hashCode/toString
Hmm interesting. This is what my Compilers professor had to say when we were learning about Type Systems. "Really strong guarantee that a type system is giving you. Which is why I think people use type systems all the time. I think they’re the most important form of program verification we have. They don’t prove very strong properties. Don’t prove you always index array within valid bounds of array. But proves the absence of a lot of errors."
&gt; These simple classes, which usually are little more than data holders You don't need to mindlessly follow OO orthodoxy when it makes zero sense. If you find yourself writing hundreds of lines of getters and setters with nothing in them besides the mutation and retrieval of a private field, it should have been public unless the class is part of a public API. DTOs aren't. 
I've never quite understood this obsession of using (visual) DSLs for testing. Can someone explain to me why they're good for testing while (almost) no one uses anything similar for non-test code (Xtext and MPS aren't exactly mainstream tools)?
According to wikipedia, the OCP is summarized as "software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification". It doesn't say "SOME software entities" should be open for extension. The Strictness Principle seems to say that "by default" classes should not be open for extension. The conflict seems obvious to me. Plus I think it's difficult to know, when you create a new class, whether or not it will be extended by someone else. The conflict is limited if you own the code (you can always change a final class to non-final to extend it), but in a 3rd-party library a final class is definitively closed for extension.
I'll make that argument. One test per method is fine for unit tests, but once you start getting into more complicated scenario / use case style tests that doesn't cut it. For example, if I'm testing the state machine for a class that implements revertible change tracking, I need to pass through several states before I actually test Revert(). So reading a narrative of each state and its associated tests in one long method makes sense to me.
The strictness principle doesn't say that by default classes should not be open for extension. It says that by default one should restrict the scope, but increase the scope as the **need** arises. The **need** can be the act of opening some attributes of a class for extension. For example, somebody can open a class for extension by exposing some of its members, those would be the only necessary for that extension (exposing a behavior instead of attributes, for example). The other members don't need to be exposed, because there is no reason to do so. They can remain as strict as possible. *Classes don't need to expose all of its members to be extensible, it all depends.* Let's say we are developing a `Person` class. it should be designed initially with everything private, and along the development one can make decisions of what is necessary to make the class open for extension (all this decision can happen even before the first commit), and that does not mean making all of its members with low strictness (exposing a method, but restricting the internal attributes; making a class possible to be subclassed, but restricting the visibility as default, etc.). The same way OCP doesn't say that "**some** software entities" should open for extension, it also doesn't say "**all** software entities" should be open for extension. A per use case scenario should be considered. Bottom line is: If the author design the entity for extension, which is recommended, then the author probably have to think about it **before** violate the strictness. In doubt, don't do it and keep it private. &gt; I think it's difficult to know, when you create a new class, whether or not it will be extended by someone else. This is a problem inherent for using classes. If one uses prototypal inheritance and composition over inheritance, then most of the problems can be nulified.
Data vs logic? 
Why not write/read a narrative for the state machine itself? Why write it in plain Java (or other "ordinary" language)?
I have added the following paragraph in the article that probably clarifies this a little bit, since it is not the first person who gives such feedback, thanks! &gt; One could argue that classes should be open for extension, but closed for modification, so it might not make sense creating everything with a reduced scope by default in Java. If one wants to make the class extensible though, then it might be reasonable to increase the strictness a little bit. However, this is a smell that encourages the author to consider using other forms of class extension instead of inheritance (like composition or prototypal inheritance using the prototype pattern).
Testing is about as perfect an example of where a DSL can be useful as you can get. Spock makes writing tests easy and pleasurable. I've used it for over 2 years now and both I and my colleagues now write almost exclusively Spock tests (on our own will, of course). If you don't see how that may be, you should absolutely give it a try without your prejudices biasing you from the start.
I'm glad for you that you've found a tool that makes you productive. But, consider me to be someone with academic interest in the topic. I'd like such an explanation without me having to try it out myself.
I know, however SQL does not exist for me, there are much better database query languages that do not have the habit of exploding.
Here's some hobby code I've tested with Spock: https://github.com/karlthepagan/MagicForest/blob/master/src/test/groovy/unisoft/MagicForestTest.groovy Here's a test that would lose 70% of its lines when converted to Spock. The data table would also look nearly exactly like the specification found in the Percival SCrypt paper. https://github.com/karlthepagan/scrypt/blob/master/src/test/java/com/lambdaworks/crypto/test/SCryptTest.java Here's one that's not as bad... But it has a specification method which I had to write to achieve similar readability and save LoC: https://github.com/karlthepagan/forge-antispam/blob/master/src/test/java/karl/codes/minecraft/antispam/AntiSpamTest.java
I love Spock, but it has a few issues that make me think it's not quite mature, even though I've used it professionally; Refactoring with Spock is a nightmare; the Intellij integration isn't quite there yet. There are quirks with defining mocks for verification if you also want to test output (though some would say if you're trying to do both, you're doing something wrong) Auto complete is missing. Mocking objects without auto complete is miserable. I can't tell you how many times my test wouldn't work because I had the wrong capitalization in a mock method or was missing an underscore or something else non-standard. Other than that, I love it, and I'll probably switch to it for personal projects too. Edit: I'll add that the given/when/then/expect structure is a godsend if I'm not quite sure what I'm testing yet. JUnit is fine when I know where I'm going and just need the design oversight, but if I don't even know where I'm going I want given/when/then to help keep me focused and targeted
The best argument for Spock is that your team members will write more tests and all their tests will have assertions. Spock puts assertions first, not running code. It's obvious when your given table has a single entry.
I have not experienced any of the issues you have with refactorining in intellij. In fact I find it very good. Do you have Spock Framework Enhancments plugin installed? I don't know If it is responsible for autocompletion but for me autocompletion for mocks works just fine. There is also a set of awesome live templates. Checkout the video I recorded: [https://www.youtube.com/watch?v=t-X_xCoTYWA](https://www.youtube.com/watch?v=t-X_xCoTYWA) I am curious why would you need mock output (partial mock?). I always thought the purpose of mock is to return no (or default) value, right? Trying to get value from mock seems like an antipattern
There isn't really a conflict, though, since OCP applies to system behaviour, not classes, and there are options for system extension which do not involve inheritance from concrete types.
Nice! I heard some bad things about TestNG so I did not even bother to take a look at it (there are so many frameworks, you can't focus on all of them). It's kind of funny that you mention spock might scare junior devs since I am junior trying to convince other team members to think about picking up spock.
Well, my boss had to struggle with me to convince me to use TestNG, and here I am, making free promotion. I think you are right, you'll have more trouble convincing old Java devs to use Spock. That's the problem with fellows like me: we don't trust dynamic languages, we don't trust our skill to write code without a "compile and verify as you type" IDE, we don't like DSL's because you don't know where's the little grammar issue that will bite you... being old sucks, believe me.
I was wondering about this too. With `List.of` as an example, how often does the problem described in that Guava issue apply here in practice? From what I'm reading, the problem only applies when a specific call site receives more than one implementation at runtime. For example when someone calling `List.of` might get `List0`, `List1`, `List2`, or `ListN` depending on the arguments, then they get worse performance. But that only seems possible if they do this: Foo[] array = ... // The size of this array varies List&lt;Foo&gt; list = List.of(array); How common is that, really? I'd think `List.of(anything but an array)` would be much, much more common. I'm probably misunderstanding the original issue, since the reporter used `ImmutableList.of` as the example, which seems to be in the same boat as `List.of`.
Java is not a good language for coding without an IDE because the package structure tends to be so unpredictable with Java and it can be extremely tedious unless you have all of the packages memorized. Additionally, IDEs can make writing test cases or debugging easier. Seriously, when using a good IDE (Intellij) you'll find yourself significantly more productive than using VIM. That having been said, when doing code that is more like scripting, such as in PHP, JS, or Python, you may find that VIM or Sublime is all you really need. However, as soon as you start using a debugger, you'll be more productive with an IDE. 
How do you do line-by-line debugging over the command line? I've found that to be immensely valuable. I can step through an application and see what the variables are set to at each statement. It makes it very easy to identify bugs and things. 
By using the jdb command. There are various commands for stepping through an application and moving up and down the thread stack. It's not as quick or as easy as using an IDE, but it's very possible. (IDEs either execute jdb and feed it commands, or they execute the underlying classes, assuming that jdb is written in Java) I've never actually used jdb, but I have used gdb for debugging C and C++ applications. 
Bare minimum src/{main,test}/groovy src/{main,test}/java http://projectlombok.org/ takes care of @Data, @Getter, @Setter, @GetSet annotations Things I don't like about Groovy: * Strict typing better than dynamic typing, BY FAR! * Grails sucks compared to spring boot * Elivis operator encourages Null-programming 
He is using ChoiceFormat. The issue is not the availability of rules or formats. The difficulty stated in the article is that implementing rules across languages is hard, especially if languages with additional rules are added later.
I think it will be a viable alternative to the traditional environment, not a replacement. Have you seen Eclipse Che? https://eclipse.org/che/
That public github track record has just become the certification of "modern times", right?
This looks interesting, going to try this out
Luckily final classes and final methods are not that common in Java. I definitely go by the principle of revealing as little as possible when developing classes and private is very good for that. There are also lots of good libraries that provide tools to do immutable classes. On the other hand final has the issues I already mentioned. Can you outline scenarios where final classes or methods would be useful and refute my counter examples? So far I haven't seen any concrete evidence to change my mind.
I don't insist that people follow OCP or any other principle religiously, but it's useful to know when one's principles are in contradiction. There are certain cases where it's better to prevent extension of a class, especially for security reasons. The (religious-sounding) thing you said that I do not agree with is "one should always use the final modifier by default in all declarations". That's probably good if you think a lot about dependency inversion and composability every time you create a class, but it seems like a pain if you're doing TDD and plan to refactor your code as the design emerges. When I come across legacy code created in neither of the 2 preceding cases (i.e. code created without tests and without a well thought-through design), I like to be able to add some tests with mocks without changing production code. Final classes are a barrier to this approach. Your new paragraph is an improvement, and you are right that inheritance is not always the best way to extend a class. I think Jon Skeet makes some good points in the StackOverflow answer you linked to and his associated blog article. 
The VPS over at digital ocean comes with subpar hardware to relatively high prices and no DDoS protection. I would suggest you look over VPS options at OVH.ie, (use their search). They provide their first option for $3.50 and it's already better than the cheapest at OVH. 
You're right, I'm sorry if that came across this way. I didn't mean to imply *you* insisted, but many people do. &gt; When I come across legacy code created in neither of the 2 preceding cases (i.e. code created without tests and without a well thought-through design) In that case, *none* of the rules apply, and we're in the wild west :) &gt; I think Jon Skeet makes some good points in the StackOverflow answer you linked to and his associated blog article. Hmm, did I? Where?
Why is that an important rule to follow for Java classes but not Groovy?
I agree with you. However, even in C++ there is this debate and Visual Studio is an excellent IDE (considered the best one by some people) I strongly recommend to use an IDE.
http://htmlunit.sourceforge.net/
Why not http://tapestry.apache.org/?
I think you misunderstood what I meant. I'm not saying C/C++ developers don't use IDEs. I'm saying those people who dislike IDEs tend to come from an old school C/C++ background and love make, gcc and vim or emacs (but never both).
In groovy, the getters/setters get automatically generated for you, but they are still there.
I've used digital ocean to install Unix but I've only used the command line. Can you actually run Ubuntu for example on it? I need to install Eclipse on it. 
I was reading up on it last night. Looks very promising. 
&gt; Usually you can contain everything you need in identifier names and when you really need to write some comments, it is a red flag. I suggest avoiding this option unless you really want to stick to the original convention. It feels like the author is against comments/JavaDoc and is in the "comments are the code" group. This is fine for small projects, but once your project gets big enough having a basic overview of what things do can be nice. Modern IDEs can collapse and hide comments so you never see them at all. Also all of your methods and classes should be documented even if they are private, if your project gets popular and you are working on it 10 years down the line after a long cruise vacation with no computers in sight, you will be glad you did because you can just read the comments that describe the stuff rather than digging through the code to understand them again. &gt; Something the code is too complicated, method has too many responsibilities, a hacky solution etc. Then it is refactor time, if you never refactor then your code will be a mess and no matter how long and descriptive your variables, classes, and parameters are it will still be one gigantic mess. EDIT: Grammar 
Yep thats what I do, caps convention makes it easy to recognise the generic but the naming is more inline with clean code principles.
I've always preferred the c# style of naming, i.e. TKey, TValue, etc.
Ok, I will try to argue about those points. Reasons why someone else might override your class or method: # testing There are situations where to be able to unit test an object (and that's what I assuming that "test" is about in this context) you don't need to expose more than necessary in an object. It is hard to make this point using an example, but the principle is that you should avoid changing your class to behave in a way that the only concern is about making it testable. Ideally one should focus in exposing only what is the concern of the class, and that, by side effect will make it unit testable. # mocking It depends how you mock. You can mock a dependency by injecting the value through reflection without having to mess with the actual type/contract of the class, or one can design the class in a way that it is possible just to pass a pre-crafted object as the argument of a method instead of having to inject using arbitrary injection mechanism. If one need to mock something that is an internal concern, that might be an indicative that the class could be better designed. `.punch(Fighter b)` could definitely receive a custom Fighter built only for testing purposes. The other attributes, such as skillset are private because they are not being used anywhere. But if it makes sense that a fighter learn skills, then the test could be teaching the fighter to learn and test the punch given a specific set of pre-determined skills. There is no need to inject internal mocks if there is no need to. If one is worried in subclassing, there is always the option to use composition or creating an interface that can be mocked on. # patching a bug We are talking about hacks here anyway, so nothing stops someone from using reflection or creating business adapters that use composition on top of existing APIs. The adapter can change the interface and also fix the bug, or one can use reflection or other sort of hacky technique to fix the problem. # doing something the original author hasn't thought of If the original author didn't though of, then one shouldn't be trying to use it in the first place. The author knows better what one can use from it's classes, and if someone wants to suggest a new API to be exposed, one should open up a discussion to be able to weight the pros and cons. If the author is incompetent and blocks stuff that should not, then the problem is not the principle, but the incompetency of the author. &gt; Luckily final classes and final methods are not that common in Java. I agree people usually don't do that much, even in companies. My theory is that people don't care about the tradeoff between typing 6 characters and having to think about the scope in which a class can be changed. I would always encourage thinking about it though, otherwise one might be stuck in the future by not having the option to change the visibility of a class just because of the likelihood of it being used by someone.
It's not that I think that comments are bad as such. It is not so black or white that comments are either good or bad. My point and opinion about comments was: - Need to write complicated comments may indicate that the code needs refactoring - Choosing descriptive names reduces the information needed to be contained in the comments and comments should not contain information which is obvious from the code (eg. you would not have javadoc for getters and setters as it is obvious what they do)
Ah, it's possible we didn't know about the correct plugin, I'll look into that. As for why you might mock the return of a method, have you ever tried getting legacy code under test? See how long before you've exhausted every anti pattern you know of lol Edit: just re read you post, that's not a partial mock. A partial mock is when you mock the object under test. That's bad. You only mock collaborating objects. If you're partial mocking or spying or making private method protected to test them, yes that's all very bad. Specifying what a collaborating object returns is kind of the point of mocking, especially in large code bases that haven't had the TLC of frequent refactoring.
Second that. What if someone forget to fix the comment after a bigger refactor. That may lead to confusion.
AWS Workspaces?
This is overkill, if you extend your Generic carefully, not just extending Serializable for instance, the compiler will tell you what type is needed when you write your calls. If you make containers which hold too broad types, then I think you may have a problem with your architecture. If you're implementing a new data structure otoh, following the convention is probably preferable.
&gt; I think that's the crux. You're saying authors know better. But, in real life developers and authors make bad judgements all the time. But at least is a mistake that can be fixed. If someone make a mistake of exposing something that shouldn't, the damage is bigger because you can't just change it to be private. If a mistake happens by being strict, then that mistake can be fixed by going public. If a mistake happens by not being loose, then that mistake cannot be fixed by going strict because it has the potential to break a bigger amount of consumers, either consumers of an external API or consumers of an internal API. &gt; I'm not critizing the "principle", instead I'm criticizing on how you've defined it to include the use of "final classes and methods" Thanks to clarify that. But even then I would still recommend using the strict mindset to limit the vectors that open the possibility for wrong API usage whenever possible, and that includes using the `final` keyword unless the original author design the class with inheritance in mind (or change later to be so).
This is true, 9B would be an easy solution. However the time and money spent on litigation is more than likely horrendous. It's also a reputation issue...Google is a company you want on your side, not against you - especially when they are using your tools and have the potential to use many more from your company as opposed to your competitors.
Ugh. Hungarian notation.
My opinion is the opposite, xml is ugly. 
&gt; Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name. I guess by that logic, it's hard to tell the difference between a method name and a variable. Or even more specifically, the difference between a local variable and a field. Why not have different conventions for those? Because your IDE easily distinguishes between the two and highlights them in different colors (just as it does for generic types). I've never stuck to this convention, it's really stupid. We don't pay by the character or anything, why would we use one-letter generic names? I've always stuck with all-caps, like `DATA`. It's way more descriptive and still readable.
No build tool? Just a build.bat?
Tbh I think that should be in a separate 'glossary', because often the business uses the terms too, and it should be clear to everyone that works in the domain. 
For information: [H2 Database](http://h2database.com/html/main.html)
After more searching I found this: https://github.com/h2database/h2database/blob/master/h2/src/tools/org/h2/build/Build.java Looks like they made their own build system, neat.
... £106??
A proven solution to this problem is to use this form: "Items remaining: {0}" instead of "There are {0} items remaining." It neatly avoids the singular/dual/plural problem and the grammatical case problem in every language of which I'm aware. Both Windows and OS X use the "items remaining: {0}" approach frequently. 
H2 is not a new product. There was no gradle when it started.
H2 rocks. It's the native Java equivalent of [SQLite](https://www.sqlite.org/).
Generally, every API is public to either end users or to the developers/maintainers themselves. If every API is documented, including private ones then ones that suddenly become public will then have been already documented. 
Maybe not text editor and command line, but maybe a beginner IDE, like bluejay would be good to learn with
Apache Beam seems to be where everybody will be headed to. Crunch is similar, so it's not wasted effort.
shop around, you can find it MUCH cheaper! 
To be fair, it also wouldn't be Thomas Müller if he didn't do something on his own :) (such as the H2 SQL parser, which is pretty neat)
My mistake, I was referring to the new paragraph by @fagnerbrack. 
I wrote [a guide](https://sekao.net/nightweb/blog/clojure-on-mac-app-store.html) a few years ago. A little bit has changed in the meantime but for the most part that link explains what I did.
Heh. Good thing I added all those fixed-arg overloads. :-) But actually I think the use case is iterating over a large collection of Lists of different classes, calling a method on each. I'll have to check this out further.
Scrubbing code of specific references to a copyright holder is a huge red flag. It shows intent to circumvent potential copyright issues.
That's exactly what I was thinking. I realize it's not a new product but man... refactor that. That is a maintenance nightmare.
They do have a [browser](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/web/WebView.html) but it doesn't support Java.
Again, I'm probably misunderstanding the original issue, but I don't think the fixed-arg overloads have any impact here. If the caller's code looks like this: List&lt;Object&gt; list = List.of(a, b); // later... public int getSize() { return list.size(); // the call site } then that call site is dealing exclusively with `List2` regardless of whether `List.of(a, b)` invoked a two-arg method or a varargs one. Since there is only one list implementation used at that call site, I think it would avoid the performance problems. No? One could conceive of slightly different code where `list` was equal to `List.of(userProvidedArray)`, or it was `List.of(a)`, `List.of(a,b)`, or `List.of(a,b,c)` depending on some condition that actually varies during runtime. That code should run into the performance problems, but I'm questioning how common that code is (or will be). &gt; I'll have to check this out further. +1
I wonder if this means that getting TCKs will be made easier now.
I agree, it's one of the things that drives me nuts about early Spring. If you use Eclipse though and the STS plugin then you get some compile time control over configuration errors. Having said that, I'm glad Spring Boot came along. I just wish the Enterprise would go Spark Java or Spring Boot could do the same work with less Annotations but it is still better than old Spring.
Sounds like you should file a PR. It's non-conventional, but it ain't broke.
I wouldn't file a pr before opening an issue and having some discussion about it first. 
Turbo C#
&gt;it's just that the approach it uses (along with asp.net webforms and others) seems to be - IMO - an antiquated web-hostile approach. What part or aspect of it specifically would be web-hostile then? &gt;(i'm guessing JS stuff like angular?) Yes, I indeed thought you would mean one of those. &gt;this stuff has been around for over a decade. Almost 2 decades; the original Struts is the poster child of action oriented MVC. People didn't quite like it after al, and it wasn't particularly friendly to develop for.
I've seen worked on a few old Java projects that have similar builds. Lots of devs used to copy their build system from project to project and end up with things like this.. It should be refactored, for sure. Immediately.
I hope so. I'm definitely in favour of the goals of the Beam project, but it's early days for it. I expect it will take a little while before it becomes useful, so I'm sticking with Crunch for now and trying to make my life as easy as possible while I'm doing it.
You can use both of them. The IDE for the edition, because you don't need to use a crappy editor for editing. Java is complex and has lot of libraries and packages, use the IDE. It will warn you when you do something wrong, so you can learn of it. On the other hand, use the command line for building your project (Maven, or whatever), even if you want, for executing your program. This way you will be learning from both worlds.
This, +1000
[removed]
&gt; 1. Don’t use JDBC Excellent. This is forgotten way too often.
You can also use array processing if you're on jdbc 6 or higher. 
I don't think this counts as a point for his presentation. It is particularly about speeding up jdbc inserts, by not using jdbc, we aren't really speeding up jdbc. That's like saying, here's 5 ways to improve your Java code: don't use Java. Super trolley and circlejerky if you ask me. 
except it's not just "Don't use JDBC", it's more useful, it's "Check there's no tool more suited to your specific data format". 
5 ways to improve Java: don't use Java, use scala. That still holds. You're not improving your jdbc insertion by not using jdbc. I think this blog should be titled 4 ways to improve jdbc inserts. 
Interesting, I didn't know that, good to know! I had SQL*Loader in mind, which does outperform ojdbc.
Disable indexes on the table being inserted to. A large part of insertion time is index maintenance. Also watch out on the multiple inserters thing, I've seen deadlocks in mssql due to too many inserts. It is real neat (index maintenance and lock escalation was the root cause).
&gt; I have tried multiple ways of batching with JPA/Hibernate Why would you do that? ORM stands for *Object* Relational Mapping. If you're not mapping into an object graph which implements a non-trivial domain model, why bother with an ORM in the first place? If you can easily precompute your inserts, using at most dumb DTOs, an ORM seems like a huge waste.
Many reasons. Here's one: when selecting a subset of those records from the DB, recreating the objects is extremely tedious (again, multiple one-to-many relationships). The ORM will give me my data in the objects that I want them in without me having to manually assemble the objects. 
X-Post referenced from /r/kotlin by /u/spud111 [A Lightstreamer Client In Kotlin (Real-Time Data)](https://www.reddit.com/r/Kotlin/comments/4jrk35/a_lightstreamer_client_in_kotlin_realtime_data/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
CNTLM was a godsend for me at a previous position where the NTLM firewall prevented me from updating eclipse. It is awesome.
&gt; why bother with an ORM in the first place? Because the old versions of JDBC were downright painful to use (positional parameters? WTF?) and over time whole companies forgot how to use SQL.
You sound like one of those people who keeps asking how to make his hammer insert nails fasters, then whines when everyone tells him to use a nail gun.
I do that with SQL Server some times, but setting up the table types to receive the data is annoying.
You've got way too much confidence in your ORM.
Its one thing to question why libraries are missing seemingly (to you) vital APIs, and its another to demand it, saying that a library is shit without it. You just sounded so entitled in your post, like you deserve these things, and that its shit if it doesn't have your approval.
Maven? Shiver...
&gt; Powered by a unique Build Programming Language, Gradle also boasts an ecosystem with over eight hundred plugins supporting all facets of software development and deployment Interesting how they circumvent mentioning Groovy in this press release. 
But when you need to need to retrieve the records back it will be slower w/o indexes.
Other than being Java, how does this compare to Theano/Tensorflow? 
&gt; With approximately 2 million downloads per month, Gradle is the most popular build automation system world-wide. Wuuuuuut?
You're welcome. I may post some more as I progress.
Same as with temporarily disabling the integrity checks. You re-enable it when you're done.
This is why you add the indexes back once you are done with the bulk inserts. Depending on the DB, you can even sometimes disable the index without dropping it (so the index rebuild time is reduced). Indexes have to be sorted, ordered, etc. As inserts happen, the DB is shuffling, reorganizing, and potentially triggering "GC" like behavior with the disk space (think of middle inserts in an array list, that is what any given insert can do to an index). By disabling the indexes, you are telling the DB "Don't worry about it, just throw it in somewhere". Once you rebuild the index, the DB can much more efficiently take stock on what is there and how to organize/sort it. The time it takes to do that with a bunch of records is much less than it is with individual records.
When you try to sell me a book on the best techniques to use to nail nails with a hammer, and then start with "don't use a hammer, use a nail gun", then I moan. 
Way 1: don't use JDBC
&gt; Gradle is still declarative if used in its base form, This is true. &gt;it's just easier to mix in your own scripts. This is my problem, I've had to deal with enough shitty make scripts, shell script monstrosities that I never want to do it again. With Maven, you actually have to write something and publish a plugin if you want to do anything outside of normalcy. Where normalcy is a very broad term because there are already SO MANY published plugins to do everything. &gt;I switched to Gradle a few months back and my POMs shrunk to a few lines. I use a shared parent POM and my project poms aren't very big. That honestly never bothered me with folding and such. 
The mvn/pom xml configuration is just way too verbose imo. I think maven had its place in the early 2000's but we programmers can be more efficient using more modern build tools that prioritize convention over configuration. Maybe the declarative syntax gets it closer, but I said good riddance to maven 2 years ago and havnt missed it once.
Their download numbers are huge because they have everyone use the "gradlew" wrapper that downloads gradle each build if you have a bare repo. Our CI server probably downloads gradle a few thousand times a month and we only use gradle for two projects compared to the 800+ that use maven... I'm sure we're not the only ones with that kind of a setup.
&gt;A majority of enterprises are already using Gradle to build and deliver...
Gradle normally caches both the Gradle distribution and all the dependencies, and it's very good at it. The cache is per user; it's not going to get wiped if you run a clean build, so something seems really screwy about your setup. The gradlew script is great since it means we never have to care whether or what version of Gradle is on a box - each project controls the version they need directly. We also use artifactory as a caching proxy for external dependencies, so even when it does need to download it's still hitting internal most of the time.
I don't hate JDBC for bulk inserts, but JPA/Hibernate is brutal. Maybe it's just a matter of perspective. If you're starting from JPA/Hibernate, JDBC with batches isn't that bad. Ideally, I'd have a way that uses JDBC batch and generates IDs that Hibernate won't double up on later. Probably should just create a non-overlapping sequence, but haven't focused on that yet.
What is Jeta? Best I can tell is some sort of AOP-ish annotation processor... maybe? Anyone have experience with it, and found it to be useful? Just curious.
Seems like a very strange setup to me - most builds I've seen tend to be more CPU-bound (or network-bound on dependencies, tests, and publishing artifacts) rather than disk-bound. Do you really see that much of a boost by running in ram disks?
Yes.
Theories is much cleaner than the other parameterization options I've seen. It's a trade-off of Spock's complexity and loose groovy types to get that flexibility.
mvn and gradle pretty much do the same thing with convention over configuration aspect. The pro-gradle difference is 1 line of groovy vs. 5 lines of xml per dependency/plugin. The pro-maven benefit is the richer parent/artifact/plugin capability. As a matter of taste people fall on either declarative or imperative builds. I'm usually not comfortable with things that straddle that line as it means that there is a lack of clarity. For builds I certainly prefer declarative as I work with roughly a 50% contractor team that rotates through ~18 months and that generally means there are a lot of opinions that come through that are frustrating to have to repeatedly course-correct. 
Another nice thing about Maven: tools other than Maven itself can easily make sense of its build files. That means I can open a Maven project in IDEA or NetBeans without hassles. The lesson Maven was supposed to have taught us all is that the main build file should be *purely* declarative and easy to parse. Unfortunately, almost nobody learned that lesson, and so we have Gradle and SBT repeating the same stupid mistake of Make and Ant all over again… This is especially unfortunate because Maven does have serious problems, and I see no indication that they will ever be fixed, nor that anyone will ever make a real replacement for it. I had toyed with the idea of making a replacement build system myself, but I have neither the time nor the energy for such a task, so I still use Maven.
These are excellent points. I'm also a fan of the type safety that XML provides despite the 2.2 lines of boilerplate :)
Who uses JDBC directly anyways? There have been tools to make plain SQL easy to work with in Java for quite awhile. iBatis (now MyBatis) has been around at least as long as Hibernate. Map my objects straight into handwritten SQL that I can paste into PL/SQL Developer? Yes, please! 
Extends is evil. if your class is extended in the codebase, and people have overridden your non-final methods, and at this point you decide to want to change the signature of those methods, then you cant without refactoring all the extended classes. The implementation details of your class has become exposed, and now you cant do anything about it!. Its not to say you shouldn't ever make methods and classes not-final, but the default should be final, and then if needed to, and you are happy with the implications, then by all means remove the final modifier and allow people to extend. This is far better than just letting anyone override anything and everything. 
The native NoSQL drivers usually provide abstraction levels comparable to JDBC, which means that things like object-to-store mapping, resource management, exception translation are all left to the user. That's all technical code that you don't want to write yourself, even more so not over and over again. There are basically two players in that space: Hibernate OGM trying to use JPA as the fundamental API to abstract these things and Spring Data with a unified (repository) programming model but not a single API to rule them all. Which one suits your needs best is up to you to decide. I won't go into details here, as I couldn't be more biased ;).
We found that (many of) the JPA APIs are actually not tied to relational stores. E.g. stuff like @ElementCollection maps very naturally to embedded arrays in MongoDB documents. So one use case is integrating some NoSQL store into an existing JPA application (based on RDBMS) at relatively low effort. Say you want to experiment with storing parts of your model in Neo4j in order to benefit from its graph querying capabilities. Hibernate OGM is a means to help you with that, without requiring you to learn a completely new API. We don't claim to make the chosen store transparent (in fact we also expose specific options/settings as needed), but it helps lowering the barrier for working with different stores. Another use case is OxM for Infinispan, the JBoss data grid (this was the starting point for OGM). Hibernate OGM is the go-to option here. (As you guessed, I'm biased, too, as I'm working on Hibernate OGM)
Nothing stops you from putting a fixed gradle version into your repository (or to any other cached location). That would not just increase your build speed, but also ensure a consistent build over time. I am not sure how many of the downloads of gradle can be attributed to setups as yours.
Just to list some: * http://stackoverflow.com/questions/3084629/finding-the-root-directory-of-a-multi-module-maven-reactor-project * http://stackoverflow.com/questions/11044243/limiting-a-transitive-dependency-to-runtime-scope-in-maven * http://blog.ltgt.net/maven-is-broken-by-design/ I wrote more here: https://github.com/tkruse/build-bench/blob/master/Buildsystems.md EDIT: And obviously, the lack of incremental builds makes Maven much slower than the modern competitors, for multi-module builds.
&gt; Actually no, Gradle looks declarative, but it is imperative, even in its most basic form. E.g. "apply plugin: java" is the function call apply(["plugin": "java"]). Also every time you see a word and curly brackets "foo { ... }", you invoke a function with a closure argument: "foo({Object it -&gt; ... }). That doesn't make it not declarative. It's a domain specific language in which I describe my project. I'm not telling it when to compile, I'm not telling it how to compile, I'm just telling it what I want it to compile and what my constraints are. ("This is my dist folder" vs "for file in files move file")
&gt; Disable Integrity Constraints OP must really enjoy doing DB backups and/or rollbacks then..
Me too. Names/variables with all uppercase letters are constants/finals. The T-Prefix is pretty nice ... (from Object Pascal?!)
You could write an idea generator and then use its output for the topic.
I don't know if this is a success story, but I worked at a company that developed a case management system. We leveraged Hibernate to allow our product to fit in any customer environment. We had customers using Oracle, SQL Server and Postgres. At the same time, we provided reporting capabilities which let users write native SQL queries to allow them to leverage the power of SQL and their particular database. On the other hand, not using JPA but rather Spring Data, we have switched data models from SQL (relational) to NoSQL (non-relational) stores like Gemfire and Elastic. A proper abstraction lets you keep the *code* oblivious to the particulars of the data storage mechanism, and moves the details to more of a wiring and deployment concern. Classic Dependency Inversion ;-)
&gt; If using other people's code is such a problem for you I'm not sure where you can derive that statement from anything I've said. I rely on a ton of external dependencies. I rely on several teams within my organization. What I don't want to rely on is taking something like clean/codegen/compile/test/static-analyze/code-coverage/integrate-test/deploy and turn every fucking one of them into a snowflake. &gt;Or maybe you just can't be bothered to learn Groovy... Not sure how you could be in a programming forum, and be so illogical. We actually have Groovy test scripts on most of our forums. While we're playing the "I'm going to make baseless assumptions on the minutia of what you said" game. You strike me as somebody very young, very inexperienced, never worked in a large multi-team company or codebases larger than 100k lines. Probably learned everything you know off of stack overflow, and don't have a degree in a STEM school, and if you do you cheated or it was a shitty school where they teach you a programming language or software instead of CS. You don't read much outside of code.
I completely agree with you. In most CRUD apps that is not an issue since you list will have only a few items, but when dealing with thousands of object it can easily become a bottleneck
Most build-in functions that you call do not invoke build tasks, but merely define them (or variables), leaving it to gradle to invoke tasks, yes. But that is a far shot from being declarative. See Gradle documentation: task loadfile &lt;&lt; { def files = file('../antLoadfileResources').listFiles().sort() files.each { File file -&gt; if (file.isFile()) { ant.loadfile(srcFile: file, property: file.name) println " *** $file.name ***" println "${ant.properties[file.name]}" } } } (https://docs.gradle.org/current/userguide/tutorial_using_tasks.html) Being declarative only works for very simple projects, the Gradle DSL has many hooks to add imperative code for your build. You could say anything imperative is not gradles "base form", but actually this is probably how gradle started, adding few "declarative" bits and pieces here and there to make life easier for developers. The simple core of gradle however lets developers define imperative tasks, and gradle will merely schedule the task execution order. So "base form" is not a useful term, what you mean is that most gradle plugins provide DSL functions that attempt to provide an API that does not require to write imperative code.
Excellent. Something like [this](http://cbsg.sourceforge.net/cgi-bin/live) but for Java!
Great idea! Unfortunately I don't have time to put something like that together, but I'm definitely going to tell my bosses we need to have a Java Golf competition, even if I can't use it for a blog post. 
Thank you so much for helping! I love your ideas! 
 import java.awt.*; import java.awt.event.*; import javax.swing.*; import java.io.*; public class MainMenuPanel extends MenuPanel { private JButton newGameButton; private JButton helpButton; private JButton optionsButton; private JButton MultiButton; private JButton creditsButton; private JButton exitButton; public MainMenuPanel() { super(); newGameButton = new JButton("Single Player"); newGameButton.setSize(new Dimension(157,45)); newGameButton.setLocation(400,250); newGameButton.setFont(new Font("Adobe Caslon Pro Bold", Font.PLAIN + Font.BOLD, 20)); newGameButton.setForeground(Color.DARK_GRAY); newGameButton.setBackground(Color.WHITE); newGameButton.setFocusPainted(false); MultiButton = new JButton("Multiplayer"); MultiButton.setSize(new Dimension(157,45)); MultiButton.setLocation(400,300); MultiButton.setFont(new Font("Adobe Caslon Pro Bold", Font.PLAIN + Font.BOLD, 20)); MultiButton.setForeground(Color.DARK_GRAY); MultiButton.setBackground(Color.WHITE); MultiButton.setFocusPainted(false); helpButton = new JButton("Help"); helpButton.setSize(new Dimension(157,45)); helpButton.setLocation(400,350); helpButton.setFont(new Font("Adobe Caslon Pro Bold", Font.PLAIN + Font.BOLD, 20)); helpButton.setForeground(Color.DARK_GRAY); helpButton.setBackground(Color.WHITE); helpButton.setFocusPainted(false); optionsButton = new JButton("Options"); optionsButton.setSize(new Dimension(157,45)); optionsButton.setLocation(400,400); optionsButton.setFont(new Font("Adobe Caslon Pro Bold", Font.PLAIN + Font.BOLD, 20)); optionsButton.setForeground(Color.DARK_GRAY); optionsButton.setBackground(Color.WHITE); optionsButton.setFocusPainted(false); creditsButton = new JButton("Credits"); creditsButton.setSize(new Dimension(157,45)); creditsButton.setLocation(400,450); creditsButton.setFont(new Font("Adobe Caslon Pro Bold", Font.PLAIN + Font.BOLD, 20)); creditsButton.setForeground(Color.DARK_GRAY); creditsButton.setBackground(Color.WHITE); creditsButton.setFocusPainted(false); exitButton = new JButton("Exit"); exitButton.setSize(new Dimension(157,45)); exitButton.setLocation(400,500); exitButton.setFont(new Font("Adobe Caslon Pro Bold", Font.PLAIN + Font.BOLD, 20)); exitButton.setForeground(Color.DARK_GRAY); exitButton.setBackground(Color.WHITE); exitButton.setFocusPainted(false); ButtonListener listener = new ButtonListener(); newGameButton.addActionListener(listener); MultiButton.addActionListener(listener); helpButton.addActionListener(listener); optionsButton.addActionListener(listener); creditsButton.addActionListener(listener); exitButton.addActionListener(listener); add(newGameButton); add(MultiButton); add(helpButton); add(optionsButton); add(creditsButton); add(exitButton); } private class ButtonListener implements ActionListener { public void actionPerformed(ActionEvent event) { Object obj = event.getSource(); try { if(obj == newGameButton) { GameManager.setMulti(false); ( ScreenView.getInstance() ).changeActivePanel( (ScreenView.getInstance()).newGame() ); } if(obj == MultiButton) { GameManager.setMulti(true); ( ScreenView.getInstance() ).changeActivePanel( (ScreenView.getInstance()).newGame() ); } else if(obj == helpButton) { ( ScreenView.getInstance() ).changeActivePanel( (ScreenView.getInstance()).getHelp() ); } else if(obj == creditsButton) { ( ScreenView.getInstance() ).changeActivePanel( (ScreenView.getInstance()).getCredits() ); } else if(obj == exitButton) { ( ( ScreenView.getInstance() ).getFrame() ).dispose(); } } catch(Exception exc) { System.out.println("Exception is catched: " + exc.getMessage()); } } } } 
We are not going to help you to do something unethical nor illegal. **Post removed** &amp; **banned**
And given that Sun's main line of attack against Microsoft was use of the term "Java"...
&gt; Why did they focus on Solaris when Linux was becoming the clear leader? Because management weren't willing to GPL-license Solaris to make it competitive?
WebSphere Liberty Profile + DB2?
&gt; The main power of an API key over an human chosen password is that it can be truly random, and of a considerable length, e.g. 32 characters. **Have a look into UUID generation** to receive such strings at low cost. I wouldn't consider UUIDs to be appropriate for API keys. RFC 4122 [specifically states](http://tools.ietf.org/html/rfc4122#section-6): &gt; Do not assume that UUIDs are hard to guess; they should not be used as security capabilities (identifiers whose mere possession grants access), for example. In Java, a better choice is [SecureRandom](https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html).
 &gt;That's a really long time for a build. I'd check your disk. Is it over a network? Is the disk dying? Yeah, it's over a network, but all the boxes (from my understanding) are in the same building. What do you mean by disk dying? Are you saying that I/O may be a contributor? I'm really at the point where I've got so many questions that I'd really like to be surgical with how I approach this. I feel like it's unfathomably slow, but I have very little data to back up that gut feeling. &gt;What build tool are you using? Maven? Gradle? Ant (shudder)? We're using ant.
Also, the char type wasn't originally UTF-16 anyway. It was UCS-2. So char was never intended to be UTF-16.
http://i.imgur.com/JkIpSFH.jpg
Hmm, I guess Oracle's JRE is redistributable. I was thinking of the older JRE from Apple, which wasn't. Sad that the JRE now counts as an external dependency and not a standard OS X feature.
created https://github.com/h2database/h2database/issues/283
Thanks that was my attempt at first start for the maven build - although its a bit tricky to get it 100% parity since the current build does some interesting stuff. 1 - Modifies the source based on the JDK being used 2 - Custom test framework (makes it harder to playnice with surefire) 3 - Many different JAR types available (I think this is best solved with modules?) So far the PR that was merged gets you a pretty good starting point for the full JAR with a minimal bridge to just run some unit tests. The current build system although handrolled is actually quite unique - I just think you get more mileage out of adopting something with more developer mindshare (i.e. Maven)
Ant and a two hour build time? maybe where I work is not the worst place in the world.
UUID is based on SecureRandom
Do tell if you find a suitable project for benchmarking, I've been looking for the same
This feature, supporting Maven inside SceneBuilder, is really exciting. I can't wait to try it out! 
it sounds like you are actually trying to drive/control/scrape a web browser, which can be done via java using a tool named selenium/webdriver. Otherwise if this is something you see as a user-facing accessory, you'd want to implement it as a browser extension which would be javascript for chrome/ff, which once installed into the browser would be able to interact with the webpage that the user is on. Although you hypothetically could do some of that with applets, it's not a viable option and honestly, just getting anything to work is an uphill battle.
Exactly what ran through my mind when I read the title. 
200K LOC - usually full compilation takes less than 5 min with Ant and JDK8 (even on slow and old system!)
Right, I don't think it has to do with the factory overloads. I tried some obvious things like looping over a bunch of List1's vs looping over a mixture of different List implementations, calling size() on all, but I wasn't able to observe a slowdowns in the mixed case. I didn't try very hard though.
Apart from SceneBuilder, they seem to be [porting JavaFX to Android and iOS](http://gluonhq.com/open-source/javafxports/), with an open-source license! This is very welcome news!
&gt; developed by a single developer Who else did take part in modeling the current design, besides you? I was hoping reading something like upfront design. But I see your implementation has already started which makes it now late to discuss design decissions. While browsing through your repository I spotted some things: - I see interfaces violating the I of SOLID (basically all your service interfaces) which tend to lead to god classes (see GameServiceImpl with 455 LoC and 15 dependencies). Speaking about god classes, I guess you could rename MainController into God. - This document about Application Design is just shouting out what tools you use. I get the feeling that one might get tempted to let the frameworks drive the design. I would expect more like that image on that page. Especially I'm missing a high level overview of the domain model(s). - No JavaDoc? Imagine how happy you will be without that https://docs.oracle.com/javase/8/docs/api/ - About flaw. I see you're going to be multithreaded (which is good for the UI). So I understand a user could possibly send commands concurrently to your controllers which then would let some services dance, right? Also I understand that the client will keep some state (I see that in the services). I possibly simply missed how that design avoids race conditions. Don't get me wrong. I do not want to make your project down. But "I'll be your java mentor" to make a "better" design than the existing "flawed" design are heavy words.
The UUID implementation that comes with the JRE (`UUID.randomUUID()`) is supposed to be cryptographically strong, as stated in [its JavaDoc](http://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID): &gt; The UUID is generated using a cryptographically strong pseudo random number generator. However, you cannot rely on UUIDs _in general_ to be cryptographically strong, as stated in RFC 4122. Another Java library that generates UUIDs may not be strong, as it is not required. Given that, I see no reason to use UUIDs instead of SecureRandom.
Yeah, that's been the standard pattern for most of my career (although usually WebForms rather than WPF). However, I'm starting to see enough Macs creep into the picture even at traditional enterprise shops, so I'm not sure how well that will continue to hold up. 
Probably some broken cache that leads to re-downloading the whole thing each time a build is started
This is excellent! Thanks!
On our case, if it is something typical CRUD then it is web based. I know other shops go Qt or Xamarin for more resource intensive applications.
Java is a really popular on single purpose devices. And if the JVM is already ported to the architecture you don't need to pay someone else. A lot of single purpose devices are just small computers at the end of the day. This really shows that Randall is not a software engineer, and just a techy.
\&gt;current year
intellij-community - compile time 6 minutes (i5-3570k@4,4GHz, SSD, NTFS) - java source code lines ~3 000 000 according to Statistics plugin (excludes comments and blank lines, some files might not be compiled). I would be interested in some benchmark with i7 Skylake...
No, that's not quite it. It describes everyday objects (not computer-related) being connected to the Internet that haven't traditionally been. Routers were never a part of IoT. Light bulbs, coffee makers, kitchen gadgets, etc. Those are IoT devices.
maybe I have it backwards but with IoT I think of devices (not laptops, watches or smartphones) that connect to the internet. The weightscale that lets you see your progression over time by sending data to your phone for example. Is that not what it is?
Also antivirus exclusions helps. And really fast CPU.
Glad we agree that UUID (in Java) is based on SecureRandom. &gt; Given that, I see no reason to use UUIDs instead of SecureRandom. Ease of use ? Just a personal opinion : In case i can afford 36 char i'll use UUID for ease of use.
&gt;Work on multiple workspaces in different browser tabs with each tab consuming ~100MB of RAM. Jesus! Doesn't this lag like crazy? :O
Ant + javac are usually lightning quick. Try using javac directly and see what you get. If that's slow, then the problem is (prolly) your network filesystem - copy files to local disk to verify. But if it's fast, then it means there's some additional processing in your build and you'll have to trank down what it's actually doing
I thought that was one of the points of Jigsaw, to get rid of numerous distributions. 
Targetting Jigsaw to something similar to the current ME would complicate Jigsaw because you would need to split packages in half (lots of classes are missing from Java SE). The current public `java.base` is probably about 4-8x larger than the current ME. Also since ME lacks reflection (just has `Class.forName()` and `ServiceLoader`), ME can actually be statically compiled ahead of time as a native ROM or similar and then executed. Adding reflection would complicate things because you would no longer be able to statically inline field values and such. 
MIPS is making a comeback.
&gt; I could address all of your points and we could have an interesting discussion. I would be really interested in that discussion. Which channel do you suggest to continue? &gt; Actually, you're trolling. There's no reason to get personal.
Reading the documentation (there's plenty of it) is a good start
Yeah, Oracle is not interested in providing a generic abstraction layer to move easily between different cloud providers. Their bread and butter is vendor lock in. Not that even JDBC managed to do that, but still. 
Maybe Java EE is overrated. Don't get me wrong: I like standard APIs, but the reality shows a lot of little incompatibilities between implementations. Before JPA Hibernate was the de-facto standard and worked well. What other implementations are relevant? Other than, maybe, EclipseLink not that much. Look for all the competing CDI implementations ... does anyone care about it? Spring DI and Guice are fine without big standards (the @Inject support in Spring is more or less meaningless). The world moves on - with or without Java EE. Don't panic.
It's what I pick up left and right indeed. Oracle feels that Java EE is helping the community and competitors too much and doesn't provide enough unique value for their own proprietary products. I think it's a narrow short term vision. Without Java EE, how much people would really consider WebLogic? I mean, suppose WebLogic consisted 100% out of Oracle's own APIs, what developer would ever be interested in learning that? Currently people come from JBoss, TomEE, GlassFish, etc and learned the Java EE APIs there. Then, if they must, they can be fairly productive on WebLogic since it largely uses those same APIs.
I am still not sure when I need something like this. Does this not indicate code smell if you can not determine the specific type of your object? Like using instanceof in your own code.
Please keep in mind, Java EE (J2EE) is just a bunch of JSRs. Java EE made only sense for container vendors. And it made money for Sun by selling the TCK to those vendors. It was a period where the EE container provided standardized runtime environments. But that period has ended. Today, we find more and more customized stacks. And integration of many technologies (or APIs) have become simple. So there is no need for big EE containers anymore. And therefore its a good thing to not have EE releases anymore. Some JSRs will vanish, others will stay and evolve. Live goes on.
&gt; J2EE died under its own weight. J2EE died more than 10 years ago. Why bring this up in a topic about Java EE? &gt;The idea that multiple apps will run in one container is flawed due to dependency hell. Java EE does not require that you run multiple apps in one container. If you are foolish enough to do that it's your own fault. We've been using Java EE for nearly 14 years and have **never** run multiple apps in one container. If you don't do that, and really nobody forces you to do that, so many supposed problems with Java EE are just not there. 
So you downvote for disagreeing? Not nice. Please read the reddit guidelines on voting. Typical size of Java EE? There is no such thing. And of course Oracle owns the JSRs, because they own the JCP. But they will not invest in something that has no community support. If only a few people care about Servlet 4.0, then this JSR will not move forward. And that is totally ok, because a standardization process should be based on many supporters. The world does not stop when there is no new specification. Other approaches will surface and will be adopted or die out. 
&gt; A typical full Java EE is around 100MB total size. That's less than an Angular hello world application pulls in as dependencies WTF?!? Firstly, the JBoss installer is nearly 200MB, compressed. Secondly, Angular is a single file that is 154 *kilobytes* in minified form. Maybe you're talking about a typical application EAR/WAR that gets installed *into* a JEE server... and maybe you're talking about Angular 2 instead of the current version. But the former would be a meaningless point, and the latter would be nowhere *near* 100MB even if you included the Node.js/NPM installation on your dev workstation. I don't get why comparing a server-side framework to a client-side framework would make much sense even if your numbers *weren't* bananas.
&gt;WTF?!? Firstly, the JBoss installer is nearly 200MB, compressed. Secondly, Angular is a single file that is 154 kilobytes in minified form. Let me check some servers I have lying around here: GlassFish is 109MB, Liberty 99.5MB, WildFly 130MB, TomEE 34.5MB, WebLogic 187.5MB, ... Yeah, it's around 100MB. Check https://antoniogoncalves.org/2016/02/02/o-java-ee-7-application-servers-where-art-thou/ for some more numbers. &gt; Secondly, Angular is a single file that is 154 kilobytes in minified form. LOL &gt;Just downloaded 89MB worth of dependencies to get started on an Angular 2 hello world app #hashtagproductivity See https://twitter.com/AWalela/status/733235517492334592 And that's on the low side even. There's a bunch of more like that (Google is your friend). &gt;Maybe you're talking about a typical application EAR/WAR that gets installed into a JEE server... Nope, for Java EE that's anywhere between a few kb, and a few MB (3 to 4 typically, at most). If you're using Spring intensively the size can go way up, even over that same 100MB again (Spring essentially packs an entire AS worth of dependencies into a .war). &gt;and the latter would be nowhere near 100MB 89MB is pretty close to 100MB, and I've actually seen it go over it :X &gt;I don't get why comparing a server-side framework to a client-side framework would make much sense Just to put your "big" into context. It's easy to just say Java EE is "big" and "heavy", but without putting those numbers in perspective it doesn't mean anything. People will just parrot it along, all thinking Java EE is indeed big just because someone said so. It's a text book case of confirmation bias without much or any ground. Another funny comparison is that a Java EE server that supposedly starts so slowly actually starts in about a second. A Spring application starts in several seconds more. The amount of memory a Java EE server uses is supposedly huge. In reality its around 40MB steady after startup. That's quite a bit less than a single tab in Chrome uses. Again see: https://antoniogoncalves.org/2016/02/02/o-java-ee-7-application-servers-where-art-thou 
Learn Maven and know what Spring does, then reading Java will be much easier in general.
I love IDE debugging for this. Build the project, run the database server, set a breakpoint at "the right spot", run a command and step through the product's various parts: - Parsing the command - Building an expression tree - Possibly transforming / optimising the expression tree - Collecting the data from indexes / disks (learn how indexes are implemented, etc.) You name it. Debugging = Seeing what's really happening while it's happening. An excellent way to find the right place to put a breakpoint is by using a profiler like JMC or simply by printing a thread dump whil running queries
I agree with your point about API stability. That is an advantage of such specs. However it is not always good, as J2EE has shown. And the JPA criteria API is terrible. 
I agree partially, if you are talking consumer grade embedded devices such as say phones or the common development board that runs Linux then Java SE would work fine on it. I would say the limitations are not irrelevant becuase there might be older hardware, smaller embedded systems, or special purpose hardware where you cannot really give it much speed or memory and where the ME limitations make sense. Say for example there is a SoC which can survive and still operate while being dipped in molten lead, the technology is either very new or has to be very robust and giving it the speed and memory of current new embedded systems might not be currently possible. 
It is one thing to ignore the troll and another to feed them ;)
Join my slack team https://salty-fjord-26094.herokuapp.com/
Also, I believe that standard APIs are useful "in case this framework dies". Even though 95% projects use Spring, they feel safe using it - if Spring dies it would not be difficult to migrate to some alternative.
I agree with your post, but even though you already say it, I'd like to emphasize that Java EE is really 3 things: * The individual JSRs (APIs) that have great value individually (CDI, JPA, JAX-RS,etc) * The combination of above APIs in specific versions to make up a standard stack where things leverage each other and work together (CDI 1.2 + JSF 2.2 + Servlet 3.1 + ...) * A specific installation and deployment model (AS installed on a server mostly managed by ops, dev providing .wars or .ears) For some reason the last point is what people often think about right away when "Java EE" is mentioned, but actually there's very little or anything at all in the Java EE specs that specifically mandates this. It's the norm for sure, but certainly not the only way to use Java EE. We for instance don't quite use it like that at all. At any length the installation/deployment model is just one of the three aspects, the other ones are arguably more important. 
&gt;Even though 95% projects use Spring, Do you have *any* references to back that up? Most evidence (surveys, SO questions, jobs), points to them being used approximately equally. In my area it's more Java EE, I know in the UK in the banking sector it used to be a bit more Spring, but overal not that much difference. 
J2EE was largely build with ivory tower in mind, although Servlet came out of that which was okay. Java EE was developed in the open, and as time passed an increasingly open process. See how the JCP process evolved.
No references, just personal experience. Could be skewed by preference in my country or just luck. Anyway, my point was not about popularity of frameworks, but rather about knowing that even if your framework dies it wouldn't be hard to migrate to any other compatible one. 
Actually, MyBatis can be a good fit for domain driven design, if you rethink things a bit. Mapping rows into a domain model is easy, which MyBatis can do quite well. Mapping changes in the domain model back into the database is a harder problem. That's the selling point of the Session/EntityManager, to track changes and generate the appropriate SQL. Alternatively, instead of depending on change tracking, which depends on mutability (which introduces other problems), changes to the domain model can be communicated by domain events, which can be handled by persistence commands calling MyBatis mapper interfaces. This is a more "reactive" approach. A side benefit is putting a check on mutability. 
No, it's an alternative to JPA entirely.
Great points. I've always preferred to use stored procedures for all write activities, as well, which is quite easy from mybatis. 
If you were writing code to do something with either a `Dog` or a `Cat`, you'd probably have `Dog` and `Cat` as subclasses of some common superclass like `Pet`; your code would accept `Pet`s, and would ideally use polymorphism rather than `instanceof` to make sure that dogs barked and cats miaowed, etc. It would be unusual to handle this case with `Either&lt;Cat, Dog&gt;`, not least because things would start to get messy if you introduced a `Rabbit` class into the picture. `Either` is not really for this case. It's for the case where the two kinds of value you might receive - typically, a value in the case of success and a value in the case of failure - have distinct meanings and must be processed in different ways. It provides an alternative to throwing an exception on failure which works better with certain patterns, such as stream processing, and enables us to reserve exceptions for genuinely exceptional cases rather than things like validation failures. Validation is a good example, in fact: when validating a collection of items, we sometimes want to collect all the validation failures and return them to the caller together, rather than halting immediately on the first failure. If our single-item validation method returns `Either&lt;ValidRecord, ValidationFailureDescription&gt;`, then we can validate multiple items like this: public Either&lt;List&lt;ValidRecord&gt;, List&lt;ValidationFailureDescription&gt;&gt; validate( Collection&lt;Record&gt; inputs) { Split &lt;ValidRecord, ValidationFailureDescription&gt; validationResults = inputs.stream() .map(this::validate) .collect(Eithers.split()); return validationResults.getRights().isEmpty() ? Either.left(validationResults.getLefts()) : Either.right(validationResults.getRights()); } This is quite a bit easier than defining, handling and constructing `ValidationFailureException` and `ValidationFailuresException` exceptions. 
Oracle? I'm just saying rather than maintain/update/add to an entire distribution just maintain packages.
&gt; What's a JEE platform? The discussion is about Java EE, not something called JEE. I can understand pushing back on people who still say "J2EE", as they are obviously dating themselves and their knowledge. However, whenever someone (and there's always someone in every thread) says, "*What is this JEE? Never heard of it!*"... it's hard not to just stop reading right there. That's almost as bad as saying, "*What's a JDK? I was talking about the Java SE 8u91 SDK!*". JEE is an extremely common colloquialism. Most **Oracle employees and consultants** that I've worked with use it. So knock it off. Pedantic is not the same thing as smart. For this rest of this: 1. I was not arguing that you should include the size of a dev workstation's IDE in the size of server infrastructure and deployable assets. I was arguing that doing so would be *dumb*. 2. A well-constructed JEE application (with server) can indeed be smaller and faster than a poorly-constructed Spring application (with server). Sure. But you have to muddy the waters and compare apples-to-oranges to wind up with numbers that win that argument. Meanwhile, a modern well-constructed Spring Boot application (with server) is smaller and faster than a modern well-constructed JEE application (with server). Anyone who disputes that in 2016 might as well be discussing "J2EE". Moreover, getting back to the original subject matter of this thread... Pivotal still cares about Spring and its future, while Oracle arguably does not with JEE. Which in my my mind, ends the discussion right there and renders the rest of this conversation entertainment-value only. 
&gt; Most Oracle employees and consultants that I've worked with use it. So knock it off. Pedantic is not the same thing as smart. In my experience, it's really only Spring people who use it. Java EE folk use it rarely. They may say "EE" as colloquialism but really not JEE often. It happens, but really not often. Because it's used mostly by Spring people, and the majority of Spring people talk negatively about Java EE (admittedly juvenile thinking, but it's their "sworn enemy"), the term "JEE" gives a distinctively negative vibe. It feels like a word used to ridicule Java EE. It's less about being pedantic really. &gt;Meanwhile, a modern well-constructed Spring Boot application (with server) is smaller and faster than a modern well-constructed JEE application (with server). I absolutely don't agree with that. Smaller on disk is debatable as argued above, and the differences are such that it barely matters. If in some strange situation it would matter, then with Java EE you can minify your server just as well. WildFly Swarm, Payara Micro, and Liberty natively all offer options for this. Now faster is debatable as well. Faster in what? Performance? Serving requests? Faster to develop for? And if the latter, faster to develop a hello world or a large application? In case you meant performance, then I can tell you this is not quite the case. We did extensive benchmarks here for a greenfield project and Spring was NOT faster than Java EE (we compared against WildFly). Our findings compared well with http://jsfcentral.com/articles/understanding_jsf_performance_3.html &gt;Pivotal still cares about Spring and its future, while Oracle arguably does not with JEE. I hate to admit, but that's likely true, at least the Oracle part. There were rumors that Pivotal was eying a cloud strategy as well and delayed development of their Spring framework because of that, but as of now they are just rumors. &gt;Which in my my mind, ends the discussion right there and renders the rest of this conversation entertainment-value only. Perhaps, although there's more parties involved with Java EE than Oracle, and Oracle can perhaps still be made to change its mind. But it's a grim outlook... 
&gt; Please keep in mind, Java EE (J2EE) is just a bunch of JSRs. I don't think I could disagree with this any more strongly. There's much more to the JavaEE space than JSRs. When I use a JavaEE container that has been built and I know conforms to a specification I know exactly what to expect from it. There is a lot of work that the vendors put in to get their containers to conform properly. By saying that JavaEE is just a bunch of JSRs, it belittles the work that is put in to construct these runtimes. I could look up every JSR for JavaEE 7, go find libraries that implement those, and construct my own runtime, but I'm not going to do that. I am going to rely on a vendor that provides the runtime who guarantees that it conforms to the JavaEE specification. They have worked out the issues already where library A has some weird interaction with library B under certain circumstances. The guarantee that you are using a certified runtime is huge in the enterprise world. We need something we can rely upon and invest heavily in that will be supported for years to come.
ITS IN CAPITAL LETTERS AND EVERYTHING
500K LOC system here with maven and jdk7 takes 20 seconds, including java unit/integration tests and javascript unit tests.
"Disjoint union type" or, if you want to be really fancy, "exception monad".
Is this only useful, if I want to keep the type of the right side? So it will not automatically narrow the scope down to e.g. an interface right? Like var map = new HashMap&lt;String, String&gt;(); which would resolve to HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); vs Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
I honestly am not sure how it will work out being implemented with regards to generics and diamond operators, but I think that looks right. 
LoadRunner was great on the Commodore 64. Tapper was also another great one to invest it depending on budget.
Honest question, is it bad? I never used templating in Java before.
A bit outdated? The post was made in 2014.
There is a difference in Javascript, its like all functions either written recently or a long time ago all implicitly inherit from something similar to Function. While the new Function interface we can only apply it to new code that we develop. But in practice its perfectly possible to do functional programming in Java 8, it comes with a lot of powerful constructs.
There may be a difference concerning backwards compatibility, but as the article states explicitly, that is does not exist in Java 8, isn't that plain wrong?
If you're confused then you're on the right track. When developers say "Java" they usually mean the Java Development Kit (JDK), the Java Runtime Environment (JRE), and the Java Virtual Machine (JVM). Think of it as a matroyshka nesting doll: the JVM is inside the JRE which comes in the JDK. The JDK is a development kit with the dev tools for making Java. The JRE (which is in the JDK) consists of the JVM and class libraries. The JVM is where the magic happens --this is the virtual machine that runs the Java code you build. J2EE is the "Enterprise Edition" and it's a platform for the web. If you're making a web app, you use the J2EE and a server like Tomcat, Glassfish, Jboss etc. And external things like a database, MVC framework, etc. etc. How to learn it? Well, first, if you're a trainee, they'll show you the flavor they want you to learn. When they start you out with topics, just start looking those up on Youtube for more practice. For example, they want you to start making web apps with the Spring MVC framework, the Tomcat server, and a MySQL database, then do that stuff at work and practice those things when you get home. If you start going down the Spring rabbit hole and they want you to learn something completely different, then you're only confusing yourself. For just Plain Old Java, you can start with Codecademy's Java course that they just added. Or you can use Youtube tutorials. The most popular (free) Java IDE is Eclipse. You could get that and start practicing --if they want you to use something else, it wouldn't be hard to switch over. After you have Eclipse, go through Derek Banas's tutorials: https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19 Derek goes really fast through his tutorials, which I like because he's not sitting there going "um and guys, this is ... this is um ... this is how ...um Arraylists ... um." But, the speed he does his tutorials at can kinda leave you in the dust. I recommend going through his tutorial, stopping it to catch yourself up every now and then, and then practicing what he went over for a few minutes afterward. There ya go, that's a decent start and like I said, your job will train you on the frameworks and stuff they want you to use. 
Thank you so much dude. This really did clear my clouded mind. You're a savior!! Unlike those who chose to downvote sadly. 
Those who downvote likely do that because this is a help question which should go in /r/javahelp.
Thank you man. Will check that one out as well.
Sorry about that.
Minotaurohomunculus has answered this very well, and I can second the recommendation for heads first java book. Wanted to add in a couple links: This is the original Java whitepaper which will get you oriented around why Java was developed and created. http://www.stroustrup.com/1995_Java_whitepaper.pdf This brings me to the other point - Java has had a rich history of evolution. Java today (version 8) is FAR different than the original version and it will serve you well to get a basic idea of which features were released in which version (for example, to really understand "Generics" you need to understand how the language worked before!) This is a great introductory class on Coursera - only issue is that this is a scheduled class and it is not always offered. https://www.coursera.org/learn/object-oriented-java/home/welcome
What is you salary on this job ? 
&gt; The most popular (free) Java IDE is Eclipse I would suggest start with Intellij Community (it's free) or/and trial for Intellij Ultimate. It's imo way better :)
If you're developing for enterprise (JEE), make sure you get the [Eclipse for Java EE Developers](http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/mars2). It comes with a bunch of built-in tools to make web development more streamlined.
Thank you!! this will keep me busy. :)
am currently doing a course with Intellij, will look that one up as I heard most devs at the company use Eclipse. I'm just about to start. :)
Until he wants to do JEE stuff. Or don't you need the commercial version for that anymore?
Honestly, /r/javahelp is a slow sub. I don't think you would've gotten this quality of an answer over there. You weren't asking questions about for loops, so I personally think this kind of question is ok to have in this sub.
Just to clarify a bit on one thing you said: &gt; J2EE is the "Enterprise Edition" and it's a platform for the web. If you're making a web app, you use the J2EE and a server like Tomcat, Glassfish, Jboss etc. It is just referring to as JEE (Java Enterprise Edition) now, J2EE was the old acronym. If you're making a web app with Java, you do not HAVE to use JEE or any of the JEE server implementations that you listed. You CAN if you want to, and some of the most popular web frameworks are built upon it (eg: Spring). A lot of the most popular recent frameworks however bypass it and have implemented everything from the ground up themselves (eg: Play).
I don't understand why he's been downvoted - a lot of others are curious to know the difference in salary between someone who is considered a software engineer (without an actual s.eng degree) and someone in OPs situation.
That's okay! Lots of other people already gave you advice, so I'll just say good luck! There's a lot of fun interesting new technologies and concepts ahead of you. :)
For what it's worth, I third the heads first java book and highly recommend their design patterns book as well. When you can start using that stuff properly you stand out way above your peers. I'd highly recommend reading it after a few months with Java.
What do you mean by only new code? Also in another post you wrote that you "implement" the interface and that may be confusing as the keyword implements is not used. Old code works fine with functional interfaces
So by number 1 I mean the process of breaking down a business problem and converting it into the related programming concepts you need to use to solve the problem. For example with a lot of people who just got out of school, I could ask them to write a binary search tree and they could do that no problem. But when I tell them they need to work on an application that sends all people who buy Purina pet food and live within a two mile radius of any Wal-Mart across the United States then things start to break down. So I guess what I am trying to say is that knowing when and how to apply the techniques you acquire in your CS program is a well valued skill. For number 4, integration testing is a type of testing that tests multiple components of you software together. Unlike unit testing, where you only want to test the functionality of a single class or method and look for failures, integration testing looks for failures across multiple software components. In enterprise systems it is very common to have multiple large systems that all need to work together, so testing those integration points becomes very important. 
Knowing each other's salaries gives us power. Your boss wants to make sure you don't share your salary so they can pay workers as little as possible. 
I live in the Philippines, which is a third world country. I'd say around 400$, not including tax deductions. Not too bad if you live in a third world country and living with your parents. I know the pay is low, but after the training, they promise a raise. And it's a huge company! :)
&gt; they promise a raise Such promises aren't worth anything.
Or, you know, prioritize: money or a good IDE. 
Get head first Java series, they have an enterprise version too. Same thing happened to me but I had already read the books before hand. http://www.headfirstlabs.com/books/hfjava/
Just like a digital portfolio of sorts. 
It's funny how the title "Software Engineer" is thrown around these days. I have no problems with people calling themselves Software Engineers providing they have the qualifications and actually took engineering courses in university. But, I'm guessing the vast majority that call themselves "Software Engineers" didn't. And then there's the ones that don't even have a Comp Sci degree. 
Right, but OP is a beginner. Generally not such a good idea to tell beginners to go out and spend $50/month on software until they really understand why that price can feel like a drop in a bucket.
Who says it is bad? You shouldn't be afraid to throw NullPointerException or IllegalArgumentException (or subclasses) from your constructor especially if your objects are immutable. Fail as early as possible so that the culprit is in the callstack and provide and explanation of the reason. It is also helpful to document the RuntimeExceptions you might throw. For example with Objects.requireNonNull I have gotten in the habit of using the two arg variant and providing a message naming the argument being checked. Often when I get a stack track the source line number has changed slightly as a result of intervening chances from the version which generated the stack trace. Having the extra info of the parameter name really helps. i worked on OpenJDK which spent a lot of effort to document which arguments could be null and the conditions under which exceptions are thrown. This documentation provides much of the basic for JCK tests. It is a lot of work to create documentation this thorough but I definitely came to appreciate the value of having that documentation when I found it missing with other APIs.
Probably just to maintain legacy code
Every time you download it? Or every time you try to install it? It looks like a corrupt installation. You should be able to check the MD5 checksum against the one they provide on the website. If it matches yet still fails, perhaps try from a mirror. I cannot tell what OS you're running but obviously, make sure you correctly select both the OS and proper architecture (x32/x64).
I still use it preferentially. * swing has a better look and feel. Even a native one out of the box. Fx never looks natural or behaves like anyone cares about the HIG of the platform it's on * I prefer the tooling for swing. NetBeans gui builder works well for me * oracle openly don't care about Fx any more than they care about swing. Neither is being developed 
Congrats mate! I've been working with Java for over 10 years, if you have any questions shoot me a pm.
What do you call this? try { Foo f = new Foo(); f.doSomething(); ... } catch (FooConstructorExpception e) { ... }
Tell that to people with comp sci degrees calling themselves software engineers. I actually went to a school that had an actual software engineering program.
I find video tutorials don't go in depth enough. I recommend reading some books. https://www.goodreads.com/book/show/17063544-oracle-certified-professional-java-se-7-programmer-exams-1z0-804-and-1z0 Good starter book. Teaches you the basics. https://www.goodreads.com/book/show/105099.Effective_Java_Programming_Language_Guide This is a bit more advanced, it will help you avoid some pitfalls in the language. https://www.goodreads.com/book/show/3735293-clean-code I really recommend reading this one, it will change the way you write code. The examples are in Java but the concepts are useful for most Oop languages. Sorry if the links are huge, wrote the comment on my phone. 
I personally don't like throwing exceptions in constructors, but it really depends on what you are trying to do. At the end of day, you have to handle your exceptions and you have to pick your poison.
But I do have a Bachelor's degree in Information Technology. We had to do a couple of thesis for 3 semesters and those weren't a walk in a park.
&gt; Who says it is bad? It can cause problems in other languages, and also in Java on Android. For example in Delphi you could then wind up with objects that were not initialized properly (at the language level). I'd argue that this is weaknesses in those languages/object systems, and not a problem with exceptions in constructors per se.
Have enough space on the disk partner? Shouldn't be an issue really but wouldn't hurt to check. It looks like you're using the java updater to grab the update - try downloading it directly from https://java.com/en/download/
Java 7 you have try-with-resources which can help with closing and cleanup.
&gt; What do you mean? Are you having issues with compatibility around the app-server provided libraries? Wel, we never have issues really since we strictly adhere to the one app per app server rule ;) But the idea is that upgrading always comes with a cost. Java EE is quite compatible, but even it has upgrade costs. If you have 1 app running on a single server, you can upgrade it in say 3 days and you don't even mention it to management. If you have 10 apps running, the combined time needed may be 20 days, and you have to inform management and they'll say no (but eventually you'll do it anyway). If you have 100 apps running, it just doesn't happen. Just recently, we did an upgrade of an app from WildFly 9 to WildFly 10. The change from Hibernate 4 to 5, and specifically the dependent Hibernate Search and Infinispan caused more than a couple of issues. Since we only had to do it for 1 app it was doable. Had it be multiple that all had to be updated before we could have done the WildFly 10 update the entire update may not have happened. &gt;I know it's considered controversial to say it, but I think the scale-out fad of recent years tends to overlook the maintenance costs. Smart orchestration/devops tooling does simplify it, but there's a cost to each server you run. It maybe sounds conflicting, but we are actually a big fan of scale-up as well ;) But we're in the data registration and processing business, which means a single relatively small application in terms of code (say max 20k loc) can easily use a dozen of cores to the max. So we tend to provision a few very powerful servers instead of hundreds of not so powerful ones. You need a few extra for redundancy, but far less extra for scaling as the mongo/webscale HN crowd wants you to believe. (just see what SO is running on) &gt;but have you looked into replacing VMs with Docker for this? While we're on the bleeding edge with regards to many software packages, we actually haven't looked into Docker yet. Some devs have played with it, of course, but production is still XEN based. We'll see how things evolve ;) &gt;So... Undertow - on a scale of 1 to 10, how much do you love it? Because at about an 11. It's quite okay, I like the extension (handler) system that we intensively use for some low level stuff (such as a universal cookie rewriter that you just can't do with the Servlet API), and Stuart (main Undertow guy) is quite a capable dev. 
Initiated a commercial fat-client project recently that had some fairly hairy UI requirements. I ended up having to do a bake - off between the two. In the end, JavaFX has a richer set of built-in components, but Swing has a broader ecosystem of libraries. I'd have preferred to go with JavaFX, but my bake - off included a need for a docking framework. There is one project in the broader community that offers an option for docking in JavaFX, but it has enough bugs as to be unusable. It was very close, but we ended up falling back to Swing.
A compromise that uses other recommended practices: don't have a public constructor, instead use a **factory method** that documents the thrown exceptions. Regardless of which is "correct", a factory method that throws will probably surprise fewer people. This is Effective Java #1.
Any reason for using a String instead of an Enum for the method?
The poster is showing only a superficial understanding of Thymeleaf, and does not seem to understand the implications of the Thymeleaf HTML-centric model. The model truly shines with master-child templates (JSP [template tags](https://docs.oracle.com/cd/E19575-01/819-3669/bnaoh/index.html) are comparable) and AJAX (nothing I have found in JSP compares). Thymeleaf lets you do something like this: example.html: &lt;script&gt; var table = function(html) { $('#table').html(html); $('#table').find('.nav').each(function() { $(this).click(function() { $.post($(this).attr('href'), table); return false; }); }); } $(function() { $.post('/example', table); }); &lt;/script&gt; &lt;table id="table" th:fragment="table"&gt; &lt;tr th:each="r : ${result.items}"&gt; &lt;td th:text="${r.id}"&gt;Sample Item&lt;/td&gt; &lt;td th:text="${r.description}"&gt;Sample Description&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;a class="nav" href="#" th:href="${result.prevUrl}" th:if="${result.prevAvailable}"&gt;&amp;lt; Prev&lt;/a&gt; &lt;a class="nav" href="#" th:href="${result.nextUrl}" th:if="${result.nextAvailable}"&gt;Next &amp;gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ExampleController.java: @Controller public class ExampleController { @Autowired private ItemsDao itemsDao; @Value("${site.limits.items}") private int limit; @RequestMapping(value = "/example", method = GET) public String init(@ModelAttribute Result result) { return "example"; // whole template on initial load } @RequestMapping(value = "/example", method = POST) public String init(@ModelAttribute Result result, @RequestParam int start) { result.setItems(itemsDao.findAll(start, limit)); boolean prevAvailable = start &gt; 0; if(prevAvailable) { int prevStart = start - limit; result.setPrevUrl("/example?start=" + prevStart); } result.setPrevAvailable(prevAvailable); int nextStart = start + limit; boolean nextAvailable = itemsDao.getCount() &gt; nextStart; if(nextAvailable) { result.setNextUrl("/example?start=" + nextStart); } result.setNextAvailable(nextAvailable); return "example :: table"; // *partial* update } } Thymeleaf's HTML-centric model lets me keep the integrity of the template. With JSP, I have implemented this pattern by chopping up the JSP template, with the partially updated section forced into a separate JSP file.
Why is this useful? Why not use an existing solution? Is it just a hobby project? Does it offer unique features? What did the author not like about current solutions?
Thanks, the main reason for this thread was to see if there was one, but it appears there isn't 
I am handling the conversion of a Json Object to Java by jackson, since its done automatically I don't have the option to try/catch or pre-check the inputs
This should use codepoints rather than char. Also much of the functionality is duplicated from existing standard library methods.
Same experience here. The last fat client I worked on, we decided to create a WPF/Java hybrid application, where the UI was implemented in WPF and the services were implemented in Java, and the two sides communicated through REST. But, as a consequence of the Java REST service being remotely hosted, we had a few users who wrote Python scripts to use our REST API programmatically. So, win?
Neither. Html + js front end beats them both. 
It won't help in that scenario, though (exception thrown from different method). Try with resources is essentially shorthand for calling close in a finally block.
in my opinion throwing exceptions in a constructor is one of their best uses. consider that you can't exactly return null from a constructor so there's no way to return a status, plus you shouldn't be returning statuses anyway that's sort of what exceptions are for. Thus we throw an exception, our caller knows something bad happened, we didn't return null, everyone's happy. Some might argue it's a bad pattern and you should just be using factories anyway, but that's another discussion i think.
What would be the advantage of code points over code units (in Java *char*)?
It can also cause ExceptionInInitializerError which hides the root cause in some cases. I don't blame these other languages because java gives you plenty of opportunities to fail.
what platform is that ? It works on Windows, Linux and OSX where swing does...
&gt;It can cause problems in other languages Drawing conclusions about best practices based on other languages is questionable. In C++, which is arguably much more closely related to Java than Delphi (especially when it comes to exceptions and constructors, where Java very closely mimicked the c++ syntax), [throwing exceptions from constructors *is* the best practice](https://isocpp.org/wiki/faq/exceptions#ctors-can-throw). &gt; and also in Java on Android. I think you're referring to parts of the API that invoke constructors and don't expect any exceptions to be thrown. That doesn't mean throwing exceptions from constructors in general is bad, or even that throwing exceptions from constructors on Android is bad. It just means throwing exceptions in places an API will not be expecting them is bad.
Pass enum instead of boolean flags to toggle things like 'case sensitive' and 'allow overlapping'
~~Unicode~~ If, for example, a string is encoded under UTF-8, then a single printed character can be represented as multiple 8-bit sequences. For example, the single Cyrillic letter Ж is code point 0x0416 in the Unicode specification, which is encoded as two 8-bit characters, 0xD0 and 0x96 (or Ð and the `Start of Guarded Area` control character).
Yeah, but ES6 is already out.
I'm 90% sure u can add .project to .gitignore because u can import and existing maven project. Using auto wiring is fine and that's how I do most dependency injection in my projects.
If you're going to use maven then stick to the convention of using src/main/java for your Java sources and src/main/resources for resources like spring configs. You don't really need Spring for this project but if you want to stick with it then consider using Java configs instead of xml. Auto wiring is fine for small projects. Don't commit IDE specific files like .project into your source control. If you clone your project to a new machine then just import it as a maven project in Eclipse
This is good practice. Only note to add is that I'd personally limit rigorous precondition checks to public APIs. For internal ones I'd either not bother or use assert which is compiled out when shipping the library.
Check out item 38 of Effective Java, basically you want to fail fast in this case. If the calling code is doing something with resources that need to be closed they should be doing it inside of a try with resources. Quote from Effective Java: "Constructors represent a special case of the principle that you should check the validity of parameters that are to be stored away for later use. It is critical to check the validity of constructor parameters to prevent the construction of an object that violates its class invariants."
You have the right idea, however what you wrote is UTF-8. Java's `char` being 16-bit means that said letter is represented as `0x0416` (the sequence `0xD0 0x96` is just `Ð` (the second character has no graphic, at least for me)). However, characters `0x10000` and above must be represented using two `char`s (using something similar to UTF-8's multi-byte sequence) . 
Debian has an OpenJFX package for PowerPC... So I guess it is in fact available? 
It depends on how you define better. Most if not all Java developers I've met write and compile within an IDE Java has great IDEs and it's hard if not impossible to get that level of integration with let's say vim or sublime.
Uh, it’s always bad to write code which can throw errors. Just write flawless code, problem solved!
An important question is : for existing projects, what is the interest to migrate from Swing to JavaFX ?
Jackson can also use the Builder pattern for deserialization, but it may not make much of a difference in this case. You also need to worry about Jackson dealing with whatever exception you throw in a way that ends up with the right return code. You want this to be a 400, not a 503. 
I examined the source code and I don't see any duplicated functionality (but indeed a lot of standard methods are wrapped and shortened for convenience).
No idea why people say IntelliJ is better. 1. You need a license for it 2. Many things that are in the core of Eclipse, can only be added to IntelliJ by a plugin Just my 2 cents on using both.
I don't quite understand you. How is "doing nothing for 8 months" removing technical debt?
Or with any of the StringUtils classes from Apache, Spring, Google, Eclipse, etc.
&gt; In practically every project you’ve used a “dirty hack”. setAccessbile(true), sun.misc.Unsafe, changing a final value with reflection, copy-pasting a class from a library to change just one line of wrong code. In practically zero projects, although I will admit that I used `setAccessible` about 2-3 years ago. One thing that you should NEVER do is change the value of a `final` value. The JVM could end up just optimizing, inlining, and caching the `final` just once, so any future changes would take no effect at all. So a `final` could point to an instance of `Foo`, but at the start of the program you change the value of a final, but your entire program uses the old value instead. Unsafe is also not portable, so if you plan to run your program on more than one JVM, do not use it. Another consideration is that Unsafe is quite powerful in what it can do, so if your code using Unsafe has a kind of vulnerability which allows your Unsafe call to be crafted into a vulnerability, that would have been avoided if Unsafe was not used. Hacks are like taking a shortcut through a minefield rather than going around and taking the safer path. &gt; lets you move forward to delivering actual value, rather than wondering “should I use a visitor pattern here If you are thinking about a specific pattern to use in specific location without regard to the entire project, then you may be overengineering the solution. Basically one is weighing the costs between "Should I use `AbstractCookieFactoryBuilderWorker`?" and "Should I use `setAccessible()`"?
&gt; One thing that you should NEVER do is change the value of a final value There's always an exception, with deserialisation :P -- see the java spec (https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5.3) Although, most people should never come close to doing something like this. Gson I believe does this, it allows you to declare simple imutable pojos and the magic behind the scenes does this last time I looked. 
To be fair, you left out some important context from that quote: &gt; In practically every project you’ve used a “dirty hack”. setAccessbile(true), sun.misc.Unsafe, changing a final value with reflection, copy-pasting a class from a library to change just one line of wrong code. **Even if you haven’t directly, a library that you are using most certainly contains some of these.** Spring and Netty both user sun.misc.Unsafe, Jackson uses setAccessible(true), etc. There's an excellent chance that somewhere it your dependency chain, someone is using one of those "dirty hacks". 
Luckily for me I do not have to deal with serialization because it does not exist in Java ME. Personally, serialization is a rather large and ugly hack. There are definitely better ways to implement it but the Java developers chose a hack and now we have to live with it for the most part.
Fair point, however I was going on a more personal end. Due to the nature of the project I am working on, all the libraries that are used are written by myself. As such, there are none of these "dirty hacks" in said code base (there are exceptions however). The only acceptable place for these "dirty hacks" such as unsafe code is in the main Java library and other very important code, which is where they are and where they will remain. However, the more they can be minimized the better and that is my general goal. 
Same content as &lt;https://www.reddit.com/r/java/comments/4hg3ql/11_myths_about_embedded_java_dev_tools_content&gt; for the most part.
&gt; you end up creating nonflexible shit Or, you end up with the opposite problem, unstable monkey patched pieces of shit that cannot be upgraded to newer framework versions because of dependencies on internal functionality that was never meant to be used by the public, without even knowing it. Having worked with Wicket before, I have run into issues with final classes and final methods. I actually *appreciate* that the Wicket team made it clear which extension scenarios they had considered and are safe to use. They made it extremely difficult to depend on unstable abstractions. So you have to do crazy reflection hacks to use Wicket in an unsupported way? Good. You have just added a bright red warning flag to your code that this could break in the future. 
&gt; against Effective Java rules! There is no rule in Effective Java that says not to use protected. Rule #13 says to *minimize* access, which for most purposes, is private access. On the other hand, Rule #17 says design for inheritance or forbid it. Forbid by making the class or nonoverrideable methods final. Allow by carefully opening up the class through judicious use of protected methods. Which is exactly what Wicket does. &gt; If I copypasted everything Increased maintenance, yes. But more difficulty upgrading, probably not. Because some isolated parts of their code are now your code, and has now become isolated from their updates. But at least you are depending on stable abstractions. You know the cost and can decide to bear it as long as practical. &gt; Reflection is not crazy You're misinterpreting my meaning. Crazy as in highly unusual, extreme methods to circumvent a restriction, which obviously communicates instability. &gt;So what seems to be the problem here? There is no problem. Wicket's design approach of controlled inheritance is good. Forcing the user of Wicket to go through measures which are obviously extreme is good. The obviousness of the extemeness giving you insight to write a test case is even better. Following the rules in this case leads to a great outcome. 
That's one part of rule #17, a design restriction on inheritance to ensure safe initialization of subclasses. If the Wicket team is calling a protected method from the constructor, a wag of the finger. You didn't follow the rule to the letter!
Your points are really bizarre. Software engineering is more of a white collar trade, pretty much a glorified mechanic and ops are glorified plumbers. I have a comp sci degree and I'm basically free to do what I want in this industry (benefit of comp sci vs software engineer degree). If I wanted to I could easily go into ops or security, which I would argue is hard for somebody who studied a specific implementation of computer science, like software engineering. However, I had absolutely no idea how to be a software engineer when I was finished with computer science, so there is that.
This project is better named than ButterFaces!
As someone who uses both on a daily basis, JFX is hands down better than swing. Code organization, speed, layout, and look and feel are all better. The only thing it lacks is the amount of libraries and frameworks that use it, which has nothing to do with the actual implementation, but more to do with the amount of time it's been out. 
for anyone interested there's an interesting CS/PL discussion of "boolean blindness" here: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
You're free to call yourself whatever you want just as a garbage man can call themselves a sanitation engineer. It doesn't mean you're an actual software engineer. There are a number of US universities that offer Software Engineering degrees and in various places around the world, such as Canada, it is a legal requirement that you must attain your Professional Engineering accreditation before you can even use the word Engineer in your title.
Have you set this up and got it to work? 
First of all, did you try reinstalling Java? This is a classic *cum hoc ergo propter hoc* fallacy: just because two events happened seemingly simultaneously does not mean they're always related in anyway. 
Spring does not need a JEE server! A servlet container is enough (tomcat, jetty, ..). 
Technically, neither Java, not JDownloader can do this - unless you downloaded them from a shady site. Also - no shouting (writing in ALL CAPS is shouting). Last: this is a case for /r/techsupport and has nothing to do with Java. **Post removed:** not Java related, and misconduct.
His explanation is not entirely correct. JVM, JDK, JRE explanation was correct, but you do not need JEE to develop web apps. I for one would stay far away from it. You could use Spring / Play / Dropwizard / Vert.X . They all work without JEE (Spring for example only needs a servlet container, not a full blown JEE server). And yes JEE servers have their disadvantages: you are bound to the implementations (or even versions) they provide (hibernate/logging/transactions/...). A lot of complexity, with what in return? A more expensive server? You could deploy more apps on the same JEE server, so the server JEE stack is shared by them. Kinda insecure no? (and that for a couple of Megabytes memory savings). Don't be fooled and research some more before you take the plunge in JEE.
No.
I'm sorry that my all caps harmed your delicate eyeballs. My problem WAS (oops, sorry, didn't mean to EMPHASIZE with all caps, I promise it won't happen again,) Java related, the implication in this response thread that it wasn't is false. Further more, r/techsupport is the mostly useless subreddit on this entire site, so forgive me if I decided going to a subreddit specific to the **definitely actual problem,** would have been more effective.
is on reddit. working fine. installs java. cannot access reddit. uninstalls java. can access reddit. within the span of 10 minutes. NOPE definitely not java related whatsoever, bulletproof logic there. Thanks for the clarification.
Integration into Hibernate Search in case anyone was wondering.
No code shown :-(
Please don't take what I'm about to say as meaning that I want to deter you from making an app; however, with that said, I would seriously consider some of the logistics of making a high-level app, such as a real estate one. For instance, what devices do you want it to run on? You posted this in /r/Java, so I'm left to assume you want Android devices. Is that it, or will you want to expand in the future to iOS or Windows Market? Next would be, and I cannot stress this enough, if you do not have an account, create one with StackOverflow... and use it religiously! In more cases than not, it's going to be better than Reddit at giving you specific programming advice anyway. And lastly, although I love to see people with ambition, I would suggest you start out with a simpler project. There are many on the internet, and you can probably think of some, as well. Regardless, as stated before, please don't take what I'm saying as being said to deter you; however, I think you need to think a little bit more of your end goal before jumping in.
The spring boot documentation has a section on migrating from a spring to spring boot app.
Don't confuse stable with dead. Ribbon is well supported in things like Spring Cloud and others.
&gt; The most popular (free) Java IDE is Eclipse. Last time I was at a Java conference and someone called a vote the vast majority (like 80% at least) favoredIntelliJ over other IDE's. So I think this is a pretty bold statement :)
It wasn't immediately apparent to me what BootsFaces. It took a few judicious mouse clicks for me to finally discover that BootsFaces "is the next gen JSF Framework that takes the best from Bootstrap 3 and jQuery UI."
You can do JavaConfig without Spring Boot...
Check out spring boot + gradle https://spring.io/guides#gs
First framework that came to my mind was Spring: - WebSockets: [Spring Web/Spring Messaging](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html) - ORM: [Spring Data](http://projects.spring.io/spring-data/) (Spring Data JPA uses [Spring ORM](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/orm.html)) - Background tasks: [TaskExecutor](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html) Depending on your needs, you might even want to take a look at [Spring Integration](https://projects.spring.io/spring-integration/).
I disagree with your naming conventions: classes should start with an upper case letter and packages have no capitalization. Also, I think this would benefit from unit tests instead of a bunch of mains, and putting them into their own source tree (src/test/java/yourpackagehere).
Thanks for your feedback, what do you mean by "packages have no capitalization." ?
You should improve your question (= title)! *"API"* is an extremly generic term; it could be everything. You should better ask for a **web** framework - with that said, everybody will immediately understand, what your problem is.
&gt; package ga.dryco.JerkTest; the line above should not have capital letters. Edit: If you're looking for more advice on how to style your code, I'm a big fan of https://google.github.io/styleguide/javaguide.html
&gt; Also, I think this would benefit from unit tests instead of a bunch of mains, ... I doubt that there are many sensefull unit tests at this kind of project! (Nevertheless he should of course implement them!) But I think there will be a bunch of *integration* tests, which one could of course implement by using a testing framework like JUnit.
I'm actually about to start writing a blog on how to write Java web services without using a big framework but it probably wont be done in time for you. I highly recommend picking a low level HTTP server and just stitching together the few libraries you need. This will probably feel a lot more like node. Java web frameworks tend to be very heavy. My recommendations **Web Server** - http://undertow.io/ Very fast non blocking web server. Gives you access to very low level code if you need it but the normal use is very simple to use as well. **JSON marshaling** - https://github.com/FasterXML/jackson Very performant API is easy to use and tons of resources can be found. **Configuration** - https://github.com/typesafehub/config or https://commons.apache.org/proper/commons-configuration/ Both work well and have decent features. **SQL / JDBC** - http://www.jooq.org/ with code generated daos for crud operations. If you know SQL its much easier to learn jOOQ than to learn Hibernate. **Metrics and Health Checks** - http://metrics.dropwizard.io/3.1.0/ can't really beat this library
What if, like me, you come from a different language and can be a lot more efficient with your code with naming conventions you are used to? 
Starred and watched ! What is your coverage of the API at the moment ?
I say you stick to the language conventions 99% of the time, especially if working on an open source codebase. If working on a shared but not public project, stick to local (the people you are working with/for), then language conventions.
What remains is Private Messages, Multies and Wikies. Private Messages are next. These are the things I rarely use so they are not implemented yet. There are some other Subreddit moderation, settings and flair endpoints not implemented yet.
How complex of stats? Most of the big data, statistical analysis is going to be in Scala/Spark, Python, R, or Hadoop in industry.
Thanks for the advice. Is there any negative impact of using Integer ? I also always use List&lt;String&gt; ArrayList instead of arrays.
Please don't have packages by type. Create packages by features. Packages should contain an API. Controllers or exceptions are part of the API. Use subpackages for specializations (implementations) or extensions to the API of the upper package. Your packages should be structured by domain, like subreddit, thread, user etc. I bet, you would automatically break up your Reddit interface. Its too huge. Your API should lead the user through stuff. For instance, you need to authenticate before you can make new threads or add comments or read your profile.
Mostly personal preference. The Daos generated by jOOQ cover all the crud cases and yes it does look like QueryDSL is very similair to the jOOQ DSL. It only took me a few days to be able to work with jOOQ well.When I first learned Hibernate it took several weeks to learn the ins and outs of the caching, flushing, criteria builders and all of that. jOOQ just feels much more natural to me and I feel like I have more control without needing to learn a huge framework. I'm also not a big fan of the proxy objects Hibernate uses I like to keep my stack traces as minimal as possible. I don't like magic going on behind the scenes.
I am actually using it in a spring-boot website too, that's the reason I wrote it, and to learn about Java JSON deserialization.
That is really good to know about, because J2EE is on a lot of job listings I see. I saw in a comment recently about the name being changed to JEE, so would JEE also be obsolete, or just the actual older J2EE? 
JEE (Java EE) is still a thing: http://www.oracle.com/technetwork/java/javaee/tech/index.html
Check these guys out. We just started using them at work recently I love it. Priced well and the best part is you write just raw SQL with a few extra templating / filtering features. https://www.periscopedata.com/ Theres also http://www.tableau.com/ and a few others You must be comfortable with your data syncing to their dbs though.
Integer is a class type, and therefore references to instances can be null. Unless you want nullability, you should favour int.
Watch http://vertx.io/ ...and Kotlin ;)
that worked thank you!
You will want A LOT more javadoc. I don't see any now, at least nothing beyond generated doc. The Reddit interface is way way way too big. You are inconsistent in your language standards, again in Reddit, you are using camel casing for so method names. Avoid using enums as method parameters unless it's something that will all but never change. Use String instead, if you want to back that with constants or an enum that is fine, but with you methodology if a Reddit adds a new moderation type of whatever you will have to release your code again and whoever uses will have to update it to use the new moderation type. You are catching and eating exceptions in some areas (OAuthClient line 151), should be thrown or at least logged (probably an oversight). You are making a lot of classes final. Do you really not want to allow anybody to extend a class? (Worst offender would be RedditApi) What does the "T" in "T1" mean? Can you give a better name? Also including numbers in a class name in discouraged, you should spell out "One" Use PostResponse instead of PostReturn and PostBody instead of PostData. Why do you have controllers extending model classes? Controllers are singletons and are concerned with directing the flow of an application. Data models are not singleton and contain state. They are two fundamentally different things and one cannot extend the other. More pendantic, but your controllers are RESTful.
Same goes with the underscores
Check out sonarqube too. Pretty easy to setup and scan your changes by using the maven plugin. It will help identify all of these style convention issues and more.
You have the Reddit interface, but then you implement it with RedditApi and then hard coded that reference into your controllers. Either there is no point to having the interface as only one implementation can ever possibly exist or you need to allow a way for a client to define and use their own implementation of Reddit. I would suggest changing the interface name to RedditApi and RedditApi to DefaultRedditApi. RedditApi.getInstance() is coded dangerously. Could easily result in a lot of NPEs.
You are right, I never intended for more than one implementation, so the Interface's only "purpose" if you can even call it that is to serve as a list of all the methods...I guess I will remove it. &gt; RedditApi.getInstance() is coded dangerously. Could easily result in a lot of NPEs. Can you elaborate on that, why would it cause NPEs ?
That would be wonderful! The code would become so much more readable. 
&gt;Good point, hadn't thought about it that way, I guess I wanted enums because it's less error prone, it's going to auto-complete while with string parameter you have to remember the exact string and can make a typo. Like i said, if you want enums/constants to provide guidance/help developers from making mistakes, that's perfectly valid. I just ran into the issue I described many times. &gt;I am not at all familiar with javadoc yet, what you see was auto generated by the ide, I should look into that. Yup its definitely useful and really required if you are developing a truly public API. When a tool tip pops-up with information when you are hovering over a class or method name, that's javadoc. It's extremely useful in helping to describe to developers how your application/code works. &gt;These are the official reddit's names for their "Things", for example a comment is t1, while a link is t3. Hmmmm.... So this ultimately gets to the underlying logic behind my initial comment. I am a huge believer in making code as self documenting as possible. Give good descriptive names to classes, methods, variables, and make sure that all handle one concept and your code will be much easier to understand to any other developer. Had Reddit named "T1" "Comment" it becomes imminently clear to any developer remotely familiar with reddit what the class Comment defines. Ultimately I guess you are somewhat handling this issue when you are subclassing T1 with Comment. But again back to my point, by using T1, reddit now requires a developer to go look at documentation to understand what T1 defines and that slows down the process of understanding what an application is attempting to accomplish. Now going directly to the issue at hand, because reddit decided to name the class that defines a comment as T1, I guess you should continue using that name as well. Though this is where javadoc comes in, which you are actually doing in this case, so good job! &gt;Because I couldn't think of any other way to get the behavior I wanted. For example here I am getting a Subreddit object: Subreddit amSubr = red.getSubreddit("ShitAmericansSay"); &gt;and I wanted to be able to call methods like this: amSubr.subscribe(); &gt;instead of something like this: rApi.subscribe(amSubr); &gt;Was this a bad idea ? Yes, its a pretty bad idea. Models and controllers are two fundamentally different concepts and its entirely improper to have one extend the other. At best it will make your application inefficient and difficult to understand to client developers at worst it will lead to a lot of weird and unusual behavior. Unfortunately I have some errands I need to run and don't have time to get into this subject right now as really explaining why its wrong (so you can learn and become a better developer, which what I am hoping I am helping in some small way with these comment) instead of banally saying its wrong will take some time. 
Oh joy, Here we go. Junior Java Developer -- Entry Level Here at terrible corp our motto is to be different than the competition. Do you like working hard hours for little pay? Look no further! We have a position available for you! Requirements: Must be under the age of 23 Must have at least Bsc Computing Science Must have 15 Years of Python 3 Experience Must have 15 Years of Android Dev Experience Must have 5 years apple Swift experience Must know the following programming languages: HTML, XML, JSON, CSS, CSS3, HTML5. 
Hmm, I hadn't thought of it like that but it does make sense. I just started getting into Spring Boot last year but JavaConfig is probably more what attracted me to it I see now. The single Jar deployable is nice too.
There is a definite performance impact in using Integer over int. Under the hood, using Integer result in a lot of conversions and object creations. int on the other hand is a primitive type, and is mutable. So there no object creation or type conversions going on with int, and primitives do not need to be Garbage Collected Primitive Wrappers should be avoided unless you you have a specific need for them.
Do you have any link to that? My google-fu is weak
http://docs.spring.io/spring-boot/docs/current/reference/html/howto-traditional-deployment.html#howto-convert-an-existing-application-to-spring-boot
Or the book Clean Code by Robert Martin. Not bashing the code here just adding another great resource for some softer coding skills / best practices.
I think the age requirement is illegal here in the states.
Controllers should have the Controller word as part of their name. 
Ya, you can't ask someone if they know CSS. But if they volunteer that they do....
You can circumvent that with: "Must not have any exposure to or knowledge of or experience in C, at all"
I was looking for gratuates around my area (Adelaide, Australia) and posted this a few days ago: I’m opening a position for a Java Core Programmer at my company, uniVocity (address details here). We build open-source and commercial Java libraries used in processing and migration of data in all sort of formats and volumes, and also provide services using these libraries to clients around the world. We strive to build the absolute best, most feature-complete and fastest libraries. Our open-source projects are being a tremendous success, with [unVocity-parsers](https://github.com/uniVocity/univocity-parsers/) having more than 200K downloads/month. We are looking for candidates who: * Are NOT interested in web development (at all). * Are GREAT algorithm developers, able to understand and create custom data structures based on graphs, stacks, queues, trees and binary trees (if you ever questioned when/where you’d use such things in your professional career, I got a surprise for you). * Are able to use Java to build solutions involving concurrent/distributed processing (threads, yay!). * Have some experience using SQL, JDBC and a few different databases. * Know a bit of Test-Driven-Development and how to build unit-tests that actually test something. * Are PASSIONATE about coding and have pet projects on a github/bitbucket account with code I can look at (we tend to like games). * Know how to refactor code to make it reusable, readable and FAST (we micro-optimise the shit of our code). * Can create a compiler in a weekend. If you are up to a challenge and really love to crack difficult problems, send your resume to (my email). ---- Once you get a response, send a few screening questions to make sure the person can actually perform the sort of work you need. In my case I sent a few questions asking for: - a basic implementation for a problem of some sort, and test cases for the solution proposed. - some code to be improved - a written opinion on how to improve a few other snippets of code Use that to filter out the weeds, and invite those who gave you decent answers for an interview. I'm following up with a pair-programming task with me.
Spring and Java EE has everything included. But you should start from Servlets - this is the thing that is used in both of them. You also can use Undertow to try out Servlets, see https://github.com/undertow-io/undertow/blob/master/examples/src/main/java/io/undertow/examples/servlet/ServletServer.java. Websocket support is also a part of Servlets API. For background tasks you have multiple options in java depending or your needs: async request processing in Servlets, scheduled tasks in Spring/Java EE, batch processing in Spring/Java EE, ManagedExecutorService, JMS, Hazelcast supports tasks too, etc. For REST API JAX-RS is a standard with notable implementations like Jersey and RESTEasy. Dropwizard adds to this. For ORM JPA is a standard, but I'll vote for QueryDSL - due to its code generation I found the experience is more like in dynamic languages like Ruby or JS comparing to JPAQL (And Criteria API is too verbose). Vert.x is more like Node.js.
Why must you not be interested in web development?
I think for next time you, as a beginner, should probably first post this on /r/javahelp and ask for reviews. /r/java is mainly for Java related news and discussions. So to give you some feedback: * You use a Singleton RedditApi instance everywhere in your code. This is a huge [anti pattern](http://stackoverflow.com/questions/12755539/why-is-singleton-considered-an-anti-pattern). There is no need at all to do this; use dependency injection instead. * Please follow the [official naming conventions](http://www.oracle.com/technetwork/java/codeconventions-135099.html). For me this alone is reason enough to not use a library. * Your API is just a translation of the JSON structure to Java objects. That's not what an API should be. An API should make the life of the programmer as easy as possible leading to better and more readable code. I would urge you to redesign your public API for ease of use if you want people to use it over an established API like [JRAW](https://github.com/thatJavaNerd/JRAW). * There's a huge lack of documentation.
This, and i hate the shit out of it.
Excellent! Do I get this right, it won't be part of Java SE (like JAXB) although it can be included explicitly?
"This JSR will work with Java EE 7 and will be targeted for inclusion in Java EE 8." - Seems like it aims to be included in EE, but not by default in SE, maybe because SE inclusion is much harder to attain.
Why not start small and write a Brainf**k interpreter with this?
Or a SQL parser!
Good idea, then we can easily port a brainfuck port of the JVM! Simulated in Javascript of course.
Bad naming. This is going to be confused with Postgres JSONB every time you google it: https://www.postgresql.org/docs/current/static/datatype-json.html 
We have one of these already no? Jackson does a pretty admirable job. 
&gt; for most simple selects The emphasis here is on *most simple*
Note that addition, subtraction, and multiplication of two's complement numbers (what Java uses) use the same algorithm for both signed and unsigned. So performing an unsigned add/substract/multiply of two `byte`s does not require that they be expanded and masked to types that can store more bits. So provided the programmer knows of the expected data type, then using for example `char` or `short` to store unsigned `byte`s is not needed, you only need `byte`. However it must be masked manually if it is meant to be zero extended when promoted. 
And anyone trying to use something like that in an enterprise environment (ie where Java has the most used) should be fired on the spot.