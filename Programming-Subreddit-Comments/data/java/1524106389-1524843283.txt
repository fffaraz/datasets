No... You have to pay to get long term support of the non LTS releases.
Wow what a great response. Not something I usually say on reddit. Thanks
Based on this it looks like you have to pay for Java 11, period, and the free OpenJDK builds will stop after 6 months when 12 is out. https://medium.com/codefx-weekly/no-free-java-lts-version-b850192745fb In other words, if you want to use an LTS release starting with 11, you have to pay - period.
The difficulty here, as I see it, is that the next LTS release of Java, Java 11, is due out in September. So depending on when in the month it drops, businesses will have at most five months to transition to Java 11. That's not an overnight timeframe but it's not super long either, especially for businesses which do biannual release cycles. I agree with the principle of pushing people off old releases, but this feels more like it's intended to get as many people as possible onto the faster release track which I'm less enthused about.
Been using it for 4 years, still have no idea how it works.
It is not my fault, I use the same link Oracle providing me when using Java Control Panel
I still use 7
My concern is you want to go from one LTS to the next (Java 8 to Java 11) they are giving you only a couple of months of support to do the switch. Java 11 is not due until 9/2018 (and that's only if it's on time).
What does this all mean for those of us who just want to use java at home?
&gt; trivialy Oh boy.
The Enterprise version of anything is rarely improved performance and smaller footprint
Because you used it in 2004, didn’t like it back then, and assume it has never been improved in 14 years?
If only migrating to java 9 wasn't so difficult. Java 8 will stick around a long time
Then those businesses are free to pay Oracle gor updates.
Kotlin hype since 2011?
Don’t you mean free updates will stop when 17 comes out? LTS is scheduled to last three years. 
So to sum up, LTS versions are mainly oracle jdk for which you have to pay, or you can use open jdk, but get support only for 6 months. Correct?
What does support mean in this case? Someone to ask for help, or new security fixes like java 1.8.0_151 --&gt; 1.8.0_152? 
That still appears to be unannounced, but at least in some presentations it has been hinted that LTS won't be free. I guess we'll just have to wait and see until Oracle announces their plans...
You can use RxJava to some extent.
Migration to jigaw/newer java should be done months ago, it's not like we were warned yesterday about new breaking changes or java 11. Companies had literally few years to do that. 
Looks like it will only affect LTS, they will be supported for a few year, in case of j8 almost a decade. Java 9 is now Eol.
What does JSF mean now? Jakarta Server Faces?
OpenJDK from http://jdk.java.net/10/ is entirely useless for me, because it [don't have all](https://bugs.java.com/view_bug.do?bug_id=8189131) SSL certificates in cacerts file. This means I can't connect to some https:// pages from Java...
&gt; If you are a CONSUMER using Java for individual, personal use, you will continue to have the same access to Oracle Java SE 8 updates as you do today through at least the end of 2020.
We need to stop using File::delete. It's a terrible API, because there's no way to discover the error. All you get is a boolean that an error occurred. The NIO API is much better designed. Basically, prefer `Path` and `Files` over `File`. If lambdas dealt with checked exceptions, you could do: Files.walk(path) .sorted(Comparator.reverseOrder()) .forEach(Files::deleteIfExists); But, no, that's far too easy. Wrapping Files::deleteIfExists with a function that converts checked exceptions to unchecked exceptions is probably preferable to the version demonstrated because it provides better error handling. But then a single error will fail the whole operation, so you might want a custom delete method that handles each individual failure. 
honestly, fuck gradle.
What if you used JSF in 2015 and don't like it any more than JSF in 2004? There are quite a few people who don't like JSF, although I personally wouldn't call for s technology to be retired if I personally don't like using it.
&gt; I'm curious why this has suddenly popped up here, it was announced a while ago. I estimate that probably 90% of Java developers (and nearly 100% of critics and casual observers) have absolutely zero true understanding of Java governance, release plans, licensing, legal matters, etc. As slow moving as Java has always been, that stuff is just is dry and boring to people. And Oracle and the community tend relay the information in dry, boring ways... not being known for the snazzy dynamic websites, with huge pictures and minimal words, that it takes to hold people's attention spans these days. This post is old news, but those like it will keep bubbling up, because: 1. A lot of people are out of the loop, and still don't really know anything that's happening with Java versioning, and 2. "_Oracle is doing something that sounds evil_" will always be worth a few upvotes on social media (which frankly, Reddit is becoming)... and that's both fun for commenters, and validating for posters in the form of upvotes. Really, I'm just surprised that this thread hasn't been hijacked to talk about the Ask.com toolbar yet.
What did it do to you?
You can customize your ca, you know 
Touché
The [AdoptOpenJDK project](https://www.adoptopenjdk.net) is stepping up to produce binaries for OpenJDK Java SE 8 for as long as the OpenJDK source code stream is maintained. I fully expect those who have many customers using Java 8 (Red Hat, IBM, etc) to continue offering support for their users, and making those updates available through OpenJDK &amp; AdoptOpenJDK.
For a lot of companies what you're asking is an extremely hard sell. There is a reason so many people are still working with Java 6 and 7, and it's not because they want to. Older versions of Java (including 8) are safe and stable, which is what many companies want. While I agree we should all strive towards J9 and beyond let's not downplay the difficulty in getting there
I don't do pre-8 projects anymore. 
&gt; You can customize your ca I cannot say such thing to the app users ;) Probably I just "borrow" entire /etc/ssl/certs/java/cacerts from Ubuntu...
There's many variants of not liking it. There's actually not liking it, there's not liking it because of not knowing it, there's not liking because your peer group tells you not to like it, etc etc We all know it somehow became popular to not like JSF, and that's why I ask so often "Why?". And you'll often see people can't really say why they don't like it. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Java 9 broke so many things out of the box. It's going to be very non-trivial to "upgrade to java9/10/11" for most large Java organizations. In some cases, those changes are 1 way (meaning you have to not use Java8 after upgrading). While this is fine for a server-side app where an organization controls everything, it is less doable for organizations that produce enterprise software where they do not.
[This](https://docs.oracle.com/javaee/5/tutorial/doc/bnaqq.html) is why I don't like JSF. JSF has an extremely stateful lifecycle, where bean state in one phase can have side effects in other phases, such as a UI component not rendered in the Restore View phase causing action events from not being invoked in the Invoke Application phase. BalusC has been an invaluable resource for me when something about the lifecycle got me stumped. This is not a problem I have *only* with JSF, but pretty much any server-side component oriented framework, such as WebForms in Microsoftland and Wicket in Javaland. Although, I like Wicket better than JSF aesthetically, since I think Facelets are ugly, but I would actually *use* JSF instead because, being the standard, it has plenty of library support like OmniFaces and PrimeFaces. *In my experience*, I have found action oriented frameworks to be far easier to work with than component oriented frameworks. You may say that action oriented frameworks have their own lifecycles, but I *prefer* the action oriented way. 
&gt; I mean... Are we going to have to pay to use Java? It won't be free anymore? There had always been a paid edition by Oracle (previously SUN) that included security updates for older versions. For example, you can still use Java 6 (I think?) or 7 and get updates if you pay Oracle. And, there's always the free (GPL) OpenJDK, which can be used instead of the Oracle JDK. What's new is the versioning scheme and the publishing roadmap. Essentially, if you want to use Java for free, you might need to update a bit more frequently in the future.
\&gt;Does it output statically linked binary like Go does? Similar, yes, with the native\-image command [http://www.graalvm.org/docs/getting\-started/#native\-images](http://www.graalvm.org/docs/getting-started/#native-images) \&gt; Can it perform cross compilation? Out of the box: no, not really. In theory: I think it is possible.
probably gave him a foot shooting gun.
What’s stopping someone from forking it and allowing such PRs?
Maybe Hazelcast?
lol nobody can code Monopoly in an hour. If you're serious, you might want to consider paying more than an hour's wage.
Do your own homework.
If you don't need GUI (and any other interface for that matter) then I think 1-2 days are possible. But seriously, if I were to implement monopoly, I would change it so that TM would not apply, release it on some Play Store or Steam and hope to milk from it much more than $70.
Their _latest_ OpenJDK 10 build listed on the front page is from November 2017! There are newer _nightly_ builds but I'm not sure which are production ready.
It's pretty neat! How are you handling the security bit? Biggest downsides is lack of intellisense and that it's rather slow I guess. 
1) 70 dollars is an insulting amount to most professional java developers, that wouldn't cover an hour of my time. 2) do your own homework, talk to your professor they'll probably give you an extension if you're upfront with them. 
Literally cost me weeks of development time as we fought our fucking build system.
LOL, my rate is 94$/hour... I'm sure I won't finish that game in 45 minutes.... I think I'll stop developing for money :\(
Yup, no JDK 5 for SCO OpenServer or HP-UX 10...
Awesome. Any chance to self host the thing ?
You want ~2000-5000 lines of working code, and have barely over 48 hours to do that in. Very unlikely to succeed, but... Look at the bsdgames package. Written in C but [monop](https://github.com/vattam/BSDGames/tree/master/monop) has a playable game. You can get a general idea of game play from that. You won't be able to directly transliterate it to Java, but the general ideas can lead to a reasonable class structure: Play, Card, Jail, and so on.
I am sure it has improved. However, I think the concept is flawed. Personally, I won’t invest my time in technologies that don’t have the following things going for them: 1.) Jobs: not just quantity but quality. 2.) Community: I prefer a vibrant community with thousands of contributors. 3.) Corporate support: I like to see companies paying people to contribute to the project. I don’t have an interest in spending my time on tools of yesteryear. I’m sincerely glad you like it though. I’m sure it will be easier to contribute to the project now. 
I appreciate you mention it's a personal opinion and that action oriented has some lifecycle as well. That said, in JSF specifically "lifecycle" is often used as those words to beat JSF with, even by people who barely know what it is (not saying that's you, but just in general). Truth is that the scary "lifecycle" actually when you look closer does a lot of things every web framework does. Loading a template, grabbing and validating the request parameters, letting the application call business logic and finally rendering the result. All those steps themselves are hardly anything special. Perhaps JSF biggest fault was in trying to be helpful and giving those steps a name and drawing them up in a diagram. This seemingly has scared a lot of people. Maybe the entire concept of "lifecycle" should be removed from the JSF spec, and it should just say: "JSF loads a template and renders it. In between you can call your own code, oh, and request parameters can be validated for you". Same thing, but sounds far less scary. Of course, when we really go into the technical aspects, there are some differences indeed, but the majority of people don't even reach that point. It's lifecycle! Peers told us to hate it! RUN!
of all the things to add... Why bother? I don't buy the explanation in the ticket.
Not only is this subreddit not for help with *Java programming*, but it is also strictly forbidden (in all programming related subreddits) + to ask for your homework to be done + to offer rewards of any kind Both of the above are bannable offences in the programming related subreddits. You might have more luck in /r/domyhomework but you'll most likely will have to offer a lot more since the extent of the work is rather high. **Post removed**
**Sidebar** + **Do not post tutorials here**; these are supposed to go in /r/learnjava Post removed
&gt; Truth is that the scary "lifecycle" actually when you look closer does a lot of things every web framework does. It's not *what* it does, it is *how* it does it. &gt; Loading a template, grabbing and validating the request parameters, letting the application call business logic and finally rendering the result. All those steps themselves are hardly anything special. This is extremely reductionist and obscures the major differences between action oriented frameworks and component oriented frameworks. Action oriented frameworks map a URL to a controller method, grab and validate the request parameters into a model object and call the controller method with the model object, and then render the template from the response based on an output model. Component oriented frameworks load the template from the URL and use it to build a component tree, the component state being derived from the request parameters (and other state), and the component state drives the business logic that is triggered usually through event handlers. In JSF, this has consequences, such as if the bean mapped to the `render` property of an `h:commandButton` gets set to `false` during the Restore View phase, the method mapped to the `action` property will not be called during the Invoke Application phase. So, you have to be very aware of what you are setting when so that JSF behaves the way you expect. I have had enough problems with JSF that I have a go-to guy, BalusC. There is simply a lot more going on in the JSF lifecycle than typical action oriented framework lifecycles, so much more although I have used JSF on and off for the last 10 years, I still don't know all the pitfalls, whereas I can usually get proficient in an action oriented framework in a weekend. &gt; Same thing, but sounds far less scary. Yeah, JSF is a lot scarier to me than Spring MVC or Struts.
How does this compare to the likes of Liquibase? I've been using that in production for a few months and I like it a lot but has some issues and is hard to get used to in the beginning.
I think it's awesome, I wish they'd add filterNot to Optional and Stream as well!
wish I could use arrow keys and TAB
It doesn't matter. Let them add it.
It would be awesome if they would unify monadic types instead of that. Something like `Option` in vavr.
We need to separate helpers from core APIs, I think. Because if you start slapping those helpers on everything, then everything that implements those interfaces have to implement all the helpers. This is why C# extension methods are that good. You can keep the core simple, and then pepper it with whatever B.S. your heart desires on a file by file basis.
Indeed. I would rather they add chaining of streams. Definitely need that one.
It's more useful to think of 9 and 10 as release candidates for 11. Welcome to the new LTS universe.
Nah, they can just be added as default methods to the interface, then subclasses only need to implement them if they wanna change them :)
It is my understanding that Red Hat will provide help and patch new security fixes as with any RHEL supported software. More information can be found [here](https://access.redhat.com/articles/1299013#OpenJDK_Life_Cycle) and [here](https://www.redhat.com/en/about/subscription-model-faq). 
Lets just add Extension Methods so we dont need to wait for entire JDK releases to tweak things like this.
JSF seems to tick all those boxes ;) There are the jobs, there’s the contributors, just look at the community surrounding JSF with PrimeFaces, OmniFaces, BootsFaces, Liferay, etc. look at PRs and issues that are created for each of those projects. And there’s corporate support too, look at IBM, Irian, Payara, Liferay... It’s definitely not yesteryears tech. JSF has existed for a long time and is still useful. Of course, if you’re the person that wants a new shiney JS framework every week, and wants to recode everything every week, then JSF is not for you. But if you like stability, performance, ease of use and just getting work done, JSF works pretty well.
From the ticket: &gt; Generally we avoid adding methods that are simple inverses of each other. For example, there is String.isEmpty but no String.nonEmpty, and there is Collection.isEmpty but no Collection.nonEmpty. It actively argues against the creation of this exact thing! It goes on to say that null-ness is more important or something... I don't buy it. It's an API to use, adding ! isn't something new to Java. 
I don't know their reasons, but sometimes you want to say ... .filter(Method::reference) and there's no boolean counterpart method. p.s. But assuming this I can't imagine a use case when I'd need to, say, filter(Optional::isEmpty).
As I said, I am glad you like it and that it supports your requirements. I think this announcement is another indication that Oracle has a particular vision for Java. They apparently don't want to spend any engineering dollars on this and other Jave EE projects; unless I misunderstood the transfer of ownership.
You should really be creating your own wrapper over these things if you need to change implementations, you can.
You can time it, or you can use the view scope ;) Action frameworks have other issues, such as not necessarily knowing what was rendered upon a postback, keeping track of what widget responded, etc. It’s not for nothing action frameworks have looked at several JSF concepts regarding scope, ID assignment, locales, etc
Run doesn't work, but Check does. FAILED: Program.main([Ljava.lang.String;) java.lang.NoSuchMethodException: Program.main([Ljava.lang.String;)&lt;:LF:&gt; at java.lang.Class.getDeclaredMethod(Class.java:2130)&lt;:LF:&gt; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;:LF:&gt; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;:LF:&gt; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;:LF:&gt; at java.lang.reflect.Method.invoke(Method.java:498)&lt;:LF:&gt; at clojure.lang.Reflector.invokeMatchingMethod(Reflector.java:93)&lt;:LF:&gt; at clojure.lang.Reflector.invokeInstanceMethod(Reflector.java:28)&lt;:LF:&gt; at codewars.runners.java$fn__591.invokeStatic(java.clj:93)&lt;:LF:&gt; at codewars.runners.java$fn__591.invoke(java.clj:87)&lt;:LF:&gt; at clojure.lang.MultiFn.invoke(MultiFn.java:229)&lt;:LF:&gt; at codewars.runners$run.invokeStatic(runners.clj:21)&lt;:LF:&gt; at codewars.runners$run.invoke(runners.clj:17)&lt;:LF:&gt; at codewars.core$_main$fn__664.invoke(core.clj:40)&lt;:LF:&gt; at clojure.lang.AFn.call(AFn.java:18)&lt;:LF:&gt; at java.util.concurrent.FutureTask.run(FutureTask.java:266)&lt;:LF:&gt; at java.lang.Thread.run(Thread.java:748)&lt;:LF:&gt;
&gt; You can time it, or you can use the view scope ;) Don't even get me started on view scope. The first time I used view scope, the `@PostConstruct` method mysteriously got called multiple times, and I couldn't figure out when the bean was being instantiated multiple times. Thankfully, BalusC came to the [rescue](http://balusc.omnifaces.org/2010/06/benefits-and-pitfalls-of-viewscoped.html). Apparently, there was a bug in JSF 2.1 that caused the bean to be instantiated twice. &gt; Action frameworks have other issues, such as not necessarily knowing what was rendered upon a postback, keeping track of what widget responded, etc. You do things differently with action frameworks, more in line with HTTP than UI. The output model controls what is rendered on postback. What widget responded is irrelevant to an action oriented framework, because processing is driven by the URL and the input model. If you prefer working within the UI metaphor, I can see the attraction of JSF and component oriented frameworks in general. If you don't like working within the UI metaphor and prefer the request/response model, JSF is maddening.
I hope [StringBuilder.isEmpty](https://bugs.openjdk.java.net/browse/JDK-8181398) will be added one day, too
In comparison: 2025: Java FTW 2030: Java FTW 2040: Java FTW
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
How frequent are the messages? If they're beyond the ability of the database to update, you will need to rearchitect the application.
I had plenty of WTF moments with Struts... in 2001. I remember form action beans or things like that, which were very tedious to maintain. But I assume Struts has changed somewhat since 2001. I also remover Rail’s mass assignment vulnerability, a good WTF, again in an action framework. And already mentioned the high stress Thymeleaf + Spring MVC put on the GC, leading to a rather high amount of memory in use at any moment and high cpu for cleaning it, another wtf, again in an action based setup. And you’re missing the point wrt the model used. There’s an impedance between applications having UI elements and the web being designed for hyperlinked documents. There’s, like you do mention, several approaches to bridge this. Action is not simpler overall, as it moves complexity elsewhere. Sending JSON to a client application is when you think of it even more alien to the original web, and has its own problems too. Long story short; there are at least 3 different approaches and neither one is really “the best” or “yesteryears” approach, and neither one should be universally hated.
The kind of WTF the moments you are talking about are not the kinds of WTF moments I am talking about. Every framework has some kind of security vulnerability or another, which get addressed over time. I am talking about *developer experience* with different kinds of frameworks, and my experience with JSF has not been pleasant, which is why I avoid it. You may have had different experiences, but I am not questioning your experiences. &gt; There’s an impedance between applications having UI elements and the web being designed for hyperlinked documents. Irrelevant. At the end of the day, what is served to the browser is HTML. And the browser makes HTTP requests to the server. If it makes *you* more comfortable to transform HTTP requests to UI components and events, then more power to you. There are plenty of others who prefer to stay closer to the HTTP request/response model, which obviously works just as well. &gt; there are at least 3 different approaches and neither one is really “the best” or “yesteryears” approach, and neither one should be universally hated. You're missing the point. Obviously, there are many ways to do things, and there are people who prefer some ways to others. It is okay for me to hate JSF, because that reflects my experience with it. And, as I stated, I wouldn't let my personal preferences judge that JSF should be retired, and I wouldn't let my personal experiences with JSF judge others experiences with it. This sub-thread is more a reaction to /u/henk53's comment that people who hate JSF hate it because they don't understand it or because other people told them to hate it.
I've been wrapping the call with a not, `.filter(not(S::whatever))` https://google.github.io/guava/releases/23.0/api/docs/com/google/common/base/Predicates.html#not-com.google.common.base.Predicate- 
good call there...
Please tell me you're joking.
Having experienced extension methods (in Kotlin), I'm inclined to agree.
`Stream.concat`
&gt; StringBuilder().toString().isEmpty()
Why the clickbait title? The URL itself is a better title: https://blogs.oracle.com/developers/javaone-event-expands-with-more-tracks-languages-and-communities-and-new-name
Looks like you used clojure. What else? Pretty good portuguese i18n BTW.
Ahh, the old 'add an unnecessary dependency" solution.
nothing to stop you from making your own... also, is the alternative to alter the language? Seems overkill... but w/e - I'm not losing sleep...
`Stream.concat` only accepts 2 parameters, I don't know why they didn't use varargs here like they did for `Stream.of`. So for 3 streams or more you have to do something silly like ``` Stream.of(stream1, stream2, stream3) .flatMap(Function.identity()) ```
&gt; I'm curious why this has suddenly popped up here, it was announced a while ago Because some of us non-developer data workers just updated our installations of Java, and got this scary message that made us scramble to Reddit to ask, "Does this mean we'll need to pay Oracle just to run .jar files on our work computers?"
No shit. 
Java is more than big enough to have a full conference dedicated to it. Making it a go/rust/python/JavaScript conference is oracle trying to chase all the cool kids and deluting Java.
If it literally requires you to have a mutable Java bean, then you're out of luck. But I'd recommend poking around Spring 5 and seeing if they've relaxed that requirement.
&gt; You also create UI widgets in a document The concept of UI widgets only makes sense in the browser, which interprets renders HTML and executes the JS to implement the UI behavior. The server serves merely serves HTML and the JS. If you want to replicate the UI widgets on the server, go ahead. But that is in no way a requirement. &gt; and have to track manually where a request originates from. How does that actually work? It's an HTTP request. You can generate the component tree and map the request to some component. Or, you can map the HTTP request to a controller method and input arguments, without any understanding of the UI at all. &gt; Why is that irrelevant? Ultimately, it is an implementation detail. Thus, irrelevant *to this conversation*. &gt; At the end of the day all approaches are doing http requests. Your approach is not more http than my approach, is it? Depends on what you mean by "more HTTP". If you put it that way, yes action oriented is much "more HTTP". HTTP is request/response. Action oriented frameworks are just converting HTTP requests into models, executing a function mapped to a URL, and returning a model which gets rendered into a HTTP response. This is a natural mapping. Component oriented frameworks translate HTTP requests into UI component model and UI events, which is entirely different than HTTP. Its like how ORMs map the relational model to an object model. &gt; I think there’s truth into the statement that people hate or love things because of peer pressure. Yes, but people also don't like things because they can think for themselves. To dismiss someone's opinion because it's just "peer pressure" is extremely disrespectful. Obviously you are a JSF fan. Note how am I not dismissing your preference as peer pressure (you only like it because its the JavaEE spec, for example) or lack of understanding of action oriented frameworks.
Uh, no. But it does mean that the interface problem goes away. That's all I was saying.
It's a larger trend, especially now with default methods, I see lots of helper methods around the standard library. I don't like it when it's an interface, I don't like it when it's a class, and I don't like it when it's a final class. The larger point I made, but I guess in another comment in that thread, is that these helpers are often specific to a developer's workflow, they are in very high count (you can always add one more helper), and they obscure the core purpose and function of the object you're working with. As such, a C# style extension method feature would be a much better approach to helper methods.
So, we've added a method that is essentially `!Optional.isPresent()` ?
&gt; Action oriented frameworks are just converting HTTP requests into models, executing a function mapped to a URL, and returning a model which gets rendered into a HTTP response. This is a natural mapping. A truly natural mapping is an HTTP request returning a static HTML document. That's the only way the web was designed. Everything else is diverting from the one-and-true mapping. &gt;just converting HTTP requests into models, And component based MVC frameworks just convert HTTP requests into values set on component. You know, those same components via which the HTML was rendered in the first place. It's the same natural mapping. URL maps to controller, controller chops up the request into manageable pieces (call them models, call them component values, call them server side includes), process them and render the response. &gt;Note how am I not dismissing your preference as peer pressure (you only like JSF because it's the JavaEE standard, for example) or lack of understanding of action oriented frameworks. You're not doing that, but you do have somewhat of a tone of action frameworks being more natural and less hate-worthy. If that's not your intention, then you should perhaps realise that's how you come across. 
&gt;This sub-thread is more a reaction to /u/henk53's comment that people who hate JSF hate it because they don't understand it, because their experience is limited to JSF 1.x or because other people told them to hate it. That's not what I said. I literally said: &gt;**There's actually not liking it**, there's not liking it because of not knowing it, there's not liking because your peer group tells you not to like it, etc etc Read the part in bold again. I included the reason that people actually don't like it.
I really like Liquibase as well. What issues did/do you have besides the ramp up?
That's still relatively tame, especially since it's trivially wrapped into a helper function like concat is anyway.
sounds a lot like ransomware
Just sometimes the changelog files that were generated contained duplicate 'changes' that already existed on the database so had to figure that one out.
this release schedule is insane - java is effectively non-free for commercial use, which is exactly the bait and switch we've been worried about since inception write once, pay everywhere 
Yes
To the people telling OpenJDK is a viable option. Isn't most the development on that also done by Oracle? That means OpenJDK is just considered a playground and things will break a lot and I am sure Oracle could figure out to make it such that in mysterious ways their production releases are you guessed it... better suited for business \(because they do not contain fatal flaws\). De facto this means that every company using Java is going to be royally fucked over the coming years. 
Or switch to IBM's Java 8 which [is supported until 2022](https://developer.ibm.com/javasdk/support/lifecycle/).
On the other hand, it is Oracle investing in something for its benefit too. Devoxx is a great alternative, as many other Java independent conferences. Meanwhile, Oracle needs, just like Amazon, Google, and Microsoft, a developer conference that it can talk about other things. In the end, everybody wins IMO.
In that case, never mind!
So this means that, for a business, we 5 months (starting with September of this year) to migrate to Java 11 from Java 8. After which point, no more patches will be available for Java 8 unless we pay. That sounds... horrible. They're taking a product that many businesses have adopted in part because it was free and trying to force a cost onto it. This is absolutely ransomware. With this rapid release cycle, how long will Java 11 be supported? Yes, it's good to be on the latest version, and we always wish everyone would upgrade faster, but IT doesn't move like that. This move is a slap in the face to Java developers everywhere.
Looks very thin really.... almost more like a 10.0.0.0.0.1 release :)
Ahh interesting. Hadn't seen that yet.
Perhaps, though I'm struggling to find a good reason to visit this code one conference now as Java developer. Before JavaOne was clearly -the- conference, with Devoxx Antwerpen a good second one. Is Devoxx Antwerpen now -the- Java conference, and is code one just a bland conference for, uhm, for who actually? Will Python people flock to it? Who is the target audience now really?
&gt; What is unnatural to the web is that the browser has been turned into a UI platform, making information extraction much more difficult. And both MVC pull/component and MVC push/action gather to that exact same platform. &gt;But the server does not (and should not!) care that the request originated from a UI. Even better, the server *can not* care that the request originated from a UI since a request is a request. There's no magic characteristics other than perhaps the easily spoofably user agent string to determine where the request originated from. In an MVC push application with a rich UI and many tables, buttons, what have you, a postback contains as much "clutter" as a postvack from an MVC pull application. Both types of postbacks can be done from any type of client. A MVC push application does not by definition use "ultra clean rest style requests" (and even if it would, 'cleanness of key/value pairs' is not a rigid definition). &gt;You're confusing HTML with HTTP. HTTP doesn't know or care about HTML. I think you know what I meant, but to be sure HTTP originally was used to return HTML documents. It's in the name; *Hyper Text* Transfer Protocol, not "Whatever Transfer Protocol". &gt;Yes. As a more natural mapping to HTTP. There's no difference there really. In MVC pull a page is represented by /page, while in MVC push a page is represented by /page. In MVC pull a request to /page returns some kind of HTML document, in MVC push a request to /page returns some kind of HTML document. What's the real difference there?
Why did you pick a build system you were unfamiliar with?
This could be pretty expensive if your string is in fact not empty and in actuality a huge array of stuff.
What’s an extension method? 
The ability to seemingly 'add' methods to existing classes. Except in the background they're just static methods with syntactic sugar.
Was looking at introducing this into my SpringBoot app - does roll back work nicely? 
Ahh okay very nice. That would be useful. Just had a look at https://kotlinlang.org/docs/reference/extensions.html
That's not an extension method, that's akin to a Trait system, or some kind of stateless abstract class, like Java's default methods on interfaces. They work differently on bytecode level, and I imagine its the same with .NET.
What you seem to be saying is that you took a course that taught you the fundamentals of computer programming and algorithmic thought, without focusing on the particularities of the Java programming language. If that's a skill you want to advertise to an employer, I'd think about emphasizing the programming part rather than the Java part. That avoids overrepresenting your knowledge of the language while putting forward the useful part of what you learned.
The Trait system in Java looks interesting at first sight! I am not _that_ familiar with Java (but surely not a hater :D). And I am sure there is some compiler magic involved on bytecode level for both languages. However Microsoft themselves are calling them extension methods on interfaces, so I try to refer to the same naming when I am talking about C#. https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods 
If you really want to put it on your resume, I'd put "basic knowledge of Java". That implies to me at least that you know some Java, but not enough to be hired as a full time programmer. 
&gt;Maybe you want to hit Code One and focus on the Java tracks? That's JavaOne in essence (content and people). So the total conference is much, much bigger? Just the Java track is as big as the entire JavaOne conference was, but now there's also the Python track, drawing in all of the world's best Python developers? And then there's Oracle Open World as well?
Sounds like a plan.
TL;DR is at the end: - Switch statements now come in a simpler (arrow) flavor, where there is no fallthrough, no weird scoping, and no need to say break most of the time. Many switches can be rewritten this way, and this form can even be taught first. - Switches can be used as either expressions or statements, with essentially identical syntax (some grammar differences, but this is mostly interesting only to spec writers). If a switch is an expression, it should contain expressions; if a switch is a statement, it should contain statements. - Expression switches have additional restrictions that are derived exclusively from their expression-ness: totality, can only complete abruptly if by reason of throw. - We allow a break-with-value statement in an expression switch as a means of explicitly providing the switch result; this can be combined with a statement block to allow for statements+break-expression. The result is one switch construct, with modern and legacy flavors, which supports either expressions or statements. You can immediately look at the middle of a switch and tell (by arrow vs colon) whether it has the legacy control flow or not. So far, I think this is an excellent outcome. All of switch's flaws essentially stem from fall-through in one way or another, so when you don't need that, an arrow-form switch lets you escape all of those flaws.
Devoxx is already diluted aswell.
With non-lts versions you have one month to migrate if you want to be PCI compliant.
By the time tooling adjusted Java 9 was already out of support.
This looks good. Best of both worlds!
\&gt;So the total conference is much, much bigger? Only attendance level will tell. \&gt; And then there's Oracle Open World as well? It has always been a separate conference with a completely different content and target audience.
This looks great! Do pattern matching next!
A couple of points... 1. 300k rows is not ordinarily a big table. Perhaps yours is, but a table that size usually fits in RAM. 2. You ask for a caching layer, AND you mention a high write load. Do you need a caching layer that also works well with a high write load, or are you looking for one that helps minimize the write cost? 3. Really the most important question I have - what, really, are your persistence requirements? Can writes be delayed? Can they be batched? Can reads return stale data? Ever? Sometimes?
You should probably disallow network access though. Otherwise users could potentially send malicious requests from your server.
Goetz talks about it [here](https://youtu.be/qul2B8iPC-o?t=29m28s).
Have you tried [IntelliJ IDEA](https://www.jetbrains.com/idea/)?
You can probably stream that list now anyway, so the size check may be unnecessary!
Could do `Stream.concat(s1, Stream.concat(s2, s3))` as well.
This is the best way to do it atm `StringBuilder().length == 0`
I use the MetricsReloaded plugin with IntelliJ IDEA, it throws out a lot of numbers. I used to use a plug-in for Eclipse which gave good data as well but I've forgotten the name. 
It wasn't meant as a click-bait title. I just think it's incongruous to use the term "expands" when the new conference will have 8 (out of 11) tracks that are not Java focused and does not include Java in the name. It's entirely Oracle's decision to replace JavaOne with a conference that has a broader developer appeal but they shouldn't try and sell it as this is a better version of JavaOne. It's not.
Build a portfolio of tools you have made. Have experienced developers provide feedback. List the language and give a link to your repo.
Which of those numbers are important for you?
1. True, affected tables can fit in RAM even if actually some tables are much bigger than 300k rows in fact, I'm not considering whole tables but just the single partitions required (still &gt;&gt;300k rows). The other partitions are not needed for all the day long. 2/3. Messages can be pretty frequent, at the moment paying both for the read and the write is a problem. Write (mainly update) is more expensive and can't be delayed much, my guess would be to try to read messages and update cache/in memory DB "real time" and write on the persistent DB asynchronously but with reasonable delay. Messages are the only thing modifying the data, so there aren't many problems with consistency, in case there will be two data sets.
What I would try to do is to try to asynchronously update records, updating single records is pretty expensive compared to the peak of frequency of messages. How far would it be to "rearchitect the application"?
For someone like a database marketeer it's definitely something you should add to your resume. Having some basic programming skills is definitely a pre. 
Which do you feel have been forced?
Why would I be joking? It's a standard we use at the place I work :p We never directly use a standard class and always create a wrapper.
After I "Check" code and the code passes, if I then "Run" it, I get FAILED: Program.main([Ljava.lang.String;) java.lang.NoSuchMethodException: Program.main([Ljava.lang.String;)&lt;:LF:&gt; at java.lang.Class.getDeclaredMethod(Class.java:2130)&lt;:LF:&gt; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;:LF:&gt; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;:LF:&gt; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;:LF:&gt; at java.lang.reflect.Method.invoke(Method.java:498)&lt;:LF:&gt; at clojure.lang.Reflector.invokeMatchingMethod(Reflector.java:93)&lt;:LF:&gt; at clojure.lang.Reflector.invokeInstanceMethod(Reflector.java:28)&lt;:LF:&gt; at codewars.runners.java$fn__591.invokeStatic(java.clj:93)&lt;:LF:&gt; at codewars.runners.java$fn__591.invoke(java.clj:87)&lt;:LF:&gt; at clojure.lang.MultiFn.invoke(MultiFn.java:229)&lt;:LF:&gt; at codewars.runners$run.invokeStatic(runners.clj:21)&lt;:LF:&gt; at codewars.runners$run.invoke(runners.clj:17)&lt;:LF:&gt; at codewars.core$_main$fn__664.invoke(core.clj:40)&lt;:LF:&gt; at clojure.lang.AFn.call(AFn.java:18)&lt;:LF:&gt; at java.util.concurrent.FutureTask.run(FutureTask.java:266)&lt;:LF:&gt; at java.lang.Thread.run(Thread.java:748)&lt;:LF:&gt; Honestly there doesn't seem to be much of a difference between Run and Check. Why not just have one Run button? Then once the code passes, show the "Submit Final" button alongside the Run button. If the text in the codebox changes, hid the Submit Final button again until another Run successfully completes, etc. Then the user can Run as many times as they want, and all Submit Final-ed code is guaranteed to have passed the test. 
I have multiple problems with [this](https://edabit.com/challenge/mDM9eJXqjL7kJc3hh) challenge. If a method accepts exactly two parameters, it should accept exactly two individual parameters, not an array of parameters, since any array can be of any size and the method only wants two Strings. Using regex for such a simple task is needlessly complicated. Anyone reading such code would likely end up having to interpret the regex all over again (especially if it's not documented), whereas looping through the characters is equally efficient and significantly more readable. If this tool is for practicing, it should enforce idiomatic Java, not encourage bad practices. (Disclaimer: don't take my criticism too hard, just trying to provide my honest opinion as feedback)
Concerning the arrays, same with [this](https://edabit.com/challenge/g3zwGCJN5Ti8TSSbh) challenge. Ideally there would be an immutable Circle class with x,y,r fields, and two Circles could be passed as parameters. Barring that, I would argue that six parameters is preferable to two fixed-size arrays. At least with individual parameters, someone coding to the API will have the parameter names for guidance, instead of having to rely purely on documentation for parameter order inside the arrays. 
[This](https://edabit.com/challenge/g7mkKpAtZZ7mnuFQX) is a solid use of arrays. The method is expected to deal with a variable-size input. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Java will be the only compsci language where returning a value is via the keyword `break`? Of well.
Still not enough SQL talks
It _is_ an extension method, it's just an extension method that operates on an interface type. And it doesn't 'automatically' obtain, it needs to be explicitly imported. As for syntax sugar, it absolutely, is. extension methods have no additional access, then calling static methods on a class would have. var myFly = GetSomeIFly(); myFly.Fly(); would be absolutely no different then. ExtremelyLongAndAnnoyingStaticClassName.Fly(myFly);
It's not so much declared **inside** an interface, but an extension method that takes an interface as a 'this' parameter.
Honestly, when it's Guava I err towards adding it then accidentally having 4 different `not's` defined everywhere.
Extension methods annoy the **shit** out of me. One moment a method exists, the next it's gone, oh you wern't searching the entire available classpath for that extension method definition, whoops! You shoulda known that, doesn't your IDE color extension methods differently for you so you can easily recognize them? Honestly, having extension methods use the same object.method call notation is horrendous. I can't think of a better substitute, But I'm sure there's a better solution.
I look at all the complexity numbers. Others which interest me are WMC - Weighted method count (tell me if a class is doing too much) Efferent and afferent coupling - These tell me how far the reach of my classes are. Other numbers I just scan over without paying a lot of weight unless it's really off average. 
I'd call it 'employee security' as opposed to job security. Your employee's know your libraries, and can never develop without them :P.
I thought you made it for practicing C#?
&gt;The worst possible outcome (which is also the most commonly suggested "solution" in forums like reddit)
Differentiating them further in syntax is interesting as an idea, but coloring them differently in the IDE should be enough. Have you tried Rust? It has taken the idea of extension methods and made them the way of doing basically everything (I'm talking about traits). I appreciate the simplicity of "here's the class and here are its methods" but if you think about it, objects should be a representation of how the world works and how we think about it. And honestly not every action we perform on a real-world object is implemented by the object. It just doesn't match. Some actions are contextual and come from outside parties, but preserve the object's encapsulation. Rust traits and extension methods are attempts to capture that aspect of it. 
You're right, if it was the usual 11 tracks (on the same conference space as before), and then an added 8 tracks for Python and Go etc (in additional space/venues), it would be an expansion, and there would just be extra Python talks in parallel to the usual Java talks. Now that's far from the case.
dear mrarthurwhite There are a few tools that do only code analysis, but you can simply install a plugin for your faworith IDE and use the analysis while coding :) To name the moust famous imho SonarQube - Code Analysis, and bad praxis - good praxis examples ! Can work as IDE Plugin but also as Repository Scaning Tool, combined with JEnkins FindBugs - Plugin and / or Combined with Jenkins CheckStyle - Plugin and / or Combined with Jenkins 
&gt; Only attendance level will tell. I meant in setup. So 11 Java tracks on the same floor space as before, but with extra venues / floor space for 8 additional Python etc tracks?
I've looked at Rust a couple of times but not enough to be familiar with what you are talking about. For the most part I dislike Scala's Implicit Conversions which is how the equivalent of Extension methods are implemented which basically create a wrapper around the object (but the wrapper can be a phantom of some sort and never actually instantiated) But also has Traits, which get basically mixed into the object at construction, at compile time. However, using implicits, it's possible to create TypeClass like methods, which I really like the sound of. &gt;I appreciate the simplicity of "here's the class and here are its methods" but if you think about it, objects should be a representation of how the world works and how we think about it. And honestly not every action we perform on a real-world object is implemented by the object. It just doesn't match. Doesn't match OO, sure. But I do concede they can be really handy in making fluent DSL's which are usually an abuse of their host langauge, but fairly easy to program with (until something goes wrong.) &gt; Some actions are contextual and come from outside parties, but preserve the object's encapsulation. Rust traits and extension methods are attempts to capture that aspect of it. I still have troubles working out what in an object is internal that should be encapsulated, and what is part of an outside system that tracks objects, using extension methods to make it seem like it's an action an object takes, when it's a tracking action a system takes on an object... Scala also lets you have operators that can have right / left associativity, allowing you to easily compose functions / tasks. I'd be interested in seeing a language that had 2 or more ways to invoke a method with different associativity. e.g. 1. object.method(arg) //default 2. method[object](arg) //calling an implicit extension method? 3. class.method[object](arg) //calling an explicit extension method, [] denotes the 'this' This would allow things like HealthSystem.Heal[Player](20, HealingSource.Vampirism); vs Heal[Player](20, HealingSource.Vampirism); vs Player.Heal(20, HealingSource.Vampirism); Separating out the 'this' in extension methods makes it VERY clear what's being operated on, who owns the method, and what the primary target is. 
Who gets to decide what's an "Enterprise feature"? You? Why? &gt; e.g. commercial database support Aha, that's a very good way to split things, indeed! ;-) But it's not the only way. Besides, Boxfuse would have had to remove the commercial database support from the community edition, and that would have annoyed other people, including you: &gt; ***But removing*** or holding essential features Well, perhaps not you, because obviously, there are "good removals" and "evil removals" by your double standards. The only thing that seems to matter is that *you* don't have to pay, right? But why not just pay, if you get value? This has worked well for centuries. You pay, you get a cookie. You pay, you get new pants. You pay, you get a lawyer. You pay (and pay and pay), and you get a MacBook. Why not pay a hard working, deserving member of our community who goes the extra mile of adding value to *your* business? Why not? Why focus on costs when you could focus on value? The only valid criticism here would have been: "It's too expensive for me" or "Its value proposition isn't worth the price". But being salty when someone tries to run an honest business... that doesn't help anyone. Step up your game and purchase the license.
Honestly I welcome it. (contrived example) Aircraft landingAircraft = foreach (Aircraft a : allAircraft) { if(UserInteface.isSelected(a)) { a.Land(); break a; } } if(landingAircraft == null) { System.out.println("No Aircraft was selected to land"); } How many times have you had to abort a loop, and store a value? I'm surprised breaking with value has only just been introduced. int a; boolean found = for (a = 0; a&lt;array.length; a++; false) { if(array[a].TestThing()) break true; } if(found) DoThings(array[a]); Only problem is how would you specify the default value nicely.
There is something very true about this, but also a small caveat. I totally agree that software developers community is seriously ill. On the one hand we want highest salaries, benefits, perks, etc. We want the best machines and our favorite IDEs. Well, we want all this as long as our employer pays for it. When devs need to pay 10$ from their own pocket, it becomes an issue. I've seen devs spend countless hours searching and experimenting with questionable open-source stuff to spare less than 10$ a month. So, yeah, we are hypocrites because we don't want to buy products of our own industry. Kind of a cook who doesn't it his own food. The caveat here is that (if I remember correctly) part of the premium features used to be free. It's been a while since I tried flyway (great product BTW), but IIRC dry run existed even before monetization. So, if my memory doesn't betray me, there is an issue here. I don't mind great free products adding premium features and getting paid for their outstanding work. However, I don't like when features that used to be free become paid. Nothing illegal here, of course, but there is a bit of unfairness in this. 
Raising prices is always difficult, especially if the price is going from zero to anything, because that means its infinitely more expensive afterwards. At least, that's how it's perceived subjectively. But objectively, there's nothing wrong with it. The old version that had the feature is still free and available under the ASL 2.0. Nothing can ever change that, that's how the ASL (and other licenses) work. Now, people ought to do the math. How much more does it cost now than it did before? What do the alternatives (forking and maintaining, competing products) cost? Does it still add up? If yes, buy. If no, jump ship. You can see it in the same light as a vendor sunsetting a product, which is also annoying to some extent, but the vendor doesn't *have to* keep supporting it. In the same way, a vendor doesn't *have to* keep offering it for free. So, again. The only viable, *objective* criticism in the end, as far as I'm concerned, is: "Its value proposition isn't worth the price". (and to some extent: "This vendor isn't trustable", but I doubt this is what's being discussed here).
JSF is......wrong! I dont care how good, or bad it is - it is wrong. HTML should be HTML. Java should be java. By using JSF you are ultimately coupling your HTML with the java backend. This is wrong. Now this is not to say that it shouldn't exist as a third party framework (just like, for example VAADIN), thats fine by me....BUT, to position it as the official standard way to do browser based apps, is just.....wrong.. &lt;/rant&gt;
&gt; The only thing that seems to matter is that you don't have to pay, right? Actually, no. In my company, if we need something, and it is reasonably prices, we buy it. No reason not to. I do not say that Flyway is too expensive or its licensing model sucks. This is not what I am talking about. I say that the open source edition sucks because it is missing essential features. Essential to everyone, not just enterprise users. There are people that won't pay for a license, no matter what. These are open source developers, students, or people interested in technology and working on their weekend projects. You could completely kill the open-source edition of Flyway and they would just move on, switching to Liquibase or building their own tools. You could argue that these people are not important for your business and if they are annoyed by your product, you don't have to care because they don't pay you for your product anyway. No sales gained, so sales lost, right? Just ignore the salty guy on reddit and move on. I'd argue that these people are potential future customers and extremely valuable to any dual-licensing software business. Ignoring them is plain stupid, from a business perspective. Why have an open-source edition it it sucks and will drive people to the competition? The open source edition is your advertisement. If it is shitty, you either need a really really great product so people don't have a real alternative, or you will loose visibility in the market, loose support from the community and loose sales in the long run. The curious but broke students of today are the decision makers of tomorrow. Lots of successful software companies have realized that a long time ago. Dual-Licensing is hard. Too many free features, and people that could pay for a license won't because they don't need to. Too few, and people start looking for alternatives and you have lost potential futures customers. Not listening and calling them salty is probably not the best strategy to get this right.
Thanks for the clarifications. For the record, I'm not behind Flyway or affiliated with BoxFuse (although I do call Axel a personal friend of mine). &gt; Not listening and calling them salty is probably not the best strategy to get this right. That is perfectly correct, and if I did go too far, it is because most of the comments around this topic are not too well reflected, and hardly ever stem from rational, objective decisions but gut feeling and ... well, I said it before, saltiness. I may have mistakenly seen your comment as being one of them. Sorry for that. Now, whether the math adds up for both the community and the vendor is hard to say in advance. After all, a community also generates work (support, PR, etc. etc.), and if that work is not properly done, the community will perceive the product as low quality. It is hard to find a proper balance between the "freemium" customers and the paying customers. There are many studies about what the ideal ratio should be in order for the positive brand effect to be high enough to compensate for the cost it incurs. The biggest asset a vendor can have is a brand, which does not correlate with pricing at all (see Apple). Flyway is a brand, and it might continue to be one despite the license change. Whether dry runs are *generally* such an important feature that removing it will kill the brand is debatable. I doubt it, but you may have a different story to tell. But then again, following your argument, you shouldn't actually have a problem with that, because you're not in the category that categorically says no to commercial software. So, I'm not certain why this license change is such a disaster for you? Sounds like you think that BoxFuse made a wrong decision *for others*? Or do you no longer trust them?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; I could take open-source product by convincing myself that its free cost justifies time investment. However, if this product becomes paid later, I can't go back to the same dilemma again. Of course you can. The maths is the same. Total cost of ownership = License costs (their work) + Integration costs (your work) One variable went up. It does not matter at all if it goes up from zero or from something. Whenever the variables change, you re-do the math to see if the total costs still justify the value. &gt; Now if I want to take another approach I would need to invest additional effort to remove the now paid product. This is an intrinsic lock-in. How was it not a lock-in before there were any license costs? Your integration costs were always there, and they're usually bigger than whatever the license costs are, now. &gt; Sure, I can still use previous versions, but this only means that I postpone the actual decision for as long as the last free version doesn't become too outdated. Yes, and that, too, is hopefully easily justifiable by some simple cost arithmetic. &gt; So, my real and unavoidable dilemma becomes: pay for what used to be free, or pay for migrating off it. It wasn't free. You just ignored the fact that you already had migration costs. And again, you're just focusing on costs, costs, costs. If you had to migrate off it (because product was sunsetted, maintainer left, or because of some design decision that you can no longer work with, etc.), you'd do the same math. That math is completely unrelated to the license cost, but to the total cost of ownership. What about the value? That should always be your first question (as it should be when you talk to *your* customers). The value also increased, because the new dual-licensed version has new features. Is it worth the now higher costs? Yes or no? You see, again. This discussion needs to be made objectively, doing the entire math. Not with some sort of subjective feeling about unfairness. It simply doesn't work, economically. If we were talking about some leisure car, fine. That's a very emotional thing. But we're talking about software that is used for doing business, so I'm really a bit surprised by anyone perceiving such a change as unfair.
Flyway creator here. I just wanted to set the record straight as I feel this is quite important here. None of the features that were in the open-source version were removed and made pro only. In fact we payed special attention to this as we felt it was only fair things stay that way, even though some of the community edition features would be a great fit for being pro-only. Now if you want to read why exactly we decided to launch the pro and enterprise editions and why this is very beneficial for all users of Flyway, regardless of the edition that they favor, you can read the comment I made when this was first brought up as part of the Flyway 5.0 announcement: https://www.reddit.com/r/java/comments/7i5nbk/flyway_500_released/dqwb4an/ Thank you for understanding.
&gt; The worst possible outcome (which is also the most commonly suggested "solution" in forums like reddit) would be to invent a new construct that is similar to, but not quite the same as switch No. The worst possible outcome is a franken-switch that overloads an old, simple and well understood tool with random junk into a bloated, incomprehensible mess. (Actually the absolute worst would be breaking backwards compatibility.) The best thing would be to not touch the switch, and create a different pattern-matching expression construct (e.g., ```match``` or whatever).
Flyway creator here. As Lukas already mentioned in this thread, and as both of us already discussed as part of the thread of the Flyway 5.0 announcement (for those reading who want to understand our rationale for introducing pro and enterprise editions of Flyway, please see my comment about it in that thread: https://www.reddit.com/r/java/comments/7i5nbk/flyway_500_released/dqwb4an/), no licensing model will be 100% perfect for everyone. We worked very hard on finding a balance that would both be fair and affordable for the overwhelming majority of companies out there. We paid special attention to *not* remove any features from the community edition (which has always been and remains fully open-source and Apache 2.0 licensed) and make them pro-only, even though there would be a number of excellent candidates. In fact we even designed the pro and enterprise licenses to be extremely friendly, giving you access to the full pro and enterprise source, including via private Maven repositories, ensuring commercial users would have the same source access (and the benefits this brings) as community users. As mentioned in the comment I linked, at the end of the day having a viable business model that sustains the extensive development, testing, documentation and support efforts a successful open-source project like Flyway requires, is highly beneficial for all users of Flyway, regardless of the edition they chose to use. Thank you for understanding.
As stated in my other comment, I just wanted to reiterate that none of the features from the community edition were removed and made pro-only. We work very hard to made and keep things as fair as possible.
Hey Alex, As I said, I relied on my own memory here. Looks like it let me down. Thanks for clarifying this. I didn't even need to read your post to understand why you decided to launch pro and enterprise. I remember myself wondering how comes you provide this product for free about a year ago. To me, it was crystal clear that future of Flyway can only be promised with a solid business model strategy. I also wrote a similar post recently myself. Thanks for your investment over the years and sorry for getting some facts wrong. I truly wish you a great financial success (because product-wise Flyway was great even a year ago).
That will become obsolete, just to piss u off. 
Finally - what is the impact if your caching layer, holding delayed writes, crashes? Can you recover the write data from the messages?
franken-switch - I like that. I'm going to start calling it that.
Hi Alex. By reading your public comments in this and the original release thread I still think that most or all of your arguments are targeted at commercial users and you still seems to have trouble understanding or acknowledging the value and perspective of non-commercial users. Perhaps you already know what I want to say, perhaps I am wrong, but I'll try again anyway: Not adding a highly requested feature to the community edition is just as bad as removing it. You tell people that there is a solution for their (non-enterprise) problem, but they won't get to use it for their weekend project and never will. These people don't care about how fair your licensing model is, or what they get for their money, because a license is out of the question for a non-commercial hobby project anyway. They will just use something else, build their own tools, or live with the missing features and be annoyed. The community edition is advertisement for your commercial edition, good or bad. It is the most visible and important part of your brand. If it sucks, people will notice and remember. I'm not asking for free stuff or that you add any feature someone on the Internet asks for. I just want to raise attention that the current feature-set you choose to include in the community edition may need some more thoughts. 
Would you prefer a `return` that didn't return from the function?
By doing this: Item[] array = getItems(); Arrays.stream(array) .filter(Item::testThing) .findFirst() .map(this::doThing) .orElseThrow(NotFoundException::new); A default value can be returned using `.orElse()` instead of `.orElseThrow()` (I'm guessing from your syntax that you're normally a C# developer.)
Why even have the `-&gt;` shorthand? case foo: break bar; It's just as easy to type as case foo -&gt; bar;
Actually - this may be better than I thought. Look at Brian Goetz's response here: http://mail.openjdk.java.net/pipermail/amber-spec-observers/2018-April/000628.html I didn't realize you could do: case FOO -&gt; { int x = 4; println(x); } That's certainly better. Then IDEs should mark the old style as a warning or something and everyone should move to this new style.
I like it. Real world code: switch (mimeType) { case "application/xml": doXMLTask(task); break; case "application/pdf": case "application/epub+zip": doAssetBinaryTask(task); break; case "task-only": doTasksOnly(task); break; default: logger.warn("doBinaryData should not be called."); taskManager.remove(task.getId()); break; } becomes: switch (mimeType) { case "application/xml" -&gt; doXMLTask(task); case "application/pdf" -&gt; doAssetBinaryTask(task); case "application/epub+zip" -&gt; doAssetBinaryTask(task); case "task-only" -&gt; doTasksOnly(task); default -&gt; { logger.warn("doBinaryData should not be called."); taskManager.remove(task.getId()); } } And for the expression case: String typeName; switch (mimeType.toLowerCase(Locale.ENGLISH)) { case "application/pdf": typeName = "pdf"; break; case "application/epub+zip": typeName = "epub"; break; default: typeName = "binaryasset"; break; } becomes String typeName = switch (mimeType.toLowerCase(Locale.ENGLISH)) { case "application/pdf" -&gt; "pdf"; case "application/epub+zip" -&gt; "epub"; default -&gt; "binaryasset"; } 
Yes because we're all used to that with lambdas and this looks like lambda syntax.
Returning from a lambda is returning from a function. Additionally, explicitly returning from a lambda is a rare case (and usually a sign that your lambda is too long). 
IntelliJ already offers to change older constructs to newer forms when it can, like converting loops to stream operations.
There's nothing inherently wrong with a server returning HTML! For the longest time that's how the entire web worked, and it's how the web was originally designed. And isn't staying close to original designs always the best thing to do? Or do you get to pick and choose? If you think JSF deviates from how the web was designed its bad, but if you think you're preferred solution deviates from how the web was designed it's good? As discussed many times before here, HTML5/REST is not universally better than providing read-to-render-HTML. Having a full client application run locally invariably ends up using more client resources, which means batteries draining and hot devices, and by the use of more memory other applications getting killed. Full client side may be requesting JSON, but if the services are nearly organised, you'd end up doing more HTTP cals (get user data, get feed data, get website status data, etc etc), and you often end up sending more data. Like get order -&gt; get company -&gt; get user returning the full user JSON string when you only need the first name. The latter often happens with server generated HTML as well, but there the overhead of sending extra data is between servers, and the unneeded data is culled when rendered and sent to the client. 
Additionally, because it's a block, there's no weird scoping, where `x` will exist after the switch.
you guys are too sensitive with respect to boilerplate code. i don't even see it, nowadays, therefore having it or not having it means absolutely nothing to me. yeah, 100 getters/setters, nobody will ever look in there unless absolutely needed. you are waaaay over-thinking a non-issue. 
Nothing stops you, or anybody else, from writing a plugin supporting Kotlin in their IDE, or even a brand-new IDE just for Kotlin.
Indeed.
That is about as clear is mud. ELI5?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You obviously don't work in the enterprise market.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I agree. The Run button is supposed to be just for logging output to the console. It's actually quite useful when solving some of the more complicated challenges. Seems to confuse people though.
You are just ignoring an actual issue. Just because you got used to a very verbose style of coding it doesn't mean that it's not a problem. There are obvious objective drawbacks to boilerplate and there is not a single advantage to it. 
Good one. Thanks.
&gt; I was arguing that Kotlin is not tied to IntelliJ Technically, it is
Why do you think its likely I have guava on the classpath? You don't have to be an apologist for the other idiots here that think adding a dependency for a one liner that really doesn't add anything to readability of the code is a wise decision. This is setting yourself up for a situation like LeftPad, where the dependency changes but someone thought to update packages because....new shiny. The r/java hivemind has some incredible failings and this is a perfect example. 
it's not an issue unless you want to make it. don't you have enough things to worry about already? why make out of thin air issues? 
That works great.
&gt; Why do you think its likely I have guava on the classpath? Because it is one of [the most popular](https://mvnrepository.com/popular) java libraries. Maven does not allow changing or deleting dependency versions, so if you never update you're fine. Guava also has a [very solid deprecation policy](https://github.com/google/guava/wiki/PhilosophyExplained#iteration).
This is some solid conventional wisdom every should think about.
unlike you, i don't have idiot colleagues. 
The company I work for has plugins that our customers use which have Java 8. Does this mean that we would have to have all of our customers pay for Licenses + support in order for their java to receive fixes?
I wonder why you need to ask this given extensive Scala experience. Java is just the bad parts of Scala.
We found the Boxfuse employee.
Scala makes me appreciate how much a vision and hard work can drive the development of a language without the fear to cut clumsy or unsounded aspects. The goals of both languages are totally different and so are their development constraints. I admire both - I feel so lucky! 😎
Good tutorial. Thanks!
The first case allows fall-through. I think you can write case foo: case goo: break bar; But you have write case foo -&gt; bar; case goo -&gt; bar;
JDK 8 is the new Java 10 and 11
i was confused by their example of "reading through a text file and printing the count of each word appear in the file" because i would expect that one file would be read by just one thread; and if its word count was stored in its own ConcurrentHashMap then i would not expect that compute() would be required: in that case, i could also use a just get(key) followed by increment(). but, if were using the same map to hold counts coming from multiple files, which were being processed by multiple threads (in parallel), then indeed using compute() is a much better mechanism coding with an additional dedicated lock. 
Your colleagues obviously have an idiot colleague - who happens to be quite rude btw
[DROP DATABASE](https://youtu.be/QR0hK7rqkGM)
So you wrap things like java.lang.String and java.util.List? Seems like a great way to add extra overhead and simultaneously make it a huge hassle to exchange data with 3rd-party libraries. When you replace standard classes and interface with your own versions, you're essentially creating your own nonstandard dialect of Java. It's like the bad old days of pre-ISO C++, when every library had its own string class, collection classes, etc. Making a wrapper around Optional is particularly silly; it's so simple, every implementation is bound to have near-identical performance, and any wrapper is going to have worse performance than any halfway-reasonable implementation. If you absolutely insist on using your own class, you may as well just implement it from scratch and avoid the overhead.
IME, replacing one library with another is exceedingly rare in practice, and when you do it, the old and new libraries are usually different enough that the changes in your code can't be confined to just the wrapper. Even if the APIs look compatible, subtle differences in semantics can cause bugs that are very time-consuming to track down. Writing a common wrapper for two specific similar libraries is hard enough; writing a wrapper to accommodate some hypothetical libraries is almost impossible. Preemptively wrapping a library just because you might want to swap it out later is a classic case of YAGNI. Most of the time it just adds extra development overhead, extra maintenance overhead, and extra runtime overhead.
Nope, not affiliated
&gt; I understand where your frustration comes from, as this is an emotional topic for many of us Touché ;-) &gt; But I love open-source (if done right) Now that is a sentence that is said very often, but I have never understood its meaning nor true intent. Of course, there are many benefits derived from open source. The most important ones being: - Legal ease for modification and distribution - Pricing - A high correlation with an open development model (which isn't strictly the same thing, nor does it strictly depend on OSS) Yes. What's not to love about that. All of these make the lives of customers much easier. But it's not really depending on OSS, it just correlates with it. Commercial software can achieve the above as well. In this particular case, I guess (haven't verified) that modification and binary distribution rights are included. Pricing might be reasonable depending on how you perceive the value proposition, and I'm pretty sure the development model is still very very open. So, what's missing, really? &gt; and while I would always prefer a community driven project over a commercial one What's a "community driven project"? There are vendors with interests and roadmaps / agendas. In this particular case, prior to being commercialised, the project was a one man show with 1-2 pull requests. That's not community driven. Now it's a one company show with 1-2 pull requests. Nothing has changed. Most small projects aren't community driven. Even most bigger ones aren't. Yet, you'd probably still prefer them over a commercial one. For what I can only fathom to be non-objective reasons. &gt; I might be wrong in this specific case and no one really cares about these features, but still If you're not using Flyway, and you're not affected by the change, then why bother focusing on a particular feature that you *think* you might find essential if you *were* using Flyway? At this point, I guess I'll stop arguing as this seems to evolve into an argument for argument's sake :) Cheers, and good luck!
Maybe, we can agree on the basic fact of project management that change management is super hard, and it could have been done better in this case? Well, yes. It shouldn't be taken into account for decision making. But it is being taken into account, because after all, we're all humans and we make decisions based on both objective reasoning *and* gut feeling. Everyone is guilty here, and in order to be successful as a vendor, the subjectiveness has to be taken into account. Otherwise, no one would need salespeople :-)
Yes, I remember the story. And it really sounds weird and not from this world to me :) Perhaps I'm not involved deeply enough with those communities... I can simply not relate to the idea of taking something that someone else did and making it my own thing. I call this stealing. Even if it isn't legally stealing in these cases (due to the licensing explicitly allowing it), it is still morally stealing. Now, we can have a discussion about where "stealing" starts and where "taking inspiration" stops, of course... In the case of Flyway, however, an unfriendly fork would clearly be stealing, and not very credible.
Yeah, love his talks :)
Java is not moving towards less typing. Var on Java uses strong typing
No you both
no u
No you both
Is it bad that I call all my identifiers `var` /joke
wooooooooo. you got me.
no u
Can you be more specific about what you need help with?
What is the very immediate benefit of this, just being able to use Java syntax for shell executions? 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is there a subreddit you'd recommend for all things JVM?
make your own or go to r/scala which has 7 people there. 
For me, when I forget how a specific bit of the language works and the javadoc is unclear, I drop to jshell to test and avoid writing a small sample app. No clue what the benefit of scripting in Java over groovy is
The latter usually implies the former.
I normally agree! And both is always option #1. I'm more talking about when you start getting into self referencing generics. Things can get harder to read...
&gt; For me, when I forget how a specific bit of the language works and the javadoc is unclear, I drop to jshell to test and avoid writing a small sample app. err, you can already do this in Intellij you by creating a method with `@Test` and run it. You can even debug and execute expression by pressing alt-F8 with all of the intellisense available.
&gt; a very simple implementation where the interface had a lot of methods and likely a lot of similiar code Sounds like a violation on SOLID principle especially on single responsibility and open for extension/closed for modification. 
I know you were being sarcastic, but /r/jvm
We'd need more information. Right now the information you given is very small and isn't helpful. Could be because of some mistake. I'd imagine that you in your public CLASSNAME(), you declared the ball's position to be 0 so something like This.ball_pos == 0; If that's the case, you have to set the ball's position by set() function to set the ball's position because the default position is 0.
Then rethink what you're doing to get rid of the self referencing generics. Chances are: you don't need them
Yeah. I am going to look at that. I was using it was a common base class for builders/fluent code, and I couldn't think of a better solution.
Isolate the horrible bits and hide them in separate classes (eg factories)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
As a rule of thumb: prefer composition over inheritance. Maybe the base class wants to be a utility instead.
Then you have duplicated methods spread over multiple classes. Sure, you can have the body of those methods be in a shared class, but it makes it harder to add methods.
It's just a syntactic sugar, it has nothing to do with typing.
The token comes after ct, so am I right in thinking if I work out $r6 I will understand how it is being generated? r41 = new MultipartEntity(State.id, (byte) 0); StringBody $r6 = r42; StringBody r42 = new StringBody(str); $r5.addPart("ct", $r6);
What information can I provide to give a clear understanding of what I am trying to achieve? 
Scala is for esoteric people who enjoy complexity and did well at theoretical math in school. That person is not me. As Gosling said, Java is a “blue collar” language targeted at getting things done. Having spent the last 2 years in Scala and now returning to Java I feel a great load off of my back. Scala makes you feel stupid. Java makes you feel productive.
No but we want to use it, as a security concious company though I want to make sure it's not insecure, which I believe it to be if I can work out how this string is generated. 
Hey, Bot-01A, just a quick heads-up: **concious** is actually spelled **conscious**. You can remember it by **-sc- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Good bot 
If you're writing a library for external users, then I'd err towards an easier to use API. Your extra effort will make life easier for many people. If this is for an internal project, I'd err towards maintainability. 
How so? You can pass utilities in as dependencies to another class. No need for duplication.
&gt; What's more important: an easy, clean API or having the underlying code be easily maintained? This type of question is known as "[a false dichotomy](http://wiki.c2.com/?FalseDichotomy)".
Why not both? this is why you separate your concerns? This isn't an either / or situation. 
There is something worse than duplicated code: a base class that is littered with special cases to cater to every subclass. Now, if the superclass is a pure "template class" pattern, then it might be justified. But as soon as you see the superclass do branching logic depending on the subclass, slow down and consider whether that reduced duplication is worth the cost of an awful mess in a parent class.
If you think a lot of unrelated classes need the same methods, these methods probably belong somewhere else. Can you give an example of what these methods do?
TIL this works `.filter(((Predicate&lt;String&gt;)String::isEmpty).negate())`
&gt; I guess, as they're likely footing most of the bill. What about the entry fee?
So would all subscription services be "ransomware"?
I need to prove it though by decoding this string. Otherwise it's just a 'maybe possible' 
To expand on /u/nfrankel's reply: it's intended to make concurrent code easier to write/read/maintain/get right. Same reason C# did it. https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/hh191443(v=vs.120)
not at all - i'm strongly in favor of subscription services if they're done "right". the big problem here is that security **defects** in the original software are what's forcing customers to purchase the subscription there are some other factors too: * the customer is forced to pay the full cost, not the cost of just the fix * the source code isn't available and liberally licensed so the user isn't able to fix the bug themselves * the transition time is too short and/or the delta from 8 to 11 is too large * the terms changed after 8 was already in use i'd argue that the only time that it's reasonable to force users to pay extra for a critical bugfix is when all the following are true: * the bug wouldn't have been fixed by ongoing development or the product is discontinued * the price is only for the development cost of the fix * the source is liberally licensed so 3rd parties can compete to keep that cost down * adequate time is provided to allow users to adopt other solutions none of these four conditions appears to be true in this case. i've actually written [a subscription license](https://github.com/db4j/pupl) that attempts to offer guarantees similar to this 
Still, you should probably thank Scala for being guinea pig for the Java featurds you take for granted.
Lets start by me laying out what I understand your situation is and you correcting things and answering questions. 1. There is an Android application "Application X" which your company uses, but doesn't develop and you don't have the source code for. 2. Application X fetches data from a server run by a third party (developer of Application X?) and this data is sensitive. 3. By your determination, during initial authentication with the server the application provides the same token each time. 4. By your determination this is a bad thing and you have investigated to determine how exactly the token contents are derived. Some questions: 1. What is the nature of the sensitive data? Military? Intelligence? Health? Financial? Business secrets? 2. What have you used to determine the application is providing the same authorisation token each time? You admittedly don't know much about Java or programming in general, so I have a hard time believing you could accurately capture and analyse a packet trace of a llogic handshake and determine it is insecure. 3. Is the connection between application and server encrypted e.g. using TLS/SSL (HTTPS)? 4. Is the authorisation token encrypted e.g. using public-private key cryptography? 5. If you believe there is an attack vector for a malicious actor to gain access to the sensitive data, then describe it. What would someone have to do to get their hands on this data, and how feasible is it? Sending the same auth token each time is a bad move for sure as it opens up a replay attack vector, but if the underlying connection is encrypted then the attacker won't be able to find out the contents of the token regardless so the security is poorly designed, but still secure.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Doesn’t Khan Academy have Java?
I used codeacademy for some other languages. I seen javascript on it but not java
Video: Tim Buchalka's course on Udemy (worth the $10 without question) Book: Java: A Beginner's Guide by Schildt Software to use: IntelliJ IDEA Community Edition (it's free) Documentation: https://docs.oracle.com/javase/10/ Official Tutorial's: https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html Have fun!
Oh yep my bad 
I would recomend Derek Banas if your new to programming / OOP https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19. If your more comfortable with programming then I would suggest the Oracle Docs and/or a book on data structures and algorithms in java 
Context, so it won't be one-sided: &gt; The worst possible outcome (which is also the most commonly suggested &gt; "solution" in forums like reddit) would be to invent a new construct &gt; that is similar to, but not quite the same as switch (`snitch`), without &gt; being a 100% replacement for today's quirky switch. Today's switch is &gt; surely suboptimal, but it's not so fatally flawed that it needs to be &gt; euthanized, and we don't want to create an "undead" language construct &gt; forever, which everyone will still have to learn, and keep track of the &gt; differences between `switch` and `snitch`. No thank you.
Scala is a great achievement. That said, there are many languages influencing Java right now. 
it would need to be from netflix, i made a simple program that picks a random link to play from a series. I have it working fine however right now I can only use it with two shows (the office and parks and rec) because i went through and copied/pasted the episode urls into 2 separate text files. it wasnt that bad for two shows but ideally if i could automate that would be great.
www.hackerrank.com There’s a section on there that goes through Java fundamentals. I’d just work through that.
Ok will do. 
All you need is YouTube and an IDE. Books are great after you've gotten some knowledge and can follow the material to pick up finer details you may not have known. Make your hello world, make your calculators, if you're into Minecraft make Minecraft plugins or mods, the more things you can write and explore with imagination the more obstacles you face, the more obstacles you overcome the more you learn. With programming you learn when you're stuck, do your absolute best to not get discouraged. As a programmer of many languages and a career in the field I am stuck often on code, that's how I learn and get better. Java is a fantastic language to start programming, start small, it takes time, but you won't regret learning. 
I'm not sure what method would be best suited for Netflix, but I used [jsoup ](https://jsoup.org/)to scrape data from a website a while ago. It worked great and was somewhat error prone. You can query elements by id, tag, etc... \(Disclaimer: I only used it for like 10 minutes and got my job done, so I'm not an expert on the subject.\)
This! I haven’t figured out a way to not get my IP blocked — read: haven’t Googled it yet — but if you know how to securely do so, then selenide is the way to go.
What about a browser extension? 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Java Environment Setup to write &amp; execute Java Programs, Java Syntax Rules, Java Program Structure, Java Statements, Java Comments, Java Code Blocks and a Sample Java Program. Write and Execute Java Programs using Eclipse IDE for Selenium Automated Testing. Java Language Elements for Automated Testing with Selenium.
Presented build: jdk8u144-b01 Latest archive build: jdk8u162-b00 Nightly build: jdk8u172-b00 Only the presented build has an installer for Windows/Mac. The others are only binary archives. (Note, no other JDK version has installers though) I can't find any info on when they decide to present a build.
Severe case of NIH. I subscribe switching jobs.
&gt; EDIT: I want to add, don't learn for money. If programming doesn't fuel your inner curiosity and drive you to walk in circles talking to yourself solving programming problems in your head AFTER you're home from work. It may not be for you. :) I agree a lot :) 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes but why would I do it?
There is a lot of great stuff in the pipeline, along with all that we have already received. I recommend watching [this talk](https://youtu.be/oGll155-vuQ) from Brian Goetz, one of the architects on the Java Platform Group.
It's a very stable language which has a ton of open positions available, mostly in backend APIs or Android UIs. It's no longer used for frontend or middle-tier work, that's mostly left to client side frameworks and NodeJS. When. Done right, a Java backend and JavaScript frontend are very cohesive together. I don't know about how Java handles http2 or some of the later technologies, but for REST architectures it works well.
Can you tell why your company is forbidding Ruby? Because I'm at the beginning of my career and currently working in a Ruby on Rails based company.
They aren’t forbidding Ruby. We will still have to maintain our Ruby app in transition. But my mew boss views Ruby as a “hobbyist’s language.” Reading between the lines though, they have poisoned the San Francisco Ruby community well by burning out every engineer on the team and decided to switch languages instead of fixing the toxic culture.
&gt; Why should I be excited? What are your favorite things about Java? The tooling and the ecosystem. IntelliJ is possibly the best IDE ever created. Maven (and also gradle) are rock solid, and there are well maintained and active libraries/frameworks for almost anything you can think of. I'm just a lot more productive in Java than I am in other languages, especially on larger projects. The language itself is pretty meh though, I usually port parts of my projects to Kotlin.
It's not node? 
One thing I really like is the huge infrastructure. Of course depends on what you mean with "transistioning to Java", because if you are speaking of a Java runtime environment you are not limited to the Java programming language. There are literially dozens of languages out there that can run on the Java virtual machine, including [JRuby](http://jruby.org/), Haskell-based variants such as [Eta](https://eta-lang.org/) and [Frege](https://github.com/Frege/frege) or other functional languages such as [Clojure](https://clojure.org/).
What do you mean by middle-tier work exactly? 
&gt; Maven (and also gradle) are rock solid Lmao, for such a simpkistic tool maven is incredibly unreliable. 3 times in the last year, in both coding at home and coding at work, the only way I've been able to get maven working right was tracking down the cache location on disk and deleting it. 
I write Java for a living. Coming from C++ background it was a natural transition that I made some 15 years ago. I also know some Clojure and Python. Java is a programming language like any other. It has good and bad sides. Because it's relatively old it has had time to make and fix many mistakes that more hipster approved languages are suffering from. It has garnered some notoriety for being verbose but that's much exaggerated. People who know what they are doing can write clean and concise Java no problemo. Lots of very good and very prominent software is written in it. Not just "enterprise apps". Minecraft is one example. Facebook's Presto is another. The JVM is very fast for a VM hosted language - probably the best there is. You will definitely not miss the slowness of Ruby. Modern Java is often augmented by very good libraries like Immutables. It allows one to create very clean code that mixes imperative and functional styles with ease. Only morons write Java these days with the old style FactoryManagerHandler bullshit. Between Immutables and Java 8 lambdas it can be a very good experience. Yeah, for a true FP experience Clojure is better. For a nazi style typing system Haskell is better. But Java is the language of the person that gets shit done. It ain't perfect but it works.
&gt; Everyone on my team is quitting Seriously? &gt; [(from your other comment)](https://www.reddit.com/r/java/comments/8e3npm/my_company_is_transitioning_to_java_why_should_i/dxs4l4g) they have poisoned the San Francisco Ruby community well by burning out every engineer on the team and decided to switch languages instead of fixing the toxic culture Oh, that wasn't the only reason... ;-)
That's odd, I 've never had to do that in over ten years of using it. I've had to do `-U` two or three times when running against artifactory at work.
I’ve been using maven for years and have never had to do that. 
this. The tooling and build system are rock solid. Great testing and integration with CI and VCs. I am so productive in this environment. Add frameworks like Spring and Hibernate and you can write some rock solid code. Plus the JVM is incredibly fast and a marvel of engineering. 
The Java job market is great! You will have an easier time finding a job if you have Java experience.
I used to like Java, but I'd suggest you look into Kotlin. It's 100&amp;#37; interoperable with Java, so there's no reason not to use Kotlin. Plus, it has a lot of modern features that makes it far superior than Java
Java is nice, but if I were you I would try to convince your company to switch to Kotlin instead. I don't see any good reason not to :) 
&gt; I love static type systems, so I look forward to Java's type system. The type system is easily the biggest strength of Java. At first, as a Java beginner I saw more compile-time errors and it felt annoying, but once I got past the initial irritation, I realized that the compiler was saving me from a lot of bugs, sometimes serious ones. A close second biggest strength is the ecosystem around Java. There's really nothing close as far as the stable, secure, scalable libraries and frameworks available for Java. Not to mention the standard library, which is pretty good as well and has some really nice surprises like mature data structures and algorithms for parallel programming.
The 3 downvotes in 7 minutes? That always comes with people circlejerking an agenda. I assume you'd say anything regardless of how untrue it was. When Jsf was being pushed you'd be insisting jsf was amazing and replacing jsp. When ruby on rails was being pushed you'd be insisting it was "killing" java. Etc. I'm not sure I've ever worked on a project where maven **didn't** exhibit minor bugs. One job I had Intellij which had a bug where it would claim to have run maven but it wouldn't, you'd have to run it from the command. Like I said I've seen numerous times when tracking down and deleting the cache on disk was required to get it running again. And this has applied to 2 laptops at home, several different work machines, and coworkers machines as well. I don't know why such a simple tool is so consistently slighrly buggy, but it has been every time I've used it.
Not the other post, but often: Backend: database Middle-tier: Rest, business logic
Spring is hugely popular for middle tier.
One thing with Java that I never see mentioned that I personally like are the primitive data types. The primitive data types are platform independent so cryptography is 100% consistent. A byte is always a byte. A char is always a char.
That's not a good sign imo. Who says this won't happen again but with Java -&gt; [other language]?
You might be projecting some of your frustrations onto me. My opinions on technology tend to be fairly metered. I really don't think there is a single way to do things, and all tools have merits. We use Gradle at work and I have used Ant extensively in the past, but I still prefer Maven. It's fairly intuitive, easy to use, and I have not run into the problems you have run into. Have you considered just using a different tool? If Maven upsets you this much, it might provide some mental relief to change to Gradle or Ant. It seems nonsensical to install Maven onto all your systems then get mad that you're using Maven. Especially if you're going to channel that frustration into getting into fights on the internet and calling out people who downvote you.
&gt;It has garnered some notoriety for being verbose but that's much exaggerated. I don't know if I would call this exaggerated so much, as getting better. The core language is getting better and over-engineering isn't as commonplace. But I think calling it verbose is an earned title. For instance, I took a break from Java for a bit and now that I'm really starting to get back in to it, being able to use a switch on a string is blowing my mind! 
It probably will. But I can’t change jobs for at least 6 months so I want to at least embrace the chance to learn something new.
Besides what people have already said, the ecosystem around it is great. Learn to use the tools: the VM itself and its bazillion parameters, IDEs (Eclipse and IntelliJ are both great), debuggers, package control (mvn, gradle, etc) profiling; from simple things like jps to jconsole, jmat, jstack, jhat, MAT, yourkit, visualvm, junit and even jshell if you're using the newest versions
There is a huge open source base of quality projects bolstered by millions of engineering man hours of investment from tech giants. If you have an infrastructure problem on the JVM that hasn't been solved at this point it is so much more likely that you just don't understand your problem than the odds that there is a hole in the solution space. 
Java's `HttpClient` handles HTTP.2 perfectly!
Have you EVER used Haskell? In java you can atleast cast objects and types but in haskell the correct way is using maybes. Takes in string, returns maybeInteger...
Why the hell you're giving such a bad advice? Spring is easily the best thing you can use in java. I've used pretty much everything in java and I can assure you that spring boot with project lombok is a breeze!
&gt;It allows one to create very clean code that mixes imperative and functional styles with ease. Only morons write Java these days with the old style FactoryManagerHandler bullshit. Between Immutables and Java 8 lambdas it can be a very good experience. Can you share any example projects that follows the mentioned design? 
You shouldn’t be. JVM is a resource hog and Java is way too verbose, obsolete, and an impostor language as it perpetually adds features from dynamic languages. I would jump ship and head for greener pastures 
Java is a solid language with lots of support and well supported packages for every thing you can possibly want. Also Java doesn't mean you have to use the Java language itself there are other JVM languages, for example Groovy On Grails, runs on the JVM, compiles down to java byte code, and works a lot more like what you're familiar with. It's the best of both worlds (unless you really really really need transactional speed, but even then there are answers to that) 
The syntax is a bit verbose, but that makes it extremely easy to read and identify errors as everything is explicitly written out. I think it's certainly easier to take Java code that someone else has written and figure out what's going on than something like JS or Python
Yes please any examples would be super nice. I am also trying to adapt to modern Java.
Database -&gt; backend -&gt; middle tier -&gt; frontend Backend is one of the closest systems to the database. Middle tier typically handles proxying or server side rendering of client side code. For instance, the server side of a Ruby or PHP website could be considered middle tier if it connects to other service APIs. If there are no APIs then it is also considered backend because it's the closest thing to the database.
Let’s put this this way: There more than a few reasons the why twitter switched from ruby to java, and more than a few reasons why java is used to build scalable, exceptionally fast, reliable databases used the world over for mission critical implementations such as Cassandra, Neo4j, Solr, and ElasticSearch. Netflix powers a huge overwhelming majority of its back end with Java written microservices. JVM is infinitely configurable, scalable, and consistent across multiple environments, from your Windows to your 10yo pre-IoT toaster. I used to be just like your train of thought, but these past couple years really looking into it has changed my head so much I’m, and my co workers, are still recovering from the whiplash. My first ever deployed project was an API service that powered a high traffic blog, and just the one instance of it took little less than 500mb of memory at peak times and required no caching strategies to stand up to the task where a python API of the same purpose needed two instances running constantly to load balance with a shared cache. I wrote the new service with Kotlin using SparkJava as a quick microframework to get me off the ground running 
&gt; Beware of Spring though. Stay away from it if you can. You might have a reason for this suggestion, but in general "don't use X" without any substantiated reason for why X is somehow bad is not going to get you far. Particularly when X is likely one of the most (if not the most) widely used libraries/frameworks in the ecosystem.
Did rails for a living some time ago, coming from java and now i am back to jvm. I'm glad i was given the chance to do rails because i learned a lot about functional programming and dynamicness. But i would never ever ever ever... ever do a big project with dynamic typing again From my experience lacking static types, for example in ruby, is compensated with so much more tests... And i never felt any confidence changing existing code, because refactorings produced subtle errors that wouldn't have happend if there were static types. For meine, this is the single biggest advantage of java over Ruby. Nowadays, one can write very Elegant code in java while still having a very low bullshit factor. The toolset is limited, so understanding foreign code has a very high chance of being easy. I personally can't say that about ruby and rails. If you are naturally curious and open for static typing, i bet you will have a good time with it. Other topics, like very mature tooling and a super fast runtime are also big pluses...to be honest, i can't see many disadvantages by switching.. maybe ten years ago, but not today.
Hey, hpernpeintner, just a quick heads-up: **happend** is actually spelled **happened**. You can remember it by **ends with -ened**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
I was a Ruby developer until 2 months ago. I loved Ruby, its community and all the good practises that we respected and followed, and weren't so usual in other communities/languages. I decided to go from Ruby to Java for multiple reasons. 1. To understand better all the things that are under the magic and easy ways that Ruby provide. 2. To get away from the Rails way of doing the things that, in the end, take over some design patterns and imposes other kind of methods (involving rails magic). 3. Because I wanted to go to Switzerland or Austria, and Java is the king over there. 4. Because I wanted to get in touch with the Java department in my company, and try to support with good practises, standards/conventions, TDD and clean code. I think Java code can be beautiful too, and it feels even better than with Ruby.
It's a Krappy language that looks like someone trying to bring back Skala..
Agree until: &gt; nazi style typing system
&gt; It's 100% interoperable with Java Not without pain and dealing with Kotlin's ugly syntax and odd semantics. The JetBrain's employee trolls are out in full force. 
My advice- put Java on your CV and switch. Java on CV opens a lot of doors.
var is type inference, not dynamic/weak typing
Yeah. I'm stuck for at least six months. So I am going to use it as an excuse to pay for Java training. 
You could try using pauses of random lengths to make your traffic seem more human, though that’s just a guess. Not sure if it would work or not. 
iDontThinkJavaIsVerboseDoYou()
I think maybe he meant all the boiler plate. With streams and shit it can be a pretty terse language.
Just because you can't do pointer arithmetic does not mean Java does not have pointers :)
Java the platform is fantastic. You have decades of high quality libraries available and the JVM is an excellent piece of technology. Multi-threading and memory management is pretty much a no-brainer with the JVM. Java platform tooling is also phenomenal. The Java platform is also has a ton of industry backing and is frequently updated. Java the language is fine. It has a lot more sugar than it used to but still doesn’t feel too modern. That said it is one of the easiest languages to debug, refactor with confidence, and figure out what other people’s code is doing. Ruby is great but the platform has well known limitations. Most Ruby shops that need to be highly scalable move to jRuby. Seems short-sighted that your company is willing to have a brain-drain instead of going that route. I’d make the argument that platform is way mote important than language in the end. I can code in many languages (big whoop) but overall I need to know I can support that code and know what the heck is going on in production. All that said our company embraced Amazon AWS since the beginning so a lot of my code now is as much Lambda functions in javascript and other such glue code. We code a lot in Groovy as well so don’t really use Java the language much at all. TL;DR embrace Java the platform, feel free to ignore Java the language. 
Compensation depends more on location, experience and company. 
It's not your mentors fault, I worked with Ruby for about an year and the rest of my career in java. There's this thing in the Ruby community forcing people to hate java because reasons. Ruby was a good bet but not anymore, for the same purpose you have python.
There are many reasons not to use rare programming languages. First is the lack of engineers who are able to write good code on day one. Second is the lack of libraries, documentation and general support. 
Yeah. That is the only one that works for me.
Ill use Spring Boot if I have to, but lombok is an unstable hack relying on unsupported bytecode manipulation and just isn’t worth it compared to all the more stable alternatives. 
&gt;tracking down You mean `~/.m2`?
1/10 troll attempt. Could maybe go up to 2/10 if you said something ignorant about the garbage collector. 
&gt; burning out every engineer on the team and decided to switch languages instead of fixing the toxic culture. Get. Out. Now. Or at least as soon as possible. You mentioned you can't quit, but it sounds like you should start planning an exit strategy. There is to much demand for good developers to put up with toxic culture, the stress isn't worth the years off your life. 
Offtopic: their name is horrible IMO. At first it might look like some scam "initiative".
I was very sceptical for a long time to use project lombok. At my company all of our project currently use lombok and I just can't live without it anymore. You should be using &gt; java 8 of course 😀
I ended up in the psych ward for 10-days. I wasn't the only one that spent time in the hospital in 2017 because of overwork. I can't leave for a bunch of reasons - but I am working on an exit strategy. I think I can convince them to pay for me to learn a new language though, so I am going to lean into that while I can.
It depends on fiddling with internal bytecode structures and hooking undocumented functions, which can (and do) change between java versions - which is why lombok tends to break with new releases. They usually fix it pretty quickly, but I wouldn’t want to risk my business on them always being able to do that. What if the next major java release breaks it in a way that can’t be fixed? You can get pretty much everything lombok offers with either kotlin data classes or the immutables library, both of which are much more reliable. 
You're right, kotlin is a good option! I had no issues until the latest version where they made breaking changes because Java 9. @value and @data have issues with Jackson but it's easy to fix. I started to use when pivotal started to encourage in their workshops to avoid boilerplate code. Oh man it's so good to have value objects without getters / setters
The best thing about Java™ is that you will memorize how to type the ™ symbol. 
Could someone explain what "FactoryManagerHandler" is? Or point to some article?
Every programming language has about a 20-40 year lifecycle. Ruby was on top in the 00's but now is kind of on life support.
Whoa there. If multiple employees are literally being hospitalized that goes way beyond "toxic culture". What's so important that you have to stay for 6 more months? A visa? Just throwing this out there, but you might consider legal action with your colleagues. Any desk job that is hospitalizing employees is probably vulnerable legally.
Same question. I've been programming in Java for years and I've never heard of "FactoryManagerHandler". Of course, that could just indicate that I'm not a moron.
Just say no to overwork. Saying no is the greatest skill you could learn in the businessplace and in life. Since everyone else is leaving the company left and right, they won't be fire you so easily. So don't be afraid to say no.
I'm working as a Java dev for 7 years. In those 7 years, I have been also working with Python, C++ and maybe some other language. Like leostrauss told you, every language has good and bad parts. My biggest problem with Java is the amount of code which you need to write to get something done. On the other hand, I have written a lot of amazing and high-performance apps in Java where it was much better than Python and easier to use than C++. If I may suggest, ignore people who hate some specific language or tool. I never understood why someone hates some specific thing so much without any reason, and never will:S
[Project Amber](http://openjdk.java.net/projects/amber/) is addressing the verbose aspects of the language.
Things I love about Java: - It is a simple language. You should be able to pick it up within a few weeks if you're familiar with OOP in any capacity. There are really no hidden surprises and no arcane syntax to learn (with a few exceptions, I guess). - The tooling is top-notch. No language has better tooling than Java. The amount of static analysis tools available is amazing. And IntelliJ is the best IDE out there. - The library ecosystem is by far the largest available. People joke about how in Python you can just go `import solution`, but this is at least as true for Java. I have almost never had a need for a library in a project I'm working on and came up empty-handed. Java's type system could be a little more powerful, and there are features in other languages that I wish we had. For me personally, I just try to write Kotlin whenever possible, and that gives me the perfect compromise. All of the same Java libraries and most of the tooling works for me, but I get a modern language with all of the best features I've always wanted.
Other poster said "Maven (and also gradle) are rock solid". Needing to find cached files in the file system and delete them to get it to work is not at all "rock solid". I've didn't call it "unusable", butcit's certainly nowhere near rock solid. Especially dor something thst's so simple (I'm not even doing builds I'm just using for dependency management).
There was a time where OOP and Design Patterns were cranked to eleven. From that time come all those atrocities like [RequestProcessorFactoryFactory](http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory)
Are you… a moron by chance?
https://projects.haykranen.nl/java/
&gt; Because I'm at the beginning of my career and currently working in a Ruby on Rails based company. Oh, boy. You better sit down before you read the replies. But long story short, Ruby was heavily elevated by the hype around RoR and now that hype has died down, and every other platform on the planet has their own "RoR, but better" clone. There's no single reason to go RoR right now, usage is dropping down and the future is not bright. If you're working in a RoR company, RoR will continue to work fine for you of course. But I hope you diversify and check out other platforms, because Ruby is going downhill. And honestly it has no advantages over other scripts and languages in general.
Take a look at [FizzBuzz Enterprise Edition] (https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) 
Honestly, Java probably has the best developer tool set built around it. You have one of the world's best IDEs, IntelliJ. You have packaging systems that aren't terrible like npm, and actually have dependency management unlike stuff for C. You have a language that has sped up it's development process to accommodate new features and new practices into the language.
I used to feel the same as your mentor. I started in Java out of school, but found it boring and stodgy, and not very cool or fun, in addition to highly unreliable. Turns out I was just working on a crap codebase. You can program great practices into Java, and get just as get results with it as with any other languages. Once you understand the type system, you can use it to turn lots of runtime errors into compile time errors, and navigate through code with ease. It really shines in big complex projects where you need to untangle someone else's rat's nest, because you can use an IDE to do so in an unambiguous way. RubyMine, bless its heart, can *try* to tell you what method is being called, but it usually just a "best guess". My main beef with Java now is that any object could be null, which drives me absolutely bonkers.
In OPs defense (not that it's needed), the relevant topic of interest here is Java. What seems irrelevant is the obviously complicated and certainly subjective other stuff.
Try r/learnjava - lots of resources and people in a similar boat to you! 
This.
Less than you or less than the average Ruby developer?
I love writing Java
&gt;Java may not be "fun" to write I love writing Java
&gt; the lack of libraries, Every Java library can be used with Kotlin, no? Sure, the libraries might not have Kotlin-specific docs, but from my experience, the interop has always been straight-forward
One thing you might appreciate is execution speed. I inherited a Ruby back-end system — OK, 10 years ago — and a straight port (no algorithmic changes) led to a 70× improvement in speed. I haven't been enthusiastic about Ruby since. [It looks like Ruby has not closed the gap very much since.](https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=yarv&amp;lang2=java) 
At first, you'll hate the verbosity. And the build system will probably be *evil* XML. And it will seem like a huge pain to set up the JDK and possibly Tomcat or JBoss or whatever other containers you might use. You'll cry when you realize that a simple *hello world* requires a class, a method, and a compilation step instead of just the one liner *print "hello world" * dynamic languages like Ruby and Python can pull off. You'll cringe at some of the types like *Map&lt;&lt;T extends ?&gt;,&lt;L super ?&gt;&gt;* vs dynamic langs' tuples and dictionaries. And in a year from now, after you've been using Java, you might have to revisit some of your legacy code. And now you'll be irritated at the awful IDE support that dynamic languages have versus the awesomeness that is Java and IntelliJ. And you'll curse Ruby when a single change to a variable name blows up the whole app (at runtime, next week) - in Java the compiler would have caught that immediately. And you'll now be frustrated with the dozens of amateur libs from Github that you use in Ruby vs the professionally maintained docs and stable libs of the Java world, backed by huge companies. And regardless, Java has moved away from its bad habits and now has a lot of improved syntax and libs that are just as enjoyable as Rails was a decade ago. With all the benefits of a static lang.
How is it better than Clojure? I
Are you also bringing in Jython? 
I will toss in my own vote to emphasize maintainability. It's verbosity exaggerates unreadable or over engineered code. You'll see that stuff right away in PRs One thing I'm conflicted about is that I would never write Java without an IDE (intellij specifically), which some argue makes writing unmaintainable code easier. OTOH maintaining readable code with an fully featured IDE search is bliss, I mean an IDE that fully understands your references (not just string match). 
Probably wanted to say how following certain design patterns (especially in bigger companies) can end up with having obscure and unreadable code. Often, following simple OOP design principles, based on common reason, is the best approach in my opinion.
I do to actually. It's just that these day's it's not the hip new language. That's why I put the "fun" in quotes. 
I haven't actually looked at the code for these projects, but I would very much expect them to follow those principles. Akka's Java components. Play Framework's Java implementation ReactiveX etc
Those. 
that was true, but now you can write a hello world with jshell ;)
As someone who will soon enter his 4 month of unemployment because of burnout, I will add what others have said about leaving as soon as possible (don't feel too bad about me, my country has great social care for people in my situation). It only took me about 7 months before my body couldn't take it anymore. However, about a year ago I worked some months on a 30kLOC (including tests) Ruby on Rails app. While Ruby is a good language and Rails is a nice framework one thing Java does better is tooling. I used RubyMine, and while it's Ok, IntelliJ is just miles ahead. So that's one thing to look forward to. Another thing I found was that I had to use a library to connect to a SAML server and it took me several weeks of monkeypatching and learning the internal implementation of the library in order to get it working. This autumn I had to do the same using Java and it only took me a day or two. I had the same experience using other libraries where the Ruby ones felt very unpolished and the Java ones were rock solid. Now that could just have been my experience (and Rails most definitely was rock solid), but if you've used unpolished gems you may find Java to be nicer in that regard. Overall my Ruby experience was fun and I'd do it again without hesitation, but those two things annoyed me. Less exciting for a Ruby developer, but since Java 8 we have streams and lambdas. And since Java 10 we have local type interference so a bit less `StringBuffer sb = new StringBuffer();` and a bit more `var sb = new StringBuffer();`. Again nothing you should be excited by as a Ruby developer, but hopefully it'll make Java less boring and hated. At last there are exciting things like JRuby, Kotlin, GraalVM and others, but I doubt that a toxic management will let you use those so I'm only mentioning them in passing. Finally, no matter what language you'll end up using I hope you'll find a non-toxic workplace before things go too bad.
Have you tried Kotlin yet? 
Much easier for those who come from other Algol based languages to come to grips with it vs a Lisp descendant. 
This is the best resource that I found when I was just getting started: http://mooc.fi/english.html
It just means you’ve not been exposed to a particular style of development. There is still plenty of scope for you to be a moron
These.
This made me chuckle
Which are the most important design patterns in your opinion?
You mean strings aren't integers?! Well that doesn't make sense to me! 
No, not at all. I must admit I am a bit reluctant to get into yet another jvm language. A lot of posts saying how amazing it is, but I have not taken the time to look at all at what it is or why so many say that. I think Clojure is absolutely amazing with all the read-only data-structures and good abstractions, and improved LISP-syntax that is a pleasure to work with in a good editor REPL, and optional static typing.
What an idiotic thing to say when the person is talking about migrating from Ruby to Java
I'm not really sure what you mean by file management? Java has a full set of IO routines, and lots of high quality libraries for generating things like PDFs if you want to do that.
It is mainly syntax, and pretty minor to be honest. Like instead of o.f(x) you type (f o x), more or less. It is not like trying to wrap your head around Haskell or Prolog. That the entire language is built around things that are immutable is the huge thing, but very easy to get used to (more difficult to get back to work in languages where immutability is not everywhere so suddenly things can change from underneath my feet again). But as I said in my other comment I have not looked at Kotlin at all yet. Probably should though, both because of all the hype and that I work with Android all day (mostly C++ though, very little Java nowadays).
I believe most of our team's responsibility is transferring files. I've done basic File IO in java before but I'm asking about practices, patterns (good/bad), regarding IO at an enterprise level. The answer may be there is no real answer. Just trying to come in prepared tomorrow. 
I'll agree that this isn't a great sign. I favor Java over Ruby bigtime, but the language he is using here isn't exactly "encouraging". I'd tout why I find Java to be better in general in technical terms, industry support (developers). Complaining that it's a hobbyists language is meh. Don't get me wrong, I think he has a point, but I hope to hell he went a little deeper.
There's no such thing as "most important" patterns. Patterns are a tool. When used appropriately, they help you. When used for the sake of using them without a good understanding of why you're reaching for it, you'll probably end up with something that's less easy to read or maintain than it otherwise would be. What I *would* directly answer that question with, though, is that you're typically well served by following SOLID design principles. Write code that has a single purpose. That takes its dependencies in rather than creating them. That relies on interfaces, not implementations. These things will do orders of magnitude more for your codebase than any one pattern. 
**Electronic data interchange** Electronic data interchange (EDI) is the concept of businesses communicating electronically information that was traditionally communicated on paper. The two classic examples of such information are purchase orders and invoices. Technical standards for EDI exist to facilitate parties transacting such instruments without having to make special arrangements. EDI has existed at least since the early 70s, and there are many EDI standards (including X12, EDIFACT, ODETTE, etc.), some of which address the needs of specific industries or regions. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; Because it's relatively old it has had time to make and fix many mistakes that more hipster approved languages are suffering from. Only saying this because Ruby was specifically mentioned by the OP, but Ruby is only 7 months younger than Java :-D
I had the same reaction to Java coming from a Ruby background, but if you can get past the initial hump it's more versatile than you'd think even though it's an older language.
I think Java is basically the least bad language. If you look at the spectrum of good and bad parts of any language, I think the worst parts of Java are less bad than the worst parts of just about any other language. Java is the worst language, accept for all the others.
Is there a page somewhere that describes what all these different packages are? Or do I need to Google each one 
Was just reading that article :) And yeah of course I'll ask them. Can't hurt to do some early studying. 
Thanks for the info, you have been very thorough. When you sign up for an account what data do you have to input? You think the token may contain the IP address or MAC address of the device but what good would that be for authentication if the server didn't know which IP/MAC to expect? IP addresses change too frequently to be reliably used for authentication. For example if you are on Wi-Fi at home then leave the house your device will cut over to the 3G/4G network and you will be assigned a completely different IP address. This would actually be a good test if you want to determine if the token is IP address related. Generate a token, switch off Wi-Fi, generate another token, compare. At the end of the day, the application is sending a digest of several essentially arbitrary values to the server over an encrypted channel, not much different to a username and password combination. How would you go about creating a token for another user? This would require knowing their IP/MAC which is difficult without physical intervention such as stealing the device or hacking your Wi-Fi AP, or having them visit a website you control which would yield just the IP address of the gateway. If you still want to go ahead reverse engineering this, then you should provide samples of the token including which device/connection it was generated on, and the MAC/IP of each. If you want to know for sure how it's doing it, supply more of the decompiled code, or the entire de-protected APK or .class files. I don't know how Android is different from standard Java but inspecting the bytecode should be enough to determine what it's up to. Also, MAC addresses are generally displayed to users in hex, so I'm not sure what you mean about encoding the addresses into hex. It is perhaps applying some sort of trivial obfuscation (think ROT-13) so it isn't immediately identifiable as a MAC address. If you want to do this privately, PM me.
&gt; "static typing does not have to be that bad, that is just Java's type system" Well, it's not Java type system either, but the way you use it. If you've got Blah&lt;Sometype&lt;TypeZ[]&gt;&gt; all over your code, you do your code wrong. Second, I guess most complaints about strong typing come from people having to type in variables' types. Especially variables that are results of function. But this is solved by proper tools. Type in a function, place a cursor on it, in Intellij press the "introduce variable" shortcut and just type in the name of the variable. IDE does the rest of the job for you. In return you always know the exact type of the variable just by looking at the code. No guesses, no hidden catches, no compile-time or (God forbid) run-time checks. You just look at the code and know what exactly is going on. 
LOL, thanks!
I'm a complete beginner and maven has been nothing but awesome. Gradle on the other hand... 
I remember when I finally got Maven really working for me. That was so awesome.
I need to check it out, then. Have been using Eclipse for years. Is it completely free?
Hehe, good one!
The community version is free!
Funny, like I said, I don't think I've seen a single project that maven hasn't been at least mildly annoying to keep going. And like I said I'm not even building with it, just using to download the jar files. 
Several comments on verbosity ITT. I’m big fan of Lombok for combatting this. Reduces the code without having to go all the way to a derivative language like Kotlin. (Kotlin is great but probably not relevant here). 
I have worked with lots of different languages in my career: Pascal, COBOL, VB, C, C++, Smalltalk, Ruby, and, now, Java (and others, the list reflects my age). Engineers who complain about languages and say this one is the best and that one is the worst, are, in my opinion, wankers. A competent coder should be able to express him or herself in any language. There are advantages and disadvantages to every language. I adore overloaded operators. But I can get shit done without them. I think overlays from COBOL are really clever, but I don't need them. Java is a perfectly serviceable mature language with a staggering compendium of available libraries. There's something to admire in any language.
I think the whole point of maven/gradle is to use it to download the jars *and* build it seamlessly,
Jsoup - amazing for "static-ish" sites. Can't run JS at all so sites that use react a lot won't work. I'd recommend PhantomJS is you need the ability (currently no maintainer but oh well). Runs off selenium engine and has a really nice JS api.
Yo if your with a shitty consultant firm, run as far as you can after those 6 months. Doesnt mater how much money they through at you.
It's not that much better that it's worth adopting a new language with god-know-what performance errors and other potential issues. 
It's still new and has issues. Google it 
The really weird thing with Ruby is honestly the Japan / US disconnect. The US Ruby became the goto for Ruby on Rails and making quick webapps. In Japan its thriving, but in the low level and embedded space. 
Used to be Java/JavaScript but recent career change to C# Miss Java often.
Write both Kotlin and Java for a fortune 50 as my day-job and couldn't disagree more. Kotlin is just a much better Java. A java dev can pick it up in a week or two and will be more productive in a month or two.
Why dare? It's objectively better. Crossplatform, much better inspections, much better shortcuts, thousands of different plugins for many languages.
I saw that you could step backwards in Visual Studio in debug though!
 &gt;You'll cringe at some of the types like *Map&lt;&lt;T extends ?&gt;,&lt;L super ?&gt;&gt;* vs dynamic langs' tuples and dictionaries. If he likes Haskell, that type is the best part of the type system, as opposed to everything that relates to Object and type erasure. 
I heard people saying performance of JVM is better than Ruby, but I am not familiar with Ruby. I cannot say it is right or wrong. If your company starts from scratch for Java, take a look at Kotlin.
/u/b1ackcat already said it below. I think dependency injection is one of the most important techniques used to achieve decoupled, modular and testable code. When I say DI, I'm not referring to frameworks such as Guice. I'm talking about the pure design principle. Of course, there are other commonly used patterns like strategy and factory, singleton, decorator, facade, etc. 
What IDE do you use? The big 3, NetBeans (my favorite), eclipse and IntelliJ should all have excellent support for something as old as maven. Oh and about the downloading jars part, it's nice that in mavrn/gradle it can auto update it for you so that you don't have to go hunting on every website every day looking for updates. 
&gt; What IDE do you use? The big 3, NetBeans (my favorite), eclipse and IntelliJ should all have excellent support for something as old as maven. Most recently Eclipse both at home and at work. A few years ago it was Intellij that had a serious issue where it would say it ran Maven but really it didn't, and I had to run it from the command line to build the project as a workaround. Did I mention again that none of this is actually necessary, that we dealt with downloading jar files and compiling code just fine before maven? Maven was supposed to - &gt; Oh and about the downloading jars part, it's nice that in mavrn/gradle it can auto update it for you so that you don't have to go hunting on every website every day looking for updates. No one who's a web developer had to "go hunting on every website" or any of the other b.s. maven marketing made up to pretend maven was solving any sort of huge problem. If maven worked correctly 100% of the time, the annoyance it solved was dealing with jars that were dependent on other jars. Like you'd download spring, but also have to download apache commons, and then sometimes different projects would both use apache commons and it was mildly annoying to deal with when you wanted to update stuff, and a little more annoying to try things out because downloading the jars took some time. Thing is, before maven once you had the jars downloaded and in source control and working, they **always** worked past that point. Like the only way it wouldn't work is if source control was down, in which case it wouldn't matter because you couldn't get the code either. Maven isn't like this, sometimes it just messes up when you're building even though you haven't changed any libraries, and you have to be interupted with what you're doing to track it down and fix it. Before Maven -&gt; slightly pain to add new libraries or update existing libraries but once you did it and got it working and checked into source control it was rock solid and always worked for everyone After Maven -&gt; Easier to add new libraries and update libraries, but adds in headache in initial project setup and occassionally while doing development at random times when something glitches out
Bear in mind that the types of applications you write in Java shrank considerably in 20 years as well. These days, the majority of Java is web backend work.
That still makes it a maven problem. Still, had I only once run into a maven bug like this, I probably wouldn't mention it and just chalk it up as a random bug that happens. I mean hell, back in the day, intellij had a bug with not removing compiled anonoymous class files when you recompiled. I mean that's a java-level bug. Just one bug I'd have forgotten about it. But with maven a year goes by I hit another bug. I switch ide's I hit another bug. I don't remember any of these bugs being total showstoppers, but they are annoying, and I'd think by this point with maven not being that complex in it's function of getting your jar files, that I wouldn't run into them at all any more. 
They
Use sbt for a non-trivially sized project and you’ll be longing for maven ;)
lol, hey man, I never claimed that maven is the **worst**, no doubt there's much much worse out there...
fwiw you can shoot yourself in the foot with any build system 
All the answers are about technical stuff, but have you looked at this from a professional point of view? In your place, I would be really excited about this opportunity. First, your team is leaving while you are accepting the strategic direction of the company, which should translate into a good position. You should be expressing your enthusiasm to learn new things and grab every opportunity to participate. Java programmers are very well paid, and the company will finance your acquisition of this valuable expertise. Congratulations on your good fortune.
I don't really have an opinion on Maven as a build tool, I'm just tired of running into minor but consistently annoying maven bugs with dowloading jars and dependency management. &gt; Especially if you're going to channel that frustration into getting into fights on the internet and calling out people who downvote you. I've seen an entire department implode as someone forced every "new shiny" into our project to the point where we couldn't get anything done. They also had the same "if I don't like it it didn't happen and didn't exist" attitude you guys do. At my next job I saw my poor boss - who was a pretty nice guy - get completely reamed because he was nieve enough to believe this bullshit on the internet, and rather than sticking with tried and true solutions he believe these stupid claims about speed and reliability, and realized to late for him to keep his job that they were bullshit. He needed to stick with stuff we could get stuff done quickly with that was reliable. That job was specifically where intellij would say it would run maven but then not actually do it and we ended up needing to use the command line to run. That wasn't the worst of the problems, believing the bullshit that Thymeleaf was way faster and way better than jsp's was the biggest problem I was aware of, when half the team was familiar with jsp's and no one had any experience with thymeleaf. So after a ton of stress and a few people losing their jobs over the insane push of half-developed frameworks, yeah, I say it's absolute bullshit. Maven is nowhere near the worst tool I've used, but it's certainly not "rock solid" in my repeated...and repeated...and repeated experience spanning different machines, different ide's, and entirely different companies. It's not in my top 10 wastes of time, but I just find it a bit absurd how many times I've had to hack it to get it working recently when what I'm doing with it (just dependency management downloading jars) is so simple.
CamelCase methods and `foreach` :)
&gt; A straw man is a common form of argument and is an informal fallacy based on giving the impression of refuting an opponent's argument, while actually refuting an argument that was not presented by that opponent. One who engages in this fallacy is said to be "attacking a straw man."
PhantomJS has been discontinued in favor of Chrome headless (which is in the production build since 65).
stable af, less dealing with shoddy libraries. rock solid servers. platform independent. 
&gt; Programming languages typically have a 20-40 year lifecycle. Ruby was on top in the 00's but now is kind of on life support. Ruby are maybe 2% of job postings. Java is more like 80%. From a risk mitigation perspective companies choose Java. I wouldn't give every language a fixed lifetime. Ruby and Java both were created in 1995. I'm quite sure Java will still be strong in 20 years. Maybe in 40 years as well. It all depends on how it's managed. And then there are languages like JavaScript where it'd be absolutely everywhere even a century from now, because... browsers (and yeah I know - WASM, but we'll see if that ends up *replacing* JS, my strong hunch says no).
Java is in more places than you may know. It's in your Blu-Ray player. It's in your ATM kiosks. Believe or not it's also on the chip in your credit card. Also... mobile apps. It's not Java... but it's Java.
Check out the articles from [Not Your Father’s Java: An Opinionated Guide to Modern Java Development](http://blog.paralleluniverse.co/2014/05/01/modern-java/). Great examples of modern and even lightweight java apps.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is IntelliJ better than Eclipse? If so, why?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You don't have to love or hate it. It's a job. 
This is definitely true if you're coming from dynamically typed languages only, but for someone coming from Haskell, with many of those things... Java will be worse at them than Haskell :/
Dependency management is anything but simple.
I've written Java on and off for 15 years and it's much more developer friendly now. In the old days we had to use Vectors and reading a file was cumbersome. The language has had much improvements over the years. Innovation has been slow, but that's a tradeoff since it could wait and see what worked in other bleeding edge languages. With the new release cycle innovation has sped up. The language is not its main selling point, the JVM and its ecosystem are. Developing and running Java applications is easier than ever. 15 years ago I spent 25% of my time writing business code and 75% writing low level stuff, now it's reversed.
Fair enough. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/8ea6v8/state_of_async_programming_on_the_server_side_in/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I don't follow. But, while we're at it, `Integer` is also maybe a number. Or `null`. `int` is definitely a number.
[removed]
[removed]
Can someone clarify please: Does this mean if someone (customer etc.) sends me a program (at work), which just happens to be written in Java, my company has to purchase a Java license otherwise I cannot run it (unless it can execute on an outdated and possibly insecure runtime version)?
As the professional, it does not matter to me what the programming language to use in my day to day job. It's the same as for the builder, you can like the tool more or less but the tool does not matter to do a great job.
I moved from Ruby to Java. Ruby was one of the first languages I learnt but Java I learnt in my first proper development job. I loved Ruby and struggled with Java initially but now would find it quite difficult to switch back again: * Static typing. This is really awesome but also the dependence on reflection is far less in Java. I find 3rd party code to be very easy to read whereas I would continually get stuck reading another person's Ruby code. Where does this variable come from? Where does this method come from? Everything is much more explicit in Java. * Platform independence. Being able to write code on any OS and have it run on any OS is really great. Not just your code but any library you depend on as well. The abstraction is also much greater with Java. With Ruby, you would get cross platform packages but you would always get build warnings e.t.c. saying that some feature or another was not supported on a particular platform. Not so with Java. * Spring Boot. I find this framework to be fantastic because it is the only one I know that strikes a balance between full stack frameworks and micro frameworks. You can glue together all of the individual libraries that you want, writing reusable auto-configuration as you go, or just use the glue that others have already written. This makes it simultaneously much more flexible than Rails but much less bare than Sinatra. * Dependency Injection. I know some people might hate this and Ruby has no need of it but I found that by religiously using constructor injection, the complexity of my code has dramatically decreased. * Stateless services over Stateful objects. I feel that Java tends to be more functional and less object oriented that Ruby. That is not categorically true but ActiveRecord like frameworks are not nearly as popular in Java. I much prefer this style as I find stateless methods much easier to deal with even though it has been criticised as an anti-pattern: https://martinfowler.com/bliki/AnemicDomainModel.html. * IDEs. Seriously, I'm not sure how I manged to write as much Ruby as I did with vim or other text editors. Refactoring, debugging and easy access to all the tools I need make me much more productive. Try IntelliJ.
Personally I just use JSCAPE with tls enabled.
Absolutely hot topic. You've hit gold OP !
I don't know why ppl are downvoting you. Maven can be a bitch if it doesn't work right. 
Well, some C# fans may murder me, so I muttered all my courage to dare say it XD
That's cool, didn't saw that in IDEA, but I don't always debug, I find IDEA's "intellisense" to be superior and more helpful.
Lombok, Spring, Hibernate, gson, Apache commons, Guava collections
Spring framework core
I agree if you compare tools that are equally suitable. However, different tools have different advantages and disadvantages. If long-term maintainability, powerful IDE support for refactoring, and scalability are critical then Java may be more adequate than Ruby. 
is guava still relevant in the post java-1.8 world?
Personally, I found Ruby's support for this was better because I could add/change method signatures. In Java, I believe I need to pay for JRebel to get that some functionality. The standard hot reloading supported on the JVM does not allow this as far as I know?
There are still a few bits in guava that are just simpler than java8+ counterparts. I still use Joiner/Splitter and EventBus - so if there are easy replacements for them I would be happy to replace them.
I am excited about Java's new aggressive release cycle. I see Kotlin does look a lot better, but I hope with the new releases Java will quickly catch up. Nothing against Kotlin
&gt;There are absolutely a few hidden surprises: The first thing you learn is primitives and operators and I'm about to the point of thinking they are last resorts. &gt; &gt;int i = 0 &gt; &gt;if \(i == null\) \-\&gt; null pointer exception. \(Why is this not a "compiler type check"?!\) &gt; &gt;int i = 127; Integer j = 127; \(i == j\) == true &gt; &gt;i\+\+; j\+\+; \(i == j\) == false. \(because auto\-boxing moved out of the constant pool or something?\) &gt; &gt;There are also hidden surprises when apparent closures of class values inside a lambda in a method aren't in fact changed \- rules about the necessity of "effective finality" or something, but the compiler doesn't always catch it.
Apache Camel: http://camel.apache.org. Abstracts communication for your application. Say you build a Java process that sends everything via JMS, and someone wants you to support a legacy format using a socket. If you already used Camel, your changes would be contained to your Camel configuration, requiring minimal changes to your actual application. It also provides standard communication patterns, like splitting a message, filtering a message, etc. Might be a bit too heavy for smaller projects. 
I never liked Lombok, seemed to cause me problems all the time. I just wrote getters by hand.
I'm still using quite a bit of Guava stuff in my code; far more than Apache Commons. And that's after refactoring to use Java 8 stuff. I could probably remove some of it, but other parts definitely is still required.
AssertJ is also nice in this space. Has a similar feel to the FluentAssertions library for .NET
That is how I'm approaching it. 
I'm not. I work in Fintech.
Java was the last language I had any negative feelings towards. I got past my JS biases a couple years ago. Java is just the butt of every joke in the Ruby community and everyone on the team is being really negative about it (granted, this is not the only or biggest problem our org is facing). I wanted to see what people who use and enjoy using the language say about it.
The collections most certainly. Multi map and set are useful, as are the list + 1 wrappers.
User preference, some like eclipse more, some intellij. For me the skin in intellij (darkula) looks awesome. 
In my opinion, the best language for a project is the language that the people assigned to the project are most experienced with. If I were assigned a group of Ruby programmers to do a task, I would try to figure out if the project could be done in Ruby. Obviously, other things have to be taken into consideration, like, you probably shouldn't have 10 different projects in 10 different languages in the same organization. Having written things in both Ruby and Java, I find them more or less interchangeable. Ruby is a little more wordy and has a couple of clever things like the "if not null" operator (or whatever it's called), but, really, it shouldn't make that much of a difference. I think the practice of shitting on programming languages tends to be both an elitist behavior ("I am better than Bob because I know Ruby and Bob knows Java") and tribal identity ("Our group is superior because we work in Ruby and that group works in Java"). As I said above, I would expect a professional developer to be able to adapt and express himself/herself in any language. I would encourage you to adapt that sort of positive attitude: look forward to learning another language for your skillset and resist the urge to wallow in negative and non-constructive moaning. To actually answer your question, advantages of Java: - Garbage collection - Cross-platform - Huge pre-existing collection of libraries Disadvantages: - Some people find it involves too much boilerplate (lots of getters, setters, and constructors) - Build dependencies can be very difficult to manage - The most common dependency/build management system (Maven) uses *gasp* XML to configure - Some people feel that the JVM is too memory-hungry
- Spring - Hibernate/OpenJPA/EclipseLink (choose one, probably Hibernate) - Apache Commons - Guava - JUnit/TestNG (choose one, probably JUnit)
My entire company uses it with no problems. I definitely disliked the experience more when I was using Eclipse because the Eclipse integration doesn't handle a lot of things well (refactoring, finding usages, etc). The Intellij plugin is much better.
Preconditions, immutable collections, services
I can't stand Lombok. I don't like how you need to instrument stuff to use it properly. I like my projects being able to be open by ANY IDE and just go. Lombok kills that premise and I won't use it. That said, I see its appeal to folks and I don't begrudge folks for using it -- I just prefer not to. The last time I touched a Lombok project I had to wade through the Jr. dev's project with a giant machete and Lombok was part of my cut job. In the end, I think Lombok wasn't the problem, but cutting it out made it easier for me to navigate and fix the rest.
I find myself using `ImmutableMap.of()` , etc a lot. I think that's the only aspect of Guava I use on a regular basis post 1.8 now that I think of it... maybe I should stop using Guava...
[vavr](https://github.com/vavr-io/vavr), if you want to write like Scala.
I'd switch Gson for Jackson. If you need to fetch just a few properties Gson is way to verbose IMO.
If those maps are copied to other immutables often it reduces the memory foot print.
Can you give some examples of these interesting problems? Because I'm ... err ... interested.
Another gotcha is like when some method returns a Map \- but it's actually an "unmodifiableMap" \- so it doesn't actually satisfy the interface, it just throws runtime exceptions when you call them, thinking it's, you know, a Map.
Everything to do with keeping the state persistent. A lot of interesting problems in enterprise integrations (like windowed sorting, cross entity dependencies etc) can only be solved by tracking state in a persistent way. For those reasons I find technologies like Apache Flink or Kafka Streams more relevant to solving integration problems than Camel. Camel just gives an API to implement those things but doesn't do the actual heavy lifting. 
Immutables, vavr, awaitility 
I've migrated lombok `@Data` classes to Kotlin `data class`. Of course introducing a whole new language to your project is a bit heavy handed, but I've found there to be less breakages since the switch.
Personally I would recommend to learn the JDK really well. It has a lot of functionality and there are some hidden gems in there. There is no particular library you really need to "improve" Java. 
If maven isn’t even in your top 10 worst tools and you’re this opinionated and angry about it, you need a vacation. Your boss was fired for having to use the command line to run maven? What? You lost me. 
So you added more noise and verbosity and that made it easier? Sad
YMMV, but I would definitely shy away from persisting state on some integration middleware. 
In a lot of integration problems there is no choice. If you need to change ordering or if you need to provide integration between unreliable endpoints there is no other choice.
If you can use Java 9, you can use `java.util.Map.of` instead.
Much easier to deal with than red squigglies and build failures. 
Sounds like a use case for a queue, or maybe some kind of event architecture? I'm tired at the moment, maybe that's kinda what you meant. Or maybe it's because I've almost never done integration between two legacy systems. There's usually a client that can untangle that kind of legacy mess.
Java has pointers but programmers can't directly access memory via one. And yes that means no arithmetic either. I'm not making a value statement here. It's a feature of the language if you will. 
I literally cried when I used JUnit for the first time because it saved me such much extra effort I had been putting into projects for a year. 
&gt; I just wrote getters by hand. By hand you mean have your IDE generate them for you?
Lombok works fine with any build system since it’s an annotation professor. Maven has no issue with it, and you literally just need to install an ide plugin to get the squiggles to go away. You did a ton of work to make the codebase noisier because you couldn’t be bothered to install something 
I agree, but Eclipse and IntelliJ can auto-generate getter/setters, equals, and toString implementations. 
Even those of us with companies that let us jump to new and shiny things are waiting for 11 to get the long term support. I wouldn’t recommend jumping into an already unsupported java version without good reason.
Yeah. What happens is you run into a reddit circlejerk. They create a mental image that their (topic) is godlike and infallible, and anything that contradicts that perfect image sets them off. I like Eclipse for example, but I can't imagine freaking out that much about someone saying they ran into bugs in it.
I think a process that can be fixed by clearing the cache and running it again isn't likely to be tremendously complicated. Tracking down the dependencies might be, but downloading them and keeping them organized enough to be stable and not buggy doesn't seem overly complicated.
I use it a lot for the event bus
&gt; If you can use Java 9 yep... which really means &gt; If you can use Java 11 But yea... I am looking forward to that.
&gt; just need to install an ide plugin to get the squiggles to go away This. Exactly what I said. I didn't say it was hard or some uncontrollable evil in the world. I just said I don't like it and don't use it for that very reason.
Does camel support clustering? (i.e., running "the same" app across multiple camel instances located on different boxes?)
Very much this. Some of these libraries and frameworks would more than triple the amount of code being loaded at runtime. (We know, because we measured.) The only stuff I've found that I really don't want to live without are JUnit and SLF4J/Logback.
Yeah, it can be overkill. We've gotten so used to it that we "require" / "encourage" developers to use it for all JMS communication, even for small projects. Mostly to keep a clean separation between business logic and communication. We have a bunch of small adapter processes that are basically defined by a single camel configuration (we use XML config, which I've grown to hate). For things like hosting web services we haven't really used Camel, mostly we use it for async communication (JMS, Redis, sockets).
Unsaid here is that it's impossible to say unless you have a goal in mind. There are so many wonderful libraries/toolkits/frameworks in the Java ecosystem (the biggest positive about Java) that we could boil the ocean trying to help you. Stream processing: Camel, Rx, Akka Reactive Microservices: Vert.x Dependency Injection: Guice, CDI, Spring etc... 
Java's verbosity can be reduced somewhat by using Project Lombok.
Don't worry, you're safe in /r/java
Meh, is the magic worth it? None of what `@Data` adds is that special. There are plenty of things like Guava's `MoreObjects.ToStringHelper` if you can't be bothered to create a string builder and do appends yourself. Otherwise, if your concern is missing fields as they are added, I'd say that manually adding them is worth not having a dependency like Lombok.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I agree with this. There is an *awful* lot of stuff included in the standard library. That being said, there's still some stuff in libraries like Guava that are pretty helpful!
The big value for me is keeping our developers from locking us into a single communication implementation. We had a legacy GUI application that basically glued a ton of code into multiple sockets. While not impossible to untangle, we could never get the money to refactor things to move to JMS. We would have all sorts of mysterious connection drops (threads were glued to sockets as well) that we would come out of no where (say once every six months). Now with Camel if I want to switch from JMS to Redis the change can be as little as a different configuration property.
I disagree, I'd rather turn on some IDE plugin and more than halve the size of my classes.
The standard lib has improved a lot. I think you still see a ton of code using java.io where java.nio has vastly superior APIs.
I’d add a mocking framework like Mockito.
&gt;Your reaction? "Who cares, I was entertained". That wasn't my reaction. I'm legitimately having trouble following your line of reasoning. \&gt; I can understand how, as a sociopath, you are incapable of understanding why people get upset when your actions cause bad things to happen to other people. Uhh... I think it might be time to take a break from Reddit, dude.
He's just starting. For the same reason I wouldn't bother with Spring and other enterpricy packages.
I would recommend against using SparkJava. Simply due to the creators refusal to change it's name. Believe me, it's almost impossible to google anything related to it.
Netbeans is now hosted on Apache Foundation : https://netbeans.apache.org. Netbeans 9.0 Beta handle JDK 9.
That's because the Kotlin compiler is actually designed to handle that. Lombok, by contrast, uses hacks to coerce the Java compiler into transforming the code like that.
https://en.wikipedia.org/wiki/Development_hell
In that case, you might want to consider Scala or Kotlin, which have built-in equivalents to Lombok `@Data`.
[Scala](https://scala-lang.org/), if you *really* want to write like Scala.
Go *purchase* the study guides to the OCA and OCP (certifications). They explain everything very well!
The stack I am using on Java 10 has been enjoy so far. Server: - AutoValue (alt. Immutables) - Caffeine (alt. Guava Cache; author) - Typesafe Config - Guava + Apache Commons - Failsafe - Flyway (alt. LiquiBase) - Guice (Dagger on Android) - Hikari + Flexypool - Jackson + JsonPath - Jetty + RestEasy - jOOQ (on Postgres) - slf4j + Logback (alt. log4j2) - Retrofit + OkHttp - Univocity CSV - Quartz Testing: - TestNG + Hamcrest (alt. JUnit + Assert4J) - Awaitility - Mockito - H2 Build: - Gradle - JsonSchema2Pojo - ErrorProne + PMD + SpotBugs - JavaPoet (for custom codegen) A nice thing about the Java community is that there are mature alternatives to the above, each actively maintained and well thought out.
Thanks for this info. But, is Oracle trying to Kill java? Netbeans isn't even at complete Java 9 and Oracle has dropped Java 9 support, and gone directly to Java 10. You can now download only Java 8 and Java 10. http://www.oracle.com/technetwork/java/javase/downloads/index.html 
I've noticed Java only makes me "feel productive" by making me write a ton on boilerplate code like accessor methods and constructors that just copy their arguments to member variables. I'm more partial to Kotlin than Scala, but I really appreciate what they're trying to do with Scala.
I'd switch Spring for Java EE. If you need just a simple app Spring is way too verbose IMO.
Jsoup
yea, I like that they are expanding the standard library in each java version. Quite a lot of good stuff in there.
Many of the things said here plus all the clever people that make up the community. There are tons of resources if you hit a problem or need a tutorial. You can meet with them at a conferences and talks in your vicinity (see JUG, Devoxx, ...).
thanks
Well of course, how could you possibly know if the previous FizzBuzz value is valid unless you examine the ledger? This is a no-brainer.
Kinda off-topic, but does anyone know of some alternatives for localization instead of ResourceBundles? I always found ResourceBundles to be unfriendly for external translators because of the positional placeholder approach ({0}, {1}, ...) instead of clearly speaking named parameters ({name}, {listCount}, ...).
Uh by hacks do you mean a preprocessor run before compile time? Because I'm pretty sure that's how it works.
Hm I've never actually used Jackson. I'll check it out. Usually if I pull out gson it's for some relatively heavy duty stuff though. It was the first json framework I used which let me transform json directly into POJOs so I'm pretty biased. I will say the TypeAdapter system can be very cumbersome. Also I always dread the "declares duplicate uid fields" error. It's always solved by some random bullshit that makes no sense.
&gt; I used RubyMine, and while it's Ok, IntelliJ is just miles ahead. So that's one thing to look forward to. RubyMine is from Jetbrains just like IntelliJ is. In fact, if you have IntelliJ Ultimate and install the Ruby plugin that is RubyMine that is embedded in IntelliJ. Not sure the issue you had with RubyMine but is it possible that since Ruby is dynamically typed the IDE just can't help you out as much as it can with a statically typed language? 
bad bot
I large codebase written in a dynamically type language is unmaintainable.
**Language related:** *Main features:* Stream Lamda Functional Interface Functions https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html New date time classes Method reference Default method - here is complete list http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html VM wise: Metaspace flags to enable hardware backed AES encryption on certain hardwares. Java mission control 
So can NetBeans. This still doesn't take the pain away from a scenario in which a junior developer auto-generates a Hibernate entity class for a 200-column database table (created by an equally inept junior DBA), complete with getters and setters, equals and hashCode, and multiple constructor variants, and sprinkles some rando utility methods in with the getters and setters. There's nothing quite like getting a blank, vacant stare when you blurt out, "dude, @Embed some of that bullshit" during a code review, but Lombok would have been a godsend on that pile of shit project.
I'd argue that users of Lombok should look to Scala or Kotlin. I'm happy with Java myself :)
In lieu of silly religious arguments, how about I amend it to: - Spring/Java EE (choose one)
I'm a big fan of runtime code generation when it can be done, so this is a change I'm looking forward to. Tentative woot!
Lombok. It'll save you a ton of typing.
Caffeine is better here. It was done by the same guy that did LoadingCache. It is more Java 8 friendly and faster.
Lombok just doesn't really do anything useful. The most useful part, value classes, can be done with annotation processing libraries (AutoValue, Immutables) without doing bytecode manipulation. I hate the fact that Lombok binds you to a very specific version for the JVM. It breaks every rule of a good library and it blows my mind that it is so often suggested in these types of threads.
This was the resource I used a few years ago, it's pretty comprehensive but also easy to follow: https://github.com/shekhargulati/java8-the-missing-tutorial
&gt; Lombok works fine with any build system since it’s an annotation processor Lombok is NOT an annotation processor! That is the big problem with lombok. It predated annotation processors and does all of its stuff through bytecode and AST manipulation. I would have much less of a problem with Lombok if it was actually an annotation processor.
&gt; Because I'm pretty sure that's how it works. You are pretty sure wrong. Lombok works by tying into undocumented compiler apis and doing direct AST and bytecode manipulation. How do I know this, because lombok frequently breaks on minor java updates. If lombok was just a preprocessor or an annotation processor library I would have much less of an issue with it, but it is neither of those things. There is a reason this is in the lombok source https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/javac/JavacAST.java
There were many contributors to Guava's cache, or else it wouldn't have been so good! Caffeine gained a lot from building on that experience. Definitely please don't mistakenly dismiss their hard work, as we tend not to share credit appropriately in our industry.
Fair enough. Wasn't necessarily trying to dismiss LoadingCache as it is definitely better than it's ancestors. But Caffeine is simply more polished and fixes some of the LoadingCache mistakes.
I've long wondered what the numbers look like on JavaOne. Did Sun make money on it. Does Oracle? My guess is no and still trying are the answers. Hence the change in format.
Thanks! I wrote Caffeine but feel bad when I'm given credit for others hard work. :)
There is no need to ist StringBuilder. Just have your ide concat everything together. The compiler will do the rest.
One of the most useful bits I've learned is the String API, followed by the List API. 
Nah might as well start with the Spring basics.
Of course, they are the same thing in bytecode. Can't always toString everything, but for the Lombok replacement, sure.
Just right click and generate the boilerplate.
nice, don't stop posting :D
If I may ask, how is your project non\-standard?
Java release cycle is now every 6 months.
This. They have an active and helpful discord community too
yep the years I went it was usually around 15K. Figure about $1.2K each we're looking at a budget of $18M not including sponsorship. Of course they're spending a boatload (literally) on entertainment, food, services. The Wednesday night gig out on Treasure Island, with top-tier bands. How much to you think Pearl Jam or Elton John asks for headlining? Not to mention they must charter every coach bus in town.
Your question makes no sense. One requirement of a good api is to be easy to mantain. I think what you are asking for is if it's better to start big and implement all the patterns everywhere or to start small and build the api while requirements grow. And my answer to that is: it depends. But, I don't like to solve problems I don't have, so I often start small but scalable. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yeah, AssertJ has a nicer, more discoverable, API, at the expense of being hard to expand with custom matchers. Your choice of Hamcrest or AssertJ really depends on which you'd prefer. (Also Hamcrest should really get a new release out at some point to make Java 8+ nicer to work with)
Reading it means nothing. Try now to build something, I bet you'll pause and be like 'how the f#5k does a thread work again'....
No one writes boilerplate anymore. They use IDEs, lombok, etc. In any event, language supported data classes with full decomposition and pattern matching will be in Java very soon (Kotlin doesn't have that). The Java version will be best of breed too. 
&gt; But then, our build environment is not the standard just-get-everything-from-the-internet project, It's weirdly not entirely stable at handling that either. Justvthis afternoon the girl across from me's environment started wonking out and giving her a bizarre error message for no apparent reason. What ended up fixing it was manually deleting maven's cache and also running a maven update after that. It's just weird maven is still just not entirely stable.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8egg3b/add_decimal_value_counter_to_jslider/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Immutables: https://immutables.github.io Dagger: https://google.github.io/dagger/
RetroFit is my all time favorite HTTP/REST client library. Just annotate an interface and away you go.
https://github.com/google/guava/wiki/PreconditionsExplained &gt;Simple, varargs "printf-style" exception messages. (This advantage is also why we recommend continuing to use checkNotNull over Objects.requireNonNull)
The biggest thing from Maven's viewpoint is that the build system's network is not connected to the public internet; data flows in only under tight control, and never out. The second biggest thing, probably, is that we very specifically *must not* arbitrarily grab newer versions of dependency libraries. As "automatic dependency management" is the (perceived) problem Maven set out to address, trying to use it on this project meant that nearly all of the time spent on "build system" translated into "working around errors because Maven is defaulting to behavior that cannot possibly work here". It's trying to solve a problem that we didn't have. Ditto for its "build cache", which is something that -- again, for our projects -- created problems while never helping us. Switching (well, switching *back*) to build tools that don't assume that we're constantly plugged directly into Github, or whatever this week's favorite repo hub is, simply avoids all those problems. But uttering the phrases "we chose something that isn't Maven" or "Maven is not a panacea" on this sub is just begging for the wrath of the CADT hivemind.
&gt; The biggest thing from Maven's viewpoint is that the build system's network is not connected to the public internet; data flows in only under tight control, and never out. The second biggest thing, probably, is that we very specifically must not arbitrarily grab newer versions of dependency libraries. Granted I've only ever used maven with internet attached, but it was my understanding that as long as you are hosting and installing packages in a network attached repository (or hell, locally hosted) it can be as private as you need it to be.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8egst9/i_have_become_proficient_in_javafx_especially_3d/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 &gt;Granted I've only ever used maven with internet attached, but it was my understanding that as long as you are hosting and installing packages in a network attached repository (or hell, locally hosted) it can be as private as you need it to be. That is correct, but it's not the default, and at the time would keep resetting to try and talk to the world given the least provocation. I'm told it's been fixed, but I've also heard the fix was incomplete and it will still try to reach out there for tasks that you wouldn't think would require an internet. &gt;I've also never had it grab **newer** versions, unless I specified a version range or snapshot. It was retardedly insistent that version X.Y needed to be replaced by version X.Y, even though we had specifically told it to only use X.Y which was entirely locally available already. Every version was newer than every other version, including the *actual* newer ones. (If it was Make, I woulda guessed a system clock error, but keeping correct time was not a problem on that network.) The guy who pushed Maven onto the rest of the team ("but it's what the internet uses!") finally lost his shit trying to debug what it was deciding to do, screaming at his monitor at the top of his lungs, which earned him a talking-to from the Colonel sitting down the hall along with a "put back the shit that you knew already worked and get back to solving the actual problem" directive. He transferred out of software work a couple months later and mostly refuses to even use (wtf!) a computer. I came in to help with the transition back.
Agreed, this isn't maven's problem.. this is their private repository's problem and a dependency management problem in their pom.xml(s).
Lombok _is_ an annotation processor. It doesn't do any byte code manipulation. &gt; I hate the fact that Lombok binds you to a very specific version for the JVM I've never heard this before. Can you point me towards something to read on this? 
So, you catch it early during code review, the dev learns how to be a better dev (hopefully), and you don't need Lombok? Cool. Sounds like a typical teachable moment.
Depends on the size of the project, but this can be disastrous unless you are on a relatively small project, or hiding the fields by using interfaces effectively.
https://projectlombok.org/changelog Java 9 support just landed, Java 10 support isn't there yet. We had problems going from Java 6-&gt;7 because of Lombok.
Depends on the size of the json you are processing, but on occasion it's worth it to be experienced in both a 'just serialize it pls' vs a 'streaming json processing' option. Both have advantages.
&gt; SparkJava Is this because of Apache Spark vs Spark Java? Until recently I thought they were the same thing.
Java spark! http://sparkjava.com super fast and simple Java microservices is easier to stand up than nodejs very little boiler plate required.
As someone who keeps seeing SLF4J around but has never used it or looked at it really, why would you recommend it?
It lets you choose what you want the logging back-end (the part doing the "actual" logging) to be. Logback is the native implementation, but there are others. My very first experience with it was in an older project, moving away from java.util.logging. Step 1 was to configure SLF4J to use j.u.l as its back-end. Step 2 was changing the client calls to request a logger reference thru SLF4J instead of j.u.l directly. Step 3 was in replacing j.u.l with a different back-end, and it wasn't until then that the project "actually" stopped using j.u.l, even though there hadn't been any mention of that class or package in the clients for a while.
Thanks! I'll go take a look at it.
:\(
builder &amp; control
Redis has pubsub capabilities, if you didn't know. 
They posted their pom.xml on the maven users list and asked for help. They were told they were using the tool correctly. Could they (well, "I" at this point) do it better now? Probably. Is anyone in this building willing to try? No. It's still solving problems that we don't have. I get that you feel the need to defend your favorite piece of software from anything that isn't praise, but you need to accept that it wasn't perfect, and could still use improvement.
Best Software Training Institute for Java,.NET, Python,Ios,Android,Php,Oracle ,Database, Matlab,VLSI&amp;ERP.We provides online&amp;classroom training classes
I heard JDK 12 comes with free beer.
Interesting, be sure to keep updating.
Apache Camel
Apamel. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'Apache Camel'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
Where are companies like this exist?
I didn't want people changing values on data objects. I just wrote getters and not setters. I guess I could have exposed final fields but I guess years of having my head pounded with getter/setter didn't allow me to see that as an option.
Yes, of course. 
You can actually just type /r/javahelp ;)
wow..
Retrofit2 - it helps you to consume REST APIs and even if you are developing server backend there are good chances to need something from other servers
Or Project Amber at some future Java version.
Really well written!
As others said, apache commons. I didn't see Jodatime in the comments, and I'm surprised. Although the new standard api made it pretty much useless, it was a huge improvement before. Still is in older projects. 
I think it can be done in intellij also by selecting the frame from the debug window and right click -&gt; drop frame. I never use it though. I always worry about messing with state when doing it.
Thanks! I'm interested in avoiding programming mistakes by design, so I'll write articles like this one from time to time :)
Thank you!
Java has a giant ecosystem with thousands of very good libraries, frameworks and tools. Plus Java is all in all a fairly productive language (mostly due to the good tools). And Java runs fast in many scenarios, but doesn't have the memory and safety issues like C and C++.
http://www.vavr.io/ - makes working with collection so much more enjoyable, and offers some more gems. you get pretty close to actual functional programming
If you choose to live by "study so i can pass" then you might've chosen the wrong occupation. It's not about searching a reason to learn a programming language, but quite the opposite. It's about having a problem and trying to find the best solution/tool to solve it. Getting to know various languages can really broaden your view about the possible solutions.
Well you are right about that and i completly agree. It's just sometimes a guy has so many things to study, research and projects to do it's just a bit frustrating wanting to give the time it deserves to a thing (like Java) and don't having it. So the stupid mentality of "study so i can pass" kicks in and well the rest is obvious. 
Didn't thought about that. Thanks 
Wonder if half of that is even necessary. Devoxx just shows a movie as extra, which is easy since it's already held in a movie theater. People go to the conference by themselves too.
I see. I'm going to have to make some time to explore that. Thanks 
fuck this bot
The mooc.fi course is pretty good it gives almost instant feedback. After part 1 you move on to part 2 which has a greater focus on OOP. Its not a bad course especially since its free. Not to mention other courses from other reputable schoo l like MIT that serve as an introduction to Java that is entirely free. https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-092-introduction-to-programming-in-java-january-iap-2010/
Eventually I found how powerful java is for fault tolerant and quick servers. Some people complain about the verbosity of the language but end up writing more code to enable a feature included in a java lib. To reiterate what everyone is saying... the tooling is somewhat unparalleled for the serverside (when you start talking about telemetry, threadmgmt, etc). But always right tool for the job...
Well that's a very interesting perspective. When i started programming in it i admit the verbosity made me somewhat uncomfortable since I wasn't used to it, neither was i used to think in a high level perspective. I think i might still need some training in thinking like that. Of course you are right, right tool for the job always.
Excellent! One of the best introductions to this subject I've read!
You're also going to have to get used to thinking in a somewhat functional programming manner if you're reading (and writing) modern Java. The streams API allows you to do some operations that previously you'd write in a loop. 
I use `filter` and `reject` in my current TypeScript project.
Thanks :)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html is probably as good as any. List&lt;Integer&gt; transactionsIds = transactions.stream() .filter(t -&gt; t.getType() == Transaction.GROCERY) .sorted(comparing(Transaction::getValue).reversed()) .map(Transaction::getId) .collect(toList());
Java EE was already coming back technically, but just as it was getting more popular and technically better Oracle dropped it. But take a look at Payara vs GlassFish what can happen ;) (If you don't know, Oracle got GlassFish thrown into its lap by acquiring Sun, but because it also acquired WebLogic from BEA a while ago, it had 2 Java EE implementations, so it decided to drop one; GlassFish. Then a tiny company from the UK picked it up, and made it far better than both the original GlassFish and WebLogic combined :P)
Well, that's way different from what i'm used to 
Very broad industry support! The future looks really bright. Lightbend has one of Red Hat's old EE evangelists working for them (Markus Eisele). Could be that he will get involved again too.
This seems pretty interesting. I'm going to have to delve into this. Thanks
It fits for all. You can write web server-side, console programs, desktop UI programs, simulations, games(minecraft is most well known) and small code-snippets in it. Also it's clear and strict about how you use it, (for example can't assign i = 5 in 'if' accidentally like in C), IDEs are smart enough to warn you when you are about to make a logical mistake, etc. Very well supported ecosystem by tools and users.
You can transform java.time to `java.sql.Date` just fine - using the valueOf factory on Date. I will add that to the article.
Yeah unfortunately I was talking about Java.util.Date
For `java.util.Date`, you can convert from and to `Instant` using the factory methods in the article. Converting other types to juDate is not possible because it does not make sense without zone information - first convert to `Instant` (using the conversion table), and then convert to juDate. Also see the compatibility section on the topic.
Microsoft is doing their best that Azure is the best option to deploy Java applications.
Javalin is a nice alternative
They're not opinionated....under the "more" menu they have a link to download Eclipse IDE, also in the footer.
What if Jakarta EE will be written on the top of Akka?
Not a Java specific thing but look into learning reactive streams as a concept. I think the best starting place right now is the Project Reactor library that is built for Java 8 support, but Java 9 has its own implementation of the standard. Then there's also RxJava and Akka Streams which work on Java and have their own properties you might like.
It's very popular and has a lot of tooling, documentation and libraries. With lambdas and streams it's getting better in terms of verbosity. 4 me main downside to java are those who code in java since they often reluctant to learn or tend to overthink/over-engineer stuff. If you like C you may want to learn Go or maybe smth functional. But one more language would not hurt
Thanks. I like lombok because it generally "just works." But, looking under the covers of a tool you like is often like watching sausage being made. Based on other comments I'm going to look closer at AutoValue and Immutables.
Dunno about "a bunch". "Slightly more readable" yes, but maybe that's worth it. If I were writing a new project from scratch, I'd probably give it a try. Not worth refactoring for a codebase that's already 1200 files and growing... 
Or Akka on top of Jakarta EE? Or on top of each other?
Java EE, renamed ;)
Oh nice, they went with the sailboats!
any different than google search in your firefox browser? Gotta pay the bills somehow...
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Not sure if being sarcastic or not :P
&gt; but this can be disastrous unless you are on a relatively small project I specifically mentioned "especially when not writing libs" for this reason. In an app w/out downstream deps, refactoring is easy.
&gt; years of having my head pounded with getter/setter didn't allow me to see that as an option. Yup, this has happened w/ large javadoc, getters/setters, over-abstraction, DI, ORM, etc, etc. Just remember, especially when starting new projects, that convention for convention's sake is not always the right answer.
Akka is generic, ie you can write almost any kind of application on the top of it. Jakarta EE is not.
You don't work in industry if you are going to say glassfish is better than weblogic. Sure maybe if you are running small java web apps that only use servlets but if you are maintaining enterprise applications and integration services you should absolutely be using weblogic over glassfish.
&gt; Not sure if being sarcastic or not not...
Because coding in C and Assembly is full on aginy while python has the functionality of a wet turd.
I'm confused. The author of this article appears to be unfamiliar with `Optional.or` and `Stream`, as it seems at a glance that all the Vavr examples can be recreated almost identically using them.
&gt;Struct MixedData does not have its data aligned. JUnion detects this and realigns the data automatically. The Jvm/jit does this already. Since java 7. http://openjdk.java.net/projects/code-tools/jol/
GP said Payara is better than GlassFish and WebLogic combined, not that GlassFish is better than WebLogic. And that resonates, I’m seeing many of our customers who were on WebLogic to Payara, or JBoss (but the JBoss migration may be more difficult since Payara and WebLogic share many components). WebLogic was once one of the best, but Oracle has been neglecting it for some time. Many senior engineers who worked on WL have bailed ship, so I’m not sure what future it currently has.
I thought it was pretty accepted that Optional should only be used as a return type, not a parameter type. There are other ways to clearly indicate which parameters are not required. 
Good bot
Gonna be honest I fucked up it's not from Guava it's from Apache commons. It's called "LinkedMap": https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/map/LinkedMap.html A java 8 version would be pretty nice. 
Optional or is available on java9. This is a java8 post. But thank for your comment.
Accepted by whom? The only other way I know of to make parameters optional is to overload the methods. I'm not going to argue the point, though. If you think is not acceptable, that's ok with me.
This sentence is ambiguous.
Hmm are you a developer by any chance?
Yeah, I tend to overthink because i'm used to thinking in "low level mode". I've been founding some libraries in Java for almost everything. I'm kinda scared i'd lose my low level thinking mode :D
Yeah so i've seen. I don't know why but i kinda had the idea of Java being this really resource heavy language.
does anybody know if this works with android. or if there are plans to include such annotation as part of a future java release?
I agree with that guy and I'm a developer. Java is the perfect middle ground in every single respect. Seriously, it's like the guys working on this shit could look into the future and chose the path. 
Okay sure, but if you're going to write an article about the shortcomings of Java 8 it deserves a mention that they are addressed in a future version. And what about `Stream`? Was it an intentional omission? Because if so it seems pretty disingenuous to imply the Java code in that article was the best you could do when compared to the Vavr code.
if you deploy software across multiple OS, it's a blessing when it comes to building. No building/linking nightmares and endless compiler options to get things to fully work elsewhere. garbage collection lambdas I think it's a great tool to have.
&gt; The only other way I know of to make parameters optional is to overload the methods. Right, and what's wrong with that? In OP's example it didn't even need to be an optional parameter (i.e. the hypothetical overload would have been a no-op). It really should have been a required parameter and the `flatMap` performed at the call site imo.
Yeah I'm starting to understand that by all the comments here
Akka's docs already have a (short) chapter on OSGi.
Please see this tutorial, I think Its very helpful for your learning 
The current release, has not been tested with Android. Regardless, it will work if the Android version supports com.misc.Unsafe, from a quick search, my guess is this will require at least the Android API level 24.
You need some jmh benchmarks for people to take you seriously I believe. Seems like memory pooling in disguise. 
/user/Scybur thanks for the downvote, but I'm on to you now. You're a SPRING zealot who's just trolling here. You almost got me! :P
You're right, the only logical use case for Optional as a method parameter is in private methods you control that exist for one of two reasons; you're breaking a large method up and need a helper method OR you are consolidating duplicate code. Even then this is only for reasons of convenience for the auther. Java 9 private interface methods allow for proper usage as I describe above for using Optional as a parameter. That's about the only place it makes sense in my opinion. The traditional knee jerk argument you most likely here is "b..b..but you have to check the Optional itself for null now." but even that is a pointless argument based on the assumption that there is not another way to design or flow the code. Optional as a method parameter is an anti-pattern. When you see it you should be getting a code smell about the architecture in this area of the code. If its a private interface method then go nuts.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Accepted by whom? The people who designed `Optional`
This... does not sound like positive news. The article says that Oracle Code One will continue to have a large Java focus for various things, so there's that, but I think I'm just too biased about Oracle to be happy about this, even if, as far as conferences go, it were the same. Are there other Java conferences in the SF bay area that are more worth attending? My cursory searches are not turning up anything of note.
In few words: 1. Getters/Setters are code smell \(especially when they come in pairs\); 2. Data classes as one of main targets of this library is also known target for refactoring. So my question is: why helping to write *bad* code faster?
What happen to make you quit information security? I'm aiming to be a pentester by the way
\&gt;Getting to know various languages can really broaden your view about the possible solutions. I just started programming and this is terrible advice. You will never get anywhere if you flip flop around programming languages. You should "broaden" your horizon after you put your head down and learn 1 language.
That's an old meme that has been false for a long time too. Modern java is very fast and sometimes faster than c/c++, depending on the tuning of the jvm and application. Check out some benchmarks: https://benchmarksgame-team.pages.debian.net/benchmarksgame/ https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=db https://github.com/mach-kernel/vertx-polyglot-counter#benchmarks
Not in that way. But I've seen projects so "flexible" that you can drown in configuration and patterns like factory. 
You can learn about what came in Java 8, 9 and 10 later. The foundation is still the same. Especially since this is a total beginner book.
I recommened you to carefully watch [Optional - Stuart Marks](https://www.youtube.com/watch?v=Ej0sss6cq14)
&gt; Right, and what's wrong with that? Nothing at all. I have no problem with overloaded methods.
Ugh.... this will be the conference where they announce java being rebranded as Oracle Solution Builder... 
8 was a pretty big release though..
But it didn't significantly remove or change anything. It just added things. So you can read a book for 7, and then read an article about what changed in 8.
SPAM SPAM SPAM
While on the subject of Horstmann's books. I noticed there is two versions; Early Objects, and Late Objects. Which is the "better" version and why?
Stuart Marks is the guy who designed `Optional`, so he should know a two or thing about it. 
Mutable? Nope. I'll wait for Value types. 
I disagree, collections didn't change much at the byte code level- but they changed enormously from the developers perspective with generics. Java 5 is the only reasonable minimum version to discuss and even then, only if you're talking about classroom settings. You'll probably find lambdas whether you like it or not via any libraries you touch.
sun.misc.Unsafe*
Well, it's a lot of repetition for one. If I need to overload every method that takes optional parameters with all permutations of acceptably present arguments (and check them for null, maybe) then it's going to be a maintainability nightmare. Brian Goetz is great, but his advice may not really apply to the code you write in the way you think it does.
A beginner isn't going to be touching libraries. And introducing the collections *and* generics at the same time is not necessarily going to be best thing for a new learner. Introduce one and then the other. And if you read my comment you'll see I said that Java 8 is the minimum for modern development. But beginners aren't at that level yet.
Hmm. I haven't done much Java development lately so I wasn't familiar with Lombok. It looks like a very useful tool if you have to use Java. As for IDEs, I've never been a fan relying too much on them. When a language is only pleasant to use with an IDE, it greatly limits developers' choice of editing tools. I'll gladly use an IDE when I have a good one available, I still prefer Emacs a lot of the time because it's so much better an text-editing fundamentals than any IDE I've tried, and that makes a huge difference when I'm working in a language that doesn't have great IDE support (which is pretty often for me). Coming back to Lombok, as helpful as it might be, I think it's a very poor substitute for improving the core language. Aside from complicating builds and being being yet another tool with its own quirks, my main gripe is that any kind of annotation processor is inherently limited in what it can do. For instance, Lombok can save you the boilerplate of writing accessor methods, but Kotlin also lets you _call_ accessor methods using syntax that Java reserves for accessing public fields or fields of `this`. This works both for fields declared public in Kotlin code, and for bean-style accessors declared in non-Kotlin code. I find this a boon for readability. While Lombok lets you insert nullness checks automatically, Kotlin will statically check for null safety (and insert runtime checks when calling into Java code). It also makes types non-nullable by default and has a very concise syntax for nullable types, plus it has some some handy operators that greatly reduce the need to write explicit null checks, leading to code that's shorter and easier to read without getting distracted by null-related corner cases. Kotlin's approach is also more general; since Kotlin nullability applies to types rather than variables, it's able to distinguish between things like a list than contain null elements vs one that can't. On the whole, I find Kotlin a very pleasant language to work in compared to Java. Most of the ways it's different are pretty minor in themselves, but taken together, all those small ergonomic improvements make a big difference in how the language feels. I'll be very pleased if Java gains a full-fledged pattern-matching facility, but until that happens, I don't think it's fair to treat it as an advantage of Java over any other language. I'll be very surprised if languages like Kotlin don't incorporate the same feature (hopefully in a fully compatible way) to maintain feature parity with Java.
yeah if you want to have to relearn basically the same stuff with slightly different class names to ever get a job
I spent a month writing and running a selenium script to scrape a licensing website. By the time I was done, and able to run it through without crashing their website, they added a button to download as csv.
Some times you don't really know that you have a problem before you see a sollution to it. This thread helps giving a perspective of which libraries a program *could* use.
Your incremental learning method is pretty good for completely beginners, especially for those who are new to OOP programming, but for those come from another OOP language, I think they could learn straight Java 8
... being sarcastic
Gradle is overwhelming.
Learn spring boot. 
There's really something to be said about people like you mong screaming dropwizard and Kotlin every few seconds. 
Spring reactor and/or Akka
Maybe I'm too tired too think about this correctly, but doesn't this minorly changed version for Java 8 optional accomplish the same DFS as the vavr one? private Supplier&lt;Optional&lt;Node&gt;&gt; checkChildren(Optional&lt;Node&gt; node) { return () -&gt; node.flatMap(n -&gt; doSearch(n.getLeft()).orElse(doSearch(n.getRight()))); } private Optional&lt;Node&gt; doSearch(Optional&lt;Node&gt; currentNode) { return currentNode.filter(isSearchFor()).orElseGet(checkChildren(currentNode)); }
After playing around with Java for almost five years, your next step should be to work on a real project. Become a contributor to an open source project you really find interesting. It doesn't matter if it is a little-known project or a famous one. What really counts is to join a team of talented and welcoming developers. You will become a much better developer by diving in the existing code, fixing bugs and implementing new features. And you will learn a lot of things along the way. I don't know if there is something that everyone who codes java is doing right now. But focusing on this 'something' is not necessarily the path you should take. Try to find out what you're really passionate about. Is it GUI development? Working with complex frameworks? Writing compilers? Developing highly optimized multitasking application? Whatever you do, have fun! 
I think it depends on what languages they're coming from. From C#, just throw them a one page "this becomes this" cheat sheet and let them get on with it. From something like PHP or Javascript, I'd probably use "all this casting with List is a pain" as a seque into generics, but if they have Typescript experience, I'd go straight in with genericised collections. I think the evolution of the language follows roughly a good progression for learning the language. And it's impressive that a twenty year old book is as relevant as it is. Compare that with a 20 year old C++ book or Python, or PHP. 
I use oenjdk8-alpine but as you said they're not up-to-date so I'm going to make my own with openjdk10 based on alpine linux.
At least they're not suggesting that it's rewritten in Rust.
What year is this?
That surprises me. I have the opposite impression. With Gson a simple static class with no anotations and not even getters and setters is enough as data model. I dunno how Jackson is doing these days, but last time I checked it couldn't beat that.
I'm kinda irked that the performance graph isn't properly labelled. What is `N`? Number of creations? Reads? Writes? I know I can look for the mentioned source file and probably figure it out, but I would have expected at least a minimal explanation.... 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Alpine Linux and Add jdk echo "http://dl-cdn.alpinelinux.org/alpine/v3.4/community" &gt;&gt; /etc/apk/repositories apk update apk add openjdk8 Search on Google 
&gt; Scala is for esoteric people who enjoy complexity and did well at theoretical math in school. I think that's a somewhat unfair stereotype. It's true that Scala attracts a fair number of "esoteric people who enjoy complexity", and it sounds like you may have run into one of those projects, but it can also really good for "getting shit done" people as well. It's a tool, you can use it in different ways. I use it to be more productive than I could possibly be in Java.
&gt; The Java version will be best of breed too. More likely it will be a poor man's version of the feature, as backwards compatibility will constrain the options.
Well You can do that too with Jackson now. But also that's exactly the point: If I need just a few properties this approach of creating a dedicated POJO and having to traverse every property in the message until I get to the one I need is too verbose IMO. With Jackson I'll just use the JsonNode's path method and get there without having to worry about non existing nodes and NPEs thanks to the EmptyNode characteristic.
All the suggestions are for libraries you wouldn't want unless absolutely necessary. Enterprise Java solutions being suggested for a hobby programmer? Not good advice, IMO.
Side question: what do you (any of you) use your java-loaded containers for?
&gt; If I need just a few properties this approach of creating a dedicated POJO I normally do this as a private static inner class. It doesn't add any noise and is really just a few lines and I do see type safety and IDE support to traverse actually as a benefit my the POJO approach However… &gt; With Jackson I'll just use the JsonNode's path method and get there without having to worry about non existing nodes and NPEs That's an aspect I didn't consider and is indeed very convenient. I might reconsider my opinion on Jackson. Thanks for sharing.
Your comments helped me a lot guys, thanks. The only experience I have is webdeveloping/PHP/Mysqli and that's about it. I geuss the Horstmann book will be a good one for me then. Again, much appreciated!
You're right, they were biggest last time I checked it.
learn j2ee and spring.Then you can start to make a simple application. After that, you may need to learn something about JVM. This would help you write codes with good performance.
Value types are here. Yes, they are mutable, you can read/write.
I thought so :P
Every time I use `Optional`, it just makes me despair that I have to use Java in the first place. Because `Optional` is just a convention and not enforced by the compiler, you either have to let if infect your code entirely or use conflicting idioms. 
Run java services in Kubernetes
I think netbeans will become obsolete. With its slow updates and new oracle rules for java, netbeans will be supporting only outdated and unsupported versions of java.
In the current case I use docker to run a Spring Boot application.
what's the advantage vs running it in a vm?
migration strategies rebuilding them quickly resource consumption 
Follow on question: which Docker image do you use for Java on an ARM based OS?
Well then fuck it.
gcr.io/distroless/java
The issue is that these are indeed mission-critical applications using the browser plugin. And there are (to my knowledge) no alternatives at this point in time. :/
&gt; ... there are some hidden gems in there. What are some of these gems that we need to know? 
&gt; On applets (the Java browser plugin), you should just drop everything. I don't know many sites that still use it, and you should just kill it unless there's a mission-critical application that uses it. I could be wrong, but I get the feeling you don't have much experience in large enterprise environments (10,000+ users). We still have some business-critical applications that only function with JRE6.
Not as an admin, no. I just assumed none of those business-critical applications are applets. 
I've seen the proposals. It will be as good as Scala or better.
This appears to be an interesting set of ideas without much code underneath. As someone else commented, the performance graph does not make clear what was being tested, or how. From a cursory glance at the code I'd suspect that the reason JUnion results are so close to a primitive array is because you're effectively using the same thing. There seem to be a lot of things that are not clear from the project page about how things like mutability are handled and the nesting of 'structs' as opposed to simple encapsulation of a set of primitives. Azul (who I work for) have a similar project called ObjectLayout (http://objectlayout.org/). You might also want to watch a presentation I gave on this a while back, https://www.youtube.com/watch?v=iKC2yoTwuvk.
Hey, we should rewrite this in Golang!
Our architecture consists of a bunch of Spring Boot based microservices we deploy in Kubernetes. 
Integration testing 
Not only shorter, should be much faster too due to the String concatenation in the first example.
Looks interesting and I'd like to give it a try there seem to be no build files (maven/gradle). Any plans to add them? 
I'm kind of a newb here: why would you have a Docker Image just for Java? Depending on the use case wouldn't Java be secondary? For example, if I am using Docker for a Spring application I would install a docker image with a server, the right database and associated Spring boot dependencies, and Java. 
Not sure if many people will care, but it means a lot to me. I've been using HttpClient since J9, this is the official implementation, and so will finally be forwards compatible with the eventual 11+ releases. No more hacks to get it working!!
Wow, It's the best explanation for far
Not sure if many people will care, but it means a lot to me. I've been using HttpClient since J9, this is the official implementation, and so will finally be forwards compatible with the eventual 11+ releases. No more hacks to get it working!! (no more --add-modules)
Best practice is to have only a single application per container, so for example a Spring Boot application XOR a database server. The Spring application with all its dependencies is typically baked into a fat .jar. All you need to run this is a Docker image with Java or one without Java, where you install Java in the Dockerfile + the .jar file.
How similar is this to the [JAX-RS client API](https://javaee.github.io/javaee-spec/javadocs/javax/ws/rs/client/package-summary.html)? I've been using that whenever I need HTTP client.
Hmmm I'm fairly new to Java. Why is the data being contiguous important for performance?
It's basically that one, but re-inventing the wheel, since JAX-RS is Java EE, and Java EE is well... it has a difficult relationship with Java SE. A few years ago that client-API would have been added to Java SE directly. But as we now know, this is problematic, since Java EE will also update it. This means all kinds of endorsed tricks have to be done, and annotation attributes will suddenly be gone (like the `lookup` attribute in @Resource). So to prevent all of that, and to prevent it getting kicked out later again (which is what you do with everything that originates from EE), they just re-invented the wheel. It does the same thing, but just using a different API.
https://bugs.openjdk.java.net/secure/Dashboard.jspa?selectPageId=17668 
Thanks !
Spring boot is awesome!
Hidden gems may have not been the right term to use, but rather uncommonly used gems. Off the top of my head two classes that probably aren't used commonly but come in very handy for specific use cases are BlockingQueue (several implementations available in the JDK) and CopyOnWriteArrayList. For BlockingQueue the two implementations I have used are LinkedBlockingQueue and ArrayBlockingQueue, in the case of ArrayBlockingQueue it lets you have multiple threads pulling from a queue while still maintaining FIFO. In the case of CopyOnWriteArrayList it lets you avoid synchronizing on an ArrayList when you have the specific use case where your reads _vastly_ outnumber writes (e.g. think of the use case where you are writing messages to connected clients in a client/server app many times per second, but a new client doesn't connect very often). These are just two examples from the thousands of classes available in the JDK. 
I'm not clear as I've never used the JAX-RS client. The reason I am using the J9 incubator, and now J11 final HTTPClient, is that it natively supports HTTP/2. Which I imagine JAX-RS doesn't have (my project requires HTTP/2)
I'm sorry but @autowired isn't doing anything that you couldn't do avoiding it. I think your problem is with Spring as a whole and not boot because everything is spring is a bean anyways and the only thing is does it make sure the class has uses it. The reason for that as you've hopefully guessed is that since the bean is instantiated only once for the entire runtime, you shouldn't need to go around creating new objects of the bean everywhere. You however aren't forced to and can decide to go the route of factories and constructor instantiations all over your (shit)code even in spring (boot) . DI is just best practice and is under heavy adoption in the entire industry anyways. The classpath one however, I entirely agree with. It's a bit fucked; one should need to pass some parameters/ configure some properties at the very least. Was slightly shocked at the start myself when just adding spring security to the classpath turned on basic Auth. Rabbit MQ in the classpath without actually implementing JMS is an issue. In that respect, yes you're right. 
tomcat:8
Note that you only need to use SLF4J if you are writing a library that other people may use that may be using a different logging framework. Otherwise you don't need it. 
Arrays typically store data that is accessed sequentially (searching a list, etc). Having the data contiguous in memory means that the underlying hardware can spot regular access patterns and use pre-fetching to improve performance. Also, if data is stored contiguously (and known not to change its position relative to other data in the struct) locations can be calculated using simple maths and offsets rather than requiring pointer lookup and traversal.
For more info: https://github.com/GoogleContainerTools/distroless
traceability, portability and having the system configuration versioned and just depend on docker to run your stack. Need more reasons?
he should learn the basics of web applications with servlet &amp; jsp. then he can start spring mvc.
Genuine question: why would you use ARM based OS for hosting Java apps?
Research and development team. We are trying to deploy Distributive Messaging Frameworks on Raspberry Pis. One of our candidates is Apache Kafka. It failed miserable on the poor little guys. ZooKeeper itself is a memory beast. We were doing that bare metal. We hoped to deploy using Docker. We’ve moved onto the other candidates in our AoA. I still might need to know what Java image to use.
FWIW, since *most* collection usages don't need mutability, `ImmutableMap` also works for this (it has indexed access via `.entrySet().asList()`.).
Just like streams lol
You have to configure your system's PATH variable to include the Java bin directory.
No alpine versions exists for jre 9 and 10.
CI/CD pipelines in Concourse, and in clusters on AWS, mostly
It makes upgrading a single component, such as the database or application much easier. Besides, PostgreSQL and other parties maintain their own images, so it's easy to reuse those. If you employ something like Flyway or Liquibase, all you need is a standard PostgreSQL image with your overrides (db name, credentials) in an env file and you're up and running. I use Spring Boot profiles to specify either a local or Docker datasource. 
Do you think discussion of object-orientation is helpful or confusing to beginners? If helpful use early, or confusing use late.
Yeah, what then?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Compare with [Ozark](https://github.com/mvc-spec/ozark), the action-oriented MVC standard(?), which I believe more naturally fits the action-oriented paradigm, being an add-on for JAX-RS.
? and you don't have that in a VM? since when?
the VM is portable and it has a fixed configuration. ...what am I missing? there are definitely use cases for docker containers, but this ... this i don't see it as being one of them.
Streams in Java are currently better than Scala. First, they use invokedynamic which will generally perform better and second they are "view" based so you don't get a ridiculous amount of intermediate objects. See Paul Philips' (the guy who wrote most of the Scala collections libs and later quit) talks on this
&gt; Streams in Java are currently better than Scala If you just said up front you were an idiot, it would have saved us both some time lol
In my case, I do all my encryption using a native library (libsodium) which I package up in my docker image. This means I can trivially guarantee that I’m using the same version throughout the whole deployment pipeline, don’t need to worry about the lib being installed in different places on different distros leading to weird path bugs, don’t have to install a build toolchain on production servers to deal with the fact that stable apt repos only have ancient versions, etc. 
reported
Why the vote downs? it is true, servlets are the base of Spring MVC and JSF, learning jsp will make the learning of JSF and Spring MVC easier, he can even use JSP in Spring MVC, it is pretty common, unleast it is Spring Boot.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8ewmot/making_a_class_out_of_a_complex_collection/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Create a new ticket? Kind of specific to openjdk and how they run their life, but pretty sure they'll be happy with that.
That was my first inclination, but unless I am mistaken the jira site says &gt;Everyone with OpenJDK Author status or above has a JBS account which may be used to create and edit bugs. Those without accounts can view bugs anonymously. So because I am not yet an author I cannot create a ticket. That's why I am here.
What do you use javaPoet for?
If it's an executable jar file (not a library), you can run it via Console command: `java -jar app.jar`
It was almost certainly never going to happen, but I still had a tiny bit of hope there'd be early\-access value types in 11. Oh well, maybe in Java 12 :\(
What's your idea?
Hey sorry I never replied to this. This is seriously some high caliber input. I am finally going to be able to start working this project and have really taken into consideration your feedback! Even if I'm not tasked to refactor the licensing code (which I think I will be), it was still a very kick ass write up on how to truly ensure something is encrypted securely. Definitely keep an eye out for questions from me in the future :) /evilgrin
I threw it in from my hobby project since it is so nice, but we don't use it at work. At work, we codegen a lot of boilerplate away using libraries like JsonSchema2Pojo. For that project, there are many configuration options requiring metadata on the hash table entries. Since only a few configurations might be used most of those fields would be unused, wasting memory. The codegen instead adds to the jar size for unloaded classes, which is a better trade-off. I'm sure the [code](https://github.com/ben-manes/caffeine/tree/master/caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache) could be nicer, though.
This is obviously something people have thought about. Brian Goetz mentioned that it might be concidered in a future jep here: http://openjdk.java.net/jeps/326 What exactly is it that you would like to contribute here? Are you experienced with the java compiler code base? Do you know the ins and outs of the JLS?
PM me if in the Bay Area :)
Finally , I've been waiting for this for so long , stuck with this (library )[https://github.com/AsyncHttpClient/async-http-client] for a while now .
when are we getting enhanced enums? 
Meh, even if it lands in Java 12, you will touch it on production by 2030 (2045 for Android) ¯\_(ツ)_/¯
a beginner needs some idea of what generics are. generic classes you will use are everywhere, whether or not you need to know how to write one
I didn't write it, I just crossposted it because it looked interesting. /u/itheleoi
you can think of containers as a mini VM, the container will contain the essential parts of the OS to run your app
VM requires a lot more work to set up. With stuff like Kubernetes, docker makes a lot more sense.
I know what a container is. I use containers (docker) myself. I know where it is useful. To run a java app ... not very useful.
Yes but there is no performance loss really and it works well with the environment for other languages. I use this system extensively and it works perfectly for me.
They seem to only matter for govt jobs. In the US anyway. Don't bother unless your company pays for it and it matters to them.
Then, what does matter more to employers? 
Can you explain more about your configuration and what the I/O and CPU load for this process are? My understanding is that Docker containers run directly on the CPU without any sort of indirection or translation, so if it's a CPU-bound task it should complete just as quickly running on the host as inside a container. Note this is from a Linux point of view, I think with Docker on Windows it has to create real VMs so there will be massive performance degradation.
What happened with your last sentence?
Fedora 27, up to date. The process connects to a postgresql database, grabs data for a project (id passed as command line argument), runs the numbers (mlpack library, which uses armadillo which uses openmp), basically a bunch of matrix operations, saves the resulting data into the database. connection to the database is done via the network. on fedora proper is via localhost, in docker is via the 192.168.1.2 IP of my machine. I doubt the network traffic has much to do with it, but hey ... it could be. but no, it is not "no performance loss really". That's just naive. It can be "acceptable performance loss", which is for me (the advantages of running that crap from a lambda triggered via SNS are worth it), but it never is "no performance loss". 
It depends. Will people hire you because you have them? No, not really. They're not that hard to get and they don't really guarantee good habits. Will you learn a bunch of stuff about Java and the JVM while you get them? Yes. I got the certifications and they did make me a better programmer. The study books are great and have a ton of useful knowledge in them.
This is very helpful. My primary background is on database development. I do use java at work but it hasn't been the main tool. We are just starting to build web services and building java libraries for use in tools like Talend. I do use tdd with the java libraries but since I have never been in a java shop I don't have a good sense of all that really goes on or typical best practices.
Great article. Depending on the licensing terms and future support this looks like it could well make it into many of my future projects!
That's a bizarre performance degradation, the CPU is executing the same instructions whether the executable is running via Docker or natively so I would suspect the network access to be the cause. I have only a cursory knowledge of Docker but the performance impact should be negligible, in the order of &lt;1%, less than the overhead of a full VM.
Do you expect for the answer to be in pseudo code or in perfect java?
Great to see twitter is already using it in prod.
From https://github.com/oracle/graal/: * Truffle and its dependency Graal SDK are licensed under the GPL 2 with Classpath exception. * Tools project is licensed under the GPL 2 with Classpath exception. * TRegex project is licensed under the GPL 2 with Classpath exception. * The Graal compiler is licensed under the GPL 2. * Substrate VM is licensed under the GPL 2.
It's useful if you don't have any relevant work experience.
I have OCJP which I got last year and I can tell you this that if you are a sophomore.. New graduate then companies do look at it as It gives them the assurity that the candidate is through the language fundamentals, syntax and other important libraries. It definitely helps in you building your java accumen. But in the long term only projects matter. 
Here im talking about real machine and docker, not vm and docker. It could be that vs a vm there's only 1%. 
&gt; Here im talking about real machine and docker So am I. Docker should introduce not zero, but negligible performance loss compared to running the same code on a physical machine. A VM has an inescapable performance loss (mitigated well by hardware) due to it running an OS on top of an OS.
Migrating to a Jigsaw based JVM comes with.... challenges that are not just "drop in the JVM and go crazy" - hopefully by the time 11 hits the shelf most libraries will be updated to at least work properly under it. But if you're not in a position to upgrade libraries...
I use NetBeans 9 right now with JDK 10 https://netbeans.apache.org/download/index.html
They pressed an r instead of an e? Was one accidental typo worthy of a comment?
What is this "Classpath exception"?
It is as useful as a "full" vm, but with less runtime overhead and smaller files.
How does it compare performance wise to async-http-client?
Portfolio &gt; Certifications If your employer pays for them its not a bad option. If you take them seriously they will make you a better programmer. You'll learn the language and APIs to a much higher degree than through natural experience. Be warned if you just try to pass them you'll probably come out worse. I interview a lot of contractors who are certified, yet they fail to answer basic questions and have no idea about writing clean testable code. I find they have memorised the right answers but still have no idea how to write code that is easy to understand and change. Often they will use knowledge of advanced language features (e.g. reflection and concurreny) to add complicated hacks that need removing because they are so brittle. IMHO aim to be T-shapped and always keep learning. Pick up Effective Java, Clean Code and Java Concurrency in Practice. These and a portfolio will last and get you much further in your career.
Let's say you're getting certified in 'hammers'. You can spend years studying hammers, knowing the names of all the parts, different variations of hammers, where they can be used etc. But if you never actually used that hammer to build anything companies aren't going to hire you as a carpenter. Language certifications are there to show you know some rather specific details of a language in depth. Not that you can use that language to build software. Companies, mainly ones hiring junior developers, are mostly concerned about you being able to actually build stuff. If your company pays for the certs; by all means go for them. But when you're looking for a job actually spending time building stuff is a much better investment. 
Easy for an engineer to understand but less so for a lawyer (in my experience) 
Are all those ones listed under 'candidate' actually being considered for Java 11? There are some huge JEPs listed there. 
This looks so good. I would love to see some benchmarks comparing it to hotspot.
Yesterday I was just thinking about [JRockit](https://en.wikipedia.org/wiki/JRockit) and how everybody was using this (years ago) instead of the original JVM. It also boosted your IDE performance. Going to try this with GraalVM, good times :-)
**JRockit** JRockit, a proprietary Java virtual machine (JVM) originally developed by Appeal Virtual Machines and acquired by BEA Systems in 2002, became part of Oracle Fusion Middleware as part of acquisition of BEA Systems in 2008. The JRockit code base and the HotSpot virtual machine from Sun Microsystems (now Oracle) are currently being integrated, with the target of releasing a JVM with a combined code base around the release date of Java Development kit(JDK) 8. JRockit was made free and publicly available in May 2011. Many JRE class files distributed with JRockit exactly replicate those distributed with HotSpot. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
The you would be able to run Jakarta EE on a cluster by default
I think this talk from last year describes some of the benchmarking which motivated Twitter to use Graal https://www.youtube.com/watch?v=H8GdPe6gqSQ
right. so why would you run it in a VM and not on a real hardware? The entire point is to replace the VM, right?
See Twitter's opinions on it. They're using it in production and it's saving them money. https://www.youtube.com/watch?v=OSyvidFXL7M
Yes, maven/gradle build tools, along with IntelliJ support is on the ToDo list.
A lot of people are talking as if Java 11 will be a paid product, but as far as I can tell Oracle have stated that Java **8** will be the only version that requires a fee. Java 9 is already terminated, and Java 10 will become terminated once Java 11 is released. Therefore, people will be able to use Java 11 for free until it gets superseded in the same way Java 8 did. Considering that Java 8 has already superseded Java 9, and will technically supersede Java 10 (albeit through a paid format), Java 11 could easily last 3+ years.
The point is unification. Every app is handled the same way, no matter if it is a Java app, a Python app, a server written in C or whatever. This unification makes many things easier. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Anyone know what the typical licensing costs for this might look like? If this is beneficial to us I'd like to have a ballpark idea before I sent the request up the chain.
You can use CE in production for free - Twitter are doing this. So you might as well start experimenting with the CE version now and you can just put that into production if it works for you. I think if you wanted to use the EE version it'd be a conversation at this stage, rather than a neat PDF price-list. Talk to us about what you're experimenting with on the mailing list and we can help you make it work.
if you are senior (5+ years) then most likely not, for juniors it is a nobrainer how to prove basic and advanced capabilities if completed both OCA and OCP. Price is nothing when you consider lack of developers world wide and therefore huge wages even as freshly graduated.
Effective Java will no doubt get a lot of recommendations. It's good, make sure you get the third edition. I think Clean Code is good too, language agnostic but generally good advice leaning towards making your code readable above all else.
Ah thanks for pointing that out, I see Community edition and Enterprise edition and my mind immediately just assumes we can't as a company use the community edition in production as a for-profit company. Unfortunately I also see that it is Linux only and our infrastructure is all Windows due to most of IT being .NET, thanks for your time though.
Concurrency in Practice
Yeah effective Java is for sure on my list. Thanks!
Yeah this looks like a good one to get as well. Thank you.
worlds smallest computer
In my opinion the certificate is not worth, but reading the study books sure is. Grab yourself OCA and OCP books, read them through. They are really good, you will learn much from them, and you can use that knowledge. The exam is basically testing theoretical knowledge and if you can spot a missing semicolon because of which the provided code doesnt compile...
http://enthuware.com. I passed both OCA and OCP Java 8. Their mocks are super great. Helped me to pass exams, showed what I was lacking. And its only 10$. 
Thank you!
It looks like in your [submission](https://www.reddit.com/r/java/comments/8f3f3k/passing_variable_to_javascript_via_ajax_in_flask/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Appprktly it waz
Is there like...a text version? Why the fuck do so many orgs think just video is appropriate for programming instruction? Am I the only one who despises this trend? Am I just a luddite? 
Yes. I have passed both OCA and OCP. It helped me to market myself better and land a job. After joining a team of developers, I was dumbfound that regulars (3+) don't really know intuitively lambdas or new java.time libraries. Generics are also a weak spot for some of them, not differentiating between upperbound and lowerbound. Moreover, juniors lack basic understanding of simple polymorphism. However, if you're a regular/senior and you constantly keep yourself up to date, then I guess no. Unless you work for big corporation (in my company you cannot easily be promoted to regular/senior if you lack both certs and degree in CS). 
Some humans like to talk my broddah
It's missing information about the fork-join, parallel decomposition, and the new parallel bulk data operations. But what's in there is still good.
Alright, I appreciate the suggestion. 
Have you looked into the (usage tracker feature)[https://docs.oracle.com/javacomponents/usage-tracker/overview/toc.htm] that was added to the public JRE back in ver 1.7.040? I use a scheduled script on each of our endpoints to enable that feature and direct its output into our Splunk server for visualization, but there are other services available that likely do a better job. 
Will this ever work on Windows?
Java bangla tutorial
OK, thanks.
Fundamentals of python: data structures
I wouldn't put AOP in the list of things most people care about. I personally don't like AOP and it wouldn't make me think more highly of a candidate who advocated AOP. I haven't run in to very many engineers who are passionate about it. Other than that its a pretty good list.
Good article, I really like how other languages work with visualvm. Didn't know that before. But what I didn't like is, you didn't show time of native image on large.txt. Also I was reading before about region based memory management. Is this included? Or is it only in enterprise version?
Last time I checked we couldn't register custom URL handlers/transport handlers per webview object. I want that.
Agreed. Just about every piece of network equipment, it seems.
Look into sending http requests. Never done it in java, but it should be easy enough to figure out 
Thank you for your help
Yeah, agreed. Don't feed the troll.
This all sounds nice for polyglot development using scripting languages. But could GraalVM bring any improvement to cross-compilation of already available statically typed languages on the JVM? A concreate use-case I'm imagining: Say I want to create a project using Java, Kotlin, Scala and Groovy and each class from one language should be easily accessible from another language. This is currently impossible to do in the same compilation unit.
Thanks. I tried it and got bad results :-( 3860 vs 2574 
Effective Java. 
&gt; Eclipse is much more than just a Java IDE. It's a platform for all of those nice modeling tools about which an average programmer has no idea (including me). In much the same way that Netbeans is a RCP...if you're ever used VisualVM from the JDK, you've used a Netbeans RCP application.
[Code Complete](https://www.amazon.ca/dp/B00JDMPOSY/ref=dp-kindle-redirect?_encoding=UTF8&amp;btkr=1) is a favourite of mine. It might be aimed a little more at the professional than the student, but if you become a career software developer, it is an invaluable asset.
No, I fucking despise it as well. It turns a 5 minute article into a 30 minute exercise in patient listening. at the very least I'll put it on 2x speed and skip around to approx what i'm looking for. Videos are just the primary way to monetize web traffic, so it's not surprising that a lot of the corporate-ish bloggers are all over it. 
Except it took like 300 years to get it set up correctly. After that it was fine forever, but good lord. Wasted so much time on that thing. 
hopefully not. windows is a big black hole of time when it comes to compatibility, as well as having the most demanding customers. It's probably meant for high-scale server processing, which is so rarely done on windows+java. 
and n instead of m :)
That looks like something I could get working and might actually provide me with the data I need. Will look into it tomorrow. Thanks a lot!
It's a great book, but I'm not sure how much OP will get out of it at this stage. Like the 'Code Complete' recommendation, it's going to be more useful in a professional setting (or after a few years of experience). I'd worry more about writing extra code. Take a udacity or coursera course on algorithms. I think writing (and struggling with) code early on will pay greater dividends. Pick a topic and practice with purpose. It might be control structures or iterators now. It might be reflection or injection frameworks sometime down the road. The more code you write now, the less you'll fight your tools, which means you'll be able to absorb more of the theory presented instead of worrying about a null pointer exception.
I recommend this book always to newbies because I wish I had it when I was one. You don't need to read it Cover to cover, just take an item at the time or wait until you have concerns about something and search for it. It is very good to read your opinion about that, though. I might have been giving wrong advice to some people. 
I took python classes in high school. Can I ask why this recommendation?
https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672
https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420
Clean Architecture by Uncle Bob
And most of those people are not in the engineering gene pool haha (kidding)
It depends how new you are to the subject. Personally, if you’re looking for a book that could get you ahead, basically extra practice, Al Sweigart has some nice books on python that go over a couple “higher level” programming topics and from this I would recommend “Automate The Boring Stuff With Python” as it covers topics such as opening, creating, and saving files within a program, which is something that you will need to do a lot of the time in programming. If you’re not familiar with manipulating files like that within a program it can be a real pain in the ass to learn for the first time, and it’s something a lot of people struggled with while I was taking my freshman computer science classes. 
I've taken a python class and a Java class as well. This book does a good job of covering programming basics, but also does a good job of applying thise basics to actual problem solving, specifically using different types of data structures. It may not be your forte, but I found it helpful even after taking my first python class.
To my knowledge Twitter is using it with Scala. Plain Java might not see the same improvements.
Ew people. They disgust me. 
I think it's a really good book to know of early on, but you don't gain a lot from it as a beginner. I've re-read it every few years and every time I've found that it was more and more useful to me. There's a lot of things in there that just didn't mean anything to me when I was starting out. I was able to follow the descriptions of the problems intellectually, but they didn't speak to me as they do now - after I've really come across these sort of problems in my practice. Similarly, the solutions to the problems didn't really stick with me, because the problems felt so abstract. After a few years as a professional developer, the concepts and ideas were so much clearer to me that it was much easier to pick up useful advice from this book. I think it's easy to forget just how different one thinks about many problems of programming that feel natural to more experienced programmers when one is just starting out.
Absolutely, I agree 100% this book need to be read multiple times and kept safe. :) 
We get 25% in the Java example in the blog post.
Running GraalVM in the JVM mode works on Windows even now. We're working on making native images support Windows too. Not sure when it'll happen, but there certainly will be an announcement. 
Currenly, the JVM languages are executed through the JVM bytecode they compile to. There's no Truffle interpreters for it yet (there should be at some point). So the interop between those languages works the same way as it'll work on the normal JVM. And for example, Scala-Java interop, Clojure-Java, Groovy, etc interop are quite straightforward, Kotlin-Java interop is allegedly excellent. Not sure what you mean by the same compilation unit, mixing all those in a single file? That'd be quite cumbersome I think. At the same time, you can compile a program which uses different JVM languages into a native executable already, for example you can check out the [Java-Kotlin-aot sample](http://www.graalvm.org/docs/examples/java-kotlin-aot/).
Author's first point is that eclipse is ugly. #journalism
That's always nice
Nope. That's not what the announcement says. You're free to use Java 8 after Jan 2019, even as a commercial site. Updates for commerical sites, however, will require payment. This is totally standard. By 2019, Java 8 will be nearly five years old and three revs of Java behind. Most vendors (Microsoft, IBM, etc.) require you to pay for support on releases that old. That is all this announcement states. 
And in .net we get IE 7 compatibility with their com component. LOL FAIL.
because it is ugly and such a PITA to use. 
I like videos to discuss a topic for the first and introduce how to get a feel for how things piece together. Otherwise when you go read the docs https://docs.spring.io/spring-statemachine/docs/current/reference/htmlsingle/ its going to be difficult without context imo.
&gt; Migrating to a Jigsaw based JVM comes with.... challenges that are not just "drop in the JVM and go crazy" besides the removal of JEE stuff behind a flag or another library on the classpath, what else? yes other jvm languages might have their problems, but besides that... You could use, 9, 10 with Classpath and some warnings. JPMS of course can't work without more adoption.
This could be an Electron killer if it gained mindshare.
What's the advantage of not programming to the interface?
My dream. I wonder how it does on RAM usage in comparison. 
I think it is actually impossible to be worse than Electron, so ... it should at least be a wash.
Tbh I think Eclipse Oxygen is beautiful. It integrates well with Windows 10, anyway. If you want to see ugly... Bluefish.
Goodbye JavaOne, and fuck you, Oracle.
I use NetBeans with no complaints.
Working Effectively With Legacy Code
What's the problem with TypeScript support in IntelliJ? 
Oxygen with Darkest Dark Theme plug-in works and looks great to me. Granted, I haven’t used IntelliJ a whole lot, so I can’t directly compare. However, I’m pretty satisfied with this setup compared to what I got with Eclipse in the past.
Compared to other modern IDEs and editors Eclipse is objectively... well... let's say somewhat less nice to look at. 
Yet here I am along with half the Java devs still using it. Also why were only 2000 people surveyed.....
&gt; You could question it's bias, i.e were the respondents taken from the intellij mailing list for example. But not the # of respondents. I wouldn't expect bias, but still question the sourcing. I'm sure 2040 is a good sample size when taken scientifically from a representative group, but not if taken from a random survey on the Internet.
Oh, believe me, if I could have gotten rid of Java at any point I would have already done so. When I started this job the entire company was running some stone-age version of Java and there was no software deployment in place that would update the Java installation to the latest available version. Right now we update (almost) all the clients to the latest version within a week of it being released. That is already a huge improvement. Thing is that I'm working for a public employer, namely my hometown. Which means that we have so many departments that interface with outside companies that it is very hard for me to even know what they are doing in all those departments. The usage of Java ranges from library software to track which books have been given out, over handling of car licenses and taxes, to refugee related stuff, to digitally signing toxic garbage disposal documents, and whatever else you can imagine. This is all specialized software with very very few alternatives on the market. And then of course there is the odd ancient network switch/router somewhere in the infrastructure that still requires Java 6 for the console that interfaces with it. Getting rid of all that is next to impossible.
Native git support in Eclipse would be awesome. The performance of the Java git library is underwhelming for larger repos.
I'm still loyal to Netbeans since version 6.0.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Kotlin in Action
Eclipse is extremely buggy and slow. My main frustration at work together with EclipseRPC. After Applets, Eclipse became the source of bad reputation of Java.
I am working on a project (&lt;http://atlastk.org/&gt;) with same goal, desktop interface development with web technologies, but with a different approach. It's based on *Electron*, but I think it could be, as well, use *JavaFX* *WebView*. By the way, this project also allows to develop web applications that do not require, on the client side, a *JRE* or a plugin, contrary to, from what I understand, *JavaFX*. Sorry for the self-promotion, but, not knowing *JavaFX*, I wonder if my assumptions are correct. 
This annoyed me as well, just name it customers, but even that's a bad name, because you rarely deal with all customers at once in your program, most likely a selection which leads to a name like `vipCustomers`.
Shitty, lying title from a deleted account? Why spread FUD? Go away.
Looks nice, thank you. I'm contract developer working in javalin now, and have been quite happy so far. I don't know about the websockets but it looks pretty similar to sinatra-websocket. The java ecosystem is actually quite nicer than ruby though, I learned while working. I'm considering learning spring boot, and you also say javalin is trivial in your post. Is it required to switch to spring boot? How do I know when to switch?
Last time I checked anchors didn't work. `&lt;a href="#lolno"&gt;Standards&lt;/a&gt;`
But than you are missing the fun of compiling it on your own 😀
Also checkout https://spring.io for great tutorials and https://baeldung.com for the best Spring blog out there. Good luck!
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Spring development with Eclipse? Guys common. Without IDEa it's freaking hell
Actually built a real-world app in this style; we got a long way in, then jettisoned WebView for two really unfortunate reasons: First, the JS debug tooling in WebView is poop. You have really only two choices: remote chrome debugging or embedded firebug-lite debugging. Both are painfully limited compared to what you can get in Electron. Second, and probably biggest, is that JavaFX will stop being released with the core Java runtime in Java 11, and that's less than a year away. If you have to bundle your Java runtime, you're back up to Electron-sized deployments. My shop, like many, is really thrashing to realign our products to keep working because of this release's moves from Oracle.
Isn't that bias by definition? I.e. taking a sample from a non-representative group?
Number 4, is easier to read the before rather than after.
I've never been a huge fan of the look-and-feel of Eclipse, but I do like the style of Eclipse Oxygen. It would be nice if the desktop IDE could at least adopt the same icons. If nothing else, it would make it seem a bit more fresh, even without a big overhaul in looks.
Hey now, Javalin is not only for personal projects, you can be perfectly serious about microservices and run Javalin in an enterprise setting. We're currently running a survey to find out more about our user base, and so far 50% of respondents are running apps in production.
Here I am, using Java 8. I feel like a peasant.
I concur.
For short-lived variable, where `x` would be an acceptable variable name, the type is usually not very important to understand the code. In that case, `var` is fine and reduces clutter. If the type really is important and also non-obvious from the right-hand side of the assignment, then `var` may be the wrong choice. Yes, `var` adds another possibility to write bad code. I do not think anybody really argues that. Bad programmers will always find ways to write bad code, and `var` is tempting. But the benefits overweight the risk I think.
Go for both! Glad to see Javalin is used in prod. Please share replies once you get them from the survey!
Will do, but with a conversion rate of slightly less than 1%, it's going to take a while before there are enough responses.
&gt; Second, and probably biggest, is that JavaFX will stop being released with the core Java runtime in Java 11, and that's less than a year away. If you have to bundle your Java runtime, you're back up to Electron-sized deployments. Why does including JavaFX as a dependency change anything? You should always bundle a java runtime with your app and using modules with Java 9 and then using javapackager (which uses jlink) makes this a non-issue. I don't understand your concern. 
The runtime for Electron is an instance of Chrome which is bundled with an Electron app. So you most certainly need a runtime. The runtime for JavaFX is a JVM as you mentioned and you should bundle it with your app. Either way I have no idea why someone would want to write a desktop app using web technologies. People using JavaFX just to put a web app in a WebView strikes me as beyond ridiculous.
or use https://builds.shipilev.net/
It was. I was looking forward to it, but it now makes since why it's on hold. Thanks!
For maximum readability don't use 'var'.
that's FUD not a javalin user, but this sort of attitude has no place in the community
A shitty post, with click baity title because Java10 is thrown in. Most of the advice is poor or straight up wrong, like someone hasn't worked with a real codebase.
OpenJDK 10: https://adoptopenjdk.net/
Hey, I don’t mean to talk Javalin down. I love the framework! I was trying to give a professional advice for contracting and what will be useful (I work in consulting). Sorry if I came across critical of Javalin.
&gt; OpenJDK 10 Make sure you don't click "Latest build", because it's from November 2017 (known page bug)
&gt; so few responses You could have a trillion people and as long as you're picking at random, 2000 gives you a 99% confidence. It seems like few but statistically speaking, it's sufficient.