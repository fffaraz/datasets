The official tool (and only as far as I know) for building JavaFX GUIs is SceneBuilder. Oracle no longer releases binaries for it; however, it is pretty trivial to build from source or you can get binaries from Gluon: http://gluonhq.com/products/scene-builder/ Note that it is still developed as part of OpenJDK, Oracle just doesn't release binaries for it. If you want to build it from source you get it from OpenJDK. 
What are you trying to accomplish? Something like OAuth2? Or JWT? Spring Security comes with tools to [build](https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v) an OAuth2 auth server, resource servers and clients. Each of these would exist as separate services. You can [store](https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/config/annotation/configurers/ClientDetailsServiceConfigurer.html) granted refresh tokens in memory in the auth server or in the database. If you don't want a separate authorization server, but want to integrate token-based authentication into standard Spring MVC request handling, then you will have to roll your own token based authentication. Here's a [starting point](https://auth0.com/blog/securing-spring-boot-with-jwts/) for integrating JWT tokens into the Spring Security filter chain. Note, this involves access tokens, which you wouldn't need to store because they are cryptograpically signed. However, you would need to store the refresh tokens and how you implement refresh tokens is up to you.
I suggest people make a clone of this fine java ide. Emulation is the best proof of admiration.
Tomcat implements the Servlet, JSP, and EL specifications (3 of the ~28 specs/apis available in Java EE 7). If you want to understand the inner workings of a web app container like tomcat it is probably more important to understand the specs: * http://download.oracle.com/otn-pub/jcp/servlet-3_1-fr-eval-spec/servlet-3_1-final.pdf * http://download.oracle.com/otn-pub/jcp/jsp-2_3-mrel2-eval-spec/JSP2.3MR.pdf * http://download.oracle.com/otn-pub/jcp/el-3_0-fr-eval-spec/EL3.0.FR.pdf This page tells which version of the specs each version of tomcat implements: https://tomcat.apache.org/whichversion.html
God help you if Apache 2.0 is too restrictive, as it's the *least* restrictive license that also grants patent usage (and jetbrains holds patents) Apache 2.0 from their [faq](https://www.jetbrains.org/display/IJOS/FAQ)
I just copied the title off of Twitter.
I use Vert.x as the main framework for https://github.com/gentics/mesh (~90k loc). Gentics Mesh is a headless CMS with a REST and GraphQL API. I can't really compare Vert.x to Spring Boot because I have never used that framework but these are the pros/cons that I noticed while working with vert.x: Pros: * Vert.x code base is well maintained, very clean and easy to read. * Documentation is **really good** * Lightweight. You can pick from the set of libs and just use those (eg. don't use vert.x-web if you don't need it) * Community is active * Release quality is high. I did not notice any major bug that I can recall that really affected my development. Cons: * Tools and libraries around Vert.x are still growing and some feature are missing. One example for this is the API Doc generation. I use RAML to document my REST API docs. A generator which would work with Vert.x routes does not exist. Thus I wrote my own generator. The https://github.com/vert-x3/vertx-awesome list is a great resource if you want to find tools/libs to be used in combination with Vert.x. * It is sometimes not easy to figure out the *Vert.x way* to implement things. I initially used multiple verticles to modularize my REST API but this approach was not recommended by the devs so I changed it. 
Good feedback, much appreciated. &gt; It is sometimes not easy to figure out the Vert.x way to implement things. I initially used multiple verticles to modularize my REST API but this approach was not recommended by the devs so I changed it. Tell me more, I am just doing that.
I would like to build my own token store using JWT. Also auth0.com offers paid subscriptions to the token store.
Auth0 is essentially running an authorization server, like Facebook or Google. You can run build your own authorization server using Spring Security (see the link). Spring OAuth2 tokens by default aren't JWT, but you can [configure](http://www.baeldung.com/spring-security-oauth-jwt) Spring OAuth2 to use JWT.
The in-depth issue around this topic is afaik https://github.com/vert-x3/issues/issues/138#issuecomment-233144641 - I changed my implementation to use a single verticle which uses dedicated classes to setup all REST endpoints: https://github.com/gentics/mesh/blob/53602db58962073174696cd9e50be8197a1c5323/core/src/main/java/com/gentics/mesh/rest/RestAPIVerticle.java#L185 Other solutions that were discussed would involve the eventbus. The rest request would be passed along using the bus and worker verticles could process the request. That solution never really appealed to me. 1. Handling sessions/binary requests becomes a nightmare or even just impossible. 2. The evenbus overhead never really made sense for me. I think it is best to keep all routes modularized in dedicated classes and use a single verticle to register them. You could still use the eventbus to offload certain tasks to other parts of your application or even to other microservices. Hope that helps
Ultimate is open source now? If so then it might be good enough to switch from Eclipse in a few years.
I thought Gluon took over the development of SceneBuilder too
Err what? Apache Avalon got released in 1999, well before Spring.
&gt; CDI is inspired by JSF Managed Beans, EJB, Seam and Guice. So CDI was inspired by all that but not Spring. At all. Is that what you're saying?
Are you suggesting creators of software are anywhere near lacking work?
Gluon one is unusable for me as I can't click on anything in the toolbar, but when I download scene builder from oracle's archives it works. I just have to get used to that unpractical tool then.
[removed]
I'm asking you how you feel software developers can eat if all software becomes free as in beer? 
IT is known! King when asked answered that and he designer of CDI no?
&gt; many Spring fans claim DI is Spring's unique idea Who says that Spring invented *DI*? That person would be a colossal moron. The claim made by many Spring zealots (which is also wrong), is that *CDI* is a ripoff of Spring DI. Also, really - why are you making swipes against Spring in completely irrelevant places?
I homebrew. Yes software is free as beer.
So you don't have an answer. Thanks for clearing that up. 
Actually it got garbage collected...
Runnable jars are literally in the jar format specification and have always been: https://en.wikipedia.org/wiki/JAR_(file_format)#Executable_JAR_files
So when one day, the need to distinguish them does arise; you will have deferred the burden of thinking to a developer down the road. KISS and YAGNI are not opt outs for good planning.
I would use the Observer pattern (probably ReactJX would be fun to use rather than do it from scratch) to subscribe to the (event/notification) that the car type that I'm interested in is available when they publish it.
Why haven't you written your own, clean room style?
&gt;Tip #1: Don't.
Because I have fun with BlueJ
Thanks. Spark is more of a distributed big data platform, whereas Morpheus is focused on medium sized data problems that that can fit into RAM. Memory is pretty cheap these days, so loading 100GB datasets into memory is not crazy. Spark in theory gives you infinite scalability, Morpheus doesn't, but it was purposefully designed that way as I feel most problems don't need that kind of scale.
hey, here it is: https://github.com/auth0-blog/questionmarks-server
[codewars.com](http://codewars.com) is pretty good.
You are still on eclipse? Why? It's years and years behind even community edition, the big steamy pile of application platform with mediocre/poor IDE somehow bundled.
There are problems for which C++ is a good fit and there are problems for which Java is a good fit. 
C++ is good for your brain, it requires you to think slightly more critically because of its many nuances.
Containers are a bit weird in that they use a lot of internal wiring with classloaders and such to launch embedded applications.
What do you mean by "unpractical tool"? Where are you downloading it from? 
Certainly! Just playing around, haha.
As far as I know SceneBuilder is part of openfx which is a subproject of openjdk. The source for scenebuilder is still in the openfx repository for Java 9: http://hg.openjdk.java.net/openjfx/9/rt/file/c734b008e3e8/apps/scenebuilder/SceneBuilderApp Gluon also has a SceneBuilder source repository, I don't know if it has forked, or if Gluon merges into the openjfx repository on occasion. It is kind of confusing exactly what is going on: https://bitbucket.org/gluon-oss/scenebuilder/downloads/
Yey lets make the no1 predictable and performant platform a buzzword chasing nightmare riddled with bad designs choices Due to tight schedules. 
They would be if they made everything for free. 
Look at what the scripts are doing; mostly specific environment workarounds for cases that would fail when launching a jar with no arguments.
Community edition doesn't edit web files. 
what is "web files"?
You mean HTML, the format that is editable in notepad.exe?
Forcibly you don't get a thing about disruprive technologies
What does that even mean?
I understand that a lot of people love intellij and have passion for it. But it's not free as in freedom. They have patents on it. You can correct bugs and push to then, but you can't implement all you your needs onto it. It's free as in "free beer" not as in "freedom". I also understand that isn't easy to make a living with open source. But please, don't help this companies turn open source on a marketing brand. If they don't want to deal with open source users freedom ( witch include the right to implement new features and redistribute it) so please, don't open sourced it. 
The Oracle one is outdated. Try to get the Gluon working. Though don't expect much of an improvement. Download links: * [Executable jar](http://gluonhq.com/download/scene-builder-jar/) * [Windows x86](http://gluonhq.com/download/scene-builder-windows/) * [Windows x64](http://gluonhq.com/download/scene-builder-windows-x64/) * [Mac OSX dmg](http://gluonhq.com/download/scene-builder-mac/) There are Linux builds for deb and rpm, also x86 and x64. Drop a comment if you need one of those. I find the Scene Builder rather practical compared to other tools that float around, e.g. for Swing, WPF,... except maybe Android. That one is pretty nice.
A technology is something that provides technological advancement at the cost of jobs.
And gwt, jsf, js (with frameworks), xml (that recognizes persistence and maven) for serious web developing. I understand that a lot of people love intellij and have passion for it. But it's not free as in freedom. They have patents on it. You can correct bugs and push to then, but you can't implement all you need onto it. It's free as in "free beer" not as in "freedom". I also understand that isn't easy to make a living with open source. But please, don't help this companies turn open source on a marketing brand. If they don't want to deal with open source users freedom ( witch include the right to implement new features and redistribute it) so please, don't open sourced it. 
Source code files to develop software for web. Like html, js, gwt, css, etc... 
This is a great attitude to have and I would like to work with someone like you, even as a non-junior developer (~5 years).
For most people who pay for IntelliJ, coding is their job. Good tools are worth the price. If you feel you can adequately or better work in Eclipse, feel free. The notion that 100% of software needs to be open source and freely distributed, I think is unfairly restrictive. Businesses should be as free to sell it as you are free to ignore it because the "licensing terms" (requiring money) are not suitable to you. It's not inherently "bad", it's just not for you. 
an uberjar (aka fat jar, etc) is specifically a jar with it's dependencies bundled into it. all runnable uberjars are runnable jars, but not all runnable jars are runnable uberjars. or something.
&gt;Documentation is **really good** Totally agree. The vert.x tutorial is one of the finest introductions to any package anywhere IMHO. 
as is java, no? text files.
You didn't understand what I wrote. I would never think that everybody need to use free software, because that's not freedom. I just don't like when the industry use the term "open source" as a marketing brand. I feel exactly the same when I go to supermarket and see an "organic sea salt". It's like a lie. It's promising you something different that is written on the product. I think it's unfair. 
No I mistook you for the original troll I was responding to. My bad. 
Have a good grasp on Git. Have basic knowledge of vim, and basic shell script commands. Have a clue of how to learn about a thing they never hear of before. 
I still like _Effective Java_ by Bloch as a general best practices book. The chapter titles make a good "best practices" list, and the chapters themselves give detail and examples of why and how. I've heard a rumor of a new edition coming out which includes Java8.
Head First Java
You can easily write a plugin for HTML. It IS free, no one is stopping you.
Thank you. The fact that any programmer working in a banking industry doesn't know this is terrifying.
Effective Java 3rd Edition - November 20th 
You are certifiably crazy. Why?! 
Hah - it's a habit that started when I was still working on the TestNG plugin I started, when it moved over to Jetbrains control it moved into the main build. It's actually remarkably stable - when builds fail its usually because I need to refresh the Android plugin repo and rebuild again - but sometimes the community build just gets broken, I usually file an upstream ticket and its fixed quickly. If, on the odd occasion things are quite broken - I report it upstream and revert to either an older build I've made, or a released build.
Even when not rebuilding - watching the git log at http://git.jetbrains.org/?p=idea/community.git;a=shortlog;h=11081459fec9c41cdf69a6c2f6cf080bd802d79c I find is quite interesting.
This guys got issues
I suppose. I don't expect someone to know about all that stuff, but I do expect them to pick up on it pretty quick that they don't open pull requests with barely any tests/comments/ etc.
I agree. code versions in files are immutable, but tags can be changed freely. Also moving code between SCMs is prone to loose all SCM tag history. It would be more interesting to have SCM branches following a name from the source code than the inverse, though that would require the SCM to forbid parallel commits with the same version.
"The platform is in the unenviable position of being used by both large enterprises and as the foundation of a large amount of open-source platforms and languages that are used to a faster release cycle." Most language projects would kill to get into this "unenviable" position.
No, Oracle has a bad reputation due to how badly they treated the Java community. If they start treating it better, their reputation will improve. Of course neither going open-source or not will not by itself change the reputation of Oracle. But that does not mean they cannot redeem themselves. It just isn't that easy to make a comeback from years of abusive behavior.
That's such bs
He is trolling you dude. 
The Complete Reference is surprisingly easy to read and to the point.
Thanks for pointing this out. That's great!
You know there are tools for that, right?
And I picked up second edition only two months ago.... &gt;. &gt;
Java consists of lots of extra functions compared with its predecessors like C, C++. These functions make the language more comfy to deal with. It is included to be platform Independent. You can run your program on any platform that supports Java with no modifications in the industrialized program. Everything you see in java program is a thing, therefore, it is referred to as an item oriented language. You will these concepts very well while getting advanced java training in Kolkata.
Alternatively, just use IntelliJ Idea and its inspections will tell you when you do something innefficient and offer quick fixes.
Not allowed at any of our customers, where Eclipse is the IT mandated IDE on the developer's image.
Author of the article is the one who is working on such inspections in IDEA :)
Another way to help new people on your project could be to pair for the first features. You could explain that way your approach and what is expected. After that you can give him one simple feature to implement...etc I think it is important to do only one step at a time. And don't forget that juniors are like John snow : they know nothing ^^
Sounds like a guber-ment job. I cringe for you, my friend. :/
People coming from Python could like Groovy, and the book Groovy in Action.
Interesting... What is their reasoning behind that?
Maybe they have their own awesome Eclipse plugins that make everything so easy! ;) That was the argumentation of one customer I've been working for. Well those "awesome" plugins just executed Maven commands, so it was easy to use them in IDEA. I just continued working with IDEA.
Most Java based HTTP clients only support HTTP 1.1. If you are looking at HTTP 2.0 support, take a look at [light-4j client](https://networknt.github.io/light-4j/other/client/). It is the only client that doesn't need ALNP in Java 8. In https, it is twice as fast as Apache httpclient with multiplexing. 
To be honest, if I'd ever face such situation, I'd offer to rewrite the plugins for IDEA, first at their expense, if denied, then from my own time, then if still denied probably quit the job, but I would not go back to using eclipse daily. (also it seems like a poisonous environment to work in anyway.)
Everyone gets to use the same tools across the whole company and the possibility for not having security exploits lies within IT validation, not a random piece of software installed on the computer.
Not really, my experience with Android Studio performance made me love Eclipse again. So I am not sure I am actually missing something in spite of what everyone says. And if I had any freedom to choose my IDE I would be picking Netbeans actually. Additionally enterprise consulting does have other perks more valuable than being able to choose what IDE I get to use.
I never worked for any Fortune 500 consulting project where externals would have the freedom to use their own computers instead of IT validated images. Unless someone is willing to sign compensation clauses for security breaches caused by not using the official developer tools and computers.
My condolences. 
Ouch. That sounds like a very unfriendly environment for getting work done!
One of the first questions I ask when I'm being interviewed is whether the shop is IDE agnostic or not. Love me some IntelliJ.
I get having preferences for certain tools, but this kind of attitude seems more poisonous than having to use a mandated IDE (even if the reasons for the mandate are dubious which is not always the case).
Tomcat is a very complicated software by nature of its purpose yet it is very well abstracted. Even though a reddit message will not be enough to explain what it does and how it does, you can still move around the source code by ctrl+clicking but reflection is going to be a problem at some point eventually. Here is an example of how you can move around the source: It starts with main method in org/apache/catalina/startup/Bootstrap then goes to parsing conf/server.xml with Digester class which instantiates objects with reflection that starts by creating org/apache/catalina/startup/Catalina object (main object). Then Lifecycle objects are initialized that inherit from LifecycleBase, see their implementations of initInternal method for what they start. For example Catalina inits Server which inits Services which init Containers, Executors, Connectors etc. Then go a bit lower, e.g., Connector has adapter which is the controller interface about what to do the with a request coming from lower levels , ProtocolHandler (AbstractProtocol and its subclasses) handles the workflow to work the lover levels by AbstractEndpoints (and its subclasses) which handles socket connections with(out) encryption, converts them to low level request/response objects with specialized input and output streams and what not, assign them a thread with SocketProcessors that reads and writes and eventually hands back to Adapter for further processing to higher levels... Depending on your interest, you can follow a similar route.
Several of IntelliJ's quick-fixes are there because they can be programmed, not because they're necessarily a good idea. I tell everyone to disable the `Iterable::forEach` and `Objects::equals` inspections, for instance, because they're rarely the best solution to the problem even if there is a problem.
refer this : http://www.technewsncareer.com/p/oops-concepts.html
Typical across the majority of Fortune 500 companies.
I read the article expecting some sort of nuance. Instead the whole thing was essentially "Don't do things that are obviously wrong". Do people really do this shit?
They joy of not being allowed to use new versions of software because it's not "validated" by IT yet! So that i had to use old version with published CVE's. How I not miss it.
I don't get why this comment is downvoted.
Used IJ at a bank that was anal about security checks and they validated it. If anyone at my current workplace tells me there might be security issues I'll remind them kindly that their piece of shit web filter allowed me to download it in the first place, we're using soapui 3.8 in "courtesy mode", and I had to use someone elses credentials for 1 month before their retarded IT got me some credentials. Oh, and they would want me to use eclipse mars which I don't even know if still has security updates coming. Sorry, had to rant. 
What about OkHttp?
A tool to automatically deploy those files to my container while I edit then? To solve EL's and preview then as I change my server side code? To indicate configuration problems and inject test values? Yes, there are tools for that. This kind of tool is know as "IDE". 
Why would anyone care which tools I use (apart from the mentioned security issue), if the code I push to repository is by standards and I am not somehow less effective than others? I don't see how this is anyone else's business but my own, which technique/tools etc I use if those conditions are met. If a company has raised such pointless bureaucratic limits to tools, it is very likely it has this kind of attitude elsewhere as well, which wouldn't fit my expectations of good working conditions anyway so I might as well leave.
Some of those things might not be obvious to programmers that are less experienced with streams.
AFAIK, OkHttp needs to use a specific version of Jetty ALPN jar in the bootclasspath which is very hard to manage. Before building my own I have evaluated all Java based clients that support HTTP 2.0 and none of them are usable. The real issue is they treat HTTP 2.0 as an add-on and trying to balance between HTTP 1.1 and HTTP 2.0 without realizing they are totally different beasts. Light-4j client is designed for HTTP 2.0 from ground up with minimum support to HTTP 1.1(no connection pool). It is designed for light-4j services with default protocol HTTP 2.0 and it is used to communicate with Consul(HTTP 1.1) for service discovery and InfluxDB (HTTP 1.1) for metrics. https://github.com/square/okhttp/wiki/Building
&gt; it is very likely it has this kind of attitude elsewhere as well, which wouldn't fit my expectations of good... This applies equally (imo even more so) to somebody offering to rewrite plugins for their favorite IDE at the company's expense. I say this as somebody who strongly agrees with the fact that code and build should not be dependent on any specific IDE. 
I dont see the plint in this. Every decent ide has a debug mode. No need to upload code
Interesting, IT companies offer loads of perks and advantages to their workers, I don't see why it would be bad to ask for extending one of their existing plugins to platform many people prefer over the other. It would be like a perk, plus good for morale as people are slightly less likely to look for another place in the long term. It's not like I'm going to leave with that code after I would leave that job, they get to keep that.
[removed]
This is so backwards. When you hire a contractor to build a roof, do you provide a hammer? In our company external people can use their own stuff as long as it meets certain basic criteria.
you have a very interesting history of posting.
In my experience people that are heavily invested in these types of religious wars (ides/languages/build tools/etc.) are a pain to work with. How do you expect the rest of the team to react when instead of contributing to the project you spend your time extending an existing plugin (that does an adequate job) to your favorite tool?
To be honest, I don't really expect them to react much at all. The company I work for lets me choose the computer I want Mac / PC, the operating system, and the tools we use. We find it completely normal that "this thing won't work under linux/mac/win, let me fix it.". So the culture is very mixed and we don't generally have any kind of wars over the technologies we use (There is some hg/git tension from time to time, but only because this is not personal choice but team wide). Though I would expect those wars to be constant if people were forced to use software they don't want to use.
[removed]
I see `collection.stream().forEach(...)` all the time. Some people are still familiarising themselves with the API. Nothing wrong with that.
[removed]
&gt;We find it completely normal that "this thing won't work under linux/mac/win, let me fix it.". This isn't my definition of normal... I'd rather everybody use JDeveloper than "JVali can't work on the project until he's done getting this 'thing' to work in his environment."
Well, then, let's agree to disagree.
Great contribution to the conversation. Not like there's a button to the left of the comment where you can do the same thing without leaving a comment.
The technology just isn't there.
&gt; The claim made by many Spring zealots (which is also wrong), is that CDI is a ripoff of Spring DI. That's the most common one, but the invented claim is there too, with the slightly better educated of them claiming Spring introduced DI in enterprise Java. Point is, almost no Spring fans realise that JSF had a full fledged DI of its own, and that JSF was released almost simultaneously with Spring. &gt;why are you making swipes against Spring in completely irrelevant places? Isn't that how Spring rose to fame initially? It's deeply buried in the Spring culture, at least for the older folks. When Spring started they were completely unknown, and the trick they used to get on people's radar was making swipes against Java EE at all irrelevant places possible. 
&gt; Servlet, JSP, and EL specifications And WebSocket and JASPIC ;) That's 5 of the ~28 specs in EE 7. 
collection.stream().forEach() is pretty silly, considering you can do collection.forEach(). stream.forEach(methodHandle) is pretty nice IMO.
This library has a lot more static mutable state than I am comfortable with...
It sounds like it's assuming the directory structure is the package layout. If you had `package Desktop;` at the top of the source file, then it would work.
[H2 provides its own connection pool, which is as simple as the example provided.](http://www.h2database.com/javadoc/org/h2/jdbcx/JdbcConnectionPool.html)
Android studio has been based on IntelliJ for about 4 years now, hasn't it? Sure you're seeing that sweet IntelliJ performance? ;)
&gt; That vulnerability, according to a report on the data breach by William Baird &amp; Co., was in a popular open-source software package called Apache Struts, which is a programming framework for building web applications in Java. Not Javas fault at all. &gt; Correction: An earlier version of this article said the vulnerability exploited by the hackers who broke into Equifax was the one disclosed on Sep. 4. It’s possible that the vulnerability that was targeted was one disclosed in March. We will update this post when we’ve confirmed which vulnerability it was. So it *might* have been Apache Struts fault, but certainly not Javas. But nice clickbaity title.
Clickbait. It's the struts attack that a billion other applications were vulnerable to. You realize struts is a framework and is different from Java?
Wonder who uses Struts in 2017 anyway, it smelled bad back at 2002 already.
Ahhh ok. So the default is assuming it's a package structure. I guess it makes sense. 
Why it will be misleading? If you don't have years of experience then i think it is fine to have it as a headline on your resume. Something like " Oracle certified Java Developer......"
Maybe a wake up call to the (finance in particular) industry that just because outdated software works, and that it costs resources to rewrite, doesn't mean that its still secure.
I thought we were over C3P0. HikariCP seems to be the modern choice nowadays: https://github.com/brettwooldridge/HikariCP. (also, https://github.com/vibur/vibur-dbcp, https://github.com/swaldman/c3p0, http://commons.apache.org/proper/commons-dbcp/, in this order)
Just say no to Java streams. They are shower, produce more garbage, and less clear. Look at the max example. It is absolutely less clear than a simple foreach loop.
On a side note, a lot of JavaEE servers have their own connection pool libraries built in that you can access using JNDI. Granted, you still have to set up said connection pools in the server's settings.
HirakiCP is not standarized in a JSR. It should be avoided.
Ok thanks
I put my certifications under my education section.
Congratulations. You should put it under your education and certifications section. After you have some years of experience behind you this will be your least important section in the résumé.
Google modifies it a lot, so it is unfair to fully blame InteliJ.
I find `collection.stream().peek()` pretty funny as it's basically a `forEach` without consuming the elements, or a `map()` returning the same element.
You are welcome. I think you should use bullet points in the first paragraph. At the junior level punchier résumés catch the attention. Remember your objective is to grab the attention of your interviewers and give them as many talking points as possible. If you are at an entry level consider mentioning your hobby projects too. All the best!
I'm not a native English speaker so it may be right, but the "Self-taught himself" on the first line sounds awfully redundant to me. I didn't want to keep reading after that.
Java is good for some things but is overkill for web dev. Lighter runtimes are replacing it in droves. In a microservices oriented architecture it's commonplace to use runtimes like node.js to route requests to downstream services written in multiple languages, including Java, when it is called for. But using Java for *everything*, including serving your API routes, is going to cause you a lot of pain. The JVM is extremely resource intensive and as you've seen in spring boot, doing the *simplest* things with Java is time consuming and overblown. In today's world of containers and horizontal scalability it makes a lot more sense to use lightweight and flexible runtimes to serve your web layers and only use Java **where and when it is actually required**. Edit; note that the downvotes are only due to the serious case of self-loathing this sub has. Java has been on the decline for years now and nobody here chooses to accept it. What's more, people in here actually *encourage* monolithic application design (using Java, no less) and say that containers or any other ephemeral runtimes are bad. Notice how someone commented that I only see in black and white when I literally said that there are still valid use cases for Java. That's essentially gaslighting. Java is a great choice for CPU-bound apps and tasks, services with rich concurrency requirements (java.util.thread is great for this). But for everything else it's literally overkill and extremely costly to run. Also, apparently outdated as Equifax uses it just divulged credit info of 140mm people
Learning core Spring (IoC/DI) is enough. You can learn the rest when/if you need it. 
in case you're wondering why this guy gets mass downvoted it's because he is an anti-java troll that talks shit.
And where and when is it required, in your opinion/expertise?
An article author here. There are many cases when IDEA inspections will not warn you. E.g. IDEA warns about `Arrays.asList(array).stream()`, but if you have a stream of arrays and write `.map(Arrays::asList).flatMap(List::stream)`, then IDEA will not notice that it's essentially `.flatMap(Arrays::stream)`. Another case: IDEA will warn about `filter(...).findFirst().isPresent()`. But if you extract an Optional to the variable, then warning will disappear. Probably these cases will be covered by IDE in future, but it's better not to rely that IDE will think all the way instead of developer.
Could you please tell what is `Iterable::forEach` inspection? Which kind of code this inspection suggests to refactor?
ALPN is a requirement for negotiating HTTP/2 over TLS. Not supporting it is a mistake, not a feature. In particular, not supporting ALPN means that if the server ever attempts to serve HTTP/1 then clients will break. This could happen in practice when you introduce a CDN or HTTP/1-only load balancer. OkHttp requires jetty-alpn on the bootclasspath for Java 8 because Java 8 doesn’t support ALPN natively. OkHttp will use the built-in ALPN on Java 9 without any bootclasspath tricks.
Did you change the URL in that resume? Because it gives 404.
Depending on org.json doesn’t inspire confidence.
Not just that: a while ago he forgot to switch to his 'normal' account and asked a completely basic CS question on his troll account. Not only is he a troll; he's a complete beginner too. I don't know what his problem is but he's probably not on the meds he should be taking. 
&gt; What I have found with Spring is that it's massive and will take quite some time to master. Yup. Most modern web frameworks are though. &gt; So my question is, is it worth investing time to get really good at Java and it's ecosystem for web development, particularly the Spring framework? Most of the stuff you learn when you're working with Spring translate pretty well to other frameworks. How it's done might be Spring specific but the concepts easily translate to other frameworks 
Forget about him. See my other reply. 
https://gist.github.com/mbabna
That question is answered right there in the article: &gt; “At least 65% of the Fortune 100 companies are actively using web applications built with the Struts framework,” the report said. I know you were not seriously asking but people would probably still use it even if it went EOL 10 years ago because they build a huge system around it.
Can you explain what a SCS is? I am not familiar with the term. Or do you mean service? If that's what you mean it's the weirdest abbreviation for service I've seen :) As for your question: you could automatically start a VM and deploy the services in there and run them. But if you can't use containers (why the hell not?) I doubt they'll let you do that too. 
Is there a connection pool that *is* standardized in a JSR? And is there a practical disadvantage to not being in a JSR?
Doh, sorry. Lack of coffee. Well, those 'projects' you post there are going to cause you to never be considered. Build some real applications first; a Java certificate doesn't make you a software engineer and that gist makes it painfully obvious. 
&gt; When you hire a contractor to build a roof, do you provide a hammer? If you're a major construction company running large scale building projects, sure.
Thanks for your reply. http://scs-architecture.org there you can find some information. I don't know why their Ops are completely against containers. There were no real arguments, but I try to convince them, that this is the best solution to our problem. But also I try to find some alternatives if that doesn't work out.
This is well before entry level work. Sorry. Also the code is a complete and utter mess. You should have separate applications in separate github repo's and they should actually be functional applications; so including a web user interface. Basically what you have is some very basic main classes. Not fully functioning applications. You don't have any relevant experience or education and this means you have to put in a lot of effort to compensate with a decent portfolio. 
Wow. This is huge for the court case they will face. Equifax got hacked by an already patched bug and neglected to update their servers. 
&gt; http://scs-architecture.org there you can find some information. Ah. So none of the benefits of microservices with all of the downsites. Gotcha :D But yeah, I'd definitely go for a container approach. I'm also quite a big fan of uses container orchestrators like Kubernetes. I think their main objection is that they have to learn new things. But for ops people learning containers is incredibly important; you can't really not have it absent on your resume as Ops in 2017. 
Yeah, totally my point. I think there ist really no other way that is state of the art and wouldn't cause a lot of pain. Maybe the guys over in DevOps have another idea, but I don't think so. :D
&gt; If you think I should upload on github repo I will...I'll also fix the if statements, for statements to make it more legible (is this why u say it's a mess, things of this nature?) It should be a proper runnable project, properly formatted. A quick example of an extremely simple application I made: https://github.com/nielsutrecht/jwt-angular-spring (it's an example application and nowhere near production quality). &gt; Thanks for the stern advice...it just seems like all computer science grads get software engineering jobs so easy. Well they spent 4 years learning a ton of pretty hard stuff. I would not call that 'easy'. Sorry if I come across as a dick but all you did is do a relatively easy certification exam. Software engineering is much more than that. &gt; Anyway, I don't fully understand what you're saying by very basic main classes. my main class links to other complex classes. For you they're complex. That's the point. You probably have never seen actual production code; what you created is utterly trivial compared to a production application. Again; I'm not trying to be a dick. I just feel you're going to be really disappointed if you expect companies to hire you based on what you present here. P.s. I don't know who's downvoting you but it isn't me. 
If they have a better idea on how to handle this they should explain it. Just saying 'no' without an alternative is completely unprofessional. Where are you located by the way?
At the moment I'm working as a consultant in germany. 
&gt; Well, anyway everyone forgets what they learnt in college...idk I just don't think a college degree means much... Keep in mind that that is pretty insulting to people who did go through those 4 years ;) It's simply not true either; the basic algorithm / data structure stuff is something I use every day. &gt; Like if I got my masters in computer science right now, I would honestly not be a better software engineer than I am right now. You're not a software engineer yet. You just got some very basic Java skills. You're off to a good start; don't get me wrong, but you have much more to learn. If I may make a suggestion; start with a really simple web application. Aside from some core Java there's more you need to learn to be productive at your first job. I would suggest you learn: * Git source control; use it in everything to get into the habit * Maven as a dependency manager; it's everywhere in the Java ecosystem and your github projects are expected to have a Maven pom.xml * Start with Spring Boot and build a simple [web application](https://spring.io/guides/gs/spring-boot/). Spring Boot is the de facto standard when it comes to web frameworks * Learn to use a logging libraries (slf4j + logback) * Learn how to create unit tests with junit * Learn how to mock dependencies in unit tests with Mockito * Learn some basic HTML and CSS skills so your Spring web appl doesn't look like garbage * Learn some SQL basics and use Spring Data JDBC to interface with a database in your application (you can use an in-memory database like H2 for now). After you did the introduction on the site I gave you I would suggest starting with a very simple web application. A todo list for example. Don't start with some kind of hospital management app just yet, that's still too complex. The above is basically the bare minimum you should be able to do to be able to be somewhat useful in a project. And even then getting hired will be hard. 
Ah, too bad. We have a sister company that gives a Docker 101 course but I doubt I can convince them to travel from here (Holland) to Germany for that :D
I hope you understand that for most devs uploading production code to some random site is a huge no-no. 
Well, Docker skills aren't the problem I already did those things for other companies and projects. :D
No I meant for your ops guys, not you :D
I meant learning this before applying to companies. 
takes seconds, which I wouldn't have to do if sites were laid out properly...
I use Unirest for testing or when I need to make a few simple rest-calls. Lightweight isn't the word I'd use to describe it (it has a lot of dependencies and performs worse than most other clients), but it has an API that's very pleasant to work with.
Not all of it no. But you will have to compensate your lack of formal education with showing your ability to at least create a complete application start to finish.
&gt; *“At least 65% of the Fortune 100 companies are actively using web applications built with the Struts framework,”* Erm what? I mean, perhaps 65% of them have Struts *somewhere* in their thousands of applications, but hardly 65% of applications are still built using Struts. Would be worth stressing this.
IMO streams are the first addition to the Java library in ages that reduce code quality significantly when applied mindlessly (either by hand or by using IDEA's suggestions for replacing simple loops). Compared to functional languages, they are _way_ too clunky for small one-off transformations, as in persons.stream().map(Person::getName).collect(Collectors.toList()) vs something like (Scala) persons.map(_.getName) or Haskell map getName persons I appreciate the reasons why streams were implemented like this in Java, but they really need a more compact API for everyday use (e.g. underscore syntax as in Scala, .toList() helper method, adding common combinations like ".stream().map()" or ".stream().filter()" to collection interfaces).
TL;DR - The vulnerability that was said to be used would have been a zero-day exploit at the time of the hack. Once it was made aware to the Struts development team, it was patched (prior to the hack announcement) Lesson: Always patch your software with security fix releases, although it may not have mattered in this case.
Currently, Spring is the central piece of Java web dev, whether you like the framework or hate it. Learning it should be the biggest priority, but mind you that you should rather learn by doing instead of trying to memorize the documentation. It's true that Spring is huge but it's also quite well modularized, so you can start with the most important modules first (Core, Web MVC, Rest, Data, etc.) and then move on to the more exotic ones (or only learn them as they're needed). And yes, it's definitely worth the time to learn Spring. If you look at some job offers for Java web dev, you'll probably see Spring *everywhere*. Perhaps maybe if you're in the US, Play Framework might have a bigger impact there.
&gt;^() 4. Establish security layers. It is good software engineering practice to have individually secured layers behind a public-facing presentation layer such as the Apache Struts framework. A breach into the presentation layer should never empower access to significant or even all back-end information resources. Most common thing that I see not being done. 
Read again. At the time of the breach the vulnerability was not known, so I doubt it'll bear relevance to the case. Also, as per the article, it is *alleged* that they exploited that vulnerability.
If possible, if I'm doing a lot of collection manipulation I try to use Eclipse Collections, (Former GS Collections) in my JMH tests they are about 10-25% slower than JDK's Collections (But this doesn't take into consideration of garbage collection, Eclipse Collections are supposed to be memory efficient). It's a breeze to work with libraries that use Arrays a lot, as their List implementation has an Array Constructor
It suggests something like replacing for (Object o : objects) { foo(o); } with objects.forEach(this::foo);
When you're starting out it's very easy to think very black and white when comparing languages and frameworks, so it might not even be trolling.
&gt; Is there a connection pool that is standardized in a JSR? No. &gt;And is there a practical disadvantage to not being in a JSR? The typical Rod Johnson argument. "is there a practical disadvantage for Spring not being standarized?". Fuck developers like you that get their customers into a vendor lock-in situation just for money..
What a retard. JSON is not a Java technology so the JCP is not in charge of that. And yeah, [JSON was standarized a long time ago](https://www.ecma-international.org/publications/standards/Ecma-404.htm). No vendor lock-in at all.
Sorry if I didn't express myself clearly. We implemented ALPN natively without patching JVM. You cannot claim you support HTTP 2.0 without ALPN :)
It should not be highlighted by default, this inspection has information level, so you can use it as an intention action. You can convert if you want, but IDEA does not issue a warning. If it actually makes code yellow by default, then it's a bug. If it's not highlighted, why disabling an action? Just don't use it (usually it's the last action in Alt+Enter list, so it's not very annoying). Disclaimer: I'm IntelliJ IDEA developer and mostly responsible for this feature, so I want to know if it poses some inconvenience.
We have hired some Java developers by looking at their github contributions and it is a great way to find great developers. I would recommend young programers to help open source projects to learn and build up your experience and show off your capabilities. 
was this struts1 or struts2?
I interpreted that as. At the time of breach they did not know the exploit. Later they then found out the exploit used was patched months prior to the breach. 
Neat. I’m sorry for misspeaking. I looked through the light-4j code looking for ALPN and I didn’t find it.
Thanks so much for the replies everyone! I have a few books to order!
From the article &gt; the breach could be related to CVE-2017-9805, which was publicly announced on 2017-09-04 along with new Struts Framework software releases to patch this and other vulnerabilities. However, the security breach was already detected in July, which means that the attackers either used an earlier announced vulnerability on an unpatched Equifax server or exploited a vulnerability not known at this point in time --a so-called Zero-Day-Exploit. If the breach is related to CVE-2017-9805 there's no doubt that the breach happened *before* the exploit was known, let alone patched. Even the original Quartz article's writer has doubt on which exploit the researchers are talking about. So the most charitable interpretation is that no, even keeping their software up to date, Equifax wouldn't have prevented the breach. But don't worry. There are still other fuck-ups they could have avoided to prevent this clusterfuck (see part of discussion [here](https://news.ycombinator.com/item?id=15208211), for example).
I dont have any further input on this but i want to thank you for respectfully educating me on the matter
I also hate (with a passion) spring for how invasive it is. HikariCP on the other hand is actually not invasive at all. None of your code has to even know it exists. Just set it as the data source and you're set. And it's trivial to switch it out for any other of the popular connection pools. I don't think any of the popular connection pools lock you in. So this isn't an advantage specific to HikariCP. 
True, there are many other (more modern) libraries. That's just the way I implemented it. Anyways, I am thinking about adding HikariCP to the tutorials...
fyi vertx is very node-like but much more performant, and runs circles around spring/servlets at microtransactions, and is designed to scale. plus if you really have to share your js validators across the wire, it is trivial to do (vertx is polyglot). There is a lot of runtime overhead in spring, and annotations are a language unto themselves, with less than stellar ide support/very slow. If java HAS a future in web dev, it will be in the form of something like vert.x. Otherwise it will be relegated to "enterprise", i.e. klunky apps where the client on the other end of the phone keeps hearing excuses about how slow the system is today. https://www.techempower.com/benchmarks/#section=data-r8&amp;hw=i7&amp;test=plaintext 
The light-4j client is built on top of Undertow and the ALPN is implemented there. https://github.com/undertow-io/undertow/blob/master/core/src/main/java/io/undertow/client/http2/Http2ClientProvider.java
Learning java will be rewarding in web apps. As you've mentioned the eco system is vast and well documented. I personally use JavaScript and jquery for client environment. Page is rendered using jsp. Hibernate to talk to db &amp; Struts to glue everything together. the sheer size of the code base could give one nightmare if it weren't for java's strong typing. In short yes it is awesome to learn it build your core code since it offers maintainability.
Sprint Boot. So just keep doing what you're doing. I'd recommend you try Dropwizard ( or alternative ) just to give yourself a counterpoint reference. These help you identify underlying and central themes and limitations as opposed to library design choices.
I've been working with Java for 10 years, and I still have no clue what Spring is supposed to do. Lately I've been using [SparkJava](http://sparkjava.com) to create REST APIs together with Mongo/Cassandra/Solr/Kafka own clients, and a HTML5 frontend. What is a framework like Spring supposed to solve? 
My colleague told me that he met a guy who didn't know the movie, "Pulp Fiction." This is similar.
Are people still building projects on Struts or is this a 10-year old legacy product they've never refactored?
Misunderstood the title - this made it look like the Quartz scheduler software had a vulnerability... but nope still the Struts issue. 
My main concern is in terms of the future. I don't want to spend 6 months learning the framework inside out and finding out it's becoming obsolete. I know currently there are lots of jobs for spring, but they are almost entirely in Enterprise. Do you see this changing? I don't want to limit my career in that aspect.
This is my main account. I did ask a noob question about something and I'm not ashamed of it. Nobody knows everything, but that's a critical piece of why the attitude in this sub stinks. 
Struts2. Struts 1 is unaffected. Sometimes older is better.
Anytime ;) I actually don't understand people correcting others in rude ways, unless 'others' are being uselessly obtuse and rude themselves, which you weren't.
Changing the MVC framework you're using is not refactoring. It would be rewriting. 
I'm not sure if I understand your original question properly - have you settled in on Java, or are you looking around for a language and ecosystem to use for web dev? If the former: Java is a huge part of web development and it is used mainly in enterprise. If you that suits you then Spring is part of the basics. It will most certainly not be ditched in the nearest years to come and even if, by some miracle, it stops being used at one point in time, you still have a huge buffer of projects that were setup using it and need to be maintained. If the latter: you need to do some research, there's plenty of options: Ruby on Rails, Django, etc. They fill different niches, they're used more in startup projects, I guess? Not really sure, I sit in enterprise Java web dev in Spring with some occasional big data in Apache Spark and private game dev projects which are an entirely different environment.
I used to work for banks and other huge (really, tens of thousands of employees in IT) companies - and you're right, they will. Not because they are stupid or something, but because it takes enormous time to make even a small change. People are still stuck to JDK 1.3 for whatever reasons. So yeah, the question was mostly rhetorical. I believe that we will see more of cases like that in the future, especially when AI will be trained to find and explot such breaches automatically.
It's possible it doesn't highlight any more! It definitely did in the past, though.
**Remnants of the Precursors** is an attempt to make a modernized version of the original *Master of Orion* from 1993. The most recent Alpha is now available and downloadable from: https://remnantsoftheprecursors.com/2017/09/01/alpha-4-is-available/ We have our own subreddit at www.Reddit.com/r/rotp which I am using to centralize feedback, discussion and bug reports on the game. If you are interested in this game, then joining the subreddit is a good way to get the latest updates into your reddit feed. The game will run on any Linux, Mac or Windows PC with Java 8 installed and at least 512Mb of memory. I'm trying my best to ensure that it will run well on a Raspberry Pi Zero. Remnants is not yet feature-complete but still very playable. The last big functional piece remaining is player-controlled ship combat, which will be arriving in the next Alpha. Eight of the original ten races are already in the game, each containing its own unique artwork. The artwork is amazing, so check out some of the screenshots on the blog. To give you an idea of our team, along with me and the artist we have a professional writer working on in-game text and background lore. In addition, a graphic designer has been redesigning all of my original, amateurish attempts at the user interfaces. We're over halfway done with that :) We are also planning to translate the game into at least 20 languages by release. To that end, we are currently fully translated in 4 (English, Polish, Greek &amp; German) with 3 others in work (Spanish, Russian and Hungarian). Lots more are planned and we are always looking for additional translators (paid). Email me if that sounds interesting to you. This project has grown organically as so many talented people have joined with the goal of making this game a worthy remake of what is arguably the best game in the space 4X genre. I am more excited about this game now that even when I started it 2 1/2 years ago as a hobbyist project. It is free to download and play now and will remain free when it's completed. Thanks for your consideration and feedback. 
I am using it at work, and only know enough to do my job properly. I want to invest time to learn it better, but want to make sure it's a good investment. I think I might be getting too stuck up on frameworks and languages :(
&gt; court case Equifax has no legal case - see: [8. Limitation of Liability](https://www.apache.org/licenses/LICENSE-2.0#no-liability). 
Even if Spring or JavaEE become obsolete, the practices they use and the OOP and functional programming principles you will learn by learning either of those 2 will always stay true. The good part about Java is that many problems have already been solved by experienced programmers and are open-source do you can learn a lot by using and analyzing them. Hipster languages may lack the structure or the good practices or the documentation and learning material. That doesn't mean you can't write good code on them, but rather that it is harder for a beginner to do so. Both spring and javaEE can make rest endpoints really fast and solve aspects fairly easily (logging, security etc.). Unit testing is done really easily if you use mocks for dependencies and di in production.
This is not like the JS ecosystem. The dominant Java frameworks rarely change or they exist alongside for a long time giving you time to learn the details if you feel like so. Most are so similar anyway. Also note that Spring is an application framework not web only. See: * [Zeroturnarounds Top Java Web Framework 2017](https://zeroturnaround.com/rebellabs/java-web-frameworks-index-by-rebellabs/) * [Zeroturnarounds Top Java Web Framework 2016](https://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-2016/#web-frameworks) * [Zeroturnarounds Trends 2016](https://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-2016-trends/)
Interesting thought, but if there are people who will use this stuff maliciously, there will be people using AI to uncover exploits and report them, just as it is now.
Did you use any base library/framework like JavaFX, Swing or libGDX?
Not necessarily. It could be as simple as changing a base class. Web MVC frameworks don't really do a while lot.
Whill will lead to the AI vs AI competitions. Imagine some AI stealing bitcoins from another AI just because it was able to second-guess the passkey for the wallet that it had retrieved from some storage.
I'm using Swing libraries minimally, but mostly just JPanel to give me a graphics context to draw in. I've gotten rid of most of my JLabels and Borders, but am clinging desperately onto JTextField because it's so convenient! My idea of an ideal JPanel is one without any layout. I do use JavaFX to deal with mp3 audio files but am not super happy with the results so far. There's a lot of thread growth issues that I am currently willing to chalk up to something I'm doing wrong but at some point I might cut bait and look for another solution. I used to use ogg files and the jogg/jorbis jars but had worse issues with them and got tired of debugging the code. I don't use libGDX at all. edit: I do use the Apache FastMath class for its implementation of arcSin() which is much much faster than what is in Java's Math class.
They mean against equifax, not against apache.
Sorry for breaking rule 3, please remove if this post is not okay. I was reading a web-framework popularity article at RedMonk, and I was wondering what frameworks people in this sub use. The question pops up every now and then too, so why not make a poll. If this is allowed to stay up, I'll publish the results next week.
Hmm, this is a very narrow minded approach and one that honestly would make me skip over your resume entirely. Your assumption is backwards actually. There is no way that you can get a good solid grasp on a code base with millions of lines of code that has been under development for years by a team of people with a lot more knowledge than you. What you can do, however, is understand what every other programmer has done if you know and follow basic/universal principles of programming and software development. You don't go into medicine by studying one person's body. You study all bodies and then apply them to one specific person. It's a billion times more efficient.
The backend starts in the stack du jour, but always gets rewritten in Java when availability and maintainability become concerns. Most will say to use Spring Boot, but if you don't want the startup bullshit for the rest of your life, JAX-WS is a bit more mature--and a part of the JavaEE spec. 
You deserve an upvote for taking the time to help this guy out. He's been over in /r/resumes asking the same questions getting the same answers.
Older is different, not necessarily better
No one said you had to spend $200k to get a CS degree. You would have to go out of your way to spend that much, in fact. And you're really only proving the points we're making here that if this is what you learned in "6 months hardcore learning the material" then it was basically a waste of time/money. Also, if mech engineering students aren't creating projects and portfolios, I am seriously going to go back and get my Mech Eng degree. I should be able to pick it all up in about 3 weeks from a $100 online course, right?
I appreciate your comment a lot, thanks :)
No he's definitely trolling.
Someone who's asking the most basic of CS questions should not go and actively seek out people and give this kind of shitty advice. We've all been inexperienced but most of us have been humble enough to know when to shut the F up and listen. 
No prob. He blocked me for trying to explain it to him too. Some people hate being told their super awesome shortcut to six-figures isn't going to pan out. :)
Yeah. It's always nice to be told that the 4 years of school I went through is useless ;)
Well -- I don't know how to put this without sounding like an elitist prick, but I saw his github and thank god I went through those four years. I, too, wouldn't get a call back from a portfolio like that. But if all else fails, we can go back and get another engineering degree... how about mechnical? Aerospace? All it takes is about $250 and three weeks and we can get hired right at NASA.. isn't that how it works? :)
Well, OnlineGDB cloud IDE isn't meant for large production project. But it can be helpful for testing and debugging small program, may be to newbies.
It's not about large vs small. I can't upload anything that I produce in my job to you. I'm sure that this goes for most professional devs. So your target audience is rather small unfortunately. I really like the effort you put into it though; don't get me wrong. I can imagine it being useful for students.
&gt; isn't that how it works? I wish ;) He'll find out soon enough. I did my best, that's all I can do. If he doesn't believe me; fine :)
&gt; I've been working with Java for 10 years, and I still have no clue what Spring is supposed to do. Yeah, don't tell that to a prospective employer ;)
Learning things that will be obsolete in 6m is basically all we do as developers lol
CORS is computer science? Lmao this is too much. Your entire comment is the perfect example of why this sub is dying
Very cool. I have been making games for years now, mostly in C++ DirectX/OpenGL. Recently, I've been porting my C++ code to Java and using a bit of LibGDX as sort of a glue for OpenGL between platforms. I wanted my games playable on Android + PC + Android TV. So far it's been a great experience. Even just finished my Collada File Importer into my game. Rendering Animation correctly too!
Yes I think it does. I know on windows you click an exe to start the app and I think on linux it's a .sh.
Neither Spring nor JEE will become obsolete any time in the next few years. However, it's worthwhile to keep an eye on trends, and spend a little time exploring alternatives on your own time. My advice is to learn good design and architecture, how to write solid, clean code, and work effectively as part of a team. Those skills translate very well no matter what specific framework or language you're using. 
"As a result, I now often have to pretend I’m writing in C" I do that a lot in java when I want/need performance. Signed bytes are still kind of a PITA though. Still the best way to deal with GC glitching is not to make garbage in the first place. 
Im in a similar situation. I love java, it's my favourite, but everyone always talks bad about it. I'm an Android dev but I'm in the process of learning both Java EE and Spring. I have indeed noticed a LOT of job postings for java positions but something to keep in mind is that the work environment for those kinds of jobs might be very different, potentially the complete opposite to what you (game dev) and me (android dev) might be used to. It seems most java jobs are for corporate stuff, though obviously not necessarily always the case. Other than that, there's always negative stuff to be heard about the use and future of Java in every aspect of programming. People saying its dead, complex, clunky, not worth it etc. But then again, you look around and you'll notice the same thing has been said for the past 10 years and yet here we are. Search results show java EE / spring as one of the most common techs even today. I've got a few books and a few courses on udemy that i plan to use once i get started with it (i'm currently learning angular first)
You can learn either Java EE (J2EE is a deprecated term) or Spring or both. They both have pros and cons. With Java EE a lot of external dependencies are magically present in your application server and you only have to know how to use their APIs. With Spring you have to do some manual stuff but there's Spring Boot which makes it magic again. Both have the same goal of trying to strip away boilerplate and wiring stuff so you can focus on writing business code. There's a lot of work in Java EE in Spring as it's perfectly suited as a backend for web services, so basically whenever a frontend talks to a backend or backends communicate directly.
Java the language is not very hip, but it's catching up. If you want hip, use Kotlin. Java does have a very strong and standardized ecosystem. Lots of good frameworks to choose from without having to face a complete rewrite every year.
Interesting. I thought about Android Dev as well. But couldn't really find jobs for it, and honestly, I have done very little Android development, so my 8 years in the industry doesn't help me like it does for web/application programming. When you say very different? do you mean corporate culture? Because I've worked in start-ups, mid sized, and corporate companies so far. Obviously a Game company has a stronger "nerd" culture, etc. But honestly I'm seeing pretty much nothing but .NET and Java EE jobs when looking at the state I want to relocate in.
Number one: It's not called J2EE anymore. Has been JEE for several years.
Ah thanks for the reply. I will look into what Spring Boot is. Any online resources other than Spring Documentation to learn from? 
Good to know. I noticed some Job positions still mention J2EE. Like I said, I want to get involved with J2EE more. I have a lot of experience with Rails and MVC, and other languages, but would love to learn Java EE. Thanks for letting me know.
There is a lot to unpack in your post... And I feel you! Language rivalries have been mostly toxic and rarely productive. A few notes from me (10+ years in Java and web development) 1. J2EE was rebranded as Java EE a long time ago. It sounds pedantic but as someone who interviews others, if they mention J2EE, I tend to think they are not in touch with the latest changes and grill them more on the concepts than I would've. 2. There are Java EE only firms, but spring would offer more opportunities. However, would highly recommend starting with Java EE and then moving to spring. In my experience, all Java EE people could understand Spring code, but not necessarily the other way around. 3. Regarding studying, Java EE is a huge world, try to pick and choose one topic at a time. Would recommend servlets, JSPs as a starting point, moving on to EJBs (especially scopes and transactions) and then JPA and JaxRs. Do take a look at what the market is asking for, these however must be essential even if not mentioned. 4. Resources. Official documentation is good enough for starting, their Twitter account also posts some good ideas and blogs. Adam Bien has a YouTube channel with good content (also look at his Github repositories) . If you still prefer books, then I highly recommend Safari books online. They have great collection, and I think they offer free trial, if you can though, buy a subscription, it is well worth it. 5. Pitfalls that I have seen with others is that at times they get stuck in understanding application server, would recommend you just understand what that application server specific file is doing and move on! These were all from off the top of my head, feel free to ask more if you have questions. You can even message me on Reddit anytime... Always glad to help! 
Even worse, there's a persistent rumour floating around here about some bloke who allegedly hasn't seen The Godfather 😮
I think the future of web dev in Java looks quite good. Java as an ecosystem has a stability that the crazy fatigue inducing JavaScript community can only dream off. With the two major players releasing their new version soon; Java EE 8 and Spring 5, thinks are pretty well on track. And both won't radically change everything, and will have transpilers and web packs and turning around their entire approach. Instead they keep providing a steady stream of usuable and for the largest part backwards compatible changes. If you're a 15 year old high on sugar, perhaps not that exciting. If you're a serious developer who needs to get work done, these are in most cases your go-to tool. 
Is there a list of major changes from 4 to 5 somewhere? Edit: Found a few high level comparisons: * https://howtodoinjava.com/junit-5/junit-5-vs-junit-4/ * https://howtoprogram.xyz/2016/08/10/junit-5-vs-junit-4/ * https://www.ibm.com/developerworks/library/j-introducing-junit5-part1-jupiter-api/index.html
There was one but the features I switched for were @BeforeEach and dynamic tests. 
isn't BeforeEach just like Before?
I think it is absolute awesome what you done in Swing. I got so many questions. For your JComponents did you extend a lot of the classes in order to give your components their own feel or go the route of creating factory methods to produce them? How did you go about layering your components on top of each other? Did you use JDialog components to have things overlap each other or did you use the GlassPane? Noticed your game isn't resizeable? Why did you end up going this route? How did you go about creating animations in Swing? Did you do it with Timers and overriding the paintComponent method or place components in a container that has animation capabilities? With the animation question, say you give a component animations how did you go about it not causing issues with your layout manager so to speak? What layout manager is your favorite? I'm curious why you went the free route. What you have done I can definitely see that this game could have a price on it. I tried it out and I can tell its going to be great. My biggest tip for you is some sort of help/tutorial section for people who don't know how to play the game but I'm 200% sure you already know this. I'm also developing a game in Swing and some of the things you have done amazes me. Spinning world, the Tech menu, music, the galaxy creation (the static background would be great when you moved the galaxy the static image moved with it) are all just on point. Overall what a great job you have done. Every action was quick and smooth, typically people complain Swing being slow/locks up but really its the programmers fault if that happens. With the graphics the artists has done it looks super professional. Props to you man.
Before runs before the suite, BeforeEach runs before each test (if memory serves). The big feature was dynamic tests, we managed to refactor most of our tests to a single data file and a factory which generates all the tests. 
[Release notes](http://junit.org/junit5/docs/current/user-guide/#release-notes) [Migration guide](http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4) 
Thanks for the response. 1. As many have corrected me, yes I did make that mistake. Good to know. I also saw the words J2EE on the job postings, so either it's legacy code or a company I should avoid? 2. Having spent around 8 hours with Servelets and JSPs I get them. I feel like their almost PHP like as far as the workflow. I also read up on some Spring examples, using Annotations to implement RESTful webservices and MVC sites. This feels the closest to home and Ruby on Rails. At least the flow, just different syntax and files. Seems like Both Rails and Spring requires the programmer to know tings, like which Annotations to use in spring or correct naming convections that affect behavior of controllers/models in Rails. Regardless, I'll keep you in mind for any private questions i have. I'm pretty excited to get some sample sites up. Are there any free small crummy web hosts for a J2EE project I can deploy too for free or low cost? I would love to make some web services for some of my Android Games to query as a test project. 
Not that I know of but the way I learn stuff like that is with the official documentation, trial and error and googling and finding answers on Stackoverflow. Try to make something incremental such as Hello World with only basic libraries, add a REST interface , then a database etc.
This was recommended to me by a friend. Told me to pay for a month get the course done and cancel (cost would be $30) https://www.pluralsight.com/browse/software-development/java Looks a bit light topic wise to me though.
Yeah, saw that. Was looking for something a bit more high level than the entire user guide. Thanks though.
I will try to answer them all! &gt; For your JComponents did you extend a lot of the classes in order to give your components their own feel or go the route of creating factory methods to produce them? Actually, the route I am trying to take is to use almost no JComponents at all. I draw everything with a Graphics2D object in the paintComponent() method whenever possible. I did extend JPanel and JTextField. The latter has too much useful behavior to try and recreate. Buttons and everything else are all hand-rolled. There are some exceptions, but mostly in the panels that I have not yet converted over. There are still some places that I use layouts to manage child panels but I am increase trying to avoid doing that. &gt; How did you go about layering your components on top of each other? Did you use JDialog components to have things overlap each other or did you use the GlassPane? I use the GlassPane for drawing modal dialogs. There is also a spot at the very beginning (the race introduction screen after you start a game) where I use a glassPane because I want to smoothly fade from that screen to the Main screen. When my graphic designer came up with that idea I immediately thought it was great, but had no idea how I could do that. But the glass pane worked great. &gt; Noticed your game isn't resizeable? Why did you end up going this route? This is mostly a game design decision. There is a tremendous amount of artwork in the game, including background art, and it can't be stretched without looking bad. Therefore, I use a fixed aspect ratio. Some players have complained and asked for fullscreen with sidebars, so I am still considering that but it will take a lot of rework so it's a low priority. &gt; How did you go about creating animations in Swing? Did you do it with Timers and overriding the paintComponent method or place components in a container that has animation capabilities? Timers and paintComponent. &gt; With the animation question, say you give a component animations how did you go about it not causing issues with your layout manager so to speak? There are no layout managers, so it's not a concern. I try to imagine the game as a series of full-window graphic panels that I draw on and I flip between via a CardLayout. &gt; What layout manager is your favorite? BorderLayout.. so easy to use. &gt; I'm curious why you went the free route. What you have done I can definitely see that this game could have a price on it. I tried it out and I can tell its going to be great. First of all, I am an experienced professional Java developer and don't need the money. Secondly, I'm of the opinion that money corrupts people so I do not want to corrupt what is essentially the most fun hobby in the world (my wife's words) with a profit incentive. Once you start monetizing your hobby, it ceases to be a hobby. You start making decisions based not on what you like but what you think will sell best. &gt; My biggest tip for you is some sort of help/tutorial section for people who don't know how to play the game but I'm 200% sure you already know this. Eventually we will make a game manual for the game that will be available in-game via PDF and printed in the boxed set. &gt; I'm also developing a game in Swing and some of the things you have done amazes me. Spinning world, the Tech menu, music, the galaxy creation (the static background would be great when you moved the galaxy the static image moved with it) are all just on point. I'm glad you like it! I did write the code for the spinning world (making a 2D map look 3D) and I will pass on your compliments for the tech screen to the graphic designer. &gt; Overall what a great job you have done. Every action was quick and smooth, typically people complain Swing being slow/locks up but really its the programmers fault if that happens. With the graphics the artists has done it looks super professional. Props to you man. Awesome, thanks! 
Under Junit4, @BeforeClass runs before the whole test suite and @Before runs before each test (just like @AfterClass and @After, and @ClassRule and @Rule). import org.junit.*; public class SimpleTest { @BeforeClass public static void beforeClass() { System.out.println("beforeClass"); } @Before public void before() { System.out.println("before"); } @After public void after() { System.out.println("after"); } @AfterClass public static void afterClass() { System.out.println("afterClass"); } @Test public void test1() { System.out.println("test1"); } @Test public void test2() { System.out.println("test2"); } @Test public void test3() { System.out.println("test3"); } } produces this output: beforeClass before test1 after before test2 after before test3 after afterClass 
Has anyone been using RC and could share their experiences?
So in junit 5 you could declare a @BeforeEach once and it would act like you did @Before each test? I could see that being handy...
&gt; I don't want to spend 6 months learning the framework inside out and finding out it's becoming obsolete. Are you sure software development is the right field for you? https://www.youtube.com/watch?v=zut2NLMVL_k
Lol shit, too true. In my defense, after trying the various backend frameworks in node, I used express on a variety of projects for over a year, and I know I can still go and use it for a backend framework. So it's not entirely unheard of. I don't have problems with updates, I love learning, my concern was more towards an entire ecosystem going out of use. I think I have realized though that I need to get good at core skills, rather than frameworks and languages.
This looks for very beginners, but since you have experience in the industry and also programming in general, I think Safari would be a better choice, as you can freely jump from tutorial based book to a more in-depth book as and when you need it and want it. It helped me when I was reading about something and wanted to know more about dependency injection, easier to switch that in Safari without much overhead. I may be a bit biased because I keep seeing these "quick and easy" tutorials on the Web... Especially with spring and JavaScript world... They skip a LOT! if it was that quick and easy I would not need a tutorial. Safari kept me from going insane, plus I really like the new additions and features in the last 2 years, so yes, I am a Safari fan boy! 😀
In this case with less features, more secure. 
Thank you!
All you need is Spring Boot for back end, ReactJS for UI, AWS/Kubernetes for runtime.
1. I would avoid them if I had better options, but often it is a miss from the recruiters or HR reusing the job requirements, so would at least interview with them before deciding. 2. Good to see that you are relating to other languages, you are correct, almost all languages have similar flow, where they differ is in philosophy of who is responsible for what. I think Amazon provides you instances where you can install your own app server and have fun. I think it is free for upto 8 hours of use per day (do check though, I have always had internal infrastructure to use, so not much experience there) 
You should read the wiki pages for HikariCP on why it is more correct than a lot of the older connections pools like C3PO. Specifically in [database down scenarios](https://github.com/brettwooldridge/HikariCP/wiki/Bad-Behavior:-Handling-Database-Down). Some minor comments on your implementation. * The poolService static field should be volatile. * You probably want to use double checked locking or something like an enum singleton to make sure poolService doesn't get instantiated twice. * In get connection you just print the stack traces but don't throw so its possible to return null connections whenever there is database connectivity issue.
I'm super excited for nested tests. https://blog.codefx.org/libraries/junit-5-basics/#Nesting-Tests Though I prefer Java, for the last year I've been working at a Ruby on Rails shop. But there have been some (few) things that the Ruby ecosystem has gotten right, and one of those is nested tests in Rspec. Now I can better group my tests up, for example, to test the behavior of a service class for different users or different contexts. And more importantly, I can set up that context with a @BeforeEach method that applies only to the tests in that group.
HikariCP goes out of its way to never return any non standard classes. Most other connection pools have custom exceptions or certain classes that may bleed out of the implementation where HikariCP does not. EDIT: Here is a good example https://github.com/brettwooldridge/HikariCP/issues/951#issuecomment-322075586
If memory serves me correctly Baeldung is a website with many awesome spring and Hibernate material.
What is Safari? Because all i'm thinking about is Apple's Web Browser.
Mea culpa! Here is the link https://www.safaribooksonline.com/
 J2ee and jee are mostly interchangeable. You'll hear both from people who know it's changed but use j2ee anyway
You appear to be correct, according to the notes. Before/After become BeforeEach/AfterEach and BeforeClass/AfterClass become BeforeAll/AfterAll.
Of the over 13K jobs on Dice right now, only 3.4K mention Spring at all. There's a lot of Java going on outside what's discussed in /r/java.
It looks like the text test is the only one where it's at the top. Data updates, multiple and single queries, etc. all place even plain servlets higher than vertx.
Eh, as I said dynamic tests was the real big deal.
Good, sounds like they have a clue.
It's funny how when people (JetBrains employees maybe?) don't like someone's tool choice (Eclipse) then they say it's a poisonous.
&gt;"As a result, I now often have to pretend I’m writing in C" &gt; &gt;I do that a lot in java when I want/need performance. Sucks, doesn't it? I wish Java had something equivalent to typedefs so we could use all the facilities that Java provides without sacrificing speed.
I really love they finally added labelling tests
Yeah, would love to have something like a typedef
On my phone but I'll try. There's setup that isn't intuitive and it seems like a lot of breaks for no good reason at first. However it has a lot of configurability that didn't exist and parameterized tests are pretty awesome. As an example you can look at this file and see halfway through I changed to csv parameterized tests. https://github.com/secondsun/sms4j/blob/master/src/test/java/net/saga/console/emulator/sms/sms4j/test/E03_Z80DecrementTest.java As you can see I switched from each test being for a specific register and then went to passing in the codes as a csv set.
I really don't see what it changes, apart from the fact that the names changed. But there are no new behaviours...
In 4, @BeforeClass runs once. @Before requires you to annotate a specific test. It sounds like @BeforeEach would allow you to do a single annotation that would run again and again, as if you had duplicated that annotation for each of your tests.
hahahahahahaha.... nice one. right now, I am just learning, and I constantly need to share files with other peers. I do appreciate the feedback telling me to use github but I am too busy to learn and my peers are way too busy to learn it.
I am not even gonna pretend to know what you mean to say :D
will surely do. but tbh, right now, i am very busy and don't have the time to learn something new as I am already learning programming and undertaking studies
They should hand it over to the Pivotal so that, there is no duplication between Spring innovations and then lagging, bureaucratic reception in the JavaEE.
Sure, but it probably won't carry much weight.
I see Collection c = new Collection stream.foreach((i)-&gt;c.add(i)) More than I would like. 
&gt; They are slower, Not usually. Most benchmarks I've seen put them in the same neighborhood as regular for loops. &gt; produce more garbage, The nature of streams makes that garbage short lived and very likely to be captured by escape analysis. That said, the amount of garbage overhead is really minimal. There isn't a lot of state captured by streams. &gt; and less clear. &gt; &gt;Look at the max example. It is absolutely less clear than a simple foreach loop. A matter of opinion, but I disagree. I find streams much more readable, the problem is often that they are unfamiliar. Ultimately a steam/filter/map/collect is more terse than a comparable for each loop.
That's exactly what @Before does in Junit4. You annotate a method with @Before, and it's called before **each** test. public class MainTest { @Before public void setUp() { System.out.println("Test executed"); } @Test public void testOne() {} @Test public void testTwo() {} @Test public void testThree() {} } Output: Test executed Test executed Test executed This is just a name change, not behavior.
Does `@BeforeAll` still require a static method?
My experience is that it's not worth it to get to a point of "mastery" in any of these frameworks. You aim for "competent and can learn more as needed", then move onto the next one. You never know what you'll end up with at a job, and in the next few years they'll move to something else. I haven't seen Spring in new projects for a while, except for the excellent Spring Mvc. It's just another yearly fad, the excitment wore off and they moved onto the next fad.
/waves to the fellow JGO'er. ;)
Ah I stand corrected. Thanks for the clarification.
[removed]
&gt; this sub is dying Then why are you still here?
There is a difference between not using it and not even having a clue what it does. For someone who's been in the field for 10 years that's pretty bad. 
&gt; As such, the commission a team of 2 people to remake the tool in C++ and QT. Well that was started last January. 8 months later and they aren't even close to being done. I'd wager at this rate they have another 2 or 4 more months. The silly thing, is my program in java was 3 files with maybe 400 lines of code. You are at a company with very junior people. Unfortunately it's juniors who fell into the [expert beginner](https://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/) trap and feel they already know everything. It's common for people like this to shit on other programming languages. Actual experienced devs know they are just tools and pick the right tool for the job. Regarding your questions; I for now would recommend to not focus too much on the framework (both Java EE and Spring are fine, and learning one means you're also learning pretty much 80% of the other anyway) and focus on your core Java skills first and foremost. You already have experience so you will probably blow trough something like [this mooc](http://mooc.fi/courses/2013/programming-part-1/) really fast. Other than that books like [effective Java](https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683) and [clean code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) are great books to have read for a professional Java dev. When it comes to starting with either Java EE or Spring; pick the one you prefer. I'm personally quite fond of Spring Boot because it is quicker to get started with and still has all batteries included, but if you prefer Java EE it's fine too. P.s. like others said; it's not been called J2EE for a long time. Some vacancies do write it this way but that's generally a sign the company hasn't gone with the times. 
I've been using it. Rewrote some rules into extensions. Extensions give more control than rules/runners. Also need less boilerplate code to add them all to a bunch of tests.
Not Java.
It will only take you an hour or so :)
According to the sidebar there's already a platform to share tutorials: &gt;Do not post tutorials here! These should go in /r/learnjava.
Migrated one of our smaller projects this morning. Finding and using the extension for Mockito was the "hardest" part. The rest was pretty straight forward.
&gt; startup bullshit yyy.. what's that mean? Cause for me it's look like startup = fresh, modern; jee = maintaining a bit old financial app written in jdk 1.5.
You are experienced with java, why do you think its not a thing yet? Btw love your work!
First thing you should learn: https://javaee.github.io/javaee-spec/JEE
Yes, they are interchangeable in that they're both not applicable ([outdated vs. never happened](https://javaee.github.io/javaee-spec/JEE))
One of the authors here (Sander). If you have any questions let me know!
For anyone interested in how these ideas may be brought to Java, take a look through the documents here: http://cr.openjdk.java.net/~briangoetz/amber/ Brian Goetz has expressed the hope that they will be able to bring some of these features to Java quite soon, in comments which imo iirc make more sense now their new release cycle policies have been made public. Related features and enhancements are likely to be added to the language progressively rather than in one huge step.
ok, will try it then
Glad you took that as ribbing :-) You don't need Spring unless the employer uses it. If you want something hot, easy, new, and compatible with that grandpa tech, you may want to consider Armeria from Line. 
What if I told you that I'm doing something brand new in JavaEE right now? It's actually pretty great. I am not being ironic or sarcastic. What's more, I'm not filtering through startup blogs of people reinventing the wheel badly, because I don't need to. I don't have to care about what's popular at the moment. If you want to see finance apps that suck, you should see the mess I'm replacing. 
I have around 4 years experience in Java doing the following projects (some for my job, most on my own). * Custom Buildserver. (Sockets. Master/Slave model which actually transfers work to a new node if a node goes down, like if a machine powers off. * Application tool. Made using Swing, Interfaces with HTTP REST calls on various web servers, displays data, downloads data, simple. * Personal Game Engine. I'm Using a Bit of LibGDX to handle the glue to OpenGL, so I can use LWJGL for Desktop applications, and OpenGL ES 3.0 for my Android applications. Things include Component Entity System, Models, Skinning, Animation, Collada Importer, Particle Engine, Quad Tree Terrain, Collision detection, and a shader suite of classes all made from me. So I would say I'm generally comfortable working in Java the language. I've just done very little Web Programming in Java, but a lot in Php + Kohana (MVC), and Ruby on Rails (MVC). I understand those concepts as well. And like you said, The people on my team are a bit junior on some things, and an unfair hatred for Java. But My boss is actually a very smart person, with a lot of low level technical skill when it comes to games, Graphics programming, Driver bugs, etc. He just really really really hates java. I think it stems more from a game programmer's "everything that isn't c++ is slow". I showed him my games I worked on, and he asked why I didn't write them in C++ and use the NDK for my android ports. I have written games in C++, but I said the Java games were fast enough. Hell, one of my games in an RPG running things like post process effects, complex water graphics, etc. Even though everyone on the team loves the 1 java tool I wrote in 2 days. While all my backend Rails work gets no praise because it's not "cool". haha. Anyways, this is to better explain myself.
&gt; But My boss is actually a very smart person, with a lot of low level technical skill when it comes to games and OS calls, etc. He just really really really hates java. Even though everyone on the team loves the 1 java tool I wrote in 2 days. While all my backend Rails work gets no praise because it's not "cool". Sounds like pretty horrible people to work with. Sorry. 
I think that's what he was saying. It's convenient to take someone literally instead of figuratively. If he knows about and how to use Spark Java, he knows about Spring even if he hasn't used it.
&gt; It's convenient to take someone literally instead of figuratively. This is not some kind of contest to see who has the biggest developer dick. If we both interpret that message differently then that's fine. 
It's not terribly bad. I went back to edit my comment a bit more. It's not a hostile work environment. I have learned a lot from the man and have grown as a programmer for that. We do discuss Java. I explained all my reasons for making the tool, and I contently bring up how long the 2nd tool is taking and how I can probably get the new features in a week if he gave me time to do it. I would just do it, but it would be wasting the other programmers time who are working on this beast of a second application. With talks, he generally tells me Java is old, outdated, and going away. Perhaps he's right in his view. He's done nothing but Graphics and game programming for PC/Consoles. Not a lot of Java in there. But as I looked last weekend for jobs in the state I want to relocate the list of jobs I found that I wanted to apply for (or could apply for were as follows) * 6 - Ruby on Rails * 12 - Python * 150 - Java * 112 - .Net (I know very little on this Though i'm strong in C#). And yea, i'm looking to quit.
&gt; Perhaps he's right in his view. No. And sorry but he's an idiot. He can be both you know; pretty darn smart but an idiot in other areas. He has some kind of personal grudge against some language he probably hasn't used for ages. Unfortunately these types of idiots do push a lot of beginners in the wrong direction. Don't get me wrong; I have no issues when people have strong opinions on languages. But if that means you're telling people stuff that's just plain wrong that's where I get pretty annoyed with people. No matter how old or 'experienced' you are, if you're telling newbies that "java is going away" you're a moron and nothing you say has merit anymore. 
Sorry, my bad. I will not post tutorials to this Reddit. Thanks.
I have been thinking about that since aI saw how powerful were enums in Java 8. What stopped me is that enums don't have inheritance. Could this be a problem in some cases?
Shouldn't this be in r/Kotlin subreddit?
The link you posted takes things a step further, with Destructuring patterns. My one true love.
This is really nice. Thanks! What licence is this under?
AngularJS is Java**Script** and not **Java** and thus completely off topic here. You keep spamming your site. This is strictly against the [**reddit rules for self promotion and spamming**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer). This is the last warning. Should you continue like that, you will be banned without further ado.
no, it isn't
Yes.
That's what they said about Scala once...
Is it just me, or is this contradictory? First, why do you need an strategy interface at all? Enums are classes, and all enum members inherit the methods defined in the enum. Second, the main purpose of the strategy pattern is OCP: you can create a generic algorithm whose behavior can vary *without changing its source code*, based upon varying implementations of the strategy interface. Adding cases to an enum means you have to change the source code of the enum, and possibly all code using the enum to account for the new cases. This defeats the purpose of using the strategy pattern in the first place. Finally, if you can implement strategies outside of the enum, aren't you defeating the purpose of the enum, because you no longer have a complete accounting of cases?
&gt; What layout manager is your favorite? &gt; BorderLayout.. so easy to use. If you had said GridBagLayout I was going to rage quit reading your response :-) The Oracle Swing tutorials say to use GridBagLayout and I cringe every time I read that. It is seriously bad advice. BorderLayout+BoxLayout will handle 99% of any layout needs.
BSD
I have never used GridBagLayout.. ever. 
&gt;static EnumMap&lt;Strategy, Strategy&gt; lookupStrategy= new EnumMap&lt;&gt;(Strategy.class); { lookupStrategy.put(Strategy.STRATEGY_A, Strategy.STRATEGY_A);... Wat? 
Hey dartalley, I have incorporated your suggestions into the code. Thanks for the advice! :)
&gt; all enum members inherit the methods defined in the enum. But you can override them. See this example: public class Swimmer { enum AnimalClasses { MAMMAL, FISH { public boolean hasFins() { return true; }}, BIRD, REPTILE, AMPHIBIAN, INVERTEBRATE; public abstract boolean hasFins(); } public static void main(String[] args) { System.out.println(AnimalClasses.FISH); System.out.println(AnimalClasses.FISH.ordinal()); System.out.println(AnimalClasses.FISH.hasFins()); System.out.println(AnimalClasses.BIRD.hasFins()); } } 
Why for the God's sake did they swap type-name in declarations? It makes me sick every time I look into kotlin code &gt;val name: String
Things like local variable type inference and data classes are being considered for Java. Value types are also being added, which I don't believe Kotlin has at the moment. Also, what's so bad about checked exceptions?
&gt; That is not correct. Huh? First, your example doesn't compile. You've defined `hasFins` as abstract, such that each member of the `enum` *must* implement `hasFins` (but only `FISH` does). Second, you've demonstrated what I was talking about. The `AnimalClasses` enum has the method `hasFins`, which means that every member of the `AnimalClasses` enum will inherit the implementation of `hasFins` (in your example, it's only interface inheritance). Normally, `enum` instances are instances of the `enum` class (i.e., `AnimalClasses`). However, if you have varying implementations of `enum` methods (as in your `abstract` method), each `enum` case becomes an enumerated subclass of `AnimalClasses`, and you get ordinary inheritance from `AnimalClasses`.
Got a link for that to save me the time?
I would consider using ``enums`` within some kind of *factory* that chooses the strategy based upon a concrete enum value. Otherwise I agree that this concept looks kinda old fashioned spaghetti code! 
&gt; Could this be a problem in some cases? Enums already have inheritance, with the top-level `enum` as the base class of a 1-level inheritance hierarchy. Needing inheritance beyond that I think borders on enum abuse. Enums are meant to create enumerated instances/subclasses of a single enum base class, they are not meant to replicate a generic n-level class hierarchy. But... you can always use composition instead of inheritance. That's probably useful as generic advice too, but that's another story.
A link to what?
You said finding the extension to mockito was the hard bit. I was hoping you could link to it. 
Oh sorry, my bad. :) https://github.com/junit-team/junit5-samples/blob/master/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java
Java is the new Java. Kotlin might be a flash in the pan, or it might not be (it's only at version 1.0). Or, it might stay as niche as Scala has. Many languages that have been called "Java-killers" have done nothing of the sort. Java is the de-facto language of the JVM. It has survived for decades, and continues to improve, while at the same time maintaining extreme backwards compatibility. The standard JIT is optimized for Java idioms. Thus, Java has too much inertia, stability and legacy code to be unseated so easily, especially by an upstart like Kotlin.
There's also no option for inheritance with enums at all. At least with the interface implementation someone who's using your API can provide a brand new class that implements it. With enums they have to have access to the source code and the ability to change it.
&gt; There's also no option for inheritance with enums at all. There's no option for inheritance *outside* of the enum. That is the entire point of maintaining an *enumerated* set of subclasses/instances. &gt; With enums they have to have access to the source code and the &gt; ability to change it. Exactly, which is why the posted article makes no sense. Enums completely defeat the purpose of the strategy pattern, and the strategy pattern completely defeats the purpose of enums. 
Yeah, but your entire article is white noise too. Kotlin is only at v1.0, and yet the Internet is full of white noise of grandiose claims of Kotlin being the next Java.
If you want to make yourself look old: by all means use J2EE.
You might be interested in this book, dated but still quite relevant. Has a nice animation framework that it walks you through: https://www.amazon.com/Killer-Game-Programming-Andrew-Davison/dp/0596007302 There are free draft chapters online: http://fivedots.coe.psu.ac.th/%7Ead/jg/ 
Coffin, meet nail. Java 9 is now dead for enterprise. See you all nice features in Sept 2018...
&gt; while I ship production software for thousands of users written in &gt; Kotlin. So what? Tons of production software is written in Scala and Clojure, which have been around a lot longer than Kotlin. Yet the amount of production code written in Java and *continuing* to be written in Java dwarfs all of its contenders. &gt; I'll repeat again in case you did not comprehend it the first time: You're completely missing the point. There is nothing to refute. So Kotlin has features that Java doesn't. Big deal. Many languages do. That has nothing to do with whether or not Kotlin has any chance of displacing Java to any significant degree. &gt; Google already announced that it is officially supported on &gt; Android next to Java. So what? Even if *all* future Android code changes to Kotlin (which targets Dalvik/ART), it is still a drop in the bucket compared to all other Java code which target various JVMs. Furthermore, what Google does with Android is irrelevant to Java, since Android *never was Java in the first place*. 
Right, first - you mixed things up. I was the OP, /u/_dban_ just also shares similar opinion. Secondly - what I take offense with is the claim that kotlin is somehow the next java. No, it isn't. It's kotlin. Whatever hype train you are trying to ride and stir up to justify your investment in learning new immature tech (some like that stuff), it does not qualify or warrant you to make grandiose claims like these. I am not going to pick apart your cherry picked examples and I'm very happy that you consider kotlin fit for your requirements, but it's just another language. Another tool. Right now it seems to be headed to become hipster toy for android crowd. Good for them. If anything you are the one who should take chill pill and tone down hype train. It's not helpful and not productive. As for where java fits in - it's an extremely mature tech stack with well understood libraries and dependencies, I know what to expect of it in next 18-24 months with 100% certainty and I can plan my long term projects to rely on tools and libs that I _know_ will be there and supported. Kotlin? Who the f* knows where it'll be in 18 months. Don't touch hipster hype for serious work you will need to support in 5 years time. Let's not make JVM ecosystem the same crap node.js shit is.
What does it mean for Java's future? Java 8 will be the final version?
&gt; So much anger. Haha, anger? Nope, more like amusement. I like Kotlin, but the behavior of its fanboys amuses me. &gt; So what? All you did so far is wasted my time. If you really want to take that route, you've wasted everyone else's time by repeating the same message that gets spammed on /r/programming and /r/java by Kotlin fanboys all the damn time. &gt; it is clearly visible that Java is on its way out So what? You're still missing the point. Java may be on the way out, but there is no evidence that Kotlin is the one to take out the king. &gt; it makes no sense Any more than saying that Kotlin is the next Java. &gt; You can keep using Java and ignore better options Bold claim there, cotton. I'm telling you that Kotlin is only at v1.0 and there is no evidence that it will be the next Java, and you assume that means I only embrace Java and ignore everything else? Maybe you should take a chill pill.
I'm not trying to justify anything. It is a justification in itself you just don't give a crap about anything which is not Java. I do pity you for living under a rock. You should learn to be able to tell the difference between a hype (like what Scala was) and a legitimate contender. I bet you still use Ant while Maven and Gradle take over the market. You are not going to pick apart my examples because you can't. Accept the sad truth. It has also nothing to do with hipsters. As I have said in my other comment a lot of companies / projects outside the Android world already adopted Kotlin (Gradle and Spring just to name a few). You need to realize that it is not me being on a hype train it is you living under a rock. I am already 25% more productive on my projects compared to Java (I was writing Java for 10 years). I did not jump the hype train when Clojure came out (nor when Scala or Ceylon) so I can make an educated guess that Kotlin is the next big thing. &gt; to rely on tools and libs that I know will be there and supported. Which you can use in Kotlin since 100% Java interop is the norm with Kotlin. &gt; Kotlin? Who the f* knows where it'll be in 18 months. Don't touch hipster hype for serious work you will need to support in 5 years time. Let's not make JVM ecosystem the same crap node.js shit is. So who needs to take the chill pill? Seems like that the only words you know is `hipster` and `hype`. You need to shape up. I am doing **serious work** right now in Kotlin. node.js is also not a good comparison since it uses Javascript, not multiple languages. With Javascript you don't even have an STDlib... 
This is just speculative, but it's probably related to their plans to release a new JDK biannually. Ubuntu has a less aggressive release schedule and still has too many releases to designate them all LTS. This probably just means we'll be getting one LTS JDK per year, or maybe every other year. 
Fine, let's agree to disagree. You live in some reality where wishful thinking is somehow a fact, I have been burned by NextBigThing enough times to have a very heavy dose of salt before diving in. Good to know you are doing serious work. Hope it works out for you. Maybe you should volunteer to do some speaking at conferences or whatsnot is is that you 31 year olds with 10 years of experience do. (p.s. I get it. Somebody doesn't like your super snowflake. You are taking it personally. I can relate. Put down the booze!)
Isn't this a finite state automata?
&gt; But... you can always use composition instead of inheritance. That's probably useful as generic advice too, but that's another story. The *Favour composition over inheritance* principle is almost in all software engineering books
The title isn't exactly true.
All I said is that is that Kotlin is at v1.0 and there is no evidence that it will be the next Java, and that makes me a "typical hardcore Java dev" who "lives under a rock". You even trotted out the old "blub paradox" trope. &gt; I'm also not a fanboy Yeah, sure you aren't. You seem eager to insult everyone who points out that your claims might just be a *wee bit exaggerated* for a language that hasn't been out that long. &gt; I can clearly see that your cognitive capacity is a bit lacking And you finish off with the "you're too dumb to understand" retort. OMG, I think you've hit all of the fanboy stereotypes.
Google probably can. Or having a bit more patience than waiting 10 minutes before spamming your question here, where help topics aren't permitted as per the sub's guidelines. Anyway, look at the line the error's being reported for, then think about how you could see if the values being used on that line match up to your expectation - a clue would be that they're not, given that you're getting an error. Then figure out how to correct the value coming in, and work from there.
\* sigh *
spot on. It violates the rule of "open for extension but closed for modification". Normally this would also result in a huge code in the single enum class if there are a lot strategies. Inheritance based hierarchies won't be possible (although it can be argued not to use them in the first place). Only applicable use of the above would be an instance when you need a limited amount of strategies (i.e. a low number) but limited to those. i.e. we don't want any other strategy to exist in the system. (and hence the inherent enum nature). Before I try to give an example, I would say for such a case to work, there would be no Strategy interface as in the code, and instead of client classes accepting a Strategy ref , they would accept the enum ref. After making the above change, it isn't a Strategy pattern in the first place. It is just the enum object (with behvior) kind of pattern that Java provides us. :)
Undoubtedly. Red Hat's entire Middleware stack is Java-based, and there are plenty of Enterprise customers out there who still want a supported Java / JEE platform to work with. Interesting times. 
&gt; you have hit all the burnt out 60 year old seen-it-all programmer &gt; stereotypes lol. Please point out where I have done anything of the sort. &gt; I'll gladly be a fanboy instead of being a jerk git. Says the person being the jerk git. I mean: &gt; burnt out 60 year old seen-it-all programmer stereotypes and &gt; you are the typical hardcore Java dev who lives under a rock and who is the typical casualty of the blub paradox. and &gt; I can clearly see that your cognitive capacity is a bit lacking For pointing out that a v1.0 language is in no position to make the claim that it is the next Java. You're not looking to good there, sport.
But this is white noise too. You can ship production software for thousands of users in brainfuck. Or, to be slightly less hyperbolic, people can and do ship production software for many millions of users with PHP, and yet I doubt you'd be writing an article titled 'PHP is the new java' any time soon. In other words: Ability to make a working product that is popular in language X is no proof language X is worth learning, better than some other language, or anything else about the 'value' of X. I can see how the comments in this particular thread feel a bit insulting to you, perhaps, but your extremely defensive reaction is kind of clichéd for fanboys. And if there's anything I really _DO NOT_ want to read, it's a defense of language X, by noted fanboy of language X. If your aim is to convert some souls, this isn't a great way to go about it.
I think the idea is to ask you: What makes kotlin so different from scala? I think there are a million ways to answer that one, so I'll give you a more interesting question: What makes kotlin different from Fan(tom)? 
&gt; Except that you write comments without meaning, purpose and content, while I ship production software for thousands of users written in Kotlin. If you want to win souls for Kotlin being this insufferable does a lot of damage. 
two wrongs don't make a right. Nevertheless, it's not really your job to defend kotlin's choices, unless you're part of the kotlin language design team, in which case: yeah, what the heck? If I take the past 30 years, pretty much at any given time the top 80%+ of programming was done in C-style languages. Whether it was C, C++, javascript, or java. I don't really see the upside of `String name;` style naming.. but I don't see the point in `val name: String` either (if it's to make types optional, well, `val name;` – there you go, now it's optional in C/java style too, and it's just as short) – I do very much see the point in not changing a winning formula. The only argument I can see in favour of `val name: Type` style is that it makes parsing the language easier. You don't need a type library to ascertain intent anymore. That's nice but kotlin doesn't do much with this power, and the rest of the language isn't consistently designed to be parsable without the context of other files/jars... so, seems kinda pointless. 
You can have value classes in java by waiting a bit. Or by using lombok `@Value`. That feels like a lot less effort than adopting a new language. 
If the upgrade path isn't problematic there shouldn't be much of a problem though right? Also it doesn't say there won't be LTS, just not for all versions. 
This title is just another click-baity attempt to spread FUD. Just relax.
*Java EE, not JEE https://javaee.github.io/javaee-spec/JEE &gt; One of the big reasons we changed the names of the platforms is because we wanted to emphasize that they’re all “Java”. The old names of “J2EE, “J2SE”, and “J2ME” don’t do that. Java is what’s important to us. Java is why we’re here. Java is the value we share. We need to make that clear to the world by talking about “Java EE”. &gt; Please, use only the correct name “Java EE”.
This. That has to be the most spaghetti piece of Java I've seen in a while. I also don't see any upside on using enums. Deviating from the pattern makes it harder to understand.
Except, in an enterprise environment, I can't deploy services where I have to come back in &lt; 1 year when there's an LTS Java that's going to be supported for a while. Because that means QA, Security, Operations etc will want to verify the entire app as I've changed a major version of the language. I think Oracle's idea of a revision every 6 months is misguided for this reason, and having Java 1.9, a language that's been constantly pushed back, *not supported*... disaster for the enterprise, the bread and butter of Java usage.
They may not be correct, but they're still used by knowledgeable people. Just because the people running the platform don't want a term used, doesn't mean it's not going to be used. Mostly though, devs just refer to Java as Java, irregardless of what particular thing we're talking about. EE, Spring, Jersey, Dropwizard are all just frameworks on top of the language.
java rarely breaks compatibility afaik. Although 9 is a very big change. It makes sense to not make 9 LTS while frameworks are adapting.
I think having the type after the variable name works well for languages that support inferred or dynamic typing: val name = "David"; val name: String = "David"; vs val name = "David"; val String name = "David"; or even val name = "David"; String name = "David"; It makes variable declarations look more consistent.
"Every three years, the feature release will be a long-term support release, with the next long-term support release" https://www.infoworld.com/article/3222867/java/the-road-to-java-9-twice-yearly-releases-are-coming.html "The first new long-term support release for Java will ship in September 2018, a year after Java 9 ships under the old release schedule. Updates will be available for at least three years, and possibly longer, Oracle says." Requesting the mods fix the click bait title. 
Will you be able to get O'Reilly to let us buy your DRM-free eBook in PDF and mobile (e.g., ePub) format from a single purchase? If you can't get O'Reilly to do this, why did you choose O'Reilly for your publisher as opposed to any of the other publishers who still respect their customers?
This subreddit is **English only**. 
OP's comments in this thread confirm something that's become increasingly apparent - the people who affect to like Kotlin are collectively one of the most off-putting things about it... 
You have posted your question in **/r/javahelp** which is the correct place for programming questions. You need to have patience since people are not constantly refreshing the subreddit. **/r/java** is not the place to ask for help with Java programming problems, so please refrain from posting here. Also, never post a link in the title of a reddit post. The link is not clickable, nor can it be easily copied and thus it is useless.
&gt; Requesting the mods fix the click bait title. Even though we would like to, we are unable to do this. Editing titles is not possible in reddit at all. Not for OPs, not for mods (and most likely also not for reddit admins unless they go directly into the backend database).
Still no support for Property-Based Testing |-(
I too was saddened by their choice to stop selling books directly. This happened without advance notice a couple of months ago. Obviously we were far into writing the book already. On a positive note, as you'll see on [javamodularity.com](https://javamodularity.com/#plans), ebooks.com sells the original DRM-free PDF and ePub versions of the book. I believe you get both versions in a single purchase there. Google Play store is another DRM free option, but their PDF is generated from ePub and doesn't look as nice as the original typeset O'Reilly PDF you can get from ebooks.com (although I've heard O'Reilly is working on this).
Completely useless. lookupStrategy.get(Strategy.valueOf("STRATEGY_A")).execute(); can be replaced by a simple Strategy.valueOf("STRATEGY_A").execute();
Openjdk is built primarily with developers from red hat, ibm and oracle. Red hat and ibm would be happy to support you.
Thanks for that. I definitely will have to check it out. Its probably my biggest flaw right now not knowing exactly how to go about doing animations regarding my game. 
Thank you for clarifying.
Requesting that the mods purchase the company, reddit, take control of the dev team, implement a title-change feature, change clickbait title of this post, the sell the company back.
Pretty cool!
Android is based on Java, your game industry experience may even be helpful for some places. But you are right that there isn't as many positions outside of major hubs
Wholly shit you're being an asshole in this thread.
You can add a tag to it marking it as `misleading` or something, if you want.
Exactly right
Those two guys are lonely though.
Check out the tutorials point website for Java, take it step by step and try to incorporate all the tutorials into one program. Anything specific you're struggling with? 
Okay, can you just edit the row in the database then? Please. 
Java as a language is fairly simple especially if you know other language like the C's. I'd recommend you go for a software engineering position as it's more broad aka more opportunities to both learn grow and move up the ranks.
&gt;If you want to see finance apps that suck, you should see the mess I'm replacing. As has been said by every developer replacing a legacy product ever. 
Put it this way, there are significantly more jobs in spring than any of the newer languages and frameworks. This means that those applications will require maintenance for many years. If something new comes along, you will simply learn the new product whilst enjoying gainful employment and move on, or take a different path that doesn't involve direct implementation. The alternative is to constantly learn new kid on the block frameworks, looking for work in the limited companies that use them. My advice is to start on something solid and mature.
It does not even compile: ```public enum Strategy implements Strategy```
Yes. Yes it has. Believe me, every legacy finance product is a *monster*. We're talking proprietary languages without documentation, spaghetti code that gnarls itself for days, gratuitous use of goto, cryptic variable names, and all of it done in the name of preserving bits--because bits were expensive back then, and nobody thought anything would ever change. In comparison, the old J2EE codebases with their two interfaces to create EJBs, a stubborn insistence that coding by configuration was the future, and such baroque database access tools that it's no wonder Java people came to hate SQL--that's *nothing*. Even the God method that I marked for refactoring today, written by a very junior dev at the beginning of his career, was nothing compared to legacy code. Nobody gets into the legacy situation by incompetence.
Effective Java Book
https://www.youtube.com/playlist?list=PL484D73FA74A11AC9 It's a bit old but it's free and it should still have some decent information. edit: downvotes? why? i'm just trying to help?
For great videos check out YouTube, like [theNewBoston](http://www.youtube.com/playlist?list=PL27BCE863B6A864E3) and[Derek Banas](http://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) Also, to save time and narrow your focus. Ask yourself what don’t you understand? Then find different books and info online that explains that thing you don’t know. I’ve found sometimes hearing or reading the explanation from different sources helps.
You might try /r/javahelp. But, your question doesn't even make sense. You might actually try putting in some effort in asking sensible questions about specific things you don't understand if you actually want to get help. If you can't do that and you truly have no idea what's going on, I don't think you'll find much help here. BTW, call by reference doesn't exist in Java, Java is call by value only. Good luck...
I watched thenewboston for c++ and it wasn't that great. I would recommend avoiding him. Derek Banas is definitely a lot better and preferable. Definitely check out his 30 min Java video since it'll quickly cover some of the topics you might have gone over in your intro class
Call by value for primitive types, for objects the reference to the object is passed and modifications to that object are not restricted to the called method. In Java, unlike C, you can't choose one or the other.
You'll pick it up in no time. You know syntax, so it's most of the struggle gone. 
If you're going to do Java web development, scope may be a bit big to get started with. You should look into which web framework that you're comfortable working with, then proceed to apply for a Java developer job.
Why on earth would you ever recommend The New Boston? OP, please for the love of whatever deity you fancy DO NOT use The New Boston. 
Id find a pet project to work on. Something small but which will cover the types of things you think you should have learned. Having a practical project to work on is much more helpful than some contrived examples.
Yep, that's what I meant. Having map with equal key and value pairs looks ridiculous. 
&gt; knowledgeable people Being knowledgeable *in general* doesn't keep one from being ignorant *in particular* ;-) But I agree. It's the people running the platform who didn't really excel at marketing its name.
The New Boston is a horrible resource people should stay away from. 
Well, it's call by value only if you look at it from a lower level standpoint. Objects are basically pointers to heap-allocated memory and when you pass a pointer by value, you still have a pointer.
https://github.com/JavaKoan/java-koans/blob/master/README.md
I would assume all the EE stuff. You could look into serializable since java doesn't have parceable. Java.net (the library) or rather stuff like spring for web stuff. But overall after a getting used to time it shouldn't be too different. For the UI elements you will probably use javafx if you don't have to use vaadin. And javafx can be created similar to androids ui with fxml.
Useful only when you already have an experience. Not for learning 
I suggest going to the professors office hours and asking for supplemtary material and extra work. 
I second this. I taught myself Java by creating a conference room scheduling application. The code was fucking awful but, I learned all the syntax and a good part of the standard API. Afterwards, I went on to learn to write decent code and learned much more.
A simple project makes it easy to stay focused and actually complete it.
Your "most important book" covers Java through Java 5. You're going to find it very difficult to read code written today. And the code you'll write using Java 5 will look very out-of-date to modern Java programmers.There are many *excellent* tutorials in Java, why recommend one that's years out-of-date? 
Mods, do we really need to tolerate name calling morons with tunnel vision? I don't think so. It seems like that the Java devs here lack even the basic skills to argue so this subreddit should also be renamed to `javaZoo` or something along those lines.
It is also apparent that the same stands for Java, with the only difference that Java devs also have poor judgement.
That's true -- but the Platform is the basis for other test engines, like http://jqwik.net -- Example Based Testing and Property Based Testing
*sigh*
It depends: `@BeforeAll` method must be static unless the test class is annotated with `@TestInstance(Lifecycle.PER_CLASS)`. See http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle for details.
The title says that the article is about books that helped **me** as a Java developer. The book introduces basic notions, while the features of Java 7 and 8 are better documented in the second book and perhaps difficult to understand without the building blocks. While what you're saying has a point, most Java applications still aren't migrated to Java 8 code, and the information and code syntax in the book is highly relevant. Even related to Java 6, the book's opening chapter says: &gt; for the most part the focus of Java SE6 did not affect the content of this book; the features were primarily speed improvements and library features that were outside the purview of this text. Edit: second paragraph.
I don't think it is a good idea. I think people can learn fairly easily... So for me, you should apply to jobs and when accepted, you can work on the framework they are using. You won't be able to master every framework anyway so it is useless to learn every one of them. Aside from the fact that frameworks does not live for long time and so it's useless to spend time on things you won't really use.
that's if he want to work with fat client... which is not really famous today... I see a lot more webservice REST offers linked with javascript frontend. 
Good. It means there are no any reasons to migrate from TestNG.
Struts and JSPs don't remind me.
This is a question for **/r/learnjava** as is clearly outlined in the **sidebar**. In the sidebar of /r/learnjava, you will find plenty resources.
As in a code formatter? There's the google java format tool if you can accept their rather strict formatting - I maintain a maven plugin that wraps it so you can have it run as part of your build. As for linters - you've got many - error_prone from Google, CheckStyle, PMD.
Every single decent Java IDE (Eclipse, Netbeans, IntelliJ) incorporates this functionality by default.
The example in 3.4 would be much more elegant written: Stream.generate(MyObject::new).limit(N) 
click on the cloud tab, vertx is consistently near the top at scale. undertow is also looking like a real good candidate for web facing performance with minimal cruft.
https://github.com/notzippy/JALOPY2-MAIN
I couldn't download it to my Mac so I use eclipse instead. Looks like shit though.
The category of tools you're looking for is [static analyzers](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#Java) which should help with your googling. Checkstyle is the closest equivalent to eslint, but also PMD and FindBugs can do deeper analysis and find structural red flags. There's a product called [SonarQube](https://www.sonarqube.org/) that manages a raft of static analysis and code coverage tools for you. Also, quick history lesson: eslint is derived from the original [lint](https://en.wikipedia.org/wiki/Lint_(software\)) written in 1979 for C.
Vim is not the best? Oo 
well, it took me ages to troubleshoot and finally use it. but even then, it is poorly designed, since it doesn't have a "fullscreen" toggle like all other apps do. 
WTF is DrJava?
Oh yeah totally. I just was listing stuff specific to java. Like javafx for a desktop application. For web of course he should look into some web frontend with a java backend. Lots of possibilities and usually dependend what the company wants. 
https://youtu.be/z1Vse5IEKUA
&gt;[**Java complete training II How to create application frame in java II create a software with java [4:07]**](http://youtu.be/z1Vse5IEKUA) &gt; [*^Peeru ^Jee*](https://www.youtube.com/channel/UCLy7723Jorbf7yXcbh6pdGQ) ^in ^People ^&amp; ^Blogs &gt;*^0 ^views ^since ^Sep ^2017* [^bot ^info](/r/youtubefactsbot/wiki/index)
You are looking for checkstyle
hahahahaha. check it out :D
From my point of view this does not seem like a framework issue, it's more of a architectural problem. Equifax architecture was not designed to be secure. There was no proper security layers/zones established. Data was stored in plain text. Seems like a systemic problem. I bet the other two credit tracking corporations are no better.
Well that takes me back! When I was at Northeastern in the late 90s through early 00s, the PLT guys all moved from Rice Univ in TX to our school, and we used DrScheme a ton to do our scheme work. Until this moment I forgot that they also had a DrJava! Thanks for the memory! And I'm *really* sorry you can't use IntelliJ.
I always thought DrJava was good for what it is. A quick out-of-the-box ready java IDE environment. Very easy to setup. But once you get to do bigger projects, Eclipse/Netbeans/IntelliJ become comman sense options. What's poor about its design?
You're lucky.
It's similar enough that you will pick up the skills quickly. In general things are the same just have different names. You'd have to search for the "Java" equivalent sometimes but mostly you're gonna be good to go
DrJava is designed perfectly to make you appreciate real IDEs.
&gt; DrJava Why are you using something that you will never ever use in real life (i.e your working life).
Your professor is a total nut, from what many people tell me, the real world uses intellij or eclipse
yeah, not my fault :D 
that's not what I meant. I meant that it has a poor GUI
hahahahaha don't worry :D probably because it takes time to learn it but DrJava is ready out of the box :D
And that is exactly what the other person meant.
it has a poor GUI. the main problem is that on mac, it doesn't have the green "fullscreen" toggle like all other apps do
Yeah ok, so its an IDE. If you don't like it, use something else. How does your professor know if you're using it or not?
No, you are not. I really wish universities using Java to teach would either let you go all in on Eclipse / IntelliJ early on and teach you how those tools work, or force you to write in a text editor and compile at the command line. The latter is better for learning, the former much more important for industry.
It's a text editor, and It's a compiler. What more do you need to learn Java? It doesn't have the bells and whistles on purpose. Use your command line if you don't like it. &gt; javac helloworld.java Your prof is trying to teach you the fundamentals of Java, not how to use an IDE. 
As others have already said, it doesn't matter if it's Spring or JEE. I prefere Spring, but the main concepts are the same. Yous should learn about: - REST API (JAX-RS or Spring MVC) - Dependency injection (JEE or Spring) - Declarative transaction management (JEE or Spring) - JPA (Hibernate, EclipseLink or whatever) and Spring Data For the View side it depends on were are you going to work. It could be some JSF, JavaFX, React, a bit of JSP.... Both worlds are based on the same principles, but they use their own libs... it's a matter of using them. My advice is going with Spring because it evolves faster, has more powerful modules (like Batch, Integration, Data ...). On the other hand JEE is easier because it's more simple from my point of view. They are 2 worlds trying to achieve the same. And of course don't forget about testing libs ;-). BTW: Your boss is not so smart if he denies a simple solution because of the language used to do it. Good luck.
&gt; do we really need to tolerate name calling morons really?
Yep, don't worry, I had to learn: Smalltalk and Cobol at various points in my education many many years ago :) 
We started out with bluej
IDE behave differently,
why is that?
I'd assume, but that doesn't physically stop you from using something else does it?
They're lucky they haven't heard of it since it means they've never had to use it.
I used it 3 years ago for a high school class, it did everything it needed to do and think it's a great stepping stool before throwing yourself into an IDE like eclipse Just Google your errors 
Well, his reasonings are that there are no Java programmers on the team, so If I write a tool and leave the company basically no one would be able to maintain it. However, the tool is very small, Only uses Get and Post requests, and some simple UI with Swing. Arond 400 - 500 lines of code. Alos written in 2 days, and fixed bugs with another 5 or so days. So he's only losing a week of developer time. And I made the tool on my own initiative to solve a problem that was haunting the team for about a year. Which is why he wants the tool re-written in C++ and QT since they have a full team of C++ developers. But it's just taking them sooooooooooo long to re-write it. Hell they can copy my code really. And I did make arguments for why I choose Java. * Needed to be cross platform application * Easy Network/HTTP code in Java * Easy Threads in Java The biggest complaint I get is that it's 140 ~mb sized application. and 140 MB of that is the JRE. But I went the extra effort to package the Jar into a MacOSX application for Mac, and a Windows executable for Windows. And since Java isn't installed on anyone's computer and we do a lot of fresh installs, it made sense to just ship the JRE and bundle it with the tool. Thus bloating the size. Really the only downside, but copying a 140mb folder one time seams hardly anything to throw a fit about.
Would have been better if it used the `Objects ` methods.
Dr Java is perfect for its intended use. Testing Java files on their own like a scratch pad 
Pure java developer jobs are hard to find. I would learn the framework spring using spring boot for server side development. I see a lot of jobs that want angular as a plus, which is pretty easy to learn as well. 
It is probably due to the low number of applicants or the other applicants did really poor during their interviews. I wouldn't go into a role being the only developer (since that can be stressful!) if you consider going with them. Usually, companies will list a bunch of tech requirements (in your case, maven, spring, JavaEE) but rarely anyone will ever have all the requirements and as long as you meet some, you'd be fine.
Yes, that's my main grip with being the only developer there. For the Java stack one, i've been seeing a Spring course in Udemy because i did want to post in my GitHub a web project with Java, but atm my undestanding of Spring is limited, thus i do not put it in my CV.
Never heard of DrJava but I did use BlueJ for few java classes. Real world java developers use eclipse/netbeans/intellij.
Us too :( It's ridiculous because Eclipse and Netbeans are free, and IntelliJ has a free version. And for students, the full version is free too!
CodingBat is a really good resource for practicing string manipulations, arrays, and loops.
It's really hard to find good Java devs these days who know those frameworks and tools. What they are hoping for is that you'll learn to pick up Spring, Hibernate, etc. while you are there building what they want.
Just use notepad++ or sublime text and run your program from the command line. I have had teachers who didn't want IDEs before but these are better options and more practical learning experiences.
On the bright side, it makes the JGrasp I had to use while in college look good.
I've been a software developer for over 30 years, mostly using Java, and with at least 20 f those years as a contractor. I start pretty much every job believing the client knows way more than I do and when they find out I'll be in trouble - it's called Imposter Syndrome. It usually takes me about 2 weeks to realize that most clients have no idea what they're doing and, in fact, I can get ahead of their game. There are a few things I do that help: Work hard to understand what they want, then what they NEED and research (Google and Stack Overflow are your best friends) how to achieve it. Build it in your own time before you need to build it for them - in other words, prototype it first but don't necessarily tell them you have. This will help you understand the problem more and let you explore different solutions without APPEARING clueless. READ ... a lot. I have a "Daily" reading list of about 12-15 web sites with articles on development that I skim over every morning. Short articles I read immediately, longer ones get bookmarked to "Radar" where they are "on my radar" for reading when I have time. Read stuff that relates to your work, it also read stuff that's just interesting. You'd be surprised how something that's irrelevant now becomes a solution to a critical problem a few months later. Being a developer, especially a contractor, isn't about knowing everything. It's about knowing a little more than the client before they do and maintaining that lead.
Interviews should be a two-way process - as well as them assessing you, you need to assess them - what technologies they use, how many people you'll be working with and for, what kind of hours, etc. If you're not sure, then ask to go back for another session, so you can find out more about the exact nature of the role. It's not an unreasonable request, and if they say "no" then move on.
[Picocli 1.0](https://github.com/remkop/picocli) is out (actually 1.0.1 is the [latest](https://github.com/remkop/picocli/releases)). * Java command line autocompletion * customizable usage help with ANSI colors * zero dependencies (not even on the picocli library itself) Is this useful to you at all? What new feature would you like next? Anything that has bugged you about JCommander, Commons CLI, Args4j, etc., or just any idea that may be useful? Any feedback welcome!
If the class is in a lab and doesn’t have any other IDEs available, it may become obvious that a user isn’t getting practice with it outside of class.
The time you save by using a proper IDE is so much more than the time spent on learning how to use it.
Is this like BlueJ?
He posts his blogpost with an idiotic "Kotlin is the new Java" clickbait title to a Java forum, and then gets all salty when he gets ripped to shreds for it. WTF did he expect? He's now deleted nearly all of his comments from this thread, most of which were equally, if not more, infantile than the above one. Shame, because some of the comments were absolute gold - "[You need to shape up. I am doing serious work right now in Kotlin](https://www.reddit.com/r/java/comments/6zfxe6/kotlin_is_the_new_java/dmv77qc/)" and the like.
hardly a required feature in a learning environment.
&gt; I have a "Daily" reading list of about 12-15 web sites with articles on development (...) Would you mind sharing them, please? I'm always on the look out for more resources.
wow, that was quick; even though it is based on glassfish. Lets check how easy we can migrate to JavaEE 8 :)
Then why not just teach cli? The fact you're using an ide means you're learning one, so why not learn a proper one while you're at it? Also, forcing someone to use a certain environment doesn't actually improve the learning experience at all. 
Looks very interesting.
Wouldn't crap on COBOL, we're facing a grim round of retirements in the next 10 years. Like, directly partnering with universities that still teach it to hire people.
there is never a silver bullet, you always trade X for Y if you use technology/pattern Z. You use it if you require it. If you ask yourself, if you require it, you probably do not require it. If you are working in the financial section, DDD and Event Sourcing could be a requirement since the domain is generally dictated by many different stakeholders. For example, we have to keep track, how each transaction was moved and how it affected other calculations. Also involvements with taxes or other advantages are tricky. CQRS, on the other hand, is a pattern to remove the limiting factor of the read and write performance differences of databases but adds overhead. You could apply this pattern for other problems, but imo this is not the intended use-case e.g. transforming input data and produce different output data for higher read efficiency. If you are in a field with changing requirements, thinking about the perfect design will get you nowhere. And even in greenfield you will not require this kind of pattern, but it might need to change depending on the changed requirements (e.g. need an optimized read-only database, because writes are low but reads are very high).
hey, i looked at picocli a bit ago, but we ended up going another direction. the features you have added are quite helpful, especially the changes related to sub-commands. We ended up going with [airline](https://github.com/airlift/airline), and had pretty good luck. At this point, I think yours would probably win a shoot-out. I'll definitely give it a go at some point. 
Which didn't exist in Java 1.4.
My wife did a Java course in a college recently and they were forbidden from using an IDE. They were allowed text editors with autoindentation and syntax highlight support, but nothing smarter than that. Compile it from the command line, read the compiler error, fix the code and repeat. I think it was a great setup.
Ehh, learning on specific environments can prep you for certain jobs where there are environmental restrictions. It's not completely wasted. I would personally never teach that way, but whatever..:
how do you realize the zero dependencies? Do you use annotations and generate the sources? €: nvm, I read the dzone article. It offers a single source file for inclusion.
Nothing spectacular. The Morning Paper, by Adrian Colbert; O'Reillys Four Short Links; Reddit Programming; Smashing Magazine; InfoQ ... and so on. When I see an interesting site I just add it to the list and remove it if it's not useful. The main thing is to skim the list every work day - 10-15 mins is usually enough. 
Basically, I think that the answer is NO. The level of language given by sololearn course is so low for working on a real projects. If you really want to apply for a job you need much more practice. 
Wow, holy blast from the past (article from 2002). Here's an article from 2009 from Mr. Scala himself about the [difficulty](https://www.artima.com/lejava/articles/equality.html) of properly implementing the `equals` and `hashCode` methods. Avoiding subtyping altogether by using `this.getClass() == that.getClass()` instead of ` that instanceof This` solves the problem, but it doesn't seem satisfactory in an OOP language. I honestly don't see the problem with `instanceof`. It should be totally okay to compare a supertype to subtype, since the subtype must have the same equality properties as the supertype in order for it to be substitutable for the supertype, as per LSP. In fact, Odersky's article is a glorious description of the bad things that happen when you violate LSP. `ColoredPoint` cannot be a `Point` if it is not substitutable for `Point` in an `equals` comparison. By the definition of equality for `Point`, all points are equal if their coordinates are equal. If `ColoredPoint` breaks equality by making points with the same coordinates different if they have different colors, `ColoredPoint` breaks LSP and you're in for a world of hurt.
It's not ridiculous; it's perfectly reasonable. Real IDEs like Eclipse and Netbeans are full of options, plugins, and other distractions that tend to break or just not work correctly for beginners. Using something like DrJava or BlueJ limits the amount of noise the student has to deal with and allows them to just focus on the programming.
Its not just COBOL, its other mainframe stuff too, i know some peeps that work in banking, and they are starting to panic as people retire.. 
They do.. some netbeans, but most dev's we see/hire will use IJ/E always.
What does DrJava or BlueJ bring that Notepad++ or TextPad doesn't have, besides a "compile" button? I used BlueJ and DrJava in highschool, was required to use TextPad and Notepad++ in college, but professionally use Eclipse and IntelliJ. I haven't touched BlueJ and DrJava in a decade, so I'm actually curious if they're still basically just syntax highlighted text editors?
There is loads of fancy crap, and loads will suggest the current hip framework, but just for now, get spring boot under control.
They have more Java specific features like the compile, debug, auto-complete (for BlueJ), etc. It gives a taste of IDE features without being overwhelming. There is a balance to be had here where following around with the compiler on the command line and using plain Notepad isn't the best learning tool either. So, yes Notepad++ is better than just Notepad, but it still leaves the student high and dry with other important features; especially the debugger IMO. 
Not something a school should be doing though, they need to stay as neutral as they can in that regard, as the graduates will probably end up in many different companies.
The one nice thing I remember about BlueJ was the class file view making it REALLY easy to grok polymorphism by literally drawing the lines on the screen. But once you were past that point in learning, it felt like it got in the way more than helping. Was really helpful for me in high school 14 years ago.
How serendipitous. I was looking for an explanation of this just yesterday. Although the solution that was provided to me was a little different. The solution I was provided just used the hashCode methods of the object variables added together.
Aren't these stacks dead now?
Payara? Uh, no I don't think so. Why would you say that if they just released an alpha of a major new version?
this is actually alarming. java 9 breaks a lot of things, eg unsafe and modules, but because of pushback from the community they've softened the blow by allowing command line switches etc to allow the old-style java to continue to be used but by not supporting java 9 long term, this means that as early as sept 2018, there may be no java that supports those features, effectively negating all the guarantees that we thought we'd won from oracle 
what title would you suggest ? it's technically correct and provides important information and this isn't a moot point - java 9 has deprecated a bunch of common usages that the ecosystem depends on (eg unsafe) but provided command line switches and other workarounds what this non-ltr means is that as early as sept 2018, there may be no supported java that can use unsafe or non-modules. if anything, the current title is too reserved
what would make it exactly correct ? i guess oracle may provide long-term support for enterprise customers, but for the general public it appears to be a true statement 
Nice! Can't wait to try the new EE 8 goodies 😊
I don't know Dr Java, never heard of it and I use Java daily
We use Event Sourcing lite in a Payments application we are building which uses Event Sourcing for calculating payment limit calculations based on rolling windows. We also enable temporal reporting off of a couple other domains that we represent as events that are aggregated for reporting but this is not used in the main application. A previous Akka application I wrote attempted to use CQRS/DDD but in that specific instance it was just excess complication (smart scheduling application) but the end result did resemble CQRS organization. In general I've seen Event Sourcing be more widely applicable. CQRS/DDD I've mostly seen implementations inspired by but not fully adhering to. But that's just my small slice of reality :)
The real world use tools but that doesn't mean we didn't learn using a text based editor, the sun javadoc and cli. Uni is about learning, not productivity. 
We used vim and cli. Remember that uni is about learning, not productivity so I don't agree (at all) with people in this thread who suggest using heavy tools when learning fundamentals. By all means, a subject in a later year of a degree that uses a tool is helpful to be work ready, just as we used (terrible) Rational products for drawing UML. But the earlier you use a heavy ide, the sooner it becomes a crutch that you rely on and thus are less able to evaluate different tools in your career.
My experience has been opposite. Reaching for those paradigms has been a breath of fresh air to keep things closer to SOLID-esque for an otherwise chaos bound onion approach. It really depends on how enterprisey things are (read: heavily divergent/beauricratic processes and data requirements)
The post below by /u/ReadFoo answers it.
It's not technically correct. The article content says the opposite.
Lol, DrJava is horrifically buggy, and doesn't even work at all on Java 9. I'm a TA for a Java course where everyone is encouraged to use DrJava, and about half of everyone's problems come from this terrible editor.
Thanks for the feedback! Could you share what other features/capabilities (or any other considerations) played a role in the selection process? 
What's wrong with learning something productive?
I had to use some custom made Smalltalk IDE for Object Modeling - drawing UML, it was really horrible and so bugged that the teacher was even fixing its bugs during the lecture. So I started using Netbeans UML plugin and everything was fine. 
from the main article &gt; Oracle’s revamped release plan for standard Java means the upcoming Java Development Kit 9 will not be designated for long-term support. from the article readfoo linked &gt; The first new long-term support release for Java will ship in September 2018, a year after Java 9 ships ie, java 9 will not be designated for long-term support. show me a quote that says (or even suggests) otherwise 
&gt; The first new long-term support release for Java will ship in September 2018, a year after Java 9 ships ie, java 9 will not be designated for long term support
I thought Java EE was dead with jdk5. 
Oracle won't donate something that can still make money.
What does that mean? I use Java EE with eclipse all the time. 
EE is a collection of technologies and specs that are alive and well. Just check the JCP page, lots of progress on many parts like JAX-RS, JSP, Servlet, etc.
What was the old home of Java EE?
If you read the article it just means the project has been moved to the Eclipse Foundation. It has nothing to do with the IDE itself.
Oracle.
&gt; Aren't these stacks dead now? Glassfish = Fading. Payara = Getting brighter.
I've used DDD on a large project from 2003 -2010. Was definitely worth it, and i'm still a big fan of DDD. Recent Agile madness taken away from DDD a bit in that teams don't want to spend the time on fleshing out domains. Haven't come across anyone working on a CQRS platform yet, but I like the idea of it. Could make maintenance on such a system easier than the sorts of setups I've seen..
Their cost benefit analysis for Java EE was in the red so their automated systems gave it away to Eclipse.
But... I could use it in NetBeans? 
You can use Java EE anywhere. This is not changing that. All this is changing is who is in charge of Java EE.
Or maybe Oracle cannot make money on JavaEE because they make WebLogic and out there are WildFly, Payara and TomEE.
I'm happy to see that JavaEE is moving away from Oracle. But why Eclipse and not Apache? Apache is running some of the biggest FLOSS projects quite successfully and Eclipse is not a real comparison to this.
That's true, but why the focus on Java 1.4?
wow, good to know.
**Sidebar** **Do not post tutorials here** You have been previously warned. Next time you will be banned without further ado. There will not be any further warnings.
Kinda surprised there as well since the community seemed to have a strong preference for Apache. 
&gt; The other interview was for the Java stack, since my academic experience is in Java. The interview did not run too well because the main discuss of the interview was if i had knowledge in Spring, Java EE, Hibernate, Maven, etc. No, i did not have any knowledge in the Java web stack, because i did not learn them in my academic degree. So i've left the building with a sense that it was not a successful interview. I think that's something you should work on. Most interviews are going to try to find out how good you are. So in general get all the questions right is something almost never happens. They knew you were a junior dev with no experience in the Java ecosystem, they just wanted to figure out how much you did know already. That doesn't mean the interview is unsuccessful. Aside from that; I think it's great that you recognise it's not a good idea to be the sole developer at a company when you're that junior. You'll learn a lot more if you work together with experienced devs. I've been working as a dev for 15 years now and still prefer not to be the smartest person in the room. 
My room mate who's graduating with me in a few months loves COBOL. I'll be sure to tell him. Should be an interesting future.
No, you're confused with j2ee
Well, it's a good reason if the tool to be maintained is complex, but on the other hand they should bear in mind that having 'polyglots' developers is a good thing. On the other hand, I don't think 140MB are going to kill the hard disks of your mates.
j2me
[Forte Group Services](https://fortegrp.com/technologies/java-development/) employ the full-cycle Java development services and guarantee their delivery. 
Is there no such thing as "before suite" and "after suite" to have global setup and teardown? I'm looking for something like TestNG's [@BeforeSuite](http://testng.org/doc/documentation-main.html#annotations) or KotlinTest's [beforeAll](https://github.com/kotlintest/kotlintest/blob/master/doc/reference.md#interceptors)
take a look at Checkstyle http://checkstyle.sourceforge.net/ also recommending taking a look at PMD and FindBugs for static code analysis
Nice list. It contains not only obvious choices (such as JUnit) but also several tols that I didn't know. Thank you.
With CQRS/Event sourcing your gonna need a serious amount of messages/traffic to be worth the pain IMO. In my current project, we get about 40k messages from IoT devices a second. We considered CQRS as these messages are written once, but read thousands of times. It seems like a great idea, but when you actually come to implementing it, it adds massive amounts of complexity, and what would be a simple problem to solve in "standard" architecture becomes a whole sprint for your team. So we scrapped it, and focused on the optimisations that could be made. It's handling the load nicely ATM, and there's plenty of headroom (maybe double throughput) for if the company grows. What we learnt from this is stick with a traditional architecture until it simply can't cut it, then refactor, rather than trying to roll with it from the start. 
They're being tongue-in-cheek, suggesting that DrJava's actual design goal was to be so poorly designed, you'd appreciate real IDE's. Like - I like Eclipse, but is it really so special? After a year of using the DrJava interface, the Eclipse interface is amazing! 
Yeah, okay, but unless you are stuck in some corporate dead-end nobody bothers with EE anymore. Rightfully so. It's crap. There are better ways to do things.
Another option providing [property based testing](https://github.com/kotlintest/kotlintest/blob/master/doc/reference.md#property-based) would be KotlinTest. However you would write tests in Kotlin (what would be more concise and fun, but is not always possible).
Oracle moved TopLink to the Eclipse foundation quite some time ago (now called EclipseLink). Also the transfer of OpenOffice to Apache didn't worked out that well (though personally I would blame Oracle for that). And my general impression is, that the people of the Eclipse foundation have maybe a better relationship with the people from the industry. And don't forget Oracle, IBM and Red Hat as well are all strategic partners. There are a lot of projects hosted by the Eclipse foundation which are used a lot, but are not that visible to many developers: VertX, JGIT, SmartHome, AspectJ, Paho &amp; Mosquitto, JSF, Jetty, and Modeling stuff which in turn is used in many commercial products.
Why is it crap? What are those better ways?
Apache has a very strict way ("the apache way") of running a project. My guess is that they did not like that way.
I too have used airline for the last bigger CLI I have written, and [kotlin-argparser](https://github.com/xenomachina/kotlin-argparser) for a smaller one, that i needed to finish quickly. I am definitely going to try out Picocli for the next one, looking great. What is missing is *maybe* some way to register exception mappers, something similar to the jax-rs way of handling exceptions inside CLI. Also, maybe some way of representing ["one of"](https://github.com/xenomachina/kotlin-argparser#mapping-from-an-option-to-a-fixed-value) options. But anyhow, keep up the good work!
We used it in university for intro course in Java (11 years ago). It was really good for learning Java, because I didn't need to use shell to compile source, and If I remember it correctly it even has a *read eval print loop*, aka REPL. This was really cool (now Jshell will come as default with Java 9 SE). I mostly have good memories of it. Later on we moved to NetBeans when we started to do more advanced things, like Swing applications and using JDBC API to connect to databases. So in short, its purpose is to be a lightweight enviroment for newbies and it serves its purpose pretty well.
j2me4meiide
neither? I used gwt a while ago, but it didn't save me from having to learn javascript or the whole dom/html/styles mess.
This is reported as an issue on the github page already, but I wanted to add that without a license this is nearly unusable... 
If you restrict it to value types most of these problems disappear or are mitigated. Value types have no identity so there can be no NPEs. Value types cannot be subclassed, so generally there will be no weird ambiguities like your ArrayList/LinkedList example as the operators will be defined for specific single types.
I think GWT is kind of dead lately. Maybe look into Spring (And then spring mvc) for what you want to do. What you will learn along the way should be useful to you for a few years at least. My two cents
I have experience with Java EE and the Spring framework. I recommend using Spring (Boot) in combination with modern JavaScript html rendering solution (React, VueJs or Angular). This approach has a steep learning curve but is very powerful once mastered.
Besides name and goal they don't seem to share too much - why do you think it's the same project? They seem to be implemented very differently.... 
That's great feedback, thanks! Speaking of Kotlin, I'm looking for examples of using picocli in JVM languages other than Java. I would love a good Kotlin example! If you (or anyone) has the time and inclination to show what a real picocli-based application would look like in Kotlin (or Groovy, Scala, etc.), please post your example(s) in [this ticket](https://github.com/remkop/picocli/issues/183). 
I'll take a look at your suggestion for exception handlers. Currently picocli throws a `ParameterException` or a subclass exception if the user specified invalid input. The `run` and `call` [convenience methods](http://picocli.info/index.html#_less_boilerplate) catch these exceptions and show the error message and the usage help. Is this what you have in mind, or is it something else? Can you expand a little on the exception handling idea?
Check the publication date of the article.
Really? Why bikeshed over the version number?
Welcome to Java world. My conclusion from 3 years experience on enterprise development in Java: Spring Boot wins. Unlike the other frameworks you mentioned such as Django, Spring Boot is split into many modules and you have freedom of choice on them. For example on ORM, Spring Boot provides several integrations including Hibernate (as you mentioned), Mybatis and JOOQ and you can choose what you want. You can also use more than 2 of them at the same time. Spring Boot also pays attentions to its portability. The good old Java frameworks need to have Servlet container (something like web app server for Java such as Tomcat) installed on your environment. This means that the application have other dependencies than Java runtime. Spring Boot has the plugin to generate fat jar including embedded Servlet container. This allows you to run your app just by running: java -jar yourapp.jar only with Java runtime installed. If you want to make it daemon process, run: nohup java -jar yourapp.jar &amp; The easiest way to run Java web app. Spring Boot has so many great features that I can't mention all of them here.
If im understanding what youre attempting to assemble correctly, then yes its a good choice, as my former employer just delivered a solution to their client that was exactly what you've described in your title.
We have them both on the same box without any problems. As long as the machine has enough memory to run both you should be fine.
Thinking in Java was a good book but is seriously outdated now and I wouldn't recommend it to a beginner/junior developer in 2017. 
https://github.com/mikaelhg/modern-mainstream-web-example ## Modern mainstream web application example Build tools: * [Maven](http://maven.apache.org/) 3.5.0 with [polyglot-maven](https://github.com/takari/polyglot-maven) ([YAML](http://www.yaml.org/)) for the backend, managing the frontend build, and mushing the frontend and backend together. * [Yarn](https://yarnpkg.com/lang/en/) 0.27.5 for managing the frontend dependencies, and the frontend static web site build. Virtual machines / programming language runtimes: * [JVM](http://openjdk.java.net/projects/jdk8/) 8 for running the backend, as well as executing the build. * [Node.js](https://nodejs.org/en/) v6 for running the frontend build. Programming languages: * [Kotlin](https://kotlinlang.org/) 1.1 for developing the backend. Compiles into JVM class files in a JRE8-runnable JAR. * [TypeScript](https://www.typescriptlang.org/) 2.4 for developing the frontend. Compiles into browser-runnable ES5 JavaScript files. Frameworks and libraries: * [Spring Boot](https://projects.spring.io/spring-boot/) 2.0 with [webflux](http://docs.spring.io/spring-framework/docs/5.0.x/spring-framework-reference/web.html#web-reactive) for developing the backend. * [Angular](https://angular.io/) 4 with `@angular/cli` for developing the frontend. * [Project Reactor](https://projectreactor.io/) for structuring the backend data manipulation and data flow management in a particular manner, which has some potential for reducing long-term maintenance costs. * [Bootstrap](https://getbootstrap.com/) v4 for presenting the combination of web content and visual user interface, and structuring the collaboration between frontend developers and UI/visual designers. Other resources: * [Wrap Bootstrap](https://wrapbootstrap.com/) and [Pixelarity](https://pixelarity.com/) for high-level user interface design products, which allow you to spend your UI budget on features, rather than duplicating standard work. * [Unsplash](https://unsplash.com/) for great photographic visual elements. Operational tools: * [Docker](https://www.docker.com/) and [Docker Compose](https://docs.docker.com/compose/) for building production/staging-deployable application containers. * [Traefik](https://traefik.io/) as a reverse HTTP/S proxy and [Let's Encrypt](https://letsencrypt.org/) free SSL certificate automation manager. * [Sentry](https://sentry.io/welcome/) for collecting and managing the application execution errors reports produced by both the backend JVM and the frontend end-user web browsers. * [Prometheus](https://prometheus.io/) for collecting quantitative data related both to the business logic and the application infrastructure. * [OpenTracing](http://opentracing.io/) and Uber's [Jaeger](https://uber.github.io/jaeger/) for distributed enterprise application tracing, where you need transparency into business processes which have been distributed across many separate applications.
GWT 2.8+ is great however it has a very steep learning curve. I would not suggest it as a starting point. Why not go all Java EE and use JSF? 
Both Java and .net have a healthy supply and demand of developers. However, a company will have trouble hiring experienced talent if they cannot afford to pay a competitive salary. As a result, they may be forced to hire people with little/no experience with the hopes that they will learn on the job.
Maybe you meant Atom-DIE* (ssly why use a web browser as IDE ?) IntelliJ IDEA masterrace 
Kinda dead GWT is what I was afraid of. Thank you.
A have some experience with JS. Thank you for suggestion.
I enjoyed theNewBoston. Even my professor used it at a reference point. Is it the best no. Can you still learn something the answer is yes. Please don't down vote. I'm just trying to help. Where's the love?
They changed its name to JavaEE at 5. It isn't dead. The spec is alive, well, and still quite useful. 
Never heard of JSF. I'll take look at it. Thanks.
I am aware that I have to know something about web pages.
Will this mean better plugin support for the commercial server environments (e.g. JBoss EAP, WebSphere, WebLogic)? Because currently, those plugins aren't the best. 
Just use Java EE 7, you don't really need a 3rd party framework these days. Java EE was mostly awful prior to Java EE 6 so everyone just got used to using frameworks. A lot of people have not stopped to take a look at the newer spec, but things improved greatly in 6, and then improved even more in 7 (and 8 is just around the corner). For the view you can use JSP or JSF. Those are included in Java EE and you won't need additional dependencies to use them. If you have a favorite templating engine you can use that for your view too although you will have to add the dependencies and set your project up to use them, FreeMarker or Thymeleaf seem to be popular choices. For the API application (I assume you mean a RESTful API) then you can use Jersey (JAX-RS reference implementation) which is part of Java EE. However, if you are deploying to a servlet container like Tomcat you will need to include jersey as a dependency of your application as JAX-RS is not implemented by Tomcat. If you use something like glassfish, jboss, TomEE, etc then those are full app servers and the container provides JAX-RS to you. http://docs.oracle.com/javaee/7/tutorial/
This is not about the eclipse IDE, but about the eclipse foundation. Just like the apache foundation does a lot more than just the apache webserver, does the eclipse foundation host many projects. JavaEE will be on of those projects.
Eclipse? Hahah
I know that. I'm hoping that this causes the Eclipse Foundation to put a bit more work into the JavaEE plugin ecosystem, which is currently a mess. 
Even without Spring Boot creating a web app that runs with tomcat embedded in it just takes a few minutes. It is literally just a single class. Everyone thinks Spring Boot is doing some magic to get an app to run standalone, but it is quite easy to do on your own with any java web app.
I'll also add these links: [Spring Cloud](http://projects.spring.io/spring-cloud/) - which provides a suite of tools for managing distributed services. [Spring Roo](https://projects.spring.io/spring-roo/) - if you like the Django and Rails code generators (for auto generating things like admin screens).
You don't need Spring these days, just create a Java EE 7 application. Java EE 7 is quite modern: http://docs.oracle.com/javaee/7/tutorial/ 
if you are looking into jsf you also want to look at https://www.primefaces.org a component library for jsf
&gt; AspectJ Out of the discussion but fuck that little shit. 
If Java EE was dead most of the java web frameworks would be dead since most of them are just wrapping up Java EE. (e.g. Spring uses a DispatcherServlet).
2j4me
Some of what you described can just use an Atomic*FieldUpdater
It's not a web browser as IDE though. It is adding IDE-like features to the Atom editor.
Can someone edit the title to say Eclipse Foundation instead of plain Eclipse 
&gt; **How does get() method of HashMap works in Java?** &gt; The get() method of HashMap works in the principle of hashing. It is responsible for storing an object into backend array. The hashcode() method is used in conjunction with a hash function to find the correct location for the object into the bucket. If a collision occurs then the entry object which contains both key and value is added to a linked list and that linked list is stored into the bucket location. What are you trying to do? Make sure people fail the interview on their first question? 
http://docs.oracle.com/javaee/7/tutorial/ Versus: https://spring.io/guides/gs/spring-boot/ They really need to work on their documentation. I hope with the move to Eclipse that there will be a substantial amount of effort int that regard. If a developer is assessing multiple platforms the first impression matters a lot. 
&gt; Everyone thinks Spring Boot is doing some magic to get an app to &gt; run standalone That's only one part of Spring Boot, and building a fat JAR from Spring Boot isn't really its main selling point (the Maven Shade plugin has been doing this long before Spring Boot came around). The real "magic" to Spring Boot is autoconfiguration and the wide availability of "starters". For example, you can include (and configure) Spring MVC and the Thymeleaf template engine by simply adding `spring-boot-starter-thymeleaf`. You can include (and configure) Spring Security by simply adding `spring-boot-starter-security`. You can include (and configure) Spring Integration by simply adding `spring-boot-starter-integration`. And then if you want to build on Spring Integration with Apache Kafka, just add `spring-integration-kafka`. Furthermore, there are a large number of third-party starters, such as including (and configuring) Mybatis using the `mybatis-spring-boot-starter` or Apache Camel using the `camel-spring-boot-starter`, etc., etc. There's also Spring Cloud, which seems to be an add-on to Spring Boot (it really shouldn't be, but that's another story). That's the actual "magic" of Spring Boot and its main selling point. 
Yes, apache cares much more about getting a community going and certain things - like domination by one company - is something of a red flag. (I was surprised openoffice got in to be honest)
The Atom editor uses a web browser (Chromium) in the background.
Did you make any games with it? If so, got any screenshots/videos?
I am interviewing for Java. If I get one answering like this: What is the requirement for an object to be used as key or value in HashMap? (answer) The key or value object must implement equals() and hashcode() method. The hash code is used when you insert the key object into the map while equals are used when you try to retrieve a value from the map. he/she is not going to get a job. Here is a better question: Why overriding hashcode and equals does not guarantee that instances of a given class could act as a key in a Map ? 
The [Java part](https://atom.io/packages/ide-java) of that "IDE" is powered by the [Eclipse JDT language server](https://github.com/eclipse/eclipse.jdt.ls). Not sure how you can get excited about this.
Newbie here, but isn't the result of the hashcode of an object that object's position in the array? Hence why all hashcode results must be integers?
The "problem" with JavaEE is that it is just a spec (Spring OTOH, is a product). That JavaEE tutorial is good to get a basic understanding of the various JavaEE specs (like, how is JSF *supposed* to work?), but I have found it useless for learning anything concrete. For that, I would recommend starting with the tutorials for an actual JavaEE app server, like Wildfly: https://docs.jboss.org/author/display/WFLY10/Java+API+for+RESTful+Web+Services+%28JAX-RS%29
&gt; Just use Java EE 7, you don't really need a framework these days. In what way is Java EE *not* a framework?
Nice to see our blog here! 
What do you think of jet brains taking ee?
Going full javascript might be the way if you want your statistics to be shiny and responsive in the browser. Both Java EE and Spring are frameworks intended to support large enterprises in creating large applications that survive 20 years of ever-changing teams. For personal websites something like Grails or Play might work just as well, and be more fun. 
https://www.forestadmin.com/lumber/ For the back office solution, I use Lumber, which I recently discovered! Powerful and fast to install! However, they only work with SQL Database
Spring Boot is king. 
Oracle stopping to invest in JavaEE and abandoning it is in itself not likely to improve that situation. Should JavaEE actually pick up speed and vastly improve as the evangelists all wish (no surprise there), plugins might improve. I would not be on it, though.
Thank you for great comment. 
I am not fan of server side JS, but thank you for suggestion.
You are being pedantic, but I have added "3rd party" verbiage to clarify. Although Java EE is just a bunch of specifications so not sure 3rd party clarification is even necessary since its status as a framework is arguable.
Electron : Yay or Nay !? https://www.reddit.com/r/linux/comments/6yo84y/electron_yay_or_nay/ Might want to check this out mate :)
I found the java ee 7 tutorial to be quite comprehensive. It is true that it includes a lot of dense descriptions and explanations of the various specs, but there are a lot of examples in there. I agree a quick start guide with examples of servlets, filters, jax-rs, etc would be helpful.
Ah, thanks. TIL. That explains why it is slower than Sublime on my machine.
You've not used JavaEE lately, I can tell. 
Not even sure how useful it would be, but I was thinking about passing custom exception mapper to the (for example) CommandLine.call or something else, that would be able to catch the runtime exceptions leaking through callable that is executing the command and write them to the output stream in a way that user specifies for each type of custom RuntimeException he provides the mapper for. To avoid the need to wrap the CommandLine.call with try catch blocks for custom user exceptions, or to handle them inside the callable for terminating exceptions. I was referencing how you can let some exceptions "leak" through your rest method handler in jax-rs implementations - if you have a registered exception mapper for some exception, right response will be propagated to the requester. Maybe it is totally unneeded, i just have not found a pattern that I like for exception handling in java CLIs. Ether it is all over the place (with system.exits), or centralised but in a place where I don't want it. Just my opinion, don't take me seriously if it seems stupid to you.
Almost. Hashcodes are used to figure out in what bucket an object should go. Basically if you have 10 buckets you take the hashcode modulo 10 which gives you the index of a bucket. This bucket is just a list in which the corresponding entry is found based on key equality. This is why it's so important that you implement both equals and hashcode properly. But please do not even look at that page. The author doesn't understand at all and the answers are plain wrong. 
U funy n00b
[removed]
Maybe reading is not for you. Have you tried CodinGame.com?
Let's get this one out of the way: Programming is hard. If you're having trouble, then that means you're trying. Keep going. It will all make sense with time and effort. Second, post any questions you have to /r/learnjava. I'm not complaining about you posting this here, just that you'll find people ready to answer your questions there. Third, try to have fun. This is like any other alien skill. Like learning a new language, or picking up a musical instrument. The first time is always the hardest. Keep at it and you'll be rewarded with a new skill.
They have no experience in that sort of thing. Not to mention they are a commercial entity. They would be a worse choice than either of these.
Head first java by O'Reilly This us the best java book there is. Maybe get a pdf from net ?
I haven’t heard of it. Will give it a go! 
Best way to learn is learn by doing, just keep at it and alot of it will click some of it won't ever but you'll understand enough to be able to make your own programs to do what you want 
Hey thanks for the advice. I guess I get a bit overwhelmed when I glance at further concepts. I’m here thinking to myself “Man how am I gonna understand that when I don’t even understand the basics?” Lol. I want to be really good at this stuff. I’ll keep at it though Thanks again. 
I’ll look into it for sure. I enjoy the resources. Thanks! 
Learning Object Oriented Programming (OOP) is hard if you don't have previous programming experience. Java just implements all those concepts in its own verbose and corporate way, witch can add some level of difficulty. Maybe you should start with a structured programming language, like C, and then read about OOP and start with Java. In my case I had a similar issue and I took in-person classes because it was easier for me.
I'm a super beginner also and what's been helping me is practicing while reading. Reading the book and then playing with the codes they give as examples. Mess with stuff, see what works and what doesn't. After doing that, the concepts in the book are starting to make more senss. 
Why travel to Oslo and pay 6500 NOK, when you can watch it online?
I felt the same way when I started to program. Sometimes I still feel this way. At some point it just starts to click though. As my professor told me: programming is just like any other skill, you have to practice to get good. If you want to be good at riding a bike or programming you must practice. Some people may appear to pick up programming easier than you but do not worry you will pick it up. As long as you continue to practice it will get easier. Do not fall into that trap of comparing yourself to others. It will not be good for your long term growth. This is coming from a guy who did exactly that. It didn't help me at all and it won't help you. Just focus on your work and do not worry about others. 
is your complaint that there are existing better clients for the jdt-ls, or that the jdt-ls is less than impressive itself i've been interested in using a command line tool to access jdt-ls (so refactorings could be shared across decentralized code bases)
Im in a beginning Java class right now. Most students are really struggling with it while the others have had previous programming experience of some sort. I previously took a javascript class for example so i understand most of whats being taught. I would bet that most of the students around you either have some sort of programming experience. If not, then i would think that they aren't focusing on understanding how and why the code works the way it does like you might be. While i was in my javascript class, we started with super dumbed down codes like putting a circle on the screen where i was being narrow minded and just did whatever i was told. The course was hard as hell because by the end, i wasnt thinking like a programmer. I was only doing what i was told to do. Programming is all about problem solving. Its NOT easy but i strongly believe the only way you can be good at something is by practice and experience. Stick to it and you'll be a pro. Dont ever think youre dumb for not understanding something completely new to you
Definitely agree with the article's opinion of time based versions. So much more confusing than the semantic versioning everyone is used to, and won't tie in very well with the Java VM/bytecode specifications.
I've only made test projects to test things I've added to the engine. But one of my contributors has made a rogue-like https://github.com/rickbau5/SimpleRoguelike
Networking with people ya autist.
Heyy, so when learning your first programming language, it will be difficult as hell! I never understood anything and it took me around 12 months to even grasp how to write simple text based applications. I had been programming as a hobby for 4 years before I could even consider myself remotely good. The best thing to do when learning any new skill is to practice, practice, practice! The more code you write (even if it's repeated code), the more you'll understand. Once you feel comfortable writing code (even if it does nothing special) you'll learn to progress. What I found useful when I was learning was, download an open source game/application and then try to edit it (e.g. changing the text). You'll eventually get a better understanding :) 5 years down the line now and I've made a good starting portfolio. I can understand a couple things and I'm trying to get an entry level programming job. Hopefully over the years, I'll progress into real professionalism! Just some food for though; nobody is naturally clever. People work hard, even though you might not see it! :)
take both jobs on the condition that they let you work from home 50% of the time. then hire an offshore freelancer to help you get it done, for a small fee. / (semi) s
It is right, that one doesn't *need* Spring, but Spring provides a lot of power, convenience and real world solutions. Spring is a lot better to test than Java EE in many scenarios (without helpers like Arquillian). Plus: Spring offers way more integrations to other technologies. To cite the [Spring documentation](https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/overview.html#history-of-spring-and-the-spring-framework): &gt; While some consider Java EE and Spring to be in competition, Spring is, in fact, complementary to Java EE. Spring does not support every Java EE specification. Rather, it integrates with a carefully selected subset of the most widely used Java EE specifications ...
👌 best comment in this entire thread!
I don't recommend spring boot. Stay away from it.
Spring Boot wishes it is king, but it's more like a street beggar.
both
&gt; I started at 8am and now it’s 1pm. I started in 1996 and it's now 2017, and I *still* learn new stuff about Java. Don't worry, it gets a lot easier as time goes on and you turn knowledge into experience.
Some of those sure but not most, not an authoritative of definitive list and no to Kotlin. As far at the OP's question, I'd word it as, "how to architect a modern Java application and/with/besides these other technologies". To that the answer is...complicated. 
To expand your horizons and hunt polar bears.
They recently moved Netbeans to Apache and Hudson move to Eclipse was not successful either. I don't think those were a factor.
I would use Spring Boot. Having used it for both enterprise solutions and personal projects, I believe that it could easily achieve the result you wanted. You could very easily deploy the finished product as a jar to a platform service such as Heroku if you ever needed it to be available on the internet if you choose to use Spring Boot. If you use Java EE you'll need to use Amazon AWS, Cloud Foundry or another similar hosting service where you would need to manage the hosts / servers as well as your application itself. 
 Out of curiosity, could you elaborate what the reason is for you not to recommend spring boot?
?
Learning programming is excruciating until you get a bit into it. Once you start making even simple stuff you'll love it. Kind of. It's pretty hard, and can get very frustrating. I'd follow along in an IDE though.
&gt; I’m here thinking to myself “Man how am I gonna understand that when I don’t even understand the basics?” You're setting yourself up for failure. Stop doing that! A stressed brain won't process new information properly. You're going to hit many road bumps, like everyone else. It's normal.
Thanks for the clarification! This seems a very flexible and powerful concept. Of course the trade-off is additional complexity so for now I'm going to hold off on applying it until someone comes with a problem/use case that could be solved with this. Thanks for adding it to my toolkit of potential solutions!
What would you recommend?
The great thing about programming languages is they make more sense the more you use them. When I first started, object oriented programming seemed like a huge hassle and a waste of time. As I started to make projects that were more and more complex, it became blindingly obvious that the OO model wasn't just something someone did, it was something that needed to be invented. Once I started looking at every concept in programming like that, it made a lot more sense. Keep trying, don't give up!! Soon you'll be able to do shit that most people can't even understand. 
Dude, just don't give up. I mean, right now, when I look back and remember all the stuff that seemed hard and impossible to learn, I actually wonder how I couldn't understand it. And your speed of reading is alright, it will get faster with time and with better understanding of what you're learning. Don't think that you're dumb. It's just important to keep going and study/work on your skill constantly, and you'll get there. And also don't look at other people and think, "oh, they're so much better at this", they might've had (and most likely they did) different backgrounds where they could learn some stuff on the subject, or anything like that. Don't think that coding isn't for you just because you're having a rough start. Coding is not for you if you actually don't like it. Hope it helps, good luck bruh EDIT: btw, I'm not sure, but I think the book "Head First Java" or something like that might be for you, google it, I think it's really good for starters.
If only they’d do one last OpenSolaris code dump :(
Tonight I cought several polar bears. I took the skin and walked around like Jon Snow. On a more serious note: As /u/briene80 said, it's a lot of networking. For us that work in Oslo this is a key part of the whole event. I meet old colleagues. I met previous clients. I had the opportunity to meet a lot of great IT professionals. Another excellent reason is that I would probably not watch the sessions online, but when I'm there, I love all the great talks. It is something entirely different watching some videos online, and taking some time without caring about domain specific problems and just learn. I meet great people I can discuss the talks with. I meet people I can argue with. I meet people I agree with. Perhaps the talk was great, but a lot of the learning happens afterwords when discussing it with other skilled people. I will feel rejuvenated when I go back to regular work on friday. Filled with new ideas and opportunities. I would never feel the same if I watched a video or two online..
No license file at the root of the project, but if you look in the src directories a copy of the Apache 2.0 license is plainly visible.
&gt; It’s free for up to 20 calls per build. Even for commercial use. I'm all for people trying to make a living from commercial software, but you should at least cover the basics: have license information available, better documentation and examples and a website detailing the commercial options and support. Additionally, if your library is meant to scratch a real itch, and you want people to pay for it, it better be VERY good at what it does. It must be worth the trouble of licensing and all that jazz. The lack of any of the above, and you asking for opinions on it here indicate it's not nearly a mature product and it will likely create more trouble than it attempts to solve. You'd be better off starting as an open-source and free solution that can be used by everyone. If it proves to be relevant you'll get feedback, bug reports, feature requests, etc. Work on building a rock-solid solution that people want first. If you intend to sell a commercial license later then implement whatever additional features you think are game-changing on top of that . These features will be built on a more solid foundation (the open-source bit) and your product will be more likely to be successful. 
Hey thanks dude. Much appreciated. I love the feeling of writing code and having it run. I just hate when things don’t compile, but at the same time I love the challenge. 
I will definitely check that out. You’re right I can’t just give into it. It’s too much fun when something actually compiles correctly lol
I don't think this is really a good idea. Heavy use of `synchronized` is adding locks everywhere, which can lead to bad effects like deadlocks if you order your locks improperly. Synchronized is something you should do explicitly and with forethought, rather than willy nilly. If you want to really implement concurrent access to memory with transactional semantics, why not use a proper implementation of [Software Transactional Memory](http://doc.akka.io/docs/akka/1.3.1/java/stm.html)?
 public int update(int delta) throws Exception { int current = value.get(); int update = current + delta; if (update &lt; 0) { throw new Exception("value is negative"); } while (!value.compareAndSet(current, update)) { update = current + delta; if (update &lt; 0) { throw new Exception("value negative"); } } return update; } This doesn't appear to be thread safe. 1. Assume current = 5 2. Thread one calls update with delta = 1 at the same time thread two calls update with a delta of 3 3. if both hit the while loop at the same time one of the updates will win. Let's assume thread one wins and current now equals 6. 4. Thread two will now infinite loop because it is comparing 5 to 6 to make the update and will always return false.
There are much better ways to solve concurrency issues. Promises, immutability (copy-on-write), queues/tasks, and a bunch of other goodies in java.util.concurrent.
Can we integrate breaker box ui with Resilience4j metrics?
You need to bite off what you can chew. If something is confusing, see if you should learn something else first. Get a program to work, and then change it. If something breaks, find out why. If you don't have a stable base to build off of, then it makes it really hard to figure out what caused the problem.
The final example uses Java's Atomic* classes which are transactional. However the example still has some issues.
Java's Atomic classes aren't transactional, they are simply optimistic (while synchronization is pessimistic). Even with Atomic, concurrent updates to the heap are still immediately visible to all threads without any isolation. With Atomic, atomicity is restricted to CAS type operations (which are faster than sychronization because they are lock-free). STM actually implements transactional semantics on the heap, allowing concurrent (C) isolated (I) access to shared heap values between threads, and allows atomicity within transaction boundaries complete with commit and rollback (A). Since the heap is not persistent, STM of course isn't durable (D).
There's also /r/JavaHelp if you have specific questions, though I know they try to guide you to the answers rather than just give them out. Coding isn't for everyone, but I believe you can do it if you keep at it!
http://www.ihatejsf.com/ :)
The whole post talks about "Kay" and "Ingalls" but doesn't explain what they mean. After following some links I've found they're version. It would be probably more clear to just call the version by numbers and not by release names. Anyway, thanks for the great work! That's what counts. I enjoy using Spring Data!
I clearly only looked at the first two examples which atomic classes can do. That's pretty interesting although I have never actually had a use case for something like that.
It's noteworthy that you were able to put in a 5 hour session learning. I wouldn't worry too much. You figured out what you read right? I'm guessing you spent time fiddling with things, asking yourself questions, and coming up with answers. That's the process. It takes time to get mentally organized with this stuff. Think of it like a giant wheel. Right now it's moving very slowly because you're just starting, but sooner or later it'll have tons of momentum and an ability to fly through stuff.
1) Forget everyone else. They don't matter. 2) No pain. No gain. If others are not struggling, they are not trying. 3) Write code every single day. The books are a supplement not the main focus. 4) Be patient with your own mistakes while writing code. 5) Write and debug more code. A few weeks or months down the line, you will be able to write code almost automatically, seemingly without too much effort. Then you are a programmer.
&gt; I want to be really good at this stuff. I’ll keep at it though Programming is merely a means. Working code which solves some problem is the end. Don't learn a language. Learn how to use a language to solve a problem. Also, if you keep at it long enough, you will be proficient in it. That's really the only way to learn things and to solve problems. That is the right path - nay, the only path.
Headfirst java helps you visualise better, SCJP by Kathy sierra helps you master the fundamentals. That's how you start. Needs a lot of practice to understand and use design principles effectively and optimally 
I want to say that I really do appreciate everyone’s advice on not giving up and pushing through. It means a lot when my confidence level is low. 
Learning tools takes a fraction of time when you really understand what it's doing to your code under the covers, which is why they're used later in courses after you have a deeper understanding of the language it's helping you with. On the other hand, language fundamentals are much harder to grasp after having learnt with the tool, especially considering these tools can make whole structures of classes with a single click. 
Little progress is also a progress.So learn by heart just..
But there's more: - searchable left-side TOC - many improvements to Envers documentation - all examples are based on unit tests that reside on GitHub Impressive, right?
But there's more: - searchable left-side TOC - many improvements to Envers documentation - all examples are based on unit tests that reside on GitHub Impressive, right?
So it needs Project Valhalla to be used; for value types it actually makes a lot of sense. Value types often behave like vectors for which operations are well defined.
Checkout [spotless](https://github.com/diffplug/spotless). It can use Eclipse formatter, google-java-format, or a bunch of other formatters. Has a gradle plugin, but you could jerry-rig it to work with other stuff.
Being able to search for new settings is nice; I'm guessing it's not new, but I've only just discovered it.
Check the upload time - it was only added _after_ my comment.
There are better open source solutions available. So it's utterly pointless to try and make money off of this. What you're doing is nothing more than combining some (not all) functionality from [Test containers](https://github.com/testcontainers/testcontainers-java) with the basic Spring testing stuff. 
Imagine programming is like a smartphone. Lets say thats your first time you touch it and you have no idea whats going on. In school they will teach you how to search cats in google with instructions like: click this button, then swipe, then click on that icon with label Google Chrome then on top click on the white bar, keyboard from bottom should appear, type cats and on right bottom corner there is curved arrow, click that. At this point you are thinking - wow thats really useful. But you have no idea what happened. Now the key point here is to write down that example and question yourself what every action means and is doing. People might say that you need to learn this or read that book, thats fine.. As long as you try to understand what every think you are doing means. You dont need to know that Google Chrome has private tabs. At this point that knowledge is useless. Its like learning concurrency when you dont know what is a List. So learn whats keyboard and why you need to click that right bottom button. Then learn why you clicked that top bar in Google Chrome. Whats Google Chrome. Why you swiped, what does it mean. Why you clicked that button. Once you understand, try different application. Ask people or google. Messenger is popular, lets try it. If you experiment long enough, you will start understand that every time you click on text bar, keyboard will appear. Now you know its universal for the whole system. Just like Collections for example. Then maybe install Firefox, because now you know there are different browsers. Compare it, think about use cases. Thats how i learned and how i teach my friends. They need to understand why they are doing this and not something else, whats that for. TL;TR; experiment, question every step you lear something, understand it, use it, ask others, read materials and DO examples, a lot! 
Been running an app that started with grails 1.3 when it was new, and is still being actively worked on. It's good for long term projects...
As the original creator of Axon Framework, I can confirm that there are many systems nowadays that run on Axon. However, because it's open source and freely available, there is only a small portion of users that we actually know, and an even smaller group where we know what they're actually doing with it. Some of the Axon users are large (a couple of them in the world's top 20) banks, which use Axon in their core payment systems. We have heard of airport management systems (processing radar information and advising air traffic controllers) based on Axon. Axon is also used a lot in the betting and gaming industry, because of the strict auditing requirements and high value of past events for data analytics. Adoption of AxonFramework has also been increasing significantly in the past months, and we're currently seeing more than 30k downloads a month. We have also recently founded a separate company that will focus on the continued development of AxonFramework and provide professional support services: [AxonIQ](axoniq.io). Not meant as a shameless plug, just as 'proof' of my point ;-) Getting started with DDD and especially CQRS is something that you need to get used to. Practice is the best way forward. Make some mistakes, but make sure you take the time to learn from them. Most developers I talk to get used to it quite quickly, and wouldn't want to go back to the "traditional" approach anymore. In case you get stuck, there are mailinglists ([generic ddd/cqrs](https://groups.google.com/forum/#!forum/dddcqrs) and [axon specific](https://groups.google.com/forum/#!forum/axonframework) ) where you can post any questions you have. There is a large and active DDD/CQRS community out there, and they're willing to help. Also note that there are a lot of DDD meetups and conferences all over the world.
I agree. I mean I am sure the professor in the university knows what he is doing
Took me at least 3 years to have a slight understanding what I was doing. So, this is normal ;).
I do not agree. I was taught in school how to make tables, not in Paint, but in Excel. And how to program microprocessors in some IDE, program PLCs in some IDE, program Java in Netbeans... Programming without an IDE is simply a waste of time, you are mastering something totally useless. I have nothing against writing a hello world, compiling and running it via cmd, but that should be the end of it, anything more is a drag with no benefit.
I know, even the Eclipse projects are moving to Jenkins at the moment. Moving Netbeans to the Eclipse foundation would have been nonsensical, since they already have an IDE.
So young and naive...
i think one of the maior difference is the scale of project. Android app's seems to be quite 'small' but JavaEE [my god] or spring apps are fkin huge [one of my project contains 90+ modules where each of one for me is like one Android app]. 
Is this the first programming language that you are learning to use? Then this is absolutely normal. Even if this is the first OO programming language you are learning, it's again normal. If you're a computer science student, spend a lot of time on algorithms. Also for AI, calculus and linear algebra are good-to-know subjects. Don't worry if it takes too much time to become good at them. Be persistent and do not give up. 
we use it, still a few places do - actively developed. Saves a fuck load of time. Looked at using react+blueprint,holy fuck the libraries are immense.
Isn't this what drop wizard does?
In concept yes. This just appears to be the same goal implemented with Guice
I just skimmed through it... I did not understand any of it. I guess it would make more sense to somebody with prior knowledge of spring (or the other stuff you used). Would it be possible to hide all of that internal stuff? As a user, I just wanted a way to run some integration testing on my database. 
Check out [ReflectASM](https://github.com/EsotericSoftware/reflectasm)
Example for usage?
It's better to ask this in /r/learnjava. &gt; JSP? JSP is still very common in the industry but Oracle encourages the use of JSF for new projects. If you're just getting your feet wet, I recommend reading the [official Java EE tutorial](https://docs.oracle.com/javaee/7/tutorial/).
Dropwizard is a fully featured framework and this is just a Guice module intended for those who uses Guice as main DI framework in their projects and want simple and lightweight solution to run embedded web server.
The entire Hibernate user guide should consist of a single line of text that reads: "Please stop using Hibernate".
From github page: SomeClass someObject = ... MethodAccess access = MethodAccess.get(SomeClass.class); access.invoke(someObject, "setName", "Awesome McLovin"); String name = (String)access.invoke(someObject, "getName"); Unfortunately it seems like there's no reflection over annotation, which probably is the biggest usecase of reflection. It is also quite bare, e.g. no convenience methods for access that the [reflections](https://github.com/ronmamo/reflections) lib, [Guava](https://github.com/google/guava/wiki/ReflectionExplained) or [Spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/ReflectionUtils.html) ReflectionUtils provide.
Ah, that's a typo, just replace get() with put() and it will make sense. I'll correct it on the page. 
Look deep into hibernate setup HikkariCP to cache connections and redis as a second-level cache have had very important implications for performance in my stack. Also tweaking your sessionfactory implementation
Correct everything else as well?
On a similar boat. We're using the Spring Cloud Netflix framework on Amazon Web Services, seems to be all the rage. I recommend learning it, I'll be doing the same.
So, J2EE is sort of a huge mixed bag. There are really good parts and really awkward kinda painful to use parts, and even worse many of the areas need their own focused training. Personally, for webapps I would recommend starting with Spring boot for your web api/controllers and mybatis for your ORM. As far as server side templating languages go you can use JSP(which kinda sucks), or thymeleaf(spring specific but less sucky), or just use a simple template like handlebars. Something you may notice is that these recommendations dont make much direct use of the J2EE stuff and this is with good reason. Much of the J2EE stuff was based on these outside libraries and quite frankly is trickier/pita to use by comparison. tldr; JSF, Hibernate are a PITA. Use Spring Boot + mybatis.
Thanks for taking the time to answer. I do't really mind something being a PITA so long as it is the rage in the job market :) A lot of job listings seem to use Spring, J2EE, Hibernate, JUnit etc.
That would be @BeforeAll and @AfterAll
A lot of job listings just list buzzwords, I wouldn't read too much into it because it can mean anything. In my experience its more important to be familiar with Spring than bare J2EE when they list it as a requirement. Its important to start with stuff simple enough for you to be able to understand what is going on. From there you can be in a real position to make decisions about things like hibernate vs mybatis or Spring vs WebServlet + other supporting libs.
Can someone explain what is lambdametafactory?
&gt; Ideally I'd want to set something up like Spring Fortunately it's really [easy to get started](https://spring.io/guides/gs/spring-boot/) nowadays. &gt; What about the ORM? What are some of the in-demand things in web development in the industry at the moment? It differs from project to project but the stuff you see almost everywhere: * Maven or Gradle for builds/dependency management * Git (in case you haven't used it) as source control * JUnit for unit testing * Slf4j + Logback for logging * Mockito for mocking Other than that in my experience Spring has become the de facto standard for 'web' applications and Spring Boot provides a ton of [easy to use starters](https://spring.io/guides) for stuff like Spring Data, security, etc. The biggest 'hurdle' you will probably face is getting used to the concept of Inversion of Control. When it comes to accessing databases I'd recommend starting with Spring JDBC. It's basically similar to manually writing SQL and easier to get started with when you're coming from PHP than JPA. I've been on quite a few projects were the moved away from using ORMs too, they seem to be falling out of fashion a bit.
&gt; So, J2EE is sort of a huge mixed bag. Small remark: it hasn't been called J2EE for a long time. While it's still on outdated vacancies the 'proper' term is Java EE. So I'd personally recommend against using J2EE on your resume ;)
Feel you. I've been learning Java for several years. I feel like I have some understanding of SE. But recently, I've started learning Spring. Man I feel dumb. Those guys who came up with that Framework and keep developing it are lightyears away from me. But... All I can do is just move forward in my own pace. Hopefully I'll be half as good. And its ok aswell :)
I dunno recruiters love that buzzword even if the name changed the job postings stay the same!
Hibernate is unstoppable. According to this DZone survey, [64% of Java Developers use it](https://blogs.oracle.com/theaquarium/dzone-survey-shows-jpa-dominates-java-persistence). This 2014 ZeroTurnaround Survey says that [67.5% of Java projects](https://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-for-2014/10/) use JPA and Hibernate. And that was before investing time in the new User Guide. Now, the market share is over [70% and counting](https://vladmihalcea.com/2016/08/18/jpa-providers-market-share-in-2016/).
A helper class in Java 8 that is typically used to evaluate lambda expressions and create an object with a single method, which is then invoked to return the result of the expression. However, you can also use it with any `MethodHandle` obtained through reflection.
I saw an interesting approach in a [comment](https://github.com/decebals/pippo/issues/369#issuecomment-307334493) on [Pippo](https://github.com/decebals/pippo) (it's a micro Java web framework) site. So instead to use Guice to Inject dependencies in Pippo controllers, he uses Pippo as a dependency in an existing application (Guice based) to add web support. Practically, with two lines you resolved the web layer of yours Guice based application. 
I come from a symphony background - which I believe is a framework quite close to java in that I've used concepts like ORM, Unit testing, OOPs, Dependency Injection, and have seen various design patterns in action. I am confident of my ability to learn Java but I am trying to learn top of the market stuff to invest my time in if that makes sense. Thanks for your response!
Thanks for the nuanced reply, makes sense!
I think it would be better to add the `children()` method as the OP mentioned. Much nicer for future maintainers.
&gt; I come from a Magento background - which I believe is a framework quite close to java in that I've used concepts like ORM, Unit testing, OOPs, Dependency Injection, and have seen various design patterns in action. Ah, that'll make it a ton easier for you to get started. It's probably all very similar for you then. &gt; I am confident of my ability to learn Java but I am trying to learn top of the market stuff Can't really go wrong with Spring then. It's only direct competition is Java EE and most concepts translate pretty much 1:1. 
[Argumentum ad populum](https://en.wikipedia.org/wiki/Argumentum_ad_populum). Or to invoke Godwin, Hitler was unstoppable at one point, too: which doesn't mean we should all become Nazis.
**Argumentum ad populum** In argumentation theory, an argumentum ad populum (Latin for "argument to the people") is a fallacious argument that concludes that a proposition is true because many or most people believe it: "If many believe so, it is so." This type of argument is known by several names, including appeal to the masses, appeal to belief, appeal to the majority, social justice, appeal to democracy, appeal to popularity, argument by consensus, consensus fallacy, authority of the many, bandwagon fallacy, vox populi, and in Latin as argumentum ad numerum ("appeal to the number"), fickle crowd syndrome, and consensus gentium ("agreement of the clans"). It is also the basis of a number of social phenomena, including communal reinforcement and the bandwagon effect. The Chinese proverb "three men make a tiger" concerns the same idea. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
No, `@BeforeAll` is executed before all tests of the class. From the [documentation](http://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations): &gt; @BeforeAll: Denotes that the annotated method should be executed before all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class;
Why not use Travis for that? 
This breaks easily if someone added a method named `getNodeCopy()` or something similar. If implementations are free and smart enough to choose their own way of storing nodes, they should also be smart enough to know the optimal way of walking them. This just reeks of bad design and reinventing the wheel.
How would I go about doing that? I want Travis to run the benchmarks before and after a commit, on the same VM, for consistency. And then I want it to calculate the difference.
Our devs just startup the db in the gradle script, then shutdown the container after. It's all done automatically
There are many other alternatives: plain JDBC, JdbcTemplate, jOOQ, QueryDSL, MyBatis. If Hibernate were so bad, why do you think it's still so popular? After all, when a project is starting, any data access layer technology could be chosen. 16 years later, Java developers still choose Hibernate because: - it's open source and [very active](https://github.com/hibernate/hibernate-orm/graphs/contributors) - there are over [65k Q&amp;A on StackOverflow](https://stackoverflow.com/questions/tagged/hibernate) - the [Hibernate forum](https://forum.hibernate.org/viewforum.php?f=1) is as active as you wish it to be - the [User Guide is just awesome](http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html) - there are plenty of books available, some [written in the past 2-3 years](http://hibernate.org/orm/books/) You might not like it, but there are millions of Java developers using Hibernate every day. And, where there is demand, there's an offer as well.
You can run arbitrary scripts during the build, so I imagine you could pull the last build, run the benchmark, then run the benchmark on the current build and compare.
Reflection is a sin and we should not celebrate getting quicker at it...
I concur. Instead of adding a method to the interface making the contract explicit he instead made the contract implicit and did it in such a way that allows it to break in all sorts of interesting and unpredictable ways. Not to mention that actually implementing the interface would blow any reflection based implementation out of the water.
Well it definitly has its use cases, like every sin ;) 
Can you not send a few and reuse the data it returns?
That depends. How much traffic is the site experiencing otherwise? What percentage will be just you? How much resource-consuming are your requests? Could your scraping cause problems for other users?
Sure, but in fairness this doesn't sound like a great one.
Oh hell nah. It sounds like something that would better be solved by making some abstract classes implementing the interface for walking the tree in the few different ways there are and extending those further. 
"is this too much"? well, that is a question for the website you are flogging. Are you at least adhering to robots.txt? They are free to ban you at any time without some sort of service level agreement. It might not even be them but whomever is hosting them, and you could push them over a data limit or whatever and then everyone gets an error page. Why not contact them? it sounds shady AF to just start spamming them with requests for your own purposes without any idea if they can handle the load.
There's no "before and after a commit", just the current commit and the commit before. Trigger run the tests each commit and compare. In Jenkins you could run "Post Action" which would execute a script that compares this builds result with the last one and notifies a regression. Travis can mostlikely do the same.
Sorry, didn't get you. The explanation seems fine to me. It's not very detailed e.g. doesn't talk about linked list replaced by a binary tree in Java 8, but it's to the point and leaves scope for follow-up questions. Happy to correct, if you tell me what exactly is wrong. Thanks
You forgot to list Java 8 under Programming languages.
If its not in their api directions or robots.txt then start at 1 request ever 30 seconds and work your way faster until response times dip or you get service errors then back off.
There are a few java http servers. Tomcat is the one I use.
I like the recent Java-on-Java trend. I find it's pretty Hotspot.
Oh ok. So I did the right thing by installing apache tomcat?
Yes, but are you sure you installed tomcat and not just the apache httpd server?
you can use any method as a base of a single class method ?
If you are building a REST API, Spring Boot makes it insanely easy and comes with embedded Tomcat out of the box. Java Brains on Youtube has a good quick start tutorial.
I find this interesting because Sun already did something quite like this over ten years ago. That was the Squawk JVM, which was a Java ME implementation designed for the Sun SPOTs (a design for developing mesh sensor networks, now referred to as the Internet of Things). Clearly, this is different because it's Java SE and is primarily built around the Graal compiler project but they should dust off the Squawk code (if they can find it) and look at what Sun Labs did back then.
Hibernate is unstoppable because it is best at what it does and it will remain unstoppable till something better comes along. Developers only care about the framework which makes their life easy by getting the job done and not what Godwin said. 
Ethereum already took this name for 2017! 😋
1. I've been using it on my current job and I've made a commercial application that is now in production at one national company in my country. It isn't a web application but rather a headless daemon application that periodically grabs and parses logs, and dispatches them to Splunk. Since app is running on a system which is paid by CPU usage we've seen a lot of savings due to vertx being really lightweight and gentle with thread usage (which comes from it's non blocking and async nature). 2. Also used vertx on a raspberrypi (hobby) project. Since I wanted to save as much money as I could, I wanted my application to run on a cheapest raspberry model out there - raspberrypi Zero. To achieve that I picked vertx and I was completely thrilled to see that the framework itself is so powerful but still so light for the hardware. It was communicating with the server through REST services. There are a lot of pros of using it, cons compared to Spring Boot would be that creating REST services is not that straightforward (I'm kind of used to annotations) but still not hard at all. As others have stated It really misses API Doc tools. Good luck!
Call the C or C++ code from your Java build scripts (Ant, Maven, Gradle) as pre-compilation step. Make use of the C/C++ plugins in InteliJ. Alternatively use Netbeans or Eclipse, which support mixed development out of the box, including debugging across languages, because JetBrains still doesn't know how to integrate C and C++ support on InteliJ, https://blog.jetbrains.com/clion/2017/07/clion-2017-3-roadmap/#roadmap
&gt; Every 12-24 hours I would like to send ~3300 HTTP connection requests to a website within the span of around 30 minutes. Is this too much? Probably not. You should ask the owner though, not us. 
no-one cares about your dumb cryptocurrency
:D
Funny thing is now you can get a cheap Android phone for what a Sun Spot cost back then and it has more sensors and networking options (and, craptons more processing power and memory).
So, now the JVM itself will be written in Java? Cool!
No one cares about your dumb jvm dehancement
There was also the Maxine project from Sun Labs which was a full Java SE implementation. Actually, one of Maxine's JIT compiler was the starting point for Graal. One of the engineers working on Graal has worked on the Squawk JVM so they should be able to find the source code ;)
Thank you very much for suggesting spring! I started using it and it actually have terrific documentation for all of projects there. Only thing I cannot yet find something like debug toolbar like in django or symfony. Actually I don't even think there is one... Anyway, Java is really not so frightening. Not that I thought so but devs around me often was jibbering about how java is bloated, slow, hard to code and learn etc etc etc I'm started digging into Java because I already use TypeScript with nodejs and I eager to have even stronger and closed-sourced (for not giving opportunity to play with insides of given modules to build upon) language to work with. Going to build system which has to make many computations every like 5 seconds and I think with nodejs I will just end up with multiple processes, like many processes and in Java I at least will have ability to use threads to make computations, checks and perform tasks (sending email, saving files, making multiple requests to another services) at the same time.
I do.
Sun Labs has become part of Oracle Labs, specially the JVM research people.
I really like the progress this library is making. :)
Given how many people rely on the JVM, I'd beg to differ. 
You cannot *use* JavaEE to create an application unless using an implementation, and any such implementation is a 3rd party framework with respect to Java.
Right, because recent users of JavaEE are singing it's praises? I have more the impression that it's the long-term JavaEE users who have suffered through it for years who now say: "It has quite improved, you know?". To make up for sunk costs.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/unexpectedfactorial] [\[\/r\/Java\]Etherium already took this name for 2017!](https://np.reddit.com/r/unexpectedfactorial/comments/709hzh/rjavaetherium_already_took_this_name_for_2017/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
No, it's not sunk costs. When I started doing JavaEE work, yes, AbstractSingletonFactory whatevers were all the rage, as was putting business logic in XML, injecting dependencies by having them in separate JARs, and that mess. That genuinely isn't the case anymore. To be quite honest, the average JAX-RS or JAX-WS project looks more like a Spring sans JavaEE project than a JavaEE project of old. 
A wrapper on top of JavaEE, like Spring, is a 3rd party framework. An implementation of a JavaEE specification is not.
Hibernate is not Wolverine.
&gt; It's similar to how they program in RPG. They have a concept of subroutines, which are defined in the same file with the rest of the code that looks and works exactly like goto. RPG has had relatively advanced features for handling this stuff (far beyond what you describe here) for at least a couple of decades now. But RPG in one form or another has been around for a long time now and old habits die hard, I guess. One big problem that you'd often run into as you tried to use these new features was that they would be quite buggy or otherwise immature and somewhat painful to use. So you might enthusiastically jump in with both feet, only to get badly burned and revert back to using the old ways. It didn't help that IBM, rather than own up to these deficiencies and work post-haste to correct them, often took a "blame the user" attitude. By the time they finally acknowledged the problems and fixed them the customer might have already lost interest. If the deficiencies were bad enough and had caused enough problems then these features might have even been put on the customer's "verboten" list, and it can be hard to recover from that. RPG as a language and IBM as a vendor certainly aren't unique in this regard. For example, I know of major Java customers which have their own "verboten" lists, based on being badly burned in the past. This is one area where open source has a definite advantage, at least in theory. If there are serious problems then the community can step in to fix them quickly, or even you yourself if you have the skills and the time. You don't necessarily have to wait on a vendor to prioritize the matter and devote resources to it.
3300 requests over 30 minutes is a little under 2/second. You could serve that up with a Raspberry PI, assuming each request doesn't have an insane about of payload. However, is there a way to consolidated requests or the data being sent? Does their API (or are you scraping?) have any bulk operations?
Just use gradle. Stop relying on an IDE as your build tool. Maven, ant is not going to help much but the general idea is that you have a platform independent build tool separate from your editor/IDE. The top three java IDEs all have gradle support builtin to make it easier.
I think you're benchmarking performance, right? In that case, Travis may not give you the desired behaviour as I think you're sharing servers with other customers so performance may vary between (or during) builds.
God, this is just mind-blowingly cool! Hoping to see some results from it sometime
It's not directly used in that project.
You're absolutely right, the Sun SPOTs, great as they were, were far too expensive to be a realistic production choice. Although let's be fair, when the SPOTs first came out there was no such thing as a smart-phone let alone Android or iPhone :-).
Check out the sidebar. This belongs in /r/javahelp 
I was kinda hoping to find something like Travis, but not Travis. Travis is anyway for running tests and deployment, and not for benchmarking.
You could use a simple file sharing service such as Dropbox if you don't want the hassle of version control. It does mean you could overwrite changes so carefully manage who works on what.
It's worth getting to grips with GitHub - it's not that difficult and it would give you some useful experience. As for simultaneous editing of code, if you really want to code [like this](https://www.youtube.com/watch?v=u8qgehH3kEQ), then if you google for "collaborative real time code editor", a few possibilities come up: * https://codeshare.io/ * https://c9.io/ Can't speak for any of them though...
I have found Vert.x to be a joy to work with, it has excellent performance and the library is very well written.
I found using git GUI tools like SourceTree to be very helpful in getting me comfortable with git workflows. I'd recommend taking an existing workflow such as [GitFlow](https://datasift.github.io/gitflow/IntroducingGitFlow.html) and simplifying it for your use case. I can't imagine trying to code even a simple application with a google-doc like "live code editing" app. Embrace the standards, there's a reason they have developed in the way they have over the years.
Do not use Dropbox or anything similar for real-time collaboration with others because you will be overwriting each other's files and losing changes etc.
Impressive to see Rust so high being such a new language. I guess the future is bright and I should start learning it.
Cloud9 is probably the closest to a real-time collaboration IDE you can get, not sure about it's usefulness as a Java IDE though. Generally it's better to stick to proper version control though because the risk of interfering with each other's changes and getting in each other's way is greatly reduced by using a proper workflow.
There is a theory which states that this has already happened.
&gt; We are sorry, but you do not have access to this service. Please contact your domain administrator for access. Page got locked down? 
TL;DR Some advice that used to be important for C/C++ does not always make sense in Java.
it will be interesting now that vert.x AND j2ee are both under the eclipse umbrella, not necessarily in a good way.
Still works for me, try their main page: https://sites.google.com/view/energy-efficiency-languages/home
Sun SPOTs were released in 2007. So lets see what I could get with Java in 2007. https://en.wikipedia.org/wiki/Nokia_N95 Note the part of *Fully HW accelerated 3D (OpenGL ES 1.1, HW accelerated Java 3D)*.
Ya for sure this will ruin Rust. /s What a waste of time comment.
Just found another article of theirs regarding Java collections' energy consumption: http://greenlab.di.uminho.pt/wp-content/uploads/2016/06/greens.pdf
Tl;dr Use Spring Boot with thymleaf mixed with JS which dynamically consums your API. The question Java EE + GWT vs Spring doesn't make much sense. As GWT is a third party Web-View framework which you can use with both Java EE and spring. Whereas Spring and Java EE are full blown application frameworks (dependency injection, DB-access, security and more) which you can usewith whatever View technology you want to (though Java EE has its own View framework called JSF and JSP). So first you have to decide between Java EE and Spring (boot) which is a whole new discussion. For the View layer you can choose between pure HTML with JS for dynamically loading data from your API; writing the frontend in Java with GWT or preferably Vaadin; using a template engine like thymleaf or JSP and maybe combine with some dynamic part in JS data loading; or use JSF which is a mix between a template engine and Vaadin (not recommended). As you implement an API anyway I would go with either pure HTML and JS which consumes your endpoints or use a template engine as well. 
...don't like it... I get confused easily...I don't have the brain power to grok what's being returned if it looks like someone took a shot gun loaded with returns to the code
Because of "energy effectiveness"? What a ridiculous measure for a programming language.
You'd be amazed how important being energy efficient is. For very large applications lower energy costs mean substantial savings and for IOT / phones lower energy costs make the device last longer and the customer happier. 
How is it ridiculous? Green computing is a very large area of research. The difference in hundreds of thousands of dollars in power costs a year for some companies. For someone like Facebook and Google probably more.
For a software as a service company it could mean higher profit.
Why another when we have RestTemplate, OkHttp, Apache, etc already 
I will have you know that the JVM is not dumb : it uses algorithms !
Nice!
Imagine running your software across a large data center, on hundreds of computers, 24 hours a day, 7 days a week, 365 days a year. If on a daily basis your software consumes 10% less energy, that is 10% less energy cost over an entire year, which could mean substantial savings.
Oh, this looks interesting.
you don't need github per-se, you can just use git, or any other scm (cvs, svn). have a shared ssh box with the "master" repository and coordinate coding changes there. Most java ide's will know what to do with it.
It performed 3 times worse than c/c++/rust in energy consumption. It seems like if energy consumption is your thing, Java isn't a great choice but better than the other VMs and surprisingly outdid Go as well. 
Lol
C is such an amazing language
Great little lib. But, given the target audience it does not make sense having it under commercial license.
Keep telling yourself that.
Nice! Been following the Graal/Truffle stuff for a while but since the initial buzz died off I've been paying less and less attention. Very excited to see it being moved closer into the mainstream Java tech incubation process. Thanks for sharing!
&gt; surprisingly outdid Go as well That isn't surprising at all to anyone who's not opted into the weird voluntary learning difficulties of the Go cult.
The biggest takeaway is "Don't use Erlang if you're concerned about power."
You spelled C++ wrong. But I love Java more anyway
I've never bothered with it because I get annoyed that it has no generics. I always hear people raving about how fast it is but I guess that's mostly placebo affect they probably aren't actually timing it. 
If you code in Eclipse, using SVN via Subclipse or one of the other SVN add-ons is really simple and straightforward once you set it up. I haven't set it up personally, so I can't speak that. Like others though, I would recommend learning GIT as it is pretty much the industry standard for new projects.
If energy efficiency is your thing you should probably consider c/c++ or rust first. If energy efficiency is just a nice to have then Java is a strong choice. Consider for example something with a limited battery like a watch, you would last 2 to 3 times longer than Java.
I got maven a while ago and it made third party libraries with java so easy.
Only if your watch was doing intensive computations all day.
For the most part, yes, until you come across some transitive dependencies.. then it can get a bit messy.
Check out Activiti 
Right on an Apple watch the screen most likely dominates the energy usage making an energy efficient language a non priority. Something more efficient like the pebble smartwatches would likely see a big difference had they used Java instead of C
surprised javascript is as high as it is.
My side projects have recently all been things I can use for my company. A better postgresql job scheduling agent: https://github.com/GoSimpleLLC/jpgAgent And a password strength estimation library: https://github.com/GoSimpleLLC/nbvcxz
If you get confused easily by multiple return statements, how do you deal with any combination of the other ways to exit a method/function? Java gives us multiple ways. Returning a value is one. Another is by throwing exceptions. A third is by shutting down the thread or the entire application. 
Check out gradle. I even prefer to use gradle over sbt for some scala projects.
As a former java dev have you tried C# it basically writes the code for you. No getters and setters needed to be generated. 
It depends on the third party with whom you intend to communicate. At my work, I have applications talking to 6 different third parties. Each has specific guidelines for how much we can throw at them simultaneously. Usually, that means throttling requests to 1 every interval of milliseconds. The range differs wildly between these 6 parties: from "hit us with all you've got", to "no more than 1 request every half hour, or else!" If the party with whom your application needs to communicate is a mere website, and not a dedicated web application, you'd do well to keep requests under 2 per minute. But some dedicated web REST API applications have no problem with handling hundreds to thousands of requests per minute. So, as others said: go talk to them and work things out.
I'd be curious to also see "speed of implementing stuff" and "cost to system of normally occurring bugs"; C shines on CPU speed and lightweight, but's slower for time-to-write-the-code, and bugs that normally would have just shot something in the foot kill it and the neighbors instead.
We have Linux servers. I know its not impossible now to run run C# on Linux, but it's not worth it just to avoid getters and setters 
And the garbage collectors
so you're making the rounds over each programming language reddit now? 
With a good IDE and about 5 years of experience you will probably never be shaken by a compilation error. You will have 10x the problems with integration errors though.
A tool that [translates bytecode to C code called ParparVM](https://github.com/codenameone/CodenameOne/tree/master/vm). We use it to support iOS natively with our [cross platform mobile framework](https://github.com/codenameone/CodenameOne) which is pretty cool in itself.
:)
https://gradle.org/gradle-vs-maven-performance/
try lombok. it takescare of getter,settersand quite a bit of boilerplate codes.
actually that's not true - java is also bad at doing nothing there are a bunch of gratuitous wakeups. try running a java process with powertop - it's ugly
C# is my favorite strongly typed language. Just waiting for .NET Core to finish getting established in the Linux world.
obviously a language can't be successful because of this but my (unsaid) feelings were also that it brings a lot of other things to the table as well. But disagree that it is a "ridiculous measure"
That's unfortunate; try opening a bug report. Gratuitous wakeups are a bitch. 
&gt; No getters and setters needed to be generated. Lombok takes care of that in our projects. 
Yeah, C is just thinly abstracted ASM, wouldn't wish being forced to use C upon my worst enemy.
&gt;C# is my favorite strongly typed language. How is C# compared to other strongly typed languages for example Python; got any anecdotal comparisons to share?
If your application shuts down...then you look in your finally... If you throw an exception...you don't have a return value and it's not something you care about I still find single returns neater though
That is interesting. But some of the results don't make sense to me. Particularly between HashMap and LinkedHashMap, and then between HashSet and LinkedHashSet. 
Shocking: statically typed, compiled languages on top of efficiency benchmarks. Scripts are less efficient. More at 11. BTW there's something weird here. TypeScript, which is basically JavaScript with type annotations (which are stripped away after compilation), is listed as a separate language, and with much lower efficiency than JavaScript. That's B.S.
Do you write, for example, a linked list implementation for one project, and then a completely new linked list implementation for a new project? The use of C does not prevent code reuse.
Maybe the transpilation was also a factor. 
Ok.
Not migrating away from it at this point. Maybe in a while. I have automated all of our builds so it's mostly a difference of which button to push.
The fact that C# is strictly typed really makes a lot of diffrence. No weird dictionaries keeping the data - it really does count. And "var" solves verbosity problem.
Okay.
What do you mean by the weird dictionaries part? You mean that variables can easily be used as if it's of an unintended type?
Mwhokay.
Please stop saying "please stop using Hibernate". Thanks!
I saw a lot of production Python projects and the temptation to put data into dictionaries is just too big. You end up with API which depends on dictionary structure that cannot be easily defined. This leads to plethora of problems... Ofc I am not saying that it's impossible to write good Python code, but it's IMHO harder than in C# and Java. After 10 years in Python and PHP I really like strongly, statically typed languages...
A-OK
If it was a factor, then the whole test is nonsense. You compile on one machine then deploy and run countless times on countless machines. No compiler, if weighed properly, would skew the test so much. Furthermore TypeScript is a very nimble compiler for scripts of that size. Literally soft realtime. 
There are other JVM languages that take care of that. Kotlin for instance. It even plays very nicely with existing Java libraries.
&gt; Shocking: statically typed, compiled languages on top of efficiency benchmarks. Scripts are less efficient I don't think that's the whole story, maybe, saying that compiled languages with minimal to no check on runtime are the best. For example, C is not really typed, only looks like it is; and Haskell is statically typed and compiled yet is worse than java.
you don't want to work like in google doc. google doc-like editors are useful only during interviews, when your code is 40 lines long and the other side mainly talks even when you do pair programming, only one person at a time writes code. and then their code is merge with other's people code using scm software. git gained such a popularity for a reason. if you're a programmer, learn it - it'll pay back 
&gt;I saw a lot of production Python projects and the temptation to put data into dictionaries is just too big. You end up with API which depends on dictionary structure that cannot be easily defined. Uuuh wut? Why not only take in a specific type into a "dictionary factory" guaranteeing the input type? Also what's wrong with putting data in dictionaries? Usually you'd do the same in Java as well if there's data you want accessible in O(1) time without creating a bunch of helper classes. &gt;Ofc I am not saying that it's impossible to write good Python code, but it's IMHO harder than in C# and Java. To be honest I thought the same at first, but honestly I find bad Java code to be much more common than bad Python code; much less you can do wrong if you stick to the more popular packages.
In most cases dictionary just replaced something that should've been an object of a given class. Probably it was used only in one place at the beggining and later nobody cared enough to replace dict with some reasonable object...
thanks
Thank you!
Is it *your* company, as in the company you own?
I am very pleased around IBM's work with Eclipse OMR. It is great to see they went another direction than Oracle and tried to fit their JVM into existing languages. 
&gt;In most cases dictionary just replaced something that should've been an object of a given class. Probably it was used only in one place at the beggining and later nobody cared enough to replace dict with some reasonable object... Aaah alright, yeah that's understandable; it gets left in the "TODO" pile forever :D
what this has better than oracle or openjdk?
Can anyone tell me why this JDK has that much importance? I mean as we have Oracle's JDK and OpenJDK and they work pretty well. Why should I go for IBM's JDK? 
Maybe he means the transpilation result. If that differs from optimized JS code for that specific test, then ofc. you get such an outcome.
&gt; Maybe he means the transpilation result. If that differs from optimized JS code for that specific test, then ofc. you get such an outcome. TypeScript, as I noted, is plain JS + type annotations that go away after compilation. The code isn't more complex or even different than what you'd write directly in JS. If the TypeScript result is significantly slower than plain JS, it's an obvious flaw in the test code or methodology.
I don't understand the apathy in this thread. This is an entirely separate Java implementation than openjdk, and will probably handle some workloads better than openjdk, and some worse. The fact that it's now open source means we can start testing it to see where it shines.
I kind of disagree with the `equals` advice, or at least, I have a different idea about it. I think it is better to clearly identify the types of classes you are writing: values, entities or utilities. Depending on the type, you should have a different equality strategy. Value types are data structures, without identity, most likely pure data structures and unencapsulated (or maybe not, i.e. `BigDecimal`). I think it is sensible to always define `equals` (and `hashCode`!) for these kinds of classes, because they are pure values and don't have identity. Since equality is likely fieldwise, you can probably use tools for this (C# value types define equality for you, Lombok has `@Data`, Kotlin has data classes, or Apache commons and [EqualsBuilder](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html)). Utilities are like service classes or classes that act as a namespace for a bunch of static methods. It doesn't make sense to define `equals` at all for these kinds of classes. Entity are special, because they have identity. For the most part, I think it is better to not bother with overriding `equals` for these types, and fall back on reference equality. So, `new` is like giving birth. But then, you have to manage the heap somewhat or let someone manage it for you (like the JPA `EntityManager`). If you have share the object between contexts so that uniqueness in the heap cannot be maintained, then define a *business key* for the object and use that as the equality criteria. The [Hibernate User Guide](http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#mapping-model-pojo-equalshashcode) has goes into detail about this. Although, as per DDD, if you're crossing [bounded contexts](https://martinfowler.com/bliki/BoundedContext.html), you should probably use a DTO instead of directly passing entities.
&gt; I don't think that's the whole story, maybe, saying that compiled languages with minimal to no check on runtime are the best. Statically typed languages means they have less runtime checks. Java is partially dynamically typed. There's reflection and some runtime checks, but many things are compiled away, such as generics. C and C++ are basically static, and they're AOT compiled so no JIT overhead, so they're fastest. None of those bring new insight over what was commonly known, TBH. &gt; For example, C is not really typed, only looks like it is; and Haskell is statically typed and compiled yet is worse than java. "C is not really typed" ... of course it's typed. You mean it's not strongly or soundly typed. But this is entirely irrelevant to a performance discussion. &gt; Haskell is statically typed and compiled yet is worse than java. What drags Haskell down is its lazy evaluation semantics and inability to modify data in-place (save for some limited optimization hacks like TCO etc.). Haskell sacrifices performance at the altar of functional semantics. Java has a similar overhead so it can be garbage collected and partially dynamic. It sacrifices performance at the alter of convenience and higher-level APIs. C doesn't sacrifices nothing for performance, so it's fast.
Yes, co-owner with the other two founders.
Okay, asked because too many devs create things outside hours for a company they don't own, but good to hear that's not your case ;)
Why?
isn't it harder to grok where all the possible places retVal may have been assigned?
I don't get it. What does this do better than openjdk?
It doesn't prevent it, but the ecosystem/lack of proper modules/package mangement makes you regret it. When you do a C project, most of the times you take a minimalistic (as in as few libs as possible) approach because vendoring, upgrading and what not is a pain in the butt.
Erlang was never intended or sold as a solution for rendering Mandelbrot fractals. Erlang exists to connect nodes where the heavy lifting is, in fact, done by none other than C. And C is on top of that benchmark (and most). So the biggest takeaway isn't "Don't use Erlang if you're concerned about power." The biggest Erlang takeaway is "Use Erlang as it was intended to be used."
IBM open sourced its own **JVM**, not **JDK**. It can be used as replacement to Hotspot in OpenJDK. Here's FAQ: https://www.eclipse.org/openj9/oj9_faq.html
If you are ever forced to deploy on WebSphere, this is most likely the jdk you are going to run your code on. There are quite a few differences and quirks with the IBM jdk and being able to run the same jdk locally and actually be able to read the source is a big improvement for me.
If you can't tell.. That was written "tongue-in-cheek". 
Seems very misleading then. 
I don't know if any has changed but: * Packed Objects * Class Sharing, (Reduces JIT I guess for new instances) * Dynamic Heap Size * Better Performance under Power Architecture * Classes are stored in the same heap as the objects * Larger Objects are in a different space than Small Objects
So yeah, it probably means they used idiomatic TypeScript and optimized JavaScript. If the codebase was bigger, the differences between TS and JS would also be bigger, as you programm differently with static typing available. However here it seems to be a flaw in test code indeed.
* A tool for my work. Application that queries several web services and downloads builds from our buildserver/data pipeline * Entity Editor Tool for my RPG game. * World Editor Tool for my RPG Game. * Finally RPG game (PC/MAC/Android/AndroidTV). Currently a work in progress.
Interestingly Java 9 doesn't seem to have had much impact on the JVM / bytecode. Given that they adapted so quickly. I mean module path etc. does also concern the JVM, doesn't it?
game itch.io: https://rayfowler.itch.io/remnants-of-the-precursors dev blog: https://www.RemnantsOfThePrecursors.com