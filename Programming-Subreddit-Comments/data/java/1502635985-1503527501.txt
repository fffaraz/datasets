What part of + **NO TUTORIALS** + **English ONLY** Did you not understand? **Second warning**
**Third warning** + **NO TUTORIALS** + **English ONLY** + **NO SPAMMING**/**NO FLOODING** Next time you will receive a permanent ban.
Since this is help with **Java programming** it should be, as the *plenty hints on the page* indicate, posted in **/r/javahelp**. Please make sure to **read** and **follow** the [Posting Guidelines](https://redd.it/48eykt) there before posting.
Been using Emacs since the 90's as my main. Works quite well.
ah Windows, sorry for that. I had no idea people still used Windows. I understand your pain now. 
Well, I get a new laptop from my company every 3 years but I have to run Windows on this one. I'd prefer Linux, but I'm doing most of the things in my VM. Thanks to Vagrant I can setup my dev environment on any device in 15-20 minutes and I can give it to new colleagues, so I'm fine with this.
Yeah thing is, some upper management guy freaks out when he interviews a guy who uses VIM or EMACS as an IDE, he always goes REMEMBER X, HE USED EMACS AND HE WAS SHIT :-( 
ProGuard or no obfuscation at all.
I wonder if this connects to zero-copy OS primitives on major platforms...
As someone who has had plenty of head banging moments with Java's core I/O libraries, this looks like it could be super useful.
I'm sitting here scratching my head and thinking "why".
that's interesting 
For what it's worth, now you can configure Spring with Kotlin right out of the box. Their project creator on their site gives you an option to add Kotlin. But I see your point about it just being one more thing to think about for sure. 
I mean, it is because of competition. There are many languages I'd pick over Java at this point if I had my pick of the litter. Java is still on top and will be for quite some time, but its competition will eventually overtake it. 
As soon as I see C# anywhere in the upper sections of Techempower or equivalent I'll pay attention. Right now it's equivalent to python, or Ruby performance-wise. 
&gt;and is fast Ahh, [the Max Power way.](https://www.youtube.com/watch?v=7P0JM3h7IQk) final Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put("key", 1); final Optional&lt;Map.Entry&lt;String, Integer&gt;&gt; opt = map.entrySet().stream().filter(e -&gt; e.getKey().equals("key")).findFirst(); LOG.info("Value is: {}", opt.get().getValue()); map.put("key", 2); LOG.info("Value is: {}", opt.get().getValue()); &gt;Value is 1 &gt;Value is 2 Can Optional&lt;Optional&lt;String&gt;&gt; do that? I guess you showed me! How will I ever recover?
nothing at all. obfuscation will only cause pain for everyone in most cases :/
[No.](http://hg.openjdk.java.net/jdk9/dev/jdk/file/65464a307408/src/java.base/share/classes/java/io/InputStream.java#l518) [FileChannel.transferFrom/transferTo](http://hg.openjdk.java.net/jdk9/dev/jdk/file/65464a307408/src/java.base/share/classes/java/nio/channels/FileChannel.java#l581) do offer this functionality.
Yeah I know what you meant :) but what kind of competition are we talking about? language syntax? eco-system? cloud computing? because everytime I see such trends I don't understand if the top language is a sort of perfect language to do anything we want, or it's just because of legacy? One day maybe we will see another language on the top, but the rates through the index are going to be smaller and smaller in order to be almost all the same - in the first ten at least (hypothetically speaking of course). And then we don't care about it anymore. 
Language syntax, I think. Ecosystem, nobody has the JVM best. That's why I have such faith in Kotlin and think it's on a path to quickly become the top alt JVM language, and one day overtake Java itself. It can do what Scala couldn't because it's lightweight, simple, and explicit. The JVM in general is gonna be dominant for a long, long, long time, though. The other language I have a lot of faith in is Rust. It's been a long time that we've been waiting for a good C++ competitor Go is a joke in my opinion. The library system for it and the lack of any modern language features sucks. Rust has a rich ecosystem, a fantastic build system, and insane safety and performance. It can cover pretty much any scenario that JVM/Kotlin can't in terms of performance. 
to be honest i don't fully get the task. Can you describe the main steps, like: 1. need to fire sql query to grab data from source db 2. fire sql query to grab data from target db 3. compare rownums of both queries 
I'll give it a try, thanks.
I think the same about JVM and Kotlin, I do hope for the best for JetBrains lang, it's so straightforward and just too good for Java developers who want switch JVM lang. I just started with Rust, I like it! much more than Go :)
That's it for the most part, except step 1 is very complex in many cases. The sql to reproduce the ETL is hundreds to thousands of lines using temporary/volatile tables due to the high volume (billions of rows of transactional data). This is ok as a one-off, but I would like to build something that can be used in other similar situations. On top of that I want verbose logging and traceability, things I won't get with straight sql
Even oracle doesn't use obfuscation in Coherence. It's not worth it.
&gt; Currently building software on top of their ide netbeans-as-a-platform is very different than netbeans-the-ide, in spite of the fact that they share code. don't compare apples and oranges
That's a little disappointing.
None. Security by obscurity is always wrong. In fact if you look at several major companies, their client sofware is fully open source (and only the back-end is proprietary)
https://www.infoq.com/news/2017/08/Java-Still-One-Tiobe
deleted ^^^^^^^^^^^^^^^^0.6221 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/96891)
I agree. I wish there were some way for businesses to accurately post their percentages of various technologies/languages used to help give a more accurate picture. People are curious though and we like to have some idea of what's going on, so I don't think there's much way around folks grabbing at the bits of data that exist until more reliable data is available.
There's nowhere for languages to go. Sure the front end developers will try and make us write everything in interpreted typeless emoji code but really we've got everything we could ever need and only syntax changes are possible.
That doesn't sound like someone who should be interviewing tech people. IDE's don't make good or bad developers, though I have seen IDEs that do *too much* for the developers and then when they need to do a headless command line build they freak out.
None. It's not worth it. Have the business and legal side of your organization write up a proper contract with clear language about damages if your client decides to decompile or evade the terms of the agreement. This is what companies like Oracle or Microsoft do... and is one of the reasons why an Oracle or Microsoft license audit is serious... because the penalties can be very stiff.
&gt; I have to keep and eye not to have too many chrome tabs open (usually when I reach about 10 I begin to close the unused ones). You can use a Chrome plugin to automatically suspend inactive tabs after a certain amount of time 
Also, scala not being backwards compatible. That's a complete nogo for corpo. 
I read their methodology and was not impressed.
no doubt, it's pretty simple and could be improved. That said I know of no other set of benchmarks which are this complete WRT number of different languages and frameworks. 
Extremely sensible! I've needed to do this often enough that I wrote a utility method for it.
shitpost
Yep, mentions JavaFX UI's but doesn't mention Google's material design.
It's a pity they couldn't just make it return a future. I guess you just have to wrap it yourself.
I'm guessing your utility method closed once the input stream was empty. This blocks until interrupted or closed by another thread. This is still useful, but in a different way, that is, if my assumption about your utility method is correct. 
Be contextual. And duh material design was mentioned and only because this is a Java community i.e the reason behind the title. CBYP - And those were examples - the vids.üòé.
It was simply this: /** * Pipes in to out until EOF, using a small temporary buffer. Does not close * either stream. * * @param in stream to read from * @param out stream to write to */ public static void pipe(InputStream in, OutputStream out) throws IOException { Objects.requireNonNull(out); byte[] buffer = new byte[8192]; for (;;) { int n = in.read(buffer); if (n &lt; 0) break; out.write(buffer, 0, n); } }
Java Environment Setup, Java Program Structure, Syntax Rules, and Java Sample Program. Writing a Java Program in Eclipse IDE using maximum Java programming features like Comments, Variables, Constants, Operators, Control Flow Statements, and User defined Methods. Core Java Programming or Code Examples with Conditions, Loops, and Methods etc...
Yeah... And, in the event that the try/catch is undesirable (streams maybe?), you can write this yourself as a static method in about 10 lines.
I work in a similar environment as a DBA supporting a team of Java developers. We process something like 80gb a day of new data. Not as much as some places, but it all has to be tracked and available for logging under certain conditions. Send me a PM and I'll go over some of the basics of what we do to handle our ETL jobs.
Most pairs of InputStream and OutputStream are not suitable candidates for this, especially since new streams can be easily implemented by the programmer. So while possible to special case, it's not worth the effort as everyone will be asking for more optimized pairs which will only work for select pairs and not any custom streams. I can quickly think of optimizable pairs like: * ByteArrayInputStream and ByteArrayOutputStream (internal array reference copy) * Some file and a socket (via sendfile)
EOF is different from an empty stream.
I don't see anything new. This looks like an alternative to PipedInputStream / PipedOutputStream.
1. Java 9 hasn't been released and is still in beta, this is probably a bug. 2. Did you submit a bug to the appropriate bug tracker?
Using less RAM isn't more performant, it's being more efficient.
&gt; It would be sad if Java was #1 forever because that would fundamentally mean software programming languages stopped evolving. Or that Java is constantly evolving too and provides more to business than any other ecosystem can?
They have to run on something, you know.
&gt; Kotlin Maybe. &gt; Python, even Javascript Never.
**Sidebar** -&gt; **Do not post tutorials here!**
**Sidebar** -&gt; **No surveys, no job offers!**
Thanks for sharing the link..its helpful..
for example AWS Lambda ;)
**Sidebar** -&gt; **Do not post tutorials here!**
**Sidebar** -&gt; **Do not post tutorials here!**
Getting rid of primitive types would cause the same serious performance problems that Python has when dealing with numeric data. It would necessitate a C-based array library built with JNI similar to NumPy, so I'd rather have the Java primitive types than the alternative.
Anyone has experience with JavaFX on android?
Good read - only alteration I'd suggest is that the TL;DR should mention that this only affects applications which are set to use client side state saving, which isn't that surprising, but would still give some indication early on that it's not a problem with the default settings.
The reason why Python is still "becoming" popular is that many new comers keep discovering it. E.g. mathematicians who want to get into data science learn Python and like it, or web frontend developers (who knew some Javascript) find Python and it looks great to them. Everyone has heard of Java and C++, but when they see and hear Python in action, they are usually amazed and create fluff on the Internet (which is why you shouldn't trust the Internet's popular wisdom). 
OP here. I agree the tl;dr isn't perfect. But: Unfortunately MyFaces always deserializes the ViewState as Java object (even when the state is stored on the server)! Mojarra uses a normal ID.
I'm a big fan of JNLP and Web Start; I use it to deploy software to my services teams who have to do field work. I've headed down this road a few times - code signing certs are, at their core, about making you (the code publisher) identifiable (and to a lesser extent beholden) to the CA, and by extension the user. It was not so long ago that site certs were every bit as expensive as code signing certs. On the upside, cheap site certs like letsencrypt are increasingly becoming a thing, so it's possible that we might see something similar happen... someday. For now, you're probably going to have to pony up that hundred bucks.
Another option is to use Java Native Packaging and have a download link to an installer. 
&gt; CBYP Cincinnati Bell Yellow Pages?
I haven't met a single Java developer who hasn't written a utility method for this (or used Apache Commons IO or similar).
if any, Kotlin has a higher chance 
Good points, thanks. :)
I would have lost my mind last year without Apache Commons.
ZKM (Zelix KlassMaster). The configuration script "language" is rather confusing, the obfuscator/obfuscated code is pretty solid though.
The read me explains in the first paragraph why this is useful. The text of the readme is displayed right there when you click the link. 
Nice to see some PhD thesis posted on reddit 
Very neat, starred and will share this at work. Ironically someone sarcastically asked me if there was a Java API to write Java. Lol
Using Java serialisation for this is a design flaw in the first place. It does not matter whether the view state is encrypted. JSF should standardise rules for serialisation that require a format that can be verified (like all sane programmers do for a normal form validation). **NEVER** trust the client, ever! Good read!
Does Jake Wharton ever sleep?
I'd explored this option, but in the end it can be almost as tricky as JNLP, with less functionality. You still have to sign your packages or Windows will throw up a nasty "unknown publisher" screen when the user launches the installer or package... and you lose JNLP's update functionality. On my project, we have code signing baked right into our CI system, so we can do a one-button deployment of our product to production, and *all* of our installed instances get updated on their next invocation. That's a huge time-saver.
After I learned Kotlin, I've only had to write Java a few times at my job, and it only ever reinforces that "better version of Java" idea.
I think I may write a Clojure wrapper.... I wanted to write a language, I wanted to use Clojure, I wanted to generate JVM bytecode, this isn't that but it's only one step away I guess.
&gt; Methods generating methods! And since JavaPoet generates source instead of bytecode, you can read through it to make sure it's right. That is an advantage - during development and testing. For production usage a shortcut to bytecode would still be nice.
I've used JavaPoet to generate Java source from data models defined in Clojure - it works really well. The best feature is the ability to specify type parameters and have JavaPoet automagically generate the correct imports - saves so much time as opposed to more na√Øve code generators.
Oh wow, I hadn't clocked it was being quite that insecure in its behaviour!
Stop shouting and stop spamming.
`com.sun.codemodel : codemodel` has existed for a long while. Java Poet looks like a friendlier API but I'm not necessarily convinced it's worth the ground up reimplementation. https://sookocheff.com/post/java/generating-java-with-jcodemodel/ EDIT: Oh, Java Poet is actually way less powerful because for actual implementation it uses Strings. That's kind of disappointing.
All good points, but very subjective. I have released a number of applications to various types of end users using both methods, and each has their merits. There's a lot to consider. :)
any idea how does this work: the license says "Square, Inc." while Jake's profile says he is at Google, Inc.
He was at Square before.
Fair enough. You can't do an offline install of a JNLP app. The "N" counts.
There are already lots of code generator libraries out there. How is this different? This also is not very enlightening https://github.com/square/javapoet/issues/221
Don't write that kind of code. Just use a library that was built for it: https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html 
that's correct , people started using library and they don't have any idea how that was implemented. this post is a chance to people understand the core implementation.
No. https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines
**Betteridge's law of headlines** Betteridge's law of headlines is one name for an adage that states: "Any headline that ends in a question mark can be answered by the word no." It is named after Ian Betteridge, a British technology journalist, although the principle is much older. As with similar "laws" (e.g., Murphy's law), it is intended as a humorous adage rather than the literal truth. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
WTF - get rid of this post.
He went to Google recently
Sorry but that absurd amount of OO boilerplate is expected in most Java contexts. It's a joke, Java, yes. 
**Sidebar** -&gt; **Do not post tutorials here!**
Am i the first one to see the mistake in the multiply example? :D
Coming from someone who doesn't know [what CORS is](https://www.reddit.com/r/AskProgramming/comments/6tjvwt/corssame_origin_policy_for_rest_apis_called/dlleldf/) that is rather hard to take seriously. Yeah, "oops" for posting a newbie question on your trolling alt I guess. Bye bye!
Relevant xkcd's: [tools](https://xkcd.com/1629/) [automation](https://xkcd.com/1319/)
production data movement, data cleaning, processing, profiling, machine learning, automated integrations. 
None, and at least for the groups I've contracted with, it's explicit that the source code will be provided. I don't trust any company that doesn't give the source to the modules I'm importing. It's 2017, I don't have time for this BS. 
"omg java is too verbose!!!" "wtf why do i have to type the variable name twice?!" 
it's been long enough. lombok is here to stay. and nearly every ide allows you to apply the lombok changes to your source code. embrace the lombok! 
What do you think happens when you put a @Transactional annotation on your method? Or a @Accept("application/json")? Do you really think there's no code doing anything with that? And how do you think they accomplish it? Bytecode manipulation. 
Then go to /r/kotlin and leave it alone here. Why are you so insistent on being "that guy" here? 
how about you go to a more enlightened sub like /r/golang or /r/python and just start telling them about how kotlin solves all their problems. 
only if you aren't used to your toolset. "this is just excessive".pl&lt;tab&gt; gets converted to your first line. It's really not that hard. 
I sure hope java9 doesn't "solve" this, because "this" is an issue that is solved with proper segmentation of code. 
How? If you depend on two different libraries that also depend on the same library but different versions of it.
Job interviews, mostly
Well, I guess not. Java tend to get a bit complex sometimes and it makes it hard using it. Not sure how long it's gonna stick around. There are programs that helps detect errors, such as checkamrx and others but it's too much sometimes.
I built a few desktop applications using JavaFX since I dislike JS and figured this was easier than fighting with gtk or some other C-based toolkit
Amen !
I built my current project with it and this was exactly what I needed. I have given ini files and wanted to make them availabe in java but not ceate every file manually. Now I have a neat little generator that takes the interfaces that specify the structue and creates not only the data classes but also all the parsers. Every time I get more insight about the ini files I just have to update the interface and everything is regenerated accordingly. The first few steps were a bit confusing but the examples show all basic usecases and right after I found the api straight forward.
Desktop software. JavaFX is good for this but holy shit does it ever suck when you run into things that the toolkits don't provide intuitively.
Why so angry?
Research. I'm a RA in evolutionary computation. I'd been coding in Java over a decade and never touched EE/web/mobile. Universities often use Java, even at research/post-doc because everyone coming in knows Java from undergrad (other stuff is used too though, like Python, MATLAB, R, etc.)
Swing and backend batch processing. Looking to move to JavaFX though..
Because it's the right tool for the job. Why are you so insistent on being a Luddite? There are tons of people who haven't even heard of Kotlin who would agree that it alleviates most of the pain points of Java. What a close minded attitude you have, that we can't talk about other JVM languages here and their advantages without old Java geezers getting their pitchforks out. 
[removed]
What platform are you running this on? Most Linux and UNIX hosts have the JRE available as a package which you can install using the package manager.
Compilers and interpreters.
I develop agent-based computer models for epidemiological research. I'm not a scientist, I take the descriptions of how the model is supposed to work from the M.D., Ph.D.s and turn it into working code. 
in some sense, possibly in terms of space. not necessarily time, though.
You can actually read the source!
Why don't you just open the source code?
[Link for the lazy](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/String.java#String.split%28java.lang.String%29)
Good API, but can anyone care to explain any practical scenarios where this API can be useful?
I think you've confused your API tastes with the feature set of the library. I'd love to see an example of less power.
But we have javac for that. Why bother going to bytecode?
Okay but is it worth learning ? Couple month ago I got into java without really thinking about looking up other langages and I really like it. But I often hear very good things about Python. My end game is backend/desktop. I don't care for Web or mobile. So, python ? 
There are many uses of Java. Zookeeper is written in Java, for instance. The company [Cinnober](www.cinnober.com) implements their trading software in Java. [Satalia](www.satalia.com) implements their SolveEngine in Java etc.
Hard to make a recommendation without a specific goal. How about "advanced" basics such as Guava and Apache Commons? Since Java doesn't live in a vacuum, learn how to integrate it with a data layer or webservice. JDBC, Spring, Netty. Use the AWS SDK and integrate with various AWS services. Maybe start with S3 and DynamoDB. Create a Lambda using Java8. 
This plugin is excelent. I've used it for creating restapi-codegen-maven-plugin -&gt; https://github.com/jansoren/restapi-codegen-maven-plugin
yes everyone is and was using codemodel... It was part of JDK till 8th but in 9 it wont be and there are few forks (which are not 100% backward compatible with pre java 8.) Currently we use: &lt;groupId&gt;com.helger&lt;/groupId&gt; &lt;artifactId&gt;jcodemodel&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt;
Minecraft
Because * You would still have to manage loading and unloading (depending on how dynamic the code is) the generated bytecode. * You create additional and unnecessary IO to disk which has its own risks (disk full, other IO errors) * It's slower (because of the additional IO). Btw. there is a [ton of these libraries](http://java-source.net/open-source/bytecode-libraries) around already.
As the others said: look at the source code. Plus: next time, please follow the plenty hints on this page and post programming related questions in **/r/javahelp**.
I used to work for a company that made test tools that connected to specialist hardware. It was all Java Swing.
Do you use a framework for agent based models?
JDBC. Gotta talk to the database sometime, and it's better to have used the basics before moving on to data frameworks
What did you actually build with this knowledge? Also: /r/javahelp is more suitable for these types of questions.
same in Software Engineering research (SER). I do not have hard data to backup it up, but in my experience I would say that 80%-90% of all tools in SER are written in Java, where the rest is C (with some sporadic C#). Then of course there is Python/R to analyze the data of the experiments, but that is a different story...
Ok, maybe not less power (possibly more power because of the freedom), but less structure. CodeModel gets you closer to a tool that matches the grammar of the language your composing - i.e. closer to a guarantee your generated code will compile.
Let's say your project uses a DSL for specific endpoint. You want to generate specific classes based on what ever custom validation/constraints you've defined in each of your DSL's so that you can write code/tests against your DSL. This gives you dynamic classes, so you only have to change the configuration in your DSL/specification and it will automatically regenerate and compile your classes so you don't have to change your .java files every time there is some kind of scope/change.
I can only give you my experience, which may or may not be applicable to anyone else in the world but here it is: * If you plan to do backend development where you are the only developer, or you just need to accomplish some easy things quickly (e.g. scraping, data processing, etc.) use Python with which you can quickly develop your own idiosyncratic project organization * If you plan to work on applications with a number of other developers - Java is a better bet. Java's frameworks and best practices push you towards more standardized code organization. * For desktop - decide which desktop you want to target. Windows is best served with C#, while Apple dictates Objective-C or Swift. In a way - always compare frameworks first and languages second. So, e.g. if Spring or EE appeal to you - your decision has been made for you. 
[removed]
Which framework do you use? ECJ?
Yep sure. Next time. Thxs
50 MB overhead. yayyyyyyyy
Does "Big Data" count as "enterprise"? If not, I am doing that.
How in the hell do you program (for real) on a phone keyboard?
You didn't answer my question.
I have been writing Java since 2000. I have been subscribed to this subreddit for 3+ years. To paraphrase a catch phrase of the school administrator on the 1980's Nickelodeon show called "You Can't Do That on TV": "Where does the Universities get these programmers, and why do they keep sending them to me?"
Your "java code" doesn't even compile because you seem to have auto-corrected first words to have capitals. Get a blog that can actually format code properly. Also what does your blog have to do with architecture? It's a really short bit about very basic OO principles.
Stop spamming.
Just because I'm on vacation in another country! At home, of course I would use my PC.
It's the path to becoming an architect, so I figure we'll have these posts for about 7-10 years before the author becomes an architect. 
Yeah...No.
**Sidebar** -&gt; **Do not post tutorials here!** Also: You are to be classified as **spammer** according to the **reddit rules** [**What constitutes spam? Am I a spammer?**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer) They state **verbatim**: + If you flood a Reddit community with posts or comments, you may be considered a spammer. Instead, post one or two times and see what happens. + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer. Both of the above apply to you, so you are a **spammer**. **This is your first and last warning** upon the next post you will be permanently banned.
I usually use a bluetooth keyboard in order to maximize screen space on my device.
A brand-new [text user interface](https://github.com/klamonte/jexer) that runs on both real xterm and as a Swing UI. 
Sorry. I made 3 projects A file renaming/sorting tool A txt to srt (subtitles file) with live preview. A versionning tool (sort of super simple git) that saves projects. 
Right. And that was a design decision we explicitly made. You always run javac after using JavaPoet (or sometimes you're already inside javac) so it becomes redundant and very restrictive to try and enforce something in the API.
I think you're confusing runtime generation libraries with compile-time ones. This is the latter, used for code generation tools or annotation processors where generating Java is vastly superior to bytecode in this situation.
this interesting, but I'll stick to ssh/vnc-ing to my home development box, from my phone if necessary, otherwise I'll be on vacation.
That's a mild inconvenience, not one of the serious problems.
Could you give some examples of the sucky parts?
This post gave me AIDEs
Oh I know that those are generally implemented by generating bytecode. I'm not against bytecode generation, the vital difference to me is that in your examples, the generated bytecode implements an API rather than forming part of it. When Lombok adds code to a class I've written, everybody needs to be aware of that. As a code reader/API consumer, I need to know that: * I can access a private field despite the lack of setters/getters, * I can use a class as a map key, I can effectively test for equality despite the lack of equals and hashcode. Basically, I feel like lombok sacrifices readability and usability of code for the sake of development speed. To me, that's an unacceptable trade off. These are reasons I don't like Lombok. I can certainly understand people who do like it. For what it's worth, I'm a big fan of Groovy and Kotlin, which basically implement Lombok features as part of the language. In my opinion, that's where these features belong, in a language, not in a library and compiler extension.
What part of my [**warning**](https://www.reddit.com/r/java/comments/6tu7dy/java_architect_journey_curious_to_write_code_in/dlni82x/) in your [last post](https://redd.it/6tu7dy) have you not understood? **Banned for rule violation (NO TUTORIALS) and spamming**
Maybe. But I haven't seen any indication that JavaPoet is intended for compile time usage only. I thought it makes more sense to have such a library implemented in Java when using it at runtime in a Java program. Based on the verbosity of the code I'd probably resort to other tools for compile time code generation (e.g. Ruby with ERB) or another template engine ([Velocity](https://velocity.apache.org/) comes to mind). Granted, those don't do the kind of type checks that JavePoet can do - "But we have javac for that". ;-)
That's been in flux the last year or so. We used to use AnyLogic. This is a choice that was made by people with Ph.Ds in Epi and Statistics, not software developers. They found it easier to work with than other options, because it's visual, and they can get a long way down the track to a model without having to really code. I took over several of their models when I came on, and found about what you would expect. Spaghetti code, no adherence to convention, no awareness of of the things that are in the core libraries... wheel re-invention on a truly epic scale. I spent quite some time refactoring and rebuilding in AnyLogic. Since then, AnyLogic seems to have moving in a more logistics, road &amp; rail, crowd control direction. Also, a key issue with AnyLogic is the business model; it's a closed source, proprietary framework. It runs on the machine it's licensed on and that's it. This particularly sucks when you have a large, multi-dimensional experimental parameter space and a hi-fi, long-running model iteration. I have 24 cores on my experiment-running rig, and I've had to tell the PI it was going to take weeks to see the results. You can't share the source with peer review very easily. Finally, it's so fucking expensive. So. Fucking. Expensive! We're moving to Repast. You get a lot less developer-time support from the IDE. You're coding much more of your stuff from scratch. It's much harder to show a visualization at runtime (which is useful for sniff-testing calibration). But the agents are just POJOs, that live inside containers that extend Repast's DefaultContext, so there's no wondering about what code has been generated underneath a GUI IDE. We'll use Repast's network and spatial projection infrastructure. It's FOSS, so when it comes time to run an experiment, I can distribute binaries to anyone with a computer that's not being utilized, and we can all be running iterations at once. We can put it under git, which we couldn't do with AnyLogic (no version control at all, except at the "pro" price point). And, if we want to, we can point peer reviewers, or studies who want to try to replicate our results to the git repo. It's plain old Java, so it's easy to find engineers who can then be brought up to speed quickly on the framework. The other thing that pushed us toward Repast was that there's a C++ version for high-performance computing clusters. We can learn how Repast works in Java. Later, if we want to, all we'll have to do is learn C++ or hire someone who knows it and we can move onto the University's HCP cluster. 
The big advantage JavaPoet gives you over that approach (which is the one from where the library was born) is a model which does two main things: manages imports automatically so that you never refer to two things with the same name via import and re-order the generated members so that you don't have to create the resulting code linearly.
Wow thanks for the detailed overview. I have only used JADE for a bachelor thesis, hence the reason I asked. It is written completely in Java and there is a GUI for the administration of the Agents which you build in Java again. I dont know whether it helps in your line of work.
You know, there comes a point where you have to make a platform decision and then just hold the fucking line. I'm tempted, sometimes to look around at quick prototyping in Python's MESA library. I'm constantly having to remind myself to not change horses in the middle of the stream. 
This is very good EE server! üëç
Great lib! So many memories from turbo C :). Do you see some return of TUI nowadays? I ask this because I see so many potential for niche apps. I'm a huge fan of mc, midnight commander, for instance. Sometimes I miss some apps for log monitoring, simple IDE/debugger for java and REST devel,, a TUI for tmux (menu, panes ,etc) could be awesome! Your lib is definitively inspiring, keep up the good work! 
Probably. I am moderately OK with Java and have a rough understanding of Python, enough to tell yuou they have a lot of differences. Both are object oriented but if you have no coding experience It's probably best to only learn one at a time. I have been doing Java programming off and on for a few years and I still find myself slipping up and trying to use Python syntax in Java, or the other way around, sometimes. Java has more use and is more in demand while Python is more powerful and easier to use. Pick one based off your career goals and learn others later.
I would suggest starting with python. The syntax is cleaner, and my intuition is that as you scale up the complexity of what you're trying to do, python will be less likely to cause weird complications. Also using 'pip' to get third-party libraries is super simple, and you won't be tempted to get too much into the weeds on things like maven (at least early on).
Point of Sale and Retail Systems
It's complicated. It's best to just look at the source code. Most IDE's should allow you to do this. There are also a number of websites that you can browser the source code with, or you can just look at the source in the JDK (look for src.zip). Here's the source from 1.8.121: public String[] split(String regex, int limit) { /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters ".$|()[{^?*+\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 &amp;&amp; ".$|()[{^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) { int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) { if (!limited || list.size() &lt; limit - 1) { list.add(substring(off, next)); off = next + 1; } else { // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; } } // If no match was found, return this if (off == 0) return new String[]{this}; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) { while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) { resultSize--; } } String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); } return Pattern.compile(regex).split(this, limit); }
They're both intro classes so it shouldn't be that hard depending on the rest of your schedule. I'm sure you have the capability to learn two new things at the same time.
Mattermost is a very valid Slack alternative which can be installed on premise. SaaS doesn't work well for chat/communication platforms in certain regulated industries. Best of all it's open source and free with the option of switching to a commercial tier if you need certain HA or sign-on integration. The mobile client sucked for quite a time but it has come a long way since. They release every 16th of the month, so hang on there tomorrow for a new announcement.
**INSUFFICIENT DATA FOR MEANINGFUL ANSWER.**
Thanks for that post. Would be great if you could insert some pictures, especially if you explain the way to find memory leaks in a specific program. However keep up the work! 
Such a sad, pathetic post filled with excessive self loathing 
Oh wow, what a funky conversation :)
 Use Bytebuddy then
 Nice. Mostly, I prefer string-template based approaches, most specifically [Xtend](https://eclipse.org/xtend/documentation/203_xtend_expressions.html#templates), though. It seems that sticking to text-based code generation allows for much more flexibility with all sorts of edge-cases.
Games (LibGDX), any small scripts, desktop programs / simulations.
Anyone have some info on the major changes in 4.0?
Well my business' application is written using Vaadin, so that ticks both the enterprise and web checkboxes. But I also write other utilities and tools in Java. I've written a [password strength library](https://github.com/GoSimpleLLC/nbvcxz), an alternative implementation with way more features of [pgAgent](https://github.com/GoSimpleLLC/jpgAgent), a web scraper utility to gather a bunch of not easily accessible data. In a previous life I used to work on the L2J Lineage2 server emulator.
HTTP 2
Right now I am doing more theoretical work, like landscape analysis, but I have used ECJ in the past. Also messed with others like Watchmaker Framework.
TL;DR 10/10
1. ChromeOS uses Linux so you can't run anything for Windows. 2. I don't think you can run custom executables on ChromeOS but I might be wrong.
But what's the advantage of writing anything in code given that argument? I mean you could just write the entire file as a series of strings. You want something that you know before generation-compile time will compile. JavaPoet doesn't give you that. CodeModel does. I feel like a halfway house like JavaPoet is the worst of both worlds. Simultaneously you provide no guarantee it will compile and you provide only a small amount of freedom. I mean the downside of CodeModel (apart from the license) is that the API is very ugly. You still have that in JavaPoet, just slightly less, partially because of improved API design since it was developed and partially because you just don't implement the statement syntax.
The BlueJ "other installation" download wasn't meant for a specified platform, so I dunno
Strings don't give you much. The two main advantages are automatic imports and non-linear emission. We used to do strings and we tried things with equally gross full-model APIs. They're both really bad development experience. I've built at 8 code generators this far and JavaPoet is by far enabled the best experience. Try it. I think you'll like it. And if you don't, well, frankly we don't care. There are multiple tools for a reason.
because trying to obfuscate your code means 1 of 2 things: (1) your code is doing something evil or bad, and you're trying to hide it, or (2) you somehow think that obfuscating your code will result in some level of protection against prying eyes If (1), you're an asshole. If (2), you're... dumb. 
You could do it, both have different paradigms but they aren't complete polar opposites. Number One rule I can give you if you want to work with both, use the recommended style guidelines for each language, for me anyways this sets me in a different mindset, but if you can I would pick one and see if there is an SQL centric course
Constructor injection into servlets, filters, tags, listeners yet? For components from a more primordial container or context?
Similar free project, enunciate, can generate api documentation from your Jax-rs project. It recognizes most of your Jackson json serialization rules. It also can generate clients in JavaScript, Java, c# and a few others, though I've never tried using them. You can set up your build to publish the generated docs and clients packaged in your web application, and even deploy the Java client artifacts when you deploy to a maven repo. It's honestly a really great tool. https://github.com/stoicflame/enunciate/
&gt; (and first zero-comment ballot) Because nobody cares. ^^^^^^/s
What if, after heat death of universe, god chooses Java to write next version of universe?
You can probably handle it but it would be wiser to learn one and then learn the other later. You'll have a greater appreciation for the differences and far less cognitive cross-talk in terms of fixing problems. It isn't quite the same but imagine learning 2 musical instruments simultaneously (without a musical background), compared to learning one to an intermediate level, and then the other. Easy call, IMHO.
its broken
Take a look at openjdk, this is exactly what they did. 
if it's open source compatible with the openjdk you're fine
You have to pass JCK test which is not public and owned by oracle then you can use Java trademark. AFAIK you have to pay for Oracle to have access to JCK
What about Gluon VM is it licensed? 
You can claim compatibility, but you cannot call it Java. That requires passing the Java Technology Compatibility tests and paying a license fee to use the trademark. The Technology Compatibility Kit can be used for free only on software that is principally derived from the OpenJDK. Testing JVMs derived from other software requires payment. 
Correct. We have our [own VM](https://github.com/codenameone/CodenameOne/tree/master/vm) but we are careful not to use even a moderate term like "JVM". That's exactly why the term OpenJDK was invented. It's a "free term" that doesn't violate Sun/Oracle IP and a person can use that if he has a fork and doesn't have liability. But he can't call that fork Java. The term Java as you mentioned is proprietary and expensive to purchase. The same is true for the coffee cup symbol of Java which is also protected by IP. Duke specifically is free. Another legal alternative is to give your VM a different name and say you run Java bytecodes. Notice you might be on shaky grounds if you claim "Java compatible". 
fixed...
have you changed the algorithms? Ie, is the C# program doing less, with a more efficient algorithm?
I'm mostly surprised here that Duke is BSD licensed.
States which version of core is used. Doesn't state which version of java is used. So imma assume it's Java 1.2...
The article mentions Java 6 (1.6). Changes nothing on the Java side, undermines the results entirely by employing task parallelism, and still gets a 3x slower regex implementation. Bummer.
No it doesn't. It mentions the score. Java won 6 time while dotnet won 4. If you click the benchmark link however, you'll find out it's Java 8.
&gt; When I first saw the C# .Net Core vs Java benchmarks the score was .Net Core 2.0 4 - Java 6. If you are thinking about the line I've quoted above then the '6' is a score and not a version.
Wasn't this also what the Dalvik Virtual Machine did for Android,which brought a shitload of lawsuits that ended up with Google winning? EDIT: Hey, thanks for the downvotes for asking. 
No, Dalvik was not a JVM, but rather a totally different technology. Java code compiled for Dalvik can not run on the JVM, nor can JVM binaries run on Dalvik. 
No, not even close. OpenJDK compatibility doesn't get you past the trademark and patent hurdles that Oracle has put up in the past.
No, in this case it was claimed that a developer specifically copied some code directly from sun's jvm . This you cannot do this since source code is copy right protected. The OP said he wrote his own jvm, not copied oracle's code. Openjdk is written from scratch without copying any of the jvm code. 
Java have much better parallel libraries than C#. Just most of them are 3rd party.
When this project will be out: https://github.com/graalvm/graal/ Java is going to even faster than is now.
This is a good answer though it's worth noting that OpenJDK isn't written from scratch. In fact Oracle's JDK is [largely built on top of OpenJDK](http://javapapers.com/java/oracle-jdk-vs-openjdk-and-java-jdk-development-process/).
Thanks for the link. It does explain how code was donated from oracle. Thanksy
&gt; I am not going to enter into details No, why would you. Fortunately the [official trail on sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html) actually does. 
Shouldn't that count as "my own JVM"? Yeah, the bytecode is not compatible, but it still takes compiled java source and executes it. Unless we are defining "JVM" as something that produces actual bytecode compatible with the one of the official JVM, of course. I'm actually interested on this topic, so any link or documentation about those definitions could come handy!
No. The JVM run Java bytecode (.class) files. The Dalvik virtual machine runs Dalvik Executables (.dex) which are a different intermediate representation. The bit you're thinking of is the compiler which takes Java code and produces Java bytecode (.class) or the .dex files.
this project will probably not make java faster. it will make other languages on top of the jvm faster, if they make use of JVMCI/can make use of it.
The answer to your first question is most definitely, yes. The specification for the JVM is published as part of the Java Specification Request (JSR) for the Java Standard Edition (Java SE). The JSR grants the rights to the IP of this so you are free to make your own implementation. As has been pointed out, what you are not free to do is use any of the trademarks that Oracle own related to this, i.e. you cannot call your implementation Java or use the term JDK. For the second question, conformance to the specification is assured by running the Java Compatibility Kit (JCK), which is the Technology Compatibility Kit (TCK) for a Java version. As has been pointed out, you would need to license this commercially from Oracle for a non-OpenJDK derived implementation (as IBM do for their clean-room J9 implementation). The free, community TCK can only be used in the context of the OpenJDK (i.e. an implementation deriving substantially from it).
OpenJDK is primarily developed by Oracle. Oracle's JDK is essentially OpenJDK + some add-ons. It's the same situation as Chrome and Chromium
The lawsuit was centred around the Java API (the standard library) and not JVM/Dalvik.
Exactly what I was looking for. Great
Thanks :)
Thanks.
I was watching many presentations on graalvm and It does make JVM faster. For example escape analysis is greately improved. It can allocate on stack any object and if It's going to escape it will copy to heap. Graal is generating vector instructions in cases hotspot couldn't handle. There are a lot more of improvements versus hotspot. As far as I saw on presentations Java is around 10% faster on Graal VM than on hotspot.
**Sidebar** -&gt; **Do not post tutorials here!** These should go in **/r/learnjava**.
Cool! will post any future tutorials in /r/learnjava. Shall I delete the post from this subreddit?
Leave it for now as it already has gained pace.
When will it be out?
Sun was the one that created those trademarks and patent hurdles.
lol if you got here it means that you already know about PrintStream of BufferedReader
Concurrency, lambda, stream API. EE stack if you want to be EE developer.
A few remarks: * You should prefer to use synchronized blocks over the synchronized keyword because it allows you to 'hide' the monitor from the outside world. This the keyword synchronises on 'this' other classes in the VM might 'abuse' your class as a monitor and cause unexpected effects. * It is very important to understand that a volatile variable does not save you from stuff like race conditions. It's not synchronised and as most operations (such as ++) are not atomic you are still creating a race condition. As such it's actually a code smell: multiple threads in general should not access the same non-synchronised value. * CountDownLatches are pretty awesome and definitely something beginners should know exists. I'd recommend giving a quick overview over all these concurrency primitives. * By far the easiest way to deal with concurrency is by not sharing anything. You can't really deadlock or have a race condition if you're not messing with the same thing. So an approach that is actually very beginner friendly is by having treads communicate via message passing. BlockingQueues that are part of the concurrency API are definitely worth mentioning there.
This is great! Lots of important insights. Will try to incorporate your suggestions in my post. Thanks man :)
Seems like a lot of work.
That was only a small part of the overall lawsuit concerning the standard library (I want to say "harmony" but I'm not certain of the name.) There were also patent claims against the Dalvik virtual machine. In any event, my point stands. Dalvik is not a JVM and doesn't use Java Byte Code.
They both did, but I don't see the point in talking about the one that doesn't exist anymore.
It was about both. Copyright was used for the Java API, patent claims against Dalvik. 
What about the standard library? You can't make your own without getting your pants sued off by Oracle.
In [this comment](https://www.reddit.com/r/java/comments/6sng06/secure_rest_api_with_authentication_using_spring/dle2v4h/) you stated that you want to follow reddiquette. In [this comment (in reply to the very comment above)](https://www.reddit.com/r/java/comments/6sng06/secure_rest_api_with_authentication_using_spring/dle91kt/) I made you aware that you are close to being considered a spammer. Yet, you keep posting as if nothing ever happened. In between, another of the **reddit rules** [**"What constitutes spam? Am I a spammer?"**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer) applies to your contributions: + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer. Every single of your last three posts got downvoted and reported to us moderators. This is a sign that the above rule applies. Also, we have a **Do not post tutorials here!** rule in the **sidebar** (which you, when following reddiquette, should have read anyway). I am not telling you to stop posting completely, but I am telling you to stop posting content similar to the one that got reported and downvoted. This content is obviously not well received by our community and thus can be seen as **spam**. Also, your history indicates that you are mainly a *link supplier* and not an active participant in the subreddit discussions. This is something we are not really happy with. Supplying content is okay as long as the people also participate actively in other threads, which you completely fail. Consider this a formal warning. If you continue in the same manner, you will face a permanent subreddit ban.
I think a more interesting question woud be: "Will the JVM remain popular?" Kotlin is gaining popularity in the Android community. It's not Java but Kotlin code gets compiled into Java bytecode. We also have Scala, Groovy &amp; Ceylon. 
The hate towards Oracle in some circles makes people attribute them actions that were actually done by their beloved Sun, and there are quite a few examples. 
Just so I can find this later
Why? Just fork the OpenJDK's and keep it GPL...
You forgot (3): its quality is too embarassing to disclose.
None. I trust my customers and I like them to be able to debug and patch my logic and send nice bug reports with useful stacktraces and potentially also PRs (yes, non Open Source pull requests are a thing!) Again, most important reason: mutual trust
SQL
ooo I've had to quickly write shitty versions of this several times that I can't really keep a hold of or make public, Ima bookmark this :o
It's closer to 2% according to official charts: http://i.imgur.com/6rLWp2t.jpg Screenshot taken from this presentation: https://www.infoq.com/presentations/polyglot-jvm-graal (17:22)
Tbh, I dislike concurrency tutorials that start with threads and locks. Mostly because threads and locks are where dragons lay. If I were to write a tutorial, I would start with completablefutures, head to immuable data structures, then to concurrent data-structures, and then to synchronisation and threads. You can do 90% of your work only working with futures and immutables. So those should be the first abstraction learned.
I'd like to make a slight alteration from: &gt; The Technology Compatibility Kit can be used for free only on software that is principally derived from the OpenJDK. to: &gt; For free implementations, the Technology Compatibility Kit can be used only on software that is principally derived from the OpenJDK. A slight change, but an important one to make it clear that it's not about cost of the TCK, but instead that Oracle won't permit certification of non-derived, open source OpenJDK competitors.
There is the classic book of Brian Goetz et. Alt. - who needs more? (Ok... there are some newer APIS available in the meantime. But imho you could learn them better and with ease if you know about the foundation explained in this book) (Java Concurrency in practise is the title of course)
Step 1: don't use Java for concurrency Seriously. Look at eg http://book.realworldhaskell.org/read/software-transactional-memory.html instead. Edit: downvoted, but can anyone elaborate on why Java with threads, locks, synchronized etc should be used for concurrency when there are clearly more sane options? 
https://en.wikipedia.org/wiki/Chrome_(video_game) - [Duke's Choice Awards winner](https://community.oracle.com/docs/DOC-922215)
/r/typescript
Thanks for the info. I was actually responding to the comment above and not directly to you. Misplaced reply, my bad
I would love `is` for object identity.
Check out the **Sidebar** in **/r/learnjava**
i was just about to come delete this post after seeing the side bar ty tho
Can you give an example? I always use `\S+@\S+` for emails so I don't reject valid ones.
Ya, it was more closely based on Apache Harmony.
Thank you
I firmly believe that Maven is a far superior solution to Pip + PyPI + Virtualenv. The latter just feels like a hack.
Agree, but for someone who is just learning to program.. there are fewer ways in python to get bogged down in the stuff around programming, rather than the programming itself
There are [a](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8124977) [number](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4519026) [of](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4738465) [related](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4199068) [bugs](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4900150) as well as a comment on the [original](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4488646) stating to the effect that they have recently made the filesystem unicode aware and that changes need to be made to the JDK -- comment dates from 2003. 
so you can't launch java from a path with Unicode characters ? 
Seemingly not.
that's really a bummer 
No GridBagLayout. No inheritance like Swing has. Those were my two gripes when working with it.
Because java has a great ecosystem around it. Because your job requires that use java. I don't really know anything about Haskell, but I think it might be hard to feed yourself with it.
you don't have to go to china, german (√ú) or hungar char's also apply
mkay
I don't believe that guys name is Joe.
why is that way back machine feeling when clicking links in r/java
I don't see the point in doing this comparison for toy applications. They do not tell anything about real world enterprise applications. In fact I would bet that for 90% of the enterprise applications out there the bottleneck is the database and the fancy queries used on it, rather than the implementation language.
&gt; So an approach that is actually very beginner friendly is by having treads communicate via message passing. I wonder if this could eventually be part of the language spec, some kind of 'pubsub' system. As in, instead of returning a value a method may 'publish' some data, then any method can subscribe to listen for that event. The use case is removing listener boiler plate, but also makes getting events across very different parts of the application my simpler. The value is being able to create code that is entirely encapsulated, only communicating with the outside world by publishing events.
A rant on a pet peeve of mine : could we please stop using "transpilation" as a word? It's a compilation like any other... Call it a translation if you like, that's also correct, but creating a new word for something which the existing ones are perfectly suitable in the literature already is silly. 
You can download it [today](http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/index.html). 
I like that expressed this idea without being a jerk about it.
_I like that expressed_ _This idea without being_ _A jerk about it._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^twistedmixes ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
I think this would depend more on the operating system than on Java itself.
Jmx monitoring tools like jrocket ect, bunch of different ones in the jdk bin folder they mostly just do the same thing with different uis. You can also configure different garbage collectors be used. Only reason I know this is I once had to wring a shit sysadmins over the coals for not having elastic memory configured right in the VM lieing about it and thinking he's suddenly a Java developer telling me it's a memory leak when the application that runs for less than 5 minutes gets a malloc. The VM wasn't giving the os the memory it told it it had, that's how you make Java malloc if you ever needed to know. Pretty exact break down of memory usage shuts that shit down fast. That place gave me a lot of anger too. Edit worth mentioning, haven't tried it but bet you can point valgrind at the Java process too.
Why not JAX-RS? Also request params by http spec is Map&lt;String, List&lt;String&gt;&gt; since you can do a=1&amp;a=2... via multi select input.
It's become the meme scripting language latly lot of beginner classes teaching in it, they made publishing rest API client libs super easy, and they're finally unknotting their panties from the API break schism that happened for 3. Not really a Java threat still, different use case for the language.
Technically, according to the RFC, even a single word like 'bob' can be a valid email.
&gt; Why not JAX-RS? Uhm the only practical reason is that Spark is a RAD tool and abstracts over jetty/tomcat, so i don't have to worry about depoying Wars, etc.... But the api is really minimal at the moment, i agree that for larger solutions Jersey/Jax-Rs would fit better. &gt; Also request params by http spec is Map&gt; since you can do a=1&amp;a=2... via multi select input Can you make an example?
Diving into java memory model could be a bit rough on beginners. 
[removed]
It only takes like a weekend to pick up if you're familiar with any other kind of programming already. It's basically such low time investment to pick up they would have to really work at also being worthless enough to not be worth picking up.
Thanks for the clarification. Much appreciated.
java is a big language, so everyone targets java devs for conversion to there new language platform. We get very sensitive to a tells of a hipster language, and node.js puts off a lot of them. Dynamically typed languages also kind of suck for any buisiness logic more complex than a hello world rest api. 
quick github with some hello world jee bullshit, a coding bootcamp, the lower level oracle java certs are also kind of a joke but they get the I've seen this language before Idea across.
Diving into concurrency could be rough also, right? üòâ
&gt; root@discovery:~# /usr/lib/jvm-√º/java-8-oracle/jre/bin/java -jar /home/kuschku/.minecraft/Minecraft.jar &gt; Bootstrap (v5) &gt; Current time is Aug 17, 2017 9:49:45 AM So, Java works at least on Linux with unicode paths. It is likely this is either a problem with the Windows implementation. Can anyone reproduce the issue? Might be possible to get a fix into OpenJDK 
`a=1&amp;a=2` is the example. See also multiple inputs with the same name if you want to see HTML generate such an URL, though that has nothing to do with HTTP.
Oh it sure is, but Java memory model is a bit of a mindfuck for a beginner programmer. 
A transpiler is a source-to-source compiler, so it's a specialization. I'm definitely in the pro-new-word camp here ;)
If you had admin access 1. Add JAVA_HOME to environment variable and add the bin directory to PATH and access java command globally. 2. Or, you could probably install something like mingw, link the Java directory path to something simpler (English name), and run JVM through bash command. 
There is a "save" link right below the post that exists for exactly that purpose without cluttering the thread.
**No promotion of potentially illegal activities!** **First warning**
**No promotion of potentially illegal activities!** **Second warning**
To reproduce this dysfunction follow those steps : -Copy Jre 7 86x folder to a folder in which it's name contains Unicode characters for example (ÂäüËÉΩÈöúÁ¢ç). -Try to execute javaw.exe. The system language must be different from any Unicode language (Chinese, Japanese, ... ) 
I am assuming this was all conducted using Windows OS. It would be nice to see the test conducted atop Linux on the same hardware. That is a more common production deployment for Java.
Maybe - understanding immutability shouldn't be so hard imho! Of cource there are many traps, but better one graps this concept early. You needn't dig too deep into the advanced chapters - the rest might be tough, but possible to handle, if you have reached the level of doing concurrency!
Yesterday I thought F**K it, and started moving my stuff from TomEE, to WildFly. I really want to like TomEE. But, after battling over long polling / comet and async servlet requests, Im done. There are too many bugs in Tomcat / TomEE. If you want to know what I'm talking about, try creating a simple, basic webapp which has Server Sent Events, using TomEE. 
You should probably do your own homework
1. **Sidebar** -&gt; **Do not post tutorials here!** 2. This is an **English only** subreddit
1. Since this is help with **Java programming**, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. 2. We are not **/r/domyhomework**. Plain homework posting is not allowed in any of the related subreddits. In short: **do your own homework**
neat
We started out with TomEE but had to move to GlassFish when it started to become more serious. We're now at Payara and pretty happy until we can leave Java EE behind for good.
Only the latest chapters of JCIP tell you about low-level primitives like locks, semaphores and the JMM itself. The book focuses on using the right level of abstraction to handle concurrency. I won't give you a quote, but I remember it saying that your application shall not normally create `Threads` directly but use higher-level abstractions. The same idea is in a [recent series of posts by Goetz on Java Streams](https://www.ibm.com/developerworks/views/global/libraryview.jsp?series_title_by=Java+Streams).
If it actually doesn't work and PATH environment is no option either, maybe he can make it work by using [mklink](https://technet.microsoft.com/en-us/library/cc753194\(v=ws.11\).aspx) (symlink). Link a non-unicode folder to the actual jre-folder.
You are completely ignoring everything that is said to you, aren't you? Just [yesterday](https://www.reddit.com/r/java/comments/6u3fed/refreshing_configurationproperties_in_spring_boot/dlplxh4/) I basically told you to **stop spamming** this content, and yet again, you continue as if nothing happened. I am banning you for 10 days to give you time to think about your participation here.
Nice üëç 
Payara &amp; Java EE is very good, no? Why is you want to leave is good? I think leave that is bad, no?
Although the Java EE ecosystem is rapidly improving with efforts from Payara and Wildfly to become more cloud friendly, we still prefer Spring Boot for its control over external dependencies and easier debugging.
Had to check again cause I always thought Java memory model was one of the first chapters but it's the last one actually. Guess not reading the book in order shows up :)
Do you know of any existing concurrency tutorials that follow this pattern?
I'd love to have this, but since I was condemned by our client's obsolete webserver to use JSF 2.1, I had no choice but to create a resource serving servlet to send anything under /resources to the client. Voila. No more .xhtml crap. (The more I use JSF, the more I'm convinced that the best way to use it is to use it as least as possible.)
Something better would need to come along, it hasn't yet.
&gt; we can leave Java EE behind for good. At the risk of being that annoying pedant, with Spring Boot you're not leaving JavaEE behind for good, since many Spring Boot starters use JavaEE APIs. Instead, you'd be leaving behind standard JavaEE app servers.
**Sidebar** -&gt; **Do not post tutorials here!** 
No one has ever asked me if I was java certified. No one I've worked with has ever asked or cared if someone was java certified. 
I'm more convinced to update to the latest version ;)
The first thing i thought when i saw this was "java 9 already??"
This would be huge to the Java EE ecosystem. There needs to be more investment in the platform to keep it going strong. This is a great way to do it. I only wish this was done sooner. 
Is it a good thing?
This could be huge indeed. Red Hat already applauded Oracle for this move, and I'm sure the other vendors will do so too. I do wonder if Oracle will stay in the game with WebLogic and GlassFish, and how the entire JCP will be re-organised around this.
Seems to, Java EE development hinged on Oracle putting in resources to keep it going, but this prevented others from really doing much. For some specs like JAX-RS nobody from the EG has access to really anything, so if the spec lead is away for some extended "vacation", everything immediately grinds to a halt. As long as Oracle would work on the specs full steam ahead this wasn't such an immense issue, but when Oracle started giving its spec leads more and more of those vacations, and those vacations started to be longer and longer there was a kind of a problem. Hopefully this will allow all vendors (including Oracle!) to all take up some bits as most OSS projects work.
I don't know... If I were to use a different word for it I guess "translation" would fit much better instead of the odd malamanteau. Though I still believe that the end result is irrelevant. It's a compiler pain and simple. In any case, this battle is lost anyways. I was just ranting ‚ò∫Ô∏è
"Already"? Java 8 came out like 4 years ago...
Can Microprofile.io be the solution?
That's neat, but Java is beyond microservices
Microprofile.io is not only microservices. It is an effort to develop Java EE specifications quickly before standardising them.
I'd assume its on debian Linux since its on the debian.org domain
If you're going to optimize and find shortcuts for one language then why not get someone to do the same thing for the other? Also, in looking at the memory usage on the Benchmarks Game website it would appear that .Net Core 2.0 is still a bloated pig when it comes to memory usage compared to the JVM.
Which is the best open source foundation for that?
According to a recent poll Apache: https://twitter.com/reza_rahman/status/896128633537822720 Personally I think Eclipse would be better.
Just for clarification, the only code that was similar was a simple 7 line range check (that Judge Alsop said a high school student could write) that was written by Joshua Bloch when he worked for Sun. When he went to work for Google he coded the same method.
&gt;Personally I think Eclipse would be better. Apache is successfully running a lot of top level projects. Apart from the Eclipse IDE what do they have to reclaim for them? I know they're running many projects but without looking them up i couldn't tell a single name.
Hmm. I worked with Josh at transarc. I'll ask him about it. 
Doesn't Oracle just want to stop developing and leading Java EE? Saving face by offload it onto the open source community. [InfoWorld suggests the same](http://www.infoworld.com/article/3217347/java/oracle-doesnt-want-java-ee-any-more.html). Though Paul Krill has always been looking to badmouth Java (why garbage truck image?). I can still not shake the feeling that anything under the "Open Source Foundation" is doomed to fail eventually as soon as a competitor with a big lead company behind it pop up. Eclipse IDE / Netbeans -&gt; IntelliJ, Hadoop -&gt; Spark are examples. Open Source foundations lack the "Github freshness" appeal and perceived security by having a strong lead backing the project. They also move at glacial speeds (well not compared to Oracle, because Oracle has no stake in JavaEE). I forsee that the remaining JavaEE applications will be migrated to Spring or leave the Java ecosystem entirely.
Jetty, for example.
&gt; Guess not reading the book in order shows up :) üòÇ
https://www.apache.org/index.html#projects-list They're not playing in the same league.
They just don't want to compete with Spring.
Not trolling, just an honest question, what do you all actually use GlassFish/JBoss for? For as long as I've worked with the ecosystem, including giant corporate monoliths and small (micro-)services, neither JavaEE nor a full blown application server was never needed nor wanted. Tomcat or something like Spring Boot was always more than enough... I mean, parts of JEE like JaxB or JAX-RS are damn nice, but you don't need dont need an application server for that. The only ones that insidted on full AppServers were old timers at my uni and two astronaut architects at my work that admitted they didn't code for 10+ years. So... what do you actually use them for?
Not really. If you look at Java SE (openjdk), every one of the devs on that open source project are on the Oracle payroll. 
so can deploy wars of only a few MB, rather than an entire application server stack. The more resources you can have already installed on your server, the smaller the war size needs to be. Easier, faster deployments. https://www.youtube.com/watch?v=hoqJdH87e7g 
For me it's always first and foremost the API of Java EE that matters. Indeed, JAX-RS, JAX-B, JSON-P, Bean Validation etc. The fact that the implementation of that API most often comes in the form of an "application server", triggers strong sentiments in people. I guess because far too often ops takes ownership of those bits and locks developers out. But it doesn't have to be like that. In the companies I work for, dev always owned the AS bits and we delivered the AS and war. Meaning that one per half year or so there was a "big deploy", meaning the AS + war at the same time, and in between we had "small deploys", meaning just the war. With docker this becomes a bit more standard practice, and you can ship an update to the docker image where either the AS bit stays constant or the AS bit changes. There are also other deployment models and still be fully compatible with the full API; both WildFly and Payara allow you to do uberjars and running of a war from the commandline. And actually pretty much all jars that make up Java EE can be added one by one to Tomcat. As for Tomcat itself being enough... it rarely is. People add tons of libraries to Tomcat. Almost no project runs on a bare Tomcat with not a single thing in WEB-INF/lib. There's always at least some web framework or REST framework, and some kind of persistence things being added (like e.g. Hibernate). &gt;So... what do you actually use them for? Simply said; to run (web) applications on. But really, you could just ask yourself when writing a Java SE app where you actually use the JDK for. It's essentially the same question.
MicroProfile is on Eclipse as well and that seems to be pretty hot.
If the web site requires support for java applets in the browser then the web site is outdated.
That sounds really shady.
Java EE is not the same as Java SE though
It is outdated, but I still need to access it or I can't work my new job. The IT department was useless :/
**Sidebar** -&gt; **Do not post tutorials here!**
Hope that you are using Internet Explorer because basically everything else has Java already disabled. Is a Java Runtime Environment installed on your machine? The error message rather indicates that there might be a problem server side as it seems to have to do with a SSL VPN tunnel - an encrypted connection.
**Sidebar** -&gt; **Do not post tutorials here!**
Oracle knows it will become obsolete once most companies move to Cloud with light-weight microservices. They don't want to control it anymore as there is no potential. 
&gt; As for Tomcat itself being enough... it rarely is. Actually, this is my favorite feature of Tomcat. It is a servlet container and nothing more. This lets me manage libraries *myself* in WEB-INF/lib. Tomcat is enough for what I want it to be. The thing I never really liked about full blown app servers is that they do too much. I mean the idea of coding to just JAX-RS is nice and all, buy what if I'm running Wildfly but I'd rather use Jersey than RestEasy? &gt; when writing a Java SE app where you actually use the JDK for Actually, it's not the same thing. The JDK provides a *concrete* class library. Some things are configurable, like XML and cryptography extensions, but the JDK is fully usable as shipped. JavaEE is a specification, shipped as a set of API JARs. To actually *use* JavaEE, you need a separate piece of software, either an AS or third party library like Hibernate which actually implements JPA. This confused me when I first encountered JavaEE. Why can't I download JavaEE like I can download a JDK? Now I understand you need to download a standard AS. The nice thing about the JavaSE is that is a simple foundation for Java development. It doesn't add a server on top.
The majority of my Java written giant corporate monoliths have always been on WebSphere. The other ones being Liferay. Just one or two were actually done with a pure Tomcat server.
I didn't even know that!
duh
&gt; Easier, faster deployments I've never been convinced by this argument. First, deployments are just as easy. It's a WAR. Second, in my experience, deployments to a bare Tomcat with a fully loaded WAR are more than fast enough. I started writing webapps in Java with Tomcat. I had the brilliant idea of loading up the server/lib of Tomcat to make deployments faster. Of course, this annoyed other developers who couldn't download an ordinary Tomcat, but had to grab the ZIP I had on an FTP server. I quickly went back to libs in the WAR. Then I discovered JavaEE app servers. Standard distributions with all the bells and whistles! Slim WARs again. Except now I'm fighting the app server. Want another implementation of JAX-RS? Want another version of JPA? Change app servers or upgrade the entire app server. I've never really worried too much about Tomcat versions because Tomcat only does one thing. The only reason I've found for updating Tomcat is for security patches and if I really, really want to run a newer servlet spec. So, I'm back full circle to Tomcat and fat WARs again, except that I'm sometimes deploying fat JARs these days. The promise of fast deployments and thin WARs is not a convincing enough case for me to use JavaEE app servers again.
&gt; Actually, this is my favorite feature of Tomcat. It is a servlet container and nothing more. This lets me manage libraries myself in WEB-INF/lib. Tomcat is enough for what I want it to be. There's much to say about that. For one, do you also install a bare Linux kernel and then build your own linux from scratch, or do you just download Ubuntu? Second thing, Tomcat includes Servlet, JASPIC, JSP, JNDI and WebSockets, and wants the JDK to be installed. Neither of those can be shipped from WEB-INF/lib. It's not such a bare kernel as you claim it to be. Third, as mentioned, all the Java EE jars -can- be added to Tomcat. TomEE is the living example of that, but you can do it on your own too. The thing I never really liked about full blown app servers is that they do too much. I mean the idea of coding to just JAX-RS is nice and all, buy what if I'm running Wildfly but I'd rather use Jersey than RestEasy? Just don't want that then, or build your own stack. It's basically the same thing as running OpenJDK, but the complaining it contains java.util.HashMap, and what if you want to use the IBM or even the ancient Microsoft version of that? Is OS X/macOS bad because it includes the BSD bash shell, and who knows, maybe you want to run the Linux bash shell? &gt;Actually, it's not the same thing. The JDK provides a concrete class library. Some things are configurable, like XML and cryptography extensions, but the JDK is fully usable as shipped. Payara or Wildfly is also fully usable as shipped. I don't get what point you're trying to make here. &gt;This confused me when I first encountered JavaEE. Why can't I download JavaEE like I can download a JDK? Now I understand you need to download a standard AS. You're still confused. You don't download Java SE either, you download the Oracle JDK, or OpenJDK, or the IBM JDK or even IcedTead. There used to be somewhat more implementations even, so it really is exactly the same thing. You just didn't see it. 
No zip :(
&gt; For one, do you also install a bare Linux kernel and then build your &gt; own linux from scratch I also don't build my own server hardware, source the minerals for the semiconductors that make up the electronics, create a planet which produces these minerals or create a universe in which such a planet with such minerals exists. Your argument is like saying that in order to bake an apple pie, you first have to create the universe. I'm only concerned with what makes my development experience easier. I take some things as prerequisites, but I like to minimize my prerequisites as much as possible to increase flexibility. For example, I take the existence of the universe as a prerequisite. &gt; It's basically the same thing as running OpenJDK, but the &gt; complaining it contains java.util.HashMap No, it's completely different. For example, I can definitely complain that `java.util.Iterator` has a `remove` method, and throws `UnsupportedOperationException` for immutable collections, which totally breaks the Liskov Substitution Principle. However, I don't actually have to use the standard Java collections, because they are unobtrusive. I can use alternative collections libraries like guava-collections without fighting the JDK. Also, `java.util.HashMap` changes for entirely different reasons and in a completely different way than the JPA spec and its implementations. Also, `java.util.HashMap` is a concrete class. `EntityManager` is an interface. &gt; Payara or Wildfly is also fully usable as shipped. I don't get what &gt; point you're trying to make here. Is Payara or Wildfly JavaEE? Or are they implementations of JavaEE? There is no such distinction with the JavaSE. You cannot get the JavaSE independent of a JDK, they are tightly coupled together. This is the difference between *concrete* and *abstract*. &gt; You don't download Java SE either You have missed the point. JavaSE doesn't exist independently of Oracle JDK or OpenJDK, or whatever. JavaSE is a *concrete* class library. JavaEE is a set of APIs, almost entirely *abstract*, which is implemented by app servers. If you don't see the distinction, I suggest you read up on [Dependency Inversion](https://lostechies.com/derickbailey/2011/09/22/dependency-injection-is-not-the-same-as-the-dependency-inversion-principle/). 
or Vert.X
&gt; Java is beyond microservices what do you mean?
Alright, where's the github link?
I think they're talking not about source contributions, but rather the process of making JSRs that pertain to JavaEE. There are numerous open source and free software implementations of JavaEE, including GlassFish Community, which is the reference implementation. Currently, that process is incredibly opaque and very much a smoke filled room thing. 
That was unintended but now I see it :D
 I know, I don't hate the library part of Java EE, rather the app server part.
Download Firefox ESR, and get your IT to help you configure it. EDIT: https://support.mozilla.org/en-US/questions/1154163
I could have been clearer. I glanced at the article on microprofile, and the main theme as far as I understood was microservices. The original article was about open sourcing java, I was implying microservices is just a small portion of what java can be used for. I hope that helps. 
A very good article. Love the conclusion! &gt; Do not blindly follow any recommendation on the Internet, please!
Nice try. Asking about "actionable info about what exactly the security vulnerability does" is asking for working exploits for one of the most profitable exploit targets, right? Very nice try!
please stand up!
You're likely to get better support from the official forums: http://www.minecraftforum.net/forums/support/server-support.
Almost all Java EE related projects are already on GitHub. The majority of them are here: github.com/javaee. As far as I know, only EclipseLink, the JPA reference implementation, is maintained outside GitHub, on the Eclipse Foundation infrastructure (eclipse.org) Some specifications though are not specifically on github.com/javaee. Bean Validator and CDI specs are maintained independently on their own orgs/repos on GitHub, as well Jersey (RI for JAX-RS).
LOL
how does one pronounce 'vavr'? what does it mean?
https://twitter.com/vavr_io/status/887644004858421248 Was formally javaslang but for legal reasons since it included 'java' in the name they had to change it. It is such a weird name, I would never have pronounced it as 'favor', I was calling it 'vav are' lol. I will probably keep calling it that too. 
http://www.vavr.io/vavr-docs/ Is what I could find. Can't make heads or tails why'd you need it
If you flip it, it looks like Java but reversed in that particular font. It's just an interesting design choice that I don't think actually has any real meaning beyond that. Was formally called Javaslang
You could need it because lambdas and streams in Java 8 lack of important parts, like tuples, or functions on 7 arguments.
Well that's a silly way of writing the first example. You don't need to assign to a local like you do with the null check. Either: findUserById("667290") .ifPresent(user -&gt; System.out.println("User's name = " + user.getName())); or even: findUserById("667290") .map(User::getName) .ifPresent(n -&gt; System.out.println("User's name = " + n)); would be easier to read imo.
That depends on your definition of "powerful". Having a trillion libraries in Java doesn't make it "powerful"?
Even though IJ's code analysis is way better, I've found Eclipse not only to run smoother, but also to compile faster. If you really need something quick though, you might want to take a look at vim and plugins. [Take a look at this](http://spacevim.org/use-vim-as-a-java-ide/)
Some elements of the list are not tools at all. I'm glad to see that Google Guice is still alive, but I wouldn't call it a top tool. Missing: * Vavr * jOOQ * Vert.X * Play! Framework Looks like this list was made some years ago.
this is why i hate jpa/hibernate there are a ton of things nobody knows about because they're hidden from you
What does C2 mean?
&gt; You have missed the point. JavaSE doesn't exist independently of Oracle JDK or OpenJDK, or whatever. JavaSE is a concrete class library. JavaEE is a set of APIs, almost entirely abstract, which is implemented by app servers. You're wrong, both Java SE and Java EE are a specification that can have a clean room implementation. And yes, Java SE -DOES- exists independently of the Oracle JDK. Java SE does have more code in its standard classes, but Java EE isn't solely interfaces either. Check for instance the UIComponent class. And what do you think all the problems with JDK 9 about applications using... **IMPLEMENTATION SPECIFIC*** classes is about? The infamous *com.sun.* packages that don't exist on other Java SE implementations? Sorry, but instead of suggesting others to catch up, you may want to catch up yourself a little ;) 
HAHAHAHAHAAHHHA... LOL LOL LOL hahahahahahahah har har har üòÉ üòÑ üòÅ üòÜ üòÖ üòÇ ü§£
üòÉüòÑüòÅüòÜüòÖüòÇü§£
Some time ago I've submitted my first attempts on creating a library that can be used to generate arbitrary data for provisioning applications with initial input. The library become much more stable recently, and I've decided to write this more "complex" example on how you can programatically generate SQL Inserts for a "real-world" HR APP SQL Schema, while keeping the relationships between the tables. I hope it can be useful for some of you. Any feedback is greatly appreciated. Also, there are a lot of things that need to be done, for example refactoring the ["markov chain" module](https://github.com/nomemory/mockneat/wiki/MockNeat#markovs). Additional information can be found on the [wiki](https://github.com/nomemory/mockneat/wiki).
I just skimmed it, but could not see a mention of less efficient code or any benchmarks. Did I miss it?
How much less efficient would you put this? Roughly? 
OMG a doubly nested loop ;)
Exactly, this is the correct question. If it's negligable always go for a easier to read and understandable code. Unless the double for loop is used in Teslas super electric batteries to make battery last 1 more minute I see no reason why not make the code be easier to read which is what the article shows.
well it might be background noise or it might be significant, depends on the application context. but with reactive it is making copies of copies of data at each period for one thing, and adding any optimizations that are trivial in the functional form get rather convoluted (i.e. smelly). The first example better mirrors what is going on in the hardware, it is less abstracted.
If the array is long enough and you do the double for loop often enough, index those values ahead of time. Or keep them sorted to begin with, dependent on read/write ratio. I don't know. 
That's what you say if you don't read [High-Performance Java Persistence](https://vladmihalcea.com/books/high-performance-java-persistence/).
That red Algorithms book is crap. Makes you download a bunch of files to follow the book with that are not easily available nor correct. 
http://imgur.com/FqI3fFl
It's the more advanced JIT compiler in HotSpot also known as the server compiler. C1 is more basic and known as the client compiler.
It provides actual immutable collections, something that Java is sorely lacking. Additionally it provides a lot of framework to improve functional programming in Java.
By using [OpenJDK](http://openjdk.java.net/) or [IBM developer kits](https://www.ibm.com/developerworks/java/jdk/) you should have less license problems.
I cannot see a serious smell in this particular example either - other than maybe `mf.getLoadNames()` which might be better pulled outside all the looping to avoid repeated work.
I agree the code can be improved. But OP completely misses the point of using streams or moving the inner loop to its own method. And it has nothing to do with efficiency or the arrow shape. It's about Imperative vs Declarative.
Working with code in a daily basis I really like an easy to read codebase. The time you need to put into understanding a part of the application you are not an expert of is more than halved compared to non clean code. In my experience‚Äã stuff like this allows you to be more productive.
&gt; It‚Äôs OK to read, if we forgive the single-character variable names, So they think that the quoted code: for (final MappedField mf : persistenceFields) { for (final String n : mf.getLoadNames()) { if (storedName.equals(n)) { return mf; } } } would be more readable like this: for (final MappedField persistenceField : persistenceFields) { for (final String loadName : persistenceField.getLoadNames()) { if (storedName.equals(loadName)) { return persistenceField; } } } I see code like this every day and it makes my head hurt. Combine this with AbstractTypeNamesThatAreOverlyElaborate and you can make code a [complete impediment to understanding](http://assets.amuniversal.com/6348ecc02b5e01300649001dd8b71c47).
`mf` changes for each iteration of the outer loop, so you can't pull `mf.getLoadNames()` out of the looping.
Agree. Single letter/short variable names are good if they are extremely local (i.e. used within a few lines of declaration). Never as method parameters or member variables.
Be warned: Oracle Java SE Embedded is free only during **development**. Once you deploy your app in an actual device you have to pay a license fee. See http://www.oracle.com/technetwork/java/embedded/embedded-se/documentation/javase-embedded-faq-2043259.html#8
But it IS more readable. It helps a lot in preventing stupid mistakes. In the second example it's immediately clear to the reader what this piece of code is supposed to do. You also don't have to keep a mental map of what each variable is supposed to be. In the first example, you get to the if statement, and for a split second your mind has to make the connection that n is a loadName. Of course this is a small example, but add like 5 lines of extra code to this function that also uses "n" and it becomes a complete mess. I aggree you shouldn't go absolutely overboard, but the less I have to think when reading code the better.
Well, I usually go the Java EE way with wildfly swarm, I find it simpler and less magical than spring boot, things are more predictable. For REST just go with JAX-RS (Jersey or Resteasy) of course if going the EE route just use the proper annotations and you don't even need to care about which one is under the hood (swarm uses resteasy afaik). If you want something more lightweight maybe spark, I used it before on some stuff that didn't even needed persistence, just a main method and it was done.
Some [options](http://www.gajotres.net/best-available-java-restful-micro-frameworks/): * [Spring](https://spring.io/guides/gs/rest-service/) * [Dropwizard](http://www.dropwizard.io/1.1.2/docs/) * [Jooby](http://jooby.org/guides/hello-restful/) * [Rapidoid](http://www.rapidoid.org/) * [Vert.x](http://vertx.io/blog/some-rest-with-vert-x/) * [Spark](http://sparkjava.com/) (tutorial [1](http://www.mscharhag.com/java/building-rest-api-with-spark), [2](http://sparkjava.com/tutorials/reducing-java-boilerplate)) * [Jax-RS](http://www.vogella.com/tutorials/REST/article.html), Jersey ... Spring or Dropwizard probably the most used. Internally Jax-RS / Jersey anyway. 
Spring is the clear winner these days in the corporate world. 
Java EE is the clear winner these days in the corporate world.
LMAO!
lol a scriptkiddy
Look for Java EE 7 now and Java EE 8 really soon.
&gt; aesthetic issue with text If the codebase is meant to last and to change hands (potentially) many times, readability is almost always worth a slight loss in performance unless (as /u/papaz1 said) you are working on something where performance is a sensitive issue. In the long run, the clarity of the code and the quickness it can be understood will pay off in dividends with developers of varying abilities touching that codebase. It's well worth a few extra CPU cycles. IMO, whenever possible, one should strive for making the code as readable as possible before making it more efficient (although the two are often the same)
Single-character names quickly become hard to keep track of. In that example it's fine, but add in a few more method calls and a logging statement or two and it's easy to get lost. In the case where the full name is too verbose you can often compromise: for (final MappedField field : persistenceFields) { for (final String name : field.getLoadNames()) { if (storedName.equals(name)) { return field; } } } It also gets more important when the return values aren't as obvious. I assume you're mostly talking about loop variables, but if you're not then consider stuff like: String t = placeOrder(o); vs String transactionId = placeOrder(order); In the first case, you have to read the documentation for the placeOrder method to know what's being returned, in the second it's obvious.
And even that is done poorly. What's easier to read? public boolean hasName(String storedName) { return getLoadNames().stream() .anyMatch(storedName::equals); } or public boolean hasName(String storedName) { return getLoadNames().contains(storedName); } So better write nested streams distributed over two methods than just replacing the nested loop with a method that's present on every Java collections object? That's just idiotic refactoring and definitely not easier/faster to read and understand than public MappedField getMappedField(final String storedName) { for (final MappedField mf : persistenceFields) { if (mf.getLoadNames().contains(storedName)) { return mf; } } return null; } But hey, it doesn't use streams, so it's not aesthetically pleasing. \s
The smaller the context the shorter the names can be. No-one objects to `for (int i = 0; ...)` is a simple for loop.
I agree, which is why I said it's fine in that example. If you just have one or two lines in the loop it doesn't matter, but in general it's better to stick to a short name than a single-character. It also helps if someone adds more stuff to the loop in the future, since they might not bother changing the variable name and suddenly your simple loop is 20+ lines. Also, naming the index i is a standard convention which every programmer understands, so it's not a good example. Basically the only time where naming i index would improve readability is if your codebase contained lots of single-character names in the first place.
In addition to the options mentioned by others, you might want to look at Zulu Embedded (https://www.azul.com/products/zulu-embedded/). That gives you the licensing flexibility of OpenJDK, the pre-built simplicity of Oracle Java SE Embedded, and a commercial support option from Azul.
Ah! Yes, of course. Thank you for the correction!
Spring-boot. Agree with other comments, spring still most popular and boot flavour is opening doors in corporate world. Very enjoyable to work with and not falling behind competitors. Dropwizard would be an alternative IMO. I do believe serverless will eventually take over but not until we close some loopholes.
I can't wait for Java streams to lose the last of their "new car smell" so that people stop rewriting perfectly readable and straightforward procedural code into stream API for no good reason. Seriously, why do so many people use an API intended for pipeline processing for logic that consists of only one or two steps? That's just silly.
&gt; The smaller the context the shorter the names can be. No-one objects to for (int i = 0; ...) is a simple for loop. More because that's a well established idiom than because the size of the context. I think a lot of people would object to the following code and insist on swapping the use of i and j to their idiomatic uses with i as outermost: for(j = 0; j &lt; 100; ++j) { for(i = 0; i &lt; 100; ++i) { createElement(j, i); } } 
Fucking idiot
[removed]
I've always said that the #1 rule to maintainable code is sensibly-named subroutines. If a function name tells you accurately what it does, the maintsiner doesn't need to dissect it. Barring a good name, a good test is better. If the test thoroughly describes the expected behavior, you can trust it.
[removed]
oh really?
I'm liking vert.x fwiw. didn't like spring (or node).
I'd go with dropwizard
How do you deal with all the magic of boot configuration? I used it in a project and had serious problems with it, everytime I wanted to change something I needed yet another class that extends this and that or yet another annotation that I couldn't find anywhere in the docs where to put it. 
Username checks out.
initialization of streaming api takes way longer than iterating through a hundred entries (might be an exaggeration, tested it out once, but forgot the exact factor) . so if you have a million calls with 5 entries each the performance will be WAY worse
+1 for Calvin and Hobbes
Like everyone else Spring Boot is my vote on how to get back in. Take a look at [JHipster](http://jhipster.github.io) as a full stack framework for Spring Boot and Angular 4 apps.
Sorry, dude, but deeply nested code is ALWAYS shit, usually written by some foreign contractor. It can almost ALWAYS be refactored into something that is more readable, more testable, and more performant, all at the same time. Granted, a double nested loop is not the best example.
Scala and Play are good options 
Jooby is amazing.
Wow! that actually looks seems good
One way of creating a REST API using vert.x is described here: http://vertx.io/blog/contract-driven-rest-services-with-vert-x3/ If you don't like the contract approach it might get a bit more tricky with vert.x at the moment. I for example ended up writing my own wrappers in order to generate the REST spec (raml) from my implementation. There are some projects around which help to solve this problem (swagger vert.x/jersey for vert.x)
I Accidently read it as "modern java sucks".... Made me evaluate my whole Life again! üòÇ
The stack I like: * vert.x - http/networking * graphql-java - public API * dagger2 - dependency injection * hazelcast - clustering And a db which fits the need.
I, uh, just post json blobs back and forth. the command is in the blob (and whatever security tokens/etc, and of course data). And I just use the json library that comes w/vert.x. Are we saying the same thing here?
With graphql you need to post a query which basically describes what you want from the server. So yes, you basically send json around. The auth token must not be part of that payload. I like JWT which is just passed along the request within the auth http request header. Vert.x is not very strict. You can use whatever JSON lib you like. 
Spring Boot
Never heard of it, I'll try to Google it to learn more. Thanks!
Spring Boot isn't a web framework. Spring MVC is the web framework.
I've never had real big problems with the Spring Boot magic. Most of the time, it just works. When I do run into problems, Spring has a large number of [guides](https://spring.io/guides), a large number of [samples](https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples), and the Spring Boot [source code](https://github.com/spring-projects/spring-boot) is available and very easy to navigate with the debugger. And, I've done weird things with Spring Boot, like getting it to run as a WAR on an ancient version of Weblogic. At the end of the day, it all boils down to what you're used to and what works for you. Spring Boot seems to work for a lot of people.
oh, no graphql here, pretty strictly defined commands and data structures for most things (for security and reliability). Guess that puts me in the contract category :) No dependence on http implementation details either, and everything over https is post because of old scars running into get payload size restrictions.
Doesn't mean it is the better choice. IMO Dropwizard provides much more bang for the buck.
So... You need to buy a book in order to understand a 13 year old api? Right...
The [Hibernate User Guide](http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html) has been rewritten from scratch and covers everything you want to know about the API. So, just like you have the [MySQL docs](https://dev.mysql.com/doc/) and [High-Performance MySQL](https://vladmihalcea.com/2017/07/17/book-review-high-performance-mysql-3rd-edition/), you have the Hibernate docs and High-Performance Java Persistence, and [the testimonials tell why people have chosen to read it](https://vladmihalcea.com/books/high-performance-java-persistence/#testimonials) even if they have a very good Hibernate User Guide to understand the 13 year old API.
What kind of servlet applications did you write? In Java most of the web frameworks that exist actually work on top of the Servlet API (from Java EE) in one way or the other. Also the Spring Fw wraps a Servlet engine. If you don't want any servlet in the picture then you have to search for Netty and frameworks based on it. Examples that i know are Jooby or Vert.x 
It's generally easier using them together rather than setting Spring Web MVC on its own as you have to do a bunch of additional configuration.
JSF aka JavaServer Faces, combined with PrimeFaces and OmniFaces.
Yeah, betamax was better than VHS
That's not entirely Java, though.
Java EE, especially with EE 8 around the corner and it moving like .NET to an open process this is the stack to be on!
Like everyone else??? Don't think so! Spring has always been to verbose to me, boot is too magical and while it wraps a lot of stuff out there it's also eager to abort it very quickly, leaving a landscape of half or non-supported stuff around.
Java EE's JAX-RS is much nicer for REST and Micro services...
You're saying Spring has porn? Since that made the difference for vhs
I'd go with http://www.ninjaframework.org/ Easy to use and has nice design
Spring is porn
How is Java EE more predictable? If anything - spring boot is more predictable since it's always the same implementation everywhere you run it.. 
+1 for Wildfly Swarm and JEE. Fully agree that if you want a standards-based approach it is the way to go.
Agree. Personally, I prefer to go the standards-based route with JEE. Sure, if you use full fat implementations like JBoss / Wildfly it's never going to be 'sexy' but it'll be predictable, it'll follow the JEE standards, and it'll get the job done. And if you want something a bit lighter, then the Microprofile stuff / Wildfly Swarm is getting pretty good now. 
Also a big fan of Vert.x here. However, unless you embrace the asynchronous, reactive approach, then you end up with a lot of bad code, very quickly. I've never felt the 'do one thing and do it well' has applied more than to a Vert.x project and its Verticles!
Personally I find something as simple as replacing the egyptian braces for(int i : firstList ) { for(int j : secndList ) { if(someTest(i,j)) { doSomthig(i,j); } } } with the opening `{` on a new line for(int i : firstList ) { for(int j : secondList ) { if(someTest(i,j)) { doSomthig(i,j); } } } Also find having smaller indentations (personally I use 2 spaces) prevents too much horizontal code sprawl. Note also this example is not easily converted to a stream.
&gt; How is Java EE more predictable? Spring can deprecate and change APIs pretty much at will. For the Java EE APIs you'd have to reach some level of consensus. This obviously has both pros and cons.
Never nest functions in your domain objects.
This kind of code is inevitable when dealing with JAXB objects due to XML's nesting nature. Either you have nested for loops or a bunch of flatMaps, both equally unreadable.
Thinking about layout and streams what are peoples thoughts on the most readable layout for stream code. I currently use something like the following sourceMap.values().stream() .map(this::valueToList) .flatMap(Collection::stream) .filter( x -&gt; someTest(x.getValue())) .forEach( x -&gt; { doThis(x.getName()); thenThis(x); }); Note the code could be refactored to be cleaner but is used as is to demonstrate‚Äã layout. 
Agreed, JavaEE is a public standard API. You can't get more predictable than that.
Spring feels much more "unstable" last time I used it, every time I had to Google around most of the things I found were not working anymore in the version I was using, either it was an annotation that didn't exist anymore or was deprecated, or extend from a slightly different class. 
JSF, ZK, STRUTS, SPRING MVC .....
What saved me most of the times was debugging around the source, but that's not very effective. I always found the guides lacking for the things I wanted to do, same with the samples. One of the things I remember trying with boot was replace tomcat with undertow, in theory it should have been easy, just add undertow dependency from boot, ended up having to add tons of exclusions on other boot dependencies that were pulling tomcat. That was not what the docs advertised. Like you said it will boil down to what works for each person, spring boot definitely does not work for me. 
[removed]
And the service proxy API is and amazing. Go fully reactive over websockets. 
I'd like to ask, how do you get started with Spring if you don't really know Java? I've worked with Django before and Spring just seems incredibly daunting and complicated. There seem to be a lot of options for a lot of things and I'm concerned that I might also have to learn Struts and Spring Security and a whole bunch of stuff to get what I had in Django. So how does a total newbie get started with Spring, or rather which framework should I use to get started?
Make sure to checkout [Play!](https://playframework.com) and [Lagom](https://www.lagomframework.com), discover the world of [reactive systems](http://www.reactivemanifesto.org). 
you know what, it probably has, i bet many porn sites in their backend run spring :)
The first is against the Java code conventions. Of course you can do it like you want in your private code, but when you work in a company you usually have to follow the conventions of your company or department and usually those don't invent everything from scratch but will use the default conventions as a basis. The second thing is just a setting in your IDE, at least if you use tabs and show them as X spaces.
I think the second version is way more readable, I even would rename `loadName` to `persistedName` to make the line `if (storedName.equals(persistedName))` more clear. I guess you could name them even better if we would know the context of the objects, because right now they have a very technical naming. I think those single-character variables and abbreviations should only be used as index variables or if the abbreviation is very common knowledge where you work at. Like where I work we have a lot of different types of "Tasks" objects, an example would be the `ContractModificationTask`, but everyone just calls it `CoMoT`.
Start with Spring Boot; it's a bit automagical, but everything you use is just a configuration on top of Spring.
If you have a complex object graph, I would *seriously* recommend some GraphQL library (non-react are even non-patent-encumbered). It makes pulling data so much easier.
You don't if you don't know java. Learn the basics first. Maybe get to know how Gradle or Maven works as well and then jump into spring. (imo)
Using strings for field names makes the code more fragile, as you can't just rename the field in an IDE.
As /u/FennekLS and /u/GuyWithLag said. If someone was learning Python I'd also recommend starting with the basics, then checkout Flask. Only later look into Django. Also note that Django is a web framework, Spring is an application framework. Pick the parts you need for web apps.
And in case of Play the pain of non-idiomatic Java that pretends to interop well with Scala. Lagom is a microservices framework. If you want reactive, use Vert.x or Spring Reactor.
No, thank you
Should I start with plain Java EE Servlets with maybe Hibernate for ORM, JSTL for templating and something else?
What are the alternatives ? I am using reflection to do that, as far as I know I don't have alternatives for IDE-friendly refactoring.
Java EE 7 has a very modern feel and is likely going to make you very productive. Java EE's weakness and strength is that it's been around for a long time, so people may have seen it 15 years ago, didn't like a particular implementation and now still shout from the roofs it stinks. But modern Java EE is quite different. Adam Bien's books and articles are a very good source for what modern Java EE looks like.
&gt; I do believe serverless will eventually take over but not until we close some loopholes. You mean like an actual server still being needed? Yeah, tiny loophole there.
&gt; Maybe get to know how Gradle or Maven works as well and then jump into Java EE. (imo) There. Fixed that for you ;) 
That would indeed be a good intro
Really
You would have to use them together. Spring MVC is built on top of the Spring Framework, and Spring Boot provides starters to autoconfigure many Spring Framework based projects. Spring Boot still isn't a web framework. The best documentation for Spring MVC is among the Spring Framework documentation.
Well I mean doesn't really matter. I just said spring cause that's what the guy above me was talking about. Both are more than valid options
For me, another win for this kind of refactoring is often better assignment of responsibilities and composability, which is achieved here by separating iteration and business functionality. After Tricia's refactoring, if we need a new `getLoadedField` method I end up with the following: public Optional&lt;MappedField&gt; getMappedField(final String storedName) { return applyPredicate((t) -&gt; t.hasName(storedName)); } public Optional&lt;MappedField&gt; getLoadedField(final String loadedName) { return applyPredicate((t) -&gt; t.isLoaded(loadedName)); } private Optional&lt;MappedField&gt; applyPredicate(final Predicate&lt;MappedField&gt; pred) { return persistenceFields .stream() .filter(pred) .findFirst(); } Each method does exactly one thing, and is (to me anyway) very readable. 
I think he really goes into a lot of the problems that exists in a lot of Java code where either people just don't care enough about what they write or "that's normal" has propagated bad coding styles (especially in our language) for decades! Let's write some less shitty code :P
Okay ;)
The alternatives aren't pretty either, but are worth considering. One of them is to ask the user to provide the field using actual java syntax, for example a method call (mockito does this) or a lambda expression: // using a method call to describe a field Mockito.when(a.getFieldName()).thenThrowException // using lambda to describe a field FieldManipulator(a -&gt;a.fieldName, other, stuff) Then from that java call you extract the information of what method/field was accessed. Mockito uses subclassing to detect which method you've called. For field access you'd probably have to do some other trick to extract the information, in the worst case by examining the lambda bytecode. 
The only reason I see to down vote this post: not a java bot.
You'd probably have more chance of success asking this in a place that's supporting the product you're trying to use.
The only problem with swarm is the jar size. A simple app weights more than 150mb.
Recently did a Dropwiz project. It's like Diet Spring. Basically the same with 1/4 as many features. I don't see any compelling reason to ever use it.
It's a persistent mystery to me that Java EE wins all these threads since I've been in and out of dozens of media, finance, retail, etc business. Big and small. Plenty of companies you've heard of. I have not even once for Java EE be implemented or even considered by any of them. Spring have been the default option for about 10 years. I've done a bit with Dropwizard, vanilla Java or just non-Java (Python, .NET, JavaScript). I'm imagining some hidden corner of the industry with thousands of EE developers that I've just never met. I personally would recommend Spring 90% of the time or otherwise go vanilla. I'm also very keen on Kotlin although I'd be reluctant to put it in production just yet or try to staff a team with it.
What was missing for you? One main reason I like Dropwizard is it pulls I'm just what I need vs spring which is everything and the kitchen sink. 
Ok this isn't really on topic here, but you have a specific example of a general challenge with Java apps launched from a browser. Triage steps: * First, say EXACTLY which product and version you are using? * Next, cite which FAQs or manuals or forum posts you've read about this product and issue. * Do you have a Java runtime (JRE) installed? Check by running *which java ; java -version* on a command line * Is the application running in the browser itself as an applet *or* is it having you download *or* is it downloading a JNLP *or* are you dealing with a regular old application? * If it is an applet, have you installed and enabled the browser plugin for Java? 
It's a persistent mystery to me that Spring wins all these threads since I've been in and out of dozens of media, finance, retail, etc business. Big and small. Plenty of companies you've heard of. I have not even once seen Spring be implemented or even considered by any of them. Java EE has been the default option for about 10 years. I've done a bit with Wicket, vanilla Java or just non-Java (.NET, JavaScript). I'm imagining some hidden corner of the industry with thousands of Spring developers that I've just never met. I personally would recommend Java EE 90% of the time or otherwise go vanilla (use Tomcat, Jetty, Netty, Grizzly). I'm also very keen on Kotlin although I'd be reluctant to put it in production just yet or try to staff a team with it.
Check out Payara Micro as well, it's somewhat smaller.
And RichFaces
I don't recommend jersey tho, I really prefer spring web, as I needed to work with both now. https://stackoverflow.com/questions/42944777/difference-between-jax-rs-and-spring-rest The question is somewhat obscured, but you'll get some informations out of this.
Awesome video
Actually the video talks about a lot more things than you could ever write in a 5 paragraph text. But hey...deflect other peoples viewpoints so you don't have to think about new stuff :P
I guess you haven't tried deploying on another server/system then.. nothing is predictable.. every implementation of the API is different - especially when forced into WebSphere that uses a complete different jdk... I used to love and preach about EE as well... Until I started using spring and docker 
If your Spring installation has a lot more than what you need, then you're not using Spring correctly. It's highly modularized and can be pretty lean. New projects should start with Spring Boot and add what's needed as it's needed from there.
You should ask the creator.
I would argue spring is mature enough you don't need to upgrade on majors .. they always keep up with security patches on minor updates that does not break backwards compability. Furthermore - it's not exactly a dance on roses to upgrade Java EE either
I agree, but you can use JAX-RS/Jersey along with Spring just fine.
With the difference that .NET is moving forward while Java EE is moving into the Eclipse or Apache graveyard / dead code archiv.
Was nice indeed, but has been sun set.
I can only talk about Servlet containers (Jetty or Tomcat) and JAX-WS/RS APIs. I admit I didn't get to work much with full Application servers, and I can imagine the horror story when porting an application from one AS to another, only to find out that the new AS doesn't exactly implement some JavaEE spec as claimed. But, if you dive enough, Spring is not an alternative to JavaEE, it is a framework that uses JavaEE a LOT, including Servlets and JAX-RS. For that matter, is not worse or better by principle, it is just offering the same services in a different form. Yes Docker probably is the death of application servers, and that's great. Docker for sure solves all portability problems that you talk about, but it does it not only for Spring, Play or whatever, but for anything. You can use Docker and selected JavaEE pieces like I do at my shop.
Unless I'm misunderstanding you, he's referring to services like aws lamda and azure functions where you don't actually ever provision a server.
hadn't thought about compile times w/scala, is that mostly because of the type inference?
Right, but you can still use Spring Web MVC on its own by manually setting up the DispatcherServlet in a JavaEE/Servlet container.
You can, but then why use Spring? The rest (no pun) of EE is pretty nice as well ;)
For the other way around, I wouldn't recommend Spring web at all and would always go either with Jersey or with JAX-RS (which in turn can be Jersey again).
I meant that APIs are not going to disappear underneath you, which can happen at any time with projects where the API is not under some form of group consensus. Java EE rarely removes APIs and rarely if ever changes behaviour of existing ones. Projects governed by 1 owner do this quite frequently. It's not only Spring that does this, but JBoss' own APIs change radically as well (including things like Hibernate Validator, Infinispan etc), Lucene does it, etc etc As I mentioned, there are pros and cons with this approach.
JAX-RS with Dropwizard or Spring Boot
 If you can find the log file ( i.e. something like log4j.properties) you can change level debug to all so you can have chance to see exception in logs but if developer catched exception and using a different notification mechanism and you dont have access to source code just contact him.
:)
&gt; I can imagine the horror story when porting an application from one AS to another It's not that bad really. Indeed, they aren't 100% compatible, but I've ported MAJOR applications in several days to several weeks at most. &gt;Yes Docker probably is the death of application servers, and that's great. It's not really the death of the AS, far from it. Docker enables you to even more easily deliver the AS as before. Somehow the idea had rooted that an AS always has to be installed beforehand by an ops team, but this is *absolutely* not the case. In my companies I've always seen to it that dev delivers the AS instead of the AS being some kind of black box target dev has to code against. Surely for the Java EE APis it does not matter one way or the other. Those APIs will live on, whether they're part of an installed AS, an AS shipped with docker, part of an uberjar or when a .war is run from the commandline using a tool (such as Payara Micro).
You're not running Spring MVC on its own that way. You are manually configuring the Spring Framework, which is running Spring MVC. Which is a perfectly reasonable alternative to using Spring Boot. But it's the same Spring MVC in either case.
There's still a server behind that. It's really the same strange reasoning people had about "clouds", which were supposedly totally different from hosting providers, since there was no hardware involved anymore :|
With the difference that Java EE is not a single implementation, so the RI projects will move to one of those foundations, but the JBoss implementation and the Liberty implementation to name just 2 will squarely stay where they are.
Except that it isn't. Java EE has more competition now, but we're in the strange situation that the original reason for Java EE (countering Microsoft) is now supporting Java EE (Microsoft even has an EE evangelist). At the same time ASP.NET has become a much more serious opponent. Some platforms have effectively died out or lost lots of mindshare (PHP, RoR), while other competing platforms have arisen (Node.JS, which is however not universally loved either). On top of all of that the total market for server computing (web apps, APIs, app backends) is still growing, meaning the percentages may have gone done but the total number of projects per technology has gone down far less or has even gone up. 
&gt;This is the fate of every language: to disappear into oblivion - or more precisely to be used less and less for new projects Would you say that this is true for C as well? &gt;Kotlin has won the Android battle I find this, a very bold statement. Do you have stats to support this claim?
Nice article and mostly agree with it, for the exception of clojure? You listed extend but ignored clojure? Why? 
I will have to agree on that, but really depends a lot on the fractions you use, just Jax-rs should be quite small (I didn't test to be sure). Also if I remember correctly you can create a hollow jar, that only contains some bootstrap code and your app and will download the rest of the needed stuff, something I still have to check out. 
Is just configu? Please! Is very difficult! And smells bad! ü§ß
You is talking gibberish? ü§§
Is not my vote!!! üò°
You are in wrong sub! This is /r/Java please, not :r/Scala! Please look üëÄ at you URL bar before post, no?!
Guessing OP hadn't heard of it
Always found using tabs for indentation to be a bit unreliable unless everyone uses exactly the same indentation. can lead to some unexpected indentation as tabs and spaces are usually indistinguishable. This becomes even more important when using egyptian braces and relying on indentation for marking blocks Also if one wishes to rigidly adhere to the java code convetion &gt;Four spaces *should* be used as the unit of indentation. The exact construction of the indentation (spaces vs. tabs) is unspecified. Tabs *must* be set exactly every 8 spaces (not 4). &gt;Avoid lines longer than 80 characters, since they‚Äôre not handled well by many terminals and tools. 
Xtend is used to create DSL with xtext. I think the comparison with other jvm languages lacks a bit. 
Actually, I did, but it's true that I ignored it in this post because I'm not familiar with it, and never saw it for real. If you're interested, you can just use the link to Google Trends and tweak it with your own JVM language.
The difference is that Clojure is used commercially, whereas Extend is not. Try this instead of Google Trends - https://www.indeed.com/jobtrends/q-clojure-q-scala-q-groovy-q-kotlin-q-ceylon.html ... sadly extend is general a word to be searchable.
It is not 'extend'. It is 'xtend'.
&gt; It's not really the death of the AS, far from it. True, what I meant is that Docker in some way unbundles the necessity to mantain stuff like the AS for the customer. You just embed everything in the docker image and everybody lives happily without even knowing about the presence of the AS, if any. I guess that also will change part of the AS business though.
Play has many happy Java users and the Java API has become much less awkward with Java 8. Both Lagom and Play leverage the Akka actor toolkit, which is very reactive and has been well before vert.x and Reactor (which surely are also fine frameworks) even existed. 
Precisely.
kotlin has kinda screwed itself by wedding itself to android hasn't it? android's dalvik is evolving at a much slower pace than the already slowly paced java and jvm. scala was running into this problem too when people were using it for android development where android devs were demanding scala never target higher version bytecode than what android supported, which was a contentious issue when 2.11 wanted to base itself more on java 7 level bytecode. is jetbrains going to have kotlin targeting 1.6 level bytecode and 1.9 level bytecode simultaneously or are they going to just stay stuck in the past and support only 1.6?
Noooo. Also, damn it's been a while since I've worked with these technologies
Implementations frozen in place as a worst case scenario. JavaEE will lack leadership and there will be too many colliding interests to have meaningful and couragous advancements.
Agreed. It's just different levels of abstraction. There's still electricity and A.C. provided to the server, you just don't worry about it. The hypothesis is perhaps trendy java development of the future will be just writing small functions/programs, and everything else will be abstracted away.
Scala does have long compile times. But for large projects I think it's better than CPP. Scala has long compile times because of type inference, as you guessed. Along with the more complicated features. But it also only r compiles the parts it has to with changes. So while it's off putting, it's not something that is worse than all big languages.
I think that the fact that Google now supports Kotlin as an Android development language is enough proof that you need. 
You mean like what happens in MicroProfile now? Which includes almost all EE vendors except Oracle and is hosted at Eclipse? Yeah, these are doing so bad that they've done 2 releases already...
My bad, I copied 'extend' from the OP's article, without fact checking. Here are the job trends including xtend without and e prefix: https://www.indeed.com/jobtrends/q-clojure-q-scala-q-groovy-q-kotlin-q-ceylon-q-xtend.html
What are benefits of level 1.8 bytecode vs 1.6? At least for me, as long as language is nice and execution is fast, the intermediate representation doesn't really matter to me. 
They do [support 1.8 bytecode if you want it](https://kotlinlang.org/docs/reference/using-gradle.html#attributes-specific-for-jvm), but few JVM languages _strictly require_ JVM 7 or higher bytecode compatibility simply to work, if the language can compile down to operators with the same effects without extra keywords. And I sincerely don't believe they target 1.6 because of Android, but rather because 1.6 is a common JRE runtime that enterprise development still uses (1.5 not so much, and anyone past 1.6 is probably on 1.8)
1.7 bytecode and 1.8 bytecode have new ops to facilitate lambdas and such. iirc, some of the benefits is you don't have the classfile diarrhea as bad as when scala would generate them before hand. you can also probably expect said opcodes to be optimized compared to making functors. edit: apparently java 8 opcodes allowed scala to use SAM interfaces, making it possible for scala code to use scala lambdas with java methods, and vice-versa [this slideshow](http://downloads.typesafe.com/website/presentations/ScalaDaysSF2015/T2_Rytz_Backend_Optimizer.pdf) goes over the reasoning behind scala 2.12 only supporting java 8 and up
Kotlin is great, but all this proves is that it's a first class language. 
supporting java 6 users (non-android types) who are paying for java 6 support seems kinda silly to me, cause those guys are stuck with java 6 cause they refuse to update their software and code. so why would these people need the latest scala releases to target java 6? they could stick with old scala just like they stick with old java. my issue with android is that they are the biggest reason why java 6 is even a thing anymore
Java EE is on the decline. Oracle realized last year that application servers are becoming obsolete - see the "Java EE strategy" section in https://jcp.org/aboutJava/communityprocess/ec-public/materials/2016-08-09/August-2016-Public-Minutes.html And now they'll just stop putting resources in the advancement of it and instead dump it on the open source community: https://blogs.oracle.com/theaquarium/opening-up-java-ee I wouldn't start a new project with it. 
But are there many companies using MicroProfile actually? Also application servers aren't really what you'd call "in demand" nowadays. Even the posterchild Eclipse IDE is loosing marketshare, fast. Is there anything Java-related in the Eclipse foundation, that isn't heading south? Vert.x and Jetty maybe. But then?
Kotlin has type inference without compilation time issue.
EE on the decline if EE 8 is about to come out? And as mentioned here already but Java EE as an API goes way beyond the concept of the "application server"; very little to almost nothing in Java EE depends on this. Implementations of this API can just as well put in the .war or merged with the app code into an √ºberjar.
MicroProfile is implemented by major servers; Payara, Liberty, etc which are certainly used by companies. The APIs are quite new so it'll take some time for any uptake, but they are available *now* in production servers such as Payara 173.
[removed]
Oh is in decline huh???? then explain me, please, why we do good business in making Java EE programs? Please? Have very full bag of orders and is 3 big one going live this month! Now you tell me again, please? Is in decline? Should not start üõ´ new project???! Please, think again!
I don't think Scala's long compile times have anything to do with local type inference. Scala makes heavy use of implicits, which I think is the culprit.
It's not really ever an issue in real practice unless you have some insane macro based implicit code. Most large projects I've seen are fine and you'd use an incremental compiler anyways so from scratch builds are rare. Also scala is mindful of their compiler performance. 2.12.2 I believe yielded a 30% compile time speed increase. They also publicly release their benchmarks. https://scala-ci.typesafe.com/grafana/dashboard/db/scala-benchmark
I haven't done to much Scala 12, so I am glad to hear they upped performance. Long compile times are an issue in many of the advanced languages I think, it's also an issue in rust for example. In my experience though you are right that incremental compilation fixes it.
Serverless means you don't pay for the server but only for the time your code is being executed. I meant serverless will come with different flavours and will hide loads of stuff we use spring or other frameworks to solve. The loopholes are related to how they will charge you for bugs that consume too many services/processing. Not cool mocking ppl that are genuinely trying to help.
I have yet to ever use Spring and lean in the same sentence. Yes Spring Boots modularity is nice but the dependency tree quickly gets out of hand once you start adding those modules. 
No, lol, that's not proof at all
It's true for C like big O notation gives you an idea of runtimes - yes, eventually it'll change over... but if the coefficients are 6 digits it'll take a while. I think it's already true of C as it is, the decay is just slow compared to "fad" languages.
In order for this to be true for C, we would have to start to see it replaced in mainstream systems projects like major OSs and browsers and the like. The only place I know of where this is occurring is Mozilla using Rust. Beyond that....?
The quote didn't say anything about old projects just newly established but even in the cases you mention Chrome is mostly C++, Windows is largely becoming C++/C# for the OS (outside legacy components), and it's exceedingly rare to find a AAA game written in C. Mobile has hardly anything written in C unless you're looking at the kernels they rely on (which even the big companies are playing around with rewriting in something else.) Don't get me wrong C is still big but it's not as big as it used to be and continues to not be used as much in new projects. The only place it really continues to dominate is embedded systems or kernels.
You can have a small jar with dependencies on various external libraries or one big jar with a lot of redundant code. That's true of any library, certainly any application framework. Our web systems have about 10MB worth of Spring Jars, including dependencies, while another has less than 8MB. When brought in to review existing systems, my personal observation has been that a lot of folks don't understand what they are installing. Rather than take the time to learn how a library works and how to configure it properly, they simply install it with all of the options and end up with a fat library. That's not to say that some libraries aren't unnecessarily large (e.g. BIRT) but Spring isn't one of them. 
I'm upset that you put R on the left and L on the right for that Either type.
&gt; New projects Why would we need to see existing projects stop using a language in order for new projects to stop using it?
i thought [Vert.x](http://vertx.io/) was pretty cool when i tried it.
r/learnprogramming 
May be I am no t talking about a simple app, jpa and cdi takes a lot of dependencies. But without these what is the advantage of swarm? I mean, why not start with dropwizard and wire everything by hand?
I've had crashes from faaar less complex lambdas. Also it incorrectly typing Supplier generics with Object til I hit resmfresh. That and m2e are about to see me switching
No it hasn't. If anything Kotlin has now elevated itself to be the premier Android development language. A lot of people never really took into account the Android bump when it came to the popularity of the Java language. I believe we're now going to experience the Kotlin bump as it rockets past other languages in language popularity charts. Also, the Dalvik VM died a long time ago. It's now called ART and the development of the Kotlin language has nothing to do with the evolution of ART when you consider that Kotlin still supports JDK 1.6 even though ART now supports Java 8.
The *Embedded Java* article on Wikipedia lists [a few alternatives](https://en.wikipedia.org/wiki/Embedded_Java#External_links) too.
**Embedded Java: External links** STM32-JAVA : Full product line for Java on Cortex-M3/4 from STMicroelectronics : Eclipse based IDE + dedicated part numbers STM32J (free samples also available for prototyping) STM3220G-JAVA : STM32 F2 series Java evaluation kit. Java SE for Embedded : Java SE for Embedded technology from Oracle Corporation 28 Kbyte Java Virtual Machine Supports 32-bit MCUs : Embedded Java for Cortex-M3/4 MCU from IS2T Corporation Java SE for Embedded Development Made Easy : Webcast covering development, troubleshooting, deployment http://www. systronix.com/ - Systronix TStik, JStamp, JStik : Small embedded Java systems, some with deterministic/realtime capabilities Google Android project : Open source project to create software for mobile devices such as the T-Mobile G1 phone JControl : Very compact Java Virtual Machine for Embedded Systems Mysaifu Java2 Virtual Machine MicroJvm : Java virtual machines for embedded systems, available for Renesas, Freescale, STMicroelectronics Excelsior JET Embedded : Compliant Java SE Embedded 8 for x86, x64, and ARM, with AOT compiler PTC Perc : a cleanroom implementation of Java Standard Edition with patented deterministic garbage collection for running realtime and embedded Java programs. Parallax : Parallax's Javelin STAMP, similar to the Basic Stamp but utilizing object-oriented technology instead of Basic Azul Zulu Embedded : Open Source Java for IoT &amp; Embedded Systems JamaicaVM : a cleanroom implementation of a virtual machine and build environment for running realtime and embedded Java programs. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Tried to make sense of the code but didn't fare any better than Eclipse. 
Apple, Microsoft and Google OSes. Now on mobile, but can later put links on how they are moving away from C into C++, Swift, Java, .NET Native.
Upgrade to Java 8, Java 6 is no longer supported.
A better proof is how constrained the NDK set of allowed APIs. Beyond drawing triangles, audio and a cut down set of syscalls, everything else requires JNI, even if it is actually implemented in C++ (Skia for example).
The new DEX compiler will work with Java 8 bytecode. https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html?m=1
The problem is that many still want to sell apps to those using Android versions older than Lolipop.
&gt; `))))))))))` No thanks.
What about IntelliJ's performance?
Android usage numbers indicate that 75% of users are on Lollipop or greater. KitKat accounts for 16% and anything older is irrelevant. So if you're holding back the development of your app for the 16% of KitKat users then you're doing a big disservice to the high majority of your users.
Serverless doesn't mean there's no server running your code. It means that the server is abstracted away from the developer. This "hurr durr there is still a server" is getting old :(
&gt; It's a persistent mystery to me that Spring wins all these threads since I've been in and out of dozens of media, finance, retail, etc business. Big and small. Plenty of companies you've heard of. I have not even once seen Spring be implemented or even considered by any of them And you don't see the huge selection bias here? 
But, some product support only java 6. They say that nobody has time to develop it.
And stuff like this is why doing "real" FP in java is a bad idea. The language just isn't there yet.
Have you tried those products under Java 8? Java keeps backwards compatibility so there's so general reason why they wouldn't work.
I only started to care about Lollipop as minimum version this year, other devs might think differently. There are still lots of 50 - 100 euros phones being sold in Germany with 4.4, and your quoted value should actually be 25%. Not everyone is willing to loose 25% of possible revenue.
I do...
Why do these writers have to be so dramatic with their titles? Next thing you know you have a bunch of morons parroting about a language being dead just because they read it has "risen and fallen" somewhere. Some of those languages aren't even a decade old yet. 
Good. Because 'here' (also finance) I see Spring everywhere and a lot less Java EE. It's almost like you get hired into roles based on past experience. I also really don't get these constant discussions. The similarities between Spring and Java EE implementations tend to be a lot more striking than the similarities between for example Drop-wizard and Java EE. I don't understand why people get upset if beginners get the advice to start with Spring Boot simply because it's easy and convenient. 
The percentage of developers targeting the 9% of devices below 4.4 are so low that I think it's irrelevant and the high majority of apps supporting those versions below 4.4 are probably not even maintained. If you're inconveniencing the high majority of your users by maintaining an inferior experience by supporting devices below Lollipop than your sales will reflect that. 
`invokedynamic` is the big thing. Customizable, fast runtime resolution of invocations. Very useful in dynamic languages and in languages which have invoke semantics not easily implemented with standard special/interface/virtual/static
No, corporate world has expensive Java EE servers so your app must run there and use its facilities. Spring dominates the "java +do it all for me" Google results that's for sure. 
visit the cetpa i think this is the right place for the learning the JAVA in a easiest way !!. Click here for more details :- http://www.cetpainfotech.com/technology/java-training
You are confusing two different things. The meeting you refer to was about what they were going to do people deploying to the Cloud instead of WebLogic. So why did they gave so much code to the community? Couldn't it be because they need to get people developing using their technology?
Xtend is a full-blown JVM-based GPL so it can be compared with other JVM-based GPLs. But I agree that it has not been marketed much so it's a poor candidate for the populary challenge that is the OP.
&gt; Scala developers generally consider the language superior to Java (or Kotlin) and won‚Äôt migrate to another one. Except migrating to Eta, Haskell or Idris.
Learn java the hard way is a good book and what I used to transition from Ruby and Python to java. It will def teach you enough to pass a high school programming class. 
I tried it. It doesn't work at all. Only works Java6.
In theory. In practice most large real world applications won't work. Spring, Tomcat, Mule etc... are funny about it, and they made a lot of changes for security and performancr which tend to break things . Source: software engineer who just spent the last 2 years on a java 6-&gt;8 migration.
On my case, it is the customers that asking for consulting services that care, not me personally. Such companies usually have free mobile apps as yet another channel into they products, so they want to have as much eyes as possible going into their services. As mentioned, Lollipop is now the minimum supported version on my case, but others might not want to lose 25%, depending on the actual dashboard values they are getting for their apps.
My personal preference these days is for Spring Boot, and Kotlin as the language. It works remarkably well together, and is so easy to get set up and working. If you want you can use JPA easily enough, or else just use JDBC - via NamedParameterJdbcTemplate - for database access. (I'm actually doing something with MongoDB right now using MongoTemplate, and it just works) You might also want to consider if you want to do REST - which Spring Boot does out of the box - or GraphQL - which you can do really easily with Spring Boot GraphQL Starter and GraphQL Java Tools.
Do the MOOC. It gives you all the basics plus a solid foundation in OOP and does support everything with lots of graded exercises. And next time, please ask such questions in /r/learnjava.
&gt; This "hurr durr there is still a server" is getting old :( If such statements pop up regularly or are confusing newcomers, this is clearly an indicator that maybe the term "serverless" is absolute garbage.
I've said it before, and I'll say it again: [Play! Framework](https://playframework.com) is my favorite. Make sure to check it out. 
Actually no, that's just because eclipse is shit.
does it say what it is chewing on in the progress window?
Likewise I don't get why Spring gets upset when people get the advise to use Java EE. It's a double edged sword really, or a pot and a kettle.
Have you heard the phrase "clickbait"?
`Flow&lt;Pair&lt;Path, DirectoryChange&gt;, Path, NotUsed&gt;` whats this BS. Just create a proper object already.
&gt; Elegant weapons for a more ... civilzed age [xkcd](https://xkcd.com/297/)
The progress window just says "Compiling" and it gets stuck at 93%. Sometimes I see multiple "Compile" tasks pile up, waiting for the first to finish. All this on a 13 line source file in a project with 3 files :-O 
I agree Eclipse is shit, especially compared with IntelliJ IDEA, but the truth of the matter, that people seem to not say here, is that maybe the code needs to be less complex and thought through better. "Simplicity is the ultimate sophistication."
If you were to zip up the project folder and find a place to publish it, I would take a look.
If only Java had `for` comprehensions like Scala, all of that explicit `flatMap` wiring would not be needed...
In an enterprise environment with complex dependency-filled setups there might be problems indeed but certainly not all of it will be because the Java language and libraries were extended. Also judging by OP's screenshot from a desktop system, it seems more likely to me that whatever his program is, it isn't a large enterprise application.
It might be worth figuring out why it doesn't work in such case. Or just keep using it like you always have which supposedly has worked so far.
"serverless" implies peer to peer or pure client side computing, which is anything but the case here. One could as well call SOA and remote EJB "serverless" then...
It sure has the stickiness of it :P
Sigh...clickbait title. Can anyone who watched that clickbait shit summarize?
Servles aren't out, they are just generally encapsulated away by a web framework. However, people that say "servlets are out" probably haven't bothered to keep up with the Java EE 7 spec. It is many times better than it used to be. People should at least take a look at it before deciding if they want to wrap up Java EE with a web framework. https://docs.oracle.com/javaee/7/tutorial/ However, if you really want a web framework I would recommend Grails, it uses spring boot under the covers. http://www.grails.org
Compilers these days are incredibly impressive in what they are capable of doing and optimizing, but at some cost. A lot of the developer doing it themselves is pushed into the compiler (type inference for instance) and obviously these things pay some computational cost. But since computation power has increased it hasn't been a big deal. But for the most part there are still some compiler features that are expensive to do. I believe the scala compiler has about 20-ish phases depending on what optimizations you enable https://typelevel.org/scala/docs/phases.html so looking at those, the scala compiler does a lot of shit, but most of it is "scala dealing in java's world". Obviously some phases are slower than others just by the nature of their goal, but yea, my point was that slow-er compilation time is a side effect of pushing a lot of considerations into the compiler.
One way to handle this is to copy your java 1.6 to a temp dir, then uninstall it and after that, move the temp copy back to the original dir. Then you install Java 8 in a normal way. That way, you can try using the old java 1.6 only for those special programs that don't want to update and run them by making an icon that runs java exe from the 6 dir and then the application. If you are not a computer tech guy this may feel a bit tricky but it works for some programs.
It was credible until it started comparing Java and JavaScript. The real reason Java is here to stay is because it has so much people invested in it. But there are many good alternatives already (such as Kotlin and Scala if you want to stick with the JVM). Java is trying to incorporate shiny features from other languages, but because of its backwards compliance baggage and JCP it moves at a much slower pace. Java does have a strong ecosystem to back it, but with something like Kotlin you can still use all of it without having to actually code in Java; yes I'm biased because I like Kotlin.
I think it lost its credibility well before that when it claimed Java was responsible for iOS apps and how swift was just Java with differences. Author has no clue what he is talking about. 
Wow, IntelliJ straight up murders Eclipse. IntelliJ was able to process this complex lambda expression without any issues at all. No noticeable slowdowns. IntelliJ even gave some hints to simplify the expression. You can replace this: tryE(() -&gt; ps.executeUpdate()).flatMap(cnt0 -&gt; with this: tryE(ps::executeUpdate).flatMap(cnt0 -&gt; One more reason to switch to IntelliJ. If only IntelliJ's git integration worked as well as EGit...
&gt; that people seem to not say here This is an *experiment* to see how well checked exceptions *could* work with an `Either` type. In reality, you shouldn't use JDBC this way. The proper way to use JDBC in Java 8 is *try with resources*. The real problem with this approach is that the existence of lambdas doesn't make Java a functional programming language. This construction is *idiomatic* in languages with proper functional programming support, such as Scala with `for` comprehensions, or Haskell with `do` blocks. Java 8 only makes certain constructs *possible* in Java, such as null safe traversal with `Optional`. Like `Optional`, an `Either` type could be *useful*, if you don't have too many expectations.
Yes, but you have multiple nested streams/flatmaps. How realistic is this? In the real world (at least in my real world :) ), I would never set up such a construct in this way. However, it is an interesting experiment!
&gt; How realistic is this? This is basically how monads work, and is the standard way to capture effects in functional programming. Nested functions allow you to abstract effects through delayed evaluation, only being executed when you actually try to extract values. For example, by delaying effects using nested functions, the `Either` type can short circuit the rest of the chain, finally producing a value (the exception) on the left side.
Then this is one reason I don't like languages like Scala (even though I have to use it from time to time). Even with short-circuitry you're effectively looping within looping within looping. It's bad form, in my opinion, even if by design in functional programming. I guess I'm just too old school for this. I see the potential for a O( n^6 ) algorithm in your experiment. For an experiment, cool, but for reality I would feel quite uneasy with that.
It's actually not looping (that is the effect of the list "monad"). Also, this is why `for` might be a misleading term for what Scala is actually doing. See the implementation of the `Either` type. It's basically a bunch nested `if` statements, which is an abstraction of how you would handle errors in languages that return errors through the return value.
Maybe I'm ignorant, which I'll admit, but doesn't flatMap run on every item returned in the stream? Are you saying there is only ever a single item in the stream?
`Either` isn't a stream, so `flatMap` behaves differently. A Java 8 stream is kind of like the list monad, you can use it to abstract a sequence of values, and `flatMap` abstracts processing a sequence of values.
Maybe, I can set the java environment to get the same effect.
I decide to use java6 without the security option : (
I see, so each one of the flatmap method calls is preceded by a method that returns an Either. Is that what you mean? Because at a glance, the only one that returns the Either is the processQueryResults. I guess that's kind of what I'm getting at. At a glance I don't know what's going on so it is seemingly needlessly complex (despite my original performance concern which you've explained isn't a concern). Thanks for the explanation. I'll research more on Either and Optional and see what, if any, benefit I can glean for my Java experience.
This is being pedantic. What are you supposed to say? "Use Spring MVC but use Spring Boot to bootstrap your project"? It is easier to say Spring Boot.
&gt; the only one that returns the Either is the processQueryResults That's because I statically imported `tryE` from `Either`. Once you enter a monad (like `Either`, `Optional` or `Stream`), you stay in that monad until you extract a value out of it in a terminal operation, because that is the "effect" you are working in. That's why `processQueryResults` *has to* return an `Either`.
Ah, that's what was eluding me. Thanks for the help in understanding!
&gt; Use Spring MVC but use Spring Boot to bootstrap your project Yes, you are supposed to say that. Because if you check the documentation for Spring Boot, you won't find much of anything about the details of Spring MVC. For that, you actually have to go to the documentation for Spring MVC in the core Spring Framework documentation. Also, knowing that Spring MVC is a different thing than Spring Boot will make searching for *how to use Spring MVC* much easier.
I don't know: Either&lt;List&lt;String&gt;, Exception&gt; reads a lot better than: Either&lt;Exception, List&lt;String&gt;&gt; It's a tradition that the "right" answer is stored on the "right", and the error is stored in the "left". But `&lt;R, L&gt;` just reads better than `&lt;L, R&gt;`.
If you search for the CVE number you can usually find a description of the problem in the Red Hat bug tracker. However these will be short. Getting more detail requires you to look at the patches themselves and have a good understanding of VM engineering. Often the security holes are somewhat theoretical in nature, i.e. nobody has actually tried to write an exploit, instead the issue was noticed during code auditing or review. The vast majority of CVEs do not affect apps like Cassandra or other server side software, as they're sandboxing related (i.e. for applets). A small number might be related to things like the Java SSL stack which may or may not affect you; depends on what the software uses. If you look at the categories for each CVE, then you can narrow down which ones to examine. But by and large there's no downside to upgrading when CPU releases come out, so, why not just upgrade.
There's a great app called SoloLearn with built-in compiler etc with guides f√∂r several coding languages. Easiest Way to start imo. 
Comodo do them for $60/yr if you buy for three years up front. https://codesigncert.com/comodocodesigning Yes, for small projects it does suck. It might be worth setting up a pooled code signing fund. Like, if you buy a cert, agree to sign other people's WebStarts for a small amount of money. 
I won't, you can't make me.
I think the Eclipse looked fine, even from the pinhole viewer I had to borrow. 
That isn't an object?
If only IntelliJ had workspaces, proper projects, platform widgets, looked decent, didn't try to use context to manage views but let me manage them, didn't have a 600 employee company in Russia who constantly infiltrates popular Java coder hotspots like this one and HN with fanboi ballywhooing.
[removed]
decline doesn't mean useless. it doesn't mean no customers. just means more customers are going to choose to go in another direction
&gt; decline doesn't mean useless In this crazy hype oriented world that stares itself blind on statistics regarding usage pattern, declaring something to be in decline pretty much translates to being or becoming useless. Even when you didn't intended it that way, this is unfortunately how many people would interpreted it.
What it is Jaybird? The official website doesn't contain any description.
ü§¢
And you don't see the huge selection bias here? 
Agreed, how's a new person supposed to ever understand what that is. Rx is hard enough 
Some developers complain about erased generics, but I, for one, prefer them. It‚Äôs nice having only one class file for all possible instantiations of ArrayList.
My biggest complaint is verbosity, *especially* the early versions(thank God for lambdas). It has improved, at least. Also the lack of composite name aliasing, which plays into the verbosity part. I have a bunch of methods that take a `Collection&lt;HugeEnterpriseClassNameBean&gt;` as a parameter, it'd be nice if I could create a small alias for that. Oh and whoever decided using Reflection was a good idea, fuck that guy. Refactoring and organizing code is a pain in the ass, and Reflections just make it worse by creating failure points at runtime. I know this isn't exclusive to Java, but it's the environment I see it the most.
SonarLint (http://www.sonarlint.org/eclipse/rules/index.html#version=3.2.0&amp;ruleId=S1612) does it to! (among other cool things)
be one of the people that people pay to make judgements based on reality, not hype. fancy tech isn't a solution. new tech isn't a solution. it just is. if you have a team of 8 experienced java ee programmers, then they can probably churn out a lot of business value using that technology, and changing it is going to take a long time to repay the investment. on the other hand, if you are building a completely new team or practice, you should probably weight up several options. maybe nodejs is a better fit for the things you need to build. maybe golang is, depends on the pipeline. most serious businesses don't make 7+ figure investment decisions based on reddit/HN hypetrains :-)
Mostly what I hear is that Java's "heavy", meaning it's usually slow and rarely performs well in low and mid-tier hardware. While I can think of some cases I saw that, I invariably think it depends on lots of other factors than just Java. 
What other object could there be here? The [`Flow`](http://doc.akka.io/japi/akka-stream-and-http-experimental/1.0/akka/stream/scaladsl/Flow.html) object comes from Akka and has a sensible type bound of `&lt;In, Out, Mat&gt;`. The `NotUsed` type bound is just a fancy way of saying `Void`, since there is no value materializing outside of this flow. The `Pair&lt;Path, DirectoryChange&gt;` is the type of the objects published by the Alpakka CSV parser. So, we have a generic `Flow` object sensibly parameterized to map the Alpakka input to a `Path` object output.
apple keeps sabotaging it is my biggest complaint.
I feel that too many good java proposals die a death of not being backwards compatible with reflection or serialization. And I have yet to need code I couldn't write without them.
&gt;It‚Äôs nice having only one class file for all possible instantiations of ArrayList. That's completely unrelated to having or not having reified generics.
If generics were reified, though, there would be an explosion of class files. Project Valhalla includes adding reification to Java, but it most likely won't be exposed at the language level.
https://projects.haykranen.nl/java/
Because Java has been #1 for a long time for good reasons and the people backing languages that are not #1 are whiny bitches. 
&gt;If generics were reified, though, there would be an explosion of class files. Again, it is unrelated. If the implementation is not a shitty one that would NOT be the case.
Bjarne Stroustrup once said: &gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. 
The method is `System.out.println(res);` it is a lowercase `L`, not an uppercase `I` (Stands for **print** **l**i**n**e.) Next time, please post such questions in /r/javahelp as is indicated in so many places on the subreddit.
JetBrains is a company from Czech Republic, not Russia, czech your facts ;)
Reflection is a critical part of java for me; how else would I have the code inspect itself to learn about itself? How would it optimize itself (automatic detection and application of push-down predicates and the like)? How would it enforce complex rules, freeing humans to rely on those being satisfied? How would I have it write comparators, serializers, etc. for me (yes, Lombok could do some of this, but not in the way I prefer)? How would it automatically generate my documentation (and I don't just mean javadoc ‚Äî I mean real custom application-level documentation)? etc. etc. If I didn't have reflection, I'd have to do a lot of this using some sort of interpreted code or domain-specific language, and that would bring in a whole host of new problems (perhaps performance). 
&gt; If generics were reified, though, there would be an explosion of class files. You are thinking of reified generics as being implemented in the same manner as C++ templates. This does not have to be the case.
I haven't really heard of Apple being relevant. Do you mean for the MacOS environment? Just wondering, because I'm used to all production systems being Linux. If you deploy to Linux, but MacOS has different behavior, though, that would certainly cause huge problems in development.
I think people complain because it doesn't move at a fast enough pace, but that's because of its backward compliance and JCP baggage. Newer languages like Kotlin, Scala, etc don't have that burden so they can implement cool new stuff faster. When people complain, it's mostly about the language, not the framework. The ecosystem is great and stable (lots of "standard" 3rd party libraries from Apache, Google, etc) and the JVM is pretty decent. Compare this to JavaScript where the ecosystem is much less stable: lots of libraries that become obsolete very quickly, low backwards compliance and dependency madness with npm (the LeftPad debacle).
* Java is a relatively verbose language. * Java used to be slow. It's not really slow anymore, but still has that reputation. * Java has a tendency to result in "enterprise" style coding, and excessive use of patterns and abstractions. https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition * Oracle's business practices are often questionable.
So you don't use Spring, JEE, Swing, JavaFX or any kind of database access.
Most of the Generics parameters are YAGNI / needlessly abstract. It gets harder to read. Just return `Flow` or rather the explicit, corresponding type. `Pair` and `Tuple` and the like have no right to existence in an OOD system. The whole thing is another example (e.g. Play) of how Lightbend tries to bend Java into some sort Scala bastardization instead of creating an java-idiomatic API.
tons of java ee servers have spring apps running in them.
Because developers like to complain.
I think a lot of the "heavy" is due to applets and in particular the applet browser plugin.
There are some things that people dislike even after using the language for some time (as opposed to those who only "heard Java was slow and awful"): - Checked exceptions and especially how they irk you all the time if you're starting with programming / the language, e.g. because the I/O libraries use them more than liberally. Yes, sometimes they've been overused in the JDK. Mostly a non-issue once you pass the entry and intermediate level programming classes. - The `byte` type is signed. Seriously, this makes *all* operations on 0-255 bytes awkward. - `==` is reference comparison, but should probably have been an overload to `equals()`. The good old saying for API design goes "Make the common thing easy, and the uncommon thing possible." ... Java got this backwards. - the lack of any methods on arrays - all objects have `wait()`, `notify()` et al., and an implicit lock. What a shame. - generic erasure, and more importantly no primitives in generics (for now) - `.clone()` sucks - serialization also sucks, but for different reasons - some other minor, but sometimes suprising things like silent lossy `long `-&gt; `double` conversions - Too much syntax have been ported from C, e.g. unstructured `switch` statements In general, Java is an awesome language, a fully matured platform that does the job. Its backward-compatibility policy forbids fixing some of the language-related and library-related (awk, corba) issues of the old times, and that sucks and a lot of people hate Java because oft his ancient baggage. A proficient Java developer knows most of these issues and avoids them. Modern Java is a lot different from what people were/are taught at universities, and that's a good thing.
Simple: Java went mainstream in the 90ies with an OOP style that basically made it a better C (compare it to Smalltalk). Even back then it was not the most amazing language in terms of style and features. Now it's 20 years later and Java hasn't aged really well (backwards compatibility?). The type system is okayish but falls flat if you want to do more generic things (Functor and all the functional Jazz, Sum types which exist for exception signatures but can't be translated into actual types so exceptions can't be checked at compile time sometimes) There were also decisions/tradeoffs in favor of verbosity (e.g. no operator overloading, no "magic methods" that make getters/setters obsolete, no map or list syntax) so Java code tends to get very long. Then there's Oracle, don't think I need to say any more. Finally Java found its way into the realm of enterprise software. Because software for companies is usually highly customized and complex, the code tends to become complex as well. Then you end up with convoluated xml configuration files and interfaces. TL;DR: People hate it because they hate the enterprise environment and its restrictions that lead to design decisions in Java. 
I feel bad for having the first comment be a negative one, but the list of advantages sounds like something I would have thought up for a school assignment. &gt; Java EE in an open source foundation would benefit from: &gt; 1. the open source culture that Red Hat inherently embraces &gt; 2. the opportunity to grow the community even more Giant corporations don't give a shit about community, in my experience. They certainly aren't making decisions based on open source culture, or permissive licenses. They decide things based on money. Money for them. Money for their shareholders. Money taken away from their competitors. If other ideals fit in with their message then great, but if not then never mind. 
Java has always had a very interesting relationship with Open Source and "openness" in general. I haven't always been convinced that it's a good thing, when comparing this to Microsoft / .NET's approach where nothing is community driven and everything is vendor driven. Sure, not everyone agrees with a given vendor all the time, but avoiding lengthy discussions with the community leads to faster execution - which may or may not a good thing, too. We'll see if this is a good move in the long run. Certainly a very interesting move!
JDBC uses reflection? Not everyone uses JPA.
Which is silly because Java performs so much better than Python, PHP, Ruby and such.
Yes, that is how database drivers are loaded.
Reflection is such a great thing to have.
**Sidebar** -&gt; **Do not post tutorials here!**
People complain about everything that's popular, because complaining about something niche won't get you clicks, just mehs.
The JDBC driver for the [Firebird database](https://firebirdsql.org).
&gt; Payara Is this server widely used these days? I assumed once Oracle offloaded Glassfish it would have died off.
&gt; Giant corporations don't give a shit about community, in my experience. Red Hat does. They give a shit because of the way they operate. They take an open source product, test it, re-brand it and support it usually in full cooperation with the community. That's their business model. The more community grows, the more options and opportunities Red Hat has. It's simple and it makes money. The point about culture is also valid. One of the main benefit mentioned to talented employees is open source culture and a lot of people care about that. Source: former Red Hat employee.
I don't know about Python and basic Ruby (not the Rails framework), but definitely better than some other praised languages. 
Yeah, I have a lot of respect for Red Hat. I mean on the OS level they are actually [working with the CentOS people](https://community.redhat.com/centos-faq/) now. And they [purchased from Netscape](https://www.redhat.com/en/about/press-releases/press-netscapeenterprisesolutions) an enterprise level CA and LDAP directory and then they go and fucking open source the shit and give it away for free! So now the world has [389 Directory Server](http://directory.fedoraproject.org/) and [Dogtag Certificate System](http://pki.fedoraproject.org/wiki/PKI_Main_Page) for free.
* Lack of value types * Lack of unsigned types * Fat JRE dependency * Slow startup 
Ironically Javascript is quite fast due to the amount of money thrown at it.
Java has better future. http://indiaoptions.in/software-courses/java/j2ee/
You need to copy&amp;paste the JSR number into a search field and 5 additional clicks to get from that page to the actual spec. http://download.oracle.com/otndocs/jcp/java_ee_security-1_0-pfd-spec/index.html
&gt; The good old saying for API design goes "Make the common thing easy, and the uncommon thing possible." ... Java got this backwards. I always thought the Java way was "Make common and uncommon things possible but difficult". Then you add some libraries to make commons things easier 
I was a huge swarm fan, then found Payara micro and i love it even more.
I like BootsFaces
Me too, great stuff
I think Payara is used a lot indeed, and increasingly more. They are involved with the MicroProfile as well.
Have you seen the Java streams API or the observable API that comes with JavaFX? Flows and streams are *necessarily* abstract because they are generalizing computational processes. In order to be useful at all, they have to have the level of abstraction that they do. The `Flow` type without generic type bounds would need a ton of type casts, like the pre-1.5 Collections API. Pair and Tuple aren't anti-OOP any more than any other collection type. You don't have to create new types for *everything*. But like maps, they can be abused, of course. &gt; creating an java-idiomatic API What Lightbend is trying to do can't really be done with a Java idiomatic API. You either need a very dynamic language (like Smalltalk or Lisp) or a sophisticated static type system with things like higher-kinded types (like Haskell or ML). If you look at the language and library improvements coming out of Oracle, Java is aiming to make these kinds of APIs *possible*, and changing what "idiomatic Java" API means. I for one encourage people to try stuff like this, to push the limits of Java and drive future language improvement, just like the original Java did with OOP.
Payara Micro is great indeed! :)
Java on Linux, MacOS and Windows (and Android) all have different behaviors, which has caused tons of headaches for our product that needs to run on all of them (my particular experience is with the networking APIs). These are often caused by differences in the underlying libraries. The Java API implementations tend to map directly to the underlying libs and thus have the behavior of the libraries rather than what is specified in the API docs. Java is "write once, run everywhere" only if you use just those parts of the standard library that are fully implemented in Java and don't use anything that depends on non-trivial OS services.
&gt; most serious businesses don't make 7+ figure investment decisions based on reddit/HN hypetrains :-) You'd be surprised, really, depending on your exact definition of "serious". Whenever something is hyped, you see a huge number of companies using that hyped tech. Or looking at it the other way around; you can quite accurately say when a project was started based on the tech it's using. Just lookup when that particular tech was hyped. For instance, Scala has existed since 2003/2004 and still exists. But the majority of projects started with Scala are from 2011/2012, exactly the moment when the reddit/HN hypetrains were in full motion. This includes very serious companies like The Guardian and eBay.
&gt; 17 YEARS OF TRAINING EXPERIENCE Yeah well maybe you should've updated your material in that 17 years. 
I skimmed the text and I read like 5 times how incredible gluon is and how everyone is using it. So.. it's more about gluon from gluon. I don't say it's bad, tho. I don't know much about gluon to give any proper critiques. Just my 2 cents.
Yeah, but then you're beholden to the vendor for any kind of improvements or support. The availability of a vast number of free libraries keeps me in the Java world, even though I'm often envious of C# features. On the other hand, this has nothing to do with Open Source, but rather Open Standards. Many Open Source projects are run under the BDFL model (benevolent dictator for life), which aren't driven by community driven consensus. On the other hand, Open Standards doesn't mean Open Source. The JavaEE APIs are driven by community consensus, but many implementations are closed source.
No mention of https://blogs.oracle.com/theaquarium/opening-up-java-ee?
Is this mainly just for native UI elements? Just asking because I've been working heavily with java for 20 years and really have not seen a breakdown of "WORE". But I would be working in web systems where everything is to a network protocol, not a native UI element. 
That's my point exactly, reflections the java API have become embedded in so much functionality of the language that its now a shackle around it. Taking a step back, functionality such as 'instanceof' (or better 'true' pattern matching) or (reified) generics *are* reflection, but implemented in an abstract way such that's the underlying implementation can change, this is good design. Reflections the java APi is more like taking a hammer and a crowbar to everything and extracting whichever pieces you need, and then putting it back together in possibly a different way (setaccessible im looking at you). This puts enormous design constraints on future language changes because now everything has to be decompose into the same components, lots of code now expects a very specific implementation. So every language design change now starts by asking the quesiton how does it work with reflections the api', 'how does it work with serialization'.. and its rarely a good answer. Best case scenario is often lots more dev hours spent per change to ensure compatibility. This is my outsider impression in any case, reflection the functionality can be good, reflections the java API is pure evil.
It might be easier, but you're not communicating anything of value. When talking about any of the dizzying number of Spring frameworks, you cannot possibly be too pedantic.
At first glance, I think you point makes sense. Most companies don't care about anything but profit. RedHat is a bit different though. And the only way you'll know for sure is to look at similar software companies at scale (i.e Microsoft, Oracle). RedHat leaves billions on the table because you can go and download their software for free. No lock in. No creative switching costs. Sounds like a pretty foolish money making strategy... They definitely benefit from open source, but so will everyone else. Disclaimer: Current RH employee
But it's Oracle and not Redhat who should be analyzed here; Oracle has always been the big bad regarding open source: They take some software and then close it up, change the licensing, etc., to squeeze every cent of profit from its users. The top-down, cathedral-style of development that Java has been under, has been one of the most frequent complaints in the Java community. For once, Oracle did something good here.
RestAssured
[OkHttp](http://square.github.io/okhttp/)
Finally RememberME: public @interface RememberMe { int cookieMaxAgeSeconds() default 86400; // 1 day ....... I wonder how it relates to JWT, though... Could this be used with JAX-RS for instance? 
And if the community is non-existent, red hat can't really do their thing.
This news means Oracle sees no way to monetarize JavaEE any more, and does not want to invest money in it. Oracle is not a company that open sources anything as long as they smell any money in it. Already they sacked JavaEE Evangelists and had worked on an internal project competing with JavaEE: http://www.theregister.co.uk/2016/07/07/oracle_java_ee_8 And JavaEE 8 is really just a bunch of patches and minor improvements. If this move proves to be actually good for the Java community (it could), then this is by accident, and not the intent of Oracle. If Oracle could, they would prefer to silently suffocate JavaEE lest nobody else make any profit from it, but their reputation would suffer too much, so they are shamed into giving it into the hands of a foundation instead.
Except that Java uses a compiler while Python uses interpreter. Compiler is supposed to run faster cause its optimized (which it does) but some other compiled languages like C++ run faster than Java and thats why people complain. My point: don't compare compiler with interprerer.
It's great to understand how threads work and the overhead incurred but you should almost never find yourself creating threads on your own. java.util.concurrent should cover a vast majority of your use cases and its very valuable to read through many of the classes in the package just to see what is available. Some highlights * Executor and ExecutorService with Callables and Runnables (also See Executors) * ExecutorCompletionService * CompletableFuture * CountdownLatch, CyclicBarrier, Semaphore, ect * Blocking Data structures BlockingQueue, BlockingDequeue, ect * Threadsafe collections like ConcurrentMap * java.util.concurrent.atomic
Would you rate verbosity as the first reason to complain? I have the feeling that a lot of developers get sick of it after having worked on old codebases for their job (your 3rd reason).
The future of Java EE in my opinion wouldn't be in the hands or IBM or Oracle. It is with Red Hat and other open source vendors (Payara, Tomtribe etc.). The explosion of innovation from these vendors is what I look forward to. I bet Oracle and IBM will just implement the new Java EE version but contribute very little.
http://docs.oracle.com/javase/tutorial/essential/concurrency/
I guess I'm wonder bread, I use the JAX-RS Client API with a provider (usually Jersey).
Yes, I agree with you. The knowledge that I am looking for is more about how threads works, jvm works, pools, GCs... 
URL
&gt; Have you seen the Java streams API or the observable API that comes with JavaFX? yes, Stream atleast is more or less ok (except e.g. flatMap) &gt; Flows and streams are necessarily abstract because they are generalizing computational processes. In order to be useful at all, they have to have the level of abstraction that they do. Why is it trying to generalize everything under one common type? Why does it have to be such a irresponsible god object / type. Just return something specific and explicit. One or two flat Generic parameters are ok, but once you nest have Collections in the Generics of the useless wrapper types like Pair / Tuple / Optional ... inside the Generics, it's getting overly-abstract. &gt; Pair and Tuple aren't anti-OOP They totally are anti-OOP. Name the things. Why are they afraid to create classes? It's not even difficult. &gt; What Lightbend is trying to do can't really be done with a Java idiomatic API. Then it shouldn't try. Actually it's all possible already without creating these unnecessary over-abstract monsters. Keep It Simple. Don't bend it into a Haskell parallel universe.
This is a pretty nice writeup: https://www.callicoder.com/java-concurrency-multithreading-basics/
OkHttp if project size or external dependencies are allowed. Wrapping HttpUrlConnection with a saner API if not.
[Async Http Client](https://github.com/AsyncHttpClient/async-http-client), which AFAIK is pretty much your only option if you need to make requests at scale.
Okay, so don't label them Right and Left in code. Name them T and TException.
Thank you for responding in this manner. In my experience, Red Hat have been a firm advocate of Open Source values, and have stood by their mission statement to *"be the catalyst in communities of customers, contributors, and partners creating better technology the open source way."* I can't really see a downside to this move from Oracle to embrace the community for JEE. 
Unless you need to specify headers
&gt; Stream atleast is more or less ok (except e.g. flatMap) What's wrong with `flatMap`? Its extremely useful for processing members of nested structures, which would otherwise require nested for loops. And if you don't like `flatMap`, you must really hate collectors and reducers. Conceptually, flows are no more complex than streams. So if you have no problem with streams, you should have no problem with flows. &gt; Why is it trying to generalize everything under one common &gt; type? It's not. Flows and streams each generalize *a* computational process, in OOP terms, that is SRP. The exact opposite of a god object. Streams generalize the patterns of producing and consuming a sequence of values, from iteration, collection and reduction. Flows generalize transmitting changes in input signals to output signals. With streams, you use combinators to describe a consumption pattern of a stream. With flows, you use combinators to describe a signal propagation network. Streams and flows also implement OCP. You customize the generic stream and flow by implementing interfaces which represent different custom strategies for iteration, collection and reduction. This prevents streams and flows from becoming god objects by letting them focus on the single abstraction that they implement. &gt; Just return something specific and explicit. That's what type parameters are for. Unless you also think `List&lt;T&gt;` is also too abstract. &gt; but once you nest have Collections in the Generics of the useless &gt; wrapper types like Pair / Tuple / Optional ... inside the Generics, &gt; it's getting overly-abstract. This has nothing to do with flows or streams, or even pairs and tuples. What about: Map&lt;String, Map&lt;String, Integer&gt;&gt; Is this overly abstract? &gt; They totally are anti-OOP. Name the things. Why are they afraid &gt; to create classes? So, instead of creating `List&lt;String&gt;`, which is too abstract, you would rather have `NameList`, because this is what it means to be OOP? `Pair` and `Tuple` are exactly the same thing. They are just containers, but with a specific number of members. &gt; Then it shouldn't try Who are you to tell them that? I'd rather let them try and let the market decide. &gt; Actually it's all possible already without creating these &gt; unnecessary over-abstract monsters. Okay, how would you go about creating a generic framework for building a signal propagation network that connects arbitrary signal producers and signal consumers? &gt; Don't bend it into a Haskell parallel universe. Adapting basic ideas from Haskell is not bending Java into a Haskell parallel universe.
org.apache.httpcomponents which work with http and https.
Red Hat is inevitably tied to open source. Since their products themselves are mostly free and they only receive a small amount with support fees, they lack the capital for a full blown r&amp;d department. So they depend on the community for innovation, just as much as the community depends on their reputation and knowledge to give some projects a boost.
Classic ad with a bullshit title.
But Java is way faster than JavaScript.
The left type might not be an exception. It can be any kind of alternative return. In this experiment, I used exceptions as an alternative return. Left and Right are just conventions that the creators of the `Either` type adopted.
I find it's often an anti-pattern when reflection is used, especially in a language like Java. What do you need to learn about the code that isn't available at compile-time? What optimizations are you performing that can't be made statically? Are you really generating documentation using reflection? I find the cases where reflection is the simplest solution to a problem to be *extremely rare*. YMMV of course.
OS services of different operating systems behave differently and it should be expected that Java cannot always make up for the differences. For example, unlike UNIX and Linux, Windows does not make an effort to be POSIX-compliant. That said, no other programming environment provides more platform independence than Java. 
Unirest has a pretty nice api.
Yes, but looking at benchmarks JS is faster than you might think. JS is a factor 5 to 10 faster than Python!
[Java Concurrency In Practice](https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601) is the book you want to read.
[removed]
Take a look at these slides : http://www.dre.vanderbilt.edu/~schmidt/cs892/2017-PDFs/ If you have access to safari, the author of the above slides has given a very comprehensive class on concurrency here: https://www.safaribooksonline.com/library/view/java-concurrency-livelessons/9780134070957/ 
yep - gluon, gluon, gluon. I was hoping to learn something about JavaFX, given the title. Reads like a marketing pitch. The upvotes on the OP didn't come from the community.
I may or may not agree with a lot of your points, but this one in particular I don't quite get: - all objects have wait(), notify() et al., and an implicit lock. What a shame. Why shame?
I would substitute developers for people honestly...
How much are you willing to pay?
[Retrofit!](http://square.github.io/retrofit/), which is backed by OkHttp. Also another comment referenced wrapping HttpUrlConnection if you have dependency restrictions, if that's true, [http-request](https://github.com/kevinsawicki/http-request) is exactly this, and is very well put together. It's a single class with static helper methods, so you could even import the single source file and remain dependency free.
Thanks a lot!!!
I generally have a problem with some things: * Type witness. It's legacy before compiler improvements and should not be needed to have some funky functionality. (Unless it is for showcasing?) * Deep nesting. Be it loops or blocks or recursion or Generics. I think there's almost always a (flat) solution that is more readable. * `Map&lt;String, Map&lt;String, Integer&gt;&gt;` looks like a sort of primitive obsession to me. It's harder to read and figure out. It also makes you deal with managing the inner map. If it was just e.g. a `Map&lt;Department&gt;` I could just have `Department` do it. I don't even have to know the details. It's plain data vs. data in a context-giving structure. * The problem with `Pair`, `Tuple` etc. is that it leads to combining things without the "self-explanation" that a proper type / class can provide: `Pair&lt;String, Double&gt;` vs. `Product` with fields `String name` and `double price`. And the type shouldn't be the same as e.g. `Category` with fields `String title` and `double rating` which could also have been expressed as `Pair&lt;String, Double&gt;`. The last point is somewhat close to `Map&lt;String, Integer&gt;` vs `Map&lt;Type&gt;` or the `List&lt;String&gt;`vs `NameList` problematic. Yes, imo `NameList` would be better if there were an easier way to get List functionality and generality together. I'm pragmatic in that regard. In Go lang they controversally decided to follow "`NameList`" to keep things simple. &gt; Okay, how would you go about creating a generic framework for building a signal propagation network that connects arbitrary signal producers and signal consumers? Doesn't sound like a really new problem. Build upon any message oriented middleware / JMS that supports subscriber and consumer. Camel, ActiveMQ, RabbitMQ, Vert.x. Heck you could take the new Java 9 [Flow](https://community.oracle.com/docs/DOC-1006738). None of them has an API like that `Flow&lt;Pair&lt;Path, DirectoryChange&gt;, Path, NotUsed&gt;` and requiring type witness `Flow.&lt;Pair&lt;Path, DirectoryChange&gt;&gt;create()`
[quicktype](https://java.quicktype.io) infers types from JSON sample data, then outputs Java classes and converters (Go, C#, TypeScript and other output languages are supported). We were inspired by tools like [jsonschema2pojo](http://www.jsonschema2pojo.org/) etc. that try to do the same thing, but we are taking a more rigorous approach, and so far we handle maps, type unification, naming, reserved words, and code generation a bit better. For example, we generate synthetic types ("unions") for heterogenous data, rather than simply using `object`. Tooling support is planned. This is a new project and we would love your feedback. Is this useful to you? What can we improve? Please let us know if there's anything we can do to generate more idiomatic code, or what additional options you'd like to see! You can also try our CLI: $ npm install -g quicktype $ quicktype -o LatestBlock.java https://blockchain.info/latestblock Thank you!
Jetty client. Works great, no fuss. 
Honestly, given that Glassfish is already open source, and the open source was always the reference implementation, that announcement isn't very meaningful. 
Feign which is backed by java.net by default
&gt; I generally have a problem with some things The things you have a problem with have nothing to do with flows, but the specific types being put into a specific instance of a flow. &gt; Build upon any message oriented middleware / JMS that supports &gt; subscriber and consumer. None of these technologies do what flows do. These would be specific signal producers and signal consumers. Flows are more like Excel. You can set up a bunch of relationships between cells. When you change the value of one cell, Excel propagates the change to all of the cells linked to that cell. Flows are a generalization of this kind of process. Thus, of course they wouldn't have an API like flows. &gt; None of them has an API Neither do flows. The API for flows is `Flow&lt;In, Out, Mat&gt;`. You're confusing a particular instantiation of the flow API for the flow API itself.
Retrofit/okhttp
These days I wrote a single wrapper class that makes HttpUrlConnection sane. It works great for 99% of my needs. (my recently written Kotlin version of this class is even better because of Kotlin's default and named parameter features). If I find something that my wrapper class doesn't work well for for whatever reason I usually use org.apache.httpcomponents. 
&gt; Oracle's business practices are often questionable Could you (or anyone else) expand on that?
But the API is `Flow&lt;In, Out, Mat&gt;` instead of just `Flow` that you then pass an object containing In, Out and Mat or a Function (and not some stupid Scala one) or whatever. The whole [Akka-Flow](http://doc.akka.io/japi/akka-stream-and-http-experimental/1.0/akka/stream/scaladsl/Flow.html) class is an abomination.
I use https://github.com/mirraj2/Bowser which is backed by http://www.simpleframework.org/
&gt; But the API is `Flow&lt;In, Out, Mat&gt;` instead of just `Flow` that you &gt; then pass an object containing In, Out and Mat or a Function or whatever. But the API is `Map&lt;K, V&gt;` instead of just `Map` that you then pass an object containing K, V or whatever. Why is that?
Hello! I'm the author of the NextRTC. I'd like to answer for subjects that was mentioned here. - Does it need log4j? I could use slf4j, but I at the begin I decided to use lombok annotation @log4j instead of @slf4j. Up to now it wasn't problem for any library user. - Spring It's optional dependency now. It was a lot of problems during the years with spring + websocket + different servlet containers. So every release of tomcat/jetty/undertow caused changes in my code (and also in dependencies). - Joda-time First commit of NextRTC (https://github.com/mslosarz/old-nextrtc/commit/787efa2c98592c501db30762641d69c70520def3) was in 19 Apr 2014. Java in version 8 has been released in 18 March 2014. A month after first release of java 8 I used in in my project. And you know what? I had to revert version to 1.7. I was forced to do it because of tomcat and jetty (first release of tomcat that was able to support websocket and java8 has been released about one year after java 8). So Joda stay with NextRTC in version 0.0.X, But in version 1.0.X I'm using ZonedDateTime from java 8. - Dependencies You're right. Maybe there is too many dependencies in NextRTC, but I'm pretty sure that project that has more than 3 years can be more rotten/devastated by time than this. I used Guava in several places before I move to java 8 when I move back to java 8 some structures like Table from Guava stayed and I didn't saw a problem in this. I found this topic by chance. Next time please create an issue in github. That'll help community and the author of library. :)
&gt; but some other compiled languages like C++ run faster than Java Not in all cases. The hotspot compiler can optimize on-the-fly at runtime, not just at compile time. 
Because Map is a collection and we are being pragmatic about it's wide and general usecase. Also you should always evaluate between `Map&lt;K, V&gt;`, `List&lt;X&gt;` with X containing K and V or simply `Y`. Flow could also be just Y.
Meh, it's... _ok_
I develop on a Mac and my server applications are deployed to Linux and my desktop applications (Swing) are used on Window boxes and Macs. I have never seen the cross-platform issues you are referring to. My applications are primarily client/server so use the networking APIs. I think you are just trying to spread FUD.
Yes, seems it can. Effectively remember me and JWT have things in common, in that a remember me token is essentially the result of exchanging credentials for a token. What data is stored in that token is up to the vending mechanism and yes, that could be JWT or JWT-like.
True, about things already being open source, but this now moves the spec and IP into OSS as well. The specs always had these somewhat weird license of requirements. As I'm not a lawyer I could not make head or tail of it, but they were definitely an impediment for contribution.
java.net.URL 
&gt; Because Map is a collection and we are being pragmatic about it's &gt; wide and general usecase. Because Flow is just a reactive connector and we are being pragmatic about is wide and general usecase. &gt; Flow could also be just Y. A flow cannot just be `Y`, just like a `Map` cannot just be `Y`. 
There's just no reason for such methods to live in all objects. It's like all objects having a `next()` method for being nodes in implicit lists. It might be sometimes useful, but 99.99% of objects won't ever use these. Again, it's the same API design principle - make the common thing easy and the uncommon thing possible. Low-level concurrency primitives are not commonly used, they are not easy to use at all, and therefore they should not be accessible everywhere. Java loves being explicit about things - you must state your types, you must state your generic types, you must write all the things that make Java verbose in order to be explicit. Having no `Lockable` type, and methods that are accessible for everyone, everywhere, makes things hard to follow sometimes (when abused). It leaks implementation details, internal state, methods that should be internal, to whomever you pass the objects to. Want to synchronize on an object for internal purposes? You better be sure you're the only one using that object, or that the synchronization policy is well documented (...which leaks your internal implementation details). Worse, it confuses people a lot. For the first year or two while using Java, you should simply avoid using these methods. Why? They're useless to you. So why should they be everywhere? They shouldn't. You probably should not care about these methods until long after you've been using ConcurrentMaps and BlockingQueues (unless studying for a CS course). They can lead to many subtle bugs and/or attacks. You can, e.g. lock on `Thread.class`. If you do that, no new threads will be able to initialize/start in your current JVM as long as you hold the lock. Last, but not least, apparently all objects having an implicit lock prohibits otherwise useful compiler optimizations.
Spring 5 (Oct 2017) will use reactive programming out of the box. Async non-blocking, and with back-pressure will be a huge boon to the community.
RestAssured is not an HTTP client though.
Intellij doesn't have it's own typechecker, it re-uses javac. Eclipse on the other hand has it's own java compiler, currently the only 2nd implementation of the java spec. The java 8 spec has a lot of issues and it's been a pain to implement. See https://objectteams.wordpress.com/2017/04/02/several-languages-java-8/
Thats where we disagree then. I start to comprehend some of Go's design decisions to prevent misuse.
But at end of day, is still Spring ü§¢
You disagree with the idea that a connector which connects a source and sink of different types should have at least two type bounds? Do you not want to give the compiler enough information to verify that your pipeline is constructed properly? Go doesn't even have generic types. I'll pass.
Retrofit + RxJava FTW
my library of choice
Apache HTTPComponents
Try to use it under load. See what happens
`URL.openConnection` then `URLConnection.addRequestProperty` sets request headers.
All of the main HTTP clients can handle scale when configured properly. Async Http Client was my favorite until I found OkHttp I find it much easier to use.
I don't care who ends up with it, just give me the question mark operator ffs.
Finagle HTTP has a Java-friendly interface and is fully async (also supports streaming).
The language has been slow to evolve as well with a lack of pattern-matching, first-class regex, multi-line strings and value-types, tuples, array-slices, there's a pretty decent list, each represented in some capacity in one or more modern languages. Value-types is being experimented with, and looks like they're pushing hard to get it into Java 10 (which I really hope has a short release cycle). Limited Pattern Matching has been proposed too. We shall have to see. The size of the JRE is improving enough in JDK9 that for many applications it will be dwarfed by image content and other media and really won't matter than much. Slow startup is also not as bad as it sounds. It's not so slow now that loading a large application is substantially worse with Java than many other platforms - again, that overhead being reduced in significance by other aspects of application initialisation. For short-lived commands it's terrible (and so's the memory footprint) - Java might get fast enough with the planned AoT compilation support but we'll have to see. Unsigned types aren't coming, and that's frustrating because so many data-juggling activities aren't signed-type problems but exceed the range of the same-sized signed-type. Without the unsigned types I expect quite a few algorithms will have a horrible time trying to optimise well. You _can_ hit your code with an ugly stick and get some optimisation through some intrinsified API calls but that adds complication and obscurity to algorithms that are probably already in the most complex 2% in any given app... Java has been playing catch up on language features for a while. Generics in Java 5, Lambdas in 8, Pattern matching and value types _maybe_ in 10 - hopefully we'll get to use those in production sometime next decade :-o Where Java excels is in backwards compatibility, a fairly good cross-platform story, very rich IDEs and other tooling and an absolutely massive and fairly healthy eco-system of good-quality open-source libraries. (of course that backwards compatibility is also an anchor to drag around - too much of a good thing?)
Have you ever used annotations? You may not have used reflection directly, but indirectly you do and often
That would be part of SE not EE and is rather unlikely.
Lol. Sarcasm?
[JAX-RS Client API](https://docs.oracle.com/javaee/7/tutorial/jaxrs-client001.htm#BABBIHEJ)
I don't understand the need for ? operator. Avoiding nulls in general by practicing good design goes a long way in not having to do != null all over your code.
well, it is a form of "expressiveness" and has nothing more to do with nulls than any other conditional.
I thought it was specifically for dealing with nulls so if I had a chain of nullable getters I could just use ? instead of repeated != null checks
Maybe I'm not understanding, are we not talking about the ternary operator? http://glenpeterson.blogspot.com/2013/01/ternary-operator-in-java.html
I think they were referring to the elvis operator. https://dzone.com/articles/java-8-elvis-operator
Ah thanks for that. I would use ? if I had to recon with nulls a lot.
Yup
It is good for small scripts. Simple and easy to use.
Pretty useful when dealing with long JAXB generated chains.
That's actually pretty amazing. Do you have a source? I'd like to investigate further
Nice, thanks for http-request.
Okhttp creates new thread per request. It dont scale. ButlerianJihad is right. Asyc Http Client is the most performant http client available to Java.
No idea why you're getting downvoted. Introducing something like the elvis operator would only make things worse. e.g my coworkers would then completly stop thinking about how to avoid null values and there'd be questionmarks all over the place.
Can you disable those field name prefixes? They aren't exactly idiomatic
You must be using high level APIs. Try building your own IP multicast protocol, and you'll see what I'm talking about it. Or you can just read though the bug tracker to see plenty of examples, many of which don't get fixed for years. Just because you haven't seen a problem doesn't mean that it does not exist. And why would I "spread FUD" about the main language I use for development? That makes no sense.
Why can't we just have nice things
&gt; What do you need to learn about the code that isn't available at compile-time? I want the code to be able to know its dependencies between tiny components; this is vital to how some of our systems work. Lots of easily-broken automatable code (e.g. ensuring exact compatability between object-comparators and serialized-byte-comparators) that is painful and risky for humans to maintain can be built automatically (and run efficiently) using reflection. &gt; What optimizations are you performing that can't be made statically? I mentioned automatic push-down predicates, like when a user of a data source is only going to use certain elements and can advise a data source to just send that information. Yes, that *could* be done statically, manually, and by humans, but it would be a huge amount of additional work and testing, and would be a whole new source of risk. There are plenty of other things, like looking at a collection of run-time-requested reports (composed from small tinkertoy-like elements) and automatically grouping them based on which data they need to consume. Tests of the integrity of the design are heavily based on reflection. Looking at various components and determining "if it does ___, then it must also do ___ but not ___" allows automatic enforcement of much more complex rules than, say, carefully-constructed generics would allow. Hell, there's even one case where it scans the bytecode to ensure that no unauthorized direct access to a particular class is being made. Tests like this make it much easier to maintain design rules in a team; instead of everyone enforcing everything manually and in code review, they can rely on it not building if those problems exist ‚Äî and it gives an error message which points to the problem and possibly how to fix it. &gt; Are you really generating documentation using reflection? Of course. It's about the only type you can do, when you don't have a team of tech writers (and I don't). Maintaining extensive documentation about huge numbers of components is rather easy with a doclet-type system that is fed by information gleaned from reflection tests, nearly for free. Anything else drifts out of consistency with the code unless a large amount of time/salary is put towards maintaining it. Yes, all of these things could be done manually by humans, at a rather large increase in development time, staff, cost, risk, and complexity. Or I could let the system be able to inspect itself (which is the power reflection attempts to grant) and implement those itself. Automatically. And with tests. 
The thread-per-request isn‚Äôt typically a bottleneck in practice. For synchronous requests you have a thread anyway. For async requests, your maximum of outbound connections is typically the limiting factor.
Oracle offloading Java EE stewardship? Is this a sign of their waning interest?
Standards based is overrated when it comes to EE.
Still not as bad as the frontend jungle with frameworks of the month and deprecation of the day.
I won't deny that, I absolutely hate the crazyness of the javascript world. But I thought we were talking about Java stuff, just because Javascript is worse does not make spring in this case or whatever else is being discussed better than it is. 
Ohh. It is. I have use case where I am doing 100k - 200k requests per minute. Async Http Client with BoringSSL (native extension to netty) and epoll is like 5 - 8 times faster. Additionally with OkHttp I had issues with maximum number of threads in system. Not to mention that every thread is consuming lots of memory. It's not too good running thousands of threads in your system.
But if your dev team can cope with the rapid changes in their frontend frameworks, they can handle Spring just as easily, where stuff still changes a hundredfold slower.
Unirest is nice for simpler stuff. 
I stand corrected, I didn't realize that.
what's missing in intellij git? 
**Sidebar** -&gt; **Do not post tutorials here!**
I am but I've never run into a jar with an excessive amount of nulls. The one time I've run into a lot of nulls was a bad web API that would return lots of nulls in it's json but it's not the norm and the Elvis operator wouldn't have been a huge help, I'd still be needing null checks.
A few generic comments: * Like /u/yawkat said; the underscores are not idiomatic Java, IMHO the default output should be. * You don't need @JsonProperty() for every field, only the ones that can't be mapped automatically. * It does not detect booleans properly, boolean fields get "is" instead of "get" as a prefix * I can't tell it to use doubles, integers or BigDecimals for numbers A few reasons it's not usable for me at all: * We tend to use lombok for these kinds of DTOs anyway, which your tool does not seem to support. * A LOT of this type of work is where I massage shitty vendor JSON to something that's palatable. A recent example I'm currently working in is where all JSON properties are PascalCased, your tool does not have an option to do that for me. * Your tool does not recognise that multiple object types actually have the same objects as fields for nested objects; it just generates separate classes for every single sub object. This means I have to implement more mappers. * It simply does not save me any time, especially due to the Lombok bit. Hope the feedback is helpful :)
Gotcha. Yes, that‚Äôs a lot. I‚Äôd be curious to see what performance you get with [Quasar](http://docs.paralleluniverse.co/quasar/).
I agree that (well written, maintained) libraries that allow language extensions are a legitimate reason for reflection. I still think I should be used as a last resort, because of the potential for abuse and complexity in debugging and analysis in general.
?
How many more times are you going to post exactly the same under worse and worse titles? Seriously, such titles are completely unnecessary and have no place here. You don't get it that it is not wanted here. You already were told that it is bloated, the equivalent of a Rube Goldberg Machine, etc. What you are doing falls under the [reddit rules **What constitutes spam? Am I a spammer?**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer) and there in particular: + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer.
I believe the one member's comment "Rube Goldberg Machine" I got last time was mostly a misunderstanding after a quick look at the project. Since then I added 10 YouTube tutorials to better explain the project and avoid misunderstanding. I believe spamming would be posting the exact thing over again; which isn't the case here? If the moderators still believe this is spam, I'm willing to take down the post as I care about and respect the community's rules PS: I'm just doing this out of goodwill trying to help everyone - the project is under MIT license and the tutorials are Creative Commons Thanks for understanding :))
I'm also against memory-based interviews. But in defence of the interviewers, you would know these things easily if you used them often. So you could view this not as a memory test, but a test on how often you code certain things. 
It depends on the position you're interviewing for. If your resume indicates you're a junior developer I'm going to ask questions that test your knowledge of the language(s) you would be working with. I want to be sure you've got the basics down so I can assign you work that's productive and allows you to learn things like frameworks and libraries. For Java I expect junior devs to know things like the Collections framework and what common interfaces are for. If you're just out of college, i.e. this would be your first job, I would tailor the interview appropriately but I would stress that if you got the job you would be expected to learn these basics on your own time. If you're an experienced developer I'm going to ask questions geared toward your knowledge of the frameworks and libraries we currently use. I want to see if you can start working right away or if you'll need time to become familiar with the tech we use. Our schedule might dictate that we need somebody who knows XYZ now and not someone who knows ABC but can learn XYZ.
Just completed my Http2Client that is part of my light-4j framework. It is the first Http2Client that doesn't need to have alpn in the bootclasspath before Java 9 is ready for production. https://github.com/networknt/light-4j/tree/master/client 
Thank you for the detailed feedback, it's extremely useful. * We'll remove the underscore field prefixes today. * We may introduce an option to drop redundant properties, but for now we took a conservative approach. * Can you give an example where we don't detect booleans properly? We'll update to "is" for boolean getters later today. * Numerics detection is a limitation of our JSON parser that we plan to fix soon. * Lombok is amazing! Do you think we should target it by default? * What do you mean by "massage" for PascalCased JSON? Do you mean you want to output massaged JSON? PascalCased properties are already lowerCased. * Can you share an example where separate classes are generated for the same object type? This shouldn't be the case, perhaps it's a bug. Thank you again for the detailed feedback, we really appreciate it!
First of all I would say if an interview consists of only memory questions that are relatively easy to Google then that is probably not a great place to work. There will be a lot of duds working there. Second some of those questions could easily be studied the night before so I would be a little suspicious of a candidate that seems to know then answer to NONE of those questions. There are some basics you should brush up on before every job hunt and I would wonder about a person who doesn't seem to spend any time preparing. Also, I would recommend you don't check out. Maybe mention that you know something about the topic but usually Google it when needed. Try to throw in some nuggets of knowledge. For example, "I know one of those is synchronized but I don't remember which one off the top of my head. I usually do a quick Google search to verify." You could also ask for hints based on the knowledge you can dredge up and still come out looking intelligent and like a potential team player (he's not afraid to ask questions). Hopefully, if you're interviewing at a decent place, they are using the basic memorization questions as a jumping off point for more conceptual problems. Like not just what's the difference between a LinkedList and ArrayList but why might you choose one over the other. Or in some hypothetical what data structure would you use and why? I think you would feel a lot better about your interviews if you just Google "java interview questions" and look over some of that stuff before you go on your job hunt. Even experienced people don't remember a lot of that crap so you're not alone. And you'd be surprised how many lazy interviewers do exactly that to come up with their list of questions. A few times I've seen people with the first or second hit on that search printed out and in their hand while interviewing me.
I have about 2 years of experience, but my team is all senior devs and I get a lot of their work as well, I‚Äôve done a lot of refactoring and performance enhancements, however the issue is most of the work is kind of support work... so I‚Äôm rarely writing completely new code... it‚Äôs just debugging other people‚Äôs code, but I‚Äôm pretty good at it, is that not a desirable skill?
The more likely reason is that they can't monetize it (charge for excessive licensing fees). They did the same thing with OpenOffice.
Right I guess so, but how often you use something isn‚Äôt an indicator of how well you can do that thing. Like on my current team, I used comparable maybe once, a year ago... I don‚Äôt remember anything about it, but when I had to learn it, I did and got the work done on time, if I had to do it again, I could.
Yeah I know, but right now I need a stable giant company that will give me decent pay, that‚Äôs why I‚Äôm interviewing at these places, not because I think they‚Äôre great places to work at. I mean I do know the answers to a lot of their questions, but apparently I don‚Äôt know the answer to enough of those questions, because I‚Äôm not getting any offers, although I did get one call back for an in person. And the follow up questions I got the other day seemed pointless, like she asked me if I knew Singleton, then when I answered correctly, she asked me for the syntax, I told her you create a getinstance method and you have an if statement in your constructor to check if it‚Äôs already been initialized, then she asked me what the access modifier was for the constructor and I was like oh I don‚Äôt know, I know it‚Äôs not public, but I‚Äôm not sure. But it‚Äôs like, what‚Äôs the point in asking that far in detail 
Play that up. Good debugging skills is what separates a skilled developer from someone combing through logs full of "x = 1, y = 2, z = -1". With your experience I'd consider you a junior dev still, but I personally would be assigning you not just bug fixes but smaller features to implement. I might not have you design a workflow, for example, but I would task you with implementing parts of it. If you're not getting tasking like that then talk to your team lead and let them know you'd like something challenging. Don't get discouraged with what you're doing now. You'll do it again in the future. I just got brought on to a project to help design and implement their rewrite; day I start higher-ups stop all work on the rewrite so now I'm sifting through bug reports for the legacy system. It's not glamorous but that's how things work out sometimes.
Well the work is just not there on my team... people are mostly sitting around... doing nothing... it‚Äôs terrible... I really don‚Äôt mind doing debugging work. I do like writing new stuff, but I enjoy both work. How many years of experience is needed to be considered mid? Because my tech lead said I‚Äôve done mid level work and he‚Äôd recommend me for a midlevel role. I mean I have an under grad in cs and I‚Äôm in grad school for cs 
I have over 10 years of experience in Java and I've never managed to get a job as a Java developer. :/
That sounds like a bad situation. I don't blame you for looking for new opportunities. As for what level I'd actually put you at, I'd have to make that determination after talking to you. Everybody advances at their own pace. Two years might be long enough for you to develop into a highly competent developer and warrant more responsibility. On the other end I worked with a guy for five years who never seemed to get better; he kept making the same mistakes and didn't put any effort into getting better. He never took advantage of company reimbursed training and didn't seek out opportunities outside of work (meetups, open source contributions, etc.). The fact that you're going for a graduate degree already speaks to your dedication. Don't stop learning. Keep reading about new tech and trying new things. Find something in the open source community you like and contribute. Put your code out there to be criticized and it will make you better.
I'm sorry, but if you can't remember the difference between `Comparable` and `Comparator` (literally English words) or the difference between a `(Hash)Map` and a `(Hash)Set` (basic collection types) or what `equals` and `hashcode` are (this one is actually _really_ important), I'm not going to have a lot of confidence in you as a dev.
Many answers can be found in Effective Java by Joshua Bloch. The book is worth reading for anyone interested in Java.
That‚Äôs crazy lol, I‚Äôve managed to work as a java dev for 2 years without using comparator or hashcode, I‚Äôve used hashmaps, i don‚Äôt think I‚Äôve used hashsets. But like the only thing I can remember is hashmaps have key value pair and hashset is just key, but like how they handle null values, which is threadsafe, I just google it when I need to
You have 10 years in one company?
How can you have worked as a java dev for 2 years and not used Comparator or hashcode? Comparator I can kind of understand if you don't commonly need to sort objects, but hashcode? Come on. Don't you use Maps and Sets? These "memory questions" (as you call them) are basic java knowledge that a Java developer should have, if you don't readily know them then you probably, in fact, aren't suited for the position. If you don't want to take the little bit of effort it would take to learn the answers to common interview questions then maybe being a developer isn't for you?
Good introduction, but the real pain comes when having to work with ThreadLocal variables (e.g. for logging), Exception handling, and testing.
So can you explain hashcode to me? I know that hashmaps use hashcodes to determine where to put the key, but what‚Äôs the point of overriding the methhod? I looked at the java doc and it says that it returns the hash value of an object, but to what end? Why would you ever need that?
Yeah, I‚Äôm doing some amount of studying during this time, but it‚Äôs really killing me, would you mind doing a practice interview with me and giving me feedback? I‚Äôm not that familiar with reddit, is there a private way to exchange info?
You have never used collections? What kind of projects did you do? Using collections pretty much requires you to override `equals` and `hashcode`. If you're willing to learn I recommend you to read the book "Effective Java". It thoroughly explains semi-advanced topics like collections, hashcode, comparator and concurrency. 
Thanks for this resource, I‚Äôll try giving it a read
You‚Äôre the second person to recommend that book, I‚Äôll check it out, what do you consider to be advanced topics? Also I am mainly doing big fixes.... I almost never write code from scratch
I wonder how often you're misusing HashMap if you don't bother with hashcode.
&gt; I‚Äôve managed to work (...) for 2 years without using (...) hashcode, I‚Äôve used hashmaps This is nightmare fuel.
tl;dr - you want hashcodes to give you a fast shortcut to determine if two things are equal. Technically, you can just return 1 for all hashcodes and things will "work" however, your hash-based collections will collide (return &gt; 1 thing) when comparing things so then they have to fall back on .equals() (across 'n' items) which can be a lot slower than comparing an integer. In addition to the slowness of .equals() vs. int comparisons, you've taken an O(1) operation and turned it into an O(n) operation. The bigger danger, is if you have two items that are equal (.equals()), but return different hashcodes. In this case, the quicker hash based comparison will return "not equals" and skip over bothering to do .equals() and you'll get hard to find bugs in your code (or it wont work at all). That's why people ask you the question. If you don't know all of that (or at least the underlying tl;dr), you're bound to forget that it matters and that's bad for business.
Why would I be misusing it? If I need key value pairs stored, I use a hash map, getting values is as simple as asking using the key, I did try reading up on hashcodes, but I still can‚Äôt figure out when you‚Äôd need to use it
Because equals/hashcode is what drives a HashMap. You're going to have unintended consequences when you do not consider how equals/hashcode is implemented in your key objects.
I was in your position about 10-12 years ago. I thought I was ready to be a "mid-to-senior" developer when I was a jr. dev. I too thought these memory based things were a waste of time (a lot of it is -- StringBuilder vs. StringBuffer for example). That said, a lot of it is very relevant to understanding intricacies of using Java for large projects. If you don't understand how Hash based collections work, you won't see the benefit (and costs) of using them. If you don't understand Comparable stuff, you might waste time when dealing with a TreeMap (or get confused when your Comparable classes don't seem to be working correctly `new TreeMap(Comparator)`, etc... Those are things someone needs to be aware of if they want the "whole picture." Beyond that, there's even more complex things to worry about, but this stuff is just a foundation to build on.
I've been developing in Java on/off (mostly on) since 1995. Here's my take on your response. A) Comparable I've written a lot of. I can't recall ever writing a custom Comparator, I'd choose to override equals and hashCode to keep the responsibility of the contract assigned within the scope of Comparable. The most popular answer on SO even concludes "there isn't much difference". If I chose to write a custom Comparator I (we) would have to ensure that it remains in sync with what the related Comparable is doing; worse, it represents maintenance risk should they diverge or the needs of the Comparable implementations using the custom Comparator change. B) I use and see the use of Sets to be infrequent compared to lists and maps. It doesn't help that the distinguishing factors are lost when bringing up "set is list of unique values" when someone chimes in with "yeah except if you use a sorted set ... Bazinga!!". C) I've always been in awe of the confusing state of the concept of equals in Java. If you have a case where you know equals needs to be overrideden and remember you will also need to override hashCode; you're won 3/4 of the battle. From there, I check for best practices because there are as many opinions about how to do this "right" as there are programmers. 
Personally I'd say advanced topics are specialized skills in a specific area, for example JVM bytecode or having an in-depth understanding big frameworks like spring-boot.
I‚Äôm still a little confused, because initially I thought the idea is if two hashcodes are not equal, it means you can skip using equals, because it means they‚Äôre not equal and that if they are equal, you would doubly check if by using equals(). Which is slow because it does object comparison on every item in the list or map. But now you said that two collections can be equal, but have different hashcodes, so you still have to use equals, so then when is it ideal?
I could perhaps forgive the comparator one more, but equals/hashcode and hash{set/map} are such basic and hugely used things in Java that you should really know them anyway. You should already be familiar with these concepts if you have done any moderate amount of Java before IMO.
How much more should I know about hashmaps and hash sets than they store objects unordered, hashmaps use key value and hash sets use keys, like do I need to memorize which support null values and which is threadsafe?
I agree that `Comparator` is not that frequent, it comes up a bit more in Java 8 functional programming. The main difference is that `Comparator` lets the end user pick the order, while `Comparator` is build-in to the object. A `Set` is always a `List` with unique values, doesn't really matter if it's sorted or not, altrough `TreeSet`s definition of "unique" depends on the comparator instead of on `equals`. As for writing `equals` and `hashcode` methods, just let your IDE generate them so you can't make a mistake. 
Different people will say different things but I think everybody should have the experience of writing their own ArrayList and HashMap to really understand how they work internally. Again, they are such fundamental concepts, not just in Java but in pretty much any language that you meet. Take Javascript for example where every object is really just a glorified map.
&gt; I know that hashmaps use hashcodes to determine where to put the key You pretty much explained it to yourself; however, "where to put the key" should instead be "where to put the value". The hashcode of the key determines which bucket the value will be stored in. If you have multiple keys with same hashcode, prior to Java 1.8 the values were stored in a linked list, in Java 1.8 they are now stored in a tree so a Map with lots of collisions performs much better in 1.8 than prior versions. As far as "why would you ever need that", you would need it if you are using a custom object as a key into a Map (or something backed by a map like HashSet). You would need to implement hashcode() on your custom object. If you implement hashcode() you also need to implement equals(), and equals() and hashcode() should be consistent with each other. The javadoc for hashcode() and equals() explains things quite well: * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode-- * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-
not really, as my job is to protect my company, and get asked by the same java developers to 'prove' it's vulnerable, all I'm looking for is a more technical discussion concerning what exactly is busted. And I doubt very much that java is 'profitable', I don't hear about bug bounties for Java vulns... Oracle would never allow it. don't get me wrong, I'd love to get into exploit development, but I'm afraid I'm a little ways off from that. I'll have to thank you for thinking I'm looking for exploits on my Slack and podcast.
yea, I did notice that the RedHat and Slackware patch pages had a bit more info than Oracle's site did... I've got them bookmarked, so I can at least refer to them. I didn't come from a development background, so speaking with devs about what constitutes a vulnerability in Java sub-systems when they themselves don't even know what subsystems are and what they do is a daunting task. Also, I started following OpenJDK's mailing list, as it appears that they follow Oracle's java, so a lot of the codebase is the same, it is my hope that people there have better and more open documentation.
You are supposed to use a singleton ObjectMapper. Creating a new instance every time you serialize or deserialize is like the number one bad practice with Jackson.
Uhh... I totally agree with this. Difference between a map and set is fundamental knowledge. Knowing how values get identified as unique in a hash map or hash set is also fundamental knowledge. If you're (you being OP, not the poster above me) a self-taught programmer who finds that they're generally able to complete tasks without problems for a couple years, that is well and good, but being a programmer is sometimes more about preventing problems in the future than solving them now. If you don't know how Java objects identify themselves as unique in a map, you're in for a world of hurt when some super mysterious production bug is overwriting data somewhere along the line with no errors to even give you a clue as to why. Some of this stuff is basic computer science that you might pick up in data structures courses or whatnot, but you can give yourself a very thorough Java-specific intro on most of these things by using one of the SCJP prep books. They're actually a pretty good primer, even if you have no interest in taking the SCJP certification tests. If you're really serious about getting a job in the industry, spend a few works and really read it and think about what you're reading and the majority of these interview 'memory' questions should be a breeze. 
Nice clarifications, the thing about the IDE though is that we shouldn't allow the baroque representations of an arbitrary IDE to determine our code quality.
* Hashcodes should not be different when objects are .equal() * Hashcodes can be equal when objects are not .equal() -- not ideal, but nothing will break outright This is akin to: A square is always a rectangle but a rectangle is not always a square. I did not say that two collections should be .equal() and have different hashcodes. I said that is a 'bigger danger' (of improperly implementing equals/hashcode). It CAN happen -- if you did it wrong. It is always ideal for `o1.equals(o2) == (o1.hashCode() == o2.hashCode())`
I've coded in Java in about 4 jobs in 3 companies. But every time I've appied to a job with Java specifically mentioned in the job description, I've been rejected.
I'm using InteliJ Idea, and I once checked the implementation it produces, so now I know for a fact that it's correct and I don't have to worry about it anymore.
&gt; If I chose to write a custom Comparator I (we) would have to ensure that it remains in sync with what the related Comparable is doing; I just wrote some code that resorts a table (List&lt;TableRow&gt;) using Collections.sort with different Comparators based on the column and order the user selects for sorting. It's not the sort of thing I do all the time, but it sure made the code quick and easy. Of course, I'm off in the land of Java 6 so maybe this sort of thing is much less common in newer versions.
Most of the time, ArrayList is sufficient. LinkedList is used in rare cases when you frequently need to insert or delete elements in the middle of the collection. Set is used when you don't want to store duplicates. Obviously, the definition of duplicate depends on how you define the equals method (and accompanying hashCode). HashSet, an implementation of Set, is used when you want to quickly check for the existence of an element in the collection using the contains method. (HashSet offers O(1) performance, ArrayList offers O(n) performance)) SortedSet, an implementation of Set, is used when you want the collection to store elements sorted. Obviously, the definition of sorted implies that the element implements the Comparable interface.
Items that are equal but have different hashcodes are a mistake - one the can cause really odd bugs that can be difficult to figure out if you don't understand the mechanism. It is also the sort of thing where the code can work *almost* all the time - particularly in a small/test data set. Understanding the hashing mechanism is critical to understanding and finding these bugs.
You override hashCode() every time you override equals(). You override equals whenever you need to store the object in a Set or Map. (amongst other reasons)
IMO, debugging is 10X harder than writing new code. Debugging other people's code is 100X harder.
So if hashcodes are equal, there is a chance the objects are also equal, but there‚Äôs also a chance it might not, because of rounding to get the int? But unless implemented incorrectly, hashcodes can‚Äôt be different for objects that are equal()??? Do I have it down yet??
I always defer to folks with more expertise, which is probably most of the people in this sub, but for what it's worth, I think if you are using keys in your HashMaps that aren't custom Objects and you haven't overridden the equals() method, you don't really need to deal with hashcode. I will happily stand to be corrected if that isn't the case. But 99% of the time I'm either dealing with Map&lt;String,?&gt; or EnumMap. But importantly, there are a number of things that rely on objects adhering to the rules - and I personally couldn't tell you what might break and what won't. So I just make sure I override hashcode when I override equals because I don't need that pain in my life. ;)
I've used a variety of tools, a tool will never produce exactly all the code for all scenarios all the time that is unquestionably maintainable over the lifetime of the code; that's unquestionable.
Okay, see everything you said I know, I know when to use linked list over array list, I know, but I actually didn‚Äôt know about sortedsets, and in turn that it used comparable to sort
If they keep asking the same questions, why don't you just learn them?
I mean I kind of tried, but I always end up forgetting them or can‚Äôt explain well because I don‚Äôt use it enough 
Here's a concrete example where understanding hashcodes is important. Suppose I'm writing a system that handles car insurance policies. Each policy has a unique identifier (1, 2, 3 ,4 etc). I need create a collection of policies where I need to contact the policy holder so I decide to add these to a Hashset. I'm using a set because I might end up trying to add the same policy to the set more than once, eg if there is more than one reason why I need to contact the policy holder. If I don't override the hashcode/equals implementation then it will create a hash based on the values in the policy so I do: set.add(policy1); policy1.setEmail("me@newemailaddy.com"); // some time later in the code set.add(policy1); then policy1 may appear in the set twice as the hashcode has changed. In this case I need to override equals and hashcode to just look at the policy id as if two policies have the same id then they are the same policy. Hope this makes some sense. 
FTFY: &gt; So if hashcodes are equal, there is a chance the objects are also equal, but there‚Äôs also a chance it might not ~~, because of rounding to get the int~~ It has nothing to do with roudning. YOU are the developer. YOU make the hashcode implementation that is appropriate. btw, after thinking about it I think my tl;dr statement above should be amended from: &gt; you want hashcodes to give you a fast shortcut to determine if two things are equal. to &gt; you want hashcodes to give you a fast shortcut to determine if two things are not equal. 
&gt; There‚Äôs a danger here that this will make running Java a 2nd class citizen on containers that run on a Mac OS X or Windows machine (two of the main platforms that we see out in the wild alongside Linux). I've been dipping my toes into the Docker waters, I have a production JVM app running inside of a Docker container in an Ubuntu VM in a Xen host. It runs equally well inside Ubuntu on a VirtualBox VM on my Windows 10 Desktop. It seems like as long as Docker containers are restrained to a VM which itself runs on any popular host OS, I'd think that there should be better compatibility but welcome actual improvements in JVM awareness. 
maybe, that they use `equals` to determine the containment. E.g. using unpersisted JPA entities where `equals` is using the table key attribute.
I took /u/nutrecht to mean class proliferation, not redundant instances of a potential singleton. Can you point me to more info on this bad practice? We've never considered 'value unification' beyond possible enum support.
Nevermind! I see what you are referring to. Thank you, we will fix this.
Well I'm pretty sure the code it generates is _always_ correct whenever `equals` basically means "ensure that all fields `equal` each other".
The contract for hashCode says equal objects must have the same hashCode, otherwise weird things start happening, such as contains on a HashSet no longer working on equal objects. It's possible, due to coincidence and the limited number of hashes (it's actually a long, not an int), that 2 different objects have the same hashCode. Your job as a programmer is to make this uncommon, usually with some weird prime number multiplication. The reason for it is to speed up operations that assume that hashes are different for different objects. If you don't know how to write a mathematically sufficient hashCode, you can use `Objects.hash(property1, property2, etc...)` which does the calculation for you.
Check out the top posts of /r/java and /r/programming for two examples: * [Shipping browser toolbars with the JRE](https://www.reddit.com/r/java/comments/23y4l7/i_hate_you_for_this_oracle/?ref=share&amp;ref_source=link) * [Suing Google for using Java in Android](https://www.reddit.com/r/programming/comments/4l77w2/google_wins_trial_against_oracle_as_jury_finds/?ref=share&amp;ref_source=link)
But /r/java told me that containers are bad
It's kind of dismissive, but if it's not causing issues then you have no reason not to continue with it.
[This blog series by Dan Lew](http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/) was helpful to me for the basic concepts. It's RxJava 1, but it is still a good place to start and will give you some context to understand why RxJava 2 made some of the decisions it did.
&gt; LinkedList is used in rare cases when you frequently need to insert or delete elements in the middle of the collection. Even then, in almost every case an array list is still going to be faster, linked lists should, imo, just be deprecated and forgotten.
Only Docker is bad. [Linux containers](https://linuxcontainers.org/) are good.
I would put literally everything I can, along with a few simple files explaining the basics of UML and Design Patterns just so I can easily reference them.
The Java documentation is definitely a good choice (and it is fairly small). BTW: Such questions don't belong here. They should either be posted in /r/javahelp or in /r/learnjava
Why exactly?
to see if you know Java knowing the difference between public private protected and default is basic java 
I can understand the StringBuffer vs StringBuilder. You barely use them in modern Java... maybe 10+ years ago though 
I know the difference between access modifiers, I just didn‚Äôt memorize Singleton classes have protected constructors, I think that‚Äôs fair to forget if you‚Äôve only used it once maybe twice
What's the point of a singleton if the constructor is accessible? 
What's the point of a singleton if the constructor is accessible? 
Right, I get that... I just messed up in the heat of the moment, but it doesn‚Äôt mean I don‚Äôt know it....
if you mess up a simple question like that how are you going to response when you have upper management putting pressure on you to get something done yesterday 
I currently do my work well even under tight deadlines... interviews for me are just completely different
I'd rank that level of understanding fairly junior. Knowing when to use a type of collection fluidly is kind of important. For instance a useful property of sets is each entry is unique(as determined by the hashcode in the case of hashsets) which makes them useful for things like say deduplicating data. If I told you to deduplicate something and you didn't have that on the top of your head somewhere you might implement something stupid. Also strong evidence you haven't done much with ORM's those frameworks abuse that shit. In practice though just hit the little autogenerate hashcode and equals thing in you ide and you're probably good.
Right but all these things are things I can... learn? I had to create a couple of hibernate mapping files... but like once or twice over a year ago. It wasn‚Äôt difficult at all. Literally googled and created, lead or senior code reviewed it, it was fine. And I do know that you can‚Äôt have duplicate keys in hashsets and maps, but they asked for differences not what they had in common
comparator may come up if you don't control the code for what you're comparing and don't want to or can't extend it.
Have you worked around other java devs? you may have developed bad habits on your own that interviewers are seeing.
maps have the added property of mapping between a key and value :p the keys are normally stored in some form of set, or enum, some kind of thing with a uniqueness property, the values are more like a sort of listy thing but they have to correspond to a key. 
That sounds familiar, I think the rare occasion I've used them it was that, thanks.