What I mean is that I would like to have a single source set (src/main) which contains code in different languages (Java, Kotlin, Groovy, Scala, ...) and compile them together in a single step. Current interoperability works only good with Java (Java-Kotlin, Java-Scala, Java-Groovy. In case of Groovy it doesn't even work with Java when AST transformations are heavily used...). And it only works with Java because it is the default JVM language and each compiler creator does an effort to integrate the Java compiler. Joint-compilation between languages which are not Java currently only works with "stub compilation". And there are a lot of cases where this doesn't work. For true joint-compilation, the different compilers would have to "talk to each other" through a common interface/api. Because Graal/Truffle seems to provide some kind of common infrastructure to build languages, I was curious if my described use-case would be possible or planned in the future with Graal. For reference: https://discuss.kotlinlang.org/t/integrating-kotlin-into-java-scala-project/2554
Mine just stopped starting for no reason. :(
So much catharsis reading "This is a typical dialog you could expect to see during installing an eclipse plugin:", and that ridiculous "feature list". So many wasted evenings. So much confusion since the plugin architecture seems entirely user-hostile. Been using NetBeans happily for a good while until it spontaneously broke (possibly incompatible with a JDK 8 update).
JNLP was our preferred deployment mechanism. A pack200 JAR is much, much lighter than a bundled runtime.
`java.util.concurrent` is so damn legit 
It looks like in your [submission](https://www.reddit.com/r/java/comments/8fdn9z/problem_with_installing_java_on_ubuntu/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Some of us live in fast-evolving Java-friendly shops...
&gt; The runtime for Electron is an instance of Chrome (chromium) which is bundled with an Electron app. So you most certainly need a runtime. But the web interface does not rely on *Electron*, only the desktop one. That's why web applications based on the *Atlas* toolkit work straight in any HTML5 compliant browser, even being entirely written only in *Java*. &gt; Either way I have no idea why someone would want to write a desktop app using web technologies. Before using web technologies, I've tried *Qt*, *GTK(+)*, *wxWidgets*... Which technology do you think that should be used for desktop interfaces, and why do you think that it would be better as the web-based one ? 
I guess what I‚Äôm wondering is whether they are actually nearing completion, or whether they are just listed there because they are being worked on.
Here's my incomplete English write-up for cross-compiling on Debian: &gt; https://wiki.debian.org/PortsDocs/BootstrappingOpenJDK
Right...‚Äùfun‚Äù
[Luddite luddite luddite luddite lu-ddite!](https://www.youtube.com/watch?v=K6f6BNp1q1Y) Seriously though, I'm not a fan either. I like to read and sample that sweet copy pasta example code whenever possible.
Azul and AdoptOpenJDK project have indicated that they will backport fixes. https://medium.com/codefx-weekly/no-free-java-lts-version-b850192745fb https://www.azul.com/java-stable-secure-free-choose-two-three/
Would be nice if Windows is supported though. 
thanks for the links, the Azul one helped a lot. my opinion on the options: * free and secure - only good for personal projects and startups, 6 months with no overlap is too fast paced and risky for established businesses. * free and stable - many companies will probably go this route since many are already doing this such as companies still on JDK 7. * stable and secure - big mega corporation will have no issues paying Oracle. Java community had it good for a long time but those times are ending. does any other ecosystem do better or is Java reverting to the mean?
&gt; It's 99% the same, but the 1% is important (such as SSL certs) and that makes it unusable in production. Exactly this. I considered OpenJDK, but unfortunately the font rendering on MS Windows is broken (text shifted vertically)
How could it be ending? What, exactly, has happened that has shown you that the end is nigh?
No, this does not necessarily follow. I think the idea is that Iterable as an interface has sort of become a replacement for Collection in the java world - used as a general-purpose container interface under the assumption iteration does not update the collection. On the other hand, forEach is just a method, not a part of a shared interface between collection and stream. Comparing a method with an interface isn't really fair, because two methods of the same name can't be used in the same place. The better comparison would be comparing forEach to the iterator method on collection, and that one does exist on stream. Of course that doesn't help you when you want to use enhanced for.
Since that's not what's happening here, you're question is a little odd. Not programming to the interface, in Java, would mean using reflection to manipulate private fields. (In C, it would be using pointer offsets.) Every call to a public member is done via the class's public interface, so you are still "programming to the interface". The confusion comes from the interface keyword in Java, which really means "abstract interface". 
ThStackoverflow Thread: https://stackoverflow.com/questions/147181/how-can-i-convert-my-java-program-to-an-exe-file
I used JSmooth for that and found it to be very easy to use. 
Java never has just one of anything. 
jpackager isn‚Äôt half bad nowadays.
Yep, linux is quite better. For instance graal does not work to compile on the just installed fedora 27 because it has an issue to find gcc (that's the first issue). I am for sure I demanding customer because I want it to work out of the box! That is unacceptable! I have to take my part of the work and spend one hour to make it running :-)
We had this discussion here not so long ago.[ Take a look at this thread](https://www.reddit.com/r/java/comments/7ukei4/best_tool_for_packaging_jar_file_as_desktop/)
2040 is not a low number in statistics sampling. The issue here is not the number, but what they represent http://time.com/4568359/george-gallup-polling-history/ 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you are familiar with cloud development company Bitnami https://bitnami.com/ they have a tool "InstallBuilder" which builds a java executable for any platform http://installbuilder.bitrock.com/. Its not opensource with a commercial license. Its advantages are it targets most languages and works really well. Its worth reading its documentation to get an understanding of what you need for commercial application packaging. "Sometimes they even bring their on JRE" Yes, for a broad non technical client base developers do not want to be asking clients to install java to run an application. Below is a guide as to how you would use it for a Java application to make an installer. http://nsavagejvm.netlify.com/2016/11/issues-generating-installer-with--bitrock-installbuilder/
launch4j works ok for this
I mean the difference between "choosing a non-representative group" vs. "not having the means to selecting one". 
lol
wow!! helpful information.
bruh
This appeared on the first spot of my Reddit frontpage. [???](https://i.imgur.com/Ed4LdEW.jpg)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://i.imgur.com/Ed4LdEW.jpg) - Previous text "???" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
thanks :\) 
Also: 15 points (i.e. at least 15 upvotes) in 16 minutes after posting. For nothing but a title. Totally not vote-manipulated. /s
:)
[removed]
wow..
Ah, and now here's the real spam link. Thanks for the downvote [in the thread you deleted](https://www.reddit.com/r/java/comments/8fj2e0/top_10_popular_java_projects_on_github/dy3xvis/), /u/mahadehasan. Care to explain how an empty post with no link was immediately upvoted?
This is a heavily vote manipulated post. The article itself is garbage, and has way too many upvotes in 29 minutes based on this subs activity level.
&gt; The article itself is garbage Most of the texts are copy/pasted from wikipedia. Also the link for TDD (test driven development) is to a random github-account named "[tdd](https://github.com/tdd)", not in the slightest related to the actual programming technique.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/tdd) - Previous text "tdd" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
AtomicReference/AtomicReferenceFieldUpdater: First appeared in Java 1.5 AtomicReference wraps a complete object in a controlled environment, whereas AtomicReferenceFieldUpdate allows you to use an attribute of an object but does so via reflection. Different functions for different purposes. sun.misc.Unsafe - there are many internal implementation classes needed to bind Java code with the operating system and none should ever be used. VarHandle: introduced in Java 9, this is an evolution to a cleaner model that is moving to replace the sun.misc.Unsafe as described in [JEP 193](http://openjdk.java.net/jeps/193). It is being used internally in the AtomicReference class now instead of sun.misc.Unsafe. So what you're seeing here is not that Java was just throwing in multiple approaches to doing the same thing, they are for different purposes. 
Yes, seems that way. I've reported it to the mods, maybe they removed it. Either that or Reddit's fabled automatic anti-spam mechanisms kicked in. /u/desrtfx (sorry for pinging), was it you or Reddit itself?
Well, with jdk 9, these it should be possible to bundle a minimal jre using only what your java program require. Yet, not sure which Java bundler has these features at the moment. 
Article is 2 years old. And, Eclipse has improved a lot since then. I am using it since past 1 decade and feels it is getting better by the day. It had few major UX problem during JUNO release (2012). And, it was due to major refactorings in the IDE. But, it has continuously improved since then. I normally have Springsource Tool Suite, which has all the bells and whistle for Java Development with Spring. For Database access, I use this wonderful plugin called DBeaver. For Theme, Darkest Dark Theme is wonderful or Clean sheet. Use Mylyn to manage all my tasks. Some features of Ecilpse, like Mylyn are under-utilized and people don't know about it. But, they are such a productivity boosters when working on multiple tasks.
Result: sad üòÇ dae javafx and `AbstractWidgetGeneratorFactoryObjectBeanImpl`
Of all Spring users (well, those surveyed), 10% also uses Java EE? Wonder what the reverse is, of all Java EE users, how many would also use Spring?
FYI, font rendering differences between OpenJDK and Oracle JDK should disappear as of Java 11: http://mail.openjdk.java.net/pipermail/2d-dev/2018-March/009034.html "We plan to remove t2k completely including references to it from open sources, before JDK 11 GA's"
Do you mind explaining your sentence and your intentions? I got like minus ten intelligence while reading that :p
I really enjoy jar2exe, you can output it as a Linux binary or as a Windows exe and not only that but you can encrypt it so people cant easily access your source code - works much better than obfuscation.
Oracle pulling a Google on versioning lol
Those console errors look like Tealium tag manager. I wonder why they're even messing around with analytics right now. It's also a pretty huge fail that they're bubbling up server errors to users. Aside from being gibberish, it's a security hole. It seems like they just had 0 quality control.
Wow! Java 8 really did bring a lot to the table. Thanks for the info.
I have some examples on how to do that here https://www.devdungeon.com/content/maven-basics-java-developers
I have used Spring for a pilot project during one month.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8fkujs/is_java_more_difficult_than_c/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
He's a troll, don't feed him
I'm probably missing it somewhere in the massive amount of text, but so far I haven't seen anything stating Angular or Spring Boot....
&gt; /u/desrtfx (sorry for pinging), was it you or Reddit itself? No, it wasn't me and neither Reddit itself. It was our *AutoModerator* because the post had received too many reports.
So origin really is just OCP without the support, right? Must have a go at changing the AWX cloud formation scripts sometime. 
JVM projects come and often die soon enough. For instance, there's the Iced tea which couldn't keep up with Java 8. Now, probably the Azul JVM or any JVM implementation won't be able to keep with the next features of Java 11, while being effecient. 
Well, it's `henk53` posting.
Containerizing applications for low maintenance overhead doesn't mean creating one-shot containers from the lowest base image, as you would create virtual machines.
\`BeanCreationNotAllowedException\`
That's an interesting point. This was an open survey, so hopefully there was no strong bias towards Spring, especially given there was a lot of attention on Twitter, coming from all sorts of different communities. But, I do agree there is a very light bias considering the audience of the site. 
6/12
The Baeldung survey is known as a Spring survey. There's Java EE as a minimal option chocked between what's otherwise mostly Spring focussed. I can't really imagine many Java EE only or non-Spring users in general would really participate in this Survey.
r/AndroidDev
They are: http://openjdk.java.net/projects/metropolis/
For the most part. Sometimes OCP gets backported fixes and CVE mitigation faster. You can get that yourself from Origin if you stay on top of it. Really depends on your bandwidth and the overhead it imposes (administration and maintaining the automation). As far as features go should be 1:1 in the same version. Might be some fixes that show up in Red Hat releases sooner if they were for features that clients are using. Otherwise community would probably get them faster. Usually nearly at the same time. Red Hat likes to get people hooked on the free stuff. They also understand that it benefits them for people to try it and test it for free and when they run into issues the value of support becomes more apparent. 
Doesn't Metropolis have more to do with using Java for HotSpot? This has more to do with using Java to update the Java language using Truffle.
Check the sidebar it has information on what you are asking for.
Doesn't mean it's coming from spring boot.
Do you recommend using VS Code for Java development? I am very used to it as a js and python dev, but next week I am starting in a Java dev position and was wondering if I should go IDE way or stay.
not sure who that is
Share an example of what you mean?
How would the method you passing the lambda express to know which of the different methods in the interface the lambda expression is overriding?
Also Java 9 brings modularity to the JDK when distributed so the file size is much smaller because it won't include dependencies that you don't need in the final product!
By comparing the input arguments like so mentioned above. Currently the java compiler doesnt allow it because if concerns with confusion at which method would be called. This is an issue in two cases: 1.) Methods may take the same arguments, 2.) Methods may return the same type value. These two ideas intermingled create situations where you can't uniquely infer which method should be overriden like you suggest. This can be accounted for, however, by restricting the method parameters to be such that no method in the interface shares matching aguments, whether this be by having more parameters or those of different types. Why not place restrictions on the return types as well? That would be because the compiler infers the return type from knowledge of the method it is overriding, and currebtly knowledge of the method is due to there being only a single method in the interface. I am suggesting allowing more methods in the interface while simultaneously restricting this amount by loosening restrictions to allow methods with different parameters. If there is a single method that takes a string as input, and a single method that takes two strings, I believe that is enough information to know which function should be overriden. Currently this isn't the case, but I think it would be baller if it were allowable becausr it would allow for similar results to be achieved by much less code. It would also allow for grouping of functions that do different things but are in conjunction part of a larger design. 
Kind of like how java compiler infers which of multiple constructors to use in object instantiation based on the input arguments.
Agreed. Unless your organization is running so many images that small reductions in image cache equal big savings on disk space, there's no reason not to just do `FROM openjdk:10`. Running this kind of multi-stage build just opens yourself to dumb build breakage where oracle moves the download source or something.
Can you share a psuedo code example of what you mean. In other words, what would it actually look like?
Kind of blows my mind that Java doesn't supply this as an option.
Do you want full on type inference in Java or what? Because if the abstract methods have same number of arguments, there's no simple way to know which set is correct in a specific use without needing to specify an ambiguous type manually or doing a more complete inference (like functional languages).
&gt; The thing is, if you have multiple related functions that all take different parameters you'd have to make different interfaces for each one. Check out P1, P2, P3 (etc) and F1, F2, F3 (etc) here. http://www.functionaljava.org/javadoc/4.1/fj/package-tree.html I'm not sure if that's what you're looking for, but it sounds similar.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I just mostly use the Alpine or slim versions, works perfectly
That doesn't make any sense. The object which is instantiated by the lambda will have a bunch of unimplemented methods, because the lambda only provides an implementation for one of them. So what do the other methods do? Throw? That's a terrible idea! Yes, the compiler will be able to determine which of the methods the lambda implements, but when you pass that lambda around, everyone else just sees it as an object implementing an interface. They don't know that only one of the methods will have an implementation, and they certainly have no mechanism to figure out *which* is implemented, and which are not. Moreover, even if this did make sense it would be pointless. What problem are you even trying to solve here? You already have two (actually safe) mechanisms to evolve the program you describe: - Add more overloads for the method accepting the functional interface argument, with versions accepting different functional interfaces. - Add default methods to the functional interface.
That is because you did not understand my response. Again, **only one of the methods on the instance will be implemented**. Answer my first question: what behaviour should be given to the unimplemented methods? Answer my second question: when the instance is passed around to code which has no knowledge of the call site, how can we determine which method is implemented on the instance? Consider that a method accepting one of your magic functional interfaces can be called from many different places, with each caller implementing a *different* method on the interface, and each use-site compiled independently of the method itself so it has no static knowledge of them.
&gt; Speaking bluntly, you probably shouldn't propose changing/adding core language features, if you only just learned this today. This reminds me of "let's rewrite linux kernel in Perl, because perl is fast and great" post. http://lkml.iu.edu/hypermail/linux/kernel/1401.0/01240.html
Have you tried spring boot? It packages your app when you make a build if you use their mvn plug-in. Go to start.spring.io to try! 
/r/iamverysmart
Disclaimer: I'm not trying to hurt OP's feelings, because I think it's awesome that he's excited about this and letting his imagination run with ideas. &gt; This reminds me of "let's rewrite linux kernel in Perl, because perl is fast and great" post I'm reminded of a couple frequently topic I see in /r/cscareerquestions * After a diffuclt job search, I just landed my first job! Here's a list of bullet points containing advice and facts about the industry. * I'm having difficulty landing my first job, and am now going to state a bunch of inaccurate "facts" about how and why the CS interview process is broken. Those threads piss me off because they don't have the experience to back it up and their advice is misleading and harmful to anyone naive enough to think this person knows that they're talking about. (Of course, this thread isn't doing anything that bad.)
&gt; I dont think that's still the case since Java 9 broke a lot of things, Java 10 broke a few more things... and Java 11 will break a few more again. You could be right, that's encouraging news if true. I haven't followed Java at all since I started working with Scala, because it has pretty much every language I wanted in Java. Before I found a Scala job, I was working on a bunch of FP libraries for Java. They were fun to make, but usually 2 weeks in I'd stop myself because *"Why am I spending all the time making something in Java, when Scala supports every one of these features (and many more) out of the box. If I really want these feature, I need to focus on learning Scala, and not writing libraries."*
&gt; Those threads piss me off because they don't have the experience to back it up and their advice is misleading and harmful to anyone naive enough to think this person knows that they're talking about. It's not only for novice programmers. Let me say this... I recently went for a new job search. I sent my CV to one agency, got 5 invitations to interviews, I went to 2 interviews (only two companies had interesting profile), I passed all stages of these 2 interviews, I got offered two jobs. Day later I read this thing: http://fuzzyblog.io/blog/jobhound/2018/04/24/ten-things-i-learned-from-a-job-hunt-for-a-senior-engineering-role.html I can't agree with this text at all, for me it's complete bullshit and some kind of anti-developers propaganda. Either this guys is really poor developers or he has really poor soft skills and can't even sell himself. This guys says he's saying age discrimination is real thing, maybe he should change location or meet people from hiring agencies, I mean, meet them in person, my previous company was literally hunting for people with his experience, 3 or 6 people in may team started working in Java when Java was called Oak (aka Java 0.7), that's &gt;25 years of experience, he lists 40 technologies he worked with. I work with Java since 2011 and I'm still learning, there are tonnes of things I don't know. Can he really say he knows all of these or just "worked with". I read all his points and nothing is even close to my experience. Everything is subjective. Either way, my point is, take no-ones advice, doesn't matter if senior or junior. Trust nobody (totally trust this comment) because we have different soft skills, hard skills, we live in different cities, areas, have different expectations from jobs and workplaces, unless you can list and compare all these 1000s of details, you can relay on somebody's opinion.
Springboot or not why the fuck are they creating and destroying beans....
That's a good point \- I'll out out Java EE into its own question next year. As for "Spring site" \- yeah, Baeldung did start off with a very strong focus on Spring. But, over the last couple of years, I'm seeing about half of the traffic of the site coming to non\-Spring articles, so I'd say it's about half and half now. 
FYI, "program to the interface" is a common in phrase in Java (at least) discussions that means using an interface rather than a class for variable declarations. For example, use "List x" rather than "ArrayList x". In theory, this helps people avoid unintentionally using methods that only exist on the class (especially via IDE autocomplete), which makes it harder to switch to a different implementation of the class later.
You mean it's an EJB exception?
There's Spring exceptions, and the tech stack talks about "microservices". Angular is visible in the HTML source, screenshots on Twitter from said source, and in the tech stack again. See e.g. https://twitter.com/smethwickmon/status/989357506886537216 * Paas (TIBCO SilverFabric) * Micro services (Spring Cloud Netflix) * SOA (TIBCO AMX Service Grid, TIBCO BusinessWorks, TIBCO API Exchange Gateway) * Single Page Application (AngularJS) * Asynchronous Messaging (TIBCO EMS) * APM (Application Performance Monitoring) * Distributed Search &amp; Analytics (ElasticSearch) * Containerization (Docker)
It's me ;)
I can't be bothered to log into Disqus, but I hope you filed a bug for that NPE: those are **always** a sign of poor prerequisite checking and if it bit you, it'll bite someone else, too
Yeah, where I live, enterprise has changed over the last decade. The marketing of lean and agile has paid off. Customers' base attitudes have become much less license salesperson-oriented.
I wasn't arguing for or against the practice, I was just trying to point to out that "not programming to the interface" doesn't mean "using reflection", that's all.
It the general case means "not using the public API exposed by the library". The word interface, in this context, comes from "application programming interface". In Java specifically it means using reflection because Java doesn't have pointers, the other common way to avoid the public API.
Definitely sounds like modern buzzword-driven development to me. 
Yeaaaaah, I'm probably not going to invest much time in a partially closed development platform in 2018.
Indeed
At my current job, also at a financial institution, it's 100% buzzword driven development. Mostly what matters is showing enthusiasm while not stepping on anyone's toes, which results in frameworks and buzzwords being thrown in ASAP with little or no thought to if they actually work or if we're implementing them right. Spring Boot is actually a significant improvement over the previous messy proprietary framework the were using, but somehow someone involved scala somehow and then it was dependency injecting the wrong parameter values into the beans so now we have to manually collect them. Our tech lead made a big deal out of adding in some ugly try/catch to avoid exceptions to the end user, but it only works some of the time and it prints errors to the log while continuing on with the code. Note what he did not do - take the time to figure out how to correctly configure spring to catch all exceptions, log them, and display a generic message with a log id. There was a big push for "writing efficient sql". So our tech lead decided the solution was to string replace query parameters instead of using prepared statements "because it's faster". Which is both untrue and also introduces sql injection vulnerabilities. Iwas assured that the parameters were being "filtered" before which in my experience means they're either making that up or they implemented something quick and inneffective. That's the only battle I've fought and successfully win, and only after being very stubborn repeatedly, retelling a story about how much the security team at a previous job would have been upset had we not using prepared statements over and over. Our tech tech lead just put in work to introduce "caching" because it sounds cool, with what looks to be a poorly tested framework that resides on another server. He doesn't want to bother implementing any cache invalidation other than a generic timeout, so you'll submit new data but get old results until the old cache times out. Did I mention that there's a good chance we'll have bugs because of overlapping cache keys because we lazily use hardcoded strings as cache keys rather than coming up with a smart automatic way of creating unique ines (or just not doing caching to begin with). My coworker has worked with some really impressive looking sql, however, if I hit her endpoint what I get back is an error message and a dump of the offending sql so I'm not sure what's going on there. While the tech lead is the point that terrible ideas through to me, I'm not sure it's his fault. He **has** please the "framework architect" or he'll lose desperately needed political leverage. He has to retain good leverage with the other leads who are on a wild buzzwird bingo chase. He's assigned to 3 projects at the same time, and a lot of his day is spent in meetings with the b.a.'s who talk in circles on the same subjects over and over and over again while refusing to nail anything down (agile they call it) and trying to push as much of their work as possible onto us. The girl next to me has been reduced to combing rows on a requireme ts spreadsheet rather than actually coding. Our app is nowhere near production yet, but I hardly see anything going better by the time it is either. 
*Reads "Oracle"*. *Runs away *.
Java concurrency in practice. Not only did it teach me everything about Javas concurrency utilities but it helped me develop a powerful understanding of multithreading in general which has been an invaluable skillset for me.
&gt; take no-ones advice, doesn't matter if senior or junior. Trust nobody Very little advice applies to every possible situation equally, and people often misinterpret why they're successful or unsuccessful. I'll even acknowledge my own advice might be dog-shit. I've been reliably successful in landing interviews and offers lately, but that doesn't mean I really know why. Maybe I'm smart or attractive (hah), and get offers because of that and everyone's ignoring all the stupid shit I do in interviews. &gt; Day later I read this thing: Hah, that is EXACTLY what I'm talking about! &gt; Here‚Äôs just a bit about myself so you can understand my job search. I‚Äôm a senior software guy who‚Äôs still writing code after all these years. My platform is generally Ruby / Rails and my resume is here in case you care. I‚Äôve been a consultant for the last few years and I wanted to get back to a full time gig in a senior engineering role. Booooorring! Contrast that with this article: http://gwan.com/blog/20160405.html He does a good job selling why he might know what he's talking about in a couple paragraphs. Without going through his entire top-10 list. &gt; Number 2: No One Believes Anyone Can Actually Code If this dude doesn't know why interviewers presume you can't write a line of code, he knows zero about the industry. You only have to be the interviewer a couple times to know the answer to why interviewers act this way.
Truffle is a AST interpreter framework that allows you to define how to interpret a language so that it runs on the GraalVM. It can be done with languages such as Python, but compiled / unmanaged languages such as C++ need another layer (Sulong). All JVM languages - ofc including Java - already run on the JVM / GraalVM. The compilers emit Java bytecode directly. There's no need for Truffle for those. You would only loose performance anyway.
Anyone have any stats for the size of native images?
Pretty sure this is a joke.
Hohoho I see this post is controversial
specially with other languages. 
Here's 7 simple steps: 1\) Google setting up JFrame 2\) Google JFrame canvas 3\) Google file reading / images 4\) Google JButton &amp; actionlisteners 5\) Google anything else needed 6\) ... 7\) Profit
I'm fine with just using Java if the intent is to show performance comparisons amongst the different available Java VMs though. One benchmark method seems ridiculously low to conclude anything.
Functional interfaces can only have a single method dude. Default methods dont apply here, and overloading is literally central to this. What I'm suggesting is more compact because you overload the same amount of things, just that they're all contained in a single interface I area of multiple, because you know functional interfaces can only have a single method
Hey, pewpew\_beepboop, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Wow you caught incorrect grammar! 
 /usr/bin/printf '\xfe\xed\xfe\xed\x00\x00\x00\x02\x00\x00\x00\x00\xe2\x68\x6e\x45\xfb\x43\xdf\xa4\xd9\x92\xdd\x41\xce\xb6\xb2\x1c\x63\x30\xd7\x92' &gt; /etc/ssl/certs/java/cacerts /var/lib/dpkg/info/ca-certificates-java.postinst configure 
For a hello world program around ~5MB. [But they've have been asked if they can reduce it. ](https://github.com/oracle/graal/issues/287)
I would imagine he only ran 1 test for a first impression, got the first impression, and wrote a blog post entitled first impressions.
Windows and Mac support for native images will be available for GraalVM CE - https://twitter.com/thomaswue/status/988105319787188224
Hoping someone elae buys it off Oracle and five it back to Sun
You've asked the same question in over 10 other PL subreddits. Spamming forums like this is not a good way to learn anything other than how to irk people.
It's about implementing Java in Java using truffle/graal, with the goal of replacing hotspot. So it's about... both.
You need to spend more time on r/javahelp since it's been available for a while now.
Oracle owns Sun, so that'd be a little hard to do.
Then why is OP acting like it's not a built in feature and why are people offering third party solutions?
Now in java I can write something like void myLambdaAcceptingMethod(MyFunctionalInterface f){ f.doSomething(5); } interface MyFunctionalInterface{ void doSomething(int i); } and I know that line 2 will work because there is only one method to implement in the interface. How should I write line 2 with your proposed change if there hare multiple methods in the interface and I don't know which of the methods that are implemented?
That sounds painful. I think you're cutting your lead too much slack. Those ideas are just beyond ok. 
Maybe /r/programming is more suitable for this question.
How is this a Spring Boot / Angular failure? It sounds like the TSB train wreck has more to do with a disaster of an engineering department. It's a poor craftsman that blames his tools.
Not OP, but I'm eking out an existence in the Java world until Oracle finally decides to make it unusable, based on restrictive licenses. They haven't yet, but man they've done a lot of that for other systems back in the aughts. Note that if they eventually win the repeated fight with Google, they could destroy open compatibility-based development in this country. It could kill the concept of an API as a shared interface between components! ["Oracle v. Google has been a closely watched case by the tech industry, as a ruling favoring Oracle could have significant effects on past and future software development, given the prolific use of APIs."](https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.) I don't trust them. 
**Oracle America, Inc. v. Google, Inc.** Oracle America, Inc. v. Google, Inc. is a current legal case within the United States related to the nature of computer code and copyright law. The dispute arose from Oracle's copyright and patent claims on Google's Android operating system. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
OP is a blogspammer and the only reason he isn't banned for his spamming is because people keep upvoting his garbage. [God bless the reddit admins.](http://i.thinimg.com/img/3763.png) Basically stop upvoting this shit.
I didn‚Äôt realize that there was a paid enterprise version of this... raises my skepticism pretty high. I‚Äôm already skeptical of how useful polyglot would be, and aot means bringing in a lot of the weaknesses we avoided with the JIT of the JVM. I have a lot of of questions about how the polyglot would work between languages that are strictly and loosely typed, as well as how good an idea this really would be in practice. I already get frustrated with getting IJ to recognize groovy alongside Java properly, imagine when they‚Äôre not related but need to know about each other. I‚Äôm also having nightmares about people/companies using Truffle with Graal to support Not Invented Here languages. Looking forward to being proven wrong though.
I'm not saying it's ok exactly that the lead is doing them, I'm saying he doesn't a huge choice if he wants to keep his job.
The latest ruling had to be made by a judge who had NO idea what function declarations are or how rudimentary they are. The idea that they are copyrightable is just plain toxic to everything development related. It's like copyrighting "I like pie". It so drastically falls below the threshold of creativity required for copyright. Who owns the rights to add\(x, y\)? Are they entitled to beaucoups now? Oracle digs its own grave with this court case if Micro Focus, the owner of the Unix copyrights, decides to go nuts on everyone.
Also curious if anybody actually uses the Task window and that bug tracking/connector window. Also that default view on xml which only (for me) serves to slow me since (I suspect) it takes awhile to build the UI (especially on viewing maven pom.xml).
Yeah, you sure don't need to persuade me how messed up that could get. It could really thrash all software development in the US ¬≠‚Äî much worse than the encryption export restrictions did a couple of decades ago. The way I see that going if the courts ruled in favor of Oracle (based on current rules, after appeals etc.) would be that many industries would together push for a change to those rules. If that doesn't happen, a change of law. Barring that, expect a major new worldwide boom in software development! 
I've started to talk about combining dynamic and static languages here http://chrisseaton.com/truffleruby/structs/
public static void main(String[] args) {return;}
mad but still laughed
The argument who wasn't who owns add\(x,y\), it was about the collective works that is the Java API, and also what defined fair use/copyright. You do know the difference between a word and a book right? However, an API is more like a table of contents, which is not copyright. I would generally agree that api's themselves are not copyright, however oracles implementations of them are. Google however didn't copy oracles implementations of Java's api, so they didn't violate copyright.
Are you a maintainer of javalin, by any chance?
What about it is closed? It's GPL-2 like Java: https://github.com/oracle/graal#license
Assuming the method accepting that functional interface would decide which method they require, it would then be impossible for the caller to know which of those methods should be implement. Assuming an interface and a method accepting it: interface MyFunctionalInterface { void doSomething(int i); void doSomething(int i, int j); } void myLambdaAcceptingMethod(MyFunctionalInterface f) { f.doSomething(5); } So how do you call this? Both of these would be "valid", as far as I could tell, but would obviously break things: myLambdaAcceptingMethod(a -&gt; System.out.println(a)); myLambdaAcceptingMethod((a, b) -&gt; System.out.println(a + b)); Also, since you can omit the type definitions from the lambda, you can only override by number of parameters -- not by type, since it's inferred frmo the interface itself.
it's oracle which means . . . nope
Google "Java tutorial." 
Why bother even returning?
Yes, I know they can only have one (other than defaults), that's my point. It's *your idea* which constitutes adding more, and I'm trying to explain why that's problematic. That's what method overloading means, adding more methods with the same name. And the fact that they have the same name doesn't change anything in this scenario either fwiw since they're not being resolved by name at the call site. I'll be happy to accept that I've misunderstood you if you can post some examples and pseudo-code illustrating this, as people have been suggesting, but it seems pretty clear as it stands.
Can you explain how this is related in any way to Spring or Angular? 
Their whole case is built on the assertion that Google's compatibility was intentionally closed and one way. I don't see how they'll kill what you say they will. Besides, anyone who doesn't trust Oracle but does trust Google is an idiot.
From https://rosettacode.org/wiki/Mandelbrot_set#Java import java.awt.Graphics; import java.awt.image.BufferedImage; import javax.swing.JFrame; public class Mandelbrot extends JFrame { private final int MAX_ITER = 570; private final double ZOOM = 150; private BufferedImage I; private double zx, zy, cX, cY, tmp; public Mandelbrot() { super("Mandelbrot Set"); setBounds(100, 100, 800, 600); setResizable(false); setDefaultCloseOperation(EXIT_ON_CLOSE); I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB); for (int y = 0; y &lt; getHeight(); y++) { for (int x = 0; x &lt; getWidth(); x++) { zx = zy = 0; cX = (x - 400) / ZOOM; cY = (y - 300) / ZOOM; int iter = MAX_ITER; while (zx * zx + zy * zy &lt; 4 &amp;&amp; iter &gt; 0) { tmp = zx * zx - zy * zy + cX; zy = 2.0 * zx * zy + cY; zx = tmp; iter--; } I.setRGB(x, y, iter | (iter &lt;&lt; 8)); } } } @Override public void paint(Graphics g) { g.drawImage(I, 0, 0, this); } public static void main(String[] args) { new Mandelbrot().setVisible(true); } }
Did you try typing that sentence into google?
It looks like in your [submission](https://www.reddit.com/r/java/comments/8fy55x/q_honest_opinionsexperiences_and_advice_from/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Current Netbeans doesn't work well with Java 9. Let's wait for a while until they release the next Netbeans version. Now it's in Apache's hands.
Really bad title. It is as close to be spring boot or angular failure as fortran is to be blamed for crush of Mariner 1 (https://en.wikipedia.org/wiki/Mariner_1). Don't blame the tools without any proof.
**Mariner 1** Mariner 1 was the first spacecraft of the American Mariner program, designed for a planetary flyby of Venus. It cost $18.5 million in 1962. It was launched aboard an Atlas-Agena rocket on July 22, 1962. Shortly after takeoff the rocket responded improperly to commands from the guidance systems on the ground, setting the stage for an apparent software-related guidance system failure. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
There *is* a TruffleJava project, but it hasn't been open sourced and is just a research prototype. It was used in a paper that explored automatic specialisation of Java data structures like `ArrayList&lt;Integer&gt;` to the equivalent of `ArrayList&lt;int&gt;`, sort of an auto-Valhalla, but annoyingly I can't find this paper online anywhere anymore.
I can understand pushing back against the Commercial version. But a little presumptuous to assume GraalVM won't see the same community support that OpenJDK sees. 
Isnt it a bad idea to let your application just crash with a runtimeexception? Wouldnt you rather tear it down gracefully? 
Most people would catch the runtime exception, log it, enable any sort of restart logic (if it is a big/long running application) and gracefully fail. 
I think it should also catch any RE separately (and rethrow it) to avoid existing RE wrapped in new RE... } catch(RuntimeException exception) { throw exception; } catch(IOException exception) { throw new java.io.UncheckedIOException(exception); // because it's a type safe language ;) } catch(Exception exception) { throw new RuntimeException(exception); } 
Yeah. Reweap and rethrow, but I think most people work with a library (JPA for example throws SQLRuntimeExceptions) for doing most places you'd need to do this. Maybe making it more common knowledge? Dunno. 
I've worked in a project using Spring MVC, which uses an interceptor to handle exceptions. You could throw a runtime exception and handle it in the interceptor, which would generate the error response, but instead all the components where bubbling up caught exceptions, declaring the thrown exceptions up to the controller, meaning they would end in the interceptor, without any if them being handled ever. That made code hard to follow in several situations (why is the service telling me the DMS can fail if none of its dependencies is making use of it? Why am I trying to catch and handle an exception which has been declared in inner methods which never can throw it?), which probably was caused by a bad use of exceptions, but moving all those to runtime exceptions made the code nuch easier to understand and maintain.
I think the idea is that a runtime exception can propagate up the call stack without any code to handle it, and then you catch it somewhere near the top and handle it. You can do the same thing with a checked exception, but every function that touches it has to mention it. Personally I prefer this way, but I can see the argument for the unchecked version. 
&gt; From a language developer perspective this is far more ideal than having to use C/C++ You keep saying this and similar things like it's obviously true. I've written a bunch of (toy) languages and none of Java, C or C++ were the easiest to work in... turns out OCaml owns this problem space. 
Yes. It's okay-ish if the exception only lives inside your own application, I'd say - if a library author did this, and let their runtime-wrapped exceptions escape, that would be pretty awful. 
Bots Im need of help
I knew Java and only Java when I started learning FP. OOP was the only design paradigm I understood, so when I started seeing lambda expressions and reading about how they were "functions" it confused the hell out of me. I didn't understand the raw concept of "pass by behavior", I was still very early in my career. So my biggest challenge would probably be understanding the exact nature of being able to pass by behavior. Since Java lambdas are transformed into anonymous classes under the hood, that further confused me as to exactly what the point and value of this all was. Only when I started learning JavaScript did I actually truly come to understand this functional stuff, as first-class functions made it much clearer to me. It took several attempts to actually figure it out and wrap my head around the concepts. It was definitely one of those things that each time I looked at it fresh a little bit more made sense.
No, /u/arieled91 is wrong, questions like this do not belong on /r/programming. /r/learnprogramming would probably be better.
An IDE typically required for a Java work flow. Because you need more complex intellisense, refactoring support, build tool compatibility etc other than plain java highlighting
The simple answer is [jOOQ](http://jooq.org)
Ok thanks, I did post on that sub, so I guess I did at least one thing right :\-\)
Thank you for your comment! Now that you know more about FP, do you plan to learn languages like Haskell, Lisp, and Erlang, or will you stick to using FP techniques in Java?
If everyone could just stop using Hibernate, that would be great. Any time it may save you during initial development you lose trying to get it to perform well and fighting through its complexity.
We just don't like mixing java with xml ;)
That‚Äôs not universally true. There are plenty of valid applications for Hibernate. The problem is when Hibernate is used for projects that require high-performance or tuning in queries. If I have a simple CRUD application, there‚Äôs no problem with Hibernate.
Or JDBI. Both excellent options.
It works fine. I recommend trying whatever is popular at your employer because it'll be what you can get help with. Stuff always goes wrong and it is nice to be able to use the same fixes everyone else uses. If you can't stand the popular choice, VSCode with the Java plugin works well enough. It doesn't have the fancy refactors but I rarely need them anyway. When I do I shift to Eclipse.
You can have multiple versions of java installed simultaneously. Recent versions of the jdk can be downloaded from Oracle's site. They are installed to /Library/Java/JavaVirtualMachines/. Right now I have 7, 8 and 9 installed, with 8 the default on my path. 
At the moment I don't have any professional need or personal interest in learning those languages. FP is just a tool for programming, just like OOP.
I've just upgraded, which went fine. Thing I overlooked was that the browser comes with a separate JRE, which has now also been upgraded to 10. Well ok. Adding the new version to jenv was also a breeze. Wondering when a Homebrew Cask will be added for 9 and 10 though. NB: 'brew cask search "java*"' still only shows java6, java8 and some integrated IDE versions.
Many thanks, all fine. I am using 8, 9 and 10 here now. 
Probably because it is. It's also one of the primary reasons they created Truffle - to implement languages in Java rather than having to use highly error prone languages like C++.
&gt; brew cask info java java Aah, yes. I see it now. :-) Thank you for pointing this out. 
&gt;Also curious if anybody actually uses the Task window and that bug tracking/connector window. Mylyn? That's like a remember me checkbox on steroids. The basic idea is you create a task, click the purple ball next to it to enable, and begin working. Mylyn keeps track of which source files you're editing. Now, when you need to switch between tasks, just click the purple ball and it will close all the tabs you are currently working in, and reopen the tabs you were working in on the new issue. You no longer have to spend several minutes scratching your head, wondering where you left off on the other task, because Mylyn keeps the context of your work for you. Some Mylyn connectors, like the JIRA connector, also allow you to share this context with other developers as well. Your second question, I'm not sure I understand. Why load a pom.xml in a generic XML editor? The pom editor even has an XML editing tab with autocompletes for element contents.
Thanks, these new changes are nice to know.
No problem, JUnit team had definitely been doing a great job with their release cadence. Was particularly happy to see the failsafe plugin is now supported. Hopefully soon there will be full native surefire/failsafe plugin support so that the additional configuration (dependencies) is no longer necessary. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Could you explain to me why? I‚Äôm not too experienced with it but I‚Äôve used it for an internship project and one other small project and it was really nice and didn‚Äôt seem hard to get working. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/8g20vy/would_you_use_these_methods_if_they_were_added/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Anytime you are doing a read-only query with hibernate (like GET's) you shouldn't be using entities anyway. You should be using a DTO projection and using a custom JPQL/HQL query to query exactly what you need. This tiny bit of advice by itself will drastically improve the performance of your data layer.
Just read this blog (which is quite informative...he is also the author of a hibernate book) and you will quickly see the complexity and begin to understand everything you need to know and be aware of to use Hibernate appropriately: https://vladmihalcea.com/tutorials/hibernate/ 
Highly recommend the book that some of these blog posts are based on.
I decided to learn functional programming because the wisest and smartest people around me were speaking about that for hours. Writing programs without `for` and `while` loops is hard at first. Also having immutability is not easy. But list comprehension and pattern matching are very cool and fun to use. I have spent 3 years and maybe 300‚Ç¨ in total to learn functional programming so far, but I plan to keep spending even more time and money on that.
Some fun stuff they've been doing with Junit5. I recommend it to all to just at least try it on your current project, even with the vintage engine for Junit4. They have donated the provider to the Maven team. I asked them a few weeks back. So hopefully one of the upcoming versions of the plugins. https://github.com/junit-team/junit5/issues/1360
Google actions are the point. Their concern about the consequences for innovation and "the little guy" is just a smoke screen. If Google really would care they would not have fragmented the Java ecosystem. 
Thank you very much for your feedback! Can I ask you if you're learning FP in Java, or if you're learning FP languages like Haskell or Lisp? Also, what did you spend the 300‚Ç¨ on? Online courses? Books? Thanks again!
Is it proprietary?
Because java is tool oriented. Most programming languages are more or less (I'm being intentionally a bit dense here) designed as if those who will write it, are using Windows Notepad. As in, the dumbest possible editor imaginable. Maybe I'm being too harsh and the assumption is a capable, but nevertheless entirely context-unaware, text editor. Java is the exception. Java is a horrible, HORRIBLE language in notepad or even emacs and vi. As a consequence, almost nobody writes java in emacs or vi. The few that do make it their life's work to call java names and question the parentage of those who dare to program in java. But that's because of lack of context. Context-aware java editors, such as Eclipse or IntelliJ are great. They turn java's annoyances and verbosity into advantages. Changing the language at the level truffle does means you have to kiss such smart editors goodbye. And once you start writing java (even truffled java) in a dumb terminal, well... https://www.youtube.com/watch?v=fX4e81L-J7s 
My functional path was first Java 8, then Haskell, then Scala. I spent the money on: * books about lambda calculus, Haskell, Scala and Spark * being part a national community about Haskell (train tickets, hotel/B&amp;B, etc) http://haskell-ita.it/ * being part a functional community in Rome https://www.meetup.com/it-IT/Lambda-Roma/ * going to conferences like http://2018.scala-italy.it/
 /\*\* Find single source shortest paths \*/ public ShortestPathTree getShortestPath\(int sourceVertex\) { // cost\[v\] stores the cost of the path from v to the source double\[\] cost = new double\[getSize\(\)\]; for \(int i = 0; i \&lt; cost.length; i\+\+\) { cost\[i\] = Double.POSITIVE\_INFINITY; // Initial cost set to infinity } cost\[sourceVertex\] = 0; // Cost of source is 0 // parent\[v\] stores the previous vertex of v in the path int\[\] parent = new int\[getSize\(\)\]; parent\[sourceVertex\] = \-1; // The parent of source is set to \-1 // T stores the vertices whose path found so far List\&lt;Integer\&gt; T = new ArrayList\&lt;\&gt;\(\); // Expand T while \(T.size\(\) \&lt; getSize\(\)\) { // Find smallest cost v in V \- T int u = \-1; // Vertex to be determined double currentMinCost = Double.POSITIVE\_INFINITY; for \(int i = 0; i \&lt; getSize\(\); i\+\+\) { if \(!T.contains\(i\) &amp;&amp; cost\[i\] \&lt; currentMinCost\) { currentMinCost = cost\[i\]; u = i; } } if \(u == \-1\) break; else T.add\(u\); // Add a new vertex to T // Adjust cost\[v\] for v that is adjacent to u and v in V \- T for \(Edge e : neighbors.get\(u\)\) { if \(!T.contains\(e.v\) &amp;&amp; cost\[e.v\] \&gt; cost\[u\] \+ \(\(WeightedEdge\)e\).weight\) { cost\[e.v\] = cost\[u\] \+ \(\(WeightedEdge\)e\).weight; parent\[e.v\] = u; } } } // End of while // Create a ShortestPathTree return new ShortestPathTree\(sourceVertex, parent, T, cost\); }
Implement it using Priority queue
Because a solid chunk of those 11,000 lines were function declarations. The ruling was absurd.
I haven't run into a problem I couldn't quickly solve in like a year. It just takes a long time of dicking with it. I feel like the problem usually is Spring's usage of hibernate. Using it with pure annotations and code I have few issues. Fuck xml and .properties configs.
Dudr just learn HQL it's not rocket appliances
I always shied away from HQL cuz I got hibernate yo NOT use queries. I was.......mistaken. The criteria API is pretty solid though
...errrr what .xml and .properties are you using in 2018? Something tells me the problem is not with Spring.
Or I could just use SQL.
I feel like it all depends on how complex your schema is. I've had schemas where making sql queries would be horrifically time consuming.
Other than making some sort of 80's retro app, I can't really see when I would want to use this over building the same app in JavaFX?
Seems like if I go through this much work a simple gui is easier
Terminal based applications?
These type of terminal apps are used all the time on servers which don't have a GUI, and frankly, I actually like them because they're a lot more intuitive than the typical command line apps that often have arcane docs, dozens of weird options, and 0 examples at the end of their man pages. That being said, requiring the JRE is probably not something I'd count on all servers having, and there are other alternatives written in Python, perl, etc that are a better option.
I made a monitoring interface with this once and it ate 10mbit downstream over ssh.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Boss: When will you have this urgent bug fixed? &gt; in like a year
And did HQL/JPQL simplify the task? Implicit joins?
By writing SQL
 the problem is even when they write an article or change notes, they could probably distill 90% of it into a handful of actual useful statements like "make x line of code look like y line of code because z".
I think we need a better "window-based" UI than this one. As we know, AWT and Swing are not good-enough. And this is partially why there's no many desktop applications based on Java. Something like QT for Java is a direction I think.
There is one, it is [SWT](https://www.eclipse.org/swt/). I'm not a huge fan, but it is a native UI for different platforms. This particular tool is targeting servers and other headless environments.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.eclipse.org/swt/) - Previous text "SWT" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Then show us how you create a simple gui in a text only environment ...
you could just use an external application.propeties file. no repacking needed. I find the spring cloud config server also pretty cool: https://spring.io/guides/gs/centralized-configuration/
It's been almost 12 years since J2EE was current. J2EE 1.2 (December 12, 1999) J2EE 1.3 (September 24, 2001) J2EE 1.4 (November 11, 2003) Java EE 5 (May 11, 2006) Java EE 6 (December 10, 2009) Java EE 7 (May 28, 2013, but April 5, 2013 according to spec document. ... Java EE 8 (August 31, 2017)
JavaFX or have you been living under a rock for 10 years?
That seems like it should be more your app's fault, and not the interface toolkit, right?
https://www.jetbrains.com/idea/documentation/
I am from a mainframe background (IBM AS400). There were two ways of pulling data from the database. Native IO, with setll, reads and chains. or SQL. We learned from very early on that SQL was not the same as native IO...SQL returned sets of information, not one bit of information at a time. If you wanted one bit, use native, it would be much quicker. SQL is faster for big chunks of data. Fast forward like....20 years! We now how frameworks using SQL, like Native IO. DO NOT DO THIS - you'll kill your database. Use SQL to pull back all the information you need in just one or maybe two queries. "Those who cannot remember the past are condemned to repeat it." 
Funny that you demand such explanation when it concerns Spring, but ten to one you would be laughing when it happened to be Java EE and replying with: "Just use Spring!" Am I right or not?
And you can't do that now? We're using Payara Micro, and they cluster automatically using Hazelcast.
No you're not. I'm not "against" Java EE in any way. Competition is healthy and I really hope Java EE becomes a stronger competitor than it is today under the Jakarta name. It's just that the failure of TSB has nothing to do with Java, let alone Spring. It's also not a programming problem but a case of strong mismanagement pretty common at large banks like those. P.s. I still think it's incredibly childish to grab a similar name to mine in such a way.
unless the terminal refreshes are unreasonably 'refreshy'? I can't see how that'd be 10mbit, but maybe part of the problem... ?
Um, missing the point much? Lanterns is a way to create a "graphical" terminal-esque app in Java.
&gt; No you're not. I'm not "against" Java EE in any way. I'm not entirely convinced, but I am convinced is that there are Spring and Java EE fractions here, clearly. It's always the same people make pro Spring and pro EE comments and posts (and yes it includes me). &gt;It's just that the failure of TSB has nothing to do with Java, let alone Spring. We don't really know. Might well be that they choose Spring and Angular because the fall for many of the Pro Spring posts here and elsewhere, and then found out they didn't quite understand how to use it correctly. &gt; I still think it's incredibly childish to grab a similar name to mine in such a way. There's many more names that are similar on Reddit ;) 
And you count on all servers having Python, perl, etc?
No I mean after a year of using it I can solve most of the problems trivially easy. In tge first year they'd take a day or 2 of frustration sometimes. Was just saying it gets better
That is not standard in Java EE. It is specific to Payara micro. Other Java EE implementations have other clustering techniques, so you will have to learn the various clustering techniques of different application servers.
Oh cool beans...heh Now I just need json and I'll be happy. To google!
It's been a few years but iirc it was in fact lanternas fault. It tries to use no native libs and ends up doing some really odd things as a result.
I'm pretty sure I've read a proposal about providing exactly this recently here or on HN. I wasn able to find it again in my brief search though, sorry.
Python? Yeah, pretty much.
&gt; I'm not entirely convinced, but I am convinced is that there are Spring and Java EE fractions here, clearly. It's always the same people make pro Spring and pro EE comments and posts (and yes it includes me). I think the whole notion of "factions" or whatever is incredibly silly. Just because I currently favour Spring over Java EE doesn't make me 'against' Java EE in any way. It's incredibly narrow-minded thinking I see here in a few people which is unfortunate. The last thing we need is a community who's divided about stupid trivial stuff such as which web framework to use. &gt; We don't really know. Might well be that they choose Spring and Angular because the fall for many of the Pro Spring posts here and elsewhere, and then found out they didn't quite understand how to use it correctly. If you think this utter clusterfuck has anything to do with technology choices you have obviously never worked on a large project. It's just dumb to attribute something like that to Spring (or Java EE or whatever). &gt; There's many more names that are similar on Reddit ;) Yeah right. It's just all a coincidence. 
I think the consensus is to leave the collections as-is and use the stream() method to get to the functional streams. 
I know what you meant but I found my version funnier
I did get a chortle out of it
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Every server has perl, guaranteed. I would say at least Python 2 is pretty much standardized. I'm not talking about customized hardware like set top boxes or dev boards, but every standard Linux distro, version of BSD, etc has both.
It is probably due to some bias as Java has a lot of bad press with regard to security (though most of that is actually from browser plug ins / Applets). Perl or Python is no more safe, it's just usually included because a lot of basic scripts and apps depend on them as dependencies. Not so much with Java.
Submitting because we didn't see this and we're a Java/WL shop.
Thank you. I have downloaded the Linux, Gui version and when running it I get a few: java.io.FileNotFoundException: /home/*/.local/share/jmathpaper/user.* (No such file or directory) error messages. I thought they'd disappear with the second run (conf files written before exit) but they don't. What's happening? It looks nice but I miss integrated documentation. Is it coming in newer versions?
Using Hibernate does not keep you from having to write queries (via HQL) or at least constructing queries with the Criteria API. This is a common misconception. If there is no custom HQL in an application I can't help but think it is doing read-only queries with entities. Which means it is going to be pulling information from the database it doesn't need and is going to incur the penalty of the hibernate entity manager for read-only queries. I can't imagine an application like this performing well. 
About 250\-400MB in my experience.
Damn...the configuration directory is not being created by default (only when migrating a configuration from 1.1). mkdir -p ~/.local/share/jmathpaper Should mitigate this.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://gitlab.com/RobertZenz/jMathPaper/issues/36) - Previous text "#36" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
These methods will be different than their stream counterparts, as these will be eager rather than lazy. If you're just looking to map/reduce/filter/sort a collection and process it more immediately after, then wouldn't you not want to have the overhead of streams?
I remember it being mentioned here, but I don't think anyone had a proposal. If it hasn't been done already, I'll be submitting an OpenJDK proposal soon once I finalize the design.
When did I say it prevents you from writing HQL queries or using the Criteria API? Being able to update an object that contains 40 fields including multiple entities with a single HQL query is worlds beyond raw SQL. That's what I was saying. I *specifically* said "raw sql" to communicate this. Beyond that saveOrUpdate method exists, and transactional can be done programatically. https://github.com/Redmancometh/RedCore/blob/master/src/com/redmancometh/redcore/databasing/SubDatabase.java line 200 ish I made some very performant shit on that platform. For Minecraft stuff, but still, 400 players with 100s of data points is quite a bit of stress. I can't show you current code (NDA) but I use hibernate, and often Spring for *massive* HIS setups. It is an absolute godsend. HQL, Criteria, and abstraction for DB objects is invaluable.
Nice one Java. Smh
I think the first two methods above lack the elegance of streams. These eager methods will cause problems e.g. you write your code and later realize you need additional operations performed. You have the choice of adding more methods calls of the same style that create more collections that are not needed at all or rewrite everything to stream. Your usage examples are the same as using stream except not writing the .stream\(\) and producing problems when used. Also adding a second way to do the same thing, in this example a more functional style to handle collections looks pretty bad to me. Third method \(sorted\) already exists as far as I know.
Here is another tip if you email or SMS a 2nd factor code for any purpose. Use an alphabet made up of: * Digits 0 to 9 * Uppercase letters EXCLUSING O ("oh") and L ("ell"). That way if I ask you to type in code: A80L5X there can be no confusion that it is: a8o15x Can't confuse lowercase L with one, nor zero with uppercase O. If the user types in an L or O (or lowercase), then "interpret" it as a one or zero. This eliminates all possible confusion. Your alphabet of chars is a 34 character alphabet. Generate a random number. Convert it to base 34 as expressed in your alphabet.
If you want an easy solution, a wall of help text, I can post a [Java class](https://i.imgur.com/sF1qNUK.png) I wrote long ago. It only depends on 'javax.swing'.
These ideas were considered and rejected way back on the lambda-dev mailing list. Oracle won't take such a proposal seriously in any case, but if you want to give it a shot you'd have to explain what was wrong about lamba-dev's analysis way back when. 
I was considering something like that. Though I'd like to give a little bit more structure, like a tree with topics and then a wall of text right besides it (like the "classic" help systems). What I'd also like to do is being able to display the help directly from the input window, like you type `help functions` an you see the help for the functions.
That's not great :/
Is this the new ‚Äòthanks obama‚Äô, but the people saying it are being unironic?
I can imagine. With some thorough JMH benchmarks, I'm sure I'll get them t, at least, consider it.
https://web.archive.org/web/20150811052336/https://blogs.oracle.com/maryanndavidson/entry/no_you_really_can_t &gt; ‚ÄúI do not need you to analyze the code since we already do that, it‚Äôs our job to do that, we are pretty good at it, we can ‚Äì unlike a third party or a tool ‚Äì actually analyze the code to determine what‚Äôs happening and at any rate most of these tools have a close to 100% false positive rate so please do not waste our time on reporting little green men in our code.‚Äù Mary Ann Davidson, Oracle CSO
Wow.
That whole blog entry is so ignorant and arrogant it's hard to believe. 
The majority of Spring projects rely on Java EE. A lot of developers just do not realize they are using it.
[Screenshot](https://gitlab.com/RobertZenz/jMathPaper/raw/master/screenshots/01-main-view.png)
what overhead?
In regard to 1: The problem is if you have a method `filter` like you proposed that returns either a new collection or an unmodifiable view can be seen in this example: `someList.filter(...).filter(...).filter()` Regardless of the returned collection this will produce 3 new collections. This is the reason why the existing methods you mentioned do not return anything. Because that way the method communicates to the user that it might not be prudent to chain these one after another. This is where I was talking about the elegance of stream because it will only produce a single collection in the end, if you chose to do so. In regard to 2: If I do not want to have the problem described above but need the second and third filter now \(because my requirements changed or whatever\) I need to rewrite this to use the stream api, which would be the cleanest solution. Otherwise I could cram the 2 additional predicates for filtering into the first filtercall. This would most likely make the code harder to read/understand. Seeing how code is read more often than written I would like to avoid this. Hope this made some things more clear.
What do editors have to do with Truffle?
What? People were being ironic about Obama?
The overhead of streaming a collection, operating on it, and collecting it back into a list.
Thanks, it does. I've been debating whether or not to have it operate in place on the same collection, but I had thought that would cause some issues. Maybe that would be a better option.
Careful with micro benchmarks. Your benchmarks are not comparable because: * Collection#removeIf deletes all elements matching the condition. * Stream#filter retains all elements matching the condition.
How on earth does someone who hates security that much, and tries to hide behind lies like that get so high up in a position like that? Just crazy.
Related: https://www.bleepingcomputer.com/news/security/hackers-make-whopping-226k-installing-monero-miners-on-oracle-weblogic-servers/
She's right, folks really shouldn't waste any time reporting issues with their code to them. In the case of flaws in Oracle code, they should simply sell those exploits through underground channels. Win for you and a win for Oracle. 
&gt; For now, Beaumont is recommending that companies block incoming connections on port 7001 until Oracle issues another ‚Äîhopefully working‚Äî CVE-2018-2628 patch. Why on earth would you have that port open to begin with? You should deploy weblogic behind a firewall and use an OHS server in a DMZ. 
&gt; Mary Ann Davidson, Oracle CSO Diversity hire.
Thanks on explaining Mylyn. As for the XML editor. I guess, it is subjective. Almost (if not all) developers I've seen, when opening the pom file; always immediately goes to the xml view, ignores the form view. Personally, i did use the form view for editing property values. Maybe it's local culture.
if they write the core parts in C++ (with ffmpeg), the rest shouldn't be that big of a problem.
TIL people still use WebLogic 
If it talks TCP/IP, some instances will be exposed on the internet. It's pretty much a law. Never fails.
The law is pretty much don't expose your middle tier infrastructure directly to end users - internet or intranet. Standard perimeter security practice. Still Oracle should fix this shit, it's just lazy. 
Batman's Law?
Such things may only be said with irrefutable proof. She's been working with Oracle for thirty years, you can check her wikipedia page.
I'm surprised that you're suprised by this. Oracle have been *Scrooge McDuck* for pretty much forever.
Not quite, lol. There's still a reason we are on JDK ~~8.171~~ 8.172. There are constant issues with SSL and similar issues. Read the release notes :)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Could you please repost it?
Sure, that's the sensible thing, but the I in IP stands for "internet." It's a siren song of messed up network segmentation.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think that the guy point is not "is impossible" but it's more likely asking you if it's the right approach to build something like this in electron. About the example of YouTube, they need it to be web, as their product is on the Web and run on a browser. Not everything needs to be thought, and it's the right call to use the right tech stack for the right problem. That said, I still do use electron for some projects, and I like the idea of it. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Doing that via raw sql queries would mean a ton of joins per query Sure, a bit more verbose I guess. [The upcoming version 3.11 of jOOQ will support them as well, but for the SQL language](https://blog.jooq.org/2018/02/20/type-safe-implicit-join-through-path-navigation-in-jooq-3-11/). But I don't think it's a show stopper. &gt; and an absurd amount of SQL queries I'm not convinced by that. &gt; Hundreds of them if we wanted the convenience of one for each field I don't know what that means (one query per field? Sounds wrong), but I'm also not convinced by that. &gt; With really huge schemas wrestling hibernate is very worth it. Again, not convinced :) I've maintained codebases where we ran several dozens of joins, unions, etc. in each of around 5-10 layers of derived tables. There was no way we could have implemented this logic in HQL. The execution plan had hundreds of lines, and the queries ran below 5ms on billions of rows.
&gt; Being able to update an object that contains 40 fields including multiple entities with a single HQL query is worlds beyond raw SQL. Would you mind showing a redacted example? &gt; 400 players with 100s of data points is quite a bit of stress [...] for massive HIS setups I'd really like to have an idea of what you consider *"massive"* :-)
Yeah. That's one of the reasons why I didn't embed Ace or CodeMirror in my recent project for syntax highlighting. The WebView overhead is just too much. But I guess there's no way around it. Rendering HTML and CSS is expensive. I'd rather go for Electron if I needed to embed web technologies in a desktop app because JavaFX's WebView is not even close to Chrome in terms of performance. For the record, I hate Electron.
That's true, so are you going to propose standardizing clustering and driving the work?
&gt;If you think this utter clusterfuck has anything to do with technology choices *anything*, yes, possibly. *Everything*? no, of course not. Most insider info seems to point at rushed testing and managers being pushed to meet the deadlines. Poor outsourcing management has also been mentioned. I'm sure it Java EE has been chosen similar mistakes in the use of technology would have been made. It's just ironically that you KNOW Spring people would have beaten Java EE over it if it would have been Java EE. It's how Spring people are and its part of the Spring culture. But now that it just happens to be Spring, Spring people are eerily quiet and if someone mentions Spring there's at most an angry response asking what Spring has to with it.
&gt; It's just ironically that you KNOW Spring people would have beaten Java EE over it if it would have been Java EE. I'm sorry but this is just childish. There is no "Spring people". We're all just back-end devs. Who cares what framework you use. There's a few of you guys who want to turn everything in a "Spring" versus "Java EE" thing. Just because I have a personal preference for Spring for it's ease of use doesn't mean I'm against Java EE at all. I'm a consultant so I'll just use whatever the heck the client wants, I don't care. 
I'd like that lightbend did that. They have much more experience and resources.
Much of Oracle's own software offering runs on top of weblogic, so it's very common in big enterprises.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I would suggest your friend adds a couple examples to README, helps sell the product
Still, it's implementing the interface, maybe you should read the documentation of the library and thus know what you should expect
Fair enough, but if I'm running some Java desktop app on the JRE \- I could be using 1.3/4/5/6/7 and it'd be fine. Taking your example, there are exceptions of course \(like if I was using TLS tunnels and the JRE for publicly signed certs, etc\), but it's not like having a Java app running on the desktop is an issue. Applets, in any form, became an issue. It didn't matter what version of Java and what sandbox was used, they ultimately were a flawed technology that was ripe for abuse. Technically, a lot of that abuse is due to user complacency \(next, next, next, finish mentality\), but them's the ropes. 
Im trying to see if it is possible to run a java GUI program on a chromebook. I was able to install Java after enabling developer mode, and i can run console java programs just fine, but when i try to run GUI programs i get thrown some exceptions that i am not quite sure what means.
And it probably need to exist on Maven Central...
They might be using Spring Boot, but the failure has not much to do with the technology. 
/u/henk53 should change the title since the failure is only remotely related to the used technology. This title is just trolling.
Can you provide me with instructions on how to change the title?
Hibernate does indeed shine when it comes to updates. That is about the only time it does.
Might be Spring, but blaming Spring here is like blaming the hammer hitting your finger ...
Java Web Start is great for B2B or internal apps but unfortunately it is deprecated. Looks like Oracle is wanting to move away from deployment mechanisms that require a user to have an already installed runtime. Also, your pack200 jar was only lighter if the user already had an installed runtime. If not they had to take the extra step of installing a runtime and hopefully they knew how to do that.
Both Swing and JavaFX are better for desktop apps that the hacked together web-based ones. There are two main reasons, first both swing and JavaFX have sane layout managers, whereas with web-based technologies layout was an afterthought and until the advent of CSS Grid (only just now being supported) and FlexBox layout in a web app was nothing more than a dirty hack. Secondly, both Swing and JavaFX have a rich component library to build your apps with, and as an added bonus the look-and-feel of them match the rest of your app and they don't look tacked on like some random jquery library does.
"Would you mind showing a redacted example?" Uh I'm not really sure what to react, and my NDA is preeetty heavy. It's for an HIS for several very large companies. I can give you a decent breakdown though. I'm gonna try to describe it relatively verbosely: You have a top level entity. Let's call it Process. Process contains 20 strings, and 5 booleans. It also contains a Set of User entities in a ManyToMany relationship. User contains several option nodes, and a Set of Address objects (another entity.) It contains a very bloated entity called Order, and another called LabAnalysis. Both are in one to one relationships with Process. Order contains a Set for Panel, ICD10Procedure, and GivenTest (these are all entities) and a HashMap&lt;String, String&gt; for comments. There is also a Patient field, and a OneToOne with a wrapper for GivenTest with additional info, and a FacilityPerformed entity. It also contains another 6 booleans, and 22 strings. Some of the springs are created from objects via @PrePersist. Each GivenTestWrapper contains a read-only GivenTest instance, 4 enum values, 8 strings, 4 booleans, and a HashMap for LabAnalysis. All of the objects I haven't gone into detail in are somewhat small, and contain &lt;10 fields. So what I can do is create my objects, or pull from the DB if existing, and then use: @Modifying @Query("UPDATE Process p SET p.order=:order WHERE p.processId=:processId") public void updateTOrder(@Param("order") Order order, @Param("processInstanceId") String processInstanceId); And thanks to the magic of cascade everything that needs to be updated is updated, and everything that doesn't stays as is. Figuring out the transactional stuff was a little fucky, and I ran into some errors implementing it, but it's solid now. 
"Again, not convinced :) But if I could see an actual example, I'd love to learn more!" So I responded to another dude here with a pretty solid example. The big thing is you can do shit like this: @Modifying @Query("UPDATE Process p SET p.order=:order WHERE p.processId=:processId") public void updateTOrder(@Param("order") Order order, @Param("processInstanceId") String processInstanceId); Where Order is an entity contained within Order, and contains a ton of entities itself. "I've maintained codebases where we ran several dozens of joins, unions, etc. in each of around 5-10 layers of derived tables. There was no way we could have implemented this logic in HQL. The execution plan had hundreds of lines, and the queries ran below 5ms on billions of rows." I haven't run into anything I couldn't do with hibernate thus far. A few things I've had a hell of a time implementing, but eventually got it. Billions of rows in a database or in a table? Because billions of rows in a single table sounds problematic architecturally. 
Yeah... B2B it was. Now we have to maintain separate builds, signature verifiers, and updaters for every platform, essentially rebuilding Web Start in-house. I'm really, really disappointed in Oracle. 
&gt; Where Order is an entity contained within Order, and contains a ton of entities itself. Pardon my ignorance, but apart from a bit of syntax sugar provided by JPQL, how is this impossible to do with SQL? UPDATE process SET order_id = :order_id WHERE process_id = :process_id Where's the killer productivity gain? &gt; Billions of rows in a database or in a table? Because billions of rows in a single table sounds problematic architecturally. The client was a mid size bank, and they had ~ 1 billion bank account transactions per year. That's just how things were there. I don't see how this is related to architecture. There were ~ 500 other tables, many of them had 100 million rows. And even with that many rows (still, mid sized. Oracle can handle much more), we hardly had any significant issues with the query complexity I've mentioned... &gt; I haven't run into anything I couldn't do with hibernate thus far. A few things I've had a hell of a time implementing, but eventually got it Good for you, but you criticised SQL for not being able to get even close to HQL queries and I'm certain you got that wrong.
Oh indeed. If you're persisting (writing) the object graph to the database, then the ORM definitely helps. I thought this discussion was about reading, mostly - my bad.
What about Clean Code? https://www.amazon.de/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Hahaha thst first part was a typo I meant Order is an entity contained on Process. I thought query was a general term for database operation. I'll consider revising my terminology in the future
Nah, it's not so very common anymore. Big enterprises also know WL is not going to last much longer and that Oracle has lost many of its top engineers. Today WildFly (JBoss EAP for enterprises) seems to be the most common server. But... and that's a big but, I don't think anyone ever has (and even can) do a realistic amount of the number of instances of each server that's in use. For example, if 1 big enterprise has 100.000 WebLogic instances, and 1000 smal businesses have 1 WildFly server each. How do you count this? Is WildFly uses 1000x more than WebLogic, or is WebLogic 100x more used than WildFly is this hypothetical example?
These are good video tutorials: https://www.youtube.com/playlist?list=PLFE2CE09D83EE3E28
Please read the sidebar.
I‚Äôm on mobile I‚Äôm not too sure how to do that:(
1. This is not the subreddit for *learning Java* or *Java programming* related questions. /r/learnjava is for the former, /r/javahelp is for the latter. 2. On mobile, the method to read the sidebar differs from application to application, so I'll post a *verbatim excerpt* from the *sidebar* of */r/javahelp*: &gt; **Learning Java** &gt; &gt; Please head over to **/r/learnjava** and read the **sidebar** there. &gt; &gt; The best free Java tutorials are: &gt; &gt; + MOOC [**Object Oriented Programming with Java**](http://mooc.fi/english.html) from the University of Helsinki &gt; + [**Java for Complete Beginners**](https://www.udemy.com/java-tutorial) by John Purcell &gt; &gt; Use the MOOC as main course and Java for Complete Beginners as secondary resource. &gt; &gt; Don't forget the [**Official Oracle Java Tutorials**](https://docs.oracle.com/javase/tutorial/) and the [**Official Java Documentation**](http://www.oracle.com/technetwork/java/javase/documentation/index.html) as they are *extremely valuable* resources.
Hey thanks!
Neat. A few tips from someone who was just there: * I can't see any tests, so add some (preferably a lot). * Find a name for the project (and make a website, you can use https://pages.github.com/) * Publish on maven central * Prove that it's fast by creating some tests * Write a tutorial showing how it works * Once this is done: * Post to hackernews (in the "Show HN" section, remember to format the post properly) 
I agree it's childish, but it is what it is.
The article does not seem to mention what is the underlying library that implements connection pools in Payara. Is it one of the well-known ones or a completely custom? It also doesn't mention that using the app server for managing a connection pool is not compulsory. The alternative method is to have your application manage the connection pool itself rather than delegating to the app server. And in some case (e.g. if the app server is locked down) this is the only option available.
I use Alpine for the one case I use Docker for, works great.
LambdaConf maybe? There was a controversy some time ago because they wouldn't ban some speaker because of his personal beliefs.
I would counter with, is it possible to go back to Java 7 because FP was a really bad idea in the first place. Java isn't JavaScript and that's a good thing. Please stop poisoning Java with this new age crap that is only going to hurt long term maintenance (and job stability).
Yep, yet another pro-Payara post by a Payara shill. I‚Äôd have no idea that Payara even existed if it wasn‚Äôt for shills like /u/henk53 which I guess what they want? Anyway, fuck Payara.
Any comparisons to current popular connection pools? HikariCP, for example? Any benchmarks? No? What's the purpose of this article then? To promote your own app server?
Neat. Checking... I've been looking forever for simple http server that's not using servlet framework under the hood. https://javalin.io/ comes close, but it uses Jetty and Kotlin which makes runtime size a bit bigger for my needs...
[@thomaswue's latest tweet](https://i.imgur.com/IjImk5i.jpg) [@thomaswue on Twitter](https://twitter.com/thomaswue) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Java coding
Dude's been an active redditor for 9 years, idk man.
Yes! Thank you!
The article is pretty vague in how Lightbend might change Jakarta EE. But I'm looking forward to a more async Jakarta EE. By the way: the name "MicroProfile" won't make much sense in a more modular future.
Useful update from the old blog. 
@SneakyThrows does not wrap the exception. It merely suppresses the compiler's usual behaviour of requiring you to deal with it. Therefore the the problems with RuntimeException that I talked about do not apply.
"My first impressions" he never said anything else.
Recursive solutions tend to be a bit harder to debug because the same Method is involved so often. At least in my experience. 
Another possible concern with a recursive function is runtime. Doing the problem with a stack could save you a lot of time. For example, if the maze only allows you to go on a straight line for n moves, and you find that this leads to a dead end, the recursive function will return from each position along the way until it backtracks to a position with another valid path. Using a stack to keep track of every position that has more than one possible path would allow you to just pop the last position that has another viable path. I guess it depends on how you implemented your recursive function in the end. This may not reduce your runtime by a meaningful amount, but it shows that you can find a minimal yet effective solution. 
I agree that in some cases, the recursive method does not mimic how we intuitively think about a problem. For example, searching for a character in a string. However, in other cases, we more naturally think about a problem recursively and so the iterative solution can be harder to understand. For example, navigating a tree. I'm sure that for some problems, it will vary from person to person.
Can your recursive function get stuck in loops, eating more and more resources? 
It looks like in your [submission](https://www.reddit.com/r/java/comments/8gpbkl/someone_please_help_i_have_two_questions/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/8gpdoq/please_help_array_questions/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
looks almost like vertx
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
What I would really like to have is custom toString() method in Collection interface, which takes function as an argument. public String toString(Function&lt;E, String&gt; stringFunction) { return "[" + stream().map(stringFunction).collect(Collectors.joining(", ")) + "]"; } So for Class which doesn't have toString() method defined you could do: System.out.println(collection.toString(e -&gt; e.getFirstName() + " " + e.getLastName())); and it would nicely print something like: [Adam Sandler, Matt Damon] instead of [ee.abc.Person@5f150435, ee.abc.Person@1c53fd30] 
Came here to say this. It's literally just a difficult solution to implement and therefore easy to mess up. However when done properly they can be elegant and neat.
Just override toString in your person class?
Maybe I don't have control over the Person class?
Adding isEmpty is pointless. You still need a null check, which StringUtils does not need because it is null safe. I wish they went all the way and added a static method. Compare: &gt; myString != null &amp;&amp; !myString.isEmpty() vs. &gt; StringUtils.isNotEmpty(myString) vs. &gt; !myString.isEmpty() &lt;--static method
Maybe one day they will even add string padding utils to the stdlib.
Cool `String.isBlank()` sounds useful!
Spring batch is for batch processing. If you need to just send an email see the following boot documentation and the referenced links here - https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-email.html
Why not make it static and return false when the String passed as argument is null?
The most irritating thing to me is the lack of an isNumeric(). Completely mind-boggling that they can add so many seldom used methods while avoiding a method I would use in just about every program I write.
Recently I tried to update a project to Java 10. But there was a bug when compiling. This bug is confirmed by Oracly, but they fixed the bug only in Java 11-ea. But Java 11-ea, being month away from release, is not an option. I tried it anyway out of curiosity, but then Gradle broke, because Groovy, which is used by Gradle, uses stuff that is removed in Java 11. Then I downgraded to Java 9 to face the same issue as with Java 10. My conclusion is: You should only use the LTS releases, and these preferably only a few month after the initial release. It is ok to use the _development snapshots_ like Java 9 or 10, but you shouldn't use this stuff in production.
Exceptions = lots of extra overhead and unnecessary additional code. Moreover, why should be an error to begin with? That's not what exceptions should be used for. It's not an error. It's a simple check of what type of data is input. It's absurd to be catching exceptions or matching convoluted RegEx's for something as simple and commonly used as "is this a number?" That should be core functionality to any language. C# has it. Why doesn't Java?
It's pretty big in Government enterprise solutions.
Sure, there could be a nice validation utility in the JDK for this. But not on `String`.
Also had Gradle fail on me when I updated a project to Java 9, ended up moving back to Java 8. I worry that this new release model would cause some companies to think twice about using Java.
Out of curiosity - what bug was it?
What else would it be on? User input or traversing data is always via Strings initially.
Something that can get tricky with recursion is mutability, if your algorithm has non-trivial side effects I prefer a non-recursive version.
I've released [v1.2.1 which fixes any issues with the configuration](https://gitlab.com/RobertZenz/jMathPaper/tags/v1.2.1).
So adding wrapper per class is better than inserting small method to existing interface? I don't think so.
Better make it explicitly shown that `myString` is not null-safe and also may be an empty string: ```java if (Optional.ofNullable(myString).orElse("").isEmpty()) { // Why you can't decide? } else { // Yay myString can be used! } ``` or make sure you don't have any strings with `""` or `null` at all: ``` public static Optional&lt;String&gt; nonEmpty(String nullable) { final Predicate&lt;String&gt; blank = String::isEmpty; return Optional.ofNullable(nullable).filter(blank.negate()); } ``` which then makes a safe string from an unsafe one: ```java Optional&lt;String&gt; organization = nonEmpty(unsafeOrganization); organization.ifPresent(user::addToOrganization); ```
Flame graphs are a pretty useful visualisation. Big credit to Brendan Gregg for inventing them.
What is the use case for that?
&gt; When used appropriately, they can be more concise, easier to understand and easier to implement, Ok, but when use inappropiately there can be more difficult to implement and debug than bad non recursive solutions
Would be a nice `PrintableCollection` -- perhaps it also knows how to write to `System.io` on multiple lines.
It should be on the type you want it to be, not the type it is coming from. So if you want a `Long`, then it should have something to do with `Long`. Perhaps a safe `static Optional&lt;Long&gt; possibleLong(String s)` factory method with no exceptions. 
Okay, but what's the pros of recursive solution?
You can just do `new Scanner(string)` and call: * hasNext‚Äã(Pattern pattern) * hasNextBigInteger() * hasNextBigDecimal() * hasNextBoolean‚Äã() * hasNextByte‚Äã() * hasNextDouble() * hasNextFloat() * hasNextInt‚Äã() * hasNextLong‚Äã() * hasNextShort‚Äã() I suppose `hasNextDouble()` or `hasNextBigDecimal()` is the closest to `isNumeric()`
The Javalin`Hello World` jar-with-dependencies build is about 3mb, how small do you need it to be, and why? I actually considered not using Jetty for this reason, but I figured it wouldn't matter.
Ewww. Watch [Optional](https://www.youtube.com/watch?v=Ej0sss6cq14).
It makes good method references in Streams and apache.commons has you covered.
Concise and helpful!
Thank you.
[removed]
I don't have real experience with building a proprietary licence system, but if I were to go about it, I'd create my own backend server API that would have a way of verifying a key against a DB of keys... It could also track how many times has a person activated it. Imho this is a non-trivial problem, and you'll always be a very vulnerable to attackers, especially if you build a custom solution. I mean, we're talking about DRM, basically. 
It really depends on Oracle's support plans for the LTS releases, which they **still** haven't announced yet. :(
How is this helping if we are talking about collection to string method?
I'd rather have a "test-and-convert" like C# has.
Yes! That would be even nicer. Please Java, pleeeease?? int.TryParse(strInput, out intNumber);
I aint touching shit until jdk 11. I'm on 8 and that's where I'll stay. I simply do not have time for that upgrade dance every 6 months. 
The whole point was to avoid this loop, that's why I proposed it in the first place. My solution was singleliner, yours takes a loop and a static method... 
I agree with others. You have a product that is in need of users. You should focus on building up a user base with permissive licensing. Then you can worry about how to enforce the license. You do not want to be spending money worrying about license enforcement before building features and evolving your product.
In your example, You own the Person class. How can you think it would be better to change the JDK for your use case when you could simply override toString in Person?
isFirstName() lol? I don't see that working
It's Java, so you're not gonna be able to keep people from citcumventing your DRM. Unless EVERY function hits a RESTful API on your end. If you rely solely on auth done on a restful API they'll just modify the software. Java is notoriously decompilable
eh, it's hardly a ton of code to write and it's much simpler conceptually than defining a method in the parameter of another method. Most of the time you would be able to just define an appropriate toString for the person class (or define a subclass that overrides the toString) and this wouldn't be an issue.
Recursive functions can often be simpler read and understand. Some languages like Kotlin can optimize a tail call into a while function under the covers, this can lead to an elegantly simple solution without the performance hit.
&gt; Going from Java 9-&gt;10-&gt;11 is closer to going from 8-&gt;8u20-&gt;8u40 than from 7-&gt;8-&gt;9. Only if you count by time between releases. If you count by any other measure (e.g. forward and backwards compatibility), then it is not the same. It's a bit disingenuous to lump large syntax changes and small bug fix changes under the same "feature releases" umbrella.
http://www.oracle.com/technetwork/java/eol-135779.html covers when they will stop giving public security updates which pretty much answers that question.
I think the ecosystem is not ready for it, even if Java 10 was released, I can exploit its full potential because WindowBuilder is not compatible with it and I don't know when it will be, so I have too back to Java 8 or the deprecated Java 9.
I see you can't read a table: Release| GA Date |End of Public Updates Notification |End of Public Updates :--|:-- | :--|:-- 11 (18.9 LTS)***| Sep 2018| TBA**** | TBA**** 
It's a step forward, but it's not sounding like I'm dropping my dependencies on Commons or Guava anytime soon
you sell it instead as a service and charge people for you to host it
&gt;the space character codepoint (\\u0040.) That should be \\u0020 (20 hexadecimal, 40 would be correct in octal).
He/she was basically mocking the idea of isNumeric() and suggesting using exceptions as is the standard case now in Java-land. I just think it's absurd to use exceptions for input validation. C# and even VB handle it much more reasonably.
you mean you‚Äôve never had to check a string for null or empty? what do you work on?
When would null and empty string be a single condition? Usually null is for special cases.
Along with the already-discussed compiler and runtime behaviour challenges, the new stance from Oracle means that you can no longer rely on your end users having access to any particular runtime. You'll have to roll your own runtime using jlink on every platform you plan to release for, and package natively. The modules system is a fustercluck. You'll need to step away from JavaFX; making openjfx work is like pulling teeth.
When is `String.toString()` coming?
Oh lol they all seemed doable except that one hahaha
I mean, this is how Java works anyway. Have you seen the android/iOS/js WebRTC api? Or the media api's in general? Or the WebKit api's? They only cover the most basic functionality of the software they wrap. Whenever you want more you have to do it using c++ and, optionally, add it to the api of the language you want to use it in. 
Here's the codepoint version of .isWhitespace . isWhitespace public static boolean isWhitespace(int codePoint) Determines if the specified character (Unicode code point) is white space according to Java. A character is a Java whitespace character if and only if it satisfies one of the following criteria: It is a Unicode space character (SPACE_SEPARATOR, LINE_SEPARATOR, or PARAGRAPH_SEPARATOR) but is not also a non-breaking space ('\u00A0', '\u2007', '\u202F'). It is '\t', U+0009 HORIZONTAL TABULATION. It is '\n', U+000A LINE FEED. It is '\u000B', U+000B VERTICAL TABULATION. It is '\f', U+000C FORM FEED. It is '\r', U+000D CARRIAGE RETURN. It is '\u001C', U+001C FILE SEPARATOR. It is '\u001D', U+001D GROUP SEPARATOR. It is '\u001E', U+001E RECORD SEPARATOR. It is '\u001F', U+001F UNIT SEPARATOR. Parameters:codePoint - the character (Unicode code point) to be tested.Returns:true if the character is a Java whitespace character; false otherwise.Since:1.5See Also:isSpaceChar(int)
In an ideal world. But we do not live in an ideal world.
Comment about missing extension methods in java. 
That would destroy even the non-recursive solution.
True, but it can be much harder to build in failsafes into recursive maze solvers
I haven't upgraded from 1.8 (or 8 depending on your nomenclature) and don't intend on doing so untill it's ripped from my hands. 
Hey, BigGayMusic, just a quick heads-up: **untill** is actually spelled **until**. You can remember it by **one l at the end**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
The fuck?
Delete. 
Lol. I imagine you need to say it without caps.
delete
Anyway, with no help from Collection interface I'd prefer just using this over your solution. String output = mycollection.stream() .map(e -&gt; e.getFirstName() + " " + e.getLastName()) .collect(Collectors.joining(", ", "[", "]")); And I have no clue what you mean by "method in the parameter of another method". It's called lambda and it was added just for that reason in Java 8.
I don't see mention of post EoL security patching support that Oracle has had on the past. I do like the LTS style periodic release cycle, but this plan fails in the model of providing any overlap between non-lts versions. The post could use more information about plans and stewardship of security related issues going forward. 
I'm not sure I understand. Null is the default value of an unset variable when reading from a database, for example. What else would there be? If I read an object from a db and have to do something with strings, I have to check for null values every time, not for empty strings. You're implying that this is bad design though, what's the alternative that would make good use of this new isEmpty method?
See zenix Klass Master tools to make your code not decompilable. And see Hasp sentinel ldk for a full drm system, easy to integrate and with a really low cost. 
I'm just saying there shouldn't be a String.isEmptyOrNull(String), because you would want to check for those null and empty string separately.
That's not a use case, that's an example implementation.
But if OpenJDK is to be made a viable drop in replacement for Oracle Java, then the community can provide whatever LTS support they want, not?
Well, you can always buy extra support from Oracle, right?
I haven‚Äôt used octal since 03677.
But that's what I'm asking, there is no difference between an empty and unset value in a database, by design in hibernate at least. And I don't think it's that specific of an use case to check whether a value was set or if it wasn't, and checking for null and empty does that. So why create methods based on a standard (Null and empty should never mean the same thing) that doesn't actually exist in practice? How else would you differentiate an empty and a null value in a db?
So is java, so why are you here?
It would be possible with the current tools, but cumbersome to do. You could create something like a `ResultHolder&lt;sourceType, targetType&gt;` class holding both a result of type T and an error status. Then you could create a method in it `tryParse(sourceType sourceObject, Function&lt;sourceType, targetType&gt; parseFunction` and surround the `parseFunction.apply` with a try-catch.
Quite true. The issue with this is who, exactly, in the community will backport the security and bug fixes from the current JDK to older versions? This is a non-trivial task, which also requires a high level of trust (especially for security patches). The reliance would be on someone, who hopefully knows what they're doing, working on this in their spare time. To me, that doesn't have success written all over it.
Cometh the moment cometh the dev. The vacancy is just about to open up now. I'm sure we'll get someone putting their hand up.
Separation of concern. You could also use inheritance to have a PrintableMyObject
Single responsibility
To clarify, I mean my GTK *theme*. Using any other version just results in the default GTK theme.
If it was that obvious, more people would grow out of it Rather I suspect it's one of those people who thinks that being nice to look at is the only virtue
I see more and more people distributing the JVM with their product. Java 9 modules makes the JVM smaller to distribute than before, but it's still a hassle. Additionally, it's also making me happier to use Docker for Java applications. Previously I didn't see the point so much, because "hey, I've already got a single deployment artefact in the form of a WAR", but now it's becoming more useful to ship that war and a JVM with it.
It hasn't been 1.x since Java 5. 1.4 was the last 1.x version number.
Still no news on Oracle's plans for public updates for LTS releases. It's in September and we still don't know if Oracle is going to dump us after 6 months or three years.
That is not async IO, that is just delaying the response. Do not use JAX-RS as an example on how async should work in web frameworks, because they got it wrong (IMHO): * In JAX-RS, there is no way to read the request body in a non-blocking way. There is only `InputStream` and that blocks on slow clients. * You can delay the response (and not block a request thread while waiting for the response to be created) using `@Suspended AsyncResponse`, but once your response is ready, you have to write it all at once, and that will block if your response is bigger than the write buffer. No support for streaming large responses without blocking on slow clients or buffering to disk. * You might think that `StreamingOutput` is perfect for, you know, streaming output. Nah, it sucks: It reads from a (blocking) `InputStream` and writes to an unbounded and/or blocking write buffer (no back-pressure control). For large downloads, you either run into OOMs, end up buffering to temporary files, or block a thread most of the time (depending on the implementation). Raw Servlets (3.1+) do support *real* async IO. You can read from the request and write to the response, both in a non-blocking way and with full (albeit really hart to get right) back-pressure control. The only problem is that it is really easy to 'drop the ball' with async servlets and end up in a state where you are mistakenly waiting for the client because you missed a listener call or forgot to call `ServletOutputStream.isReady()` until it returns false. Or to issue read or write calls more often then you are allowed to and get mixed results. Or re-use a buffer you are not supposed to re-use before some event happened. Writing a simple async echo client (just copy input to output) is really harder than it should be. But it works. Not so with JAX-RS (or Javalin). A simple test for a web framework that claims to support async IO is to ask: Can I write an 'echo' application that accepts requests of arbitrary size, copies the bytes to the response body of the same request, and serves (significantly) more concurrent clients than there are threads? If you have blocking read/write calls or unbounded buffers (memory or disk) anywhere in your pipeline, then the answer is no. Slow clients will eventually exhaust your tread pool, heap or disk space.
&gt;The difference is JavaFX has these features as part of it's api already and uses DirectX or OpenGL under the hood for you. No need to use c++. The difference between what and what? &gt;multi platforms You already get multi platforms with c++, just compile for a different platform. &gt; Distro 1/2 of Electron How is that related to the fact that Java is an amputee at video manipulation. Have you looked at javafx.scene.media package? 
jooq.org
This title is confusing. I mean it's great that you went through the process of building JavaFX from source, but what does that have to do with NetBeans? I thought NetBeans was based on Swing \(which \_can\_ mimic native L&amp;F on various platforms\).
Have you looked at the link itself? 
Kotlin has an extension method for Strings. So you can use str.isEmpty() even if it's a null object (because extension methods compile into a static JVM method in which the object is the first parameter) .
what link? 
THE MAIN LINK THAT STARTED THIS WHOLE SILLY CONVERSATION.
Database reporting as a service is a backdoor..
https://www.jooq.org/legal/licensing#databases
This is getting out of control. Who are you folks!?
I've only really used it in the context of Linux (*chmod 777*).
Why not Vert.x? Very light, uses Netty, similar API to express, and it is backed by the Eclipse Foundation and Red Hat. Used in production for MANY high performance workloads at places like Hulu, Red Bull Media, etc... 
android
As someone with a decently-sized project considering migrating from AWT to JavaFX, can you walk me through a very wide overview of the process of building a VM from source with JavaFX support? How easy do you think it would be to bundle it with my package? I'm still waiting to hear how JavaFX will be made available for future projects, so I guess that's as good an option as any...
If you use a Stack, couldn't you also use a multi-threaded approach (with a data structure that uses concurrency)? 
It's not just some dude. It's the creator of Optional.
Gotta be honest, took me awhile to realise what L&amp;F meant. I thought it was lost and found as in some hidden gem lol
I've put everything that I did into a small guide @ https://beingwinsysadmin.blogspot.de/2018/05/java-usage-tracking-or-how-to-figure.html Just for future reference.
Yeah, but just because he's Stuart Marks, (one of) the creators of Optional doesn't mean he's in a place to tell people when they should and shouldn't use Optional. I see a lot of benefits to using a null-safe object like Optional, and it's not WRONG to do so. We shouldn't replace all nullable objects with Optional, but it's fine to use it in contexts that Stuart Marks, (one of) the creators of Optional doesn't approve of.
It‚Äôs look and feel, for anyone lucky enough to be unfamiliar with Swing design.
Thank you, this is great. Do you mind if I copy your response to our GitHub issue? Even if Javalin is "just delaying the response", that should still provide a significant performance increase? I'm not trying to argue, as you clearly know this a lot better than I do, but most users who requested async talked about long-running tasks (not the actual writing of the response), so this is what I focused on. I'm able to service thousands of delayed requests with just a few threads Am I tricking myself with this kind of focus? &gt; I wrote an abstraction layer on top of javax.servlet.AsyncContext that basically offers this non-blocking API (simplified) Is it available anywhere online?
The JavaFX part was just an extra tidbit. Netbeans runs and is influenced by the system JDK. If you ran it with any previous version of Java(8,9, 10, Oracle/OpenJDK) it looked like [this](https://imgur.com/a/sIg1cJZ). At some point, the ability for Swing to (almost) perfectly integrate with the system L&amp;F was added in OpenJDK 11.
Well, AdoptOpenJDK has already announced that they will be releasing LTS builds, so you'll get backports for those at least.
From what I understand from [this talk](https://www.youtube.com/watch?v=-77pMQhgupk), oracle will *not* be releasing public updates for LTS versions for oracle jdk (because oracle jdk will stop with 11) or openjdk. However, AdoptOpenJDK has announced they will support LTS versions for four years. I made a chart here: https://yawk.at/java-support/
Even when upgrading to 11 you should switch to an openjdk because oracle has not announced that they will offer free LTS support for their oracle jdk 11. For openjdk you at least have adoptopenjdk offering 4 year support for java 11 lts, but you might as well stay on java 8 then because that is also supported by adoptopenjdk until 2022.
Then just .map to String before collecting
From [this talk](https://www.youtube.com/watch?v=-77pMQhgupk) and what I've heard via word of mouth it sounds like they'll be stopping releases of free oracle jdk altogether and they will not be supporting openjdk releases longer than 6 months (even for 11 and other releases that are lts for their commercial support). The alternative is adoptopenjdk which has promised to support lts releases for 4 years. See my chart: https://yawk.at/java-support/
For Linux, It was basically just as simple as following the build guide [here](https://wiki.openjdk.java.net/display/OpenJFX/Building+OpenJFX) except: 1. You don't need the older version of Ant like it says you do, it compiled just fine on 1.9.7 on Arch Linux. 2. You need to use a JavaFX enabled JDK when building. If you don't, you'll get stuck on Observable classes from JavaFX being missing. 3. When building the actual JDK you need the --disable-warnings-as-errors arg along with your JavaFX arg passed to configure, at least on Linux. 4. The actual JDK image that you want is in the "Images" folder in the JDK build directory. 
Valid point. I thought C# had it, but now I'm not seeing it. They do have this though: long.TryParse(stringNumber, out number);
That's pretty complicated, plus you can't do cross-platform builds.. seems that I'll stick to AWT, at least while it's still bundled with the JVM...
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
L&amp;F is a generic term that isn't specific to Swing design. Win32 apps for example have a L&amp;F corresponding to their version of Windows that they run on.
http://www.oracle.com/technetwork/java/eol-135779.html, updated 5th March says TBA. I'll take that over any video that says "Don't trust anything said in it" at the beginning.
Yes, but suddenly my projects now becomes non-platform independent, which is pretty much the whole point of using Java for me. If they could package JavaFX as a library or even something you could download on-the-fly through an installer or similar, I'd feel a lot better about making the jump to JavaFX.
I suggest looking into Vuejs. Was built by Evan Yu, a google engineer at the time who needed a frontend framework for pretty much the same reason as you. Check it out!
&gt; Do you mind if I copy your response to our GitHub issue? Feel free to do so :) &gt; but most users who requested async talked about long-running tasks (not the actual writing of the response), so this is what I focused on. Long running tasks that then send a short response is a valid and common use case. For this, your CompleteableFuture API looks nice and good. Having a simple API for the simple use-case is always a good idea, even if there are problems you cannot solve with that. &gt; Is it available anywhere online? No, currently not. It is heavily tied to the in-house REST framework I had to write because of the JAX-RS limitations mentioned above. I could try to isolate the interesting parts if you are interested and I find the time, though. 
I‚Äôm using VueJs in combination with bunch Java microservices and everything works flawlessly.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You could always use [IBM Java](https://developer.ibm.com/javasdk/support/lifecycle/) and have until 2022 to switch from Java 8.
SAAS is an obvious method to enforce license compliance. But, if SAAS does not fit your solution, or your customer's requirements, here's an alternative: Get to know and build trust with your customers before giving them your software. That way you do not have to attempt to enforce your license by futile software solutions. As others have mentioned, what's the point, when the software can be reverse engineered anyway. Instead you simply give your trusted customer the software, your war file, and in a license agreement describe what terms and conditions you permit the customer to use the software. Be reasonable with your customers, and most customers will be respectful and reasonable with you. Obviously a malicious customer can disregard your license terms and do whatever they want. But surprisingly many won't, at least that's my experience. The company where I currently work have had the unpleasant experience to encounter untrustworthy customers - the initial allure of the money appeared to be just to great to walk away from. We attempted to enforce the license with a secret key and online validation, but it wasn't sufficient. Granted, we do include some level of support in most our contracts. So even if the software is deployed on-prem, the customer also pays for upgrades and support. I suppose that is an additional motivation for the customer to stay within the bounds of the license agreement.
How many tables do you need to operate over? 5? 50? 500? Do you need to broadly do exactly the same type of thing for each table or do you have lots of bespoke queries? Is this application going to be public or is it for internal consumption only? You mention you need to deliver this application "easily". Would you favour getting something basic but functional out over taking longer with something that was more flashy and slick?
Seconding vue.js for frontend, it's very easy to use. For backend personally I'd use vert.x 
...or you can use Consul or Zookeeper which are designed specifically for this purpose.
&gt; How many tables do you need to operate over? 5? 50? 500? About 20 tables. About 6 unique data types with 2 or 3 related tables per datatable. And about 5 join tables. &gt; Do you need to do the same type of thing for each table or do you have lots of bespoke queries? Basically need view, create, edit, delete, search per data type. With minor business rules. &gt; Is this application going to be public or is it for internal consumption only? Internal. &gt; You mention you need to deliver this application "easily". Would you favour getting something basic but functional out over taking longer with something that was more flashy and slick? Ideally something pretty and professional looking that can be delivered in a very short period of time, like days. &gt; What tools and technologies are you familiar with? I'm a back end Java guy ... Java/Spring/Tomcat/MySQL/Oracle ... front end I'm familiar with HTML/JSP/Bootstrap/jQuery. Although I'd prefer to do as little custom programming as possible. Any ideas?
Thanks, added. &gt; No, currently not. It is heavily tied to the in-house REST framework I had to write because of the JAX-RS limitations mentioned above. I could try to isolate the interesting parts if you are interested and I find the time, though. I doubt I will implement it in Javalin anytime soon, but it would be very interesting to see. There isn't a lot of good information about async servlets available (or at least I struggled to find it), so I'm sure I'm not the only one who would appreciate it.
Two more options: * [LightAdmin](http://lightadmin.org/) + Spring boot * [OpenXava](http://www.openxava.org/) Both are strongly opinionated, both work, both will hopefully work with zero frontend code and minimal java code. But my experience tells me: Your boss is going to ask you something, sooner or later, that will not be feasible using any of them. 
So... how does it look now on your computer?
Yes, I was teasing the author about thinking in octal. I pretty sure that was the real root cause, not EBCDIC.
Lambda expressions are a new feature from Java 8. At high level, you can consider them as "shortcuts" to anonymous classes with only one method. Internally there is a lot of changes as the lambda compiled representation is a call site recipe interpreted (and jitted) at runtime by the JRE. This allow drastic optimisation and evolution in time of the runtime interpretation. Here is the Oracle documentation for more details : https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html
I would strongly recommend you checkout [LightAdmin](http://lightadmin.org/). If that doesn't look right for you, let me know why/how and I might have other ideas.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8h2m5q/a_design_pattern_that_brings_class_extensions_to/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
What's the @Embed annotation?
One interesting feature is parallelStream() - iterate over a list/set with multi thread
Then negotiate. Don't tell your boss no, tell them you'd very much like to do it, but you don't have any time to get this done. Ask them if they could deprioritise something else. Bonus points if you tell them "you're just a programmer" and "need their experise" in organising work.
If I do "from scratch", it'll take me away from other work for at least a couple weeks. They know that. The thing is, I don't *want* to build a crud app, I want to work on other cool/fun stuff.
Convince your boss the other stuff is more valuable, then.
&gt; Properties is thread safe because it is a Hashtable It extends Hashtable, but in newer Java versions it's backed by ConcurrentHashMap...
It lets you scope a set of columns as a child object. Especially useful for repeated mappings like postal addresses, and for making legacy database tables with hundreds of columns saner to work with.
The editor is Dracula(Still, I think) which is what I used before but no, if you do a side by side comparison they aren't the same. Plus, GTK is set to the IDE theme.
The image linked in the thread title shows it.
It sounds better on paper than it really is. ParallelStream is very limited because you have absolutely no control on the threads or the thread pool. It uses some global thread pool and might still do all the work sequentially, no way to force it or anything. In a real application you'd want control over these things: especially being able to control where your application blocks.
There are plenty of books to learn Java (Head First, Murach's etc). There is also an official oracle tutorial as well, which is fairly straightforward. But my recommendation is to read OCA &amp; OCP books for Java 8 by Jeanne Boyarsky and Scott Selikoff. These books, at least for me, laid a good base ground. They start from simple stuff and build upon it. And I don't see any good reason to start using any of enterprise stacks (Spring, JEE), before understand language well as it will confuse you even more. 
AdoptOpenJDK is a volunteer effort run by the London Java Community. The question still remains, *who* will do the backporting and do you trust them to do it correctly?
**Sidebars** in /r/javahelp and in /r/learnjava - plenty tutorials. Also, the sidebar here clearly states: + NO programming help, NO learning Java related questions!
so with parallelStream you should never block, it's not a replacement for concurrent programing. secondly, of course you can change the threadpool it uses! by default you get the global fork join pool, but it's totally up to you. I don't fully understand your rant here, it has it's usages manily in functional land.
The people behind AdoptOpenJDK aren't exactly new to open-source work and they certainly have the capability, I trust them to follow through on their promises :)
Ok... sorry for inconvenience üòÖ
Does anybody know why colours are not used to denote methods that have long "self time". If more "self time" led to redder colors it would be very easy to spot hotspots at a glance. It just seems like such a simple yet effective improvement. 
of course you can.. I've done so multiple times. no conflicting info there. I'm.on my mobile but a quick Google search will show you examples of how to do that.
There is a bug (mentioned in the second link) that causes the parallel stream to use the parallelism settings of the common pool even if the tasks are run in a custom pool. So, it works somehow, but not really, and it is not guaranteed to work because according to the stream API this is all in undefined behavior and implementation details land. 
I've also used it and it appeared to work properly. But after reading the above links, I wonder if it is actually behaviour that you can expect or if it may break when running different JVM implementations or even in different JVM patches. 
This doesn't seem like something you need to solve yourself. Something like this might do it for you https://www.license4j.com
The issue is that this just "happens to work". There's no guarantee that it does so, it's not specified. It doesn't need to use the custom pool if you do it in that. It's dangerous to rely on implementation specific behavior because if something internal is changed, all of your stuff may break because you assumed something that's not guaranteed to be true.
definitely, it's a "trick". but for a specific implementition that's all we've got at the moment. I definitely agree with comments below that argued the same argument. I think I should've been more clear with that in my earlier comment. thanks for your inputs
[See my SO answer](https://stackoverflow.com/questions/48471554/java-parallel-stream-use-or-not-to-use/48472609#48472609) which has some quotes from Effective Java 3rd Edition, where Joschua Bloch talks about uses and limitations of parallel streams. I found that section of the book to be quite helpful, the whole book is worth a read IMO. TL;DR is that you should test extensively if parallel streams improve your performance or even worsen it and if the code still works correctly.
You could also use CRUD generators like the one packaged with Ruby on Rails, or automatic admin interfaces, like Django Admin but these are all going to require you to do a bit of coding to configure them to the database. It looks like jHipster has got generators as well but I haven't tried it personally. Unless you know the language/framework, I would have thought that you would find LightAdmin easier. If you have "minor business rules" then you are going to have to write some code to implement them. There is nothing off the shelf that can do that for you. If you want to write literally no code, then you are looking for a tool like phpMyAdmin but this is going to: * expose WAY more than you likely want it to. * prevent you from customising it (or at least you would have found LightAdmin easier I think) 
I second this book. it's a very good read. dont have much to say, I totally agree. sometimes developers like to throw cache and parallelism (..and observables) into their code without giving it a proper thinking, or just doing it blindly. sometimes it works, most of the time it's not the optimal solution. 
Work isn't really meant to be cool / fun. You are there to solve business problems. Unfortunately a whole lot of business problems are simple crud apps.
It‚Äôs about reducing boilerplate, ceremony, and you get access to some simple methods that can greatly reduce the amount of code you would normally write while iterating through and modifying objects in collections. That and you can use method references as arguments providing something akin to passing function pointer in C/C++. 
reddit never disappoints. Ask a simple question while hunting for tips and new tools, and enjoy people replying with unrelated topic\-changing non\-answers and lectures and criticisms. It's head\-shakingly comical.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8h7l1n/help_me_on_mooc_26/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That's why I prefer RxJava.
Non-LTS releases, i.e. Feature releases will not have commercial support available from Oracle. See this page: http://www.oracle.com/technetwork/java/eol-135779.html
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
As it is part of the paying options of the JDK, will it become free to use or will we still have to pay for the **Java Standard Edition Advanced** features ?
Did you expect a fancy webpage and a working test/build/release system just two days after the initial commit?
A very fancy VisualVM?
Like anything Oracle open sources.
Oracle, unsurprisingly enough, has it's own in-house build tooling, infrastructure etc, which would have been used for JMC. (Amazon, Google, Facebook et. al. also have their own internal build tooling, it's a common practice among tech companies, as they attempt to build something more suited to their environment and needs). It was bound to take at least a few days to figure out how to build it independent of the tooling and infrastructure used to build it inside Oracle. A build chain is not a simple thing to disentangle.
Hey, I think this is good news and quite a big deal. JMC and Flight Recorder are a big piece of what I saw as the gaps between OpenJDK and Oracle.
It's solvable with a license server.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That depends. Some will expect you to know or learn. Some will train you. Good questions to ask in an interview ;) if you have a good contact with the company you could craft an email asking what what you may be working with when you get there and start reading up on the technologies. 
&gt; Okay :) I've no idea what I'll be doing there and it's going to be my first working experience. Good idea. I'll drop them an email on Monday asking my queries.
A startup using struts? When did they get started?
Not exactly a startup since it's been business for a few years. But it's a small scale company with around 100 employees.
You'll do just fine then. I suspect you'll mostly be working on functional stuff. This means you'll have to implement or change existing features. This generally requires more knowledge about the business processes then the technology. Brushing up on reengineering and testing might be useful. (Write tests to validate existing behavior, write tests for new behavior, rewrite implementation). The frameworks generally require only working knowledge. Nobody has complete knowledge because they are huge. Given it is an existing code base there will be plenty of examples to copy from. Do read the docs so you understand what you're doing when you're doing it though. And to get started, doing tutorials for each framework will help. 
&gt; useful Okay. But will this experience of working on the 'business processes' rather than the technology be valuable for me in the long run?
Depends: what kind of shit do you want to make? A lot of us can point you in the proper direction. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/8hczwe/faster_syncing_of_views_with_vaadin/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes. Technology comes and goes, being able to understand, question and translate businesses process into software is eternal. There is a joke about the JavaScript ecosystem, "....it deprecates faster then the milk in my fridge'. Java isn't quite as volatile but the tech stack always changes (I was able to date your company based on the tech stack). Learning how to choose a tech is a good engineering skill though. Don't chose one because it's popular, chose it because it allows you to make favourable set of trade offs. Unfortunately your growth options are limited. You can become an expert in a specific product or framework (database, cms, crm, ect) You can become a lead developer. For a team, department or org. But after that it's management. Most companies won't have other career trajectories (good interview question though). Mostly tech won't be the problem. It will be people. Hence all paths leading to management. If you are in love with the hard computer science parts you'll have to find a company that is into that. As I am getting older I do find the people part becoming more and more interesting though. YMMV.
For Hibernate: High Performance Java Persistence + JPA 2 Pro + Hibernate 5/6 user guide (very well written); For Spring: Spring in Action 4th edition. For J2EE: It depends on that version they using. The name itself points to version 4, which was released on 2003. Because J2EE does not exist anymore, it was changed to Jave EE since version 5. Which indicates that guys who wrote job profile do not really know what they are looking for, thus you won't be using Struts also. Or they just wanted to get anybody who has worked with enterprise stack or at least heard about it.
Cool. Thank you. Just that i won't have enough time to finish these all. I have only 40 days left before I join and I'll also need to deal with final semester exams :|
What I meant was, the software can always be cracked (and probably will be if it‚Äôs any good). A license server would be one way to go about it, but if the database reporting software requires access to an external server, it could be a dealbreaker for some customers. Just saying, maybe OP should get some feedback from real customers before spending a lot of time on DRM. 
Jrockit version too?
it pisses me off so much how job adds still say J2EE. I am not sure if I should care so much as to not apply as its a hint at them being clueless about tech or just trust they aren't ain't actually using J2EE and instead really mean spring boot... 
Someone put that stuff on github. 
A lot of AI stuff has libraries in python. If you want to learn more about that check out tensorflow, which is a neural network library from google. 
If you want to get into AI Java is not the language you're looking for. TensorFlow does have a Java SDK but it's not as well developed as the python one. IMHO, if you want to start learning AI, learn python and take a look at the TensorFlow SDK. 
Got it. That does seem to make sense, and learning Python was on my bucket list anyway, so I guess it's about time
I feel like a more basic intro to machine learning is more appropriate than just diving into a framework like Tensor Flow. Get the math foundation and theory down so you know somewhat the magic behind it first. Andrew Ng's course on Coursera is a good place to start
I really loved Keras. It is higher level than Tensorflow so it allows you to do a lot without getting to into the weeds. Obviously Tensorflow can do more on its own, but Keras is a good place to start for sure
If you'd like to stick to Java, I recommend checking out [DeepLearning4J](https://deeplearning4j.org)
Didn't it come with Maven scripts already? Plugging that into a build pipeline on some open tooling like TravisCI would have been something that I would have done to show everyone I was serious about this being something going forward.... Otherwise it looks like my Github account with a bunch of abandoned weekend projects with a barely functioning Gradle script 
Yeah, basically string manipulation, which ends up being really straight forward. I have done so with search/filter/paginate etc. Check out what they call the "fluid syntax". 1. Define your query without filters. 2. If statements to add filter SQL. 3. Pass the completed query into JDBI using the appropriate method ```.createQuery(``` etc 4. If statements to bind parameters ```query.bind("name", value)``` 5. Perform query ```query.map(new MyMapper()).list()``` 
I'm not a huge fan of writing SQL by String concatenation. I prefer template engines. Did you take a look at http://jdbi.org/#_stringtemplate_4 ?
What you want to learn is something that (statistically) almost no programmer knows how to do (some do know how to do it 'in theory'..). For simulations (also AI) you should learn about numerical mathematics. Unless you do pendulum, it's not that easy to code. You should explore first free ready to use software (openfoam, freecad with its FEM module). For AI, there's deeplearning4j, for physics there's for example jbox2d, but for other simulations, I don't know about any such complete package.
Python is great for prototyping but is not great for putting models into production, especially real time models. Java is very good for this. There‚Äôs a book called [Data Science with Java](http://shop.oreilly.com/product/0636920043171.do) that is a great transitional book. My suggestion is not to learn one or the other, but to learn both. Use Python to prototype the optimal model, and then use Java to build the model in an application that can spit out results in a fraction of the time it takes to run in Python
AI and data science in general are completely different from programming. They have nothing in common except that AI people also have to code. You would need to learn a lot of things starting with statistics, then more general data science and finally machine learning / AI. A B.Sc. does not even cover all of this. Also, for some very odd reason, they use python in AI. It's not a real programming language, but a scripting language. 
Didn't keras and tensorflow merge recently?
Node.js Driver for Oracle DB. GraalVM. Oracle JET. These three were not acquisitions. They were implemented by Oracle and open sourced. And are alive and well.
Just do your best. I've also started with almost zero knowledge and experience in enterprise frameworks and catched it up in a few months during initial business trip. Try to find a good and patient tutor there, though, for all stupid questions :) Good luck!
GraalVM is new and first needs to prove itself. Oracle has a fundamental interest in a Node.js to OracleDB driver. The database is the main income. I wouldn't call Oracle JET really alive. Is anyone one really using that extensively.
And Oracle donating commercial products as open source is a bad thing why exactly? If there is still commercial interest, then some of the big players (RedHat, IBM, even Microsoft) will contribute developer time to keep it alive and usable for everyone (as they do with OpenJDK and a ton of other projects), or some smaller companies may pick up where Oracle left and offer commercial support (as with Glassfish after Oracle dropped it). Both would be a win for everyone. If there is no commercial value anymore, then OpenSource is still better than Oracle just abandoning it and not updating anymore, because the community now has at least a chance to fix bugs and keep it running. Even if the project dies because no one really cares, the source remains available and you can use it if you need to, even years after Oracle lost interest. Not bad at all. So, where is the downside? Why are people complaining? I don't get this "Free is not good enough, I wand cherries on top!" attitude. 
Oracle JET 5.0 was released 23 days ago. Doesn't look dead to me.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8hhxfu/extracting_data_from_a_website_that_requires_login/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Line 13 in the first listing should be `PrinterExtension`
I don't really understand why I would use this over a static method in Java. In Kotlin, extension methods are built in and natural to use \(they also effectively compile down to a Java static method\). This feels forced and is difficult to follow. The fact that I need to have my classpath in a specific order, and can only define them in specific packages reduces its utility. As a thought experiment, it's interesting, but I'd probably reject a PR that used this pattern.
By what metric is Python not a real programming language?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
As cpdean said, almost everyone is considering that AI equals to machine learning or deep learning. Although the field is indeed going to to that direction, creating simulation models and programming is closer to classical AI, which is more algorithmic. There are also some cool things from deep learning that you need to understand classical AI to do. For classical AI, I would recommend this amazing course https://courses.edx.org/courses/BerkeleyX/CS188.1x-4/1T2015/course/ (it's over, but I think you can see all contents and do the homeworks hopefully) and also this one https://udacity.com/course/intro-to-artificial-intelligence--cs271. I like the first one better, the second one is from 2011 and it's rough around the edges, but it's from Peter Norvig which is really important in the field. If you want, you can also go to the deep learning approach. But it's one that doesn't involve as much programming. If you want that, it's better to use tensorflow, pytorch or something like that. Andrew's course is a good start in the classical ML. Don't know about his new deep learning course. I did Geoffrey's one on Coursera and it's good, but it's a really difficult course which doesn't have much programming. You don't need to program as much with DL, just describe the graph, data, loss function, etc. It's not easy, but it's a somewhat different set of skills than programming I would say. Your error will hardly be some wrong piece of algorithm, but more probably some wrong assumption about calculus or statistics. I love deep learning, I'm not saying it's bad to learn it, but at least for me (I mostly study deep reinforcement learning), classical AI is a good start.
Yes. With Tensorflow 1.4 in November 17. 
Thank you. My college ends on May 26th and things will be so fast. I have to go home to pick up my certificates and stuffs and then immediately move to a completely strange city. And I don't know anything about what I'll be doing at work. I feel so nervous these days :/
You need the classpath to be in ‚Äûnatural‚Äú order (as it is automatically arranged that way by maven/eclipse/etc.). And it is safe, as the method addition is limited down to the extension interfaces and only allows the interface methods to be used. Not much thinking needed. The main use case is convenience or the benefit of streamlining a library‚Äôs API afterwards. Adding methods to classes also allows the IDE to suggest them when using the class instead of requiring knowledge about a set of static methods.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
why not just use akka for this?
Strange question. Why would you? Why do you think akka or spark are better suited for this job?
You probably meant ***DEFINITELY*** -not *'definitelly'* --------------------------------------- ^^^Beep *^^boop. ^^^I ^^^am ^^a* ^^bot ^^whose ^^^mission ^^is ^^to ^^^correct ^^your ^^^spelling. ^^This ^^^action ^^was ^^^performed ^^automatically. ^^Contact ^^^me ^^^if ^^I ^^^made ^^^A ^^mistake ^^or ^^^just ^^downvote ^^^^^^please ^^^^^don't
From what I can see (and I never worked with piper) piper does not provide anything on top of akka or spark. Is the same thing, just done differently. So, why use akka over this? Because it is probably more mature and probably performs better and probably you can find more articles on the net about it. This is a good enough reason for me.
Thanks for sharing, i seem to find bytebuddy documentation more accessible, but that could be a personal preference.
System.err.println? System.exit? Really?
Yup welcome to the serverless world. Under function initialization there isn't a context you can rely on for passing info back to callee so you are left with basic process capabilities like stderror and exit codes.
Your question made me think of an ancient web cartoon from the pre-youtube days called, [Totally Gridbag](https://www.youtube.com/watch?v=UuLaxbFKAcc)
Swing became old (not so old though) and Java FX is new. Now Java FX has been detached from main Jdk package so it became like additional library.
S3BucketPublisher the first proves you kill process on exception.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Swing is the old, phased out technology. JavaFX is the new hot thing. From a support perspective, odds are that JavaFX is the library that will see some love in the future. Swing ... unlikely anyone is/will be working on it. On the other hand, Swing is stable, solid, has a ton of libraries/components out there. At the end of the day, desktop applications do seem to be on their way out as web based ones take over. Even for desktop (electron crap). There is still definitely a market for desktop, but it is kinda fading out.
If your UI is separate from your service layer, I wouldn't use Java. If it needs to be cross platform native desktop, I would use QT and just call my service/api layer from that. Or just bite the JS bullet and use whatever stackoverflow says is the new thing. If you're lucky it will be around for six more weeks.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I agree with the "use QT" statement. And the JS statement. pretty much all of it really. 
Coming from Python, I love QML syntax. However, I prefer to develop in jQuery / bootstrap more. 
SWT and Eclipse RCP
Or just SWT. No need for the monstrosity that is Eclipse if all you need is a decent performing widget toolkit. I've used SWT standalone and it works great
For a desktop app, I'd recommend JavaFX as it's a more modern framework
Most "desktop" apps I see today are Javascript apps wrapped in Electron. It's good enough for WhatsApp and Slack.
While I agree that Java is probably not the best language (seems like Python has the most APIs, books, resources, etc), the first worry is not any language or framework. It is reviewing the necessary math that you either long ago forgot or never even took. Sure you can follow some canned data sets and a YouTube tutorial using one of the big frameworks like Tensor flow, but the goal of learning AI is to understand when and where it can help in your individual industry / project. I same this as someone who is beginning the AI journey myself. More than a f decade after I took the probability and liberal algebra that's required to understand the basics. Frankly. I have a feeling that this AI hype going through our industry is going to end up as disastrous as the *Big Data Hype* from 5 years ago where everyone decided to move their 1GB relational dbs that worked just fine over to Hadoop and Mongo so they could *scale* out for the a future sand that never arrived. Or similarly, the rush to move tried and true server side templates all to one huge, confusing Single Page App a la Angular or ExtJs or worse. And now the app is so slow and confusing, time to double down with React - that will surely save the day, lol. 
Learn the math first. While I agree that Java is probably not the best language (seems like Python is), the first worry is not any language or framework. It is reviewing the necessary math that you either long ago forgot or never even took. Sure you can follow some canned data sets and a YouTube tutorial using one of the big frameworks like Tensorflow, but the goal of learning AI is to understand when and where it can help in your individual industry / project. I say this as someone who is beginning the AI journey myself... more than a decade after I took the probability and linear algebra that's required to understand the basics. Frankly. I have a feeling that this AI hype going through our industry is going to end up as disastrous as the *Big Data Hype* from 5 years ago where everyone decided to move their 1GB relational DBs and SQL that worked just fine over to Hadoop, map reduce and Mongo so they could *scale* out for the a future demand that never arrived. Or similarly, the rush to move tried and true server side templates all to one huge, confusing Single Page App a la Angular or ExtJs or worse. And now the app is so slow and confusing, time to double down with React - that will surely save the day, lol. We're going to see lots of people who have no idea of the mathematics behind AI spend huge amounts of time putting it info Tensorflow and AWS, and no business advantages will be gained because the devs have no clue what the problem or solution actually is. 
Not really, you can use log4j2: https://github.com/aws/aws-lambda-java-libs/tree/master/aws-lambda-java-log4j2
this is r/java so stop recommending an ugly C++ library.
There are java bindings for QT. Also, calling QT ugly compared to anything in the java world is laughable.
Check out these sites for finding projects: https://www.codetriage.com/ https://up-for-grabs.net/ There are more listed here: https://opensource.guide/how-to-contribute/#finding-a-project-to-contribute-to
I almost always use LibGDX over swing or javaFX for GUI desktop applications. I've used both swing and javaFX professionally and they can certainly get the job done, but LibGDX has a good bit more features(although they may be more game development focused) that I think sets it aside from java built in GUI features. It also supports several different platforms off one base project
Of you read between the lines you will see that neither awt nor swing will probably be continued after Java 11 outside the LTS treatment. Oracle seems to be leaving the Desktop behind... For what it's worth I am quite happy with javaFX, but the future is uncertain. As for js (even js in a webview) it is a pain and your Desktop integration will suffer. It will look great though..
It is a shame that one thing Java got completely wrong and then made a mess on top of a mess is Gui's. I don't recommend it but I wrote my own in 2001 and been using it ever since (for games and real time apps). 
Well, for workflow management rather than this specific task. He has built a pipeline where you post a job and a bunch of workers carry it out. Don't Akka and Spark already do exactly that?
Ugh, ran into the same thing with remote debugging. The fact that management hired some Webdesigner to do "the grunt work" of the UI did not help. 
Just to be clear, trying to find the right solution to this.. or the preferred solution. Thanks
&gt; desktop applications do seem to be on their way out Of course not. https://www.statista.com/statistics/272595/global-shipments-forecast-for-tablets-laptops-and-desktop-pcs/
I believe that javafx is becoming more "separate" from the jdk in future versions though. But that might not matter because the intended distribution method is jlink anyway.
Javafx feels like too little too late. Fairly weak adoption since many people have moved on from java on desktop and oracle doesn't really seem sold on it either. And on top of that it feels half-baked still, and buggy.
Just because it's /r/java doesn't mean you have to believe java is the best tool for everything. I wouldn't recommend using java to program real-time systems either just because it's possible and this subreddit is about java
I don't think removing javafx from the jdk matters much. The intended distribution model for new jdks is jlink anyway. But it *does* mean that being part of the jdk would not be a big advantage anymore and third-party libraries (say, java qt bindings) might become more competitive.
&gt; but annoyingly I can't find this paper online anywhere anymore. Is this it? http://stefan-marr.de/downloads/manlang17-grimmer-et-al-applying-optimizations-for-dynamically-typed-languages-to-java.pdf
New versions are older FX is still part of JVM for compatibility.
JavaFx is sane and quite easy to use. Swing - uhhmmmm NOPE ! Spent several years writing desktop apps solo on java.
Which is sad. You can only run this many Electron apps (0.5-1G each) simultaneously on an average laptop. After that the system performance starts sagging down. Not only that, but the overall experience is typically worse with Electron than with JavaFX or even with Swing apps.
I too don't like to use html, css and js for UI part. I like the traditional way at it is more streamlined. 
Could you explain why you wouldn't use Java if the UI was separate from the service layer? 
Maybe because it's fairly simple and works on multiple platforms?
I get that, but wouldn't teaching students how to build a web application using Spring be more beneficial for their future jobs? Or are there still a lot of companies using desktop apps? 
Because it is a low barrier entry for creating tangible tools with pure java. You can write programs and have some visual feedback without the need to learn anything else. I have plenty of useful tools from when I were learning java and I still make some for myself. I can agree that you don't gain much "market value" out of it, but is a skill that will give you some notions about GUI.
I do mostly embedded and mobile development. JavaFX is dog slow. QT is super fast, even on limited hardware. I prefer programming with QT to JavaFX and in general the API tends to be more stable, easier to understand and it's what our shop has the fewest problems with (several of our JavaFX apps are being ported because they're eating up maintenance cycles). Here's a [demo](https://www.youtube.com/watch?v=Kh6K-yEp_JY) showing the difference in performance on a pi3 with a touchscreen app. This has been our experience also.
If these are CS students then they‚Äôre just using a GUI as a tool to explore the CS concepts and it doesn‚Äôt matter which particular tool they use.
I don't think that the job of the school should be to teach immediately-useful skills for work, but rather lay the foundation -- so that you can easily learn the details of whatever is used at your job yourself. Networks and web frameworks are usually thought, I would think, although a full stack web application development already requires quite a lot of knowledge to get all the parts moving (without having too many magical black boxes in the middle).
It looks like in your [submission](https://www.reddit.com/r/java/comments/8hsnwz/are_you_using_a_static_analysis_tool_if_so_which/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That was a night and day difference in the video you linked. Had no idea JavaFX was that damn laggy. But thanks for the explanation! 
Honestly, while Java GUIs are ugly, the API is actually pretty well designed, easy to learn, and can demonstrate the core design patterns in use on the web without the learning curve of something like React or Angular. 
"While there are occasional uses for interruption, it should be avoided. The fundamental problem with interrupts is that they are effectively globals. They are scoped to the thread, rather than to the task." That's not a problem, that's the point of it. It signals to the thread, that it should exit. While task is something abstract, thread represents something more physical (cpu+registers..). Note that you can't stop a thread. Thread ends either because its run() method exited, or the program ended. So this interrupted() call is handy when you want to set a sign, that run() should exit its loop. Also you don't care about what the thread is doing while signalling interrupt. This is useful not only while interrupting computation, but also while shuting down/reconfiguring thread pool (or ExecutorService), but the program can continue.
These have been all great responses. Thank you. 
If you use JavaFX for your GUI then you can make it look quite attractive. Swing is not so bad either as IntelliJ illustrates. 
The places I see a lot of desktop Java using Swing is for internal one-off applications which the company doesn't have the neither the funds or the resources to support a web app. Software that fits the bill that I have seen in the past is CRM style software catering to Automobile Repossession, Country Clubs, internal local/state government applications. So while it isn't Spring the barrier of entry is lower due to the how quickly you can build applications and get simple visual feedback at the click of a button without needing much setup or configuration.
its supposed to become more like a maven artifact than an embedded dependency. a bit of a better situation imo.
Consider the case of Fibonacci. You have three ways to skin the cat: 1. (Œ¶^n -œÜ^n)/5^(1/2) has one key problem: IEEE 754 kills its accuracy. If you can expand it algebraically and cancel out all the square root of five terms, it would work. 2. Do it iteratively, which takes linear time. 3. Do it recursively, which takes exponential time unless you use a lookup table (which is fugly but very doable). You want the right answer, and you‚Äôre not crazy. Don‚Äôt recurse here. 
You can make some nice shit in javafx. Spring is lots of training
When I did my internship 8 years ago, crap that was a long time ago now that I think about it, I had several Swing apps that we ended up developing. I had 0 experience with GUI at that point. My first real development job used jsp with html/css/js. Now everything I write has a htm/css/js fronend using angular.
I've been wondering why each Electron app has to run it's own unique instance of Chromium. Why can't they all share the same instance?
Wondering about the same - and what is necessary to make it possible.
I've used it on some production stuff. It's nowhere near as popular as SparkJava but it does what it advertises and the developer is active and a former core SparkJava contributor. If you're building lightweight HTTP microservices the web framework really should be the least of your worries IMO. I basically use it as a route dispatcher to my controller classes. I If in two years Javalin is dead then it won't be a lot of work to rip it out for someone with whatever flavor of the month HTTP framework is out there. 
What does it mean html5+js for UI? Do you run local apps in the browser, like a web app, or is it just a framework that uses that syntax?
Java's interrupts were poorly thought out IMO... It's way too common that you need to use something like Object.wait(), Thread.join(), Future.get(), etc in a method that needs to be uninterruptable (or just can't have "throws InterruptedException" because it's implementing an interface without it) And it's possible to do that correctly, but the correct code looks like this: try { waitForSomething(); } catch (InterruptedException e) { try { while (true) { try { waitForSomething(); break; } catch (InterruptedException e) {} } } finally { Thread.currentThread.interrupt(); } } So instead people almost always just write try { waitForSomething(); } catch (InterruptedException e) { /*FIXME*/ } ...which makes interrupts nearly useless because there's a good chance the interrupt will just get swallowed somewhere.
Because it's basic knowledge, you need to know that. I agree, that Spring webapps are also useful, but it's far from basic, and you can't program a simulation in pure java running Spring, you would need html5 and javascript, etc, which far exceeds the scope of Java lessons.
I have never looked into making a Java program with a QT UI. Is there a short description of how you make calls from a non Java Framework to a Java service layer? The only thing my mind can come up with right now would be Sockets... But I kind of doubt that this is how it works.
 &gt; Swing is the old, phased out technology. Swing is **not** phased out. The only possibility that Swing leaves the JRE is if Oracle takes a dump on Java, effectively killing the platform on the desktop. &gt; JavaFX is the new hot thing. JavaFX is new, but development doesn't seem to pick up speed, quite the opposite. It is also not there to a good degree, depending on what GUI you want to create.
&gt; Sought out some docs and other google searches only to realize.. Javalin isn‚Äôt as everywhere as I originally thought it was. Some part of me thought this thing was well established. There‚Äôs more on JavaSpark than there is Javalin. We just released v1 six months ago. Since then we've had ~100k sessions on the website, with ~70k "users" (so about 30% are returning users). It's been a successful launch, but it's definitely not established. &gt; So, is this thing used in production by anybody here? About 75% of our survey respondents are either running in prod or launching soon. Out of the people running in prod, *60% have less than 1k users per day*, while *40% have 100k to 1m users per day*. The number of respondents is very low (only 10 people have answered the question about users in prod), so this ratio will probably change. &gt; I‚Äôve just been having a heck of a time with a couple nagging things. If they are things that can be improved, please create an issue. We're working very actively on Javalin at the moment, so if you want to help shape its future this is the time to get involved.
I am currently doing a university project in java, from my personal experience I prefer using JavaFX with Gluon SceneBuilder. I had a previous assignment introducing us to swing, it was terrible and a lot trickier to use (personal opinion). Javafx has a lot of nice built in elements and in my opinion is designed better for using an MVC model where you seperate the controllers from the GUI elements. 
Hey, 4\_Random\_Guy, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey, u/CommonMisspellingBot , just a quick heads-up: You‚Äôre a douchebag and a buzzkill to all. The human mind is not a computer. It ¬¢an R3AD thangs dat r M!SPELLED. Furthermore, predictive text and spell-check are sometimes the cause of these typos. You‚Äôre not providing a useful service. Have a nice day! The parent commenter can delete this post by leaving Reddit.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8hvej8/need_help_to_glue_together_java_testng_and_rest/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The fact that both Oracle database and MySQL incorporated the GraalVM is a very strong sign for its strategic importance to Oracle.
How do you think Javalin compares to JavaSpark? I have 0 experience in either of them, but have checked both from time to time when thinking about creating very simple "nanoservices" (simple from the JavaEE perspective, otherwise I always go back to Swarm, though I've often wondered whether it's not just my laziness).. 
Not sure what you mean, but if you write a desktop app in Java, how else do you want to write a GUI for it? I mean, you could of course create a microservice, expose it over REST, and create a regular html frontend... In any case, I feel like you might have been asking about web development. For web dev., I am still using JSPs and even Faces ;) I quite like JSPs to be honest. Check out Liferay, which is practically built on top of JSPs. Definitely employable still (on the contrary, it's becoming a rare skill these days - Java devs do not wanna learn a lot of frontend, typically, and frontend devs do not wanna learn Java, typically :) )
They're pretty similar, as they They both run on top of jetty/servlets, but the abstraction model is a bit different. In Spark you have: * `Routes` which take `Request` and `Response` and return an `Object` * `Filters` which also take `Request` and `Response`, but are void In Javalin everything is a void `Handler`, which takes a `Context` (which wraps `HttpServletRequest` and `HttpServletResponse`). You operate on both the request and response through this `Context`. * Spark can be run on an application server, which Javalin can't. * Javalin is completely instance based and supports a lot more configuration options (and http2), whereas Spark has both an instance API and a static API (and they're not 100% identical).
Cheers, thanks for your detailed response! 
I'm new to AI/ML/DL as well and like DeepLeaning4J's documentation because it covers many of the basic concepts and refers to a whole bunch of other interesting resources. Imho a good starting point.
Hey, thank you creator for the insight :) I‚Äôve released a JavaSpark microservice app in prod last year, getting into Javalin felt fairly natural in doing so The ‚Äúnagging issues‚Äù aren‚Äôt even things super Javalin related, so far they‚Äôve all been template engine based. The documentation shows me the line to feed the template engine configuration, but that‚Äôs about it. I‚Äôm over here trying to set up Thymeleaf and I‚Äôm falling down a rabbit hole of documentation and example code tracing what that configuration needs to be just for a basic implementation use case in the realm of Javalin, and then I hit a moment where only stackoverflow Spark questions are popping up.. I just needed one simple example of a basic configuration of one of the supported template engines. I find this to be a common problem amongst most Java packages. It doesn‚Äôt matter how detailed or mature the project, the docs always assume that one fairly important thing and then moves on while I sit over here scratching my head about what I‚Äôm missing. And either the examples decide to go too basic and provide little help, or too full tilt and implement a custom framework filled with shared mock data and shared helper classes across multiple examples that isn‚Äôt indicative of normal use cases and requires much navigation just to see what‚Äôs even happening... only to realize that it‚Äôs never been updated or maintained and is no longer valid anyways against the version of the thing your using (I got that with Spring and even JavaSpark a lot) 
A sample of 344 respondents...
??? &gt;Despite all those other surveys going on at the same time we still managed to get 1054 respondents. 
Another option is to build your own license system using a library like [Licensius](https://github.com/decebals/licensius).
Maybe you should research what the book contains before getting it. Also, it would be better to buy the book rather than get a free copy (I would actually recommend you support the author). 
I'm asking because amazon does not ship the book to where I live.
lmao what
Ebook?
As a game developer working with an ancient AWT codebase, this makes me hopeful of being able to migrate and either have JavaFX be part of my build process or download itself dynamically through an auto-updater when launching the game - which would allow me to create one truly cross-platform build.
The only layout managers I use are Flow, Border and GridBag. And GridBagLayout could replace the other two if I wanted to go that far.
Very useful summary. I found SparkJava first, in particular the Spark-Kotlin variant, before learning of Javalin. So I've stuck with Spark-Kotlin, all the while wondering if I have backed the wrong horse...
My bad. I only read: &gt; and 344 of them took the survey directly on the omnifaces.org website.
&gt; So I've stuck with Spark-Kotlin, all the while wondering if I have backed the wrong horse... I don't think it makes sense to think like that. If you don't have any problems with spark-kotlin you should stick with it. The only cases where I would really recommend Javalin instead of Spark is if you need advanced configuration options and/or WebSocket capabilities. The rest comes down to personal preference.
Javalin's Thymeleaf integration was written in five minutes (literally). The whole thing can be found here: https://github.com/tipsy/javalin/blob/master/src/main/java/io/javalin/translator/template/Thymeleaf.kt The idea is that Javalin just keeps a reference to a thymeleaf `TemplateEngine`, which you can configure yourself. It should be up to the thymeleaf docs to show how this is done. I actually have no idea how thymeleaf works, so I'm sure the default-implementation I added can be improved. I'd be happy to assist you if you want to improve it.
The problem about this approach is that you can't cross-compile easily, so you need to have a build environment for each target platform (at least Win/Mac/Linux, others are easy to cross-compile to). Suddenly Java is no longer cross-platform. Doing things traditionally lets you compile once and just add the correspondent library to each target system (like Eclipse does with SWT apps). My main goal right now is to offer a single download and have it automatically download the missing JavaFX package based on the runtime system - which to me is the only real cross-platform solution, which is what Java was always supposed to be like. I might still consider not making a move to JavaFX at all and keep using AWT/Swing, just for the fact that it's still included in the JVM.
Yup I get that, and I understand why one would want to keep the ball in the dependencies court for documentation That said I‚Äôve never found it unwelcome to be presented with an example implementation from the thing that uses dependencies For example, Symfony (a php framework) uses a vendor for database abstraction called Doctrine and had set up extensive ‚Äúthis is how you use this thing in our thing‚Äù Docs https://symfony.com/doc/current/doctrine.html and things like Flask with Jinja http://flask.pocoo.org/docs/1.0/templating/ and alt implementations http://flask.pocoo.org/snippets/17/ In the realm of Javalin, I‚Äôm not well versed in any of the supported engines, I‚Äôm more of a jTwig user. I only opted for Thymeleaf because the docs looked inviting compared to the Apache laid out docs of the others, but then it‚Äôs just been a weird and confusing error prone ride ever since then lol 
I am surprised JSF is still relatively popular in Java EE applications, I haven't used JSF in a long time and I wasn't a fan of JSF 1.1.
Nobody was a fan of JSF 1.1. But 2.2/2.3 with PrimeFaces and OmniFaces has its share of fans for sure.
The todo-list for Javalin is very long, so unfortunately I can't sit down and try to understand every template engine. What I can do is add a jTwig though (or maybe you'd like to?).
It can happen to the best of us ;)
That‚Äôs not what anyone‚Äôs arguing.
What? JShell is a REPL. It‚Äôs not meant to replace the language.
I tried to post a reference to the survey here as well, so it could have included r/java‚Äôs opinion too, but a mod here found it necessary to remove it (I think because a Spring fan complained)
You should... wait... wot???
&gt; while Java GUIs are ugly What? This is nothing more than FUD. 
The report mentions the potential bias somewhere. Then again, OmniFaces does more than just JSF. See: * https://github.com/omnifaces/omniutils * https://github.com/omnifaces/omnipersistence * https://github.com/omnifaces/omniservices I also saw the survey being promoted by Java EE Guardians and various others on Twitter who are not specifically about JSF.
Yes please!
No one said anything is easy but at least you can do all you dev and then have the separate step of packaging everything up for each supported platform. Depending on client JRE versions has always been a PITA.
/r/programming
I thought tomcat was a very light weight server indeed... A JVM instance typically uses a lot of memory though.
We use Spring Boot which embeds tomcat, it works on a 1gb VPS with a mysql on the same server. Since [Linode](http://linode.com/) &amp; [digital ocean](https://www.digitalocean.com/) rent such servers for 5USD that works fine for us. 
Would you ever prefer a web-based app (on Desktop) to a native app? Perhaps I'm biased, but I never would. Am I an outlier?
I've been out of the Java game for a while now but back in the day I remember Jetty used to be the lightweight alternative to Tomcat. Btw have you looked into WildFly Swarm? It sounds promising.
Interesting, I always felt the other way. Like, that it's software vendors who strive to fully control the experience (and revenue streams) so they drive the market in the webapp direction -- regardless of what the users actually need. Adobe would be a good example of such behavior. Need to start asking around, though.. this might be a certain type of users who indeed are happier with web apps.
https://www.npr.org/2014/04/01/297690717/why-doesnt-america-read-anymore
Tomcat is already a lightweight servlet container and works well with small heap sizes. Which GC and `-Xm*` are you using? I have tested a small service on tomcat and jetty recently and both were happy with a `-Xmx=100M` heap and dropped way below 20MB when idle.
&gt; the separate step of packaging everything up for each supported platform I'm OK with that as long as I can do it all from only one platform (like packaging the JAR once with each JavaFX system-dependent package). Having to do the compilation process on each separate platform is not OK with me though (which you'd need, to provide stand-alone applications). At that point, why are we even using a language that runs on a virtual machine? Seriously, it just defeated the whole purpose and I'd rather find something else to work with instead of jumping through hoops that barely make any sense to solve problems the stack itself created, on top of that.
IMO this thing is nicer than Spark, which I do not particularly like, though I have not used it extensively. I use Spring on daily basis, but recently, I'm getting frustrated over it's complexity coming from the fact it is so bloated and ready to do all kind of things projects usually do not need. This starts to matter once you work with people that are not that accustomed to little twirks that Spring has. Also, startup times start to matter in XP TDD approach that I usually do and Javalin is nice in that matter. Definitelly going to sneak it into production one day.
Yeah what are your exact requirements...by the way Jersey is a framework not a servlet container like the Tomcat or Jetty. Maybe you meant something else.
True, we just used the default so I skipped that aspect. My main point was that it runs on a $5 server with mysql on the same machine and the spring boot overhead...
There's a lot still out there literally using J2EE . . . definitely avoid!
Whyyyyyyy? Why not just use Express and Node?
Ya man. My team at work is all php and python. It was a hell of a sell to get them to let me try out JavaSpark for a highly trafficked microservice replacement project. No one here is keen on JVM at all, and my intention was to demonstrate that java is not only perfectly capable but makes quite a lot of sense, with patterns and systems that are familiar. I chose spark because it was small, easy to learn, modern, and supported Kotlin, a language I figured my team would appreciate over Java itself. It took some learning but I got it there and it ran beautifully in prod. There was a memory leak issue because I neglected to close off my database connections (bad habit from php) but otherwise was smooth sailing. 
While this is great news, the GPL license gives me pause. Is this the plan going forward?
You don't necessarily have to do that. Eclipse for years has been an unzip into a folder and run type of app. There's no perfect solution - yet but since it is possible now to create android binaries from a windows platform (for example), it seems possible to create mac, linux, ios as well in the future.
Useful tips. I wonder how many can be covered by static analysis and which ones are in the IDEs/code checkers.
Tomcat **is** the latest lightweight technology. I'd look into what specifically is wrong - is Tomcat configured poorly? Is the problem the app that is running in using Tomcat?
Jetty, with springboot
Yes, in a fresh code base, use JavaFX.
I've had success with Grizzly on Java 10 recently, where Jetty would NPE while trying to determine the JVM version. Jetty is fine otherwise, though. Haven't tried Undertow yet.
What are you using that Tomcat doesn‚Äôt support? I would generally steer people toward embedded servlet container in Spring Boot barring special requirements. If you have a lot of legacy code, it might be too difficult. 
I like Undertow. It's one of the top ranked java web server on the [tech empower benchmarks](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=plaintext) currently. It's feature rich, supporting https, http2, and websockets. It's embeddable. 1.4.x supports Java 7. Maintained by Red Hat. The only fault I can find in it is lack of signatures on the maven artifacts. I've opened a ticket on that. I hope they fix it. You can [vote on the issue here](https://issues.jboss.org/browse/UNDERTOW-1328?_sscc=t) if you would like to see them work on that too.
Yes. That's really cheap compared to a similarly provisioned VPS on AWS/Google
Never.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thanks, I will post on that subreddit
I presume that Java swing is perhaps easier to teach than python qt?
In my experience: one of the biggest benefits frameworks offer is productivity. A lot of these 'microframeworks' (Ninja, Spark, Javalin, etc.) are nice for pet projects but in production services, even microservices, you still need stuff like logging, tracing, configuration, metrics, DI, database access, security, etc. Often with these micro-frameworks you basically end up assembling your own version of Spring, with all the dependency hell involved, with no real benefits. We did extensive tests with a few micro-frameworks to see if they are a nice alternative for Spring which has problems with memory / CPU consumption at start-up when you run them in containers in a kubernetes cluster. In the end we came to the conclusion that memory is a lot less expensive than developers. 
Schools teach CS fundamentals and then put them in practice through some language. A very very large percentage of graduates won't ever touch Spring because they're going in a completely different direction. In school fundamentals matter. The latest flavour of the month framework doesn't. 
Those specific technologies? Maybe not(J2EE, Struts), however JDBC, definitely. MySQL, definitely. But it‚Äôs less about what specific technologies the company is using NOW and more about what they may be using a year or 3 from now. Plus, being a dev for your full time job gives you the time and opportunity to advance your skill sets in your off time. I learned that, I left a decade long, unrelated career and moved into software development and can say honestly that being in it from 9-5 made me MUCH more capable of being in it after hours. Good luck!!!
Just working in the industry will be good for you. Don‚Äôt look at it as ‚Äúthis framework‚Äù or ‚Äúthat framework‚Äù. Things change fast, this is tech. Almost nothing I used in my first job is still in use. Learn good work habits, learn to solve problems and write good, readable code. You can learn a new framework or new language any time. Soft skills are much harder. I‚Äôve been programming a bit over 20 years. I‚Äôd never used java. Decided to learn it and use it for a personal project. Picked it up to a good level within a couple weeks. Learn good fundamental skills and you can pick up whatever else quickly.
Just like the old versions, or do you think Sun was giving away for free fixes to 1.2, 1.3 after they had been EOL?
Thank you :\)
Thank you :\)
The only things are really missing are restful web services and single page front and apps like angularjs or react, but really nothing wrong with that. You can always learn that on your own time or when you join another company. Being in the industry and building real, working software is really the important thing.
even if you were born yesterday, SQL is going to be a skill that can keep you employable for the rest of your life.
&gt; gets to work on cutting Javascript frameworks in her first job I assume you mean "cutting edge frameworks". I view J2EE/JDBC/etc. as having a lot more lasting value than JS framework of the month. Moving from fad tech to fad tech runs the risks of a) leaving you left behind if you bet early on the wrong stack, and b) never developing the _deep_ skills in any particular stack that you need to eventually see underneath it all and become a real "software engineer". The bright side of the Java ecosystem is its longevity. Whatever you write in semi-dated J2EE will still run on Java version XX 20 years later. So you have _time_ to learn where performance matters (e.g. SQL) and where it doesn't (e.g. quicksort), the complexities of concurrency and the tradeoffs between e.g. threads sharing data vs actors passing immutable objects, and when it makes sense to use different UI paradigms (CLI, native GUI, web UI + REST). So also seconding nhtshot, focus on the job part of the job first, those are the transferrable skills you are getting right now.
Funny isn't it? Even with the rise of NoSQL and object databases, relational databases are just so ingrained. Not to mention all those 'other' type of query languages that are really just derived from SQL or inspired by SQL.
JDBC yes. Struts? Maybe, if you land another job in a large company with legacy Java apps (thinking insurance). However, struts should provide insight into web frameworks that can translate to other, currently used frameworks (thinking Jersey)
JavaScript will never be cutting edge, it was a stop gap scripting language and still is. Literally almost any language would be better in the browser, even Kotlin.
We find it amazing how much research has been done on the JVM compilers and GC. We now have JIT with two compilers C1 + C2. And the GCs are amazing. Over two decades of intensive research by multiple organizations. What we have is amazing! Yet we don't think about the even more decades of research by even more organizations that have gone into building better SQL engines. SQL is not sexy. But it is very solid. The principles behind it are sound. Lots of databases (unfortunately not all plug in replacements for each other). And open source databases. And widespread knowledge of SQL. Today if you stick to very vanilla portable SQL you can still do an awful lot. For some nice downloadable free PDFs on SQL, MS-SQL, MySQL, PostgreSQL, see this: https://goalkicker.com/ Plus it has books on other topics, including Java related topics. All PDFs are collected works from StackOverflow questions. These are NOT introductions. Only for professionals. These do not have any basic how-to. It drops you right into the deep end of professional technical StackOverflow answers.
This is not an answer to your question. If you use Struts, I would mention a framework I came to like a decade ago. Stripes. It's like Struts but WAY easier. No XML. You simply annotate an action to make it be recognized as an action callable from the browser. It's simple to use. No ceremony. It fits very nicely with Hibernate (presumably other JPA also).
Tomcat is light weight. If you produce your application as a single WAR file, then it is a simple drop in to Tomcat. Or to other java application servers that can run on bigger iron. Even mainframes. Further, you can scale Tomcat up to large memory sizes. And scale out to clusters of Tomcat. Before you even have to consider using anything else. Tomcat is available from hosting providers so that you can simply drop your WAR file into a cloud service. Tomcat can take you from very small to pretty large.
Not a fan of Stuts, however most companies you go to will be using dated technologies. My first job out of college was just doing Java 5 with crappy jsp templating. However in a couple of years I was building MVC projects using Spring Framework and they paid me to get certified. Don't get discouraged just because a company is using backdated technology, look at it as an opportunity to help bring them up to speed.
Thanks
If I want to do a mini\-project with these technologies, where should I start? I know Java well, but I will need to learn everything else. Can you suggest some tutorial?
&gt;Struts is good to know if you work on legacy apps, but I don't think it's used often in new dev. Also I read somewhere that J2EE has deprecated and has been replaced with Java EE. And yet, the email mentioned J2EE. Should that be a concern?
Well the kind of legacy stuff you'd find struts on you'd find j2ee. Being a dev that babysits old code gets boring though.
Hey I can agree to that in a lot of ways. For several years I‚Äôve stuck to the full stack opinionated frameworks, even for api‚Äôs and sometimes even for datapumps. Do one better, I‚Äôve even started regressing back to monolithic architecture because managing a bajillion projects and keeping them in sync is driving me _quite_ bonkers. We‚Äôve started doing feature flags at work where we employ a microservice architecture orchestrated through kubernetes. Hooooooo boy. 
As a fresher I've very little idea about all these stuffs. I guess I'll join and get some experience here. Can you please suggest some good source to get started with Java, J2EE, JDBC etc?
Struts2 is also like that, no xml config required. Along with struts-convention plugin you wont even need annotations for actions as class scanning will use class naming conventions to map endpoints and such.
Where I live it's often the case that tech stack info is not passed down to HR, so what they tell you in advance may not indicate what you'll actually be working on. Stuff like JDBC and SQL will likely never go away and the old-but-gold frameworks especially in Java tend to become industry standard due to how they implement a solution, which can be considered best practice, and so what you learn there may not be used elsewhere any longer, however the experience you gain by making use of these paradigms will remain relevant and valuable in the long-term.
&gt; The problem about this approach is that you can't cross-compile easily I have no idea on how it actually works, but JMC (recently open-sourced by oracle) builds for all three platforms with a single `mvn package`. So, it should be possible.
Even though you have a point for mentioning that there are more things needed in real app than in a pet project I still can't agree. In my experience, I can always assemble those little frameworks faster manually if needed, providing explicit configuration in code itself (something that people like to call boilerplate) than people around me read 15 stackoverflow topics on which bean they have to provide, which spring-* subproject they are missing and another 15 to guess why the heck this does not work, only to find out by fallbacking to Spring's in depth documentationto find out that they miss a god damn annotation somewhere. I still find many of those big, feature-full, production-ready frameworks to be leaky abstractions. As soon as you do something unconventional, you hit a wall. You can break it, but you'll spend days to find out how to. But here, we are talking only about web api layer, so switching one of those for some micro-ish thing like Javalin can always be reverted very quickly to Spring equivalent if that is very needed.
It's under the same exact license as the JDK. [http://openjdk.java.net/legal/gplv2\+ce.html](http://openjdk.java.net/legal/gplv2+ce.html) I downloaded the javafx package and the license is the very same one linked here, which is also linked on the download page for both javafx **and** openjdk.
I‚Äôm not quite sure where people got he idea that I was building an API? Never said that lol merely was looking into microfrsmeworks like Javalin for the light weight ness and simplicity I use microframeworks daily, just not java based. Everything from Silex (php) to Falcon (python) to even Sinatra (ruby) and Diet.js (node). I primarily use these things to build independently shipped API service layers of course, but occasionally I‚Äôm looking for something like a Flask (python) where it‚Äôs micro but built for making small websites wth a presentation layer. That‚Äôs what I was hoping to get out of Javalin and it‚Äôs not like it‚Äôs incapable of that, I was just falling down a rabbit hole of third party dependency hell trying to understand just what the frig the template engines wanted me to configure to get it working right, and then within the context of Javalin and what it expects to make it work the way it needs too. Getting frustrated for all the same reasons you listed out there. I‚Äôm no spring apologizer, far from it I can‚Äôt stand that thing. But full stack frameworks man, when you need some or even most of those features, it‚Äôs easier to just start off with it ready to go. 
&gt; (I also seriously question that every project needs "logging, tracing, configuration, metrics, DI, database access, security, etc", but that's another discussion.) Every single project in our architecture at work need at least 80% of this, even the simplest of datapumps. - The logging is sent to kibana for analysis, complete with correlated logging ID for tracing purposes across multiple scaled instances - The tracing is used when an error is detected in the logs, which sends auto notifications to our team. - The configuration is necessary for kubernetes to mount environment based configuration requirements. Stage, dev, and prod all have different requirements, from filesystem paths to connection information, to toggle switches like feature flags. - metrics are collected and used by various teams including ourselves to determine development priority and make those decisions when it comes to cutting or salvaging features - security because we can‚Äôt just have any ol‚Äô person accessing our apis and data. Right down to rate limiting. - database access because there‚Äôs fewer cases where the data your sending through your API isn‚Äôt going to be coming from some database engine somewhere. I can count 1 I‚Äôve ever made, and it‚Äôs currently being converted to MySQL as I write this. 
JavaScript is the shittiest language actually in use by far
You will get experience. While some of the technology might not be used in the future, you will get experience dealing with existing code base and items like SQL, which will be useful in future. You will also gain a line of thinking in general, dealing with business and red tape that might exist.
Speaking as someone who just got their first job after graduating: Don't worry about falling behind compared to other people. Focus on learning as much as you can about how the technologies you're using work and becoming proficient in them. Learn why they are the way they are, the design philosophy behind. Think critically in how you apply them and learn to recognize when they are and aren't a good fit for some application. This is what will make you a really valuable member of a team and give you room to grow. When you know enough about the technology that you're using to understand its shortcomings, you can start learning about alternative or additional technologies that might be better suited. You might not have much say in how things are done right now, but if you become the resident expert at some part of the toolchain, your opinion will matter when people want to make a change. Like I said, I just started a few months ago, but soon after I started, our team started looking at a new solution for a part of our application. Everyone on the team was starting at square 1 with no knowledge. I now have a better grasp of it than anyone else in the office and, because of this, I am involved in every conversation about how this part of our application should work. 
 Don‚Äôt know your skill level but here are some basic Java exercises to get you started: http://codingbat.com/java These work in the browser so no installation needed. You could also get a book like Effective Java: https://www.journaldev.com/6162/5-best-core-java-books-for-beginners The official JDBC tutorials could be a good place to start learning JDBC: https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html
I don't doubt that most projects in your organization need those things, I just think "in production, even microservices need [list of things my org uses]" doesn't work as an argument. That list of things will vary from organization to organization based on the number of employees and their background.
I dunno, we adopt well established practices put in place by a number of well established companies, I don‚Äôt think our situation is even that atypical honestly In my experience you can try forgoing the added bloat of all this stuff, but eventually they will be added, either by request or necessity 
Ah... The listed licence and the link it points to disagree. Likely just a typo.
&gt;That's very insightful. Thank you!
&gt; even Kotlin What's with the shade?
I'm not even saying that it's atypical, I'm just saying it's not like that *everywhere*. If you find that almost all your services need these things, and that whatever Spring provides works for you, then Spring sounds like a great choice. Personally I have a lot of services with only business logic, config and logging. Some services are completely open. Some services don't have a data layer. Some have db and auth, but handled by other services. Spring + Spring Boot is something like 1.5 million lines of code, and it does everything (more or less). Some people prefer pulling in smaller libraries as they need them. Either approach is valid IMO.
I might have said it in a different reply thread somewhere, but I'm not a spring user. I don't like spring at all. It's too complicated and too heavy and annoying to deal with. If spring fit the bill with what I was looking for, I would have just opted for that. I come from other ecosystems. Symfony and Silex \(php\), Django, Falcon, and Flask \(python\), Express and Diet \(node\), and recently JavaSpark. I'm still exploring options within the Java ecosystem to latch onto, and so far Spring makes me want to punch puppies in the face and JavaSpark was nice to use though annoying to bolt on all the aforementioned crap onto \(But I'm chalking that up to just learning experience\). 
you can use [https://github.com/renatoathaydes/jgrab](https://github.com/renatoathaydes/jgrab) today \(even for older javas\). I use it with Java8.
AHA! This is where I fly in with another shameless plug of mine! *I'm still sorry, I just want my articles to be useful to someone*. I'm writing halfastack.com because around 2 years ago, I started fresh and was thrown into a huge Java EE application. When you say "J2EE", that is actually technology from 2003... What I think you mean is Java EE (7 most likely, 8 if you're lucky), which is, believe it or not, used very often nowadays in mid-level to large enterprise companies... So cue in me 2 years ago, totally helpless, trying to make sense of it all, and I could find no tutorials that would be on my level... They'd be like, "deploy JDBC driver to your application server and expose the JNDI such that you can connect..." and I'd be like, already lost you there, mate... So I recently began working on a website of mine that provides free resources, github codes, as well as fairly extensive introductions into the topics. My latest article is on [Java Persistence API](https://www.halfastack.com/jpa-practical-part-deploy-and-explore-working-jpa-application/) (JPA), which shows you how to: a) Set up SQL server b) Set up application server c) Use the database in a real, albeit quite simple, app d) Is accompanied by two fairly huge theory-based JPA-focused articles with code snippets that I took from my IDE (so they were functional at one point at least) [Not all the steps are in one article, these are 4 separate articles on my website so that you can pick and choose] It has its catches: a) There's little content still (so far, I've covered EJBs, JPA, and I'm working on REST, but I mean, I have 2 jobs, so I try to do like one article a week) b) I'm sometimes still finding bugs and ironing them out as we go. I don't mind admitting it, and mainly, if someone can't finish something, I hope he or she will leave a comment and we'll sort it out... Anyhow, the whole series of articles should prepare you for the [EX183](https://www.redhat.com/en/services/training/ex183-red-hat-certified-enterprise-application-developer-exam) exam, which is really quite good (albeit quite basic). That is my syllabus. If anyone has any feedback, I'd LOVE to hear it... Be it "yo dingus, this is totally wrong" or "yo dingus, this is quite good"... :)) But I don't want to only self-promote myself, so pretty much the only Java EE focused course I could find that weren't books too old, too difficult to understand, or the combination of the two, was this [puralsight path](https://www.pluralsight.com/paths/java-ee-foundations) . I believe it's quite basic but should provide very good intro as well. But hey, my website is free and will stay free :) 
&gt; I view J2EE/JDBC/etc. as having a lot more lasting value than JS framework of the month. To be honest I see things are more "standard" right now in the JS world for frontend development. Almost all projects are using Angular, React or Vue (the later seem to be used mainly by PHP developers from what I've seen). Those are three frameworks have some years already in the field and work reasonably well.
Ok so obviously, I write a Java EE tutorial site, and I'm biased... But I tell you a couple of things from my perspective... * Java EE is still very much used... Sometimes, you'll hear squabbling of enterprise java devs arguing whether JEE or Spring is better. Who cares. If you master one, you'll not have that much difficulties to switch. And Java EE is now becoming JakartaEE - exciting times ahead methinks * I love this technology A LOT... Now, as I said, I am biased... I think the most difficult thing is that because there's so much in the beginning, it can be HUGELY overwhelming... You have you application server, your application, your implementation of various standards (i.e. Hibernate), and then underlying stuff like DB connection that can fail, or whatever else... I'm not even mentioning that you HAVE to use some kind of packaging and dependency management software like Maven or Gradle, and that many students fresh out of school do not know git or any similar SVC software, so it all adds up to A LOT of stuff to learn and process. Right? But to me, the beauty is, it's actually not that complicated when you realize what it is that these things do for you... When you realize how incredibly simplified view of DB Hibernate brings, and how things like Restful API easily integrates with your JS frameworks of yesterday... Java EE is, to me, battle tested. It's not sexy. You have to write a ton of boilerplate code (oh yea, I forgot to mention JBoss Forge as another tool to use). When you get an exception, you get like 100-300 lines of code in certain frameworks (I'm looking at you, Liferay!) and when something goes wrong, it's very hard to debug because you have so many moving parts... But once you at least peek into the power of those things, you realize it's not useless; it's actually amazing what it can do for you if you know what you're doing... I don't know, I guess I just like it ¬Ø\\_(„ÉÑ)_/¬Ø
My dude, I've been doing JSPs for the past 4 months. While not sexy, as a Java dev, I grown to like it.^(It's definitely NOT stockholm syndrome!)
By the way, I've noticed many comany write "J2EE" and mean "Java EE" (as in Java 2 Es -&gt; J2E -&gt; J2EE). I wouldn't worry; I don't think many companies now use deprecated frameworks from 2003 ;) I mean, it's certainly possible, but if it's the case, they might be looking to modernize and *BAM*, there you appear with your newfangled Java EE 8! :)) But really, most often, it's just HR screwing up the tech names... 
 &gt; 8! 8! = 40,320 
There are many giant corporations with java stacks looking to modernize and afraid to move away from Java. There is definitely a niche there. Also pick up Kotlin.
&gt; I'm still exploring options within the Java ecosystem to latch onto, and so far Spring makes me want to punch puppies in the face I know the feeling :) In that case I suggest you check out [dropwizard](http://www.dropwizard.io). It's a very popular collection of libraries with a good amount of documentation and tutorial available. &gt; JavaSpark was nice to use though annoying to bolt on all the aforementioned crap onto (But I'm chalking that up to just learning experience). Spark in particular is a bit tricky because it has a static API, and all the docs are for that API. There is an instance API which is almost identical though, so if you haven't switched to that you should, but you still can't configure the Jetty server properly. In Javalin you can, so you can use plugins like `StatisticsHandler` which can expose metrics via prometheus. We're also working on creating extensions, which should make it easier to integrate with different libraries. 
Unless they did a bad job of interviewing and evaluating you, they know where you are at skill wise. It isn't going to hurt to brush up on that stuff so you can get moving quicker, but they should be aware of what you know and what you'll have to learn on the job.
J2EE.. basically JEE these days.. is absolutely relevant. Struts.. despite being old, is still relevant (though I would argue Struts 2), in that what it teaches is used today by many frameworks, SpringMVC included, which is still relevant and used today. Example.. Spring MVC was similar to Struts..but today is re-purposed quite a bit to handle Rest API endpoints instead of server side pages. Most of the JEE frameworks are still relevant today. JMS, JDBC, JAXRS, DI and so on. A lot of it is used in various different manners today than the original JEE plan of breaking up stacks of front/entity/db tiers of developers.. but most of the frameworks are still viable today if you choose JEE over say Spring, or plain old servlets and your own jdbc code. 
So as many replies have indicated.. the experience is the more important thing here as you are right out of college. Some of the stuff you have to use may be dated.. which could open opportunities for you at the company to update them with a bit more modern options. That said, the good news here is there are TONS of resources on the web around these dated technologies so you will be in good hands as you learn to be able to find information on the net and not get bogged down with issues that new tech may present. Between books, SO, and so on, pretty much anything you may want/need to do is covered, probably in multiple ways. JEE is very relevant today.. lots of the frameworks within a JEE stack are used today for enterprise software as well as back end hobby projects. Example.. some flavor of JDBC is used either directly or by an ORM solution. JMS over any number of message stacks is useful and very relevant today. Struts (hopefully Struts 2) while dated is still relevant in that it hits on the MVC pattern and even if you were to do what is more commonly done today with Rest API endpoints (using JAXRS) with a single page app built in React/Angular making ajax requests.. it is still the same MVC paradigm (more or less.. there is MVVM, etc), just different ways of obtaining the same or similar results. So use it, learn it, maybe pitch newer ways to do it. All of it will result in good starting experience as you also build up your knowledge of Java. 
There are 100's of projects in ASF that could use help from an earnest newcomer. My advise, pick something you're interested in, learn how to use it. Start interacting on their mailing list. First ask pointed questions (making sure to follow must gather standards). Once you've got some expertise in using it, you should be able to jump in and help. Here's the list of projects: https://projects.apache.org/
One year before I was a fresher like you. I am working on raw jsp , servlet and the project almost 18 years old. Job field is totally different. You have to work with in a team, interact with other people, work under timeline, responsibility of tasks. These sorts of skills also required to be a successful developer. Good luck with your first job. 
jetty runner is another option. https://www.eclipse.org/jetty/documentation/9.4.x/runner.html
IMHO, *all* Java programming benefits from reading Effective Java. 
As it is if you know that stuff, you shouldn't have any trouble finding a job.
Think of it as a framework that uses that syntax. It's more complicated than that, but that's the gist of it.
I loved Stripes as well, but it wasn't a corporate buzzword, so when Spring Mvc started doing annotations I went with that. 
the thing that makes SQL incredibly useful is that it can be trivially extended to describe a request for data (more generic than 'query') from any source where the output has structure. In practice this is nearly everything. I think in the future we will see a more heavy reliance on query languages with imperative language taking a back seat for gluing queries together. Knowing SQL makes querying a "RESTful" HTTP endpoint feel like gouging your eyes out with a fork.
&gt; don't use JS on the backend. There's no reason for that Well node.js is huge :-). It's supported as a runtime for AWS lambdas, and start-up time for the runtime is much faster than Java.
&gt;Well node.js is huge :-) So? &gt; It's supported as a runtime for AWS lambdas... Along with other languages. Again, so? &gt;... and start-up time for the runtime is much faster than Java. Java and JS are not the only languages.
You don't have anything to worry about or do. You're being confused by some terms and plans here which don't quite mean what you think they mean. Just download and use the OpenJDK. JRE is a generic term. You can get a JRE of the OpenJDK. They won't be switching anything in OpenJDK. Netbeans can run on the OpenJDK like any other JRE.
Read as much of the code base as you can. Read it like a good book.
OpenJDK comes from Oracle, and has for years. It is simply the reference build of Oracle Java. It only has a few parts missing that Oracle reserves for 'paid' license versions of Java. Just use OpenJDK unless you need the missing bits
The two declared method references are two independent instances. Deserializing each of them produces identical objects (but still not the same object, unless the JVM is doing something fucky under the hood) Printing the hashcodes of the objects should help illustrate this: Testing lambdas 1023892928 .. 558638686 1028214719 .. 500977346 lambdas ok Testing method references 455896770 .. 1323165413 1587487668 .. 1587487668 &lt;-- same hashcode Exception in thread "main" java.lang.AssertionError: equal after serialization at LambdaTest.assertNonEqual(LambdaTest.java:44) at LambdaTest.testNonEqualityAfterSerialization(LambdaTest.java:24) at LambdaTest.main(LambdaTest.java:9)
&gt; It only has a few parts missing that Oracle reserves for 'paid' license versions of Java. And those should be coming into OpenJDK sooner or later, if Oracle is to be trusted. Flight recorder and mission control appear to be headed for 11 already...
Yes, and this is especially important for registering/unregistering callbacks. If you use the 'same' method reference, it will be two objects different, and you will not unregister the correct listener.
The point is that they are equal by reference after ser/deser, but not equal before. I should have used == to emphasize this, but anyway one should get to know what the equals does before claiming anything.
Definitely agreed! I wrote this article with an angle to convince my usual reareds- frameworks and microservices enthusiasts; to slow down and look at the foundations!
It's not really a "feature" of method references as shared/consistent identity of lambdas and method references is intentionally unspecified. It's more just an artefact of the implementations you're using, and is liable to change between different versions and implementations of the JVM.
&gt; You know, that's actually really handy if you need to write characters that don't exist on your keyboard. Well you can copy paste the character, or use an ALT+numbers combination. But. Yeah. I guess it's "useful" :P for something :P let's say :P 
Honestly, we have enough of these type of articles posted on reddit already.
&gt; I've done all the lessons on codecademy so I have the basics down. No, you don't. You have the *syntax* down and learnt some *keywords*, but you are far from even having scratched the surface of Java. Do a *proper* course, like the MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki and you will see that you so far have basically learnt nothing substantial. Next time, please follow the rules and post such questions in **/r/learnjava** as is stated in the **sidebar** here. In the sidebar there, you would also have found plenty learning resources.
This stirs the evil programmer in me.
Thanks for the link. Didn't realize where the sidebar is (mobile app). 
Where's the credit for the [Stack Overflow question](https://stackoverflow.com/questions/30727515/why-is-executing-java-code-in-comments-with-certain-unicode-characters-allowed) this was taken from?
And there's some pretty terrible code in there too. for (String item : myList) System.out.println(item); Where are the braces, and use `Collection.forEach()`. It demonstrates `Iterator` when there are very few situations where `Iterator` is useful these days. for (Iterator&lt;String&gt; it = arrayStrings.iterator(); it.hasNext(); ) if (it.next() != "hello") it.remove(); } would be better as: arrayStrings.removeIf(s -&gt; "hello" != s); Then: arrayStrings.stream() .forEach(s -&gt; System.out.println(s)); One point for using `.forEach()`. Minus two points for using `Stream.forEach()` instead of `Collection.forEach()`. Mentions that you can use the `List` interface to use positions inside the list, but fails to point out that you almost certainly don't want to do this if you have a `LinkedList`. Discusses `Vector`. `Collections.synchronized*()` are better than using the old collection classes. They shouldn't be mentioned at all. Mentions `Collections.sort()` but fails to mention `Collection.sort()` or `Comparator`s.
Yeah but who would do this? I can't even get past a code review with a spelling mistake in production. 
Java, J2EE, JDBC, SQL, they are all huge and won't be going anywhere. Struts... yeah, that's kind of outdated, but there's nothing wrong with it. You're going to get some good experience, take advantage of it.
100% unit test coverage, here I come
I know, right?!?!? How those guys from the '80s got away with it is beyond me.
There are definitely times when conditional compilation would help, totally agree. I miss it from my C days.
I guess you're right, if you can 100% guarantee the encoding of your source file.
Well, it's not really in the comments. Definitely a bad coding practice, but mostly confusing because of the IDE's syntax highlighting.
&gt;Best reason I can think of (aside from annotations and rate limiting) is that Spring-Cloud is not planning to support Zuul 2. So, assuming you prefer a pure Spring stack, Spring-Cloud-Gateway is the future. &gt;Reference: https://github.com/spring-cloud/spring-cloud-netflix/issues/1498
So at least at the place where I work which is about 18 years old, the development ideology was different way back in the day and it was usually more of a "single dev per project, waterfall" type of system. When one person is in control of a project like that you can probably get away with slipping a lot more in there in terms of easter eggs and such. That said I recently put a sound effect into our web app... just for fun. It hasn't gone to prod yet, but it DID pass code review, so fingers crossed.
Which you can if you don't ignore mavens constant nagging about it
With the mixed scopes there's actually some downsides relating to local variable access.
Also much fun with symbols that [reverse the reading flow](https://384uqqh5pka2ma24ild282mv-wpengine.netdna-ssl.com/wp-content/uploads/2015/09/weird.java_.png).
snippet #1: for (String item : myList) System.out.println(item); snippet #2: myList.forEach(item -&gt; System.out.println(item)); Why do you think snippet #2 is superior? It's inferior, in fact. You save one variable type, but starting with java 10, that saves you one `var` and that's not worth writing home about I assume you'd agree, and in the mean time, you lose transparency of exceptions and control flow (you can't return the outer method from inside the lambda, nor can you continue/break the loop from inside that loop. All things that you CAN do with for`(T v:iterable)` syntax. You can also throw checked exceptions with that, unlike with lambdas. Lambdas have their place. I'm pretty sure you should consider this: someCollection.forEach(x -&gt; foo); a bug. the `forEach` method on collection is useful when you already have a lambda all set up, for example, because it's one of your own method's parameters and your caller passed in the code that is to be run on each element in a collection. Consider the alternative: That means either [A] the entire java ecosystem now splits in twain, which is obviously really bad, or [B] after a massive effort to try to teach everyone to go in and update ALL their code and relearn habits, we have somehow achieved the nigh impossible and 'fixed' the greater java ecosystem to almost always use .forEach instead. Yay! That herculean effort has bought us.... the inability to throw checked exceptions or do control flow from inside there, and we won... the ability to type `var` slightly less often. B is a loser. A is a loser. Therefore .forEach (with inline lambdas, at any rate), is a loser. 
Why would you need this when you could do byte code generation / manipulation and use the Pluggable Annotation Processing API. That should be already enough magic. Also [this](http://www.javapractices.com/topic/TopicAction.do?Id=64).
stringStream.filter( s -&gt; s != "goodbye"); Okay.............
This looks like a bug to me: the lambda/methodref producing expressions have no guarantees about the identity of the objects produced. But once the object is produced, its identity should be stable. Submitted [JDK-8202922](https://bugs.openjdk.java.net/browse/JDK-8202922) with a cleaner test.
Non-Markdown version of the links In this comment: **Link Text:** JDK-8202922 **Link URL:** https://bugs.openjdk.java.net/browse/JDK-8202922 ^(Preventing misleading links on reddit by providing the links behind the markdown. **Why?** u/reallinkbot/comments/8igale/why_do_i_exist/)
My reaction to reading this (for context, I was already sitting at my desk at work with my IDE open): No. There is absolutely no way for this to be a thing. *quickly adds a main method to random class file* I can't believe this will actually... goddamnit really?...
Meh. I don‚Äôt do checked exceptions any more anyway, there‚Äôs nicer alternatives that don‚Äôt interfere with recent language improvements. 
Startup time is not an interesting differentiator on the backend. 
The first function is a reference to a static method, `Object.toString(object)` using the instance variable as a parameter, while the second is an instance method. So you're comparing `Object.toString(object)` to `object.toString ()`.
While the official Oracle docs are a great resource, remember that different people have different learning styles. Some argue that the Oracle docs are hard to follow and tutorials like this offer a different visual representation of the material. With that said, it's all a matter of personal preference. While it's perfectly reasonable to prefer the official documentation, it's also good to have different variations of the same material to consult ... sometimes explaining the same thing in a slightly different way can make the difference between understanding/not understanding a concept.
where are the braces you ask? you should ask the OFFICIAL ORACLE DOCS the same question... https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html 
thanks for your opinion.
Yep. But we can have code embedded in a comment delimiter that will compile and execute. 
Yuk. I wouldn't recommend that either.
this makes sense and your feedback is appreciated. I suppose "in-depth" is a relative term :) 
Just set the damn encoding.
The sidebar says &gt; **Do not post tutorials here!** These should go in /r/learnjava. I guess that extends to tutorial requests as well?
// \u000d System.out.println("Hello World!");
Didn't realize Wildfly swarm doesn't ship microprofile OOTB... that might indeed explain the paltry 16% adoption
It is if you take a job using them. Seems most apps have moved to react or angular these days. 
It also depends your location. In my country big corporations still using jsf. They are move slowly and don't want to take a risk so much. The many projects has legacy codes. My advice is look at client side technologies like vuejs and react.
Using `println` is one of the few situations where `.forEach()` is worthwhile. for (String item : myList) { System.out.println(item); } vs myList.forEach(System.out::println); Of course, you probably should be using a sensible logging framework instead of `System.out.println()`. In the vast majority of cases, reaching for `.forEach()` is doing functional programming wrong, because you're probably about to do some side effects. And if it was more than a method reference, I would use an extended for instead of `.forEach()`.
I don't think JSF will be a useful legacy technology like for instance cobol was. There was a moment in time where tons of banking code existed in cobol, and operated at a level where they couldn't just replace it. A cobol engineer could pull in crazy rates. JSF seems easier to replace, most frontend are rewritten semi regularly.
I know of a few companies still using Richfaces on their applications.
I feel like it's almost always a waste of time to learn a certain specified technology ahead of time. Except maybe if you're interested in them and are explicitly looking for a job using them.
Prob worth learning for a few hours if you have an interview with a company that uses JSF 
I am right now working with JSF. It's not bad at all, but I think React or Angular are miles ahead. I really miss them haha.
It probably makes sense to have read a five minute overview on a range of technologies, but no more until you're going to work on them. Just so you have an idea of what they are and what they're useful for, so you can at least answer a few questions in an interview. 
Can someone explain me the difference between jsp and jsf ? üò¨
I always hated it. 
Similar as other mentioned - NO. Except: 1 Most/all of the companies in the location you are currently based uses it and unless you know JSF, you will hard time landing a job. 2. If you have fetish for legacy technologies. 
If you don't have to scale for huge projects, JSF is still really cool to use.
I would add [RestAssured](http://rest-assured.io/) and [TestContainers](https://www.testcontainers.org/)
JSP is stone age web technology - basically just HTML templates in which you can embed Java code either directly or indirectly. It has no support for dynamic web apps, you'd have to build that in manually if you want it. There's no direct support for routing or any other fancy web framework stuff either, though some older web frameworks use JSPs as templates. JSF is a much more modern and comprehensive technology - a full web framework with support for dynamic web apps. However, it's a bit dated and not very fashionable these days.
No
Yes! That's what I thought about. If you test the code, it'll work thanks to the String constant pools. If you want to know why it's working in this case
Nothing worse than code that works part of the time. :)
We use jsf with primefaces components. The showcases you can find here: https://www.primefaces.org/showcase/ JavaEE has very stable API. You don't must to afraid that new release break backwards compatibility to previous one like angular or other single page applications did already in the past. 
The funny thing is that Angular is directly inspired by JSF ;)
Please don't. The JavaScript framework world is immensely in flux and client-side frameworks have various disadvantages such as taking more CPU and memory on the client, which drains batteries and kills other apps. It can also cause web services that sent to much data to the client, since almost no one is capable of creating web API that return exactly the data that's needed. Almost always some parts need to be trimmed at the client.
&gt; Thus you don't have a clear separation between client and server. Try to connect a non JSF-Client with the JSF-Server side ... You're missing the point that JSF is just another client for the same REST services that can also feed your other clients. A good example of this is the JSF based admin console of GlassFish/Payara.
I'm only talking about `println`. Go read my other comment on the topic.
While this is possible, it was not the intention of JSF and it is still not used that way in many projects. Actually it is more the other way around: JSF encourages a design without a clear separation between client and server.
Abstraction is important. A/B principle applies.
Sorry, but I just don't agree. I've been working with JSF like forever, and it has always been the design of JSF for backing beans to be slim and calling out to separate business services. These services were traditionally EJB beans, SOAP services (blergh, I know), CDI bases services or REST APIs. The oldest books on JSF already promote that.
Lack of Spring experience seems to be really holding me back. Hiring managers seem to expect senior developers to walk in the door an expert on every tool in their environment.
Hey, least trolley comment you've made here. Here's an upvote!
&gt; Lack of Spring experience seems to be really holding me back That was exactly the issue I had a year ago. However, what are you going to do? Sure, I read a book and did some practicing after hour; but even so, you won't have professional experience in it, and it's pretty much up to your interview skills to convince the managers that "yeah I'll be up to it in no time".
Yeah, likely. I've seen this so many times over. People thinking another framework is going to be the silver bullet, and then just creating the same mess and same problems in those other frameworks.
JSF has been used for huge projects and public facing projects at that. Toys r us, Virgin and eBay comes to mind. There was also this interview with Adam Bien I think about zeef.com, which was public facing as well and did relatively speaking a lot of traffic on a single node.
I was more thinking of facebook or google kind of huge. Full J2EE stack projects can indeed handle with a lot of traffic if done properly.
 JSP lets me,do the shitty i18n stuff on the server to create internationalised templates, that are sent to the browser to be combined with JSON to be rendered to HTML. You will not take my JSP from me ever!
Have you tried lying like literally every other candidate in the field does? 
One thing you could do is make some sort of Spring Boot project in the cloud and have it up on your github for hiring folks to see... something impressive \(like include Spring Security for auth, etc\), but small enough that you could explain it. I really like it when folks have code on a github page that I can go through \(with commit histories so I can have some level of confidence they didn't just copy everything from someone else wholesale\). The key is to have a project that's complete and that works along with having nice clean code \(tests are a plus, but I wouldn't expect many on a personal project like that\).
As much as I think Angular is a great piece of tech, I think React has "won"... I hate the "flavor of the month" feeling I get from React folks, but after using it for a bit now, I can really say it's an impressive technology. I was very curmudgeony when it came to adopting it, but it's good. 
&gt;most frontends are rewritten semi regularly cries in JSP
React seems to be about twice as popular as Angular, but I attribute that to the fact that it's much more commonly used on publishing oriented sites. Angular, on the other hand, seems to be gaining more traction with LOB/enterprise environments, which typically expose a subset of their UIs to the public, with much more in depth read-write oriented interfaces exposed to their SMEs. YMMV of course. 
If you're looking for something to add to your portfolio (rather than just wanting to know the state of JSF in the industriy), I just stumbled across [this list](https://javarevisited.blogspot.de/2018/05/10-tips-to-become-better-java-developer.html) from which I'd say I agree with most points.
 int i = 0; if (i == null) { System.out.println("YAY"); } is a compile time error here \(Message: Operator '==' cannot be applied to 'int', 'null'\). Also, I wanted to reproduce what you said, so I wrote a small test: public class Test { public static void main(String[] args) { int i = 127; Integer j = 127; System.out.println(i == j); i++; j++; System.out.println(i == j); } } It yields true, true. \(JDK8u121\)
JSP's aren't limited to HTML templates, JSP should be viewed as a simple way to create a servlet. What you have the servlet generate is completely up to you. I've used JSPs to create services that accept/reply JSON and XML not just HTML.
How do you think JSF implements dynamic behavior in the client? With a ton of Javascript, emitted through the rendering of the JSF components. JSF even provides a native JS library to assist components with things like AJAX. You are confusing native JS with SPAs. You don't have to go crazy with JS and can still follow the principles of rendering HTML on the server and adding a JS layer on top for dynamic behavior. I would prefer to write that JS layer myself.
I don't think you're using "client" in the same way people mean "client" in these kinds of conversations. By your definition of "client", you could include a Swing based client. However, in these kinds of conversations about web frameworks, the client is the web browser. JSF, by its nature as a component oriented framework, wants to map HTTP requests to component state and component events, which is reflected in how JSF uses HTTP, which is full of JSF stuff. REST APIs are send and receive representations which do not concern themselves with the particulars of the client. For an example, check out how the PrimeFaces autocomplete feature works with jQuery autocomplete. PrimeFaces does a POST form submission, and the server responds with XML instructions on how to update the view. jQuery simply does a GET for a JSON resource.
&gt; You can learn a new programming language [‚Ä¶] and you can learn some new tools [‚Ä¶] and then you can learn the Angular 5+ API [‚Ä¶] And then you have your APIs [‚Ä¶] And you're done &gt; ‚Ä¶ &gt; it's a far simpler model Right.
which other technologies have you used besides JSF ?
Links like [this](https://insights.stackoverflow.com/survey/2018/) are a good indicator.
Same here, multiple applications with Primefaces, and while I really like it, I'm not sure it's worth learning at this point. We started using it about 5 years ago and are starting discussions to move away from it. Will probably be a few more years though.
&gt; It has no support for dynamic web apps, you'd have to build that in manually if you want it. This is good, and how it "should" be. The HTML layer and the JS layer *should* be separated. &gt; There's no direct support for routing or any other fancy web framework stuff either You're talking about "Model 1" architecture. Almost no one uses that anymore, having moved on to "Model 2". In "Model 2", JSP is a *target* of a forward. In the old model (before Struts), the controller would be a servlet (which is routed through web.xml), and the servlet would respond with a forward to the JSP template. Classic Java web frameworks (starting with Struts), provided a specialized servlet which provided other capabilities like bean mapping and validation.
You're competing against a bunch of other candidates who are simply pretending they have experience they do not. If you don't play the same game you end up behind. 
JSP isn't going anywhere. When people cite the Oracle documentation claiming that JSP is obsolete, that citation misses the context that JSP is obsolete *for JSF* and modern JSF applications should use Facelets.
we should do like many other subs and just ban this boot.
Jsp was by far the most widely and commonly ised templating language for web pages at one tome. Let's say you had an html page, you'd add in jsp for looping, conditionally showing stiff or not, etc. It rendered it all on the server and then sentbit to the browser. Jsp is pretty simple. Jsf was one of several attempts at creating an "enterprise" framework for doing web requests. It tried to pretend that tour web app was a desktop app (just rendered with web pages). Like a lot of enterprisy apps it was a bit of a mess. It also was not widely adopted. 
Jsf is crappy, outdated, and wasn't even widely used when it was released. It tried to glue a desktop model onto creatung web apps and it was really really awkward. Jsp was/ the default most widely used html templating language for server side rendering which used tp be the only way web apps were written. It might be useful to learn it because so many legacy apps use it. On the other hand it's so easy to learn you can pick it up pretty easily if you run into it. 
There are still places using JSF. I would personally avoid these places.
I would add [Google Truth](https://github.com/google/truth) -- makes testing of collection content simpler and more declarative.
JSP is a templating technology which is actually compiled into Java code (and can host Java code through scriptlets). Typically, you wouldn't use JSP by itself, but combined with some web framework (for example, Apache Struts). JSF is a web framework which uses Facelets as its templating technology. Fun fact, when JSF first came out, it used JSP for its templating language. That didn't work very well, so Facelets was born.
Same experience here with Angular used much more commonly on data intensive apps. But right after they changed the licensing everybody has started jumping ship. There are of course shed loads of existing Angular apps, but fewer brand new projects are using it (for better or worse who knows at this point).
I'm personally not thrilled with switch expressions (the "everybody come look at this mailing list message and give feedback now that we've already made all the decisions and won't change anything" introduction left a bad taste that I'm trying to get over), but I'm really looking forward to the other two features listed. Especially the multiline string literals. Java is well behind the curve on that point. That feature alone will get used a ton around my office.
Hmm... ::adds React back to personal Pluralsight channel::. :D
There is a *huge* amount of ongoing discussion about switch expressions on the mailing lists and they've been pretty receptive to feedback. They've certainly not "already made all the decisions", and in fact there is still contention over a few points. IMO your first impression was a little unfair off the mark.
The concept is cool, but I don't think that it will be useful. The goal of extension methods is to use them as you would use normal methods without much boiler plate code (like static methods which need the object passed as an argument). Your approach seems to have even more boilerplate which is what extension methods are trying to reduce.
They have a setup cost, but once they're registered they should pay off immediately. This next snippet is going to be a bit specific to my library, but please bear with me: JSON serialization to "Context" without extension method: ``` app.get("/", ctx -&gt; { Object myObject = ... ContextUtil.serializeObjectToContext(ctx, myMapper, myObject); }); ``` Extension method: ``` app.get("/", ctx -&gt; { Object myObject = ... ctx.extension(MyMapper.class).toJson(object); }); ```
It is still worth to learn how it works. But don‚Äôt use it
That's a pending discussion that we are looking to have in the near future. But absolutely makes sense to investigate and invest if there is enough traction and demand. So for that, tanks for raising the question!
I need to know 8 testing things?
File JUnit and Mockito underneath stuff you must know. the rest isn't worth the time.
What prevents you from having a `ContextUtil.toJson()` method? If you need different mappers you can overload the method for different mapper classes. And if you want to reduce written code you can import the method statically and have code like that: `toJson(ctx, myMapper, myObject)`
Nothing preventing it, I just think `ctx.extension(MyMapper.class).toJson(object);` Reads a lot better than `ContextUtil.toJson(ctx, mapper, object);` With the extension method I think it's clearer that you're operating on the ctx with the object as an argument. 
Which version of JSF did you use then, and in isolation or as part of the full Java EE stack?
What motivates you or your work to move away from it?
Why would you want to look at Google or Facebook big? The chances your own app comes even close to that are nearly zero.
2.2 I believe and it was an EE setup. My major headaches came from Eclipse not playing so nicely with weblogic. Our applications are somewhat dense so the build/compile/publish or republish cycle was quite brutal from a time standpoint and generally there were just a ton of phantom issues that would derail me in some new and unique way everyday and i'd spend forever trying to run down the issue only to finally just give up, restart eclipse and magically it was fixed. I also had so much trouble getting Eclipse and weblogic to work in debug mode. It would take forever to start up and would frequently miss breakpoints for reasons I can't explain so my primary debugging method was littering println statements everywhere and just chipping away at the problem until i had some semblence of an idea what could be causing my issue. I fully admit I've been spoiled by years of Visual Studio. My JSF experience improved slightly when I took some time to do some tutorials myself, learning how to properly handle dependencies and when to do incremental builds vs full builds and to help me from forgetting a step when I wanted to test something I made it so that if weblogic was running and I fired off a build of a published project/app it would auto publish following the build and I intentionally made it do it in front of me and not in the background so I would be sure that it had published successfully and was up and running before I interfaced with it. I'm told intelliJ and gradle would have made my life several times easier but my team is kinda set in their ways so I had to rely on the eclipse compiler and ant for when it came time to package something up for production use. 
Using an old framework?
Cool, thanks for the insight. I'll be lurking as I'm sure you'll post updates on reddit and twitter :)
I personally found assertj to be nicer to use than Google truth. It felt like google truth had better autocomplete suggestions but did not have as many features. Its still better than junit assertions by a mile though....
Uggggh been there. Except replace weblogic with websphere. Intellij, any build system but ant, and a lightweight dev app server like TomEE(or if you must WebSphere at least use Liberty) makes life a million times easier. Now if only I had known that at the time :|
Spring is so big and used is so many different ways that even after using it for years I still cant claim any real expertise. If you understand DI and can read documentation thats mostly good enough though imo.
Android
I don't understand the benefit here. Extension methods in Kotlin can refer to the object being extended as `this`, making your code cleaner and providing some nice scoping benefits. In this case, all I see is a more verbose version of a static method. I would probably reject a PR with this because it doesn't really add anything, has the manual configuration setup, and subjectively I don't like seeing the class name in the method call. 
If it doesn't need to be cross platform I would seriously consider .Net Much of your java skills will translate and you will be able to work with a windows native UI framework.
Among others, Z80, 6510 and 68000 assembly for various arcade boards, C64 and Amiga OS graphics, Motif, SGI native GPU and MIPS R4000 asm, MFC, WebObjects, NextStep, Struts, Echo, Spring MVC, AWT, Swing, SWT, Play 1.x, some Android and a tiny bit of iOS/Cocoa. I'm probably forgetting a few, but that's most of the stuff related to graphics.
I'll start explaining it that way. Can't hurt any more than me saying, "look at all this awesome stuff I taught myself - I can learn that in a snap."
What's the motivation behind not using it?
Have you heard the word of our lord and savior Kotlin?
Most of that sounds like an Eclipse/WebLogic thing, having very little if anything to do with JSF itself, doesn't it?
&gt; Java 6 Other great software released in 2006: TES IV: Oblivion, Half-Life 2: Episode One, Firefox 2.0, ...
I don't think this is any cleaner than MyExtension.myMethod(libraryObject) or new MyExtension(libraryObject).myMethod() It just makes the implementation of libraryObject less cohesive. 
Not a high-quality blog post in my opinion. There are several items mentioned here that don't appear to be maintained currently: - JWalk looks like someone's research project. It takes an interesting approach but doesn't appear to be something setup for automated testing, nor does it appear maintained. - JWebUnit hasn't had a release since 2015 apparently. - Tagunit hasn't seen an update to its changelog since 2004. It's hard to imagine this blog was posted in 2017!
I don't. But imho a lot of programmers seems to think like they are handling GAFA projects. If anyone asks me, J2EE stack is a wonderful solution for any problem I could personally encounter.
&gt; There's a set of core services which are being exposed via JAX-RS endpoints. You are describing services exposed over HTTP. &gt; JSF generates the HTML for the UI, and for that it interacts with these core services The web browser makes an HTTP call *over the web* to JSF, and JSF makes an *internal* HTTP call to another service. That's microservices, not the web. However, in the context of a *web application*, JSF is still on the server side. From a microservices standpoint, it just happens to be a client of another service.
I would like to do more of this. My GitHub is embarrassing. I will see if I can figure out if docker can help with a home dev environment because my Linux / tomcat admin skills have not proven up to the task of making my home server a good platform and I can't post anything that hints of production code I've written for work. Thanks for the suggestion and motivation.
Thanks for your feedback, maybe I'm overthinking this. Over the years I've found myself annoyed at having to write things like: ViewUtil.renderVelocityTemplate(ctx, templatePath, model) JacksonUtil.serializeObject(ctx, obj) UserUtil.getLoggedInUser(ctx) I thought it would be a cleaner to have something like ctx.ext(Ext.class).renderVelocity(templatepath, model) ctx.ext(Ext.class).serializeObject(obj) ctx.ext(Ext.class).getLoggedInUser() I'm not happy about having to specify the class, but there's no way around that.
Probably the biggest advantage to using the Spring Cloud Gateway over Zuul is that it is based on a reactive stack, more specifically Project Reactor. The key advantage that a reactive stack provides has to do with scalability. You can handle much more throughput with the Gateway than you can with Zuul with the same resources. In addition the Gateway provides a number of features that are not available/not possible to support with Zuul. You mentioned rate limiting, but there is also the ability to support WebSockets for example. In general IMO the Gateway is much more easy to configure when it comes to defining routes. It is easy to add filters manipulate the request/response and predicates to direct routes. Doing the same thing in Zuul would be much more challenging.
I'm not saying that Java 6 is bad. But sometimes I feel I could be messing with some newer stuff. And I agree with all the software mentioned above.
&gt; Duh! When iOS was just released it wasn't widely used either. It's more or less the definition of an initial release. Ok, I'll reword - it was never particularly popular. It's "peak" usage was fairly small making it not a very good direction direction to go in career-wise.
&gt; JSF 2 let that idea go a long, long time ago. What? No it didn't. It's still the *core idea* of JSF. The first phase of the [JSF lifecycle](https://docs.oracle.com/javaee/6/tutorial/doc/bnaqq.html#bnaqs) is *Restore View*, which builds the [UIViewRoot](https://docs.oracle.com/javaee/6/api/javax/faces/component/UIViewRoot.html), which is the root of the component tree, which is used to process inputs and generate input events (i.e. the desktop model). This is the key value proposition of JSF, since components sanitize input values in the *Apply Requests* and *Process Validations* phases before applying them to the model in the *Update Model Values* phase. 
yet no one uses JSF anymore unless they are forced to
I think one of the hopes of the increased release cadence is that organizations won't fall into this habit of not planning to update. When you know a new release is 6 months away and a new LTS is 18 months away it is something to plan for. That wasn't the case before.
If you think JSF is a crap, try to work with ADF. You'll soon change your mind. 
I feel that pain \(which is why I write in Kotlin now, if I can\). But in fairness, you could static import the functions and make calling them a bit cleaner... renderVelocityTemplate(ctx, templatePath, model) serializeObject(ctx, obj) getLoggedInUser(ctx)
&gt; I feel that pain (which is why I write in Kotlin now, if I can). I've also switched to Kotlin. My library's user base is split pretty neatly in half though, 49% Java, 49% Kotlin, 2% Scala. This was my (misguided?) attempt at bringing my Java users extension methods. &gt; But in fairness, you could static import the functions and make calling them a bit cleaner... It still really bothers me that the utility function has to take the object as the first arg. But, there's no point in me creating an API that people don't like either.
Idk if it's different in the US (sounds like that's where you are?), but at my work place (in Denmark) we have several self-taught programmers. Personally, I have a bachelors in CS with no special focus on Java (had one Java course in first year, that's all), and I had no trouble getting the job, nor do I have trouble keeping up - quite the opposite. So, in my (limited) experience, if you know what you're doing and can communicate that, you won't have trouble. 
Is it possible to get a job as a programmer without a bachelors, of course. But not having a bachelors will automatically filter yourself out of some companies, unless you have somebody personally vouching for you. That being said, you shouldn't ignore that 'unrelated field' you do have a bachelor in already. I remember we had an actual medical doctor coming to our IT classes because he wanted to take part into some IT-related hospital projects and they couldn't involve him without proper credentials. So, couldn't you more easily (and for higher pay) get a job in your 'unrelated field' as the guy that also knows programming?
Yes, because they've all been mentioned on the subreddit before. &gt; if you've been following this subreddit recently 
I guess that's why the multiple unrelated positive comments in my post got ignored. They're *really* emotionally involved in their features, and as I said, I'm trying to look past it but things like this aren't making it easy. Fine, I'll delete the post. They'd rather downvote than engage, I suppose.
Could someone explain what is happening here Function&lt;String, String&gt; foo = (s) -&gt; s.toLowerCase();
You're creating an instance of the Function interface. The two generics are the input and output types. This can be written in Java 7 as: Function&lt;String, String&gt; foo = new Function&lt;&gt;(){ public String apply(String s){ return s.toLowerCase(); } } The () -&gt;{} lamdba shorthand here just replaces a single method interface. You can just call foo here by foo.apply(s); I may have the name of the method wrong but that's the gist. 
Jsf is very difficult to use, especially for debugging and maintaining . But learning it will let u understand what is the good/bad parts in it and how to avoid similar problems in your own design
You should make programs regardless of job security, if you're passionate about it. 
I'm so sorry for you
It's ok if you hate anything related to crappy bs JS.
Does anyone use spring boot and not use profiles? 
we like to use profiles for secrets. You can just slap an application-foo.yml in docker secrets, specify the location of it with -Dspring.config.location in the run args, and enable the profile to grab the secret configs. Working pretty well so far.
Ok, so I did exactly what you are trying to do, so here are my thoughts. I got a bachelor's degree in a completely unrelated major. So I still had the bachelor's, but it wasn't in anything tech related. The career path I had been pursuing wasn't working out, so I decided to change to programming. Java was what I wanted a job in, I already knew some Java so brushing up on it and getting solid with it was easy for me. I went and got the Oracle Certified Java Professional certification, the higher level they offer. I wanted something to say that I knew the stuff because I didn't have a CS degree. Here's the thing, though, no employer knew about or gave a shit about that certification. Most of the time I had to explain to them what it even was. If you expect the cert to open doors, it won't. The value of it though is that the test is fucking hard. I had to be GOOD with the language to get it, and that skillset is what really mattered in the end. Interview wise, not having a CS degree or professional experience hurt me bad. I got ruled out again and again for that, and it was a painful process. I stuck with it though and found success with a company whose interview process was less a resume review and more a coding challenge. I actually had a chance to show how well I understood the language, and because of all the work I had put in studying it I aced the test. And then they hired me, and I've been good ever since. Tldr it's harder to do it without a CS degree but not impossible. Make sure you really know your shit and don't give up.
Side project...get cracking.
Lots of successful programmers don't have CS degrees. I certainly don't, and plenty of my coworkers don't either. It is totally possible to get jobs at the highest level without a CS degree. Getting your foot in the door will be a *little* harder, but really the hardest part is just learning the things you need to know without someone teaching you. That said, I would argue against wasting time and/or money on certificates. No one cares about them, and as far as I can tell they're mostly just a scam. Focus on figuring out what you'll need to be able to do to impress interviewers - that's what will matter for getting started.
Wiremock has been one of the most useful to me. Selenium should probably make it into any list like this too, although it can be painful at times. 
On the projects I've worked on, the main issue with profiles has been that they can't be composed well at all. You can include other profiles but those can't include more without messing everything up. 
You've just reinvented the GoF [Adapter Pattern](https://en.wikipedia.org/wiki/Adapter_pattern)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I've just moved a small app (SPA, few datatables, dialog windows) from JSF/Primefaces to Angular/PrimeNG and I'm super excited. I did it in 3 days basically copying code from PrimeNG showcase :) and it was my first app in Angular. Much less code and it's much easier to understand. But JSF has it's advantages, like in JSF you don't have to bother about declaring JSON interfaces, keeping them in sync with back-end beans. This is why I put huge hopes in Dart, they have native Angular implementation, language has good syntax and sane standard library, allows to write server-side code so front-end and back-end could share common classes. Blazor for C# looks cool too. Anyway, learning and understanding JSF was super hard for me, it has so many ambiguities and traps, I wouldn't advice to learn it today, it takes muuuch time to learn and find good practices even for simple things. Now for future projects I'll use Angular (and I prefer it over React).
We just use encrypted properties for that.
Externalize your configuration, then you don't need to fiddle with profiles.
https://12factor.net/de/config
Why not both? 
if you have the time and are interested, this is a very good introduction to lambdas basics in java 8: [youtube long but really worth it](https://www.youtube.com/watch?v=1OpAgZvYXLQ)
As someone who's moved off Java this year onto typescript it's an interesting read. I'm still not tempted to move back though.
&gt; Anyway, learning and understanding JSF was super hard for me, it has so many ambiguities and traps, OP would appreciate it I guess if you could name at least one example here ;)
&gt; It's "peak" usage was fairly small That's not true. Look at all surveys from the last 10 years. JSF is always somewhere in the top 3. If JSF was so small, why are there so many books about JSF and why are there still new books coming out?
&gt;(i.e. the desktop model). No! The desktop model is the illusion that there's no HTML and no HTTP. Some frameworks go pretty far there, like Vaadin and in the early days WingS. JSF with the navigation rules, pages with only components and postbacks for everything was going into that direction. But modern JSF puts emphasis on ditching navigation rules (action methods return actual paths/resources instead of logical outcomes), HTML first pages with components were needed (there's many plain html, body, br, p etc etc tags), and using normal Getrequests or Post Redirect Get between pages. 
&gt; Jsf is very difficult to use, especially for debugging and maintaining That's not really an objective answer still. In what way is it very difficult? Angular and reactive are very difficult to use as well, but that statement doesn't mean much, as the difficulty in using Angular is not the same difficulty as using Reactive. So, can you be more specific?
&gt; That's microservices, not the web. No, that's using services and re-using the same services for multiple clients.
&gt; That's exactly what a library is. You really think a small single file script like jsf.js with a few utility functions is the same as a huge client side framework like Angular? 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That's Java 8 syntax.
JSF is now intended to use with CDI, and was designed before CDI even existed- this is visible at every step; ViewExpiredException; validation- jsf has its own, bean validation own, they are integrated but jsf can't trigger class-level validators (I know- 2.3), then again jsf has own i18n, bval- own; necessity to manually call update after every change of model and client-side 'update' along with primefaces' server-side 'update()' quickly become a mess; super hard to create own components; re-rendering whole components or components' trees after every small change; not obvious how to write converters for entities (yeah pull data out of database again- great idea); necessity to manage both ids along with widget vars; never use constructors- only @PostConstruct; don't try to use converter in f:viewParam- just load models in @PostConstruct. Such things.
Everything over there says 1.1 you fuckwit.
Still no fix for my pet peeve. :( https://youtrack.jetbrains.com/issue/IDEA-188689 
I've seen a large project migrated from vanilla Spring to Boot and not using it, although they were going to migrate to centralized config server anyway.
I don't know if you're serious, but Java 10 was released 2 months ago.
In the past few months I've been using Compare And Set mechanics a lot in my code to improve concurrency. I haven't made a lot of measurements, but it is indeed a remarkable option compared to synchronized locking. If you're creating a lof of objects, and consider creating a new Atomic wrapper object a big overhead, I suggest you take a look at [AtomicReferenceFieldUpdater](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html), which negates this problem. As the [JIT optimizes these constructs](https://shipilev.net/blog/2015/faster-atomic-fu/), the performance for this is quite the same as Unsafe.
Yes, that's HTTP. But just because an application uses HTTP doesn't mean its a *web application*. We're not talking about JSF using HTTP to talk to internal services, because a *web browser* is the client of JSF.
wtf? Wasn't it less than a year that 9 came out? Java 8 came out almost 4 years ago and Java 7 was 4 years before that. What is happening
Six month release schedule. It was announced nine months ago and was very big news. I'm guessing you don't follow Java development very closely.
Of course not. That is not what I said at all: &gt; We're not talking about frameworks, we are talking about native JS. One does not imply the other. You're missing the point that `jsf.js` is the only JS file required by the JSF spec. PrimeFaces pulls in quite a bit more.
Shouldn't they just release a new version when there is a substantial number of features ready? Now Java verisons are going to be far less substantial and there are going to be a million of them.
That is a "named lambda", where as most are anonymous. list.stream() .map(s -&gt; s.toLowerCase()) .collect(toList()); is exactly the same as Function&lt;String, String&gt; foo = (s) -&gt; s.toLowerCase(); list.stream() .map(foo) .collect(toList()); The only difference is that the lambda has been put into a variable. The main reasons for doing this is to improve readability by using a variable name to document what the lambda is doing. Predicate&lt;User&gt; isValid = (u) -&gt; u.isEnabled() &amp;&amp; !u.isLocked() &amp;&amp; u.expiry().isAfter(Instant.now()); var validUsers = allUsers.stream() .filter(isValid) .collect(toList()); (Of course, the first example would be better as a method reference: list.stream() .map(String::toLowerCase) .collect(toList());
I dont think you want to do that in Java, when you have great support for rest services and bunch of great spa javascript/typescript frameworks :)
&gt; The desktop model is the illusion that there's no HTML and no HTTP. That's like saying that an ORM is the illusion that there is no SQL. Of course, any serious use of an ORM means knowing SQL. The desktop model means translating HTTP into UI components and UI events, which are meaningless to HTTP and which are fundamental to how JSF works. I also don't think it is any coincidence that Amy Fowler, one of the key designers of Swing, was also a spec lead for JSF &gt; HTML first pages with components were needed (there's many plain html, body, br, p etc etc tags) You are describing the UI with HTML, which has nothing to do with the desktop model.
We're talking about services that can be re-used for multiple clients, and as mentioned time and again, JSF does not exclude this. Using JSF one can build the web UI and the mobile app using the exact same REST services.
&gt; We're talking about services that can be re-used for multiple clients That isn't what we are talking about. What the OP *said* was JSF blurs the line between client and server, since client concerns like UI components and UI events are present in the server model. The fact that JSF can communicate with REST services is irrelevant in this context, because the web browser isn't using those web services.
[Teavm and Flavour](http://teavm.org)? Haven't really looked at them yet, just bookmarked to do so soon / aware of them. 
&gt; What the OP said was JSF blurs the line between client and server, since client concerns like UI components and UI events are present in the server model. In that case, I refer to the way the web was originally designed, which is the only way the web should ever work. In the original web, a server returned html, which is what JSF does.