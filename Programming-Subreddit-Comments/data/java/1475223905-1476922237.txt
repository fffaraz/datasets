JavaFX is IMO very easy to use, much more so than Swing. It is my go-to for making UIs in Java. It looks nice, and is fast. I think learning it is very useful if you plan to make Java-apps, however if you plan to make only web based apps then learning HTML/CSS/JS is better.
Why not link it directly?
It's worth learning. It's quite easy compared to the alternatives, and the tooling and libs aren't bad either: https://github.com/mhrimaz/AwesomeJavaFX If you encounter problems, there's also: https://www.reddit.com/r/JavaFX/
that was only for prioritization in terms of adapting to ART. If they commit fully to open jdk vm then yes they will. At this time theres many indications that they are committing to open jdk http://gluonhq.com/android-moving-openjdk/
LOL. IBM. 
I didn't say it was the complete OpenJDK codebase or API. The code is GPL+Classpath licensed, there's no requirement that they have to use it as is, or use all of it. I'm well aware they didn't import things like java.time.
one of the most important features is still missing: invokedynamic.
Nah, the worst thing to happen to Java was when Sun put Jonathan Schwartz in charge. He ran Sun into the ground and should have been booted. Best to worst options: 1 - Sun stays alive - Jonathan Schwartz dies. 2 - Oracle (at least they have a shit ton of money to spend on Java) 3 - IBM (though 1/2 of Sun would have quit because Sun and IBM hate each other) 4 - Google (they don't care much about standards so we would have had a major Java fragmentation) 5 - Apple? Mac only Java? 6 - Microsoft - I can't even imagine this nightmare. 
For some simple text editing, seems like JavaFX would be reasonable. Just make sure all of the platforms you are targeting support JavaFX (some linux JVMs dont)
New and noteworthy: Still fail to update from within UI due to missing repository bullshit. Come the fuck on Eclipse.
*hint* follow him *hint*
I used to think I want to work in web app UI until I start working in UI. So I would say I prefer to work middle layer or back end work.
...which is why it's misleading when people say that Google could have paid for Java. Sun wouldn't sell them what they wanted.
Spring is very well documented and very expansive. They have tutorials, guides and reference documentation that should be sufficient. If you have a *specific* problem you want to solve, set of technologies you want to use, etc. then let us know and we might be able to recommend something. In general for a simple Spring/Hibernate backed web application or API I would simply use Spring Boot + Spring Data JPA + Spring MVC. There's a metric ton of tutorials/guides out there on that (find one that is at least 2015+) and build something simple with it and you should get exposure to DI, MVC and JPA/Hibernate.
Thanks for the info. Definitely not just starting out. I've been working for a few years and doing mostly java stuff. My current job uses ADF for UI and I hate it. I am thinking of searching for a new job and want to know what people use out there so I can prepare and learn some new language in the process. I know ADF isn't that popular out there and I just want to learn something that companies actually wants.
Word. If you're using Eclipse, STS is the way to go. 
Notepad
Netbeans but I would like to have the best of both worlds from Netbeans and IntelliJ in one IDE.
Cause Java is hot right now with all the cloud stuff. Why would they give that up?
Should have included compact strings as well IMHO. 
I love JBoss and JBoss tools, but I agree. They're spreading themselves a little bit too thin with all that work on unnecessary stuff like OpenShift.
UI stuff in Java is definitely not where I'd spend limited time learning it. Most (though not all) Java stuff nowadays is web page generation. I used Swing (the java toolkit for ui) back in the day for professional stuff, but haven't used it in a decade, because other than Java IDE's there's very little GUI stuff written in Java. If you were trying to do a web page I'd say learn the java way, with the UI if you already know how to do it in C# just do it in C# and do your next thing in Java.
What about the limited AOT that was posted a few days ago? 
In other words: only Jigsaw
Apache Collections have similar functions. 
If you watch Java ONE 2016 sessions or the JEP list, there are plenty of goodies.
No promises. It was initially planned for Java 10. If you need AOT today, all commercial JDKs offer it. 
Lol I'm still on java 5 at work :( - we are "upgrading" to 6/7.
I'm glad to see a REPL
* The Java standard library already has a Optional, Predicate, etc. class. Why not use those in your library? (Except backwards compatability) * Use *@FunctionalInterface* * Use Lambdas * JavaDoc your library ~~Distribute with Maven~~
AIX/power reasons , plus the software in question doesn't run under 6 without refactoring a chunk of its 300kloc. Java 5/6 is very widely used in Banking still.
&gt; and leave Eclipse the last man standing IntelliJ?
Sounds like someone there loves running software with known security holes. Do your company handle a lot of money and would you mind giving us a couple of urls to where this software runs?
I meant for completely free IDEs. I'm aware of Community Edition, but it doesn't stack up against Eclipse or Netbeans lacking support for either Spring, Java EE, etc. https://www.jetbrains.com/idea/features/editions_comparison_matrix.html
"you won't believe #7!!!" /s
&gt;Isn't Javas whole steez to be super backwards compat? I'm very curious about this too.
But the Java fanboys will always blame Google for the whole situation.
That actually makes me side with Google. Why shouldn't they be able to implement their own subset or superset? 
Dumb question but who/what is jshell intended for?
I do only Java EE (-ish) at work, but I've never used any EE-specific features of either Eclipse or Intellij. I'm completely unfamiliar with them (them = the features). What does "support for Java EE, Hibernate, etc" mean in terms of IDE functionality?
For real world large enterprise apps there are nearly always some breaking changes.
It autocompletes a lot of stuff, and reads and understands the configuration files.
Because it forks the ecosystem and burdens developers wanting to write portable code. Why it is ok to bash Microsoft for not doing C99, but it is fine for Google to fork Java?
&gt;Because it forks the ecosystem and burdens developers wanting to write portable code. And as developer I would like that all the mobile platforms use the same programming language and offer the same set of libraries but this is not the teletubbies world. There were business and technical reasons to not do so and as long as they are open and clear about it (and from what I saw they were pretty clear about the differences in the platforms) I don't see the big problem. And to be fair the intersection was way way bigger than the differences between the sets. &gt;Why it is ok to bash Microsoft for not doing C99... This is a strawman. I don't have any problem with that. They were pretty clear when they said that in general they don't give a fuck about full C99 support as long as the paying C++ customers don't care about it. They implemented the most requested features. &gt;... but it is fine for Google to fork Java? I don't have any problem with that just like I don't have any problem with C++ compilers not implementing the full set of features as long as they are clear about it.
What makes you focus so much on price rather than on added value and ROI?
I was under the impression that Red Hat was shifting focus to Eclipse Che [here](http://developers.redhat.com/blog/2016/06/27/red-hat-eclipse-che/) and away from classic Eclipse. I really wish they gave a clear direction of where they want to go.
I know right? Spark. Hadoop. Basically every useful Java library ever. Enough with the false starts, Apache, give us something useful!
Someone needing a quick and dirty way to run some Java code. quick unit tests etc..
You have plenty of choice for backend work. If you want to stick to the JVM where you can reuse some of your Java knowledge, Scala and Clojure are certainly worth a look and will open up your horizons drastically. Professionally, C# will be easiest to pick because it is very much like Java and gets lots of use in Windows shops. Other than that, there's still plenty of fast-and-loose action happening in the scripting world, with NodeJS and Python going strong. Finally, you can look at next-gen compiled languages such as Rust, Go, Nim and Crystal, but knowing these will probably not land you a job (yet). 
JPA pagination, with setFirstResult, setMaxResults. no no, NO NO NO!!! It is this kind of stupidity why we end up with slow systems. Hint, the DATABASE still has to loop around reading every row, even if you put setFirstResult(1,000,000). Do not do it... Instead, find a way of using an index's to look up the next page.
I think its more about libre open source, than about price. Some of us don't like to live in cages.
Could very well be using a custom JDK, i.e. IBM's 
...and if somebody doesn't fancy generated code then there's https://github.com/tguzik/valueclasses
It is. The immutables framework gives you a lot of additional stuff for free - JSON serialization and deserialization (including some support for inheritance), lazy evaluation, checkers (so that you can't build an object with invalid data), additional control over the code generated (stylistic, visibility...), and more. Honestly it boggles my mind why Google hasn't retired AutoValue yet in favor of the clearly superior project.
for those of us here using gradle as a build system, u/jakewharton and colleagues from [Square](https://github.com/square/) wrote a few nice libraries for these needs such as: * [AutoValueAnnotations](https://github.com/JakeWharton/AutoValueAnnotations) * [JavaPoet](https://github.com/square/javapoet)
well his English is way better than my Japanese, alas I don't think I could take 50mins of it... 
Whats the benefit of doing this other than changing the method signature and relying on unit tests? This seems like you would end having to make a lot of new classes and tests for them as well.
Primarily not relying on code generation (which may be a boon if you have an established build pipeline and/or static analysis tools) and the value classes being, in the end, plain old java classes using a plain old library. The latter may make it easier to throw extra methods on the value classes or implement some specific behavior, like caching most used values and so on.
Try /r/mentors
I created this ticket for each of the projects, only lombok has yet to decline it. (I'm 99% certain they also will decline it) It sucks that it's being declined because it's a showstopper for us, it's simple to implement and I'm not the only one who's asking for it. STEPS TO REPRODUCE Call final builder step (usually .build()) without providing required arguments EXPECTED RESULT Compiletime error ACTUAL RESULT Runtime error MISC Instead of returning the builder on all steps, return the next required argument. When there are no required arguments left, return the builder. See eg http://blog.crisp.se/2013/10/09/perlundholm/another-builder-pattern-for-java 
What?
Racist political joke. 
/u/nfrankel should consider that type safety isn't what matters. What matters is compile-time safety. Sure, `@SuppressWarnings("deprecation")` has a string. Normally that would be a bad thing. What if the string was mistyped? That's the rule. However this is an exception. Because the compiler actually takes that string into consideration. The compiler warning either goes away or it doesn't. So it doesn't matter if it's mistyped. You're still going to know if it is. I think strings in annotations are fine. Consider `@javax.inject.Named("foo")`. This is even more arbitrary than `@SuppressWarnings`. But it's trivial to write an annotation processor that validates the correctness of the string at compile-time. This is what [Dagger 2](http://google.github.io/dagger/) does. If `"foo"` isn't declared somewhere else in the dependency injection object graph, compilation will fail. So it's entirely unnecessary to define a zillion annotations. All it does is bloat the jar.
&gt; Honestly it boggles my mind why Google hasn't retired AutoValue yet in favor of the clearly superior project. [Immutables](https://immutables.github.io/) suffers from the same problem as [Project Lombok](https://projectlombok.org/), which is that it generates synthetic *APIs* rather than limiting itself to only generating synthetic *implementations*. For example: @Value.Immutable interface Foo { long bar(); } Will generate code so I could call `ImmutableFoo.builder().bar(1).build()`. Where did that API come from? That's not obvious from looking at the code. AutoValue makes a different tradeoff between magic and verbosity: @AutoValue abstract class Foo { abstract int bar(); static Builder builder() { return new AutoValue_Foo.Builder(); } @AutoValue.Builder abstract static class Builder { abstract Builder bar(int value); abstract Foo build(); } } This way there's no surprises. If you define Foo in your library, and I'm your user with no familiarity and code completion is 100% guaranteed to work in IDEs. Please consider that IDEs have traditionally lacked robust support for annotation processing. With AutoValue, the worst thing that can happen is a red squiggly line beneath `AutoValue_Foo` and that's only of concern to the author of Foo who herself has *chosen* to use AutoValue. The users of `Foo` will never need to be concerned about configuring their IDEs; which is important, because they didn't necessarily opt-in to annotation magic. (I also know several Googlers who have spent a great deal of time making contributions to Eclipse to help those squiggly lines go away entirely when using annotation processing.) These same problems also apply to the wide variety of other toolings which are typically used with Java, such as grep. It's why the APIs have to be explicit. There are also [slides](https://docs.google.com/presentation/d/14u_h-lMn7f1rXE1nDiLX0azS3IkgjGl5uxp5jGJ75RE/edit#slide=id.g2a5e9c4a8_00) where Google's Java Core Libraries team talks about why they made these design decisions and the alternatives they considered. &gt; The immutables framework gives you a lot of additional stuff for free - JSON serialization and deserialization [...] AutoValue is very conservative in only offering what it knows it can do perfectly and universally. The reason why JSON \*serialization isn't included is probably because it's not obvious how such a feature should be written. Do we generate the JSONifying code without any library? If we do that, we repeat a lot of JSON logic for every single generated class. If we generate code that calls a library, which one do we choose? Jackson, Jackson2, GSON, or SimpleJSON? All of them? How do we make sure the synthetic code doesn't introduce a dependency that the *written* code didn't introduce itself? If the dependency only came from synthetic code, it would be astonishing and most likely break tooling. Particularly Google's build system Bazel, which forbids the static linking of transitive dependencies. So there's a lot of difficult choices and potential risks here. And in all fairness, Google generally prefers Protocol Buffers over JSON :) But AutoValue provides an [extensions API](https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/extension/memoized/MemoizeExtension.java) so the open source community can make its own choices. Users can start their own GitHub projects adding all sorts of interesting features to AutoValue. This is a non-monolithic design that ensures the end-user will only pay for the features he needs; and as far as I know, is not something that's being offered by Immutables.
Although this approach would have the benefit of typesafety I wouldn't call its absence a showstopper. If you test your code a runtime error in this case is absolutly fine. The presence of an argument doesn't say anything about its validity either and it's very hard to check the validity of input values at compiletime (You could go the scala route and create caseclasses for everything, but I don't think that's feasible). I also think you might be underestimating what it means to implement this approach in a general way for codegeneration. You have to generate a builder class for each required argument. If an argument is optional you have to generate two different classes for each following argument. For multiple optional arguments the amount of classes grows exponentially. From a usabillity standpoint you loose the abillity to reorder the arguments of the builder (or you generate classes for every permutation of arguments). With immutable builders partial builders can be passed around as a partially applied function of sorts. If you lock the order of arguments that usecase is somewhat limited. The only plus I could find is that this approach runs slightly faster than a traditional builder. The reason beeing the checks if an argument is already set are moved to compiletime. Although it uses slightly more memory since more objects are created. Running them through JMH (with 4 argument builders) yields basically the same result though. All in all I think this feature is way more trouble than it's worth.
&gt; http://blog.crisp.se/2013/10/09/perlundholm/another-builder-pattern-for-java Wow that pattern for using interfaces to constrain methods in the fluent builder chain is brilliant.
You are right, you don't end up with more classes but rather the interface gets more cluttered.
Consider joining me and and others in requesting for it to added. * https://github.com/google/FreeBuilder/issues/196 * https://github.com/google/auto/issues/370 * https://github.com/google/auto/issues/385 * https://github.com/immutables/immutables/issues/438 * https://github.com/immutables/immutables/issues/450 * https://github.com/rzwitserloot/lombok/issues/1202
I think you are right in the case the strings have matching `hashCode`, then it's O(n), and string equals is pretty expensive so that's a O(n) with a large constant. So since big-oh is worst case, I guess you could say that switching on strings is O(n), but it's a bit of a stretch. Java has two kinds of switches in bytecode, one called `TABLESWITCH` for continues integers (0, 1, 2 etc) used for enums which is O(1), and one for sparse integers (like string hashcodes) called `LOOKUPSWITCH` which does a binary search and as such is O(log n).
Hmmmm ðŸ¤” I've to say I used this quite often without seeing much if any performance issues, but always looking for better ways to do things so I'll look into this. Thanks!
If there is only a few concurrent users, then there is no issue. If you have a facebook game with 100's of players hitting your database, then it makes a *big* difference. Its only by the power of multi ghz pc's, and SSD drives, does this become a non issue, especially if you use this to develop. Of course once you put your creation into live, and it gets hit many times, then you start to see slowdowns.....and people start to say you should have gone NoSQL instead :-o 
&gt; JDeveloper from Oracle Which is a Netbeans RCP app...
Nothing to worry about. The dependencies go to the [JBoss repository first](https://repository.jboss.org/nexus/content/groups/public/org/hibernate/hibernate-core/5.2.3.Final/), and there's a Cron job that syncs them with Maven Central. They will be available on Maven Central as soon as that job starts to do the sync. Meanwhile, you can just use the JBoss repo if you want to get a preview.
Apparently useless. 
Thank god, those included Hamcrest libs were such a bullshit.
&gt; Your comment doesn't add value when somebody reads this but doesn't know why You're right, sorry about that. I get that people may expect that feature so they can test against external libraries while not paying the price to abstract from the final classes of the said libraries. I get it and I agree that it *may* be a rational choice to make wrt external libraries. Yet Mockito-not-mocking-'final' was also a good point for identifying ugly internal design choices and helping promoting uncoupled internal design. I insist on internal: this is not a criticism on libraries with API of final classes and their use. Let me formulate this otherwise: I've seen some shitty design and used this 'limitation' to advance my agenda. I might rather have better communicated on the reasons why I expected an uncoupled design instead of relying on a definitive argument "you can't hence you shan't". 
I'll have a go at it. Typically, a final method or class is the author's way of saying this implementation should never change. And shouldn't be messed around with. Mocking away a final method goes against the original authors intention. All of the above assumes the original author of the final method was sane and competent. I've seen people mark classes as final incorrectly thinking this will make their class immutable (It won't). If you're working on a legacy system or don't have the ability to refactor the final method or classes, I don't think mocking away final methods or classes is that bad. If it is a green field project, I would question your design. 
So, you folks will be touching my finals now? [Shame on you](http://i.imgur.com/vkNk0pg.jpg)
I wish that support for mocking static method calls was a thing. PowerMock does it.
In this case, I'd prefer testing the integration of the abstraction with the abstracted library. 
The biggest gotcha for me today was the any*() methods (except any()?!?) no longer matching with null values. It was useful (if a bit lazy). It also causes things to fail in non-descriptive ways, but that's always been a fault of the way the mocking works.
For the purposes of string switch search, the lengths of the strings are considered constant and therefore not taken into consideration by big oh, as you probably know. Also I didn't know that the JVM had an a literal instruction for doing binary search. That's so cool.
I would help you get it into AutoValue, but it might not make sense for AutoValue, because you would have to write those intermediate interfaces yourself.
&gt; It also causes things to fail in non-descriptive ways, but that's always been a fault of the way Mockito works. FTFY
You must be a Spring developer :)
*golfclap* I said what I meant, and the "fix" doesn't change the meaning.
My fix was to hint that there are other mocking tools that do not make "things to fail in non-descriptive ways". EasyMock throws an exception immediately on any unexpected behaviour, Groovy mocks put you in charge of your mocking strategy so you can make the error as descriptive as you would ever desire. It also depends on the unit tests runner. For example, Spock's default fail message has all the details about the failed assert, including toString representation of every element found on the line.
Why? I don't think anything in Spring is final.
This is really great. Awesome tip to make your code maintainable
You, Sir, are a hero. Will check out as soon as github has resolved the outage they're currently having.
&gt; EasyMock throws an exception immediately on any unexpected behaviour EasyMock keeps a rather annoying static state that can cause Test A not cleaning up correctly to fail Test B. So I personally would really recommend not using it. 
&gt; Immutables can do implementation class hiding [...] It's really cool that the Immutables authors already thought of this. I hope the authors of Immutables will consider making implementation hiding the default recommended approach, and move the documentation for doing it with interfaces in a [dark room](https://www.youtube.com/watch?v=goEeygcowwA) in the basement where no one will find it. Such a policy would be a terrific service to the many developers using APIs that were written by developers using Immutables. &gt; AutoValue's extension for GSON is actually stuff quite inspired by Immutables after Ryan Harter and auto folks were able to evaluate how it's done in Immutables to decide if they need something similar Reasons like that are why I'm really happy that Immutables exists. Because it's able to be experimental, it gets to invent all the new ideas. Then the judicious projects, which are unoriginal and lag behind on progress, get to absorb the best ones while learning from the mistakes. &gt; As a side note, the authors of Immutables reported issues and contributed to Eclipse so JDT contains those commits too It really shows good character in a developer when he or she puts in the additional time and effort to make contributions to other open source projects.
&gt; Please, don't. This comment makes no sense at all. Even for internal code it can make perfect sense to want to make something final and still want to be able to mock it. If anything making stuff non-final or default access instead of private just because you want to be able to mock it is simply bad design. I'm against making stuff final 'just because' because it prevents easily mocking stuff but a plain generic "please don't" isn't useful at all. 
&gt; Seriously, don't mock types you don't own. Only Sith and junior developers deal in absolutes. For unit tests it often makes perfect sense to be able to mock stuff "I don't own". 
I'm personally using the "sandwitch pattern" https://twitter.com/ImmutablesOrg/status/740826987883814912 where bytecode only references user-written type. Sorry for diverting from "auto" topic, will go back to my cozy dark room )
The batching collector is pretty neat when you need to do any kind of batching on a collection: https://github.com/omnifaces/omniutils/blob/develop/src/main/java/org/omnifaces/utils/stream/ForEachBatchCollector.java Though simple, mapToType is pretty neat: https://github.com/omnifaces/omniutils/blob/develop/src/main/java/org/omnifaces/utils/stream/Streams.java#L76 Name based message format is also quite handy: https://github.com/omnifaces/omniutils/tree/develop/src/main/java/org/omnifaces/utils/text And stuff like isEmpty, isOneOff and coalesce (https://github.com/omnifaces/omniutils/blob/develop/src/main/java/org/omnifaces/utils/Lang.java#L151) should be in the standard Java library. There's Objects now, and that's a start but it's quite limited.
I like it the way it is today. Wanna do some mild hacking to test you stuff: Mockito. Nobody complaings about it and it's easy to use. Want to do some extremely nasty shit to test your legacy code: Power mock You will heard a lot from everybody but they all know it's the only way besides refactoring your code to make it testable, which nobody want to be responsible for. Please keep mockito as a safe harbour for mocking. 
indeed pretty neat, great find.
&gt;back office project which is not critical. Sounds like you've just made the choice of using a guava queue.
The main factor is how much operational complexity and risk will be added by using an external queue service (eg: Rabbit) compared to the value your service provides. The only issue with the home brew approach is that failure behaviors aren't always easy to predict / control. It might be worth having a look at ActiveMQ, which seems to be embeddable.
&gt; Just don't learn Swing. That statement does not make sense at the current state. Even though Swing is in the process of being phased out, it is far from obsolete and thus a valuable skill to learn. There is plenty legacy code relying on Swing and there will still be demand for Swing capable developers in the next couple (5+ on an extremely pessimistic estimate) years. Legacy code is where the big money lies as there are fewer and fewer people able to maintain, troubleshoot and implement new features. Just think about the demand of COBOL developers that still exists. Sure, there are fewer positions now, but the open positions are extremely well paying because it is increasingly difficult to get skilled people.
If you need a distributed queue, you should use a real queue system like rabbit. It's actually pretty simple from a code perspective. If you're running 1 server, guava.
Hazelcast perhaps.
When coming into any existing project, I find and destroy mockito-all and replace it with mockito-core.
Yeah, there's this odd, but functional, mental line that gets crossed. Powermock is a great tool, but it's definitely the sign that something's amiss with your code or that someone's using a sledgehammer to crack an egg.
Were you using PowerMock, perhaps? It makes it easier with its `replayAll` and `verifyAll`, but it has this shared global state to know them "All". EasyMock on its own does not do anything of the kind.
Apache Kafka
I have something even better [here](https://medium.com/@stefanreich/lets-make-a-wiki-for-our-a-i-e341eb711394).
IIRC it slows down the code but there are times when it's nice to see the parameters output in the console.
That's genius! Have Google pay infrastructure costs with complete transactionality and persistence
Agree to this. Lot of complains are moving to this model
Seconded, Chronicle Queue is easy to embed and write for. Persistent and very fast too. You also have network options if you ever need them.
"Not critical" is rather vague. If losing in-memory data every now and then is fine then that's the easiest solution. But how 'bad' would this really be. Also; what kind of volume do you expect? Are the contents of the queue ever going to be an issue memory wise?
&gt; Distribute with Maven Actually; please don't. The last thing we need is people using this in production. There is no need for this library, it goes against best practices and the actual code is pretty bad (just look at the .delay function, it kicks off a whole executor for every call).
Wow that's cool. You wouldn't even be able to build something like that on top of [BasicAnnotationProcessor](https://github.com/google/auto/blob/master/common/src/main/java/com/google/auto/common/BasicAnnotationProcessor.java). I'm not sure if you hack on annotation processors, but if you do, here's a fun idea: Write an annotation processor that generates code for arbitrary type coercions, when provided a set of static methods defining basic type coercions. (Imagine static methods as being a set of functions defining a DAG of input -&gt; output types. Then you generate an implementation for an interface. It could be useful for HTTP request parameter extraction. I don't know.) What would the time complexity be of generating transformations? What would it be if you supported polymorphism? What would it be if you supported type parameters?
Nice work man
I meant batch.. was thinking about boot. I saw the link to a spring batch example. However I didnt see a comparison as the title sugests.
I can't read that... Is it even English?
Go through coding katas to get warmed up. There's probably a ton on an Uncle Bob site. On that note, read Clean Code and Clean Coder if you haven't already.
Uncle Bob? I'll take a look at Clean Code and Clean Coder.
The author of those books. https://en.wikipedia.org/wiki/Robert_Cecil_Martin 
Please use issue trackers https://github.com/google/auto/issues https://github.com/immutables/immutables/issues to submit feature requests, if folks will like the idea PR would be welcome
https://www.hackerrank.com is a very good site for practicing different types of problems ranging from data structures to algorithms. You can test your code solution directly on their online editor. 
Thanks, that's great advice. I will do that. How does the gang of four book compare to HFDP? I have the latter but not the former.
If they're using Java8: Get accustomed to the stream API. If you know of any frameworks they're using you can do some related tutorials.
Relax, get plenty of sleep. Save all you're energy and worrying for when you find out exactly what you need to know. 
I would look over the Object Oriented paradigm theory just to get some vocabulary that may be thrown around in design meetings or just general discussions. I would also look at the different software life cycles, and after you figure out which one the company uses, learn that model inside and out. Most likely it's an iterative life cycle, or some form of Agile, if they're trying "new" things.
IMHO if you've got HFDP, then you aren't missing much from GoF
Drink. A lot. Show up for your first day reeking of gin and cigarettes. oh, you said Java not DBA, SORRY.
I'll third this with a But... If Speed isn't super important and you are using Spring use RabbitMQ If you need to mix with other libraries, Kafka (It seems world + dog has some type of Kafka integration). Kafka also requires Zookeeper.
Yes. Logging in lets you experience more than just the one "problem." Also keeps track of various stats, too. I really enjoy trying to solve the same in different languages just to see how the solution might differ.
Learn how to use your IDE's debugger. This is the most useful skill you can have as a Junior developer. If you know what IDE everyone on your team uses, download it and familiarise yourself with the UI. Apart from that, I wouldn't really worry much. You got the job, so they certainly think you have something to offer. 
Write an app from scratch that's a miniature example of your work application. Use the same build tools, IDE, libraries, etc. You'll learn a lot by doing it from scratch. You'll be able to fully understand your little application, whereas the real application is likely to be large and very confusing. It's probably layers of old code, laid down like sediment. Of course, you may need to find out more about your work's application before you do this.
like it!
That's good! Furthermore, if it's a big software project with multiple developers, they're most likely using a version control system and a build system. The most popular VCS is Git, so knowing the basic structure of how it works would help. Regarding build systems, there are many that could be used, so I would first find out which one they use. The one that's popular and that I'm familiar with is Gradle, very helpful with large scale Java projects.
Yeah, unfortunately. I'm trying to glean from Linkedin profiles what it is, and it looks like the technologies are Java EE (which I hear no one uses on new apps), JSP (also not used much), Tomcat, Eclipse, jQuery/Javascript. But That's a lot of guess work.
This is one of the more sensible comments in this thread. 
Well, as much as I like (and hate) Gradle myself, I would say that Maven is the *de facto* standard for build/dependency management in the Java world, for better or worse.
I'd say if you don't already know OOP you're gunna have a hard time writing Java...
Try out IntelliJ, every Java dev that tries it can never go back to eclipse... But given that if your colleagues are on Eclipse will be easier for them to help if you are too. But try it still! 
Nice post, thanx for sharing!
Haven't tried it, J2EE at one place for a while but not JEE yet.
But keep in mind, we also need energy. Have you tried methamphetamine? 
Really cool concept
Definitely, I've had six jobs in the last few years, never seen gradle, always maven.
Can't turn it off quickly, and it's low class. Cocaaaine!
Thanks for the fix. It was strange to see a comment "Distribute with Maven" for this library. Kind regards, Valentyn
&gt; Didn't Oracle EoL their Java 6 VM a while back? Yes, and no. Oracle EOL'ed public releases for their 6 VM a while back (about 3 years ago). They are still supporting 6 if you have a contract with them: http://www.oracle.com/technetwork/java/eol-135779.html. Personally, I would suggest moving away from 6 at this point. It's old, isn't being very actively developed. It's missing major features and has slower performance than the latest VMs. Even 7 has been End-of-Life'd by Oracle. We are maintaining OpenJDK 7 too, but we still suggest people move off of it. Oracle does a very nice defensive thing, though. They remove the deployment stuff (applets, javaws) which are the biggest source of vulernabilities when they switch to extended support. OpenJDK doesn't include them, at all. There's an external project, Icedtea-Web, that develops these deployment technologies. &gt; Are there recent OpenJDK 6 releases with bug fixes? Yes. It's 99% security fixes (and backports from OpenJDK 8 needed for those security fixes). Our most recent release was a few months ago: http://mail.openjdk.java.net/pipermail/jdk6-dev/2016-August/003596.html and we will do one to match up with the upcoming October Patch update release (CPU). Our recent releases are available at: https://java.net/projects/openjdk6/downloads?field=date&amp;order=desc Older releases (from when Oracle as maintaining OpenJDK) are available here: http://download.java.net/openjdk/jdk6/
The worst I have seen is probably this one piece of legacy code that has some individual methods in the 1.5-2k loc range. Just spaghetti code full of switch statements, if-else blocks, other methods jumping back and forth, branching irregular dao usage. 
We did a good amount of java in university, and I've used it in my spare time cause I really enjoy it (shock!) 
This is very accurate and I wish a couple of junior engineers I work with would do this more often, especially bullet point #2. Don't feel stupid or inferior for asking questions. We all had to start somewhere. Just be willing to learn. 
I've found conceptual knowledge to be next to useless. Without context they are just vocab buzzwords and such. I learned more in my first week at work than 4 years at school. Sure, I know the 4 major oop concepts (inheritance, polymorphism, encapsulation, and abstraction) but it's not like knowing what they are really did much other than make me sound good in the interview. Sure, it's nice to read up on MVC but until you spend a few months messing with Spring/Rails/Django/ASP you can read all you want and still have no clue what to do on your first day. I would say there is not much you *can* do to really prepare that you haven't already spent the last 3-4 years doing. 
Indeed - read [Effective Java](https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/) I also highly recommend reading [Code Complete](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/B00JDMPOSY/). Clean Code is good, but Code Complete is much more thorough.
J2EE is old and not used on new apps. JEE is the newer version that might be used on new apps. Jsp is used all the time. The idea that it's "outdated" is empty Thymeleaf marketing. Most places use jsp, and it's the most likely think you'll use for the web pages. The best thing to do is just ask them, if you can talk to a direct boss or developer. They know exactly what they're using. Sometimes you have to dig through what they're actually using versus what they like to claim they're using I guess. 
&gt; Any time you are confused about how something works, ask a team member. This is pretty much the best advice I read in the last couple of days. Also, there's no point in being scared of looking stupid when you ask questions about other people's code - hell, I've had times where I was barely able to read my own old code, it'd be a miracle if anyone else would look at it and instantly go "ah, that makes sense". Five minutes of explanation takes ten to twenty minutes of time in total, shared amongst two to four programmers. Figuring stuff out yourself will likely take at least half a day, that's four hours or more - so not asking wastes upward of three hours of time, which is not efficient at all.
IDE as an integral part of the build process? That sounds broken. 
Get good at encapsulation. Seams and interfaces and knowing the right place to test. Being sure you've only changed one thing at a time is an invaluable asset. Learn test strategies and frameworks like mockito, hamcrest, assertj. Get familiar with build systems like maven and gradle.
 From a senior developer: - if you start, you MUST **pair with a senior** on the team, you will pick things up at a mind dazzling rate, the better senior the more lucky you are - programming skills: concepts of dependency injection, unit/integration testing, clean code and whatever that is important at your project (e.g. java 8 streams) - developer skills: know about continuous integration/deployment, agile methodology, TDD - social skills: first figure out what is important to know about and then go ask a team member, try to blend into the team as fast as possible (go eat with them etc.), be very modest about yourself, most seniors don't cope well with juniors that bragg - if you see something new, take some time at home to read 10 minutes about it; really, if you read 1 tutorial of something you know more than 90% of the developers on that topic It all depends on what project you are on, but with this 'standard' stack you should be able to go anywhere: - **Java 8** with streams (@see venkat talks for the streaming api) - **Spring** for dependency injection (first chapter of probably any spring book, just understand dependency injection and basic annotations like @component, @autowired) - most mainstream projects use either spring or **JEE** but the annotations and concepts are alike - **Maven** for building and dependency management (mvn clean install, -DskipTests, adding/removing dependencies) - **Hibernate** for persistence (as implementation of JPA2) (understand @ManyToOne, @OneToMany, @ManyToMany) - **Git** for version management (git pull, git add -A, git commit -m, git push) - **Intellij/Eclipse** for development (nothing really to study, but learn the shortcut to open a file at minimum, you will need it all the time and know how to use a debugger/remote debugging) - **Tomcat** for deployment unless you need a JEE stack - **Jenkins** for building your project You should not focus on algorithms, threads/concurrency, io, performance optimizations, the jvm, etc. if you are just starting on your first project. You will learn them when they become important and you will not need them in your first couple of years. That's why you have seniors on your team. In the IT a lot of people are fanboys and will tell you to use framework x, or language x. Focus on the basics until you feel comfortable to wander around and make your own opinion.
Java Signal Lights Project
I would say - sleep well. I was quite stupid and discovered after few first months that sleeping 4hrs/day is not that great as it was back in highschool. Now 7hrs is not enough sometimes. Yeah, I think you should focus on great sleep, mostly.
To open to the table of contents, rather than in the middle of an article, [this](http://www.javamagazine.mozaicreader.com/SeptOct2016/Twitter/27/0#&amp;pageSet=1&amp;page=00) is the link.
Use a good IDE (I recommend Intellij). Learn to navigate code to discover how things are connected; this will help you understand the bigger picture in your projects. 
EDIT: What I'm trying to say is, the first example is a lot messier to me where as the second example is a lot neater and simpler to understand for me (a beginner at coding). Maybe it is better to do it the second way.
WUT? You ommit closing parenthese and You call it "readability upgrade"? This code will not even compile. 
This is help with **Java programming** and thus should be posted in **/r/javahelp** as is indicated in many places in this subreddit. Please, before posting there, read the [**Posting Guidelines**](https://redd.it/48eykt) and also [**Help on how to post code**](http://www.reddit.com/r/javahelp/wiki/code_guides) **Post removed:** Programming help ---- **FYI:** Java has strict [**official Code Conventions**](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) that dictate how Java code has to look. Your format violates the conventions and thus should not be used. Also, try to debug larger code in your format - you will go crazy. I guarantee that. Everybody should write code in such a way that it is easy to read. To achieve this, whitespace, line breaks, and indentation have to be used. It makes the code easier to read, to understand, and to troubleshoot.
It was an example...
Thanks for the reply, I don't mind being pushed back, id rather just get straight into understanding java and learning it and actually putting my practise to use ASAP. Thanks for the tips though I really appreciate it :)
The funny thing is that the fans and zealots always want "their" tech to ultimately dominate, but when it eventually would and would be the only option out there, there would be no more competition and it would likely wither. See IE 6, and to a lesser degree see Intel &amp; AMD. Intel fans always wanted AMD to go away, but now that AMD is largely away in the high performance CPU space, people complain that Intel is not innovating there because of lack of competition...
&gt; The Java programming language introduced functional programming constructs beginning with Java 8, released in early 2014. There are subtle differences in the ways Scala and Java support functional programming, and the argument can be made that Scalaâ€™s approach is superior. But, Java has surpassed Scala as the preeminent functional programming language, because programmers already know Java. This claim doesn't make sense. Java is still *far* from a functional language. Having lambdas and streams is not all it takes. I won't deny the idea that Java is going to take a chunk of Scala's userbase due to the Java 8 improvements. But I don't think Java is going to assume the role of a functional programming language any time soon. If you want to do FP on the JVM, you should still use Scala. This just puts up for debate the merits of FP, and whether Java 8 provides the minimum useful features of it.
IMO the main reason to favor another JVM language over Scala is build time. Scala is just plain slow. I have time to write 10x more code in Java while I'm waiting for my Scala app to build and start or for SBT to hot swap shit.
I'm assuming you're using the rebuild on change feature - `sbt ~compile`?
I have a pluralsight account through my employer and I think it is really good stuff.
Yes. It's still quite slow compared to other languages. Scala is nice since it supports live changes of method declarations and other program metadata, but aside from that pretty much all the other JVM languages have rebuild on change functionality. Most of the time the rebuild on change process in Scala takes about as long as just restarting a plain old java app. 
Should read "the rise and fall of java"
Very different technologies. Ibm mq is a very mature product that runs on every OS including mainframes, unix, Linux and performs transactional Store and forward as well as data transformation. Rabbitmq is just a queuing technology for Linux systems. Although similar the use cases would be very different 
https://ideone.com/ is my favourite for quickly testing code snippets. It supports over 60 languages. pastebin.com and gist.github.com are good for sharing code that doesn't necessarily need to be edited. 
Put it on github if you want people to be able to see the code. If you want others to run your arbitrary code on their own machines then I don't think you'll have much luck.
No offense but what is the purpose of this? No one should be using this code when the JDK has an implementation of the RSA algorithm inside it that can easily be used for signature or encryption. There are also many other commercial and opensource crypto libraries (JSS, Bouncy Castle, IAIK, RSA Crypto-J to name a few) some of which are FIPS approved.
This is an interesting article However, I think there are some things that are true and some others false &gt; Functionnal is easier to debug, easier to test, and easier to re-use. This a myth. It is easier to modify the content of a for loop code because you can easily interact with the caller than which a functional programming style. Debug often requires to temporarily modify the code and this is hard to do with functionnal programming. &gt; Unlike Java, Scala has a flexible syntax, and typically offers many ways to achieve the same end result. The Scala community seems to spend a lot of time arguing about which of several functionally equivalent solutions is the right one. I think is exact. There is the same kind of debate in the C++ community. &gt; Scala version of a program will usually be five-10 times shorter than the equivalent Java program. This is not an advantage. The size of the code does not really matter. The readibility is much more important. Otherwise everybody would write code in Prolog. &gt; Scala is uniquely suited for development of DSLs, thanks to features such as pattern matching, syntactic flexibility, and operator overloading. This is exact. That's a big advantage of Scala. People should write the DSL in Scala and all other parts in Java. 
It sounds like you only compared it to Java, not other languages in general. C++ for example, especially with optimizations is painfully slow, but it's used all over creation. As an aside, Intellij recompiles my Scala code as I save and it rarely gets in my way. 
The fact of the matter is this - Java, for all its detractors, *is*, in my opinion, a great language. It succeeded, just like C++ did. And both of these languages were designed by people who knew what they were doing, and it shows clearly in the presence of a strong unifying architecture in each language. The same, sadly, cannot be said of a large number of languages that basically started out as research tools, and were kind of retconned into languages from programmers. 
They interviewed and hired you, hopefully they know where you are at even better then you do. Don't worry too much about cramming on Java tech before you go in there. Go in humble and ready to soak up knowledge.
Both are options. Java is not. Edit: After some downvotes, I realize I should clarify; Java is a fine option. It's just not an option for doing FP.
Compile/build time is one time payment. The runtime performance is what you should be after. Scala has complex type system - it takes more time to compile, giving you better type-safety in return(which also can give you better performance). Plus: it is cheaper to pay for longer build time instead of fixing bugs found in runtime (whereas the compiler could have found them)...
Interesting form of division (FTA): int result = number1 - number2; 10/2 = 8!
lol, you gotta the point, it's not for redistribution or something like, just a demo for how it works in simple code.
Java hits the right spot between brevity and readability. Anything more compact is barely understandable and anything longer would be too verbose. Perhaps they could add Val as is currently being proposed, and the lambda support is awesome. But the key is not to overuse it.
Scala has a number of good attributes: it's expressive, it's fast, it's stable, it can make use of the JVM universe including Java libraries transparently, and it has a dedicated/active community. Languages about which you can say much less have survived much longer. Scala isn't going anywhere. If this article touches on any truly salient point, it's that Scala requires some non-trivial study to really leverage it's power. Some of it is syntax, but a lot of it is conceptual things that don't have transparent value to the uninitiated. I was lucky to have found Haskell before Scala. By the time I came back around to Scala I was in a much better position to appreciate what it does. 
I think Scala the language has only little more inherent language support for immutability. Your point about Java just as well applies to Scala. Immutability is optional. In Scala it just is the prefered way and the brief syntax does not penalize it (val x vs. const int x), while Java is just getting there. In fact there are weirdly some Scala parts that are more mutable than in Java, e.g. variables captured by lambdas. I would say it's the immutable collections (and the implementation attention they were given) that encourage immutability out of the box, but there is nothing first class about that, and can be covered to some extent by Guava in Java. Implicits are indeed very powerful, but if overused can easily lead to code that is hard to understand and debug, especially since IntelliJ still has problems dealing with nontrivial implicit resolution. Scala provides more options than Java, which is good, and these options allow a nice emulation of Haskell style type classes, but maybe those should be offered first class anyway. Also, neither type classes nor immutability are relevant to determine whether a language enables "real FP". ML dialects don't have that restriction and neither does Scheme. Mutability is discouraged but not penalized as for instance in Haskell, and even there it came out of necessity to make lazy evaluation feasible. Scala does offer better modularity support, more ways to structure code, easier, concise sum types and pattern matching, great syntactic sugar, and not to forget one of the most expressive type systems in a popular language (though it is unsound in some weird cases). All great stuff, but I really don't think the immutability aspect is what trumps here, as that is a matter of style that can be adhered to in Java as well without change in language. 
&gt; Java is still far from a functional language. We can only hope it stays that way.
I think the problem with Scala is just that it's too damn clever. If we had time to sit everyone down and teach them an entirely new language with new paradigms and structures and syntax, we'd just have everyone write everything in Rust or something, because it would guarantee a much higher level of correctness and safety. But we don't. This is why the world is still writing most of its code in Java and Javascript and whatnot. Because it's straightforward and familiar to most people. This is also why I think that in a few years, Kotlin will overtake Scala as the predominant alt JVM language. It borrows a lot of great features from Scala, Groovy, and Java, and adds its own on top of them. At the same time, it's incredibly straightforward, a fluent Java user can pick it up in under a week, and it has fantastic tooling and commercial support (due to the world's most popular Java IDE being written partially in Kotlin at this point). I could never introduce Scala as a Java alternative in any team. It would require way too much retraining. But Kotlin? That can be dropped in and picked up super-easily. It's more explicit and easier to follow than Scala, the runtime lib is way smaller, the compile times are actually reasonable, and adoption rates are incredibly rapid considering the language isn't even a year old yet.
I can't stand the names of the GoF design patterns. It takes more brain power to remember the weird, disconnected, overly ambiguous and abstract names they came up with. A Facade is a wrapper, an API, nothing more. 
I wouldn't say Java has a balance with brevity. It has very little brevity. It's just that brevity isn't always a good thing. But sometimes it is, so I support the idea of at least supporting the higher-brevity features like `var`/`val`. That way programmers can decide when to choose brevity.
Good read. What a beast was created.
Because no one uses scala or reads /r/scala. :)
Precisely. I couldn't care less if a language were flashy or boring. If it does what it's supposed to do well, that's good enough for me.
With Scala you don't need to throw OOP out of the window. You get the best of the both worlds imo.
Very well put. That's why a language like Nim (no offence to Rumpf personally) didn't work out for me because it starts out nice and cosy, but it quickly degenerates into magic and edge-cases. I agree with overusing the 'val' bit as well. That's what we can see happening in the C++ world (well, a bit). In a recent talk on "Include OS", I was bemused to see autoS everywhere. It is fine when you're writing it, but reading it becomes too much of a mental overload, especially for people using text editors rather than powerful IDEs.
To me at least, the compile time overhead is worth it for all of the amazing features I get from Scala. I haven't worked with large codebases, so there's that.
&gt; I think Scala the language has only little more inherent language support for immutability. It has 'val' and it has an entire family of immutable collection classes, including a cons'd list, etc. It's pretty significant in my mind. &gt; Also, neither type classes nor immutability are relevant to determine whether a language enables "real FP". I think we can agree that referential transparency plays a large role in FP, specifically when you try to start making proofs, and i'm not sure how you do that effectively without enforceable immutability. And to solve the same problem as type-classes with Java (with any notion of type safety) you would have to employ interfaces and/or base-classes. I think it's quite hard to make the case that your language is functional if you have to use OOP techniques to achieve it. &gt; In fact there are weirdly some Scala parts that are more mutable than in Java, e.g. variables captured by lambdas. What exactly about the variable changes when it's captured that justifies the Java approach? If anything I think Scala's handling of this -- that the type/accessibility/capabilities of a variable are preserved across all uses of that variable -- is far more consistent. If any argument could be made for it, you would have to look at a language with real capabilities, like Pony. But that language actually uses capabilities (or mutability rules) to prove safety -- Java appears to do it just to make things easier for it's compiler/optimizer. 
I think what /u/naranha is saying that Java syntax has a very consistent set of basic rules that are applied everywhere. What this implies is that writing some code and reading it becomes surprisingly easy (and consistent again). And the fun part is that it does this without the fanatical "there is only one way to do it" philosophy followed in something like Python. In fact, this is the very fact that I was alluding to in my original comment about Java (and to a certain extent, core C++) being very carefully designed. Sometimes being boring is exactly what's needed. Java's verbosity is overrated. Sure, we've all seen the contrived examples with the factory-method-bean-what-not nonsense. In my humble opinion, being a bit verbose with descriptive names is far better than writing inscrutable code. About type inference using var/val, sure, it is a good feature to have, but we should again be careful not to overuse it otherwise reading code becomes quite difficult, and I'm sure you'll agree that we spend more time reading code than writing it.
Better than monster oneliners that contain the whole business logic and modification requires hours of preparation, a scalpel and three people looking over your shoulder so that you do not screw up as it is not reversable.
They just read about how Scala isn't. Makes perfect sense. I'm sure you're out there doing the Java community proud. :)
Where do you see fall?
It's hard to assume Java as a functional language at this point.
Fair enough 
It has val, Java has const and final. I agree that val is more consistent but const and final are equally effective. Again Java the language does not prevent the creation of immutable structures like consed lists or make it especially hard (verbose though, indeed). You just need to use a library for that if you don't want to implement it yourself. And yes, that is an issue but not a needs-first-class-support one, well... maybe in terms of lack of syntactic sugar for literals, but in the end one doesn't work with literals that much anyway. Re: type classes. I am just saying that many languages that are widely considered functional programming languages don't have them or even static typing in the first place. So requiring Java to do so isn't really fair. You can always emulate type classes like in Scala, just without the implicit conciseness, e.g. Comparator (maybe a bad example due to it being an FI). Signatures/Modules in ML dialects are also explicit. I certainly wouldn't put implicits at the top of the wishlist to improve Java. First case classes and pattern matching please. My point is that it is eventually more about style and best practice in an ecosystem. SML has while loops, references, side effects, but that's just usually avoided. Very similar to Scala. So, looking at existing FP languages there is not that much inherently preventing a sufficient degree of functional programming in Java. I would say the most crucial problem in terms of satisfying FP purits is the lack of tail call optimization, which often leaves no choice but to resort to while loops, ...but hey, many internal parts of Scala's libraries do too to improve performance (or at least used to). Ultimately a lot of application level code can do without it... again a matter of tendency rather than enforcement. When a loop is more natural to reason about why not? While I like recursion, shoe horning it into a tail recursive fom with accumulator so that the compiler can optimize seems like a step back where I have to think of adapting to the compiler, so not much better than resorting to lower level optimizations in the first place... I digress. Re: captured variables. Of course Scala is more consistent there. I didn't say Java's effectively final restriction is more justified/better, just that it is one aspect where Java exhibits more immutability enforcement (with no choice) than Scala. I for one like the fact that I am prevented to write code where the closure application can modify my local stack (as perceived... of course it's achieved by implicit heap refs). And surely if you adhere to using val anyway Scala makes the same guarantees. Java is not a functional language. It hasn't grown up to one, but I think the issues are not that fundamental and frankly, lack of val or implicits are weak arguments compared to other aspects of what makes FP languages practical. P.S. I would love to exclusively write Java, but I recently am forced to use a language so vile its name shall not be uttered, from down here Java and Scala are both close and at the end of the spectrum I would rather be at ;)
Immutability seems to be the central theme FP'ers talk about. Uber can describe the problems arise when immutability and microservices run rampant. It quickly becomes modern day spaghetti code.
The point is, that neither boilerplate nor overboarding "conciseness" are helping readability. In one case you lose sight of the wood for the trees, in the other case you'd need a magnifying glass. For Java, the languge is working on getting better. For Scala, the community needs to work on it. I've not seen it getting better much. (It did get better with Scalaz for rare instance)
&gt; I won't deny the idea that Java is going to take a chunk of Scala's userbase I don't think any current Scala user would switch back to Java (I'm guessing they'd rather go to Kotlin if they need to give up Scala), but it's pretty clear to me that Java 8 has dissuaded people who were considering adopting Scala in the near future from doing so. 
Yep. Plus, at this point, Gradle (the 2nd most-popular build tool for Java) is adopting Kotlin. Kotlin will be the main language to write Gradle build-scripts in soon. Considering also that most Kotlin users are on Android (the unique combination of Android's Java 6 runtime and low method-counts allowed makes Kotlin the perfect alt language), and most Gradle users are also on Android, I think we'll see Kotlin use explode on Android very soon, and pick up very quickly on desktop Java too. Once people start writing in Kotlin for Gradle, they'll wonder "why am I not using this beautiful language everywhere!?"
I've the opposite and WMQ is a solid product for sure. Remote channels are awesome, server and client support is great, though authentication is definitely a PITA. In what ways do you use RabbitMQ or what do you like, maybe I can speak to it from the WMQ side.
Agreed. Kotlin is great. We're writing our backend in it currently.
I don't actually like Scala that much. But it has more type inference. `def`, `var` and `val` are all very brief. Singleton objects are far more concise in Scala. There's some other things not coming off the top of my head
https://www.google.com/trends/explore?date=all&amp;q=%2Fm%2F07sbkfb
I'm a current Scala engineer. I would switch back to java tomorrow if I had the choice. I also think that functional programming is inherently inferior to oo, having worked with both for years. 
Code like this: implicit def KCategory[M[_]: Monad]: Category[({type Î»[Î±, Î²]=K[M, Î±, Î²]})#Î»] = new Category[({type Î»[Î±, Î²]=K[M, Î±, Î²]})#Î»] { def id[A] = â˜†(_ Î·) def compose[X, Y, Z](f: K[M, Y, Z], g: K[M, X, Y]) = f &lt;=&lt; g } implicit def CCategory[M[_]: Comonad]: Category[({type Î»[Î±, Î²]=C[M, Î±, Î²]})#Î»] = new Category[({type Î»[Î±, Î²]=C[M, Î±, Î²]})#Î»] { def id[A] = â˜…(_ copure) def compose[X, Y, Z](f: C[M, Y, Z], g: C[M, X, Y]) = f =&lt;= g } Comes with ninja documentation.
&gt; Re: type classes. I am just saying that many languages that are widely considered functional programming languages don't have them or even static typing in the first place. And that's why i put "or dynamic typing" in parens in my post. If you wish to live in such a world, then type-classes have no purpose. I am firmly in the strongly typed camp at this point in time. &gt; So, looking at existing FP languages there is not that much inherently preventing a sufficient degree of functional programming in Java. This is like saying that there is not much inherently preventing a sufficient degree of object-oriented programming in C. But i think we can all agree that if we decide OOP is the way to go, that a true OOP language would be better suited for the task. And in this case I think we have to admit that if we want to live in both worlds for the time being, that Scala is better suited to fill that gap than Java is, and with few technical downsides. Scala is fast, integrates nearly natively with Java, and have shown itself able to implement things normally only found in hardline functional languages. The real difference between Java and the Haskells, Erlangs, Clojures, and even Scalas of the world is that the later support some form of adhoc polymorphism, either dynamically at runtime, or via language constructs like type-classes. That behavior engenders the separation of data and functions, and the creation of libraries of functions that work across types cleanly without coupling. That then extends to the creation of higher-kinded types libraries, and support for even more powerful abstractions like monads and monoids. Even in the cases where you can do these things in Java, you end up with so much boilerplate, glue, and noise that you wish you never started. Let that stuff go and what's left? Trying our best to write pure functions and chaining them together with streams? Those are nice features, but calling it functional programming -- i feel that's a stretch. 
Agreed. Lamda's in Java has likely introduced more dev's to Scala, making the transition easier. 
Depends who you ask. [ZeroTurnaround reported IntelliJ being used more than Eclipse for the first time ever this year.](https://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-2016/) (Ctrl+F for "IntelliJ" and you'll find it). Everywhere else, it's pretty much neck-and-neck. Either way, Eclipse is in massive decline. It's awful compared to IntelliJ.
Yea there is pretty cool stuff to be done in Scala and there are things that are improveing, still I don't want to encounter many of those things. There is already too many headache causing complicated stuff while working.
I don't know what this means.
Oh, I can. I do not work for a software company. I work for an aerospace and defense company. I don't write software for products. I write software to grease management wheels. I write process automation software. I'm a force multiplier, but still a cost center, not a revenue center. When your dev team is not a revenue center, that $500/seat license cost is just money on a fire.
This article needs some serious fact checking. The whole premise - Scala use is declining - is completely speculative. Look at job listings, StackOverflow questions, Spark adoption, and you'll get a very different impression. Yes, Yammer moved away from Scala.. in 2011. If you read about companies moving away from Scala over the last years, there's a good chance it was someone re-iterating the Yammer story. And most people don't even know what Yammer does. Lightbend has not released frameworks (plural) with Java API first, just one, Lagom, which is meant to be a bridge for Java EE developers into the "reactive" world. A Scala API is planned for release by the end of the year. Lightbend is the main contributor to Scala and sponsor of ScalaCenter. The author seems to be very confused about how Scala's type system works. &gt; typically define data structures in the most generic &gt; possible way, as a collection of (any) things What? &gt; A function in this paradigm is not allowed to &gt; produce any side effects If only. &gt; data is implicitly passed from a nested function &gt; to its parent function, via a general-purpose collection &gt; data type. What? Rule of thumb for the future: If Yammer is mentioned as evidence for some supposed recent decline of Scala, proceed with caution. tl:dr; This is just FUD, not facts. 
So in short you don't like it. 
RabbitMQ works well until it doesn't. Probably the biggest complaint we have is how it handles when nodes in the cluster go down. It will redistribute queues from the down node onto the remaining nodes in the cluster, but it doesn't seem to have a way to redistribute who owns the master instance of these queues once the down node comes back up. Once you have enough node failures, all of your queues end up being mastered on a small number of nodes in the cluster and load is no longer evenly distributed. 
Why would you'd define Monad and Comonad in terms of a Category instead of a Kleisli arrow?
Lol, last sentence is brilliant.
Why the /s?
[removed]
COBOL's focus was "assume users of the language don't understand anything even remotely related to math or logic." Classic example is replacing "=" with "move". That's not readability, it's infantilization.
One word: Lombok
&gt; I'm a current Scala engineer. I would switch back to java tomorrow if I had the choice. Why though? &gt; I also think that functional programming is inherently inferior to oo, having worked with both for years. Scala isn't functional though. It supports more concepts found in functional languages, but it also supports mutable data structures, OOP, and well, outright imperative code. Plus OOP is not mutually exclusive even to a purely functional language. Erlang being an example (it's a giant distributed OOP system, where each object is entirely functional). 
Any language can be used to program functionally, as functional programming is technically a subset of imperative programming. I doubt Java wants to *assume the role of a purely functional language*, but any well written Java codebase out there, you might find, contains a decent amount of pure functions. By design. For example, any "getter" is by convention pure. It alters no state, it produces no effects, or side-effects.
&gt; If you can't implement the type-class pattern and don't have first class support for immutability Depends what you see as requirements for "first-class" immutability. You can have objects whose state is entirely declaratively immutable (final fields).
&gt; You should consider looking into Kotlin. Ah, yes, the next JVM-based language we'll love to hate in about 6 years.
&gt; Uber can describe the problems arise when immutability and microservices run rampant. You really severely misunderstood this presentation (the "things I wish I knew" presentation, I assume).
Tonight! I'll be starting the stream in about 20 or 30 minutes
&gt; It does not help that Scala is everything I hate about Java filtered &gt; &gt; through the brain of a Haskell groupie that doesn't understand the &gt; first thing about what makes Haskell actually good. Would you mind elaborating? Just curious :) 
Asking about using IBM software is akin to asking how much it costs to maintain an old Mercedez Benz. If you have to ask, it's not for you...
If that proves really popular, Oracle will make a Good Enoughâ„¢ copy of it and stick it in Java 10, just like they did to Scala with Java 8.
To anyone looking, I'm live NOW!
Number one reason would be the compiler. It's not only slow, but from what those working on our builds tell me, not nearly as good at doing incremental builds as Java is, where a single class is a single file. I understand that Scala could be programmed as if it was Java, but most people don't do it that way. It drives me up the wall when I have to manually unfold all the types on a method with different generics because we like to omit types, because that makes it "Scala-like". I often have to chase type-errors which are three classes away from the actual breaking code, because A implies B implies C and so on. Case classes do not support OO and since matchers are so important (I loathe matchers, I think they are a glorified if-else switch, which overwhelmingly points at bad design) we use them all the time. I understand that we could start coding Scala as if it was Java. In that case my only real problem would be the slow compiler and the much poorer toolsets (due to the monolithic compiler, I've yet to see an IDE give good support for Scala, I often have to go and compile the whole project before IntelliJ marks/unmarks something I know should break/work). Also, usually being the most experienced person on the project means that I think a lot more about leading juniors than just writing code. Scala gives too many options to young engineers. It's also a _lot_ easier to learn FP than to learn OO, so if given a choice, they will pick FP, even if on the long run that choice will hurt them (as you can pick up FP in a month, it takes years (a decade?) to master OO).
You can run RabbitMq on Windows (https://www.rabbitmq.com/install-windows.html)
This is pretty much it. With IBM MQ you are getting a rock solid product that works everywhere in many scenarios, particularly it works well with mainframe systems. With RabbitMQ you are getting a system that works well in modern environments, but will struggle in legacy or highly-distributed environments.
You're thinking like a programmer. Stop that. Logic, sense, and my sanity don't matter in management-speak. The problem is that we don't contribute to the company's bottom line in a direct fashion. My productivity doesn't have an easily measured, easily observed impact on the incoming revenue. However, it has obvious costs. If you can't define the value of something, you account for it with a big fat zero. That's what the bean counters say.
The things that make Haskell good are its clean syntax, its complete isolation of tasks, and its almost complete lack of support for mutable state. The existence of `var` in Scala is a terrible idea. Go whole hog on immutability. The things I hate about Java--or more specifically, the JVM, are wrapped up in me having to know about the JVM internals, however slightly. I shouldn't care. But Scala forces me to care, because it still links against Java's core libraries. 
I think Java is way off from the sweet spot. Java has Weak type inference, no pattern matching, for starters. Kotlin, Swift and Nim are much better in my opinion. 
Not the best analogy. I am not the company owner just the developer. 
Java got simple singletons with `enum`. Although not common, and kinda weird if you are used to `enum`s from other languages, it is recommended by Joshua Bloch in [Effective Java](http://www.drdobbs.com/jvm/creating-and-destroying-java-objects-par/208403883?pgno=3).
I would not advise writing a neural network in Haskell. It's unsuited to the task. There maybe should have been an "Or don't bother" at the end.
http://courses.baeldung.com is pretty awesome
You should! It's awesome.
This was a very fun refresher. I enjoyed reading the references and then your code. Good stuff.
Just like Java? &lt;/s&gt;
Netbeans has been a very popular IDE for more than a decade. Eclipse is still the most popular though.
It happened, it was accepted. And yeah, Apache is just terrible: &gt;[So that's why we never hear of Cassandra, Spark, Hadoop, HBase, Zookeeper, Mesos, Maven, Ant, Ivy, Groovy, Solr, Kafka, Tomcat, Subversion or SpamAssassin any more?](https://www.reddit.com/r/programming/comments/532tto/oracle_wants_to_dump_its_netbeans_java_integrated/d7prw5a)
I also lean towards it
This one works for me: https://java.libhunt.com/categories I think it's outdated. [Github Link](https://github.com/akullpp/awesome-java) has more entries. Though libhunt shows stars and activity.
Can't get to it, page is down - but is it like this http://ifljava.com? 
I think I need an /r/OutOfTheLoop post to help me here.
first learn how to format your code, then fuck off
decent memory usage and performance
Well, it will use all your memory decently if you want :D Seriously, JVM tuning is a job on it's own.
An optimizing compiler to get rid of the MASSIVE build sizes due to dependencies that your code may or may not use.
This comes up every so often. Try a [subreddit search](https://www.reddit.com/r/java/search?q=java+certifications&amp;restrict_sr=on&amp;sort=relevance&amp;t=all) and read through some threads. Short answer: certifications aren't really worth it, at most it's for management's satisfaction.
Proguard does that for you, reflection included. However it's easy to run into "proguard hell" because its error reporting is often hard to decipher
As a library developer, I'd really like to be able to have internal classes and interfaces hidden from the external world but avaliable with public visibility within a package AND its sub packages, or specific packages (i.e. should be visible under com.univocity.parsers and com.univocity.common only) Would be great to have something like "package protected class MyClass" or similar.
Null safety and smart casts are two features I've been very happy to see in Kotlin I wish would make there way to Java. I also do not like that in Java methods are not final by default. Methods should be final by default and require a keyword like virtual in C# noting the method can be overridden. 
No.
Map Literals
Can you expand on this with an example, I'm having difficulty understanding
Quite the opposite for me. I like having the ability to override methods. I think everything should be extendable/overridable by default - "you break it you own it" kind of situation.
I sometimes find myself needing to know the Type that was passed to my generic. For example, when I go to serialize what was passed, I have to have access to the original Class... such a pain to pass that in.
But what if the reflection doesn't statically reference a class? An example might be accepting user input and checking if the class is present. How would it be possible to account for that?
Thanks.
I know that, but it's not sufficient or flexible enough. See my other commment with a source code example.
A shell wouldn't be too bad to have
Isn't this criticized somewhat in Scala?
I could live with that if the Java compiler forced the use of the @Override annotation so it was clear from looking at code the method was being overrided. 
Pattern matching, like in ocaml or scala
Native support for microtypes. I 'd like to have possibility to declare MyEntityId type which essentially just a String(or Long) to enforce safety and have some self-documentating ability. Otherwise something like Map&lt;String, Map&lt;String, Map&lt;String, SomeObject&gt;&gt;&gt; looks confusing.
Really? your customers dictate the tools you can use to do your work?
I used to use Eclipse at work then a couple years ago I started using Android Studio based on Intellij at home to try Android development. Very quickly I realised I found it years ahead of Eclipse and started using the community edition of Intellij at work. Over the next year pretty much all my team followed though we do have a few die hard Eclipse people left. No NetBeans though.
Coming : http://www.javaworld.com/article/2971152/core-java/what-repl-means-for-java.html
Value types (come on Project Valhalla!)
It is, but the Scalagentsia consider that criticism invalid, saying "Scala doesn't have operator overloading, because Scala doesn't have operators: only functions". Oh, and punctuation marks like + and - that alias those functions.
I think it *has* been a great and successful language, and advanced the state of the art. Java bashing is cheap, and I'll admit to indulging in it on occasion, but if you look at what it achieved in the 90s, it's hard to argue with that. Now, though, it's behind the times, and evolving far too slowly to ever catch up. We need to be looking at languages like Scala for the future.
Tupel. 
Seconded, this is called type erasure, and is apparently promoted as a feature...
even = ? 
This is going to be a feature of Jigsaw in Java 9. By default, the classes in a module won't be exposed outside the module, and you declare that they should be exported in module-info.java. This [article](https://dzone.com/articles/project-jigsaw-is-coming) had a pretty good description of how it will work.
I wouldn't mind seeing a native annotation that produced getters and setters for properties. The language wouldn't need to change at all since the methods would be generated at compile time. All it would do is remove clutter in the source. Should be easy enough for IDE's to handle as well. Any implementation would automatically override the annotation. Something like: @Generate( get, set ) ~~public~~private String foo
Java has no concept of a 'sub-package' (e.g. `com.mycompany.myproduct` and `com.mycompany.myproduct.controller` have no relation whatsoever as far as the compiler/language is concerned) so you either have to make something `public` (accessible to all) or have it not accessible to subpackages.
Property keyworld would be very, very useful is implemented in java at compiler error: e.g. http://www.delphibasics.co.uk/RTL.asp?Name=property It allows to map getter and setters to a specific class property. No more get this and set that. 
Yes this! More intelligent runtime casting from the type too por favor.
Personal projects, surely? I took a four year break immediately after my degree and I worked on some personal projects for the last six months before I came back to show what I was interested in and what I could do. Two years isn't long really, but it might be worth asking a friend who's working today to help you make sure you aren't using any libraries or patterns which have become notably unfashionable in the mean time (not that this is actually a good reason not to use them, but just for the impression it gives in this particular case). Good luck!
Real properties. My code base would shrink by... well, a lot. Any syntax will do, C#'s, Kotlin's, whatever. Just no more `getUser()/setUser()` please. 
JavaFX's Pair&lt;K,V&gt; functions as C#s tuple afaik.
But why the annotation? Just autogenerated getters and setters.
At least it might get chemists off of NumPy's slow ass.
Scala calls this type aliases. Such a simple feature but I find myself craving it fairly often.
Tuples can have more than 2 elements
One of the many nice things about Kotlin is that this is enforced at the compiler level.
&gt; has fundamentally not understood why Scala is a well designed language That makes two of us, because I also don't see what makes a language with as much magic as C++, with awful compile times, with an enormous stdlib, with absymal tooling, not even a "well-designed", but a "decently-designed" language.
Combine with Value Types?
&gt; magic where? &gt; compile times not good but acceptable, given the amount of work I save elsewhere &gt; enormous stdlib one of the big plus points for Scala. &gt; absymal tooling blunt lie. 
Class local *var* is in Java 9. Much to my dismay
Explain please
Better GPU support. [Project Sumatra](http://openjdk.java.net/projects/sumatra/) was killed off when I think it really should be a hard requirement of Java 9. 
&gt; where? Implicits? One of the worst features of the entire language? &gt; compile times AKA "death by a thousand cuts". As an Android developer, I can tell you for a fact that bad compile times ruin productivity. &gt; one of the big plus points for Scala Yeah, I love huge dependencies for no reason &gt; blunt lie Yeah, how's that IDE support?
Value types and generics over primitives.
Optional arguments. The amount of boilerplate and documentation duplication and clutter it takes to overload a method with a version having just one extra argument is really painful. I wish it were possible to specify an argument as optional with a default value.
It would also clean up documentation, if the meaning of a property could be documented in one place, instead of once at the getter method and again at the setter method.
There are only 2 things which bother me every day coming from other languages: var/val (it's coming, yay! 2020 or sth) and a shorthand for getter/setter 
It is a common practice in consulting where the customer IT is the one configuring the computers the consulting companies are allowed to use. They have a standard stack and the externals have to follow along.
Don't. Writing unmaintenable code is not a job skill and it has no real value other than showing off. Learn to write efficient and elegant code.
If you feel your Java could be better I'd do the practice questions for the certs. Back when it was SCJP I studied for it. Even though I failed the test I was far better at the type of nobody-cares edge cases that get asked in interviews. I'd look favorably on someone with an OCPJP but that's just because I know it's hard as fuck. I wouldn't say it's worth the money, but maybe you'll find a job that pays for it.
C#'s extension methods. I want to make a class from one library work with classes from another library, without modifying either library and without filling my code with static converter methods.
That isn't what I asked. This isn't for everyday use. I just want to know where people learn these neat tricks, as I find them interesting and want to learn more about them.
&gt; Kotlin somehow manages to do this with a stdlib Kotlin made (yet another) wrong decision here. And you will see that they will see it, and then (yet again) go Scala's way eventually.
&gt; And yet still second-rate compared to Kotlin and Java, just like everything else about Scala. Kotlin is not even half-ass stable. A totally oversold beta product.
RemindMe! 2 years "Is Kotlin as shitty as Scala yet?"
Well, learn to write efficient and elegant code and these tricks will become obvious to you. There is no magic answer here, it's all about experience. It's like riding a bike. You start with helper wheels, then you end up wheeling all over the place. 
Yeah, given the amount of random Tuple classes, would definitely be good to have in the JDK like Optional is.
Maybe [Optional](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html) can help you in those situations.
Alias would be helpful but not perfect. There are usually more characteristics, like non-null non-negative id etc which makes it a real type of it's own.
It's easy only in the simplest case when you just execute tasks on the executor and wait for their results. There's a reason why people use concepts like actors, message queues, transactional memory or just reactive streams.
To the hot tube time machine! https://wiki.openjdk.java.net/display/Coin/2009+Proposals+TOC
There has always been a concept of encapsulation in OO languages, where you don't reach all the way into a member variable to make changes or read values, but rather perform said operations via a method. The purpose of this is to allow you to change the inner workings of the class, but maintain the interface and so avoid chasing other code. And this concept has some value (though probably not as much as OO 101 would have you believe ). So the difference is that if you do a class like I describe above you can always OVERRIDE the default implicit method with your own method whereas with a direct field reference, you cannot change the interface.
Unless the object is purely for data holding (and often not even then) you won't want all the fields to be accessible. Having said that I see a mistake. I mean to make the field private as it normally would be. That's what come's of banging out code without unit tests I suppose.
I wish I could use the `this` keyword in a method signature as the return type. Example being builder style classes that can be extended. In order to get the correct return type on methods you have to use generics. Would simplify some messes I've made. 
How about Shenandoah GC? Maybe it's not pauseless but advertised as "Ultra-Low-Pause-Time" and bundled already with Fedora's OpenJDK.
The problem with this is that you never know what minor extension of your code someone might need. Unless any modification will likely break it, it shouldn't be final. This is mostly referring to code that may be utilized by people other than you.
One of the things that turned me off from Scala was the community. The comments on that post just reinforce that. They're rabid white knight defenders who cannot accept any criticism, no matter how valid, of their favorite language. 
I don't think that helps here. If your optional argument is wrapped in an `Optional&lt;SomeClass&gt;` you'd still be forced to always provide at least one argument. But OP wanted a way to be able to both call `myMethod()` and `myMethod(someArgument` without having to declare two versions of the method. Some languages have that. So you can declare a method like so: private void myMethod(int someArgument = 0) { // continue with code, knowing that arg "someArgument" // will be provided, or else get the default value 0 } 
I don't think this will work. For example, for a class `MyClass extends ArrayList&lt;String&gt;`, `getGenericSuperclass()` would return `ArrayList&lt;String&gt;`, and `getActualTypeArguments()[0]` would then return `String`.
But tuples make almost zero sense without value types because you won't actually use them in practice due to having to be heap allocated. Seriously, lack of stack allocation in Java is the only serious wart left. Fully instantiated templates ala C++/C#/D might be nice, but I'm still not totally convinced those don't do more harm than good. Modern processors are so good at branch prediction, combined with JITing I'm just not sure that static polymorphism is really necessary.
I have a java cert. I used it as a toilet paper. 
I agree that would be nice. Do you know about `{@link #methodNameInSameClass }` for javadocs? I doesn't solve the doc duplication completely, but you can at least refer back to the documentation of the method with most info. The link is clickable and will show the doc of the linked method. /** * print greeting to provided name * ..some more info here.. * @param name */ private static void sayHello(String name) { System.out.println("Hello, " + name + "!"); } /** * Like {@link #sayHello(String)} but with name bound to "Guest" */ private static void sayHello() { sayHello("Guest"); } But yeah, it would be so much nicer with /** * print greeting to provided name (or defaults to "Guest") * @param name */ private static void sayHello(String name = "Guest") { System.out.println("Hello, " + name + "!"); } or something similar.
Java 9 has factory methods which come close.
It appears I do. Time to get more coffee. 
Can you support that? Right now the [JEP for this feature](http://openjdk.java.net/jeps/286), which reflects the latest status, shows that it's a candidate, which means it's a long way from being approved for inclusion. 
Any reason for linking to the one for Java 7 instead of Java 8? http://docs.oracle.com/javase/8/docs/api/
is *anything* missing from Java? isn't part of the reason its so big because it does damn near everything?
No, you guys are missing the point. It's not the right side, but the left side that could be reduced. See his getUser example. 
Thank you! I will create some small test project.. That is a good idea
it is out https://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html
&gt; it's pretty intuitive. I have no idea what the user var is. I would have to check to see what the return value of GetUser() is. 
I don't have any Java certs at the moment but I do plan on getting them just because my job provides an incentive to do so.
You have 7 years of experience with Java? I think you will pick it up relatively quickly. If anything, the newer versions of Spring are easier to work with.
it's a User object..... C# relies heavily on the IDE it would quixotic to think you could write large projects without the scaffolding, intellisense and build file. 
I don't know which IDE you're using (visual studio) but I assume you still have to mouse over the method to see the return type?
Multiple inheritance. Look up Uncle Bob's rant on this if you're not sure why. I agree with him that the 'problem' with the deadly diamond of death is easily resolved (and has been in other languages (ruby, anyone?)), and it's quite likely the language designers were some kind of lazy.
Less lazy developers. (Lombok and all that garbage should be killed) Seriously: typedefs. ;)
Value types
As a Clojure fan... tail recursion natively in the JVM. We could really use it.
Full optional support, not making it another object type. Let me just be able to call `object?.doStuff()`
Don't like this unless I can do something like: immutable var age: Integer Which would restrict it to be assignable only in the constructor
C++ did this 20 years ago, it didn't work out. 
New visual identity https://www.java.com/en/ This page looks like a scamming website It is an important thing, because lot of non-tech dude think java is old and ugly.. For comparaison: Foo | Bar ---|--- Kotlin | https://kotlinlang.org/ Scala | http://www.scala-lang.org/ Rust | https://www.rust-lang.org/ D | https://dlang.org/ C# (.NET Core) | https://www.microsoft.com/net/core 
JMX 2. Got dropped from Java 7, I think, and then was forgotten. It looked pretty decent in the early releases, and almost all java big data software uses JMX for various things. Moreover, it was rapidly evolving until it got the kibosh, so the huge potential of JMX 3,4,... are now way over the horizon. On a smaller scale, ditch freakin' RMI as the default connection mode and come up with something better, or promote JMXMP to first class status. Days are long gone where your JMX connections are all on the same LAN, and RMI (as implemented) just doesn't jive with firewalls, cloud and what-not.
generic enums ... e.g.: public enum StandardDbOption&lt;TValue&gt; implements Option&lt;TValue&gt; { HOST&lt;String&gt;, PORT&lt;Integer&gt; } ... dbConfig.set(StandardDbOption.PORT, 123); dbConfig.set(StandardDbOption.HOST, "localhost"); // public &lt;T extends Option&lt;V&gt;, V&gt; void set(T optionType, V value) { ... }
Value types should address this at least mostly: http://cr.openjdk.java.net/~jrose/values/values-0.html
Apache commons is one of the goto libraries in any project for me. StringUtils.IsBlank is your friend here. It really needs to be in standard Java.
Thanks!
I know it's not definitive, but Brian did mention this in his JavaOne keynote. https://www.voxxed.com/blog/2016/09/var-comes-to-java/ Personally, I've been following the builds closely and I don't see it not making it. Especially given the overall project delays.
Git
One word... Groovy 
In that case you can just use a value class: case class Length(meters: Int) extends AnyVal // can of course be a member of Length, it's separate for demonstration only def square(length: Length): Length = length.meters * length.meters square(Length(5)) // perhaps name the class Meters or write extra code to allow using "5 meters" here
A better term is, borrowing Haskell terminology, a [newtype](https://wiki.haskell.org/Newtype).
Generic exceptions. To be more precise, if I have a function `void f() throws XException, YException`, an `interface Procedure&lt;E&gt; { void run() throws E; }`, and a function `void perform(Procedure&lt;E&gt; p) E { p.run(); }`, I want the call `peform(this::f)` to be considered at compile time as throwing `XException` and `YException`. If smartly integrated into streams, it could solve the pointless exception management that is happening now.
Bad example, maybe. Length and Width are just a matter of perspective, but different units aren't. typedef double PoundForceSecond; // deprecated because stupid typedef double NewtonSecond; Trajectory calculateTrajectory(... , NewtonSecond impulse, ...); PoundForceSecond impulse = getImpulse(); ... 150 lines later ... Trajectory t = calculateTrajectory(... , impulse, ...); =&gt; Type error: expected type NewtonSecond does not match provided type PoundForceSecond. Use SI like a civilized human being next time. Mars Climate Orbiter cost: $327.6 million Ok, so it's not quite that simple; getImpulse() is reading from some other contractor's software that almost certainly doesn't share this one's type system... but maybe, just maybe, being completely pedantic about types and never just assuming that the `double` someone called `acceleration` is a `MeterSecondSecond` would avoid the occasional disaster.
You can usually use `Mutable*` from Apache Commons here, but what's the point, the compiler should figure this stuff out automatically for you.
I was illustrating how scala supports it, rather than actually doing anything with it. But yes, it's better to have a regular public attribute until a property is actually needed. Doesn't help doing code examples on mobile is a pain in the ass. 
There's `Pair` and `Triple` in Apache Commons. Anything more, and I think your should roll out your own datatype.
Or just deprecating checked exceptions once and for all.
Well, you can always access any objects attributes anyway, I was only replying to seb letting them know they can do away with "boilerplate" code if they just made it public. Also he's not doing anything special in the getter or setter. 
I don't know why would someone downvote you. Swing is a mess. I mean, it kinda works, but that is all. The same with JavaFX. There are some bindings for GTK and QT, but they're not up to date. Java could use some good GUI library. C# has WPF and it's really nice.
You can only access private attributes from within the object, not from another object. So if you have a private attribute and no getters and setters, there is no way (ugly workarounds aside) to access these attributes from the outside. Edit: Again, why not just make it public? Because the other objects should never see the own attributes. The boilercode is the necessary evil for that in Java. Ofc. you could make the variable public, but this would very likely result in a bad program.
Agree, I was going to say, look at the one line " var user = myObj.GetUser();", one has no idea what user really is. It requires searching the method to see. It's not descriptive.
I read that twice, I still don't get what you're saying. Java exceptions work fine. this::f reads like C++, we used to call it the scope resolution operator I think.
This is the only thing I'm jealous of Go for. A small program ends up being around a meg or so IIRC but for a Runnable Jar it's around 50 megs +/- 5, last time I did it.
Not SWT apps. They use the underlying OS's native controls. https://www.eclipse.org/swt/
I'm not sure what you mean - as long as you are passing everything by value what is the potential for memory problems?
But you can't propagate unknown exceptions from a lambda. Currently, you can't pass an exception-throwing lambda into stream methods like filter and map. Which makes sense, you don't know what happens to those lambdas in a particular stream implementation, but in most context you'd want the exception to bubble out, and the compiler doesn't â€“ and currently cannot â€“ notice it. A silly simple stuff like files.stream().map(Files::readAllBytes) doesn't compile right now, and I'd love it to compile and make the whole expression to throw a checked `IOException`.
What about using [jython](http://www.jython.org) or [jruby](http://www.jruby.org)?
What I like most about Netbeans is how easily in consumes Maven projects -- just point it at a root directory and off you go. Trying to do the same thing with Eclipse or IntelliJ is like pulling teeth, even if the latter has lots of nice features.
Concise property definition and usage.
I miss Array object from kotlin in java. It has a lot of methods compaing with List interface.
Scala typeclass pattern
Running in browsers. JavaScript is terrible. --- What you say about version selection in the module system is mostly sensible, but note that, even if you could use multiple versions of the same library at the same time, doing so would be painfully wasteful and introduce other problems. Npm demonstrates this problem nicely. Still, Jigsaw really should perform version selection, so that we can have something like .NET's Global Assembly Cache. That'd be sweet.
I'm very curious about those npm issues regarding versions, if you have a link to share!
Ah...I feel like some n-element relation has to exist..that class would take little time to write I think
Real lambdas, and real generic functions. Macros a la Common Lisp would be nice too.
That's because the stinking lambda is just bloody syntactic sugar for an anonymous class. Lambdas really disappointed me in JDK 8. Streams are awesome though.
This has more to do with the JVM than with Java per se.
&gt; Multiple inheritance. It's 70% there with the ability to inherit from multiple interfaces that have default methods. In Java 9 interfaces can also have private methods meaning we'll be 80% or so there. 
Property or method literals (not just method references) would be really cool, so e.g. in JPA we can do: aQuery.join(Foo:id).join(Bar:fooId);
True, but we wouldn't need the whole concept of interfaces if we'd have multiple inheritance
Java needs Reified Generics.
And List. I use Arrays.asList(...) but literals would be better
What do you mean it didn't work out? 'const' member variables are still used everywhere, and why shouldn't they be?
Right. Yet we wouldn't even need the whole concept of interfaces or default methods if we would've had multiple inheritance. I think they created more of a headache than they avoided
[removed]
Case classes are more powerful, though. You can use them for pattern matching for example.
Something like this: Map&lt;Integer, String&gt; = { 1 : "Hello" , 2 : "World" }, for instance. Just makes code much more readable.
IIRC, AOT is being considered for Java 10. The way things are going, it might not be too far away too. However, the Module system in JDK 9 should help out tremendously.
Unsigned integers. In Java 8 we now have some methods that treat ints as unsigned but we still cannot declare an unsigned int. 
I actually like this idea, albeit allowing only a small set of operators to be overloaded. What I miss most is the ability to overload the function call operator. In that respect, C++ does a grand job.
&gt; I also do not like that in Java methods are not final by default. Methods should be final by default and require a keyword like virtual in C# noting the method can be overridden. This is one of the few things I dislike about C# and believe that Java did better. 
Javascript is terrible, but you should probably understand that it is punching above its weight class. It was never intended to be the workhorse language of the web but a simple scripting language for amateurs. It is only because Java dropped the ball so catastrophically that is serves the current role. 
Yeah I use an IDE. Why does that matter? I quoted OP saying it was "intuitive"
Why? That method might return a string an empty string as a fallback
There's probably a technical term for this, but I'd like to see support for unit annotations. That is.. if I have a float representing money, I should be able to annotate it with [dollars], and if I have a double representing time, I should be able to annotate it with [seconds]. When I divide the first by the second, it should automatically infer a result with units [dollars/seconds]. If I try to assign that to a variable that I've already marked as some other unit (like [meters] or [dollars/year]), there should be a compiler warning. Similarly, if I try to add a variable with units [meters] to a variable with units [centimeters], it should spit out a warning. Methods should be able to be annotated with the units they accept and return. Stuff like that (including generic units). This would be quite helpful when coding things that require a lot of data manipulation, like scientific computing.
&gt; alternative libraries Such as? 
You're stuck with Java (i.e. it has the market position that it does) *because* of its emphasis on backwards-compatibility. If you want a JVM-based functional language that is willing to "fix the API" between releases, then go to work in a Scala shop. That is, if you can still find a shop that didn't get burned by that attitude and lose interest in the language five years ago.
Could you elaborate on this? or link the explanation? I've been seeing lombok for a while and looks really interesting but haven't used it yet. I don't want to start using it if it is really a problem.
You're describing C#. I work in both languages, and about half the C# shops that I've seen discourage the use of `var` because it makes the code too hard to understand/review outside of an IDE. 
Read-only properties (with a `final` backing field in the bytecode) are created with the keyword `val`.
How does .NET manages those issues? How does the GAC adresses the "instanceof" problem, for example?
Yes, it still has wider adoption probably, is more likely to be in a school CS lab, and it's a little smaller and less confusing than 8 with stuff like streams and lambdas. He might be jumping to 9 if the school is hip.
People wouldn't accept solutions so they don't have to pay the bounty. 
The need for certifications in general depends on how your job market works. If employers demand them, by all means pursue them. If not, and you can demonstrate your skills in other ways, you don't have to.
What part of Lombok are you using? The main value add, value objects, can be done with libraries like immutables and auto value.
https://www.experts-exchange.com/ People hated it so much that they built stackoverflow.
The option is there if you enable it in the compiler. Frameworks like Spring can leverage that metadata when present.
I believe that the correct answer to "How do I do X with Maven?" is usually "By switching to Gradle". 
A little late to this thread, but would you say that Ant is out of the game or is it still probably used fairly regularly?
2 usually recommended books to become more familiar with Maven. [Maven by example](https://github.com/sonatype/maven-example-en), probably closer to what you desire. [Maven: the complete reference](https://github.com/sonatype/maven-reference-en), advanced version, huge. 
I didn't know that. The more you know.
Just put the string in Oracle database. The empty string will become `NULL` and there'll be only one thing to check for. try (Statement s = con.prepareStatement("SELECT TRIM(?) FROM dual")) { s.setString(1, foo); try (ResultSet r = s.executeQuery()) { if (r.getString(1) == null) { // Your logic here... } } }
thanks, I will have to look into it. 
ah, basically something like we already have for arrays. Thank you
&gt; modules in jigsaw I'd seen the term jigsaw in posts lately but hadn't looked into it. I went Googling and found an article that reads well: http://www.javaworld.com/article/2878952/java-platform/modularity-in-java-9.html Thanks for the tip associating what Java 9's Jigsaw is about. Found another good article: http://njbartlett.name/2015/11/13/osgi-jigsaw.html If Jigsaw could combine its best parts with the best ideas in OSGi...that would solve so many Java problems today, possible even addressing DI hell in large Spring projects. 
I'm fairly certain [XStream](http://x-stream.github.io/) does this.
Who would "accept" solutions? Majority upvotes? Sounds like the perfect target for shady businesses...
"I will consume free content from there, but I will not contribute." Perfect.
The presenter is from Azul systems. I found this video to be a brilliantly prepared overview of JDK 9 modules. It gives a lot more useful information (in my opinion), and is better presented than the talks given by the actual authors of Project Jigsaw (which, no offence to them, I found extremely bland and boring).
Indeed. Another all-time favourite - https://www.ferrethandjobs.com/. Heh. 
The fun part was that in a lot (if not all) cases, the actual answer used to be at the very bottom of the page. Well, at least 10 odd years back! It just happened that most people were too pissed off to scroll down!
Yeah, it's fragmented, but Microsoft is a strong enough technology leader to fix that over the next few years. I haven't seen anything official from them, but I wouldn't be surprised at all to see the Mono community and tools merged into Core. As to whether Microsoft can really "do" FOSS, well, we'll see. In a few respects, they already do, but it's not like they're really opening everything up yet in a way that's central to their business model. I suppose they'll keep their options open. In the meantime, if they can at least shoot for being better at it than Oracle, that's a reasonable goal, and probably measurable as well. That will be something to see. In the meantime, the march of SaaS and cloud computing continues and much of their future revenue will build on that, as it will for most of the industry players. A future with even stronger free software will be essential to building those infrastructures and making them resilient, reliable, and scalable. This is already happening of course, and it will be essential to Microsoft to keep up with everyone else on FOSS in order to be able to stay competitive. Right now, they are playing catch up, but getting better.
Did you just reply to yourself contradicting your post?
LOL :-) yeah, that went in the wrong place. Anyway, doesn't make sense to argue with this shadow dude.
Sorry, but that is not a problem that needs solving. Nobody cares about redundant references in a data transfer format. There has to be an underlying reason for this! See /u/GuyWithLagâ€™s reply.
You'd be surprised how far people will go to for e-points on stack overflow. No need to spend real money 
they do, but they shouldn't
It's not ready yet. Also it's low pause but there are pauses and they are significant. The [success metric](http://openjdk.java.net/jeps/189) of the project is: &gt; This project will be a success if we can manage 100GB+ heaps &gt; with the majority of the gc pauses requiring &lt; 100ms which is great, but not *pauseless*. For example - for small heaps (0.2-1GB) I see pauses in the range of 5-20ms (young). When deciding if Java is a good platform for something I have to consider if this is good enough or not. I'd prefer if I didn't have to and it was always as-good-as-other-picks :) 
Don't forget about [Ceylon](https://ceylon-lang.org)! ;)
Are you saying to avoid jobs asking for certs? That seems like what you're saying.
In college we had a store called the "Student's Exchange" but everyone, including professors, called it the Sex Change.
I understand why people downvote this post, but seriously, it's not an absurd opinion. Some people prefer to make things explicit over improving readability by making everything as concise as possible. That's a matter of taste, not something to downvote. That said, I'd prefer to see properties in Java, and that's why I consider Lombok an important project. If nothing else, it shows that developers want this feature, which may result in adding it to Java in the future. Without Lombok, it's a lot less likely something like this will ever happen.
Picking a queueing systems always depends on the workload and use case. In general, while Apache Kafka is great for very high bandwidth / streaming analytics like workloads, it can also be a little more cumbersome to work with (and even overkill) especially if new to queuing systems or need something simple. I would stick with a simple single message req/ack queues such as Amazon SQS or RabbitMQ so you don't have issues with retrying failed transactions, de-duplication, etc. 
I may have misspoke when I said domain models (as in models for the database), I mean domain models as in for view objects that are marshalled into JSON objects. I have the following problem where I dynamically build forms, IE..you have a form with multiple questions that reference the same list. For example, list of states, etc. I simply just want to use references to objects as opposed to jerry rigging my own dictionary to hold those reference. { question1: { listOfStates: ["AL","AK","AZ",...] }, question2: { listOfStates: ["AL","AK","AZ",...] }, ... } to something like { references: { ref123: ["AL","AK","AZ"...] } question1: { listOfStates: { refId: "ref123", isReference: true } }, question2: { listOfStates: { refId: "ref123", isReference: true } }, ... } I have an existing View domain model that is used with JSPs/Servlets that are derived from the service/DAOs. I'm still in the prototyping phase so I'd like to be able to cut down on the payload in order to minimize refactoring of the existing View domain model and be able to retrieve these JSON objects with minimal bloat.
&gt; It's also a lot easier to learn FP than to learn OO, so if given a choice, they will pick FP, even if on the long run that choice will hurt them (as you can pick up FP in a month, it takes years (a decade?) to master OO). Could you elaborate on what you mean to master OO. Which specific style of OO you have in mind? Something along the lines of "Growing Object-Oriented Software" book or something else?
That's about what I pictured you were attempting. To be honest it strikes me as a combination of premature optimization together with a break from the model expected of such APIs. Such a break will likely result in friction with tooling, libraries, frameworks, mental models, etc. and that friction could burden you in many places for a long time. If something like a standard list of states is part of your logical model then you could treat it as first class, expose it via its own endpoint, and save the duplication in each response. If that can't be the case then you are probably better off nesting the states, even repeatedly, in the response as in your initial illustration. You could always add in response compression as a next step if/when proven necessary. If that is still not enough, well, then maybe at that point it would justify something more arcane. At this moment, though, you don't necessarily have enough evidence that it will be the case. 
I still don't understand why engineering time should be spent on this enhancement. * is this required by Product? * is this necessary due to a library or dependency? * is this necessary as a fix because we're hitting payload/response time limits? * is this necessary because the current implementation is broken? * is this something that we likely will hit in the near future and we want to have a clean architecture? 
* structs/value types * built in lombok * free functions * real generics * pattern matching * Algebraic Data Types, or at least kotlin's sealed + nested classes 
Yes!!! An "identity" return type would make chained methods so much easier with inheritance. 
Only if you got there from a Google search--they served different pages, and did that so Google would keep listing them.
You seem like a nice person as well
I'm still often shocked by how much code you need to support good OO structures vs bad ones. OO is not so much a science, much more an art. It's about finding where a structure fits in into the wider system and how that works with others. OO is about the interaction of agents in an artificial space, so it has a lot to do with how your mind makes up stereotypes about the world around it. If you worked on the field long enough, you start realising that by far the simplest solutions are the ones which are also the most straightforward, looking back. You do need a lot of boilerplate so that you can separate your logic from your environment, but that's life.
Well, you can hire an expert consultant to come to your company for 5000$ and you'll get the expert's answer guaranteed.
How do I configure the project's organization, name, and version in `build.gradle`? Trick question. You can't set the name, only the organization and version. Because reasons.
I think it's pretty clever use of Optional (I'm not one of the people down-voting you), I think maybe it's just an unconventional (and therefore potentially confusing) way to use Optional. &gt; Not that I am a fan of Optional myself, I think it's rather convoluted to use, but it can help cleaning null-plagued code. Yes, but for Optional to make sense as a suggestion here, you first have to convert OP's problem into a "null-plague" problem. If people were normally solving this OP's problem of method overloading (and doc duplication) by passing nulls as arguments (with tiresome null-checks as a result) then using Optional is definitely better... but were they doing that? But I get your reasoning (I think). If Optional&lt;T&gt; represents a value T that may or may not be there, it seems it could be used to signal that a method argument is indeed optional (in the ordinary sense). And if I know that the method expects a value that may or may not be there, I guess I could also feel safe when i call it with an empty Optional. Btw. I just googled some and found [this thread](http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments). Seems like there is a popular rule-of-thumb saying you shouldn't use Optional as an argument. But of course there are exceptions and general disagreement about the rule.
Forget him. He's just one of those people who reply "Why don't you use Z" when you ask "How do I do X using Y?" I don't have much of a tip apart from what I used to do (and still do) - find such code, deconstruct them logically, and add them to my memory bank! Sometimes I can even find an optimisation or two myself on the existing tricks. The other bit is reading tons and tons of code from top competitive programmers (Gennady Korotkevich, Petr Mitrichev, rng58, etc.) on sites like CodeForces.com which actually allow one to see other people's source code. Most (if not all) of these are in C++, but a huge number of them, especially related to bit hacking tricks, carry over nicely even to Java. Petr codes almost exclusively in Java though. Finally, knowing maths definitely helps, particularly Number Theory, and in the case of full-blown algorithms, Graphs inside out. Hope that helps a bit! EDIT: A good book for bit hacking (if a bit dry) is "Hacker's Delight" by Henry S. Warren, Jr. Definitely recommended. Also, sites like TopCoder and CodeForces have excellent editorials and even tutorials. For example, https://www.topcoder.com/community/data-science/data-science-tutorials/a-bit-of-fun-fun-with-bits/ 
&gt;I'd much rather be explicit in my choice to allow something to be overridden. Honestly, how often do you make this explicit decision for every implementation and how often are you just writing the least keywords in C# and not thinking about it until you need to override something and you cannot? That process isn't so quick when you have a release schedule and the consumer is the public at large instead of ourselves. On a language level the default should support strong development principles like Liskov substitution and Open/Closed. If you expose such public functionality `DoSomethingWithFoo` that takes a `Foo` object instance, I should be able to implement a `Bar` that extends but does not modify `Foo` and your `DoSomethingWithFoo` should happily accept it. The responsibility for ensuring that `Bar` works, including any methods which override those on `Foo`, is on me, not you. 
same here. tried Gradle for nearly a week this year, but ran back to Maven. Gradle might have some nice features, but not enough to justify a switch and learn most of its details (like I know now for Maven). If Gradle's market share increases (now it seems dominated by Maven) then it might be worthy to look again at it... Anyway, for sure I would pick up Gradle vs Ant any time! :)
I had actually forgotten about c/cpp until I read thread on Reddit. /s
I think, the original question makes sense. Maybe there are other possibilities to solve the problem, negating the existence of the problem isn't very helpful. You could argue too, there's no need for compresion, just reduce the amount of transferred data. And there are solutions for the problem in other languages so why shouldn't it be allowed to ask for that feature in java? IMHO it would totally make sense having automatic support for reference deduplication in marshalled data.
Talking about collections, it would matter now whether you use Java 7 or 8. If it's 8, then you should search about Stream API, otherwise you go for the classic approach mostly with fors and ifs.
Except that guava has the `Strings` library, which includes the `isNullOrEmpty` example above. In large projects, I usually end up with both as tertiary dependencies anyway, so it's a bit of a moot point.
It's java8 , ill have a look
&gt; 80% of your average enterprise application really works best with the object oriented model. There is your problem: "enterprise application" - java devs can't design a simple module without poisoning it with ridiculous design.
&gt; OO is not so much a science, much more an art. OO is nothing but a subset of modular programming with some generic toys. At the case of java it's implemented very badly. 
Do you know any other programming language besides the three you've mentioned? Scala isn't related to Haskell - they are different in pretty much every aspect.
In short these people on this thread supporting java don't know any other programming language besides java and they've zero clues on what's PLT. They only know how to follow the instructions of agile-nazis and how to search stack overflow for library samples.
How complex do you tests get? We usually do the given when then As method doc 
A wild guess, but it might get more relevant with HTTP/2.
No, it wont. HTTP/2 doesn't change semantics of HTTP, it just changes encoding.
Enterprise applications are typically data-dependent, not algorithm-heavy. Sure, JavaEE is overengineered. I often gripe about overwngineering in apps I maintain. But the overengineering isn't an enterprise feature. It's just best practices gone wrong gone sexual in the hood. 
Yes, I do. I've done OCaml and Lisp in he past. And you're right about Scala and Haskell being unrelated. I stand by what I said, though. I presume the Haskell fanboy began his life as a Java dev. 
HTTP can stream both the request and the response. The trailer support doesn't have to be in the HTTP header (i.e., 4xx or 5xx response code), but it can certainly be encoded in the response. Something I've done with streaming APIs is to encode a response status at the end of the stream (`{ success: true }` or `{ success: false, errors: [ ... ] }`). This model is well supported in Spring MVC. (Anecdote: I wired Spring MVC into a Spring Integration flow, so I really didn't need a separate request thread, all the flow needed was to be notified when new request data was available. Thus, the request thread was just taking up resources.) Under synchronous IO, the the read on the request stream will block the thread, so a slowly producing client can hold up the thread, which you make up for with more threads. Likewise, the write to the response stream is likely on its own thread (not necessarily, but that's the easiest way to synchronize writes), and if the response is writing a ton of data would hold up another thread. With reactive, the read is non-blocking, and the select call on the read file handles will invoke handlers when data becomes available, on a single thread. Likewise, writes will be scheduled via callback executed in a single event loop, making synchronization irrelevant. Thus, reactive is totally relevant to MVC in certain cases, such as applications streaming large volumes of data over HTTP, such as perhaps a streaming music service. Threads servicing individual requests are much faster, and you are not likely to run into resource limits on a beefy enough server or sufficient horizontal scalability, in the general case. But reactive is useful if you are willing to sacrifice overall throughout to handle many more connections, when the request processing work is light, a useful tradeoff under certain circumstances. The new API allows Spring MVC to be a contender in this space.
Glad you're enjoying the new guide Eddie. Best of luck with your first Java tasks. Cheers, Eugen. 
Nice article... May I propose that you mention String methods that use regular expression (without really knowing it like replace) and sometimes you don't need a regexp. eg parse a file path to get the file extension, parse an xml file. http://stackoverflow.com/questions/16228992/commons-lang-stringutils-replace-performance-vs-string-replace
Nice article, but much to complicated compared to the readable Verbal Expressions replacement: https://github.com/VerbalExpressions/JavaVerbalExpressions
Sure, I'll definitely have a look and potentially update the article - thanks for the suggestion. Cheers, Eugen. 
Nice. Is it setup to use a specific database or nothing at all until a user decides on that for themselves? I see H2 in one of your sub-project pom files. What's with the spotify base url in your main pom?
Neat.
Thenewboston on YouTube has been my goto programming video maker. Codecademy I think has java tutorials as well. 
I suggest submitting this to /learnjava or reading some of the top posts there. I learned from class mostly, but codeacademy is a good resource. Really though get a good book. Head first Java helped me a bit. It's cheap and not terribly outdated. Most important is to practice and avoid bad resources, like theNewBoston. Lots of bad YouTubers out there. With programming there are a lot of bad books that promise you they can teach you a language in 30 days or whatever. Avoid those.
Interesting.
Give this site a try, a lot of redditors have vouched for this site in the past... mooc.fi/english.html
I learned java through a free online college-level textbook at math.hws.edu/javanotes Not only does it cover how to program in java, it also covers how to program _correctly_ in java and talks a lot about java standards and methodologies that youtube tutorials and other sources simply don't cover.
"making spring projects even less transparent" 101
Java API halloween tips: If you are working with Unicode chars, `Pattern.CASE_INSENSITIVE` also requires `Pattern.UNICODE_CASE` flag: Pattern p = Pattern.compile("Å»Ã“ÅW", Pattern.CASE_INSENSITIVE); p.matcher("Å¼Ã³Å‚w").matches() // false :( Pattern p = Pattern.compile("Å»Ã“ÅW", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE); p.matcher("Å¼Ã³Å‚w").matches() // true :) If 2nd parameter in replaceAll/replaceFirst comes from untrusted/unpredictable source (e.g. user input) it must be quoted using `Matcher.quoteReplacement`: String unixPath = "/foo/bar"; // Linux - OK :) ... NOT String nativePath = unixPath.replaceAll("/", java.io.File.separator); // The same code on Windows - CRASH :( String nativePath = unixPath.replaceAll("/", java.io.File.separator); // OK but... String nativePath = unixPath.replaceAll("/", Matcher.quoteReplacement(java.io.File.separator)); // ...you actually should use this // (but beware of Nashorn java.lang.String.replace impl.!!!): String nativePath = unixPath.replace('/', java.io.File.separatorChar); `Pattern.asPredicate` (since Java 8) documentation "suggests" that it uses `Matcher.matches`. Actually it uses `Matcher.find`: List&lt;String&gt; list = Arrays.asList("foo", "bar", "foohno!"); list.stream() .filter(Pattern.compile("foo").asPredicate()) .forEach(System.out::println); // prints "foo" and "foohno!" :( 
Huh, why do you say that? I taught myself java and used that as a basic guide for syntax and I have few complaints. (However I will concede I learned it a while ago)
They are a [discouraged resource](https://www.reddit.com/r/learnprogramming/wiki/index#wiki_discouraged_resources) as they teach questionable practice. They don't adhere to commonly accepted standards, such as the [Java Code Conventions](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html), use horrible variable naming ("bucky" is under no circumstances a proper variable name), and in general don't teach proper practices, plus their "just do it now, I'll explain why later" approach is really bad.
Fair point.
I have to agree. The guy _is_ trying but there are so many bad behaviours taught in those videos. I do hope there's an up to date interactive equivalent of Thinking in Java which was excellent for its time. Definitely head over to one of the learning subreddits but be prepared to ask fairly specific questions if you want a lot of help.
There is a big problem with your idea and that is that the people who are actually knowledgable on this matter aren't as incentivized by these kinds of bounties as 'the rest'. So the quality of the responses will be rather low. You see the same thing happening in SO: people trying to get the first answer in on any question and these are just virtual points. 
&gt; So much haters. Now imagine a company, which needs to filter 100+ candidates. And you'd prefer someone with a cert you can pretty much memorise the answers for to someone who can you know...actually program? &gt; you need to show somehow that you're better than everyone else. That's the thing though. That is not at all what a cert does. 
Well a couple of people suggested Codementor. _Might_ give it a try.
Look up SoloLearn
Oh great... I really like to answer performance issue with "it depends". But thanks for the comment, learned something ;)
Lots of high profile Java developers are active on twitter. Start by following @Java and take it from there.
I'm personally a fan of the EE deployment model, but I work mostly at sane organizations where there isn't some rogue sysop that thinks he needs to take control of the AS because it has the word "server" in it and everything called "server" is his territory. But these guys do exist, and unfortunately the above sketched model is needed to work around them. It's technology solving an organizational/social problem, but it is what it is :(
Twitter is what you're looking for. Check out [this article for more info](http://techbeacon.com/java-leaders-you-should-follow-twitter#.V8mQFUBwK18.twitter).
Yea wait for my next post..I will share with you Thanks 
yea wait for my next link . Subscribe this subredit i will share it for you here soon
[removed]
I'm in the USA.
Guava Strings doesn't have [isBlank](https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#isBlank(java.lang.String)) from StringUtils which saves you from calling trim(). Wonder why the guava authors didn't include that.
 &gt; so I thought I'd try here. Why? From [droidscript.org](http://droidscript.org/): &gt; DroidScript &gt; &gt; JavaScript IDE That's not **Java**.
Since your question is not Java related, you might get more/better responses over in **/r/eclipse** which is a subreddit specific to the Eclipse IDE.
As far as learning goes, the best way to learn is by doing. You'll quickly learn what you don't know by running into problems and trying to solve them. To make your code look nice, I'd read Effective Java. I feel the book is quite intimidating for novice level though. Edit: this is probably better suited on another subreddit, too. Check out the sidebar for awesome tips.
Frustration is good, cause this will motivate you to search for a suitable/better solution.
Agreed. I think *Java in a Nutshell* is better suited for the beginner and *Effective Java* as a follow up.
For quick analysis and performance tests monitoring of heap and CPU VisualVM is decent. JProfiler is not free but is far more powerful.
Badass, thanks! I'll give that a look and be sure to remember it for the future.
No, the NodeJS part is needed for generation, and for working on the frontend. It doesn't work at all like Webjars, we have hot reload, minification, etc... JHipster has started 3 years ago, we have 250 contributors: yes you could do the same kind of thing manually, but don't underestimate all our work, that's going to take you a lot of time to get everything right. The whole point is that we don't do something better than what you would do (I'm also not underestimating you), but that we automated everything: it's making you gain time. It's about initializing, coding and deploying your project faster.
Sure im willing to try anything. What is your youtube link? 
Then again, you are doing something very different from JHipster. You won't have tools like BrowserSync or minification like we have. Lots of people love those tools, they are very popular in the JavaScript community, and I encourage you to have a look at them.
VisualVM for custom JMX module monitoring.
Thanks for the heads up, glad WebJars does have them in case I decide to use them. http://www.webjars.org/ 
Just curious, how many open source projects have you submitted code to? I know that for me, I had contributed to zero until GitHub came along. Now I've contributed to at least a dozen, exclusively through GitHub. I'm not sure exactly why it's so much easier to give and get contributions on GitHub than the other platforms - but it certainly seems to be the case. I'm also worried about the monoculture, but I'm thankful for the explosion of cooperation we've seen.
&gt;Just curious, how many open source projects have you submitted code to? [A fairly large one](https://github.com/liferay). i started when it was previously hosted on Sourceforge, then on its own SVN server, then now Github. what you describe is largely a feature of Git, not Github specifically. I do like that Bitbucket is out there, but it doesnt get nearly the same popularity as Github.
Liferay looks great! After moving to GitHub, have you found that you have any more or less contributors than on previous platforms? &gt; what you describe is largely a feature of Git I know that's theoretically the case, the thing is I just never contributed to anything through the other platforms. One exception is Gerrit, and it took me **so much time** to get just a tiny snippet of code into Gerrit, and navigating the code review has been wildly painful. My gut is worried about the GitHub monoculture, but if it might be akin to worrying about "UTF-8" monoculture. Sure, maybe there's innovation to be had character encodings that we're missing, but by agreeing on one that frees us up to worry about other stuff. I'm sure we're missing out on workflow / bugtracker innovations by having GitHub be the arbiter of those domains. But maybe GitHub has reached a good enough level that projects have more to gain by reducing the initial contribution friction of learning a new bugtracker / code review than they do from cobbling together their own cutting-edge best-of-all-breeds solution. For me, if a project is on GitHub, then I know how to track it and contribute to it. If it's somewhere else, I could probably figure it out, but it might be a pain. Gerrit has certainly been a massive pain, and that has made me cautious of investing time in other unknown-to-me platforms.
https://m.reddit.com/r/learnprogramming/comments/56wa22/this_is_simple_i_dont_know_why_i_cant_figure_it/d8mw8xs?context=3
The current state of GUIs in Java is to use JavaFX 8. Swing (the second best option) is in the process of being phased out and replaced by the aforementioned JavaFX 8. Still, there are plenty of Swing programs around and still in active development. Swing will not be developed any further, but will stick around for some time. 
Swing? I would have thought that swt is preferred over swing? 
&gt; Oh, how I miss php's associative array syntax... Well, congrats, Java 9 has this: Map.of( "foo", 1, "bar", 2, "baz", 3 ); 
Hmm. Yea I won't use swing because native look and feel is more important than being "fully" cross platform (what platforms does swt not work on?) 
It's not (just) about SWT not working on particular platforms, it's more the price that it pays for its cross-platform compatibility. Basically it can only offer widgets which are natively available on each supported platform, giving you a rather limited set of them. At least that was my experience several years ago
There's [Apache Pivot](https://pivot.apache.org/).
&gt;(â€¦) Swing and found working with it fairly nice once you ~~understand the way it works~~ know its limitations, workarounds to bugs and accept outdated design choices FTFY
Headfirst Java is what im using cuz it explains everything in a funny and realistic way (real world examples like couples arguing, funny pics etc), really keeps your attention. Mobile app: Learn Java Youtube: 1. Derek Banas (more detailed, explained well) (https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) 2. Thenewboston. Some like him, some doesnt (the way hes naming stuff is not effective sometimes hard to follow), i liked his first videos, gettin harder to follow later on (20-30+ vid) What im doing is, watching him code it, then re-watch while also typing it in. then change the names,sizes w/e u can and make it your own, adjust it to your logic if needed (careful with that) :) That is if you are still at the core like i am.
yea i am trying to be flexible in this.. and i am only working on java not javascript. You can ask me to help yu in javascript too 
It really depends. The ease at which you can swap the underlying library depends on the similarities between the two APIs. If they are dissimilar, then you're going to end up with horrible code where you try to force the abstraction model of one library into the model of your facade class. This inevitably ends painfully with anything involving moderate complexity. Once objects enter the picture, it truly becomes a mess. If they are similar and most of the library calls are functional, then it may not be difficult to swap out the directly accessed library across your codebase using any number of the available tools to do so. This isn't to say that the faÃ§ade pattern is without merit, but to use it blindly for all cases where third party libraries are used would be a mistake. I feel like these subtleties may have been lost on the author, as he does not list "mismatched abstraction" as one of the cons in his [article on when to use the faÃ§ade pattern](http://zoranpavlovic.net/facade-design-pattern-jaava/)
Idea is using swing.
We use JavaFx 8 for a call centre application, only on windows, but I believe cross platform compatibility is supposed to be pretty good. We replicated two years of development on a web app (moved to desktop to get access to some telephony APIs) in about 10 months, currently running brilliantly in production. Only minor niggle is the occasionally spotty coverage on stack overflow, etc, most of the API documentation is pretty good. 
A facade either simplifies an interface or provides an abstraction over a concrete implementation. It's a bit more refined of an approach than just wrapping everything foreign. 
Really?! I thought it was awt. So far every swing app I've seen was ugly as sin, especially on Linux. 
No, I'm not redefining cross platform. Still, since SWT uses native widgets that rely on the underlying operating system, and that may or may not be available on all platforms, it is not truly cross platform. You cannot deny that fact. Cross platform means: compile once, run everywhere with the same results. Not with some components available and some not.
&gt;Cross platform means: compile once, run everywhere with the same results. No it has never meant that. According to you now suddenly Qt is not a cross-platform solution. That's some big bullshit I have never seen before. Swing has that as a feature, that's true. But cut the crap.
Good point about mismatched abstraction. I have not stated anywhere that you must use Facade or any other design pattern to minimize dependency upon external libs. I should probably add that you should use Facade when you are expecting to change external library, library is not trusted or you just want to use just small subset of library without exposing the whole library to the client. 
Interesting results. JPA is the most used Java EE technology. 
If you are using angular and not using the node build tools you are missing a lot. Jhipster just a sets up a Java back end app with angular front end stuff pre configured so you don't have to worry about doing all that yourself. The angular front end development requires node for their build process. 
Better for sure, then it would leave me salivating for more!
And also interesting that JPA gets approximately the least attention from Oracle. There are a lot of spec issues open, but already a year ago Linda said JPA is basically "done", and recently Oracle said something about JPA not being cloudy enough.
JPA is far from being done. [Check out how many features Hibernate offers over JPA](https://leanpub.com/high-performance-java-persistence/read#leanpub-auto-jpa-vs-hibernate): - extended identifier generators (hi/lo, pooled, pooled-lo) - transparent prepared statement batching - customizable CRUD (@SQLInsert, @SQLUpdate, @SQLDelete) statements - static/dynamic entity/collection filters (e.g. @FilterDef, @Filter, @Where) - mapping properties to SQL fragments (e.g. @Formula) - immutable entities (e.g. @Immutable) - more flush modes (e.g. FlushMode.MANUAL, FlushMode.ALWAYS) - querying the second-level cache by the natural key of a given entity - entity-level cache concurrency strategies - (e.g. Cache(usage = CacheConcurrencyStrategy.READ_WRITE)) - versioned bulk updates through HQL - exclude fields from optimistic locking check (e.g. @OptimisticLock(excluded = true)) - versionless optimistic locking (e.g. OptimisticLockType.ALL, OptimisticLockType.DIRTY) - support for skipping (without waiting) pessimistic lock requests - support for Java 8 Date and Time and stream() - support for multitenancy As for cloud applications, there are many enterprise systems running on AWS and which use JPA. I was involved in developing one of the largest real estate platforms in Finland that was using Spring/Hibernate and all front-ends and back-end services were hosted on Amazon.
That was precisely my thought. "Stay tuned for next week. You won't BELIEVE what additional things I'll reveal!!"
It's the one who pays Linda and Bill that needs to be convinced.
My guess is that it's not even that person, but the one paying the one paying the one paying the one ... paying Linda and Bill that needs to be convinced.
Just to note that Servlet 3.1 does support asynchronous request processing.
IMO as a member of a team which adopted NIO very early. (2004 or so? Before most NIO frameworks) 1. ByteBuffer is too low-level and many people have trouble using it properly (read flip write compact, or was it write flip read compact?). A higher level wrapper/interface which is suited to exactly the NIO common use-case would have helped. 2. There were few default APIs suitable for assembling server logic against byte streams. Pattern: works against CharSequence, StAX2 events: didn't exist until jdk6. Where these APIs exist they don't usually provide efficiency. As a result you may see the claim that stream IO is faster in all practical implementations. It is in fact always faster in only a few trivial cases (see the Grizzly project blog) 3. Sun did not move aggressively to push JEE to asynchronous APIs. Tomcat remained the free reference impl instead of a free glassfish. However not all is lost. There are some interesting projects using Netty to build their services (Minecraft anyone?). I'm also using Netty where it makes sense.
Before Java NIO existed, I worked on a servlet container that was built on top of Windows NT IO completion ports, and static content was also sent using the asynchronous SendFile API. Performance in terms of number of connected clients was really incredible. Following is a little hyperole, but I think Java NIO is more fascinating that people realize since it was never supposed to exist at all. The super-easy-to-use thread-per-client model of Java should have been the greatest victory of imperative programming, and I remember lots of research was devoted to underlying threading implementations to make it all work. The same philosophy left select() out of the Java socket API also. But eventually server writers needed NIO and finally adding it to the user APIs should be seen as a major philosophical defeat, if not for Java then for imperative programming. 
Not to say what is better but you can use maven plugins for that. Very similar to gulp. You can can do pretty much everything with files during the build process. That way you can stick with one build tool for an entire app. Btw what do you mean with inject?
Osm 
This video does a great job of explaining why okhttp steamed forward and the use of NIO didn't catch on. https://www.youtube.com/watch?v=WvyScM_S88c
Agreed, I do remember, Google's search engine agrees too.
I expected more people using Spring Data, such a useful tool also interessting that more people use bean validation than CDI and EJB, especially CDI since its like the glue between all specs.
Well, wouldn't call it the best talk, but still a decent one and still another one is good for perceiving the whole picture better. Thanks!
NIO is super fast but earlier versions had some nasty bugs and once bitten applies I guess.
and https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html
Hrm, I have never had any particular problems with maven projects in IntelliJ, and I've never used anything *but* maven projects with it. Any particular issues you've run into?
I've recently been working on a project which sends low level packets to 100,000 or so embedded systems over TCP/IP and we originally started with the standard 'old' IO library. It quickly became apparent to us that the blocking nature of it would really cause issues when we tried to scale it, so we tried NIO. The systems we were reading used to take around 2 hours to complete, simply switching to NIO brought it down to around 30 mins. Crazy fast in comparison. The individual calls were only marginally faster, but the way the threading was handled... I shan't be using standard IO libs anymore. 
Regarding ByteBuffers, they are a bit awkward. On the other hand, take a look at Netty's ByeBuf. Much simpler to use and masses more functionality, with buffer pooling to boot ! It's also available as a standalone library which is great since it is very useful in all sorts of non NIO specific scenarios. Ehm ... What else... Good metrics available, auto extending, built in support for r+w with streams, clever memory allocation algorithms and smooth integration with java ByteBuffers. Now if we could just get rid of those nasty APIs using byte[]... Yeah, I'm looking at you, Kafka !
Which part of Java 9 do you find pretty darn good?
Thanks for the link, I will give that post a try. 
The basic reason is that the NIO API provides only the primitive low-level APIs for doing the IO but none of the library infrastructure to use those APIs. Most developers don't want to have to deal with IO at that level and the original java.io APIs provide that convenience. If you wanted to write a program to read a byte from a socket and respond with a byte using NIO using the techniques you'd need for a production application handling thousands of simultaneous connections you'd en up with a couple thousand lines of code in several classes. Minimum. That's not where most developers want to be. As usual the solution is libraries. There have been some libraries such as Grizzly, Mina and most popular lately Netty that make NIO much simpler and provide the appropriate robustness and scalability needed to really take advantage of NIO.
Isn't basically Hibernate the JPA implementation that everyone uses? Who uses EclipseLink?
Really cool, thank you!
Does anyone have a characterization of HotSpot improvements for Java 9?
There's also the possibility to use something like GWT or Vaadin.
I was just referring to the tooling status and is it in a usable state for building simple toy apps and learning/using new features. 
IDEA also supports Java9 syntax
&gt; Maybe Jigsaw and the Process API will make groovy and clojure more viable for devops purposes. My hope as well and funny you should mention that, because that's precisely what I'm looking to play with Java 9 for, a re-working of some of the tools around clojure. Clojure, as much as I love it, has a fundamental problem loading too many classes on startup. Even worse Leiningen is built with clojure, compounding the problem. People sometimes blame the JVM for slow clojure startup but it's really clojure and it's tooling's own fault, and that needs to be fixed. 
What exactly is an "installable Internet application"? Is it basically just a webapp in a window? So... The DOM and everything? 
Java has call by *Reference value*, so it is entirely possible to change the contents of objects inside a method and that changes are reflected outside. The following is legal and fully possible: public class Test { private List&lt;String&gt; myList = new ArrayList&lt;&gt;(); public void changeList(List&lt;String&gt; aList) { aList.add("Item 1"); aList.add("Item 2"); // etc. } // Rest of the code to complete a full class omitted. } This approach often makes returning multiple values unnecessary.
OSGi has great support for bundle/package versioning. You can even set it up to fail the build if you have breaking API changes against the last released baseline and forget to update versions according to semantic versioning rules. You can resolve a set of run-bundles containing however many different versions of the same package or bundle as you need.
What about returning different types?
* It's more complicated and error prone as instead of dealing with a return value, you're dealing with a value that "magically" changes. * The method isn't going to suddenly switch up the order of the parameters next time its run (Unless someone did something really weird in there), so you do always know which variable from the Tuple is going to be which, if you have two different types then you are still going to have to know which side you want, it's not like you're going to be calling a method tuple.giveMeTheIntValue, you'll be calling tuple.left or tuple.right. * At least with a map and Enums you get a nice hint as to what value you're getting, map.get(USERNAME) and map.get(ADDRESS) for example at least tells you what you're getting from the map. A map also makes the usage cleaner the more parameters you need to return. All this aside, I'm not sure really of a situation I've come across where I really ever needed two values from a single method that didn't then benefit from having those two values encapsulated in some other logical manner such as a full object. Do you have a real world example that you came across where you found this to be the best solution to your problem? I'm not trying to say that there isn't a situation, I've just not come across one so would be interested to read about it.
What's wrong with creating a dedicated type to capture the combination of the elements to return? The desire to return multiple things in the first place indicates a concept you should make explicit is implicit. Tuples can be a generic solution but if you can find a more expressive concept, especially the code consuming the returned value gets way more expressive.
&gt; * It's more complicated and error prone as instead of dealing with a return value, you're dealing with a value that "magically" changes. Isn't the usage of Out&lt;T&gt; in the method signature already a strong hint that it is supposed to change? &gt; Do you have a real world example that you came across where you found this to be the best solution to your problem? I'm not trying to say that there isn't a situation, I've just not come across one so would be interested to read about it. I've had a method which copied a file and returned a boolean to indicate whether it succeeded: boolean copyFile(Path sourceFile, Path destinationDirectory) { // copying... return success; } Then later on I wanted it to return the resulting path (directory name with the file name appended) and simply added an Out&lt;Path&gt;: boolean copyFile(Path sourceFile, Path destinationDirectory, Out&lt;Path&gt; destinationPath) { // copying... // fill destinationPath return success; } 
[removed]
&gt; 3. is at least typesafe but, if for example, you want to return multiple strings, then you have to know which tuple attribute contains what value. No. Due to [type erasure](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html) this isn't type safe at all. ~~At runtime a tuple can be set to anything.~~ Also your Out class, which I really don't see the point of, more or less duplicates [java.util.Optional](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html). The best way to return multiple values from a method is to simply define another class. At least these are actually typesafe. 
For java up to 8: &gt; How many of these have actually been removed? The answer is simple: none. For java 9: &gt; In JDK 9 some previously deprecated APIs will actually be removed. The number is very small; only six methods are being removed.
&gt; You are thinking in C++/C# but writing code in Java :) . So you don't like it because it is to C++/C# like?
&gt; So you don't like it because it is to C++/C# like? Languages are different, and so are the required thinking patterns for using them efficiently.
No, you basically created mutable versions of it. Optional is not mutable nor should it be. With the type-unsafe options available (tuples) yours is pretty much slightly less bad than returning an array of objects. 
I've always taken it that if I need to return multiple values from a method then I should have spent more time designing, returning to the design can sometimes result in a small class to hold multiple values together (often ends up being used elsewhere and solving other things) occasionally however better design makes the issue moot...
I'm not a Pivot expert. I've used Pivot for desktop applications. Unfortunately, finding Pivot tutorial material written by anyone other than the Pivot team is difficult.
It isn't, I'm not entirely sure the above guy is correctly understanding how type erasure actually works in practice, or the difference between your class and an Optional. Though Optional does raise one thing, a isPresent() method might be nice to add to your class that throws the exception when the value isn't there and an access attempt happens, it would add a nicer way to detect a missing value that your code is expecting instead of having to deal with catching an exception.
My recommended way to prevent the exception is explained in the [Tips](http://www.pera-software.com/html/blog/returning-multiple-values/returning-multiple-values.html#tips) section.
&gt; It isn't, I'm not entirely sure the above guy is correctly understanding how type erasure actually works in practice, or the difference between your class and an Optional. public void doSomething(Out&lt;String&gt; aString) {} public void doSomething(Out&lt;Integer&gt; anInteger){} This for example won't work. You are correct however that the "At runtime a tuple can be set to anything." bit was a brainfart on my part. 
You are talking about this problem https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotOverload
For simple toy apps, Java.exe and Javac.exe are the only tools you need.
I dont understand serverless. If I use 'Spring Boot', it is said to be serverless, however, Spring boot still uses tomcat under the hoods. It is a server.... its just that the webapp does the configuration, rather than the configuration being in the conf directory. Serverless is not a prerequisite to doing microservices....adam bien is doing microservices, deployed to docker containers http://www.adam-bien.com/roller/abien/ So, please tell me, what are the advantages of a serverless vs war+server type app. I dont see there being any...(appart from forcing abandonment of JavaEE for political reasons) 
Well, I'm certainly not against the idea of loosely coupling your interaction with third party libraries, I think that's a very good thing in fact. I am just opposed to the thought that depending on third party libraries is a bad thing altogether. We are probably saying the same thing here though. I think what you are trying to communicate is that you should be able to swap out libraries at will if they no longer suit your needs and not that using libraries is somehow a bad practice altogether. Edit: I think maybe this would be a clearer stement of the problem: &gt; The main problem is that you become ***tightly coupled*** to that external library and that is something that we should try to avoid as much as possible. 
Yeah, that's right.I mentioned in introduction section, that we should use external libraries and in conclusion section I wrote when you should write facade around them. Maybe, I will edit my conclusion to make it more clear.
The exception bit is weird. What's wrong with throwing the exception? Seems pedantic to instead have to add flow control (i.e. if statements) to examine for possible exceptions inside Out objects. Instead let the exception be thrown and use a try-catch, seems much more succinct, clear and conventional. Multiple conditional return values seems like a code smell to me, unclear what the method does. Not conclusive, but indicative that their may be a problem. If you really need multiple values, I'd favour adding a class, or just using something like a map, or DynaBeans.
&gt; does it mean that people are preferring Servlets over JSF to develop non-SPA web apps? I hope not. Servlets are great for lots of stuff but to fully create a (server side) web UI with? That would be awkward... Likely it means people are using Servlet with some framework, such as (but clearly not exclusively) JSF. Most JSF users would likely say they're using Servlets, since JSF is based on Servlet. We should also take into account not all developers may recognise that they're using JSF, strange as it may sound. Oracle and friends didn't quite put "JSF" out there as a very clear brand, and the confusion between Mojarra, MyFaces, PrimeFaces etc is there. Of course Servlets have the same problem with Tomcat, JBoss, Jetty etc, but less so.
I'd suggest some reading before jumping straight into building stuff. While it covers an older version of the language, I think [The Java Programming Language](https://www.amazon.com/Java-Programming-Language-4th/dp/0321349806/ref=oosr) is still an excellent introduction, it's how I learned Java almost 2 decades ago (after being totally baffled by some other books, including "Java in a Nutshell" by O'Reilly). Another more recent book aimed at programmers with some Java experience is [Effective Java](https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683), it's a list of "do's" and "don'ts" from a very experienced Java developer, and it's great. While not Java-specific, I consider [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1?ie=UTF8&amp;qid=1476291319&amp;sr=8-1&amp;keywords=clean+code) to be required reading for any professional software engineer.
Using my phone for reddit, so I didnt see that there was such a thing. Thanks a lot for the help!!
There's a whole world of tooling for you to learn. Rather than drown you in choices, I'll give you opinionated recommendations. Become familiar with Eclipse, Maven, Nexus, Jenkins, SonarQube, in that order. I don't care if you've been using Java for 20 years, if you aren't using SonarQube, your code is very likely garbage. If you are a beginner, the recommendations it makes while you code will be enormously helpful. It's like having all of StackOverflow peeking over your shoulder and pointing out every stupid thing you do, as you do it. "You're using Java 8. Stop using HashMap and use ConcurrentHashMap, n00b." That sort of thing, but nicely :) You can sorta simulate the SonarQube recommendations with a few Eclipse plugins, but these are no substitute: PMD, Checkstyle, and Findbugs. I run all of them in addition to SonarLint.
Besides the fact that you are, as /u/Trailsey pointed out in the wrong subreddit: &gt; had a small doubt in LinkedList implementation. Have you **read** the [**Official Java Documentation for LinkedList?**](https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html) This documentation explains every method that you mentioned in detail. When questioning Java built-in classes, **always refer to the official documentation first.** Usually, you can just google "Oracle Java &lt;classname&gt;" and you will quickly get to the relevant Java documentation.
Since you want to replace the frontend of your web application caring about JPA and DAOs will not propell you forward since these are backend structures used for data persistence and access. If you really want to use **Java** and **MVC** for your front-end Spring MVC is the way to go. But if you are basically learning a new framework anyways you might just use some of the latest JavaScript Frontend frameworks like React or Angular[2] and thus seperate your frontend from your backend. If you want to just migrate your whole team to a new language and thus only Java, stay on the whole Spring Stack. It is generally also possible to stay one part on the old infrastructure and just expose the backend e.g. via REST and consume it from your frontend client of your choice.
In addition to the great advice posted by others, I'd suggest the following: "empty your cup". Java and javascript, other than some similarity in basic syntax, are extremely different. OO vs. Prototype, etc... Approach Java as a new thing, don't try to "map" it to javascript in your mind.
Not proven, no
I just want to know what is out there and might be worth looking at that I could potentially drop into my servlets app to build a JSON API. Reading Java stuff feels completely impenetrable due to the huge number of acronyms and "enterprise" speak and design patterns for your design patterns. When I go to the Spring web site, I am completely put off because everything I am reading requires a huge amount of context that I don't have, doubly so for Java EE. The application requires a level of interactivity that can only be achieved through SPA, unfortunately. I just want to know how to build the JSON API in a way that works with the current code, not how to architect the whole thing.
True, and I guess because of the preference of those developers JBoss initially wanted to lead MVC. There was definitely something going on behind the scenes. I asked at Devoxx last year about why JBoss suddenly wasn't involved anymore and the response was more than a bit evasive.
I think what you are looking for is called JAX-RS. It is the "standard" way if building REST APIs in Java. There are several implementations of the standard and you can pick whatever you feel comfortable with. Personally, I recommend using the reference implementation: Jersey. You can install Jersey just as a standard servlet in your WAR application and it will serve your REST API nicely. If you need more functionality, you can add stuff like dependency injection to it. Lastly, if you want something to bundle Jersey with some other tooling like DB access etc... you can look at Dropwizard
Thanks! That is exactly what I wanted to know.
I find a bit strange that some deprecated things can be removed in the future... while I approve that, and I really think it's necessary to do a real "clean-up" on the Java library, wouldn't that make all the "back-wards compatibility" thing fade away?
Wow - the Oak specs!! Const was still in play! ` interface InterfaceName { const int aConstant = 42; .. . } `
In my opinion JPA is *far* from being simple, except if your application is very simple too. 
SWT looks like pure and utter shit, this is why Eclipse looks like shit. Go with JavaFX for new development.
Spring Boot is your friend. There's a lot to take in, but JPA / Hibernate are your ORM, and with projects with Spring Data REST, you can easily map entities to REST endpoints. Take a look here: * [Intro to Spring Data REST](https://spring.io/guides/gs/accessing-data-rest/) * [Spring Data REST Project Home](http://projects.spring.io/spring-data-rest) 
Well I was generalising what is a Java Spec
&gt; Isn't Red Hat or more specifically the JBoss department already a major(?) backer of GWT and AngularJS? &gt; At least the WildFly/EAP admin console is build with GWT and they have this CDI connect thing called eliad or so. JBoss tools seems to put a lot of emphasis on AngularJS editing (and far less on GWT or JSF these days). Yes, you are absolutely right. They still contribute to the Errai project for GWT and they have been investing in improving their Javascript tooling. With MVC so popular on both the .NET and Spring frameworks, it may be worth for them to invest in this area as well.
C# took a Java-like syntax and introduced C++ idioms like "out" and "struct". These features don't really make sense in Java. If you have a situation where you need a method to return multiple different Types of data, you should return a custom class to represent this data, if only so that anyone browsing your code in the future understands what that data represents. Otherwise, if you're returning a list of objects, they should all be the same thing (A list of user names, a list of URLs, a list of phone numbers), so there's no confusion to the caller what they are getting from your API. If I saw a "tryParse", Out&lt;T&gt;, or something similar in the APIs I work with, I would be confused, and annoyed that I have to learn yet another nonstandard thing. If you're trying to return a dynamic list of attributes / values by name, use Properties (or Map&lt;String, T&gt;)
&gt; There's Apache Pivot. They really should put up some static images before forcing people to install stuff (...if they only want to see what it looks like)
Build out a separate API layer, then slowly deprecate the .jsp pages once the new frontend has feature parity? EG, use something like Vertx (vertx.io) or Dropwizard (dropwizard.io) to build out a simple greenfield API, run it on a separate domain (api.yourdomain.com), and then start building your user interface against that. Don't know about Dropwizard, but you can run Vertx in a servlet to ease the transition.
Find a project and work on it. You will learn on the way. I take computer science in college and I rarely go to class and have been managing by self teaching(I do not condone my lazy behavior, go to class!). Find a good book on Java (there so many on amazon for cheap, you do not need a full on $200 textbook) and go from there. Once you finish reading an introduction to Java book I would grab a Java Data Structures and Algorithms book to continue onto more advance things. 
Since REST is just a set of subjective guidelines which can be interpreted to mean a wide variety of things; it could still be REST. If it were SOAP, it would be 100% locked down.
I'm quit partial to just using Spring's JDBC templates and RowMappers. It gives you the control/flexibility of plain SQL with the convenience of automatic object mapping and without the constant SQLExceptions everywhere.
If you want to be really hip, which is what you of course want, then refactor everything into *microservices*, use async and reactive patterns liberally at places where it makes sense and of course also were it doesn't make sense. Then having gotten rid of the monolith in the backend, front it with a giant monolith aka SPA for the frontend. Yah for progress in IT. /sarcasm
[removed]
&gt; Because everyone knows what he means : A load of endpoints that are accessed via get/post and put, which return s and consumes json. This type of REST definition is like a new age book talking about how "quantum physics" align the universe with your inner feelings. It's a popular interpretation of a term with a specific meaning, and completely incorrect. REST needs specific resource representations (as in distinct Content-Types, for HTTP in particular) that describe the semantics of the resources its interacting with. The semantics of JSON are "bunch of maps, lists and scalars", nothing more. An API built this way relies on implicit ad-hoc interfaces defined by the individual API makers. So if your REST endpoints return "application/json", it's not REST, *unless* the semantics of your REST service is to store, process and return *generic* JSON blobs, that it doesn't understand the meaning of. Custom Content-Types can use JSON as an underlying format, but they need to be related to the type of entity being returned, for ex. "application/cinema-program+json", or "application/payment+json" and so on. And such a Content-Type should be registered at IANA to meet the "uniform interface" constraint of REST, which is *not* optional. I'm not trying to sound elitist, just set facts straight. But chances are you'll ignore what I say and shut me down, instead. Which is also how a fan of "The Law of Attraction" would react to a physicist explaining quantum physics.
This is the original PhD that first defined rest, https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
Look up the Richardson REST Maturity Model. 
I'm aware of it. For what purpose?
Spring spring spring spring....AGHHH! people. "I want to make a simple hello world web app" USE SPRING BOOT. "I want to connect two systems together passing rest messages between them" USE SPRING DATA "I want to boil a kettle of water" USE SPRING MVC I will put my neck out, and say *DONT* use spring. You already have tomcat. Upgrade this to TomEE http://tomee.apache.org/downloads.html . Exactly the same setup, everything will work as you already know... configuring it exactly the same.... you will be up and running in minutes. HOWEVER, you then have the ability to use REST, with tomee decoding /encoding the java beans to JSON automatically. No bullshite. Really... 
You are right!.... It shows how popular frameworks can be base on company pushing them into the forefront, rather than any technical merit they have. #frameworkdogma 
&gt; What do you think? It's one of those judgment calls for the library maintainers. Is this method useful? Sure. Of course it's useful. Is it useful enough to be in the library? Well... The [Guava](https://github.com/google/guava/blob/c462d69329709f72a17a64cb229d15e76e72199c/guava/src/com/google/common/collect/FluentIterable.java#L416-L432) and [StreamEx](https://github.com/amaembo/streamex/blob/d021d02b57c8708421d8bbd433c24271215ef5e2/src/main/java/one/util/streamex/StreamEx.java#L107-L122) maintainers apparently thought it was worthy for inclusion in their libraries. The JDK maintainers did not. I don't think there's a right or wrong answer here. If you feel strongly that it should be in the JDK, go ahead and make the case on `core-libs-dev`. There is a reasonable default implementation for this for the `Stream` interface, so it's not impossible to add. Personally, I don't encounter this pattern often enough to be turned off by `.filter(instanceof).map(cast)`. I use that pattern and I think "that's just the way things are" and I don't dwell on it too much.
Seems this method is not really needed in standart library. You can use [StreamEx](https://github.com/amaembo/streamex) for doing this. StreamEx.of(shapes) .select(Circle.class) .mapToDouble(o -&gt; o.getRadius()) .average();
I've said it before, and I'll say it again: Don't decide on anything else before you've tried [Play! Framework](https://playframework.com).
Pattern matching.
I guess you're refering to something like this? example: { do_stuff(); } I didnt even know they were called labels tbh. I sometimes use them to escape multiple loops at once since you can simply use "break example".
As mentioned by /u/johnmcclean in [his answer](https://www.reddit.com/r/java/comments/574vi6/proposal_for_stream_a_casting_filter_by_class/d8q5fvi), jOOÎ» has copied LINQ's `IEnumerable.OfType` method for these use-cases: // (1, 2, 3) Seq&lt;Integer&gt; seq1 = Seq.of(1, "a", 2, "b", 3).ofType(Integer.class); // ClassCastException Seq&lt;Integer&gt; seq2 = Seq.of(1, "a", 2, "b", 3).cast(Integer.class); You're obviously looking for `ofType()`, which you can also implement on your side, trivially: static &lt;T, U&gt; Stream&lt;U&gt; ofType(Stream&lt;? extends T&gt; stream, Class&lt;? extends U&gt; type) { return stream.filter(type::isInstance).map(t -&gt; (U) t); }
I lolled
Would u give a try to Rust.. à² _à²  And then go back to Java again?I'm not sure.
How well Kotlin works with dependency injection frameworks, such as Guice? Any differences than with plain Java? The syntax is pretty great.
The nested loop example, where you can use "break example;" to exit an outer loop seems like something I might need to use, but in eight or so years of programming Java professionally, I don't think I've ever used it.
Yeah, it bothers me immensely that "goto" is a reserved word in Java. Like it's just lurking there ready to rise from the grave when the correct blood sacrifices have been made.
The fact that other libraries which provide Stream extensions support this is a good indication that the core Stream implementation should support it. I've often needed exactly the same thing.
I saw it once in a complex custom Matrix based diff'ing algorithm someone had implemented as part of data collection to escape multiple levels of nested looping based on specific conditions. It was written in a very low-level C-like style as well. I personally haven't had the need to write myself either, nor do I anticipate myself using it any time soon. However, it is good that there is always an escape hatch available, even if you don't have to use it until you need it.
lets pray it will never rise
I am still considering Spring MVC, but there is a massive acronym barrier in everything I read about it.
I'd really love to learn Kotlin but there aren't any good tutorials that take you from the basics to something somewhat advanced.
what's the roadmap for bringing the version up on android?
I didn't say anything about Android. 
This comment is incorrect, and I'm not really sure of the purpose of this line anyway: val name = null // String? type It will not infer that this is a "String?", I believe the type will be "Nothing?". In some cases the Java and Kotlin blocks are not really equivalent, and this is going to cause confusion. For example, in "Null II" the actual Java equivalent of the first line of Kotlin would be: final Double length; if (text == null) { length = null; } else { length = text.length; } I think you should probably try to make the Java and Kotlin blocks exactly equivalent, or as close as possible, to avoid confusing people. You should probably also mention that some of the later examples would be a lot more concise if using the Java 8 streams API, as others have mentioned (not everyone is stuck on Java 6 or 7!).
Using JNA/JNI you can write your own library for this and have it call the C library. If you do not want to do this, then you can write your own implementation.
Don't know about the roadmap, but here are the few currently supported Java 8 features: https://developer.android.com/guide/platform/j8-jack.html (though requires a new compiler)
Both "const" and "goto" are reserved words, but have no function. [Wikipedia - List of Java Keywords](https://en.wikipedia.org/wiki/List_of_Java_keywords)
Spring (and it's slew of annotations) works out of the box, no problem.
Start with Java EE friend! It is basis for Spring anyway. Then if you know basis, then it you still want, you can look at Spring. 
Grails is bit slow is it not? And groovy is not so hip anymore. Yes, you can choose it to be different if that what you want, but then why not choose struts 1? Then you are different too.
Downvoted for thinking that everyone uses Windows
Spring MVC with Jackson for your json converter, super easy. Spring boot web gets you up and running quickly, and allows you to ease into development through the use of profiles. It's a completely different way of thinking, but if you want some help, getting started, PM me.
Actually, it's just the opposite for goto. It existed in the very early days of Java (or Oak, not sure). They removed it before the language was ever public, and keep it a reserved word as a kind of intentional backwards incompatibility. Here's James Gosling talking about it: http://www.youtube.com/watch?v=9ei-rbULWoA&amp;t=17m25s
Only the language features require the new toolchain. The APIs work with both.
Kotlin looks like Groovy...
Gradle and Maven solve the problem of *Dependency Management*. Your build file specifies that you need a particular version of a library, and the build tool downloads it and places it on your build path. This, for example, will get you version 3.4 of org.apache.commons.commons-lang3. Dependencies can be *~~transient~~ transitive*, meaning "because my project depends on library X, and library X depends on library Y, my project also depends on library Y". This is where the problems come in. Let's say you depend on library X, which depends on version 1.2 of library Z. You also depend on library Y, which depends on version 1.3 of library Z. You now have a conflict. You need versions 1.2 and 1.3 of library Z. It might be ok to just take the latest version, but it might also break something. Let's say version 1.2 has a class called `com.foo.NetworkConnection` with a method `connect()`. It has a bug, and library X has logic that depends on how that bug behaves. Version 1.3 also has a class called `com.foo.NetworkConnection` with a method `connect()`, but it fixes this buggy behavior, and library Y depends on this fixed logic. Currently, you're out of luck. Jigsaw is in part an attempt to provide *Dependency Isolation*. It's a mechanism to allow one portion of your code (ie library X) to depend on one version of a library, and another (ie library Y) to depend on a different version. This function already exists in a framework called [OSGI](https://en.wikipedia.org/wiki/OSGi), but this will make it a standard part of the JDK. There's a bunch of other stuff in there, like breaking the monolithic JDK into separate pieces that can be stitched together or separated as necessary, but the above is what will probably affect developers the most.
Did you try kotlin koans? It is a very good tutorial.
Can you give an example of a nice feature in missing out on? :)
I'm not quite sure Jigsaw try to solve the versions problem. What I know it solves is the encapsulation problem.
Awesome answer. Small correction: the word is "transitive" not "transient".
&gt; The meaning of â€œthe bestâ€ actually depends on you. It depends on your needs. For you, â€œthe bestâ€ language may be the language which pays you the most. or the language which lets you work from home, or the language which is the most versatile language and lets you work on some cool and exciting stuff. Thank you.
It's irrelevant imho.
I looked in the comments when I saw that word. You nailed it!
So, the idea of "out" parameters is obviously not new. Some considerations: - You make caller responsible for setting up "out" parameters, which is the opposite of DRY. Unlike C, there is no meaningful setup here (no memory allocation). - Your method is now mutating the state, which makes it harder to understand, use correctly, and test. - Single return value promotes the SRP-compliant coding style, and "out" parameters do the opposite, promoting creation of mish-mash monolith 1000-line methods. Ideally, I would prefer inline type definition at method declaration, combined with "val"-like variable type declaration. Absent that, explicit type declarations for return types are probably a way to go.
Look at the spec for Jigsaw at the chapter Non-requirements. From spec: Multiple versions â€” It is not necessary to support more than one version of a module within a single configuration. http://openjdk.java.net/projects/jigsaw/spec/reqs/ But I remember from some talk that multiple versions in single configuration will not be supported. Basically version string will be ignored. So lets say we have a module com.foo.bar:1.0 and module com.foo.bar:2.0 for the jvm that is the same module.
Is there something like Spring Framework for Rust and IDE like IntelliJ Idea?
As someone who has used DW, it definitely is super easy to end up with a nicely packaged service that you can just run from the command line and change config via external file but it doesn't come with the same types of "container" services like Spring or Java EE and so you need to do some more plumbing yourself.
On the other way, all those features over-complicated a simple thing to be done. Using JPA is much more lightweight and easier for none-initiate than going in "hibernate".
It actually took some inspiration from Groovy. Also some of Groovy's contributors we're involved in Kotlin's development.
Just when I thought I knew a lot about Java
... easy: give me some tape and I'll implement every app for you with my Turing machine. No dependencies at all!
So "demanded" == "best"?
Correct. I think James Strachan (original Groovy author) was involved (or still is) at some point. In general I think the Kotlin syntax is a mix of the best bits from Groovy and Scala though I do wish the language had Groovy-style collection literals. The factory functions just are kinda ugly.
It does make sense. Why compile on startup every time when neither the CPU nor compiler has changed?
Spring boot is the shit. Ninja is ok... but Spring Boot shits all over it. Give it a try!
This is a monster truck feature. Occasionally useful but will be mostly used by jackasses who don't really need it.
[removed]
However, enterprise applications demand advanced data persistence requirement. 
&gt;However, enterprise applications demand advanced data persistence requirement. Actually, my financial company would had been better with JPA for their needs, but they follow your "recommandation" of advanced data... but we don't use that (advanced...) and we have the overhead of it.
If you took the time to learn Scala, there are far better "frameworks" than Play like http4s.
Have you looked at Grails? I haven't used Play but I think it similar followed a similar path to Play e.g convention over configuration and a lot of stuff just working out of the box. Grails 3 is based on spring boot.
I'm working only in Java. For me Play Framework is easier, faster than spring boot and have hot reload built in, which dramatically speeds up development.
I have used Play 2.2/2.4 quite a bit and it was 100% via Java. There were a few very obscure cases where something existed only in the Scala API but it was very, very rare. From what I understand they are also planning on improving upon the Java support further in Play 3.0. Play and Spring Boot both have their strengths and weaknesses. Play and it's autocompilation are very cool. It's also a bit cleaner and simpler to use in some ways. Spring/Spring Boot on the other hand are much more comprehensive. Basically everything you could want to do is supported and probably mature. One of the reasons we switched from Play to Spring was so we could use Spring Security for instance... Play does not have any libraries that even really compare to it. There are a number of third party auth solutions but none of them are as mature or complete.
Interesting, I had forgotten about that one, what do you like about it?
I don't think I'm that interested in Grails, just because I don't want to get into Groovy. It does look like it has a lot of stuff though.
I wonder what's that overhead? You can use JPA with Hibernate too, which is actually another level of indirection. Prior to 5.2, the EntityManager is just a delegate to a Hibernate Session. Now, the Session implements the EntityManager interface.
&gt; You could write an entire system procedurally in the main function. While the `main` method still *must* be in a class. If we are being pedantic semantic your statement is also wrong because writing something *procedurally* requires splitting code in procedures (methods), which isn't possible inside the `main` method, though. What *is* possible is to write it *imperatively* (which Java generally is). Had you said that you can write everything in *a single class*, your statement would be valid. 
I've been using it for years. Clean, open source microservice with a great community of devs, Sinatra inspired(which most are nowadays), very fast, and runs in an embedded jetty so you just run the jar, no container deploying necessary. http://sparkjava.com/
fair enough, only suggested as code written with Java syntax is almost fully compatible with Groovy and using @CompileStatic you can take advantage of static compilation if that is a concern.
I kind of agree with you, but: &gt; For the initial release, the only supported module is java.base. In other words. The most likely use of this feature will be to pre-compile (at least some of) the JDK classes to the benefit of all Java applications.
shr and shl for bit shifting? I don't like that syntax.
[Jooby](http://jooby.org) definitely. It offers all the things you mentioned and more: * Script programming model (like sinatra/expressjs) * MVC programming model (like Jersey/Spring) * [Plugabble Web Server](http://jooby.org/doc/servers/) including Netty, Undertow and Jetty. * [HTTP/2 + Server Push](http://jooby.org/doc/#http-) * [Server-Sent Event](http://jooby.org/doc/#server-sent-events) * [Rich REST APIs](http://jooby.org/doc/devtools/) with live testing and documentation using Swagger or Raml * Hot reload of classes for [fast development](http://jooby.org/modules/) * Maven (primarily) but also [gradle](http://jooby.org/doc/gradle/) * [Assets processors](http://jooby.org/doc/assets/) (sass, less, jshint, ..., etc.) These are just some of most valuable features of [Jooby](http://jooby.org), but there are a lot more to explore thanks to the extensive [module eco-system](http://jooby.org/modules/) Thanks. 
Data structures, efficiencies of algorithms (big o notation), threading / concurrency concepts. 
Been there. Tried hard to like Play 2 but got tired of the forced upgrade - 'we've decided to do things differently in the next 2.x release' - cycle. After looking at a bunch (including Spring Boot, Vert.x, JHipster) I settled on the [Ninja Framework](http://www.ninjaframework.org/) as a very Play 1-like replacement. There is a lot less 'magic' about it: no bytecode enhancement and they seem to take the "Maven is the defacto standard, so we'll use it by default too approach". I'm no fan of Maven but that does mean you can pass off a Ninja project to someone else to maintain and they don't have to throw out all the Java conventions they know. The community is small but they still make progress. There are not nearly as many modules available and documentation is light once you get passed the topics available as part of their site content. Ninja's SuperDevMode, when combined with the [fizzed-watcher Maven plugin](https://github.com/fizzed/maven-plugins) gives me something close to Play 1's rapid - make a change, see that change in action - development cycle that made Play 1 so productive.
Concurrency package. Java threading is simpler than pthreads http://docs.oracle.com/javase/tutorial/essential/concurrency/
Thanks! I've been doing hackerrank problems as practice because it's nice to actually be able to run my code and see if I'm getting the correct output. I'll see if anywhere else has good problems with answers I can check against.
Okay cool. I'm pretty functional with file IO in Java but I'll take some time to ensure I'm doing everything efficiently. I'm sure I will never know enough about inheritance and polymorphism but I"ll try and brush up.
Yes. I was hoping they would mention the practical limitations in the JEP.
I've been asked about Design Patterns in two interviews recently, so 8'd suggest those. Worthwhile to know in practice anyway.
&gt; One of the reasons we switched from Play to Spring was so we could use Spring Security for instance... Play does not have any libraries that even really compare to it. I think this is also a major thing why many new developers are just using Spring boot, it's very easy to set up Spring security and it's almost out of the box. We got Play! authenticate for Java, the guy who wrote it, doesn't care much about the project anymore, there are heavy bugs all over the place and even simple caching the user is missing. It seems like the lightbend philosophy is something like: "We only provide the http tools for you". Security is a heavy topic, I agree, there are so many different scenarios we have to cover but at the end of the day, an official security/auth framework directly from lightbend would keep developers happy and would also make profit for them in the long run, because users are satisfied. They should not underestimate small developer teams either because a small idea can become a startup which later could require commercial support which again leads to money and growth as a company. 
I usually get asked about knowledge of the streaming API, and weirdly, every time I get asked to name implementations of the Collection interface (ArrayList, HashMap, etc)
Don't forget JDBC, man.
There will be an expectation that you won't know everything coming straight out of school. I would say that you need to go in and show passion for coding, and commitment to learn as well as some of the more specific concepts other people are suggesting. When you talk about something make sure you can back it up with examples. Talk about projects you have worked on and how you learned from them. 
Yeah, I doubt we will see it in JBoss, but it will play a part in their OpenShift strategy.
Most interviews I've been to involve some questions about data structures(stack, queue, trees etc) and to discuss how you would implement them. Java isn't really needed but pseudo odd is, just to show your thought process. Another thing they will likely to ask is knowledge of design patterns such as factory, observer, and even MVC. More advance interviews will ask about concurrency in detail and even knowledge of rest.
I'm looking forward to seeing that in action ðŸ˜‰
Pretty sure it's extremely valuable to know if you are allowed to have comments before you declare the package... /s
Community is still small but growing every day. Have a look a t the number of release, commits frequency, response time at github or google group and you'll see it is highly active (more active than other micro web frameworks). Another key feature of [Jooby](http://jooby.org) is the number of unit and integration tests. Code coverage is close to 100%. We are very confident on what Jooby can do and how it works.
This is pretty neat, but I absolutely agree it can become a "golden hammer". Part of the reason why we should prefer more primitive implementations is that they will be more discoverable &amp; comprehensible to people who inherit our code. For example: on my honor, I will not use this InjectionPoint config to create a logger.
Wow, super impressive work, congratulations! I think I now vaguely remember you from a Play mailing list post a couple years about how you were going to write a Play 1 style framework, so cool that you stuck with it. A couple quick questions: How much bytecode enhancement do you do? And how does the performance overall compare to play 1? Thanks again and I will definitely check it out.
Kotlin data classse don't HAVE to contain immutable fields, it is acceptable to use "var". I use them a lot because of the automatic implementation of hashCode and equals, and it's nice to have an automatically generated constructor for JPA entities.
lateinit saves the day here. I'm working on a spring boot app in kotlin, stuff looks like this. @Controller open class MyController { @Autowired lateinit service: MyService ... } Without lateinit you have to mark this as a nullable type and the language will force you to check it before you use it, with lateinit you are telling the type checker you know this value will be initialized before you use it (and if it's not you will get a kotlin exception saying it wasn't initalized before access. I'd you're using a DI framework that doesn't go initializing fields behind the scenes for you it works exactly how you would expect.
Have you seen the article about the application using like 160 Annotations in 300 lines of code? Hilarious! From a business perspectice a framework should deliver a better performance-wise and more bug-free version than you could so you can focus on your business logic 
The dependencies were copied from the JUnit 5 GitHub page, but you're right, they should actually be `test`.
It doesn't sound like this has anything to do with Java or Python. Both have their strengths, and while I'm primarily a Java developer, I do use Python for quick scripts. I couldn't imagine using Python for any large-scale projects though (10,000+ LOC). As a programmer, you'll learn to use the right tool for the job. Reading your post, I'd say you had the following problems: 1) **You're unfamiliar with Java.** There are going to be some adjustments that you'll have to make while learning a new language. I would say you had the same problems when first learning Python. 2) **You left your project too late.** You mentioned it yourself, but it bears repeating. Obviously you're not going to be writing your best code when under a tight deadline. Don't procrastinate next time. 3) **You need to learn to debug.** There's no way that a missing ! should have taken you an hour to hunt down. I'm guessing a project for a class is max a few hundred lines, so you should have easily been able to find the problem in a few minutes. Look at the variables in your debug window, learn to step through your program properly, and train your intuition when there is a problem. 4) **You need to learn your IDE.** Java tooling is amazing, and you need to learn it. From what you said, your problem stemmed from having '=' instead of '!=' in a conditional. Your IDE should have flagged that with something like "Conditional is always true" (IntelliJ does by default, not sure about Eclipse). That would have given you a massive clue that something isn't right. 5) **Write some tests.** Now I didn't do this in college, but it's a good habit to get into. If you had written some tests, then noticing the problem would have been trivial. Now it's a shame that you got a 0, but use it as a learning experience instead of just stating that you don't like Java and Python is better. It'll take a little while to get up to speed with Java, but it's worth it in the long run.
In short: you screwed up and blame Java for it instead of your own negligence in every aspect (starting too late, not coding properly due to pressure, inefficient debugging, etc.) Sure, Python's fully spelled out boolean operators are nice, but every C-based language uses the same boolean operators as Java - so better get used to them.
And I doubt he would have found the bug earlier had he used Python and had the same experience / knowledge with it as with Java.
8'd? That's a new one. Phone keypads ftw
Not everybody is hunting upvotes ðŸ˜‰
iPad, actually, toggle between alpha and num has "i" and "8" on the same key.
Stop looking for excuses, getting a CS degree means you're gonna have to learn how to debug, clearly you're just scratching the surface. This won't be the last time you're spending hours on an easy mistake.
public class JavaSubreddit extends Reddit {
 private static final int NUM_SPIDERS = 1_000_000;
That won't compile with those underscores in the int ;) *Edit Fair enough, it does now. 
http://docs.oracle.com/javase/7/docs/technotes/guides/language/underscores-literals.html
One reason is naming. The @Component is a too general name as well as is @Service. Sometimes you want to specify the component's role more precisely e.g. @DomainService. Second reason is brevity. Say you want a strict application service layer (a pattern of DDD) that acts like business facade and is the one responsible for transactions. In this case, you define your custom @ApplicationService annotation as a stereotype of @Transactional @Service with @LogInvocation (the latter is a my custom annotation for method call logging using AOP). Now, instead of specifying three annotations you just include one.
Okay, these are some good tidbits to know. Thanks!
Alright I think I have most of that covered. I think I do sometimes worry I don't know enough but it's reassuring to hear that I'm not expected to be an expert. I'm willing and happy to learn. :)
Yeah, I have, and it drives me nuts whenever I think about it. I'm working on a spring app with both a web app using spring MVC and also a background service that share the same database. I find it mind boggling that if I went the route of tossing Jackson annotations on my JPA entities I'd be forces to pull than entire library in or I'd get class loader exceptions because they need runtime retention, less a pain in the ass to just write a DTO and use dozer or something.
You're welcome
Well, depends on how much technical debt you want to introduce. Every additional line needs to be maintained. I think, there is always a trade-off.
System.out.println("I'm afraid some idiot made the spiders final and static, so while I'm sure you'd love to kill " + n + " we can't change the variable." );
return false;}
}
&gt;cannot find symbol -- variable print
 public boolean funcyBooleanFunction (int a) {
if (n &lt; NUM_SPIDERS) {
// Do you even do Java?
 try{return (Math.random() &gt; .97);} //I dare you to override this with a finally block.
return !0;}
what does this do?
When the class is loaded it runs the code in the static{} section meaning that despite the main method returning ~~null~~ immediately, the method theOtherMain() runs also
Syntax error. Expected boolean return type.
`Reddit.java:3: error: class JavaSubreddit is public, should be declared in a file named JavaSubreddit.java`
 finally { try { return funcyBooleanFunction(a + 1); } catch (StackOverflowError e) { new Thread(new Runnable() { @Override public void run() { System.out.println("super funcy! " + a); funcyBooleanFunction(a + 1); } }).start(); } }
true. just trying to share!
Not the first time either. Once had a moth land in one of my switches. Took me forever to find the little bugger.
Needs to be declared static 
It returns void. 
bad title
Do you mean `System.out.println`?
You can't even fix it with reflection, the field disapears during compilation :( Maybe the spiders disappear too?
Haha. I like Business Insider's list as it doesn't include C#. 
I suppose the spec says â€˜between digitsâ€™, and â€˜xâ€™ is not a hexadecimal digit.
this, 1000 times! that is also a big issue on how software development is taught in universities/colleges. I do teach in a college, and when I give exam exercises, half of the whole grade is based on the tests. But I guess I am an exception, not the norm :)
No, void means there's nothing to return. It's not what the function returns.
20 GOTO 10
let's not
`static{System.out.println("real programmers don't need more than one line anyway");}}`
But Python has ! too...
Testing helps as projects get bigger - in any language. A good coverage gives confidence that everything you do works fine. (A late school project that just needs to run once on the teach's PC, oh well whatever...)
Does someone have a tutorial for basic security in EE7? Or am I better off using spring security?
private int spidersStillAlive = NUM_SPIDERS;
if (n &gt; 0) {
// [I made one for you](https://www.reddit.com/r/java/comments/57nur1/lets_write_a_program_one_line_each/d8u8v0n) 
What about command line applications? What about tests?
I run Maven and JRuby hundreds of times a day I'm sure.
Actually it is not. You only have: int, float, long, double, and reference. A method that returns void, just does not push any value to the stack and not a "void" value. The Java language, there is the boxed `Void` type which appears in Java SE.
TDD next time OP
The barrier to entry keeps the chaff out as well. 
I wish them swift success with this project. The benefits to the Java community will be huge.
Differnce between oberloading overriding ???
System.out.println("It was not such funny ");
Yea there are more ways but its the easiest way in my point of view
You can use this, but Scanner is not very efficient for large sets of inputs. You cal also use a BufferedInputStream or a BufferedReader, or implement a solution based on StringTokenizer (my recommendation).
For begineres ??
[removed]
Please, in the future post your programming/learning related questions in either /r/javahelp or in /r/learnjava as they are set up specifically for such questions. Both subreddits also provide learning resources.
Might well be - thanks for the info! 
JVM != Java, Java runs on the JVM. &lt;https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf&gt; contains the specification for Java 8's virtual machine. There are "void" return types in method signatures, but that only means that no values are pushed onto the stack after a method is invoked. Read _2.2_, _2.3_, and _2.4_. `Class` is also made for the Java language, you can implement a working JVM and not have any instances of `Class` (although any code that relies on `Class` instances would not work). To the compiler, `&lt;primitive type&gt;.class` is syntactic sugar for `&lt;boxed type&gt;.TYPE`. 
Python the most readable language my ass, I had to do some Python for PostgreSQL triggers, even heavily commented I still can't figure out what the heck it was doing when I came back to it a month later. My best... using Python 3 then along comes a dependency on 2.7 :(
Thanks!
I still don't understand how they could make primitives and generics work... A generic is an Object and Objects can be null... primitives can't be null there will always be a value assigned to it. Mind blown. ie: List&lt;int&gt; list.add(null) ??
* **JavaScript:** required client side script language. Requires good tooling due to its nature. Has many caveats. Was improved with ECMAScript. * **Node.js:** good quick setup backend server for "small" projects or helper. Nothing big should be implemented here. I like to use it for drafting services since you can achieve a lot in a very short amount of time * **Microservices:** bad name for a practical approach if your business grows * **NoSQL:** makes sense when you need NoSQL. Making something as default regarding NoSQL and SQL makes no sense. It depends on the domain and architecture * **Functional Programming:** makes sense if you have to transform tons of data (like Hadoop, Big Data in general) * **Agile:** makes sense if you are working in a fast-paced environment. The faster one generally wins due to the lock-in effect. Without the correct management this can be a heavy burden on your teams. It is part of your culture.
"When it makes sense" : of course, I agree. But, sadly, I think there is currently a big problem with some of those (buzz)words having very powerful effect on people who probably shouldn't be in charge of deciding which technologies to use. Can you believe that, where I work, they try to show they are "Agile" by using fucking Post-its everywhere? Or that Node.js has been choosen simply because it's trendy? This is so sad. 
lwn just had a good article about this question: Why kernel development still uses email http://lwn.net/Articles/702177/
Yeah that was the point, I couldn't wrap my head around how they would make primitives and objects operate and let's say I enhanced some byte code under the assumption that we were storing a referenced value especially if there is no byte code verification, would this crash the JVM (Some Java agents need this off) Edit: What would be the behaviour of a Map&lt;int,int&gt;? If you use a Map.get(key) it shouldn't return null
I've found that adding this to your nightly build system (you do have one of those, right?) can help catch shoddy tests. If you're already practicing TDD, it won't catch as many issues, but it'll certainly be more useful than something like jacoco.
&gt; Edit: What would be the behaviour of a Map&lt;int,int&gt;? If you use a Map.get(key) it shouldn't return null I think this is one of the problems they're still figuring out. One idea is that Map.get(K) will only be available when V is known to be a reference type. http://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2016-March/000111.html
On larger projects, it takes too long to run, especially if it already takes a few minutes to run through all your tests as it is. I guess it depends on how many build servers you've got available, too.
I don't see why it would be a problem to build on every push if it only took a few minutes to run through all of your tests. Bear in mind that this will typically occur asynchronously.
System.out.println("reddit is awesome");
It's not a few minutes typically. It took 25 minutes to run pitest on a 55,000 line code base. Standard mutators and 4 threads concurrently.
I was unclear, I was referring to the necessity of having a nightly build system in general. Long-running operations, like integration tests or pitest, probably should run less frequently if they take more than, say, 5 minutes.
Throw the J2EE book away, it's been Java EE since 5 and we're on 7 now. I guess some of the APIs haven't change much since then but much of it has changed quite a bit and gotten very "convention over configuration" and annotation-based.
Method overloading: In a same class defining multiple method with same name and different argument Method Overriding: In method Overriding we inherit method from super class and provide new implementation without changing method signature. See below link: http://javaforlearn.com/method-overriding/ @princeabc1 
Yes. Thanks for catching that.
[From this page](http://www.guru99.com/mutation-testing.html), I learned the following: * Mutation testing creates mutated versions of your software. * It's a whitebox approach because it modifies (hence, needs the availability of) your program's source code. * It does NOT evaluate your code per se, but your unit tests, to see if they're precise and thorough enough. * It's intensive as fuck.
That's amazing. And all this time I was using a gradle plugin, manually running that and manually opening the HTML files
Exactly. It changes (mutates) your code to see if the mutations make the tests fail. If they do, the mutation is considered killed (which is what you want), if the tests don't fail, the mutation 'survives', which means your tests are most likely incomplete
In my current project we are heavily using RestAssured as client. It's wonderful and has also automatic json and xml parsing capabilities out of the box. And it has a very nice fuent syntax (given, when, then). In comparrison apache httpclient seems very rusty and outdated. Catching your exceptions? No thanks ;)
Try, but I don't want that to happen on my CI
What are the situations where TMP is preferable over a composition based approach? Maybe when the class implementing the abstract methods needs to call back into the superclass?
Javascript everywhere / Node.js = technical debt Microservices = technical debt NoSQL by default = technical debt Functionnal programming = technical debt Bonus question : what do you think of Agile? = bonus technical debt
&gt; At some point, if you want the language to survive and thrive, they'll have to do it. Java is clearly surviving nowadays. C is also a surviving language showing that this is not needed. On the other side, true functional supporting language are not really surviving. Who is still using lisp ? You can also use a top level language for expressing some things and still use Java for the remaining part. This is currently the opinion of a lot of people with Scala 
RuntimeError as well because of auto-boxing.
Doing anything just for the buzz is just plainly wrong, but that is management and they do not understand the flipcoin. If it raises your business value, then you should adopt it. It is the same as with programming or other patterns. Other: &gt; I used 15 patterns here! Me: &gt; why? Other: &gt; ... Netflix has a very nice dev culture. They mainly use Java(/JVM) for the backend, but that does not mean you are forced to use that (maybe you do not like Java, or you want to do something more hipster like) but they just provide the nice tooling for Java (and their frameworks), so if you want to do anything else you have to do it yourself. 
Just picked up number 2. Any tips on best way to approach this book?
I recommend running it locally after every code change - size/time is a non issue if you mutate just the changed code. This way it is more likely the information will be acted upon. 
Required reading: http://puredanger.github.io/tech.puredanger.com/2007/07/03/pattern-hate-template/
Not to be rude but the way you described your question shows that you are not ready at all. There is much much more to programming that knowing the syntax of java. Until you can write some what complex program then you're not ready for a job. Spending a few weeks learning a language is not going to suddenly get you a job. If that was true everyone would do it. Work on a few projects and when your ready make something cool that you can show and put on your resume. This is going to be a long process that will take years. You're not going to know "nearly everything about OOO" at least not for many many years. 
The first time I read it, it was cover to cover, but Iskimmed the subjects I already was aware of or not really interested in. After that, I used the book rather as a reference. But I also once made a point to completely re-read it, a chapter a day.
The thing I'm missing most is a powerful search functionality. Long threads would be nicer to view if not organized by months but by full threads. Hightlighting for posted code snippets would another nice thing. Just to name a few.
I think you're unnecessarily discouraging. Instead, this should encourage to learn software patterns (common in OOP or not) and move towards the "web" part of Java, which is where it really shines and is most widespread. Imo, looking into common frameworks, checking what technologies job applications around you require and learning those, THEN building a sample project to put on GitHub and advertise on your resumÃ© is the best course of action.
That's a good start. Get it finished and start something else. More practice won't ever hurt.
So just apply and hope for my luck? ^^
&gt; Java's approach of "(almost) everything is an object" was a reasonable match for the hardware and compilation technology of the mid-nineties, when the cost of a memory fetch and an arithmetic operation were of comparable magnitude. No, it wasn't. * GC was expensive proportionally to number of objects even in 90th. * Memory wasn't cheap even in 90th, and each object header takes a lot of memory. &gt; Imagine if we did lambdas and streams, but didn't do default methods, that allowed the Collection classes to evolve to take advantage of them -- Collections would have instantly looked ten years older. Imgine we still have hundreds of problems with default methods, because we cannot extend collections with missing functions like `List.isSorted()` or `Stream.toList()` because we do not have extension functions. (BTW, first proposal of lambdas (cannot find link right now) had extension function. Unfortunately, it was rejected).
So how do you use Zester in the newest version of intellij? There is no run button where the tutorials say it should be.
Yes, just learning the syntax isn't going to qualify you for a job. Software projects are enormously complex webs of functions and responsibilities. On top of that, working on a project, especially with other people, requires so many other skills too. In order to qualify for a job, it would be best to get yourself a software-related degree, either in computer science or software engineering. I understand that there are other software/IT-related degrees in colleges, but I don't know of a single person who has gotten a software job with one of those degrees. I suppose it's possible to self-teach yourself and get a job, but you have to have projects to prove that you can follow through with making a good project. Even with a degree, a good portfolio is a near-must anyway. Any decent University should have a co-op program to get you the critical experience you need to make yourself more employable. They will also help you decide whether you are in the right field.
Warning: Out of everyone I graduated, I am the best case. Graduated a little over two years ago and I make 92k in Connecticut, my wife is also a java developer, and we own a rental property. Financially, life is pretty awesome for us. Work life for me is great. I work only 8 hours and have the rest of my day and weekends to do whatever I want (no kids yet). My wife on the other hand works crazy hours. I've seen her put in 18 hours in one day. I think the problem people face is poor management of expectations. She will estimate a project 1/3 of the time it actually takes then has to work over time to meet the deadline. In 5 years i figure I'll be a tech lead / team lead. Maybe if I am lucky I'll be an architect. My advice is while in college find an internship at a company that has a career development program. Even if the pay is lower then market value, you'll learn more. After graduation you should try and keep the interest in programming. If you see code/patterns that doesn't make sense, ask questions.
Most java jobs I've seen will be easier to get if you also have some familiarity with the following: 1. sql 2. spring or javaee 3. at least one application server [tomcat/jboss/glassfish etc] 3. javascript 4. html/css 5. git 6. maven 7. at least one major IDE [eclipse/intellij/netbeans] There might be some jobs out there where you can just write java, but realistically you'll want to prepare for the full stack. You don't have to know everything about everything, but at least understanding basic concepts of the above will dramatically change the type of jobs you can get.
Find out what your professors know outside of that class they are teaching. try and make a project that uses those technologies. Ask them for help when you get stuck. Also on your class project (even group projects) go over board. After you complete the basic project spend more time to make it better or use a different technology. I posted this in another thread: "In class I tried to see what they were teaching applied to my internship and tried to learn from them about things that could help me outside their classroom. For example I had a professor that worked at microsoft, so I built a chat program in asp.net and used her knowledge to make it work. I learned about salting and hashing passwords, WCF, IIS, and C#. She was only teaching a basic html/js class. Edit: I almost forgot. I also made sure I left some 100 level courses for my senior year. I spaced out my work load so that a hard programming semester would be paired up with painting and volleyball."
If you are at a research university, look into opportunities to work as a student worker on projects in your (CS?) department. In graduate school we would hire undergrads to work in our lab, and it gave them a great environment to learn to work on a team on intellectually interesting projects. If you work on such a project and really put effort into it, you will have more to talk about with interviewers to impress them with your practical experience. It even helps for getting internships. 
As others have said, it is very dependent on where you live, what sort of company you work for, what you think makes a good work/life balance, etc. I graduated just over a year ago with only 18 months programming experience, having done a MSc conversion degree in CS. Got a job straight away and even started full time employment before finishing my thesis. I did have some team and project management experience but none of it was tech related and I didn't feel not having done internships made any difference to my prospects. I work on interesting projects with cool technologies. I'm treated as an adult (which I've never found in a workplace before) and am trusted to complete the work I'm given, so I have the freedom work the hours I want. Generally, I'm doing seven hour days, two or three of them a week will be working from home. I'm paid fairly well and will be looking for big pay increases in the next few years as my skills improve. I also realise how lucky I am working on a small project for a small company, where I don't have to deal with the tedium of meetings, the bad management and the intractable deadlines that plague many software development projects. I also have little interest in working for one of the big tech companies or working in high pressure fields like gaming. 
unless they're reddit programmers. *i have faith in them*.
I work from home in flip flops and shorts, for a startup. Every once in a while we'll have to do crunch time which is pretty hardcore in terms of impacting my personal life, but otherwise the work is pretty low stress. /r/cscareerquestions is for career questions. Entry level is the hardest time to find a job as a Java dev because fewer people want to pay for any time you spend finding your feet. Big corporations are more willing. It really really helps if you get internship experience in undergrad. You're pretty much expected to know git. You should definitely learn the basics of maven or gradle. Web programming is the most in demand, if you learn Spring MVC you might find work easier. 
I rarely hear about java being used in startup environments - how common is this? Probably will take up Spring MVC if I don't do python/django
Do you even VCS?
Nice to know that. I did not know of that feature.
If you treat NoSQL as relational, you're gonna have a bad time.
PIT mutates the byte-code, not the source. 
I have about 9 years experience coding Java and currently work as a Software Architect. My first job was a graduate positions building a large back-end system for around 2 years at a big company. I learned a lot here from other experienced developers. Use this time wisely as you can getaway with asking a lot more questions as a graduate. This was also the hardest job to get and also the only one that asked about my degree. The first job is more important than your grades at university. I know a head of engineering that has no degree and just went straight into coding at a young age. A lot of the coders you will meet just have a passion for coding and learn in their spare time. My degree mark was rubbish, and I really struggled with getting the first job but after that it didn't matter. I did work hard outside of work to learn as much as I could, getting advice on what to read to make me a better developer. After about 5 years I moved to a senior position. I actively asked "what did I need to do to get a senior position and pay". Took me 6 months to get with 2 rounds of pay rises. This worked well for me and was a great step to getting much better pay. I guess the lesson here is that you should always be aware of what your skills are worth and ask for what you want (without being threatening) otherwise you probably won't get it. &gt; How's life and work on the daily for you? Life and work like others have said depends on a lot of factors other than coding Java but I for the most part quite enjoyed work. The big thing for me is the people. I've noticed most people can handle having to work on shit projects but time and time again I see people leaving because they want to get away from other people they work whether that is the manager or a college. There should always be a balance between work/fun. Also I've never worked at a large bank before as they will work you from 8.30am till 7pm without fail. Currently I won't do more than 7 hours a day which I think is reasonable. &gt; Where are you headed in 5 years? Technical Management if possible. Definitely pays more and also feels like you have a lot more say in the direction for the company. I think that after 9 years I've not got the same passion for writing code anymore. &gt; Anything we should learn extensively? Design patterns. https://www.amazon.co.uk/Head-First-Design-Patterns-Freeman/dp/0596007124 Software Architecture https://leanpub.com/software-architecture-for-developers Algorithms http://algs4.cs.princeton.edu/home/ A good knowledge of the above and how to apply them will separate you from the rest of the crowd. There are many other books that you should read on top of this but too many to list here. And of course a good knowledge of Java 8 &amp; Spring Framework. 
Oh no, no way, I'm talking minute changes over minutes, not hours. :-)
IntelliJ has a local history for a long time and a lot of other useful features ;) 
There is probably a lot you still don't don't know but you don't have to be a full stack developer to get a job. I would recommend start looking at the spring framework, it's very common. Also look at either Gradle or Maven for building your application. Finally Java is very commonly used for the web so start looking at a web framework, like Spring Mvc. People have a lot of opinions about what web framework is the best but I think at least to start it will be a good one because you should learn Spring anyway(the purpose is after all to get a job so something common is good). To get started fast look at Spring boot, it comes with an embedded web container and is very fast to get going with. But I would also like to say that it does a lot of magic behind the scenes that you should not take for granted. Learn the core concepts behind it (servlets, dependency injection etc). Spring in general is great but you should know how the magic works. After this there is a lot of other stuff you should learn like unit testing, design patterns, ways to persist data(I would say mongoDB is good to start), git, client stuff like JavaScript, SCC and HTML. The list gets long but learning it all at once will become to much and not all jobs will need all these skills. Good luck and don't get discouraged! :)
Well it makes sense if your whole team works on the master branch and you use something like SVN for VCS, but if you require to make backups from your workspace (wth!) you should switch to something like Git which allows local commits and cloud-based private repositories you can commit too to share your code. 
Where I shop, the only "milk" in cartoons is almond milk.
&gt; 40hrs of effort uncommitted Who in his sane mind would do such a thing? If anyone did something like this in my line of work they would very soon be looking for a new job. What if your hard drive had crashed? What if your computer had been stolen/damaged by fire/water/whatever? First rule in programming: **save often** and **always** have a backup. Use Version Control systems.
Wow that algorithm link is fantastic! Even as a fairly seasoned dev that's really useful.
Do I understand this correctly, that this replaces the JIT if you choose to use the AOT? Why not just combine both? &gt; It is possible that the use of precompiled code could result in less-than-optimal code being used, resulting in a loss of performance 
I went to a state university in the mid-west and decided to move out East Coast (Boston area) to see the country a little bit. I started right out of college around $80k and after working here for two years I am up to $92k. I work 8 hours a day maybe have answered one email on the weekend. Time is very flexible and working from home or taking a vacation day is welcome, not looked down upon. I do full-stack java for our internal stakeholders so I get to work directly with the people that are using my code which is cool to see. My best advice for you is to make sure you know a lot about semantic versioning. That was the biggest obstacle for me to wrap my head around when dealing with other dependencies and all of the automation that makes enterprise applications run.
Oh there are quite a few but those guys actually just focus on their product instead of writing blog posts about their hipster stack. [Here are a few jobs for Java devs](http://stackshare.io) and [Here](http://stackshare.io/search) 
&gt; If VCS means revision control system Yes, it's common to refer to them as Version Control Systems as well.
https://github.com/opencv-java http://openimaj.org/ https://chimpler.wordpress.com/2014/11/18/playing-with-opencv-in-scala-to-do-face-detection-with-haarcascade-classifier-using-a-webcam/ http://codereview.stackexchange.com/questions/7865/building-a-breakout-game-from-scratch 
Focusing on any one specific language is a good starting point....there is a possibility that things will change, ultimately you will learn many languages if you plan on being a professional. It will influence and enhance what you do and how you build your services, patterns, design approaches. Prepare to spend the rest of your life studying and learning. If it is your passion, this won't matter. You will find in the beginning there are a lot of people complaining, bitter, and you tend to have some shitty situations thrown on you. Fight through it, the grass is greener on the other side and it doesn't matter the company, skill, etc, they all have this same barrier. You'll be tested like anyone in any situation. As you sharpen your skills, plenty of times from failure, you will climb higher among other developers that are just like you. People who shortcut and write shit code have a low ceiling. Be choosy who you spend your time with because they will influence you. Right now you have an opportunity to focus solely on programming and unleash your passion on it in some of the most creative ways. If you have a shit professor, use your own imagination to push the envelope. The more diligent you are while studying....the more of the line you will be able to jump when you are out. Money will come, autonomy will come....the hardest thing to find is to be surrounded with other talented developers. If they aren't around you now....go out and find them. You'll spend your life looking for them and before you know it....they will be searching you out as well. 
Oh sorry, I didn't really answer your question. Haskell and other functional languages excel in concurrency, largely because most everything is immutable and you don't have to bother with locking. And there is a larger name for it (edit: referential transparency ) , but in FP, you expect the exact same results everytime you call a function. Something about if you were to 'expand' every function into an inline call, it would look and behave exactly the same way. Functional Programming in Scala is the best functional book I've ever read. 
I have a 2 year degree in computer programming &amp; analysis. Got hired at a large consulting firm following a 10 week industry training, got laid off from the consulting firm at the end of the year and have spent the last year trying to get any kind of development work. I live in the central florida tech corridor and am pretty salty about it, but from what I understand in this area you cannot get an interview without a Bachelor degree. 
Java 8 is actually really, really slick - I could see using that in a startup no problem. Me personally, I'm addicted to types - and now Java has a lot of the other goodies with the new streams API as well. It's been a good few years for Java.
Just want to bump this one ( good advice ). If you're looking for job security, especially right out of college, you'll want your Java skillz up front.
I'm trying to make the move to data science / analytics. What kind of tools are you using for Java ? Mostly I've been in iPython and Matlab ( still learning ).
+1 especially the part about never stop learning. You should go into development with a scientific mind. If you're not learning new things you'll get bored and end up in middle management /s (really, though)
Is it better to shoot for a larger enterprise to work for over startups? I'm in a small city that glorifies a lot of its startups, so I don't know if I'm feeling some kind of, 'echo chamber,' effect here. A lot of people in my classes tend to hype them a bit while knowing the lack of job security. Is it better to just immediately shoot for an enterprise job?
That's for you to decide ultimately. Are you looking to start a family? What are you financial goals? Can you handle the cubicle life?
It's more towards the big data end. Nosql databases like apache accumulo/hbase for bigass key value store, neo4j for graph databases. Streaming data, apache nifi is a fantastic ui-based way to hook this to that, apache camel is another good hook anything to anything type plumbing thing. Handling complex events in esper or drools, kind of like applying a sql query to data in motion, with ability to operate on rolling time windows. Storm and hadoop used to own the territory but it's evolving rapidly. 80% of the software stack is open source apache, basically. Data science jobs usually go towards R, matlab, python, I'm sure you know. Maybe I'm more of a data engineer or data plumber. There's a huge demand for big data people, if you can spell hadoop you can get six figures.
No desire to start a family, I want to strive for financial independence ultimately, and maybe even early retirement. I'm not sure about cubicle life, however. If the hours are alright and company culture is decent, I'd be willing to put up with it. Idk if it matters but I'm a woman. 
The _what_ serialization?
I am working in a benchmark. It should soon (probably within one week) be published in the github project.
Well, that's a question we always should ask themself before starting that kind of project. Kryo is a well established library and will probably do the job for many. With Externalizor I wanted to integrate the best compression model. For instance, I currently use Snappy for arrays and there will be more specific compression in the next releases.
&gt; You can throw a rock and find a job in Java around here. He barely started. Applying now would be a complete waste of time. Sure there are a lot of Java jobs but typically those are quite a bit more complex than very basic web apps. 
Jesus Christ, he wrote it that way EVERY TIME on the GitHub page, too.
Of course. He will change it on the projet too. And this is the first issue. Please subscribe :) https://github.com/qwazr/externalizor/issues/18
You can actually reply to individual people and they'll get a notification. And it's fine that you are telling me how I should "see" stuff. I'm telling you why no one is going to actually use your library in production. 
&gt; Kryo handles this case I don't see the point you're trying to make. It would still require me to implement Externalizable on all my domain classes. 
Wasn't this going to be a proprietary-only â€œcommercialâ€ feature?
Apart from the video already posted this gives some insight: https://www.youtube.com/watch?v=uNgAFSUXuwc
No Javadocs - *seriously*? What's the difference between an Externalizer and an Externalizor? Do you handle object graph cycles? How does performance compare to Kryo?
Well, you're in _luck_! Many companies are still ~~stuck with~~ using Java 6, including the place where I work, heh. I guess migration is hard in the java world. Anyway, you can check what [Java 8](https://github.com/winterbe/java8-tutorial) offers and build up your skills by doing a sample project. I'd definitely have a look at [Spring Boot](https://spring.io/guides/gs/spring-boot) for building web applications and services. Other than that ZeroTurnaround offers a nice recap of what's been happening in the Java technology landscape recently. * [Java Tools and Technologies Landscape Report 2016](https://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-2016/) * [Most popular java frameworks](https://zeroturnaround.com/rebellabs/most-popular-java-frameworks-tools-and-libraries-2016/) 
Java is often used for backend systems, running either as a Web archive (WAR) on Java EE Application servers (Glassfish/Payara, JBoss/Wildfly, Tomcat/TomEE) or as a JAR-that-bundles-everything with Spring Boot. Java EE and Spring Boot are both mature production-ready frameworks and it's hard to say which is better as both have their pros and cons. Spring Boot does make it easier to use your application in a container-based (Docker) infrastructure as it is as simple to run as java -jar myapp.jar. This means that applications typically expose a JAX-RS/REST and/or JAX-WS SOAP interface to be used by things like web sites (through AJAX calls) or (mobile) applications. The current job market is mostly about these backend technologies although there is some (a lot?) frontend work with Spring MVC as well.
&gt; Well, you're in _luck_! Many companies are still ~~stuck with~~ using Java 6, including the place where I work, heh. I guess migration is hard in the java world. I work with a project that started out as Java 3. It still had loads of Java 3 style code throughout. It actually does use some Java 6 features now, but amazingly they've managed to make it fail to build on Java 7 or 8...
&gt; It would still require me to implement Externalizable on all my domain classes. If you want to use Externalizor as the only and main serializer, yes, you have to do that.
Don't listen to this comment, learn core java. Collections, concurrency, hierarchy of classes, hierarchy or exceptions, JDBC and so on. SQL is a must. And maven. Maybe basic EE, like servlets + jsp + jstl + containers, and web stuff, like http, http methods (difference between get and post, when to use each, restrictions of get). Only after start tinkering with web frameworks and such. You will thank me later. 
I found this tutorial to be really helpful to explain most of the basic concepts that Spring introduces: http://www.tutorialspoint.com/spring/
Thank you!
GIT and commit often you numpty
But why? Why would I want a dependency on a library that is already asking me to add other dependencies that are related and overlapping. What is this library real benefits vs. its counterparts?
This, I had a complex object graph and used Kryo Unsafe to Serialize to Apache Ignite. My testing revealed Kryo was slower than plain old Serializable. Ignite uses its own enhanced Object[Input/Output]Stream where apparently the bottleneck can lie. 
1. Consider "Java Concurrency in Practice" (JCIP) instead; it is a newer alternative to Doug Lea's book. A lot of Lea's stuff is actually in the Java API now, and JCIP builds upon that. 2. No 
&gt; 3) Counting conditionally with case Stop doing this: &gt; select sum(case when mobile = true then 1 else 0 end) as mobile_count &gt; from impressions; Start doing this instead: &gt; select count(*) filter (where mobile) as mobile_count &gt; from impressions;
There is no type `bool` in Java.
 Spring recipes - book - was good once. Don't know about the recent versions. Use Spring Boot for getting started - it will ease the ramp up period. There's a lot of fine tutorials aimed at 20 - 40 minutes or so. If you want to master Spring and understand what's really going on, then read from the reference documentation. Don't forget to create example code - play with it - that's when you really learn. 
Ahem... release date in the **past**? Think that you need to delete and resubmit - the release date is 27^th July of **2017** (not 2016).
Microservices. Overview: https://www.youtube.com/watch?v=4wtupt-Q5sQ Details: https://www.youtube.com/watch?v=1aaw7iYS_VM Philosophy: https://www.youtube.com/watch?v=PFQnNFe27kU Oh yeah and Java 8 basically introduced functional programming and new concurrency APIs. Get familiar with that.
After all the old java you've worked with you want a build and web routes (MVC) framework which won't drive you nuts. IMO start with Spring Boot and Gradle. Then compare maven to gradle for the same projects.
Java 6 -&gt; Java 7 is pretty straightforward. Java 7 -&gt; Java 8 is less so, but this is a transition many devs are currently undergoing. Long story short, you haven't been "left behind".
I imagined the situation where you do not want to commit to a public location or you do not have the ability (e.g. no connectivity). When else do you not commit for a whole week?
but why would the AOT will result in a loss of performance if you opt in the JIT afterwards? This can only be better than using the plain Java Bytecode or not?
For the usecase mentioned, quick serialization of custom classes, how is this better than serializing manually? You already have to make each class implement a specific interface, and with it's impossible to beat custom serialization done right since you can use the minimum bytes possible (or bits if it is super critical that it's small) since you can have the serialization be order dependent - this library already assumes you drop support for cross-language communication.
I use Hackerrank.com a lot 
Great Scott!
Where do we get the 1.21 Gigawatts to drive the flux-compensator to go back in time?
You're new to CS and you're new to Java. So here should be your progression: 1. Head First Java (HFJ) - take your time here if you aren't good in any other OOP language, otherwise skim fast. 2. Some important concepts aren't covered in HFJ, (I think Generics, Threading, Reflection etc) for that go to Oracle's official documentation and go through their tutorials. 3. Effective Java by Joshua Bloch. You will find this a difficult read, go through it slowly, you will have many questions while reading it and it's natural, it's not a book for light hearted engineer, it's deep, but when you finish the book you will feel enlightened (like Buddha!!) If you still have an urge to learn more Java. 4. Java Concurrency in practice. If you want to learn about JEE (Java Enterprise Edition) then it's a huge restaurant where you find every cuisine, decide what you want to learn in that. Every dish there satisfies the thirst of a different customer, so it's easy to get confused. Probably just read first 2-3 chapters from that J2EE book to get an idea about the JEE architecture or the level of thinking that is required. Rest of the book would be obsolete today. Before diving into JEE, the first things to learn are Servlets and JSPs, I would recommend Head First Servlet's and JSPs by kathy Siera and Bert Bates. Reading books will teach you 30-40%. Coding all that you read is important for the rest. Happy learning.
Is there a reason you store binaries in SVN as opposed to a something like Nexus or Artifactory?
What is protostuff
&gt; filter (where mobile) I've never seen that syntax, thanks for that.
&gt; What if your computer had been stolen That's literally what happened to the game, Project Zomboid (which funnily enough is written in Java). Guy had a home break-in and the computers with the only current copy of the code was stolen (only had months old backup offsite).
"This JRE (version 8u112) will expire with the release of the next critical patch update scheduled for January 19, 2016." Either typo or timemachine.
Typically there's no real need to use the higher/CPU version, because those bugs/features are often so obscure you wouldn't have encountered them anyway.
A lot of it looks like GUI issues. Good to seem them actively working on desktop issues. 
Mostly just a bullet point list of good practices. E.g. these: * Avoid Overusing Default Methods in Interfaces * Ensure That the API Methods Check the Parameter Invariants Before They Are Acted Upon * Do not Simply Call Optional.get() * Consider Separating Your Stream Pipeline on Distinct Lines in Implementing API Classes have nothing to do with API design. 
You've been in this game too long havent you. lol
On my team we keep all of our development versions as a SNAPSHOT. So while code is in development SNAPSHOT dependencies are allowed. Then when we create a release candidate we use the Maven release plugin. The plugin will scan all of your modules and make sure that nothing is using a SNAPSHOT dependency at that time. It creates a tag in your SCM, builds the new tag, and pushes the artifacts to Nexus. It works well for us, but every team adopts different workflows.
Has this anything to do with Java? (disregarding the links on the right side)
My way of using them is basically thinking good thoughts about them as a quick first try of the concept, and waiting for the compiler to integrate the concept in a more seamless and less verbose way. 
/r/javahelp
In general, yes. The looser the coupling between classes, the more flexibility your code has. This article is quite old, but is still very relevant: http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html
Why did you submit this in /j/java? And simultaneously [in /r/webdev](https://www.reddit.com/r/webdev/comments/58alma/writing_good_code_how_to_reduce_the_cognitive/) and [in /r/python](https://www.reddit.com/r/Python/comments/586gc4/how_to_reduce_the_cognitive_load_of_your_code/)? Don't just spam your blog post across different programming subreddits if its topic is not related to the language, choose a more general sub.
Thanks for the tips!
&gt; For instance: using an Spring MVC application, is it always a good practice creating an interface and its respective implementation for each Service rather than just a concrete class to attend each case. Not at all. In the project I work on (Spring Boot, Microservices, Cassandra, so all the hipster checkboxes) we decided to not do this. Mockito can mock concrete classes just fine. Creating interfaces for all these services just creates overhead (both in code and in the mental model). Creating a SomethingService interface together with a SomethingServiceImpl everywhere 'just because' is something I consider a bit of an anti-pattern. 
The article is about good practices while designing APIs
Probably because those store dependencies for other applications and not all binaries are dependencies for other applications.
Yes, it really is. It's mundane, laborious and sometimes frustrating but to have a maintainable code base; it is needed.
Abstract interfaces don't actually create loose coupling. Used correctly, under certain circumstances, they can assist in reducing the coupling between classes. But the standard pattern of blindly copying the class's public interface into an abstract interface is, by itself, just a distraction. 
I never choose to create abstract interfaces. If I actually need one because I'm in a situation where polymorphism is desired and a shared base class isn't an option, so be it. But that's not a choice, that's a necessity. So here's your decision point: Can you remove the abstract interface without changing the application other than to rename types? If yes, then you didn't need it and it should be removed. 
Can you support that claim? We've already seen that it isn't essential for mocking. Loose coupling only matters if you are actually taking advantage of it, and even then abstract base classes are often preferable. And the expression "program to the interface, not the implementation" concerns itself with encapsulation and not exposing every field with a getter/setter pair, not Java's abstract interfaces. So aside from those, what's your basis?
Explain then what "Do not Simply Call Optional.get()" has to do with API design. 
I concur to this opinion! In functional programming, which I love, you normaly go as abstract as possible (There is even a category theory lib for Haskell). In OO however, you should do abstraction only as much as necessary. This takes a bit of experience, but it is a great feeling you you can incoorperate changes with minimal changes to your codebase :) Things that are likely to change at some point: Databases, Authentification methods, protocolls, the way you represent results, ....
I remember having this debate a few years ago with another Redditor and he or she made a good point that stuck with me - each concrete class already has a "public interface" - it's the set of all public fields and methods of that concrete class. So you don't necessarily need an explicit interface. The principle of [YAGNI](https://en.wikipedia.org/wiki/You_aren't_gonna_need_it) applies here - if an interface is implemented once and once only, does it really solve anything? If an interface is interchangeable in both directions with its sole implementation in terms of referencing by other classes, are you really decoupling anything? After all, if I add a new method to the interface, it goes onto the implementation. If I add a new public method to the implementation but not the interface, but never reference the implementation directly, does that mean anything? Interfaces have specific uses - the most obvious one is where you **need** that layer of abstraction, typically achieved by implementing the interface **more than once**. There are other uses, such as Java proxies (which require interfaces), but this isn't really in-scope here. Ask yourself - will I ever implement this (potential) interface twice or more? For services, this is unlikely (in my experience). And even if you wish to future-proof yourself, consider that modern-day IDEs make extracting interfaces easy (when that time comes), and that future modifications may involve [composition](https://en.wikipedia.org/wiki/Composite_pattern) and/or [adaptation](https://en.wikipedia.org/wiki/Adapter_pattern) - so it may not be just a straight "extract interface" command. Is there a cost? Well, it's one more class to manage, and an additional command when I navigate to this interface, grumble, then navigate to its implementation. A minor cost perhaps, but a lot of technical debt is also a "minor cost", yet technical debt is usually recognised as a problem (although reducing it is not always prioritised...).
Experience mostly is the reason. Maybe I've just been doing it that way too long. I'd have to do a long project for a couple of years to see how the maintenance pans out in the long run. I suppose if you can keep all implementation out of your abstract classes then they are actually interfaces. The problem is, keeping all the implementation out of your abstract classes. I've worked on teams of up to 150 engineers; It's hard today for me to imagine not using interfaces on large enterprise projects that needs to survive maintainability challenges for decades.
If you can't point to concrete examples then maybe you are confusing experience with habit. The thing about interfaces is that it is trivial to add them later. I've never been in a situation where I said, "I need an interface here" without adding "... and done." So while knowing how to use them is definitely a positive, saying that it is needed from day one seems suspect. 
I question this phrase "abstract as possible". Not to detract from your overall point, but an abstract interface isn't really an abstraction over a concrete class. It can be an abstraction of a concept such "list-like things", but in the case of service classes we're usually talking about a direct copy of the class's public interface. 
&gt; The wording of that section title is misleading Except that entire section is quite clearly advising you to use other methods of Optional and to not call Optional.get in your code. It in no way uses this as a motivating example for a discussion of bad or good API design. Let me quote it for you, just in case you're reading an entirely different article: &gt; Calling get() without checking if a value is present with the Optional.isPresent() method is a very common mistake which fully negates the null elimination features Optional originally promised. Consider using any of the Optionalâ€™s other methods such as map(), flatMap() or ifPresent() instead in the APIâ€™s implementing classes or ensure that isPresent() is called before any get() is called. &gt; **Do This:** &gt; &gt; Optional&lt;String&gt; comment = // some Optional value &gt; String guiText = comment &gt; .map(c -&gt; "Comment: " + c) &gt; .orElse(""); &gt; **Don't Do This:** &gt; &gt; Optional&lt;String&gt; comment = // some Optional value &gt; String guiText = "Comment: " + comment.get(); Do you honestly think this is about API design?
Long term project much? Are you reading the words that I am typing?
A big indicator that you're using interfaces needlessly is if you have "-Impl" classes. If there is literally nothing to distinguish your implementation other than to name it "This is the implementation of the interface", then there's really no need to have an interface defined.
If building a public API.... yes. If I'm writing internal code that can be refactored easily, not unless I need it.
That's not information hiding. If you do that, and the developer notices that the interface has only one implementation, he is going to cast it right back to the class so he can use the things you thought you were hiding. I see it all the time in .NET programming where people think writing `list as IEnumerable&lt;Customer&gt;` magically makes the list read-only. *** If you actually do need to hide something, make a wrapper class that doesn't expose the methods you don't want called. 
&gt; If you plan on testings/mocking it, it's a good practice. Why? What problem does it solve? People keep repeating this without being able to give arguments. Concrete classes can be mocked just fine. 
I've worked on many long term systems, some of which were over 20+ years old before I touched them. And even with them, I found that it was trivial to add interfaces where needed.
That one was already debunked. &gt; Mockito can mock concrete classes just fine. https://www.reddit.com/r/java/comments/58axzf/is_it_always_a_good_practice_use_abstractions_as/d8yxydi
Um, wait a minute. If you are building a public API, presumably you'll want to add new functionality to your classes over time. Which means an abstract interface is going to be problematic, as you can't change it without introducing breaking changes. The public interface on a class, on the other hand, is fair game for new methods. *** This is such a prevalent problem in Java that we added the ability to convert abstract interfaces into abstract base class using default methods. But unless you want LSP violations everywhere, there is a limit to what you can add in that fashion.
It can be frustrating until you need to refactor. If the Java community wants to drop interfaces, I'm OK with it. After 20 years of coding in Java and seeing benefits using interfaces; I'm pretty certain I'm in good company saying they should remain.
Sweet, OK let's convince the 99.9% of the rest of the Java coders in the world and we will have a no more interface world (except where they need to be retrofitted).
Refactoring usually ends up meaning that both the class and the matching interface are changed, so no benefit there. And please, stop being so melodramatic. No one is saying that interfaces should be dropped entirely. We're just saying that they should be used more judiciously. 
You're still doing that thing where you make claims without any arguments. 
The problem is that if you don't expose a interface and architectural boundaries, people will just turn your class into a pile of mess that can't be refactored later without a huge burden. By setting up the boundary, it forces people to write clean code and think about the boundaries of their design
They can be, but not everyone wants to develop around 3rd party libraries. Mockito for example can not mock final methods. It's your choice if you want to use a mocking framework. I architect my code in a way that they are unnecessary, but if you really want to, that's your choice.
Did you not say mockito can mock concrete classes, because it can, sometimes, if they aren't final and don't have final methods. No, I just inject my dependencies in my constructor typically, about as simple as it gets.
You'll need to be more specific and provide concrete examples and arguments.
How do we know `myService.getSomeOptionalInteger` doesn't return a null? Is there a compiler feature that prevents this error?
No. But if your return type is Optional and you return a null you should be kicked in the foo-bar-baz. 
It doesn't confuse the mental model though, because the average developer only needs to understand the interface, and not the implementation. It leads to far less of a risk of interface pollution. Where developers may make methods Public by default in their implementation, now they can make everything private/protected in their implementation and everything from the interface public. This separation enforces good coding practice, and keeps the implementation and interface separate. It makes consumers not concerned about implementation details. 
Interfaces -&gt; Mocking. It's an argument for Interfaces. Just because you can do it with mockito doesn't mean you can't also do it with interfaces, without any 3rd party libraries. Interfaces also enforce good design by separating implementation and interface cleanly. 
&gt; It doesn't confuse the mental model though, because the average developer only needs to understand the interface, and not the implementation. The class still has the exact same public interface? Not having an interface doesn't force you to go through all the code. There's this thing called JavaDoc. We had it for a while. &gt; It leads to far less of a risk of interface pollution. Where developers may make methods Public by default in their implementation, now they can make everything private in their implementation and everything from the interface public. Using interfaces doesn't force this at all. They can still make the ones not in the interface public. &gt; This separation enforces good coding practice, You claim this but don't back it up. &gt; and keeps the implementation and interface separate. Again: what problem does this solve? I'm not talking about 2 different things implementing the same interface, that makes perfect sense (and something I use all the time). I am talking about what benefit you gain from having a SomethingService interface and SomethingServiceImpl implementation. &gt; It makes consumers not concerned about implementation details. Repeating stuff doesn't suddenly make it true. That's a self-referential fallacy you're trying to pull off here.
What you don't seem to get is that people rarely should be passing around the implementation classes. e.g. ArrayList&lt;String&gt; list = new ArrayList(); //BAD List&lt;String&gt; list = new ArrayList(); //GOOD You can add as many public methods to the Implementation of ArrayList as you want, but when you are working with List, you will never see them. If you need to add a new public method to List, it makes you think "Hey, is this appropriate for the List interface"? Because I use the List interface, I can make any class act like a List, or I can swap ArrayList for LinkedList, or something else with no impact on my code. Nothing public I add to ArrayList will be exposed, because people are using the interface and not the implementation. For the record, I don't follow this 100%, nobody should. Just that you should follow it when it makes sense. When you may want to swap something, or you want to put extra thought into what your public interface should be.
Not really, for e.g. renaming a method will propagate to all implementations. It's pretty much the exact same amount of work.
I know that Maven can override the versions of dependencies that a specific library requires. We used it at my last job to force a library to use a newer version of svnkit than it otherwise would.
About ten years ago I saw a great talk about this subject - it was presented as a c# talk and in a (I think) Microsoft event, but the principles are the same. Sadly, I can't recall who it was by nor could I find it, but the key point I do recall was this - use abstract class for a "is a" relation, and interface for a "can do" relation. Of course there are always exceptions, and sometimes it's not clear which it is, but I find that in most cases it's pretty accurate.
Yep, I think you and I are on the same page. I agree with all of that. I definitely encourage my devs to think about the architecture and reason about what a class is for when it is written; In the case where an implementation might change in the future (such as a wrapper for S3 data storage or some other remote dependency) it is important that the public interface to a class be clean, but it doesnt necessarily need to be enshrined in a separate Interface definition. If the time comes that the implementation does need to change, it is trivial to extract the interface and create two implementations assuming the original implementation was clean in the first place. That's the important part. I just don't like codebases to be cluttered with interfaces when they aren't necessary. Enterprise software code bases are large enough as it is, we don't need extra code lying around "just in case".
Can we ask what your credentials are?
final classes and methods cannot be mocked by Mockito.
Yea, but unless the function is documented otherwise you shouldn't be returning null regardless of the return type.
&gt; Yeah, and then someone is just going to change your wrapper class to make things visible. Not without reflection. (Unless you are talking about source code changes, in which case all bets are off.)
As soon as you start calling anything "the enemy" you are making decisions based on emotions rather than logic.
As some others have said, using separate interfaces makes it much easier to mock / test your code, especially if you are using dependency injection. Need to test your application but dont want to test it against some real backend service? Now you have an interface that you can easily make a concrete mock of without any magic. In addition, for a class that might be used a lot, creating an interface helps you figure out what functions really need to be shared / public and which are implementation concerns.
Interfaces are our friends. :-)
True. But I have to say, it is downright amazing how many hoops the Java community has had to jump through to make this possible. Not just refactoring and other IDE support, but the Hotspot JVM itself was designed around trying to mitigate the overuse of abstract methods and interfaces.
if you need to call trimToSize() it should be private, and you should call it when appropriate in the implementation. Externals should never call it, if they do that's leaking implementation details.