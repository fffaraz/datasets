I posted a [new sample Spring Boot app](https://github.com/spring-projects/spring-amqp-samples/tree/master/spring-rabbit-json) that shows some of the various techniques that are available to co-exist with non-Spring apps.
Well, the traditional idea of a microservice is that each microservice would have its own isolated datastorage. Nevertheless, if that approach solved the problem at hand in a better way than having segregated data storages, that's great! There are no silver bullets, right?! So the idea is to learn from all these patterns the gurus talk about and bend that knowledge to our needs. Btw, did those microservices have their own read storage or did they also read from that centralized location?
Here we go. The weekly null bikeshedding...
Ah, the old ivory tower argument. Turns out all we do today is predicated upon yesterday's (and sometimes even older) theories, usually developed by theoreticians. You think theories that don't apply? Better stop using that hard drive, file system, type system, garbage collection, ... Not all theories make great practices, true, but that something is based on a theory gives it more credibility than some Redditors personal experience. I personally have tried many of the object oriented design principles and found most of them work quite well. And where some didn't I'm not arrogant enough to automatically assume it was their fault. Maybe, just maybe, I need to learn more to use them properly.
&gt; I know how the bullshit game works. So you assume because you know some bullshitters all of them are? Or do you know the guy's work personally, in which case, do share your experience. Maybe he _is_ a hack after all.
The author is clearly a pageviews stuffer and not quite up to date with best practices of java development these days (for a while). Nobody works with threads and synchronous blocking for best part of a decade. Cool kids for longer. NIO has been around since what feels like ever, any even remotely popular public endpoint framework will be netty or similar under the wraps. Any developer that finds him/her-self actually creating a Runnable to wrap in a Thread are stuck in about a decade ago. Lack of application servers, standalone apps as the norm and even some sprinkling of occasional OS container use (whether docker or dedicated VM I really don't care) has been mainstream for half a decade as well. In those big slow moving enterprises, no less. Actual content about anything reactive? Couple of sentences. Fine. I could talk about executors, pools and FJ framework. And streams. But I won't bother. T'is a silly article and such it shall remain.
It was a broad article that touched on a lot of ways to structure concurrency. You've made a great point that is highly relatable to monolithic architectures with multiple developers working on it. For a fine grained microservice only performing one function, than there is no issue manipulating the common pool to achieve the service's task (which I included a section on and listed as the test scenario). That was what I worked on recently which prompted the blog post.
sorry, I didn't mean that way. when a object is updated, depending on certain fields, more business logic is triggered, which modifies different set of objects. and those updates can trigger some more. its like a chain. so we are breaking it from single txn to be asynch, detached process. that's what i meant by even.consistency.
I dont believe that microservices are by necessity not-soap.
One of the code projects at my work is full of code that doesn't fail-fast. In our case it's a bunch of try-catches with an empty catch block. It's horrible to debug because the error happened much earlier than the incorrect effect. It does incorrect things in a number of cases, but those cases are hard to find because there's no fail-fast behavior. Another one fails fast. That code project gets fixed fast when there is an error and is now very robust. You're advocating that fail-fast is the wrong way to go. In time I hope you will learn how wrong that is. 
I am a Java programmer, having multiple versions of Java installed on my laptop. I never had a security problem (that I know of ;) ). Just make sure you update Java regularly. That said, I wouldn't install Java if it didn't have a use for it, e.g. an application asks for it. Websites do not tend to use Java applets any more (even disabled in chrome for ages now). I've never seen a game requiring Java in the past.
Not a good idea for bulk operations. If primary key is auto generated then each entry has to be persisted before the next one(operations are no longer in bulk). 
That's how business works. I've worked in little IT shops and I've worked for one of the biggest consulting firms in the world. Invariably if you have more than a handful of employees, you are going to have some that spend all of their time doing presentations, making sales, and otherwise being the 'face' of the business. These are the names we hear about. The people who are actually doing the work don't have time to write book after book and tour the conference circuits. I'm sorry if it hurts to hear that your heroes are shames, but that's how it is. The real engineers do the work and the managers take all of the credit. 
&gt; "primitive obsession"? Is that what the cool kids are calling code that has to be performant? Actually "primitive obsession" is another way of saying "writing countless classes that are so simplistic as to be individually useless". Or in other words, the "Single Responsibility Principle". But in the grand tradition of design pattern fanboys, he completely missed the point. 
While I haven't argued with the other posters (because I am a beginner) I think this post says more about you than about anything else. Your immature and annoying tone is why I wouldn't say anything else but report your post. There really is no need to annoy posters.
A lot of people but guessing from your continued participation in this conversation, you're not one of them.
&gt; Actually "primitive obsession" is another way of saying "writing countless classes that are so simplistic as to be individually useless". Citation needed. Every definition of the term that I found says otherwise. Primitive obsession is the use of primitive types (e.g. numeric or strings) for domain concepts (temperatures, email addresses, ...) without wrapping them in a class that guarantees the invariants you would like to uphold (e.g. sensible range and unit, valid email address). Besides making it much harder for invalid data to flow through the system, this also makes it easier to understand the code and enlists the compiler in preventing little mistakes like confusing parameter order. Having worked with coders (those were not professional software developers, though) who loved the shit out of primitives and gave every other method half a dozen `int` parameters (which could've instead been one or two objects), I experienced the massive downsides of the lack of abstraction first hand. &gt; But in the grand tradition of design pattern fanboys Now I'm a fanboy because I use them?
&gt; The problem with insulting someone on the internet is that you really don't know what their background or experience is. Don't get defensive, I no more insulted you than you insulted me. We both just expressed our mutual distrust.
I know of a few government agencies that still use containers and threaded requests in their web apps so /shrug
The 'why' is simple: Because I can. Exercises like this always teach me new things, I wanted to create something that automatically uploads to YouTube, and the first creative commons source I could think of was Wikipedia. It was never the intention to fill YouTube with great content :-)
Kotlin is JVM yeah. Don't be shy, link your (finance?) app. I reckon it's good to take every opportunity to have other developer's eyes on your code.
Your description does not fit your title. Java has no particular advantag for small projects, other than maybe some very mature libraries to draw from. But those can be consumed by several other JVM languages as well. Java is a language for the masses, for big Enterprises having lots of mostly trivial applications that can be solved with standard frameworks but need to be maintained by hordes of cheap workforce. For this target audience, it provides a better combination of documentation (examples to copy paste from Stackoverflow) and better code safety than other languages. So it's wrong to ask which projects/problems Java solves best, Java mostly solves a business problem: How to reduce the cost of developing and running tons of dull software during decades. The only problem that comes to my mind where Java is best, is as a language to create a library for other Java developers. But that's cheating the question.
IIRC the whole thing was a MQ messaging system, with only the central manager writing to drive. And the manager had some advanced, custom tailored IO underneath to make it fast. So in case of critical failure it could start from where it stopped, or it could even replay whole day. Other services except for logging or reading config were doing no IO (besides network access for messaging of course and the db writing service mentioned earlier). The critical services had whole machines for themselves, less critical were in groups of few on the same machine, separate jvms. That was what I liked about working there - there were lots of people smarter than me I could learn from and I could see they adjust everything to suit the needs.
Thanks for taking the time to read and comment. I agree with your statement, in fact, that's what I meant when I wrote "Not that [Threads] are going away, but as an API for us developers, we need something else, something that gives us sub-thread level concurrency." 
Thanks for taking the time to read and comment. &gt; Nobody works with threads and synchronous blocking for best part of a decade. &gt; Lack of application servers, standalone apps as the norm I don't have any empirical data on this. Do you? That'd be interesting. Maybe Im "preaching to the choir" and everybody is building reactive systems already. Anyway, my personal experience is different. A lot of people seem to be stuck on JEE in some way or another. Maybe you're lucky to work in a very progressive industry segment. 
Can someone ELI5 Jigsaw?
Hi, I recorded the Hibernate Tip video. As I explain in the video, Hibernate uses the primary key internally and can't delay the execution of the insert statement. That prevents any performance tuning techniques that delay the execution of the statements, like JDBC batching. Due to this, you shouldn't use the IDENTITY strategy if you need to persist multiple entities at once and want to benefit from certain performance optimizations. The SEQUENCE strategy is a better fit for these use cases but you don't always start from scratch and can influence the table definitions. I explain the other strategies on my blog: http://www.thoughts-on-java.org/jpa-generate-primary-keys/
We had Maven. And OSGi. They weren't good enough for the JDK, so they created a [new standard](https://xkcd.com/927): Jigsaw.
Why bother? Not many are using java these days
Jigsaw does two things. First, it introduces to Java the concept of a module. Modules can declare dependencies on the implementation of a given interface. You can think of it as link-time dependency injection. Second, it is an effort to modularize the Java standard library, so that it is not necessary for the JVM to load every class the JVM provides at startup. This should translate to improved startup time for most applications. All of this, of course, needs to be compatible with Java 1.0 code and classes. This has been the tricky part.
Why are you on this subreddit then?
Don't feed trolls. :)
Is there going to be some reflection for modules? eg can I see all the currently loaded modules, see which modules module A requires, etc.
Well, I'd say it is a bit too early, as I am aware of a handful major deficiencies (there are no tests whatsoever, the GUI layer is a royal mess, and so on). Plus the app itself is of limited interest to the global audience - even though the language is English, in its present state it is hard-coded to work from a local investor's perspective, which means the main currency is ruble, the stocks are Russian blue chips, etc. I can send you the link via a PM if you still wish to have a look.
You'll see it everywhere from now on. E.g. when this list discusses Java EE vs. Spring or Eclipse vs. NetBeans vs. IntelliJ or Tabs vs. Spaces the next time ;)
Its crap that a HTTP/2 Client isnt going to be included into the Java9 JRE but the upcoming JavaEE8 includes support for HTTP/2 servlets.
On the desktop, maybe. But like 90% of real world enterprise web tier apps are Java.
I judge authors by the quality of their work. And early in my career I found his work to be by and large full bad advise that leads to unnecessarily complicated designs that, in most cases, have no redeeming benefits. It was only later in life when I learned how consulting companies work that I realized why he was so popular despite the poor quality of his work.
Rapidoid sounded nice until I discovered it didn't do HTTPS. Until it can do that, and HTTP2 and probably websockets, I think I'll stick to netty based stuff.
Yeah! You suck u/Gvaireth. Nevermind your rational advice. You didn't provide me with a perfect solution, for free, hand delivered on a velvet pillow! What is even wrong with you?
Yes, it' true. Thank you for the reminder me about these things. The same thing with WAF, IDS are releted to SQL Injection. 
You are annoyed by being criticized? That's funny. Your code is **Pythonic Java** there is no discussion about that. Your code is a complete mess - again no discussion about that. You will need to learn to accept harsh criticism and not be upset about it. **You** brought your code to the public without further explanation, so **you** have to stand trial. I still stand by every word I've said in my previous comment because simply it is **fact**, there is no denying. You cannot apply Python style to Java as the languages are nearly diametrically different. Python can be both very short and very elaborate. Java is generally somewhat elaborate. You cannot solve everything with Lists as in Python. You have to learn completely different concepts and if nobody points them out, you won't learn anything. You have bitten off far more than you can chew. Start with something way simpler and learn to program *proper Java style*. 
thanks for the comment. the customer ended up doing more or less what you suggest. i just liked the idea of the release being atomic, ie the war being self-contained do you have a sense of whether your suggestion is a de facto industry standard ?
i agree on not exposing tomcat i was referring to delivering the static resources ("git/ftp/whatever") and the java portion of the webapp separately 
Yes.
No
Wait... is he asking for too much, will Java 9 enormously simplify deployment or are you simply answering my question as though it were a logical expression?
No problem, glad it helped! I remember which parts of this stuff I found unclear and confusing initially.
Java is created to run on a virtual machine. One of the ideas of java is that you should be able to use one program compiled to bytecode for the virtual machine and run it on any operating system that has a VM for it. So you are not asking for too much, you are asking for the wrong thing. 
I look forward to it :) The highly optimized memory access stuff looks impressive.
Thanks! :)
indeed
Maybe
True. But shipping a VM with the app does make sense and some companies do that, JetBrains, for example. 
Would you mind sharing an example of those lambdas?, I was reading about and I would like to picture it better with a real example.
Am i missing something or can it just be "class A{}"?
So you know it is already possible. Java 9 will just help to reduce package size.
It means compiled .class file.
Boring.
The idea is GREAT! I am more interested to see it become more mature.Let's see what the future brings to this child.
ART in Android also does something similiar with Java and also golang which you mentioned already. Java 9 is adding AOT support, but the code still needs to be executed along with the JVM. I have a feeling that Oracle will slowly head into that ART/golang/gcj direction as it makes a lot of sense in the way applications are deployed nowadays.
A Java program cannot work without the JVM, but JVM != bytecode. Precompiling (the statically known) classes down to a native executable for a particular platform does not make the original bytecode of those classes less portable, nor it precludes the JVM from loading classes that were not precompiled for any reason. A JVM can handle such precompiled classes just fine, and interpret or JIT-compile whatever the app wants to load at run time. See the [Java AOT Compilation talk @ JavaZone 2016 (video)](https://vimeo.com/181905276) 
They are still in use. Not all companies follow the latest trends and use the latest technologies. After all, even COBOL specialists can still find work these days :)
I am not sure what your point is. First of all, I never saw anyone claim that bytecode is equal to JVM so you are right that they are not equal. Are you saying people precompile java classes to native executables for the underlying operating system? I never saw any javacode .exe-files (or similar for linux), are you saying that is a feature of Java 9?
It depends, due to the security features, Java sometimes complains if you have old JVMs installed and if you have a program with its own jvm java can recommend to uninstall it. That can be a bit confusing for the user.
This is not the right sub for that, try /r/cscareerquestions
I'm excited for VarHandles: http://openjdk.java.net/jeps/193 sun.misc.Unsafe has a potential replacement, remains to be seen if it is worthy.
Java libraries are the best.
Are you using any task managers for your frontend builds (e.g. gulp or grunt)? If so, during development, you could always serve the html/js files using browsersync or express and define a middleware to proxy API calls to the backend. Checkout [JHipster](https://jhipster.github.io/development/) for an example of how this would work.
Part of the problem is that early feedback of the HTTP/2 Client API didn't seem unanimous, which lead to think that the API wasn't completely ready yet (see [discussion thread](http://mail.openjdk.java.net/pipermail/net-dev/2016-October/010404.html)). This is why they have decided to include it as an incubating feature (so people can use it and experiment with it), without making it a standard feature (so the API doesn't have to be locked yet).
I know. This describes the status quo. But I was more hinting at the point that perhaps having an identity in *every* type in the entire type hierarchy might've been a design mistake in early Java.
GCJ project is dead
I don't think so. Object identity is an important concept in OOP. I do not see how OOP would work without an idea of object identity. As soon as you talk about different objects you have already defined that there are entities which have identity.
No it doesn't if you simply include a JRE. You don't need to have any installer specifically for Java. It can just sit in a folder inside your application and be used.
&gt; Are you saying people precompile java classes to native executables for the underlying operating system? Yes. Ignoring GCJ and RoboVM (which are obsolete), there's [Excelsior JET](https://www.excelsiorjet.com/), [Avian](https://readytalk.github.io/avian/), [MultiOs-Engine](https://software.intel.com/en-us/multi-os-engine) and few others.
Ok, I see, yeah I heard about compilation tools existing a few years ago but I thought those guys left the project. I think going for solutions like that might give some trouble, though. You are right, once it is an exe you can't be completely sure if it is java or C++. However, often if it is a GUI program you can recorgnize for example swing menus.
[removed]
Thanks, this is very interesting!
Félicitations pour cette milestone ! Je vais la tester au plus tôt.
[removed]
Is there a way to plug into JHipster to use Aurelia instead of Angular 2?
I thought JSP in Spring Boot was limited and not all features were available and that is why wasn't recommended.
You are welcome. Full disclosure: I wrote [this article](https://www.excelsior-usa.com/articles/java-to-exe.html). Need to update it with the above info though.
Ah ok. I thought you were trying to say you have JavaFX, plus some libraries that allow you to create dynamic applications via Python in JavaFX. I figured it was some kind of dynamic interface application. I didn't realize you just meant that you create JavaFX GUI's. Thank you though!
Nah, it was still cool to read. Even if the specifics don't make sense, it's cool to read what others are doing with Java.
Thanks for the share, curious about the server-side events JSR. Will be keen to follow developments in that space.
This is exciting, good job everyone! I can't wait to start using this on my next project.
Really shows how much careful work goes into these kinds of decisions.
For me: java version "1.8.0" Java(TM) SE Runtime Environment (build 1.8.0-b132) Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode) .class files: Empty interface (without debugging info): 53 bytes (smallest I could get so far) Empty interface: 83 bytes Empty annotation: 122 bytes Empty nested interface: 127 bytes Empty nested annotation: 166 bytes Empty abstract class: 176 bytes Empty class: 176 bytes Nested class: 220 bytes Inner class: 267 bytes Anonymous class: 352 bytes Empty enum is: 608 bytes (huge) Empty nested enum: 660 bytes 
In principle the bytecode or aot code could be bundled with a jvm in a single file.
404'ed
I think having both `val` (for immutable) and `var` (for mutable) is the better choice. Then again I think migrating to Scala is a good choice for most projects.
Do you have a source for that statement? My personal work experience is not like that but if you have a real source I am open to information.
I skimmed through it. I generally only use `val`-s except if it's actor state. I actually think just `val`-s for immutable values might be sufficient. Mutable variables can just jump through the loops without having type inference, whatever.
I was waiting for this...well done
Not in C#. 
Another way of answering this is that since Java was invented we have gravitated towards particular ways of using it, and found things that we want to do with it which aren't perfectly supported. New languages support the new things we've learnt, and attempt to solve the new problems we've found. Java is required to support all of its existing code, and so is rooted in the past. A new language can make a clean break from that.
&gt; I think having both val (for immutable) and var (for mutable) is the better choice. They're way too similar visually, it's not a great idea to pick so similar keywords which can be found in the exact same position as one another. Not to mention, that in certain countries near the rising sun, saying "val" and "var" literally sounds the same :-P It's not like we're running out of... words. I'm sure an alternative that's distinct enough can be selected.
The error in the language design is making `as` easier to write than the more frequently used `(Foo)` style cast. This goes back to the "pit of success" philosophy wherein you should make the thing that is easiest to do also be the one that is most likely to be correct.
That's when you use the final keyword.
That's true, but decent IDEs will paint them a different colour so it's not usually a problem.
Writing `final var`is 6 chars more of spam in source code compared to `val` (and not sure it's even allowed per current proposal). And why? You should be defaulting to `val`-s anyway for more maintainable code. If anything, discriminate against the `var`-s and not `val`-s.
...which is what Gradle has been doing all along.
The amount of code I see that doesn't use final fields is too damn high. I would even support a distinct mutable keyword to declare mutable fields. Mutable fields are bad, and you should feel bad using them. The need for them drops as more of your codebase becomes immutable. You can literally eliminate an entire class of bugs by simply using immutable fields.
OK, perhaps I misunderstood you.
Please no. Just leave Maven alone and use another tool like gradle if you feel the need for this kind of stuff. The fixed descriptive syntax is exactly what makes Maven a godsend for large projects with coders of different skill levels and coding styles.
As long as I'm not forced to use it, I don't mind; likely I will try it out and go back if I didn't like it. Would be useful if there was some kind of conversion tool.
it was if a million java devs suddenly cried out in terror, and were suddenly silenced.... If Maven do this, *even* if they keep supporting fully the original XML format, they will loose what makes them strong. Having a non-turing complete build system is absolutely what makes it so great. 
http://jdbi.org/ ftw
The problem is that ``beans`` require mutability and *constructor injection* is not widely used in Java land. So many devs uses their beans as anemic domain model and even don't know anything about ddd and other good technics. They are *lost* in the *dictatorship* that Java EE or spring offers them.
Polyglot for Maven has been around for many years. It's not replacing the XML format.
I wish all members, parameters, and other variables were `final` by default in Java.
Ditto for `private` and non-nullable. Lock it down by default and make people explicitly loosen the rules. 
And give us a true immutable! OK maybe I am asking a lot now.
Why is "non-touring complete" desirable for a build system?
damn the submitter, you gave me a heart attack! Maven shifting from XML to scripting languages would be a deep blow against Java... fortunately, it looks like XML will still be supported. If you want your build under control in a large system, you stay far away from any scripting language. Please, leave Maven alone. If you really want to deal with scripting languages, go use Gradle...
[removed]
You don't have to rely on development discipline to make sure your build is reasonably simple. With scripting build systems you'll have people add "that one function that adds that feature" to your build script instead of implementing it properly and to convention so other people can actually work with it later. *Not* being a scripting language is the main advantage maven has over gradle. It's also better for parsing, though that's less of an issue.
&gt; you'll have people add "that one function that adds that feature" to your build script instead of implementing it properly but these are the same people who work on the project with you, so most likely you already have bigger problem than build script. 
Your team must be special or trying to fight the convention
Spring offers constructor injection, and generally recommends it as good practise to use immutable fields. If developers still choose to write large classes that handle several types of functionality and have a large amount of dependencies (more than 3-5), the blame is solely on them.
I think with the ant plugin it might already be Turing complete.
&gt; If enyone use nowdays pure jdbc to big projects or everyone use jpa? JPA is nice for straightforward inserts / retrieval but when there are more complex views to be assembled I prefer writing SQL myself. You can quite easily mix Spring Data JPA and Spring Data JDBC (JdbcTemplate is a nice convenient JDBC wrapper) in the same application if you want. 
I'm curious though; why would you do this instead of just adding a random UUID when you create an entity? I mean, you have to add this to every entity: @GeneratedValue(generator = "inquisitive-uuid") @GenericGenerator(name = "inquisitive-uuid", strategy = "com.myapp.persistence.generators.InquisitiveUUIDGenerator") Instead of just doing this: UUID.randomUUID() when you create an entity. Assuming you have a person entity and static import the function it's simply this: Person person = new Person(randomUUID(), "John", "Doe");
I've seen a few big projects using JDBC. Then I created [jOOQ](http://www.jooq.org). Note, you can always combine SQL APIs (like JDBC or jOOQ) and ORMs in an application. [SQL solves different problems from ORMs](https://blog.jooq.org/2015/03/24/jooq-vs-hibernate-when-to-choose-which/)
Groovy plugin too. But I agree. Once is submitted to maven I was at peace. 
Just. No. The tooling and culture for maven is finally at a good place. Please stop. 
What about react? 
Not necessarily! Build scripts are part of the "externally exposed" areas of a project, but are very different from normal API design. And the people working on the build scripts may not even be the same as the people working on the API, it may just be that one sysadmin that can't figure out why the build is erroring.
A click bait title leading to what appears to be a shitty almost broken web app claiming that somebody is building a scripting language for Maven. And yet everyone jumps to into the comments to show how pissed they are. Come on guys, were better then this. 
sooo. they chose to add the following languages: atom, groovy, ruby, scala, and yaml? It seems very odd in this day and age at json isn't included, or even maybe -- java?
Yeah. I might want it to support TOML, YAML, or JSON before it goes to a full blown scripting language. But as it stands, xml is good enough. I think the complaints about xml are overblown. Is it bulky? yes. Is it hard to read? Not at all. Plus, it really is a one and done sort of thing. In my day to day, I hardly ever futz around with the maven configuration. I would take a little bulkiness any day over having to debug what a coworker's script did to the build system.
I would love to have something like xml, but not xml. I want a strictly declarative language, flexible and type safe, maybe even defined by dtd or schema file files, but not as ugly and verbose. What I really want probably is another representation of xml, as machine friendly as xml, but more human friendly And not only form maven
Well our company policy bans "var" in C# so I'm guessing it would be banned in Java as well. 
I can see this happening a few times... Dependencies can get weird, but 20% of every day? I'd fire you. :)
Ant was specifically designed to not be a programming language. But because you can't easily achieve many tasks many try. But the you run into properties that can only be set once. Then you need to invoke another ant script in a new process, often multiple times, to do what you want. There is also ant contrib, which can help. But then ant is not a programming language so why try to program in it? Ant if, ant try catch, ant logging: seen it done it, ran away screaming. 
Surely you are joking!!! I've seen XSLT generated Ant and it was hard to maintain. 
Yeah polyglot maven has been a thing for some time. 
as a developer, XML is a nightmare
Guys let's just use Clojure and be happy, okay? Can we do that for once?
Maven is NOT shifting from XML to Scripting Languages.
But what about JPA Cache? When i change something in db with JDBC the changes will be made in JPA Cache ? And what about when the application must use multiple databases ?
If you execute `gradle init` in a Maven project it will convert the Maven build to a Gradle build.
That article is a set of massive images, who does that?
Exactly, and it actually works pretty well
&gt; large projects with coders of different skill levels and coding styles. "The problem is not in the tool but in the team, so let's keep using xml because my team sucks and it helps limiting the damage bad programmers can do to pom files. Why bother solving the real problem here?" Of course it's impossible to write shitty poms, right? Every time I hear "let's not use X because we have some bad programmers around here" it's just an excuse to let bad programmers keep writing bad code. That just doesn't help.
&gt; Scala is probably to most popular alternative language on the JVM. It is Groovy, later Scala and Clojure. Edit: http://www.tiobe.com/tiobe-index/
&gt; trying to fight the convention Conventions are not something we're known for. I'm all about freedom, but when it comes to project management a little authoritarian, "this is how we do things," can be helpful. We're barely transitioning to Git from SVN and already we have repositories named with X.X.X deep version numbers.
Different strokes for different folks. Scala and Clojure are different enough that I don't think anyone is stepping on each other's toes. ;)
Try one of these: - https://github.com/requery/requery - http://jdbi.org - https://www.jooq.org - http://www.querydsl.com Or if you like more an ORM tool try http://ebean-orm.github.io
I find it easier to work in just straight up JDBC though I've enjoyed Mybatis in the past. 
Why the hate? Oh, yet, its using the standards not some company backed framework. 
Maven sounds like a bad thing for an organization where anything goes...
[Stop](http://www.indeed.com/trendgraph/jobgraph.png?q=scala,clojure,groovy&amp;relative=0) [trolling](https://pypl.github.io/PYPL.html)
its always the people who think theyre the smartest.
&gt; as a developer, XML is a nightmare use a real IDE or even a smart editor and it's not.... maybe a little verbose, but like most things, there are benefits to that verbosity.
No, I believe in static typing.
Aaaand the link is now not working...
&gt; XSLT You mean that you are allowed to use the same nightmare to process the XML ? &gt; xml schemas Schemas does exists in json too &gt; easy pars-ability You must joke: any XML conforment parser is a security nightmare &gt; folding, sytax highlighting you mean as any other textual language ? &gt; auto detection of errors. Can you explain ? &gt;&gt; Using an ide/smart editor should be optional and not required by a good enough textual language. &gt; I can also drive a nail without a hammer, but it's pretty lame when I don't. at a bare minimum vim, notepad++ but emacs, eclipse/intellij are all fine with XML. That I want to say, is that for a good textual language, an editor with maybe syntax highlighting should be good enough to edit it. Convenience with advanced editor or ide should be only a bonus and not mandatory. So XML clearly don't fit the job.
Do you have a 30-minute workday? Because WTF. I've got at least 5 projects that I have active participation in, they're all in Maven, and they almost never change. We're talking maybe 1 change per month, and usually it's just fixing a BOM version for a new set of managed dependencies. 
Yeah, the real trouble (and a great way to blow half a day) is to get the tech leaders in a room and have them come to a universal understanding of microservices (and if you want to go a whole day, REST). A good architect should be helping to identify places where transactions are absolutely needed and where they're not. And all the problems you talk about (messaging, circuit breakers, monitoring, logging) should be fleshed out before even getting involved. It's a lot of work to get your first couple apps deployed, but after that not too bad to keep it going. It sounds like your company/people bought into the hype without realizing the work that goes into that kind of decision. 
that's a different thing. look into the [lambda architecture](http://lambda-architecture.net/) patterns. we've had some good success implementing stuff like this, but having kafka queues to help broadcast change events across the system (so small services can update a local data copy or perform some business action, but it's never considered the source of truth, just derived data). you can also look into [LinkedIn's DataBus](https://github.com/linkedin/databus) project. I found it a bit heavy-handed (and too Oracle-based) for what we were doing at the time, but I've been keeping an eye on it. But the pattern of a CDC system with a perpetual lookback/replay capability is quite solid, and really enables some microservice patterns. Be ready to push for some big hardware, though. Our Kafka cluster is ingesting ~80GB/day. We have to make some tradeoffs with data aging so it can't all be perpetual, but we have some rollup mechanisms that help keep us hanging on a bit longer. 
You are learning from a bad source. The best patterns book out there, which really explains the purpose and usage of them: http://gameprogrammingpatterns.com/contents.html 
I opened Flyweight Pattern, and it's shit. Also Abstract Factory Pattern, what a fucking waste of time. Read this great, free, open source book instead: http://gameprogrammingpatterns.com/ 
Well I passed the exam so I Guess Im fine for now. I want to keep on studying Java alone for now so I will have to find some good sources.
Yes, you're being cynical, but you're not really wrong. Microservices are a special-case version of SOA. Many people conflate SOA and web services, and from that perspective, it's easy to see them as equivalent. Microservices were a response to the amazing contortions you have to do to really call your architecture "SOA." It's not the same thing as setting up SOAP-over-HTTP services and calling it a day. You need to do message translation (json, xml, avro, thrift, etc), transport transformation (http, jms, jbi, etc), routing, policy management, and a whole bunch of other shit. If you look at the [defining concepts and core principles](https://en.wikipedia.org/wiki/Service-oriented_architecture#Defining_concepts) of SOA, many of them are in opposition to the goals of microservices. Most people who think they're SOA are really just dealing with a pile of web services. Microservices as a concept are significantly less rigid and prioritizes resiliency/uptime and team ownership over the entire service lifetime, instead of logically grouping services together. This implies (but doesn't necessitate) the potential for duplication of efforts, either in code or data. I tend to think of it as a natural derivation from SOA given the recent advances in continuous delivery practices and cloud computing. 
Sorry, I could have worded that a bit better. Fortunately, the article makes clear that it's in addition to their core XML support. Again, apologies. 
Marking it final is communication to the method reader that this will not change. There is less mental effort in understanding the state in the method if you can consider these as constant once assigned. This means that a maintainer can't accidentally add a line that would change the value when another line of the code was written presuming it would not change. 'Effectively Final' wouldn't provide this assurance unless something later in the method _required_ that it was effectively final and that the newly added change violated that. 'final' and 'effectively final' therefore play related but slightly different roles.
People with real paying jobs. The majority of front end work seems to be either Spring Mvc + Jsp, or Angular. No one has anything significantly better than jsp. All the "alternatives" are either overly leaky abstractions, or just reinventing the wheel and ending up with basically the same result (like thymeleaf). 
Languages that had immutability by default have been around for decades. Every decade or so someone comes back to rehash the same idea again and again. They never catch on in widespread use because they're a lot more pain than they're worth. The few bugs you catch by having things immutable are offset and then some by the new pattern of having a million copies of the same data because you just needed to change "one thing" but data is immutable by default. It's not a new idea, it's been tried over and over again before and every time the result is bad and it gets ignored from experience.
Clickbait title. Maven is not shifting. It's not shifting at all. It's not closing it's major bugs that have been around for 5 years. It does not shift towards incremental submodule builds. It does not fix it's horrible deficiencies in handling transitive dependencies. It does not fix the problems that right now require 3rd party plugins as workaround. Maven does not not move an inch, in any direction. And the reactions to this clickbait title shows how unsuccessful polyglot Maven has been to even come known, let alone used.
This guide doesn't make the way ConcurrentHashMaps works completely clear. ConcurrentHashMaps are broken down into multiple segments, each of which has a lock, and holds keys that hash to a given range of values. The lock gets taken whenever we write to that segment. More segments = more write concurrency. Reads, on the other hand, aren't really affected by the segmentation - they almost never take a lock, preferring lock-free access instead.
Goddamn it. I voted for `let`.
so according to your views, Google didn't do anything wrong by forking Java with Android? I am sincerely curious. What differences between Microsoft J++ and Java Android? Or asked differently, how did Microsoft failed to embrance Java extend it and kill it? Since Google won the case against Oracle, I guess the design of APIs won't be protected. But as an API writer, I disagree. See my book analogy. 
&gt;&gt; As a personal tip, I recommend that you evaluate your API and be more specific about what do you want to protect (and why) Good tip. I will think about it. On first thought, Why? Because bad implementations that become popular are used as weapons. Big corporations like Google can steal the work easily. Not saying anyone will want to copy my API. Just asking in case, it is indeed very good ;) As you say, only recourse of action is a patent. but that is so damn expensive.
If you built an API that provides interfaces that can be easily implemented by someone to produce the same result, then whatever you did is not special enough, or it requires too much work from your user. Stop to answer the question: "what's the minimum amount of code the user requires to perform X?" If there's a lot of steps involved, or there's too much repetition, your API is probably not good enough. If you are confident it's ready for prime time, all you can do is to put the copyright notices in place, and hope for the best. I wouldn't care too much about the rest... if your stuff gets copied/pirated it means you did something really good. By then you'll be somewhat successful and one step ahead of those copying you.
"what's the minimum amount of code the user requires to perform X?" Let's not circle around the pot, my API is an Application Framework UI Toolkit. So the answer is: That depends. There are many ways to build an UI application. I am trying to bring something new to the table. The ideas are not necessarily genius but the amount of work to make it work and fitting in a clear and concise API is a lot of work. I did this API because I was unhappy about the way I was making fat UI applications, be it Swing,Android etc.
Think of your API as an idea, instead of an artifact. For an analogy, let's say you found a great way of building and running a business. However if not applied ethically, the methods you found might have devastating effects on the whole economy. Now what you want to do is to open up a business school where you can teach people how to apply this method to run their own, successful businesses. No matter how you try to control it, some people might eventually be greedy enough to skip on the ethics for more profit. Now one way to control this might be to make all your students sign an agreement. The problem with that approach is: Once they become big and powerful, you probably won't be able to enforce the agreement. The alternative way might be: Next to the school, run your own business, or even create an organization which will monitor the graduates and intervene before things go south. Now in this analogy: - Idea: The idea that you have for your API - School: The api - Agreement: Copyright/Patent etc... - Your own business: A reference implementation of your API - Organization: The community of developers which will form around your API/Implementation I think your best chance at protecting your API from "bad implementions" is to provide a high quality reference implementation and create a motivation for developers to form a community around it. J++ failed because it never gained developer support. So as long as you can keep developers loyal to your RI, tou have nothing to fear about.
I respectfully disagree. an API is a collection of ideas articulated together with human and computer language. There is what we call a "body of work". You are right. That discussion is outside the scope of this post. Thank you for your input on the Google vs Oracle case.
APIs are in fact copyrightable. However when you copy it with the intent to provide compatibility it is covered under fair use.
My API expresses things differently. No Listeners on Buttons.
I understand that. The things is that if someone finds the way you organized it useful, it will probably be imitated. You can try and copyright it but I doubt you'll be able to enforce anything.
* Kotlin has better interop because it's using the same types and collections as Java * faster compile times * better support for type-safe DSLs * non-nullable types * the runtime is tiny compared to Scala's that's why it's better suited for Android dev * easier to learn/master 
This article seems pretty inaccurate. For example, the `concurrencyLevel` and `loadFactor` arguments are no longer used, except as an initial sizing hint. ConcurrentHashMap got an overhaul for Java 8, and is no longer an array-of-lockable-maps. Instead it's closer to a regular HashMap, an array of buckets, with locking at the bucket level. http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/concurrent/ConcurrentHashMap.java
&gt; They never catch on in widespread use because they're a lot more pain than they're worth. The few bugs you catch by having things immutable are offset and then some by the new pattern of having a million copies of the same data because you just needed to change "one thing" but data is immutable by default. Sorry, but that is plain wrong. Having worked with Scala for that past eight or so years, and I can clearly and unambiguously say, working with immutable by default is 100% the right decision, and is many many more than a "few bugs" that you prevent. If I write Java code now, I tend to go for immutable, too, because I learned that it is provenly better. Not in every specific context or situation, but in the broad general yes.
&gt; They're way too similar visually Many people are bringing up this argument, and without further ado one would think that intuitively this must be true. But when you work a while in Scala that has these two keyword, you realize that de-facto you do _not_ mix them up. That's really not a problem.
Explain 
this is just wrong headed, an API is an index, the implementation is the book itself, you can easily run a cart and horses through the intention of an API with implementation, so as such the API isn't really worth that much. If you are so worried about "theft" you probably don't understand open source sufficiently well enough to profit from it, so I'd suggest you keep it closed.
&gt;&gt; So **for us** it doesn't really matter how awesome your parser is; if you go out of business and we can't fix a bug ourselves we're likely to find an **alternative** that is OS. Here's the thing: you probably won't be my client, but many others will be (and are!), because they can get the job done in a few hours instead of a few weeks - and without the maintenance nightmare. The thing about building a closed-source solution is that there's no alternative that comes even close to what we are offering. You can choose to use Linux and not MacOS, or Eclipse over IntelliJ, but it may cost you more in the end simply because of the time you have to spend to make your open-source alternative work for you.
That's fine and I fully understand and support that decision. IntelliJ is closed source but I 200% support their business case :) But the OP was very specifically asking for an OS solution. I do appreciate the alternative view though, I think your input is valuable. It's just not the direction the OP appears to want to go in. 
Don't know about other alternative JVM languages, but I like to use Groovy to write small, throwaway scripts for things like backup, automating tasks, etc. These kind of scripts are usually written in a scripting language such as Python, however Groovy's syntax feels more natural to a Java developer.
Please stop. We don't need videos explaining how to install a program.
for 6 minutes even
I would not worry about protecting your work with copyright. If you work is really that good that big players (like google) plagiarize it then you will have gained enough fame anyway. You would not have the money to pay lawyers to enfore your copyright notice. 
&gt; In method bodies most variables do not need to be final. That's just like, your opinion, man.
Personally I think Jetbrains came up with Kotlin to entice Google to but them out for $$$$$$ Think about it google is using their product in Android Studio so Kotlin could be Google's answer to Swift on IOS for Android development. But quite honestly I love scala and its community and don't see a reason to use Kotlin instead other than for the sake of it. Personal taste of course.
maybe he needs a video explaining how not to bad post on reddit
So you usually program in SSA? I think a method body should be short and clear enough that a programmer doesn't has to think about making a local variable final or not. Same is true for the guy who wants to change the code next time. When he wants to change code and doesn't care about the algorithm and blindly changes local variables do you really think val would hinder him? 
[removed]
I think that people that can't do this and then bitch about it are just not smart enough
&gt; It is not open source yet. I don't know how to protect my work. Can Google take my API, implement it and steal my work? Yes. The real question is would they bother for *your specific API*, and I'm willing to bet money on "no" (as in literally - PM me, and I'll bet money and then we sit down and wait for Google to copy your API **^^:-)** ). &gt; What do I want? People cannot modify the API without my consent. Implementations must respect API contracts. Otherwise those implementations are illegal and I could sue the company providing them. It seems like you need a custom license, as the typical open source licenses don't permit this. If you release anything under GPL, MIT, Apache licenses, it's gone. You can't put the genie back in the bottle. That's what "open source" means, after all. You're deliberately opening the source.
If I'm expected to perform a Jack and Jill code academy trick like a performing seal I thank them for their time and explain that I believe trust and mutual respect to be integral elements in an effective business culture: if my resume and references are insufficient then I would take that as a sign of indecisive middle management and/or incomplete human resources. Thanks for the time, I don't think this company is for me. Done that twice, no regrets 
The coding exercise is to weed out people who can't code at all.
 &gt;You mean that you are allowed to use the same nightmare to process the XML ? Maybe if you understand it better it wouldn't be a nightmare. &gt; Schemas does exists in json too The sophistication of one vs. the other is tremendous. The tooling available for one vs. the other is tremendous. The spec for json schemas expired in 2013. The implementations vary greatly by platform and even libraries within that platform. It covers some basic types. On the other hand XML has https://en.wikipedia.org/wiki/XML#Related_specifications You can specify rangers, minimums, maximums, enumerations, etc... &gt;any XML conforment parser is a security nightmare Are you worried that you will denial-of-service your build tool, are you afraid that there will be information disclosure to the programmer? Could you help me understand the maven/xml security issues? &gt;you mean as any other textual language ? you're right there isnt' as big as a distinction. &gt;Can you explain ? See the XML specifications &gt;So XML clearly don't fit the job. some folks are less intimidated by &lt;/&gt;
Or candidates that have spent the last 15 years in Java roles and can't write a for loop to sum numbers in Java. It's... astounding. If I wanted to turn this into a TV show I'd have to tone it down just to make it believable. We had a senior candidate get pissed and storm out because we shouldn't expect a Java developer to know JCF without it being on the ~~resume~~ *job description*. What have you been doing the last 10+ years, using nothing but Vector and arrays?
Any place that is "bluffing" for their coding exercises is some place I never want to work. Meanwhile if you refuse to write a simple for loop when applying to a Java position we'll just shake your hand and say nice meeting you.
&gt; Or candidates that have spent the last 15 years in Java roles and can't write a for loop to sum numbers in Java. I always wonder how those people managed to fill a role for that long without being caught doing exactly nothing at all. I had an interviewee last year that was similar to what you were describing. Not that bad, but he had 5 or so years on my 14 years experience and could not explain the difference between a LinkedList and an ArrayList. At first I actually skipped those questions because I didn't want to insult him with stuff a junior would know.
Faith-based hires are _terrible_. Anyone can write anything on their resumes. What do you have against proving you can write a tiny amount of code?
&gt; the one who has to clean up the bullshit code from these people who do your 1 hour java assignment. Again: What? The assignment is there to filter out all the people who simply lie on their resume's. The types that claim 10 years of Java experience yet can't even write a String reversal. The 'hardest' part of that test will be something like a recursive solver. No big deal for programmers. Also this is a test you do at home, not on prem. You're making a ton of assumptions. This tests comes before the technical interview where we will asses a candidate. The test is just so that neither party wastes his time on a technical interview that won't go anywhere anyway. I'm a Java dev myself and have no interest in working together with people who aren't good at their trade either, trust me. 
&gt; How are they useful in evaluating a candidate for a job that requires solving business problems writing clean code? It's really useful as an indicator of a place to avoid applying at.
&gt; The problem is you want a C like, no libraries, CS string reversal. If you really were interviewing for a senior Java person, all you should accept is something like So YOU are telling ME what I want? That's approach is acceptable. I am going to ask him how many objects are created there though. That's something I expect a senior Java dev to be able to tell me. Also if I would (I normally wouldn't unless I suspect they just found the answers online, but this happened only once) then ask him to do the same in a for-loop I would expect them to come up with a solution easily too. 
You will probably hire people who interview well and memorize interview questions and answers. Good luck.
&gt; rediculous ridiculous :-)
You really have troubles reading don't you? I said we use them as a filter. They're not the base on which we hire you or not. 
&gt; The assignment is there to filter out all the people who simply lie on their resume's. It's a power trip for interviewers. If you can't tell if someone has lied by interviewing them, you know, asking questions, getting answers then, well you can guess the rest. &gt; yet can't even write a String reversal. Can't or can't under on the spot, performance pressure? Huge, huge difference. Exhibitionist coders are great at interviews, often poor at the long haul, daily thinking grind that it takes to build and fix real systems. 
Keep in mind not everyone is a native English speaker. So stop being a dick. 
You won't get to shake my hand but feel free to pat my butt on the rear as I leave before you extend your hand.
&gt; I believe trust and mutual respect to be integral elements in an effective business culture :-) 'zactly.
Read what I said about exhibitionist coders earlier in this discussion.
I don't recommend Gradle, uses too much memory and ends up crashing.
&gt; Think about it google is using their product in Android Studio Which was a massive mistake.
&gt; It's a power trip for interviewers. If you can't tell if someone has lied by interviewing them, you know, asking questions, getting answers then, well you can guess the rest. For efs sake. The point is that we don't want to even DO an interview if they are lying. That's the point of this test that they can do at home. If I have to interview someone it takes at least 3 hours out of my work day (1 to prepare, 2 for the interview). We don't want to spend that on every rando who things he can fake it by copying a resume. The purpose is to not waste anyone's time. &gt; Can't or can't under on the spot, performance pressure? I'm sorry but even though it's not something we normally ask if push were to come to shove and we found out someone can't do a for-loop that starts at the end of a string and works forward there's no point in continuing the interview. If you want to call that a power trip; fine. I really don't care. But that kind of stuff should be muscle memory for a senior dev. &gt; Exhibitionist coders are great at interviews, often poor at the long haul, daily thinking grind that it takes to build and fix real systems. "I do poorly in interviews but I'm in fact a misunderstood genius, really". That's how you're coming across right now. 
Not you you, but that's been my experience more than a few times. 
What I infer is that you perform poorly under pressure. There will be difficult days in the office and I don't need someone who's going to fall apart.
&gt; So you usually program in SSA? I didn't realise it's SSA but yes, seems like that's what I use. &gt; a programmer doesn't has to think about making a local variable final or not Well, I don't. I write `val` and move on. &gt; When he wants to change code and doesn't care about the algorithm and blindly changes local variables do you really think val would hinder him? He should stick to functional programming and avoid `var`-s or he has no place in touching our code base.
Work pressure is different than performance pressure.
Actually, *Oracle v. Google* did say definitively that APIs are copyrightable subject matter. So many software engineers heard about the fair use defense and got everything plain wrong. APIs are copyrightable. Open APIs are copyrightable- but implementing them *may* be fair use. That's cold comfort though. Fair use is something that you have to get through the entire trial of infringement on the merits to determine. So yeah, you might be okay after an 18-month-long trial is shoved down your throat by a company with way more money than creativity, and you spend tens of thousands of dollars handling their attempts to shut you down on technicalities early on.
Use RegExp using 3 groups and do not forget to escape the parentheses.
String[] arr = s.substring(1,s.length()-1). replace(" ", ""). split(","); gives you an array of strings, which you can then write to individual variables with Integer.parseInt(arr[...]). That works for every String formatted like that, no matter if it has 3 or 300 numbers. 
/r/javahelp
betamax vs vhs. it'll be used. 
Yeah I meant a resume, although as you guessed where I'm from we call them C.V.
Like I said, functional languages like Scala that have everything immutable by default (or other languages that did that as I'm not as familiar with Scala) have been around forever. Let's see how scala has caught on. Glassdoor.com in my area (minneapolis, mn): - "java" - 1,123 results 95% - "scala" - 57 results 5% Let's search for all of their listings nationwide. - "java" - 62,870 93% - "scala" - 4,939 7% I've heard these arguments before every time there's a new framework. Ruby on rails was going to "kill" java. Thymeleaf was going to replace that old crusty jsp (it hasn't with good reason). Jsf was going to be so much better than anything else. Etc. If you were working on a system who's priority was high reliability over anything else, that also had very limited input - like aircraft - I could see an argument. I wouldn't automatically agree, but I could see the argument. But that goes out the window the moment you're writing a web app. Data that goes out through the browser and back in again can be changed to be anything. You're literally constantly translating data back and forth between text strings to java objects to db rows and tables. That you say "oh, well when it's a data objects it's immutable!" effectively pointless, and the extra hassle and overhead gets you nothing other than patting yourself on the back **pretending** that your small slice of the data's lifespan being immutable is significant. In a web app your data doesn't spend that much time in java form. It's mutable in all it's other forms, making it immutable in it's java form is a lot of additional hassle and doesn't keep it immutable the rest of the time. It's a waste of hassle and time.
First of all, Google reused the method signatures (not implementations) of 37 Java API's that were open sourced as part of the OpenJDK. So Google didn't steal anything they were legally entitled too. As for Microsoft, they extended the Java API with their own Windows specific API's and continued to use the Java trademarks.
I wonder if we can't just write APIs, and have SOAP, REST and so on flash-in-the-pan protocols be simply placed on top of the API as a protocol layer / translator. Actually I don't wonder, as that's what I do. It's awkward to see Java EE shift from one fad to another, though.
Then you probably wouldn't have agreed to it with the recruiter or after we re-iterated the exact scenario you'd be in over the phone. Although it has happened. Once. He couldn't seem to put together any working code, at all, in libraries and frameworks he was an expert in. He got angry that we weren't willing to hire him purely off his resume and references. So we didn't. No big deal. Not sure why he showed up though.
I think they're a waste of time. There's just not that much you can learn with a coding test that you can't learn with a couple probing questions. 
It actually doesn't sound like you want to open source your stuff. What are you trying to achieve by open sourcing while also protecting your design so heavily? If you really think you have value, sell it with a proprietary license and protect everything but the real fluffy part of the marketing with an NDA. This is the only real protection for something like this. Think trade secret rather than patent etc. You probably can't afford to enforce a patent or copyright anyway. Even the NDA/licensing will require an expensive lawyer and that you sell your product to pay for it. If you can't do that, it's probably not really worth protecting as much as you think it is. 3 years of hard work seems like a lot, but at most it's an investment of a few hundred thousand dollars of salary.
Are you Turkish by any chance? You kind of have the general Turkish accent I know of.
I like a coding test, but none of the ones you mention. When vetting new hires, if I have a say in the matter, I give them a take home programming project that has simple elements and more complex elements. It should take a coupl of hours to complete for the average coder. The candidate might not do a perfect job of it, but that's OK. I see it as a technocal test, but also a "coding personality" test. Some candidates have produced pristine code but pedestrian solutions. Some have produced so ewhat sloppy but clever answers. We need all kinds of coders. :)
As a senior developer, I've been on both sides of a lot of interviews. Beyond the qualities that one might want from employees more generally, there are basically two ways for an interviewer gauge the abilities of a candidate for a developer job: 1. The quality of their portfolio. 2. How they do on exercises. If someone has a really strong portfolio with code samples they can actually show you, then that might be enough. Most developers–even great developers–do not have portfolios bursting with code samples they can legally show you though, so having a process in place to evaluate those individuals is key. For developer candidates that means you will probably need them to write code. Designing tests can be difficult though. A test is only helpful if it tells you whether someone can perform the job duties, so choose a problem related to the kind of work people actually do. It is unlikely that your employee will be writing Roman numeral conversations for their work, so why test them on that? Try and be upfront as possible ahead of time about the problem scope without revealing the specific task. As an example, my old team was interviewing people for a front-end developer position. We let the candidates know ahead of time they would be using the technologies listed in the ad in a web page styling test. Then we gave them an Illustrator file, a minimal base theme, walked them through everything, and asked them to try and get as much done as they could within the allotted time. Some people asked for more time and we gave it to them. A few people asked to take the assignment home and we let them. We were upfront with candidates that we never expected anyone to get through the whole thing, but were rather looking at how they did things. Very few people truly enjoy taking exams, but this process helped us identify a lot of people trying to oversell their abilities.
My opinion is that technical interviews are far too heavy on CS optimization gotchas and never touch on software engineering principles, which are used far more frequently than low level optimization nonsense. I also ask questions on how they would approach a problem. Give a few clues and see where their thought process takes them. Those are things that are harder to teach and more important than something I can look up in two seconds because I haven't used the interface in 5 months.
ML?
&gt; That's actually entirely possible. Yeah, I know what the other data structures are but in over a decade over CRUD development have never used anything other than ArrayList and occassionally HashMap. I've tried it, there's little point when you're following a simple pattern of "load / sort / display" or "receive / sort / save". Sorting it in the query with order by is usually the easiest, in some situations I'd use Collections.sort() with a Comparator. There's no reason to use the more complicated collections in a CRUD app in my experience.
We typically do this by presenting a current story or issue in our pipeline. We just ask them to diagram and pseudo code in whatever technology they are most comfortable in. It shows us problem solving skills and thought processes.
Maybe! I don't know.
The one danger with this is in mistaking a developer who is a good programmer but jumps around a lot for one who can't actually write code. For example, my job requires me to jump between about half a dozen languages fairly regularly (not to mention what I do on my own after hours), and I also sometimes go a week or two without actually writing much code because I have to tend to more pure architecture and management tasks. So, frequently I forget very basic things like "what the hell is the syntax for the new style array iteration in Java again?" It takes me probably 30 seconds or less to refresh my memory via Google (or looking at some code I remember writing before) and then I'm off to the races, but if that happened during an interview then you might conclude that I don't know what I'm doing, but you'd very very wrong. You'd miss out on a top-notch dev who maybe just doesn't have the memory of a young kid as a result of the nature of my work. To me, an interview task should be given to the candidate, along with a quiet place to work and a PC with Internet access. Give them a set amount of time to complete the task (or ask them how long they think it'll take and give them that time) and then leave them alone for that amount of time. When they're done, have them walk through the code they produced with you and probe them about it. Make sure they understand it and can explain their decisions. In short: on the job, results are what matter, not how you arrive at them. The same should be true during an interview. 
I think it might be so. to continue on the book analogy. Do you consider Swing an API? If so, the method implementations are the content chapters and the methods definitions the index entries? I see your point but when working on my API, the bulk of the work isn't in the implementation. The hard part is designing the API. Chapter Index entries are enslaved to the content. While the implementation is enslaved to the API contract definitions.
html?
What is the water bucket problem?
&gt; I personally feel that tricky questions, ones that require you to have memorized some algorithm or factoid, or "puzzle" style questions are signs of a poor interview process. These are mostly a test of "did you read the same online sources for interview questions that I did?". 
I was responsible for running an IT department for a consulting firm in SE Asia and China: lie filled resumes are standard practice there. In the end it came down to effective vetting and careful analysis of references. There's a few firms that do that kind of work very well(Vericant for example is great for verifying academic claims). At the end of the day I'd rather have a team that started off feeling respected then a team that started off walking on eggshells. It may have cost to outsource background checking elements but the return in productivity and retention was worth it.
My recent experience is definitely that the more time they want you to invest before you come in in person, the less likely they're actually going to hire you. Companies that want to hire right now have shorter processes. 1 short phone screen, 1 interview, and they make a decision has been the process in my experience for companies that actually hire. I don't know if it's different at places everyone is applying to like google, but even there I've read they got got rid of decided those long puzzle questions they used to do because they found it had no influence on whether someone made a productive employee or not. 
as a small player that probably will be my fate. 
I think fizzbuzz is a poor test as it has little correlation with what they're actually doing. Bring in a laptop with a working IDE and environment, see if they can pass info to a page and display it. Second part see if they can query simple info from the database and display it. I've become hesitant to invest more than 15 minutes before an in-person thing, and won't do more than an hour at all. My experience has repeatedly been that the more time they ask you to invest, the less likely they're hiring anyone at all. One company wanted me to do this big puzzle, then read all this stuff. It was the first time so I did it. Took 16 hours. I showed up - they didn't ask about the reading, they didn't ask about the programming puzzle at all, the woman running things had just been hired from another big company, and a few months later I got an email that implied that they had interviewed a bunch of people, hired no one, and now they were reaching out hoping some of the people they interviewed would still be interested. If it only takes them a few minutes to send it out, but it takes me hours to do it, my experience is they're not serious and I'm not wasting my time on it. A short test to weed out people incapable of coding is fine, more than that and they're usually just screwing around.
https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc. &gt;The appeals court reversed the district court on the central issue, holding that the "structure, sequence and organization" of an API was copyrightable. It also ruled for Oracle regarding the small amount of literal copying, holding that it was not de minimis. The case was remanded to the district court for reconsideration only the basis of the fair use doctrine
&gt; Err what? If we give you a one-hour Java assignment and you don't do it you won't get an interview. Simple-as. Do you only hire new college grads with a ton of free time on their hands? Does anyone actually do these? Most of the other programmers I've talked to have had the same experience I have - "take home" assignments mostly come from companies that are interviewing but not really hiring, so I don't waste my time on them any more. Last job 15 minutes on the phone, then an in person interview, then a decision the next day. When I got there I talked to someone who had also had the same experience I did at another company - they wanted to do lots of test and phone interviews and nothing ever went anywhere except more endless interviews. Another company wanted me to solve this puzzle programming problem, when I got there they didn't even ask about it. When I asked about it at the end of the interview, they told me to send it to some guy who they didn't even bother to bring in to the interview. These tests also don't give me any info about the company I'm interviewing with either so it's a waste of time for me as well. I have trouble imaging competent experienced people signing up for this unless you're a big name company people are clamoring to work for.
I wasn't sufficiently clear. It's hard to convey a rich and complex thought in a paragraph before impatience sets in.
Wow, that's a pretty great addition.
&gt; Do you only hire new college grads with a ton of free time on their hands? Why do all of these comments need to be borderline insulting? I've replied to these questions numerous times. We only hire senior devs. &gt; I have trouble imaging competent experienced people signing up for this unless you're a big name company people are clamoring to work for. Here in Holland we're basically one of the top-3 java consulting firms. So we have no issues getting applicants at all. If an applicant doesn't want to do a one hour tops code screening at home fine; there's plenty companies that hire anyone with a pulse. 
Yes. We do that. In the in-person interview he will get AFTER doing a simple Java test at home. It's really annoying that people here don't read the whole thread and just try to pick apart individual comments.
yes I am :)
I would say it depends on two factors: 1) Who are you interviewing. If its a junior and his first job, it might be god idea to check basics, if its a senior its better to talk about approach to problems and experiences. 2) How much time do you have for interview. If it's 1 hour i wouldn't get down to code. If it's 2+ hrs then its okay.
I read the thread. :) I just wanted to point out that the correct answer to the question "him how many objects are created" is rather complex and a huge jump from "reverse a string". Some people might ask that question and expect the answer "one more (the StringBuffer)", which _could_ be true (I haven't checked) but would still need elaborations. Instead of reversing a string, I got asked to reverse array content (in place because presumably it's huge), which I think hits the same spot but is less synthetic.
Google has a phone interview, 5 technical interviews on site, and then internal review (this last part you don't participate in).
shit?
&gt; API contracts are just index entries. I'm unsure why you're calling them "index entries". They are object type definitions and the behavior contracts bound to them. &gt; An API might be protected, that does not prevent you from using it. Well, actually if you're allowed to use an API, you have access to the API and you can still copy it. So that's not even factually right. &gt; It is indeed a complex matter and I understand that Oracle continues the legal fight since Oracle has money. I think you're so focused on the Oracle vs. Google case, you can't notice that this is not even near the top issue stopping you from starting your business. You're not Google, you're not Oracle. Think harder about the value proposition of what you intend to offer, as I suspect "I like it a lot, because I made it and makes sense to me" would be the core value proposition here, and it's not a good one. Indeed APIs take a ton of work, but if you intend to let the public **see the API** you can't possibly be so attached to the idea of no one ever borrowing ideas from it. &gt; My question was to get some community input on the issue of API protection. The API has come to mean two things: - First, the API alone, i.e. the interfaces. You can't hide those if you want the public to use the API (unlike what you said above). If you allow the public to instantiate and call your classes, then they obviously see the make-up of your API and they can copy that. - The second meaning of an API is a service with a public API. In this case the service doesn't publish its source, but it again provides access to its interfaces, so people can still copy it. There's only one way to protect your API and that is: don't show it to anyone. And BTW, the point of contention between Oracle and Google is about copying the exact 1:1 API to the letter. People will always be able to copy your API and *modify it somewhat* and claim it's their own API, **even** if Oracle wins their case. This is how C# .NET, a Java clone sort of, exists. Sun/Oracle never sued Microsoft for C#, despite it contains very similar core APIs as Java. They are just different enough in the way the method names are spelled and so on, that it's technically not the same API. So... rethink your goals, and strategies and then move ahead boldly without fearing whether your API can be copied or not. It's not up to your control anyway. 
Betting the future by catching up with the past ? Java EE moves too slow, already have everything mentioned using Spring Boot.
[Again](https://www.reddit.com/r/java/comments/5rzz2z/java_netbeans_82_download_and_install/)? Less than a day later? The very same link, and still using the attribution link? Reported.
This ^ It's easier for senior developers to blame the build tool when configurations start getting out of hand on larger projects, rather then the actual development group it's self. Doesn't matter what tool you use, if you can't maintain some standardization and organization, your shizzle is going south. All of the devs I work with are like "We're using XYZ because it's the best now, XML configuration sucks", and pretty much all of the SB/YAML/Gradle projects I've had to work with are a total mess and nearly impossible to understand without asking the dev who wrote the shit. 
&gt; Maybe, just maybe, your interview questions need a little bit of calibration. Do you know what a Map is? Can you combine two Collections? We do not expect you to know a stupid acronym. And you can use Google. 
There was an attempt.
That's borderline okay to me... given how much most devs look stuff up to get their job done, syntax or otherwise, I still feel like it might be slightly unfair to have to do it at a whiteboard since that probably doesn't match the reality of the job. But, if you're careful about the question you ask it can be okay... gotta be something that it's fair to expect most devs to be able to do without research. 
The video would be more live with at least some default soundtrack. Anyway thanks for the nice beginner tutorial.
Any big new features?
You forget if Java EE ever stops, your favourite Spring will start moving at a very specific speed...
Currently reading documentation on the site now -- appears to be a neat tool -- especially for teams that don't want to go through the process of maintaining LDAP and authentication servers
&gt; The problem with final var is that it's verbose. In terms of language design, we want the preferable syntax to be the easiest to write. Exactly. We should have `val` and `mut val` not `var` and `final var`. Mutable state is bad. Rust got this right with `let` and `let mut`
Hi. That sounds extremely odd. A factor 10 for clean build may well be, but are you saying those 4 classes take 1 minute in javac? What kind of classes are those? To give some comparison: I have one project of 21K LOC spread across 170 Scala files (that's a full blown framework). On my slow 2010 model laptop a clean build takes 150 seconds (2 1/2 minutes), of which 20 seconds or so is just dependency resolution. In normal operation with sbt running incremental build, changing a class or two will not take more than a few to a dozen seconds. So while compile times will depend on what you are actually doing - for example, if you use lots of type inference or recursively derived type classes - if you are really talking about a project with just a handful of classes, several minutes is clearly wrong. Is it possible that sbt spends a lot of time resolving a dependency, and you have slow or blocked Internet? You could try to shut down the network and see if it helps. If the problem persists, perhaps ask on the sbt Gitter channel.
&gt; In that 4 hours, it had to be done on their site, no ide's, tools, and no use of the web. Last time I had an interview like that, it was because the company literally didn't use IDEs and had no intention of starting. Free IDEs were not available at the time, but for the money they spent on drug testing, they could have purchased Visual Interdev for everyone. 
Honestly the easiest way is going to be to just make the files in netbeans and copy and past the code into it.
I agree with nerga. Your professor is a nutjob. IDE dependency is the last thing any programmer should want. 
Your comment smacks of extreme stupidity.
Agreed, but like a jedi who knows how to use a gun will always have a light sabre as the fav weapon, just like the IDE.
Development of Kotlin started in 2010. There was no Android Studio in 2010 and there was no Swift in 2010. It would be quite hard to "come up with Kotlin" in response to things that haven't existed yet :)
True that!
This, converting into a maven project is not that hard, specially if it is an academic project should be small. From there just open in NetBeans, I don't use it but I believe it will properly import a maven project, same goes with intellij. You can develop on intellij and when you are done just open NetBeans and export the required zip. Just be careful so that intellij specifics don't get in there (.idea directory and *.iml files). I think it is stupid to require a specific IDE but you can easily work around that. On my job we also use a mix, of Eclipse and intellij, since we use maven projects it's easy. 
The professor is going to want to assess a class of a hundred people's code. They aren't going to play around with 100 build systems. Having a standard format for the class to copy their likely 4 java files into seems entirely reasonable for assessment purposes.
[removed]
as it is today, in Java there are 2 main build systems in industry: Maven and Gradle, not 100. you choose one of the two, and then you can use whatever editor/IDE you want to write code. Focusing on a specific IDE which is not even so much used in practice (compared to Eclipse and IntelliJ) is not such a great idea... And I am saying it as a professor that does mark hundreds of student Java projects... :)
As it is today you should all be teaching Javascript as it provides better job prospects for students with webstorm. My point really being professors are rarely on or teaching the bleeding edge of programming and often just want to get the teaching ticked off so they can go back to their research.
&gt; Please seek help with java programming in /r/javahelp. 
Why not just run SpringBoot integration tests? No need to start your application through maven lifecycle, and surefire can run ITs separate from tests.
So pretty similar to Google guava then?
What do you mean by "require state"? Anything you can do with state, you can do with functional programming. You change the way you program when you use immutable data structures.
Good catch. Thanks!
If that data is just 20MB and not likely to grow I'd personally just keep it all in memory. Any specific indexing requirements? You could look into key-value stores like Redis but then you'd have the connection overhead between your service and Redis. 
Set.of having a requirement that the items be unique is a HORRIBLE design... everyone will just end up making mutable sets and then transforming those to get around the risk that someplace var1 and var2 point to the same thing! Gah!
netbeans will create a project out of a pom.xml. so assuming that it's already mavenized, just open the top level directory in netbeans (open project) and you're good to go
netbeans will open a maven project directly, zero additional config required. the professor is effectively requiring maven
Do you know if there is an equivalent of “The Bastards Book of Ruby” for the Java language? 
Spring Boot is something I use daily and very easy to use. So why don't you give it a shot? Like I said; 20MB is not a lot of data so easy to keep in memory. If you're doing multiple requests from the same client don't forget to configure the client and server to keep HTTP connections open.
This depends on how you store values in database, most of the databases support columns of character length not byte length, then just make sure that you have the same count of characters in validation and in DB. I also described how to create custom validation rule, you may return to article to find more, then you can do any check you please - including checking number of bytes after encoding...
But you can make your API accept and return `Immutable*` to prevent your users from sneaking around mutable collections. Not the perfect solution, but I find it okay given Java's ancient API.
This is normally solved with persistent collections. Check out Javaslang to see an example of them in Java. Also, aren't recursive algorithms on the JVM at risk of blowing the stack? Did you write your own trampoline? But to pull back a little, I think most people would agree that there are times when mutability is necessary, for performance or other reasons. Their general point is that in most cases it isn't something you need, and it should be carefully deployed only in those times that it is a requirement.
Is the Java virtual machine actually installed on your computer? 
&gt; strict response speed requirement. which is? 20 megs can be served from in memory just fine so data access should not be the problem. Also if the data is never going to change I would cache it on the client/requester if the requirements allow that. This can be finicky if you have too many clients relying on that though since this needs better integration than a simple rest endpoint.
Spring Boot with JPA achieves the same thing, but isn't generating scaffolding code. Instead, it provides default behaviours (i.e. db -&gt; entity -&gt; interface) which you can customize. You start with an entity class, which builds your tables (using JPA annotations you can fit the entity onto your pre-existing tables) and with a couple annotations you have a working scaffold using conventional behaviours rather than generated code. It's a different means to achieve the same result (rapid application development with minimal boilerplate). Worth a look if you're not too fixed in a particular approach. https://spring.io/guides/gs/accessing-data-jpa/
It allocates memory
Seems to me that that's attempting to use Set.of as a shortcut for a uniqueness filter, which is not its intended usage.
Would be nice if the Collections API could distinguish at the interface-level between immutable and mutable collections. Unfortunately that horse has long bolted.
Problem: functional algorithms often require tail call optimization to be fast, which Java doesn't support.
Is anything ever going to be used the way it's intended? [Hint: No](https://twitter.com/lukaseder/status/778153514300272640)
[Believe it or not, there's a different, optimised `Set` implementation for each degree up until 2](https://github.com/netroby/jdk9-dev/blob/master/jdk/src/java.base/share/classes/java/util/ImmutableCollections.java) and if the API is also distinct, then some additional inlining can happen in the JVM more easily, possibly avoiding the entire `Set` allocation in the first place (just my hypothesis, didn't check).
It's also great, because I have the freedom to give around a fixed collection of references to items that other code then can manipulate. If I want to have immutable items, I can still make them so. If you want immutability per default you need to look elsewhere I guess.
If you're working in a single-threaded world no problem. One of the main benefits of immutable structures is that it makes intercommunication between multiple threads safe. If parts of the immutability contract are broken, the whole concept becomes kind of useless. It's like a salad bar with a sneeze guard but there is a big hole in the middle of the glass. Sure it solves some problems but sneeze in the wrong place...
It's also no problem in a multi-threaded world. Well yes you have to design correctly, but you also have to do that when using FP constructs. E.g. problematic if you have to take ordering into account, caching and performance, dealing with barriers, critical sections or communicate with outside interfaces. In conclusion FP is making parallelization more easy, if the problem can easily be mapped to the map-reduce scenario. In all other cases it needs effort to get there. No free lunch.
Does anyone know why did they call it Collections::unmodifiableSet? Doesn't Java has other abstractions which use the word "immutable"? 
oh ok. there's Spring Roo . It can generate a site for you
[removed]
&gt; unmodifiableSet This method provides a view or wrapper around a Set for which all methods which would modify it will throw an exception and all other methods are delegated to the internal Set. I.e. it prevents the receiver from modifying it. The Set being wrapped is still mutable by anything with a reference to that Set. For example if the unmodifiable view were stored as a member of a object x, then anything with a reference to the internal Set could modify it, meaning that the unmodifiable set changes during the lifetime of the object x.
immutableSet is just a wrapper that references the original set and throws NotSupportedException whenever you try to call methods that will modify it. The underlying state of the original set may still change, though. 
No equivalent of Guava's Immutable{Set,List,Map}.copyOf(mutableCollection) yet, though? Or is there a better way to defensively make a immutable copy of an existing collection in Java 9?
I don't know about everyone else, but for me I'm not interested in java (or guava for that matter), collections which have objects that offer mutating methods but throw exceptions. I find the [javaslang](http://www.javaslang.io/javaslang-docs/#_introduction) collections vastly preferable. My reasoning is that if I'm using an exception throwing "immutable" JCF object in my code then I have to treat it specially, not like any other JCF object. Therefore I get no advantages from the common interface and might as well use a more suitable object like the ones in javaslang. In code which isn't mine that accepts JCF objects; I can't give it exception throwing objects, since it might try to modify them. However with javaslang objects I can always use the `toJava` methods when I need to interface with an external library without worrying about my immutable object being modified, or exceptions being thrown from java objects.
this makes coding a lot nicer - instead of importing a ton of classes that are only used a couple times each, you can just refer to them like `new okio.Something()` it makes it easier to avoid name clashes, and encourages class names that are simple and expressive (since it's easy to include the package name with the class) i really hope this trend continues 
 Set&lt;Integer&gt; set = Set.of("a", "a")); Shouldn't that be `Set&lt;String&gt;`? Also, does `List.of()` have the same duplicates limitation? **Edit:** Seems `List.of()` does not have issues with duplicates, while `Set.of()` does. As does `Map.of() with duplicate *keys*; duplicate values seems acceptable. This seems reasonable.
Many uses of anonymous inner classes (classes defined inline) are interfaces with a single method. Lambdas allow you to implement the same thing with much less code. Compare: Collections.sort(personList, new Comparator&lt;Person&gt;(){ public int compare(Person p1, Person p2){ return p1.firstName.compareTo(p2.firstName); } }); with: Collections.sort(personList, (Person p1, Person p2) -&gt; p1.firstName.compareTo(p2.firstName)); They are functionally identical. In this case, lambdas are syntactic sugar for anonymous inner classes. 
Until you already know the things that lambdas can replace, it will be very difficult to understand lambdas. I suggest continuing your learning about abstract classes, interfaces, inner classes, and anonymous classes first. Make sure you really understand them very well and have used them competently for a while. Then come back to lambdas. 
But javadoc generates html files from the comments and annotations in the java code and as such, is not a documentation viewer. :C
You can only use a lamda expression of the interface contains exactly one method. It knows which method you are implementing because there is only one. 
And what if Example has methods exampleMethod() and exampleMethod2()? How does it know which one I want to override?
Exactly one *abstract* method, so your interface can have default methods. You can have lambdas from abstract class, but they must have a single abstract method.
Yes, if you need to implement two or mores methods, you'll need the full anonymous inner class syntax.
yes. 
Great thank you for your help. btw. Example example = {() -&gt; System.out.println("Something else");} This doesnt seem to be working. EDIT: Just noticed that you typed it on the phone never mind :D
Thanks for help.
Doesn't let you compile what? Intellij will bug you about converting to lambda, but it shouldn't be forcing you to. I also agree with /u/GrantSRobertson and recommend disabling that inspection until you have a better understanding of what it's doing.
&gt; under what circumstances would you ever want to call Set.of with duplicates? Any time you want to create a set from a non-guaranteed-unique collection? So, like, a lot?
As a small note for more advanced readers: while lambdas are functionally very similar to anonymous inner classes, they aren't strictly syntactic sugar for them. Lambdas are implemented differently under the hood and have some slightly different semantics. https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood
I doubt that databases support arbitrary character based column types. The typical ``CHAR`` and ``VARCHAR`` types are based on bytes (true for MySQL and MS SQL Server). So the DB does not care whether you store ASCII, UTF-8 or UTF-16 within. Of course if you use UTF-16 you won't run into trouble as the encoded representation is the same as the internal one for Java. But with encodings with variable byte length you will run into trouble when you only rely on validation of the internal ``String`` representation of Java... just try it out 😉
* Slow and steady wins the race: plan what you're going to do before you do it. * Come prepared: at least have an skeleton project set up in your IDE with whatever you think you might need. 
It's not like the package name convention is present only in classes. If you publish to maven Central you have to use a domain-based group id as well. 
"HORRIBLE" is a well-recognised and widely (over?)used hyperbole for saying: "I disagree with this." Having said so, I disagree with this design. I don't see the point of enforcing this constraint on `Set.of()` arguments. It is, for instance, inconsistent with the behaviour of `new HashSet&lt;&gt;(Arrays.asList(1, 2, 1))` without giving any reason about the "design" rationale. Or, take JavaScript, for instance: $ {a: 1, b: 2, a: 3} &gt; {a: 3, b: 2} People bash JavaScript all day long, but its object (map) and array literals are really very nice. Most languages / APIs that allow for such `Set` construction would intuitively retain either the first or the last duplicate in argument iteration order (where last is probably a better choice, because that would be consistent with individual additions to the set/map, were it mutable).
If this is 20MB data set then maybe just write a library instead of a service? Suddenly lantency problem is gone. You only need to be able to update the data file - e.g. fetch it at startup and then poll some URI for changes.
Some people use the GitHub domain for GitHub projects like `com.github.square.okio` or `io.github.square.okio`. Since people tend to open source much more nowadays with providers like GithHub or Bitbucket the clashing potential is rising. A project name does not have to be unique (could be a fork) but the username is under the GitHub domain and thus you can also trace back the real homepage of that project while you use it. `io.github.square.okio` -&gt; http://square.github.io/okio in this case, there exists no hosted solution so you just provide the repository of the source: `com.github.square.okio` -&gt; https://github.com/square/okio
- exposing rest endpoints - 20 MB of data - strict response speed requirements I'd put it all in memory using something simple like a hash map. Load the hash map during program initialization and never mutate it. Generate no garbage during runtime that the garbage collector must clean up. The hardest part here would be the rest endpoints. If you can trust your clients to use the API properly and it's a simple API and you can test the clients, then read/write NIO sockets manually and generate no garbage. Keep everything simple enough with no dependencies such that you can end up tweaking and testing every line of the code to reach max performance. Also after deployment, warm up the machine with many test cases. Or if the complexity of the use cases precludes any of this, research what libraries (or JVMs) the programmers in the financial world and real time world are using and understand this will take a lot longer to get perfect than anyone expects.
Because when you find out there's a better way of coding the solution or a better/more efficient way to solve the problem you have to waste a lot of time going back and changing things, time which could have been used much more efficiently. 
Or maybe he just didnt know about it. 
Yeah and even if you like having short packages, you can work with low depth ones but refactor it to longer package names before sharing.
I was not referring to OP. Anyhow I meant that ignorance alone could be the issue too. Java's been around a long time. People rightfully question the weird ways a lot of things are done and sometimes they go overboard in doing away with conventions.
MongoDB isn't Relational. Calling it an ORM would be silly.
Why isn't https://projects.eclipse.org/proposals/eclipse-microprofile the submitted link? [Oh wait, then it's not driving traffic to infoq.com like almost every other post of yours](https://reddit.zendesk.com/hc/en-us/articles/204536499-What-constitutes-spam-Am-I-a-spammer-). Edit: Oh yeah and you have your SEO/tracking BS on the end of the link as well...
Looks really cool and clean. But "cool and clean" is not a good enough argument for our bosses. JUnit is something we already know and use a lot, and switching technologies usually takes time, which translates into money. I will definitely check this and probably use it in my personal projects though.
There are a few things wrong with this blog post: 1. Not adhering to [Java Code Conventions](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) + In Java, the opening curly braces are always on the same line that as the statement that opens the code block + In Java, Interfaces are never prefixed with "I". There is no `IList`, there is just `List`, there is no `IMap`, there is just `Map`. Prefixing interfaces with "I" is C style convention. 2. Code formatting. The code formatter used in the blog is horrible. + No indentation is maintained, everything is in one vertical line. + No Syntax highlighting + Proportional font for code - code should always be presented in monospace 3. Practices: it is uncommon (though not explicitly frowned upon) to misuse Interfaces for constants. Static utility classes (pretty much like `Math` are better suited for that purpose). 4. Nomenclature: Your `ISwap` example describes the [**Strategy Design Pattern**](http://java-design-patterns.com/patterns/strategy/) - name it as such. 5. Grammar: in English, articles are not optional: &gt; Like classes, we use `extends` keyword for extending an interface. Should be: &gt; Like classes, we use **the** `extends` keyword for extending an interface. Here, you should also apply an *inline code formatter* to make keywords easier identifiable as is used in this comment. 6. Inconsistency/wrong code: You use the prefix "I" in most cases, but in the paragraph about extending interfaces, you don't use it. In your interface `ISwap` you declare `void swap(int x, int y);`, but in your implementations you have `public void swap(int x, int y)`. The visibility modifier must be the same for declaration and implementation. 7. Violation of the [**Single Responsibility Principle**](https://en.wikipedia.org/wiki/Single_responsibility_principle): In your `ISwap` implementations, you print directly. This is not what a user would expect from a Swap routine. A Swap routine has exactly one purpose: to swap two values, nothing more, nothing less. Output should always be decoupled from processing. ---- Last, the title of your post here as well as of your blog post have very little to do with the actual contents of the blog post. You scratch variables in interfaces and then you talk a lot more about advantages of interfaces. There is no semantic connection between both, except that you talk about interfaces. This means that you haven't properly prepared your post and got carried away while writing. Pick one subject and handle it thoroughly. Then make another post with another subject and handle it thoroughly.
I think the focus on parallelism was exaggerated. The Scala libraries also have some parallel collections, which apparently are hardly used (can't find the source anymore). Without parallel features, the "Stream" API could have been made much more generally interesting with tons of nice features that are very easy to implement for sequential streams (e.g. `zip`, `zipWithIndex`, etc.) but not in parallel ones. Not sure if the infinite stream feature also incurs costs that don't pull their weight. But the fact is (as far as my Twitter followers are representative of "fact", and as far as my interpretation of that result is) that more collection API convenience is dearly wanted, parallel/infinite streams are nice-to-have. The EG's focus was on the nice-to-have feature, rather than the in-demand one. As a comparison: Oracle SQL has tons of parallel features as well, but I hardly ever see anyone using them. They're expert tools for niche use-cases (just like the `ForkJoinPool` itself) and don't need such a prominent API in the SQL language.
Oh interesting thought. That's quite possible for the `Set.of(E...)` call, but probably not for the `Set.of(E1, E2)` calls. So the fixed-degree constructors help bind the concrete implementation to the call site, which will constantly get the same result.
TL;DR: 1. IntelliJ 2. Netbeans 3. Eclipse but they all work... 
What bollocks. Take it seriously, OP, and you'll get more out of it and learn a lot in the process. Every single person I used to compete alongside in the ACM contests (that I'm still in touch with) is doing exceedingly well in their careers and most credit the competitions as instilling rigor and focus as a factor. People who treat them as a hacking contest tend to not win, then pooh-pooh the whole idea.
I've been assuming that the low number of functions was a result of conservative thinking due to backwards compatibility, but you make some very good points here. Thanks for the clarification!
It should be noted some OS projects will use org.package and then use com.package for their commercial offerings.
Great! Another article written by someone who has absolutely zero clue of what they are talking about. This reads like written by a Java beginner who just, by pure chance, has found interfaces and is surprised by their capabilities, not by a professional programmer who wants to actually teach something. The whole article is unprofessional, including the formatting, is unprepared, is wandering around, has a misleading title, and in general is common knowledge. **TL;DR:** "Look, I have stumbled upon interfaces" - material that is in every **beginner** Java course.
To be fair about 6, all methods declared in an interface are public. The visibility modifier is permitted but not required.
Perhaps, but on the other hand, those designers change their mind time and again. Compare this to `EnumSet.of(...)` (as mentioned otherwise in this discussion). I guess, when it comes to the JDK, the only reasonable answer to all questions is [this](https://www.youtube.com/watch?v=pWdd6_ZxX8c) :)
Got an error when I tried to run in on a work VM. Submitted an issue. Looks neat though!
Since this is *programming help*, it should be, as is pointed out in many places on this page, posted in **/r/javahelp**. Please, read the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. **Post removed:** programming help
Not a very helpful suggestion.
You'll be surprised at how much of Java EE is actually used in Spring. From my own experience the methodologies are pretty similar, the main difference is in how things are glued together. You're likely to see some sort of JAX-RS library and JPA among others.
Don't move. 
I don't care about directory structure. I do care greatly however about not forcing users to recompile everything because I moved project hosting from github.com to gitlab.com, or sf.net, or whatever. The com.company.org.blah works fine for commercially-produced code, where a company is its own domain name / hosting provider. It falls apart for open source hobbyist work. 
Yes that's what I've seen so far. Which makes me quite hopeful the transition will be fairly easy. Spring Boot is neat too, but almost too magical for me though. I have no idea if I'll be using that though. Is that largely in use for Spring 4?
Hi, First of all, I want to thank you for flagging this. Following, I’d like to express my view on the matter, if that’s ok: * Regarding the SEO/Tracking, I wasn’t even aware of it. The page has a “post to Reddit” button that is part of the [AddThis plug-in](https://www.addthis.com), and I just used that button to post. I believe this is rather standard for AddThis plug-in and therefore it probably happens with a myriad of sites and users, not just me. * The link about “What constitutes spam?” states that “If you are posting your own content and other redditors appreciate and upvote your posts, you shouldn't have anything to worry about”. It is true that I have been posting my own content, but so far it has always had a good reception. Also, I don’t fire-and-forget, I actually engage with comments and extra clarifications, and sometimes even correct my original articles if, after interacting with other users, I realise that the original content wasn’t entirely correct or clear. * Regarding this particular link, I don’t think posting to the Eclipse Foundation site would have been as informative. This article includes information about issues that occurred during the transition, while the project site is just that: the project site. For the above reasons, I don’t believe to have been spamming the community. However, I’m keen to hear what other users have to say, and if there is a common understanding that I have overstepped my boundaries, I’ll just apologise and take a step back. Happy to learn from my mistakes and remain a valuable member of the community :)
Those don't make copies. They just return a wrapper around the original collection which prevents any modification. If someone with a reference to the original collection makes changes to it, it'll be reflected in the "unmodifiable" view. 
actually I'm new to reddit ,the user interface of reddit seems to me very confusing . sorry 
I've been burned by the urge to immediately start coding too many times to count. I would always have to go back and rewrite or redesign and find the code that I had written was not conducive to modularity or extensibility or even to a system that I was trying to make. Essentially you wouldn't start building a house or a car without a plan so the same practice should apply to your code.
One of the more common trends now is to focus on using less libraries. That is why you see folks saying don't go as Spring is one of the worst offenders of library bloat. I personally still like it and think it is the easiest to use. The reason this trend is happening is so your application can start up as fast as possible. Things like serverless architectures are starting to force people to think of application cold start times and ideally you want your app to be as lightweight as possible. Just adding instead of the stupid comment "DONT DO IT"
I'm not sure why people are so afraid of static methods. As long as it doesn't use any global state and takes an input and returns an output it is easily testable and reusable.
On top of that: A ``private static`` method that could be reused is a good candidate for a ``public static`` message. Obviously it holds no state - so why artificially create an object around it? 
Spring boot is pretty awesome. Check out this presentation by Josh Long. Pretty good. https://m.youtube.com/watch?v=rqQOSG0DWPY
Spring has a lot of libraries, yes, but that is because they are highly partitioned, meaning that you only use what you need. Our latest web-based application relies on Boot, REST, jdbc and tx management, security, and a few other features of Spring. The jars, 33 of them, weigh in at about 10MB for the entire framework. Contrast that with Eclipse BIRT, the report runtime, which is over 50MB and 83 jars. Spring is not as heavy as you suggest.
&gt; The page has a “post to Reddit” button that is part of the AddThis plug-in, and I just used that button to post. Your blog post on sitepoint.com has the button, not the original source on projects.eclipse.org. So you wrote about it on sitepoint, then submitted to reddit. Hence promotion. &gt; Regarding the SEO/Tracking, I wasn’t even aware of it. ~~~And yet, /u/abrahammarinperez, almost *every* one of your links to sitepoint is by author "Abraham Marín Pérez", I guess you're not aware of that either?~~~ Edit: I'm a moron, didn't read that part properly, sorry. &gt; The link about “What constitutes spam?” states that “If you are posting your own content and other redditors appreciate and upvote your posts, you shouldn't have anything to worry about”. And the link to [the guidelines for self-promotion](https://www.reddit.com/wiki/selfpromotion) states that &gt; You should submit from a variety of sources (a general rule of thumb is that 10% or less of your posting and conversation should link to your own content) *10 percent*. Now look at your stats: domain submitted from|count|% :-|-:|-: [infoq.com](/search?q=%28and+site%3A%27infoq.com%27+author%3A%27abrahammarinperez%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|16|94% [javaworld.com](/search?q=%28and+site%3A%27javaworld.com%27+author%3A%27abrahammarinperez%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|6% subreddit submitted to|count|% :-|-:|-: [java](/r/java/search?q=author%3A%27abrahammarinperez%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|17|100%
I personally have seen this grown into the feared util-god-class :D attention is still required, but easy questions are generally: * Do I modify state * Am I reused elsewhere * Does me being `private static` force multiple boundaries merge in this class Correspondingly refactor the code
Here's a video tutorial that talks you through pretty much all the basics: https://www.udemy.com/java-tutorial/ It teaches you to get the JDK and an IDE, so it makes it a lot easier to start playing with Java yourself
Don't be convinced then. I personally am not going to refactor all of my imports, publish a new release, and then require any users to refactor all of their imports, just because I changed host providers. 
Spring Boot is only magical at first, it just replaces a lot of manual configuration and dependency management by simple annotations and all-in-one dependencies. This is a pretty fun starting point: http://start.spring.io/
unmodifiableSet is that. Guava's ImmutableSet however makes a copy.
Maybe you are thinking of indifference?
.... I cant see the wood for the trees!! What exactly is CDI portable extensions, and how does it help me?
I've seen purely functional implementations of various algorithms that ran in the same time complexity (but with a possibly large constant factor). I'm not sure if it's known how to do them in the same time complexity and space requirement in general. That said, this is a discussion about Java, and we know that Java isn't so great for functional programming (to put it in nice terms). In general, immutable / functional solutions can be just as fast or faster depending on the application. Immutable solutions are usually easier to reason about (saving developer time) and for example completely avoid certain patterns like safe-copying (improving time performance).
Not going to disagree here. As the OP article says, Java has tons of roadblocks when trying to use it in a functional way. Even the idea of immutability doesn't exist outside of primitives.
* Evolving a language. * Maintaining consistency. * Not breaking existing code. Pick two.
We use it too. Very helpful. Can't write tests without it anymore. CompileStatic has taken us years (we didn't even try for 1.5 years but we suffered without it), but our newest tests are all strongly typed and checked at compile time. 
`com.github` is kinda... github's though. `io.github` is more appropriate in my opinion.
John?
well, you got the not accurate part right
I was providing a basic sample of something that I know works and have seen implemented. If you're so inclined to avoid extra typing, google "save a class as a variable." Simply discrediting my entire post over a half-assed example isn't really mature IMHO
you were wrong on every point in that post save "may not be accurate" * you don't need reflection * ## isn't a java comment * you can't dereference a field from a class variable there is literally nothing in your post that doesn't discredit itself by being wrong 
"Nobody expects the CDI portable extensions" I agree one hundred percent. So please for the love of god do not use them in any code that other developers are going to have to work with unless you absolutely have to. Nobody expects them, so when they have to debug an issue they may be causing, they may have no idea where to even begin.
I am particularly excited for JDK-8068730. The increased precision can become very useful for more precise tracking of elapsed time without the problems that default System.nanoTime() comes with. Glad to see java.time continuing to get improvements
&gt; You can have lambdas from abstract class, but they must have a single abstract method. [Have you tested that or are you blowing smoke?](https://ideone.com/HjxnYt)
I don't know why that's being downvoted so much. In any case, I disagree as that just sounds like an extreme avoidance of imports. I can understand avoiding static imports since they obscure the origin of static references but even with those it is common to statically import JUnit and Mockito for tests...
Yes, many lesser smart people are not able to migrate from Java EE to Spring and the other one is doing. In the survey of ZT(When asking hundreds of developers) 36% are migrating from Java EE to Spring, compared 14% in the other direction. So actually yo make the right decision. At Spring, Forgot about manual configration and boot fast and neatly. 
No, criticism doesn't bother me. Provided, it's criticism not an attempt at bashing. Anyway, I've updated the repository. My mistake is just I write the first code I can think of and then try to improve it.
the concepts in JEE and Spring are very similar, so shouldn't be much difficult to use either of them once you know one. One advice, look at how Spring applications are tested (org.springframework.test) and the supporting annotations (eg @SQL to run SQL scripts for each test): so much easier than JEE, as you can use embedded containers (Tomcat or Jetty) instead of having to configure an external one as in JEE (Arquillian helps in JEE, but still more cumbersome)
You might want to reexamine why rules exist. https://publicobject.com/2016/04/20/deliberate-disobedience/
These competitions often rely heavily on optimizations, but I'm not sure if it's the case with "Junior" Java competition. That means that aside from getting the right result you actually need to make the program perform with extra large input values. They usually define what the maximum is. Reduce the steps it takes to calculate output to minimum, know about different lists, sets, arrays, and in what situations they perform better and worse. Try to find mathematical shortcuts, for example if you need to find 1 + 2 + ... + n, and you use loop, you are doing something wrong, because there's mathematical formula that lets you calculate it in a single step.
It's a very powerful mechanism for libraries to use though, and even for the Java EE platform itself. E.g. JPA and JSF both use them for spec level functionality.
For those that don't know, NetBeans was accepted into the Apache incubator a while back. http://incubator.apache.org/projects/netbeans.html
There will probably be about 3 people total that will use this, but if I can save those 3 people from going through the trouble of getting something like this done, which wasn't intended to be done by the plugs creators, as it seems, I hope it helps them.
[removed]
[Btw, beware that ojdbc (Oracle 12c) doesn't implement the JDBC specs correctly](http://stackoverflow.com/q/42091653/521799)
In Java EE, Payara among others works really well as embedded container.
Would "don't do it" be more helpful? :P
And i believe it will stay there for while. 
Are recording of the talks be available in video?
&gt; My mistake is just I write the first code I can think of and then try to improve it. Word of advice from an experienced programmer: *Plan your code*. Don't immediately hack away because this is bound to create unmaintainable code. Also, get rid of your Python habits. Java and Python take completely different approaches.
what can NetBeans do that intellij cannot? legitimately want to know. 
One thing that creates gc pressure is creating objects unnecessarily. 
EE stuff without paying for it. Great Maven support. Great Gradle support (so I'm told. It still feels slow to me). Makes itself super-easy to use right out of the box. Java (+Groovy +Scala), PHP, C/C++, Terminal/SSH built-in, and JS are all first-class languages with a whole buncha tools. It's far better than Eclipse, imho, but the full paid-for IntelliJ is probably better. 
The groupId is `com.squareup.okio` so that's not a problem.
About time. It looked like from the 90s before.
Care to elaborate? IntelliJ CE has excellent Maven support.
The old one looks better.
I liked the built in profiler
Eclipse has way better third-party support. There is a plugin for many languages and technologies. E.g. I work with mobilefirst, no netbeans for that.
So you are telling me, that you use every possible optimization to prevent object creation? You use `StringBuffer` and `StringBuilder` everywhere? You use indexed version of array looping just because the object creation of the synthetic sugar of the foreach loop is too expensive? You use `++i` everywhere because the creation of the temporary variable is too expensive? Be serious dude..
Why the hate?
Apache Spark with SparkSQL? It features easy json parsing into DataFrames, and can keep the entire dataset persisted into memory. Even if you don't go the SparkSQL route, the inmemory stuff still applies. 
&gt; So you are telling me, that you use every possible optimization to prevent object creation? You use StringBuffer and StringBuilder everywhere? Yes, actually I do. I have a helper interface which, among other things, contains default methods for str() and concat() &gt; You use indexed version of array looping just because the object creation of the synthetic sugar of the foreach loop is too expensive? No. My chief concern with loops is that they are performant, so I focus on optimizing object creation within the loop itself. However, I do use arrays instead of ArrayList when I have a list of a known, fixed size. Does that count? &gt; You use ++i everywhere because the creation of the temporary variable is too expensive? I'm not sure I understand the issue with ++i. Can you please elaborate? &gt; Be serious dude.. I'm serious. I don't understand the defense of a coding practice that intentionally and unnecessarily both creates objects and refactors code to be less direct in order to pursue a questionable dogma about code smell. 
Why embed node.js when you could just use Nashorn?!
I've tried to work with a very large maven project in both NetBeans and full IDEA and I prefer NetBeans. With Intellij, I couldn't find a way to stop it from trying to load every module and totally bog down my machine while it did it. It was unusable. NetBeans, by default, loads the top level pom and just has references to the modules inside it, you have to explicitly open the ones you want before it will try to load them.
The trick is to close the Project View in IntelliJ when it reimports poms - it makes it much faster and without lags. But how many of modules you had?
[:D](https://static3.fjcdn.com/comments/Jaffa+kree+_bb55b1a7d0aea3b775ccfe5aad0e5d52.jpg)
Wow that is creative
I think 3rd party plugins is where eclipse has them all beat. I like the Netbeans interface better than eclipse or intellij.
http://docs.spring.io/spring-boot/docs/1.5.1.RELEASE/reference/htmlsingle/ this can also be useful http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/
i think it's a bit odd that a convention requires a notional awareness of tlds and domains. it's weird that it's expected for a package name to correlate with a "real" url. yagni seems to apply here... i've never even potentially used two libraries of the same exact name at the same exact time, much less two of the same libname/authorname combo.
I second this. I use all three IDE's (not to be fancy...just ended up down that path for different projects). I like all three IDE's, but I have the most beefs with IntelliJ. I used to have a love-hate relationship with Eclipse until they fixed a lot of problems associated with m2e-wtp. I had to use RAD a lot in the past, but even that got better. I don't like how Maven support for Eclipse and IntelliJ is essentially a bridge between the IDE GUI and the Maven tool itself (m2e-wtp and whatever it's equivalent in IntelliJ). Both Eclipse and IntelliJ sometimes run into sync issues where the GUI doesn't reflect the actual state of the project. Hitting some kind of "refresh button" or setting a config option to "build automatically" might fix the problem, but remembering to do that sometimes, especially if you're new to the IDE, might waste a decent chunk of time. Another annoying waster of time is when you see the GUI downloading dependencies before you've even built the project with Maven itself. You don't deal with issues like that in NetBeans. Maven projects behave the same as a vanilla Java project. You build it, the project is updated, and it's dependencies are downloaded when you hit build (no run profiles, btw).
Nothing much to say (No drastic change) only apart from new apache domain name. From https://netbeans.org/downloads/ to http://netbeans.apache.org
I would suggest to read its code, actually. Spring Boot and other Spring projects have well structured and decently commented out code. Seeing how Sprint authors wrote something helps to understand advanced aspects of it. The books, docs and talks will still leave you a bit on the surface of Spring.
[removed]
https://www.hackerrank.com/
The site creator should read an article on "the legacy developer's guide to responsive websites"...
Spring has pretty good test coverage and [it's open-source](https://github.com/spring-projects/spring-boot). The tests are rather easy-to-understand and copy-paste from.
(x-post from /r/programming) Ah, excellent. One obvious question is whether SVM must compile Truffle interpreters, or whether it could AOT compile other ordinary Java programs as well. Graal is being used to implement AOT in HotSpot but you still need the whole HotSpot VM and infrastructure. It doesn't compile to a single binary and it doesn't do aggressive size optimisations. Also, the compiled binary is under the same license as the GraalVM itself. I wonder what that means in practice. Can you deploy such a thing to production, or distribute the binaries.
So, does that mean that they should not be included in the list of popular Java tools? 
(What follows is under the assumption that you're using a build tool backed by Maven Central.) The libraries you transitively depend on are referenced with their Maven coordinates which are the same on the system that built the project and on your system which needs them. In both cases the same name is used to reference the same JAR. While likely, it is not required for that JAR to have the same file name on both systems, though. In fact the file name is pretty irrelevant, so if your build uses, for example, a single folder to store all artifacts as `groupId.artifactId`, then that's fine and the program will work as planned. Because the JAR's name is irrelevant - all that matters is that it contains the right classes. When all your dependencies are fully modularized, then you're in a similar situation. The dependencies' names are baked into the module descriptor and their descriptors define the matching names - again regardless of the file name, which is hence irrelevant. So you are right, if everything's a module, this will not be a problem. It is pretty clear, though, that it will take many years before that is the case. In the meantime there will be plenty of projects using a mixture of modules and "regular" JARs. Here's where automatic modules come in. With them modules can depend on regular JARs. In such a case the names of a module's dependencies are baked into its module descriptor _but_ because these dependencies are by assumption not modularized, they don't declare their own module name. What to use as a name? Their JAR name. But _if_ that differs from system to system, you can end up in the scenario that two libs depend on the same third lib but use different file names and hence different module names for it.
It offers almost no good points for extension. There are a number of times I've wanted to extend a base JSF component, but the render kit classes are a mess of control and display logic, meaning to enhance either the functionality or the display you have to copy a whole bunch of code to ensure compatibility.
An example less contrived than "anacardiaceae.mangifera" vs. "juicy.drupe" would be the JARs of specs, e.g. hibernate-jpa-2.1-api-1.0.0.Final.jar (Hibernate's JPA API) vs. javax.persistence-2.1.1.jar (EclipseLink's JPA API). Jigsaw's take on this seems to be that specs like JPA should mandate a module name for the API module (e.g. "javax.persistence"). That's what we are considering to do for Bean Validation 2.0 ("javax.validation"), but of course it will take a while until that practice is common. The main issue I see is that one cannot easily override (transitive) module requirements. E.g. say I work on application A which has a requirement to "hibernate.jpa.2.1.api" but also uses another lib B which has a requirement to "javax.persistence". There is no way to align the two without repackaging B with an updated module descriptor. I think there really should be a way for updating/aliasing/excluding transitive requirements, somewhat similar to dependency exclusions in Maven. So I could express that "hibernate.jpa.2.1.api" acts to satisfy B's requirement of "javax.persistence".
Here is a good video to learn the basics: https://www.youtube.com/watch?v=JPOzWljLYuU For beginners it is a good start.
I think the JavaFX projects are doing an amazing job like * https://github.com/aalmiray/bootstrapfx * https://github.com/sialcasa/mvvmFX * https://github.com/jfoenixadmin/JFoenix
Thanks for sharing!
Well it's an implementation of a specific data structures yes. So that's like saying you 'can't control' how an Array works. It does what it says on the tin and if that isn't what you wanted, don't use it. If I gave you an `LRUCache` class then you also 'can't control' it to do something different like MRU. I'm not sure it's a valid complaint.
The article suggests using it as a cache. I'm saying it is not a very good cache. I'm criticizing the article, not the data structure.
And so Azul enters the Let's Advertise on Reddit club, not with [one](https://www.reddit.com/user/AzSysWiz) but [two](https://www.reddit.com/user/hgreenazul) brand new marketing accounts. Good luck you guys!
This mechanism can be useful. For example you want to spare time deserialising objects from entry sets in a database. Let's say because you query them very frequently. As soon as one of those entities is not used, it will be removed from the heap space. If you need it again, it will be deserialized and put into the cache. So this behaves like redis or memcached with php and a very short lifespan.
that's not that underrated. 1300 stars. 
The main problem with this approach--just reading the code--is that Spring Boot has lots of multipurpose annotations. If you rely on those annotations without understanding what they're doing and why, you're just another .NET developer pushing buttons and not knowing why.
Ignoring the confusion about the primitives, do you think the statement is incorrect? Do you think objects with strong references should be eligible for collection? Or are you disagreeing with something else? At the comment line, there are no strong references to the `one` objects. Note that the statement says nothing about when objects 'will' be collected, only that some objects aren't eligible.
In your example here, both one and two will only ever be on the stack, not the heap. Instance vars go on the heap.
&gt;Few have heard of Okio or OkHttp heh, OkHttp has 17k stars :)
Both of those bullet points are right, and they don't conflict with each other. At the point of the comment, there are no strong references at all to the `one` objects, which is why they're eligible for GC.
Jodd, I've used this library a lot. Awesome stuff, even the core utility contains very interesting stuff. - StringUtils - ArrayUtils - Class path scanner 
Thank you for pointing out my mistake :). I am a native speaker so the mistake is sadly inexcusable. I am sorry you got downvoted so heavily. 
Exactly! Are you from the midwest as well? 
That was actually entertaining.
Calm down man, I'll admit fully that I was drunk as hell when I wrote the comment and re-reading it well there was a reason I deleted it. So for that I apologize go the OP. I have used netbeans, dr java, Bluejay, eclipse (sts and jboss flavors) and intelij. I agree that he should use the tool the professor specified, however I have yet to see anyone else use it in prime time. I did see two peers back in college that came out not knowing how to use anything but notepad++ and netbeans. So if a beginner such like himself is going to get extremely familar with a tool, shouldn't he at least get familar with what I would call an industry standard?
but intellij isn't slow on my machine, with the same specs, or on any of my co-workers machines'. 
I started the MOOC yesterday and it's amazing. I did try Codecademy a while back but this one seems to be "clicking" with me more. I love that you can submit comments on each exercise and that you can look at their solution. I always look at their solution because sometimes it's different than mine and a lot of the time it's cleaner. 
[this ](https://i.stack.imgur.com/HvICL.png)is the menu i'm trying to get to work
In the system variables section, click "New.." and then set the variable to be "JAVA_HOME", with the value being the directory java is installed. If you are running it from cmd, you may have to open a new one and try again
thanks guys, working now! i'm a windows noob tbh
Funny this post came up today. I just left my job where I've worked from home over the last 2 years. My take on it? ...mixed. It's great having the freedom to work at your own pace, but I'll be honest, it does get boring. The day to day contact with coworkers in a office is surprisingly nice, and you will start to miss it. Also, be wary of cabin fever. I've noticed that the longer I worked from home, the more I felt like I needed to get out of the house. Just my two cents. I also did Java work, so it's probably going to be a similar experience. Hope this helps!
yeah, if it's a third-party library, and the class name is something ambiguous like Util, I like the idea of using the fully qualified name. it depends on the context, so if your class only uses one JettyHandler then it makes sense to import it. similarly since no one uses both JUnit and TestNG in the same test class, it is reasonable to statically import Assert.*.
you come to reddit asking for advice/input, then rather annoyingly and irrationally criticise nearly everyone who posts ? Which is a shame, as it is a good question.
If you prefer to keep your SQL in text files but don't want to run into problems when you have to generate SQL (for dynamic filtering in WHERE clauses etc.), take a look at [ElSql](https://github.com/OpenGamma/ElSql). To make dealing with JDBC easier, [fluent-jdbc](https://github.com/zsoltherpai/fluent-jdbc) is one of the best JDBC wrappers I've seen. Those two go very well together and are a nice alternative to relatively heavy solutions like JPA.
Well, reading the code will lead you to a place where annotated classes/methods are iterated over or to the annotation processor that generates some code. That'll give you a lot of understanding. The only thing you may miss is some back story. Like "this was done in an odd way, because java 1.4 did not had generics, but we still support it blah, blah, blah" kind of story. But there is not too much of it there, Spring is also decent at deprecating ancient things. And if you really curious, `git log` is right there. You may contact the authors and ask a question. 
I guess the joke didn't go over as well this time.
You should have used the /r/switcharoo Next time I guess.
I literally said out loud "dayum, gurl"
This video is a great test case for the final 'Make it Fast' step of development.
Well, perceptions vary from person to person. Some might agree with you while others (like new Java developers) might not. Besides, the article was not posted with the intention of getting any ad revenue since no ads are being posted on the site where the blog was originally posted. Anyways, thanks for the feedback.
Just FYI you don't really need these global variables. You can set environment variables per script like this. Put something like this at the start of your batch script SET JAVA_HOME="c:\path\to\jdk" I usually do it like this with gcc/jdk/python because I have few differenet versions installed But if you have only one JDK installed at a time, it might be a good idea to have a global variable anyway. You can set user environment variable instead of system one. It will work just the same. These can be easily set through registry editor in this key HKEY_CURRENT_USER\Environment 
It's common to have a private constructor and implement factory methods to create objects. The factory methods have a bit more freedom than constructors. For example, a factory method can instantiate a specific subclass based on method arguments.
You want a private constructor to hide the details of how objects are created for the class. A better idea is to have a static class method for returning instances of the class. This method may typically call a private constructor, but it also gives you the flexibility of also caching instances of that class for re-use if you have memory issues.
So for instance the math class has its private constructor that by using the static methods they automatically create the instances. Right?
Oh this is clear! Now I get it. 
Private constructors are good for cases where you don't want the end user to be able to call "new Foo". For example, an inner class may have a builder pattern that returns an already configured instance on build, but which cannot be created outside of it.
That's what I'm saying - speed is all relative, of course. Can you share what settings you use for your IntelliJ? I currently have it set to ea -server -Xms1g -Xmx1g -Xss16m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:+DoEscapeAnalysis -XX:+UseCompressedOops -XX:+UnlockExperimentalVMOptions -XX:+UseConcMarkSweepGC -XX:LargePageSizeInBytes=256m -XX:ReservedCodeCacheSize=96m -XX:+UseCodeCacheFlushing -XX:+UseCompressedOops -XX:ParallelGCThreads=8 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+DisableExplicitGC -XX:+ExplicitGCInvokesConcurrent -XX:+PrintGCDetails -XX:+PrintFlagsFinal -XX:+AggressiveOpts -XX:+HeapDumpOnOutOfMemoryError -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -XX:CMSInitiatingOccupancyFraction=60 -XX:+CMSClassUnloadingEnabled -XX:+CMSParallelRemarkEnabled -XX:+UseAdaptiveGCBoundary -XX:+UseSplitVerifier -XX:CompileThreshold=10000 -XX:+UseCompressedStrings -XX:+OptimizeStringConcat -XX:+UseStringCache -XX:+UseFastAccessorMethods Eclipse runs just fine even with the default settings. 
Is that a mistake? Those are three common dictionary words together
If you want people to use your stuff over the standard tools like JUnit please; * Explain why it's an improvement * Make it available in a maven repo * Actually test your stuff
&gt; You can set environment variables per script like this. Quite a few tools depend on them being set. Since he's a beginner it's best for him to just follow the instructions or he'll just get stuck somewhere else. 
What would the benefit of having the messy constructor private be?
Lets say it has parameters A, B, C, D, E. But really, you can only use (A, B, C) or (A, B, D) or (A, D, E), the other combinations are not allowed. So you make your public constructors offer the three valid combinations, then the private constructor accepts all the parameters and does the real work. Admittedly this is rare, but it does happen.
Side note: In some languages you get the same effect as Java's Math class using a slightly different syntax. * VB: `Public Model Math` * C#: `public static class Math` In these cases, there is no need for a private constructor because the compiler understands there isn't any constructor at all.
I love a good anti-ORM rant as much as the next guy, maybe more. But this wasn't a good one.
Lesson of the day: there are no silver bullets. Hating Hibernate is just as stupid as loving it unconditionally because there are times when Hibernate _is_ the best tool for the job. You just have know when to use which tool instead of just listening to propaganda and using the framework of the week (or hating the anti-framework of the week).
Hey, beginners. Don't call classes with all static methods, "modules". They're not called modules in Java world. Source: I'm a professional Java developer. Since 2004.
I'm also a professional Java developer, and I call them modules because that's what they're called in every other programming language.
fight the good fight.
So why would I want the functionality of my less complex constructors to be aggregated in one complex, messy constructor? Let's say the way I want to initialize the class with my (A,B,C) constructor changes in the future, there'd be a good chance I have to change the (A,B,C,D,E)-Constructor as well, since it implements the functionality for my (A,B,C) constructor. But this might break the (A,B,D) and (A,D,E) constructors.
you are so right. I should have not written that comment (or at least not in the way it was written). I honestly did not mean to criticize anyone nor a any project. 
Java 9 introduces the concept of "modules" as something completely different.
Use an enum for that. Their constructors are always private and instance creation is handled by the JVM.
That's the attitude that makes Java developers think they use late binding and pass-by-reference and makes everyone else think we're idiots. 
I'm very aware of the xkcd. The output of the program will tell you exactly why it is rated as it is. The fact is, three words is just not enough to be safe from an attack using dictionary combinations. With a 10k word dictionary, 3 words can be guessed in a maximum of 1,000,000,000,000 tries. 4 words increases that to 10,000,000,000,000,000 tries.
it's hard to get people to test, and the few that do they get on with junit (the de facto standard). I would like to hear some alternative approach on how code should be tested... but I am afraid your github page does not tell me so... please update and I will check your project again good luck
Duh. Author missed the obvious solution: $ touch duh.class If they insist that javac produces it, do this instead: $ touch duh.java $ javac duh.java
As much as ORM is a pain, what the hell kind of argument is this against it? This is just a made up story. *Why* didn't hibernate work for Monica? I've seen hibernate installs running for the last 6 years with no drama. Maybe Monica whiffed her data model. Let's stick to facts when making arguments for and against ideas, not fictions that vaguely fail somehow
Plus, it's a quine 😉
No, because without competition every company just halts... When MS had no competition for their browser they just stopped. When intel had no competition for their high end cpus, well they didn't stop but severely slowed down. Bottom line, we all scream that Xbox must die because PlayStation is so much better, or that Samsung must die since Apple is so much better, but without those arch rivals innovation would just stop. And besides that, do you think Spring isn't in the game for the money?
That was a good read, but it made me think of why the dichotomy javacode/bytecode is painful. Some will say it's an unfair comparison, but if one was to ask the same question in javascript (what's the smallest javascript file you can produce so that can be read by nodejs or the browser) the correct answer would not require the best brains to get worked out. by the way, for all you might care, the answer would be an empty file (an empty string is valid javascript) 
on phone, but I'm running default with xmx4g, and some higher memory options for the rest 
Eh, I don't think JSF itself is that bad in that respect - it's things like primefaces that are the killers for that.
Holy Lord!
I agree. I've been working from home 2-4 days per week for the last 8 years. I am not sure I'd recommend it.
TLDW: If you are processing lots of data, use space efficient objects, consider using a binary representation of the data. Pretty underwhelming video imo, but if you are unfamiliar with how data is represented in binary. It doesn't really cover stuff like off heap storage, or really anything about performance other than reducing the amount of data you put into memory and hence reduce how much garbage collection you need to do.
You are correct, I agree with you. I was trying to make the case for the Singleton pattern with my answer, but maybe I missed the mark.
100% Correct, in my application Hibernate performs better for at least 9 out of 10 times it is being used. The only time it has really choked was a large object graph where the generated query for PostgreSQL was rather large and the PG Driver used .toCharArray(), but I patched my driver to use sun.misc.Unsafe to pull the array from the String (Because it was just constructing another string). If I were say doing a Banking Application, I'd use JDBC. Pick the right tool for the job and, PROFILE.
Ahh I see, thanks; misread the summary when skimming. That's really amazing overall then. Happen to know numbers on the Graal dynamic compiler?
First thing on Google: http://superuser.com/questions/949560/how-do-i-set-system-environment-variables-in-windows-10
Im also looking for a podcast! 
There are no good Java podcasts. I've tried every one I can find. All they do is ramble on about how much fun they had at all the conferences they went to and how special and authentic the beer they're drinking is. If they talk about Java at all they rattle off the wacky names of about fifteen frameworks without ever explaining what they actually do or why one would use them. Oh, and the audio quality usually sucks too.
You'd be arguing incorrectly. Because i just instantiated a type that *instanceOf* and *SomeAbstractClass.class.isInstance* would return *true* for, so it **is** a *SomeAbstractClass*, albiet anonymous.
reading SVM... Support Vector Machines? What? Was hella confused :D
Thanks, I'll have a look at those episodes
There's no such thing as "public final class" in C#.
I forgot to mention, I did use C. I have done some projects in codeblocks aswell.
The first sentence says it: The Substrate Virtual Machine, or SVM . . .
Anything else available?
&gt; how special and authentic the beer they're drinking is I thought that was all there was about it :(
How is it painful? The bytecode should be opaque to most users of java. Same reason people don't usually manually peruse the .o files gcc generates when compiling C
Oh, I'm not knocking the improvements classes gave us over bare C (though I'm not sure you can call GC an OO concept), just noting that it's sad that Alan Kay's original vision is only just now getting realized. OO was meant to be about a lot more than classes, but for some reason C++ and Java became the stand-ins for that idea despite lacking many of the key concepts. I'd cautiously agree with your comments about performance, with some caveats: First, the vast majority of code obeys the 90-10 rules, in which there's only a key section that really is performance critical. Second, I've found that database queries are a far more common performance bottleneck in your standard enterprise CRUD app than anything in the actual software. Third, while higher levels of abstraction tend to impede performance on a cycle-by-cycle basis, I've often leveraged higher level abstractions + parallelism to blow "faster" code out of the water. In a multi-core era, the ease with which you can parallelize your operations has been much more important to me than how fast they run on one CPU - and given how almost everything seems to be network IO-bound nowadays, performance really does become a matter of leveraging the ability to do multiple things at once. That's from my limited perspective though (server-side, JVM, SOA/microservices), someone who wrote client apps or database drivers would probably have quite a different one.
I checked on youtube. The oracle version is old. Gluon now maintains it https://www.youtube.com/watch?v=T3NlWMzPyXM http://gluonhq.com/open-source/scene-builder/
They did talk about some good, solid practices for Java, that really don't go out of relevance. If you have a solid base of Java, much of what they talked about can also be found in a more cohesive format in Josh Bloch's amazing book ["Effective Java"](https://smile.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/ref=sr_1_1?ie=UTF8&amp;qid=1486760145&amp;sr=8-1&amp;keywords=effective+java) . even though this book was last published in 2008, the content is as relevant as ever, as it discusses foundational best practices.
Yep, that seems like the answer. Funny Intellij keeps the oracle version integrated into their IDE....
Programming is easy to pick up. Difficult is to learn all the ecosystem and good design. 
Learn the basics. You can spend time learning frameworks but if you don't understand what its doing under the hood you will be hurting yourself. Learn HTTP - Best way is browser dev tools and cURL. Once you are confident you understand HTTP well it becomes much easier debugging frameworks. Learn logging - SLF4J and Logback or Log4J. I can't tell you how many senior engineers I meet who have no idea how logging works or how to use it properly. Logging saves you tons of time debugging. It can also cause performance hits or security issues if you log too much. Learn build tools like Maven and Gradle. In rare cases strange things can happen with dependencies can cause difficult to track down bugs. Once you have a firm understanding of maven / gradle its easier to identify these rare issues and track down the root cause. Learn SQL - If you know SQL well and turn on proper logging you can debug any ORM framework. 
I agree with you. Scene builder sucks. I have found a workaround to the problem of it not updating changes correctly. I go into the fxml editor in my IDE (Eclipse), add a space somewhere, then save it. Then I delete the space and save it again. After that the changes are reflected in the program correctly.
Airhacks by Adam Bien is OK
The problem with this approach is that the supposed strategy for Hibernate is to put your business logic in your entity objects. If you'll be working around your entity objects for the "trouble spots", now you're duplicating business logic in multiple places and you risk ending up with inconsistencies that are very hard to debug. If you'll be using Hibernate with another DAL, then you must wrap everything in a service object and put all your business logic there and NOT in the entities (which now will be just "dumb data transfer objects, DTO"). But if you'll be using Hibernate just to materialize and persist DTOs, then the whole value of Hibernate is drastically reduced.
Of course, because the anonymous is a subclass of the abstract. This doesn't mean it's not a new class definition. I'm pretty sure the JVM will see it as SomeAbstractClass$1
www.illegalargument.com is/was pretty decent. It's not completely Java specific, but the hosts are strong engineers and talk a lot about Java. In the last / most recent episode two of the hosts appear to have gotten into a heated discussion about the effectiveness of estimating stories / tickets in Jira. Hopefully that's not the reason why I haven't seen a new episode pop up on my phone since last August. I really enjoyed listening to these guys.
/r/javahelp is more suited for questions like these That said: Between Spring and Java EE there are so many similarities that it doesn't really matter which one you pick. Most concepts transfer really well and Spring is for a large part built on Java EE. Make something simple with both of them (simple Hello World REST API for example) and see which one you prefer. 
I do enterprise consulting, our Java web projects are all JEE based, been long time "friend" of Websphere. Only used Spring once in 2014 for a prototype, as part of a proposal deliveries. Currently on a .NET project, but what I hear from the ongoing JEE projects, they are all focused on PrimeFaces for the greenfield ones, with some legacy ones still using RichFaces, which means JEE with the JSF stack. But this is the typical enterprise consulting, with 20 - 50 devs, scattered around the globe, so your situation might vary.
Yes there is: practice on a real project. You'll then pick up different parts as you go along. eg I'm writing a queue simulator in Kotlin to learn the basics of Kotlin. I've ended up diving into DSL design, different test frameworks and co-routines. It doesn't have to be a fantastic idea that's never been done before, just choose something doable and start coding.
REST for sure, it's the standard nowadays and there are many libraries to make your life easier, such as JAX-RS implementations Jersey and Jackson. JSP is neither SOAP nor REST, it's just a Servlet with some HTML preprocessing.
Rest 
In past 10 years I have gone from Programming is easy - &gt; Damm how do they do that - &gt; Oh I can do most things, this is not so hard -&gt; Damm wtf is this method supposed to do -&gt; Am I supposed to rewrite this entire thing -&gt; PROGRAMMING IS HARD. Java syntax is easy but man programming is hard. 
Nobody needs JEE just for competitions sake. There can be other competitors. And Pivotal certainly wants to make money, but they try to get it via quality products, not by vendor lock-in blackmailing, patent suits, prohibitive licenses, and generally being an asshole about open-source.
I would say it depends on the coupling between the client and server you want to achieve. To break it down in a few words, with SOAP you get a tight coupling between client and server. Client and server are entering into a rigid contract to each other. Means you are not allowed to change you web service after you publish it. I guest that's one of the reason you'll find so many SOAP applications in the enterprise world. On the other hand you have less coupling with REST. The REST client only has to know the entry point of the server side and not a knowledge of the API behind. The advantage of this is, the client side don't violate the contract if he adds extra methods. So it really depends, what's the goal of your web service. In general I would say, use REST if you're web service targets to any normal end user. If you're web service targets to any enterprise application where you are not allowed to change it frequently, use SOAP. To make the decision more difficult as it already is, in the end, you can achieve both either with SOAP or with REST :)
"So why is Docker, Kubernetes and enterprise Java such a natural fit?" Because Oracle does not bother to provide an official java docker image, or linux packages? Because oracle licenses prohibit creation of Docker images with their products? "The most obvious benefit to using container technology with Java EE applications, and perhaps the feature most beneficial to software developers, is the incredibly fast build times. ... You can only achieve this performance with very thin WARs, and infrastructure that doesn't have to be rebuilt each time. " Java Enterprise is mostly used with Maven, the slowest of the modern buildsystems. The main time during build is lost on testing, where there is no difference between JavaEE and others (Except for JavaEE not providing any testing support itself). "...which is pivotal for production systems hosting applications that are ..." bad choice of words?
What annotation is that, I wonder?
I get fucked enough by my own code already, no thanks.
I've been looking into some books and this just made it easy. Thanks for the link!
At my company I recently switched from vanilla Java EE to Spring (Boot) with some Java EE libraries thrown in.
Depends on the person. I'm just past 2 years in to a remote job and I can't see myself ever working in an office again. 
I started with JavaScript and went on to learn Java too. This what I used to learn Java. Start here: https://docs.oracle.com/javase/tutorial/getStarted/index.html Then go through this: https://docs.oracle.com/javase/tutorial/java/index.html Then this: https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html That will teach you the almost everything you need to know about the Java language. From there it's just learning about what different libraries and classes do. 
&gt;Design Patters 1994 Is this still relevant? I mean it's over 20 years old by now.
Just refresh the workspace. Like press F5 on the folder holding FXML. The refresh is a problem of Eclipse, not SceneBuilder. It also occurs with many other formats.
I have read something like this few months ago. Not sure if it is the same article or this guy copied it entirely.
Using the newest [Gluon SceneBuilder](http://gluonhq.com/products/scene-builder/), I've not experienced any of the problems you mentioned.
Yes, a legit choice if this was based on trade-offs. Never do something, because you can. Good luck on your success road :)
Great writeup, I just started using actuator and I think it's fantastic. If you're looking to add to this piece, I think it might be worth mentioning the "info" endpoint - any properties defined with the "info." prefix are automatically exposed on the /info endpoint. I find this to be a really simple and powerful way to expose information about version/build/etc. without hooking in to the "real" git/build provider classes.
Thanks. I'll keep those in mind. ;) Cheers.
The academy provides certificates once I finish it, meaning I can take tests for certificates that are highly valued in the world of programming. 
Agree with the comment above. Payara is gaining most momentum now, with WildFly (JBoss) being a very good established server. WAS Liberty is very good too, although closed source. I used to be in love with TomEE, but for some reason it seems to have lost some momentum. The speed with which they advance has decreased and I'm not sure that David Blevins (the original programmer) is even really involved with it anymore.
If inefficient queries are being generated then you can always create native queries. ORMs don't stop you needing to understand SQL; they just reduce the amount of boilerplate code you have to write.
Its a new class, yes. But it's still a subclass of a class that it should not be.
Good thing we're talking about Java 😉
This site is really not very good. They only counted Amazon links to compile their data. Meanwhile, *Effective Java* has its own tag on Stack Overflow, which is used over 100 times. People mention it without linking to it all the time.
&gt; Singletons, observer, factory, etc. Do you really need a book for this? Like... each of those topics would be a single page.
i use with mybatis. i'm writing a intellij plugin to generate all the crud code https://github.com/gejun123456/MyBatisCodeHelper. never need to write sql anymore(except join) 😁
As the subtitle states: the patterns are meant for *object orientated* languages - so the limitation is clear.
Singletons in Java: use an enum. Done.
Singletons - just don't.
It's not even a good idea for all object orientated languages. It's probably true for Java, with a healthy dose of scepticism, and to some extent C++ but many of the design patterns exist to overcome weaknesses in Java 1.5/6 as a language.
Or scala
So how do you deal with application wide services/connections?
That's a fair caveat. There are often better ways to solve some problems in, say, JavaScript.
Avoid them. Pass in connections to components that need them at creation. Pass a Context interface which allows retrieval of a connection which allows you to mock it out in tests. Singletons are a fancy name for global variable. They make code very hard to test and isolate and encourage code which is very difficult to reason about, as they strongly encourage action at a distance.
&gt; Pass in connections to components that need them at creation. In what way? If you do this "dependency injection" principle for everything, you end up making every object have a constructor with 50 parameters.... ooooor you end up with a massive "dependency injection container" system object that becomes a monster that makes your code impossible to deal with...... &gt;Singletons are a fancy name for global variable. Except they really aren't. They're encapsulated objects that don't let you alter their state in a dangerous way. Global variables just float around and let you destroy them without complaint. A singleton can only be destroyed/modified if the singleton allows it. &gt;They make code very hard to test and isolate and encourage code which is very difficult to reason about, as they strongly encourage action at a distance. The alternative is to make the code more easily tested and much harder to implement or modify.
new Foo(mContext); mContext.getDatabaseConnection(); This is a surprisingly powerful model as you can provide subcomponents with a modified context to change their view of the world. If you think this is horrible, this is just making explicit what you are already doing, but allowing it to be overriden. Effectively FooDatabaseConnection.INSTANCE is roughly jEnv.getClass(j_com_company_FooDatabaseConnection_id).getStaticMember(j_com_company_FooDatabaseConnection_INSTANCE_id), where jEnv is the Java Environment which Java passes to every function, and the ids are static constants defined at compile time. Also if you have fifty of these you probably need to rethink your design.
&gt; Also if you have fifty of these you probably need to rethink your design. What's the largest project you've worked on...? Cause there's a lot of situations where a top level class calls on a ton of sub-classes that will each make use of various services, then when you need to add a new service, you need to modify every class up the call chain... which is horrible.
&gt; Sometimes singletons are the right 'short' term answer, but they represent a long term architectural and testing headache.l Sure, but I find people go to extremes to avoid them and end up writing far uglier code because of their stringent 'no singletons' rule... &gt;Also often that thing you thought you would only have one of, you now need two or six due to a change in requirements! :) I don't doubt that. There's nothing more permanent than a "Temporary Hack/Fix".
 Example 1: StringLogInterface log; log = new ArrayStringLog ("Exer 20"); log.insert ("what is the difference" ); log.clear (); Example 2: StringLogInterface log; log = new ArrayStringLog ("Exer 20"); log.insert ("what is the difference" ); log = new ArrayStringLog (log.getName ()); Use 4 spaces before each statementto indent properly next time. The differences are that clear isn't called in the second example, and a new object is created and the log variable is set to it, after the insert statement in the second example.
The first one is reusing the same log object, while the second one is creating a new object and leaving the old one for the garbage collector to clean up. Though, I assume you got that much. As far as the functionality of this code, they are just the same. However there may be performance issues. I'm not familiar with that class, but it may take longer to just clear the log rather than create a new one. In a more complicated system, you may have some code that configured the log. Simply clearing it would avoid needing to re-execute all that configuration code. The ArrayStringLog class may even set a timestamp variable when it is created. Clearing the log would preserve that timestamp while instantiating a new one would give you a new timestamp. This could have unintended consequences in some other part of the program. This is why you really gotta look into how that particular class behaves. The books always tell you that an interface is a "contact" about what a class that implements it will do, but that is an oversimplification. An interface does not say which fields will be set to what in the constructor of an implementing class. You still gotta look at the code of said implementing class.
&gt; Maybe Monica whiffed her data model Every time I see someone criticizing Hibernate I wonder if they understand basic database concepts like third normal form or natural keys vs surrogate keys. You never see that stuff mentioned in 'stories' like these. And if you don't of course you're going to have trouble with any ORM library.
I'm not talking about data objects knowing how and where they're saved. I'm talking about where the business logic is. Do you know what business logic is? Well, short story is that it's not persistence logic, which is what you're talking about :P
I wasn't trying to be snarking, and yes I know the difference, business data, and business process are separate concerns. Ready a little on SOLID https://en.wikipedia.org/wiki/SOLID_(object-oriented_design). 
And that tag system is BS. 
Well, in my experience JPA and JPQL really help when your application has to be able to connect to different databases which aren't even running the same software (local HSQL vs production database). SQL isn't really standardised so it really helps that you don't have to carefully find a way to make it work on both or, god forbid, have two different queries for both databases. I also really like that JPQL, unlike pure JDBC, allows you to put named parameters in your queries. You can even do this in native SQL queries. My experience. [YMMV](https://en.wiktionary.org/wiki/your_mileage_may_vary)
Nice to see Head First Design Patterns in the list. Been reading that lately. Verbose, but covers many of the majors very well.
It's what people said about MS too. When IE had 100% of the market share, they abandoned the iE team,saying browsers were "done". And remember that Java EE is more than Oracle. There's also Jboss, Payara and TomEE for instance.
&gt; SQL isn't really standardised Well to be pendantic: https://en.wikipedia.org/wiki/Pedant Sql is standardized. But then vendors put their own crap in there and destandardized it so...right "pendantic": pointing out when you're technically wrong, when overall you're right. lol &gt; I also really like that JPQL, unlike pure JDBC, allows you to put named parameters in your queries. You can even do this in native SQL queries. I do like the named params, but do not like running into the bugs and different behavior in queries which is my experience with using it. It's odd they don't have named parameters is jdbc. 
It doesn't come with JSF out of the box, but you can add it in various ways.
And Thinking in Java.
Spring and Java EE are pretty intetesting. Vert.x is a different style and may be comfirtable to wait Kotlin 1.1 coroutine to avoid callback-hell. (Kotlin is a sintactic mix of Java-Scala-C#)
As someone who's been programming for most of the time I've been self-aware, Java is admittedly one of the easiest languages I've used. The issue is, Java is gigantic and often taught poorly and explained terribly. The key to learning to program (notice I didn't say learn Java, programming is mostly universal) 1.) Motivation and purpose 2.) Adequate learning resources and spaces to ask questions and such Optionally but optimally, 3.) Know someone who is already a decent enough programmer. I'm no Linus Torvalds, but I know Java, Scala, and Clojure pretty well, feel free to PM me.
I'd say complexity-wise Java is in the middle of programming-languages. The big problem beginners usually face is, that you basically need to be familiar (at least in an abstract way) with a lot of concepts to start programming in java. The way to start programming in any language depends on your prior knowledge and the best way how you learn things. What works for me is the following: Do you know any programming language already? If yes, pick a (relatively) simple open source project in java and look at it, modify it a bit, if you find something you don't understand, try to look up what it means and understand it. For this approach it's pretty essential to have a IDE in which you can debug and compile easily, for minimizing the "feedback-loop"-time. This means if you don't know a IDE already, you need to figure it out first with a few simple programs (like Hello World) first. It's basically the [socratic method](https://en.wikipedia.org/wiki/Socratic_method) with yourself when you program or try to understand anything. Just a simple example: 1: public class TestProgram { 2: public static void main(String[] args) { 3: System.out.println("Hello World!"); 4: } 5: } You basically go line by line and ask yourself what each line does. 1. public class -&gt; What is that? -&gt; Class-Declaration - What is a Class? - Why do I need to have a class? - Why is it named that way? - Why is it public? 2. What is that -&gt; Method-Declaration - Why do I need that, why is it named main? - What's this "String[] args"? - What does static do (public should be clear from the research for 1) 3. What is "System.out.println" -&gt; System? out? println? - What is "Hello World!"? And so on - there'll be a ton of questions at the beginning, but when you start to answer them for yourself, it'll quickly get less and less. The detail to which you answer them should be (in the beginning) enough so it makes sense to you, but over time, I highly recommend going deeper and deeper. At least this is the way I learn new programming languages best. Your mileage may vary.
Java is pretty easy, but if this was your first programming class you probably didn't struggle with Java, your probably struggled with learning how to program which is harder. You have to learn how to think about problems in a certain way. Once you learn to program, java will be pretty easy, along with some other easy to pick up languages like python. Are you trying to complete the entire major online? What school if you don't mind me asking? The early CS courses set you up for everything you learn later, I'd think they are usually better taken in person, but a lot that will depend on how you learn best, and how well the professor teaches. My first programming class was in java, but was taught by a great teacher who explained the concepts in lecture, the concepts that apply to many programming languages. Mostly just the homework was really java specific. I'm concerned about the quality of the program if the professor didn't lecture. At that point you could save a lot of money by just buying the book yourself no?
Thanks for the tips. as for your questions, I took it at Mesa CC (in AZ). My major is not online, I took that class online because Mesa CC was pretty far from my house. The professor was crappy tbh, he got only 2 out of 5 stars on ratemyprofessors. I didn't know much about him but pretty much all the review said was that he gave no instruction and his tests were very challenging. he gave no lecture/Powerpoint slides at all and I had to read the entire book. Actually I don't really blame him on why I dropped the class. It could be because I didn't have any prior knowledge, nor I understood the concept of programming before I took java, or I didn't read the book carefully :| and yeah I think you're right, taking it in person is better, much better. Even though I heard that java can be self-taught, but for me interacting with classmates and professors give me better motivation to learn.
Thanks. My first question when I saw this was "why"?
Yep. That's what I recommended at the end of the text :)
You have been working at two fronts simultaneously. You had/have to learn *a programming language* (Java) and *programming*. Learning the programming language as such is actually the easy part because the language is only vocabulary and grammar. Learning to program is the difficult part, pretty much like writing a novel in a new spoken language. With good resources, Java is an easy language to learn. The main upsides of Java are that it is very verbose, explicit, and statically typed. Someone called Java a "boring language" in another thread and I can understand why. Once you know how Java works, there are very few surprises. Try using the MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki as a learning resource. It is free, text based, very comprehensive, and has graded exercises, and it does not assume any previous knowledge or programming experience.
&gt; came out with Java EE which mostly copied Spring Mvc based on this statement, i get the impression you have more to learn about the subject area.
This was enlightening, to say the least. My perception of the multi-threading landscape is still hazy. I didn't know that the remove() method in Iterator is the safest way to ensure data integrity and proper iteration in a multi-threaded or simultaneous access environment. However, I knew there had to be a reason why the developers would take the pain to implement this method. I had imagined the same scenario, but I interpreted it the other way around. That's why I am not designing my implementations to be thread-safe. I say that in the JavaDoc multiple times. If people need thread-safe implementations, I'd recommend them to use the default classes in java.util. There is one thing I do for array-based Collection implementations that makes sure iteration isn't affected even after the Collection is modified: I copy the elements to a separate array and send to my ArrayIterator. It doesn't seem to be a major performance hit. Not quite sure what to do with implementations backed by custom Linked Lists, though.
Yeah, it it super buggy. I don't even know what's happening when I click on different tags.
Yeah, he does only love C, but he's damn smart about it. My approach is that programming is a skill in and of itself, knowing a language is the insignificant part. I mean of course there are exceptions, if you drop the best Java programmer in the world on an island where everything is written in Haskell they'll probably get lost. But the goal is to teach people to quickly understand and incorporate concepts instead of focusing on mastering the nuances of a single language.
That is called brute forcing or in a poor encryption a collision attack. This is the equivalent if you picklock a door (might be better compared as drilling the keyhole) or open it with a key.
We are teaching 7-8th graders Java with fundamental concepts of programming and 10-11th graders Java without prior programming knowledge. It can be a bit daunting since it can require the interaction with an IDE for the first time in their life and if you need to do the setup yourself for the first time, it can be pretty intimidating, but that is with every programming language and not especially specific to Java. If you go to university you need to adept yourself to the speed they are teaching you. It can raise very quickly in a very short amount of time since a lot of knowledge has to be covered in a short period of time. That being said, having C/C++ would be a lot harder for somebody without programming knowledge since you would need to know how memory works to understand pointer arithmetrics. In Germany Java is generally the first language you ever encounter in university, so no prior programming classes. Nowadays with the Internet you can self-teach anything in a short amount of time if it is required.
The first image in the article of the wax looks like a bloody penis 
I think you would benefit from working on some fundamental programming problems. Look for a few websites. I've had luck with hackerrank. It takes some time to get up to speed with Java's built in data structures, but they're very useful and not exclusive to Java (they can be found for the most part in every language or you can write your own). For example, how would you use a map to count the occurrences of each word in a txt document? Or, if you don't use a map, what's your approach to solving a problem like that? It took spending some time with C and then coming back to Java before I really appreciated and realized how easy Java was.
Isn't that what @Theories is for? @RunWith(Theories.class) public class StanfordBinetIntelligenceTest { @DataPoints public static Pair&lt;StanfordBinetIntelligence, int[]&gt;[] data() { return Stream.of( Pair.of(StanfordBinetIntelligence.VERY_GIFTED, new int[] { 145, 150, 160 }) // … etc. add whatever other test cases (data points) you want here … ).toArray(Pair[]::new); } @Theory public void forIQShouldReturnCorrectLevel(Pair&lt;StanfordBinetIntelligence, int[]&gt; data) { Arrays.stream(data.getRight()) .forEach(iq -&gt; { final StanfordBinetIntelligence observed = StanfordBinetIntelligence.forIQ(iq); Assert.assertEquals( "Failed test for IQ "+iq+": ", data.getLeft(), observed); }); } } Though if I were writing these tests myself instead of just picking a few examples in int[]s I'd cover every value in a range using Range&lt;Integer&gt;; a few hundred iterations is nothing for a computer, even in a frequently-run unit test. I find it odd to write an article complaining about inefficiencies in the expressiveness of an ancient variant of that same system; compare to the best it offers. Now, if you prefer Spock, carry on and use Spock! But junit does have better capabilities on offer than were described there.
Well said Techkeguruji 
It's always amusing when I click the link without checking the subreddit and because of the horrid color schemes and ridiculous predicaments I think for a second I'm in /r/programmerhumor or /r/shittyprogramming.
Websphere is the problem, Not java EE. Try using Apache Tomee. Much more lightweight, but keeps the JavaEE api.
Your test case sample is invalid, JUNIT has had the ability to test using parameterized for awhile https://www.mkyong.com/unittest/junit-4-tutorial-6-parameterized-test/
Hahahaha. Oh brother. 
Java 8 added `Collection.removeIf(Predicate)`, but prior to that, a reasonable workaround was to use `Iterator.remove()`. E.g. ro remove all nulls from a collection. Java 8: collection.removeIf(Objects::isNull); Before: Iterator&lt;E&gt; it = collection.iterator(); while (it.hasNext()) if (it.next() == null) it.remove(); Note that the above is also the default implementation of `Collection.removeIf()`, so to answer your question: Yes, you should probably implement this method if you want your collection to be mutable. [(OK, I had to write this down in a blog post)](https://blog.jooq.org/2017/02/17/should-i-implement-the-arcane-iterator-remove-method-yes-you-probably-should/)
If you'd drop the Java dev on Haskell island he'd probably be able to deduce whats going on little by little. On the other hand if you'd drop a Haskeller on Java, he'd complain all day that it is not Haskell. (Then he'd starve, because he has no job)
Do note that in many cases, you can also just extend `AbstractList`, which implements quite a few methods with sensible defaults.
So basically, removing elements while iterating over a Collection is a bad idea if we don't use the remove() method in the Iterator. Right? This has seriously opened my eyes. I need to address these cases I've never thought of before. I guess that's a part of learning.
Basically you're saying "it's a lot more work to write a remove method than to not write one so I don't think it should be allowed". But I'd say that: - In real coding you're effectively never reimplementing collections, you use the built in ones that are extensively tested already. - While it is more complex to write remove, it is possible to write it with no bugs or errors. I prefer to have it there, though admittedly I don't use it a lot. My opinion could be different if you needed to implement remove constantly, but it's not something you usually need to implement yourself.
Based on this low effort, non-illustrative statement, I get the impression you're just fanboying frameworks that I'm saying aren't used very often in real use.
I am pleased to hear that there will be a revised (third edition) of Effective Java. 
Specifically on co- and contravariance: - [Brian Beckman and Erik Meijer](https://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/) - [Brian Beckman - Covariance and Contravariance in Physics](https://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Brian-Beckman-Covariance-and-Contravariance-in-Physics-1-of-1)
If the functions of A are virtual, then yes the methods will resolve to C. In Java all functions are virtual, so the short answer is yes.
Thanks. I'll continue with Java EE for now and have a look at Srping at a later time. Since some concepts applies to both and that as of today, most app I do support are Java EE, I think it's still valuable knowledge. As for Angular, or any JS framework, they are a bit down the list to be honest. I prefer to focus on backend technologies for now (Database, Messasing, and such). Thanks for your input.
Hum.. Was curious... is there any known issue / limitation of using Java EE with Kotlin (that you are aware of...) ? 
It depends on the crowd that you're around. Most crowds I'm around seem like they're not aware that there's anything but Spring. I prefer Java EE's spec implementations over Spring, but both tools essentially can get the same jobs done. If Java EE doesn't have a spec implementation, such as the equivalent to Spring LDAP, then there's most likely an API out there that will fill that void. In the aforementioned case of LDAP, there's the Apache LDAP API, which is great and works within any Java EE container. The industry trend is microservices. Whether the community likes it or not or thinks its a repackaging of a previous idea, Spring has Spring Boot, and Java EE has several of its own implementations. I prefer KumuluzEE.
Java is an exceptional language to start with. Watch Java Brains on YouTube for great tutorials. I am a professional with 5 years experience and I use this channel on a daily basis. The presenter makes complex concepts seem simple and easy.
Exactly. The only way to remove elements from a collection based on the elements' properties is to do it while iterating, through an iterator. Or with filter() in the new stream api, but that internally does the same thing by default. I'm curious. What type of collection are you implementing? Is it for educational purposes, or are you solving some problem? 
Java brains on YouTube. 
Java brains on YouTube 
http://www.techkeguruji.com/p/blog-page.html It says on the link here that the owner of this site wants to work for Google. I'd say he'll have some tough luck with that without knowing to use their Search Engine first.
&gt; I believe that Iterators should not be allowed to change the Collection I mostly agree, iteration is the process of going throu all the element of a collection and nothing more. I'm pretty sure the reason they added "remove()" was to solve the "remove all elements of a collection that satisfy a condition" use case, which otherwise would require much more code (you cannot simply call list.remove(), as it will throw ConcurrentModificationException, so you 'd need to copy the collection somewere else). I'm pretty sure that, it they rewrote the Collection Framework today, they would leave it out. Btw today we have removeIf() that is that exact use case but much more concise.
I had prior c/c++ knowledge from previous courses and java felt like it was super easy. If you haven't grasped the concept of OO it might be a lot more diffcult 
Please address such questions in either /r/javahelp or in /r/learnjava.
[Previous post and discussion](https://www.reddit.com/r/programming/comments/5tl7u1/spacevim_use_vim_as_a_java_ide/?st=IZ47TRED&amp;sh=c85b279e)
This subreddit is for **Java**, not for Java**Script**. If you can't distinguish between those two languages, you are not qualified as programmer.
Object methods are virtual by default, but you can make them non-virtual by declaring them as `final`.
What i tell people when they have to choose between java ee and spring boot with an angular front end. I ask if they have the hardware to support its user base, what i mean is do you have the servers to generate the pages server side? if the answer is yes then always go Java EE. Its a better experience for the user, especially if they are on a slow connection
If it were me I'd write logs to the filesystem as a backup but send my logs to Kafka and then have Graylog pick them up from there. I work with a high volume of logs, though, so in your case sending directly to Graylog may work perfectly.
I'd definitely go for ElasticSearch. It's easy to use and building your own search engine is not the most efficient use of your time :)
I'm genuinely curious why anyone would want to spend the time configuring Vim to be like an IDE instead of installing a Vim plugin into an existing IDE. I use Vrapper in Eclipse or IdeaVim in IntelliJ IDEA. I have all the functionality of an IDE and text editing capabilities of Vim without spending a significant time with configurations.
vim looks cool
It would be cool if you linked the class/source file the paper was cited in as well
Kafka is still version 0.x for some reason, yet that's in use in production all over the place. Version numbers aren't always that accurate.
JCodec. Literally the ONLY available Java library in existence which implements a pure h.264 decoder 
Arguably, if implementing iterator.remove is difficult or inefficient for your collection type, then don't. This puts the onus on the caller to find an alternative approach that is optimal for their use case. To put it another way, if you implement it, then callers will quite reasonably assume that your implementation is efficient. &gt; I currently have it implement the iterator() method by copying the current elements onto a separate array (thereby creating an effective snapshot of the data) and send it off to a custom ArrayIterator. Is this good practice? This does not sound efficient therefore I would say no. A caller can always do the copying themselves (and for example filter out rows that would otherwise be removed). This would be no less efficient that your iterator.remove implementation, and it's possible the caller may be able to further optimise based on their exact requirements.
Sorry for uploading this in java but I have already uploaded in javahelp but I haven't gotten any answer yet
There is most likely some non daemon threads still running. Maybe you need to close a data source or connection pool? Something along those lines.
Older video but still highlights CompletableFuture very well. Also shows some of the pitfalls of the default async methods that dispatch to the common pool :(
your scope of though is quite limited here, imagine having a voice chat up and being able to work on a project, its essentially what programmers have to do all the damn time, but much easier because they don't have to manually copy changes or work one at a time
 class A {} class B extends A{} class C extends B{} interface D { ? bar(?); } class E { B b; B foo(D d) { return d.bar(b); } } Think about the return/parameter types method "bar" can have and still work as a parameter to "foo". B bar(B b) // Ok // Return A bar(B b) // Not ok (A is not a B) C bar(B b) // Ok (C is a B) // Param B bar(A a) // Ok (methods that expect A can treat B as A) B bar(C c) // Not ok (methods that expect C can't treat B as C) The return type is covriant, while the parameter type is contravariant.
Looks pretty nice and I like the fact that they support various combinations of development environments (e.g. vim -&gt; IntelliJ), but putting my code on a 3rd party server is a non-starter for me. Their Floobits Enterprise offering seems nice, but $100/user is pretty high.
This is a work in progress for Eclipse Che, and is expected to drop sometime this year. https://github.com/eclipse/che/pull/2131
This would actually be nice for remote code reviews.
Why would you want it though, for work, for a serious project? I can see it being useful for something like an interview, or a quick help from a fellow programmer, but other than that ... why???
https://en.wikipedia.org/wiki/Pair_programming
You think I was born yesterday? This is not pair programming. Actually, even the wikipedia article says so: &gt; Pair programming is an agile software development technique in which two programmers work together at one workstation Edit: This is pair programming https://www.youtube.com/watch?v=dYBjVTMUQY0
thanks for your comment. in a high volume case, is there a potential problem sending directly to Graylog?
If it's just java, you could use IntelliJ Community Edition. It's free. And if I remember correctly, you could also use your private IntelliJ licence at work... At least that's how I did it. In the end my workplace even bought a licence, because they figured out I was much quicker with IDEA.
There is an early access preview of Intellij ultimate for free. Might not be that stable, but you don't pay a nickel. Some people at my team use it and are happy. https://confluence.jetbrains.com/display/IDEADEV/EAP
Just remember that if you don't implement remove in your Iterator, mention it in your class's documentation.
This is basically my nightmare.
I think this as a sort of preview + normal version control would be really nice. 
&gt;Maybe I should write it myself? Well, that depends on how willing you are to commit yourself. If honestly you think you don't want unnecessary headaches, I'd say you reuse the resources available to you.
How about: training, pair programming. The alternative is sharing a desk and swapping in and out to be in front of the keyboard and mouse, which is far less convenient.
Exactly, why limit yourself to waiting to 'git update' to see what someone else broke? 
Isn't a screen sharing tool that one can hand control to the other person watching enough? Zoom Conference, WebEx, and many others out there... Seriously... 
Note that the author of this article has exaggerated the warning by the National Institutes of Standards and Technologies (NIST) in [section 5.1.3.2.](https://pages.nist.gov/800-63-3/sp800-63b.html#sec5) of the DRAFT NIST Digital Identity Guidelines. It does **NOT** say: "Out-of-band authentication using the PSTN (SMS or voice) is **deprecated** and is being considered for removal in future editions of this guideline." Instead it says: "Note: Out-of-band authentication using the PSTN (SMS or voice) is **discouraged** and is being considered for removal in future editions of this guideline." There is a difference between the words deprecated and discouraged. 
Its not hard reading if you are new to Java either since if I remember right, it focuses on covering those fancy array sorting algorithms and other things like that.
**Here's a sneak peek of [/r/AskProgramming](https://np.reddit.com/r/AskProgramming) using the [top posts](https://np.reddit.com/r/AskProgramming/top/?sort=top&amp;t=year) of the year!** \#1: [Do you meditate? Does it affect your coding skills?](https://np.reddit.com/r/AskProgramming/comments/5cpryq/do_you_meditate_does_it_affect_your_coding_skills/) \#2: [Am I crazy for believing we should form a trade union or guild?](https://np.reddit.com/r/AskProgramming/comments/5hqkw5/am_i_crazy_for_believing_we_should_form_a_trade/) \#3: [What's your "programming pet peeve"?](https://np.reddit.com/r/AskProgramming/comments/5gboah/whats_your_programming_pet_peeve/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
You got me there...
Screen sharing with voice and video chat already does more than enough for this task. The task of a developer is usually very focused, getting code from state to state in the process of completing a task. Then debugging, testing, checking these incremental changes in isolation. How that can be achieved while one or more people are making, or potentially making, unknown edits to the same environment sounds nightmarish. 
I've used ScreenHero many times for pairing with other developers and think it's the best solution out there currently.
 The following threads had a state of runnable: RMI TCP Connection(3) 192.168.1.64; RMI TCP Connectio(2)-192.168.1.64, RMI TCP Accept-0; DestroyJavaVM; Attach Listener; Signal Dispatcher
~~When does Lombok create these dynamically generated getters, setters, etc?~~ ~~Also, I'm a bit wary about a framework manipulating my code behind my back. Especially since reflection is known to be one of the slowest things in Java.~~ Never mind. Lombok is a separate compiler. I personally _really_ don't need another code generator in my life, though. (Well, unless it's the toy project I might be writing.)
I'd say certificates are pretty much worthless. Are you in the US? I usually just shuffle certificate heavy resumes off to the trash. They prove you can pass a test not that you actually know how to program which makes them worthless. 
Use a vcs like git,svn, mercurial and have your dad commit the changes. At the same time have your dad recording his IDE with any screencapture tool like OBS, nvidia shadowplay or any other free recording software. This way you can look at it even several times and not only once
&gt; Lombok is a separate compiler. No, it isn't. Lombok is an *annotation processor*. It just uses annotations to generate the code. You could call it a *preprocessor*, but it is not a separate compiler.
No, I'm looking on to something how to use or not use eclipse as a code editor. Not the specific features it have, but how to use it all together. Imagine, an eclipse developer who would implement those features of eclipse, imagine he or she uses eclipse themselves, how do they use it, what is they workflow, do they find it comfortable. Basically, I already described it in the initial post, but I'll repeat. In intellij it was all tremendously increasing my code writing/editing speed. In eclipse it's all just off. Yes, similar features are there, but when used as a whole they more hinder me. Like caret positiones itself in the wrong place, some features were not exactly how I would expected them to work. So it's actually more of a wrestling with those things that suppose to help you. So that's why I'm asking is there a handbook , how to use eclipse as a code editor, maybe how to tweak those nice features so they would actually help, rather than distract and make you wish they were not there.
But he wants to watch him learn! This would be useful for projects but he's looking for something that would allow him to see what his dad is writing in real-time. 
And it could easily become obsolet if the corresponding JEP will hopefully get implemented... best would be ASAP ☺
No exaggeration intended. At the time I wrote the article, the word was "deprecated". I've updated my post to reflect the current wording. Thanks for pointing it out.
CollabEdit (actually used for a lot of programming interviews as well) - http://collabedit.com/. Supports Java and a bunch of other languages. EDIT: Not a full-fledged IDE though, more like a tool to collaborate on code in realtime.
I like this. Not something that would be useful for webserving....BUT, something very useful for real time processing, driving timing sensitive interfaces. +1 
I guess the NIST document is still undergoing changes because it is a draft. Nice article by the way. Thanks for posting it.
Couldn't agree more with this. Getting a certificate obviously won't make you any dumber, and you will likely learn a couple of nice and even useful things, but "certificates being highly valued" is simply not something that is true in the real world. Highly valued is relevant work experience, or lacking that a nice GitHub portfolio where you show contributions to **other** people's/organisations' projects. 
I agree, screen hero is great and works a treat, use it for pair programming, helping out etc etc.
Yes, I can. But I want to know how to change it for it to be useful. Like some guide done by someone who actually changed it and then found an improvement. 
Why is everything that passes around lambdas called "declarative", these days? We used to send `new ActionListener() { ... }` anonymous classes to Swing for ages and didn't call those suckers "declarative". As far as I'm concerned, if you're not a 4GL, stop pretending you are.
I have long resisted but I will be using Lombok on my next project. The only annotation I might use from this article is @nonnull. I mainly want it for the @getter @setter and @Data. I do not understand why this is not built into Java. It is a simple thing that removes tons of useless boilerplate code and improves readability.
I feel the element of surprise keeps developers on their toes... In all honesty, Iterator.remove just feels wrong. Using a separate ModifiableIterator interface for the few collections which support *modifying a collection while you're iterating through it* would be a far less deranged approach.
I'm sure resources to help with Eclipse configuration exist. There are definitely guides for hotkeys. Probably just need to do some googling.
Well, it's not only about configuration, it's also about way of working, what to use, how to use it. Anyway, thanks, you're right, I hope that along the way I'll be able to find my way in it. Like what and when to use.
Neat. So...is there supposed to be a question in here somewhere?
I was playing with this awhile ago. You can strip it away as you may see fit. Purely Java that can be accessed through a Spring Controller or Rest API. http://codereview.stackexchange.com/questions/133192/search-files-from-large-directory-and-sub-directories/133198#133198
My team was using Floobits for a few months while pairing but have moved to Screenhero instead. The former was great when it worked but really held up development when things regularly got out of sync and needed to be deleted and set up again. Screenhero on the other hand won't have everything you want but works great and in a good connection is not far off having two (or more) people working at the same workstation. 
He browses reddit /u/shipilev
Of course I've seen it -- in fact, I think Gleb (the author of that tutorial) and me were hacking that thing five years ago on a train from some conference. But the difference between "let's stub out `CollectedHeap::collect` to immediately return", and "let's not do anything at all" is humongous. Including, but not limited to, avoiding native collector data structures, spinning up GC threads, emitting GC barriers, etc.
Have you considered elasticsearch instead of using lucene directly?
I do not have to worry about any of that since I use Netbeans but thanks for the heads up.
This would have quite the niche uses as you need to take care not to allocate and throw away short-lived objects, because then your app will crash, guaranteed. A far more useful, and not at all complicated implementation would be reference counting with deferred object destruction (so spikes can be spread out). This would both provide a method for writing Java apps with real-time needs, and free memory just fine, with the exception of cycles, which are easier to avoid than what this "non-GC" GC would require. So... why doesn't Java have ref. counting mode?
Logging: No Lazy Loading: Hibernate Synchronized: I'm using Java synchronized or I am using something more appropriate to that particular situation Null Checks: There are plenty of better or equally as good already widely used options. AND that assumes I want to use an annotation for this anyway (outside of hibernate mappings) val: NO @SneakyThrows: NO @ExtenstionMethod: NO Utility Class Constructors: "Talking about utility classes… An important thing to remember about them is that we need to communicate that this class should not be instantiated. A common way to do this is to create a private constructor that throws an exception (in case somebody is using reflection to invoke it):" http://stackoverflow.com/questions/309553/should-helper-utility-classes-be-abstract "You could just declare a private constructor that does nothing." Seems just as reasonable to me. This one I don't have a problem with. Maybe the exception could be useful, but I believe this additional functionality to be too trivial warrant an annotation. It would basically be the functionality of a static top level class could you create one in java though. OP says, "This constructor is distracting and cumbersome. Fortunately, Lombok has an annotation that generates it for us:" Do yourself a favor and learn how to collapse methods in your IDE. Annotations are distracting and cumbersome. Unless their entire functionality is explicitly in their name or they are so common place that everyone knows what they mean. Even then the sheer number of them should be kept to an absolute minimum so that they can be treated with the appropriate reverence. Flexible @Accessors: HELL NO. Why am learning new keywords for basic functionality? Field Defaults: ...
This would have been an awesome proposal to post on April 1st! Just sayin'.
The Disruptor framework doesn't work in near-garbage-free mode, it just has a few central structures, which do work in garbage-free mode, but all your code won't be just using these message passing / context switching structures. For all objects you create from the standard library and various third party packages, and including your own code, GC is business as usual with Disruptor, because it's not a runtime, it can't possibly affect how objects fundamentally work in Java.
😈
Eclipse also has http://wiki.eclipse.org/ECF/DocShare_Plugin
I think they should use "const" which is reserved (but unused) keyword in Java...
why not?
This is a very comprehensive view of JMX as of now 2017. In my opinion JMX is indeed very powerful but still does not allow you to really get into the hard parts of the running JVM. For that you need a console that lets you communicate with the JVM in a REPL fashion. I heard java 9 will have that. https://blogs.oracle.com/java/jshell-and-repl-in-java-9 In the meantime, I am for https://lorenzoongithub.github.io/nudge4j/ You can do anything that you would do with JMX and more. (that would be for an article like "all things you can do without JMX")
Would a GC that does not do memory reclamation still be a GC?
Not OP but I don't think that the `showXDialog` methods that return an `int` are the most intuitive. A better option might be to return the selected `File` or null/optional. Another option might be to use callbacks for the success/cancel options. As far as setup of a JFileChooser goes I'd prefer a builder pattern.
now that you point it out... the JFileChooser really is terrible xD never really thought about it
I agree Calendar and GregorianCalendar. I mean, GregorianCalendar has just got the worst name ever. 
These article is additional Lombak annotations that are probably not used as much. It is not suprising that you or most people would not have a need for them since they are a bit more nich. The more popular Lombak annotations are probably more useful.
This is long overdue. I hope it truely is a simple solution. Going through evaluating different security models now and it is no fun. Looking at JAAS, JASPIC and Spring but they all seem to have annoying little issues. Probably will settle with JASPIC since it seems the most intiutive and not overly burdonsome.
After using Rails in Ruby, it's amazing how bad the Calendar still is.
java.awt.list. for a very obvious and painful reason. i mean: wtf?
I will say another one myself: java.lang.Compiler I bet no-one knows what it really does and it's in a java.lang package 
Lafores
They could allow both for a while and slowly switch over as developers adopt. Kind of like what Apple did with Swift and Objective-C
Fuck Oracle
I have taken a look at elastic search and I am trying to get familiar with it. so far I have a U.I developed in vaadin( using spring boot) . and I need help indexing pdf files that will be later searched and opened by a user. 
Me too, thanks.
Isn't there also a bug in the file name filter that they won't fix?
You thought about posting another techbeacon link? What a surprise. Also: this is not about Java, at all. Try /r/programming. 
&gt; Go is faster Not enough to justify switch. And Java 10 will make things even better. &gt; and just nicer to write Lol. Hear that, Google? /u/konrain thinks that Go is "nicer to write", switch to it right this moment.
Sorry, but *entriely off-topic*. **Removed**
&gt; And Google reaped billions of dollars while leaving Oracle's Java business in tatters," Oracle's lawyers say in the brief obtained by The Register. Now that's just dumb. What stopped Oracle from creating it's own "Android"? 
I don't think either Solr or Elastic Search supports indexing PDFs directly (although I'd be happy to be corrected). What we do is extract the text using a PDF library (in our case, JPedal) and index that extracted text.
lol no generics
What are you specifically annoyed by? There are many features that I turn off in Eclipse because I prefer a simpler editor.
Kotlin gives you a glorious syntax plus access to all of Java's tooling. Java developers have no reason to complain anymore.
Oracle is the new Sun. No longer producing anything new or of real value in order to compete, but instead just suing everyone using their stuff.
Not a class but a classic in terms of bad design: https://docs.oracle.com/javase/7/docs/api/java/lang/Cloneable.html "There are a few design flaws, the biggest of which is that the Cloneable interface does not have a clone method" as Josh Bloch said in "Effective Java" and reiterated in this interview: http://www.artima.com/intv/bloch13.html See the book and the interview for a more detailed discussion of this quirky "interface".
Selling sun was a horrible, horrible idea.
&gt; C, and Go are as close to machine level as you can get Doesn't Go have a runtime though? It must if it's garbage collected. I would argue that Rust is closer to machine level than Go.
thanks I'll check it out 
Oh. What happened to common sense, reasoning and logic?
Religion?
Seems you can feed Elastic Search PDF files: https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest-attachment.html Elastic Search doesn't scan directories. You feed it documents over HTTP, which it then puts in its indexes. Your Spring Boot application will need to read the PDFs from the drive and push it to the Elastic Search server. I believe the same is true of Solr.
Difference in performance between Java and those languages is negligible. There are things other than performance, and C or Go can't provide that.
SimpleDateFormat also has this "feature".
What were they thinking? They did everything short of creating a browser instance, going to the other URL and reading the contents to see if they get the same page.
And with that, who would ever expect SimpleDateFormat to be not thread safe?
Did you manage to use it successfully for Java projects? Would you switch to it for your day to day work horse? Last I checked, Java wasn't their no one priority and required a dedicated VM to stub the missing parts
Actually it extends java.util.Vector. Remember, ArrayList and co. didn't exist until 1.2 so before then the JDK collections (Vector, Stack, Hashtable, etc.) were all synchronized. I have absolutely no idea why the decision to default to synchronized was made, but Java's commitment to backwards compatibility meant these classes couldn't be made "unsynchronized" to make them more performant.
You can't lose if you don't admit defeat.
- So, what do you want to do when you grow up? - I want to maintain getters and setters! 
Yeah, and in C :-)
Even IBM would have been a better steward than Oracle
Always with the IntelliJ crusading on this sub... If you don't want it don't import it in the first place. 
And why do you think so, if similarity is not what you have thought about?
And people not using their stuff
Sun had J2ME. At first, Oracle announced great things for J2ME. But J2ME was domed to fail (ie. the menus were horrible). Meanwhile, iOS was released on 2007. Android on 2008. The rest is history. 
I was trying to be subtle, but guess maybe too much... (note arm not intel, Java not Javascript...)
You say it yourself: Java**Script**. This subreddit is for **Java**. Java and Java**Script** are completely different languages that have as much in common as ham and hamster. /r/javascript is the proper place to post your question. **Post removed:** Java**Script**, not **Java**
Since this is help with Java **programming** is should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. **Post removed:** Programming help
No. Java is still used in tons of places and unless something incredibly ridiculous happens, that won't change any time soon.
URL.equals is blocking. You must be right. This has to be the worst. 
OK cool. I was curious because I have been learning online for the last cpl weeks and this post had me a tad worried I was wasting my time.
Depends. What do you already know and what will you do with it? As a java developer I would recommend python as a first language. The learning curve is smoother. Might also try javascript but parts of it deprecate faster then the milk in my fridge. What is important is not the language but the underlying concepts. Once you understand those getting into a new language is like getting in to a new car. Its different, but you are mostly getting used and fiddling with the radio.
&gt; Now that's just dumb. What stopped Oracle from creating it's own "Android"? I can't follow your train of thought here. Why would they be creating "their own Android"? Java already had a successful position in the mobile space (which it since lost), in many operating systems supporting mobile Java, and they are positioned as a "write once run anywhere" platform for servers, desktop, mobile and embedded. Oracle's position is that Google fragmented the Java ecosystem, and made it acceptable to violate their licensing program. Oracle isn't trying to say they wanted to make "its own Android".
That's the kind of nuanced and intelligent interpretation of events our community needs. Thank you for being the voice of reason.
Java ME couldn't compete with iOS, that's a fact. &gt; Oracle's position is that Google fragmented the Java ecosystem, and made it acceptable to violate their licensing program. Oracle isn't trying to say they wanted to make "its own Android". I'm not saying that Google are saints or something, but Java ME's death at mobile segment was a matter of time. 
Let me tell you how things work here on Reddit. You're supposed to believe Java is the best and most popular software platform in this world, that Java 9 and 10 are packed with innovative stuff that'll make it better, and believe in its bright future. Also any time Oracle is mentioned, you should turn into a raging lunatic screaming "Fuck Oracle!" and talking how they drove Java into the ground, and are producing absolutely nothing anymore, just suing people using 10 year old technology they bought from other companies. You're to wish Oracle was wiped off the face of Earth, and with it every single line of code they even wrote, because they're the personification of evil. You must hold these thoughts simultaneously in your head and believe in them both, strongly. There is no conflict here. There's only one truth. Long live Java and its creators. Fuck Oracle and all their software. Amen.
Where's the distinction between a programming language and a programming language encoded in annotations?
The problem many people have is that if you use a List in your code and try to generate the import using your IDEs shortcut for it, your IDE will ask you wheather you mean java.awt.list or java.util.list (and have awt at the first spot). This is an issue both when using IntelliJ and Eclipse (and presumably all other IDEs). Considering the market share IntelliJ has, it makes sense to give a short tip that you can disable this behaviour. Esp. when it seems to be such a huge hassle for many people. 
That speech is repeated at every Google IO since Java 7 was released. &gt; What kind of features are you looking for in a programming language for Android? What about 100% compatibility with the official Java, instead of cherry picking features?!
any class from javax.tools. They missed a great opportunity with that package. Picking one at random javax.tools.DiagnosticCollector&lt;S&gt; I mean, the signature of the methods make you cringe and this is the jdk. very sad. 
Vrapper in Eclipse compared against Vim/NeoVim it's like comparing a Ford Model-T against a Tesla. I'm using Vrapper, and I'm missing all the time the whole set of features that have Vim.
this is called content management, and is a solved problem. try https://www.alfresco.com/products/enterprise-content-management/community it's free, java spring based if you want to DIY, use Spring Boot and Solr
Why would you want to do manual memory management in Java? For a small piece of a larger application I get it, but turning off the GC for the whole app seems weird. Most of the libraries aren't built to run that way (there are functions in the standard library that create garbage). Programming languages that are actually designed to run without a garbage collector can clean up objects when an exception is thrown. If your application is short-lived enough that you just want a bump allocator, then you probably also want to avoid the JIT overhead, and should use an AOT compiler.
If you know C it's very easy to jump into Java and do the same things you can do in C. Although it may not be the same for the other direction, you can't say they have nothing in common. 
But you can write code this way. If your application is a number crunching one (strings are the prime source of garbage) and you use an off-heap messaging library for its input and output then you are in a loop working with arrays which you may be able to re-use. That'll be as garbage free as it gets. Consider a classic HFT application as an example. It receives arrays of prices and bids, perhaps hundreds per a ticket and spits out trade instructions or some price analysis stream. Also, all numbers. It will use virtually nothing from the standard library and you can fairly easy write it to be near-garbage-free. There is a lot of academic research into cooperative GCs, and Java is yet to get one. This is a step in that direction. A truly Cooperative GC will have two calls - one to perform after initial startup which would move anything alive at this moment to a "permanent generation" and another to be issued by application every so often to tell GC "I am back into initial state, you can wipe anything allocated since the initial state". A single-threaded batch-processing application can easily do this, it is back to the initial state after each batch.
Same in Eclipse—you just add a type filter in Preferences.
&gt; just suing people using 10 year old technology ..actually, java is 22 years old. ;)
Well, RedHat's Shenandoah is almost around the corner. And I, personally, think it is better than the pure reference-counting GC. It uses an extra word just like Azul's C4 and the barrier there only blocks someone accessing the variable while it being evacuated. Java Off-Heap memory structures started the same way - there were questions as to why would anyone use them. But a few years passed and they are the mainstream of performance-conscious frameworks. In my experience optimizing performance of JVM-based applicaitons GC rarely was the culprit. Most of the time "GC tuning" was simply removing whatever odd parameters where placed there before me, with ParallelGC in mind. Having a non-collecting-GC is beneficial at least because it will be a good way to measure the GC overhead on application's performance. At least as a way to demonstrate that performance optimization effort should be on the application code, not JVM runtime flags (which is most often the case).
Is he wrong? :) p.s. Fuck Oracle
They did early on. My point was that the reason they dwindled and died was because the spent the last 5 or more years of the existence doing nothing and just suing others.
Side note to people who didn't know, this shipped as part of Java 8 as the [java.time package](http://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html).
...which they fixed in `DateTimeFormatter` in the new Date/Time API.
&gt; You're supposed to believe Java is the best and most popular software platform in this world, that Java 9 and 10 are packed with innovative stuff that'll make it better, and believe in its bright future. That isn't how it works on Reddit. People complain about Java all the time on Reddit. I think it is the most hated programming language on here besides php. Everyone uses it though so it is useful. 
&gt; People complain about Java all the time on Reddit. I think it is the most hated programming language on here because php. People hate Java, because PHP? Not sure that follows, but ok...
When the module system is respected by IDEs, this might improve. java.awt is in the [java.desktop module](http://download.java.net/java/jdk9/docs/api/java.desktop-summary.html), so if you don't have a dependency on that, all those AWT and Swing classes will not be shown.
typo. I meant "besides php"
Java runs probably over 50% of the internet. C# is popular, but since it still has heavy ties to Microsoft /Windows (though that is changing) its not going to get the numbers of Java. Even for websites built in Php, Java is a popular mid tier. Just about every enterprise company, bank, financial company, tech company, etc. has Java developers. If you know Java + Javascript you are qualified for the vast majority of development jobs. Some areas rely on different technologies, like C/C++/VHDL/Verilog rule the embedded world. Python is great in scientific computing, and is big in Robotics (along with C++). If you go into more academic areas like AI you might see lisp, prolog, python, c++ or whatever language they decided to use. But Java is the backbone of most large scale serious development teams. Even if for some reason Java "dies" in the next decade (it wont) you can easily transfer skills from one language to another. And honestly if you are learning Java has more tutorials than any language out there. So if you program Java and then want to jump into C++ in a year or Python or lua or whatever you want, it will be an easy transition. Java will probably be in use in 2100 still, right along with Cobol. They will never die.
O'Reilly's Java 8 Lambdas is really good for getting familiar with what Java 8 has to offer and a decent intro to functional programming.
[removed]
If you become a programmer you'll end up learning multiple languages. Even if you eventually move to something else it won't be a waste of time. Java is a good one to have in your skill set. 
Ehhh your first statement would be true if you ignored CMSes, but let's be real, most of the internet runs on a mess of PHP.
Thanks, so far I really enjoy it. I've been learning from that Finnish Mooc.FI site that everyone suggests and it's been really informative. I am not sure I want to become a developer or anything. I just want to learn the language and play around with it right now. 
Fuck Oracle
I think Red Hat would have been the best. 
Someone should start a petition like [neveragain.tech](http://neveragain.tech). The signatories will pledge: &gt; If Oracle doesn't stop their malicious lawsuits, we won't use any Oracle products or any projects that depend on Oracle products 
If you make that into a t-shirt and sell it on the sidewalks of silicon valley, you'd make a fortune.
According to my housecleaner, yes.
If maintaining getters/setters is in any way a noticeable thing for you, you have significant issues that no library is going to solve
Nice find. You didn't include the rest of the quote though: "I hope to avoid getting dragged into the fray: they only picked one of my patents (RE38,104) to sue over." (RE38, 104)'s patent text is as follows: " hybrid compiler-interpreter comprising a compiler for "compiling" source program code, and an interpreter for interpreting the "compiled" code".... Well played, James Gosling.
This actually looks pretty good! It does what one should do when doing encryption with AES. Nice work! A few minor things to mention: - It's a shame it only accepts File and not Path when Path effectively replaced File so long ago. (and/or an InputStream, OutputStream - maybe some input/output builder would be nice?) - The decision to only take char-based passwords instead of byte keys is, again, a shame. We're encrypting with binary keys. - Your "narrowing conversion" of the password is wrong and can lose data. Just call `password.getBytes()` with UTF-8. - What happens when the password is of the wrong length for the encryption algorithm? I only read some of the code and did not run it as I'm on mobile, and I could not find the answer to this question. Does the library simply pass the wrong key and then throw when encryption throws, or are you trying some clever padding?
That JavaBeans™ brainwash from back when AWT was cool is still effective, eh?
Just because you wrote something with J2ME doesn't mean it would work on your desktop and vice versa for Java FX without an alt JVM.
java.lang.Object
Stream works on bytes. Reader/Writer works on Characters. This is more important than a lot of people give credit for, because in Java characters are all Unicode. This means that you can quite easily get characters that are multiple bytes, and you have to be concerned about encodings when reading and writing them. (A character would be encoded in UTF-32 as 4 bytes, and the same character could be anywhere between 1 and 6 bytes in UTF-8) Non-buffered versions of these will consume all of the data as it comes. Buffered ones will give you the ability to jump around to an extent - skipping forwards and backwards, and in the case of BufferedReader it will let you read until it finds a newline character. (Though not any other arbitrary character, which is annoying)
[Those parts, luckily, are obsolete "soon"](https://www.youtube.com/watch?v=oGll155-vuQ). Don't get me wrong. Lombok responds to real world needs and it delivers now, not in 2024. I appreciate that this is OK for some (many?) projects. But most of the features in the blog post like `@Slf4j`, `Getter`, `@Synchronized`, `@NonNull`, `val` (!), `@SneakyThrows`, `@ExtensionMethod`, `@UtilityClass`, ... They're creating a new language on top of Java. I really don't think that this will end well if more features are added to this library. That's just my opinion.
Hopefully. Most of these things should be language features. Saves me from having to write "WARNING: LOMBOK" disclaimers on my blog posts :D
plugins, visual block mode, config when use tabs over space for indent, autoident code with ggVG=, insert mode fast shortcuts like ^^ u or ^^ w, navigate file system when I do a :e foo/bar/[enter] , etc
more or less. According to the source it was https://www.linkedin.com/in/jeffdinkins/ I'd be interesting to hear what he thinks of it now.
Haven't we seen this exact post already this week?
I'd heard that it wasn't really Java they were after when buying Sun, it was the Solaris OS and the really juicy contracts with the government who was running on them.
I'll update the docs for this scenario. The password is padded up to the key length if it's not the right size.
I thought it was more like auto configuration + some other neat things on top.
[JTable](https://docs.oracle.com/javase/7/docs/api/javax/swing/JTable.html) and the [AbstractTableModel](https://docs.oracle.com/javase/7/docs/api/javax/swing/table/AbstractTableModel.html) with those amazing methods: public void fireTableRowsInserted(int firstRow, int lastRow) public void fireTableRowsUpdated(int firstRow, int lastRow) public void fireTableRowsDeleted(int firstRow, int lastRow) 
because it is the same from the technology point of view, but it is very different from the user point of view. When you think of the question: what web framework do you use? Do you have separate scenarios when you respond with Spring Boot and JHipster? I think most people would have a different mental model of what are they using, boot or jhipster.
Geeze. Everything on this list is either: 1. Spring MVC, 2. some generator or abstraction layer on top of Spring MVC (Boot, jHipster, Grails), 3. view-tier libraries that shouldn't be on a list of full stack frameworks at all (JSF, GWT, Vaadin), or 4. Struts, Dropwizard, and Play (more of a Scala framework) at the very bottom. Ultimately, the *real* list looks like this: 1. Spring (60%) 2. Java EE (30%) 3. Other (10%) But that would be to boring to blog about. 
If you did that you might make Oracle babies.
Where would you put my bastard stack of JSF/Spring on that list then? :P
Not really. Once you install it and get a project going, you're done with jHipster. From then on you're using Angular and Spring Boot. You will still be tied to those for the life of your project. 
Isn't it shady that I'll rely on external resources to provide me with the html and js that will send my code through to my JVM? Seems shady.
why shady ? The browser is the ultimate tool. Everybody has always one running. didn't you use the browser to reply just now :-) So, by making your JVM a webserver you can open a tab in the browser talk to it. It's the opposite of shady. It's to bring light to your JVM. 
Apologies; it was certainly not meant as an insult. Maybe 'your codebase' would be a better fit that 'you' in my previous comment
One of the developers started a React module, but it still requires a lot of work to make it production ready. https://github.com/hipster-labs/generator-jhipster-react
Why not just run main methods?
For that matter, there should be an explanation on Executors too as they're the main reason to use Futures in the first place.
And watch out for edu.emory Collections. Somehow I always accidentally auto-import their Collections backport.
Also how its a bad idea to use the common pool for blocking operations!
&gt; Play (more of a Scala framework) This is a common misconception. Play has a first class Java API that does everything the Scala API does: https://playframework.com/documentation/2.5.x/JavaHome
I have, in the past, relied on debugging, setting a known breakpoint and then running statements... This is pretty neat from a dev perspective -- I'd be terrified to have it productized though.
No, I got it. But even if there is a "first-class" Java API (a really controversial claim just a few years ago)... the reality on the ground is that nearly everyone I've even heard of using it is doing so with Scala. So even if it's a Java framework in theory, I'd still describe it as "more of a Scala framework" in practice. 
Clever use of Gosling statements, since you forgot the most important one. &gt; Just because Sun didn't have patent suits in our genetic code doesn't mean we didn't feel wronged. While I have differences with Oracle, in this case they are in the right. Google totally slimed Sun. We were all really disturbed, even Jonathan: he just decided to put on a happy face and tried to turn lemons into lemonade. https://www.cnet.com/news/java-creator-james-gosling-google-totally-slimed-sun/ 
It's truly not. Last time I looked at the numbers (downloads / users / projects etc), it was roughly 50 / 50. Source: on the Play team.
I think there are many more misrepresentations in this article. They count jHipster and spring boot and spring mvc separate, but you cannot use jhipster without spring boot, and you cannot use spring boot without spring mvc when you are building web app (oh ok theoretically you can, but nobody does that). According to this logic, servlets should be included and they should be most popular mvc technology since spring mvc ("and spring boot") runs on top of them. Many people (including me) use spring mvc (and automatically spring boot because spring configuration is a pain without it) for rest apis, so there should be jaxrs included in this ranking as well.
val works in IntelliJ now? It used to be "we'll never support _that_".
Never actually had this problem with IntelliJ.. Auto import handles it perfect every time.
**First:** wrong subreddit - this should be in /r/learnjava (as is indicated in the sidebar) **Second:** the **sidebar** in /r/learnjava has a section **Free Tutorials** that lists some excellent and in-depth tutorials. In particular, the MOOC [**Object Oriented Programming with Java**](http://mooc.fi/english.html) from the University of Helsinki goes very deep and has practical exercises that need to be completed before proceeding.
Looks like a pretty awesome library!
Not a class, but `java.util` naming resulting in everything being put into that package. Collections, Currency, EventListener, Calendar, Date, Formatters, Locales, Scanners, Iterators, etc.
at least someone already created this: http://bad.solutions -&gt; will go to Oracle website.
&gt; Play has a first class Java API that does everything the Scala API does: Except for one things; debugging into Play when you inevitably run into some bug. Btw, JRuby can also be used with Play, just because it's a JVM language, same as Kotlin. Scala is *the* premium first class language for Play. Maybe Java is important, but it's just not at the level of Scala which by definition will always be number 1 for Play.
What's the file size limit? (Assuming you're keeping it in memory during the encryption phase)
I really hated using Play because of it's Scala-ness. I'm sure the Play devs do everything they can to make java users feel at home, but you can't design a framework for one language and expect it to feel right for an entirely different language and ecosystem. It's like living in a different country where most people speak English—it's still a different culture.
Frankenstein's
They are usually complaining about the verbose syntax. Over time other languages have become popular due to programmers enjoying the syntax.
Kansas City Spring User Group now has their own channel. Video has moved there: https://www.youtube.com/watch?v=GuMabUFBFf8
Java is a boring language. It doesn't have the flair of younger languages like Rust, Go and C#. However, those programmers fail to realise that in an enterprise world, you _want_ your programming language to be as boring as possible. When you have a large number of developers with varying levels of skill, the last thing you want is a "cool" language where you can do syntax wizardry that makes it hard to tell what's going on.
I think you're looking for Web scraping. Edit: made a dumb statement.
And really, just how many minutes in a day do you spend because of the "verbose" syntax? Then compare how many hours/days you're saving while maintaining code because of the "verbose" syntax. Then realize that with IDEs, the "verbose" syntax may actually be *saving* you time while writing code!
Its not just that you have to type things once, its that whenever you makes changes you are forced to change a lot of code in order to deal with Java's obsession with forcing you to be explicit about *everything*. This not only takes a lot of time, it makes the structure of your code actively resist being changed, meaning you probably won't do it. You may have your (misguided) reasons for liking these things, but the rest of us would rather focus on more important things than telling the compiler what type that variable is 20 times, knowing that any half-decent compiler would be able to just infer it. That and Java has the worst generic type system ever invented. Edit: Good job Java fanboys, can't handle anyone criticizing your favorite language.
Would it be easier to port if they built it on something entirely new?
No I don't, I know very little scripting and have zero experience doing what you mention. I work in IT and I am fairly good at learning new things. I think this is over my head though. It would take me some time to wrap my head around this stuff. 
I haven't really used any other languages besides Java, but I can't even understand how it would work if java didn't have any "verbosity" to it. How would polymorphism work nearly as well? It's also a lot easier to learn a language that uses actual words rather than "std, cout", five different types of object operators, and other shenanigans. After all, programming languages are created for the explicit purpose of readability.
Date class, SimpleDateFormat class, etc. Ughhhhh.
That's very much not the experience I've had. Are you using Java 1.4?
works for me with ublock origin. main point is that Oracle's new stance is potentially ground shaking bc it sets a dangerous precedence. In the author's words it's akin to buying a house straight out. no mortgage, nothing. it's yours. you live in it... you're doing great then i decide to say the mortar that holds its all together, well that i didn't sell you. so that's the 2 second version so you don't need to fiddle with ad blockers. edit: although they do have that stupid "we use cookies" bullshit sticky footer so imo the f yourself is still pretty warranted
Back in the day, some c++ libs overused it, and the readability was a mess. Java decided not to support operator overloading as a result. Kotlin, scala and groovy which are JVM languages do support it though.
I just started Java a few days ago, and I already feel that c++ leaves a lot more options for the programmer. I honestly want c++ just because of the operator overloading and friend functions. Besides that, Java is great, but I wish you could code in c++ for android development.
Copy/pasta: &gt;Oracle has fired the latest round of shots in its ongoing war with Google over the source code of the Android operating system. &gt;Despite Google winning what seemed like the final-round last year after a judge ruled that its use of Java code was fair use, Oracle vowed to fight on and has accordingly filed papers that argue that the original trial failed to take into consideration certain aspects of the way the code from the Java system it inherited when it bought Sun Microsystems was being used and how it relates to its intellectual property. &gt;Oracles argument is that while Java is open source, it believes that the APIs it provides in order to interface the code with that of other programmers is subject to copyright and therefore the billions of dollars that Google has made from Android is partly theirs to the tune of $9bn. &gt;Google, along with the rest of the software industry, sees this as a somewhat ridiculous premise as it negates the whole point of open source software if it is then useless unless you pay someone a licence. &gt;Look at it this way, let's say bought you a house. No strings, no mortgage, I just buy you a house. &gt;But then months after you settled in, I tell you that mortar wasn't part of the deal and that you have to pay me thousands of pounds to keep living in the house because although you own everything from floor-to-ceiling otherwise, I'm going to evict you for stealing my mortar. &gt;Actually more accurately rather than evict you, I decide to start charging you rent for a house that you own. &gt;Now in the case of Oracle and Google, the mortar is probably affordable, but the issue at stake sets a precedent for the entire software industry right down to kids programming in their bedrooms. &gt;Because if Google is not allowed to use Java without paying a licence fee, then much smaller companies with shallower pockets will suffer the same fate. Not only could that stop successful software packages from working overnight, but could severely stifle innovation in the sector by making it unaffordable to start designing software. &gt;Both companies clearly see themselves as having a point to prove but in the case of Oracle it seems to be fuelled by a principle of greed. The platform the platform it inherited was always open source and it seems that Oracle has no vested interest beyond simply making a shed load more money. &gt;As such the consequences of its actions with repercussions so deep and this new precedent so ingrained at that point, it makes Oracles ongoing vendetta seem not only greedy but highly irresponsible. &gt;The danger is that whatever the ins and outs of the case, Oracle could very well change the software industry forever and not for the better. In short both parties really need their heads banging together because no matter who you believe is right or wrong in the situation there's no real winner here but potentially an awful lot of losers. &gt;Google has argued that there is almost no remains of the offending code left in Android today anyway, but Oracle's new case takes issue with the fact that Android has been expanded out beyond mobile phones, which were at the centre of the original case to things like televisions and automobiles. &gt;Oracle has even claimed that Android has destroyed Java as a viable platform in certain key markets and therefore it is entitled to compensation. &gt;The latest filing says, "The jury reached the wrong result because the district court repeatedly undermined Oracle's case, often directly contrary to this Court's prior opinion. The court reinforced Google's theme that Android was limited to the smartphone market where Java supposedly did not compete—and eliminated one of Oracle's central arguments—by precluding Oracle from showing all the markets where Android and Java overlapped. Android supersedes Java in markets Java occupied before Android—including TVs, cars, and wearables. But the district court barred all evidence of Google's competition in any market other than smartphones and tablets." &gt;Neither Oracle or Google has made a formal comment since the filing. &gt;What makes all this even more frustrating is that Oracle is recognised as having a terrible reputation for clear licensing with many companies falling foul of clauses in the past but Oracle's lawyers have lept on. Should the "fair use" decision be overturned it could pave the way for Oracle to launch legal action against everybody who has ever used the Java code and perhaps more worryingly it probably would. &gt;The whole spirit of open source is the ability for everyone to be able to create software collaboratively, and the only way to do this is to ensure that coders don't feel intimidated to innovate. When one bad apple shakes the tree to this extent there is a genuine risk of bringing the guiding principles that give joy to so many and employment to many more crashing down. &gt;But this time it goes beyond having badly written licences and loose scruples, and onto a point where a vague point of principle could make things worse for everyone and it's at that point we really have to question whether it's a price worth paying. I'm too lazy to read now anyway, but I have javascript disabled &amp; ublock on, yet had no issues.
Really, how often do you use friend functions? There's an occasional use here and there, but most things needing access to private data belong inside the class. I miss operator overloading every time I have to compare strings in Java, though. The whole thing of "someone might use this the wrong way, so we're going to limit readability everywhere" bothers me. On top of that, I never understood why operators are so special - people do stupid things in regular methods. Case in point, Java's `URL::equals` method, which is a blocking operation that works differently if you have an Internet connection.
How about for luolong?
I once worked on a codebase where operator overloading was in heavy use; I never want to go through that ever again
I think it's a good convention to not allow everything. An ideal tool for programmers should not have all features, it should have nothing more to remove. I think code with operator overloading is not readable. Think about large teams, think about open source projects; if Java had operator overloading we'd have to have a glossary for operators while wandering around an open source project. Because it's so tempting and exciting. For consistency and long term investment, boring is good. Code in a boring way.
&gt; Oracles argument is that while Java is open source, it believes that the APIs it provides in order to interface the code with that of other programmers is subject to copyright and therefore the billions of dollars that Google has made from Android is partly theirs to the tune of $9bn. One key point that's often overlooked here: OpenJDK is open source, but Google didn't use OpenJDK as their base. Instead, they used Apache Harmony, which is a cleanroom implementation of the Java Standard Library using a different license. Which is actually where a lot of Google's arguments come from; the only code in Android that was identical to the code in Oracle Java / OpenJDK were: * Method signatures, which by their nature must be identical. * Code which is generally simple to implement. Constructor chaining is a good example of this. To my understanding, the first of those is why Google won the previous trials.
Sure, just stop using any form of Java, including hardware devices that have it inside, like SIM cards, Ricoh/Xerox copiers, Cisco IP Phones, Bluray players.....
As always the possibility to abuse or missuse a language feature can't ultimately be prohibited by the language itself. Only knowledge, experience and learning can garantee a proper usage of a feature. Code reviews are a very good instrument for that!
Operator overloading is a horrible feature that makes code less readable and arguably slower. e.g.: a + b. In java we know what would happen but in C++ we can't possibly know what that code is actually doing because of operator overloading. Finding usage of this in the code (which is real "reading") is impossible since I can't grep a code for + and "find Usage" IDE integration is often flaky. In terms of performance this looks similar but often isn't. E.g. let's say I have a Vec3d object that I want to add. With a regular function I'd do: Vec3D add(Vec3D... vec) With operator overloading this would use the + sign which would be fine if I do: v1 + v2 But would incur an overhead of creating redundant vectors if I do: v1 + v2 + v3 If you don't understand why that is much slower than the ... then you might start seeing why this is a bad idea. 
Point noted I mainly used operator overloading for wrapper classes
&gt; you could code in c++ for android development. What is preventing you? https://developer.android.com/ndk/index.html Of course, if you just want a plain app instead of games, then it would be too much work, writing JNI wrappers.
I always preferred this (since 1993!) to printf and friends. &gt; cout&lt;&lt;"Hello"&lt;&lt;" "&lt;&lt;"World!"&lt;&lt;endl; 
Personally, I agree with most of the people here who are warning against operator overloading and advocating its omitting. Yes, it's powerful, but also very dangerous and so easy to exploit and misuse... In Java, we like things to be non-magical and as explicit as possible. And that's a good thing when you're working in a big team on a huge codebase. Explicit things are easier to read when you're not familiar with the code - you don't need to jump around to see what operator does what. Anyway, we're programmers and we can do whatever we want. So there's a library for operator overloading in Java: https://github.com/light/JOps Please don't drink and overload operators.
&gt; Please don't drink and overload operators. Will I be charged for OUI(Overloading under Influence) otherwise?
Your post was pretty much undistinguishable from a post made by a person who does not know the difference.
[citation needed]
What the hell is this corporate software doing that it doesn't run on OpenJDK?
AFAIK Kotlin and Groovy support it but only in a limited way (in contrast to C++ where you can overload stuff like `=` and `(`).
 &gt;because I've seen prison-worthy abominations more than once Like? 
Yeah, I'm actually enjoying it quite a lot - using view scoped web beans as controllers, with a bit of JSF magic on top to save me having to write any JS myself or use a crappy front end framework
thanks, i read your article find it very useful for my learning.
By the same logic we should prohibit methods because in, for example: a.plus(b) *we have no idea what it is doing, how horrible*, and because: c.plus(a.plus(b)) is inefficient.
Yes, kitchens should get rid of knives too because half-wits might stab themselves.
Yep, I think it may have been a technical limitiation works on more recent IntelliJ versions. (https://plugins.jetbrains.com/idea/plugin/6317-lombok-plugin)
The feedback loop on stabbing oneself does more to prevent recurrences than the feedback loop of poor choices when working as a developer
Java does have some operator overload: + can add ints, floats, longs, and also concatenates strings. There is no legal way for the programmer to have custom operator overload, neither defining new operator nor assigning the existing ones. Java creators thought it was a too easy too abuse feature. But I think it is more a cultural thing: in Scala they love abusing it, in the c# world is used with care and I found it nice. Maybe after value types we can have it too. Note there is at least one project [java-oo](https://amelentev.github.io/java-oo/) that gives you operator overloading today, but it is a smart hack, I am not aware of anybody using it in producing code
Ehh, this isn't /r/cscareerquestions (thank God)... but don't ever let an interview rejection stick with you longer than 24 hours. Every candidate is looking at 100 different companies, and every company is looking at 1,000 different candidates for each open req, and who knows what the real story is for those other 99 or 999? Sometimes there isn't really a req at all (i.e. HR or senior management thinks a group need more headcount, but the line manager or lead struggles to find enough legit work for the people he already has). Sometimes there is a req, but the person doing the initial tech screens doesn't want to let anyone through who might outwork or outshine him (i.e. "A's hire A's, B's hire C's"). Sometimes they just flat-out don't like you because of your appearance, your demeanor (you can even be "too nice"), the fact that you expressed an interest in Scala (i.e. you'll never be happy with the shop's conservative technical choices), or the fact that you didn't express *enough* interest (i.e. the interviewer is a bored wannabe-polyglot who's looking for more people to back him up). As someone who's spent a couple decades on both sides of the interview table, one thing I CAN say with certainty is that you'll rarely get a useful answer as to why you were rejected. A lot of times people will just throw out the first semi-plausible explanation that comes to mind, even if it wasn't really the reason. Even if you do get the real reason, it's rare that this information will guide you in a helpful way with your next interview at the next company. TL;DR - If an interviewer passed on you because you weren't familiar with a niche web framework, which only a single-digit percentage of shops are using and which they themselves aren't even using, then fuck 'em. Not worth sweating it. 
**Here's a sneak peek of [/r/cscareerquestions](https://np.reddit.com/r/cscareerquestions) using the [top posts](https://np.reddit.com/r/cscareerquestions/top/?sort=top&amp;t=year) of the year!** \#1: [No, Palantir. Your internships are not worth 5 months, 8 interviews, dozens of emails, a flight to New York, and a drive down to Palo Alto. Get over yourself before you drain the company of all its tech talent.](https://np.reddit.com/r/cscareerquestions/comments/5ncqti/no_palantir_your_internships_are_not_worth_5/) \#2: [For the love of god please stop Peeing in the talent pool!](https://np.reddit.com/r/cscareerquestions/comments/4xfkc7/for_the_love_of_god_please_stop_peeing_in_the/) \#3: [I don't want to be a rockstar coder. When 5PM hits, I want to go home, and not think of a single line of code. Is that too much to ask for?](https://np.reddit.com/r/cscareerquestions/comments/4xashc/i_dont_want_to_be_a_rockstar_coder_when_5pm_hits/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
No, fuck Iterator.remove(). The only way you should ever implement it is with UnsupportedOperationException
Does it work purely with Nashorn? The readme says it'll fallback to it, but will everything work or are there limitations? 
Or the real source of Oracles income, all the products its sells other than java. 
Something says Google would 
Ah well. The topics to learn are : ReST, Web Scraping and then Databases for storing the scraped data. 
Do you have a specific reason for this? It's a very useful operation when you have to filter items from a list, among other things. (And not everyone has access to Java 8+ yet.)
Author here. The lib includes v8 engines for windows, linux and mac. It tries to run on these and if it fails, it uses java's Nashorn engine. Nashorn is about an order of a magnitude slower, but everything should just work fine.
Again. Is your underlying collection mutable? Then you probably should. Otherwise, of course you shouldn't.
Yea that is the drawback of using J2V8. It depends on some platform specific jars. 
It seems operator overloading wasn't the issue, just ignorant and abusive programmers as always; don't blame the language. + is just short for 'add'. And if 'add' isn't clear enough, it doesn't matter whether you use + instead.
You do realize that the solution suggested in the article is just syntax sugar for iterator.remove(), right? https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#removeIf-java.util.function.Predicate- wait, were you being sarcastic? It's early in the morning for me. That might have gone over my head.
I agree. It has legitimate uses, but it's up to the author to not abuse it. I'd much rather that than no friend at all. Java has the same with reflection tbh. 
The problem is that when you see it for the first time, it's very surprising using bit shift operators for I/O. However, like all conventions, you get used to it quickly enough. The thing is that this convention doesn't really offer any major benefits. Just one more reason why many people want a proper streams replacement. 
Jealousy
1. It's very hard to implement efficiently, in ArrayList it can be an O(n) operation. How do you implement it in HashSet and TreeSet without screwing up the iteration order? 2. Used it thousands of times and not a single one of them have I ever passed an iterator intending for it to be modified.
The problem is that they should not have won on fair use, but rather won on "API's can't be copyrighted anyway". SCOTUS made a very tragic error in ruling that APIs are "copyrighted but fair use", and it has opened the door to this next round. As much as I want to Oracle to lose here, I want even more for APIs to not legally be considered "intellectual property" at all. Oracle might end up doing all of us a favor if they can be so obnoxious about this that the courts somehow realize that software needs to be legally much closer to mathematical algorithms or scientific data than to literary works. 
Plus you can get "friend" equivalent function using package private access and protected functions. It's sort of there, just hard to get to. If you know you need it, the extra hoops are trivial to justify.
That is the main reason I prefer Java. It is explicit and non-magical. I don't mind that it is also verbose because that verbosity makes it moderately self documenting. 
If you want some fancy Java magic you still can use a fuckton of frameworks. If you want some debug hell like in many of the newer Ianguages I can recommend using Java reflection.
As I said, find usage becomes flaky with every IDE I ever used when your project approaches the 1m LoC mark. Regardless find usage means you search from the method (operator) but if you are going the other way around it's not as trivial to find it or read it and even when you do get to it then it shows you lines with arithmetic symbols as results and it's harder to tell which are actual arithmetic, which ones are methods and if they are methods are they ones that are related to what we have defined. String + is true which is why we have a special case for it in Java which fits and doesn't require operator overloading. Special cases are totally fine. Notice that adding special cases also allows working around the inherent problems of operators, e.g. adding Strings was always slow as shit in Java and the best practice was to use StringBuffer then StringBuilder. Now plus is back in the game as the compiler became better. That's a good way to deliver optimizations at the compiler level that can't be done in a generic operator. Time duration is where I lose you though, there are a lot of complexities to adding time and the very definition of what time "is". I often use longs to represent time and in that case + works great but doing it with something like Date or one of the other abstractions is asking for trouble e.g. Date A has TimeZone X while Date B has TimeZone Y what would A + B do and which timezone will it have? I'm of the more conservative school that bears the scars of horrible C++ code where we just added all the stuff into the language and then had to live with that... We can disagree on that and that's fine. However, Java itself as a language chose the conservative route of throwing away everything that isn't essential so throwing away operator overloading is probably very smart for Java! I also get Scala adding it as it went in the opposite direction of adding stuff back. So the argument here is about why Java doesn't have them and in that case I think it makes a lot of sense with the spirit of Java as a more conservative (smaller) language.
What are you using to scrape for images? JSoup?
Indeed. C# got it right by NOT putting remove() in IEnumerator. As a "most general" metaphor for iterating collections, remove() breaks the separation of an abstraction and its efficient implementation. Filtering a Splay tree anyone? And if the underlying data structure is a linked-list-like thing, why would you not then use the more specific ListIterator?
Nah. I'm good. Thanks.
So any criticism of your pet language means I'm an "Internet troll"? I use Java due to necessity, and I subscribe to the sub to keep up-to-date with changes to the language and ecosystem. Unlike yourself I don't have stockholm syndrome and start defending a flawed language just because I am forced to use it. 
&gt; If you know C it's very easy to jump into Java and do the same things you can do in C First of all you can't do the same things, as there are no pointers in Java. Second you shouldn't do the same (*procedural*) programming style in Java - then you have a programm with java syntax but with weird semantics and abused practises. So I think you don't get more precise as you have no idea, where the similratities are lying - imho there aren't so much ;-)
As expected like most Java fanboys you have no idea what else is out there and yet you will fall on your sword to defend the only thing you know. 
Ofc. No problem. 
I am European and our software is multilingual. The thing is, it is modern GUI based software, where text cout plays no role.
that bad, huh? Should I change jobs? 
Hard to say... Explicit problems: 1. Java 6 is ancient and is not going to do much for your resume. 2. I suspect the version of WebSphere is ancient and probably has lots of legacy boogeyman in it. 3. You're a junior developer. Implicit potential problems: 1. You may be at an employer that doesn't really care about you, its tech stack, or how shit is done. Questions: 1. CS degree? 2. Location? If you have a CS degree and live in a tech hub (Boston, SF, NYC, Seattle, Austin, Charlotte) then I'd consider it but it's not a surefire "Yes". If you don't have a CS degree or don't live in a tech/industry hub then no. I'd grind it out for a year. You'll need to sharpen your tech stack on your own: learn Java 8, do outside of work shit, maybe pickup another language like Python or Go to broaden your horizons. Etc. Honestly the biggest problem you'll have is not advancing your resume in interesting ways. You can overcome that with external projects and natural curiosity. Working on a legacy project like that is also not the end of the world... if there is a good core of senior engineers around you then you have a chance to learn a lot and be mentored (hopefully they're good...). Being a young thirsty-to-succeed developer in an Enterprise *can* be a good thing. You can easily become a big fish in a small pond that gets to work on interesting stuff if the people around you recognize your talent. The big question is whether the company and mgmt is setup to get you that recognition when you do succeed. IMO: Grind it out for a year and reevaluate afterwards. Learn as much as you can both internally and externally. 
And it became a mess in many Scala ([eg](https://gist.github.com/folone/6089236)) libs aswell.
Yeah, it's much harder to cut yourself on a knife. On the other hand, you now have to shave using a knife instead of a razor.
True to some extent. Regardless, the by far most common and sane usage of goto (breaking out of nested loops) is implemented in Java anyway so it's not much of a loss. The problem is that Java does not have an equivalent "safe" way to use overloading that covers most of the use-cases (whatever that would be), which in turn often contributes to the verbosity that makes Java harder to read. For example, reading the same code which uses GMP in C++ and BigInteger in Java is almost physically painful. Is operator overloading abusable? Absolutely. Is it dangerous enough to not be included in the language? Debatable, but I personally miss overloading quite often in data classes.
Yea that's why I say easyish because it's kinda in the middle of the spectrum 
Only Java EE vendors are fighting and soon they will realize they are irrelevant in enterprise market. 
I know what you're saying. The environment is enjoyable for me too. But I fear that it might not be the best approach for this early a stage in my career... Thank you for the answer! 
Sorry I didn't know those subs exist. Should've looked better. Definitely gonna look into object oriented programing, thanks!
Oh shit it's a huge red box. How did I miss that... Fuck I feel stupid.
If you don't have access to Java 8 you might want to point out to whoever is stopping the upgrade that [Java 7 hit end-of-life 22 months ago...](https://www.infoq.com/news/2015/05/Oracle-Ends-Java-7Public-Updates).
All I'm reading here is "patents". If you create some novel shape that works perfectly for a case, and patent then both, then awesome job. If you create some novel way to make a wire and port, and patent it, awesome job (see USB). If you make some new type of screw and screwdriver, and patent it, awesome job.
That's not that bad! My company is YUI2 for GUI work and CVS for version control. We don't even put upgrade on the table until it's been deprecated a decade!
I hope you have a good security team ... 
Does every person in engineering have all passwords to switches and servers count?
No Apache Wicket?
&gt; One key point that's often overlooked here: OpenJDK is open source, but Google didn't use OpenJDK as their base. Instead, they used Apache Harmony, which is a cleanroom implementation of the Java Standard Library using a different license. &gt; &gt; Which is actually where a lot of Google's arguments come from; Wait. What if they used OpenJDK? AFAIK, it's licensed under GPL v2 anyway.
Bugs
Consider it a good experience instead, since you still studying this gives a good opportunity to get some real world experience. Once you get your degree you can always move on to another company and find a more "modern" stack :)
Nothing to do with Java. Down voted for being off topic. 
It doesn't really matter what technology you're using so much as what you're working on. Java is accepted almost anywhere and opens the door for functional jobs as well (on the JVM).
Operator overloading in general is not a good idea. I personally think you have to let the programmer do what he wants, but in general it obfuscates understanding and creates some domain specific knowledge. By obfuscating, I mean that it is easier to track back the implementation of a method than an implementation of an operator. By domain-specific knowledge I mean that unless you are implementing some new numeric scalar class, it does not perform the operation it was designed to do. Take adding string for example. Using + on strings doesn't perform addition, it performs concatenation. You shouldn't use the addition operator to do that IMO. Things like matrices can add additional ambiguation to this. How do you know if * multiplies the matrix cell-by-cell or if it performs actual matrix multiplication. How do you know what ^ does without looking into some documentation. Java-style code is usually very verbose, so overloading operators actually sacrifices some of that verbosity. There are multiple reasons you might not want operator overloading in Java. If you want the definitive answer, you have to ask Gosling.
I really haven't figured out why would anyone choose websphere, yet I see it used all the time. 
Anything with java is bad in this day and age
IBM is good at marketing to executives.
What are your OBJECTIVE reasons for saying that?
From what I could understand from my colleagues, it's chosen mostly because it's IBM, it's supported and is considered to be secure, whatever that means.
Bloated runtime, classpath hell, JVM is heavy, syntax obsolete
So, what are the alternatives you are proposing? Node?
Very simple​. No one gets fired for buying IBM, management loves to say. Never mind the hours of wasted time developers need to spend running and configuring and debugging their garbage. Imo, websphere is a steaming pile of shit that should have died a decade ago. But IBM knows how to sell shit. They don't care what developers think. They go directly to upper management and convince them that their turd is golden coloured. They're not the only company that does this. Oracle also along with others. I efn' hate them and their shitty products. 
Agree. Oracle database.. worst crap I'v ever installed. Doesn't even come with an uninstaller and uses Gigabytes of RAM without having added any database yet. I don't get why anyone would buy their products.
~~It will run, but certain parts of the OpenJDK are much less optimized leading to serious performance problems. I couldn't tell you which parts though.~~ edit: It appears the difference in performance is no longer the case.
That was *never* the case. OpenJDK uses the same JVM.