&gt; Today's Hibernate is tomorrow's JPA. But today's JPA Criteria API is tomorrow's Hibernate Criteria API.
My point is that Oracle, being evil and all, is unlikely to care what the JCP thinks.
The team have exams to tend to for now, so development will be put on hold for a while. STOMP should be pretty easy to implement, though I have not used it before and I'm not sure what the use-case would be compared to WebSockets
The whole discussion of the Jigsaw not being a OSGi replacement started still in the Sun days. The same people on the Java team that are leading the Jigsaw design were already on the team during the Sun days.
This isn't a design pattern. It's about simplicity and flexibility. You don't know everything up front; you never do. And once you have data people will want to 'do' stuff with it; relational stores give a ton more flexibility there. Choosing a NoSQL store because your problem is 'simple' is completely nonsensical. Most NoSQL stores like Cassandra solve very specific hard problems. Mongo is an exception; it doesn't even solve anything that relational stores don't. Mongo is just a fat marketing layer over a memory mapped file. I work on a project that uses Microservices and we use Cassandra as our primary store. This has been a huge mistake. There are only a few areas where we need Cassandra; for anything else the capabilities and tools of/for a relational database would've been a much better fit. So please don't lecture me on using NoSQL stores. I've been using them for the last years (ES, C\*, Neo) and they're well within my area of expertise. And **in general** projects are much better suited with a **general** all purpose relational database. It's from an architectural standpoint much smarter to start with a relational DB (and nowhere did I say every microservice should share the same DB!) and migrate specific functionality to specific tools. Starting out with a NoSQL store is almost always a huge mistake. 
STOMP is a messaging protocol that can work on top of websockets. It provides a few improvements, mostly for the case when there are many types of messages that could be sent over the single websocket connection. Currently you have "connection.onMessage" in which use will need to put some message handling. This will likely quickly evolve into examining "message.split("\\\\s", 1)[0]" or something like that. With STOMP abstraction ready one will do "connection.subsribe("mytopic", s -&gt; { something })"
I see, I actually just encountered the situation you described, but I solved it by having a messagetype in the JSON instead of splitting, but using STOMP sounds better. When we expand the framework I will try to implement it :)
Their goal is to *help* Java. By trying to contribute their significant knowledge and experience in this area. That's the entire point in the EG in the first place. And they are certainly not just crying "right before release", they have been trying to have these discussions the whole time. If you think you know better regarding any particular points raised then you're free to actually attempt to address them. Go right ahead.
&gt; This isn't a design pattern. It's about simplicity and flexibility. You don't know everything up front; you never do. Yes. These are some of the foundational principles on my side as well; Don't build for requirements you don't yet have, and keeping your software as simple as possible is ultimately the most flexible. &gt; And once you have data people will want to 'do' stuff with it; relational stores give a ton more flexibility there. Relational data stores absolutely have more ad hoc flexibility, but I'd argue that it is irrelevant from a software perspective. Feature creep needs to be guarded against regardless of your DB choice. As people want to 'do' stuff with the data, those new requirements need to be evaluated and built into the application. That is often precisely where the use of RDBs go wrong: additional queries or data are added as an afterthought just because you can, and over time the feature creep destroys the software. &gt; Choosing a NoSQL store because your problem is 'simple' is completely nonsensical. That's not what I said at all. I said you'd choose NoSQL if your software design ultimately requires nothing more than a key/value store. Most of the rest of my post was simply an explanation for how you get to that point. It's really not that complicated, and trying to counter that by saying your software doesn't fit that requirement doesn't contradict my point. &gt; I work on a project that uses Microservices and we use Cassandra as our primary store. This has been a huge mistake. That also doesn't contradict my post. For every story about an improperly used NoSQL db, there's probably 10 times as many examples of improperly used SQL dbs. Just because someone uses a tool wrong doesn't mean its a useless tool in the right context. &gt; So please don't lecture me on using NoSQL stores. I'm not. I'm explicitly _not_ trying to tell you how you should be doing your job. I'm trying to explain an environment in which you would use NoSQL, and the benefits associated with those patterns. Because what I *am* telling you that it is practical, it *does* exist, it *does* work, because it is what I do everyday. I believe you that what you're doing doesn't work well, and using a relational DB could have been a better choice given other factors in your environment. You're trying to prove a negative; arguing that NoSQL is almost always a huge mistake because it's almost always been a huge mistake in your experience. I'm simply saying that it *does* work here, reliably, in a lot of different services. And it works not because we default to NoSQL, but because we default to a software paradigm that ultimately leaves us with no need for anything more than NoSQL. There's no need to account for a safety-net style approach to use relational "just in case", because we rarely ever need to revisit the DB decision. I'd also repeat a point I made in an earlier post: If you build your software by starting with the decision of what DB to use and build your software around that, it doesn't matter if you choose NoSQL or relational, you're almost always going to have a bad time. The database is not your application, it is just a tool that needs to be chosen based on the application's requirements. It sounds like that explains some of the pain you're having with Cassandra, if it was chosen because someone thought NoSQL was a popular idea with no real need for it based on the software architecture. &gt; It's from an architectural standpoint much smarter to start with a relational DB My ultimate point is that you shouldn't unilaterally decide on any tool without first understanding what the job needs. I disagree with this sentiment; From an architectural standpoint, it's much smarter to start with precisely the tooling that you need, and keep the system simple enough such that it is trivial to add functionality in the future if and when it becomes necessary.
Re-reading the automatic modules thread I suddenly realize that module names will have to be unique across the entire Java ecosystem now, with the first one to claim the name of the module be a winner. I just checked maven central, there are almost 40 unique libraries called "json" (the group differs, but group is not relevant for the module name). That is going to be fun times when Java9 is released...
Next you'll need some auxiliary information in each message (STOMP headers), then an ability to check if message was received by the recipient (STOMP tickets) and so on :) It all can be done as custom code, it is just a little bit easier - it is already a well known protocol and many languages have libraries for it. Glad it is on your list to look at. Thanks!
[removed]
There's a vote, not crying. 
I agree, and I would say more, I'm more scared of JPQL than of SQL.
I'm afraid of nothing, bring it all on.
What is the MEAN stack? I have never heard of this so I don't think it is that hot.
Picking the default module name from the jar file name, rather than from the shortest common prefix of included package names, does look like more of a mistake than a choice. It's the job of the build system to pick between multiple implementations or versions of the same module. It can't do that if they all have different module names.
Well, because if they screw this up, which they are trying to do, Java 9 is dead in the water and so is Java. No biggie, Oracle, do whatever you like.
Disclaimer: I'm not even close to an expert in Java politics, my opinion is only informed by having followed along with a few JCPs when I've had interest in them, and reading some of the discussions during their development. &gt; (1) The JCP is a useful process though! Oracle may *sometimes* just push things though regardless of input, and I think that is a shame if and when it happens ... but in general I don't think it's fair to write the whole thing off as a "pretence". There is clear value in gathering experts in related fields and involving them in the development of specifications. &gt; (2) They didn't just come up with a design at the start, carve it into stone, and then work on implementing it the rest of the time. They have made a great number of modifications and taken on suggestions throughout. In other words there would be no "initial spec" to vote on because the whole point in the JCP is to *develop* a spec. Voting "no" now isn't just voting to throw out the whole thing, it's just voting to not finalise the design quite yet because they feel it could do with further work. &gt; the JCP seems pretty broken It might not be ideal but I think even in this instance it's probably had a positive effect. I know for a fact that some OSGi people have made at least small contributions that were listened to, for example. I haven't been following closely enough to know the full extent of it, but to have a formal process in place to facilitate this interaction is better than nothing imo.
Exactly what is the point of this? It's a single guy (the answer you link to) who has no experience with Java in startups seeing this huge selection bias as some kind of truth. Take a look at the rather well funded Fintech startup world. Java is used in the back-ends (which you normally don't even see) a ton. The main difference there is funding: if you mostly work for small companies strapped for cash you're going to find very different tools than when you work for companies who can hire whoever they want.
Oops I meant to link to the question not that specific response my bad. Just trying to get other peoples opinions. Fintech does have a lot of Java but if you look at most other start ups it's pretty rare. 
Interesting study like each year
I mean to use XML instead of JSON
Its all according.... are you exposing the XML api? - might others make use of it? then XML might be better, if you publish the schema. OR, if the api is private to just your client and server, then you can use what you want.... 
Having a verifiable schema and defined type mappings for more than numerics, strings, arrays and dictionaries? This isn't impossible with json data but I think it's a lot less usual. It's pretty much a given in xml.
An object reference, maybe?
I think Java 9 adoption will be slower than 7 and 8...
If we're going to have another module system, it *should* be able to replace the others. Using two different module systems at the same time sounds like a nightmare.
I don't get it, Servlet 4 will be part of Java EE 8 which is unrelated to Java 9, and should be released soon. BTW, what is so special about websockets in Jetty10?
You get less boilerplate with JSON and faster serializers. [https://www.cs.montana.edu/izurieta/pubs/caine2009.pdf](https://www.cs.montana.edu/izurieta/pubs/caine2009.pdf) 
[Java Evolution Parade](http://turnoff.us/image/en/java-evolution-parade.png)
Swing is dead when java is ;-)
This is starting to look like it has the potential to turn into a Python 3-esque community nightmare. 
Or use protobuf 3 or Apache thrift 
Basically, the module names for the servlet related packages must be part of the Servlet 4 spec. Which implies that module naming convention is established. It is possible for Servlet 4 to go out with it and be followed by Servlet 4.1 when Java 9 is out. It is not a hard dependency and it is up for the committees to decide on the way forward. My language above was wrong, sorry. The point where I said "which can only proceed after Java 9" should've been more cautious "may get stalled until Java 9". On the websockets in Jetty 10, it is supposed to be a big rewrite and get a nicer API and better performance. I actually need a websocket client for Java that would work in harsh conditions.
i reckon that most people use reserved instances.
At least here in Germany it works (but it's very rare amongst collegues). I'm doing that since more than 10 years and would never go full time. LPT: Don't search for explicit part time jobs. There are none. But you will be surprised how many employees will consider part time when you ask for that on a full time position. Regarding the work's nature: It's the same as my full time peers do, just two days a week less and less pay of courseâ€¦ well, not exactly as I do pay relatively less taxes, so you do get more net for your time, at least here in Germany.
This always comes down to use case. Json, xml or custom serialization depends on what you care about. Json is easy, xml is easy but more verbose. Iirc xml will let you serialize more complicated data objects more easily. But this is if you're doing more complicated data structures, not just transfer objects
Have you ever used XML with an XML schema or DTD? You can actually validate that the XML conforms to a specification. Can you do that with JSON? Nope... not without converting it to XML first. XML may not be popular with the cool kids these days, and I still personally think they're both used WAY too often (binary protocols for the performance win!), but it's far from trash.
IntelliJ uses Swing...
Having taken AP Computer Science A in high school, I would definitely say that there are more advanced topics that aren't covered on the AP exam, like generics. If you are serious about receiving the certification, I would try to learn more of the language.
I'm a gainfully employed developer who sometimes makes hiring decisions. Don't waste your time. You're better off just working on something, either an existing project on Github or your own side project. Try to use a framework that you haven't worked with before so you can eventually throw it on your resume. 
Are you referencing the package also? Like `package.Class#field`?
I did the SCJP 10 years ago in the first year of my first job (they paid for it). It was great for me personally coming out of school and learning Java again from a non academic point of view, if that makes sense. But even just four years later I didn't put it on my resume when looking for a new job. If you're going to do it, do it for yourself. But if you're going to do that, you can just skip the cert, and study and code instead.
Also you will learn more about good coding style through doing and seeing other talented coders work than through studying.
What about a WADL?
Heck yeah might as well flip some front panel switches too. https://en.wikipedia.org/wiki/IMSAI_8080 Have you ever entered a boot loader this way ? Even once ? Yeah, abstraction is not such bad thing.
[@Where's latest tweet](http://i.imgur.com/8otUHdo.jpg) [@Where on Twitter](https://twitter.com/Where) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
What about using @link?
Each item will be serialized as a class name and any non-transient field values. The class name determinesâ€‹ the type. No method data needs to go over the wire. Here is an example on stack overflow: http://stackoverflow.com/a/448233/3430807
This answer assumes your asking about Java native serialization, not serialization to json or xml.
For example of actual production experience and impact of using Zing on AWS with Cassandra, check out: https://twitter.com/garryturk/status/859883566267871232 Those factors are easily there in many cases, at least for things that care about speed, responsiveness, timeouts or error rates under load, etc. Java-based infrastructure like Cassandra, Elastic, Solr, Kafka, Zookeeper, etc. are easy examples since their common use cases all seem to care about that stuff. And when they do, capacity choices are basically driven by "how many of these instances do I need so my SLAs don't break and people don't scream at me?..." questions. Empirically Zing seems to have a large (and occasionally huge) impact on the answers to such questions on AWS. Some of the numbers we are seeing are so good that we avoid being explicit about them, since we don't want people who "only get 2x" improvements in carrying capacities to be disappointed ðŸ™‚
&gt;You can actually validate that the XML conforms to a specification what does this mean and why would i want to do this?
Using IntelliJ might solve the problem.
I tried that! Didn't help. :(
I fear you might be right. :\
JSON has schemas as well ([link](http://json-schema.org/)) however, it is not as widely used as XSD for XML
Comments, Schemas. 
Such pragmatic constructs are often more practical than the pure data structure definition. Depends on use case, ofc.
This is a troll right?
[removed]
[removed]
And allow them to be in really deep shit when they finally remove this flag.
Please, provide an example, what JDK developers cannot do because "everybody and their dog keeps poking into platform internals"? &gt; despite the 20 years of docs telling them not to do that Obviosly, people only do that because there's no other way to do certain things.
maybe im over-simplifying, but this sounds equivalent to just defining multiple endpoints and request/response types. what is a practical example of doing this? ive read about API discovery techniques - could such concepts be coupled with these client-driven contracts?
Sorry, I don't understand.
This is only for validation of implementation, that it complies with the requirements. Think of it as a unit test of your REST API, for both, client and the server. It doesn't do anything else than this. As a practical example think about any two services, any client and server, that are developed by separate teams. With defined contract and generated unit tests, each team will know really fast when they will break the communication in case of a bug. This also gives the ability to test your service in complete separation from other services, because if you can test your business logic with unit tests and your API with CDC, you eliminate a lot of potential problems that could occur in production enviroment. API discovery like HATEOAS? I think that API discovery techniques are more focued on public API, when CDC is for your internal API and communication between your internal services. 
I know what `Unsafe` is. What problems JDK developers cannot solve without restricting access to `Unsafe`?
Unsafe code bringing the JVM down because developers misused Unsafe. Java 9 was supposed to remove it, as it is an internal Sun API, but wasn't possible due to major packages depending on it. Hopefully by Java 10 timeframe there should be safe APIs for all Unsafe use cases (some already introduced in Java 9) and then it will be gone as well.
Why do you say that?
To watch tutorials and projects live.
It cannot be deleted. AFAIR, it is used internally in implementation of `VarHandle`.
I am a Director of Engineering, and regularly hire engineers. If I received a resume of a recently graduated High School student that had passed a certification exam, I would be very interested in hiring that person as an intern. Why? The certification itself is not an indicator of any significant depth of knowledge of a language. However, it is rare for a newly graduated HS student to show such interest in bettering themselves, and would make you stand out from other candidates. It also is a fairly level measuring point against other candidates, unlike a hobby project you would work on. However, I recommend you look to Java 8 instead of 7. 
&gt; No, you are wrong, there are other necessary things which become inaccessible. For example, FileDescriptor.fd field or Throwable fields (which need for custom serialization). If you have any specific inaccessible APIs you believe are essential which do not have a public replacement, I can only suggest to raise the issue on http://mail.openjdk.java.net/mailman/listinfo/jigsaw-dev They're quite responsive there. 
&gt; it just got removed/renamed/whatever (which is a backward incompatible change). Now what? Now I'm asking what are the reasons for removes/renames? Why don't just keep them? What problem JDK developer can't solve without renames/removes? &gt; Why on earth wouldn't you want a public API instead of relying on an implementation detail of the JDK? Some things are not possible with only public API even with Java 9. E. g. allocate an instance of class without calling constructor (and much more).
Did you try?
Once I found a minor bug in `CompletableFuture`. I tried to report it, but I couldn't. Because you can't create an issue in the [issue tracker](https://bugs.openjdk.java.net/browse/JDK) if you are not a developer. I've created a workaround in my project, and that's it.
If you're going to be using it as a Deque, replace ArrayList with ArrayDeque. ArrayDeque is often forgotten but it usually performs better than a LinkedList in push/pop ops and has O(1) random reads (but O(n) writes that are not at the end/begin).
you can join a mailing list in five minutes and post the bug you found on there :)
The other ways don't corrupt memory.
I'll show you another example. Bug was reported by someone else, but that person asked exactly what I needed: http://bugs.java.com/view_bug.do?bug_id=6526380 I believe if they had public bug voting in their tracker, that issue would be very popular.
There is a lot of way to corrupt memory using public API. For example, you can simply write to /dev/mem. Or use JNI (probably with JNA library). Unsafe API is already hard to use. If some developer corrupts memory using that API, it is problem with developer, not with API. JDK authors trying to protect irresponsible developers by hurting good developers.
Using JNA/JNI means there is a dynamic library that is easy to find and mark the whole application as possible unsafe. Using the unsafe package means one needs to decompile the application to track it down.
/r/learnjava
Since this is help with *Java programming*, it should, as the *plenty hints* on the subreddit indicate, be posted in **/r/javahelp**. Please, **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there **before posting!** As it stands right now, your post is not acceptable according to the guidelines. **Post removed:** programming help
If you'd look what they have done you would probably not recognice it as Swing anymore.
No problems on Ubuntu here and at last a more nice look and feel.
Looks nice. What if I want to define generators for my own classes?
&gt; How about injecting bytecode of modified jdk internals via agent or otherwise, that will grant you "addOpens", maybe that works? Any luck with that?
It's not only JDK internals. Any module will be closed if not explicitly marked open. No more bug workarounds of ancient but essential libraries. No more quick and dirty but **fast** hotpatching. No more Minecraft modding. etc. That monkey patching like flexability helped Java become popular.
Exactly this. I know inheritance based subtype polymorphism has gone out of style for good reasons, but sometimes you need a simple fix and don't have time to swap out an implementation behind an interface. A quick and dirty subclass that overrides a few things can be safer and more maintainable.
Generally speaking, this lets you determine if the data given to you in a specific XML document is actually any good. Does it have all the required elements? Are they the correct types? Are they the correct format? Do the elements that refer to other elements actually exist? A somewhat useful example is detailed here: https://www.w3schools.com/xml/schema_example.asp Without validation, you basically have to write your own validation logic, and if you process a lot of different types of documents; it can be a real boon to have this.
I'm sure that works too. But if I create a schema, anyone can use it and all they need is an XML parser that can run validations; regardless of platform. Also, as an interchange specification language, it widely usable by a variety of audiences, whether or not they use Java or the specific version of Java / Spring that you use.
You could use it to build a low-allocation unbounded version of ConcurrentLinkedQueue. Right now, CLQ allocates an object for every entry put into the queue, which is wasteful.
You are a child.
XML != SOAP You can use XML with REST
Depends what you're trying to represent. XML is better for modelling document markup, and can handle references better. Otherwise, JSON is faster and smaller and I find it easier to read
While technically true, I have yet to encounter this in the wild.
XML can be smaller than JSON but that's because JSON has better naming capabilities. I prefer JSON because naming is important. However, if you have strict control over naming and performance is a deciding factor, then here is an example to consider: &lt;elem a="1" b="true" c="foobar"/&gt; vs "elem":{"a":1,"b":true,"c":"foobar"} JSON uses more bytes even though two of the three values don't require quotes. For large documents, the difference can add up. I wish a hybrid solution would take off, I don't think this is settled... After-thought, is there even an XML parser as fast a Jackson or Jsoniter? No agenda, I wrote a JSON lib which I won't name, but Jackson and Jsoniter are the two fastest AFAIK. 
Actually... REST and JSON aren't the same thing at all. You can be doing RPC and use JSON too, and not being using REST at all. And you can design REST interfaces that deliver XML. REST isn't a data format; it's an architectural approach. Don't believe me? Here's Chapter 5 of the original dissertation by Roy Fielding: http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1 See section "5.2.1 Data Elements". You will not find any mention of JSON or even Javascript in that section, nor in any part of that chapter. You're quick to find fault with someone who doesn't jump on something like JSON just because it's the new cool thing. Well, guess what? It's not always the best tool for the job. The sooner you realize that, the more quickly you'll mature as a developer and architect; so why don't you take a good look at yourself **instead**. 
This is a very cool program. Too bad it's so dated. Nice of them to include the source though. It would be an interesting project to upgrade it to JavaFX or something.
Looks amazing, but code styleâ€¦
'No more' is a bit hyperbolic. As I've shown, it's only an `--add-opens` away. Whether that's a fair deal depends on which perspective you take. For now, most applications will run on the classpath on Java 9 anyway (which is open).
Why not just rewrite it a bit to launch a JFrame instead of Applet? the foil.java contains all the necessary code, right?
Read up on restful apis A nice and simple way to get started with building a restful api is with a framework called Spark. From there you can move on to something like Spring Boot or maybe Play. If your client is going to run Java then checkout retrofit by square. It makes it easy to consume a restful api from Java.
[removed]
[removed]
 java.nio.file.NoSuchFileException: log/TPD_XML_creator_tool_0_0.log.lck. This tells you that there is no directory/file named **log/TPD_XML_creator_tool_0_0.log.lck** found on disk. Manually creating that directory or file may solve your problem.
Yes. 'activator run' :). In play you have hot reload so you will see changes without restart so it'll will ease beginners pain. 
To be fair, you have Spring-Boot devtools for that, as well as regular hot reload (when not changing method signatures). If that's not enough, you can just patch your JVM and you'll almost never have to restart your application again. But that's hardly an argument for choosing one technology over the other.
From the sidebar: &gt; No programming help questions here! These should be posted in /r/javahelp
It's trying to write to a subdirectory of the current working directory called "log". I suggested the `cd` command above to keep everything under there, but from the output here, it looks like you're still in your home directory. So just try: mkdir log and then run it again.
environment[x][y] = z;
It speeds up development / debugging a lot. So it's an argument. Also play is much faster than spring when processing requests (less overhead) 
&gt; If there are public APIs for some problem, there is no need for encapsulation, because nobody in sane mine will use private API. I see that you have never maintained legacy applications. But it's a nice fantasy, I wish reality corresponded.
Can you elaborate be on this? gRPC caught my eye lately too and I'm wondering what all the fuss is about.
If you just starting, my suggestion is to start [Head First Java](https://www.amazon.com/Head-First-Java-Kathy-Sierra/dp/0596009208) book. This is one of the best book for beginners (It's still in my collection). Once you have basics, you can start looking in to web resources to more advance tips and tricks.
With 3 "no" votes, not a whole lot of room for error (6 more "no" votes and the public review fails). As someone who is preparing some presentations on Java 9 in very near future. This vote definitely has me nervous. Paging /u/nicolaiparlog you have any additional insight into the upcoming vote? 
good for him, agree entirely with what he has said.. redhat and IBM love the bloat..
but is it the best for that purpose at the moment or what else could you recommend? And where can I ask questions like that?
For me, the biggest advantage is that it handles all the infrastructure work for you - It allows you to focus on your business. Let me explain. You define your service method signatures using a special syntax (platform independent). Then run the grpc compiler and it will GENERATE A CUSTOM SERVER AND CLIENT for you in any language you want. Then you just have to complete the server by implementing your business logic. You can even later generate more clients in different languages. 
If you maintain a legacy application, it is even worse if it breaks today, than if it would continue to work for several more years.
Spring makes more sense, since it is everywhere. So yes, maybe there are some small advantages in learning play, but spring and boot have much bigger market share. 
Evolve Unsafe into something else. For example, breaking it down to a more focused subset of functions. Or replacing it with something completely different. Unsafe is JDK's internal implementation detail. Whatever JDK decides to do with Unsafe should be possible without worrying if some popular high performance libraries get fucked because of this. 
Which one's the third? Eclipse Foundation? Edit: Seems to be [Hazelcast](https://www.infoq.com/news/2017/05/jigsaw-public-review). Given Eclipse Foundations link to OSGi, which is excellent in comparison to Jigsaw, they might also vote no. Azul Systems sees Jigsaw as simply means for JDK modularization and will likely vote yes to move on. The London Java Community EC member is undecided, but also sounds somewhat negative. &gt; However, if the broader ecosystem refuses to support the current design / implementation, then it will fail to gain broad adoption and will at the very least cause a lot of frustration in the ecosystem.
I briefly thought about that, but it seems like a waste to set up an entire Windows VM on each station just for one legacy Java app. The applet viewer method actually works really well on Windows 7, 8 and 10, and I've integrated the more [modern version](https://wright.nasa.gov/airplane/tunnl2int.html) the same way. I'm still going to research JVali's suggestion of re-writing it if it's something manageable for a beginner.
yes my application is running with spring anyway. So no, I would also not use the JavaFX for that. I can use Thymeleaf or Vaadin. But as I said I am totally new to that and I dont know what techs are the most prefered ones at the moment. So I dont care if Thymeleaf or Vaadin or whatever. I would take what people think is the best and easiest.
If you already use Spring then going with Thymeleaf would be easier. Thymeleaf is a template engine to serve HTML.
I liked it, tried to make a similar clone of the list. Yours is the main one http://berlinbrown.github.io/javathirdparty.html https://github.com/berlinbrown/javalist
&gt; Mark Reinhold is not acting like a leader here. He is whining that people don't like something that is not satisfactory to them, and then uses weasel words so that he can impugn them. Red Hat has a few fairly small changes that they want; they actually have stated that they want to move AWAY from JBoss Modules, directly going against what Mark says, but nooooo, Mark has to say "I don't know why they don't like it, they haven't said" even though they have. &gt; I'm sorry, Mr. Reinhold, that not everyone wants to stick to the party line. That's the way the JCP is designed to work and how it SHOULD work. If you've designed something that doesn't fit what the industry needs - and yes, IBM and Red Hat both have a right to vote when and how they see fit, for whatever reasons they choose - then they should vote according to their own rational self interest.
&gt; Evolve Unsafe into something else. For example, breaking it down to a more focused subset of functions. OK, just do it when it will be necessary when it will be necessary. Probably emulate old API. Why restrict access now? &gt; without worrying if some popular high performance libraries get fucked because of this They are "get fucked" now. "Get fucked" now is worse than "get fucked" in several years when (and if) change will be really needed. &gt; Unsafe is JDK's internal implementation detail. Which means that JDK is designed poorly, because a lot of problems cannot be solved without accessing implementation details.
There's really nothing cyclic here. Static fields are initialized once so it doesn't go into an infinite cycle. If the initialization has already started it can't be started again, that's why the `null` gets printed: no initializers left to start but no value yet set either.
I'll see great use from Jigsaw, while everyone else is complaining...
Clearly you're not ready to move up in the ranks. They should keep you on bug fix scut work until you know the difference between validating parsing and deserialization.
I'm crap at maths fortunately my computer is very much better at it... While this might seem flippant, think about it the hard bit of math is done for you, without getting into programming I'd have never known about matrix maths and how to useful it is for 3d graphics, just don't so much need to be practised at the mechanics of math, as knowing what techniques to use at a higher level. Many things in IT look complex and impenetrable, but its all based on the simplest possible maths (boolean) 
It really depends on what you mean by "do you need math". The core of mathematics is logical reasoning which is certainly a skill you need in programming. That doesn't mean you need to know calculus to program for example. But many concepts of mathematics and computer science are relevant when writing code. There's enough overlap that I would say that if you like programming you probably like math as well, even if you don't realize it. Math is more than just numbers like programming is more than just code. 
&gt; designed by someone else 20 years ago, implemented by dozens or perhaps hundreds of engineers over the span of two decades During these 20 years they could fix those problems a lot of times. They even can solve problems now (provide public access to low level things like memory allocation, raw memory, certain aspects of reflection, SIMD and so on; yes I know about `VarHandle`), but instead they decided to complicate users' daily work. Suppose, you have a problem: people do not close the door. There are three solutions: * ask people politely to close the door (doesn't work) * fine people who don't close the door * install door closer JDK developers fine users for not closing the door. &gt; That or an incredible case of hubris. Sorry, I can talk only about technical aspects of problems, not about myself.
Just curious what libraries are you using? A lot of very popular libraries/stacks will not work right now with Jigsaw, or at least jigsaw as it is intended to be used. For example the Spring framework won't be supporting explicit/named modules until Spring 6, which is currently planned for 2019 at the earliest. Hibernate also craps out because of Jigsaw. Not saying Spring and Hibernate are the entire world, but a lot of what causes those libraries/frameworks to fail will also impact many other libraries and frameworks. 
I'm not using Spring and Hibernate. But I have highly modular projects with strict architectural guidelines, that we can now enforce thanks to Jigsaw.
Our company has been slowly divorcing IBM because of the bloat. RAD, Websphere, RTD... tool after terrible tool to promote bloat and vendor lock in. What a shitty life for Java....a great accomplishment within Sun only to be oboarded to Larry Ellisons Deathstar and then mired in the quicksand that is IBM and Redhat.... At least the Spring Framework team exists to shock the JLS back out of defibrillation. That and Ubuntu keeping up just fine for me...(sometimes, yeah I'm looking at you Unity)
The burnt child fears the fire. People who used both have faced hardship with Java EE and not with Spring. The details do not matter much. Java EE is based on a conflicting strategy. The large players in the Application Server market are both cooperating and competing. They are competing for signatures on license contracts. They try to win over higher-level management people looking at feature-spreadsheets and project plans, not at code. This causes all the pains that come with Java EE. * Feature bloat that projects do not need but needed to be included in Application servers to make upper management feel better about spending that much money. * Vendor lock-in for all the non-standardized parts, testing, building, deploying, operating, integrations, ... * Features that are very difficult to use and hardly documented, again existing only to make expensive license contracts look nicer * A fragmented community which makes it hard to reproduce, report and discuss issues that come from specific combinations of application servers and integrations. Spring on the other hand is made for developers, not to blind some upper management with the longest list of features to get that signature on everlasting license contracts. So spring has more innovation, more usability, better documentation, less bloat, as a matter of philosophy (though of course not in every detail).
Microservices are modular apps that collaborate together. Do I need a (500MB * N JVMs) for a group of services that used to live in the same house along with all of the other packages that I don't use with it? I want to have a serious conversation but it doesn't sound like you understand what you are talking about. 
Linking/modularity won't save you anything in terms of memory. Classes are only loaded into memory on use. Yes rt.jar is a monster, but it's major hit is to storage, not to memory. EDIT: Also linking to a blog article written about an engineer who works for a unicorn, doesn't really disprove the point I was making in my original post.
I'm just saying it is far too easy to be smart in hindsight - wave your hands around and make self important noises about how someone else should have handled something you have had no input into. You are saying you can only talk about technical aspects of problems. Fine. Talk about technical aspects. What _should_ they do with Unsafe precisely? The huge problem of Unsafe is that it is, well unsafe. It gives you C style access to raw memory. And besides being a huge gun to shoot your foot off, it is also ha tremendous potential security hole. For a language that prides itself being safe from memory errors, that is a big hole in their argument. If Unsafe would have stayed an internal implementation detail like it was designed to, they would be free to ditch Unsafe as soon as they could provide something better to address high performance low latency use cases. As for the door analogy - the door was hidden Ina an and inaccessible room to start with. People using Unsafe are going out of their way to get to that door, using lock picking tools and crowbar to get through that door. Sorry but no amount of "asking nicely" helps here. 
what about saving a few gigabytes of transmission time? a project i'm involved with tries to make usage of cluster computing easier for scientists. part of this involves shipping off an executor jar and a jvm to grid machines to manage and run the scientists' code. right now we have to bundle a full fledged JVM, but with modules we can create an executor binary that includes just the subset of the JVM we need and the executor bytecode. doing so reduces the overhead of starting computation for us, and is extremely welcome
&gt; The first criterion is to allow cycles to exist among modules &gt; The third criterion is to provide package namespace isolation among module path modules. What I get from this is that Redhat wants to keep its own module system, and all the bugs contained within (to me a sound dependency system should enforce a DAG structure). They went ahead and off the trail into complexity, and now the committee is normalizing to a simpler common base. And they are protesting about having to migrate their legacy. ---- &gt; The second criterion is to re-evaluate (piecewise if necessary) the (still very small) module primitives patch. I dont understand what they want here. 
Suppose I have three modules: a logging interface, a logging implementation, an HTTP client. * The HTTP client uses the logging interface to report statistics. * The logging interface uses the logging implementation to dispatch logs. * The logging implementation uses the HTTP client to upload batches of logs. Assume there's no compile-time dependency from the logging interface to the implementation. Is this possible in Jigsaw? I configure cycles like this with Guice and I wouldnâ€™t want to lose that.
Let's imagine your new project uses Spring and you decide that you also need Hibernate. Oops, module system doesn't allow that, because the frameworks use different versions of slf4j or guava or whatever. There are countless non-obvious combinations of 3rd party libraries that do not work together in the module system. In conclusion Jigsaw works fine for new projects that are completely **independant** from 3rd party libraries... 
It's not a business case of course. You can't very well fix the issues when everything looks fine at compile time but only surface sometimes at runtime. Also there might nothing be actually wrong designwise because the cycles might appear because of some unlucky combination of 3rd party libraries or a plugin mechanism.
However should the situation appear on the classpath, there is a less hacky workaround (less compared to modifiying the artifact): The conflicting ones have their own classpath. That doesn't work on the module system. For another workaround, you have the build system like Maven with Shade plugin, that manages the name. That works because the coordinates of the artifact are clear. The module system however doesn't give any help. [As Brian Fox said](http://mail.openjdk.java.net/pipermail/jpms-spec-experts/2017-April/000677.html): &gt; *The build tools can help this migration from the old world to the new one, but you must let us help.* 
I played now a bit with Thymeleaf but I don't understand it at all. So I guess to have Java Skills is not enough for what I want right? Do I have to learn HTML too? Atm I just don't understand how I bring my data into a usuable Design in a Webbrowser. I looked for some tutorials and cloned some projects at git but ended usually with some ugly interfaces. Yes they work, but these examples were not even close to what I need and do atm with JavaFX. There I use scene Builder to make pretty frames, just connect them with some controller classes and thats it. Am I correct: I have my code. I handle request regular with my RestController and send data back to the browser? So if so, how can I add buttons, tables etc. to the site. I think for exactly that I need some HTML skills or not? 
yai, okay. Thank you mate you helped me a lot. At least I now know that its by far not that easy as I expected. Since you appear to me very good in that topic, could you maybe recommend some/one site(s) which are a good address for a newbie due to HTML, CSS and all that web stuff?
I can imagine that circles in dependencies can exist. I have had to clean up circular dependencies a few times at work, and none of the involved developers have meant to introduce circular dependencies, they just didn't look at the whole picture when they introduced a new dependency. I can easily imagine that there exists circular dependencies between different maven modules. If someone would load them all into a sort of graph, it would be possible to discover.
I'm not an expert on TDD, so don't take my word for granted, but I believe it works as soon as your test coverage is "good enough" - meaning there is a high chance of detecting broken old code when adding new features.
The author went into more detail in an email from February: http://mail.openjdk.java.net/pipermail/jpms-spec-experts/2017-February/000600.html It sounds like changes were necessary to make slf4j compatible with this aspect of Jigsaw: https://www.slf4j.org/faq.html#changesInVersion18 (I'm not saying *I* think this is a good idea.)
&gt; I'm just saying it is far too easy to be smart in hindsight - wave your hands around and make self important noises about how someone else should have handled something you have had no input into. Well, you are saying exactly the opposite: JDK developers are smart, they know what is better for us. It is also easy to say. &gt; The huge problem of Unsafe is that it is, well unsafe. It gives you C style access to raw memory. And besides being a huge gun to shoot your foot off, it is also ha tremendous potential security hole. Honestly, I see no problem in that. It safety is a concern for you, if you do not trust yourself or your developers, if performance is not an issue, just don't use Unsafe. You are not forced to. &gt; For a language that prides itself being safe from memory errors, that is a big hole in their argument. There's a language called Rust. It "guarantees memory safety" (quote from rust-lang.org website). Technically it is not true. Because you can always use `unsafe` block which allows you to corrupt anything. But despite that, Rust is still considered safe from memory errors. Just don't use `unsafe` unless you understand what are you doing. &gt; they would be free to ditch Unsafe as soon as they could provide something better to address high performance low latency use cases. I'm fine with that. If and when they really need to solve some problem. And users would have a library, like objenesis, which would unlock access to internals differently depending on implementation details of current JDK version.
TDD is not a silver bullet for the correctness of your tests. It is very possible to write 100% code coverage TDD'd code and **still not find the solution to your problem** What is does help with is building assurance that any new changes to your code will not break other pieces of code. This typically starts to happen when your codebase increases in size. What TDD also helps with is client code and API exploration. You typically **need to understand your 3rd party dependencies a lot more** when going through a TDD process. You also tend to design your own code in such a way that you're a **client to your own code**. For me, this is the best benefit you'll get from a TDD process.
those aren't dependency arrows, those are loading order arrows. yeah, the http-client should depend on the interface, and the implementation should depend on http-client and interface.
Well, that's what the runtime dependency cycle looks like :) And that is exactly what is going to be more troublesome if the current implementation of Jigsaw is to be adopted in the wild (I am 100% with it inside JDK)
Consider start-up time. In Java 9, the gains are admittedly infinitesimal, but the road-map is interesting re: AOT compilation. e.g. In Java 9, the `java.base` module can be pre-compiled using an AOT compiler on 64-bit Linux. The long-term potential for AOT is faster start-up times, which is linked to modularity. See [Mark Reinhold's answer](https://youtu.be/WJHjKMIrbD0?t=33m30s)
It depends on how wide you want your skill set within the programming domain to be. There exists many different subsets of programming where math isn't relevant. But there is also a significant part of the domain where you will be severely handicapped if you don't understand the underlying mathematical concepts. It's perfectly possible to build a career where you never touch the parts of programming that needs math. On a more personal level, I experienced that i was able to solve programming problems better when I studied a lot of math, since the mental models for solving math problems and computer problems correlated a lot.
&gt; and Redhat wanting it built in a way that aligns with them specifically. Redhat wants it built in a way that is minimally usable by any developer and not have it tied back by silly "but it was written in the requirements" restricitions that will only bite back once a system grows. Something that e.g. Azul Systems seems to have already given up on: &gt; I can't justify rejecting it as a module system for primarily in-JDK functional purposes (which is how I look at it from a critical Java SE 9 point of view). IMO, the Jigsaw we now have will see limited use outside of the JDK, especially when it comes to libraries and reusable code posted in the wild. However if you look at it like that. Java 9 is a rather so so update given the 3 years it was in development. 3 years partly waisted resources instead of the real beneficial features and sorely needed language improvements (type inference, value types, pattern matching,...) that will come the earliest in another 3-4 years with Java 10.
Last time I checked the JVM was 156 MB. Heck you could host your microservices on Raspberry Pi's and you would have plenty of storage left. Sure smaller is better. But this is getting silly if you talk about storage for microservices. IoT is another matter where it does make sense though.
Well, you've got loggin-int twice there... If Jigsaw allowed more than one instance of the same module loaded that would've been a DAG. But it is not, and if you merge the two "logging-int" verticies in your graph you'll get a nice cycle there.
The game is commercially called BRIDG-IT, and is a version of the theoretical Shannon Switching Game. The game is solved, meaning one player (presumably the first) can play so as to always win. I had a quick look but couldn't find the algorithm, but I know I read it somewhere once.
Hmm I've tested the code in laptop. No such problem was noted. 
That doesn't prove anything. Just testing it on one laptop doesn't mean all laptops pass. I'm using an MBP using tap-to-click. Try one of those.
That sounds interesting. Would you mind elaborating? In what kind of code is this cache detrimental?
Your testing methodology is less than robust. Good luck in the real world.
Can you elaborate on the "Spring cycle" aspect? Have you brought this up with the team? We're taking very great care of avoiding package cycles and every glitch reported would be very welcomed!
Article contains very little on immutable data structures (no mention of the benefits - thread-safety, simpler to reason about, facilitates data sharing, or the drawbacks - increased number of objects), and instead offers some anecdotes about making fields public on the basis that it "sav[es] a good number of lines of code". Seems DZone will publish [any old rubbish](https://dzone.com/articles/java-method-overriding-and-visibility) these days. If you are writing immutable data structures, I'd recommend using something like [Immutables](http://immutables.github.io).
you don't have to load it twice. http-client and logging-impl both depend on the same module, and once logging-int is loaded both can use it. The module load order is therefore not acyclic and goes 1. logging-int 2. http-client 3. logging-impl logging-impl doesn't need to load logging-int cause logging-int is already loaded.
Do you know any major differences between Immutables and the immutable parts of Lombok? We currently use Lombok, but it is mostly out of habit, it's been a while since I looked at the alternatives.
Program testing can be used to show the presence of bugs, but never to show their absence! Edsger Dijkstra 
I still have this project in the office. I'll dig it up and report it to the team. If I recall correctly, the problem was in the OAuth package. But do not take my word for it. My experience reporting issues in Spring and providing fixes for them was not really the best so far ( https://github.com/spring-projects/spring-security-oauth/pull/581 ) ;)
Yes, depending on how smart your implementation will be you can squeeze a little bit of performance on some cases, while performing worse on others. It won't be a general purpose List, but it's a nice thing to have. Being more cache friendly you can iterate better than on a Linked List, while in the same time you won't need huge contiguous memory blocks as for Array Lists. While I was in University I had to implement different types of Lists, and the implementation you are talking about was one of them. You can also take a look at a Gap List implementation and improve that. As other mention, a Tree List is also a nice thing to implement yourself. 
She did, but daddy wasn't listening. 
Are you describing how the class loader works now or how JPMS will? Because reading current draft spec I do not see it working the way you are describing. The way you showed is exactly the ClassLoader way of handling it. If something is already loaded, it does not care how, it lets user to access it. Let get some examples. I'll use syntax outlined in http://openjdk.java.net/projects/jigsaw/spec/sotms/ module com.foo.app { requires com.foo.http; requires com.foo.logging-http; } module com.foo.http { requires com.foo.logging-int; } module com.foo.logging-http { requires com.foo.logging-int; } I think current dev build can be made to work if `com.foo.app` declares logging-http as `transitive`. But you insistence on that it works this way and JVM will resolve the load order to start from the leaf node in the tree to make it DAG makes me want to try it out. Edit: Looking at `jdk/src/java.base/share/classes/java/lang/module/Resolver.java` now. I think it will resolve modules in the order they are defined, so that later on `visit()` will detect that as a cycle. Still have not tried to run it.
Cheers. Gave it a try. Comments: - Tests with the same method name and class name in different packages will use the same json. Not ideal when projects get huge. - Idea allows click through from hardcoded paths to the resource file. This hides it completely. - I'm using a hamcrest style matchers to compare json for readability. Something like `asserThat(json, matches(json(expectedJson.load())))` so the JsonContentVerifier isn't much use. The loader is pretty nice here though. Otherwise, pretty cool!
Useless article. The first given example is not bad: any class can be written in that way. This is quite pleasant to use always the same kind of code. Ok we can sometimes use public data, but what is the gain here ? 
You can use RAML
As I said, on code that is dependant on escape analysis. Using interfaces with generics, I had to sometimes return Integer instead of int. So, code like this public Integer get() { return i++; } can be used somewhere else like this int i = supplier.get(); Without integer cache this is as fast as using primivites. With integer cache, JVM can't determine that this Integer object never leaves stack, so it just allocates new Integer on heap and has to collect it later. It could probably also be fixed by writing ````return new Integer(i++)```` that avoids the cache usage at all.
Then look for things to remove in the JDK (Java 9 helps) and as of this [benchmark](http://java-performance.info/hashmap-overview-jdk-fastutil-goldman-sachs-hppc-koloboke-trove-january-2015/) Trove4j doesn't perform that well in comparison. I'm a fan of [fastutil](http://fastutil.di.unimi.it/). There are [tools](http://autojar.sourceforge.net/de_d/index.html) to extract and repackage only the needed classes too. As always there are many things to consider. E.g. &gt; JDK HashMap is the only map which stores entries in the Node objects, which combine a key and a value. It means you have at least 24 bytes of overhead per entry. The actual overhead are 32 bytes because each bucket in a HashMap is a double linked list, so each entry has 2 extra pointers.
Yea, hopefully in a next Java (10?) with value types this discussion has become obsolete.
...&gt;And you get voted down. JavaEE haters gotta hate.
and one more question : if i have trouble with creation flowcharts, f.e(as it's part of logic ),how it can be improved? Any thoughts?
Thanks nice tutorial
First, thanks for your reply ! Also, you are ~~probably~~ right about I should learn to use a good VCS (and gitbub is probably the best example) and after procrastinating around some cool github projects, I decided that just for ~~contributing~~ -making my fork and trying to improve some of them- it would be worth the effort. However, assuming I properly learn how to manage and setup the project with git and gitlab, does my coworkers also need to learn the whole thing ? Because, unfortunately, they are the "if it works, don't fix it" type and won't bother to try to learn unless it's easy at first (and thennn they start to spend some of their own time to do correctly the whole thing because they see the advantages). Finally, I admit I should have posted on a general programming subreddit. Seriously don't know why I didn't though of it as I guess I'm probably not alone to ask myself that question..
&gt; does my coworkers also need to learn the whole thing ? Because, unfortunately, they are the "if it works, don't fix it" type and won't bother to try to learn unless it's easy at first (and thennn they start to spend some of their own time to do correctly the whole thing because they see the advantages). For your coworkers it's enough to know how to pull, commit, and push. You can setup individual branches and then let each work in their own branch and you do the merging into master.
With Immutables you define either an interface or an abstract base class, and it then generates an implementation class along with builders. As far as I know Lombok modifies your classes at compile time to add further methods, something I've never been keen on.
Had a look at the code. Unless you're into a very specific type of self hurt this won't be a nice learning exercise. :D Made it work in ~~Java~~ a JFrame. This is not as it should be but it works. https://pastebin.com/5bLg3X90 You might be better of rewriting this in javascript and using an html5 canvas. That way you're not dealing with any browser restrictions and people won't have to install anything.
You're welcome!
Agreed - the article is written with space issues as a primary issue already. Any additional library greater than your size budget is pointless to consider. Trove isn't designed for what you want anyway. No need to test performance if 1.7Mb is a primary concern over performance. 
I'm for quality over quantity. If you can't provide quality better redo or leave it be, otherwise you end up in a "JavaScript-ish" or "Java Generics" world.
I thought this was going to be about image processing...
Encouraging the use of "wait(), notify(), and notifyAll()." Random hodge-podge of "X is thread safe", "Y is not thread safe" and no explanation of the underlying semantics or JMM guarantees. If you want to better understand Java threading and the JMM then Aleksey Shipilev's site is a good resource. https://shipilev.net/blog/2014/jmm-pragmatics/ https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/ Forget "thread safe" language constructs. Focus on the underlying guarantees and ordering semantics.
An interesting parable from the [Art of Fear](https://www.amazon.com/Art-Fear-Observations-Rewards-Artmaking/dp/0961454733) *The ceramics teacher announced on opening day that he was dividing the class into two groups. All those on the left side of the studio, he said, would be graded solely on the quantity of work they produced, all those on the right solely on its quality.* *His procedure was simple: on the final day of class he would bring in his bathroom scales and weigh the work of the â€œquantityâ€ group: fifty pound of pots rated an â€œAâ€, forty pounds a â€œBâ€, and so on. Those being graded on â€œqualityâ€, however, needed to produce only one potâ€albeit a perfect oneâ€to get an â€œAâ€.* *Well, came grading time and a curious fact emerged: the works of highest quality were all produced by the group being graded for quantity. It seems that while the â€œquantityâ€ group was busily churning out piles of workâ€and learning from their mistakesâ€the â€œqualityâ€ group had sat theorizing about perfection, and in the end had little more to show for their efforts than grandiose theories and a pile of dead clay.* To each their own but I'd say hiding behind the Quality vs. Quantity argument is a path to becoming irrelevant. Fail and fail fast, people don't have time for you to plan the world....still fail....and then fix it. Otherwise Waterfall wouldn't be such a curse word these days. I hope we have the ability to reel in those who are fired up to make shit happen, not those clinging to some semblance of safety that never existed.
Read JCIP and JMM.
... or RxJava?
To add to this.....think about the journey of EJB's from 1.0 to 3.0. It came out in 99' and spent a decade of being figured out how to be used effectively to answer the enterprise call. Ultimately it was a complete rewrite of the EJB API. &gt; Accordingly, in practical terms EJB 3.0 is much more lightweight and nearly a completely new API, bearing little resemblance to the previous EJB specifications. [source](https://en.wikipedia.org/wiki/Enterprise_JavaBeans) I feel it's hard to argue with iterating to a successful implementation. It's honest in the sense that it isn't expected to be perfect. It asks for feedback and allows itself to be molded into something that will be used leveraging the feedback loop of your users.
That's really interesting, I had never thought about that. Thanks for elaborating!
I am working on my 2nd part as we speak that shows this!
At the very least it's more primitive than basic Oracle tutorials. Don't understand why it's on front page.
What a load of garbage. Avoiding (un)boxing in **the right places** is a **very** useful optimisation. It's neither "premature" nor is it offset by the paltry 1.7MB dependency. The tricky part is finding which places are the right places. Tight loops which get called a lot would be a good place to start. Even the benchmarks used are garbage: &gt; Construction costs are not incurred during the benchmark, only access times over a small batch of records. One of the major costs of (un)boxing is the extra garbage it creates. Some of the instances can be reused (AutoBoxCacheMax), but that's only useful for the most frequently used numbers; it's quite useless when you're dealing with the full 2^32 range. These benchmarks don't even look at the garbage created nor at how long the GC needs to clean it up. It only looks at "access time". 
[removed]
This is a much more lighweight library and you don't need to read a book to use it (unlike RxJava). Anyone familiar with JS promises or $.Deferred will be able to start using it without much hassle. The main difference with Rx is that its only purpose is to manage async ops, it doesn't have any of the functional stuff RxJava has (althoug it has filtering). And it is not oriented to cancellable streams, only single results (Rx didn't have Single until recently). The disadvantage is that it does not have a large community after it, and tutorials and other info are scarce (including docs).
Use an intervening data service that can execute the queries using appropriate query hints like entity graphs or using named queries. This also lets you convert your entities to appropriate DTOs if your client doesn't need the entire entity. Although if you are doing large entity-&gt;DTO conversions it might be better to skip JPA at that point and tailor a query to get the specific fields you require.
The solution is actually [very simple](https://vladmihalcea.com/2016/09/13/the-best-way-to-handle-the-lazyinitializationexception/). To summarize it, just follow these guidelines: - use LAZY for every association - use JOIN FETCH for ToOne associations and at most one ToMany assocations - use secondary selects if you have more than one ToMany assocations to fetch - use DTO projections for read-only views - fetch entities only when you plan to modify them So, you don't have to abandon JPA or Hibernate just because of an Anti-Pattern. After all, JPA and Hibernate have a huge market share for [very good reasons](https://leanpub.com/high-performance-java-persistence/read#leanpub-auto-why-jpa-and-hibernate-matter). 
Do you know a sane way of doing DTO projections?
1. For JPQL, the DTO constructor projection: List&lt;PersonAndCountryDTO&gt; personAndAddressDTOs = entityManager.createQuery( "select new " + " com.vladmihalcea.book.hpjp.hibernate.query.dto.PersonAndCountryDTO(" + " p, " + " c.name" + " ) " + "from Person p " + "join Country c on p.locale = c.locale " + "order by p.id", PersonAndCountryDTO.class) .getResultList(); 2. For native SQL queries, you can use a [ResultTransformer](https://vladmihalcea.com/2017/04/03/why-you-should-use-the-hibernate-resulttransformer-to-customize-result-set-mappings/) List&lt;PersonAndCountryDTO&gt; personAndAddressDTOs = entityManager .createQuery( "select p, c.name " + "from Person p " + "join Country c on p.locale = c.locale " + "order by p.id") .unwrap( org.hibernate.query.Query.class ) .setResultTransformer( new ResultTransformer() { @Override public Object transformTuple( Object[] tuple, String[] aliases) { return new PersonAndCountryDTO( (Person) tuple[0], (String) tuple[1] ); } @Override public List transformList(List collection) { return collection; } } ) .getResultList();
[Eager fetching is even worse](https://vladmihalcea.com/2014/12/15/eager-fetching-is-a-code-smell/). If Lazy loading becomes a performance issue, then it's surely a code smell. Most often, this issue is caused by relying too much on entities even when DTO projections would suffice. That's because a deep-level graph of entities will eventually lead to many secondary queries or even [N+1 query issues](https://vladmihalcea.com/2014/02/01/how-to-detect-the-n-plus-one-query-problem-during-testing/). Although convenient, fetching entities is always going to be less efficient than fetching just the right amount of data you need for a particular business case.
Looked at JMonkeyEngine a few years ago, but the installation kept screwing up (early days of Windows 10, so nothing unexpected really) so I moved on - this topics certainly piqued my interest again, always good to see what can be done. FYI your link to JMonkeyEngine has the brackets the wrong way round, so it's probably not appearing as you want it to.
I spent the better part of last Friday testing Java Lambdas + API Gateway, and couldn't, for the life of me, get it to return a body. The documentation is usually for Node and outlines how you need to ensure that the response object contains a "statusCode". Based on your source, I'm now thinking maybe the statusCode is an implied 200 if it returns, since you're not manually creating one. I think the secret here is that the getter/setters are required (which makes sense; I just dumbly hadn't considered it). So thanks for sharing this. It's definitely going to help me get past the hurdles I've been fighting.
JMonkeyEngine is okay for higher level things, but the IDE suffers from its parent IDE it just feels slow and bloated... I've notice (without the need of benchmarks) that libGDX 3d physics looks smoother and more fluid The disadvantage is the libGDX comes in at a lower level, but then I don't see that as a disadvantage...
The SDK (the IDE based on netbeans) is not developed any more and the developers have focused on improving the engine itself, to be used as a maven/gradle dependency. The physics engine is pluggable and can be replaced by Dyn4J or your own if you want. Personally I use eclipse and scala for my hobby projects, never used the SDK for more than transforming assets into jme's own format.
You actually need to go to the API Gateway page, and configure the function that triggers the lambda to have the correct response body mapping in the method response. Also the setters and getters are required since Jackson is used to parse the object back as json data. Final point make sure you publish or 'save' your edits when you test the api gateway.
Yea yea. There's a little twist though: You can't interate on Java language features due to backwards compatability , resources and the community. As I said look at how we are stuck with the rushed Generics from Java 5 until now (some minimal superficial changes happened. Hopefully getting reified generics with Valhalla). With community I mean that in Java you need to get it right at the first moment otherwise it will have a bad image forever and noone uses it and will therefor not be improved later. &gt; Fail and fail fast, people don't have time for you to plan the world....still fail....and then fix it. sounds like: &gt; Weâ€™ve seen some ecosystems diverge from this, leading to new challenges that ultimately had to be reversed. A great example can be seen in the â€œtragic mistake from npm creators,â€ which was to launch without a namespace concept. Eventually, NPM started running out of useful names and had to backtrack to introduce â€œscopes,â€ which is really just a namespace. The real problem here is that the major change in namespace was backed in after several years of momentum without it. Itâ€™s taken a long time for tooling and best practices to catch up to scopes and, in the interim, people have been left with a dual mode â€” a "some namespaced, some not namespaced" situation â€” that has created chaos.
API's are not language features and nowadays EJB's are frowned upon even if they supposedly have improved greatly. Noone cares. They should have gotten it right from the start.
A side note: Someone recommended [Delver](https://www.youtube.com/watch?v=D3TilUaMT_o) on Steam Early Access recently and I must say I agree. It's quite enjoyable. Though the difficulty is extreme.
No discussion of CompletableFuture/CompletionStage?
java has had coroutines since 2006-ish- check out [my fork of kilim](https://github.com/nqzero/kilim) and quasar simple imperative code that scales to millions of green threads
And why?
thnks for the share. 
Node is stable and the de facto choice now. This is old news Edit: seriously, people generally couldn't care less about jigsaw 
A three year old article but the compile error in the second line of the very first example still isn't fixed.
&gt; Unironically believing this.
Going to give you an upvote on this. The performance, organization, flexibility etc that you see with Node these days is amazing. There's a reason it's used by so many companies now. The idea of a module system being radical and hard to implement is very strange.
A convenient feature in the new process API is the ability to run code upon process termination. This can be done using the onExit method in either a Process or a ProcessHandle, which returns a CompletableFuture. Process process = Runtime.getRuntime().exec(command); process.onExit().thenRun(() -&gt; { System.out.println("Finished!"); }); Also read this: http://123projectlab.com/interview-questions-with-answers-on-java-vol-1/
nice information. thanks for sharing!
A 100 times out of 100 this. The 49 lines of java code could be replaced with a few lines of python/awk/perl/php/whatever, java sux at regex/file processing
There are some reasons why Java might not be the best choice for game development, and that's what "everyone" is telling you. However, if you can arrange yourself with Java/the JVM's downsides, you can really achieve high end graphics. Although I like jMonkeyEngine, I tend to say that you can achieve far more with a custom engine and high end render paths. I didn't find a single example with jMonkey where I say "yea, CryEngine ahead". That's why I (one person) started developing a custom Java based engine for fun in my spare time, implementing high end rendering techniques such as Tile Based Deferred Rendering, Voxel Cone Tracing (Global Illumination completely dynamic in realtime!), HDR Rendering, Volumetric Light Scattering and so on. Maybe someone want's to take a look at it :) https://www.youtube.com/watch?v=9UGc6gn6sXA https://www.youtube.com/watch?v=VJHYPhxJ-dg "Pushing the limits" in terms of graphics.. we are far away from it
Regarding quick fixes: we create a language for all developers, and must guide them to best practices. Don't do quick fixes because you can. Make changes for the long term. We messed up before (eg. final is not final). Regarding cycles: we cater all developers, not just application server developers, cycles are problematic, we can always add them later, there is an API that already allows it (post-resolution) Regarding module primitives: This JSR isn't about creating a meta-module system, we probably used the wrong primitives, so exposing them would hurt us now. We can always do it later. Regarding module isolation: We believe in the reverse-dns approach already there. Problems will be resolved by library maintainers. We tried isolation and it broke a large set of external libraries. If we don't do it, we can always do it later. If we do implement isolation now, we cannot go back if it is bad. Basically, be defensive with your changes. Make reversible changes. Think long-term, not easy fixes. You affect millions with the decisions we make. It's a really good reply, thinking about the long term and survivability of the Java ecosystem. You should read it. 
This is what reading a JavaScript thread in /r/programming feels like 
&gt; FYI your link to JMonkeyEngine has the brackets the wrong way round Actually the brackets are right. The problem is that the URL has to begin with either "www." or "http://" to be recognized as such.
Be sure to stretch the text area (what a wretched UX) at the bottom to see all of the comments in the vote log.
This just got interesting.
Looks really good
[Here's a meme](http://i.imgur.com/IHvePre.png) to illustrate what's happening.
Are you saying that the class should be like following ? class Customer { List&lt;Address&gt; addresses = new ArrayList&lt;&gt;(); public Address getAddresses() { return addresses; } public void setAddresses(Address address) { addresses.add(address); } } 
He probably meant, that the reference is final but the value is not immutable.
 grep -A 10 "Exception" README.txt Why the heck would anyone write a program for this.
Yeah. In the other thread somebody said that the comittee did a good job and that they should try again and "get it right". I laughed at that. No one will get it right, not even this Mark Reinhold guy. But Reinhold is realistic enough to understand that they need empirical evidence to not fucked it up really bad.
I would go with the simplest solution that works and meets your requirements regardless of whether some people think it is bad. If it makes your code base simpler and there is not a performance problem in your application then why add a bunch of extra work and complexity?
It works just fine on a developer machine which has only a fragment of the whole production data and entails no concurrency due to multiple users trying to accessing the application. Also, if you have an application with just 10K records in the DB, you won't probably notice the performance degradation of OSIV. But if data accumulates and you have 10M records and tens or hundreds of concurrent users, you will surely bump into problems related to OSIV. If you don't believe me, just read [this post](http://www.dagblog.cz/2017/03/papirova-skalovatelnost-bcrypt-ladeni.html). You can use Google Translate if you don't speak Czech.
&gt; but this tide of "no" votes makes it obvious that they're not alone in their concerns. It could be simply a matter of companies trusting other members of the EC who have a vested interest in the topic, and not an independent confirmation that the complaint is valid.
&gt; grep will only work on live logs.. and -A is not a valid option Both of these sentences immediately disqualify you from the topic of "searching through files". 
&gt; grep will only work on live logs What does that mean?
You... you're joking right? Or trolling? I mean... do you really think most people default to Node?
Please don't be salty. 
You must be doing stuff I've never heard of. Never met a log I couldn't grep.
As I said use the simplest solution that works and meets your requirements. If you are writing an internal business application that will never have 10 Million records and hundreds of concurrent users that you are fine. That is the vast majority of software development.
What is the reason that Pivotal does not include JSF in Spring Boot? They include, for example, another web framework - Vaadin.
Unfortunately, OSIV is [enabled by default in Spring Boot](https://github.com/spring-projects/spring-boot/issues/7107).
In fact, many of the explanatory comments posted with the 'no' votes said that they wanted the committee to have more time to resolve the problems and that they were not votes against the proposal itself. 
The JSR 376 proposal states : &gt; This JSR will define an approachable yet scalable module system for the Java Platform. It will be approachable, i.e., easy to learn and easy to use, so that developers can use it to construct and maintain libraries and large applications for both the Java SE and Java EE Platforms. If it fails to meet the stated goals then it should be rejected.
As it stands that JSR would impose many rigid rules incompatible with the current practices. Once introduced it would mean that projects that adopt it would become backwards and forwards incompatible with projects that don't adopt it. Since the vast majority of libraries won't be immediately updated, this would force most people to stay back and not upgrade. This would be a disaster akin to the python 2/3 split. I'm very worried about this JSR and hope that it is finally rejected after the 30 days delay, as I don't think such a short delay is sufficient to address the serious unadressed concerns.
That is a fairly old post, which has bee discussed here already. Why would you repost it?
At least now the poster knows why that happened.
Google: java real time systems robotics
For hard realtime robotics you can use Java Realtime with the most capable VM being [JamaicaVM](https://www.aicas.com/cms/en/JamaicaVM). For non-realtime robotics you can use Java SE Embedded or Azul Zulu. You'll probably end up needing libraries for device I/O as well. PureJavaComm seems to be the best option as of today. There are Raspberry Pi specific I/O libs. A couple of people (Including me, twice) have done things with CAN but there's no common public solution.
A [link](http://directory.apache.org/fortress/) for the lazy..
Benchmarking is hard. Be careful drawing any conclusions from this. * How was the timing performed? I see no timing code. * A 1GB file is not very large. * How did you minimize the impact of the OS disk cache? There is a good chance that for some (all?) of your benchmarks the file was already cached in memory. * Some of the benchmarks are printing to stdout (did you direct stdout to /dev/null? a file? a terminal?) this can greatly impact the time.
Thanks for taking time to provide your feedback * I already pointed out timing taken by each method * Agree about file size, but I believe for normal application(until we are dealing with big data analysis), 1GB is a good point to start) * Thanks for this pointer, I haven't taken OS disk cache in to account for testing. * Agree, I did other test while reading file and at same time process it and write to other service,will publish my results in another post. While checking these performances through VisualVM, I have omitted (threads CPU usage etc,) few details to make this post simpler. I am fully agree not to draw final conclusion from these results, but I believe this is a good start point.
I'm used to the world where if all parts of the file are on the same disk, you've already failed. You need a splittable file format (and newline-delimited text is sufficient) and multi-disk (and preferably also multi-node) parallelism. It also helps if the file is already in (distributed) memory â€¦
He could always tail log | grep
None that I know of!
Best website to learn Java, Spring etc.,.......
This question might be a better fit for /r/learnjava or /r/javahelp. There isn't really a single way to develop a program, though, so it depends on how you approach it. Usually, you want to get something on the screen as soon as possible and then work up to actual gameplay.
Thanks, will do.
Maybe your team is more familiar with the Spring Ecosystem or is more productive with Spring in general. And sometimes it is just a business decision and forced upon the developers. Or they want to migrate the software from one platform to the other one.
True, but I was assuming we were talking about a beginner project and not a professional game engine. I wouldn't write something completely from scratch if I was developing a professional game.
I use IntelliJ development tool. Seem this code analysis is performed on the fly in that IDE. It uses color coding and light bulbs to direct my attention to code improvements. I'm I missing something? 
Read the email. Reflection can change finals.
First Robotics Competition robots can be programmed in Java, C++, or LabView.
Nothing I love more then finding the top Google link for my issue is a closed SO question, yet the responses posted before the close are useful, wonder how much better it would have been had it been left open. 
Indeed. See FRC Java Programming [here](https://wpilib.screenstepslive.com/s/4485/m/13809).
Yes. There are a couple of power users that do Android apps which have to work on certain devices known to mess up class details so reflection fails.
Hey great article for those who use a lot of java inside docker. So good to know that JVM 1.8 inside Docker should memory always be tuned.
&gt; The Process does not mandate consensus, and for good reason. It intentionally gives Specification Leads broad decision powers, precisely to prevent EG members from obstructing progress in order to defend their own narrow interests. If you take away that authority then you doom future JSRs to the consensus of self-serving "experts". Oh what a load of fucking bull.
He's not saying delete them he's talking about mods closing things for "duplicate." He's saying it's ridiculous, because a lot of those answers are outdated as fuck. Have an I/O question? Hope you didn't want to use that new fancy java.nio package.
when searching with google you just need to tell google to only show pages in the past x years. then youll get all the latest stack overflow stuff
No idea why wouldn't you just use the real edition of intellij? 
IDEA Community does not support web development as well as the Ultimate version (you still can do it, but the process is not as automated), only supports distributed VCS, doesn't do auto deployment, and doesn't have support for a few languages that you probably won't need yet (coffescript, etc). Out of all of these, only the web development might be a bit of a problem for a beginner. And it can still be worked around. I honestly would go with IDEA.
Because the full Ultimate Edition costs money vs the Community edition is free.
[removed]
The reason why I'm using community edition is because it bothers me to see that Netbeans is free while I have to pay for ultimate. If Netbeans is free and can do pretty much everything from software development to web development, then why shouldn't community edition be able to do everything? I do understand that it has amazing code completion compared to Netbeans but I'm still newbie when it comes to chosing and judging IDE's.
i understand the need to keep the high volume area of SO free of cruft. however - until the usage of the tech represented by the cruft falls below a certain level, then pull it out of the high volume area and archive it as i described then you keep the conversational area relevant to current tech BUT you don't screw the poor slobs who are stuck on not-so-current tech 
Best framework for mobile development ever! &lt;3&lt;3&lt;3
You have to pay for it I want it free
Why? Can you name one advantage over Codename One? I'm looking thru the site and I can't see pricing but the Codename One free tier has more features. Pro etc. are priced (not contact us), you don't need a Mac for regular shippable apps and it's not interpreted (it's compiled). It has more traction, support for native code, third party libraries etc. I'm honestly trying to find a single feature that will justify that claim but I'm not familiar with TotalCross so maybe I'm missing something?
Reading using a byte buffer with residual should be even faster. [See method](https://github.com/juditacs/wordcount/blob/master/java/WordCountOptimized.java#L290) used to beat a microbenchmark.
So the community edition is not worth it compared to Netbeans? How about I use Community Edition for only Java and Android and Visual Studio Code for web development? Or should I just use Netbeans for everything?
If you wanted to deploy to an application server using IDE tools, then you would need Intellij Ultimate. Personally, I use Netbeans for Java EE and it works wonderfully. I have an Intellij license from just before they moved to a subscription model but I find myself sticking to Netbeans instead. It's worth trying both and seeing what you find easiest/most productive. (also worth saying that if you are a student you can get IDEA ultimate for free on a student license.)
So, the first one? Maven compatible. Yeah, I know, CN1 says that: &gt; We evaluated both Maven and Gradle extensively and we think they are both unsuitable for mobile [Facebook post](https://www.facebook.com/CodenameOne/posts/122891011204412?comment_id=585378308289011&amp;comment_tracking=%7B%22tn%22%3A%22R3%22%7D) containing that commment. But, c'mon, Maven just turns things way easier to do stuff. So far, the dependency is already in the TotalCross artifact repository. There is no plugin **yet** to build, but it is under way; and those people offered a workaround for that. TotalCross, under the development hood, is just a normal jar file. It does not need to install a plugin to run smoothly, just run it! Creates your own `main` like [this one](TotalCrossApplication.run) from their GitHub example and let it run. TotalCross works with Java 7 sources and class files. It has some missing APIs, but staff is working to fill the holes. With the exception of `invoke dynamic` bytecode stuff and those missing APIs that are being covered, TotalCross does not need to downgrade the code to Java 5. While there is no support for `invoke dynamic`, one may use lambda-expressions with [Retrolambda](https://gitlab.com/totalcross/TotalCross/wikis/retrolambda). It is a for-now, as it is intended to rise the Java compatibility to Java 8. Also, it seems that Apple isn't really happy with JIT. See these links: * http://stackoverflow.com/a/39189193/4438007 * http://stackoverflow.com/a/5109442/4438007 * https://news.ycombinator.com/item?id=10441571 TotalCross uses a private file format called TCZ to hold a binary representation of code and data, loosely based on [VERA](http://livros01.livrosgratis.com.br/cp040038.pdf) (sorry, could not find VERA reference in English). After creating those TCZs, the next step is to create the application executable, which is transparent for the user. This process is intended to be in a way that AoT will be used. Also, running the TotalCross VM over the TCZ is smooth. There are some big applications that runs on WinCE, Android, Windows Desktop, iPhone and iOS with great performance (no hiccups). This being said, note that it does not have a production AoT yet; imagine when the staff releases this feature? To deploy the app to the AppStore, it is needed an Mac =( I don't know for CD1, though. To deploy in-house and ad-hoc, well, TotalCross users are Mac-free. To test applications in the device, one of the most used ways is to upload to [Diawi](www.diawi.com) and then install wherever it is intended.
I would definitely prefer the community edition over Netbeans. I did some large projects in both Eclipse and Netbeans, and they simply did not cope as well as the IntelliJ products did.
You can still use IDEA for everything. In Java you live in your editor. [Here](https://www.jetbrains.com/idea/features/editions_comparison_matrix.html) is the full comparison matrix between both versions of IDEA. Not supported just means it doesn't have code completion, analysis, refactoring, etc.
&gt; Says who? Says a 1 hour old account in the second post of another one hour old account. I guess that's totally a coincidence.
if you're a newbie, then don't waste time with netbeans, you'e not going to need ultimate anyway, because, you're newbie
if they don't have time to invenst into it, than there is no reason that these "experts" have a vote.
"Asynchornous Server Socket Channel" do you mean...
Why they are arguing about this Jigsaw issue right before the release ? ?
Fuck sakes this should be the top answer. WHAT'S THE MEANING OF LIFE GUYZ?
Yep, just an enthusiastic develop 
Yep, per the text on the top of the jdk archive download page: &gt;Downloading these releases requires an oracle.com account. If you don't have an oracle.com account you can use the links on the top of this page to learn more about it and register for one for free.
The point is that this only applies to older, discontinued releases, and it's not a new requirement.
You can use Java 8 with the current Android toolchain
The JDK version and language version are not the same thing. The Android toolchain requires JDK 8 but since javac crosscompiles it's not a problem to emit Java 7-compatible bytecode.
I second this request. There's a few specific things I would love to be able to do in my fave IDE..
Grandpa it's not 1999 anymore go back home. Kidding I didn't realize you could do that. I target the latest version in my IDE. I actually don't think I've ever used javac directly. 
&gt;Also due to control over what gets into their own library so they don't have to deal with me ;) Respectfully, what do you mean by this?
[removed]
This does not contribute anything to the discussion and as such it is off-topic. **Removed**
PMD provides a huge number of checks IntelliJ doesn't provide, e.g. Cyclomatic Complexity.
You're doing an excellent job at not explaining at all what "Total Cross" is :)
Thank you
Thanks for the article, i find those recipe-like posts extremely helpful. For Many-To-Many associations, though, my recommendation has always been to map them as OneToMany/ManyToOne and create an entity for the join table. In my experience, those tables almost always grow more attributes. In your example, if I wanted to store when the post was tagged and who tagged it, I'd have to go down that route anyway.
That's true. I'll write about that in a future post.
Manual dependency injection
I guess this is a joke.
I rather use ebean
Fantastic article. You sold me on learning a new language. 
Awesome, Thank you! :D
Proper IDE being the key word. Intellij is a lot of things, proper isn't one of them. And the productivity one loses with intellij makes it a very expensive proposition.
Doesn't Java9s [Flow](https://community.oracle.com/docs/DOC-1006738) API largely replace Observables?
Nice. I am choosing between Kotlin and Scala, still have to do lots of research. Have you made such a choice? If so, why Kotlin over Scala? 
&gt; Observables kinda of and I think Observable was never used to that extends so deprecation shouldn't be much of an issue.
It was never used to that extends so it's not a big surprise, in any case Java 9 is coming out with so many breaking changes so may be many things you are aware of might go away with Java 9 :)
You count from 1, you offset starting with 0. Damn kids numbering lists starting with 0.
I'm interested in this too. Looking at many of the examples it basically looks like scala to me. Why Kotlin over scala?
I really like kotlin, but all this articles are almost the same, showing the same features of the language... 
My experience with Scala is unfortunately limited, but I know that JetBrains drew inspiration from Scala when designing Kotlin. [The 3rd result](https://agilewombat.com/2016/02/01/scala-vs-kotlin/) when googling 'Kotlin vs Scala' had this to conclude: &gt; One of the best part of the Kotlin language for me is not the features it has but more the features from Scala that are not in Kotlin &gt; &gt; * Call by name â€“ This destroys readability. If a function is being passed its a lot easier when its visible that its a function pointer in a basic review of the code. I donâ€™t see any advantage this gives over passing explicit lambdas &gt; * Implicit parameters â€“ This is something Iâ€™ve really hated. It leads to situation of code changing drastically based on a change of import statement. It makes it really hard to tell what values will be passed to a function without good IDE support &gt; * Overloaded FOR comprehension â€“ To me this is a clunk to get around the problem with dealing with multiple monads &gt; * The mess with optional syntax on infix and postfix operators â€“ Kotlin is little more prescriptive and means that the code is less ambiguous to read and not as easy for simple typo to become a non-obvious error &gt; * Operator Overload to the Max â€“ Kotlin allows basic operator overloads for the basic operators (+, â€“ etc.) but Scala allows any bunch of characters to be used and it seems to have been embraced by library developers. Am I really meant to remember difference between â€œ~%#&gt;â€ and â€œ~+#&gt;â€? &gt; * Slow compile times That's just one guy tho, not the full story...
Genuine question: Why do some of you hate JetBrains?
About damn time.
Second that. I love writing SQL and it is a quite flexible library. 
Yeah except it's not better than Java and I could never find enough devs to use it outside personal pet projects. So yeah... nah.
Nice article. Thanks. The last half really reminds me a lot of Groovy... but maybe even better.
So many people are promoting this language. Who is sponsoring you all?
&gt; dynamic typing Kotlin is statically typed.
Yes, Observer and Observable are some of the more pointless interfaces in Java. Kevlin Henney used them as examples of bad implementations of design patterns in Pattern Oriented Software Architecture. 
haha, I guess my need for spreading the word comes from the fact that I want to code Kotlin at work too.
My understanding is that doing this would require dissolution of the JCP. That is within Oracle's power, but there would be significant downsides in terms of 'optics' as the politicians like to say.
there are three main Java IDE's and there are cult followers for each of them. * [Eclipse](http://www.eclipse.org/) * [IntelliJ](https://www.jetbrains.com/idea/) * [Netbeans](https://netbeans.org/)
I have no idea what GUI tool you have in VS, but for javafx there is JavaFX SceneBuilder. Though, personally I don't see the advantage of using it since creating an UI in java with either Swing or JavaFX is a very straight-forward process. About ORM: I had the "pleasure" of working with .NET (C#) in the last 6 months. Let me tell you something about the .NET ecosystem in general: It sucks. It's handicapped. Compared to Java, the .NET ecosystem (package versioning, build system, web-framework, ORM, security library, etc.) is like a starving child from Somalia when compared to a well-fed, healthy western boy. It's not even funny. IDE-wise: Visual-Studio is a fine IDE, however. In the java land you have quite a few more choices: Eclipse, Netbeans, IntelliJ (yuk, but some prefer it), plus a bunch of smaller ones. 
Yeah, when talking about programs I think it helps to try to say "at index ...", rather than ordinals 1st, 2nd, 3rd. tl;dr: "the 4th item is at index 3".
Surely there must be more to the language. from this article is not clear on "why should I choose it?" "what does it have that java doesn't?". From the features exposed in the article, it's at most a "meh, whatever" language. 
You can read the code submitted in Techempower Github for which code have an impact on the performance. We aren't sure why some framework did not completed for some reason.
As a Scala dev, let me give you my two cents. Kotlin appears to be trying to move into the position of being a "better Java", while idiomatic Scala embraces functional/object-oriented multiparadigm programming with very strong, statically typed guarantees of code correctness. Many Scala libraries and techniques emphasize catching as many problems as possible at compile time instead of runtime, which puts Scala's long compile times into perspective. Kotlin's also a much more recent arrival, that hasn't proved it will stick around (AKA not turn into Coffeescript) and doesn't have access to the same breadth and depth of libraries as Scala. Of course, both languages can use Java libraries, but Scala now has a number of Scala libraries designed for idiomatic use that you can draw on instead. AFAIK, there is no Kotlin equivalent of Monix, and I'd be hard-pressed to do my job without it. It might surprise you, but I'd say that if you're not sure which to use then you should probably go with Kotlin (or good old Java). I personally feel that Scala is a fantastic language that I'd find hard to live without, but it's also somewhat of a shift in perspective from Java, so if that's what you're most familiar with then Kotlin will be easier to adopt. But if you're hungering for learning a new programming paradigm and like the idea of strong compile-time guarantees of correctness, stop by /r/scala sometime and check it out.
&gt;I don't think you can go wrong which you choose unless you choose Scala and don't have a style guide and best practices. Yeah, get Scalastyle and Scalawart set up at the beginning with strict rules, absolutely. Kotlin doesn't have pattern matching and case classes? That's funny, since Brian Goetz seems to be trying to get both features into Java 10. I assumed that it would be high priority for a language that tries to be Java++, strange that they didn't implement them.
I'd like to add some advice, if you choose Netbeans or Intellij, still familiarize yourself with Eclipse. There are certain plugins/tools that aren't available. My favorite is a (commercial) diagram generator, Intellij doesn't have a good equivalent.
I'd argue IntelliJ is the defacto standard.
Netbeans is good and easy. Eclipse is more common and extensible. Intellij is very popular too. Intellij has food vim emulation, but it's GUI builder sucks and it eats memory. Eclipse depends on which plugins you use, but it has my favorite debugger. Very much based on your plugins, some are varying quality.
These charts can be a bit misleading. 1. The tests are somewhat contrived. This one returns a plain text response of "Hello, World!" 2. Relative performance has nothing to do with how "good" a framework is: Spring is very low on the chart and therefore appears to have poor performance. However, this shows that with the given configuration, Spring was serving 128,577 requests per second. Most people will never reach 128,577 requests per second, and therefore the performance of something like Spring is "good enough". The other benchmarks that do database queries will have more accurate numbers, but still anything that can do hundreds or thousands of requests per second will suffice for most use cases.
Interesting. I wonder how it compares to the OWASP plugin: https://www.owasp.org/index.php/OWASP_Dependency_Check https://github.com/jeremylong/dependency-check-gradle 
Ye, I was afraid that some of you might feel that way. This post is aimed at those yet in need of introduction 
I just do it because it's an awesome language.
maybe just exclude that class from import?
Really? I know JUnit well, but I prefer TestNG. But what does this have to do with the topic? Debugging and writing good tests are two different things...
I've seen too many people try to be clever at the cost of maintainability..
alt https://en.wikibooks.org/wiki/Java_Programming
Ditch eclipse and go with IntelliJ idea, and never look back. It's build in debugger is solid, and overall me and the rest of my company have found it to be faster, more stable and more usable. 
https://www.jetbrains.com/help/idea/2017.1/customizing-views.html#d827178e66 https://www.jetbrains.com/help/idea/2017.1/debugging.html
Also if your really struggling with particular collections, of all else fails just use something like Collections.toString() or GSON/Jackson and get it into something human readable to figure out where you stuffed up. Don't forget to remove the output afterwards!
heavily inferred static typing with guaranteed type and null safety.
Documentation in what sense? Rest Api? Java?... On a personal note, why Liferay? The portlet spec is terrible, and Liferay is an awful tool. It's basically wordpress for java. I had a govvie job a little while back that used Liferay, and I'd just embed spring boot apps in the portlets and call it a day. Fighting with the Liferay apis is terrible. You can build a java app that is equivalent to anything Liferay offers with 60% less code... but, ...I digress, (ptsd kicked in for minute)... that's just my experience... What kind of documentation are you looking for? 
Try with resources? Really?...
Intellij Idea is about as close as you're going to get. It's funny that the best thing that M$ built is an IDE.
Properties are a nice QoL improvement over writing getters/setters, data classes too.
It's almost Groovy with types.
`setAddresses` accepting a single argument, and then mutating global state? That's an awesome idea! Do you have a site that holds credit card information, I want to sign up! 
magicks makes it complicated.
I know it's a minor thing, but I hate name before type syntax. I wonder why they made this design decision, especially if they were trying to keep familiarity with Java?
Api design 101... make it Magick so only you can use it. Lolz
there so many different options for anything, I don't miss it. Progress of my programming philoshophy: noob -&gt; spring -&gt; fuck frameworks
Cool, thanks for the information! The OWASP plugin can take quite a while to run its checks, especially the first time that it runs or if you haven't used it in a while... I guess it takes a bit of time to download all the files and parse them. It'll be interesting to compare the performance side of things as well.
I... thought these had been deprecated for decades.
And here begins the natural selection process of engineers to be.
Trying to generate word and pdf documents from liferay data. Agree with your views on Liferay.
It allows for you to omit the type for type inference
Snooze
In what ways does it beat IDEA in features?
auto x = 5;
i did quite a few times back in 2008-2010. fine language, nothing wrong with it, but just as kotlin: meh. not really much of a reason to bother. there are languages that do bring new things (scala), new way of looking at stuff, but others (groovy, kotlin) just seem to bring syntactical sugar. with an IDE, that sugar is not that relevan anymore.
in ... every way? try to think about a thing that it doesn't beat IntelliJ in. good luck.
Reposted in r/javahelp. It needs to be in one project because that was what was asked of me. Copying and pasting is my fallback plan, but it's not very convenient. I was hoping that there would be an easier way to handle this.
Just taking a guess at why others might not like IntelliJ. Personally, I use their products. 
The thing is the community edition is free and open source
Agreed. I'd seen Kotlin integration in IntelliJ but never thought to look in to it. Will have a go a writing some stuff shortly! 
Yes, to all your points above. But simple sitting around the table ain't going to cut it this time. 
It's _obfuscated_ C code. Good luck, have fun!
Choose Clojure. 
&gt; you owe it to _mention_ (...) Scala Why? He's not talking about JVM languages in general, he's talking specifically about Kotlin. The first line is "I want to tell you about (...) Kotlin", why would he _owe_ to mention anything else? 
As far as I can tell pattern matching is realized with the when-expression. And case classes are data classes.
No one is sponsoring me (unfortunately). As an engineer, any now and then I try a new technology/framework/language. I have been mostly programming in Java for 15 years. One day I gave Kotlin a try, and I got completely hooked. Kotlin is better a Java, in all aspects. Kotlin might be just syntactic sugar over Java, but it is a lot of sugar that when put all together really makes a big difference.
Did you try eclipse options? - there's "inspect" to evaluate selected code and show it in a "tooltip". That's probably the best way to see value of something. On windows it's under ctrl+I. I didn't find any equivalent in IDEA yet :( - there's "display" panel where you can write code and evaluate it. I really miss it in IDEA, they have it as a popup, you lose your snippets when it's closed and you can't evaluate only a part of the code there :( - you can define formatters for everything (basically override toString implementation). - you can switch display of collections to one that understands their structure (and does not show internal objects, but e.g. just expandable indexes in the case of ArrayList) 
Poor article. So hibernate using jdbc to communicate with database... Of course if you looking for some sql generation tools with some out of the box improvements hibernate will help you, but many other mentioned here technologies will. JDBC used properly will be the most performant way to connect to db and any claim that hibernate is more performant than JDBC is wrong. 
Maybe rent some cabins in the wood for everybody? Make it like a summer camp, put people from different companies into the same barracks.
could you give suggestion what should `Customer` class be ? giving an example would be very helpful. What I have top of my head is that , there should not be any `setter` method. List of address should be initialize with the constructor when the object instantiate. Even in getter method reference should not be pass. First copy then return that copy of addresses. Instead `UnmodifiableList` can be used. 
Autocompletion, intentions, and Maven integration are definitely much better IMO.
surely you must be joking. eclipse's autocompletion works perfectly fine (this is java i'm talking about, i use other IDEs for C++). IntelliJ (i used it for a while) I know it tries to be smart, so that's what you are probably referring to, but 9 times out of 10 it was a PITA. The entire idea of autocompletion is to save me keystrokes, IntelliJ seemed to want me to type more. autocompetion is not in intellij's favor.
optional as a way to work with nullables. yes, you don't have compiler support like you do in kotlin, this is why i said it's more of a meh. yea, it's nice, but meh ... i wouldn't change languages on that alone. Not to mention that the language is only supported by intellij tools now as far as i know, and the prospect of having to use them again is not appealing at all.
you are joking, right? i know it tries to be smart (i used intellij at times), but 9/10 it just gets in the way.
Tool is preferred option as cuts down development efforts and time. If I can't find one, will go with apache poi.
It's dead to me.
In eclipse you can right click a file. Refactor-&gt;move and then choose a new project/package etc.
Was wondering what can it be used for, but they answered that question: &gt; What is it good for? &gt; &gt; I'm not sure yet. It's certainly excellent for simple command line utilities.
was it ever alive?
(nothing to do with JVM) -- It's just that every one of OP's points is equally supportive of switching to Scala, which currently has much wider popular support. So OP could say "here's reasons to use Kotlin or Scala, and here's extra reasons why Kotlin in particular is preferred", or even just "here're great reasons why Kotlin is great ... btw Scala does all this too, but I prefer Kotlin for reasons not mentioned here". It'd be like, during the reformation: "Hi Catholic -- don't like the doctrine of original sin, a strong focus on Mary, and rules against interpreting the bible yourself? The clear alternative is [Swedenborgianism](https://en.wikipedia.org/wiki/The_New_Church#History)!" (when Presbyterian and Lutheran churches also 'solve' those all those particular issues equally well ... it'd be *fair* to mention that as well). Not saying OP needs to defend or compare -- but it'd be fair to point out to "potential converts" that another, currently-significantly-more-popular language also is an answer to every single point being made.
The Fortunes test does not write anything back to the database, it only reads from the database and dynamically adds data into what was read from the database. The Data Updates test does both reading and writing. [Test Requirements/Details](https://www.techempower.com/benchmarks/#section=code) 
Spring boot is the route i would go. Easier to maintain just the app rather than the app + app server.
I know how to command line debugger for c and Java... Doesn't mean that using the ide debugger isn't a nicer faster experience.
Thanks, that makes sense. Would you use a templating system like Thymeleaf for the views? What I like most from JSF is Primefaces, it provides a lot of great UI components like the Datatable component without requiring any custom Javascript. Is there something similar to Primefaces (the look and functionality provided by it) that one can use with Spring?
I know this is not what you asked, but: Do you have to rewrite the whole thing all at once? It might be safer and cheaper to add some JSON endpoints to the perl backend and write a modern SPA that uses them. With that experience you'll know what the backend api needs to look like and a rewrite in java (if it's still needed) will be easier. As for tech, the tooling for typescript is pretty good and it's little to learn when you already know js. Removes a lot of pain with larger codebases.
if you were curious how it will make it easier to scale: right now the JDK comes with a wide array of packages. until recently, those packages had tons of cyclic dependencies and other messes within them, so it was impossible for a program to say "i just need System.out.println, only load that on the classpath". you still can't go that fine-grained with jigsaw's JPMS, but you can say "i depend on java-core" and only get a small subset of the JDK. this means faster startup times for java programs as well as a few other things. of particular note is how the new module system lets us hide classes on the classpath. until recently, if you had a factory, an interface and an implementation, you'd really only want to expose the factory and the interface, but it was tough to keep people from accessing the implementation directly. Modules let you say "I only want to export com.foo.x", and while com.foo.Y might be loaded on the modulepath (the new classpath) with the module, it is not visible anymore.
Nope. Pretty sure he's working for the Kingpin now.
I have to ask - why write your own solution? Is it not possible in 2017 to find standard systems which fit the requirements?
In English we say ' integer x' and not 'x integer'. As long as scala and kotlin continue to be smart ass, java will dominate. 
So you have learned every technology in the java world and felt that that was not enough? The thing that was missing from your life was some syntactic sugar? 
you could do this with Hibernate+Spring MVC+JSP in much less time. React/Vue/Whatever buys very little save for some flash. why go the trouble of separating the view and model with REST if the services wont be consumed elsewhere? this seems over engineered and a little too trendy.
depends on what kind of talent you have or can acquire. here, you can throw a rock and hit someone with Spring MVC experience, so i generally recommend that. It also supports templating engines such as Thymeleaf and Freemarker. i'd suggest not using JBoss, as it costs money that you could spend elsewhere and provides no benefit. Tomcat or Jetty are fine for 90% of webapp use cases.
It's no different than having a library for which you dont have the source code.
&gt; It might be safer and cheaper to add some JSON endpoints to the perl backend and write a modern SPA that uses them. They're using ActiveX because Perl couldn't do the job, and thus the dependency on IE (+compatibility mode), which they are trying to move away from because in true Microsoft fashion it runs like shit. So if you're gonna rebuild, start over from the beginning and do it right. The only tech I would avoid is MySQL because Oracle - Postgres runs like a champ. Thymeleaf is great way to go with Spring Boot. If you're programming for Linux, dev machines should be running Eclipse on Linux - get VMWare workstation for that, and now you can have dedicated test environments. If you have all that, then your front end can be relatively trivial - Bootstrap 3 + JQuery is great for both workstations and touchscreens.
So far, every great empire has fallen. One day, github will die, too. It's a scary thought, as every time any of the great houses falls, there's a scramble. So far, google code, sourceforge, java.net, kenai...
Excellent, thanks for the detailed reply. Much appreciated. I will look into Postgres. Also is VMWare Workstation a lot better compared to Virtualbox?
You can step into it but you can only use those libs that are exposed to others. See OSGi for reference or other module systems 
For a business app you could also consider a JavaFX client. What we did was have a JavaFX client using the built-in browser as well as our web application. This was to deal with specific browser issues like printing. 
It can fail the build if you add a violating segment of code, alerting someone if they've introduced an issue. Adds a bit of enforcement that extends beyond the developer's choice of IDE.
You are right. Fortunes test is readonly from database and using a template to output a web page. Light-4j didn't do very well in db updates as I learned too late that batch update is allowed. Thanks for pointing it out. 
I would go with Spring-Boot + MySQL for backend and ReactJS for front-end. We are doing the same ourselves
for A, I would say we do it a lot. I, for one, work mostly on the backend side of things and rarely touch html / javascript / css. On the other hand, the view layer has changed significantly over the last year (switching framework from something that I don't remember to angular and now something else). The mobile client has evolved but not as drastically. I completely agree on B - it is easy to over engineer and make things very needlessly complicated. However, the main UI guy sits literally by my side (one of the reasons I should know more about the UI but that is another story) and we work closely together. We do have another team that is located in another city (writing another type of client), so having a stable rest API that they can rely upon is really important. All in all, I would say it depends a lot on your environment, but it works really well for us.
I wouldn't say it did bad, it was way above the median, there were just a couple of outliers at the top that make it look a little bad % wise. But as the [/r/scala](https://www.reddit.com/r/scala/comments/6ala1n/the_thechempower_benchmark/dhgb64j/) thread says, the tests aren't that great for real world performance anyway. There may some of the top libraries (in terms of results) that are optimizing for benchmarks instead of real world performance anyway. 
If we're using `var` and `val` anyway, then those become the auto when you choose not to use a type. val x = 3; None of these answers are super compelling to me except the readability one when long types are specified. For that case, I'm not sure which would be easier to a novice user to understand. All I can say for sure is that the extra colon character needed is very ugly and IMO cognitively cumbersome.
When you tell people to try this new burger place that you like a lot, do you tell them about Wendy's too?
I'm not sure about VirtualBox vs VMWare, so it'd boil down to features vs cost.
I totally agree with you. Some of the frameworks are just optimized for these tests only. Also, these tests are not addressing security, service to service calls etc. I am trying to create another benchmark that focuses on microservices only. Still in early stage. https://networknt.github.io/microservices-framework-benchmark/ 
Could always use percona or Maria 
Show management how many of your bugs are caused by NPEs.
If you have the hardware and dont mind server side generated pages. I would go weblogic and jsp/jsf. It just looks better and loads quicker which could be a consern on mobile. If you dobt have the money for the hardware then i would go the spa route with spring boot and a js front end
It might be a very good use case for AWS Lambda. Currently, java has a ~30s cold start on AWS lambda. Worst if using spring (in which case you probably wouldn't want spring on lambda).
This is why I'm telling you to push back on the ask. Why does the structure of the source matter to the person requesting this? You can easily deliver ONE package with all of the application and it's libraries. If you understand how the classpath on the JVM works with JIT then you'll realize that it doesn't really matter. Dependency management is definitely a problem but it's mostly solved. Just pick your poison. My biggest concern is *why* it matters that the supporting methods are included in the same "project" at all. These are all abstractions. Basically why should it matter where source code lives and how it is structured as long as the class files are available at runtime? Either there is a very easy way to do what you want and you're asking the wrong question, or copying and pasting is literally the easiest way. (Copying and pasting is really not that hard, sure it's tedious... not sure what you expect to be "easier")
&gt; Basically why should it matter where source code lives and how it is structured as long as the class files are available at runtime? The requestor wants to have the ability to edit the application in the future, without needing to worry about the other library modules. It's not at all unreasonable; I just am not sure how to automate such a request. If refractoring is the only way to achieve this, then so be it.
Nice walkthrough. One recommendation, ditch model mapper. The performance is slightly better than dozer. Use something like mapstruct or selma for your dto mappings. They're orders of magnitude more performant. But that's just my 2 cents. Again, good stuff. People don't use `ControllerAdvice` enough, in my experience. 
This is the best, and clearest, explanation that I've come across. Thank you!
Here's a challenge for you. Write some Java code to run on Lambda that doesn't make use of Jackson. Yes, this includes the AWS SDK. I get cold start times in the 100ms neighborhood. Then add Jackson back in and it jumps to 4-5 seconds minimum. I have my fingers crossed for Lambda Docker, but I'm not holding my breath.
Make jar not war. Go embedded container and save yourself loads of grief. Also, why MySQL? Look at postgres, or maybe an object DB like mongo.
would i need to input anything prior, though? Like examples of names, fake street addresses, country names, emails, etc?
Yes you would create multiple person objects using made up data in your driver class 
Jhipster is good, I got all I need in my REST web service with Spring Boot
Lol, I like the 'make jar not war'. Based on replies from this post I looked at postgres and will go with it. Just on mobile at the moment so a bit of a hassle to edit main post. What would you say is the cause of the expected grief if not going embedded container?
Actually been using it to call something that is only implemented in Java (and therefore got made into a console application fed via the cl) from .net. As this happens rather frequently we saved quite a bit of processing time. 
Please comment on avoiding MySQL. I got the impression that people hate it but if it's good for Twitter then I think it's good for everyone.
&gt; Make jar not war You mean a fat jar, like in spring boot, right?
&gt; Expect new devs to want to provide their own macbook pros. Could you elaborate? 
The json format is *not * suited for this problem. XML is only slightly better at this (but not any easier to use). Streaming data doesn't fit a document paradigm.
ITT: developers which are familiar with their stack and simply advising with that rather than going with OP suggested options.
can you point me to any example or reading material or something. That'd be great
You can read `:` as "is a" if it helps. Superficial similarity to English is not a good metric for language design and most professional programmers are past the point where they need to relate their code back to English sentences.
Have a connection pool (tomcat dbcp is a good example) for each client to handle the connecitons for you. Have some sort map of connection pools indexed by client id, so that you can access and reuse them easily.
A few things you could do here do the conversion in the service tier, and add in optionals. 
I just had a look doesn't seem like it can handle generics unlike model mapper. I don't really want to have a new conversion for every single class when I can just have one. 
Hmm, I am not sure how best to describe the situation. I am a dev, the requestor is a dev, and the app is for an end user who is not a dev. I have a set of projects: applications and libraries of different kinds. My application projects compile to jar files that can be used as executables. However, the requestor does not just want the jar file; they want the source code relevant to that jar file. That means, they want the application source code, as well as the pertinent library source code. Once they have the code, what they do with it is irrelevant to me. That's between them and their end user. I don't need to worry about support or anything. I need to figure out a way to move all of the code that is relevant only to the app into a separate project, which has no dependencies of any kind. Then I have to send that project to the requestor. The requestor is not interested in getting all of my libraries of code, and then sorting through them themselves. They want the source code, but they don't care how it is structured - they don't mind even if all of the code is crammed into one file. However, I mind, as I take pride in my code/package structure. Thus, I want to try and maintain my package structure inside the standalone project. You are right that this is, ultimately, a silly request. However, every so often such a request arises, and does not have a simple solution. That is the reason for my line of inquiry.
i use this already but for this the file needs to be present there, what i want is to read from the file that is still uploading
JSON is fine for streamed reading. It's no better or worse than XML. It just depends on how you define your document format. The problem both formats have is you don't know if the whole document is well formed until the end. But you can know that what you have received so far is well formed.
It's one more moving part to manage, and can lead to tight coupling if you use an opinionated one. If the servlet container is just another dependency, it's much easier to change. Also, i highly recommend using a dependency management tool like maven.
Checked exceptions in Java are terrible. They are counterproductive and unnecessarily bloat code with tons of declarations and/or catch clauses. They encourage bad programming and create laziness instead of defensive programming. What's worse, is that Java's lambdas don't work with them. The Java 8 lambdas issue is so troubling that what could have been beautiful chained lambda calls is now a mess of inconsolable Runtime Exception wrapping in order to make the problem go away. By golly, Java really did a bad one there. Thankfully, most other good languages do not impose such a system. Checked exceptions belong in the deepest pit of hell. Java is a great language and has so much +ve going for it. Checked exceptions is not one of them. Just in case anyone is wondering, I think there are almost 500 Exception classes in the Java Library. It is truly mind-bogglingly-numbingly nuts. Bruce Eckel: Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result â€“ decreased productivity and little or no increase in code quality.
Something similar but different is sdkman: http://sdkman.io/install.html
Yeah that was basically my argument, except for the java 8 part, which I don't know much about, havent had much opportunity to use it at work, and have been toying with other languages in my freetime. 
Why throw when you can just return!?
Yet somehow you never see anyone actually use either. If it is such a great idea you'd think every method would be returning an Either. 
A lot of guys think the language being very strict leads to better code. That is probably true to an extent, but at least with current approaches thing get very verbose and repetitive too. 
You are mistaking java library code with java business code. While in most of *your* business cases, having an exception occur, while, say, reading from a socket, or receiving a malformed XML/JSON is equal to a crash, and should be re-thrown as a runtime, since it cannot be handled, it's not *every* case that Java has to work with. When writing a non-business, more generic code, you're often writing code that may break, and you may not be able to do anything with it on current layer. Thus, you're throwing an exception. It's basically saying "hey, something broke, and I have no clue how to deal with it. Maybe you, the guy who called me can do something about it?".
I'm primarily a C# developer and have mentioned a time or two about wanting checked exceptions. I'm usually met with groans.
Driver as a class with main method. Inside main method: Person homer = new Person("Homer", "Simpson"); // ... more info if needed Person eric = new Person("Eric", "Cartman"); List&lt;Person&gt; persons = Arrays.asList(homer, eric); // following some ways to display the persons persons.forEach(System.out::println); // provided that you override toString inside Person class persons.forEach(Person::gerFirstName); persons.forEach(p -&gt; p.getLastName()); for(Person p : persons) { System.out.println(p.getFirstName()); System.out.println(p.getLastName()); }
You could also download EAP (Early Access program) version of IntelliJ Ultimate Edition for free legally https://confluence.jetbrains.com/display/IDEADEV/EAP It may be not as stable, but it has the latest and greatest features.
Spring Boot + Thymeleaf. I discourage Angular JS or React or any other flavor of the month. JavaScript just turns your code into a pile of garbage over time.
&gt; The bad habit of catching just about everything and rethrowing it as an completely unspecific RuntimeException is easily formed and directly linked to a proliferation of checked exceptions. I disagree: that bad habit is a consequence of bad discipline, not checked exceptions. It makes absolutely sense to have every module define their own reasons for failure (i.e. checked exceptions) and propagate what they cannot handle themselves. Using RuntimeException for this is just laziness.
I've used something similar to do runnables, functions, predicates, consumers, etc with checked exceptions. I mostly use it for exception handling that should not terminate the program state, but just report an error. For example, getters that return a default value if an exception occurs, but the error is logged. Here is a little code snippet: public class Checked { @FunctionalInterface public interface Runnable_Throws { void run() throws Throwable; } public static void runExcept(Runnable_Throws tryClause, Runnable catchClause) { try { tryClause.run(); } catch (Throwable thrown) { ReportingUtilsEx.logError(thrown, "Runnable defaulting to catchClause"); if (catchClause != null) { catchClause.run(); } } } public static void runReport(Runnable_Throws tryClause) { runExcept(tryClause, null); } public static Runnable wrapExcept(Runnable_Throws tryClause, Runnable catchClause) { return () -&gt; runExcept(tryClause, catchClause); } public static Runnable wrapReport(Runnable_Throws tryClause) { return () -&gt; runReport(tryClause); } @FunctionalInterface public interface Predicate_Throws&lt;T&gt; { boolean test(T t) throws Throwable; } public static &lt;T&gt; boolean testExcept(T t, Predicate_Throws&lt;T&gt; tryPredicate, boolean catchValue) { try { return tryPredicate.test(t); } catch (Throwable thrown) { ReportingUtilsEx.logErrorMessageFormat(thrown, "Predicate defaulting to {0}", catchValue); return catchValue; } } //... } Example: Checked.runExcept(()-&gt;fooMightThrowException(), ()-&gt;runIfException())
Which you could probably handle with a retry anyway using throws, with either you just mix your error handling with your code even more, I imagine refactoring eithers is very annoying. 
I know the idea is clear, but wouldn't you want to replace the `Runnable catchClause` with a `Consumer&lt;Throwable&gt; catchClause`? Otherwise you can't log anything. Also instead of `null` you could pass a runnable (lambda) that does nothing.
[Either](https://github.com/MarioAriasC/funKTionale/tree/master/funktionale-either) allows for nice chaining though. Haven't encountered any refactoring issues yet. 
It works for me for steaming and array of objects
I wouldn't like to do the conversion from/to the DTOs in the service tier, because it's part of the domain model. The reason why DTOs are used in the first place is to hide the internal structure of the model and to provide contract to external services. Optionals are used if you look into [`UserService`](https://github.com/springuni/springuni-particles/blob/master/springuni-auth-model/src/main/java/com/springuni/auth/domain/service/UserService.java). The convention is that `find*()` methods return `Optional&lt;Entity&gt;`, `get*()` methods just return `Entity` and they throw an `EntityNotFoundException` is there is no such entity. 
&gt; A lot of guys think the language being very strict leads to better code. Compare the long term maintainability of a language like JavaScript to Java. &gt; but at least with current approaches thing get very verbose and repetitive too. We're supposed to make software better for the users; not necessarily easier for us.
no problem :)
&gt; JavaScript Pretty biased comparison, there are a whole lot of problems with JavaScript, when it comes to maintainability. And I would like to think we can have both nice code and nice products.
OK. You don't ever need to know what exceptions are thrown by something else. You only ever need to handle the contingency by defensively determining what needs to be done if something fails (resource cleanup). That's because Checked Exceptions are not the only type of exception. The code you call (method/library/Java std lib) could (and will!) also throw a non-declared exception (and they do!) such as a Null Pointer Exception, or Illegal Argument Exception or some other Runtime Exception variation. That's why nearly 99% of computer languages do not have Checked Exceptions, because the proper way to handle contingencies is by determining when anything you do requires code cleanup, and doing it if something unforeseen happens. So ... . InputStream is = ... . try{ . // do something . }finally{ . // cleanup . } This is the defacto way to do a call that requires resource cleanup. It does not matter if the 'do something' throws an exception or not, you still have to do the cleanup (close resources) anyways! There is no need to catch and rethrow because the rethrow automatically happens after the 'finally' executes. If the system is normal like any other language, the next caller in the stack will also have to determine if anything they do requires resource cleanup. Not everything does but somethings do! I should not say it again but I will ... 99% of other languages do not have Checked Exceptions! Because they are unnecessary! And they don't cover 100% of what happens anyways! I should not say it again but I will ... You do not ever need to know what exceptions something else will throw. Not even in a big 3rd party business library. Because (1) relying on those declarations is likely to be faulty and (2) your dependence on those declarations means you are coding wrong in the first place. DO SHIT -&gt; CLEANUP -&gt; LET EXCEPTIONS FIND THEIR WAY HOME = SIMPLE and CLEAN and NORMAL! I should add that some things are recoverable, so then .. DO SHIT -&gt; CATCH EXCEPTION AND REPORT or IGNORE -&gt; CLEANUP (if necessary) = SIMPLE and CLEAN and NORMAL! Anyone asking the user to input a number that then gets a letter, would think "Do I ask for a number again, quit and resume with some other user menu, or is this a reason to fail/report a problem/crash?" = SIMPLE and CLEAN and NORMAL! THAT MY FRIENDS IS HOW A NORMAL COMPUTER CODER CHOOCHES! I got CHOOCHES from this guy: https://www.youtube.com/channel/UChWv6Pn_zP0rI6lgGt3MyfA He uses it a lot. . try{ rant }finally{ get coffee and chillax} 
Another great way to create a Singleton in Java, is using Enum.
Checked exceptions are good for software safety and they guide you to doing the right thing. But programmers are lazy. That's why you see discrepancies.
&gt; But sometimes good ideas just don't work well with lazy monkey brains. That's the standard argument that is brought up every time language features are discussed. Just because someone who doesn't know how to use a tool can kill himself with it doesn't mean that the tool is bad and should never be used by anyone.
&gt; As far as I can tell pattern matching is realized with the when-expression. From what I can tell, `when` expressions are flow-typed `switch`es that can make range checks and use arbitrary expressions as conditions, not full-blown pattern matching. Here's some stuff you *can* write with when-expressions, but which are much less awkward with pattern matching. For example, here's some pattern matching the Kotlin spec doesn't seem to say I can do: def exampleQsort(input: List[Int]): List[Int] = input match { case Nil =&gt; // A sorted empty list is just an empty list Nil case head :: rest =&gt; // Note the destructuring: inside the body of this case, `head` is bound to the first element of the list and `rest` // is bound to the remainder. This is possible because of a "custom extractor" (giving us the nice :: syntax). You // can write your own extractors, but most of the time you don't need to bother. val (smallerOrEqualElems, largerElems) = rest.partition(_ &lt;= head) // A quicksorted non-empty list is: // - the quicksorted list of elements &lt;= the pivot // - the pivot // - the quicksorted list of elements &gt; the pivot exampleQsort(smallerOrEqualElems) ++ List(head) ++ exampleQsort(largerElems) } Or another toy example where being able to extract values really aids in readability: evaluating an AST containing an arithmetic expression. sealed trait Expr final case class Add(lhs: Expr, rhs: Expr) extends Expr final case class Subtract(lhs: Expr, rhs: Expr) extends Expr final case class Multiply(lhs: Expr, rhs: Expr) extends Expr final case class Divide(lhs: Expr, rhs: Expr) extends Expr final case class Literal(value: Double) extends Expr def eval(expression: Expr): Double = expression match { case Add(lhs, rhs) =&gt; eval(lhs) + eval(rhs) case Subtract(lhs, rhs) =&gt; eval(lhs) - eval(rhs) case Multiply(lhs, rhs) =&gt; eval(lhs) * eval(rhs) case Divide(lhs, rhs) =&gt; eval(lhs) / eval(rhs) case Literal(number) =&gt; number } // (2 * 4) + (1 + 9) / 5 val ast = Add( Multiply( Literal(2), Literal(4) ), Divide( Add( Literal(1), Literal(9) ), Literal(5) ) ) println(eval(ast)) // 10.0 You can also make type tests in the `case`, e.g. `case A(someB: B, _: C) if someB.propertyBsHave == 4 =&gt;` results in a block that: - only runs when the thing being matched is an `A` - ...whose first constructor parameter was a `B` - ...and whose second constructor parameter was a `C` - ...if that `B` instance's `propertyBsHave` is equal to four Inside the body of that expression, `someB` is the name bound to that `B` instance our `A` contains and we explicitly did not bind a name to the `C` instance or the containing `A`. If we wanted, we could have done those things with: `case someA@A(someB: B, someC: C) if someB.propertyBsHave == 4 =&gt;`
Personally, I have an idea for what I think should be done, but since exceptions are usually *part* of the language I can't try it out myself without developing an entire language. Basically you only declare exceptions you throw directly, and exceptions you throw directly are also given an index which is also used in the catch. So, class FooWriter { int write(char[] from) throws IOException&lt;1&gt;, IOException&lt;2&gt; { if(canWrite) ... else if(closed) throw new IOException&lt;1&gt;("closed"); else throw new IOException&lt;2&gt;("Unknown failure"); } } class FooManager { void write2() { /* Compiler issues warning here that write may throw IOException&lt;1&gt; or IOException&lt;2&gt;, but we are not required to declare it because we never throw it directly. */ fooWriter.write(toString().toCharArray()); } } class FooManagerManager { void write3() throws BazException&lt;1&gt; { fooManager.write2(); /* No warning about throw here because write2 does not declare any exceptions. However, we can catch it anyway, like a RuntimeException */ try { fooManager.write2(); } catch(IOException&lt;1,2&gt; ex) { /* The numbers changed! Each level of the callstack adds another number to the exception's params so that if IOException&lt;1&gt; is thrown directly AND another IOException&lt;1&gt; leaks up, we can disambiguiate them. Since we're catching an IOException with 2 params, we're catching the exception thrown 2 levels down. Each param corresponds to 1 level in the callstack of the throw's indirection. */ throw new BazException&lt;1&gt;(ex); //If we had thrown ex, it would get thrown as IOException&lt;1,1,2&gt; } } } This way, we can properly separate the contract of the function from its implementation details by not requiring incidental exceptions thrown by the implementation to be listed in the contract, instead only listing there the things that conceptually should be (for example, write methods SHOULD list IOExceptions, but things that just happen to use write methods should NOT). Finally, we essentially assign a unique id to each throw statement in the program so that anything can be caught without accidentally catching something which happens to be the same time, so that if our implementation uses a leaky abstraction from Someone Else's Code, we can handle it specifically without changing Someone Else's Code.
I use checked exceptions in my own code when it can be recovered or in main "borders" of my application, let's say one per package. It makes obvious where errors should be handled. At the same time I dislike them often when I'm using stuff like URI or Integer classes, I just wrap them in runtime exceptions and rethrow them to be handled on upper layers.
&gt; I'm convinced the main reason there's so much hate for checked exceptions is that most people just don't want to think about all the ways their code can fail, they just want to get the "happy path" working and be done with it. I have seen this a lot when I worked as a contractor (went indie full-time for about a decade). Just about all projects I have contributed to during that time completely lacked proper error handling and only dealt with what was supposed to happen. So when things broke, they *really* broke. :) Since then I have been doing the corporate thing (for about another decade), and it's the same story all over again: only this time I can actually do something about it (to an extent anyway). &gt; This attitude in general is responsible for quite a lot of what's wrong with software today. This could turn into a longer conversation, but this attitude seems (to me) to stem from a lack of desire to continuously improve our craft as professionals. The greater majority of programmers I have met in my 20 year career have been the "9-5" types. They come to work, they do what they are told, and they go home and forget everything about the day and stop thinking about programming in general. No desire to improve themselves or their understanding of their own craft. Case in point, one of the Java developers I work with has been programming in the Java language for about 7 years. He has deployed dozens of production facing products using Java. He has no idea what an interface is. Or an abstract class.
Yeah, because my codebase totally needs some public interface AnyExceptionThrowingFunction&lt;T, U&gt; { U apply(T x) throws Exception; } 
Since it stays within the normal type system, you can map over them in the expected way. You can also write generic code that works with any exception type.
Then blame the people who started throwing Errors that could easily be recovered from. Catching Throwable is a rational response. And generally, given the plethora of types that can be thrown, I think catching a superclass reasonable. You obviously need to take some care with what would go in the catch block then and don't want to just ignore something like a StackOverflowError. Still, I don't see anything inherently wrong with catching Exception/Throwable/etc. It's a good opportunity for logging and other such actions and you can rethrow as needed.
Yeah, but `java.util.List` is such a fundamental interface in the Java Language that I think it's perfectly reasonable for IDEs to treat it as special by default.
Such a pattern requires union types and possibly pattern matching, neither of which are well supported by Java at this time (though pattern matching is being investigated for Java 10 in Project Amber). Also, it wouldn't be possible to fix all the existing Java APIs to use an Either type due to backward compatibility unfortunately.
Yes, but you can already do this with runtime exception. Not a standard style, but you can declare RuntimeException in your method signature(for documentation sake) and then if you need to handle that exception - then have it handled, or have it be thrown up the call stack until there's someone up there to handle it.
&gt; and so a lot of programmers ignore them and add a generic catch (Exception e) that doesn't do nothing No they don't. &gt; in fact in contest where you have limited resources like embedded C++ they are not used What does C++ have to do with anything? This is Java subreddit. We are talking about checked exceptions in Java. Java is not C++. &gt; you might have memory leaks if you don't pay attention, so why using them. What the hell is even that argument? "Pointers might cause memory leaks if you don't pay attention, so why use them?" 
someone here understands! vokiel deserves a raise. The rest of you are #fired. Bruce Eckel: Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result â€“ decreased productivity and little or no increase in code quality. 
My poignant point is #1 Java Checked Exceptions are a bad idea fundamentally and #2 Have led to immense misuse as well. Both the existence and use of this 'feature' have been problematic for Java from the start. Even well respected Java experts from java's own ecosystem regret ever making this part of the language. Now that Lambdas are here, they regret it 10x as much! Bruce Eckel: Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result â€“ decreased productivity and little or no increase in code quality.
They are bad. How do know? Because no other languages have adopted the same idea.
&gt; Case in point... Urk. Sounds horrible. One might describe this guy as having seven years of experience, when in fact he probably has more like one year of experience repeated seven times.
Yeah but that's the same crowd who think partial types are good idea.
And I didn't say that checked exceptions are bad in any way or that they shouldn't be used for precisely that reason. I said they were a good idea that just happen to collide with the messy reality.
Warning: if you think you need a singleton, think twice, you don't need it. If you REALLY think you need a singleton, REALLY think twice as you REALLY don't need it. I'm always amazed at how much people hear bad things about singletons but still think that their own personnal use case is soooooo much specific that they REALLY need it. Yeah, believe me, i've seen things... horors... implemented by otherwise really sane people. Makes me think that singletons are kinda like drugs: you know it's bad but you can't stop using it. For your pleasure, please have a look at this video of speaker Misko Hevery really explaining the problem: https://youtu.be/-FRm3VPhseI?list=FLqvTGM9771vEN7-QiRYhO1w
Java runs on just about everything, including your refrigerator, TV and your phone. Also, you will find better information if you post on r/learnprogramming 
The naming probably isn't great, even if a for without yield ends pretty much being a for loop.
You don't need anything specific, but more ram, higher CPU clock speed, and (to a far lower degree) GPU quality will generally make your workflow faster. Slower CPU means slower build times, which means lower productivity. That being said, if you're a beginner, I don't think much of this will impact you. Just try not to skimp on the cpu and ram, and you'll be all set
Check out /r/buildapc for help building your computer. There isn't really anything you need to do to make it run Java well.
In that case that's a terrible idea. It would make implementation details not only visible, but necessary to know in order to handle the exceptions correctly. It would also make for super brittle code. What if I change where I throw which exception in my implementation or decide to throw one more/less somewhere in the middle? I would break the user's code. I don't even have to actually change something. Even simple refactoring like inverting an if-statement (which rearranges the source-code without any semantic changes) would break the user's code. That's a completely no-go. Distinguishing exceptions is what subclassing is for. If they are meant to be handled differently, if they describe different error cases, one should declare and throw different exception types. That's why we have super specific hierarchies of exception classes. So that we can throw exactly the one type that describes the error situation most accurately.
Answers like this are the reason the first book I give juniors is Effective Java. Simple, easy, and straight forward but, you might not think of it because you're new-ish to java and you've been using enums to define string and numeric constants. 
Whatever 
I have (ab)used Observer occasionally to completely decouple packages because it's a interface that can be expected to be present in every environment. I.e. I have a debug console that can optionally be put into the class path to activate it. static Observer console = tryNew( "&lt;classname&gt;" ); if( console ) console.update( null, "command ..." ); This allowed me to communicate with components without having to ship any of their classes. Now Java 8 added lots of better suited interfaces in java.util.function but I still have support code that needs to run in Java 1.1 (J#) as well as Java 9. 
Scala died last year. Didn't you hear? 
How about Spring Boot + MyBatis? If you were good at native SQL, I thought MyBatis would be easier to maintain. If you work with Hibernate, you would need to know how to use it. From my experiences, MyBatis would be easier than Hibernate. reference - https://github.com/mybatis/spring-boot-starter
It's pretty easy to use I've been using it for about a year now with different clients. (It's also pretty cheap for what they're offering)
Checked exceptions are annoying in Java particularly because inherited methods cannot define new exceptions, so they quickly lose their benefit unless you make everything final and never use inheritance. Unfortunately, changing this would break a lot of code, and if you're using interfaces you're still fucked anyway. Error handling in general just sucks, you're stuck between flexibility with unchecked exceptions or having to rely on concrete types everywhere if you used checked exceptions or enums/etc.
what product do you use?
SMS
Twilio is a great service at a very cheap price for what you get. We use it for SMS as it is very easy but also to buy SIP lines from anywhere we want making our customer get local numbers and plugged in with our Asterisks phone gateway rented for a few $ a month and free VoIP soft phones. For a small organization we have 1800 numbers each staff have their own lines. Can do conference calls etc. Programatically it is also used to click to dial and our team knows how to contact our customers every so often as set by our tools. Also for CTI (Computer Telephone Integration) when we receive call we can record call start and end time as well as open latest information likely to be the reason client call. So Phone rings, we get a webhook telling us this number is and we open the webpage with a simple REST call. As for the 1 call / sec refered by /r/nightman01 it is per phone line. If you have 10 outgoing lines, you can make 10 calls a seconds with no delay.
Is that similar to a monad return type?
deleted ^^^^^^^^^^^^^^^^0.4124 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/29219)
Found the koolaid
&gt;Why would you need to look ahead? If you were defining a type then you wouldn't start with val or var I'm a parser and I just consumed the tokens `val` and `x`. I don't know whether I am looking at a variable declaration of type `x` (e.g. the beginning of `val x y`), or a variable named `x` with an inferred type. It's a small issue (until you add more grammar that has e.g. overlap between type expressions and destructuring syntax), but it is something you take into account when designing a language. &gt; If the Kotlin devs wanted to make this familiar to Java programmers to switch, they should have stuck with the convention. I'm not a Kotlin dev but I switched from Java to Kotlin and it never even occurred to me that the LHS/RHS thing could trip people up. Actually this is the first time I've seen it mentioned anywhere. I encourage you to use the language a bit and see if it is as big an issue as you feel.
Company I work at uses it for SMS and voice to send 2FA codes and SMS notifications, very good and reliable.
I built a Java based RabbitMQ system that would take confirmations from our ERP, eCommerce, CRM, and other applications and depending on user preferences send text messages via Twillos restful services. If I remember correctly we originally developed the SMS component using Restarus as the vendor. We switched to Twillos and then to twoSMS. I like Twillos much better than Restarus and TwoSMS. The business like TwoSMS because it was cheaper. Twillos has a more well documented and versatile API. The interface was newer too. TwoSMS has been a constant issue. All in all Twillos is my favourite thus far however if you are going to start sending 30000 / 40000 texts a month you might be able to find cheaper options depending on what you need.
Side question: Exceptions are classes, why have I never seen an exception that has unique methods? Couldn't a lot of similar exceptions be grouped by having a getReason method that returns an enum?
http://www.drdobbs.com/jvm/parallel-array-operations-in-java-8/240166287 explains the parallel operations in added in java 8 
This might be fun: https://www.codingame.com/start
For the uninitiated, the component of the C++ std library which was formerly known as STL is a mixture of collections types (`vector`, `map`, `set` etc) and algorithms (`for_each`, sorting etc). The forthcoming parallel extensions primarily affect the algorithms. Their equivalent in Java (8) would be accessed by the collection [Streams](https://docs.oracle.com/javase/8/docs/api/index.html?java/util/stream/package-summary.html). These come in sequential form (accessed via [Collections.stream](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#stream--), and a parallel variant, accessed via [Collections.parallelStream](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--). There is [more on parallel streams on the Oracle doc site](https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html). As an aside, it's worth noting that Java 8 parallel streams are a somewhat simplistic approach to achieving performance gains through parallelism. In many cases the overhead of managing the threads and the cost of synchronisation may cause the parallel stream operation to run more slowly than the sequential equivalent.
Of course, when I first read about streams I remember thinking, that's just like algorithms in the C++ stl. Thanks!
[removed]
Scala killed itself by being an inconsistent mess. 
I must be behind the ball a bit here. What do you mean by wildcards?
Java EE includes a bunch of stuff to make developing web applications easier (there are other was to get these feature but java EE is a fairly popular one) so if you're using database connectivity or servlets and the the like you're using java EE
Gotta love Java, where every language weakness is solved by annotations and wrapper classes (looking at you, Optional&lt;&gt;)
It's 3 lines longer (or 6 if you open brackets on newlines). And if you do this multiple times, it increases the numbers of lines a lot, and in my opinion is less readable, especially when you have to nest the exception (for example, try this, if it fails, do this, if it fails again, do that... with exceptions is a mess, without is a simple if ... else if ... else). The fact that with exceptions you have to know the details of the error code is true, but when you use a particular function you check the documentation anyway to know the parameters and the return value. Also with exception, if you want to catch not a generic exception but a particular one, you must check the documentation. Beside that, there are conventions inside the particular language or project you are working on so it's not a huge problem. 
In a Java project you can just point to a folder and use wildcards so the project file itself rarely needs changing. In .NET the project files are large globs of xml spelling out each file and extra meta information so the compiler can know what to go do with itself. These project xml files change constantly as devs add/remove/rename files and therefore conflict frequently. 
Ah yes, I've had that happen. It is usually pretty rare though but maybe on a really large team it might happen more often.
We have been using Twilio, on my team at work, for over a year now. We use it for two way texting in our Ruby on Rails app. I remember it being fairly easy to set up and we haven't had any issues with their service. I can't speak for their java implementation. Based on my experience, I would recommend them.
Optional is a semantic abomination that does the exact opposite of 'putting things into the type system'. You start with one problem: there is an existing type called Object that has several sub-cases you would like to distinguish between: - null - not null - may be null - may be null in error cases That needs either new syntax, like Kotlin, or a set of annotations and checkers. If you try to solve that problem by declaring a new type extending Object, you now have three problems: - changing everything to use Optional - extending the type system to support such 2nd-order concepts cleanly - creating new syntax (or annotations and checkers) that constrain the use of Optional to safe situations. 
Effective Java
I'd go for Payara or Wildfly, with JSF, PrimeFaces and OmniFaces. Can't go wrong with that ;) I personally hate Spring, so I wouldn't use that.
I think public APIs should handle null generally. In the example given, printing lines for a null buffer should just print no lines. If that's upsetting to some users, they can check for null themselves. And if there's a situation with no reasonable way to handle null or if the API author just forgot to handle null, then Java conveniently throws NullPointerException which will unwind the stack to nearest point where anyone decided to handle it. What is so horrible about using Java the way it was designed?
Nope
Java Concurrency in Practice, by Brian Goetz
I really wish they'd kept updating "Java Examples In A Nutshell" I loved that book back in the day.
The NullPointerException might occur far away from the code that caused the value to be null, in the worst case after part of the desired side effects already occured, leaving the system in an inconsistent state.
And null should be handled appropriately by the API library in that case. Why burden users with this detail?
I second this. I think it's only up to date for 6, but it still clarifies so, so much.
Goetz has talked about the possibility of revising it. It just seems like a lot of work to do so, along with what they're already working on.
If you are building a system where a value can be null, every method must know about this. That's easy to forget. Not accepting nulls puts the decision on the caller. If you repeat that process, the decision gets pushed to the edge of the system, where that value originated. That's the place you want to handle the error. The rest of the system is oblivious to this, it can always rely on values being there, or getting an empty Optional to help handle that case. In the example, you would preferably have an empty BufferedSource which you could pass to printLines directly, or an Optional&lt;BufferedSource&gt;, which would force you to handle the empty case. That makes the decision explicit, because it's not spread into two places. I hope I didn't go completely on a tangent there. :)
it says unable to access jarfile
I meet "experienced" java developers nowadays who still don't know about enum singletons, or static factory builders. 
Two details: you can use Spring Boot with primefaces, check http://joinfaces.org. I personally dislike jsf. One thing you need to be aware: it is really hard to make changes in a well polished widget and keep it perfectly consistent with the rest, unless you have really good people doing UI. That is true in jsf, Angular material, react + material UI or whatever component set you choose: if it looks great and you make a small change, it is going to take time and effort to make it look great again. And the last time I use MySQL there was a problem: adding a column to a table blocked the table for a long time. Not a problem if your system works 9 to 5, a huge problem if your system needs 7x24 uptime.
I will be messaging you on [**2017-11-14 22:09:46 UTC**](http://www.wolframalpha.com/input/?i=2017-11-14 22:09:46 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/java/comments/6b516u/what_are_some_essential_java_books/dhk640l) [**50 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/java/comments/6b516u/what_are_some_essential_java_books/dhk640l]%0A%0ARemindMe! 6 months) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dhk64fa) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Any love for Java: A Beginners Guide?
Effective Java and Java Concurency
Not only did that book make me a much better Java developer, it totally changed my approach to API design. I work on a SOA team, and even my language-agnostic REST API designs are much better since reading that book.
I'm excited for this release
Core Java. I'm surprised no one else has mentioned these yet. http://www.horstmann.com/corejava.html
Yes
What's wrong with wrapper classes?
Java heap-allocates all objects so a wrapper class costs an extra pointer-indirection. Hardware does not like that. They might also be talking about type safety: you can achieve a much higher degree of type safety by creating semantic types instead of using primitives everywhere. In Java that requires a lot of boilerplate and the performance implications of the above further discourage it. Some languages have tuples but that only solves the boilerplate problem and I'm glad Java doesn't have that. But there is nothing wrong with wrapper classes *in principle*. Java just has some unfortunate limitations.
&gt; because it's a container, instead of being a union. An implementation detail, that doesn't really refute the idea that optionality should be an invariant captured in the type system. Ideally `Option&lt;T&gt;` will be come a value class, and calling it a sum type or union will have no meaningful difference.
&gt; An implementation detail... Actually I just explained up there why it's not just an "implementation detail". &gt; ...that doesn't really refute the idea that optionality should be an invariant captured in the type system. Because I wasn't trying to refute that idea. &gt; Ideally Option&lt;T&gt; will be come a value class, and calling it a sum type or union will have no meaningful difference. No, it will have a meaningful difference, not just in efficiency (because it being a value type is still less efficient than the current representation of null), but in semantics, and practical effects on B.C. breaks at the source and binary level.
You don't need coercion to assign x or y to a union x|y. That's the whole point of unions. You don't need value types to represent a nullable reference, either. Under the hood, it's just a reference set to zero. 
&gt; You don't need coercion to assign x or y to a union x|y. You do, because the types are not the same. `x|y` is not the same type as `x`. It's not a the same type as `y`. either.. `x` is not a subtype of `x|y`, yet assignment is still allowed. Therefore a coercion is needed. &gt; You don't need value types to represent a nullable reference, either. That's what I was asserting. &gt; Under the hood, it's just a reference set to zero. This is false. `null` is not integer 0.
well not modules thats for sure.
Too bad you have to do this per package.
Currently reading head first Java, and principal of java, are they of any value?
I'm sure it'll be retrofitted to be doable per module in Java 9
&gt; What is so horrible about using Java the way it was designed? Thank you for this. I'm constantly surprised how big of a problem this seems to be to some people.
In terms of algebraic data types it would be the sum type `data Optional a = Empty | Of a`. It seems we agree on that since I think this is the best representation. Since java does not support sum types the question how this is represented in java arises. I think the container approach is reasonable since it allows to distinguish 'normal' types from optional types. The union type seems a reasonable alternative, too. But it's not available right now AFAIK. Algebraic data types (sum types and product types) are really expressive. It's a petty that java does not support them.
This book made me fall in love with Java all over again. Highly recommended for beginners!
I mean, everything is about trade-offs right? In certain areas ORMs are better, in others JDBC is the way to go. 
why wouldn't it be?
I second this! DTO's does not belong in the service layer.
I use MyBatis, it's the best of both worlds. I can write my queries with SQL (using some dynamic stuff to generate the where-clause and such), but it also uses mappers to translate db entities back to my domain objects. So I have full control over my queries, but can also easily deal with the results.
You can just create a branch/fork and commit and push to it. This essentially "backs it up" without overriding the main sources.
[removed]
&gt; You do, because the types are not the same. x|y is not the same type as x. It's not a the same type as y. You can think of a proper union implementation as a form of type erasure. This means at runtime type `x` will literally be of the same type as `x|y`, because an instance of `x` can directly stand for an instance of `x|y`, just like subtypes. Then you can directly assign the former to the latter. In most situations union type information doesn't have to exist at runtime. Union is an algebraic data type with a clean static model. &gt; &gt; Under the hood, it's just a reference set to zero. &gt; This is false. null is not integer 0. I'm not sure what's up with your reading, but I clearly said a "reference set to zero" and not an "integer set to zero". In the JVM, null is literally a C memory pointer set to zero, is my point. You don't need additional data to describe that specific union. Sure, you can magically represent `Optional&lt;Foo&gt;` in the same way, but it requires a lot more special casing and implicit semantics than what I propose. My solution's external appearance is much closer to its internal representation, which is a great benefit for both understanding this feature as a user, and in the long term for the language complexity as a whole. We'll have complete support for unions and intersections at some point anyway.
This "detail" is an evidence that before you start using this API, you should first make sure that you know what is going on with your data and secure the weak places with tests.
That book is pretty straightforward.
Yes, it would have better in the jre. But let's be honest that is not happening anytime soon. Better would be to have a very minimal lib with say only one class in the jar that dose what you suggest. But then getting adoption won't be easy, as each lib will want backwards compatibility. 
Can you give a a small overview of how the book specifically helped you write better APIs? It's been a long time since I've read this book and I'm wondering which chapters specifically helped with this. 
Just a side-note. The javadoc of guava TypeLiteral is kind-of lying when it says: &gt; Forces clients to create a subclass of this class **which enables retrieval of the type information even at runtime**. because static &lt;T&gt; TypeLiteral&lt;T&gt; uselessTypeLiteral() { return new TypeLiteral&lt;T&gt;() {} } &lt;rant&gt;runtime reflection is so awful. JSR269 has been there since jdk6 for f* sake&lt;/rant&gt;
&gt; runtime reflection is so awful. JSR269 has been there since jdk6 for f* sake I fail to see how JSR269 could help in this case. Creating an annotation processor that makes a helper class with a method that parses json for my List&lt;SomeDTO&gt; ?
... literally don't know what OP is doing but just do the standard extends JPArepository and you use findOne, Your repository should simply be an interface you shouldn't be actually implementing it. 
Not natively supported but you can get sum types rather easily in Java, via church encoding: interface Either&lt;A, B&gt; { &lt;X&gt; X match(Function&lt;A, X&gt; left, Function&lt;B, X&gt; right); } 
&gt; Be aware that they only allow you to initiate a new call 1 / sec. Is there a way to get an exception for this policy? I assume it's to combat spam rather than a technical limitation.
https://github.com/javaee-samples/javaee7-samples Each one of these is a self-contained deployable example showing each technology. 
You probably should try it yourself :D
I did and saw several blog posts and pre-release builds available.
GlassFish website is under maintenance for some time. The search yields &lt; 5 posts related to GlassFish 5 dates before 2016. One old post related to the status of GlassFish 5 from Oracle but the link is dead. If you have nothing to add fuck off.
The difference is that it's totally transparent to the user in C#. Optional&lt;&gt; pollutes the code and hides the intent of the developer, while C#'s nullables do not. I want getUser() to return a User (or null), not an Optional
Aside from performance there's nothing wrong with wrapper classes, imho. They are just a weak substitute for language features because they pollute the code and hide the intent of the developer. I want getUser() to return a User, not an Optional 
Spring Boot + Vaadin
The last I heard it was still on track for end of this year (I think that's a little optimistic, considering the politics with Java 9 and the politics of just getting Java EE 7 out) According to [this](https://www.infoq.com/news/2017/04/long-road-for-java-ee-8) article, it's in the public review phase, or just out of it. I have not seen much on Glassfish, sadly. 
`instanceof` is a piece of crappy heritage from the times when Java had to use questionable ways to attract C programmers. Please don't include it in the list of Kotlin's good parts.
It's not in Kotlin
Do we expect breaking API changes in the public review phase and afterword?
i use something similar, Sql2o. I'm Pretty much happy with it, though i'm using it in projects with not much persistence transactions.
Java is very vast and no single book is good enough to cover everything, though Effective Java is quite close to it. I have shared my list of 9 books every Java developers should read here, you may like it http://javarevisited.blogspot.com/2013/01/top-5-java-programming-books-best-good.html#axzz4hAWc1PJC
I used @Transactional yes i know how it works, i just put @Transactional at the class level in service tier. 
It's hard to call it essential, since it's so new, but On Java 8 is promising. It's by Bruce Eckel, who wrote Thinking In Java, which would have been one of the first answers to this question a few years ago. It's in beta right now, and only available on google play books: https://play.google.com/store/books/details/Bruce_Eckel_On_Java_8?id=p4ytDgAAQBAJ
It would be useful to actually spell out what Onyx is.....
It's a masterless, fault tolerant, distributed computation system that uses batch and stream hybrid processing model. It's similar to Storm, Cascading, Cascalog, Spark, Map/Reduce, Sqoop, etc.
Sure, that is why Scala and kotlin are dominating the codebases around the world. lol 
Adding exceptions to subtype methods would break the Liskov Substitution Principle. Callers might use the supertype interface, and would not be aware that the subtype throws additional exceptions. In fact, with inheritance, unchecked exceptions can make adhering to LSP very difficult because subtypes can throw anything, and the supertype documentation or definition can't help you out. The solution is not to avoid inheritance, but design classes to be extendable. With checked exceptions, that means defining the exception at the appropriate level of abstraction to where subtypes can sensibly use the exception types defined by the supertype. Java methods are by default virtual, so Java allows dangerous extension unless you specifically make methods final. C# is by default non-virtual, so supertype methods must be marked virtual to be extendable. In fact, this was the counterargument to Anders Helsberg argument against checked exceptions, that it is a misuse of checked exceptions to simply tack on checked exceptions up the call chain. Or, in this case, the inheritance tree. You should catch checked exceptions at the lower level and rethrow at the higher level, or just use higher level exceptions at the lower level.
Ah, of course, the good old church encoding in java :) Looks like an interesting project.
https://www.reddit.com/r/java/comments/6b516u/what_are_some_essential_java_books/
half the "go to tutorial" links don't go anywhere the images are dead links overall 1/10 would not go to again
Nice article. It is hard to find good introducing material to reactor. I still fail to understand how this will work in a real world scenario, as a whole. Let's say I asked the user's from the UI, and need to get them from a rdbms: will the tractor approach work if I ask for 100 different users? How can I return data to the UI in a non blocking way? I need a web socket? Anyway, thanks a lot! 
Thanks!
Google "java double floating point" if you want to know more. No bug here, just floating point stuff.
That's just Oracle ...
The title of the page is maintenance outage. Not sure what is going on there.
You might want to check if web.archive.org has a copy
So ... presto?
When they "work", where do they go?
I don't think it's a maintenance outage.
You can still download it from maven repo. 
Yeah, I mean, it seems that the code is in GitHub, but... for the most part it's a shell of its former self. Guess the Java "ecosystem" is really in peril.
On the one hand happy that they're bothering at all to do a transition, on the other hand... oh my... the level of professionalism is *really* low here. It comes across as if they realised at the last moment things had to migrated, and are now making things up as they go, with very few resources dedicated to doing the actual work. This was of course never going to be really easy, but taking down major websites without first having the replacement in place and not having redirects in place etc is just not nice. I've seen a ton of hobby projects literally doing everything in their spare time plan better. 
Actually, Oracle's been notifying me for months that they're closing Java.Net and Kenai and that my projects needed to be migrated. They first started telling me this, let's see...more than a year and a half ago. And the reminders have been pretty regular since then. 
Could be, but when a project the size of Jersey can't be found with a simple internet search, I find it kinda troubling.
Sure, there were lots of warnings. So...where was the ball dropped?
It's stunning. Searching for "java jersey" leads to the java.net page and then... to nowhere. And here I thought the reference implementation of the JAX-RS spec was mildly important...
Sounds like the maintainers didn't get the community moving fast enough. Oracle has been pretty clear that java.net was going dark.
I think so. Now the page is updated with the following text: &gt; Most Open Source projects previously hosted on java.net have been relocated. Please contact the corresponding project administrator for relocation information.
[removed]
Hey if you want to create a mock up or proof of concept use Sketchware from the android app store. I'm not sure if Apple has it. Basically it's scratch for android dev. It's great for creating basic apps. And you get to see the source code.
[removed]
https://jersey.github.io/documentation/latest/index.html
[removed]
[removed]
Here's a good explanation: http://0.30000000000000004.com/
[removed]
Other problem that arises from this behavior, is that you should never compare doubles by a == b, because they may not match even if they should arithmetically. Instead you should do abs(a - b) and check if the result is smaller than some very small number. example: if Math.abs(a - b) &lt; 0.0000001 then you could say that a is effectively equal to b.
As with the other comment, I'd love to know where in the book, which chapters, helped you with this goal as it is a part of my toolkit that is very weak and I'd love to specifically go and check that part of the book out!
Think Java by Allen B. Downey - VERY useful for learning Java 
/r/Javahelp
Are there still any major desktop applications being developed on java?
This is my personal favorite http://screencast-o-matic.com/ But I don't think it uses FX
it depends who you are asking. java fans will make their breakfast with java
A lot of them and JavaFX is the best UI development toolkit out there. 
&gt; jshell&gt; String.format("%d of bottles of water", $1) $2 ==&gt; "9 of bottles of **beer**" JShell the Philosopher's Stone of alcoholics
Binary floating point types are extremely efficient to perform on CPUs and GPUs. Most modern CPUs have dedicated hardware to perform binary floating point arithmetic. People have weird feelings about floating point because they are 'binary' floating point types use base 2 and the way they are rounded which does not match the decimal rounding they are used to. Many programing languages have decimal floating point types like Java's BigDecimal (the arbitrary precision is just an extra, you can still have arbitrary precision binary floating point), but its use for "base 10" is the main thing that differentiates BigDecimal from floats and doubles. Plus they are software implementations and not as efficient as binary floating point hardware implementations. For scientific and engineering applications you would usually work with extremely large or extremely small variables that or very close approximation to some real-world quantity, such high precision is not important, speed is the main important factor. Decimal types are more popular in business applications and monetary calculations, speed usually not that important comparing to the familiar rounding. Even in such applications high precision usually is not important, rounding to 2 or 4 decimal places is common. Note that BigDecimal since it uses base 10 can't represent many numbers like 1/3, 2/3 ... etc. You would need a base 3 decimal or some symbolic representation.
Are there still any major desktop applications being developed? It seems to me as if anything developed in the past few years is Web-based... (barring legacy code, of course). 
Computers in general can be precise with decimal numbers, the very existence of BigDecimal shows that. The reason why java does not use decimal type by default goes way back to when Intel released 8087, which was popular enough to define the standard way of doing floating point math.
Intellij, which is in Java swing. 
Presto on top of ElasticSearch https://crate.io/overview/cratedb-vs-elasticsearch/ 
I don't think so. Do you think something else is going to happen soon? What do you think it will ultimately look like?
Since they just migrated it I would imagine it will take a several days for the search engine spiders to get everything updated.
You get the Drama Queen of the Internet award for the day.
You can find a show case [of real world application](https://jaxenter.com/20-javafx-real-world-applications-123653.html) here and also Minecraft!
JDownloader and the netflix backend (yea I know, its not what you asked for)
The syntax is pretty similar, as Kotlin mostly adopted it from Scala. If you are out for learning something new, I recommend you to learn Scala first, because it opens up a lot of new possibilities. Kotlin is more like syntactic sugar for Java, even though it looks like Scala on the surface.
Not specific to Java but Implementing Domain-Driven Design is really good 
Why does that matter though? You can just pass a reference as an argument and be done with it either way.
Shilling! 
That's a bit odd to have a book on Java 8 coming out after Java 9 ships. I hope he updates it to 9 before he ships it. There are hundreds of JSRs/JEPs in Java 9, so almost everything he writes about will be slightly different in 9--from the language, to the modules, to the libraries and collections, etc. 
&gt; How did this happen.... Transaction boundaries &gt; Its getting easier just to write just bog standard JDBC. It doesn't matter if you use straight JDBC, MyBatis or JPA/Hibernate, if are using transactions, you have the potential to run into problems at transaction boundaries, especially if you are using declarative transactions (CMT). Amplified by concurrent transactions. JPA makes problems obvious where straight JDBC would happily let you destroy intermediate updates made by concurrent transactions (by forcing you to reattach to a persistence context, and by forcing you to refetch intermediate changes if you have a `@Version` column). I prefer straight JDBC (well, `JdbcTemplate`), but I understand there are very good reasons why JPA does what it does, which I have to remember to replicate manually (which I prefer to do, because I want to be able to see the plumbing).
You can pass and mutate local variables to/in methods just like an lambda, which was what I was trying to get at. I have personally never seen or wrote Java code that requires lambda and I personally avoid them like the plague.
IIRC only GUI applications can be ran by simply double clicking via GUI. Anything command line based will need to be launched using: java -jar &lt;JAR&gt;
Nice, can't wait to check it out.
Not true. If the jar is properly built, the application will open, CLI or GUI.
Nope. Feel free to browse the repo: https://github.com/JetBrains/intellij-community/tree/master/java/idea-ui/src/com/intellij Jetbrains uses kotlin, but you'll find almost all of that repo is java.
I haven't looked into the details, but is the PDF design process of PDFBox as easy as BIRT?
Why don't you just use JSP?
The author explains that on their main page: He had to deal with a highly dynamic login solution with lots of different forms and a small amount of HTML in general. So a purely programmatic approach seemed more reasonable.
True, but CLI applications will show their results and dissapear immediately, which is usually not the intended behavior.
Never used BIRT, but PDFbox is fairly low level and for the most part a wrapper for the PDF file format. Probably Apache FOP, which uses PDFBox under the hood, would be more comparable to BIRT (XML based report design)
Java programming dialect was initially created by Sun Microsystems which was started by James Gosling and discharged in 1995 as center segment of Sun Microsystems' Java stage (Java 1.0 [J2SE]). JAVA writing computer programs is utilized to make complex applications that are sufficient adequate to keep running on a solitary PC or can be appropriated among different servers and distinctive customers in the present system. 
Who's this clown
How is this a valid question? There are release notes for a reason. WTF?
I challenge you to point me to the release notes link that makes this answer superfluous. It will be fun!
There is a changelog link as the first comment on the actual question.
That's exactly what windows does for all CLI applications.
Yes, which is exactly why CLI applications are run from the command-line, where you can't simply "double-click" the jar file. You have to either type-out the entire `java -jar myjar.jar` command-line or create a batch file which wraps this command.
Well if that info isn't easily findable why do people put up with it? Your answer was pretty decent and should be a model for release notes or new and noteworthy style post when hibernate releases new versions. 
Maybe the situation is different in your country but I think the general feeling in the US is that certificates are not worth it. You will get more value out of studying, learning, and putting some work in on a github page that can directly exhibit your skills. I got my SCJP 10 years ago and when I was looking for a new job a few years later I didn't even put it on my resume, it was a very valuable learning experience for me though.
start D:\path\to\jar.jar ?
What if I posted it because it's an interesting topic? 
Would I be able to create a full blown JavaFX GUI with Kotlin? If so I'm heavily intrigued. 
I'd say that's a borderline strawman and doesn't answer my question.
You can use java -jar myjar.jar Or alternatively, use: java -cp myjar.jar com.example.test.Application java -jar is simpler to use, but you cannot provide a custom classpath to the command line.
Most applications don't need any of that. I have always had a love/hate relationship with Hibernate, it is great for updates and inserts. But its need to join 10 tables together when I just want one column from one table is enough to make me want to pull my hair out screaming. So then I have to write HQL to query the single column I need, thereby losing all the time I gained in the first place.
&gt; Hibernate has been supporting DTO projections from the very beginning I believe you have just made my point, to use Hibernate you first have to be aware that something called a DTO projection exists, then you have to know what it is used for, and then have to know how to use it. So all the time you saved by using Hibernate (if any) you now have wasted learning about DTO projections, and this assumes you know of their existence! &gt; Hibernate has been supporting native SQL queries for 15 years now Then what is the point of Hibernate if I am just going to write SQL? https://vladmihalcea.com/2016/04/04/high-performance-java-persistence-chapter-15-fetching/ This chapter in your book further proves my point. You have 19 sections about how fetching works in Hibernate. Are you serious? I have to know all of that to use Hibernate? It is just easier to stick with SQL. &gt; Just because many choose to fetch entities even for read-only Tx, it's not Hibernate fault. I have been using Hibernate on and off for various projects since 2005ish. This is the first time I have ever heard anyone say you shouldn't use hibernate fetching if you are doing read-only transactions. If it is read-only you should use SQL? If so, again what is the point of hibernate? I am slowly coming to the conclusion that the only thing using Hibernate is good for is not having to manually change your insert and update statements when you change the DB schema. I am not sure that is worth it though.
You are still questioning what is the purpose of Hibernate for reading data? Well, the purpose of fetching entities is to benefit from: - [dirty checking](https://vladmihalcea.com/2014/08/21/the-anatomy-of-hibernate-dirty-checking/) - [transparent JDBC batching](https://vladmihalcea.com/2015/03/18/how-to-batch-insert-and-update-statements-with-hibernate/) - concurrency control, like [preventing lost updates in long conversations](https://vladmihalcea.com/2014/09/22/preventing-lost-updates-in-long-conversations/) Hibernate is not a substitute for SQL. It adds value on top of SQL and RDBMS-specific query capabilities. &gt; This is the first time I have ever heard anyone say you shouldn't use hibernate fetching if you are doing read-only transactions. I teach people how to get the most out of JDBC, JPA, Hibernate, ACID, concurrency control, batching, caching, fetching since no technology is a silver bullet. To run apps with low response time, there is no silver bullet framework, you need the whole [data access stack](https://vladmihalcea.com/2014/05/28/the-data-knowledge-stack/): JDBC + Hibernate + jOOQ. 
[removed]
[removed]
Doesn't do much, but I guess it's something
No consequences attached or hacking together weird scripts? E.g. Bidirectional binding is still doable etc.? 
Certificates are only useful if you do not have relevant work experience (i.e. you're a student or switching careers). An open source project is far more valuable to employers than a certificate.
Wtf
I do not think it can really compete with JasperReports unless they create a visual designer.
A while back I might have said something similar, but now that I've converted a bunch of existing singleton and anonymous classes over to lambdas and seen just how much cut-and-paste boilerplate it removes from the code, I've become a fan.
Wish it supported java.
Wat
Android is Android, it isn't java. Hence, wish it supported java.
Thank you.
https://en.m.wikipedia.org/wiki/Comparison_of_Java_and_Android_API
Non-Mobile link: https://en.wikipedia.org/wiki/Comparison_of_Java_and_Android_API *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^69372
Employers don't care about certs.
Regardless of what you want to do with programming, whether it's just a hobby or a potential career path for you, this is definitely the wrong question to be asking. Java, like any programming language, or any language for that matter, is never truly "mastered." You can become proficient or advanced at it. That's really philosophical and not really my point, so I'll get on to the second point, which is... **You won't learn anything if you hurry it along.** What's your rush, anyway? Got an award-winning game or industry-defining software you need to program, but in order to do it you need to master Java? Trust me. You will learn more if you just move along at your own pace, without looking at the finish line. Take this from someone who *also* identifies as a "Java noob." I've taken two full-year classes on this language and done independent programming on the side, and I still don't have it down - I doubt I ever will. Slow down.
Finish? Never. There isn't anybody in the world that can honestly claim they know everything in the Java spec. Master? Five to ten years. Get good enough to land a job and not be hated by your coworkers? A year or two, less if you already know a C-related language.
There used to be an official browser plugin that allowed Java applets to be embedded in html, but it is no longer supported by most browsers because of security problems imposed by it. So as of now you can't really run java code in the browser other than with experimental JVMs like doppiovm. If you want to make a game or user interface you can get more familiar with Java then try using a ui framework like JavaFX to make a desktop application. In the far future, someone may write a JVM that is compiled to WebAssembly to be run in a browser, but it is still an emerging technology and I wouldn't hold my breath waiting for that. Short answer: no. (someone else may come up with a better answer than me)
You can go all-out with https://codeanywhere.com/ and have everyone clone / share their dev envs... Online.
Here's confused, he means JavaScript.
1. Such questions have no place here. They should at best be posted in **/r/learnjava** as is indicated in the **sidebar** 2. You will never **finish** learning a programming language, and also you will never **finish** learning programming 3. Speed never matters when learning. Retention and the ability to apply the learned concepts do. 4. You may be able to learn most about *core Java* in a year or two, but then you have tons and tons of libraries of which you will need quite a few. You'll have to learn these as you go. 5. Knowing a programming language, like Java, does not make you a good programmer (or even a programmer). Programming is far more than knowing a programming language. It is the ability to devise algorithms that solve problems and then convert these algorithms into programs. Actually writing the programs in any given programming language is the easiest part of programming. 
Jvm language. Cooler the java (or scala )
I think it's worth looking at. My opinion is that it is what Java ought to have been. But in short; less boilerplate and more concise. 
so whats the benefit of becoming "official". you can write android apps in anything right?
Every Kotlin related malfunction is a bug, therefore you can file a issue to Google because "Google officially supports Kotlin (and Java)". If you use another unsupported language and have a bug then the problem is yours.
It is Effective Java https://medium.com/@lukleDev/how-effective-java-may-have-influenced-the-design-of-kotlin-part-1-45fd64c2f974 https://medium.com/@lukleDev/how-effective-java-may-have-influenced-the-design-of-kotlin-part-2-89844d62ddf3
Thats how i felt when doing a cursory dive into Kotlin. I generally like it and its ilk, but this incessant need to remove "boiler plate" kills it for me. Java's boiler plate is fine.. it makes things super easy to read, and any decent IDE does most of that work for you. Theres lots of other really nice features and language constructs that java lacks that these jvm languages add. If a new language could just add those features without trying to be so damn clever, id be really happy.
Wait, What? It crosses over JNI? What about Oracle JDK? Is that an intrinsic (spelling?) like Unsafe?
Great idea! Does it somehow handle path variables?
The biggest benefit is Google promiting Kotlin. There a lot of developers and managers that adopt whatever Google does.
[Sonarqube](https://github.com/SonarSource/sonarqube)? Don't know about very specific, custom rules, I guess you could write a plugin if you need to.
I don't understand the downvotes, there's nothing in this article that hasn't been said thousands of times. The title implies something else.
Yes! The last couple of times I downloaded Eclipse, I looked for the SDK version, specifically, because that seems to get as bare-bones as the Eclipse project allows its users. And then I installed just those plug-ins and extensions I considered necessary. Which was still quite a bit, but much less than downloading a pre-assembled distribution. 
Hibernate still isn't the holy grail. I recently developed a web platform for which I did not found a suitable solution in hibernate. Basically, user have the ability to add columns to the database via the frontend, and thus a mapping to a Java object is impossible since I did not want to include mechanism for scaffolding own class, compiling &amp; then loading them. I ended up using plain old JDBC and my own custom HashMap-backed model. Thus, i hopd to find similar cases in this article to compare my experience wit others.Ii have used JPA (sometimes with Hibernate, sometimes with other implementations) very succesful in other projects, so I'm very well aware of its capabiliities and enjoy working with it very much. Still, seeing what limitations other people find and how they get around them / what alternatives they use is alwas interesting. The article delivers nothing on that front, it just states "it is so".
In 2004 IE 6 had roughly 80%+ of the browser market share. IE 6 was bad.
Just that Hibernate is on the top and has twice as much market share as all other frameworks combined.
On the other hand, Hibernate was the most popular data access framework since 2004 until today and for many years to come.
Good and bad are subjective perceptions, not quantifiable metrics. Many popular technologies like MySQL or PHP have their share of critics, but that does not make them *bad*. It's all about doing the job for what they were invented.
I have used it production and it has been rock solid. The services I wrote don't get hammered but I believe Netflix uses boot so if it performs for them it should be fine for mine.
IntelliJ sounds pretty cool! Thanks for your help!
Is to much magic until you read the Docs, several books and the source code, after that, the magic becomes knowledge.
Jump into the deep side and find out that you were a fish all along. Follow Derek Banas's tutorials. Make a developers account. Use firebase. Don't try reinventing the wheel of an efficient version is already in the market i.e import libraries. Get to know XML. Use linear or frame layout as they are the easiest to use and understand. Ask your SO for answers. Get someone to give you deadlines with some consequences to speed up the process.
Thing is, classpath scanning was the same magic - until I started using in production. It's all relative.
I highly recommend you watch this video: https://www.youtube.com/watch?v=uof5h-j0IeE I used to think the same as you (I could copy/paste some "core" configuration for another old project and that's it), but as ramsees79 says in another comment, it's "magic" until you understand how it works. Anyway, I'm not married with Spring Boot, in some cases I prefer the old 'manual' way.
&gt; If Hibernate or JPA were bad, they would never have a 70% market share. Market share of what? The provided link is about a Twitter survey of 700 developers. However, it is unclear how those 700 were selected, and if it represents a valid sample of Java developers. For example, given the question: &gt; What #JPA provider are you using in production? #java were 13% answered *None*, that would mean that 87% of Java developers are writing software using a JPA implementation. Considering all the Java software that does not deal with databases (eg libraries), I find it bit suspicious, to say the least. Things get even more suspicious when looking at popularity on Github: * [Hibernate](https://github.com/hibernate/hibernate-orm) 2.4k stars * [MyBatis](https://github.com/mybatis/mybatis-3) 4.8k stars * [JOOQ](https://github.com/jOOQ/jOOQ) 1.7k stars I do not disagree on the fact that Hibernate has its place (2.4k stars are still 2.4k, but only half of what MyBatis has), but that 70% quote is a bit hard to swallow without more details on how that survey was carried out...
haha I love that pun too!
Current status: nearly irrelevant to the industry.
Eclipse's main advantage is that its totally free. Its also a pretty good IDE, but its age is showing. Its a bit of a crumbling behemoth. IntelliJ is probably better in most ways. But unless you are content with just basic Java support from the community edition, be prepared to shell out some $ for supporting the kinds of frameworks you might need/want to use for a typical enterprise application. So, if you don't mind paying for your IDE or you are fine without the support for stuff like Spring or JEE, so the Community Edition of IntelliJ is enough for you, then IntelliJ is probably the better choice. Otherwise, stick with Eclipse.
Can I ask you couple of questions regarding Spring Boot Microservices ? Have you checked the memory footprint of the container that is running the microservice ? If so, how do you manage to keep it at a reasonable level ? When I was deploying Spring Boot microservices in docker they were taking up to ~700MB of RAM for each instance (insane!) but with tweaking I was able to take them to around ~130MB-160MB. But I still feel like those are too large. Any advice would be greatly appreciated :)
I've been on IntelliJ for a long time. Sadly, I'm currently with a dev team that uses eclipse atm. It's clunky, always running off and building crap when i didn't ask it too, and it loses its way often which requires a restart. The worst thing is when it gets caught in a death spiral ie: build loop. Uggh.
Needs code snippets...
Our services tend to have 2G allocated by default. Sorry that's not much help.
I'd say just Google "spring bean life cycle", then docs and source. It's not magic one you get an idea of how spring di works, and what classpath scanning is. The "magic" annotations are just decorators for your classes that provide hints to the spring container about how to manage your code. The reason this is good is because the order in which beans are initialized in Java config is non-deterministic. With xml, the initialization order is determined by the order your beans are defined in the xml, which is bad for a number of reasons. Java config let's you do some other neat stuff too. You can provide some default configuration for your code (h2 db, embedded server, stubbed out services, etc), and clients can quickly test what you have, then override your configuration with their needs. In xml, there's no way to provide overrideable config for spring. TL;DR Once you understand how spring works (generally speaking), and look at the docs and browse the source, you'll see that it's straightforward and simple (not as in "easy", but "not complicated"). 
That said you can always exclude auto configs by using the exclude property on the @SpringBootApplication
IntelliJ Community Edition actually offers a lot of functionality aside from just Java, and is what I will continue to use. Aside from that, if you're a student, you can get IntelliJ Ultimate Edition, as well as all of JetBrains' other products, for free.
Streams for everything!
* Lambdas - definitely the best. Being able to define filters etc. as a function, that made my code heaps shorter. * Optionals - whenever I am returning a nullable, I am now returning Optional. It took me a while to persuade colleagues to handle them properly such as using orElseGet() instead of just using .get(). * Streams - they look awesome and work well when combined with lambdas. But they are slower on some collections, so I am always trying to rationalize their usage. * Default methods - I have used them once, but it was just the right tool for the job (enhancing old test Page Objects without common parents with some functionality).
I know who he is ðŸ˜‰
Default methods are under appreciated, they can completely change the way you design api for the good. Optional, get rid of null pointers forever*, and its a monad to boot aswell (apparently http://stackoverflow.com/a/19932439/106261). DateTime/LocalDate, does what it is supposed to do and not the steaming pile of garbage that was pre8 where a Date is not a date at all. Streams and lambdas are syntax sugar, nice enough but not as conceptually significant as the other two. imo.
The ones with certificates are usually the most shitty programmers ever. 
java.time is amazing 
I think this is where people hear "micro" and think it means "few system resources" when in reality "micro" means "small in scope". The concept of microservices is a distributed systems architectural pattern, It doesn't really have any bearing on the performance of individual application instances appart from making it simpler to measure and optimize each component where necessary. 
One big issue I had with Eclipse is the whole workspace thing. I don't know if it still exists, but back in the day you had tell Eclipse where your workspace folder is and you can only open "projects" in this "workspace". You have to "import projects into you workspace" which can fail sometimes (at least if i remember right). In IntelliJ you can just open folders wherever they are like a normal human being.
In what cases to you prefer the manual way? I already started watching the video. It's a bit boring in the beginning, because I know the basics (read a lot), but I will stay with it. Thanks for the link!
Thanks! It looks very promising.
You could start in JavaFX, which has limited 3D functionality, or you could try LibGDX. You can make 3D models in Blender, and there is an addon called BDX which can be used to make games in Blender.
You can decide when to start and stop docker containers, in this concrete case you are doing it for each test class (which in case of microservices probably you are only have a few of them and not taking minutes). But in Cube you can choose when you want to start the docker container (connecting to an existing one, per suite, per class or per method). Also we know that some users are doing it per test method because they want fresh instance every time. For them it take 1 second to open db and populates just some milliseconds. So it is not about written tests correctly in the sense that there is only one way of doing it, it is more following the strategy that fits better to your lifecycle. But I agree that if you need minutes to populate something, what you mention might be better, but it comes with other drawbacks. 
it's amazing also because java.util.Date and the GregorianCalendar were bad. Really really bad.
LibGdx is the library you are looking for advanced stuff, though, beware that this won't be an easy journey if you don't have much java experience. I'd also recommend starting with a game that runs on awt + swing. There's much less to learn there, but it still can be very difficult to master.
Wrong. LibGDX games easily outperform similar games in Unity. 
&gt; Generalized target type inference Could you provide an example?
Better: I can provide a [JEP](http://openjdk.java.net/jeps/101)
Compared to the old time/date utils yea it's awesome but oddly it still misses some functionality I get in joda
The fixes to java.time are saving my sanity 
LOL - I think you might have confused Java with Javascript...
I often use the ones from Oracle: (https://docs.oracle.com/javase/tutorial/). They are clear and concise.
Sometimes syntactical sugar is all you need to make a language more tolerable to work with. Saves me typing while still saving my types. :)
Like what? The author of joda was a big contributor iirc and recommends moving to java.time, so I'd find it odd if he just left some features out
The other way to do this is to start all your docker dependencies just once and not for every single test so they are reused across the tests. You can use the open source docker libs for java (one is by Spotify) to start the containers. You can use a shared synchronized init routine, or build it into the lifecycle of your build tool. I have done this with huge swaths of integration / selenium tests. This is harder to do but it kind of simulates a real life situation on your app server. E.g. Yes you should be able to handle 52 concurrent requests to sign in at once. It should also be faster than starting db/queue/whatever over and over for every single test. There are more pitfalls I've encountered with making sure your dependencies are actually started and ready to go, making sure one test doesn't ruin the state of another test etc but if you can pull it off you can get some really high confidence that your whole system is working as you'd expect on every single change
Java.
Yes, "other stuff than Java", is right, but the question was about an IDE for Java, not, say Python, or Golang. And IntelliJ doesn't give you the stuff for, for example, working with Spring, in the community edition, which was my point. If you are interested in Java, chances are its not for 'plain old Java', but something more than that. But its a fair point that students can get 'all the good stuff' with an academic free license.
I'ts been awhile, but I remember some conversions in the java.time was a bit non-obvious as well as extracting different granularities of time were a bit annoying, like for instance in order to get the millis from epoch for a LocalDateTime, I for some reason have to make it an instant. LocalDateTime.now().toInstant(ZoneOffset.UTC).toEpochMilli I'm sure there is a good reason for this, but I'm confused as to why, especially since you can also do LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) * 1000 Mind you I'm not saying any of this is really that bad or really a problem at all, I'm just being lazy if anything. This also might be a bad example, but it was what readily came to my mind.
Have you played with Groovy at all? Definitely checks some of your boxes there. 
&gt; What makes you think Java is outdated? probably this: &gt; in the pipeline And: boilerplate to make a simple app; verbosity... 
Stream ( java way of doing functional programming).
I've made lots of production systems for large to very large institutions in grails 
Boilerplate is being addressed. It takes time, though, to move a platform as large as Java's.
I came here expecting an answer like this. Well, sorry if you read my post like this, I didn't want to, honestly. I know that my question could be difficult to answer because most of us love the tools they use, in some cases the tools gives us the money so it's perfectly natural to be defensive about our choices. I don't find Java to be difficult, I just find it verbose, less productive and "old". If you don't agree, please argument your response. If you feel disappointed by the adjectives I use for Java, remember that I'm talking about a tool, there isn't any judgment about you. I trust there won't be only Java-fanboy here, but still I'm ready for the downvotes. If you think there's another better place to ask this question, please let me know, I'll be glad to have a wider audience.
Thanks for the answer, you're not the first suggesting C#, I'm looking it with interest. &gt; You know fuck all I wish I knew all! I barely know how to write a post on reddit. &gt; TL;DR: Go away, troll. If I wanted to troll, I would have write something funnier.
Python and Go would be your best bets. Or Node potentially. You're still wrong about Java being outdated and I recommend you learn to use a little discretion when you come to language's subreddit and insult all of its users
This particular source isn't a study, but a talk: https://youtu.be/oGll155-vuQ?t=15m8s
&gt; What's "some project"? It depends a lot on what you're actually trying to build. You're right. Currently there are two projects on the "backlog". One is a chatbot implementation. The other one is a web system that gets data from different sources (csv, DB, REST...) and allows the user to aggregate and analyze the data, eventually using other connectors for the output (csv, DB, REST...). &gt; And Java is not outdated. Why?
Thanks. I didn't mean to insult, it is possible that my English is not enough rich to express my sentiment. I'm just curious of what a Java developer would choose as next language.
Exactly 3761 hours. 3692 if you skip some lunches. /s
Depending on what you're planning on doing, I might recommend TypeScript. It's a surprisingly simple and effective way to cover up a lot of the mess that is JavaScript. Some of the very stupid decisions remain, such as `"1" == 1` being true (use TSLint and enforce the use of `===`, which is the sane equality check). I especially like union and intersection types. Obviously it's best suited for client side web development, but there's also Node.js and, Electron or React Native that allow you to use TypeScript on the server, desktop and mobile phones respectively. Visual Studio Code is free and a very natural fit for TypeScript development, but I also use it for Python development.
That's much more concise than mine, no suprise you have 30times my karma :)
Try: [Kotlin if you would like to try kind of modern Java], [TypeScript for Front-End &amp; Node.JS] [Watch out for Crystal Language it could be an interesting thing in the next year].
Boiler plate and verbosity are design choices. They have nothing to do with something being dated. We auto generate that stuff with our IDEs in a click anyways. I prefer the verbosity, and a move towards terse would be very unwelcome by some including myself. That's what CPP is for.
The alternatives would be using a different language or something hideous like YAML.
Thanks so much for all the answers! Just to clarify, what is: AWT? Swing? LibGDX (I'm assuming it's a class available for import)?
Great idea, downloaded it and tried it briefly, works flawlessly for my small Spring project - going to see how it fares on Monday with some larger Spring projects at work.
Could you explain why? I'm sorry I'm ignorant.
Just to add on there's some new methods in Collections class that allow you to make a one item list or map without a separate declaration and assignment. Helps out sometimes with making your lambda chains look nicer.
No, these are libraries and toolkits, hundreds or thousands of classes. Abstract Window Toolkit (AWT) - the standard API for providing a graphical user interface (GUI) for a Java program. It provides standard way to do anything graphical in Java, including starting a window (JFrame) and drawing anything in the components inside that window. See example: https://examples.javacodegeeks.com/desktop-java/swing/jframe/java-jframe-example/ Swing - Swing is basically extension for awt, which provides all kinds of buttons, panels and controls. Handling your mouse and keyboard events: See example screenshot: https://en.wikipedia.org/wiki/Swing_(Java)#/media/File:Gui-widgets.png (Swing is now slowly becoming replaced by JavaFX, but still worth learning) LibGDX is a game-development application framework. https://libgdx.badlogicgames.com/ . It's very powerful, allowing you to direct some expensive graphical operations to graphics card using shaders and allocating graphical resources on lower machine native level. It's a third party platform, not included with standard java JDK. (Someone else might have much better description for it, I've only written one game with it)
...but has the side effect of making java code unreadable, therefore unmaintainable.
Maybe you should try Hazlecast It's very easy to use and config (in my case with spring boot) for simple use case. https://hazelcast.org/
I will give it try ;) 
Terrible clickbait title... This is an incredibly basic example which generates a static excel document. I have used poi quite extensively but for more complex reports I went with a BIRT integration. Reports get arranged in a report designer UI from SQL driven data sets. Then you can output the same report as xls, xlsx, docx, pdf. I had to write less code embedding features into a webapp with custom javascript than you wrote boilerplate in this example.
Could you use this in the following scenario: recording user interaction with a webapp and then flagging certain things (like search of a specific word) real-time?
Seconding this recommendation.
Apache ignite
&gt; I would like to execute SQL queries for accessing data combined with &gt; I do not have idea how to save/load game state with database Doesn't really make sense to me. Do you mean that you don't have idea about database schema or you are not familiar with queries for inserting/updating data? Maybe we could help you with your database schema design so you could use proper db engine (postgres/mysql/whatever) and query it with sql? Or maybe you would like some Jpa Repositories equivalent such as Hibernate so you could simply store/retreive your object in/from db.
How long ago have you looked at C#? Because your information seems, I'm sorry to say, very dated. I'm not blaming you, if your day job is with Java (not an unreasonable guess considering the sub) I don't expect you to keep up with all of C# at all. I like both languages, but I like TypeScript more actually, so here's some perspective from someone that has used both languages. C# is now an open source language and the compiler is also open source. Support outside of the Microsoft platforms can be iffy, but there's DotNet Core that's cross platform (as long as you're not doing anything that requires a GUI, hence the iffy part.) C# 7 came out just two months ago, adding support for stuff like pattern matching, tuples, destructoring, a lot of that functional goodness we're craving for lately. IMO C# is still in the lead in terms of language features, even if we're comparing C# 6 to Java 8, altough the gap is much smaller now than it used to be because Java 8 was such an awesome release. C# has had lambda expressions since version 3, aside from using `=&gt;` they're pretty much the same. Functional interfaces are best compared to the `Func` and `Action` types, e.g. `Func&lt;int&gt;` is an `IntSupplier` while an `Action&lt;int&gt;` is an `IntConsumer`. You can add more type parameters: `Func&lt;int, bool&gt;`takes an int and returns a boolean, so it's an `IntPredicate`. Delegates can still be used to declare `out` and `ref` params. (I think TypeScript has both systems beat, `(x: number) =&gt; bool` is an `IntPredicate` and so much cleaner imo, but that's probably just me.) Streams are comparable to C#'s LINQ. Stuff like `map`, `filter` and `reduce` have different names in C# (`Select`, `Where` and `Aggregate`). Yes, that's a lot like SQL. Yes, not everyone likes to be reminded of SQL, especially not when they're doing functional programming. But there's also an actual query syntax that can sometimes be useful over the fluent interface style, but personally I only ever used it for joins. Just like Java had to add default method implementations on interfaces to make Streams possible, C# added a feature called Extension Methods. They'll likely be adding default method implementations on interfaces in C# 8, though, because Extension Methods and default implementations do have slightly different use cases. I personally do like the async/await syntax but I can see why you would prefer not using it. It's been awhile since I've done asynchronous programming in C# (and can't recall ever doing so in Java), so I won't comment further on that. If I do I'm probably going to mix it up too much with async/await and Promises in JavaScript. I'm curious about that interface dispatch example, if you can find it. I always like looking under the hood at what a compiler actually does.
Sounds like https://github.com/npgall/cqengine would be a really good choice for you. Not a full blown SQL database, but it should be flexible enough to cover your needs.
SQLite is absolutely the best embedded database out there.
I recommend Apache Derby.
I've seens this and it almost satisfy me ;) Thanks! 
If it needs to be fast, I recommend SQLite: https://db-engines.com/en/system/H2%3BSQLite
Queries like what? If everything is memory already can't you just run some filters on streams?
They use a merged context, so they shouldnt. This could be a misconfiguration, or some other issue with your test suite? I think we have about 400-500 slice tests in a testbase of ~5000 and have noticed considerable speed increases. 
I tend to agree with many others here. I like the idea of the framework doing all this and I like the ability to just annotate stuff and as someone else said predictable magic is good but I often find little "edge" cases with autowiring and other odd issues which overall make spring difficult and time consuming to use. 
I'm a little skeptical about the repl for java. I've used java since 1.2 and I've never felt the need to just execute a line of code in an interactive shell. I'll either use a scripting language or just create a class in an ide and run that. I know people that love the scala repl though. I'll try to reserve judgement till I've used it.
I just moved my own application from h2 to hsqldb; why do you recommend h2? 
There is. A very good one, in fact. https://bitbucket.org/xerial/sqlite-jdbc
TIL, thanks! 
either h2 or hsqldb would work fine. under a different language (c/c++) i would recommend sqlite as being better, but for java h2 works perfectly fine.
Yes. This is the foundation of "what the programmer doesn't know will DEFINITELY hurt them". It's a much better API design philosophy than trying to be helpful. Want to use the system default time zone? I bet you don't, but if you do- prove that you aren't making a mistake by figuring out how to get the system default. Oh, you can't? Good. Foot-gun removed.
[removed]
I did the whole JWT thingy with spring security. Then, one day i needed to load images that were generated dynamically by the API. Did you know that &lt;img src&gt; doesn't work? Nor ng-src? There this obscure library that makes "http-src" available and that does the proper thing and send the proper headers when requesting the picture. The entire thing (since i had to load images from JS as well, not only from HTML), made everything just be a tiny-bit more difficult. Web development is a shitty enough thing, no reason to make it even worse. All in all, now i think that JWT is more of a pain than it's worth.
So I assume this will only work in the Ultimate edition, right?
Yes, I think so. Altought it's not obvious, so I posted a comment on the article for clarification.
I think that using authentication tokens in general comes with that drawback. For Images (and for everything else which is downloaded as a side effect of an actual pageload) the _Authorization_ header will not be applied. That said, it's not related to JWTs directly, but it's rather the side effect of using HTTP headers as an authentication mechanism. If you put the token to a cookie or appended it as a query parameter, images would be downloaded fine. What's that obscure library you were using on that project for making proper headers available for http-src requests?
Seconding this: either H2 or HSQLDB are great. 
May I humbly suggest people take a look at this ? https://www.youtube.com/watch?v=Sw7I70vjN0E Disclaimer: I work at Pivotal and created this video. 
Most recommendations I have seen here are for full relational databases - either in memory or with persistent storage backend. From your description it seems, that this would create quite a bit of conversion overhead (both space and time wise) because the process then seems to be * read XML file from disk * write data into (in memory) RDBMS (can be done while reading XML) * query relational data * convert to game specific data structures Maybe [Apache Ignite](https://ignite.apache.org/) eases the pain but it seems the most optimal solution would be a SQL engine that handles parsing of SQL and then you can work with the binary representation of the query directly on your data model. So processing would have much less conversions: * read XML file from disk * write data into your specific data structures (can be done while reading XML) * query relational data and get your data structures back Or, you provide your own query language which supposedly then would be simpler than full blown SQL and easier to parse and process. ANTLR would be your friend writing the parser. Maybe OQL is also an alternative. Edit: fix link
You might want to try processing.org - it can do quite a lot with 2d and 3d graphics and you can learn graphics fundamentals very quickly with it before moving on to something more complex.
One con of Netbeans is that it's currently under Apache incubator status, so newer frameworks may not be supported as quickly as Eclipse/IntelliJ. The best one to go for is IntelliJ (Community Edition since you don't main Java) because it's feature list is quite good. Eclipse is also good, and the IDE features are roughly the same; so it comes down to preference. But irrrespective of your choice, you'd make the most of your time learning how to be productive with an IDE. That's something that's transferrable to other editors.
This won't answer your question, but there's an eclipse plugin called XRay that does this. It was designed with code investigation in mind, not CI so I don't think an automated equivalent exists. Why this might be of interest is due to the visualizations that it renders, which might help with your reports or inspire new reports. If you're interested, then you can have a look here: https://marketplace.eclipse.org/content/x-ray-software-visualization 
It's almost like he didn't specify what sort of project he was doing!
https://github.com/dougmoscrop/angular-img-http-src is what I used. got to it from a google search.
I think you overestimate the quality of the curriculum in this high school AP course.
Scrap isn't scrape and scrapping isn't scraping.
Sorry, I was in a rush to post this before I had to leave for something, I always forget about the sidebar, I'm not super familiar with Reddit.
Difference between a Web Server and Application Server
Write something significant or contribute to an OSS project. Most of what I know came from outside of school. The best way to retain your knowledge is to use it. Then, go find some online clases and learn some more. Repeat.
Congratulations! I took AP Computer Science in high school myself, and it opened my eyes to what now has become my career. There's a lot of good places to learn mor online, and you can find many resources in this sub. But if you're passionate about Computer Science, I would highly recommend going to college and getting a degree in it. It's one of the best returns on investment you'll have in your life, and you'll start a career you'll love!
How hard is it to get a job with a Cs major in a tech or aerospace company? I'm planning on going to college and wanted to major in CS but also want to work for a robotics or space company. Is it worth it to minor in robotics or physics in order to get a job at one of these companies? Or do they hire just CS majors?
&gt; Varargs is like var-args(variable arguments) Weowwwwwwwwwwwwwwwwwwww lad. That cringe title too.
Just make something. I've made over $50k with a facebook game. Nothing special....but, doing it taught me so much real world experience, and it also granted me a career as a developer. It would also pay off your student loan. Just do it. 
You post might be more well received if you could explain what you're having issues with and posting in /r/javahelp. 
thank you!
Have a look at http://www.threeten.org/threeten-extra, for some of the missing stuff.
Haha, fair enough yes ðŸ¤“
Interesting, it's on my list of things to do to mess around on a box with deserialization 
Never used netbeans, although regarding Eclipse vs IntelliJ. I thing IDEA is much more customizable in regards of your workspace, how you type, auto completion, etc. But eclipse is easier for organization. They're practically identical unless you get into technicalities regarding plugins. Some of the vocabulary is different between functionalities but reach the same goal (i.e. Artifacts) I've just gotten so use to Eclipse so I use it. Eenie meenie miny moe between then and I'm sure you'll do just fine.
I'm not sure if this is a trolling attempt, but I don't see this happening. Java is continuously being refined by some of the brightest people that I have ever seen. Watch a talk from Brian Goetz sometime.
No! period
We use h2 at work combined with Spring Data JPA to run some of our integration tests on build servers where connections to Oracle might be troublesome. Works great and we have minimal issues. Allows for solid and consistent development. 
Indeed. Strong, static typing is a must.
Reddit bots Text editor plugins
Only a title, no link or comment and 67% like it? Sounds robotic
Write code. Then write more. Then post it online some where. Listen to what people tell you about it. Then write more code.
Yea I wouldn't try learning java by watching tutorials . I took a class in high school and after learning it , I would find it extremely hard to learn without a mentor 
https://www.reddit.com/user/fee- seems like a bot account to me.
What are you talking about? Do you have any idea how many enterprises run on Java? I do not foresee it's use declining any decade soon. Java, tools/framework are not synonymous within context of web development.
Since Python predates Java, and since it didn't happen over the 20+ years they were both in existence, I doubt it will happen in the foreseeable future. 
Are you confusing server side and client side java apps?
https://apps.facebook.com/friendlystock_splits/ It wasn't my first attempt....there were a few other games I did, in the same vane, that didn't really get anywhere. 
[removed]
But even if JSF is on the decline, it's certainly not that insecure.
Java for green field backend API is going strong, particularly Spring Cloud/Spring Boot. Java for green field front end UI on the other hand....the JS ecosystem has won. 
If you're going to get all Church-Turing on me, I could have done it with a Turing machine too; that doesn't mean I'd want to.
Yeah, using Java for this is an overkill, but if you want to learn look into Dropwizard, jHipster or Spring + Spring MVC. They aren't the simplest, but they help you deal with some mundane things, and they have decent documentation out there. You can always go with Do-It-Yourself approach and use Jersey (JAX-RS reference implementation) + Guice.
I appreciate your advice. Thank you!
[removed]
I trully recommend [IntelliJ IDEA](https://www.jetbrains.com/idea/). The Community Edition is free, but if you are a student you can get Pro version as well as other products for [free](https://www.jetbrains.com/student/). 
As you are on Windows you can just use the [Oracle JDK 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html). The compiler is called "javac" but the last and only time I needed to manually compile a programm was in university. You could also try the [JShell REPL interpreter](http://self-learning-java-tutorial.blogspot.ch/2017/01/jshell-java9-interpreter.html) which will release with [Java 9](http://jdk.java.net/9/) someday. But then I'd move on to using an IDE. [Eclipse](https://www.eclipse.org/downloads/download.php?file=/oomph/epp/neon/R3/eclipse-inst-win64.exe) or [IntelliJ Community Edition](https://www.jetbrains.com/idea/#chooseYourEdition). Both have plugins to also run JavaScript.
The problem are these [people](https://www.reddit.com/r/java/comments/6c158w/greatest_features_of_java_8_and_why/dhrgp7x/).
I see some resurgence in Desktop Java with Kotlin + JavaFX (in fintech world). 
Try javax.inject
bytecode manipulation means java 'has' almost everything. :P
this is a bit silly. if you want to shill scala, then do so. don't expect others to do it for you.
the kochs
nice... reductive and a red herring in one go!
Ideally reflection should be allowed, on meta data which is accessible to an external observer anyway. So you can inspect the public properties and methods of public classes, without breaking their encapsulation. That said reflection has always been a feature to aid debugging, unit tests and so on side-concerns. The fact the various mappers and containers have abused it to the point it is a central enabler for their magical behavior is a giant problem for Java, to the point we'd be better off with no reflection at all.
I like they way Jersey annotations work. essentially take would would be a plain old java method, and convert it to be a REST end point.
I never felt like CDI really got the Contexts part right in Contexts and Dependency Injection. With Spring or Dagger you can easily create multiple contexts. So if you have different environments for development, testing, beta, and production, it's easy to switch between. With CDI it's extremely awkward to do this. You have your beans.xml file and that's it. You have to do weird things with alternatives or vetoes. I was really hoping CDI 2.0 would address this, but it doesn't look like they have.
I agree with your last point. In my experience, C# has rampant use of reflection to solve problems at runtime that could easily be solved without it, and it makes everything much more complex than it needs to be (I would even say Stringly Typed, when people are exporting the method names into tables or worse, writing them out as strings). 
In the last part of the podcast, Martijn talks about how there maybe a flag or something temporary to allow reflection to work as is in 9. I guess I support that, but I completely get the desire for isolation boundaries with modules. Now, the name collisions across non-exported module classes I'm not really sure I completely get.
The term you're describing here is "environment." Context (which uses a similar notion in Spring) refers to how the lifecycle of beans are used - e.g. per request, per session, etc.
Information technology doesn't have enough bad metaphors. Monad is a burrito.
You could use a combination of jsoup, htmlunit and a webcrawler to have a web bot. 
With alternative options out there the usage of JSF has declined, but that's just relative to the total market. JSF itself is still doing quite well and is used by many companies all over the world, and is still actively being improved (see recent release of JSF 2.3).
A significant amount of broken wrists might disagree :D
Htmlunit can be good. If the site is guarding against scraping by using captchas, then there might be problems. 
Of course you can. But why do you think there are so many alternatives that build on top of JDBC? Cool it be because using JDBC directly is far from ideal? Like IN queries, lack of named parameters, 1-based ordinal, and the overly verbose API.
The jdbc API could certainly use an update to be cleaner, but the reason there are so many alternatives is because it follows this pattern over and over: 1\. Someone thinks "Oh, this would be perfect to write a framework for!" 2\. The invest a lot of time writing it, but run into the inconsistencies, difficulties, etc of trying to write an object relational framework 3\. Someone tries to use their framework, runs into the issues, says "Oh, well I'll be able to fix these issues". 4\. They start over at #1 Db's haven't changed, I take the large number of frameworks as happening because it seems appealling at first, then when you get into it it's just not possible to fix with a framework.
But there are many mature frameworks as well besides Hibernate: Query DSL, jOOQ, MyBatis and they take different approaches to persistence. Anyway, for all those cases where you don't need an ORM (the DB is read-only and you just need to run analytics on it), jOOQ is a much better choice than plain JDBC.
I think others are misunderstanding your question and suggesting various selenium/HTMLunit solutions. Instead what I believe you want to ask is "how do I create a bot without having to do something awful such as using selenium/htmlunit" - apologies if I am wrong. Over a long break around the holidays season I started something for slack that I haven't taken very far - but it uses both the slack event API and real time messaging API (web socket based) with spring - it may provide some type of starting point: [https://github.com/mrasband/yab](https://github.com/mrasband/yab) 5mo is usually a long time in the dev world, but I bet I could update that to the latest spring boot release and have little effort to migrate it. *Edit*: not to suggest selenium or htmlunit are bad - they have a place and doing a real time bot probably isn't a great one. Though if you need to scrape sites you could use them as a utility in your belt.
I fail to see the difference of running a bot on a PC vs a Raspberry Pi. They're effectively the same thing. As much as I love my raspberry pis, they are no more suited to the task than a nice PC. [Note: I didn't down vote you, your comment just seems kind of ignorant without any background why you suggest this]&gt;
We deployed the Netflix OSS stack at my work and had a hell of a time with this. The big core of the issue is on Eureka deciding your app is up long enough to be healthy. The default settings can take up to 90s or so... Which is probably fine when you have a load of services up - but for our company having 3-5 for most things it causes a few issues. We actually moved over toward consul (which spring cloud supports) for a few reasons: 1) built in ha 2) distributed locking 3) it puts the responsibility for health checks on the registry rather than the client 4) it propagated way faster Granted the cost was more work on devops to ensure the RAFT consensus and other node discovery didn't overflow into other data centers or the larger corporate network.
If the goal is to get a job then you'd be served well by writing a web application using Spring Boot as the back end. Even if a job doesn't use it directly, you'll likely run up against one that does or at least some APIs that were heavily influenced by Spring Boot.
&gt; But there are many mature frameworks as well besides Hibernate: Query DSL, jOOQ, MyBatis and they take different approaches to persistence. None of which catch on and come to be the one everyone uses because they all have numerous issues and don't quite solve the problem. If we had a reliable star trek transporter, other forms of transportation would go away - no more cars, no more planes, no more buses, etc. The wide range of them is because everyone tries to make a superior framework and everyone fails. &gt; Anyway, for all those cases where you don't need an ORM (the DB is read-only and you just need to run analytics on it), jOOQ is a much better choice than plain JDBC. Talking about something non-ORM is a different subject.
When I reach for a bot, I tend to reach for [hubot](https://github.com/github/hubot) but he's written in javascript. I'm interested for academic reasons to see a java equivalent, but most of the interesting bots I've found are all javascript or ruby. 
Reflection is the main reason annotations work, right? I like annotations, I even use custom annotations. I would be sad if annotations no longer worked.
If you have a strong understanding of one programming language you've done already. Specifically, PHP isn't that close to Java
Frankly, I have the same opinion about reflection as I do for annotations. More often abused than properly used.
Anyway, my point is really that accessing the API is the best practice way to do it, and not pretending you're a browser.
I suggest you to read the Effective Java 2nd editions. :) Its the best out there for more advanced stuff.
You might also consider contributing to opensource java projects for example on github
The OSGi folks want to solve the problem using classloader hacks so that x.y.z.A.class != x.y.z.A.class. This is a solution considerably worse than the problem; it works 99.9% of the time. But there are uncheckable global correctness rules you (and everyone whose code you use) must follow. Any failure to do so causes obscure exceptions (e.g. ArrayStoreException: can't store x.y.z.A in array of x.y.z.A) in places totally unrelated to where the rules were broken. Systematically prefixing package names seems much better: - x.y.z.A in module x.y is x.y.z.A - a.b.C in module x.y is x.y.a.b.C 
[removed]
[removed]
Yup, if this will be done at all, they should be implicitly prefixed and therefore unique. I fully agree.
&gt; Consider a common use of reflection: Automatic serialization and deserialization of DTOs into e.g. JSON. Anything that involves blatant violation of an object's encapsulation and resulting in brittle schemes like "automatic serialization"... you won't win me on your side ;-) &gt; What is your proposed alternative? Create an interface for serialization, have objects implement it. It's how I do it. I cringe at the thought of automatic serialization. You call manual code "error prone". But do you realize what a huge source of problems automatic serialization actually is? Issues with versioning, security, inadvertent serialization of sensitive data, inadvertent serialization of useless temp data, subtly broken reference relationships, data duplication, core classes changing breaking deserialization and so on and so on. Just a few issues in the land of Automatic Serialization (or Running-Blind-With-Scissors Serialization as I prefer to think of it). Sure proper serialization code may be a bit tedious. Writing good code sometimes is. Although... there's an alternative to writing it manually, at least when it comes to simple DTOs: code generation. Another is using generic structures for DTO, which have configurable fields and come with safe serialization built-into their logic.
Maybe this? https://www.scorchsoft.com/rpg-game-maker-java
&gt; Automatic serialization does not need to violate an object's encapsulation - that is a separate issue. Reading an object's non-public state is pretty much a violation of its encapsulation. &gt; The other issues you listed are also not specific to automatic serialization but are general serialization concerns that you ought to consider when designing your DTOs. Java's "automatic serialization" way of handling things like versioning, for example, is to silently produce a corrupted object, or at best to fail in an unhelpful way. The way I resolve this is by the object supporting multiple serialization formats that are automatically upgraded as needed, which no automatic engine can do for you. &gt; Interfaces are a poor solution to two-way serialization because they only enable polymorphism on instance rather than type. You can easily specify a serialize method but polymorphic deserialize is not possible. The nice thing about custom deserialization is you choose the logic, including which class you deserialize to. That said, it doesn't make sense to be talking about "polymorphic deserialize", because if you serialize class X, the idea is you want to deserialize to X back, unless your codebase changes, but then your mapping to a specific class can change as well. If you have a use case for something else, let me know. &gt; Telling people to forget the reasons why they wanted or needed reflection is not a real alternative. I'm not telling people to forget anything, I'm rather saying it's used poorly, and the alternative is properly architected code. My code doesn't use annotations (aside from those assisting the compiler, and IDEs, like @Nullable), and it doesn't use reflection. I do a lot of serialization, SQL mapping, routing and all that other nice stuff. Somehow that has been a "real alternative" to me, despite your incredulity :-)
Welcome to 2017. Sites are built using angular js and react
[Rehost](http://i.imgur.com/c8qtmUO.png)
Good catch. I wasn't sure if I can just "umbrella license" the entire project as the individual algorithms were sourced from a few other projects. I would like to choose [MIT](https://opensource.org/licenses/MIT), though if I can.
Good idea. Thanks
It really simplifies things. 
Only as defined by the servlet spec. Its closer to an overlay. Multiple RequestContexts will span a single session context. A single conversation context will span multiple requests as well. And then of course everything overlays the application context.
Wow, you recorded that using quicktime? Every time I do that, my CPU fan starts to go crazy and you can hear it in the recording. But thanks for that video, it is pretty eye opening. Spring and Spring Boot is a great piece of software you guys have! So, it seems to me that some people are nervous to use it in production. I've never had an issue with it, but my user base isn't tens of thousands of users. I suppose the magic behind the scenes makes people nervous about it.
I've logged 6 issues with the above content on the issue tracker, seems like a better place to discuss this and update code than r/java :) 
Thanks for your input. Especially the `char[]` and Builder pattern suggestions. I think I have a lot of work ahead of me. I initially wanted to follow a Factory pattern, but found several issues when algorithms support multiple parameter-like options, such as scrypt cpu cost, mem cost, and parallelism. I want the code to be extensible, but that might be impractical given new algorithms might have more than one major parameter. As mentioned by /u/meddlepal, I also need to restructure the project to support modular class loading, as the copied implementations of each algorithm have separate licenses. Its not the algorithms themselves that have licenses, its the java-versions I've carefully reused have licenses. I could either (A) re-implement my own versions of the algorithms, or (B) spin them off as their own sub-project that extend a specific "Algorithm" class. I think that's the biggest roadblock at the moment.
Misuse of static / default methods on interfaces: No separation of interface and implementation. Just like the antipattern of using inner classes in interfaces. There goes encapsulation and replaceability e.g. swapping plugins at runtime or service discovery down the drain.
There isn't any specific advantage or disadvantage whether add a new class or not other than that code readable and maintenance complexity. This way suits for simple or medium complex logic. If you have a more complex logic, then you should consider a new class for each logic. Thanks for your idea.
I use pelican, basically I compile my website into raw html. Much faster.
I had the exact same problem a year ago... I was sure there was some Spring way to do it, I ended up something like public MyResponse onReceiveSlashCommand( @RequestParam("token") String token, @RequestParam("team_id") String teamId, @RequestParam("team_domain") String teamDomain, .... } Horrible. It is nice to know there wasn't spring support...
I read the jira, I did not thought about that option at the time, so good thinking. (At least better than mine). Oh, I hate snake_case... 
Some solutions to that: (A) The FileAttributes solution (be like java.nio.file API): You can set parameters with some parameter object. There's a BasicComplexity class with just an int with a complexity rating, but you can also pass a specific one, such as SCryptParameters or some such. No type protection (you can pass an SCryptParams to a BCrypt load, and it'll compile fine. Fails at runtime but that's that). (B) Have the builder require the algorithm, and have the algorithms be enums or some other explicit type and not strings. These have a generics param of the setter object. I'm not sure this is a particularly fantastic solution as it gets in the way of reasonable ways to read this stuff from config files and the like, but it gives you type safety. As is, just having a complexityParameter as general concept that ALL the impls can use, seems fine. As long as there's some sort of normalization ('10' is fine for older simpler hardware, 13 is more modern, 20 is ridiculous but doable, any higher than that and it's going to take far too long to be pragmatic to even do a single password). 
&gt; I looked at the example you posted to, it's longer and less clear than the original sql. I'm not sure if you are referring to the article about jOOQ, but this is how the SQL stored procedure is called with jOOQ. FormatTimestamp sqlFunction = new FormatTimestamp() .setInTime(new Timestamp(System.currentTimeMillis())) .execute(localTransactionJooqContext.configuration()) .getReturnValue(); Type-safe and elegant! &gt; You sound like someone's read a lot of marketing and not done any actual implementation. 3x more frameworks means 3x-9x more work and issues. Before joining Hibernate, I used to work as a software architect and I built software for Ford North America, Nokia, and the largest real estate platform in Finland, which uses Hibernate and works like a charm. Here's my [LinkedIn profile](https://www.linkedin.com/in/vladmihalcea/) for more details. As for open source projects, besides Hibernate, I built [FlexyPool](https://github.com/vladmihalcea/flexy-pool) which is used by hundreds of enterprise applications throughout the world. And, Jelastic thinks I'm [one of the most interesting developers in the world](http://blog.jelastic.com/2014/09/02/meet-vlad-mihalcea-one-augusts-interesting-developers/). I also speak at conferences like [Devoxx, JavaZone, Voxxed Days](https://vladmihalcea.com/presentations/). So, besides marketing, I might know one or two things about software development. What do you think?
The main problem is that Form beans are created by the WebDataBinder (org.springframework.web.bind) and not by a HttpMessageConverter (like the MappingJackson2HttpMessageConverter). So OP would need to write a custom HttpMessageConverter that handles form requests. (general rant) The worst thing is writing a REST application where I want to have a single model that can be used to render different formats, including HTML. Right now, I end up writing two methods: one for returning a ModelAndView and one to return a ResponseEntity. And now we even have spring-hateoas which just focuses on HAL / JSON. The entire concept of payload serialization / deserialization in Spring is inconsistent and really needs a makeover. Since a few weeks I am thinking about good approaches to handle this. There is no easy solution.
Yeah i just said that, because inter wrote skiing is the analogy to scale, iirc. I didn't said that that would make the analogy good.
Yep! I was leading that transition when I was leaving, so I am guessing now it's complete.
Ah, ok.
It also requires HTML... ever thought of that, Einstein?
Thanks. Maybe I will play more with @RequestBody and write a custom ViewResolver (used within the ContentNegotiatingViewResolver). I considered that before. That does not change my feeling about a missing comprehensive way of building REST applications that are centred around entities (the data) and their representations rather than HTTP. Even JAX-RS is flawed in this way. I use Spring and JAX-RS for years, now - Spring for more than 10 years. And as my understanding of REST matured, I find that all these approaches are somehow limited. But maybe that's just the engineer in me, searching for commonalities in something that isn't easy to generalise. The perfect REST framework would abstract the HTTP stuff away. You manage a set of entities that are addressable by their URIs (even multiple URIs and schemes per entity). Want to render HTML? Just use that entity as a model to whatever HTML template system you use. The same for whatever representation you want to support. I guess, it would be something between JSF concepts (component based) and GraphQL, when I'd start writing such a thing today. The hardcore test would be conversation via email (sic) where the email address represents the URL.... ;)
Other exciting new Java 9 APIs: * "java.awt.desktop" package (e.g. taskbar progress bar) * Runtime.version() * InputStream.transferTo(OutputStream) * Enumeration.asIterator() * Integer.parseInt(CharSequence, int, int, int)
FWIW, here's how I am parsing the OptaPlanner annotations (@PlanningSolution, @PlanningEntity, @PlanningVariable, etc): https://github.com/kiegroup/optaplanner/blob/master/optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/solution/descriptor/SolutionDescriptor.java#L191
Is batch processing a good use case for JPA? JPA seems to me best suited for OLTP type applications, where you are operating on a few rows at once within a unit of work. I understand batch processing to mean dealing with large volumes of data, and using hibernate/JPA for this slows things down considerably. I can't see the benefit of using JPA this way unless you have a complex object model which gets unpredictably dirty, in which case JPA's dirty checking mechanism can help collect and batch together changes. But in this case, I'd rather devise an object model better suited to batch processing than online processing, rather than trying to make the entity manager work better under extreme load.
Recognition is the big one. Invitation to JC-only events at JavaOne. Some discounts WRT JavaOne. And access to a private mailing list where JC's discuss happenings in the industry. But primarily, recognition from peers and the industry. If I've forgotten any other ones, hoping some JCs will add them.
The real issue here is that the form submit itself, with Spring, is a post and refresh, that completely blows away the current state of the page. There's currently no way, outside of a json/Ajax post to get rid of this behavior. Granted, the last time I tried to tackle this problem was a couple of years ago, but from the complaint, it still seems to be an issue. 
In this particular case, that's not an issue since it's a POST originating from Slack. I would argue, though, that Slack could support both `application/json` and `application/x-www-form-urlencoded` or just support `application/json` at this point.
&gt;In my projects the serializer/deserializer both accept a simple filter method ref/closure that takes in an object and returns a standard serializable structures or vice versa Yeah - this is the limitation I'm talking about. Every time you invoke e.g. `deserializeList` you need to supply a deserialization method . You're doing method dispatch manually/statically because Java lacks this kind of polymorphism. Passing around class/type info is currently the only way to emulate it (you can see this pattern used in the standard library e.g. EnumMap's constructor taking a Class). Notice how this limitation doesn't exist in the opposite direction: a `CanSerialize` interface allows e.g. a `serializeList` to be written that doesn't require a concrete serialization method to be passed in.
web-apps are supposed to be built using JS, not web-pages that contain static content.
You're a good person.
Well, create a burner account and tell us what site you're looking to crawl and what you've tried so far. There are off-the-shelf crawlers.. but usually pulling the data out of a web page is a lot of trial-and-error and hope they don't change the html before you're done. As far as captchas go, pulling out the image and responding with the correct answer doesn't usually work.. but embedding a web browser in the app (SWT works) and using that to log in always works.. then just scrape the cookies and continue. Obviously not meant for mass scraping of a big site using lots of different (stolen?!) credentials.. but OP can clarify what the goal is. 
Not sure that whatever responses come in here will be a representative distribution of Java developers but at least for me I work in enterprise software development. Specifically a SaaS web application. One year removed from college.
Here's some tips if you wanted to get started in your own: I am assuming you are using a JFrame, or other AWT or Swing component. Just override the paintComponent method (takes a Graphics object as parameter) the graphics object has lots of useful methods such as A. drawRect B. fillRect C. setColor and so on. This method gets called when the component becomes visible, or whenever you call the repaint(); method. Side note: you can cast the Graphics object into a Graphics2D object, which has extra cool methods.
What frameworks/tools do you use on a daily basis, if you don't mind me asking?
Survey, but why the time restriction? What's in it for the one person that does your test or interview 
I still don't quite understand what the problem is... I often have to inject deserialized objects with context that only I have, the deserializer doesn't, so I need the filter function anyway. I see no reason why more types of polymorphism changes any of this. It's not type system related at all.
Websockets. 
The problem is that Java has limitations and that metaprogramming through reflection is a good way of addressing them and expanding the capabilities of the language (and platform). You might not feel the impact of these limitations but I do and so do others who are used to using reflection effectively - often to enable things that are possible natively in other languages. &gt;I often have to inject deserialized objects with context that only I have, the deserializer doesn't Your deserializer might be able to infer this context if it could reflect (even if it was as minimal as looking up a Class instance in a map). The fact that you don't feel the need for features that you aren't familiar with is not a compelling argument against reflection. It's no different than someone from a C background saying "I've never needed lambdas." Consider a non-deserialization example. The standard library's EnumMap class. Why do you think it uses reflection? What is your alternative implementation that doesn't need to reflect?
JEE, Android, Swing/JavaFX, whatever the customer is willing to pay for. As consulting company we also do .NET, C++, Objective-C, Swift, it is only a matter to jump between projects when the opportunity comes around. Usually the projects take between 6 months and one year, which gives time to refresh knowledge and go into cruise mode.
Is that really your specialty or are you just joking?
I'm pretty good at strings
java archaeology. :( (i'm kinda like a corp version of an indiana jones)
And an inspectIT commiter here. Last week, inspectIT has been released in the version 1.7 which includes tracing over multiple JVMs via HTTP and JMS. Using this feature you can track your calls through your Java cluster: http://blog.novatec-gmbh.de/inspectit-1-7-cross-jvm-tracing/ Docs: https://inspectit-performance.atlassian.net/wiki/display/DOC17/Working+with+remote+traces We also support the OpenTracing API. So if you have an application which is already using this you will get additional information out of your system. Greets!
&gt; The problem is that Java has limitations and that metaprogramming through reflection is a good way of addressing them and expanding the capabilities of the language (and platform). You might not feel the impact of these limitations but I do and so do others who are used to using reflection effectively - often to enable things that are possible natively in other languages. Sometimes the shortest path from point A to point B is not a straight line, but reflection gives you that, allowing you to shoot yourself in the foot in the proces... Case in point: &gt; Your deserializer might be able to infer this context if it could reflect (even if it was as minimal as looking up a Class instance in a map). What you're describing is one of the most widely spread abuses of reflection: the "autowiring" dependency injection container. An approach that takes a pattern (Dependency Injection) whose intent is to avoid global state and singletons, and then turns around and emulates global state and singletons via a map of objects that are matched to constructor arguments via type. This is precisely the kind of botched architecture reflection abuse results in. &gt; The fact that you don't feel the need for features that you aren't familiar with is not a compelling argument against reflection. Me not feeling the need is not an argument, but your suggestions of how I should use it is. Because if the goal is decoupled, reusable code and flexible object configuration, relying on reflection takes those away from you. &gt; It's no different than someone from a C background saying "I've never needed lambdas." It is different. Let's not stoop to arbitrary straw man arguments. &gt; Consider a non-deserialization example. The standard library's EnumMap class. Why do you think it uses reflection? What is your alternative implementation that doesn't need to reflect? Are you referring to the single use of `java.lang.reflect.Array.newInstance`? That hardly counts as a typical use of reflection. It's not reflecting anything, it creates an array using an API which should possibly not be in that package. Or do you refer to the use of `sun.misc.SharedSecrets`? Well, the standard library has access to this package to implement core routines and data structures. And it shouldn't be accessed by anything else.
&gt;What you're describing is one of the most widely spread abuses of reflection: the "autowiring" dependency injection container. What I'm talking about has nothing to do with dependency injection. DI is a separate issue. On that note: a lot of programmers consider DI valuable and save themselves time and energy by using it. What is your alternative for them? &gt; but your suggestions of how I should use it is. I'm not telling you that you *should* use it. Write your code however you like. But your idea that reflection is only for side concerns like testing/debugging is personal to you and has nothing to do with the Java language, platform or ecosystem at large. Reflection is intended for metaprogramming. Don't like it? Then don't use it. &gt;it creates an array using an API which should possibly not be in that package It's in that package because arrays have reified type info that you need to pass in if you're creating them dynamically. &gt;Well, the standard library has access to this package to implement core routines and data structures. And it shouldn't be accessed by anything else. You don't need to access SharedSecrets to do what EnumMap is doing. You can getEnumConstants using the public reflection API. So reflection allows external libraries to provide things like EnumMap. What is your alternative?