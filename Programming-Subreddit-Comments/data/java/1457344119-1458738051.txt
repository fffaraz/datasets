Try /r/programmerhumor instead. 
Such questions should be posted to /r/javahelp as is indicated in many places on this subreddit. Nonetheless, all you need is an `if` statement that assigns the proper conversion factor and the normal way you do your calculation (which probably involves the `switch` statement). So: + Make a constant for the pound to kilograms conversion + Ask the user what they want + Calculate the weight as you have right now (most likely `switch`) + If the user wants the other unit, apply the conversion (`if` is sufficient here - a `switch` would be overkill for only two choices.) + Output the result. And if you want to do it in an even nicer, more advanced way, look at the second part of the [**Enum tutorial**](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html) from Oracle (pretty cool way used there).
I do agree with that. It's bit of the Achilles heel of OSS. Everyone is perpetually mentally exhausted and/or has other things to do all the time. What actually should happen is that it becomes normal that during that 8-12 hours day job you (the company) contribute when you use OSS. Although it's practically what happens, contributing back shouldn't be reserved to that 1% with unlimited willpower.
Is that pre-processor open sourced? Example in the blog post can be processed by *sed*, but I imagine you may have more complex expressions to support...
From the comments (by u/lukaseder): &gt; It’s a quick and dirty fopen-string-replace-fwrite-close script. And yes, indeed, it contains some extra statements tailored for jOOQ to remove imports, SQL dialect references, file headers, etc.
Not really. A circular reference is what you potentially get once the objects are instantiated. The post is mostly concerned with class initialization which happens before. The initialization process statically walks through the dependency graph and initializes each class along the way (= recursion). If it happens to get into a loop, you'd get an infinite recursion were it not for proper locking as explained in the article. Just because two classes mutually depend on each other does not mean that there have to be two instances that reference one another.
There are semantics about SNAPSHOT that are more significant than a textual representation of a version number. See the highest rated (as opposed to selected) answer here: http://stackoverflow.com/questions/5901378/what-exactly-is-a-maven-snapshot-and-why-do-we-need-it
I'm not much of DevOps guy, but creating a Spring Boot with embedded Tomcat is so easy I wonder what's the specific steps to secure or harden it for production deployments for, say, AWS EBS? 
To add on to this question. Anyone here deployed fat jars to a clustered production environment? I'm trying to figure out what options are available when using built in Tomcat or Undertow.
I hate snapshot versioning. I don't use it. If you're deploying artifacts to your own repository, then you can enable asset overwriting and enforce your own versioning scheme. Essentially every build overwrites the previous artifact. This fits more with CI than snapshot builds. 
We do too.
Oh ok, thank you for telling me.
haha, pretty awesome state of Java survey. I guess 5 questions, all about spring, will give a pretty accurate result. 
Wow &gt; Are You Using Spring Boot? Only **Yes** anid **Not Yet** are possible choices
When I read "Not Yet" I get this feeling that the Spring Boot developers (or the survey creator) will port Spring Boot to Java ME (so it runs on devices with only 1MiB of RAM). Looking at their API, I do not see that happening anytime soon.
Your query could implement Closeable which as been around since 1.5 and now extends AutoCloseable.
&gt; I know a good way. Just write Java 6 code. Ehehe... This doesn't work when your downstream users want to interface with newer APIs. 
I'd be interested to know what percentage of jOOQ's customers still use Java 6 and the percentage of their revenue stream is composed of the Java 6 customers. At what point does it make sense for jOOQ to stop supporting Java 6? Never? In ten more years? I do understand that certain industries, like finance, can have very strict change controls and stringently conservative white lists of technologies and vendors to use in production. Certainly, I don't envy jOOQ's need to maintain such thorough backwards compatibility.
I feel like this would make your code very, very ugly.
This isn't Java in 2016, this is "Spring in 2016." 
Basically ifdefs all over again. Have you tried looking to this? https://github.com/raydac/java-comment-preprocessor
Isn't the scene builder written with JavaFX?
According to [Spring Boot Actuator's page](https://spring.io/guides/gs/actuator-service/), you don't need to do anything regarding the embedded Tomcat. Additionally, search for the keyword Tomcat within the following [page](http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/). It contains tips to tweak Tomcat or replace it with Jetty and Undertow. 
Thank you for the thorough reply. I agree that library code is a different beast compared to business logic for any particular domain.
I know it's sarcasm, but just wanted to report: I haven't found any regressions or API breaks.
There is effectively no difference between a standalone (i.e. installed by a package manager) Tomcat server vs. an embedded one, as long as you run the latter with similar privilege separation, etc. In fact, the official Tomcat 7/8/9 Debian + RPM packages are built from the associated Maven packages!
What kind of Java are people writing that is actually JVM-version-specific? Aside from using Unsafe, etc, what stands in the way of upgrading?
Thanks for your reply, that definitely sounds like a good use-case. Why did you decide to use two frameworks rather than using jOOQ to interact with your predefined schema as well?
Cool, that does sound like a rather big company relying on jOOQ! What were the reasons why your company decided to go with jOOQ? Was there any concern about continued support for the framework? It also sounds like you're using it for a niche use-case, similar to /u/scadgek's answer - so same question: why only for interfacing with legacy applications? Thanks :)
Nice work! I found this searching around for exactly this, and it is very thorough. 
I mostly write for an embedded platform that is 1.3 (J2ME). Java 8 has new compact profiles and the controller line I work on is starting to ship with that, so I'll probably be able to fully transition to Java 8 in a year or so.
I don't really get why they didn't just use the c preprocessor. It's mature, stable, nuanced... If adding a preprocessor to your java code is acceptable, isn't it better to avoid reinventing the wheel? This is how, ten years from now, you end up with an impenetrable DSL
Is that what other languages / libraries call `Either`?
"How to make sure no one ever dares to fire you"
They just fire you quickly. Because it is cheaper to let someone understand the code made until now than to wait ten years and have more stupid code that people need to understand.
Hehe, I know management is not perfect but I also know most people are more easily replacable than they think. What ever weird trick they used will not help. :-)
Union2 is like Either, yes. There was an alias at some point but I found it wasn't part of the core. One difference is that either in other languages comes with more operations and is used as method return. In here the focus is on data definition.
Maven frontend plugin install node and npm automagically for you. btw: maven is also included via maven wrapper. You need only java
Last year, we introduced jOOQ in a project that has seen &gt;150 man-years of effort over the past 7 years. We use jOOQ as an alternative to Hibernate in performance-critical areas where we need to exercise full control over the rendered SQL or where the use of more esoteric features such as Oracle's advanced queues is justified. We've made very good experiences with jOOQ in smaller projects before (6 man-years, 1 man-year), so we knew this would work just as well in a large scale. And so far it did :) For us, jOOQ has proven to integrate well in a complex project landscape. That is partly due to the fact that jOOQ is much more of a library (a passive component that you choose to use the way *you* intend to) than a framework (an active component that imposes certain rules upon you).
Do not even bother, you will learn nothing from understanding that. This code is written so ineffenciently and unmaintainable.
You need to understand that Hibernate and jOOQ address different needs, rather than representing two solutions to address the same need. If you just need to persist your entities, and don't really care about the generated SQL from Hibernate, then Hibernate is by far the better choice. It grants you the ability to evolve the objects you write without worrying so much about backend persistence, apart from applying the necessary JPA annotations and making sure your DB is running OK. Hibernate proved to be a pain point for people who needed to generate very specific SQL queries, typically because: a) there was a pre-existing legacy DB that their program had to work with or b) their DB vendor had some vendor-specific SQL that they wished to exploit So jOOQ came along in essence to represent the DB and its specific SQL variant in Java. It really comes down to which is the more inflexible component in your architecture - if your entities independently change all the time, and you're trying to manually keep the DB schema in check instead of letting Hibernate manage it for you, then you're going to constantly be fighting the SQL that Hibernate generates. If your DB schema independently changes all the time, and you're trying to keep your entities coupled to the DB schema, then you're going to constantly be fighting the classes that jOOQ generates. The only real benefit then is that it's usually easier to adapt the rest of your codebase to breaking-changes jOOQ objects (especially if you hide the jOOQ objects behind a Facade) than it is to figure out why Hibernate is generating a bunch of garbage SQL. If your Hibernate entity graph ever gets so big and complicated that the SQL queries that Hibernate generates (with a bajillion joins) are getting to be too slow, then odds are that you've coded a monolith and the time has come to refactor into microservices. But if you're using jOOQ, then you're never going to refactor into microservices, because the primary driver of design/architecture for your system is your DB schema, not your business-logic application servers, and why would your DBA ever split up a relational DB schema? Hibernate and jOOQ are not two different ways for applications to talk to databases. Hibernate allows the application design to dictate the DB schema, and jOOQ allows the DB schema to dictate (parts of) the application design. Trying to use them in an opposite manner (Hibernate adapting to a changing DB schema, or having a DBA write queries to fit an object hierarchy) is a recipe for pain. They really are for very different mindsets, so you need to figure out which is the prevailing mindset in your organization/system and choose the framework that best fits that mindset.
JEE and probably also JSF will probably stay for a while, especially with llarger companies. They are slow to adapt and tend to go with whatever has been proven to work before. Angular is actually at a point where it is used in enterprise projects and Spring (Boot) often go along with that. Primefaces isn't too bad in my personal experience. Generally the more frameworks you know, the easier it becomes to learn new ones. It all boils down to: Enterprise world = older or absolutely outdated technology. A lot of different sizes, technology stacks, organizational structures, etc. in between. Startups = bleeding edge (new frameworks every week).
Haven't used it yet but I want to applaud the inclusion of easy to grok self sufficient [code examples](https://github.com/atomix/atomix/tree/master/examples)!
JSF is fine as long you can re-use the components it is providing you. But JavaEE was lacking an action-based framework like Spring MVC did. With JavaEE 8 we are getting MVC 1.0. Requirements about JavaEE are generally stable to invest, since the iteration cycle is 2 years. JSF is generally very nice for startups, since clients can just look through all the different components and they can tailor their needs visually without drawing themself. HTML5 initialized a lot of inovations, so actually predicting it is rather difficult, since in Javascript world you can expect, that the trend will change in about 2 weeks. Imo it is important to learn the different aspects of each framework so you can learn a new trend very quickly and evaluate if it is something you want to do. 
Thank you for your time and comment. To be honest I've been into many languages since I have a habit of exploring new technologies. But no other language rivals Java when it comes to organized, scalable and maintainable code. Java did made it easier for me to learn almost anything. But then again the problem with me is that I really don't feel JSF. Its not that I'm having a hard time learning it, but I just don't feel comfortable when I'm developing it. Maybe because I've been also exposed to heavy plugins and libraries in Javascript. 
I personally know more than just Java but still prefer Java for backend. Many rontend technologies work with Java. I have used different ones on different projects and it has never been a problem. Your Java experience will be the main take-away from the position and it will stay relevant for a while. Of course actually using new features of Java 8 is a plus, but getting into the typical technology stack once will make it quite easy to adapt between different Java alternatives. Even Spring vs. EE are not that different and I have transitioned back and forth without much hassle.
Hazelcast seems to believe they're faster: https://hazelcast.com/resources/benchmark-pivotal-gemfire-vs-hazelcast/ ...of course, one must always consider the bias of the source.
Ah yea all my KDE applications are fine, just not the Java ones ;)
Might help: http://stackoverflow.com/questions/26877517/java-swing-on-high-dpi-screen
I'd start looking at Play if you're interested in front end -- there's an integrated stack that will manage Angular JS for you. * https://www.playframework.com/documentation/2.5.x/Tutorials#AngularJS,-RequireJS-and-sbt-web [EDIT: more up to date and has really great tutorials, but uses Scala for controllers / JSON] * https://www.toptal.com/java/building-modern-web-applications-with-angularjs-and-play-framework 
they should rename it "the Spin Framework"
&gt; it will never be [JEP 263: HiDPI Graphics on Windows and Linux](http://openjdk.java.net/jeps/263)
JSF is definitely a step backward if you already know web development. The "dream" of JSF was to make web development "easy" enough to drag and drop "components" to make a web application. In practice this doesn't actually work and JSF is basically an extra 2 or 3 layers of cruft between you and "real" web development. JSF was standardized in 2004, and JSF 2.0 came out in 2009. Web development has grown and changed drastically since this time, but since JSF is part of the Java EE standard lots of people and companies assume it's the way you're "supposed to" build Java applications on the web. I personally consider it as a red flag to not take a project (unless it's a project to migrate away from JSF).
[**@markawest**](https://twitter.com/markawest/) &gt; [2016-03-08 15:46 UTC](https://twitter.com/markawest/status/707230935213875200) &gt; @tfnico Let me try that again…. &gt;[[Attached pic]](http://pbs.twimg.com/media/CdCWyTkXIAAkBLv.jpg) [[Imgur rehost]](http://i.imgur.com/r1DbkTX.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) ^(Starting from 13th of March 2016 /u/TweetsInCommentsBot will be enabled on opt-in basis. If you want it to monitor your favourite subs ask its moderators to drop creator a message.) 
I suppose such a thing would look better in bash or something, Java seems to be an overkill for this. But still, good job!
Check out Speedment. The UI is written in JavaFX. https://github.com/speedment/speedment
The frameworks you are mentioning have little chance of surviving. Play and Spark hardly register in terms of usage. Drop wizard is a little more realistic as least. By far the two most popular frameworks for Java today are Java EE and Spring. Spring actually uses a lot of Java EE stuff.
You can find work with lots of different frameworks using Java. Its kind of the blessing and the curse of it. The most popular today are Java EE and Spring. Java EE has gained a lot of market share over the last five years and especially JSF. No one can say if things will continue in that direction or not. You can aim for using more fringe stuff like jHipster. You just have to accept the job market for such frameworks is not as robust.
Hello, I am the author of the article. Spring MockMvc is using to fake requests to your spring application in order to test it's behaviour. This would be for faking an external web service that your web application would call - you may be getting mixed up with MockRestServiceServer
I did, still everything was very small.
I tried with JDK 9 build and it works fine :) Thanks :)
If you are just starting out with Play, look at the tutorials page and watch the Java video: https://www.playframework.com/documentation/2.5.x/Tutorials
Can't believe nobody mentioned [Scanner](https://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html#method%5Fsummary).
I know. I was meaning the full stack mocking. My point still stands though. Wire mock is also an alternative. 
Looks highly configurable since you could swap out the transport easily. Wonder what bandwidth looks like for some of the distributed consistency. I too would also be curious about how it compares to Hazelcast. One thing Hazelcast has going is the built in automatic discovery via multicast. Makes it easier for novices to get up and running. Nice work!
Why not [JavaRa](https://singularlabs.com/software/javara/)? Worked for me every time.
Is this a Java argument? Because I think JMeter would simple ignore this argument.
Jhipster is more complex and powerfull bu it's different story because jhipster using angular 1, gulp and yeoman to scaffolding
We discuss [Atomix versus Hazelcast](http://atomix.io/atomix/docs/comparisons/) a bit in the docs, but see [my comment above](https://www.reddit.com/r/java/comments/49hbcn/atomix_an_open_source_software_stack_for/d0shu30) as well. Atomix does indeed choose static configuration, at least to get your initial cluster up and running, over Multicast. But it's pretty easy to join additional nodes and clients to a cluster once it's up and running - just point to any member of the cluster and other members will be discovered automatically as needed. In terms of bandwidth, there is always a cost for the strong consistency that you get with Atomix versus a system like Hazelcast. That said, depending on your network, write throughput can still be on the order of tens of thousands of reqs/second. And while Atomix does support strong (linearizable) writes and reads, you can optionally use a more relaxed [consistency level](http://atomix.io/atomix/docs/consistency/#consistency-levels) if you wish, such as for reads, such as sequential consistency, which will yield higher throughput since it does not require going through the leader or contacting a majority of the cluster and still provides very strong guarantees (writes will never go back in time).
node.js is trending nowadays and Oracle fired JEE evangelists. Android seems to be the safe bet in Java land. 
https://www.ethereum.org/ and the current contreversy: http://bitcoinist.net/ethereum-development-reality-check/ from https://news.ycombinator.com/item?id=11246853 
In answer to MockRestService server, it'll be quite common to deploy your application with passing tests and discover the manual process of stubbing the external service was erroneous. It also doesn't use real http, so essentially creates a different spring context that mocks it so you end up not testing the thing it's doing (orchestrating http). It's still a useful framework but I wouldn't use in when integration testing a service. Wiremock is a great tool and quite similar, especially as it allows you to record real services - it's also alot more feature rich than this rule which is in it's early stages (for example a DSL). The advantages come from Hoverfly which the rules wraps - it's a single binary that can run on a machine without the need for a JVM or any other dependencies. It also allows third parties to build custom middleware in any language to intercept and modify requests, and as it acts a proxy you don't have to point your service to it like you would with Wiremock. Finally, Go is very fast. I'd take a look at the github: https://github.com/SpectoLabs/hoverfly. So in summary, the JUnit Rule is just a wrapper to help Hoverfly to fit into Java tests.
Yes
Square recently posted a blog about one of their services that uses jOOQ. https://corner.squareup.com/2016/02/spot.html
Maybe
Learn both. It will always be helpful in some way. I myself find JavaFX a lot better to work with. Easier, more consistent and more intuitive.
I tried GWT for the first time last week, and I've really been enjoying working with that. I was able to get a simple report generator with login up and running very quickly with just Java. Time will tell whether that will catch on for any broader applications, but I personally like not having to write JavaScript.
It'll make your life a lot easier. Especially when working with Scene Builder to build your GUIs visually (similar to Visual Studio's form editor).
Nowadays Java is rarely used for rich clients. So it is not about Swing or JavaFX but Java in general. The power of Java mostly comes in kicking in server side back-end applications which require a relative long startup time but have rather fast execution speed. There are always companies out there which pay you for having knowledge of a 10-15 year old technology. So yes, it is still used but outdated too. Bugs will rarely be fixed in Swing. As far as I know Oracle is not focusing on JavaFX, but it is the intended Rich-Client library to go for. It has a cleaner API and IoC introduces new technologies to play around (make the dev happy). Using FXML is introducing nothing new and has some drawbacks like reflection speed. The tooling is already given with SceneBuilder and integrated into the major IDEs (Eclipse, IDEA and NetBeans) **TL;DR** learn JavaFX but dont spend too much time with it
Is Scene Builder the NetBeans Designer? I always worked with Swing because it was implemented in NetBeans... This is the first time I even read about something other than AWT or Swing. But I am just a hobby programmer anyway. 
I always swore to eclipse. Though after been using IntelliJ for a while I just can't imagine using anything else. It's responsive, does what it has to do etc. I love the fact thag eclipse is free and open source but IntelliJ is simply superior.
https://github.com/ has a search function.
I'm not aware that Swing is deprecated.
mind elaborate it?
https://en.wikipedia.org/wiki/Embrace,_extend_and_extinguish
Thank you for taking your time to comment on my post. I really appreciate it. I have a follow up question if you don't mind. In your own opinion, would it be a better career path to invest in Spring boot rather than go with JSF and JavaEE? Because honestly I don't want maintaining legacy apps and be stuck with it. I'm really liking JHipster and planning to contribute to them. The idea of combining Spring boot and JS frameworks really suited me well. 
I agree with you. That's the main reason why I submitted this question. I can't let go Java because I really like Java as a backend. But developing in JSF is something that I really don't like. 
That will come later. I wouldn't be surprised if their positive experience with VS Code leads to cross platform tools (SSIM, etc) all around.
The widgets aren't that's correct or I may be remembering an old coding video where I saw Notch using some Swing code.
Basically Microsoft has finally realized that they can't beat Java. Took them 15 years to realize it (like a dim witted inbred retard) but better late than never. 
... and your point is ?
The two big things keeping Swing alive (for now) are Eclipse RCP and the NetBeans Platform. Both are very powerful for getting up and running with a comprehensive set of features that users have come to expect from Rich Clients. That said, if we could get Eclipse RCP or NetBeans Platform re-written in JavaFX, that would be *huge*. For now though, for a new Rich Client project I would probably use Eclipse RCP or NetBeans Platform for the main app window/toolbars, but for all of the custom, domain-specific sub-windows, I'd use JavaFX panels (since you can have JavaFX panels inside of Swing Panels, and vice versa).
Microsoft is everywhere these days. They seem to consistently commoditise all of their "minor" offerings in order to increase Azure's value. It's an all-or-nothing race for cloud dominance - being Amazon's only significant competitor
Welcome to the wild west. Anything goes. Any prediction both pro and contra Java EE is made by snake oil salesmen.
It's not dead. For example if you write plugins for Netbeans or IntelliJ then the UI is in (extended) swing.
IntelliJ platform is using Swing as well. So there's that...
definitely worth learning if you ever need to write a plugin to an IDE.
It kind of is though. Depends on your definition of deprecated... While Swing isn't likely to be dropped any time soon, Oracle do state that Java FX is intended to **replace** it for building rich desktop Apps in Java now. See point 6: http://www.oracle.com/technetwork/java/javafx/overview/faq-1446554.html
ITT: "JavaFX is a really good, modern fit for your requirements but don't use it because the herd say it's not cool."
&gt; b3 boolean := case null when 0 then false when 1 then true else null end; why is it null? why not an input binding variable? Oh, I just dropped the version that has been generated with inline bind variables for logging. jOOQ can do that on the fly. Of course, there are `?` in the version sent to JDBC. &gt; why didn't you generate bind variables for the parameters with default? Because in that particular call, the values were not passed to the procedure call. Once you do pass them, they're generated. I'll let you think about how to distinguish `null` = `default` from `null` = `null` in Java. It's possible, without any tricks (although not in a single method call) :) &gt; For primitive collections, I wrote this "converter" Yes, but can you do this for *PL/SQL* collections (including associative arrays)? I.e. collections declared in a package? Because those cannot be passed via JDBC up until 12c (and even in 12c, there are caveats). jOOQ can handle nested *SQL* collections and object types of arbitrary degree of nesting, but not *PL/SQL* types.
Just trying to get people into a secure version...
StackOverflow is more than enough when I search for something. What do you use code search for?
I think you're missing the point. Microsoft is WAY past the point about caring about Java. These days they're finding themselves a bit confined by Windows Server because the war for the server OS is no longer nearly as relevant as it used to be. Now their primary concern is to become your computing utility company (a.k.a. 'cloud') vendor of choice. You may not think of them as the white knight in this race, but really we do need alternatives to Amazon and their tooling is pretty nice. Just be glad we'll continue to have options.
no one said Java FX is bad - it's actually a pretty neat framework. But most desktop applications are for Windows computers only - therefore C#/.NET is a perfect choice. Whenever an application needs to run on multiple devices (PC, Mac, iOS and/or Android devices) you will usually go for a (Java) web application instead of building a rich UI.
With JSF it really depends which library you are using. While Primefaces has some really neat features like: * support of HTML5 data attribute passthrough * reloading parts of the page using AJAX * ability to call server side bean methods from JavaScript * ... This gives you the ability combine the benefits of JSF with any client side JavaScript library of your choice. If your application makes extensive use of either EE or Spring Beans, using JSF as described above will require much less boilerplate code than with Spring MVC (or most other Java web frameworks).
You use it to find in context examples of how to use an API or best practices from what's used in practice. Stackoverflow can be a dumping ground of short snippets, but say you wanted to see a larger piece of software's implementation, then a well linked code search engine is much more helpful.
&gt;&gt; Let me add **1-2 words** here. &gt; &gt; Haha ;) Honest intention, promised :) I absolutely agree with you, social proof is important, and so are user examples. I just wish people would blog more... At a conference, I met an employee of the ISO standards committee who used jOOQ as a way to reason about relational entity graphs on a very high level. They implemented some funky prolog constraint solver on top of their complex database schema. jOOQ just happened to provide a nice API for that, the real innovation was in their code. Who would have thought of that? Similar to a user who implemented a [topological sort in order to auto-generate join graphs](https://groups.google.com/d/msg/jooq-user/tIjEH8LK9nA/bxd3e1vvDAAJ) for very dynamic SQL statements. &gt; now it's just up to what everyone else thinks ;) Sure thing. I hope everyone else will be able to convince you as well. If you do choose jOOQ in the end, promise me to write 1-2 blog posts, though! :)
It is all Electron platform now for desktop apps. 
In the past, yes. Lately, they've really been participating in open source.
This article is just a rehash of the original blog post.
Submitted 2 hours ago: https://www.reddit.com/r/java/comments/49n58p/java_evangelist_leaves_oracle_to_save_java/
In other (non-)news, tons of people continuing their every day work at Oracle on Java
Isn't Eclipse RCP based on SWT?
Yeah, I'm hoping that there will be an article from a major outlet soon that DOES highlight the real issues.
Heavy names? Yes. [Heavy in the cloud? No](http://www.datacenterknowledge.com/archives/2015/05/28/gartner-aws-pulls-further-ahead-in-iaas-cloud-market/). The race is pretty lost
The only thing I'm seeing is: - Rumours and FUD (that happens everywhere) - Disappointed comments from people who are - obviously - disappointed (that happens everywhere) - Utter lack of official PR from Oracle on the subject (must be a corporate thing) - Years of Microsoftesque (Dilbertesque?) mistrust from the community towards the steward (must be a another corporate thing) Hence, business as usual, hence non-news. (Don't get me wrong. I'm not saying that nothing is happening. I'm only saying that nothing real is being said. I suspect Oracle NDA expire like copyright. After 70 years) &gt; In such a fast moving industry and with such important deadlines and so much work to do, putting everything on halt for many months (half a year or longer) is just crazy, and wouldn't happen if there wasn't some kind of problem. I thought that being oblivious to the industry's fast pace was Java EE's key asset? :)
How is this relevant to this Subreddit? You could've at least submitted its [Github repo](https://github.com/tchoulihan/referendum) instead.
IBM owns Softlayer, one of the largest VPS providers out there.
You can't buy something that is not for sale. Google's chance to open java was when sub went up for sale.
Clearly, but often the right thing to do isn't to give people what they asked for, it's to give people the tools to solve the actual problem properly. e.g. "Can anyone give me a regular expression to parse HTML?"
1. No code help here -&gt; should be in /r/javahelp as is indicated in many places on the subreddit 2. Here and in /r/javahelp: No **"do my work"** posts 3. You don't even spend as much effort as to prepare a proper post where you explain your needs in detail - no effort, no help. **Post removed:** wrong sub &amp; "do my work"
&gt;The only thing I'm seeing is: [...] If you're looking at the real activity levels, it's quite easy to see. The comments on the original blog had some good overview. &gt;I thought that being oblivious to the industry's fast pace was Java EE's key asset? :) I'll bite, but no, it's still a lot of work that's normally done daily. That work is now not being done by Oracle. Oracle spec leads and engineers have just vanished from the scene. You don't see them anymore. Period. All the activity that you do see on Java EE is from Red Hat, IBM, Apache and several individuals like BalusC (for JSF).
While a great link, there is something to be said that it's not quite as "accurate" for IBM. IBM owns SoftLayer as /u/ryosen pointed out, but they also have [Bluemix](https://bluemix.net) which is an awesome product but not quite at the level of AWS. I feel like Gartner missed out on that one a bit. Hard to argue with Gartner, though. 
Good point, thanks!
Heh. The site is just an illustration of how it would/can work. Its not verifying your identity if that's what you're asking. As far as private polls though, you can lock polls to only those who know the password for it, or to users who have to pass captchas, if you want. 
I use it for Unity on OS X, it's great! There isn't a great vim plugin though which is rather unfortunate. 
Every UI I write is either Swing or (more likely) HTML/Javascript, talking to a Java backend. If anything, I would say that JavaFX died before it even got off the ground. Of course, I work mostly in Enterprise applications, so that colors my worldview. People that do a lot of desktop programming might feel otherwise.
Easy deployment. Getting apps on user's desktops and upgrading them is a pain. Especially in corporate land. 
Start with Html, slowly include css3, move on to Javascript, look at Jquery. Look at a frontend Frameworks like Angular. Take a gimmick language and a gimmick framework like Rails or Django, learn it. Create 3 apps, move on to Java. Check out Spring MVC. If you do all those steps, you are going to become an excellent developer. Yes in that order. Don't get overwhelmed by the technology, always one technology at the time.
So java will slowly become JavaScript ?
It's not code smell if you don't write it in the code. As long as you code to only use the abstract interface you're able to swap it. 
You're still writing the code even if the compiler is expanding it for you. It still opens you up to accidentally using implementation-specific methods by mistake.
No, that would be the equivalent of C#'s 'dynamic' psuedo-type. The 'var' keyword is just a way to remove needless boilerplate code.
So what? The compiler will catch the error and I'm already modifying the function. You're optimizing for a non-existent problem.
Sure, some programs are still better as desktop: IDE, image/video editing, (some) games, and anything that has to interact natively with the device's hardware. But ever since Google Docs/Sheets/etc matured, I haven't touched Office. I can pull the stuff up on any device I want. I don't have to install something on my computer. I don't have to update the version or worry that if I update my OS that it's now incompatible. It's easier to collaborate on content with other people since they don't have to install the same software, either. I'm automatically updated to the latest and greatest. Frankly, I'm amazed that given how far web technology has come that you still feel like the benefits of web applications are something that require defending...
If you don't like the feature just don't use it. You can do this in Groovy and it is quite handy: def list = new ArrayList&lt;String&gt; or List list = new ArrayList&lt;String&gt; //current java way or def list = [] 
Most of the methods commonly used in ArrayList are part of the List interface. So I don't understand your argument.
The for the advice 
You can submit feedback to the developers directly using this survey: https://www.surveymonkey.com/r/KGPTHCG Source: http://mail.openjdk.java.net/pipermail/platform-jep-discuss/2016-March/000037.html
This isn't about changing Java to a weakly typed language, though. Java currently determines types via RHS (with a bit of LHS scanning for the diamond operator). If you instantiate a variable with a concrete type on the RHS, why do you need to declare its type on the LHS as well? You've already stated what you want when you instantiated it. This is simply syntactic sugar to switch this `Map&lt;String, List&lt;Class&lt;?&gt;&gt;&gt; foo = new HashMap&lt;&gt;();` for this `var foo = new HashMap&lt;String, List&lt;Class&lt;?&gt;&gt;&gt;();`.
I do understand that. My point was that: var foo = whatevs is more difficult for *humans* to read while going through somebody else's code.
Its a single line of code completely out of context. It is entirely possible the implementation depends on ArrayList for a good reason. How can you say it is a code smell from one line? So we should never use anything but interfaces in any code? Somewhere an interface has to be backed by an implementation. 
That's exactly my point. Thanks.
Alternatively, if you like the feature just use Groovy.
I write left hand declarations maybe once a day out of tons of code. Who makes this stuff an issue? Vim users?
&gt; Although, I agree with the sentiment that a superclass should be used in a lot of cases, and that fudges with this var syntax a bit. One nice thing about having type inference is that you don't have to generalize to a superclass and then downcast if you want to write code that survives refactoring. This makes var far more powerful (and justifiable) than if it was only for omitting type declarations.
This *was* my argument but then actually using `var` in production with C# and it honestly wasn't a problem. You still have the option to strongly type it if you want, but `var` does make everything more readable. And `var foo = someObject.method();` isn't as hard as you think. Visual Studio allows you to change `var` into it's strongly typed counter part with R#. Inspecting the method would reveal the return type too. What I learned among the way was that I wasn't too concerned with what it was returning but rather what it was doing.
&gt;maybe just not use var this way? Oh, definitely. I would consider this bad practice, for sure. Java just seems to have this tendency to make good coding practice a feature of the language. For instance, requiring that the class name matches the filename. The 'var' keyword is, unfortunately, very easily abused to make code less readable, rather than more readable. That being said, when it is used well, it is actually much nicer to read. And while we are on a similar subject, the 'dynamic' keyword (ex: in C#), is *quite* useful in *certain* circumstances to make code much easier to understand, but when abused it can make code incomprehensible. 
My argument against it is code like this: var c = Class.forName("com.foo.Bar") where you don't know the type of 'c' unless you know the type the method returns (which is not obvious by looking at it)
No thanks, the few keystrokes are worth the clarity.
Seems to work a lot like C++11's `auto`, which is nice.
The type of the variable will be the type of the right hand side. No confusion. 
Greetings from Brühl, Germany, where the JavaLand 2016 concluded today. I had a lot of fun at the [code golf](https://gist.github.com/dasniko/6f53b963303db2c97ce9) (German page), so I decided to blog about it. TL;DR: Yes, Java is an unlikely language for code golfing, but if you set that aside, you'll find out that it actually isn't as bad as you'd think. Also explanations for some evil techniques.
I believe you missed the point of my question. The type of the variable in the first code block would be the interface and not the implementation of that interface.
Exactly. Anyone who've coded C# more than 2 hours realize the beauty of `var`. R#, or lint for that sake, can take care of bad coding practices.
It's moot because the way you usually use the interface, the instantiation would be in a different scope from where the object is used (through injection). The function boundary will define the interface restriction. Also moot#2 you can still specify the type of you really want to.
The language doesn't define the number of spaces to use for indentation, or where to put an opening curly, or which case to use for naming methods. Turns out we have some great inventions to keep our codebase pretty and consistent. I'll let you take a guess on what those are
You'd think so, but after spending a lot of time with C# during last year or so I find it is OK, especially using reasonably named variables and methods (and the IDE helps when you aren't sure). Then I was reading some nightmare Java today the poorly named variable I was looking at was defined at top of a 100 line method and I was trying to understand its use at the bottom of said method 
Good idea. Hey, let's also introduce `val` as the equivalent of `final var` while we're at it, to promote immutability. Why not?
That's already an option called out in the JEP, yes.
Yes, I don't think java is one of those things. Especially now when Oracle is suing for billions of dollars. I don't think that google is going to say "Can we buy java from you for an additional billion dollars?"
Thank you for the clarification.
Hm? The point is that with or without `var`, you *have* to perform the cast. Without `var`, it still looks like this. Class&lt;Bar&gt; c = (Class&lt;Bar&gt;) Class.forName("com.foo.Bar"); With `var`, you get to remove a completely unnecessary type declaration.
I mean, it kinda will be because more than likely he'll be working with someone else's code.
It means that it works whenever you're writing in this form: var &lt;name&gt; = &lt;expression&gt;; &gt; restricted to local variables This means it only works inside a method body or something like that. No using it in field declarations. &gt; with initializers Means it has to be initialized immediately when you declare the variable. You can't do any of fancy declarations that use control flow like this: var x; // INVALID use of var! if (someInt == 0) { x = "Zero!"; } else { x = "Not zero!"; }
Oh, so there's tools to retype var keywords into keywords that actually describe the data type?
this can also be supported in the IDE. there's a million possibilities, but holding `alt` to reveal infered types would be a simple one. 
I've felt this way on the past, but have come to notice that in most cases it doesn't matter what the type is. When reviewing code, I care more about what it's doing at a level or two higher than the type system. The types are there for the compiler and our editors, but not for me.
I agree completely. &gt; and the IDE helps when you aren't sure Yep, in the rare case that you care what the type is, your editor can let you know. I've found this to be an extremely rare situation though (unless you frequently review code that doesn't compile).
If you decide you don't want var in your project then add it to your style checker and auto reject commits that use it
While `async`/`await` would be nice, I'm content with the abstractions, for example, Reactive Extensions provides.
Man, I switched to week-type language in my days jobs. It's fun, I'm learning. But at least once a day I miss something that can only be accomplish with strong type. ( Project wide refactor, Changing data model... )
To be fair, for Java devs who equate explicit and redundant verbosity to clarity, Haskell would be horrifying experience. I mean given the way var is implemented in C# you can just mouse over it or put your cursor on it to tell you the type if it's unclear. What I really like about var is it gives me the ability to bang out the code for something I may not remember the type of like in the articles example: var stream = list.stream(); Then I could quickly hit a button and let IntelliJ or w/e to replace the type with an explicit type if it adds clarity. As a newbie learning Haskell I often let the type inference figure out the type a function before explicitly typing it to add clarity.
by this post I came to know that main can be inside an interface
&gt; I want aCustService and bCustService to only have access to the methods available in the interface, not any public methods on the implementation. Why? aCustService and bCustService are local variables. There is zero risk that they'll be using something that you don't intend to use. If anything, you are just cutting yourself off from potentially useful helper methods. (I would say "in exchange for..." but really, there is no benefit what so ever in this case.)
People are not effective at reading long lines. [Source](http://baymard.com/blog/line-length-readability).
Please no! 
&gt; Anyone who've coded C# more than 2 hours I wouldn't go that far. There are still a lot of C# developers that hate `var`. 
And those keystrokes are `v` `a` `r`. The meaning of the code is a lot clearer without the type declarations getting in the way. 
&gt; However, the CLR does have an extra feature to make the stack traces look nicer that didn't exist in the first version of async/await. I didn't know that. Thanks!
I would be a huge fan of this! It would also make working with an API easier since I don't necessarily need to explicitly know the exact type returned from a method to store that result. 
I see what you did there !
This isn't changing Java to be untyped or weakly typed at all. This won't change how Java's type system works whatsoever. I'm a massive fan of strongly typed languages like OCaml, Agda and Haskell, and not a single one of them requires you to declare what type your data is. Requiring information that the compiler can figure out by itself does not make a language any weaker typed and does not change the type system. I'm under no delusion that Java's using Hindley-Milner, but it's worth pointing out nonetheless. The difficulty of debugging languages like JavaScript or Python isn't helped by the type system, you're right, though this isn't turning it into that at all. Java will keep the type system it has now and won't be any less clear unless the code wasn't clear to begin with.
I'm not sure why they don't just use the word "let". It's a lot more commonly used and "var" has connotations of weak typing that may confuse those coming from JS anyway.
No, I didn't misread it. My complaint isn't about the lexical structure of the language, my complaint is about ease of reading source code.
Based on the number of people who have written to tell me how wrong I am, I think it's a fair guess.
Yeah, that's where I got it and so what if it's explicitly talked about? We can't about shit all day long if we want. Doesn't make this a good idea though.
If you're not going to be using a proper dependency injection framework, and you want to avoid creating a factory object for every POJO you have, you still ought to be using static factory methods. Throwing exceptions in a constructor is a Bad Thing in Java, because the partially initialized object still exists before it's garbage collected, and can allow access to instance methods which depend on the object to be fully initialized. And yes, you want to be able to throw exceptions during instantiation for fail-fast parameter validation of immutable POJOs, before invoking the private constructor. Such method signatures can, instead of looking like `public static ACustomerServiceImpl create(...)`, can look like `public static CustomerService create(...)`, which would allow the programmer to write `var aCustService = ACustomerServiceImpl.create(...);`. Besides the compiler correctly inferring that `aCustService` is an instantiation of the interface rather than the implementation, this design has the added benefit of ensuring that developers cannot instantiate the implementation directly (since all of the implementation constructors are private).
Is it only for the OpenJDK? Always thought that OpenJDK was only a fork from Oracle JDK, and that Oracle JDK had no relation with OpenJDK. Am I wrong?
Actually, this feature is in c# and I think it's great. I get what you're saying but I feel as I use it I come up with way better variable names since I can't rely on the type.
I'm all for adding new language features like loose typing with 'var', but I'd much rather see core features like real generics and properties first.
Depends on what kind of job you want, but: Find project you like and work on that, and put it in a public git repository and put it on your resume. It doesn't really matter what you project is about (just make sure it's something you would want to show an employer, so avoid anything illegal, drugs or alcohol related and probably anything sex/fetish related). Even better, contribute to an existing open source project, although that can be much harder to get into so I recommend going with your own thing. Importantly, make sure it's something you enjoy. Ideally something you would actually use. Don't build stuff just because. You will hate it and probably not finish. Build something you actually want to build.
Increasing clarity by reducing redundancy in code
&gt; var foo = someObject.method(); &gt; &gt; return foo.method2(); &gt; &gt; return someObject.method().method2(); &gt; &gt; Do you really care what the return type is in that context? Well, to be fair, in this example, I could look at the return type, so I still know what it is. Still, I'll concede I don't _care_ about the type of that variable in that scope, since I'm just returning it immediatly. But the example was contrived to demonstrate that var can be used badly to hide type. Let's look at *another* example, contrived differently. [... hundreds of lines of code ...] public boolean containsBar(Bar bar){ var bars = Data.getBars(); return bars.contains(bar); } [... hundreds of lines of code ...] Scanning through that document, you might overlook this method entirely during a code review. But what if it looked like this: [... hundreds of lines of code ...] public boolean containsBar(Bar bar){ LinkedList&lt;Bar&gt; bars = Data.getBars(); return bars.contains(bar); } [... hundreds of lines of code ...] That should set off a red flag. This red flag might otherwise be missed with the var keyword. Like I said, it's all contrived as example. In practice, it still just comes down to coding style conventions. If var is only used for the assignment of primitives, literals, and objects from constructors, it would be great. When used in other circumstances, it _can_ make code harder to read. &gt;If you ban var, logic dictates that you ban method chaining as well for the same reason. As a rule, I often _do_ try to avoid method chaining, if possible and appropriate.
It's hard to make a reasonable decision based on an example that simple. On the one hand, that's easy enough to type that `var` simply isn't necessary in that case. On the other, it's an instance where the type is so painfully obvious, `var` has no adverse effect. But in greater examples, there are plenty of expressions whose types either don't matter or are super obvious, where actually writing the type for a local variable would be a redundant pain. In cases like these, `var` would be nice to have. In other cases, you simply elect not to use it because you're a responsible developer.
I cant read without those manifests. I can already see something like : @AutoInject var config; var worker =DocumentFactoryBuilder.newInstance(config).newInstance();
JAVAFX is recommended for new code, but honestly it doesn't really matter. Most important is what you prefer working with (or, if working in a team, what your team prefers working with). If you think FX is easier (and I tend to agree) then use that. If you hate it and would rather use swing, that's cool too. 
&gt;Right, but this is generally caught by the compiler if there is really something wrong with it. It's true. var is perfectly fine by the compiler. As I've said above, var is only a problem for readability, and only a problem when abused. 
I'm just going to assume that was sarcasm. While I have had the displeasure to work for developers who were so incompetent that they felt it necessary to mock simple classes with no external dependencies, I am choosing to believe that you aren't that stupid.
Historically I think you're right about 'let', but 'var' is something everyone already recognizes. If they're going to use 'var' though, then I hope they also have 'val' like Kotlin and Scala. Single assignment FTW!
I think it was a joke/sarcasm.
I'm not sure how I feel about type inference. It helps make small pieces of code clearer, but as the inference chain grows it becomes more and more difficult to reason about the program. You need to hold a lot of context in your mind to know the actual type at the end. I guess the proposed use for local variables is fine, but using it for function parameters could be a real mess.
Maybe but it still means that a var from a method call is not obvious what the type [is](/s "you fucktard").
Came in to ask if that's what it's like. Thanks!
The PSU is not beta, it just has more changes.
You don't always see code in an IDE. You may use your version control browsing / compare, use crucible or fisheye or any web based stuff to view the code. So you can't rely on the IDE to add the clarity.
Whether or not this would bug you has nothing to do with the fact that this won't change Java's type system. I'm a fan of strong typing too and hate using languages like Python or JavaScript. I understand that you think this will make code harder to understand, but you're thinking that for the wrong reasons. This will *not* turn Java into a weakly typed language and there are plenty of strongly typed languages where you don't need to state a type. If you think this is bad, then the reason isn't (or shouldn't) be because you think it changes Java's type system or somehow makes the language weaker typed. Your post criticised this change on the remark that this is because you like strong typing. I like strong typing too, and it has nothing to do with this change.
Just value classes. For the love of functional god, value classes.
Java developer turned C# dev here: Generally C# encourages you to use var when its *clear* what the type is. var x = new MySpecialObject(); var y = "some string"; var z = Factory.GenerateMyObject(); Additionally, because its *implicit* typing your intellisense will still work even when it's not clear what the object type is. Part of C# take on it is that you cannot RETURN implicitly typed object. HOWEVER C# supports dynamic typing. Its generally used in very special circumstances and it makes you incredibly aware that something could go wrong so dont use it unless you REALLY, REALLY have to. You can even return dynamic as a type. How this differs from var is that it isnt implicit, its type is UNKNOWN at compile time and only once the code is run can it check if .GetValue() is a method of that type. 
I thought Dalvik went the way of the dodo and was replaced with ART? 
Then why are our source files compiled to `dex` and `apk` instead of `class` and `jar` files respectively? Or is the case that ART also uses the same dex/apk files to maintain compatibility?
 var v = "a" console.log(typeof v) ???
What really should be added is a "val" keyword which is what is proposed above + "final". Or you could do the sane thing and just use Scala.
search /r/cscareerquestions for java
Of course.
Great. So, and what if we want to have OrderCollection not actually load all elements, but load them on demand from an ORM? And what if we want to test something else using the OrderCollection without having a db? By now we need to mock the OrderCollection.
That is my preferred method. Much more readable and you can tell by the extra indent that this is a continuation of a long command.
So, you won't use ORMlight or Hibernate then, because those ORMs replace any collections in your domain classes with ones that actually load elements from the db on demand. In fact, you won't use any Java ORM then, because that's the default literally everywhere.
That is what IDEs are for.
Yes. It was like that for Java 6. But with Java 7 the development started to be more focused on the OpenJDK and as of Java 8 it is mainly OpenJDK plus some other pieces on the proprietary JDK. For example JavaFX pipeline, ARM compiler aren't 100% the same.
I got that. If want to specify a variable of not of the type of the right hand side then don't use var. This is not a problem. 
You could take a look at Raspberry Pi, there are some java GPIO libraries around I belive. That is using Rasbian os ofc. Goodluck! :)
&gt; But I'm not wrong, because I'm stating my personal preference lol Why are you even commenting.
Java 8 added `-&gt;` for lambdas. Most people wouldn't recognize that as a keyword but it functions as more of a keyword than an operator. Before that `enum` in Java 5.0
The problem with online voting is simply proof of identity **and** proof that you're voluntarily voting. You need to prove you're you, that no one is forcing you to vote, and be able to prove that someone authorized you to vote for them (the latter usecase might not have to be supported if it's easy enough to vote online). You then also have to make sure that that person can only vote once. A referendum 'platform' is completely and utterly useless if you don't have a solution for that issue. The reason online voting doesn't exist in many places yet is not because no one knows how to build a web app. It's because the identity problem is hard to solve. 
intellisense is a Microsoft name for that, I don't know if they have any rights to the name, but anyway, the generic term is "code completion" or "code assistance" I guess.
You couldn't use it for parameters. Type inference in Java-like typesystems makes it too hard, if not impossible.
This has nothing to do with "weak" typing (that doesn't even mean anything, there is no common accepted definition of weak typing, maybe you wanted to said dynamically typing), var is still typed, just the type is inferred and doesn't need to be written.
You IDE will show a popup with the type when you hover over the var, no worries. You can still not use it when the type is not obvious, and use it for when the type would have been repeated twice. C#/C++/Scala/Rust didn't had problem with it, why should java has ?
^ This is what I meant
Great! Can we please have `var` *and* `val` like in Scala? I don't want to write `final var` all the time. 
As a Scala fan, using Java 8 has really diminished Scala's usefullness to me. That said, I'll always miss case classes and pattern matching... OK I take it back!
Good idea, I'll make some basic JavaFX stuff and just keep a copy of it all. Thanks for the input mate.
YES PLEASE!
And what if `Data.getBars()` returns `java.util.Collection&lt;Bar&gt;`, or the line would read `Collection&lt;Bar&gt; bars = Data.getBars();` or simply `return Data.getBars().contains(bar);`? Perhaps there are always at most 10 `Bar`s and it all doesn't matter. Regardless, it is not the `var` keyword that would be the problem here. 
First warning. Stay civilized. Hiding obscenities through links does not actually hide them and neither makes it acceptable practice.
But.. but.. that would be a totally different website for /u/gradler to submit from!
JSF, of course
It will make code harder to read an maintain. Generics on the other hand make it easier to read code. I really dislike the idea of var in java
I have found the opposite to be true. Explicit type decl on every variable introduces a lot of visual noise. The information it provides is often redundant and easily inferred from context (e.g. variable name and rhs). Verbosity isn't as simple as a read/write tradeoff. For many programmers, verbosity negatively impacts readability as well as writability. Strong typing also has nothing to do with explicit type signatures. Java is nowadays unique in its requirement for so many explicit type signatures.
Still not to be trusted. Linux based software is a strong competitor of MS' cash cow, the server software infrastructure. Lots of ways of disrupting by participating...
I end up undoing a lot of my stream chains if I need to debug.
It's yet one more thing that you have to learn. Now you have two ways of writing the same thing. I don't see any reason for VAR at all. If people want to use C++, then go ahead.
I do this too. Just a nitpick: how many tabs are on the beginnings of lines 2-6 and why? I like to never increase indentation of a line by more than one tab (compared to previous).
 .peek(System.out::println)
&gt; The identifier var will not be made into a keyword; instead it will be a reserved type name. This means that code that uses var as a variable, method, or package name will not be affected; code that uses var as a class or interface name will be affected (but these names violate the naming conventions.) Granted there are other backwards compatibility issues.
It's good to have var available, it's not a good idea to use it everywhere you can. I like to use var when the type can be easily inferred in the same line and when the variable is of limited use (only in a single loop for instance).
Like I mentioned elsewhere we don't just work with our code. The whole point is consistency. 
Just ban me then you ass face. I'll just create a new account later.
That would lead to a reddit general ban. Behave yourself. There is no reason to become abusive. It's a sign of poor self control and poor argumentation if one has to resort to abusive language to make their point. Well, you wanted it, you get it - banned.
Relevance?
This keyword is nothing like the one in JS.
True. And in that case, var would be appreciated, since the type of Bar.class would be super obvious.
You don't even know me, or what I like or dislike. I don't like change I don't like, if you'll forgive the tautology. I like change I do like. Love generics, that was a change. Love the diamond operator, that was a similar change (to this proposed change, at least in concept). var thisThing = new MyDerivedClassButYouDontKnowTheSuperclass&lt;&gt;(); instead of List&lt;Something&gt; thisThing = new MyDerivedClassButYouDontKnowTheSuperclass&lt;&gt;(); That's an exaggerated example, but illustrates what I don't like about this change. I can tell at a glance that thisThing is a List and a Collection and that really helps me understand its purpose as I read through whatever scope contains it. The rhs doesn't give me the information I want without having to rely on an IDE and hovering/clicking/whatever. I also, from time to time, look at strange code in Emacs, if I've downloaded it to look at it but don't want to take the time to load up a properly compiling project structure in Eclipse, IntelliJ, etc.
I was responding to the vein of comments that went along the line of, "you're wrong because this change doesn't make Java not strongly-typed". Had I said, "this change will make Java not strongly-typed", then I would have been provably right or wrong, wrong in this case. What I did say, though, was, "I don't like this change because it might make code harder to read". That's my point when I say, "I'm not wrong". It is my opinion that this change might make code harder to read. That statement cannot be proven wrong by you or anyone else, any more than if I said, "I don't like peanut butter". It is an opinion, not a fact. I am commenting because I had an opinion about this change. I don't thing it's inappropriate to engage in a discussion about the merits of a proposed change. Some people will like it, some people will not. We will discuss it. Some people will change their minds, some people will not. Either way, the give and take of the conversation is interesting. That seems like sufficient reason to comment.
OK, I wasn't familiar with the term. I guess it covers things like hovering/clicking/what-have-you to get more information about the statements you're looking at. This is fine and good, and I love my IDE. I've used most of them over the years, but have converged on Eclipse. As I said in another reply, though, I don't always look at code, especially strange code, in an IDE. If I want to go through the source of an included library, I rarely take the time to set it up in a complete project that compiles, etc. If I haven't automatically downloaded the source JAR via Maven, then I'll download the source, or check it out from svn/git and read through it with Emacs. It's possible to set all that bidness up with Emacs (Intellisense^tm) I suppose, but, for this purpose, I don't go through the effort to do so. Now, I'm stuck when reading something like: var thisThing = new MyDerivedClassButYouDontKnowTheSuperclass&lt;&gt;(); instead of List&lt;Something&gt; thisThing = new MyDerivedClassButYouDontKnowTheSuperclass&lt;&gt;(); That's my discomfort with this proposed change. I guess it's tied into the fact that I don't agree with the premise of the change, that Java requires too much boilerplate code. I think verbosity and legibility generally correlate. I think that brevity and legibility are generally in opposition.
I wouldn't know with certainty, I use CodeRush instead of Resharper.
Wait a second, you know that's bullshit. OrderCollection and the objects is contains are still going to be pure class. The ORM is going to create a subclass of OrderCollection in order to inject all of the lazy loading crap. So no, you still don't need an interface to unit test.
&gt; Here, foo takes the form of the implementation, not the interface, Watch your terminology. Foo is taking the "public interface" of HashMap instead of the "abstract interface" of Map, but it is still an application programming interface (API) for the class. If you want the implementation of foo, then you have to use reflection to access the private fields (or pointers if using C/C++). 
Come on! This is shallow. Could have gone with "Java to bring in var keyword, what happens next will blow your mind" to at least fit in with the rest of the clickbait
&gt; there will be an extra step to figure out the type of a particular variable. There's an extra step anyways. Most Java code is so heavily dependent on declaring everything as interfaces that you need to use a debugger to figure what the real types are. 
Well you're probably using a strong/dynamically typed language. You can't have dynamic types like Python or JavaScript without strong typing, as something needs to know what the types are. Weak typing is C or assembly, which allows you to treat any data structure as any other data structure with the right pointer games. Both suck, but for different reasons.
Whatever my auto-formatter decides to use (which seems to change according to the time of day).
projectlombok.org almost fixes problem with case classes (for me) But it's a hack! :) 
C# is looking at `let` for that role. `val` is problematic because it looks too much like `var` and is pronounced the same in Asian languages such as Japanese. 
&gt; Also: goto is still reserved. Just in case. I miss goto. Once every five years or so I write a function that needs it. Or rather, would be much, much cleaner with one.
In some communities, `let` is seen as creating an immutable variable while `var` is creating one that can be reassigned. We're trying to get that semantic added to the next version of C#.
I say no. 
I wish they would do the same in their damn blog posts. Too often they offer examples without any types nor meaningful variable names.
Why do we not have a clickbait tag
Yeah, I know that guy. He wrote some terrible code a year ago, and he was quite inexperienced -- he had a year less experience than me when he wrote it. Oh, and he has the same name as me.
I agree that if one doesn't get the purpose of interfaces, Java is going to be a lot of fun for anyone. Interestingly, since I'm not a C# guy, don't work on Windows, and don't have the Microsoft Family of Products ready and willing to display System.Data in all its interactive finery, I would have to just download the source of System.Data to look at it. And I would probably look at it in Emacs. I hope there isn't a lot of stuff defined with "var" in there.
You don't need Guava for that: collection.stream().collect(joining(".")); But while I don't recommend pulling in Guava just for Joiner, if you happen to already have it in your dependencies (and it's damn quite likely), sure, use it.
Computer science is still computer science regardless of which language you use to represent it. And I've been bitching about this since the first version of J2EE, so this isn't C# envy. I just like using them as an example because its one of the areas they got right.
Perhaps they have internal coding standards about using var. I know that I'm a lot more lax in terms of structure, encapsulation, all that, when writing tests.
You could use a bytecode generator and generate a jump instruction, then.
Maybe. I really should ask.
I wish I can use Java 8 :-c . We are stuck at version 6...
Usually, I'm not reading a variable's type, unless I'm reading javadocs. Maybe it's that I came to Java from lisp, and tend to prefer inferred type in general, but I find that, at least with the better code that I read, I don't pay much mind to the type declaration. I suppose, if something's written with poor variable naming conventions, it is helpful.
Yes please, value classes.
Interestingly, my original background was LISP, too. That's such a different nut, though, that I don't seem to use the same parts of my brain when reading Java code as I did when reading LISP code. Yes, well-named variables would make my concerns a non-issue. I just don't trust my fellow man much, I guess.
Not fair to compare javascript's total lack of typing with C++/C#/java. Compare to python or ruby if you wish. but of COURSE dynamically typed languages have less typing.
Related: a short Q&amp;A with Jonas Bonér - CTO of Lightbend: http://www.infoq.com/news/2016/03/lagom-microservices-framework
I have no suggestion, I'm just curious. I'm surprised that Cassandra is chosen over Spark, here, which seemed like the default default for Typesafe/Lightbend. I suspect some new strategic alliance might be involved, not really a technical decision. After all, a VC-backed, valuation-driven company chooses the tech of another VC-backed, valuation-driven company as their default... Certainly, that ought to create more buzz than some boring old RDBMS :)
It doesn't have to break backwards compatibility. It specifically says in the proposal that it would not be a keyword, it would be a reserved type name. For any package containing a type called `var`, and for any source file which imports a type named `var`, you could simply override the reserved "special" var type with that one and solve the problem. Everything would still work just fine, no? People who have defined their own `var` type would simply not have access to the new feature wherever that type is visible.
I agree with you, but it IS true that you can define classes with lowercase names, so somewhere this is a C programmer who wrote some badly formatted java code. So yes, there is a small corner case where this would break code. AND I SAY BREAK THAT CODE.
Yep, someone else pointed this out to me as well, I was skimming it on mobile and they used the word keyword quite a bit and mentioned it not being a keyword once, so I completely missed it. That seems like a good compromise, and my opinion on the matter really ends there.
Fair enough :)
The reason is "final var" is this kind of declaration ceremony thats change to "val" could lower. The reason why I don't think the same about "mut" is similar to me preferring using Optional instead of null. It's another safeguard in my code. The reason to have as short as possible (yet, not too short of course) declaration of final is a great way to encourage people to start thinking this way. The reason to encourage people to think this way is that immutable values proved themselves in many areas (software design -&gt; less troubles with maintaining software created in long existing languages, language design -&gt; Rust, Scala (and not counting purely functional languages)). The reason why I wasn't encourages to follow this rule when I started learning Java was the fact that I have to use another keyword and without it my programs still works. The reason why it's not only about "effectively final" stuff having language minimizing occasion to shoot yourself in the foot. If something is only effectively final it change if I by mistake change variable value. If it has final keyword then it won't compile.
Yes.
&gt; BREAK THAT CODE please don't hurt me :(
Considering the languages one big selling point is absurd fascist levels of strong static typing. O god no.
j2ee and web frameworks. Absurd number of jobs doing back end web dev in java. The other one is android, everyone wants an app to mirror there website, I have no idea why if they're not adding any value over the website, but they just do. (seriously I see so many missed oportunities in that realm, where they just mirror a shittier version of there websites functionality instead of treating it like a phone app. For instance pizza delivery apps why can't I turn on location tracking and have the pizza guy come to where I am standing)
A lot of problems go away when you involves checks with a lot of 0's
Oh please, I've been working with Java on and off since J++ was still a thing. And even if I didn't, the ORMs in .NET are based on Hibernate.
Thanks! Sounds like newtypes in Haskell - I agree they're really handy.
&gt; To be fair, Java isn't any better. Maven/Ant/Gradle are equally (if not more) complex than Nuget packages, I'm skeptical that you have an understanding of maven/gradle. Creating a package is trivial if you're using a real build system.
&gt; Computer science is still computer science regardless of which language you use to represent it and equivocation is still equivocation...
Dalvik has two meanings unfortunately. 1. Dalvik is the name of the virtual machine bytecode that Android runs. 2. Dalvik is also the name of an earlier virtual machine, which executes dalvik bytecode. It is easy to see how the same name would be used for both the VM and the bytecodes. Sort of like JVM bytecodes and the JVM itself. Now think of three stages in the evolution of the virtual machine: 1. The Dalvik VM would interpret dalvik bytecode. No compilation to native code. 2. An improved Dalvik VM had JIT. It would compile dalvik bytecode to native code as it was executed. Similar to what the JVM does. An unfortunate side effect of this is that you are using the puny computing power and limited battery power to re-re-re-compile dalvik bytecode to native code. 3. A new virtual machine, unfortunately named ART, just to help confuse you, now compiles and runs dalvik bytecode in separate steps. An application is compiled to native code when either (1) it is installed, or (2) the OS is updated. The reason to recompile everything with an OS update is that the dalvik to native compiler could have improved. And the compiler could have additional security checks of the dalvik bytecode of every app installed on the device. Hope that helps. 
Dalvik is also the current name of the bytecode executed by the older Dalvik VM and by the unfortunately named ART. The word Dalvik referred to a VM and the type of bytecode it ran. Sort of like JVM refers to a bytecode and a VM that runs it. The unfortunate name change makes people not realize that Dalvik is still the bytecode that ART executes, or rather compiles to native code.
Thanks! Glad you dug it! 
it's useful to keep in mind that, in a certain sense, most haskell code could be considered "generic" from the java perspective. this haskell: `add a b = a + b` is (roughly): `public static &lt;T&gt; T add(T a, T b) { return a + b; }` (technically the java won't compile, but c'est la vie.) it's an imperfect comparison for a couple reasons but close enough for discussion, i think. broadly, java is more concerned with the *name* of things, where haskell is more concerned with the *structure* of things.
Oh, that's a pain. Thanks for clarifying.
No, Dalvik is the VM. DEX is the name of the byte code. 
Looks very nice. Does anyone know how this compares with another similar libary called Dozer (https://github.com/DozerMapper/dozer)? Been thinking I need to pull one of these in, bean mapping is quite a pain!
'.Dex' files are Dalvik Executables.
Zulu doesn't have a version for the raspberry Pi yet. Their version is different because it you wanted to build a jvm-based device and use the oracle jvm you have to pay oracle licensing fees for distribution. Zulu doesn't charge that.
I can't speak for MapStruct, but I'll probably take some time out to give it a whirl. However, I have used Dozer in a production environment for around 3 years now and have had good results with it. Dozer can get fairly involved depending on the hierarchy you're mapping to, but I haven't run into any situations that were too crazy, yet, and the one-off mappings are usually a smell that something may need to be refactored. Dozer is XML-based which may be a deciding factor for some, though in my opinion it's kind of a toss up between that and having to create an annotated mapping class in the case of MapStruct. Whichever one you choose, I'm sure you'll have good results with either. 
Value in JS is typed (to some degree). Variable is not.
`MyDerivedClassButYouDontKnowTheSuperclass` should not implement `List`. Something like `ConcurrentCopyOfWriteMySuperLinkedList` could, but in that case it is obvious to reader that it is list, further clarification is not necessary.
In certain use cases it is more suitable than tons of `CompletableFuture`s.
Are you reading reddit during your work time instead of coding? Shame on you!
Your argument is to trust the developer to name their class properly. The thrust of my argument is that I do not trust other developers to write code that I find readable.
Spark is a pretty neat framework. My job is currently standardizing/migrating legacy applications to Spring Boot, which is a bit more enterprise-ready. I really like how easy it is to create REST APIs in Spark and it's really easy to prototype some basic functionality for toy apps. I was able to create a self-executing jar by adding [the Shadow plugin](https://github.com/johnrengelman/shadow) (a Gradle-based version of the Shade plugin). Simply run: ./gradlew clean build --refresh-dependencies shadowJar java -jar build/libs/my-file.jar [Here is a good tutorial](https://blog.openshift.com/developing-single-page-web-applications-using-java-8-spark-mongodb-and-angularjs/) on an AngularJS application using Spark as a backend. Having never had any prior knowledge of Spark or Angular (or any front-end work outside of JSPs in college), it was amazingly easy to pull it all apart and build some pretty neat applicants with it. 
But is Spring Boot that complicated, that one more framework is needded? It seems, creating the same basic application with SB is also very simple.
A basic SB app isn't any more or less difficult. I just thought it was a neat tool to have available, since it is pretty light on dependencies. 
I've used Dozer quite a bit in some midtier enterprise services, and it worked pretty well. It was all Xml confit based, which I didn't mind too much. Is the big selling point to this movement to an annotation config model? I fail to see how that makes this convention over configuration. 
Why even make this about strong typing? Rust is probably the most strongly typed language with wide exposure. It has `let`. Haskell has type inference on everything, even functions. `List&lt;Item&gt; items = makeItemList()` isn't how strongly-typed languages read. It's how Java reads, and Java's type system is weak (e.g. no null safety) compared to other statically typed languages.
Can this handle mapping nested properties from an input object to nested properties of the output object? Also can I easily define custom mappers at the field level? I've been using a similar project called Selma and those are two features it unfortunately does not have.
No, what you're getting at is garbage code might be worse with var. Well written, clean code would be improved by the reduced noise.
It's type inference, not dynamic typing.
Its working fine in C#, Scala, Kotlin, whatelse.
Hi, thanks for sharing these comments! Let me try and answer on the drawbacks: &gt; I believe Dozer (I may be misremembering) will map sub-objects implicitly. Mapstruct will return errors, so you'll end up writing a hundred mini interface methods. Yes, you'll need a dedicated method per pair of mapped methods. This is based on the assumption that you'll want to configure those anyways (i.e. map properties of different names, etc.) Otherwise, if two types were fully identical, why would you have them to begin with? That said, one could think about automating sub-object mapping if the target contains an exact sub-set of the source properties (as in a projection). &gt; I haven't had much success mapping ArrayLists to arrays. This should largely work. Could you file an issue with a short example here: https://github.com/mapstruct/mapstruct/issues? Then we can take a look. &gt; I'm not sure how it handles inheritence. Inheritance in which way exactly? Inheritance in mapped hierarchies? Mapper interfaces? An example of what you are after would help to answer. (Disclaimer: I'm the lead of MapStruct)
Regarding mapping nested properties: It's supported on the input side but not yet on the output side. It's high on our agenda to support the latter, too. Any help is welcome of course :) &gt; Also can I easily define custom mappers at the field level? There is support for "expressions" which allow you to manually handle specific field mappings if needed: http://mapstruct.org/documentation/1.0/reference/html/index.html#expressions (Disclaimer: I'm the lead of MapStruct)
Bad name. For everyone Spark is http://spark.apache.org/
Comparing it to Play framework, for example, I like that in Play you save all the routes in a separate file, so you have one entry where you can find all routes mapping. But in Spark, I should inspect the source files, which becomes pretty tedious when you have several hundreds of routes. And also, I like mapping a whole method to a route, not a lambda block somewhere alongside other similar routes. I think when you have separate method for a route is more distinguishable, while having multiple "controllers" in one method makes a mess. To sum up, I consider Spark to be great for really small and simple projects (maybe for prototyping), but I won't put it in production again.
It seems to me, Spark doesn't have dependency injection built in.
Java Tutorial or Core Java Tutorial is a widely used robust technology. Let’s start learning of java from basic questions like what is java tutorial, core java, where it is used, what type of applications are created in java and why use java.
Is this a joke?
Thanks will check whether its substantial enough for what i need it :)
There is a much better way to implement this, and that is with a builder rather than static factory methods. This is an extremely poor API choice and I hope it doesn't make it to release. Map.with("key1", obj1) .with("key2", obj2) .build(); Edit: Just updated the above example code slightly to reflect what /u/lukaseder rightly said about type inference.
I don't like how it returns an immutable map, and yet the result type is `Map`. It should be `ImmutableMap` or whatever they'd call it, so you can track which maps are mutable and which aren't and IDE's can warn you if you try to modify them. If you're copying Guava, copy it right. Also, I think they should make only variants up to 3, maybe 4 pairs of arguments, and the rest should be in some kind of builder.
Builders are not as clean as `Map.of("one", 1, "two", 2)`. If you need a builder you can as well use old Map.put..
It's consistent with existing API for immutable / unmodifiable maps, which also return plain Map: https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html
I really hope so, there are so many ways to improve this.. For example, pass in a Entry, and use varargs. And it shouldn't return an immutable map. Edit: Didn't see the entry one, but it still shouldn't be immutable.
If you refer to the `unmodifiable*` methods, those offer only views, so they offer no immutability guarantees. If you refer to `empty*` and `singleton*` methods, `*.of` methods supersede them, and therefore you can consider the old methods obsolete. Lack of immutability guarantees is one of the weakest spots of Java's collection API. Of course if would be almost impossible to split mutable and immutable collections like Scala does, but a nice family of `Immutable*` collection types would make lots of API's safer and easier to use. Guava's ones work wonders.
There seem to be two distinct concepts here: - It's consistent - You don't like it, never did, and never will (which is in itself also consistent) I'm glad you have options to *consistently* avoid JDK API
Sure. You can get around this by having the first key/value pair set during creation of the builder, so rather than Map&lt;Integer,Integer&gt; map = Map.&lt;Integer,Integer&gt;builder().put(1, 2).put(3, 4).build(); You could do something like Map&lt;Integer,Integer&gt; map = Map.with(1, 2).with(3, 4).build(); I still think this is preferable to the Map.of() solution, the limitations it has on the number of entries, the possiblity of additional functionalities in the builder, and the complete mess it makes of the API.
&gt; which are keys and which are values? Use new lines :) Map.of( "isad", "kldesf", "ijhsdef", "ijsdaf"... In this case (same type in key/value) both solutions are error prone.
This comes from this [JEP](http://openjdk.java.net/jeps/269) &gt;Much of the benefit of collection literals can be gained by providing library APIs for creating small collection instances, at significantly reduced cost and risk compared to changing the language. For example, the code to create a small Set instance might look like this: Set&lt;String&gt; set = Set.of("a", "b", "c"); &gt;There are existing factories in the Collections class to support the creation of empty Lists, Sets, and Maps. There are also factories to produce singleton Lists, Sets, and Maps that have exactly one element or key-value pair. EnumSet contains several overloaded of(...) methods that take fixed or variable numbers of arguments, for conveniently creating an EnumSet with the specified elements. However, there is no good general-purpose way of creating Lists, Sets, and Maps containing objects of arbitrary types.
Uhm. I've implemented this same method trivially with a less clunky API, and I'm no language designer: public static &lt;K,V&gt; Map&lt;K,V&gt; mapOf(Pair&lt;K,V&gt;... entries) { Map&lt;K, V&gt; resultingMap = new HashMap&lt;&gt;(); for (Pair&lt;K,V&gt; entry : entries){ resultingMap.put(entry.getValue0(), entry.getValue1()); } return resultingMap; } Usage looks like: Map&lt;String, Long&gt; namesToDigits = mapOf( pair("One", 1), pair("Two", 2), pair("Three", 3) );
it's not the clunkyness of the implementation that matters, but of the call. Yours it's much clunckier to call, even if you provide a Pair.of utility method. Also, iirc they decided not to include a Pair class in Java
&gt; there are so many ways to improve this there are not. you can slightly change the call (with Entry or any other way), but to make a clean "literal" without changing the language specification, there are no other ways
which would throw a "can't change an immutable map, bro" exception :) 
What if my first entry is a String and a Dog and my second entry is a String and a Cat? Will it know that it should be using Animal? What if it picks Carnivora instead but then I try to add a Rabbit? The type of the Map really does need to be declared somewhere...
this is very different from calling Map.of("key1", obj1, "key2", obj2) and almost as verbose as calling regular .put().
there's no ImmutableMap interface (or anything similar). Maps are never granted to be mutable, and it's a bad practice to mutate arbitrary maps (ie, received in return from a library, unless otherwise stated) without making a local copy. You should only mutate your own maps.
those methods are intended to enter map literals quickly, their use case is for small immediate maps, not for huge ones. 10 is a good compromise. If you have more stuff, you're not supposed to use your code (which would throw an exception btw), becouse you probably wouldn't have 20 variable lying around in your scope, but a list or array or something else that can quickly be drained into the map with other means. 
If only we had: k.zip(v).toMap()
&gt; And why did they decide not to include a Pair class in Java? It's part of JavaFX, so there's clearly a use-case, and most languages have something as basic as a tuple type. Sounds like a case of one bad decision justifying another. I don't remember correctly, but it should be becouse it's not a "clean" object oriented practice to use Pair, one should create his own class EmployerSalary with two named parameter "Employer employer" and "int salary". Of course you can still do it yourself as a "shortcut" or use Map.Entry. JavaFx is included in java but it's a different story, with different peoples working on it that made their own choices (suffice to say they implemented a totally different way to implement properties).
To be honest, I don't think you're wrong. The main advantage of the builder over just initialising the map and putting in the entries is being able to initialise, fill and have an immutable map in a slightly nicer format, especially when thinking about static final maps, which I suspect would turn out to be quite a common use-case of Map.of. It means we can do: private static final Map&lt;Integer,String&gt; MAP = Map.with(1, "one") .with(2, "two") .build(); instead of private static final Map&lt;Integer, String&gt; MAP; static { Map&lt;Integer, String&gt; tempMap = new HashMap&lt;&gt;(); tempMap.put(1, "one"); tempMap.put(2, "two"); MAP = Collections.unmodifiableMap(tempMap); }
becouse there's no way to show the keys near to their value. One wants to write/read Map.of(key1, val1, key2, val2, key3, val3), not Map.of(key1, key2, key3, val1, val2, val3). Also, that's not the use case for map literals.
It is different from calling Map.of, but my argument is that the Map.of is a badly designed solution for this sort of behaviour. &gt; almost as verbose as calling regular .put(). I agree to a point, though one of the common use-cases of wanting a prepopulated immutable map would be static finals. So, you can see quite a cut in verbosity in this use-case when using a builder: private static final Map&lt;Integer,String&gt; MAP = Map.with(1, "one") .with(2, "two") .build(); instead of private static final Map&lt;Integer, String&gt; MAP; static { Map&lt;Integer, String&gt; tempMap = new HashMap&lt;&gt;(); tempMap.put(1, "one"); tempMap.put(2, "two"); MAP = Collections.unmodifiableMap(tempMap); }
Counterpoint, from real code: @Override public Map&lt;String, Object&gt; generateAuditMap() { return mapOf( pair("id", this.id), pair("customerId", this.customer.getId()), pair("vendorId", this.vendor.getId()), pair("vendorUserId", Auditable.getId(this.primaryContact)), pair("contractNumber", this.contractNumber), pair("orderMinAmount", this.orderMinAmount), pair("orderMinItems", this.orderMinItems), pair("shouldSendOrdersToVendor", this.shouldSendOrdersToVendor), pair("isActive", this.isActive), pair("updateCronExpression", this.updateCronExpression), pair("contactIds", Auditable.convertToJustIds(this.contacts)), pair("externalReferenceCode", this.externalReferenceCode), pair("vendorDivisionId", this.getVendorDivision().map(AbstractEntity::getId).orElse(null)) ); } And the snippet I posted using `map.put` for the last three elements was *intentionally* broken to show the pitfalls of such a kludgey implementation. As a random user of this API, I'd see `Map.of()` and not immediately know that I was getting back an immutable map. I would just know that it's stupidly limited to a fixed maximum number of items (instead of, oh, I dunno, a *variable* number of *arguments*?) so I need to `.put` my last few. "Psh, up to 10 should be enough" is a similar line of thought to "we'll just use single lowercase letters for variable names, because who ever needs more than 26 variables?"
I don't get it? We agree that this addition is all about immediate (often static final) maps. Good. Sure your implementation is cleaner than old put(), but Map.of is even cleaner. So what's badly designed about it? It's perfect for quick jotting of maps, which is the reason it was created. The fact that there are 10 overloads is due to limits and legacies of the java specification, but it's not a problem, if not aesthetically. You find them already made and ready to use, performances are unaffected. So what's badly designed about it? Sure we'd all have preferred a true map literal like python or such, but changing the language specification is not an easy step to take.
&gt; So what's badly designed about it? It has an arbitrarily selected ceiling at which point you have to implement the solution in a different way and trades "cleaner code" for a muddier API. If moving from 10 to 11 elements causes me to have to completely rewrite that bit of code, just to implement a static final map that's found itself requiring one more element, that to me is a poorly made API design choice. I get that there is a valid use-case for it and that others obviously appear to be fine with it, but I personally don't like it.
You forget that they gave you exacly the code you show, just with "entry" instead of "pair", exacly for the reason you say. The "clean" of is for small, immediate map, not for all maps you'll ever create. &gt;"Psh, up to 10 should be enough" is a similar line of thought to "we'll just use single lowercase letters for variable names, because who ever needs more than 26 variables?" It's really not, becouse you have other means of creating larger maps. If anything it's like: "Should we require at least two letters for variable names? No, let's give them the option of using only one, which is a common use case. If they have more than 26, they can still use two or more".
This is probably a dumb question but how does it return Map, I thought Map was an interface
[Again!?](https://www.reddit.com/r/java/comments/48l56d/throwableinterfaces_extends_java_8s_functional/) :)
So in Map map =Map.of(k1,v1,k2,v2,....k10,v10) What does map point to?
It's an unspecified implementation of Map. You can use all of the methods in Map.
Cool
&gt; That said, if we could get Eclipse RCP or NetBeans Platform re-written in JavaFX, that would be huge. You can use e(fx)clipse for pure JavaFX/e4 apps already. No SWT in sight. My company has a product based on this.
You can map a method to a route, you don't have to use the lambda syntax using either ClassName::method or this::method syntax like: public class Main { static String hello(Request req, Response resp) { return "HI there"; } static public void main(String args[]) throws Exception { get("/hello", Main::hello); } } 
Is this a refactoring exercise? It looks like it was intentionally written to be obtuse. 
You should watch https://www.youtube.com/watch?v=OJrIMv4dAek This is specifically designed to avoid intermediate object allocations (like vararg arrays) and to be immutable.
Here's the talk explaining the rationale behind the new collection "literals" https://www.youtube.com/watch?v=OJrIMv4dAek
The goal of the API is to prevent intermediate object allocations like vararg arrays or builder objects. 
This would throw, by the way. The returned collection is immutable.
Immutable versions of classes always seem pretty flawed in Java. Would a language-level overhaul help?
If you want serializable, just use `java.util.AbstractMap.SimpleImmutableEntry`
FYI, you can route directly to actions in Play. See https://beachape.com/blog/2015/07/25/slim-play-app/ for details.
Why not introduce literals for collection initialization? Almost every other modern language provide such a feature - for good reason as this clumsy approach shows ;-)
Yes, I have seen that and am thankful. But that's not enough. How can they neglect the language the way they did the past 10 years?
 public static void main(String[] args) { Map&lt;String&gt; map = createMap(); // do some Map operations like put, get, etc. } public Map&lt;String&gt; createMap() { return new HashMap&lt;String&gt;(); } Make sense? If it doesn't matter that I get in particular a `HashMap` or a `TreeMap` or whatever else, all I need is a Map, then it's just easier and sensible to use `Map` wherever possible, and let the particular implementation (`new Hashmap`) be essentially arbitrary. You can imagine that I could change `createMap` to return a `TreeMap`, perhaps - maybe I've found that it provides a performance improvement - and nothing else in the code needs to change now. But if I declared `createMap` to return `HashMap` rather than just `Map`, then I have to now change that method signature, and perhaps the type of the local variable in `main` as well.
The unusual (I think) thing here is the creation of the "tunnel" object that carries type constraints with it, ensuring that it only suppresses checked exceptions of the type the outer `Tunnel.run` expression is declared to throw.
One of the main problems this causes is that if you compare the result of that with another HashMap, you'll never have them be equal because they are no longer the same type. Additionally, every time you do that, you create a new `.class` file.
That's Java for you, always hiding important information just in case they want to change the implementation later and break all your code.
&gt; there's no ImmutableMap interface So what? Just return the concrete type and be done with it.
Would have been brilliant if it had worked 👍
Not enough not enough not enough not enough not enough not enough yikes way over the top. HOW COULD THEY POSSIBLY ALLOW SO MUCH FEATURE CREEP? Yeah. I know. Some are hard to please... :)
You can't do `new Map`, but you can certainly have a variable with type Map, or a method with return type Map, or a parameter of type Map, etc.
Actually, this is not correct, according to the [official documentation](https://source.android.com/devices/tech/dalvik/), which states: &gt; ART and Dalvik are compatible runtimes running Dex bytecode. ART is an AOT (Ahead-Of-Time compilation) runtime, Dalvik is a JIT (Just-In-Time compilation) runtime.
I think that's going to be major for bigger spark adoption. What separates the men from the boys. The difference between a play framework and Play! framework. 
B...but muh backwards compatibility.
That's why I put a smiley beaneath the example.
Some links I found useful: * The [official JSF lifecycle diagram](https://docs.oracle.com/javaee/7/tutorial/jsf-intro006.htm) from the Java EE tutorial. * BalusC's [debugging guide to the JSF lifecycle](http://balusc.omnifaces.org/2006/09/debug-jsf-lifecycle.html), very useful for troubleshooting causes of events that don't trigger as expected. * BalusC's [overview of `@ViewScoped`](http://balusc.omnifaces.org/2010/06/benefits-and-pitfalls-of-viewscoped.html), very useful for troubleshooting issues with `@ViewScoped` beans (specifically, the bean gets created on every request, instead of only on the initial request).
If a method is returning a implementation of Map then it is by definition returning a Map. This is perfectly fine: public Map&lt;String, Integer&gt; createMap() { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); return map; } 
I wish Java would splinter into a new language. Could get runtime generics, better handling of primitives, literal maps and lists, etc etc.
&gt; This is specifically designed to avoid intermediate object allocations (like vararg arrays) I would wager many Java devs don't realize this is a thing.
There is a workaround to map nested properties to output object. You need to add explicit @Mapping from the current input object to whatever type you want to map.
I think what's baffling you more is the sidebar, which clearly states "PLEASE SEEK HELP WITH JAVA PROGRAMMING IN /R/JAVAHELP!" Yes, it's in caps. That's not my doing. It also says, right above that, "News, Technical discussions, research papers and assorted things of interest related to the Java programming language." People who want to help idiots who don't know how to Google can subscribe to /r/javahelp. People who want to read and learn about actual Java topics can subscribe here. It's good to have that separation, because it fosters two separate and healthy communities with two separate and healthy purposes. If you think it's pompous to ask somebody to follow the rules, you're the pompous one. And the one who needs to grow up is OP. Enough with the coddling.
Well, only one node can write to the database. I guess you can think of it like locking a mutex. If the node that has the lock on the database fails then another one can take over as the master node. In this scenario there is only ever one active node writing to to the database. So I don't think you will ever see classic SQL database type locking issues because only only node is ever accessing it. This setup would not be good for an environment that requires high throughput, but it does provide a degree of fault tolerance. My environment happens to not have high throughput requirements, so this works well for me.
I don't see the value of Tunnel, why not use a more general disjoint union and have wrap be a constructor for that union?
I wish this point was made more often. That redundant noise can make you miss important information really easily. Once you start skipping over redundant parts of declarations your brain starts trying to anticipate the next redundant words more and more and "similar" turns into "the same" and you can easily overlook subtle differences in naming. You'd think that increase in anticipation would mean an increase in focus, but that requires more energy, which would be counterproductive biologically. Patterns become more ambiguous as each affirmation of redundancy creates confidence, and less data is considered for determining if each word has redundancy. It can be particularly brutal reviewing java code with a lot of abstraction.
As "ugly" as they are, I'm glad there isn't liberal use of varargs. It's a huge performance burden, creating an array on each invocation.
JavaFX is a GUI library, not a runtime/virtual machine and it is not a compiler. 
They should be used in places where the consuming code is not supposed to be modifying them anyway. In those cases, throwing an exception is better than allowing an inappropriate modification.
Will that be insanely slow?
It works OK, but it'd be nice if it was caught at compile time. As it is, you can do this or have two classes (one immutable and one mutable) and an interface.
Sometimes it's not a performance burden at all. [Here's a benchmark](https://github.com/michaelhixson/jmh-benchmark-listof) you could run for yourself if you're curious. It shows how varargs array allocations can sometimes be optimized away at runtime. It's hard to predict whether it will actually make the optimization. It also won't help during startup as our `static final` `List.of(...)`, `Set.of(...)`, and `Map.of(...)` fields are being initialized. That's basically the justification that was given to me when I tried to argue for the removal of the fixed-arg `List.of(..)` and `Set.of(...)` methods. The fixed-arg `Map.of(...)` methods are much easier to justify, since they're more pleasant to use for the caller.
Ok will look into doing that, have all weekend to get it running. Edit: Think I have it working, dont really feel like deleting java from my computer to test it so am going to just wait til monday
Groovy does the same thing, IIRC, all the way up to 99 arguments.
The main issue is that ranked-choice voting is not only more complex(believe me, I've coded an implementation of it), its also far less expressive than range-voting.
You would need to write a JVM for that environment.
Range voting could literally have any scale. 0-10. 0-10k. 1-1M. I rate candidate A = 1, B = 2, and C = 1000000. Ranked choice I can only do that a few ways. Range voting is far more mathematically expressive. 
How is this better than [Quercus](http://quercus.caucho.com/)?
Vararg array allocations can be trivially removed by the optimizer. Is is not an issue.
Because such relatively rare use case is not worth language complication. `Map.of` does the job. Java language lacks several important features of modern programming languages that could not expressed as simple library functions, like extension functions or ADT. That should be implemented, not syntax sugar for maps.
Awesome, always wanted to learn some basic PHP, maybe now is my chance.
It's not a rare use case at all. Map.of is something any of us could easily implement, so the benefit is almost zero. Double brace JSON-like map initialisation actually does the job, and is long overdue
The benefit of immutability is exactly so you can't use map.put. It prevents other people from modifying your map, which inevitably cause pain in the ass bugs such as complicated side effects and race conditions. You use immutability to protect your code, not make things easier. Immutability is a pattern that will lead to a cleaner data model and a better separation of concerns. It's a technique to improve the safety of your code in a variety of ways, while also helping to ensure a clean architecture and design.
The point of immutability is to prevent people from mutating your map, i.e. making changes to it without your permission. It's not about the cleanliness of the solution, immutability is often an inconvenient truth, for a little bit of boring overhead and self discipline, you can often make your code much more safe by preventing as much mutability as possible.
Seems to be an equivalent of auto in C++. certainly a huge mistake to introduce that. It is always bad to have several ways to write the same thing in a language. Var will introduce such an issue. Strong typing imposes to think a little bit before coding and do not cause problems. Such keywords will lead to misunderstanding by the beginners who will write bad code. Functionnal programming ideas have already destroyed C++ language, which is now an awful mess. Java should not follow the same path.
C is simple language that is used a lot and has almost never been modified. C++ added a lot of things, so now we have "official guidelines" containing more than 15000 lines! https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md What is the advantage of adding stuff which no more than syntactic sugar? Most of the IDE already gives you the type, so what ? Write a new language or use a new language if you want new things. 
I disagree because I like tools independence. What if you want to build it with maven?
Intuition says that putting the two most criticised languages together is probably a bad idea.
Suppose we have a function `trying`: &lt;I, O, E extends Exception&gt; Function&lt;I, Either&lt;O, E&gt;&gt; trying(ExceptionThrowingFunction&lt;I, O, E&gt; function); that wraps an `ExceptionThrowingFunction`, returning a `Function` that catches exceptions of the given type, and returns a disjoint union. Now suppose we want to use it in an expression like this: Either&lt;Map&lt;K, V&gt;, IOException&gt; result = stream.map(trying(troublesomeFunction)).collect(toMap( keyFunction, valueFunction)); The problem is that `stream.map(trying(troublesomeFunction))` returns `Stream&lt;Either&lt;O, IOException&gt;&gt;` - a *series* of disjoint unions, which might contain many failures. We'd need custom behaviour in the collector to pick out the first failure and return immediately - something like: Either&lt;Map&lt;K, V&gt;, IOException&gt; result = stream.map(trying(troublesomeFunction)).collect(disjoint(toMap( keyFunction, valueFunction))); The implementation of `disjoint` is left as an exercise for the reader.
[removed]
[removed]
... why would anyone want to code Android games in PHP?
It will work if maven is integrated into the IDE. Using external API without considering types is certainly a bad idea. 
Very nice! Congratulations!
Thanx for the link - interesting talk! Besides that I've never claimed such a thing ;-) I would say you can be pretty dumb but still see the benefits of collection literals. As a turnover I would say you must be some kind of slow-witted, if you do not see the advantage of collection literals compared to an API based solution. And of course there may be good reasons to pick the latter approach, but for sure that will never compete with a syntax based solution! And yes, it feels great in other languages and feels bad in Java - and that counts for me. (If I have not missed it, Stuart have not really told, what the tecnical obstacles were! He just mentioned the cost benefit trade off - and that does not count for me as a user, that counts only for oracle as a financier ;-) )
Honestly, I don't know that I'd want to write code for Android in PHP or a PHP-like language. I don't think much if anything is gained by doing so... 
Please, have somebody check your spelling and grammar - they are absolutely horrible and thus totally ruin a possibly good tutorial. People will be put off because of the weird sentence structure, the miserable grammar, and because of the horrible spelling. Use proper sentences **with** articles - they are not optional. Use proper cases, singular, plural, have/has, etc. You have at least 20 serious grammatical and spelling errors in the **first 5 sentences** - this is horrible.
why would any one code anything in php?
yeah thats easy. But Val sheep = getSheep(); thats terrible, really really bad
I should say, my objection isn't about whether this changes the type system in Java or not, it does not. My objection is about readability of source code. This change, while not changing the type system, in my opinion, makes it *look* like the type system has changed to a less trongly-typed system. In only that way is my complaint about typing.
Right? We already have Groovy...
The problem is that the horrible spelling and grammar make it impossible to both read and digest the information. This is not fun. As I said. The tutorial has potential, but with that spelling &amp; grammar it is completely wasted.
I understand your objection but it is a misunderstanding to associate it with strong typing at all. Strongly typed languages have had type inference and `let`, `var` etc for decades. Java is fairly unique in lacking this feature. Java's type system is also pretty weak for a statically typed language. You can argue that Java code is more readable due to its idiosyncratic lack of `var`. Just don't pretend that it's got anything to do with it being a strongly typed language.
Now you've overstepped the line. This is against the rules of the sub. Edit or remove your comment, or you're banned.
Interesting but &gt; DSL compiler requires Mono/.NET, but only during compilation. There is no runtime Mono/.NET dependency, only JVM. Library has optional Android and Joda-Time dependencies. Java8 Java-Time API is supported as a separate jar, since core library targets Java6. :( It is no fun having a java dependency that also brings in a .NET dependency.
Why does it need Mono/.net Dependency? 
This is yet another violation of the "liskov substitution principle". The collections API has never been good at this. 
~~Why not an ImmutableMap interface?~~ Edit: Whoops forgot you can't have an immutable interface, only immutable implementations. 
It's not just 'nice' it's correct software design. Follow your gut on this one and not the jdk example. Jdk does lots of things we should learn from, this just isn't one of them. 
Thanks
The collection api has already a RandomAccess interface that "tags" random access lists they could make an Immutable interface so every collection that supports this feature implements it.
Thank you. Just what I was looking for.
&gt; The problem is that stream.map(trying(troublesomeFunction)) returns Stream&lt;Either&lt;O, IOException&gt;&gt; - a series of disjoint unions, which might contain many failures. We'd need custom behaviour in the collector to pick out the first failure and return immediately - something like: Excellent, I don't see why that is a problem however. That actually seems quite desirable. &gt; However, this assumes that we don't want to just stop processing as soon as any failure occurs - we're forced to collect the entire stream, instead of failing fast. You don't want to stop processing when failure occurs, this preserves associative property of functors implementing `map`. This also perpatuates the myth that computation is done in the body of the `map` method. Streams are lazy. No actual work is done until you call `collect`, `reduce`, or some other method that forces evaluation. It stands to reason that logic about how to evaluate the stream belongs there.
Hey guys, I am the author of this screencast series. BitPress is a company made up of passionate engineers who also love to teach. We noticed a lot of Java developers struggle with or are not exposed to Lambdas introduced in Java 8, so we decided to make a concise, entertaining, and reasonably priced screencast series on Lambdas. There will be a Streams series following up soon, continuing to cover the awesome new Java 8 features. This has become even more topical with the support for (some) Java 8 features in Android N. Please let us know if you have any questions or feedback!
Is translating to/from JSON really a big bottleneck for many applications? 
Well, library doesn't really have .NET dependency, but if you want compile time databinding - external DSL compiler will be invoked to generate such Java code. That compiler is written in C#, so there is that.
Is that really an issue? Except an ideological one?
Yup. It makes continuous integration harder and developer machine setup more complex. Further, if you pull this thing in as a library dependency it wouldn't be obvious to someone downstream that they also need .net installed. I've dealt with similar dependency problems in the JavaScript land (where projects decide to depend on Python or c++). It makes for a real miserable experience getting setup. I might consider this for a personal project, but never as a library dependency or something for my work.
Yes, I work for a company doing their API integration gateway. Translation and schema validation are the two most expensive processes.
that's exactly the thing I don't want to do :)
Is it though? The API is pretty clear about how mutability and immutability are handled in the `Map` interface. Maybe it's poor design, but to violate LSP, you'd need a contradiction of this by one of `Map`'s subclasses.
Why stop at JNI? Lets include web calls to every cloud which offers a modpow service.
Because the latency of a network round trip would be exponentially greater than a pure Java version. Libjgnp is packaged as a statically linked maven artifact and is dropin compatible with JCE.
Whoa. Thanks!
Thank you. It was fun, too!
There was a survey started for the naming. This is just a prototype.
That's exactly what we need. A new Java - the same philosophy, the same care, but with the mistakes fixed. Minimalist syntax, concrete naming conventions, no feature creep...
That's very interesting that these things are being considered as language features. It would be nice if you could also get rid of much of the cruft, maybe via a compiler switch or something. I think JavaScript does something like that, where you can disable some older features by typing "strict" or similar at the top.
Imho the most valuable advantage of PHP compared to other languages (or better runtimes) has always been the broad availability; especially at cheap hosting services. Now if I have access to a JVM at a server, the advantage is "lost". You can strive for non php solutions then. If JPHP provides a drop in replacement for all PHP programs, it could be used for a slight migration towards JVM based infrastructure without massive porting in the beginning.
Would a dockerized compiler lower the entry barrier? I tend to put all compile time dependencies inside containers so that I can run have reproducible builds regardless of the system installed libraries. As for runtime, once the schema is compiled it's JVM all the way (but for me, again inside dockerized microservices :)
You need to work on your commit history. http://i.imgur.com/zpmXrTO.png
[removed]
Java's type system just has a few bad ideas in it that have really hurt the language maintainers (can't make a breaking change). The whole concept of the "Number" class is simply broken. It was a way to get around the "everything is an object... except when it isn't" problem. It really doesn't help that they decided to add so much special treatment to special objects like String and Number.
There is already some level of type inference in Java with lambdas. I think it is good overall. I asked Doug Lea, and he was in favor of it, and thought it was good, as far as people who know what they are talking about. Really I am just excited to be able to write var x = new someLongHugeJavaClassName(); and save some line space.
/r/programming, /r/scala, /r/rust, /r/computerscience, /r/dailyprogrammer 
Good
Of course. But that'd break once types need to change.
LSP is about the actual behavior of sub-classes. Comments attempting to justify the violation do not mitigate the violation. Map has mutator methods. If you implement these methods to fail spectacularly at run time you fail LSP. To not fail LSP ImmutableMap would have to not have mutator methods. 
Plus, it's carefully limited in its scope, which I think some people may not consider when they first react. For instance, you can't just it as a return type of for an interface.
Other languages have had fairly good success with this concept. It's useful if done correctly and type information isn't lost.
Why? Types are only locally inferred and can be usually known from context, so you'd only use the IDE when in doubt.
What would type inference buy us, except marginally less code? Explicitly declaring types is not that big of a deal, IDEs already autocomplete that stuff for you anyway. I spend a lot more time reading code than writing it, which is a lot harder when everything is a 'var'. That's why I find reading someone else's Java easier than reading someone else's Python or JS.
yep I know that syntax. It's awful
Best way to learn is to do. Thanks for sharing. Good luck! 
[removed]
That's true, but it's worth noting that a lot of code is looked at outside of an IDE (github, stackoverflow, pastebin, etc). (I don't think it's that much of an issue - you're probably looking at smaller, simpler chunks of code in those examples - but it's worth noting that not everything can be solved by a decent IDE.)
IDEA always did. Ctrl+Q.
You can already do that in Scala, for what it's worth.
Yeah. That is kind of one of the proof of concepts for these features I think. I like Scala, a lot, I think its a fantastic language. A lot of the Java designers feel the same way, which you can see in the way they slowly introduce some elements of Scala into Java.
Generics were evil in Java and are not anymore, type inference would be evil at first but once you know how to use it properly it should result in nice code. However, serialization was and always shall be evil.
IntelliJ did something similar with Lambda before they were part of the language. In Java 7 code, you could write an anonymous inner class, and it would be displayed as a Lambda Expressions. IDEs can go to considerable lengths to simplify your life. But adding simplicity to the language itself is still much more efficient. (BTW, in this particular case the word "simplicity" refers to the programmer only. The language and the compiler get more complicated).
Maybe you can try Bulldog https://github.com/px3/bulldog
Between boxing and type erasure generics in Java still suck
I feel that's more of an edge case. It'd be better if you had to prove your number was a long before using as one
Well I would bet jenv works... 
There's a tiny file that also needs java home set for maven operation, that [an outstanding bug in jenv]( https://github.com/gcuisinier/jenv/issues/78). That amongst 52 open issues. 
I'd prefer it backwards. `var` and `mutable var`. Mutability is inherently dangerous and should be treated as such.
I did my college final on a beaglebone and had a http server running in python with cherrypy plus a MySQL DB and some C code talking to my hardware. It ran fine, they are pretty powerful machines.
&gt; ant plugin myself you should really consider using Maven. Ant is an ANTi-pattern.
I have run the unit tests for my threading library on my BB fine. That said, jersey might be a bit much for much. Only way to know for sure is to try it.
Could you point me to more info for that? I know the advantages of dependency management of maven, but in general i don't see much of an advantage other than more complicated configuration scripts.
But then you're promoting immutable-default for one thing, and the opposite for everything else... isn't that more confusing and overall less-readable? 
It isn't about laziness, the goal is to remove remove boilerplate that serves no purpose other than to add unnecessary noise: final MyThingThatDoesTheStuff myObj = new MyThingThatDoesTheStuff(); vs val myObj = new MyThingThatDoesTheStuff();
&gt; But I wanted to get an idea of how other developers do this in general. There is no *general*. E.g. say something like *"I like to put them in stored procedures"*, and you'll be burnt at the stake. Why? Because some TDD prophet wrote in his verse 13:37 of His Book Of Mockability that stored procedures are evil, and all His lemmings concluded that He must be right. But none of these prophets were ever right. Truth is: Do whatever you want. Your choices are: - External storage in the database (views and stored procedures) - External storage in files (with templating, e.g. via [MyBatis](http://www.mybatis.org)) - Internal storage in string form (e.g. JDBC, Spring [JdbcTemplates](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/jdbc.html), JPA native query) - Internal storage in DSL form (e.g. [jOOQ](http://www.jooq.org)) - A combination of the above Do what makes you most productive.
This is actually a well-known versioning scheme for people who do not agree with [semver.org](http://semver.org). Release versions are then: - 3 - 3.1 - 3.14 - ... Alternative schemes include - 2 - 2.7 - 2.71
I've been wondering how far you can take JDBI for use-cases like the OP's. I mean, a complex report with dynamic SQL bits... do you ever do that with JDBI?
That sounds interesting, so this follows the SuchAndSuchReportingDao model?
Indeed, but I'm not about to start implementing every different method and library that I can find via Google. Hence the question, what sort of methods have you tried and liked, and what parts have you not enjoyed? Edit: Although rereading that comment I was probably assuming the JDBC/JPA method and was being more specific as to how to you split up your daos when you have queries that are not entity lookups, but I am curious beyond the hype on the limitations people run into with each method
So you would advocate having the queries written and executed in the service or directly at the database layer, and would avoid having a Java level repository type layer? Doesn't having your business logic as well as the queries in the same location get messy?
Hello, We use jOOQ since this summer. The project concerned is a rule engine. As the main business calculation is made by SQL request, we needed a bit of complex requests to generate output so we excluded ORM. Our first version worked on Spring JdbcTemplate, but we rapidly migrated to jOOQ, and had some benefits of it : - jOOQ is typesage : as a DSL is generated from the database, type are checked (directly with your IDE when editing the code - we have "quite" natural code that is near of expressed businness rules in the doc of specifications : so we code more easily, and it's more readable - we are "protected" from SQL injection : with the DSL , you "naturally" write preparedStatement : you don't write statements by string concatenation with parameters, but you pass parameters to DSL functions (and then have jOOQ generates prepared statements - we can manage performance issues easily : as we have complex request, with several tables in some cases, if performance issues arise, we can easily fix them : we know the requested and the SQL way to correct : it's easy to correct it with jOOQ. We don't have to be also expert in an ORM framework (how it manage lazy loading, ...) - writting tests on dao is also easier, so we have a better coverage of dao code. And Lukas is reactive if you have questions. So we are happy with this choice. Hope this few feedbac will help you. Regards,
I've used Scala, Kotlin and C# for several years now and had never a real issue caused by `val` or `var` hiding the type. The opposite is true: the code is reduced to the relevant part, and that is the part where the hard to find errors have their home ;-)
Implementation of a discriminated-onion-based solution here: https://github.com/poetix/ambivalence/blob/master/src/test/java/com/codepoetics/ambivalence/EithersTest.java
Well I think that having the `final` keyword in Java instead of a `mutable` was a huge mistake, personally. I thought we were talking about a "wishlist" here. :)
The concern of "business logic in the data tier" is a hold-over from monolithic, client/server design. If you think of your database, not as a repository, but as a service, then it makes having business logic there more acceptable. That said, one could argue that reports aren't necessarily business logic as much as they are a data view. So the right answer is to do whatever is right for your application, what is maintainable, and what provides the best performance.
I just use a shell function: function setjdk() { if [ $# -ne 0 ]; then removeFromPath '/System/Library/Frameworks/JavaVM.framework/Home/bin' if [ -n "${JAVA_HOME+x}" ]; then removeFromPath $JAVA_HOME fi export JAVA_HOME=`/usr/libexec/java_home -v $@` export PATH=$JAVA_HOME/bin:$PATH fi } function removeFromPath() { export PATH=$(echo $PATH | sed -E -e "s;:$1;;" -e "s;$1:?;;") } Then I just say something like: setjdk 1.8 or setjdk 1.7 from my shell (zsh) and it just works. It may be a bit more basic, but works well.
I am not sure that "auto" in C++ si really successful. 
Oh this is splendid. 
Thanks.
Not really. Remember, this is only local type inference. The minutiae may be a bit finicky, but I've written such an inference engine once (for a JVM-hosted scripting language) and it isn't too hard. Yes, you need a type tree, but that can be pre-extracted easily.
Here is a list of all available components https://helmetrex.com/generators If there are no components you want, we are open for proposals.
I've tried pentaho. It was good for really gnarly stuff, but I've rarely needed that much power.
Is this your product? Do you have a soup to nuts example that implements client and server?
It look like promising. What cons do you see in C++ auto?
Trolling "The troll master".. no no...I am not even qualified for that 😊
Hey! Not in public! I'm undercover here
OK. Thanks for the clarification.
what is a non-entity query?
[removed]
Queries for data that your ORM doesn't map to an entity. So reporting queries are normally the best example.
&gt; A module’s declaration does not include a version string, nor constraints upon the version strings of the modules upon which it depends. This is intentional: It is not a goal of the module system to solve the version-selection problem, which is best left to build tools and container applications. That killed it for me. :( 
How far along is the core code? Do you plan to host the code on something like Github or BitBucket?
How does this compare to generating an app with JHipster (aside from the front end stack difference of Recact vs Angular)? I just learned of JHipster last week and it was pretty cool with how quickly it can build up a basic webapp with a lot of common features. Not trying to say this isn't nice or cool, but just wondering if you have any experience comparing the two.
Authentication/Authorization of Spring Boot REST APIs by Oauth2 + JWT? I couldn't find it on the page. If not? Why not?
Interesting to compare and contrast. Mine has projections (for `map` and `flatMap`), and no `getLeft` or `getRight`, although you can do `either.left().toOptional().get()` if really desperate...
You can definitely have dropdowns, calendar and editable/sortable/paginable tables with angular.
Thanks for the link. It's very open to changes in these initial stages, I'm not a controlling person, I just want it to be open. So if anyone is interested they can be sure there won't be a top-down approach to development, I'd much rather discuss things in a lot of detail so as to make the best tool. The extent of the detail out so far is on the page www.openpatterns.net/#ents and the youtube video there, which essentially repeats the page in more detail. If you like where the project might be going I would greatly appreciate a couple people to help me get it off the ground because though I'm comfortable with coding and have done it a lot, I'm not too comfortable with content management and stuff like that because all my projects have been solo so far. I'll try to find a license and upload the code I have so far, though again I expect it to change a lot.
When I saw JHipster (far ago) I didn't notice how to create forms with rich elements, or grids with sorting and paging on the server side. If you provide some links here it would be great, just for information.
thats actually not the example i have an issue with. My issue is with val stuff = getStuff(); 
certain other languages have a `swap()` method which is slightly less offensive for that.
...which sounds like a thing you could add to your API while it's still young! These little classes like `Optional&lt;T&gt;` really live from on the built-in utilities, because they are mostly here to shorten code.
I thought OAuth2 is valuable when you have an external server for it. So, I decided not to run OAuth2 server inside such a simple server of this project.
only essential feature should be added. The other are just complexification. We could also totally remove type because at the end there are useless. There is no type in assembly.
`swap()` is indeed useful - default Either&lt;R, L&gt; swap() { return join(Either::ofRight, Either::ofLeft); } but I don't see how it relates to `Either::getLeft` or `Optional::get`...?
The biggest annoyance to me about Java EE MVC is that the return type of Controller methods have to be one of, `void`, `Viewable`, `Response`, or `String`. You can actually return your model in the method.
I believe that, rather than doing this, Oracle and the community should adopt a "new Java" language that already runs on the JVM and has most of the requested features, and up from there have the JVM evolve and copy the current optimised implementations into a new, formal, non `java.util` clusterfuck API. This way, Java adopts a Legacy status, with updates to the standard library and fixes, but most of the meat in a newer standard library. Java has so much on it's back it's be a hard culling.
JCE is not one thing. Its an interface to many possible algorithms.
Have you looked at jvisualvm? It's bundled with the JDK and seems like it should do the trick
&gt; jvisualvm thanks, I'll take a look - didn't know about that
There was a vague reference awhile back on one of the JDK lists that whilst the module -declaration- doesn't mention versions, they can be included, I believe the core JDK modules have version information in them somewhere that jdeps can reveal. Would be good to know if that's true or how it can work (annotations on the compiled .class is one option) 
online tool :-(
Given the existing proposal, you can continue to use var as a variable name, but not as a type name.
You want to be able to inspect objects in memory? Any instance of an object, without having the reference to it? Without the software explicitly registering them somewhere? I don't think you can do that with simple JMX or remote debugging. You can probably achieve this with agents? But this is quite advanced techniques and are you sure you actually want to use that? http://www.javabeat.net/introduction-to-java-agents/ If you are trying to track down a memory leak, you can make a heap dump of an existing Java process, and then analyze it offline using VisualVM or MAT.
Fully agree, if it is online in no way I am going to send customer data over the wire.
Ha, I don't have actual experience with JHipster. I assumed it was just a project template generator and that you were free to add any angular plugin you need.
Three important points from the atticle: * Applies to latest release &gt; The new PoC exploit code works on the latest available versions of Java, including Java SE 7 Update 97, Java SE 8 Update 74 and Java SE 9 Early Access Build 108. * Not necessarily just a plug-in issue this time &gt; The bad news it that the CVE-2013-5838 flaw could be exploited also to target server environment. “We verified that it could be successfully exploited in a server environment as well as in Google App Engine for Java,” added Gowdiak. * Does require additional attack vector to fully exploit &gt; In a real attack scenario, the attackers would need to find a separate flaw that allows them to run the attack in a stealth mode bypassing the security prompts or to convince users into approving the execution of the exploit code.
Here's an overview of the features slated for release in Tomcat 9: http://home.apache.org/~markt/presentations/2014-11-18-Tomcat-9-early-preview.pdf
What is the key feature that would motivate you to migrate from 4?
Mine says to check the box to "Suppress sponsor offers when installing or updating Java". Wondering if they changed this.
My point is that if I have a JAX-RS resource that produces json or xml, I return a model that get's serialized to that format. In my eyes, producing html is the same, except your model gets serialized into html. @Path("foo") @Produces({TEXT_HTML, APPLICATION_JSON}) public interface FooResource { @GET @View("fooView") FooModel getFoo(); } Through content negotiation, the same method produces json or html, and uses `@View` when serializing to html.
While I am a bit underwhelmed, I really do like the @DisplayName annotation as well as nested classes. `@Test public void thisAndThatShouldWork()` is just ugly.
Interesting! But it also seems like such a non-intuitive side-effect. 
Uh, no, that's the point of moderation. If a post is off topic fighting fire with fire helps no one, moderating bad posts such as this would clarify things easily for users who are new to the sub. Plus, this person did ask the user to follow the rules, they posted a passive aggressive comment which helps no one.
Interesting comment about whether supporting ordering of tests should be supported. While I'm sure there's some cases it may be tempting to do so, in general I'd argue unit tests should be independent of one other. If you need to ensure they run in a certain order, that seems to indicate that you're trying to unit test code that's insufficiently modular.
I've used http://www.tagtraum.com/gcviewer.html in the past for quickly looking at GC logs, rather good for a quick overview at least.
I have to say that I am not entirely sure and I am no law expert by any means. I think this page states the issue pretty clearly: https://www.gnu.org/licenses/gpl-faq.html#GPLStaticVsDynamic Actually, I once thought that LGPL would somewhat fix this legal mess but the official page of The Apache Software Foundation states that LGPL (and multiple others...) cannot be used either because they are incompatible: https://www.apache.org/legal/resolved.html#category-x Since I chose the Apache License 2 as my license of choice I have somewhat knowledge in what I can do and what not but I do not really know about other ones (But some are quick to read and understand, like MIT or BSD). It would be nice if the choice of the license would be easy but in fact it is sadly not the case. If you have any more questions feel free to ask! At last I would like to mention that it is also possible to dual (or even triple) license a software if you cannot decide for some reason.
You need to pick a project before you can decide what GUI framework will be best for your case. If you're making a desktop app, I recommend using JavaFX. If you're targeting mobile, then android is really the only way to go. If you're making a web app, then something like GWT is the natural choice (if you must do it in Java. I would sooner just use HTML/CSS/JS than use GWT, even if my backend is Java.) There's no one-size-fits-all solution, here.
You may want to take a look at this approach https://www.reddit.com/r/java/comments/4acbrh/web_app_with_spring_data_rest_and_reactjs/
I'd go with an embedded website browser even on desktop. I am not a fan of swing or fx.
I'm making a garden planning application. It will do the following: 1. Take your city name, and from that get your "average last frost date." Cities and dates are in their own class. 2. Ask you which plants you want to plant. Each plant has a certain number of days that it's best to plant it, in relation to the last frost date (i.e. 56 days before, 14 days after, etc.). Calculate a planting date for each plant you want to plant. 3. Ask you for the length and width dimensions of your garden and ask you to allocate how much space you want to give to each plant. In the class with the information for all the plant types, each plant has a specified amount of space that it needs. So based on our allocation of space to each plant type and how much space each individual plant of that type needs, calculate how many plants of that kind we can plant. (i.e. in a 5x5 area would could plant 100 carrots, or 9 tomatoes). 4. Take into account companion planting concepts. Some plants do well around certain other plants, and do poorly around others. Attempt to order the plants in such a way that no plant is next to another plant it doesn't like, and ideally is next to a plant it does like. I'm done with steps 1 and 2, and am working on the algorithms for 3 and 4. I am only making this so hiring managers can see that I can code. 
You could also add provisions for shade based on nearby shade sources (trees, buildings, etc.) and the current time of day (using a kind of ray tracing or frustrum projection). 
&gt; I would sooner just use HTML/CSS/JS than use GWT Why? any specifics? 
Most Java work is server side, so to answer your question: the browser is the GUI. If you want to write the front end in Java, [GWT with material design](http://gwtmaterialdesign.github.io/gwt-material-demo/) is a way to get nice results without having to be an expert at Javascript/HTML. 
Basically you are in the wrong sub as such questions are better targeted at /r/javahelp. But to give you some ideas, check out the [Programming Challenges](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) in /r/learnprogramming.
I believe this is called an "out-parameters"... and yes this usually a bad practice, but may come handy if used properly. If you really have to do this, please add a comments over the function that describe the params as an "out-parameter". 
Check out Vaadin https://vaadin.com/home that's my favourite 
There is a big problem with this kind of poll. We don't know who are the voting. In particular, in which kind of enterprise they work for example and for which kind of applications. So, it's not very representative. However, I think effectively that Java 8 has a better adoption rate than Java 7 for example.
What's interesting is that Hibernate ran such a survey and got [the same results](https://twitter.com/Hibernate/status/700998618824753152).
Kotlin: A new JVM language with no remarkable or distinguishing features from other JVM languages.
I mean, if you want Frege, use [Frege](https://github.com/Frege/frege)...
I'll give you two examples: public int runDroolsRules(List&lt;Object&gt; objects); This method runs drools rules on the objects in which it changes some of its properties based on other properties. (I won't get into the details). The return is based on a certain statistic of the number of changes made. Would that really be wrong to do? Second example: public void updateInventory(List&lt;Object&gt; objects, List&lt;Object&gt; moreObjects); This would update the first List based on the second List. Is there a point in passing back the first List as it's really only a pointer anyway?
It's a better java. Not like Scala which makes you learn functional programming, is full of dsls, and implicits. Kotlin is really a better java. I've been using it for around six months and I can't think of any reason not to use it instead of Java. I can't even think of a reason to not use it inside of existing Java apps for new classes. I say this as someone who likes both Java and Scala. 
GWT is dying.
"New"? I've had the impression that Kotlin was released several years ago... Still a very cool language, though. ^(Shame I'll never get to use it.)
It just went 1.0 last month and jetbrains is starting to integrate it by default into its products (or, at least, IDEA), so it's getting a bit more exposure now.
While I highly disagree with you that it's useless, I do agree that, instead of returning void, it ought to return either default test instances (mutable so they can be altered by @BeforeEach), or a default test instance factory or default test instance template (which will, combined with @BeforeEach, still allow the creation of immutable test instances, which can easily be parallelized).
I don't find that argument very convincing. At least Ceylon has a clear mission for the language, why it exists or it was started. Same with Clojure and Frege(even if only to reimplment other languages on the JVM). Groovy already exists as the better Java with Buff and Polish. Kotlin doesn't have a clear purpose, mission, or objective. It doesn't have a clear roadmap(what will the language be like in 3 years?). It doesn't solve a problem other languages don't solve. There's no real reason to consider the language other than the fact it that's supported by JetBrains.
I've been predominantly using swing this year because of NetBeans. Some companies just love sticking to old shit that they're used to.
been using this for a while and I'm really loving it
There are a few connectors to swt, fx and swing. E.g http://www.eclipse.org/swt/faq.php#howusewebkit so you still need some fx, but just the bare bones.
Hello guys. I am currently working on A* search in java. I want to do graphical output consisting of rectangles of different colors representating walls and tiles in closed list. Whats the best sollution? :) Swing/JavaFx or is there some kind of easy drawing interface? 
Thanks for the guide. I enjoyed your explanation of sometimes difficult to understand subjects and the possible questions you might be asked regarding those subjects. If I could suggest anything is that perhaps add a small snippet of code for each subject. That would make it the essential study-the-night-before-the-interview study guide. Thanks &amp; I left you a positive review since I enjoyed the book.
I disagree with this sentiment, and can only imagine 20 years of familiarity allow people to reach this conclusion. Generics, Erasure, Inner Classes, initializers, Functional Interface polymorphism, finalization, classpaths, classloaders, dynamic linking, annotations, are all things very different from other languages that are difficult for new comers to programming and the JVM to learn.
Is that such a bad value proposition, though? The biggest issue with any of the other JVM languages is usually that they lack first-class tooling and IDE support. Personally, I feel like a JetBrains sponsorship is in many ways priceless for a new language.
I was curious what this data *looked* like, so I made a quick plot in Excel. [Java 8 Adoption](http://imgur.com/6laVL8B) It's interesting that there's a slight inflection, although I doubt it's statistically significant.
Unfortunately when I went to the Amazon page it said it was unavailable, except for the paperback.
That just might do it. Only free things in the US :(
I really don't get where the tooling meme with Kotlin comes from. Have you tried running the Kotlin compiler in Jenkins or some other CI tool? Using with emacs? WHat about binary compatibility? How do you build for multiple versions of Kotlin a the same time. Code coverage? Static analysis? Profiling? Scripting? The tools are nonexistent in most of these categories. Sure it works in Intellij, I don't see how that translates to "first class tooling".
FIFO / Clock-based / random policies should have the highest read throughput, since they do the least amount of work per access. This benefit can come with negatives elsewhere such as increasing the write penalty, reducing the hit rate, less predictable latencies, etc. Any design has to make trade-offs, especially when integrating all of the features one expects from a library. The interesting take away is probably not raw throughput, but if the caches provide enough headroom to not be a bottleneck while still being effective at their other responsibilities (hit rate, features).
Kotlin's only mission is to be pragmatic. The goal is to look at the Java ecosystem, see what's wrong with Java the language, and attempt to fix it. It's just meant to be a cleaner, leaner, better Java. Nothing remarkably different.
Worked for me. Thank you from Germany! 
I'll admit, android development is not something I don't do in any serious capacity. That said my experience in dabbling with in Scala didn't have any real issues. I already knew by being in tune with the Scala ecosystem, and being a proficient user with SBT, that setting up [protify](https://github.com/pfn/protify) was the quickest route to being productive. However, I do realize that a user attempting to try scala for the fist time and set up an android project using a number of outdated blog blog posts, and abandoned scala-android api wrappers would find the experience less smooth, given there's no official documentation or support for android.
Yeah, after giving it a second thought, Groovy doesn't belong in that list. Perhaps I'm being optimistic, but I can see Swift becoming huge in the Android development circle if the framework support is there. Using one language for both iOS and Android apps would (obviously) be incredibly useful, and, as much as I like the idea of React Native, I don't think that's the solution.
&gt; Have you tried running the Kotlin compiler in Jenkins or some other CI tool? Works properly with any CI tool which supports Gradle, including Jenkins. It's very easy to set up.
Who the fuck cares if you're a Swing or JavaFX fan?! Your answer should be based on what's the better choice not on whether you're a fan of java GUI frameworks or not. Nobody gives a shit that you'd do it using a web app just because you don't like java's GUI options.
I'm not a big Kotlin user, so I don't really know what its ecosystem looks like right now. My point was that well-established JVM languages like Groovy, Scala, and Clojure still have glaring lapses in tooling. For example, Vim's Groovy auto indent is awful, a pretty big indictment for a scripting language. As an impartial observer, though, I'll be keeping an eye on Kotlin as it matures. If Jetbrains stays behind it, I'm assuming it'll eventually be easier to work with than the other alternatives. Of course, you may be right instead, but I thought I'd articulate another view on the matter.
No, that's not its mission, and the JetBrains folks are clear about that. Kotlin's mission is to provide developers at JetBrains with a language that facilitates their work on the JVM. It is not an attempt to rectify what's wrong with the Java language. Only an attempt to serve the company's internal needs.
In what way? Seems like a better Java, but not holding the candle to Scala.
I would also void the return type to try to make it clearer stuff is happening to the inputs.
I don't know. Java was the first language I learned seriously. I knew a little C++ but haven't touched it for years when I was a freshman and it all just makes sense to me. That was only 4 semesters ago. Since then I've learned C, Python, and MIPS Assembly and I love them all (except Python, can't stand it honestly) but Java just really did make sense to me. 
Good comparison, but ObjC→Swift is a way bigger improvement than Java→Kotlin. ObjC didn't any kind of modern features, not even generics.
That works for me! Thanks!
Is it J2ME?
Effective Java by Joshua Bloch is what I would consider to be a definitive source for best practice java coding. The book has chapters specifically dedicated concurrent/thread safe practices, Factory patterns, etc. 
Yep, it complements Java rather than replacing it. Java APIs feel pretty natural when used from Kotlin and vice versa. You can even have both in the same project.
I believe so, but that was after swift so beside the point =P
Why on earth would groovy NOT belong on the list of great languages to do android development with? If your only complaint with Groovy is the dynamic typing, it might interest you to learn that ever since groovy 2.0 groovy can be compiled statically instead if you'd wish. I feel obligated to point out that anybody doing Android development is already using Groovy, you just don't know it. The Gradle build tool which android has switched to? All your build scripts are written in groovy.
[removed]
Thank you very much for your constructive criticism. I will definitely use it for the next revision of the book. Hopefully, the next time you need a quick refresher, you won't need to research a topic again and everything will click with just the overview. And I really appreciate the reviews, it helps a lot!
&gt; I can't even think of a reason to not use it inside of existing Java apps for new classes. What about social alienation? If everyone is coding Java and you're using some weird thing that's sort of like Java, but isn't, then how can you cooperate with your peers?
Easily, because it only takes one day for a Java programmer to be able to program in kotlin.
That's why you use Proguard and the new optimizing backend in Scala 2.11.
It wasn't. It was targeted first and foremost at standard Jvm development to help develop jetbrains products. 
What country are you in?
what an abortion of a website - damned ads
The Kotlin language is amazing. The worst parts of using Kotlin (as someone who is using it in all of his projects now) are: - `kapt`. Shit is just weird. As if generated code weren't magic enough, now I have to deal with an annotation processing tool that I don't fully grok. - The Kotlin plugin. The plugin written by Jetbrains in a language made by Jetbrains, for an IDE written by Jetbrains, also in the language made by Jetbrains. And it somehow feels like an awful third-party hack. I get exceptions from it every 5 seconds. Wtf man... This isn't really a knock against the language IMO. The foundations are solid. The toolchain is a little shaky. Once you get things to compile though and get your source files to actually see your generated code, you're golden. :)
I've been using SQLBrite and SQLDelight, and they work really nicely. SQLDelight doesn't actually work well with Kotlin, so I made a Java-only Gradle module that holds my SQLDelight models, and then they're compiled into my Kotlin code, where I use them. I end up with `.sq` models that become useful Java models, and Observables for my database thanks to SQLBrite. I'm really happy with how it works.
Turns out it was Alex Buckley giving the talk; colleague thought it was Mark, wires crossed (apologies Alex!). It was a slightly condensed version of this JavaOne talk - http://youtu.be/xswtIp730Ho. Hilariously, he'd seen my comment here, and he asked for me by username during the talk - we also happened to be "troublemakers" he'd identified at the start of his talk, when we raised our hands to his "who's tried Jigsaw" and "who's compiled the JDK" questions. He exclaimed "I knew it!" when I sheepishly admitted it is I, BinaryRage. Fun! The JDK modularisation work is really very impressive. I don't envy the technical debt they've had to wade through to get here. Particularly looking forward to modular runtime images, but all of their work here is a fantastic and important step forwards. The benefits of strong encapsulation are undeniable, particularly having those benefits at both compile and runtime. We're still hung up on the lack of versions in requires, however. Java's own modules do indeed include version numbers, however that's a capability that appears will be contained to internals; appears they're unwilling to open that particular Pandora's box on mere mortal developers. I'd hope that the belief they need that capability would be a signal to them it's useful elsewhere, but I understand completely their need to be concerned about the lowest common demoniator, and avoid the potential pain the complexity that introduces. That leaves runtime defined layers as the option for separating modules that have different module version requirements, which punts the concern to the build tool. Talking about it to my colleagues in the car on our way back, our conclusion is that means the build tool needs to be module aware, be able to calculate and separately conflict resolve public and internal requires, and then either use user defined, or calculated layers, and represent those layers at build time. Then through some mechanism, pass that knowledge to a runtime system at both test and runtime, to ensure that the final runtime environment is reflected at every stage of development. That's not a task we'd shy away from, there's no doubt that the module system makes this far easier to implement correctly, without resorting to class loader, shading and packaging name spacing hacks; but I so wish that the module system, javac and the java launcher could do this for us, as it's by far our single most painful and costly dependency management problem. He also mentioned some very interesting new capabilities of java.reflect.Proxy. We didn't have time to get into the details, but it looks like proxies can have duplicate interface methods, which will be satisfied by the underlying object if the method name and arguments match: http://download.java.net/jdk9/docs/api/java/lang/reflect/Proxy.html
That's sort of like saying a virus only has an incubation period of one day, especially if they're forced to use it
That's nothing compared to [FizzBuzz Enterprise](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition).
Viewing Groovy as anything less than a Java/Kotlin competitor is silly (especially since it's out of its incubator phase and is now supported by the Apache Software Foundation). Groovy is what gave birth to fantastic web frameworks such as Grails which helped bring Java web development into the future so that it can contend with the Rails/MVC way of things without having to switch to another language to use current webdev patterns. Groovy is what gave birth to the Gradle build automation tool which is, IMO, much easier to use than things like Maven and is already widely adopted throughout industry. It's even the reason why we have nifty little tools for the JVM development environment such as SDKMAN (formerly something along the lines of "groovy environment manager"). Heck, I don't really think that Groovy developers see Groovy so much as a Java competitor but more as a Java supplement. The entire point of Groovy is to be Java++: Java with less boilerplate/verbosity and added features which bring Java into the current century (like closures, beautiful beautiful closures). In fact, if you don't know the groovy syntax way of doing something you can literally rest on your laurels since plain old java syntax will compile within groovy. But the language was kind of designed with the idea of, "what would java look like if we invented it now?" I'm not trying to get people to drop everything and learn Groovy. If you're happy with whatever JVM language you're currently using then that's 100% OK. I'm simply trying to dispel whatever myths and misunderstandings keep being purported by people who have little to no experience with it yet for some reason have an opinion.
Wasn't this already free earlier this year? Amazon says I already have it.
it's interesting see all these complaints about the plugin, because during the beta releases all the forums were filled with people praising the Kotlin tooling.
I know, but one does not exist without the other. Anyone that thinks Oracle will ever replace Java the language, as the systems programming language of Java the platform, irks him/herself.
Not the OP but I am from Turkey and interested in the book. I could not manage to get a copy. Maybe you would like to share it from some sharing service for the remaining time. Is this a promotion for Amazon reviews? 
Yes, I did another giveaway a few months ago and once before when I first launched the book.
`FunctionParser#getReplaceForVariableAndType` the argument `var` is unused
`FunctionParser#fromString` the local variable `List&lt;String&gt; types` is updated, but never queried and removing it doesn't break any tests
You might want to change the method signature of `FunctionParser#fromString` from: public static ParsedFunction fromString(String functionString) { to: public static &lt;T&gt; ParsedFunction&lt;T&gt; fromString(String functionString) { and updating: Class clazz = evalClass.toClass(); ParsedFunction obj = (ParsedFunction) clazz.newInstance(); to: Class&lt;T&gt; clazz = evalClass.toClass(); ParsedFunction&lt;T&gt; obj = (ParsedFunction) clazz.newInstance(); So that callers get back a properly typed `ParsedFunction`
In `FunctionParserTest` is there any reason why you are explicitly boxing primitives like below? Object[] args = {Double.valueOf(1.0), //etc
In `FunctionParserTest` there are several tests which have no assertion and instead `System.out.println(` - it would be better to assert and not print output which (I assume) needs to be checked manually
Thanks so much for catching that! I will fix this asap.
Thank you, will fix this asap!
Thank you, the idea behind these tests is not really to be tests but simply copies of the examples supplied in the README file. I will however make the suggested changes, as i imagine tests should normally not output to System.out.
My use case when developing this library was that i needed a way of solving problems that were unknown at runtime, by reading a description from a file. Other use cases are algorithms that must change during runtime, for example with genetic programming.
Sounds reasonable - maybe include something in the readme :)
I'd have loved to but it's only available in AmazonUS and not DE :/
This is a mistake, and has been fixed thanks!
Is this for a compilers class? Seems like a fun project. How long did it take?
For my original usecase generated methods were executed millions of times, and were in the core of the algorithm. Therefore the reasoning behind creating functions that return primitives was simply performance. I know that premature optimization is a bad idea, but if i remember correctly i believe i benchmarked the difference. I will run new benchmarks and evaluate if the primitive return functions are necessary.
You mentioned elsewhere: &gt; My use case when developing this library was that i needed a way of solving problems that were unknown at runtime, by reading a description from a file. If you don't know the function until runtime, how does your code select the correct method to call?
For runtime scripting, look into using the embedded javascript engine that comes with JDK. Java 8 has a new version of the engine called Nashorn. Integration between javascript and Java is pretty easy. You can pass data back and forth.
I have now run a benchmark to compare the generic vs primitve method and found no significant difference. However i did discover a caveat of using the generic types, and that is that my library currently does not support autoboxing meaning that in order to create the function "double(Double x,y)-&gt;x+y" as a generic, the string would have to be "Double(Double x,y)-&gt;Double.valueOf(x+y)"
So, as an example, you would have known at compilation stage that it was going to be a function that took, say, an array of integers and returned an integer, and therefore in the code you would have called ParsedFunction.evaluateAsInt(Integer[]). So essentially, always the same signature, but the body of the function and the arguments would evolve?
Thanks for your feedback! There is no limitation on the amount of types the function may take in, therefore the inputs cannot be parametrised. You are right that the primitive methods should be removed and only a parametrised evaluate function should be used. However, my library does not currenly support autobonxing, so i would have to implement it before i could make that change. I will probably do this!
Seems low for skilled jee and what appears to be security clearance position. Just sayin.
Cool, but similar to JavaVDL? * http://jdevelopment.nl/authoring-jsf-pages-pure-java * http://jdevelopment.nl/single-class-pure-java-jsf-application
No matter how good it might be (I'll never know) cannot overcome the fact that it is an online tool. 
I use it https://github.com/chewiebug/GCViewer from time to time. Current version 1.35.
IDEA products continue to be the only products that have absolutely no upgrade issues.
Please tell them !
[removed]
All the fonts are messed up on my linux workstation; they were previously fine in version 15.
I'm superhappy with some of the added features: git worktree support, move elements right and left, importing static members. Keep up the good work JetBrains!
Could it be due to the 2016.1 release? 
don't know, mine just says 1.0.0...IJ143-75
&gt; Source for the faster bytecode claim? Not really. The author of MapDB claimed it. Checking benchmarks and documentation it seems the performance is on a par with Java. If so, that would imply it's faster than Scala, where I understand the accepted wisdom is that Scala has an overhead of 10-20% relative to Java. But the benchmarks etc that I've seen are not very thorough, so I can't claim to have a reliable source.
Places are offering $15,000 for referrals? That begs the question: why are they having such a hard time finding people?
Sorry to hear this. As a Linux user, our fonts can sometimes be a pain. Could you send us some information about your environment and attach a few screenshots on [IDEA-57233](https://youtrack.jetbrains.com/issue/IDEA-57233)? Thanks!
Any idea when the new EAP will come out?
Could you send us a little information? I couldn't find any related issues [on our tracker](https://youtrack.jetbrains.com/issues/IDEA?q=%23Unresolved+145+Spring), but if you get the chance to submit one, it would help to attach your log on startup (Help | Show log). Thanks!
I've tried using embedded javascript in one of the projects that needs to compute user entered conditional expression. The performance is not at the level of Java. In my case, those got executed many million times in a short period so I switched back to using one of the math eval package like Parsii to use native Java class. However, embedded javascript gives a full language that offers amazing customization power. I would use it again if performance is not the bottleneck. Also for embedded javascript, be sure to call the API to compile it first before running it. Avoid reloading the script every time inside the loop. 
It's funny. I always have the "kotlin plugin has crashed" error in the upper right of intellij, but it doesn't affect functionality at all. So it is odd that it crashes, but the tooling is still well beyond the tooling for most languages and is all functionally there.
Beats me. There isn't a ton of Developers in Idaho and I'm sure not many people would consider moving to Idaho unless they had already intended to do so and happen to be a developer. Regardless, I felt like it didn't hurt to throw it out there haha
You work for jetbrains? if so, thank you for your quality products and for listening to the community.
I did have a Gradle project! I did a Gradle clean and idea build and that didn't fix it. Although I think it has more to do with modules in the run configuration. I noticed rather than my usual names, there were two for each, one under test and the other main. I never changed those, but I had to when I re-cloned my project
I referenced what I thought had happened here: https://www.reddit.com/r/java/comments/4atdr5/intellij_idea_20161_is_here/d13ls0v After correcting my modules in the Run configuration everything seemed to work! Thank you for your prompt reply, and outstanding release!
The release notes make a quick mention about that: &gt; Gradle &gt; &gt; The project model of the IDE is now aligned with that of Gradle: each source set of a Gradle project is now a separate module in the IDE – and may have its own dependencies. This change has solved many issues reported by our users.
are you looking for something free or paid?
Ironically the next post under yours was about [his Spring boot application not working anymore](https://www.reddit.com/r/java/comments/4atdr5/intellij_idea_20161_is_here/d13e0es) But really though it's fluid as always, I just thought that was funny
Why is it telling me this on the upgrade popup? &gt;You can evaluate the new version for 30 days or buy a license key or an upgrade online. I have the free student discount for another year, so I don't see why I can't update for free.
I've always had the opposite experience and wait till version x.1 to upgrade. Been using IntelliJ since 6 and they've broken something basically every release (I do try x.0 despite being burned most times). Great ide though, wouldn't trade it for anything else out there.
Yes, it is similar, except NoVDL provides a fluent api which makes the java code look just like the Facelets code. It also has convenience methods for incorporating EL expressions. Both implementations are stupidly simple. It makes you wonder why we bothered with all that JSP and Facelets stuff in the first place.
Options are awesome, but only with proper support for monads and monad comprehensions.
This is about using Netflix libraries with Spring Boot, not about Netflix using Spring Boot (in case anyone else was confused by the title)
chile
After years of having to set up a lot of boilerplate default application configuration, it's nice to see where spring is heading with Spring Boot. It's probably a personal preference, but creating an application with Spring boot compared to without it is a big step up in my humble opinion.
I'm also a student and have had this happen before, I've just gone ahead and upgraded and then signed in again with no problems. 
Thanks, I will give that a try.
It's performance, which is basically about as fast as PHP, and excessive abuse of XML and annotations that push as many errors to the runtime. Also AbstractFactoryBean...
I worked with Vaadin for a year and a half. It's sloppy if you need a quality interface 
It's performance is slow at what exactly? I'm calling you a troll simply because your argument is nonsensical when it comes to the current Spring baseline.
I love you, JetBrains. 
[See how long it takes you to scroll down to find Spring.](https://www.techempower.com/benchmarks/#section=data-r12&amp;hw=peak&amp;test=plaintext) You can also check the other benchmarks on that site, and nowhere does it perform well. I see no reason to choose Spring over other Java frameworks, especially the really fast ones like Undertow or Vert.x...
I believe the onus is on you buddy. Show us the metrics to back up your claim
That's a very weird "benchmark." I mean it lists Jetty as a platform. It's servlet container. You're really using this to back up your argument? Ok let's dig deeper into this nonsense you linked. The first tab is JSON serialization. Is that Jackson? Gson? Genson? Spring itself doesn't do that. Single query. Single query to what? What database? What driver version? Did they use JDBC? Spring Data JPA? I'm only through 2 pieces of that and it provides no information.
Exactly, it's measuring quite a lot of different responses from frameworks, libraries, full stacks. I mean, for example, undertow is a web server, which spring boot can use under the hood, so I'm not sure what we're comparing here..
I'm not sure either. Based on his lack of responses in the past in this sub is why I called him a troll. One benchmark based on random arbitrary things is quite meaningless.
It's a shitty benchmark, so yes I can dispel it.
Great, more spoonfeeding... &gt;What container did that code run in? [Undertow](https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Java/spring), it's in the readme &gt;What version of Java? [Java 8](https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Java), it's even explicitly stated. Almost everything you asked can be answered by diving into the source code.
[Here you go](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Java/spring/src/main/java/com/techempower/spring/web/WorldDatabaseController.java), you probably know how the inner workings of spring are better than I do. I'm not going to spoon feed you everything.
Been using intellij for about 2 years now, and at least twice I've had minor version upgrades completely break building the large maven project I work on. Luckily it was easy to downgrade and fixed pretty quickly with a new version each time.
Use a build system like gradle or maven instead of shoving library binaries into version control. Also don't put your IDEs configuration files in VCS either. 
Cool
Late reply. &gt; Regarding ISO, Microsoft leaned heavily on its partners who were on ISO voting committee and pushed the vote through. Go google sources yourself, I'm too tired to do it. You're the one who put this "reason", you should show the evidence. No? &gt; There are no major OEMs that will give you an option to choose Linux operating system on any PC/Laptop bought from them. Incorrect. [Dell is selling computer with Ubuntu pre-loaded](http://www.dell.com/us/business/p/xps-13-linux/pd), which Ubuntu is using Linux kernel (in case you don't know). I posted the link but you refuse to click it. Isn't Dell a major PC OEM? I don't see why you can blame Microsoft because OEMs don't sell computers with OS other than Windows pre-loaded. It could be business decision (e.g. not enough demand), it could be technical issue (e.g. OEMs don't bother to write drivers for making their hardware work with Linux kernel). But you insist that it is Microsoft. Give evidence please. &gt; SECURE UEFI is NOT supported by Linux [Red Hat](http://www.redhat.com/en/about/blog/uefi-secure-boot) wrote a post about it, it seems Red Hat is willing to license the key. I don't use Fedora but [the manual](https://docs.fedoraproject.org/en-US/Fedora/18/html/UEFI_Secure_Boot_Guide/index.html) does mention supporting secure UEFI. So the options are there. You can buy computers with Linux-based OSes pre-loaded, some Linux-based OSes do support secure UEFI. I don't see your point.
Which, luckily, Scala's are!
It would be nice if someone could finally fix https://youtrack.jetbrains.com/issueMobile/IDEA-18765 I really like package view, but I've seemingly triggered this issue and it makes the IDE hang for minutes at a time. Been an issue since 2008! It seems worse on this release
Good luck with that. Contact IBM and ask ask new cell for Lotus (Oris it Domino now?) 
Good thing you cleared that up for him. Otherwise, he might not have known to use Google.
Thanks, will check it out. I did see this one but I guessed (wrongly) that it was more aimed at beginning programmers. 
It's a massive book and all the others are pale imitations of JHTP. It has rigor, which is what you need. After that, Spring is now king in Javaland.
In our shop, we use Persnickety for the UI and build with Barfly/Alabaster.
That... is not what is meant by "full stack". Full stack JavaEE, which is more than a servlet container, if we're comparing the JavaEE and Spring *platforms*, also includes at least JAX-RS, CDI, JPA and JTA. That's minimum for an apples to apples comparison for the benchmark. On that score, wildfly-jee scored less than spring on one of those benchmarks, assuming the benchmark is really meaningful at all for real world applications. 
Even in Java eco there are attempts to switch to alternative collections library, like in Javaslang ( http://www.javaslang.io/ ). There are many reasons to do that, for example interface that forces implementation of mutability which even in pure Java doesn't give any promises and sometimes gives exceptions in unmodifiable implementations. In case of Scala they went even further and while they introduced a totally new collections API, where for example there you can have a true immutability API to implement (no setters method), there is still integration of Java collections where they are just mutable kinds. Then if you don't like options (and what's your reasoning about mess?) then I'm sorry but now even Java has it.
I have used AngularJS a bit, as well as plain jQuery (the AJAX support was sufficient for a small project). I've also used Thymeleaf for a JSP-style templating UI, rather than asynchronous calls.
Something like this, given its simplicity may be a good addition for JSF itself. I see you do have the same Mojarra dependency that JavaVDL also has to track the changes. That won't work on MyFaces. I think Mojarra also switched to a more elaborate system for tracking the VDL changes a year ago orso (not sure, but they did a lot of fixes for dynamic tree modification back then) 
Hi, If you have done good reading on the basics you may want to review the links here because these are the current best practices, patterns, and techniques to write state of the art Java program. This may not be absolute, but these are very good reading if you want to know where Java is now and also its coming future. - http://blog.paralleluniverse.co/2014/05/01/modern-java/ - https://github.com/cxxr/better-java Enjoy ;) -- Maiah
I don't like the Arrows in the branch view. Maybe I should try to get used to ctrl-shift-a ... However, I'm not the only one unhappy with IntelliJ Git integration. I know several other devs using external tools like Tower or SourceTree although they are using IntelliJ the whole day for programming.
As someone who is a long time but intermittent Java developer myself I'd suggest focusing on Java 8 and in particular how the arrival of lambdas is influence the language and ecosystem. As an experienced OO developer I'd guess most other aspects won't present the same learning curve. Superficially even lambdas can appear as a method to reduce boiler plating, but the implications of this trend toward supporting an increased functional programming style run much much deeper I feel. With that in mind I would suggest either the book [Java 8 in Action](http://www.amazon.co.uk/Java-Action-Lambdas-functional-style-programming/dp/1617291994) or [Functional Programming in Java](http://www.amazon.co.uk/Functional-Programming-Java-Harnessing-Expressions/dp/1937785467/ref=pd_sim_14_9?ie=UTF8&amp;dpID=41Hn%2BpBip8L&amp;dpSrc=sims&amp;preST=_AC_UL160_SR133%2C160_&amp;refRID=0KGQG04BS1C60Q9J9115). 
&gt; You wouldn't really use it to store passwords, or things like that. It's for data which can be arranged as complex hierarchies, like comparing two bread recipes, enzymes, words or molecules. That's not really a selling point is it? One of the strengths of a relational database is that no matter how your demands are going to change in the near future you can be pretty sure you can store it. I get that you want to have fun creating your own database but why not just go and do that? Might I also suggest you take a look at some DB design basics first before you start writing code? I noticed you already have some classes that are implemented in a way that you seem to be holding everything 'in memory'. Although this is a valid approach for a caching layer (Redis does this for example) I would not really call it a 'database'. If I were you I'd start with a basic B-tree implementation in Java so that you can store / index binary blobs and build from there.
I get the same message. I have JetBrains Toolbox until Dec 22, 2017 paid for. However after installing and launching, it says I have a perpetual fallback license for this version.
http://james.apache.org/ - very flexible and stable mail server stack for java.
See if you are going to use Spring. If you are, you should pick up a book on that (or just scan some github code) and understand what that framework provides. The annotations and other spring tricks can be confusing for someone who is used to 'old' java.
if you are going to be doing enterprise java, you need to get familiar with Spring. It's the equivalent of .net's Unity in Java.
To make the comment more generic...find out what framework will be used. A lot of shops use Spring, but some will use others. With your background, java will be easy to pick up again. The framework will take you more time. 
Yes this makes sense, not keeping the entire tree in memory. I'm not worried about memory problems just yet, I'm sure there are many methods to cache sections. &gt;That's not really a selling point is it? That is precisely the selling point, though it has additional uses. I cross-posted this to /r/Biology because I think it will prove extremely useful in studying many aspects of that field. It will be able to hold a much higher density of useful information compared to encyclopedic entries, while also requiring less time for content generators. The common use cases however do lend themselves to the code I have so far. I understand that there is overhead for making each node an object, and I could get away with only using pointers. But for a large section of end-users, I believe this is sufficient so far. But the theory of the database itself makes it easier to handle than a general database. First off, all data by definition is already arranged in a tree, so I don't see the use in using B trees. Additionally, each node representing an entity or group of entities must be unique, so searching is done much faster just using a hash map. So, yeah, eventually I'll move away from each node being an object, but there's really no reason to now, as even a few thousand nodes shouldn't be difficult to handle at all. It's still quite useful this way. I think you simply don't understand the concept I'm getting at. Feel free to follow the project if you're interested. I'm not trying to make a "better" database compared to existing ones, I'm doing something very specific with only very specific uses, however those uses I believe are very interesting and powerful.
Have a look at the following books if you haven't: - Effective Java (Joshua Bloch) - Java Concurrency in Practice (Goetz)
&gt; The Java ecosystem is not as beginner friendly as some others The Java ecosystem could be as simple as Python's, provided the chunk of the community wasn't so obsessed with verbose design patterns, weird abstractions and factories. See this one-liner for Rapidoid on how to serve simple JSON On.get("/size").json("msg", msg -&gt; msg.length()); This manages to be high level without excessive boilerplate AND ridiculously performant. And beginner friendly too. It's embarrassing that Java has been associated with verbosity, weird factory classes and poor performance when it could easily beat Python/Django or Ruby on Rails if the community tried to. 
Take a look at https://www.runscope.com/
You really need to see what type of framework you will be working with. Start with Java EE as it is very popular and the industry standard. If that does not work for you than take a look at Spring which is also a good choice. You will also want to learn JPA (Hibernate). You will needs parts or Java EE like that whether you supplement it with other frameworks such as Spring or not. They are both similar in a lot of ways. The main difference being Spring has more configuration and not much help for the front end. If you enjoy spending most of your development time learning and writing some JavaScript framework that will be obsolete in a couple years than Spring works. If you would rather spend your time solving business logic in Java go with JSF.
&gt; First off, all data by definition is already arranged in a tree, so I don't see the use in using B trees. I most seriously doubt you understand their use. Anyway. Best of luck.
Yep, already got Bloch. Will take a look at Goetz too.
Horstmann rings a bell, pretty sure I had a book by him when I was first using Java:)
There are many things IDEs do well. Source control is not one of them.
Well, chances are you'll end up using: * Some kind of Dependency Injection framework (probably Spring) * Built &amp; dependency management tools- maven or gradle. * Automated build- probably Jenkins or Teamcity * Logging framework (probably Log4j/slf4j). If it's distributed, you'll be using log aggregation, most likely logstack or splunk. * Some kind of unit testing framework (probably JUnit) * Not sure what frameworks will be used for UI. There are too many options/possibilities. If it's recent it's probably pure JS app + REST/JSON services. There might be some automated testing using Selenium. * Obviously Spark &amp; Kafka as you mention those. * Some kind of NoSQL or SQL database? Probably some persistence frameworks to work with them. * Tools to serialize Java objects to XML or JSON or binary? * Webapp servers? Tomcat/Jetty? Or maybe full blown JEE servers like JBoss/Glassfish? * Behavour driven testing? Fitness testing? Stress/performance testing? * Automated deployment &amp; configuration tools? * Container management/VM management and other DevOps'y tools? * Runtime performance metrics &amp; reporting? * Probably lots more. Don't start digging into all of them, although a quick google just to know what these are would be beneficial. Just giving you a taste of how many things you'll need to learn to be proficient with Java development in this sort of area. It's rarely just pure java development, it's gluing libraries &amp; frameworks together a lot of the time. And there are a LOT of frameworks and libraries. Best of luck. Come back and ask questions if you need more detail. --Coder
I jumped into a Java job with nothing but Bloch and a bunch of Javadocs. TO that point all my development had been C, Python, and Fortran. Had no issues picking up Java in the time it took me to learn my company's core libraries. I have never read *Core Java for the Impatient* though, so I don't know if I would have had an easier time with that book in hand as well.
What do you mean by java-equivalent? Last I checked you can write the actual AWS Lambdas in java, and Serverless just manages the aws orchestration for you.
I'm biased (I work for Lightbend), but this is a perfect use case: you should be looking at [Play](https://playframework.com/) -- it's an full stack web framework written from the ground up to work for microservices and big data. Play 2.5.0's Java API is written for Java 1.8. It uses CompletableStage (Java Future API) and Optional for everything, and is already configured with Guice under the hood. Play uses immutable messages and APIs, and takes care of streaming and queuing using an Akka Streams API that takes care of backpressure and integrates with Spark and Kafka nicely. There's also an async http client with a fluent API and full "secure-by-default" SSL configuration included. * https://playframework.com/documentation/2.5.x/JavaAsync * http://doc.akka.io/docs/akka/2.4.2/java/stream/stream-introduction.html * https://www.playframework.com/documentation/2.5.x/JavaWS 
Yes, it's bad practice. Ideally, you want to make your input immutable -- you can do this using "final" in your parameters, and using [Immutables](https://immutables.github.io) and [PCollections](http://pcollections.org/) for your API.
There isn't one general location, but there are some good blogs to follow, and many times you'll find examples on Github. [NoBlogDefFound](http://www.nurkiewicz.com/) is particularly useful for the underlying thread stuff. When it comes to concurrency and thread safe code, I tend to use Akka -- the thread safety is baked in, but it's based around Actors so instead of calling "foo.doStuff()" in a method you do "fooActor.ask(DoStuff)" and it sends you back the result in a CompletableStage (when it got around to it): * http://blog.coralic.nl/2013/08/30/parallelism-simplified-by-akka-in-java/ * https://github.com/royrusso/akka-java-examples
Not OP, but I'm in a very similar boat. I was considering asking the same question in this sub. I didn't know Horstmann had such a book; I've always liked his teaching style. Thanks for the tip!
This was pretty much my point. But the main consensus is that it's bad practice.
Check out the Youtube videos of Venkat Subramaniam. He's an excellent presenter on new Java techniques.
&gt; Best of luck. Come back and ask questions if you need more detail. Thanks, I will. Useful set of bullet points. These are all issues I currently face doing server side .Net so the concepts are all very familiar.
Thank you. You guys do great work.
Some of those technologies are going to be hard to learn via side project, because they are meant for "big data" or large applications. You could still use them, but it would be a contrived example and unnecessary complexity. Of the technologies you mentioned, I would put Kafka and Spark (the cluster computing engine) in that category. Then you have a few technologies that are "bread and butter" for Java developers - namely Spring, Maven, Gradle, and SQL. Websites are super common, and therefore very useful to practice. I'd recommend using [Gradle](http://gradle.org/getting-started-gradle-java/) as your build system and [Spark framework](http://sparkjava.com/documentation.html) (the web server library, not cluster computing engine) using a simple string templating libary to send HTML to the server like [Freemarker](http://freemarker.org/). For a DB, use regular [JDBC](https://docs.oracle.com/javase/tutorial/jdbc/basics/). Once you can build a little app with that (it might take a while - that's normal!), you might want to start tackling Spring. It simplifies some things for you (like Spring JDBC), but can also be hard to wrap your head around when you're just trying to learn the technologies on their own. Also, definitely try to read open source code, and maybe go over the ["better java" repo](https://github.com/cxxr/better-java) for more modern &amp; advanced java techniques.
Hey, thanks for your patience. We usually prioritize features and bug reports by popular demand, it so always helps to vote for tickets you would like to see fixed. I voted for it!
call google and ask them if they'll give you the source code for gmail
Hmm, I tried to already, but the number doesn't increment. Perhaps it's my adblock rules are interfering somehow.
Akin to the "better java" repo you referenced, I really like [Modern Java - A Guide to Java 8](https://github.com/winterbe/java8-tutorial#modern-java---a-guide-to-java-8) and [Not Your Father's Java](http://blog.paralleluniverse.co/2014/05/01/modern-java/)
We're working on something to make your life a little easier. Please stay tuned. ;)
The vote button doesn't work for me on that page (in any browser), and the JIRA link next to the vote tick is broken (only path, the base URI is missing - 'browse/IDEA-18765?disableRedirect') 
Sorry to hear! We're [not aware](https://youtrack.jetbrains.com/issues/IDEA?q=docker+2016+%23Unresolved) of any UI bugs with the Docker plugin at the moment. If you have a chance, could you send us a ticket or two? Thanks!
That's odd. I'm using [uBlock](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm?hl=en) with the default settings and couldn't reproduce. And you're definitely logged in?
afaik Spring is still the defacto standard, not Java EE
This is the correct answer. There was recently a large number of changes to improve Gradle support in the [Project Model](https://www.jetbrains.com/help/idea/2016.1/importing-project-from-gradle-model.html?origin=old_help), and this may have the unfortunate consequence of causing Gradle projects to fail the first time they are run in IntelliJ IDEA 2016.1. If you still can't run the project after refreshing, and it definitely works from the CLI, they we want to [hear from you](https://youtrack.jetbrains.com/issues/IDEA?q=%23Gradle+2016+%23Unresolved).
Or work through some of the guides on https://spring.io/guides
Were you able to [import the Gradle project](https://www.jetbrains.com/help/idea/2016.1/importing-project-from-gradle-model.html?origin=old_help) into IntelliJ IDEA and get it to run?
Yep, definitely logged in and also using uBlock. Be interested to see whether anyone else on this thread can replicate it.
School pretty much forces me to, so I guess I do.
Really depends on what you want to get out of it, I quite enjoyed: * https://pragprog.com/book/vsjava8/functional-programming-in-java * https://pragprog.com/book/vspcon/programming-concurrency-on-the-jvm I'd also look at some libraries such as * https://spring.io/ * https://github.com/google/guava * https://github.com/diffplug/durian * https://projectlombok.org/ * https://en.wikipedia.org/wiki/AspectJ 
I'd recommend looking into Gradle over Maven
Please, keep your homework tasks, exams, etc. between yourself and your teacher. 
[removed]
I'll fill something out when I get a chance but go look at the docker plugin preferences on a Mac. There's no labels on the text fields
&gt; I can not create a Servlet within this project *pom.xml* &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; *ServletDemoApplication.java* @SpringBootApplication public class ServletDemoApplication { @Component static class HelloWorldServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletOutputStream stream = resp.getOutputStream(); stream.print("Hello World!"); stream.close(); } } public static void main(String[] args) { SpringApplication.run(ServletDemoApplication.class, args); } }
Sweet. I just recently began playing around with JavaFX 3D and was looking for something to do with it.
&gt; similar workaround via extension methods (which looks like a hack). wrt to being a "workaround", perhaps... but as a feature in-itself, i think they're pretty cool. being to throw my own extensions on to string for example is handy. you can do some cool tricks like extending int: `2.times(n -&gt; Console.Write(n))`. maybe not a mind blowing example, but it's nifty.
Git &amp;&amp; (maven || gradle) are the big big ones. Almost everyone uses git. Everyone should use maven or gradle or sbt, anything but ant. If you wanna do websites maybe check out play framework. It's the new hotness. Pays to learn DI, either spring or new guice hotness.
The Road goes ever on and on Down from the door where it began. Now far ahead the Road has gone, And I must follow, if I can, Pursuing it with eager feet, Until it joins some larger way Where many paths and errands meet. And whither then? I cannot say
Thanks for the response. Will take a look at that library. Actually, I would like to use this code in production for an Android app. That's why I want to get feedback from community. 
This was an incredibly concise response for the amount of information you conveyed, and exactly the type of guidance I was looking for! Thanks, and especially for linking everything, looks like now I know what my plans are this weekend 😊
You probably want https://github.com/joshjdevl/libsodium-jni then, since that explicitly talks about Android. Actually looks like there's a bunch of them, but I have no idea what Android Studio is: https://github.com/ArteMisc/libstodium Libsodium documentation is a bit odd, but you want the "symmetric encryption" function which is called `crypto_secretbox_easy`: https://download.libsodium.org/doc/secret-key_cryptography/authenticated_encryption.html 
It depends what you mean by "safe to use." If you're building yourself a little proof of concept to understand how it works, encrypt and decrypt some text or images, then it's probably fine. If, on the other hand, you're wondering if it's safe to encrypt personal or financial data with it, the answer is almost certainly not. It's nothing against you, it's jus that cryptography is really, really, really hard to get right. Your best bet is always to use a proven, tested, reviewed, audited open source solution. 
This is exactly how computer science makes me feel. I've been a long time tinkerer ever since i can remember. When I was 8 or 9 my mom brought home a C64 from the library they were about to throw out. We lived in Cali at the time but I don't remember being outside at all that summer. Just the glow of that screen and how it felt when I learned to input commands and run scripts and play games...like this machine could do anything I wanted it to do if I could just figure out the right combination of commands, and believe me I tried lol. I went back to school for computer science at 32. My first day of my of my first computer science class I had to leave the room for a few minutes because I was crying. All of the sudden all at once I just remembered being that kid again and I felt at home for the first time in a very long, long time. I felt like I could finally just relax and breathe because another little piece of the puzzle just clicked into place. It has been a long and winding road for me to get here, and I've been lost at times, but finding my passion again has truly saved me. Thanks for this. 
Aha! I wondered how Alex knew about my comment here. Version numbers will certainly be useful metadata, so it's good to hear they're available. I must have misunderstood Alex's comment about those. We were waiting on that integration before we did any more Jigsaw proof of concept work anyway, but looking forward to checking our Proxy.
That github link was great. Although, I would mention that (I think) Java just copied Joda time directly and turned it straight into LocalDate. LocalDate is (from what I've seen) a near exact duplicate and is just as easy to use. 
That helicopter site...you can probably due it with wordpress or something similar. You can hone your frontend skills, but something like that is not going to hone your java skills. Just because you have a hammer doesn't mean everything is a nail. 
http://www.mkyong.com/ is a favorite Java blog of mine. It covers webservices, Javaserver Faces, Spring, Hibernate, and many difficult to solve problems. Has saved the day many times for me.
Learn SQL. Mysql is free, mssql express is free. Get one or both and practice. Knowing sql is key to so many developer positions it's ridiculous, and as a DBA I love developers who actually know how to write good sql code rather than say they do and write rubbish queries that take ages and make my job much harder and the apps they write much worse. I recommend mssql as it's more marketable, but really sql syntaxes are so close that you can work stuff out if you've worked with any engine. It's all about learning the set-based nature of database queries. Learn how to do proper joins between tables. Learn how to do stuff *without* using loops. 
https://dzone.com/articles/java-origins-angular-js
It's a GUI and graphics library that comes with the JDK. It's not a game engine, it may have classes that help represent things in a game though. If you want to make a game without dependencies, JavaFX is a good choice, if you don't mind dependencies, then chances are you'll want to use some of the more game like libraries and engines out there.
In addition to the answer below, JavaFX is a good starting point for learning game development in general, however if you are serious about game development, it would be better to use libGDX or JMonkey, as they support mobile. JavaFX mobile support is currently not that great, but improving. I have built a game library on JavaFX for hobby projects (if that is of any interest to you) - http://almasb.github.io/FXGL/ which I also use for teaching basic game development modules.
congratulations you are passionate
For your future mental health, it is important to have a balance between free time and work time. However, of course it is natural to investigate stuff because you care about solving it. The most effective way to not get this problem is not caring about work but it is nice to have a job you care about. The right level of engagement is different for everyone so I can't say what is perfect for you. In the long run, it is important to be able to [let it go](https://youtu.be/L0MK7qz13bU?t=60) when you leave work.
I've had solutions come to me in my dreams. I rush to work, 5 minutes later I finish whatever I was stuck on. It does help sometimes to step away from a problem for a day or two. In our field you always need to study though. I'll be spending this fine Saturday taking a course to suck less at Javascript. 
Yeah, I've heard about libGDX a lot, but never seen anything with javaFX related, so this is new to me, I'll definitely search more about it. Thanks for the link, but I probably not am ready to use it, haha.
Not necessarily. There are people haunted by paying their taxes-- the monetary obligation behind roads, police departements, fire/rescue services, schools, and fiscal safety net services. I would not call these people 'passionate' about taxes. Edit: The downvote was not mine.
Same here. This seems to be typical for most developers that I know. Currently I'm also trying to fix a problem for my project at work and I don't even get paid for these extra hours.
I do this by writing an email to explain the problem and if that does not solve it right off I email to future me and take a walk
Nice. I'm glad you have a roadmap and interests. It's always best to work on something you enjoy that way you stay motivated. Best of luck to you. 
My 2 cents about blog you should be reading. There isn't single best blog about everything-java. There are lots of folks focusing on many aspects of Java programming. To keep track of all that I would suggest either this reddit :-) or this website: https://www.topjavablogs.com/
I get like that too, but I've learned to work to a point where I've at least isolated the problem so it will be easy to come back to later and solve. For instance, if its at the end of the day and I'm writing an algorithm and it's just not doing what It should and bugging out, I'll just make sure I know which part of the code is buggy by putting in some logging and catch the exceptions, and come back to it the next day. Sometimes that can't be done, and I'll put in extra time, but getting it wrapped up and contained helps me turn my brain off, because I can say "oh the problem is in this function, so that's where I'll come back to tomorrow". Before getting into software dev I studied painting, and that is where I learned this form of self control. Usually if you keep working on a difficult area you'll start to destroy it by making it muddy, or smoothing over the artifacts of the brush strokes. I had to learn how to make myself stop and come back to it when my mind was fresh. It is the same with code, because sometimes by trying to fix a bug, if you're not cognizant of the side effects of a particular method you'll just introduce new bugs. 
A good way to separate work from pleasure is by keeping the hardware separate. Does work provide you a desktop or laptop? If desktop, then silo work related activity to that at work. If it's a laptop, make a point of using it only for work, perhaps even in a different location or position from your personal machine, when at home, and when you're not working, don't have the work laptop out. Just like many 9-5 desk jobs, the problem can wait until Monday. 
[trending on github](https://github.com/trending?l=java&amp;since=monthly) is a good place to start. Other than that, I'd Google around. Good luck!
Software is a long chain of solving issues which often creates new issues which needs to be solved and it continues. Best to solve what you can in a given day and come back fresh the next day or Monday. Get up once an hour at least and walk around. I solve some problems in moments away from my computer rather than at it. Get on a treadmill at lunch time for 10-20 minutes, it's light exercise but is a great energizer.
Why do I have negative votes? This makes me sad.
Some problems have to cook for a while before they can be solved, which means you cannot always force the solution by working longer. If you understand this fact it is easier to find the balance between work and free time. 
I went from working with Java to C# and the Javadocs are the things I miss the most. I just can't find msdn as useful.
I know medical doctors, lawyers, salespeople, ... who are the same. Don't worry. It's just being passionate about your job. Ideally, you have a job that allows you to work also on a Saturday when this hits you, in exchange for a free Monday, for instance. As long as it doesn't happen all the time.
I have had this problem before and I have found that the best way to handle it is to log the problem somewhere (NOT in your head), such as a tracking application or todo list or something, and assign a time when you can work on it. For me, if I see the task documented and scheduled it gives my brain permission to let go of the problem. But if its not written down you will continually remind yourself about it.
I don't know how many times I've woke up during the night to fix a problem I've dreamt of fixing, quite bizarre really. I'm still just a student, I dread my sleeping pattern when I eventually get a job! 
thanks for the tip
I have a small whiteboard in my room for this reason :/
Yeah, if I'm really stuck I either ask a colleague or student to think with me. While I am explaining the issue to them the solution usually comes to me, because there's always that small thing your forget. Or, if no-one's available I take the dog for a walk. That is always a nice context switch. 
I don't see what the problem is. I've been doing this for 15 years and I love when I hit a problem that takes me a while to figure out; when I solve it, it feels so satisfying.
I think so many people are web-focused these days, that the number of desktop apps has gone down dramatically. Therefore, the frontend is JavaScript and backend can be Java, but no JavaFX needed.
My favorite part about working from home. The puzzle solving never turns off. I love it.
If they finally removed some deprecated methods, they can actually split some interdependencies which only exist because of a deprecated method.
Just an FYI, "Implement" means to write the code that does the work of the algorithm. If you just do AES encryption by using existing code, you're not doing an implementation of it, you're using it :)
&gt; Java Developers will officially have a year to prepare their code before modularity arrives in the new version of Java SE Development Kit 9. If you plan to switch your target JDK to 9 on its release date you're an idiot. Or you're Google.
No, that means you are prepared for the future, you are modern, and want to anticipate future issues Stay in the past, nobody will miss you, it works fine, why change?
Why AES-GCM, which seems to be made for quite special use cases? Also, you seem to find it strange to use symmetric encryption in practice, which in turn seems quite strange to me. How come?
"Generated 27" implies 100000000 calls in 27000000 nanoseconds. That's 0.27 nanoseconds a call. Seems suspect. You sure the call isn't being optimized away somewhere?
No, it does means you're an idiot but that's good for me. Morons like you can do all the legwork debugging and I'll take the stable version in 6 months.
Google isn't even using Java 8 yet... Meanwhile, I'll be switching one of my personal projects to 9 before release day (early versions are already available).
[removed]
Wow, you created that account just to reply, i'm honored :D
OSGi has no .NET equivalent. MAF might be close (*not* MEF), I'm not entirely sure. Java used Classloaders to load classes. A class loaded in 1 classloader is isolated from a class loaded in another classloader. OSGi leverages this to keep bundles completely isolated from each other. To allow bundles to work with each other, they must explicitly import/export packages in their MANIFEST.MF file. So, you could have an API bundle with only interfaces, which exports the packages with interfaces. You can then have an implementation bundle that imports those packages and implements some/all of the interfaces. In another bundle, you can import the interfaces and leverage the implementations by use of DI (with declarative services, blueprint, etc), or if the implementations registered themselves as services you could do a lookup and leverage them that way. All that said, an extremely low number of Java developers have actually been exposed to OSGi. Many large systems (like Java EE application servers) are built on OSGi, but in the case of Java EE it's an implementation detail that Java EE developers don't need to know. I hope that helps, it's a bit of a basic explanation. You can check out /r/OSGi, and there are also some Manning books on it (including using Aries for OSGi in Java EE)
I think I speak for all of us if I say: "wtf?!".
http://stackoverflow.com/questions/4699309/weird-after-java-method-signature
For compatibility with older versions of Java, methods that return arrays may have the `[]` after the method signature instead of after the return type. It works, but it's discouraged in new code.
One of my favorite personal projects was taking a mini game from another game and implement it in Java (Fortunes Tower from Fable, in this case). Sure, I'd get a nice little lawsuit if I released it, but it was never meant for that, and I learned a lot from it. Just a suggestion. Does it have to be barebones Java, or are you allowed to use libraries and frameworks? Being able to use that sort of thing will allow a lot of creativity, and a relatively simple concept can be fairly complex and take until July.
When I first got into making games, I read Developing Games in Java (David Brackeen) to point me in the right direction. He introduces the reader to threading, graphics programming with AWT, input, sound, etc. A few chapters in, and you're developing a simple 2D side scroller with simple gameplay elements. I'd say that's a good place to start.
I can use libraries and frameworks but I have to ask permission. Their idea is that they shouldn't simplify your life so much. Using too powerful libraries would allow you to focus almost exclusively on the game design part rathern than the programming part.
If it's personal, meaning you don't plan to distribute it, then that's fine. I was speaking from a business standpoint. Outside of work I don't use Java.
Maybe do an procedural endless runner? 
What criteria are they going to use to determine simplicity? Can you give an example?
I'm not familiar, what is a runner game? 
What is the criteria did they give for the game as if they just said make a game, checkers or snake should suffice.
Basically you control a character and the game goes on forever. The world "randomly" generates. Another option is http://www.avalanchegame.org/
Sounds like we need more info on the criteria they gave you. If it helps any, we made a Chess game in my 1st year in college. In my 2nd year, we made a Monopoly variation. With something like that, you have a little bit of graphics (mostly static), and a good chunk of logic to build. Good luck!
You can pretty much use anything. To learn Java, I would recommend a mud or a dungeon crawl or something. If they want art, you can do whatever. Libgdx is a good framework, and jmonkey is a java game engine.
Just download one of the free asset packs and go with it. You can just program. /u/kennl has some platformer assets at his [site](http://kenney.nl/assets/jumper-pack), though you can also throw him some cash too. You don't really need to do art if you are just learning. 
Again, as stated elsewhere and multiple times just about everywhere, please use a high level crypto library rather than using a crypto primitive like AES directly. [If You’re Typing the Letters A-E-S Into Your Code You’re Doing It Wrong](https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2009/july/if-youre-typing-the-letters-a-e-s-into-your-code-youre-doing-it-wrong/). Having said that... AES-GCM isn't for special use cases. It's authenticated encryption. If you don't use authenticated encryption, you're vulnerable to malleability attacks. This includes AES-CBC and AES-ECB -- unless you stick a MAC on top of those modes, an attacker can alter the message even without access to the plaintext. Here's Matthew Blaze talking about AES in [How to choose an Authenticated Encryption mode](http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html): &gt; Nearly all of the symmetric encryption modes you learned about in school, textbooks, and Wikipedia are (potentially) insecure. &gt; &gt; AE(AD) modes were developed as a way to make the problem of authentication 'easy' for implementers. Moreover, some of these modes are lightning fast, or at least allow you to take advantage of parallelization to speed things up. &gt; &gt; In general, the decision of which cipher mode to use is not something most people make every day, but when you do make that decision, you need to make the right one. Having read back through the post, I'm pretty sure that the 'right' answer for most people is to use GCM mode and rely on a trusted free implementation, like the one you can get from OpenSSL. Most times, you'll want to use a hybrid cryptosystem like Keyczar signed sessions or libsodium CryptoBox, where you do the handshake with public / private keys and then have a session key that covers the body of the message. It's better overall because you can hand the public key around freely and keep the private key under an HSM or secret service. Here's a blog post I wrote about Keyczar that goes into signed sessions in more detail: [Effective Cryptography in the JVM](https://tersesystems.com/2015/10/05/effective-cryptography-in-the-jvm/). One of the Keyczar authors goes into the details in the blog post: &gt; They implement encryption and decryption of data with a session key (well, a temporary key, Keyczar doesn’t define what constitutes a session) as well as signing and verification of the data. It’s certainly the usage mode that I recommend to most users, for two reasons. First, it works around a sort of a limitation in Keyczar’s public key encryption format, which is that you can only encrypt data blocks that are smaller than the keysize, less padding overhead. This is only “sort of” a limitation because, obviously, bulk data encryption isn’t what you want to use public keys for anyway. The SignedSession modes encrypt a randomly-generated AES key with the public key and then do the actual data encryption with the AES key, as you would expect. Second, it provides security and authentication in one convenient and fairly easy to use package. 
when you get an API using vectors ...
It's gonna be a lot of work, but if you could look up 3D Java game on YouTube there's a tutorial on making a very advanced rpg game with OpenGL
Then there's [this damn constructor](http://docs.oracle.com/javase/8/docs/api/javax/naming/InitialContext.html#InitialContext-java.util.Hashtable-). Not even an abstract class or interface, but a god damn Hashtable. Note that this class was added in Java 1.3. Map was added in 1.2.
Not what I expected when clicking "source"
Wow, great answer, thank you! The details about AES-GCM were very interesting, wonder whether I should improve the Wikipedia article about it. As for symmetric/asymmetric encryption I'd like to add another point for combining both: symmetric encryption is way faster. See also [this StackOverflow answer](http://stackoverflow.com/a/5479325/3281722) for a very nice summary of the differences between symmetric and asymmetric cryptography.
At least, it's consistent with the return type of [this method](http://docs.oracle.com/javase/8/docs/api/javax/naming/InitialContext.html#list-java.lang.String-)
I suggest making a tower defence game. You can make the units as complex as you like and the graphics as advanced as you like.
looks like awesome good explanation.
You know, I think I prefer the approach they take with changes in direction like this. Let the industry sort out the best approach for them, then sweep in with a platform change later when everybody knows how they would like it done. It's a sharp contrast to the broad strokes of J2EE which created so much platform complexity. It really wouldn't be possible without the open source centered community culture though.
WTF does Google have to do with this? You jelly or something?
Servlets are at the foundation of much Java's serverside offerings. As already pointed out, JSPs are compiled into servlets, but pretty much everything HTTP related is based on servlets. Do people still write servlets directly? Probably, but there's many frameworks that offer nicer abstractions. In any case it's really helpful understanding them. 
I was a bit confused by the term "frontend" for a moment. After looking at the source code, I think they mean "user interface"
I'm constantly surprised at how little of a shit the Windows devs give to cleaning up old Windows code. I'm constantly surprised at how little of a shit the Linux devs give to cleaning up old Linux code. JDK is a platform. 
Relatively few apps still use Servlets directly, but they're still the underlying technology behind the vast majority of Java and JVM web frameworks.
Basically every EE application that I've written has ended up with at least one within the application itself, eventually for some relatively esoteric purpose. Most of the time they are used through abstractions and frameworks built on top of them, though.
are you autistic?
servlets (server-side) are used now also.. but applets(client-side) which are basically java-browswe-plugin, oracle has stopped it's support.
[removed]
Sevlets are mostly used as an underlying technology in Java EE and other frameworks, for example JAX-RS API for REST services in Java EE framework or as a dispatcher servlet in Spring framework. I don't know if production-ready apps are being developed using only servlets but it is useful to learn them a bit if you wan't to understand HTTP request-response model, http headers and other web basics implemented in java. You can make simple (or advanced) traditional MVC apps with servlets where servlets are used as controllers and jsps (views, that also get transformed to servlets) are used as views. 
I recently wrote a Servlet for a customer which receives Java programs from an Oracle database via AQ, compiles them, and runs them on request. Simple, stupid, extremely effective for continuous delivery of such (small, dependency-free) programs in an environment where WLS redeploys happen only twice a year. Servlets were perfect for this kind of task, because they're very simple and low level. I can imagine many other simple and low level use-cases where you'd also use servlets directly, even in the presence of higher abstraction frameworks, such as JAX-RS or JSF, etc.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javahell] [Very odd java compiler behaviour around package local scoped class](https://np.reddit.com/r/javahell/comments/4bbf7w/very_odd_java_compiler_behaviour_around_package/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
They cleaned a LOT since the first (Java 6) open source version...
If the requirements don't exclude it, I'd suggest making a two-player competitive game that requires sharing a keyboard. Even the simplest games are great fun when you're shoulder-to-shoulder with your opponent.
Mostly in legacy code. For most part, a wrapper like Struts or Spring are used. Other alternatives like Play are also used.
isn't that what most people call the UI? as opposed to a backend (services/server) ?
Just so people don't get ahead of themselves, this JEP has successfully reached Candidate status, meaning it has been accepted as an idea only. The spec for such a change is still in progress, ~~implementation hasn't started~~, it's (obviously) not on the JDK9 feature set and it is not known whether it will be included in the JDK10 roadmap. It could very well not materialize, evaporating in a "we investigated this and it cannot be accomplished without sacrificing &lt;thing which we consider more important about the language&gt;" message on one of the mailing lists. Or it could prove technically difficult for some reason not anticipated and undergo several spec and scope changes and get delayed until JDK15 or something (see Jigsaw). EDIT: Thanks guys, I was going by the JEP and JDK bug system, haven't been following OpenJDK close for a while.
Not entirely true "implementation hasn't started"... there is already a working example to download here: http://iteratrlearning.com/jep286.html If you prefer to build OpenJDK yourself, the branch can be found here: http://hg.openjdk.java.net/jdk9/sandbox/shortlog/2535ea29c59c
I personally in general cases would not be using `var` at all. I myself do not use an IDE when programming Java either. However, I do wonder though if one has a class called `var` and then this is used. If one followed the standard Java naming scheme, this should not be a worry at all. 
The point is almost nobody says no to Google. If the newest Android OS required Java 9 very few manufacturers would snub therm.
You are correct, a class named 'var' would not compile when the JEP is released. But the one who writes that should have his/her programming license be revoked, backwards compatibility is probably not the biggest problem in that codebase.
The same people that keep telling me: "Just use Scala/Kotlin/&lt;random other language&gt;" Are also complaining every day that the code other people have written is hard to comprehend, hard to read, unmaintainable. Especially the colleagues I have in larger Scala projects are having a hard time reading and updating existing code. (just an observation) 
I would have to look at the implementation but I'm not sure that a class named 'var' would actually have to cause problems. If have var x = foo(); Then either the return type of foo() is assignable to type 'var' and thus the inference would work correctly or it isn't and the code wouldn't have compiled in the first place.
Well, I think that at the end of it you won't be able to say you know java, but you can make a game even if you don't know much more than the basic of a language (it might be bad code but still). When I said checker is too simple I was thinking without AI. With AI it'd be ok, but thay would probably turn down an AI checkers for other reasons, like it's boring, or they have already seen it the past years.
Why don't you use an IDE? Do you carve your code out on stone tablets?
It's a relic from the early days of Java, when some conventions hadn't yet become strong. The oldest parts of the Java API has plenty of such things. Like 0-based months in the original Date API. Or the Point class with mutable x and y values. Or the *Format (DateFormat, etc) classes that are not thread-safe even though they feel like the type of class whose instances you'd turn into constants and re-use amongst threads. 
I have a group project in kotlin and it's going swimmingly. I can't say I've had a negative experience with it
That's great! How large is the group and the project?
Personally I think var/val is **more** readable, because when reading code I care about what it's doing, not the types themselves. This can be solved with good variable naming.
I agree that Scala is a big mess, but Kotlin set out to just fix the annoying parts about Java. I'm using it in production now with Spring Boot and I'm definitely enjoying it.
How about these: // No var needed string1 = "abc"; // No val needed final string2 = "xyz"; No new keywords needed... *EDIT*: If you must, [`transient`](https://en.wikipedia.org/wiki/Transience) might be a nice keyword to recycle for this: // No var needed transient string1 = "abc"; From Wikipedia: &gt; **Transience** means passing with time or is the state of being brief and short-lived. If that's not a variable, then I don't know.
currently just myself and one more, but we might get some more on board soon
Not using a keyword instead of var probably would have parsing problems.
you're all about bucking conventional wisdom aren't you? &gt; I myself do not use an IDE when programming Java either. &gt; However, I do wonder though if one has a class called var and then this is used. 
Great post /s Now read this before your next one. https://www.reddit.com/wiki/selfpromotion domain submitted from|count|% :-|-:|-: [studytrails.com](/search?q=%28and+site%3A%27studytrails.com%27+author%3A%27stmith%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|7|100% subreddit submitted to|count|% :-|-:|-: [java](/r/java/search?q=author%3A%27stmith%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|4|57% [Rlanguage](/r/Rlanguage/search?q=author%3A%27stmith%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|3|43%
Which is nice, but I don't really like the fact that you pretty much have to use the intelij ide if you want to kotlin. Java at least had 3 pretty good ides going for it.
I'm all for this, I just hope they add both var and val. I try to use immutable stuff as much as possible so var is not nearly as exciting as val :)
You mean, as with lambda expressions?
I haven't tried the eclipse plugin for kotlin, but I have tried working with kotlin in netbeans. The maven/gradle plugin will get things compiling but if you try and have a mixed project in the netbeans environment you get a lot of errors and no help from the IDE.
I have worked in a business where the only approved way of writing applications was to write a servlet. YMMV. I am not bveing critical of you regarding servlets particularly... it is your dismissive respond that I have dealt with before... with 20 years of software development I have seen it plenty of times. 
&gt; I agree that Scala is a big mess Only because you don't know it to a sufficiently good level.
That's, just, like your opinion, man. 
i'm reading this... lets make the language more flexible and hope that devs do the right thing. I cringe.
Team NO ftw... knowing that one rarely gets the luxury to work on fresh projects in silo. Java's success is to it's verbosity and forcing horse blinders on sub par engineers because frankly there aren't enough "rock stars" out there to code the worlds solutions in scala/closure/haskell/&lt;next whatever complex thing&gt;
experience
One thing often overlooked when comparing with var in C# is that C# also added anonymous classes at the same time. Unlike Java anonymous classes, the C# version can't specify a base class/interface - it's a totally local unnamed class type. These are then used to build Linq expressions which was the real killer feature for c# 3. 
I'll you warn you - you'll get a LOT of "marketing" responses worded like "what modern java developers use" and claiming it's what everyone uses - that are just year or two fads until the next fad comes out. Blogs will be the same way. We're on a steep curve of diminishing returns where there aren't a lot of areas to improve things in, so new projects usually put out a lot of fanfare and unsubstantiated claims, while in reality they're just reinventing the wheel, doing the same things different ways at the same or worse speed. I would suggest: - 1 book to get up to date on the java language - not a ton has changed but a few things have - Avoid blogs and podcasts as they are usually just marketing and the signal to noise ratio is terrible - Find out what they're actually using on the project you're moving onto already (try to avoid any "we're moving to use this" as a lot of these don't pan out). My goal would be to try to find out what they're actually using on the project right now. Let me put it this way - several years ago the internet all "agreed" that Ruby On Rails was replacing java and no one was going to use Java any more. What actually happened is that most of those projects that used Ruby On Rails, that were successful (like twitter), later converted back to Java. That's one of the drawbacks of Java land - the infighting and competition over projects pushing to be used. In my experience, it's the best use of your time to find out exactly what they're currently using on their project right now and work with that, if at all possible. Here's an example. Someone posted this article: https://github.com/cxxr/better-java The section on "structs" (a word not actually used in java) claims: &gt; This is verbose and wasteful. Even if your IDE automatically generated this code, it's a waste. So, don't do this. This is 100% wrong. Everyone still uses getters and setters, and many frameworks rely on them being available. That their approach makes the data immutable makes it almost entirey unsuited for web development. I've been doing software development in java for over 10 years, most of that article is filled with hipster ideas no one actually uses. I never see "builder" patterns being used. Immutable objects are never used because they're very bad for web apps where data is constantly being changed between the browser, controller, service layer, and finally database. Trying to work around null to much causes more problems than it solves and I've never seen a real project worry to much about it. Etc. 
How about pointing to a large Scala project and saying this is unreadable instead of everyone taking your word for it.
&gt; I think the main complaint here is going to come from people that don't use IDEs. In my example above you wouldn't know where to go to look at the source code for method foo() Honestly, I don't even want to hear any complaining from the community what with the general acceptance of Javascript out there. If people can put up with a language that just let's them monkey patch out virtually anything they like with their own crap, then this is such a small deal that it's not worth talking about. Granted, this is /r/java and not /r/javascript, but the lack of outrage around Javascript still chaps my hide.
Since OP linked the *news* page without a description, here's the deets: &gt; Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. 
That's not exactly the same. You're not creating a new variable using assignment. Instead you are declaring the lambda expression with '-&gt;' operator. 
&gt; Surely I'm not the only one who has issues switching off and leaving work at work? I used to have this problem all the time. A little bit worse, probably, since I work from my home office and thus can work "any time" I want... which resulted in some twelve hour days when I was agitated and wanted to fix a bug or get a feature polished off. Ultimately one of my issues was that I felt I always had all the tools to solve the problem in my hands, so that meant the weak link was _me_. So if I worked a little harder, I'd solve the problem eventually, right? Well, right. That's pretty much how it happens. Not really healthy, though. I dealt with it by timeboxing things when I felt it was getting out of hand. As in, "if I don't make any progress in the next 15-30 minutes, I'll move on and revisit this later." Worked out pretty well.
What is the big 2.0 feature?
We change the rules and limits a bit and keep changing it together with the comunity to make it an interesting competition for all.
You mostly use servlets underneath instead of extending HttpServlet directly. JAX-WS uses servlets, JAX-RS uses servlets, JSPs are servlets, most stuff is just servlets. I used servlets as sort-of REST endpoints, but are moving to JAX-RS.
Having worked with 1.8 and 2.0 I don't think there's one big "holy shit" feature like being less of a PITA to work with, I'm afraid. Although to be fair the complexity of PDF and its specification and standards are responsible for that. I found it to be more reliable and more performant. Unicode is nice and the PDF/A preflight module is a lot more thorough than the old one and produces less false positives.
 list.stream().forEach(val i -&gt; System.out.println(i)); vs for (val i : list) System.out.println(i); Of course it's not *exactly* the same. But you cannot deny that we're not in entirely different universes.
Awesome good news but rapidoid was alread in the top 3 in the last benchmark, I'm glad that they improved that. Also, I feel ashamed when seeing all the Play! variations are slower than a few frameworks written in a scripting language ... 
Is there a way to get comparison to scientific-powered contenders e.g. Warp [haskell language] available at http://www.aosabook.org/en/posa/warp.html NB: this applies to 'Your language here' and 'Your framework here' preferences, indeed - but I could not resist noticing no Haskell stack is referenced. Java,python,Scala,Ruby,Go.. Erlang but no Haskell
are these benchmarks at all relevant to real world work?
I'm sure you must be joking, but why would anyone standardize such a specific integration? JSF and MVC represent two very common MVC patterns, component-oriented and action-oriented, patterns which the community thought would be beneficial to provide standard APIs for. If anything, a better question would be, why would you create a specialized API when you could leverage an applicable existing API, like JSF? Surely, there must be an AngularFaces out there somewhere. Answering my own question, because the standards can't cover everything. 
I understand, but "Early Java" is about 15 years ago...
&gt; Is there a sub for Ur? You know as much as I do :). I was curious what Ur was, so did a little googling
I find the speed of my webserver is rarely an issue. 99.9% of us will never need to send 7mil plaintext responses or 2mil json responses in a second. As long as the server can handle a few hundred a second the bulk of applications are probably fine. I consider development velocity over some benchmarks for how many million requests it can handle.
No, they don't take throughput into account. You could build an ASIC chip to run requests in silicon and it would work great on this. https://github.com/playframework/playframework/issues/2090#issuecomment-29267912
What? You mean you don't need to send 7 million plaintext responses with no business logic every second? /s
Sorry, never used it.
Look at [Prune](https://playframework.github.io/prune/) if you want a better idea of the Play metrics.
Hotspot is great but people were trying to show me benchmarks years ago about how newer java libraries were as fast as c++. Did some digging and found out it was because they were written in c++ (jni) and linked to in java. AWT, Java 2D, java.net, javax.crypto etc.
It honestly surprised me when I read that java is newer than python
every single one of those shows java being slower except the first one ....
What year is it? 2006? Java hasn't been slow for a long ass time. You don't even need these benchmarks to tell you this. If you look at the top 10 most visited websites, 8/10 of them use Java. 2/10 use PHP/HHVM. 
That you can get numbers even close is just proof that benchmarks unfortunately can be constructed to prove almost anything, looking at how slow every Java-implementation I ever saw or worked with was in reality. I spent most of the last 16 years programming in Java, and for a while I started to believe in the benchmarks and thought Java was quite fast. Then I got back to work with C and C++ more a couple of years ago and was like "wow, modern computers are FAST". It was easy to not notice that when working in Java and having all the CPU cores busy doing overhead and filling up all of the RAM for me.
I do agree that the use of such approach is limited to specific projects. For other projects I use pre-existing build systems since they are made well for the task.
IText uses pdfbox i believe. Personal experience with IText is it is better to use pdfbox and do it yourself... 
Tetris is a fairly easy to implement game
The JVM has a high startup overhead and a prolonged warmup time, both of which you encounter constantly in a normal development cycle. Production is usually a different matter. Also remember that computers started getting SSDs a couple of years ago, and jumped in performance as a consequence.
That's actually a great point. JSON serialization is almost always in the domain of application servers. I'd argue, though, that query resolution can be a central part of many web servers out there (anything that serves dynamic content embedded in HTML pages, for example in templates).
&gt; Hotspot is great but people were trying to show me benchmarks years ago about how newer java libraries were as fast as c++. Did some digging and found out it was because they were written in c++ (jni) and linked to in java. AWT, Java 2D, java.net, javax.crypto etc Most of the services you mention are provided by the OS, so they necessarily have to be accessed via JNI. Pretty much every language has to use c/c++ to make the rubber hit the road... perhaps with the exception of Android apps. 
Android also uses JNI. Latest development in Android is to replace the VM with a compiler so your portable bytecode gets compiled to your specific device.
Am I missing something? I used to be able to compare a language to any other in the database. Now they seem to allow only certain comparisons in the links on the page. For example, how would I compare Java to Erlang / HIPE?
&gt; It honestly surprised me when I read that java is newer than python That's because Java immediately became famous, surfing on the early Internet wave, while Python rose to fame much more gradually.
offtopic: reminds me about ["practice of breaking eggs"](https://en.wikipedia.org/wiki/Lilliput_and_Blefuscu#Satirical_interpretations).
Some unix utilities will not work as expected if the last line is missing a newline.
How's the Kotlin Spring Boot support? Have you ran into any issues so far? I'd love to use it in production but unsure on the length of support it has.
&gt; verbosity and ugliness of some code Even then, I think Java 7 and Java 8 have made great strides to fixing some of these issues.
Which is bullshit because they don't compare it to nginx serving static pages. They compare it to nginx CGI plugins serving static app content. The test is an application server sending static plaintext content which is useless. This is a carefully crafted piece of marking designed to side step questions of scope rather than a realistic benchmark.
I would say yes. When you need to sell Java to others in the team or in the company, this is some ammo on your side.
i think it's only "safe" in certain regards, but unsafe in plenty of others. SocketChannel chan = SocketChannel.open(); Object obj = sc; String str = (String) obj; System.out.println(str.matches("nominal subtyping ftw"));
&gt; why do you need this to be a language feature when you have an IDE that (...) i tend to be *very* unsympathetic toward arguments that justify themselves by IDE functionality (real or hypothetical). it seems really narrow minded. 
i can only see this playing out as "oh, well *i* can read that just fine, why can't *you* read it?".... it's pretty subjective anyways, i think.
Heavy and slow pretty much mean the same thing. Java's performance problems (and C#'s for that matter), come from poorly written code that uses too many abstractions and too many memory allocations. *** Hotspot's claim to fame is that it undid some of the negative effects of Java's disastrous decision to make every method virtual by default. But you'll still get better performance by marking everything as final by default and not routing everything through abstract interfaces.
&gt; you'll just do it i think for people outside of the open source developer community, this isn't so cut and dry. it can sometimes seem a bit opaque on how to get involved. (speaking from a logistics/operational/social angle.)
No big issues. Have to put "open" in front of some methods so they can be proxied since final is default in Kotlin (mainly configuration classes), but other than that it's the same as with Java. It's even neater with Spring 4.3 coming this spring where you don't need @Autowired on your constructors, since this is the preferred way to do it in Kotlin. If you do property injection you need to tag it with lateinit or use a nullable type.
There are plenty of benchmarks on the web, this is common knowledge. 
totally useless with most of the IDE that can compute the type for you. So no real advantage, so no need for that
I'm pretty sure that this was considered by the Java 7 EGs, when they decided to move the diamond to the RHS of the assignment, probably because of Java's love for "target typing". Would be interesting to have some EG insight...
&gt; by marking everything as final [Not necessarily](http://insightfullogic.com/2014/May/12/fast-and-megamorphic-what-influences-method-invoca/)
The keyword here was 'and'. Marking it as final does nothing if you then only call it through an abstract interface.
The jOOQ example looks way way better.
I suspect the first one is badly coded too. It's all running on a single core compared to java running on every core.
Yes you can look at the source code for both. the java one is written to be multithreaded with workers. The c++ one is just a single threaded algorithm. The java one is 319 lines. The C++ one is only 151. They aren't playing fair.
well the file stuff before NIO was in java and that's why it was so slow and got replaced.
[obligatory xkcd](https://xkcd.com/927/)
It's incredible just how useful the plain old Servlet is, for many use cases.
I still don't think you even understand what I'm talking about since you wrote: &gt; Describing nginx as static file server didn't make it faster They didn't test nginx, they tested a couple of nginx WSGI/CGI plugins. Likewise I don't see how you don't understand that there's a difference between an application server and a file server and the assumptions that can be made between the two use cases are entirely different and how that can lead to different performance. My whole issue is testing static plaintext returns through an application layer server is equivalent to a static file server, the latter of which tend to be faster because they don't need to have certain capabilities compared to application servers.
On an alternative note, I've been developing "web scale" production bespoke web apps for 20 years and have never implemented an EJB.
&gt; he co-wrote EJB 3 in Action Ok.
&gt;But then it's not testing the language but the coders competency to write good code? &gt;c++ does concurrency very well; when the work is put in to make it concurrent. &gt;Take a look at Rust for example. Doing exactly the same thing it's generally slower than c++ because it has stuff for safety. That safety stuff is done at compile time, not run time. Actually there are faster `fasta`, `fasta_redux` and `k-nucleotide` implementations on the tracker, so it's not like the current entries represent the utmost performance you can get. In general, if you see faster code generated from clang than from comparable Rust, that's probably a compiler bug. &gt; Rust is very easy to write concurrent code in, c++ is hard to write concurrent code in, but well written, c++ will outperform rust. Rust has some guarantees that are quite hard to come by in even modern C++, and allow for less allocations, more re-use and overall faster code. So I think it's the other way 'round that makes sense. Of course there are things like SIMD which Rust currently cannot use in the benchmarks game (because only available on nightly), but those will be sorted out in time.
Came here to say this.
How much are you going to pay for this? 
Oracle will disagree. The guardians will fork Java EE. I'm taking bets.
App CPU usage is rarely a bottleneck and it's usually fairly easy to scale out. Problems seem to mostly be at the DB level for web dev.
Yes, I'm too curious about the motivations by the Java 7 EG at the time. It is hard to find online but I do believe there had been some discussion about LHS/RHS at the time. One reason I can imagine is in the case where you have: someMethod(new ArrayList&lt;&gt;()); or return new HashMap&lt;&gt;(); In this case having RHS is easier and shorter. The thing is... I think both sides can be useful, as long as the actual generics can be inferred, and seeing they are now suggesting var/val I'm pretty sure it can be inferred.
What is this? 1999? The most expensive time for most software companies isn't its servers, it's its developers.
Good for you, but what's the relevance? Or are you one of those people who thinks Java EE is mostly about EJB?
What?
https://www.reddit.com/r/Javahelp
Some hints: FFFFFFFF is too long for an integer look up what you can do with regexes 
&gt; We are looking for a Backend Scala developer to join our team based in NYC. Then post a vacancy in the **relevant** places. We don't want this sub to be inundated with recruitment spam. 
I thought JEE was Java's bread and butter. Why would Oracle abandon it? And if they're planning to abandon Java entirely, why are they putting so much effort into JSE 9? What the hell is their strategy here? Are they perhaps focused on getting Java running natively on mobile devices again? 'Cause that's not happening. Sun ran JME into the ground before Oracle even had a chance to save it; it's deader than disco now. And after the Google lawsuit, nobody else is going to touch mobile Java with a ten-foot pole. Whichever way you look at it, it seems like Oracle is mismanaging Java even worse than Sun was. Are they just incompetent?
Well, it certainly *can* be done. But the many javac and Eclipse compiler issues created by [JEP 101](http://openjdk.java.net/jeps/101) in Java 8 might hint at how complex type inference in Java really is... I suspect that omitting some possible features reduces compiler complexity (and perhaps helps keep open doors for future features, that might not be possible otherwise)
You were there in 2002, right? https://en.wikipedia.org/wiki/Rod_Johnson_(programmer)
Your right, a language can't stop you from writing unreadable code. But by not having type inference you reduce the risk of developers writing unreadable code. That said I personally like it, however depending on the project and experience of the developers it can be a good or bad thing. As I consider Java to a language that beginners/less experienced people can adopt I believe it shouldn't support type inference.
Sure, using the flipped diamond is less descriptive. But... apparently I'm a minority when it comes to wanting to see the complete picture. A lot of people are really looking forward to var/val. My suggestion is: If we're going this route and allow programmers to not always list the entire type (which people really want), there might be something between listing everything and just 'var'. For example if you have a method returning a Set, but the generic type is pretty obvious in the code, I'd like to be able to say: Set&lt;&gt; numbers = DB.readSolution(); This is IMHO better than having 'var numbers' although still less descriptive than 'Set&lt;Integer&gt; numbers', still having the generics in place.
To be correct in the comparison: In the plaintext test Rapidoid is **3.38** times faster than Lwan. In the JSON test Lwan is **1.27** times faster than Rapidoid. Measuring JSON serialization performance is exactly that - measuring performance of the Jackson library used by Rapidoid and (probably) some JSON library used by lwan.
Sure, having both high-level and low-level versions would be great! Coming soon... :)
they might use the same/similar approach, looks clean &amp; neat.
Sure! I really like the idea, in fact.
oh you are right i was thinking of icepdf, ignore me lol
&gt;uh, android is moving to openjdk instead of using their own terrible version of java anymore. i'd call that embracing mobile java I wouldn't. It's great that they're going to use the class library from OpenJDK, but as far as I know, Android will still only execute Dalvik/ART bytecode, not JVM bytecode as in proper Java. I also haven't heard anything to suggest that Android will natively support JavaFX and/or Swing. Android will be more like Java going forward, which is good, but it still won't really *be* Java. The write-once-run-anywhere-ness of Java on the desktop/server still won't apply on Android.
Considering the change to openjdk is supposed to bring lambda support to android I'm assuming they're doing more than just lifting the openjdk library on top of dalvik. now I do assume they will use AOTC to compile and execute the bytecode, but lambda support is more than a library in java. that said, i agree you're not gonna have java desktop apps running on android or vice-versa anytime soon, but having the number 1 mobile java provider now directly contributing and using your implementation is better than what existed before i sincerely believe that oracle has done a lot of good for java since they took over. is their java support perfect? no, but it's way better than what we were getting in sun's sunset years
Definitely because Swing is no longer actively developed.