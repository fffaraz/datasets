Sure thing. I came across the Step Builder pattern and liked using it to help the next user/dev of my code/library to build a "complete" object. Basically, one of the concerns I have with the traditional Builder pattern is there is no way for the next dev to know what a complete object looks like. They can easily leave null properties. One work around is for the creator of the Builder for that object to require arguments via constructors, and this is perfectly valid. Now, if the case when there are "lots" of arguments to make the object complete a long constructor is usually frowned upon, discouraged. Here is where the Step Builder pattern can help, IMO. Step Builder: [https://medium.com/@castigliego/step-builder-pattern-3bcac4eaf9e8](https://medium.com/@castigliego/step-builder-pattern-3bcac4eaf9e8) So, borrowing the contrived example from that article, we need to create a Sandwich object. An example DSL could be (rough draft, so bare with me), where the resulting interfaces/classes would allow the dev to create a "complete" object like so: \# DSL (draft) `Panino` `- name` `- breadType` `- vegetables` `- meat` `- fish` `- meat` `- ${vegetables}` \# using the auto-generated classes `Panino solePanino = PaninoStepBuilder.newBuilder()` `.paninoCalled("sole panino")` `.breadType("baguette")` `.fish("sole")` `.addVegetable("tomato")` `.addVegetable("lettece")` `.noMoreVegetablesPlease()` `.build();` 
Fucking snowflakes. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I saw that, but I was wondering what your experience with getting the SDK was. 
Just need to create an account. Ask with the form to receive access with your account to download page then there is no problem. &amp;#x200B; The only difficult part can be to get accepted, you need to provide proper reason for access, like company projects, personal projects, what you will use it for, etc. If you do not get accepted, just fill in another time to correct what was wrong.
Most effective thing for you isn't a gift from other people, but a gift from yourself. Read through the official tutorials, research some java libraries, and write code that you think does something useful
Not sure what you're after exactly. If you want to be able to define a set of types via IDL and then generate Java classes from the IDL, then [Apache Avro](https://avro.apache.org) supports this. The primary goal is to allow you to serialise your data object into a serialised form (i.e. a sequence of bytes) and then reconstuct the Java data later.
Bet you're real fun at parties.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Im surprised my comment rubbed you the wrong way. Trust me, if there was a book that would make me a better programmer faster than going through docs, tutorials, and work, I'd buy it in a heartbeat. But it is what it is
Do you want a domain specific language or do you want to marshall/demarshall objects? If you want the former, Groovy (and possibly Kotlin) can make creating DSLs easier and are class compatible with Java. You are limited by the syntax though. If you want to marshall objects, then Jackson has you covered.
You could use [@Builder](https://projectlombok.org/features/Builder) from Lombok, though it will generate it based on the fields from the desired class.
/r/learnjava /r/javahelp
Interesting. I've done something similar (one time mind you) only using functional interfaces where the last interface creates the object. I say one time because I had a weird case where the API consumer was required to populate all of the fields of a massive 40 field object with non null values, and I wanted to force them to have to at least attempt to set everything. I don't know of any tools that would do that, but with Java Poet you could definitely make one. Also, there's an IntelliJ plugin that will generate the builder pattern that you could extend to suit you needs.
stackoverflow
Whoa, easy there, Satan.
Thanks. I use it passively when it pops up at google after I enered my search term. I am not yet too confident to use it actively.
[r/ProgrammingAndTech](https://www.reddit.com/r/ProgrammingAndTech) 
Thank you. I just found /r/javahelp and posted there :-)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thank you
r/Kotlin
I understand that JAVA and Kotlin are close but different languages nevertheless [https://kotlinlang.org/docs/reference/comparison-to-java.html](https://kotlinlang.org/docs/reference/comparison-to-java.html)
Hacker News
You'd be a much better Java developer by knowing Kotlin and following it's general design patterns.
Ok as I am still a JAVA noob I'll consider to check on Kotlin - hoping that it won't overload my brain ;-)
The language itself is quite simple, even more than Java. Have fun! üòÅ
Yes, kotlin is completely different language. And it is a language, that is designed to solve many issues and pains that java still has. While you could definitely argue, that java a good choice for a first language with all its restrictions and limitations, I think that kotlin helps to understand and apply the one core concept that is common to all programming languages and paradigms: using the language to express your thoughts and ideas in a way that is clear and easy to understand.
This site made it Nearly impossible to find a resource for an actual stack overflow 
Thank you!
Try to sign to your local Java User Group. For example in London it is http://londonjavacommunity.co.uk/. There is also virtual JUG https://virtualjug.com/. Both JUGs are very active, they organise regular meetups and have Slack groups where you can ask questions as well.
Thanks for the suggestion, seems to be popular my the amount of upvotes on this ill see what its about. Thanks so much!
Learn Java before learning Kotlin.
ü§£
Thank you. I am based in Bangkok right now. I checked on the official JUG map but it seems there is nothing like a meet-up group so far. I'll dig deeper into it.
Discord: https://discord.gg/UUNC6sm
\##java on freenode
Joined
Depends of what java part do you need. J2EE, J2SE,Android etc
Try vJUG then. It is very international group
CodeRanch.com is friendly to new Java developers. Responses are usually not as fast as Reddit however. You can reference StackOverflow but I wouldn't try to converse with them. It won't end well.
How about "Think in Java 5th"?
&gt;CodeRanch.com is friendly to new Java developers. I'm not a fan of how every thread is presented with a spam link at the end, in what's made to look like a relevant post. Still, some of their archives were really helpful when I was first learning Swing.
You could use [kotlin data classes](https://kotlinlang.org/docs/reference/data-classes.html) which to compile down to JVM equivalent of java pojos. You'll have to adjust your build script, but you'll get pojos with minimal syntax and will transition to kotlin in the very near future.
"This question is not a good fit for StackOverflow". &amp;#x200B; A variant of this question was asked 4.5 years ago, you are a moron for not finding it after spending a solid hour searching.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Maybe a better way to look at it is to prepare for future changes? 20 years is a lot of time, so Id pick swing, which is stable and simple, and make sure that the ui code is separated from the rest in a way that it would not be terrible to modify some years later.
It is absolutely impossible to predict how the landscape of JavaScript or Java will look like in 20 years. If I was in your shoes, instead of trying to predict the future, I would try to rely on technologies that are "tried and true", to the extent that if I have to support them past their life cycle, I will still be able to find resources and materials lying around. If you are working alone or with a small team, I would highly recommend to focus on having as few redundancies as possible. Do you need both a desktop interface and a web interface? An example from my current workplace is a backoffice web-application using the Apache Velocity templating engine. The technology seemed pretty dead with no updates to speak of for the last 8 years (http://velocity.apache.org/news.html), yet because of its maturity, it never prevented us from implementing new features or maintaining existing ones. Did it feel dated? Sure. Was it getting the job done regardless? Absolutely. About swing - what makes you think it is dead? The leading Java IDE - IntelliJ has gorgeous interface entirely with swing (https://github.com/JetBrains/intellij-community/blob/master/java/idea-ui/src/com/intellij/framework/library/LibraryBasedFrameworkSupportProvider.java#L15) 
Swing was brought up during Ask the Java Architects, [here](https://youtu.be/YR7ulGzerMQ?t=2833). As stated, there are no current plans to deprecate Swing. So no, it is not dead.
In my opinion, before touching the UI, I would update Java 6 to atleast Java 8 and get rid of JBoss somehow.
Angular/Typescript is closer to Java than Vue, as long as you understand the concept of a SPA. 
Absolutely not. I asked a couple of questions, they downvoted the question to hell, marked it as duplicate to some random ass unrelated question and now I cannot ask questions anymore. Tf.
What I would do is update JBoss 5.1 to a recent version of Wildfly and as well as update to Java 8 but keep the JSF front-end initially as long as it's just vanilla JSF and not something EOL like RichFaces. From there I would refactor/re-architect the back-end to use something like Boundary-Control-Entity pattern and push as much business logic into the back-end as possible. Once that is done then I would re-evaluate what you might want to use for the front-end. As it sounds like your front-end might be a typical business application I personally prefer to use JFS/PrimeFaces/OmniFaces as the technology has matured nicely and updates between releases is relatively painless. Nothing is guaranteed to be around in 20 years but I think taking a chance with JSF is a lower risk gamble than some of the other newer front-end solutions that may or may not make it IMO. To me this is the conservative, lower risk, approach.
JavaFX. Absolutely JavaFX. &amp;#x200B; Web technologies live and die wayyyyy faster than you can predict, so I would venture to say that you could scrap those from the start (Especially with WebAssembly on the way, that path is completely unpredictable). &amp;#x200B; Java, on the other hand, has something the web stacks don't: *an emphasis on backwards compatibility.* Yes, Swing may have slowed development, but that doesn't mean everything swing related has been broken. So, had you chosen swing a decade ago, you would be fine today. Say JavaFX's development slows the way that Swing did. In any case, it is open source, so in an *emergency* you could go in and patch whatever you need as you need it. Though, I don't see that happening, re: backwards compatibility.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
javaranch ? Haven't been there in ages though....
Kotlin is so 2017. 
I've just recently finished a quest to find the simplest most future proof way to write a web app front end. The answer: bootstrap, handlebars, and fetch. &amp;#x200B; If you're interested, I should have a blog article out in a few days.
r/scala
&gt;https://softwareengineering.stackexchange.com/questions/384129/java-ui-future-proof Be curious how this is the simplest. I think a lot of options could exist in any/all 3 of the spots. Not saying its not, just not thinking it is THE best/longest way to do so. All 3 of what you mention will most likely be gone/not maintained/rewritten/updated long before 20 years is up. Hell in 20 years we may have cognitive implants that dont require web elements any longer. 
Get rid of the JBoss specifically or the applicatioŒΩ server in general? 
Maybe they were not good questions ? ;p
Javafx seems to be removed from Java11Ôºåso i prefer webui
I don't know why you think that Swing is dead. The [Java client roadmap](https://www.oracle.com/technetwork/java/javase/javaclientroadmapupdate2018mar-4414431.pdf) says: &gt; Swing and AWT will continue to be supported on Java SE 8 through at least March 2025, and on Java SE 11 (18.9 LTS) through at least September 2026. &gt; Oracle has begun conversations with interested parties in the Java ecosystem on the stewardship of JavaFX, Swing and AWT beyond the above referenced timeframes. Considering the huge installed base of Swing applications and the "interested parties" mentioned above, I'd expect that even when September 2026 does roll round, it will carry on as an independent project, as happened with JavaFX this year. So, on the GUI front, I would keep the Swing bits in Swing rather than rewriting them in something else at the moment, then re-evaluate the situation a year or two before September 2016 (or however long you think you'd need to port the GUI). At that point it should be clearer whether Swing will continue to be a solid choice for the following 5-10 years. If you port the GUI now, you risk betting on the wrong horse and having to port it again in a few years.
It looks like it's red because it's in the default package. Put your class in a package and see if you still get the red. Doesn't seem to be a real error just a warning?
Yeah, it will run correctly. Thank you.
UI looks really good. Thanks for sharing! 
&gt; jlink also has the annoying restriction of ONLY working with fully modular applications, automatic modules aren't good enough. Shameless plug: The ModiTect tool (https://github.com/moditect/moditect) might be helpful for you. It lets you define and inject module descriptors for non-modularized JARs and build a modular runtime image via jlink from them. E.g. here's an example which runs Vert.x that way in a modular runtime image of 45 MB: https://github.com/moditect/moditect/tree/master/integrationtest/vert.x. Adding descriptors after the fact that way isn't ideal (and in some cases it might not work), but I think it's definitely worth trying. We're also planning to add support for the creation of images with a given list of JDK modules and providing non-modularized app modules on the classpath (as mentioned somewhere else in this thread). Disclaimer: I'm the creator of ModiTect.
backed: JDK11 + spring, or you may consider not to use any framework and create your own stack and use simple dependency injection like google guice. (jetty + jersey + guice, ... ) UI: JavaFX only if you need to interact with special hardware where client is running. Otherwise I'd use web UI as much as possible. Integration layer between backend and UI: REST, WebSockets, http2, gRPC. Once you have clean APIs for clients, it actually does not matter what client technology you use. You may use Web UI and/or JavaFX and/or some native Qt/C# based clients, even have several alternative clients for same thing. Typically you update clients faster than backend, so well written integration layer is very important. REST is old-school (yet still very usable), if you want to be reactive, consider http2, gRPC, websockets. Depends on what is client doing.
You can use [Xtext](https://www.eclipse.org/Xtext/) which is built on top of Antlr and facilitates the creation of textual DSLs. You can also plug your own "generator" or whatever backend to generate your Java code.
Swing is absolutely going to stay around for longer. It's just too ubiquitous. That said, I wouldn't actually want to use it api-wise. If you can stick to Web, that'd be my first choice - either stay in the java+html world with freemarker or velocity, both of which are pretty old already and will stick around, or use one of the newer js frameworks. While it's true that js frameworks move fast, in my opinion their abandonment is overblown. Just because a new framework becomes "hip", doesn't mean the community around the old ones disappears - Javascript is used way too much for that nowadays.
&gt;Java, on the other hand, has something the web stacks don't: an emphasis on backwards compatibility. Other than Angular/js, what other web stacks have backwards compatibility issues?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 If you are a Java web developer, then you are already aware of the sheer amount of Java Web Frameworks that are out there. That is why we‚Äôve made this list for you. These are the ten best Java Web Frameworks, Frameworks that will last a long time, and support you in whatever you need to do regarding Java web development. Before we get into the list, let‚Äôs clarify what a ‚ÄúWeb Framework‚Äù actually is. A Web Framework is a program that allows you to develop web applications. The framework aspect denotes a system or structure that you can modify to easily develop new applications for a specific piece of software. It simplifies the whole ‚Äúbuilding‚Äù process, so instead of having to make a number of lengthy and complex alterations to the entire software, you can simply use the framework to make specific changes, without having to rewrite all of the code. Many different Java hosts don‚Äôt actually support all of the frameworks we‚Äôre about to share with you. That is why we‚Äôve developed [this Java hosting service](https://javapipe.com/java-hosting/), which supports all of the frameworks we‚Äôre about to share, and allows you to easily change, alter and develop whatever Java software you wish to work on. JSF ‚Äì JavaServer Faces Struts [Hibernate](https://www.learntek.org/hibernate-training/) GWT ‚Äì Google Web Toolkit Vaadin Wicket Vert.X Spring &amp;#x200B;
There's also The Java Specialists Slack group: https://www.javaspecialists.eu/slack/ I've been part of it for a while and can heartily recommend it.
\+1 for everything you said.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Possible. But I was (still am?) a noob and I did not know/have any other backup after stackoverflow, at that time I felt that was harsh :(
&gt;In my opinion, before touching the UI, I would update Java 6 to atleast Java 8 and get rid of JBoss somehow. Jboss, Wildfly, they are the same. And is still widely used nowadays 
I would stick with Swing.
Javafx is stand alone jar outside the jre.
Swing is actually very quite popular and more productive than most web based ui frameworks - I‚Äôd suggest keeping it (it‚Äôs also not dead or deprecated and I bet will still be relevant 10+ years from now) It might be useful to update java and perhaps replace jboss with something more lightweight.
Languages like Kotlin and Ceylon have native support for compiling to javascript. It's not that much different than typescript compiling to javascript.
I guess he meant switch from JBoss to something more modern? JBoss is the old name. The last "JBoss" version was 7 I think. That was around 2012. So it's quite old. 
JBoss specifically.
The Immutables library has a [Staged Builder](https://immutables.github.io/immutable.html#staged-builder) feature that sounds like what you're looking for.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I work at a very large organization and we have similar constraints on some applications. My first tip is to choose something based on the time you have. If you're alone and time restricted, don't try to learn new frameworks and migrate the whole thing. You'll shot yourself in the foot. Second thing, the "important" part here is the backend. It's the only thing that shouldn't change much in the next 20 years. The front end could become a whole VR application and it would still work perfectly fine. I would suggest to rewrite the code and expose a REST/SOAP API. Third, what's the state of the application? Do you have code analysis tools? Do you have unit tests? Do you have version control? Do you have a build and dependency management tool? Make a plans before rewriting anything. Update Java first, that might break things with JBoss 5, so I would probably update JBoss to Wildfly or something else. Make sure to refactor the code with something container agnostic (e.g. use Java APIs instead of vendor specific APIs) and move all the dependencies and configuration to a Maven file. You want to make it has easy as possible to update or change container. Only when you can confirm that the same application is working on the updated stack that you can start the code migration. Fourth, migration plan. You want to slowly migrate the current code. How will you do that? Class by class? Feature by feature? Do have a shared library? Second application with new code? Who will test the changes? You can use dependency injection and interfaces with multiple implementations. You can also use Aspects. You can also try Microservices architecture. Whatever you feel comfortable. I would suggest to make small changes. It's easier to keep track and debug. Now the UI. As said, it's the last thing on my list, because once you have a good backend you should be able to swap the UI easily. If you think that a Web UI would be a good fit, go for it. It's platform independent, works on any screen and usually easier to maintain. UI is a touchy subject even for power users. I worked with untrained users in the past and they'll accept the change if you do it well. Make the same exact UI in Web. No matter how ugly it is. Just make the same buttons at the same location. Take some time to explain why it's Web now and make sure the same features are working the same way. Once that's done, iterate over and over. Slowly change and improve if you want. The worst thing to do is a full redesign. See Digg/Reedit redesign (faillure) and YouTube iterations (success). The Web framework is irrelevant in my opinion. Use a server side rendering like Thymeleaf, Velocity, JSF or client side rendering like Vue, Angular, Vanilla JavaScript, even jQuery if you want. JavaScript will work the same way. The only thing to consider is build tools. For example, if you need to compile Typescript with Node for Angular, you now depend on those tools, but large organizations around the world use them now. I would be very surprised if they disappeared in the next 10-15 years. 
Depends on if you're licensing it or not. WildFly is the name of the community, free version. If you're paying support to Red Hat to get all the latest bug fixes and security patches, it's still JBoss EAP. 
Just a small note: try { Thread.sleep(50); } catch (InterruptedException ie) { } This is bad behaviour and you shouldn't do it. If the thread has been asked to stop, then you should do that as quickly as possible. In this case it should call `break` in the `catch` block. As it stands, the thread will continue indefinitely. You should possibly also call Thread.currentThread().interrupt() https://programming.guide/java/handling-interrupted-exceptions.html
there's a cartel of high-karma users called the close-vote-ring that use automated tooling. some of what they do is pure good, some arguably good, some of it is baby-with-the-bath-water, and some of it pure evil. the company either tolerates or embraces them. i spent a moment in their chat, and didn't see anyone in the cartel that had an understanding of the nuances of java and they were generally annoyed with java because java-related-questions produced a large number of false alarms for their automated tools
GWT + Vue üëç https://github.com/VueGWT/vue-gwt
It looks like in your [submission](https://www.reddit.com/r/java/comments/a71tew/is_working_paralleled/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That link 404's for me I'd say this is the simplest for a web app front end (compared to say react+redux or similar), leaving a local purely java based ui out of the equation. You just template a page, pull data, populate the template. Hard to be much simpler. You're not wrong that 20 years is a long time. Who knows what will happen, but those three are as close as I think you can get. * I expect fetch will actually last 20 years. It's the replacement for XMLHttpRequest which came out in the early 2000s and that's still in use today. Plus it's built into the browser, so it's not like it's going to stop being maintained. * Handlebars is just a js implementation of mustache, which is pretty solid and has already been around since 2009. Worst case it's simple enough that you could re-implement it yourself if it somehow vanished. * Bootstrap is and has been "The most popular HTML, CSS, and JS library in the world." for at least 5 years. In the javascript world that's about as close as you can get to assurance that it's not a passing fad. If you're aware of some other web front end technologies which you think are likely to survive longer than one of those three I'd truly be curious what it is so that I can look into using it.
It's rare, I will admit--- only because the things die faster than that becomes an issue. However, web assembly is a major overhaul. We have no clue what that'll do. Heck, we don't even know which browsers will be popular in twenty years. Java projects move in decades, web stacks in months. 
I actually didnt know about fetch.. thought it was a framework.. will look into that. That makes sense as its in the browser. Only thing I would say is it may become a new name in a few years. :D Handlebars I love.. though.. its not as powerful as some other templating engines. That may be why it is so good.. easier to use, does enough, etc. I like it, and there is no reason it would disappear other than that other templating libs come along that do more/easier/etc. Still can be used for sure. Bootstrap I dont know if I can agree with. Google is a big company and they are pushing Material UI pretty hard. Not only is it the face of most modern day android apps, it is the face of a whopping lot of web sites too. I suspect though, both will last a while, though Google does tend to revamp things more often than not.. and/or drop things completely. I suspect as browsers mature, CSS4/5, HTML 5.1, 6, etc.. as all those things move forward, it would not shock me if Google renames/updates MaterialUI to stay in sync, as would Bootstrap. So it may be around, it may not. I have seen way too many css/js/etc libs that are good, stop being maintained, get forked, renamed, etc. So this is all truly unknown but I dont disagree that it will be viable for a number of years to come. Oh.. and Java Applets.. they are going to make a HUGE comeback. Mark my word...
They really don't though. If that was the case, there would be no web front ends written in Knockout, Dojo AngularJS, jQuery 1.x, etc. and yet there are countless. New frameworks appear all the time, so do new Java libraries and new languages on the JVM. Just because new ways to do a thing become available, it doesn't mean every project doing something different is suddenly null and void. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yeah fetch is... awesome. Material is interesting, because it's a design philosophy rather than a library and it's not clear if google is going to push heavily on their own implementations (material for web as of today) of it or focus on the general high level design spec. Today you can get material for bootstrap, so the two aren't necessarily mutually exclusive. We'll see. &gt; Java Applets.. they are going to make a HUGE comeback Yikes, I hope not. At least not they way they were before. 
Lol. Def kidding about applets. Not as sure about flash though...
This isn't serverless. Its running on a server which you need to sort out, and it even starts a web server inside the code. All you did was write a main method listening on a port?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Some of the server less frameworks allow you to deploy a function that connects to a binary listening on a port. As such this was meant to show that it is possible to host a one shot request for a Servlet. The follow up linked in the same article takes the function further and changes it to use standard in and standard out and compiles it to a single binary
Is it free?
This function is not supposed to be called by any other program, so `System.exit(0)` does not harm here Also note that the thread will break when the `function.isDone()` call returns true so it will not continue indefinitely &amp;#x200B;
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm not saying that the loop will never end. I'm saying the thread will ignore an explicit request to stop. You should not ignore `InterruptedException`.
I would suggest "Refactoring" by Martin Fowler, you will find it to be super useful after you write enough code to understand it.
http://www.jsonschema2pojo.org
Java concurrency in practice by Brian Goetz
I'm a web development for about 15 years. None of the complex web apps from back then will work today. Browsers are evergreen these days, they are always a moving target and their backwards comparability track record is very poor. Btw, 15 years ago we had IE6. It doesn't exist anymore. We had ActiveX and NPAPI, both have disappeared completely. Security models of all layers have been changed completely. Even the way we render HTML+CSS is different.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
UI looks nice, little pixel-level misalignments though. (variables panel vs numbers panel) Also I got a StackOverFlow exception e.g. "8sqrt9" (i.o. 8\*sqrt9) so you'll need some more input checking to get it right.
At least I wouldn't prefer WPF. I've worked with it some years ago on a larger project and it wasn't fun. I remember it as overly complex, XML-heavy, and partly slow.
I think you can actually e-mail them and ask that. I have badgered them more than once with different issues, and they were always helpful.
Thank you so much for pointing out the misalignment and input details, I'll try to fix it for the next commit :)
My selection is eclipse RCP for the desktop, android for web and angular for web
The real question is whether you pronounce it Azul with a Z, like in New World Spanish, or with a TH, like in Old World Spanish.
&gt; Some of the serverless frameworks allow you to deploy a function that connects to a binary listening on a port. Yeah, we call that a "server".
I've used it in C# and at first I was against it but I became a fan in short order. If you name your variables properly using var prevents you from having to make redundant declarations/instantiations and it just allows you to work more quickly and efficiently. 
You define the return type in the method declaration, how is returning a variable declared with var instead of a concrete type going to change that? Plus, in any IDE if you hover over the variable being returned it's going to tell you it's type. 
Yeah sure having to hover over 10s of lines TOTALLY won't hurt workflow. HOW COULD I BE SO DUMB! /s Also hiding the type refers to a human perspective not a machine perspective. That should be painfully obvious.
We use spring for our REST APIs and to serve up Angular front ends. 
Spring Boot makes this incredibly easy and flexible. 
Properties are something I miss to death from C# but I will grant you that when people put a bunch of complicated business logic inside a getter/setter it drives me nuts because that's not what it's for. 
I was under the impression that making class variables/fields public was not allowed in Java, hence the need for getters and setters, is that not the case?
Nope. You can have everything public if that is what you want 
All of our production web applications are JSF. We are now in the process of migrating them to use Angular front ends with Spring Boot REST service back ends. I much much much prefer what we're moving to now then what we've been doing. JSF is a bear. 
If you name shit properly and follow the convention of instantiating your variables on the line you declare them it just reduces the redundant declaration. Furthermore, if I need to change the type of a declared variable, now I just change the declaration and that's it. Far more flexible and does more with less code. If you name things properly and use basic javadoc annotations I don't see how you're going to be in the dark when you go to invoke a function but what do I know. 
LOL *my* code isn't the problem. I'm sure I can go back and figure my shit out.
Holy shit. How did I not know this? Do you know if Hibernate works with a POJO class that just has public fields instead of private fields + public getters/setters? Because if so, my getters and setters are just redundant code that don't accomplish anything more than public fields would. That would be cool.
Maybe. I‚Äôm not sure. You should try it 
I just read an SO post that says if you change the @Entity annotation to set the access to field and annotate the fields themselves (which I was doing anyway) it should work. So I'm gonna give it a shot. 
Keep thread safety in mind. There is a good reason we write those getters and setters. Some time in the future you may need locking or synchronization and it‚Äôs not really possible to synchronize a field
Ah yea. Good looking out. Thanks. 
in few years from now they are going to turn over and change the license as well. quote me.
I'm not sure what you mean. The OpenJDK is open source. Red Hat cannot just change the license. Oracle can, but that is because Oracle owns the copyright. However Oracle cannot retroactively change the license on all of the already existing open source Java. Given that other large interests are behind OpenJDK, I expect it to continue even if Oracle no longer provided any work on OpenJDK. Like Linux or other large open source projects, they take on a life of their own. However Red Hat cannot change the OpenJDK license. Feel free to please correct any misunderstanding I may have. &amp;#x200B;
woah, it was a joke man
thanks for sharing.. i have a panasonic. I will buy a Canon next time. Simply because I like Java and want to try your SDK.
Remember when the retroactively changed the license of Wikipedia contributions? Remember when the Barnes Foundation was moved? Interested, motivated, and we'll funded groups can make things happen the aren't supposed to happen. That said, I don't think Oracle would bother to try. Why would they?
Azul (who I work for) will continue to provide community editions of Zulu for as long as we provide commercial support. It is important to note that, for the community edition, we only build what is in the relevant OpenJDK project. For our commercial builds, we are doing our own backporting of updates. The net effect is there may be differences between Zulu Enterprise and Community edition.
There's a fairly large difference between a web project and a software project. You can't just take an older version of Wikipedia and fork it.
Code that is already out there under GPL license is out there forever. You cannot make it go away. There are many well funded who would like to make Linux and LiberOffice go away just to give examples. Oracle doesn't have to make any more open source contributions -- but they cann't make the old code no longer be under the GPL. There is a legal concept called Promissory Estoppel. Red Hat doesn't own the copyright and is therefore even less able to change the license. &amp;#x200B; Your argument about well funded groups sounds good, but it doesn't change the legalities.
It doesn't *sound* like a joke. And open source projects and people must take license and other legal issues very seriously in a post-SCO world. &amp;#x200B;
Working on a Spring Boot application at work for the first time. I am not a fan at all. Doesn't help that I don't think the documentation is very nice either. I have used Dropwizard twice now and find it much more enjoyable to use. The documentation is very well thought-out.
Relicensing is irrelevant. Even if they relicense, the code will still be available under the old license - just future versions of the project may only be available under more restricted licenses. I believe they don't even need to relicense for this since oracle has special rights to openjdk.
What problems are you running into with Spring Boot? What aren't you a fan of beyond not liking the documentation? Not saying you are wrong, just that I have found Spring Boot extremely easy and pleasant to use. 
Care to elaborate? What did you find confusing? 
The one thing I hate in spring boot is that I saw a couple of projects/applications having `@EnableAutoConfiguration` defined yet their maintainer never bothered to take a look into the log file to see which auto-configures actually were used. The point is that they just enabled auto-configuration and added all the dependencies they needed, or even transitive ones they did not exclude, and have some features partially enabled that they don't even need. That is not the fault of spring boot. It's obviously a fault of people who blindly enable this, kind of bad, feature and don't have the overview what exactly happens then. I think spring boot should clearly point out that you should always enable only those auto-configures you actually want to use.
I have absolutely no complaints about Spring Boot. Perhaps you didn't understood the scope of the project? 
I‚Äôd suggest not using SceneBuilder/FXML
I'm a big fan of Vertx.io-- its fun to program against, fast, and has stellar documentation.
You have strange issues. Where did you download SceneBuilder? What's your Java version? Whats your system?
Yeah, just build it in code. If it gets too messy, modularize more.
Only thing I don't like about Spring Boot is how abstracted away everything is. After spending a while (a couple months) playing with it and and reading the source code that problem slowly starts to solve itself though.
The problem with vertx is that it uses netty internally (unless that changed since I checked), which provides no binary compatibility across minor versions. That makes it basically impossible to use in my books, it's just too risky an investment.
I think the whole "implicitly try to do everything right magically" shtick is a big part of spring (boot) in general, and one of it's main appeals. I don't like it either, it can make debugging a pain, but it's "it just works" approach is what makes it so popular
Can you elaborate a little further? 
Not sure how this an issue. Using vertx, you are abstracted from netty.
Or you using a game engine or staight java? 
I'm curious as to what your level of experience with java is, are you pretty new to java backend development? 
Interesting, considering Zuul2 is not slated to be in Spring-Cloud-Netflix. I wonder if this changes that decision.
Well uh are you familiar with Spring *Core* itself or shit DI in general? If not yeah you're gonna have a bad time. People here reaally downplay how easy it is to learn
Depending on your use case, check out Micronaut.
Doubtful. Spring cloud gateway was made to replace the spring netflix zuul implementation. Pieces of its functionality will likely make it.
http://micronaut.io/ is new and exciting, heavily inspired by spring but doesn't use reflection based DI at all. Pretty nice. Strongly disagree Spring's documentation is bad, maybe because there's so much of it? It's some of the best I've seen. Have you thought about contributing samples or PRs to improve the documentation?
You think Netflix will implement SCG?
2 years just about
Yes, although I don't imagine straight away. I'd assume they'd move to SCG when it meets their needs by contributions back to it given their blog post. 
Everything is so abstracted. Like this week I spent 9 hours getting our cloud config working for all of our profiles. I don't understand why I had to autowire this bean into class B. Class B used to hold all our SFTP creds when we had an application.properties file but when I moved to creds to the remote repo, it didn't work anymore.
I‚Äôm currently taking Zuul1 to prod on a project, so I‚Äôm interested in the migration path forward.
I'm coming from mainly a Go background where everything is really straightforward. I find it's really hard to know everything about spring boot, when I'm Go you can understand everything about your code because annotations don't exist, and naming actually makes sense. Like why call it a Bean if it's just a serializable object.
How old are the projects? \`@EnableAutoConfiguration\` to me is normally a sign of an application developed before \`@SpringBootApplication\` existed, think it was 1.4, or 1.3 it was introduced (or copy paste hero looking at old old how tos). It's all well and good saying just exclude auto-configurations but you need to understand what you're doing. Spring Boot makes Spring super easy, but too many people dive into the deep end and create super super ugly applications without reading the documentation. Fun tangent, if you understand what to include you can get great gains to startup. [https://spring.io/blog/2018/12/12/how-fast-is-spring](https://spring.io/blog/2018/12/12/how-fast-is-spring) Highly recommend the Spring One 2018 talk on the same subject. GraalVM + Spring Boot shouldn't be miles away either. &amp;#x200B;
You're clearly not getting what happened. They took peoples' work under a certain license and decided that they would give it to others under a different license. Something they did not get permission to do from each copyright holder.
I haven't bothered with SCG due to how mature servlet is, was playing about with SCG for a AuthZ gateway but spring security 5.0 didn't have what I needed at the time. If Reactive is the be all and end all just go with it. Migrating isn't too bad, I switched my initial impl down to netflix zuul. Don't forget it isn't dead either, see https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now for details on what maintenance mode means. Finally, I'm always a fan of the mantra no plan survives a developer who just found a new tool. Netflix are not just refactoring their usage of Hystrix just because they are going forward with Resilience4J (https://github.com/Netflix/Hystrix)
You're clearly not getting what happened. They took peoples' work under a certain license and decided that they would give it to others under a different license. Something they did not get permission to do from each copyright holder.
Not when it comes to copyright law there is not a difference in treatment.
Straight java! 
&gt; Like why call it a Bean if it's just a serializable object. You should google for "Spring Bean" instead of just "Bean". Spring's `@Bean` is different that a normal Java Bean. It is more like `@Provider` in Guice.
Do you have any good resources for reading up on spring boot? I'd like to learn more about it
No. I mostly just read their Java API and random articles online. Sometimes I just jump to the source code to see what the hell is going on. My advice would be to piece things together. For example, Spring was a dependency injection framework before becoming a web framework. So, you have to know what is dependency injection first, and then what dependency injection framework is trying to do. Are there any other dependency injection framework? Maybe if you read a guide on another dependency injection framework like Guice you could understand it more.
Do you think value types will make it into 13?
What about We start (or whatever the plugin)
FINALLY. I can use openjdk now.
I'm not sure that I understand. Are my options to pay Oracle or pay RedHat or is RedHat producing up to date builds of OpenJDK for free?
There is when the license explicitly allows you to copy it. 
We use dropwizard where I work and we have developed our own basic Dropwizard micro-service scaffolding framework which can generate a new service instantly. Never had any problems with dropwizard, everything is customisable and things that are abstracted arent confusing.
So you can pay Redhat to use something I could already get for free from AdoptOpenJDK anf Azul?
Nice!!!
Azul does not provide commercial support for free. (Nor does AdoptOpenJDK.)
For the average user it wont change anything but if you're a giant enterprise, you get to pay RedHat for support instead of Oracle. 
neat! Makes it more impressive. I couldn't tell, I don't have sound. Why are you doing straight java instead of using something like libgdx?
True. I guess I don't deploy production workloads written in Java on Windows but do have to develop on Windows and I was thinking more along the lines of getting a decent OpenJDK for development on the cheap. So was being very self centered there. Not to say that I wouldn't pay for a JVM in production either. Especially if it offered something beyond the open source one.
Sorry for the noob question, what are the pros and cons of RedHat vs Oracle support?
I considered using an engine or libraries but this is just for me to have some fun and develop my skill and like you said it's more impressive ;) 
This is an amazing book. Whenever you join a new company/group you'll most likely take over some piece of code. It's not very common to be part of a group or project where you are writing from scratch. This book is ideal for those scenarios when you take over some else's code.
I've only dealt with RedHat support and it's pretty good. Hopefully IBM doesn't mess with it. Oracle I couldn't tell you but they're a fairly litigious and evil corporation so there's that. I would imagine RedHat will work on and patch OpenJDK versions for a while after Oracle has stopped supporting the mainline version. That's kinda their thing. That part is good for the community as a whole whether or not you have a service contract.
cool, keep posting videos :) Would be fun to see builds based on your videos. 
You really don't understand what they (Wikipedia) did, do you?
Bittersweet news for me - I created Governator as well as starting OSS at Netflix. I think we should all think twice about ceding so much power to Spring. They want to be one-stop-shopping for everything. A safer approach is small, independent libraries that can be integrated, updated, and combined independently. I've worked with both Spring Boot and Dropwizard and prefer Dropwizard's much lighter touch. But, history seems to be moving to the conglomerate. 
Almost certainly not. It looks like they need several more iterations before they get the design right for value types.
How does this change anything? Oracle has provided long term commercial support as have other suppliers. The only thing I can see being different is the price and the quality of the support.
AdoptOpenJDK will not provide support, nor will they back port fixes to older releases. They will just provide binary builds from the OpenJDK mercurial repo.
Oracle already provide a free OpenJDK build on Windows, as do AdoptOpenJDK. Neither come with any support. I believe Azul also offer a free build. For development, you can also use the Oracle JDK.
Web start? It's gone from OpenJDK, so it won't be part of Redhat's OpenJDK support.
Openjdk has been weird for Windows. The openjdk site offers only the latest version of openjdk and the other versions are only available on Linux as far as I saw. I'm just interested in openjdk it shouldn't actually be a big deal if you are just fine with Oracle's jdk.
You cannot have two dependencies that themselves depend on two different versions of netty without relocating one of them.
It's about deployment. You can't have two versions of it on the same classpath without relocating
Sure, but that doesn't mean the code doesn't continue existing under the old license, which is the only thing that matters here.
Looks like Hystrix dead for them. 
Yeah that's my point. I've really enjoyed it. Like the other day I wanted to close my database connection on server shutdown. I found the docs for the Managed abstract class, and it was so easy to understand. If your scaffolding work is open source, I'd love to take a look. Are you guys using Java 8
I'm definitely no expert. I'll take a look into that. Maybe it'll help. Thanks for the advice.
Not OP, but I'm fairly new to programming (been doing it for just 4 years now) and I'm now learning Spring Boot after working a full year with Spring Implementation. It can be difficult to grasp at first if you come from an environment where DI or IoC are not used (in fact, until a year ago I didn't know IoC and DI existed at all) and god knows I was completely lost and struggling with it at at first, but the more I learn about Spring the more I like it.
For a while actually. Take a look at hystrix's github page. 
The browser plugin and Java Web Start were never part of OpenJDK; they were additional features provided in the Oracle JDK. From JDK 11, these have been removed from the Oracle JDK as part of the work to converge the functionality of the Oracle JDK and OpenJDK. The net effect of this is that, if you want to continue getting support for JDK 8 with Web Start, your only option is to pay Oracle.
Checkout xtext and xtend.
Do you see a future where we look on spring as we do the jee stack now, where it's similar to having an application bundle of jars (bit like the "spring starter" dependencies)? 
I wonder if Spring plan to replace it with Resilence4j in Spring Cloud. Also isnt Spring Cloud LoadBalancer built ontop of Ribbon? 
Yeah, it feels that spring stack becoming yet another JEE.
I don't know anything about the Wikipedia thing you're talking about, no. However, I know enough about software licensing to know that you can't retroactively change the license of a software product. You can only change the software license of a new version, in which case people can take an old version and keep using it under the old license. In fact, the GPL (which OpenJDK is licensed under) was designed to avoid the exact situation you're talking about.
Probably not super helpful here, but Yada and family provide a composible basis for apps on JVM.
Thanks for that. Will forward that to the team. 
Micronaut to the rescue?
Nice one! It's actually even simpler than presented. I left a comment on the original article.
Just a quick thought: Are there any ways of using Querydsl that would actually make querying much more dynamic? Without the need of specifying if statements and properties of the entities? Currently using the predicate executor interface, was wondering if there was a better way to do this since I'm working on a database with 15+ tables, multiple relationships on each, as well as a huge number of columns.
If you create synthetic benchmarks like these please use [JMH](https://openjdk.java.net/projects/code-tools/jmh/). While you do take warm-up into account, your runtimes are still way too short to be meaningful indication of the performance impact. 
Meahwhile, I'm still working with a EJB2 era XML that doesn't actually help in the long run.
Admitted performance bigot here: a 400% increase in run-time is absolutely significant. The bit about the impact of the volatile keyword was interesting, though. If your cuboid classes are infrequently used, or you have only a fixed number of them that you reuse or (gasp!) mutate as part of application state, the introduction of this class is not going to hurt you too much. If that's going to run in "heavy lifting" loop, that 400% is going to be apparent.
Netbeans (for me) looks the best out of all the Java IDEs.
Be sure to check out Spring Data's OOTB \`Predicate\` derivation capabilities documented \[here\]([https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.web.type-safe](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.web.type-safe)). There's an \[example\]([https://github.com/spring-projects/spring-data-examples/tree/master/web/querydsl](https://github.com/spring-projects/spring-data-examples/tree/master/web/querydsl)) of this working in our examples repository.
While I don't see the actual code for these Cuboids, java should be able to perform escape analysis and note that a pattern like this: Foo foo = new Foo(x, y, z); method(foo); followed by method(foo) just picking off the values from the passed foo instance should result in elision of the foo instance. So the runtime performance should be identical to just passing the raw parameters.
How many different attributes do you need to build queries for? I had a similar issue in the past, so I build a query api on top of QueryDSL and SD that was more narrowly focused. I had data classes that would carry the values the user needed to query for, and on the back end, there were classes that new how to take that data and build complex queries based on the type of the DTO. QueryDSL has an ```ExpressionsUtils``` class that's really convenient for generating a ```Predicate``` from a ```Q```class attribute.
You can check the entire code [here][1] if you want to. It's using getters and keeps data objects in the instance which might be also the case. I also assumed it should inline to values, however haven't find it in results. Probably as @nutrecht mentioned the warm-up phase was too short. [1]: https://github.com/puradawid/java-constructor-microbenchmark
https://github.com/spring-cloud-incubator/spring-cloud-circuitbreaker/tree/master/spring-cloud-circuitbreaker-r4j
I considered JMH, however decided to do it once on my own. Probably the warmup time is still way to low (although I can observe GC activity in logs) as you are saying. I will try to check out the same code with JMH and compare results. Many thanks for pointing this out!
Once you convert the tests to JMH it would be nice to also see comparison between current C2 compiler and new Graal compiler.
Hey, that's a great idea, thanks!
Spring will own your application's foundation. You will be beholden to them for updates, changes, etc. For many this is a reasonable concession. But once you go down the path you are locked in. 
I've also seen it used to avoid this. calls in constructors and the like. public void setValue(int _val) { val = _val; } And just for local method variables in general. Haven't seen it used like this in Java much, but did see it a lot in C#.
Will do :) I'm going to try adding a video a week to that same YouTube channel and if it's got enough interest I might start releasing build versions as I go :) 
Yeah it would be nice to have a live reload and I could probably do it with minimal effort but idk theres just something satisfying about hitting that f6 key and watching it come to life. Personal opinion of course. Agreed I've worked with a number of different IDE's and always seem to end up back in netbeans 
See my edit; extracted the relevant code and did it for you. The difference is much larger (I'm suspecting the JVM can optimise the heck out of the first one). It also shows it's barely relevant; the 'complex' one is being called 113 million times per second on one thread. 
&gt; a 400% increase in run-time is absolutely significant. [It's much higher actually](https://old.reddit.com/r/java/comments/a7leio/data_classes_in_java_runtime_underperformance_vs/ec3w7n4/) And yeah, I totally agree that in some occasions it can be relevant. But even the 'slow' code in my benchmark gets called 113 million times per second. If you're doing anything over the network it's not going to be that code that's going to be the bottleneck. 
Wow, many thanks! I just have one question here: aren't these values (W, R...) inlined in this particular case?
You're probably right; I also did a benchmark with just calling a static method instead of constructing an object and it had the same performance.
They're also all constant in your code.
I wanted to take that bit out because it's not relevant to what we're testing. Feel free to mess about with it to see if modifying it gives different results :) P.s. you might want to add an open source license to your repo by the way. 
Thanks, I forgot about the license!
Take a look at Traefik. We just migrated to it from Zuul. 
So I guess it‚Äôs fine if you are just deploying a Docker image per release?
No. It's about future dependencies within the same application.
Oh you‚Äôre using Netty directly in the same application elsewhere? 
We're also the ones doing the lion share of actually developing OpenJDK (after having recently concluded open sourcing all of the JDK), so there's that.
Note that we will be getting [real data classes](https://cr.openjdk.java.net/~briangoetz/amber/datum.html).
Just too bad that the Querydsl project is practically dead. e.g. It does not work with Hibernate 5.2 nor 5.3. There are pull requests but the current maintainer has no time/motivation.
Does it do service discovery with Eureka?
Can you clarify? Spring Data has Test cases for its Querydsl integration and they run fine on everything &gt;=5.2, even 6.0 snapshots.
Or in a library that isn't vertx. For example a database driver.
@olivergierke Spring Boot has it's pros and cons. It's very helpful if you want to write some small application, but everything is too "automagical". Today I spent 4 hours debugging weird exception, which was caused by some incompatible libs on classpath, which were included from other dependecy I've included. I wrote "weird", because it was "FileNotFoundException", because of not found Spring Security config - but there was included such config! It just picked up all configs. Maybe I don't know Spring Boot a lot, but it's confusing for new users. Secondly, Spring Data Flow is not mentioned on [start.spring.i](https://start.spring.io)o - is it supported at all? Third point, there is too many projects in Spring, it's hard to find proper sublibrary. Yeah, I know, Spring is big... But "Spring Cloud DataFlow" is not about Cloud, it's about microservices! Libs should be better arranged into groups and artifacts, because it's hard to customize application. Last thing I see is that properties are sometimes waaaaay to long. Hard to read, hard to write, hard to memorize their names. &amp;#x200B; If there can be something changed from my list, I would be happy!
Yeah I‚Äôm following, had similar issues years ago with Groovy/Grails, forget the lib. 
In my organisation we were having issues with Querydsl's JPA module. Some method signatures got changed in Hibernate ORM 5.2 (but 5.3 fixes that issue): [https://github.com/querydsl/querydsl/issues/1917](https://github.com/querydsl/querydsl/issues/1917) And then there is Hibernate 5.3 which removes "legacy parameter" support (a positional parameter was basically a named parameter). This support got deprecated somewhere during its 4.x life, but Querydsl never got around to modify its implementation for it.: [https://github.com/querydsl/querydsl/issues/2326](https://github.com/querydsl/querydsl/issues/2326) IIRC, this was only an issue when we were using HibernateQuery. JPAQuery worked fine. But we could not use the latter as we wanted to set a lock mode on a particular path. (`HibernateQuery.setLockMode(Path&lt;?&gt; path, LockMode lockMode)`) This delayed our migration from Spring Boot 1.5 to 2.x for several months. Due to the lack of activity within the Querydsl project, we bit the bullet and created our own Querydsl fork and applied this PR: [https://github.com/querydsl/querydsl/pull/2354](https://github.com/querydsl/querydsl/pull/2354)
Out of interest, could you run your test on graal?
Yes, we are using Java 8 and work is in progress to move to Java 11 (for newer services at least). Sadly, the scaffolding stuff is not open source, because it automatically inserts some common configurations, java package dependencies, pojos etc which are internal. What I can tell you is that the scaffolder is based on [Slush](https://www.npmjs.com/package/slush). And we have a template which we use with slush to generate the actual service code based on parameters like service name, whether it needs to connect to Postgres etc etc.
Oh lol, didn't expect that: Benchmark Mode Cnt Score Error Units CuboidCalcTest.dataStructure thrpt 5 3254508488.663 ¬± 19656016.831 ops/s CuboidCalcTest.plain thrpt 5 3247566683.639 ¬± 17977940.655 ops/s CuboidCalcTest.raw thrpt 5 3249988882.638 ¬± 11170717.117 ops/s
Not a 100% sure. Consul would the recommend way to go. Eureka doesn‚Äôt look to be officially supported but you can make work with a little effort.
Not a 100% sure. Consul would the recommend way to go. Eureka doesn‚Äôt look to be officially supported but you can make work with a little effort.
This is basically a test of the quality of escape analysis.
To update an existing install you may have to add this update site: http://download.eclipse.org/eclipse/updates/4.10
Who cares?
Thanks for the detailed writeup!
Eclipse users
Not just data classes. I get PR's rejected because "Streams instantiate too many objects compared to for-loop" for data structures that contain maximally 1000 elements.
So nobody.
Looks like they dropped named releases (e.g. Neon, Oxygen, Photon)? The Eclipse ecosystem is so damn confusing. Every subcomponent gets its own version number. There are umpteen variants of the actual IDE itself. I can't tell which pieces offer core functionality versus which are optional plugins. Even the 'About' dialog is an overwhelming jumble of information packed into deeply nested dialogs. I swear it's like they're trying to scare people out of using the app.
If you say so
Do you have some performance-nazis-mates in your team?
Readability of streams is a different topic though.
Finally the added the suggestions to write a lambda, I can't believe it!
Hooray! Only three months away from Java 12 and they finally support Java 11. Great work!
This was one of the reasons most of my entire building gave up on Eclipse. "Which version?" could be a code name, or a date, or something actually useful like a fucking version number -- but that number is fucking buried, and the 'About' window only showed individual components. The IT staff and developers went out of their goddamn minds trying to communicate about hidden version numbers. "Go download v3.5" didn't help much when the website shows some alphabetical but information-free codenames and the files are listed with some internal revision number. (Apparently the About window recently started showing all the names and numbers, which still undoubtedly be useful to the one team here still using it.)
Readability is always more important than performance by default. Performance only becomes more important than readability *after* you have confirmed that the more readable option is the cause of a performance problem in the end product. Developer time is almost always more valuable than computation time. That said, it's always a shame when we have to make that choice in the first place. A failure of the language and platform to make us choose. Thankfully records and value types will mean we don't have to make this choice any more soon.
The simplest way to avoid the problem with unused results is to return the created object (or the computed value) from the benchmark method. JMH takes care to defeat dead code analysis done by the JIT compiler. Well, it seems to work reasonably well with C2; I don't know if it works with Graal. But it's easy to do and it's probably worth a shot.
Not trying to be inflammatory but who here is still using eclipse? I haven't looked back since moving to intellij. I've found it superior in essentially every way.
That's great. I used Eclipse back in uni, and no one had any idea what the "correct" Eclipse was. I had no idea they were versions until I read your comment now.
If graal is actually executing the method is awesome how fast it is. If graal is not executing the method is awesome how smart it is. I suspect we are seeing a revolution in real-world compiler and/or vm implementations in front of our eyes.
If you want to avoid defining and allocating intermediate data structures, you could try a builder-style approach: return new Cuboid() .dimensions(width, height, depth) .rgbcolor(red, green, blue) .volume(); I say "builder-style" because you probably wouldn't want a separate builder class. Instead, build up the state of the object using what are effectively setter methods. You might want to have some additional states in the object to prevent improper use, e.g. before the various bits of state have all been initialized. The API might end up being a bit clunky but this might be a reasonable middle ground between a six-arg constructor and a bunch of data classes.
or use latest [https://download.eclipse.org/releases/latest/](https://download.eclipse.org/releases/latest/)
The boost in performance is awesome. Is it possible to disable Code-Mining for Lombok? It gives me ridiculous results.
Welcome to the world of doing all the work and everyone else making money off of it.
Well, Oracle sells Java support, too. The thing to remember is that Oracle employs *hundreds* of full-time OpenJDK developers, and that effort needs to be funded somehow; it is not a charitable contribution. Other languages/runtimes of comparable size (NodeJS, Go, Rust and others, are much smaller than OpenJDK) -- .NET, Android, Swift/Objective-C -- are indirectly funded by ecosystems, fully controlled by Microsoft/Google/Apple, that generate those companies *billions*; this is not the case with Java.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a7po4s/servlets_to_jsp/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yep I totally agree. I have been a Java dev for many years. And all those years I have been paid for the work I have done. Seems only fair that the people who do the Lion's share of the work on the JVM and it's dev kit should be afforded the same courtesy. I do feel like Oracle's jdk team is fighting an uphill battle because so many have had bad issues with Oracle via their RDBMS. And I I will admit to being nervous about doing business with Oracle because of previous problems around the RDBMS. Maybe this is Redhat's revenge for Oracle forking RHEL into Oracle Enterprise Linux?
I'm a relatively new OpenJDK developer, but from what I've seen and been told, Red Hat have been good partners, and have contributed excellent and important work to OpenJDK.
I downloaded IntelliJ to check it out for a couple of days and it seemed similar in essence except all my memorized keyboard shortcuts are different. It didn't help that I've only ever done JEE and I'm leery about running into something requiring me to pay or switch back to Eclipse. I've also asked on a few occasions what *specifically* leads people to prefer IntelliJ and it nearly always comes down to a series of statements starting with, "I prefer..." And I get that. Folks get used to an IDE and just prefer the way it does things. I don't knock that. But I've been using Eclipse for over 10 years now and I'm perfectly happy with the way it does things and no one has offered a compelling reason to change. I'm not adverse to change -- I migrate tools and platforms if I see a compelling and relevant reason. Maybe this is your chance to shine.
I've worked in to companies that made the switch and didn't look back. But I see your point, the first time I tried it I didn't see much of a difference. Some points that may or may not be relevant to you: * the formatter is a lot better * proper, fast full text search * arguably better, more consistent shortcuts * better autocomplete (can't explain, it just makes better proposals than Eclipse) * better maven support (although I think eclipse got a lot better here) * better debugger * better refactorings * included database support which interacts with your persistence framework * great spring support Cons: * indexing may take a lot of time * some bugs / feature requests haven't been solved in years with hundreds of votes * the "project explorer" (or its equivalent) isn't nearly as good as the package explorer and the handling of projects and multi-module modules is utter shit in some ways * kinda expensive if you want all the good stuff
I am, unless when doing Kotlin or Android related stuff. InteliJ keeps my fans working, has this nasty habit to index all the time, lacks incremental compiler on save and doesn't support mixed debugging between Java and native code. Plus there are lots of enterprise shops where Eclipse is the only sanctioned IDE for Java development. 
About half of everybody, if the stats are any indication. I find eclipse having superior performance (less memory usage and especially the compiler is far faster), the productivity is better due to its Hot-Code-Replace feature which lets me save a source file and then reload my website, total turnaround between making an edit and seeing its effect measured in milliseconds... and the editor just makes way more sense to me. I understand you feel differently, but perhaps it is time to disabuse yourself that it's a simple matter of 'A is simply better than B regardless of metric you care to use to determine this'.
Yeah that's something we (team Project Lombok) need to work on now that code minings are part of the main distro. 
Mine says ‚ÄòGee‚Äô in the windows icon preview for the start menu (work machine)
[Two weeks ago](https://www.reddit.com/r/java/comments/a3aykz/serialization_in_java_with_examples/eb4zuwk/) you were told not to post tutorials here, yet, you completely ignore this and post again. This time is the final time. You're banned. Also, your whole contribution to reddit violates the [reddit rules for spam and self promotion](https://www.reddit.com/wiki/selfpromotion). You are just a plain spammer.
Because it insists on being the composer, rather than a collection of arbitrarily composeable primitives, sometimes it is eager to do mindless things because it doesn't and can't have enough context to do the right thing. In these cases people spend hours unpicking the framework to disable unwanted behaviour.
&gt;what are the pros and cons of RedHat vs Oracle support? One pro of RedHat is that it is not Oracle. &amp;#x200B;
No, unless the massive Jakarta EE members like IBM, Oracle, Microsoft, Pivotal, SAP, etc. pay me.
Eclipse is in a total eclipse of the IntelliJ 
One of the larger benefits of Graal is improved escape analysis over C2.
I am, and the reason is Eclipse's incremental compiler. I hit save and everything is built. I also can run in debug mode even if there are method bodies that still contain compile errors. I tried IntelliJ a couple of times, but the experience regarding compilation was disappointing every time. Maybe it's better by now? I read somewhere one can use ejc (Eclipse's compiler) in IntelliJ, I guess I could try that. Is it a thing IntelliJ users commonly do?
IntelliJ supports hot code replace. I use it daily.
I use eclipse for Java programming and feel that I am about as efficient as I can be with eclipse. I really don't miss anything in particular and am overall happy with it, so I don't see what feature of intellij would be sufficiently worth while for me to warrant spending a substantial amount of time to become as efficient as I am with eclipse. I sure won't switch out of boredom. Please enlighten me.
That's awesome to know. I am glad that many people from many companies are working on OpenJDK because selfishly that means my skills will have value for the foreseeable future. I feel as though comments that I made on this post offended the Redhat faithful which wasn't my intention. Apparently a skill I need to work on is communication. Also I do want to say I do thank you as someone who does not pay any money directly for Java that I am excited where the technology is going.
I think you'll find your benchmark got optimised away. 
apparently
&gt; Looks like they dropped named releases (e.g. Neon, Oxygen, Photon)? Yes and no. There's still the version number (4.10 here), and the name (which is 2018-12). I do agree that all the different forums, plug-ins, versions of those etc can make Eclipse a somewhat difficult experience to get into. It's made somewhat more confusing when Eclipse started to become an org like Apache and the IDE is just one of the many products.
&gt; arguably better, more consistent shortcuts Are they still using the "redo" (ctrl-y) shortcut for "delete line"? 
Why are you trying to start another IntelliJ vs Eclipse flame war? It's been done to death already. What if we just let people use the tools that make them productive? 
I swear that's what I typed but my phone changed it. I was wondering if with *commercial* support for java webstart would come over or something. I guess not.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yup. Everything he is saying. The thing that I've seen is, for the most part, 8-&gt;11 was a relatively easy move. Simply building with 11 found something like 99% of the problems. Running found the other 1%. Yet, I was pulled into so many hand wringing, pearl clenching meetings with people deathly afraid of the update. For most users, it was as simple as bumping up old dependencies. The only thing that was moderately difficult was moving people from jersey 1.x to 2.x (5 years! You had 5 years to adopt Jersey 2...)
I use both Eclipse and IntelliJ. I prefer Eclipse: * It is way more customizable, with windows and tabs everywhere, buttons the way you want, perspectives, ... * The workspace system is super handy for managing multiple projects with vastly different IDE configurations * Eclipse's autocompletion is often smarter than IntelliJ (with well configured code-recommanders) * A few powerful shortcuts are missing in IntelliJ * Modularity and plugins system Now the few things I prefer in IntelliJ : * The variables appearing instantly during debugging * Parameter types assistance * It's usually faster when refactoring (may not be so true anymore with this new Eclipse version) I'm probably biased, but it's the feeling I get when using both IDE.
What kind of work are you doing that people are so performance/memory conscious? Not that I don't see that kind of idiocy in my own work (worrying about stream efficiency when in the middle of the stream they have a db call...).
Funnily, this will probably have a larger negative performance impact than doing the inner classes or even a proper builder for an immutable class. Why? Because non final fields are harder for the compiler to optimize away/prove they aren't modified. When you say "cuboid.green()" in a loop, the compiler might not be able to optimize away the memory lookup (It will probably optimize away the function call though). That is because green is mutable. Potentially even from another thread. Final is your friend when it comes to performance.
Well, the new versioning system is quite simple. It's the release year and month. You do not really need to know the modules versions, these are more of an internal thing, or if you find a bug in a module, to follow the issue.
It's not really. It's full in modular. Thus each component needs its own version. Developing a osgi app is fun as hell. Too bad it never went mainstream.
Two things after being a long term user of each. First, unified editor. That means each editor has the same actual shortcuts and features regardless of lang. Very big deal. Second, suggestions. Intellij goes above and beyond by suggesting in lang embedded in another language etc. Saves so much time and frankly you find yourself asking "how did they know?" Very often. 
&gt; I understand you feel differently, but perhaps it is time to disabuse yourself that it's a simple matter of 'A is simply better than B regardless of metric you care to use to determine this'. Did I say regardless of any metric Intellij was better? Just the experience I've had... but if you have metrics other than your personal experience I'll certainly check them out.
You can remap any shortcut. I switched up the defaults on both IDE's when using them.
Intellij has a built in feature to use the Eclipse key bindings.
Yeah, spring on the other hand...
&gt; but that number is fucking buried, and the 'About' window only showed individual components. &gt; Eclipse IDE for RCP and RAP Developers &gt; Version: 2018-09 (4.9.0) &gt; Build id: 20180917-1800 Literally the first thing in the About dialog. 
 &gt; (Apparently the About window recently started showing all the names and numbers, which still undoubtedly be useful to the one team here still using it.) 
&gt;Well, the new versioning system is quite simple. It's the release year and month. Yes, except for the other versioning system still in effect and still displayed. As I said, it's now a date, but this scheme has only just started in the last few months, and we've already switched away. (Not for this reason alone, but it certainly didn't help.)
&gt; Eclipse Platform &gt; Version: 4.3.0 &gt; Build id: I20130605-2000 This is Kepler, from 2013. Probably doesn't say "Kepler" because i launched the bare "platform" build that has absolutely no extra plugins installed (i keep it to test compatibility).
You can move from 8 to 11 without converting your app to the module system. That should go relatively smooth. Using modules is a whole other migration and stuff like Spring even advises to not do it, yet.
And that's the problem. When the forums and Reddit and other community documentation after referring to Kepler and name doesn't fucking show up, what exactly is IT staff supposed to do? When the download site and online references are *only* to Kepler, or Mars, or whatever the fuck, which version numbers do those match up with? The IT staff aren't programmers, they're not using the software, they're not going to memorize any of this. You're trying to argue that the information can eventually be pieced together. That's missing the point. If it's not all in one place, *all the time*, without the retarded number/name/date ambiguity, then large organizations are going to get frustrated with the visible discontinuity and go elsewhere. It's nice that eclipse is finally starting to be less dumb about this, but you're wasting your time if you're claiming that it's always been perfect.
I explained the "Kepler" is not there because i ran a special build that nobody runs for regular work. I don't know how to get such an old build properly packaged now, but i'm sure i'll show the release name there.
I explained the "Kepler" is not there because i ran a special build that nobody runs for regular work. I don't know how to get such an old build properly packaged now, but i'm sure i'll show the release name there.
Yup
Yup, hence my remark under my second edit. Pretty amazing to see at work still. 
The major builds of Luna and Kepler *only* say "Luna" and "Kepler", in the place where yours shows numbers. Actually, Luna also shows a version number of some individual component/asset, but not the version as a whole. Mars shows "Mars.2", which we all consider somewhat adorable. My coworkers were complaining of the same problem through whatever code word 'N' had, when they switched to a different IDE due to crashes. I'd switched already because I needed better support for a language that wasn't Java. I think the team downstairs is still using 'Oxy' or 2017 or 3.8.6 or whatever, dunno, they're not my team. We still have these old installations because dev VMs don't get deleted as they age or get updated. It's like having a Wayback Machine inside the building, so that we can only purge memories by heavy drinking instead of simply forgetting.
Yes. Never had a problem with that though, I rarely use "redo" anyway.
Yes, I use the eclipse compiler in IntelliJ and it works fine. IntelliJ is also a lot better at determining what actually needs to be built for a program to run and reduce build times.
&gt; What kind of work are you doing that people are so performance/memory conscious? In my experience it's generally relatively junior devs that try to optimise the heck out of everything without taking into account the maintainability of the code. It's often also a bit 'showing off' when they comment on trivial stuff like this in pull request instead of looking at the actual design of the software. I've worked on systems where stuff like this actually mattered (processing petabytes of data). But in most cases by far it doesn't; object creations and method calls are 'expensive', but are completely dwarfed by how expensive something like parsing a JSON string into an object is, not to mention the cost of moving bytes over a network. If you're working, like most Java devs, on some service that generally gets stuff from a database (or other services), does some processing, and then hands it over to something else (via HTTP, a queue or a database) the 'cost' of streams in no way matters at all. There the focus should be on writing maintainable code. 
In my experience it's generally relatively junior devs that try to optimise the heck out of everything without taking into account the maintainability of the code. It's often also a bit 'showing off' when they comment on trivial stuff like this in pull request instead of looking at the actual design of the software. I've worked on systems where stuff like this actually mattered (processing petabytes of data). But in most cases by far it doesn't; object creations and method calls are 'expensive', but are completely dwarfed by how expensive something like parsing a JSON string into an object is, not to mention the cost of moving bytes over a network. If you're working, like most Java devs, on some service that generally gets stuff from a database (or other services), does some processing, and then hands it over to something else (via HTTP, a queue or a database) the 'cost' of streams in no way matters at all. There the focus should be on writing maintainable code. 
I really curious if that also means we can finally benefit from data locality. The biggest performance bottleneck we have now is that an array of objects is not actually a continuous piece of memory but just a block of pointers to memory spread all over the process space. CPU's can be much more efficient if you can plow trough blocks sequentially. 
Is this using GraalVM or just Graal compiler with 'normal' JVM?
GraalVM.
I believe you are looking for [value types](https://openjdk.java.net/jeps/169). They, too, are in the works.
Spring is the best
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'd really like to have time to take a closer look at Micronaut which looks really interesting.
The Maven support (or lack thereof) in IntelliJ is one of the main reason I'm using Eclipse. In IntelliJ it's super hard to see which of the maven modules in my Workspace depends on what and where each class comes from (the dependency graph visualisation if Eclipse is great)
Came here to say this. JavaFX API is quite straightforward. No need to complicate it with FXML.
I don't use Scene Builder for different reasons, but it's actually a good program. Can you try updating your drivers, especially the GPU? Back in 2014 or something, Scene Builder would crash my new laptop and I hated it. Turned out anything that makes use of 3D acceleration was crashing my laptop because of the faulty GPU drivers.
It's impossible to predict how will JavaScript landscape look like in 20 days.
I agree, this does not seem possible.
Why?
You mean like [this](https://blog.jetbrains.com/idea/2010/05/maven-dependencies-diagram/)? [https://plugins.jetbrains.com/plugin/7179-maven-helper](Maven helper) will show the effective dependency
I use IntelliJ IDEA, but previous versions of Eclipse already felt faster. Why do some people dislike it so much? Maybe Eclipse was too slow years ago?
I was the first person at my workplace to start using IntelliJ way back when, primarily because staring at code on a white screen drives me into a murderous rage. Eclipse's dark theme has always sucked, I don't know if they ever fixed it. We then moved to a Gradle build which nobody ever managed to get working in Buildship, had to use the deprecated Gradle plugin. Since we added yarn and react to the build process, it no longer works in the old one either, so the last developers who still use it are being forced to abandon it. FWIW, in IntelliJ I just import the project and it works.
I'd prefer atrocious Android SDK to any JS framework to build web applications.
#JavaFX
Yes, its probably good choice but question is would you like to do something quickly, or with the best quality. Because something can't be done with js
Because once it‚Äôs shipped you know it‚Äôll keep working - you have control over everything - whereas a browser will change. And JavaFX is dead.
repost. Go to: [https://www.reddit.com/r/java/comments/a7drrz/netflix\_oss\_and\_spring\_boot\_coming\_full\_circle/](https://www.reddit.com/r/java/comments/a7drrz/netflix_oss_and_spring_boot_coming_full_circle/)
Browsers can go to hell, but JavaFX looks quite healthy to me.
I don't do no web, thankfully. I'm all about desktop apps. Do you use SWT or something else in Eclipse RCP?
SWT and jface
You may then like [Spincast](https://www.spincast.org/), which goal is to be as straightforward as possible, and favor configuration over convention.
Spring üÜíüÜí
The webdev guys at my company want to replace all of our Java backend services with JavaScript. They LOVE Netflix, and are always passing around articles to management showing that Netflix is replacing their Java microservices with Node.js. Is this some indication that those other articles are misleading/bullshit? Or are the two conversations orthogonal... Netflix is making some moves here with their Java services, but those are indeed a shrinking slice of the pie over there.
Removed as **spam**.
I always wanted to try SWT, but I'm too deep into JavaFX these days.
What about the "revert current file dirty changes?" I couldn't figure that one out even with a ton of googling, which is a feature I use quite often in eclipse, like multiple times an hour.
If they exist, but yes, you can switch to that, which did help quite a bit.
I would add that IntelliJ's windowing/views system is an absolute wreck compared to eclipse. Half the time you can't tell where to click in order to change the size of an area. Eclipse has a 100% locked down consistent system because every view uses the exact same UI framework. If I had never used eclipse, then maybe it wouldn't be a big deal.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Can you return the \`.volume()\` from the benchmark method? The returned values get consumed by the blackhole, so the compiler cannot optimize it away completely. Though I don't think it matters very much in this case with the constant WHD values. 
Ctrl+Alt+Z opens the revert dialog. Just press Ctrl+Enter do revert the selected file which by default should be the one currently open in the editor.
[removed]
There are a lot of swt/Jface books. I have a bunch. You can contact me if needs
Not sure how London JUG is run, but at least the one I occasionally attend, Toronto JUG, tends to focus more on presenting the latest Java related technology and networking between professionals. I think it's a good place if you're interested in learning new things, but not suitable for posing beginner questions.
I tried (unsuccessfully, unfortunately) to reach out to maintainers to open up the project since there were attempts from atlassian and other external contributors but yes, it's practically dead.
I'm sorry to hear that your company and teams are so badly organized that they have trouble communicating what IDE version they are using for what project.
What is considered commercial is tricky. Oracle doesn't make that crystal clear. You should probably do an internal assessment to see what you have and what you use. What you find out will help you decide whether you should switch. Good luck! 
https://medium.com/@javachampions/java-is-still-free-c02aef8c9e04 Oracle's build of OpenJDK is not, but there are other builds.
We're changing to use RedHat's build of OpenJDK. They're supporting Java 8 for a good while, and where possible we're moving to Java 11 and upgrading with each new release. Other possibilities are Azul, or AdoptOpenJDK.
Very helpful! Thanks for the insight.
&gt;nor will they back port fixes to older releases. The J[ava support lifecycle](https://yawk.at/java-support/) page doesn't seem to agree, and I believe AdoptOpenJDK has said that partners like RedHat, IBM, and Amazon are stepping up to backport fixes to the OpenJDK LTS versions. Is that wrong?
That was a really interesting talk, thank you for posting.
Man, that talk super interesting. I supposed, depending on how "micro" your micro-service is, keeping them single threaded could make sense. Could you keep the multi-threading and use something like Disruptor (or and low latency ring-buffer) to handle your concurrency? I generally try to avoid parallelism until it's needed anyway, but some problems do lend themselves nicely to parallel execution.
[removed]
AdoptOpenJDK will just do builds, which your link agrees with. They expect someone else to do the backporting effort, which the rest of your comment agrees with.
Oracle's OpenJDK builds are free to use commercially. The Oracle JDK is not. They are built from the same codebase and are functionally identical (with cosmetic differences).
They would have waited another 5 if you didn‚Äôt upgrade 
Really interesting talk! I do have a couple questions: 1. Why is a CharSequence easier on the garbage collector than a string? 2. It seems that much of the challenge of making Java work for low latency systems is around minimizing heap allocations to minimize the work done by the garbage collector. As you said, minimizing heap allocations requires expert level knowledge. Have you seen anyone in this space using the [Rust programming language](https://www.rust-lang.org/)? It doesn't have a garbage collector, in most cases makes heap allocations explicit, and at the same time provides some correctness guarantees with the aim of making the language more productive to write than something like C++. 
[removed]
I hadn't realised that. There's no updates after the next release, correct?
The commercial version is for companies that want commercial support. RedHat is also selling [commercial support](https://www.redhat.com/en/about/press-releases/red-hat-introduces-commercial-support-openjdk-microsoft-windows) for OpenJDK. You are free to sell support for the OpenJDK too if you like. Does that mean Java isn't free now? OpenJDK is GPL + Classpath Exception. You can use it for free, forever, and in your commercial products. Oracle even provides a free (GPL+CE) OpenJDK build [here](https://jdk.java.net/). [Stephen Colebourne said](https://blog.joda.org/2018/08/java-is-still-available-at-zero-cost.html) it very well: A key point to grasp is that most JDK builds in the world are based on the open source OpenJDK project. The Oracle JDK is merely one of many builds that are based on the OpenJDK codebase. While it used to be the case that Oracle had additional extras in their JDK, as of Java 11 this is no longer the case. Hope that helps OP. There have been a lot of unnecessary "scare" posts about Java by blogs looking to generate clicks and sow FUD about Java. We're all doing fine here.
Nope, I don't observe any such slowdown. The memory model has no requirement for preserving repeated reads on a non-final field within a loop. Since there is no "happens-before" relationship, if another thread were to write to that field, the reading thread is free to observe a stale value for an indefinite period of time.
Oracle won't be putting in any effort to update OpenJDK releases once a new release is out. Other entities will almost certainly step up to continue the work.
Nah, it was an easy fix: "use IntelliJ". Done and dusted, but good try at being edgy about problems from years ago. /plonk
What do you mean it is tricky? If you download the [Oracle JDK builds](https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html), you need a license to use them in production. If you download the [OpenJDK builds](https://jdk.java.net/11/), you can continue to use them in production for free.
Note that there will still be two quarterly updates released by Oracle, such as 10.0.1 and 10.0.2 in the case of Java 10.
Ah, got it. Thanks.
You have **spammed** this to several subreddits only to **self-promote** your blog. Phrasing the whole as a question is a clever move, though. Yet, you need to read and follow the [reddit rules for spam and self promotion](https://www.reddit.com/wiki/selfpromotion) which you have gravely violated by **subreddit flooding**. Consider this a formal warning. Further spamming or flooding will lead to a permanent, irrevocable ban. **removed**
This is what I find lacking in IntelliJ's advocacy. You have 9 pros, but 6 are just "better X". The others I don't even understand. Back in the day, someone showed me Eclipse, showed me quick fix, jump to class, etc. and I was sold immediately. Every time I see a post about IntelliJ... is "it's just better". Or sometimes I get shown a magic feature... which I already have in Eclipse. Or something which I'm not going to use (maybe because I'm very used to Eclipse and it's "gaps"). I've tried IntelliJ/Android Studio a few times, watched co-workers use it... but it doesn't do it for me. 
It wasn't even performance critical at all. In that particular example it was just gathering optional statistics for us developers that could be scheduled to run at midnight.
Looks like [Nicolai Parlog](https://blog.codefx.org/about-nicolai-parlog/). He has a blog post on the same topic [here](https://blog.codefx.org/java/java-11-migration-guide/).
Still (forced) to work with Eclipse here. My main issue is that plugins are break very quickly and updates are PITA. Without plugins Eclipse feels very unfinished. Sometimes Eclipse breaks in ways that needs full new installation. Builds are incredibly slow in large projects. They are not really coupled to Maven builds too. It doesn't use the Java compiler, but it's own. Annotation preprocessing is like a manual step. This hurts when working with Lombok, mapstruct, etc.
Thank you for the answer. That sounds horrifying. I hope this release solves at least some of your problems.
If this is a joke, then it‚Äôs pretty good. If not, then ...
JUGs are driven by community. So if there is interest in basic then there will be basic. LJC ran beginner workshops last year, we have Java101 slack channel. We have a group "meet-a-mentor" which is close to LJC and we have study groups for different topics.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Why is a CharSequence easier on the garbage collector than a string? `CharSequence` is an interface. They made a custom implementation of `CharSequence` that was backed by a mutable byte buffer (which could be backed by an array, off-heap memory, ...). This implementation is better from a memory standpoint because the buffer can be modified in place, or the scope of the view can be changed, without having to allocate a new String object.
CharSequence is an interface that provides some methods normally expected from a String. It is implemented by String so you can easily change your codes to accept/return CharSequence's instead of Strings. However you can supply your implementation of CharSequence that uses less Java heap memory, e.g. by keeping actual characters in a DirectByteBuffer instead of char\[\]. &amp;#x200B;
Very open ended question, you want the problems that they solve or the problems that can arise? End of the day micro-services don‚Äôt really reap there benefit in small projects but if your project is big with lots of data sources and moving parts or part of a large ‚Äúinformatics system‚Äù there is no other way to go.
What a great story! After reading it I wanted to do something similar on JHipster, so we have now doubled our bug bounty program, that's $200 per bounty! See all information on https://www.jhipster.tech/bug-bounties/ Happy Open Source coding, everyone!
Would you mind clarifying what you mean by this? Why would one have to pay them money?
But that's before the release of, say, 11 in your example?
Correct. In terms of 11, 11.0.1 is already out. 11.0.2 should be out sometime before 12.
You can just add synchronized to the method signature. The only real problem is with interfaces as Java probably enforces the synchronized state to whatever the interface method signatures declared(as it probably should be).
Painful as always, but required due to circumstances like team size, geolocation, clients. In computer science, you can solve a problem with an indirection, but is very likely to arise a different problem: Tracing problems for example.
Adding `synchronized` doesn't magically make a class or method thread safe.
That sounds feasible. The easiest way would probably be to use javac to compile the source code, Java‚Äôs ZipFile API to create the jar, and a custom classloader to load the code. You could probably also skip the ‚Äúbuild a jar‚Äù step and just directly load the .class files
[Yes it does](https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html) but it's very brute forced. Blocking an entire object vs a specific locking object. 
Check out the `java.compiler` module and in particular the `javax.tools` package. That will get you programmatic access to the compiler.
Being thread-safe can be much more subtle than requiring that calls are serialised. Depending on exactly what you need for it to be thread-safe, `synchronized` may not be enough. The document you linked to even refers to one such problem in that it 'can present problems with liveness'.
What do you mean by thread-safe though? This is a subtle term, which means different things to different people in different contexts. You can't just put one massive flag that says 'thread safe', and we do not know in general how to check a method is thread-safe, so we cannot add that to Java today.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
*can be* really is the phrase. Synchronized methods are purely a brute force way of thread safety. Yes, liveness can and most likely will be impacted by such brute force ways of doing things. I never argued otherwise. That said, synchronized blocks are purely implementation specific and have little to do with the method declaration. If a method that isn't declared synchronized is thread safe then it should be **documented** as such. 
You‚Äôre mis-understanding me - the concept of thread safety may need to be more subtle than just meaning serialised calls, which is what synchronising methods does. A synchronised method may still not be thread safe.
Hello! Using java for backend and JavaScript on front could work like a charm for sure. But it really depends on what actually you're going to build. I mean, a game like wow? Maybe java and javascript are not the best choice for it. There are incredible gaming engines using c# and c++ more proper for this case. For apps based on more simple use interactions (I'll assume you meaning mobile apps, as you mentioned android studio), there are lots of options using js and java. You develop the front end using ionic and back in java. Or react native for front and back in java. If the app is simple enough, you can just stick on js, building backend in node, or even firebase. If you need something more robust, native development using java only, or kotlin is probably the best option. As you can see, there are lots of possibilities. It's probably better to stick to one language and try to focus on it, building solid bases, and then moving to the advanced frameworks. Js and Java are great languages, chose the one that fits more your profile. If your goal is game developing, well, you could consider c++ and c# (search about unity and unreal engines). Don't be overwhelmed, go ahead and explore, until you be able to build any app that you want. 
Thanks bro
If you're already going to build a mobile app, I'd recommend writing native code and not a JS hybrid/web frontend. Refactoring and growing a large source base in JS isn't pretty. Pretty much all languages can work side by side over a HTTP API, process call or what ever. If you want to build any Android app, you'll need the Android SDK to compile it for you.
&gt; js will be good for me to learn cuz i want to build a desktop game like wow down the road JS is a web language. You aren't going to be building games with it. If you want to make desktop games, JS is the worst choice.
I'm still not quite sure what classifies as a microservice...
As others have been saying, JS isn't the best choice for coding games. However, if you are interested in making an app using JS, consider React Native. [https://facebook.github.io/react-native/](https://facebook.github.io/react-native/)
Sounds like you guys have a nice setup. I'll take a look at slush thanks!
Oliver, I want you to know that Spring is obviously a very good framework. I'm just one guy with an opinion. I wouldn't take it too seriously because I know tons of people use Spring with no problem every single day.
The GPL was what was usurped by Wikipedia. 
I would recommend the javax.tools package it's always been a lot easier to work with for me. Specifically the JavaCompiler class. https://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.html
I read "Microserivices in action" and authors give us some advices to define a microserivce. Check it out.
Me too. I have a problem with building an auto API document.
I don't even understand why you'd need a strictly defined IDE version for a project. Hell, some projects at my workplace are developed in IDEA and Eclipse simultaneously, by devs with different preferences.
What, you never Ctrl+Z one time too much?
&gt; Eclipse's dark theme has always sucked, I don't know if they ever fixed it. I hear it's gotten way better in the past 2-3 releases, i don't use it myself though.
Now that you say it... I actually do use it, but I naturally use Ctrl+Shift+Z because that's the concept behind IntelliJ's shortcuts - shift modifies them. Ctrl+N searches classes, Ctrl+Shift+N searches files. Ctrl+F searches in the file, Ctrl+Shift+F searches everywhere. Using shift for Ctrl+Shift+Z is even better because your finger doesn't have to leave the Z.
Yeah, Ctrl+Shift+Z is unarguably better. It's just Ctrl+Y is too ingrained after using Windows for so long that i automatically go for it.
You could look for the `@javax.annotation.concurrent.ThreadSafe` annotation, that's exactly what it is for - it's part of the FindBugs JSR-305 package: [https://static.javadoc.io/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/concurrent/ThreadSafe.html](https://static.javadoc.io/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/concurrent/ThreadSafe.html). This can be used by tooling to check for thread safety, I don't know how much it is used in real life.
Thanks, I did not know about this.
It's worth pointing out that JSR-305 did not pass the JSR process and is therefore not an official standard. It doesn't mean that there not useful annotations in the findbugs JSR-305 library.
Essentially you want to dynamically create a plugin at runtime, then load it and use it. Yes, very possible. You can use any number of tools to "write" the java code, a few ways to compile it, and like another comment said, you may not even need to jar it up, just build the classes in the applications classpath, and/or, using a custom URLClassLoader, load the classes up. &amp;#x200B;
Sure, and they were _able_ to do that because website content is stored in a centralised database so no one could fork it. If you were talking about the source code of the Wikipedia website, and it was available somewhere in a repository somewhere, then someone could definitely have forked Wikipedia and made their own alternative. In fact, the MediaWiki software that Wikipedia is based _still_ is available via the GPL. On an unrelated note, software licenses are not really appropriate for other kinds of works.
JavaScript and Java can work side by side. The most common way this is done is with a web application where the front end is created with HTML, CSS, and JavaScript while the backend (a server the application connects to) is written in Java. As others mentioned, Java isn't the best language for gaming. C++ and C# are much better, but that doesn't make it impossible. Minecraft was coded almost entirely in Java. Java can do a lot more than just backend. It comes with a library called Swing that is good for simple front ends. Minecraft was built with an API called OpenGL that is one of the best (AFAIK) ways to build a 3D game in Java. The way I see it, you have 3 options to choose from: 1 - if you want to build web apps, learn JS and use Java for the backend. 2 - if you want to create mobile apps, stick with Java. 3 - if you want to build an MMO or any desktop 3D games, you might be able to make something decent with Java, but consider learning and using C++ or C# (the latter is more similar to Java and probably easier to work worth).
You're not paying attention to the issue. They decided not to follow copyright/licensing law/terms with no repercussions. This was thought impossible, but it happened. 
The answer is one of my favorites: It depends. It *might* be necessary (customer imposed restriction, technological imposed restriction, etc.). But overall, I agree with you there that a project should be independent from the IDE.
Sure, but the case you're bringing up still doesn't apply in this one because you can't retroactively change the license of source code that already exists. The worst that could happen is that Oracle proclaims that every future version of Java is closed source, and what will happen next is that Red Hat will take the old GPL-licensed code and fork it.
Eclipse and Netbeans are both great 
The main answers your going to get are * IntelliJ * Eclipse * Visual Studio Code * NetBeans Some of them may be overwhelming for a beginner. In some respects, like the best camera is the one you have on you, the best editor/IDE is the one you know well, so try a bunch, pick one you like and then learn it very well, because you'll be using it a lot.
No it doesn't. Two instances of different types each mutating a shared map running in different threads. Adding synchronised here will do diddly squat.
Eclipse because what I call the .intellitype works extremely well. Intellij is great but it seems less eager to please on that front. Jcreator and netbeans are the only IDEs I know I consider actually inferior.
Best answer really. 
Just a comment on distributed locking. It's not completely deterministic due to GC pauses and system time changes. It's worth having a fallback in place for when two children promote themselves to master.
I have had the pleasure of listening to a few of Peter Lawrey's talks, and this one was just as good. Do you have any tips on how to get started in the low latency industry for someone that works mostly on web apps/services(financial services/payments). 
FYI looks like your reddit account is shadowbanned.
What happens if multiple children see that the lock is expired? &amp;#x200B; I am biased, perhaps for good reason, against MongoDb. What's the decision for going against a proven SQL database like PostgreSQL
Well thank you for the thought out post! Will definitely try them out and choose from there, really liked the camera analogy :P.
## How much is a bug bounty? At the moment, each bug bounty is $100 for the person solving that ticket.
A good tip if you want to know what people do in X language, is to google for X ecosystem survey 2018. You can find not just IDEs but insights to all sorts of tools and trends. https://www.jetbrains.com/research/devecosystem-2018/java/
The problem with @ThreadSafe (as with all annotations) is that it is merely considered additional metadata and is not enforced anywhere by the runtime. The best definition of @ThreadSafe that I've heard is: "The author of the code believes that it is thread-safe". That is an awfully long way from actually being thread-safe. You may want to look at something like the Mutability Detector: [https://mutabilitydetector.github.io/MutabilityDetector/](https://mutabilitydetector.github.io/MutabilityDetector/)
Can the worker nodes see the filesystem where the files arrive? If yes, do not use any other channel to communicate with them - instead do all the signalling via the filesystem using standard old-school Unix techniques and the semi-atomicity of low-level Unix FS operations. If no, then how will the worker collect the file for processing? E.g. Are the files too big to be sent over JMS directly? As the design stands, you have 3 independent pathways: * Asynch notification mechanism (JMS) * Data delivery (??? - how do the workers actually get the file bytes to process) * Distributed locking (currently proposed as a database) This is too many. These types of solutions can be done with only 1 mechanism (in the case where the workers see the filesystem directly, or can scan it) and with 2 (the case where the workers don't have direct access to the FS). &amp;#x200B;
I'm providing 2 examples of things previously thought to be legally impossible, that were in fact done. I'm not saying this is likely. I'm saying it's not impossible. "Impossible" things happen. I gave 2 relatively recent examples. I'd bet my life that Oracle doesn't bother to try. But if they did, there is a miniscule chance that they'd pull it off even if it would be pyrrhic victory.
[removed]
[removed]
As /u/PurpleLabradoodle mentioned, your `@Benchmark` methods (`plain` and `dataStructure`) should return `ParametersCuboid` to make sure that the computation is not optimized away. Source: [JMHSample\_08\_DeadCode.java](https://hg.openjdk.java.net/code-tools/jmh/file/66fb723292d4/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_08_DeadCode.java)
&gt; i want to build a desktop game like wow down the road WoW was developed by ~100 developers over the course of 3 years. It is physically impossible for a single person to write a WoW clone.
Although that's a survey by JetBrains so it's very biased.
Eclipse, because it is one of the two most commonly used JDK (with IJidea they both has about 90% of the market, so they will always have good tips and are always be standard) and its free (instead if IntelliJ). Others JDK imo are very niche
Out of pure curiousity, how much can a java hit programmer earn? As an average in London?
This @#$%\* comment every time. Is it some kind of folklore?
No 32-bit? Why are we using java again? So disappointing :(. So I'll have to reinstall my battle proven nb because of eclipse? No way. And 64-bit java is a memory hog anyways.
I used to use Eclipse but about a year ago we converted to IntelliJ, which is awesome but expensive. I'm experimenting with VSCode plus a few plugins for Java &amp; Spring lately - it seems to do most of what I need. Has anyone had much experience with IntelliJ IDEA CE &amp; Spring Boot? Is it sufficient, being as Boot includes Tomcat in its output jars?
https://medium.com/@javachampions/java-is-still-free-c02aef8c9e04
Us it really worth it cache preparedStatement? Are they expensive to create? 
Yes, it's worth caching them.
I started with android studio in college learning java for the first time. Then got curious about desktop java and switched to intellij. I wanted to do some ee stuff so I tried out eclipse. Think I liked it about the same as intellij. Felt equally big. Had great features. But then on a wild hair I tried netbeans just to see what was what. And to this day that's what I use. It recently got donated to Apache and has been being updates for a lot of modern stuff (Jdk 11, and all the other languages it supports, like php etc...). It is really an exciting time for netbeans I think. Netbeans feels lighter than the major two options (intellij and eclipse) and doesn't really make the same project assumptions. You kind of get to just so what you want. There is much less setup and management required with workspace and such unlike the other two. Gradle is usually what I'm using too and it has been a delight with netbeans. 
Eclipse and NetBeans are the most used ones for Java. I prefer Eclipse 
Install a set of Kafka brokers and use consumers in one group to process the files. Kafka takes care of leader election between the brokers. Import the file via Kafka Connect so they're available as messages on the Kafka for the consumers to work on.
We use Microservices and I can tell you the following: * If you do not need it, do not use it. If you do not have scale problems (real problems!), I would suggest using a simple monolith first with a good design and split off the services if needed. * You will have an overhead, because you need to define and update your (REST-)Interfaces as needed * Microservices is in the first place an organizational approach to split teams
Yeah others told me, if someone wants to take the code and do something with it; go ahead. My primary goal was to show the OP how a JMH benchmark would work. 
JPPF ? https://www.jppf.org
Could use hazelcast with a distributed lock. Whichever node grabs the lock first, becomes the master and assigns the work. If it dies, the lock gets released and the next node obtaining lock on it becomes the new master.
When a mutable property is accessed in write without any synchronization, then it is not Thread-safe. One single write, and all the reads have to be synchronized everywhere in the code. The easiest way to achieve Thread-safety is through immutability of the used data (final keyword). This guarantees that the same memory won't be accessed by multiple threads. The only downside is it can create race-conditions (irrelevant in most use-cases).
Sure, I should've mentioned that you did a good job by providing a JMH benchmark at all (sorry about my missing that point)! I primarily wanted to be more explicit about how it could be improved, and I wanted to cite the source (JMH samples).
Probably not, read [here](https://github.com/brettwooldridge/HikariCP#statement-cache) for example. Also modern databases usually cache execution plan anyway I think, but I have nothing at hand to prove this ;)
Brett Wooldridge talks about caching at the connection pool level, not the JDBC or database server level. &amp;#x200B; And, only commercial databasesdatabases offer an Execution Plan cache. PostgreSQL and MySQL don't offer that.
Could you share the slide at youtube? Thanks.
I love these talks, lots of wisdom and clarity. What are your favorite books about system reasoning ? measurements .. design. Also have you made other talks ? or any other presenter you found worth watching ?
I mean for Java SE models, it's not clear which tools are considered commercial tools. You can use the Java Usage Tracker to see which commercial tools you are using but a lot of people don't realize that the tracker is a commercial tool itself. So if you use it, you should be paying
If micro services add value to the end user, then they are interesting enough. Job satisfaction should be tied to providing value to end users, not playing with the latest buzzword technology. 
Also it's worth noting that Eclipse has historicall been the most popular, but these days it's IntelliJ. I think most teams would just let you use whatever IDE you prefer. At least mine does.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No. Job satisfaction comes from where you fee most satisfied with your job. You can‚Äôt tell people where their job satisfaction should come from.
Your question isn't about a shitty CIO, you ask "are building microservices interesting enough?". If you care about your company and its customers, it doesn't really matter if it is interesting enough. If a micro service would provide the best value for the customers, you build it. If that doesn't give you job satisfaction, maybe you should re-think being a developer? 
Will you accept the answer that you're not good enough? Don't get me wrong, of course development in general requires skills and (in my personal opinion) a lot of knowledge related to IT in general, but I feel like Spring is super easy for start, assuming you don't have to start with development of super complex system. If you start with simple system with simple domain, it's hard for me to think of easier framework. The other question is - do you have the knowledge related to pure Java, HTTP protocol, databases, application servers, multithreading and parallel computing, etc. Those help ;)
&gt;Is Java difficult or am I not good enough? Java is difficult. It is a full programming language. People who have the mindset of hobbyist scripters will feel overwhelmed. You are good enough. With all of the things you mentioned, even professionals need to invest a lot of time in learning and getting used to those things. &gt;maybe due to the cause that everything was crammed to us within a week Bingo. Faster in and faster out. Unfortunately the only way to truly learn a language is to do the reading at a reasonable pace and code in it for a sustained period of time. Sort of like a human spoken language. You need sustained and a lot of practice.
A) Not my question. B) You really don‚Äôt seem to understand what job satisfaction means. You get your job satisfaction from building software for your customers, that‚Äôs your opinion. Other people get their job satisfaction from building interesting software, that‚Äôs their opinion.
You are getting introduced to many new concepts at the same time. Understand Spring first. May the force be with you.
Thank you! That really boosted my self confidence. 
Thank you! I really to work harder I guess. 
"Are building microservices interesting enough?" is not your question? Why did you make that the title of your post? I completely understand what job satisfaction means. It is different for different people. From my experience, developers that get job satisfaction from building software for your customers are developers that release software that make their customers happy, therefore make more money for the company and themselves. They get the job done. Developers that only get job satisfaction from building interesting software don't deliver, spend lots of times arguing about which new tool to rewrite their application in and are not as productive. They are never satisfied with their job. There is always newer technology they want to play with and they avoid boring stuff that must get done. Customers aren't as happy and the company makes less money. I know which type of developers I hire and which ones I don't. 
Don't worry there are a lot of people in IT who will try to rip that confidence back down :). Also a lot of programmers with dark humor. *cough*. Get good books on those subjects to go through on your own, at your own pace. Use the Internet for questions you can't find the answers to in books or via Google. 
Hah, how does this scale? I have so many questions! - Will there be a contract between each party? - Who are the parties (in terms of legal entities)? - Will the parties respect all sorts of individual double taxation treaties? - If one of the parties is U.S. based, will there be W-BEN and similar documents filed? - If two contributors submit a PR at the same time, who will get the bounty? - Is it possible to form a contract based on arbitrary acceptance / rejection of a PR? - Is acceptance / rejection of a PR a timely limited thing, i.e. can the bounty expire before the PR is merged, and the PR (submitted in good faith) can still be merged? - Are PRs that are not yet merged already ASL 2.0 licensed? Because if they are, that would allow for the PR to be merged without any right to receive a bounty. (Heh, I was bored...)
Sorry, I didn't mean to set off a fight. I am just try to gather people's reflections. I agree that product is important and should drive what technologies one employs in production. I think the essential conflict is related to "product engineer" vs "technical engineer". Each profile brings something to the table. TripleByte defines terms like "product engineer" in their blog.
It's not a matter of if you will be confused by new stuff and tough problems -- all developers experience that. It's more about how you react to the feeling. You should not be depressed by it but it is a signal that you need a bit of extra focus to move forward.
It's more about gaining experience. Build some simple test projects of your own. Learning by doing.
&gt;(REST-)Interfaces this means you built a module to connect to your microservice like the way JDBC provides a module to interact with database? (sorry because of my English).
I am the original person posing the question. The other person was just responding to your comment. I hear you on delivering and I am sure we have all seen the scenarios you mention. I think technical focused programmers need to have self awareness and discipline to offset getting derailed from the product goals. I wouldn't dismiss all of them.
You didn‚Äôt start a fight, this knucklehead just thinks people in toothpaste factories should be satisfied with their jobs just because toothpaste gets put in tubes. It really varies person to person (and for me, week to week). Sometimes I‚Äôm working on interesting stuff and couldn‚Äôt imagine being anywhere else, sometimes I‚Äôm working on essential stuff and it‚Äôs mind numbing. In the mind numbing moments, I try to find my job satisfaction through figuring out how to improve our systems so my team does less mind numbing work.
Once again, not my question. Your lack of attention to detail is astonishing.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I‚Äôm with this guy. I get the nuance that‚Äôs being argued here is about where someone gets their job satisfaction vs. which type of engineer would you rather hire. For myself, I get the satisfaction of playing with new tech. I do that on my own time because my number one priority at work is to add value to the business by making the right technical decisions. 
Yeah, I can agree to that too. Just don‚Äôt think it‚Äôs correct for this guy to confuse ‚Äúwhat makes someone a hard working employee‚Äù vs ‚Äúwhat makes people satisfied with their jobs‚Äù
Yeah, it‚Äôs definitely shouldn‚Äôt be a blanket statement. This last year I had one engineer who was arguing to use react with the other front end engineers. When asked why, his response was, ‚Äúit‚Äôs 2018.‚Äù I had to explain to him that‚Äôs not how to argue a point that‚Äôs going to lead to changes.
I personally get extremely frustrated by every company using microservices these days. Microservices are very difficult to plan out and maintain and most companies shouldn't need them to begin with. There are a lot of tradeoffs using them and people rarely focus on the negatives. A lot of my jobs have been spending a lot of my time solving performance issues / race conditions in distributed systems when it didn't make sense for that system to be distributed at all.
The point of managed languages like Java is to lower the entry barrier to make it accessible to the maximum number of developpers possible. That being said, coding your first java application with all the popular frameworks - Spring, hibernate, etc - on top of that can be pretty difficult, yes. Plenty of new things to learn at the same time. If using Spring boot is acceptable you should do that, and use the tutorials availables on the spring site for JPA stuff.
If you don't mind learning by watching videos, I can recommend [this Udemy course](https://www.udemy.com/spring-hibernate-tutorial/) that covers Spring MVC and Hibernate. It might help you if you're looking for the absolute basics on where to start.
Yes tons of stuff, but many of those questions can easily be answered: - This is done using https://opencollective.com - so the legal entity is Open Collective, to whom you send an invoice, and yes you need to pay your taxes (we wouldn't do anything illegal). If you are in the US, OpenCollective has a legal entity there. - If two contributors submit a bounty at the same time, the rules are at https://www.jhipster.tech/bug-bounties/ - There is no timely rejection of a PR. We need some time to reviews PRs, so that can take time, that's all. - Everything we do is ASL 2.0 licensed, so if your code is not, then it shouldn't be merged, and then you shouldn't get the bounty. - There is no contracts between parties, just an invoice which is sent to Open Collective. Then we've been doing this for some time and everything is public, and you can see from https://opencollective.com/generator-jhipster/expenses we do pay the bug bounties.
It depends, yes if you are outside of the general computing purposes use and/or if you use ANY of the commercial features like the tracker. Check this out https://upperedge.com/oracle/using-java-heres-how-oracles-new-2019-java-se-licensing-affects-you/ 
You should be looking at it from the other way - thread safe should be the default behaviour and methods/classes that are not thread safe should be explicitly identified (perhaps by a @NotThreadSafe annotation)
It looks like in your [submission](https://www.reddit.com/r/java/comments/a8bxkl/help_me_with_this_why_all_statements_are_not_true/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It's not easy. If it was everyone would be able to do it. :) You're special ... you're one of us! You will succeed! Don't give up! Part of being a good programmer (especially in the world of Java and Spring) is being diligent enough to work through all the problems and make it work. Tip -- try to break things down into simpler manageable parts, and focus on small specific issues. When you gets stuck ask online ... here, /r/javahelp, and stackoverflow.com Good luck!
All of the tools, like Java Flight Recorder and Java Mission Control, have been open sourced. There are no differences between Oracle JDK and OpenJDK, so I assume most will use OpenJDK unless they need support.
Java is hard, and Spring boot/JPA+Hibernate is a completely new paradigm for you I assume. Learning those 2 frameworks is a lot more of a pain in the ass than people give it credit. Weird cryptic errors that don't make any sense and no one can answer in the hibernate gitter...weird DI behavior etc. Good luck man it's not easy but the only way to learn it is to jump in with 2 feet and learn one error at a time. 
Not to mention the first few times you do code review with your boss or whatever that shit is gonna sting. Just understand a lot of the criticism you're gonna receive is intended to make you better not tear you down. Someone combing your shit line by line as you're starting out well....it's gonna be preeeetty brutal. 
&gt; Spring boot and Spring data are designed to be easy to use and to be rapidly productive (but they may be a little cryptic/'black-box'-y for a complete beginner I guess ?). It's funny that I hear that a lot, but still run into weird as fuck errors from Hibernate I have to go into the gitter for. 
While I agree.. it sounds like OP has to learn on the job, and is probably expected to learn at a typical senior engineer pace. Maybe not.. but usually this is what I have found.
I am a senior software developer in a big e commerce firm. I have a good reputation among my peers. I also Google the shit out of a lot of functionality in the frameworks you mention. Make sure you have a good conceptual understanding of which library or framework solves what problems. Don't be afraid to Google which exact function does what. Liberally use code from previous projects and colleagues. You are standing on the shoulders of giants. Don't worry about using this fact to your advantage. Remember how you feel today and look back in a month, three months and a year. You'll be amazed at what you've learned and how smooth you build stuff. Good luck and don't forget to enjoy your success!
It's hard creating an app from scratch as well, most places I've worked have you gain experience by making small fixes in a larger codebase, so you can see how things work before you start on anything big
Spot on. I gotta say, as someone thats been in the field a long time, things have changed the past 5 year or so. It is almost required that you learn a lot of things, all at once, many of which are the brain child of the architect/senior/lead who feel it is necessary. While I am all for learning, especially up to date stuff, it is not feasible, especially for someone new, to learn multiple things at once in an unrealistic time frame. For example, Spring alone is as big if not bigger than JEE. It is a HUGE framework, with a ton of different areas covered. That alone is months of learning and using day in and day out to become comfortable with it. And as someone new to Java, there are no doubt language bits you will pick up and start to use more of that you dont know yet as well. But that is just one (albeit large) library. You also have the patterns, like MVC, to learn and then you have to apply those patterns to the library(ies) you are using too. How does MVC fit with Spring, Spring boot, JEE, etc. All of this truly takes well over a year to really learn and grasp. But per my point above, today, for some reason there is this lack of understanding by a lot of managers/leads that engineers, no matter how good, can just jump in an learn it all and then put it to use for business needs right away. There are indeed some people that can learn at very fast paces, but most people I have worked with take some time to truly understand and apply the code, libraries, frameworks, etc. Jumping around to multiple areas makes it that much harder. When I started out, we had front end, back end and DB tiers. The back end was usually more developers due to security needs, db, business logic, etc. Today, the front end has gotten much more complex with SPA, PWA, tons and tons of js/node/css frameworks, components, etc. I find it takes WAY longer to build a web page that uses a back end API that literally takes an hour or two to write, or less if you are using awesome tools like RAML and generated code. 
This isn't an issue with Java as a programming language. The problem is you are overwhelmed by multiple, large frameworks all at once. Developing true proficiency across the frameworks you mentioned requires months if not a few years of learning and practical experience. You mentioned "comprehend" and "writing from scratch" which tells me you are not just wildly copy-pasting code. You may find a few years from now that was a key difference between yourself and some of the people around you who may appear to be making faster progress today. As long as you enjoy what you are doing, I think you are off to a great start !
It can take years to get comfortable with all of the big frameworks, so don't worry about it. Take them 1 at a time.
Wow! Thank you for all your comments. I never thought this community will be so supportive. 
When I wrote the comment you are replying too I did not have code reviews in mind. Being interested in code, I have always found those interesting. I was thinking of all of the negative, cynical, and hurtful people I've met in IT over my career. When I was interviewing for one of my first jobs out of school I had a guy in some company tell me what a horrible field it was, that I should give up unless I wanted to be forever unhappy. I've had a lot of tech interviews where I was treated poorly once it became clear the job and I were not a good fit. I also thought about all of the low EQ people I've met in the field who have been hurtful or who tried to cut people down to ease their own insecurities. Do not get me wrong. I have loved my career, many of the jobs, and people. Its been a good time. Nothing in life is perfect, and I did meet a number of people I could have done without. /u/s_131 would better off knowing that he will meet some of the best people in IT, but also some of the not so best.
You might look at Apache ZooKeeper/Curator (note: I wrote Curator). It‚Äôs very good at this type of thing. You might use Curators Queues for it. If you want to see any example you can look at this library I wrote that does task management. It might even be a solution for your needs: http://nirmata.github.io/workflow/
Hazelcast has important consistency problems: https://jepsen.io/analyses/hazelcast-3-8-3
As you already have fair knowledge on core java and currently working on spring based application, I would suggest you to do two things one at a time. 1. First buy a good video course on udemy on spring from one of the below authors. They are equally good. Ranga karanam, John Thompson, Chad Darby, Tim Buchalka. [https://www.udemy.com/courses/search/?src=ukw&amp;q=spring](https://www.udemy.com/courses/search/?src=ukw&amp;q=spring) 1. Buy a good book on spring. I would suggest 'spring in action' by manning publications, 'pro spring5' and 'spring 5 recipes' by apress publishers. [https://www.amazon.com/s/ref=nb\_sb\_noss\_1?url=search-alias%3Dstripbooks&amp;field-keywords=spring+framework&amp;rh=n%3A283155%2Ck%3Aspring+framework](https://www.amazon.com/s/ref=nb_sb_noss_1?url=search-alias%3Dstripbooks&amp;field-keywords=spring+framework&amp;rh=n%3A283155%2Ck%3Aspring+framework) &amp;#x200B; I would suggest you first start with video course, that way you will be engaged with a group of developers by posting questions in the course forum and see the questions/answers by other developers and you know video courses keep you engaged throughout your learning process. After you completed the video course, start reading the book. The video course helps you in a good start and a good book helps you in deep dive into the topic. All the best. &amp;#x200B;
Understanding the underlying functionality of Hibernate can be a real pain. As a DBA developer, understandably, having all the dba work done for you is a real change of pace.
Okay, take a deep breath and relax. A college fresher would just know about writing Java code, no design patterns, no frameworks knowledge unless you used it before. I would say read \`Dependency Injection\` (Inversion of Control) first. Read its benefits: (Makes unit testing easier, decouples monolithic code) As someone said in comments, understand Spring first before going into JDBC. It's a good learning curve and be patient, spring annotations(XML) are unnecessarily made complex. You could investigate about Guice as well. &amp;#x200B; Try with some Spring starter projects and tutorials on youtube. 
You're trying to get used to a language with over 20 years of additional features *and* a whole lot of separate frameworks, each with conflicting views about how systems should be structured, built over much of that time. It's going to be a lot of stuff. All of that in a week? Yeah, that's not going to go well. It should get better if you try to focus on the parts you actually need soon, and then work through each part of a simple example until you feel confident with each step. 
\&gt; There are a lot of tradeoffs using them and people rarely focus on the negatives. The best way to bring this home when people are in the planning / deciding phase is to make people read about Jepsen and testing, and figure out whether they want to open up that difficult topic or avoid it. It could be a good way to test how important microservices really are to the business problem.
I started at my company as an intern and was lost for a long time. A lot of it comes from repetition, as I don't learn from videos/tutorials very well. I learn better from hands on work. Just keep practicing and you'll get better.
One of the major strong points of Java is that it is 'easy' I don't know what is difficult about Java tbh, I mean, it has a GC and it reads like a book. 
This has nothing to do with Java. *Programming* is difficult, especially in the real world where you have to deal with complex and changing requirements (and other factors) that lead to overengineered legacy systems. I have over 15 years of industry experience, and I *still* frequently feel overwhelmed, and confused when I have to start working with a new system or new technology. Better get used to that feeling, it will never completely go away. The trick is to accept it, but keep the unshakeable faith that every problem is solvable, you just have to keep thinking of ways to get new information about *why* something is not working, and narrow things down until you know why. In some cases you just have to start debugging into the framework code.
I'd go for a state- and master-less approach until you really need advanced coordination. Just let all the worker processes grab random files to work on, e.g. by atomically renaming the file to a worker-specific temporary name. If that fails because another worker hat grabbed the same file first, just ignore the error and continue with the next random file. If there are no files left, sleep a random amount of seconds, so the workers won't wake up all at the same time. A (successful or failed) file system rename operation is probably an order of magnitude faster than any solution with a message queue or database, and way easier to implement, maintain and debug. Start easy, add complexity later. 
The Gluon scene builder is considered the "latest" one: [https://gluonhq.com/products/scene-builder/](https://gluonhq.com/products/scene-builder/) Basically, Oracle stopped making significant changes to the old one and Gluon took it over. The Oracle one still works, but Gluon is better. I've only made a few JavaFX programs (for utility programs) so my usage of the scene builder was very minimal - mostly just mocking up the various screens to generate the fxml and then going from there... &amp;#x200B;
It also boosted my self confidence, because if other people think Java is difficult, that means I actually know something significant, ha. I did flunk a job interview on Java internals only people with decades of experience or people working with compilers need to know. I'm a full on pragmatist when it comes to building and maintaining applications, with focus on standards. Not that theoretical. I have no idea where I'd use a `final class`, for example.
Scene Builder does a good job for what it's meant for. But I recommend going straight into Java withouth touching FXML or even CSS. It's quite straightforward. You put stuff on the screen and handle events. Feel free to ask any question.
I'm glad I'm not the only one who thinks this way.
If it makes you feel any better, I'm ten years into my career, and I took a few years off Java and Spring and I'm just as overwhelmed getting back into it. I'm overwhelmed but not worried about it, you shouldn't be either.
I remember when was in your position, thought I was the most useless person in the world for a few weeks. After a while I gradually started to pick things up and actually understands bits and pieces. Few years later and I'm the lead dev in our team. So trust me, it gets better :-) 
One week? That's just to get confused. That's like learning one semester material 1 day before exam. Best is to try everything on one little toy project and configure everything by hand and then it'll start clicking in. But it takes months to be comfortable with it.
Thanks for that. I wasn't aware of it.
Ehhh I wouldn‚Äôt say so. A normal ramp up period is several months. Don‚Äôt take your lack of current understanding as an indicator of poor work ethic. Competence comes with time. 
&gt;this Udemy course This course is really really good. Chad is a great teacher, sometimes he goes too slow so feel free to speed him up, but this course took me from not understanding Spring to being able to finish some college courses and build web apps. I don't use spring anymore so not sure how much it has changed, but this will get everything going for you. If you break everything down into individual components, it is less daunting. 
Haven't been around here that long, didn't realize I'd struck a nerve....
[FXGL](https://github.com/AlmasB/FXGL) is game engine based on JavFX.
I get how the whole ecosystem can be overwhelming. The other commenters are right, it is not that you are not good enough. It is that Java and it's ecosystem is not good enough. The ultimate goal of any library framework or programming language is after all to enable the developers to create some working software. The better job your ecosystem does the less complexity your solution will have and with that come stability, extendability, rainbows and unicorns. But do not beat up on the ecosystem too much. If you try something innovative that has not been done before, it is not likely everything will be straight forward, how can it? You are doing something new after all. Also java especially has grown with time and at some places it shows. The band thing is if something looks weird to you you will not know if that is because you missed something or because it is weird to support some theoretical optimisation that was I am sure real important in the 90s. Keep in mind that development is at its heard quite demoralizing: you beat your head against the keyboard to solve a problem just long enough to solve it and find something else to frustrate you. Some people are the right kind of masochists to like this work some are not. Please make sure you are happy with what you do!
&gt;Should I just code the UI? I have no need to reskin the app to a different colour scheme or anything like that. I really like Scene Builder, and how JavaFX allows you to separate your layout (FXML), styling (CSS) and logic (Java) into separate parts. But that's not for everyone, nor is it useful for every project. So no, you do not need to use Scene Builder at all, if you don't want to. You can do everything that's possible with FXML/CSS, in pure Java. &gt;I know that java FX is not really made for games I have made a number of "graphically simple" games using JavaFX. Think Tetris, Zelda, Bomberman, etc.
Hey, I can imagine, having to learn everything in one shot could be very hectic. My suggestion would be to take time and learn these topics slowly. Nobody knows everything so you don't need to feel bad about yourself.
&gt; I know which type of developers I hire and which ones I don't. I think you are right up to a point. Yes, stuff that actually delivers value has has to get done. And it has to be the main focus. But if you only hire developers with no interest in learning something new, you might, in the end, end-up with exactly that. A bunch of old farts abiding their time until retirement and little ambition to better themselves. Not a good mix in rapidly evolving industry.
What?? So many developers have no idea who the end users even are or what they are doing with the software.
You've learned the language but not the culture. You might not be "good enough" right now. But you are good enough to become good enough, and that's all that matters in the long term.
I had one whole year of self-doubts after working 3 years with java. Now I'm 6 years into it and I just love it. Just work through it, you'll get used to it.
Good thing about Java and its frameworks is that they inherently won't let you make major fuckups, everything is super explicit (bar the honorable mentions). Bad thing is, in order to understand how something works, you will have to make it fail/crash/break a lot of times, but this is directly tied to the point above. Sometimes, the path to knowledge is through many failures. 
If you really need some help, you can also join certain java/spring communities or ask the maintainers on Twitter. For instance, Oliver Drotbohm (Spring Data) is very active on both these platforms. 
that enterprise java shit went out with kelly clarkson. it‚Äôs difficult because it‚Äôs awful. 
its not that hard but dont give up if you are with some problem keep trying ech one learn in a diferent time
No, Java is not difficult, and you're probably good enough. When you're starting somewhere new, there's always an information overload at first. Every time, even after 15 years of experience, this is what it feels like to jump into a team project that has been going for years before you joined. You just need to accept this, know that it will pass, stay calm and make progress every day. You're a junior, you're not expected to know very much yet. You still get paid to learn on the boss' time, enjoy it. 
&gt;RIIR Why Rust, when it's going to be an order of magnitude slower than fpga/asic? To use the analogy from the video; If you're going to start over, why pick the fast bicycle instead of the car? The idea that anyone in HFT would even choose rust seems absurd to me. 
Another piece of advice, build your server in small steps: first make it return hello world, then maybe add the layout you want for the page, then make the content meaningful but reading from sample data, then make it read from the database. Concentrating on one step a time will keep you from being overwhelmed and will allow you to show progress to your boss. &amp;#x200B;
From what you've said, you might not be good enough. Buuuut, it is also hard for anyone/everyone in your position. Only way to know which is holding you back is to stick with it (and I mean for years, imposter syndrome is real, you won't even know until years after this job)! 
That's I'd say an indication of bad management / leadership. While you don't want to over-do it, f.e. having a bi-quarterly short market research presentation available internally helps wonders with the feeling that the work is actually meaningful.
I was terrified basically the first 3 years in the industry, thought I wasn't good enough and always felt like I was struggling. Around year 4 things started getting a little clearer and I got some confidence, I'm in my fifth year now and I make about 120k in the Midwest and feel confident about the work I do but it was a long struggle to get to where I felt comfortable with my skills. Just keep the student mindset, there is always more to learn. 
\&gt; we need you to write a large crud system Heh, that's a challenge on its own. Note that performance and latency are always worse in distributed systems when compared to monoliths. What distributed systems give you are: * throughput (as in kilo-updates per second) * ease of change management Of the two, businesses usually will hit #2 before they hit #1 (well, unless they're a startup with a high ratio of traffic growth vs developer count). By that I mean that if you have a full team that manages merges, builds, automated and manual QA and deployments of your monolith, with any given change having a latency of a week or so until it ends up in production - then actually having mostly-independent microservices looks very attractive as they are owned by different teams and can be deployed (and rolled back) with a minute's notice.
Didn't watch the videos but glad you're sharing them. I see people using old school concurrency like a lot. It sorta scares me. You can use the combination of the two with thread safe classes and basically concurrency is hella simple outside of race conditions on DBs.
I personally don't like the GUI builders, because they require your code to be organized in ways I don't necessarily agree with. However scenebuilder I have to recognize as an extremely powerful GUI builder system. 
Ummmmmm....not very. I don't even trust that allocated strings are safe at runtime...because they aren't. If someone can get that much access your shit is cooked.
Uhh do you have an explanation or...?
Java is difficult, at first. It's just that you are still learning it so don't sweat it too much ;) try to read as much code as possible and learn from the best coders of your company, ask them as much questions as possible. Don't get scared but then you have languages way more difficult like Scala. Then C++.
Agreed. I suspect, with kotlin coroutines and Java's Project Loom, everyone will start using coroutines to exploit parallelism and will need to understand concurrency to ensure correctness of the programs (similar to how ExecutorService is used today). 
You're not alone, brother! I'm also going through this right now. I got the core stuff to Java down and was like, "well shit, Java is easier than everyone made it out to be." Now that I'm introducing all this 3rd-party stuff into my skillset, I've realized the importance of a good Java dev. It's certainly normal to take time learning the things you've mentioned.
I never suggested re-writing anything in Rust, I only asked a question about whether he had seen Rust usage in this space. Given someone starting a new project with these requirements, it is not clear to me why they wouldn't consider a language like Rust. The blog post [Speed Without Wizardry](http://fitzgeraldnick.com/2018/02/26/speed-without-wizardry.html) nicely summarizes my thoughts here. Sure, someone with expert level knowledge can avoid all the traps and make the JVM perform here, or you could just write idiomatic Rust.
I use sublime text and eclipse. I work with no kidding work with with a half dozen plus languages on a daily basis. I am very comfortable with sublime so for quick work I will just us it. If I am going to do any substantial development or testing I fire up eclipse. I used NetBeans for over a year and it worked. I tried intellij but not a big fan... find what you like and use it. Once you get a job find what others use and be willing to switch. With each job we had scripts/plugins/templates for each that made work faster :)
&gt; performance and latency are always worse in distributed systems when compared to monoliths This is a huge blanket statement that is definitely incorrect. The following talk gives some pretty good advice for building low latency microservices. https://www.youtube.com/watch?v=BD9cRbxWQx8
Usually in the office, but sometimes also in my home office. (Usually in Emacs or IntelliJ)
If you want a good in-depth explanation of the spring framework, check out pluralsight. Otherwise, I would suggest learning Spring Boot, it handles on the configuration for you. It would give you a good grasp on the basic flow of a spring application. 
Nobody uses rust in the space because the space is decades old. Nobody would be starting a new project because these are massive financial companies with a massive investment in their existing systems. The idea that any of them would drop what they have in the last three years to go on a rust rewrite is ridiculous. No one working in the space would even suggest using it because the language is too new and tools immature. You can get owned by a typosquat in rust. No bank will touch that. 
What causes this week latency if you have automated QA and deployments?
I use Spring regularly and I still have head scratching moments and have to RTFM. Hell, right now I'm trying to figure out why @Transactional-annotated classes don't seem to be returning connections to the pool when the method exits when called from a @Scheduled method. Rome wasn't built in a night, and learning Spring Core, MVC and Hibernate is a mountain of information to take in - just keep the documentation handy and refer to it when you get stuck.
Well, I have worked with many people in India due to offshore work/team, and I have to say that your education system produces one of the worse software programmers in the world with little regards for code quality and sound design patterns. Spring is also probably one of the easiest framework you will encounter. Get a good book, and you should be able to get up to speed in less than 3 months.
This is a badly written article that doesn't explain anything that's going on in a sensible way. This behavior is only noteworthy as a curiosity and cannot be relied on in a production situation. The behavior shown here is an implementation detail of whatever JVM the author is using, which isn't even mentioned. We could be talking about code compiled with any version of the JDK, running on any JVM on any operating system running on any hardware. And any of those things being different could change this behavior. Do not write code based on weird shit you see the JVM do. Implementation details cannot be relied on. Code to the language spec, not your own wacky science experiments.
Do not even worry, I have difficulties after few years working with java stack. Writing something from scratch means I need to google archetypes or check documentation every single time. My memory is not capable of remembering the entire stack of functions. Spring, actually, is a big framework - maybe one of the biggest. 
You're just dumb lol
When i was learning and to catch up on how things work and get yourself into a detective of Java i would recommend a light IDE like BlueJ
Well you already got a lot of answers, but I'd like to add some help, I've been developing software, mostly java, for 12 years now, tech lead turning into software architect in backend enterprise systems. Backend work is hard, specially in the first years, we all have been thru that, the best advice I can give you is take it easy, keep your mind relaxed, and most importantly don't be afraid to ask for help to the seniors in your team or your tech leader, that's why they are there. College/University will give you base knowledge but the reality is very different from what you haven been taught, you have to adapt your knowledge, if you dont understand something google it, if you still dont get it then ask for help. Learn what's the objective of each framework you use, the thing with java is that it has a lot (and I mean a lot) of frameworks, but for enterprise development nowadays they tend to stick to the same spring+hibernate+something else combination. Learn about java specifications (JPA is a specification, hibernate it's an implementation of it... ironically in this case jpa was designed on the base experience with hibernate :) ) It takes time, it take some years, but you will eventually get it dont worry.
Why did you editorialise the title? It's an article on when to use `@SafeVarargs`. Unsafe in this context is the potential to throw a `ClassCastException` and when and where to silence the compiler warning about that potential.
Someone didn't read the article.
You are good enough. Everything is difficult the first time. Especially when you have so much thrown at you all at once instead of building up from scratch. You got this. It's normal to feel overwhelmed and lost. It's normal to feel like you are dumb. But you aren't dumb. Sometimes you hear people saying "Java is easy" "Python is easy" but what is usually missing is "Java is easier THAN C++ FOR ME". What is easy is subjective. And usually requires a comparison. Java might be easier than some things. And it's probably harder than other things. It all depends on where you start. And it will always be challenging the first time you are given a large project like this. Your experience is normal and you are not dumb for struggling. 
&gt; synchronized is only for the variables inside the synchronized block Wrong. **Every write** before exiting a synchronized block is visible to **every read** after entering a synchronized block on the same monitor.
Overkill for most things. I would still recommend Runnable, Thread, and ExecutorService until a serious performance issue arises.
Those enterprise frameworks are horrible, that's all.
Another viewpoint: Java is very simple ‚Äî it was introduced by James Gosling as a ‚Äúblue collar language‚Äù ie one without any fancy features. The only ‚Äúdifficult‚Äù parts of the core language API are probably the newer functional bits and the streams API. However Spring, JPA and Hibernate is a lot to take in, especially for a newcomer. It‚Äôs also about how these are taught to you. A lot of ‚Äúon the job‚Äù Spring training is just very poorly designed and doesn‚Äôt explain *why* you need something and doesn‚Äôt critique the Spring approach enough. They often also recycle ideas from 10+ years ago. If I had to teach someone these technologies, I‚Äôd ask them to start by using Guice for DI so they understood the value of DI. Then write the simplest possible JPA app using a simple DB like H2 and gradually add features. Once you get to the point where you‚Äôve written a moderately complex app *without* using Spring, I‚Äôd introduce modern Spring in the form of Spring Boot and re-do the previous app using Boot. Then maybe swap the database for something like Postgres. Other tips to become a better developer: * Learn other languages. After Java 7, Java has picked up lots of ideas from other languages and will continue to do so ‚Äî especially around functional programming. Learning a bit of Ruby and a bit more of Clojure is highly recommended. Ruby because it‚Äôs powerful antidote to boilerplate-heavy Java code. And Clojure because it‚Äôll make you a better developer (for instance [this discussion](http://mishadoff.com/blog/clojure-design-patterns/) on how Java‚Äôs design patterns translate into a language like Clojure which supports dynamic programming) * Read! There‚Äôs a lot of material on algorithms, UX, human factors‚Äî and reading will help you become a better, more rounded, human being * Don‚Äôt be afraid of calling out Java BS (or antipatterns). For instance [Enterprise FizzBuzz](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) is intended as humour but is also a pretty scathing indictment of Enterprise Java antipatterns. Luckily most good Java shops have moved away from that. (For instance we use a microservices-based approach, and don‚Äôt even need Spring for most things. And we‚Äôre very, very enterprisey) Hope this helped, and good luck with your career!
I started studying spring at home. I feel the same way. It reminds me of when I started Android. I think the reason is because the framework is so massive. Here's a pretty good video tutorial. https://www.youtube.com/playlist?list=PLqq-6Pq4lTTbx8p2oCgcAQGQyqN8XeA1x. 
I thought I‚Äôd contribute to your question as I‚Äôve recently starting using Java and Spring coming from decent experience with various other languages, and I‚Äôve also found it somewhat difficult. Java is quite an old and heavy going language with it being fully statically typed, if you‚Äôre just learning then that‚Äôs great as it gets some concepts in your head; but after a year or so it becomes tiresome and you‚Äôll want something more dynamically typed. Spring, Hibernate, JPA, and the million odd dependencies they pull in, collectively make up generic components that every language will have many versions of: a HTTP router, dependency injection container, entity manager, object relational mapper, and database abstraction layer. There‚Äôs probably even more buried in there too. So there‚Äôs quite a lot of big concepts all bundled there but honestly if you google them, there will be a short sweet explanation for them and that‚Äôll do. Normally I can pick up a new framework even if it‚Äôs on a completely new language pretty quickly as they all tend to work the same for syntactic differences, personally I have probably found Spring to be one of the least intuitive frameworks I‚Äôve ever used. There‚Äôs a tendency in Java to want to write more Java to configure things, rather than the more modern pattern of pushing the config out to a bit of yaml. So the language and frameworks are all pretty heavy going, even if you have the concepts and experience. It just means you‚Äôve got to work a lot harder at it, read a lot more documentation and just play around with things to give yourself some more confidence. Ask questions if there are engineers there who‚Äôve been using them for a long time, even a five minute chat will go a longer way over hours of being stuck on something.
All i see using these in is test for the most part. 
This title is more to trigger a discussion around that post. While the post describes when and where to silence the compiler warning. I want to explore more on the runtime differences and perfect the understanding. 
I think I read it while writing ( typing - to be technivally precise if you want) 
When people have access is a different case, almost all of those languages or systems have that loopholes or security holes. Ignoring that access, will there be any other problem ? Exploring that will be an interesting experience in the byteland.
import java.util.Scanner; public class Main { public static void main(String\[\] args) { Scanner scanner = new Scanner (System.*in*); String apt, opinion; double days = scanner.nextDouble(); apt = scanner.next(); opinion = scanner.next(); if (apt == "room for one person"){ double cost = 18 \* days; if (opinion == "positive"){ double realcost = cost + ((cost\*25)/100); System.*out*.printf("%.2f", realcost); } } } } 
I was referring to the person I replied to. The person that wrote a comment that was completely unrelated to the article.
Ha ha... I thought you are telling that to me üòÅ
It's a bit old now, but "The Well-Grounded Java Developer" has a good chapter on Spring in it, and Spring is definitely the easiest of that tech stack to learn. &amp;#x200B; I advise focusing on learning Dependency Injection (Spring) first, and build outwards from there. Remember that a career in software is a permanent marathon, never a sprint, so it's entirely natural to feel a bit overwhelmed at the start.
Solving a design issue by making another design issue, is not what I call a solution.
In the end there are only tradeoffs
How to properly navigate spring ecosystem? As a junior developer one has to understand underlying system like database, and also at the same time figure out how RDBMS concepts map to spring api.
I don't see the improvements of the swear word count in the Java source code. My disappointment is immeasurable and my day is ruined.
FWIW I think that's an unnecessarily harsh appraisal.
Is any serverless framework truly serverless? Or is there are always at some point a server? Similarly, is a clientless framework really without a client, or is the moment the client pops up simply shifted?
Ohh, shenandoah made it in.
how cares, only lts versions matter.
Yes but you better just learn to deal with the standard design flaws, which are known and won't change much, than to implement a custom workaround which may confuse other developers and generate even more issues. The right way to keep relationships in sync, IMHO, is directly in the entities themselves. Expose an immutable Collection, keep the setter protected, then implement addBook / removeBook methods to sync Book and Author. You just have to be careful with proxies.
Nah. These versions are still fine for projects that are in development :)
Overkill? Howso....? That makes very little sense to me. Just let it use the forkjoinpool with no ExecutorService...
But not into any Oracle builds
That's not how Java releases work at all.
Just reading up on Spring Data JDBC for the first time. In its announcement it says there's no concept of a "session", so does this mean that if I load an entity twice within one transaction, I'll end up with two different instances of that object?
Seriously? That has to be a joke right?
/** * F***** function doesn't do s*** */ Here is some to help tide you over. Keep fighting the good fight.
Hi, &amp;#x200B; not sure which way would be better, but there are two : * source code compilation in runtime * bytecode creation in runtime First approach was described in earlier posts. For the second approach, try to look up for tools like ASM ([https://asm.ow2.io/](https://asm.ow2.io/)) or Byte Buddy ([https://bytebuddy.net/#/](https://bytebuddy.net/#/)) 
[https://bugs.openjdk.java.net/browse/JDK-8215030A](https://bugs.openjdk.java.net/browse/JDK-8215030A)
&gt;Sure, someone with expert level knowledge can avoid all the traps and make the JVM perform here, or you could just write idiomatic Rust. Also, that is a feature, not a bug. HFT firms only want experts. As mentioned in the video, they spend $150K/mo for an internet connection. They can afford the experts. It's a nice built in filter to keep undesirables out. They don't want to hire some bozo who could cause the next Knight Capital.
Yes, exactly as you said.
I had a feeling this was your underlying concern, but I disagree. HFT firms need, and can certainly afford, experts in their domain (trading) for sure. But the only reason they need JVM experts is because it takes an expert to get the JVM to perform to their requirements. As stated in the video, Java is used because it can achieve the same performance as c++ with less mental overhead and risk. If your argument was correct the HFT firms would still be using c++, to "keep undesirables out". As an admitted outsider, it seems to me the primary reason for choosing Java at this point is inertia. Thats a fine reason, it means there is a trained workforce (even if relatively small, and in high demand) capable of doing this work using Java, it means their existing code is written in Java and changing languages would fragment their codebase and cause a support burden, etc. I'd think there is probably a secondary reason, which you touch on above, that Rust is a relatively young language. Both of these are valid considerations, but they become less important over time, and neither of them explain why you think "the idea that anyone in HFT would even choose rust seems absurd".
That's interesting. Does this apply for the "official" openjdk builds made by oracle too, or only for the oracle jdk? I don't believe the former get any support anyway, so I don't see why shenandoah wouldn't be included.
I was reading the first lines but the advertise on the page piss me off. 
As stated in the video, there are arbitrage opportunities to the tune of thousands of dollars a second. Which leaves us all wondering... why aren't you working on this rust HFT yourself? It's an industry just waiting for you to disrupt. Every time you RIIR, what you are really doing is insulting people who have been working in that space for years. [Mozilla never learns.] (https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/) Rewriting is why Firefox has slid into permanent irrelevance. 
Holy smokes. Good thing I have choices for other OpenJDK builds
No, that's an OpenJDK ticket about OpenJDK builds.
I thought I dreamed that up... I once searched for 'fuck' in my code and misclicked the whole project and sources and found a 'fuck' in the official documentation :')
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Using many frameworks without an architecture is the same as using tools to build a house without ... an architecture. It is possible to do it, but it is too hard and result is usually a chaos. The frameworks are not a value on its own.
I see; I think that's quite a step back compared to JPA, whose main value proposition is exactly the notion of managed object graphs whose state is automatically synchronized with the database. Say I need to modify an entity in three different places of my code base that are part of a more complex business process. Without a persistence context that ensures a given record is represented by the same object instance in the lifetime of a transaction, I'd either have to pass around the single entity instance to all the places that need to touch it. That may be non-trivial, depending on the complexity of the use case of course. Alternatively, I'd synchronize the changes through the database (by loading the entity and writing it back at each of the three code pieces touching it), but that's not desirable in terms of performance. When going for the first approach, I'd likely also end up implementing my own dirty checking, so to avoid writing back entities that haven't changed. One thing I find interesting is the emphasis of aggregates, that's generally a good idea (though you can easily achieve the same effect with cascading operations in JPA). I'm wondering though whether/how I could do fetch joins across aggregate boundaries, say to load a PurchaseOrder and the associated Product? All in all I personally have doubts about the usefulness of this approach apart from very trivial use cases. But having worked on Hibernate projects for a long time, I may of course be biased here :) &amp;#x200B;
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Spring Data with an ORM does exactly that. It's mostly a performance choice: raw JDBC will always be way faster than an ORM/JPA.
I run all of my source code through an M4sh preprocessor before feeding the output into `javac`. So what looks to the compiler as public int runEvents (List&lt;Callbacks&gt; handlers); in my editor is actually garbage bullshit turn handlers into a fucking number; I'm quite proud of having adopted Literate Programming techniques. 
This API is less flexible and more opaque than Runnables and Callbacks. And it's not imperative
Dude. .exceptionally() Logging goes in the execution blocks It's not imperative coding at all... I get the feeling you're just used to doing things one way
What's that?
We are werwolves not swearwolves. 
The article starts out bashing the nature of unchecked exceptions, which is a bit of a boneheaded move to make in java land. Instead of this entire article + writing non-idiomatic, vavr-ified java, just.... make a checked exception and throw that. 
Same. The ads and poor design of the page makes this link garbage. Downvoting.
Holy shit, the ads...
Most microservice discussions assume JSON over HTTP(S) or similar. It was interesting to hear about the use of shared memory for microservice communication in low-latency scenarios.
Spring framework https://spring.io/
At work we have a few teams that use vavr. The code looks terrible and is legit harder to read, and I love functional when it is done well... 
JEE is overkill for creating a site with static content. However, if you're determined to use JEE, you can create a servlet by extending HttpServlet to handle requests and send html back. You will also need to create a web.xml file and you will need a container like Tomcat to deploy your application. If you want something quick, look into setting up a server with Apache HTTP server or Nginx serving your .html files. 
The last startup I worked at had a rule: profanity and racism in the comments was *required*. // Jim is a dirty Albanian goat-fucking whore
Spring Boot, more specifically.
I would say a project in github is better than a portfolio website for Java backend.
When I entered the workforce as a Dev I was also overwhelmed. By nature I tried to understand these frameworks start to end, but it's futile. My personal advice to you would be to become productive first and learn to master over time. This will reduce some of the stress and anxiety you're feeling now. I would approach the API's mentioned as follows: Forget about hibernate for now as it's just the implementation of JPA. Start with spring, identify which features you are expected to use (IoC, data, rest, etc). Learn the basics of those, for instance components and autowiring, repositories, templates. If you're not using spring data, figure out the basic JPA annotations like entity, mappedBy, etc. Look at the codebase and see what is in use, try to understand the what and why. Don't be disheartened, it's really tough and is unlikely to get easy, but with the right approach you can become effective. 
Every job interview I've been to in the last year has been trying to migrate their monoliths to microservices. When asked why, scalability is always the reason. Most of these places have a finite userbase, think intranet, online banking, etc) but are chasing scalability they will never need in exchange for unnecessary deployment and configuration complexity
CE is fine. It will be as good as Eclipse. What pro offers is stuff like bean detection which helps you navigate to the injected bean from the line in which it's declared, among others I can't remember off the top of my head right now. The fact that boot bundles all those jars is inconsequential to your ide, your build tool (maven, grade) will handle that
Your microservices will typically communicate via rest APIs. If you change the specification of 1 API you need to update all clients of the API. Or you'd use API management software but that's a whole other thing
The main difference I found was that Ultimate has built-in tools to start, stop and debug Tomcat, whereas with CE you have to do that manually. Moving from a non-Boot Spring MVC project to using Spring Boot reduces the relevance of this tool. I'm surprised they leave out Spring bean detection in CE: VSCode, with the right plugins, has that for free. This isn't an issue at work: the boss pays our licences of course, but at home I'm much more likely to use a free IDE that has all the features I need rather than pay for IDEA Ultimate or muddle by with CE. 
I would say it isn't. I'd much rather see something than try to pour over yet another project of complete ravioli code.
Why not both? Have the code that runs your site in a public git repo.
I usually focus on unit test and code quality because if I hire him I need to face his code everyday.
honestly I'd hire anyone that doesn't call .toString() on a String object.
Unit tests are useless. 
This would only highlight your inexperience of the Java landscape. Don't do this unless you want to learn, and/or build out something super overkill for a portfolio
Don't overcomplicate things, keep it simple. Think about the requirements at hand and go for a minimum viable product. EE is cumbersome, it's a terrible fit for a portfolio site, it's as far away from enterprise you could get! Try and spend time on tasks that provide actual value, choosing a complex backend for a simple site doesn't show that you pick the right tools for the job. It consumes your time for very little in return! I would recommend plain HTML/CSS. JS if you need to, you can use JSON files to provide data (through XHR). The next level is static site generators, good templating support - plenty of pre existing templates to choose from. Deployment? I use netlify, it's free and easily set up to deploy your site from git. Free/automated TLS setup, domains can be bought for about 10‚Ç¨. Deploying EE applications to the cloud is much more expensive, due to always needing resources allocated. If you want something without writing code, ghost could work. I'm not a fan of EE nor Spring. Stay away unless you are six feet deep into enterprise. I built my own static site generator in 1-2 weeks in nodejs for my portfolio site, it uses ES6 template literals for rendering. It's on npm, 'static-mina'. My portfolio https://thecodingchili.com/ is hosted on netlify and deploys from GitHub. It's super fast anywhere in the world because Netlify distributes content over a CDN! If a recruiter has to wait too long for your site to load, they might load someone else's site instead. :)
Most things that need parallelism aren't batch jobs. Multi-line lambdas are awful. Java should be written imperatively. `exceptionally()` is bespoke and isn't exactly elegant. private static void doWork() throws IOException, ParseException { if(new Random().nextBoolean()) { throw new IOException("read failed"); } throw new ParseException("illegal character", 0); } CompletableFuture completableFuture = CompletableFuture.runAsync(() -&gt; { try { doWork(); } catch (Exception e) { throw new RuntimeException(e); } }).exceptionally((t) -&gt; {throw (RuntimeException) t;} ); try { completableFuture.get(); } catch (ExecutionException ee) { Throwable causeCause = ee.getCause().getCause(); if(causeCause instanceof IOException) { throw new IOException(causeCause.getMessage()); } if(causeCause instanceof ParseException) { throw new ParseException(causeCause.getMessage(), ((ParseException) causeCause).getErrorOffset()); } }
Even when execution plans are cached at server-side, it's still a good thing to cache the statements client-side. In the end it depends on the concrete implementation. Without client-side preparedStatement caching, usually the following steps have to be carried out: * The client needs to send the query string to database server (think about large queries) * the database has to check the syntax and access rights for the user executing the query * the database needs to do a lookup in the cache to find cached execution plans (which needs synchronization) If you can avoid these steps, you are usually faster and save resources on the database server.
Dammit.
Spring Boot may be all nice and stuff, but dammit, stop trying to use it to make stuff ‚Äújust work‚Äù by hiding tons of important implementation details from the developer. Unless the developer doesn‚Äôt want to be able to use anything else.
These vavr ads are always a bit annoying. Exceptions are thrown in constructors to ensure its impossible to build an invalid or inconsistent class instance. If you separate out *allocating and assigning memory* into a separate logical unit of invocation from *validating those allocations* then you make it possible to do the former without the latter. This isn't the end of the world but it's certainly not *desirable*. Why do you think methods throwing exceptions are not "composeable"? The example you give of composeability is just stringing invocations together with flatMap. But for throwing methods you can just put a sequence of invocations in a single try block and achieve the exact same thing. In what way do you see Either as more polymorphic than exceptions? They're covariant in subsignatures and can be parametric in method or type signatures. You say that if you implement an interface with a throws declaration you need to add the declaration to the implementation signature, this is not true. You complain that all exceptions have to subtype the same exception type, but then later on your first suggestion for solving composeability with Either is to make all of your errors subtype the same class anyway! And then find out which it is at the point you deal with it by pattern matching over the type, which is essentially exactly what a series of catch blocks is. Algebraic data types are really useful, surely you can find ways to advertise them that are a bit more honest and fair.
I‚Äôll just start with the color. Fix the color. Orrrr, if it‚Äôs unreadably purple because Safari on iPad sucks, figure out why and fix that. Sometimes recruiters read stuff on iPads.
So first of all I'd like to point out handling exceptions sucks just as much ass with runnables and callables passing to the parent. Second if I may you're using the exception handling a wee bit wrong. https://pastebin.com/7Ke7hJLN What you want to do is pass the CompletableFuture up the stack. So the only place you should ever see a try catch is going to be inside the CompletableFuture code. So in the bottom part all it's doing is taking the Exception and passing it up the stack. CompletableFuture already does that for you so that's completely unnecessary. Unless it wants to do something with the exceptions you don't need to touch them. So let's say &gt; try { completableFuture.get(); } catch (ExecutionException ee) { Throwable causeCause = ee.getCause().getCause(); if(causeCause instanceof IOException) { throw (IOException) causeCause; } if(causeCause instanceof ParseException) { throw (ParseException) causeCause; } } is inside a method which is throwing the exception up to another method which corrects something to fix the error or display an error. The method doing the correcting should call .exceptionally and provide it's error conditions and corresponding logic. All the methods between the CF and that method need not do so. From the RuntimeException their thenRun/thenRunAsync/etc already aren't going to fire. Next you almost never are going to want to call .get. That's a blocking call...with CF you don't have to do that to get back into a synchronous context. When you call .thenRun, .thenApply, etc it puts you back in a sync context. These act as implicit callbacks instead so it's properly asynchronous. Since you talked about parallelization here is an example that distributes the asynchronous tasks to 8 threads in a pool. https://pastebin.com/YkLpriVx In either example using Runnables or Callables would end up taking as much code or more. I imagine you didn't realize you don't have to try-catch it at every level, or completely get how exceptionally works. 
I think its fine. I mean, only a few of these versions are LTS. And the faster release cycles allows me to expriment with all the new features for each version. Where I work, we use branches a lot, and we have a tech branch where Java is always the newest version. When we hit a LTS version we merge into master and go from there.
Never mind my snarky comment, this truly takes the linked article to task.
&gt;supplyAsync I guess this also works, but it is non-intuitive as hell to return an exception object: CompletableFuture&lt;Exception&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; { try { doWork(); } catch (Exception e) { return e; } return null; }); Exception result = completableFuture.get(); if(result instanceof IOException) { throw (IOException) result; } if(result instanceof ParseException) { throw (ParseException) result; } When I run your CFRunner the process never exits -- I have to kill it manually. And printing the stack trace is sometimes nice, but what I'm looking for is to throw checked exceptions of the correct type to higher code (for instance the UI layer or the REST layer). Runnables and Callables aren't amazing at that either but they are nicely extensible.
The tick syntax wasn't great for this TBH.
No you misunderstand you don't return an exception lmaoo you return your actual return value! That would be completely awful! What I mean is once you throw a RuntimeException wrapped Throwable to throw it up the stack it's available anywhere the CompletableFuture is via exceptionally. It's effectively the same things as "throws". So what I mean is the CompletableFuture contains both your return and your exception
Yeah, I'm planning to switch only from LTS to LTS. So Java 8 to Java 11 to whichever LTS will come next after 3 years (which probably will have numbered up to Java 18). So essentially, after Java 8, I think of Java 9 + Java 10 + Java 11 features all together as the next "real" big Java release, and learned them together to migrate the codebases to Java 11.
Thats basically how I look at it as well. 9 and 10 are more like feature previews
Yes, exactly.
for each project a different microservice, this might impress some
Thanks, there are some icons/links that are purple on purple which should be fixed. I'm always tuning the colors to my desktop, which has very specific settings. It's probably a bad idea but max saturation looks so pretty. Sounds like you might have some more feedback, may I hear it?
Made a ton of edits so if you already read this probably refresh 
Especially as `Optional` has `map` and `flatMap` operations that lets you chain method calls. String fullname = userService.getUser(username) .map(User::getFullname) .orElse("unknown");
The last few projects I've been on were microservice architectures. I'm not planning to spend time writing a book on them here but if you have specific questions I'd be happy to answer them. 
It actually matches my expectations, so I'm not concerned by it. After Java 9 was released it became clear that it would be a transitional release for early adopters, with Long Term Support (LTS) releases being more appropriate for cautious production environments. There will two major Java releases every year, including one LTS release issued every three years. Java 9 also brought with it significant internal changes that need to be taken into account by framework/library authors which mostly only impact business application developers in terms of having to update code dependencies. I believe we'll see Java 11 LTS uptake increase after OpenJDK 12 hits general availability in March. For example, Java 11 will be supported across AWS some time in April.
Can't we just stop creating topics about Java release process every week/month? There are a lot of articles, video and conference talks about that already. It's ok, Java have to evolve and you as a developer have to deal with this. And whatever approach Oracle would choose there are always people who either would whine about that Java evolving either too fast or it's too old and other languages could do things that Java can't for years already. You are *software* developer for gods sake. And **soft**ware as opposite to **hard**ware means that it can and will be changed. You'll have to learn constantly, you'll have to adapt and adopt. Change is the only constant in the life of developers. So get your shirt together, and yes - learn, plan for migration, break down your old and ugly enterprise monolith to smaller pieces and replace it part by part. At the end of the day you have only one alternative to choose - either your software evolve or die. And the same applies to you as a developer.
&gt; At the end of the day you have only one alternative to choose - either your software evolve or die. And the same applies to you as a developer. COBOL.
Not that Callable is much better, but at least the interface lets me throw Exception: Callable&lt;Void&gt; c = () -&gt; { doWork(); return null; }; try { exec.submit(c).get(); } catch (ExecutionException ee) { Throwable cause = ee.getCause(); if (cause instanceof IOException) { throw (IOException) cause; } if (cause instanceof ParseException) { throw (ParseException) cause; } } catch (InterruptedException e) { e.printStackTrace(); } &gt;CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()])).get(); Na, the process still hangs for me. &gt;instead of throwing an exception up the stack you just pass the CF up the stack Na, this would break method contracts all over the place and force you to assimilate any code that touches this into a rigid CompletableFuture Borg. If it can't play nice with ordinary synchronous, imperative Java code it belongs in its own language.
It *is* a bad idea, because nobody looking at your site cares about your desktop. They do, however, want to be able to read what's there without a lot of effort. 
And how many cobol developers are out there in the world exactly? I know that it's been in use for a long time, but the fact that something exists does mean that it's a rule of thumb. Look on the numbers - how many cobol, erlang, asm developers do you know? And how many java, c#, python, go?
&gt; And how many cobol developers are out there in the world exactly? How many where there at the height of COBOL? Not sure that is comparable. Personally, I could live with an OpenJDK 8 being maintained forever.
Syntax error: "9+" expected variable or number Do you mean 9++? Which would return 10. This means your are asking for Java 10
You don't need to fully research all features included in new Java versions to use them. How difficult is it to take a brief look at the release notes every 3 months?
I like the new approach with release dates set in stone but being flexible with which features make it into each release. But I think once every 6 months is too much. I preferred once every 18 or 24 months. But that‚Äôs my subjective opinion. And there‚Äôs nothing stopping them from adopting a new release model in the future.
1- Ya Java EE is ‚Äúunnecessary‚Äù for something like this but if you want to do it then do it. No one is stopping you. Especially if you want to show off that you did it in Java. 2- JSF/JSP are completely fine options for something like this (I know people like to hate on them, especially JSF, but they‚Äôre still heavily used). 3- The biggest inconvenience to using Java over something like PHP is if you plan on using a hosting service (instead of hosting yourself). Most of them come with PHP compatibility out of the box, but not Java. And a lot of them aren‚Äôt compatible with Java EE runtimes at all. 
Why not? 
I think there is a psychological issue in play, with people thinking of the releases as major releases because of the version numbers (perhaps this wouldn't have happened if Java adopted the YEAR.MONTH version scheme originally proposed by Mark Reinhold of 18.3, 18.9, 19.3 etc., but this turned out to be extremely popular). The last major Java release (ever) was 9. Now Java uses "Chrome versioning" (no one makes a big deal if they're a couple of Chrome versions behind), but it will take some time for people to adjust and internalize that. The thing is that Java was on a 6-month release schedule even prior to Java 9, but those releases were called update releases (and previous updates did not get patches); they could and did contain some very major changes (e.g., G1 was introduced in Java 6 update 14), just not changes to the API or language. Removing this limitation does not make the 6-month feature versions much bigger, but it does completely remove major versions, for which there is no longer any need. This helps people who want new features get them faster, and also hopefully reduces the cost of upgrades. Now, as to "serious" production systems on 9+, there are quite a few of them, but you're right that adoption was not as fast as for Java 8. The reason there has nothing to do with the new versioning scheme/release schedule, but with changes in 9. Upgrading to 9 is harder than upgrading to previous major releases, but that difficulty is gradually reduced as more and more libraries upgrade (for most projects, the upgrade becomes very easy once all of the dependencies are upgraded). 
‚ÄúPlease remove the generics syntax and implement a proper generic system‚Äù - love everyone 
I forgot about the Tomcat integration. You can get that with Eclipse for free as well. Typically when I used CE I just used a remote debugger when necessary and launched the app from the built in terminal tab, no biggie to just hit the up arrow and enter, bit to each his own
Use the TLS
Can't disagree more with this. &amp;#x200B; It's not because Big Oracle said it's good that it's good. The same "evangelists" who tell you today to split your application in microservices will tell you in 2 years to come back to a monolith, because they have some new framework to sell you. Changing for the sake of change is not the same thing as evolving. They changed the release cycle without adding any real incentive to migrate in the newer versions, this situation has been seen many times before and it almost never ends well. This will only lead to fragmentation. &amp;#x200B; Let's say I maintain a small open source library. Now I have to setup a parameterized continuous integration to test on every JDK, which can be a headache. I also have to do some digging to decide if the many distributions of the JDK are different, and if I should to test on each of them or only one. And in a few months, my CI will probably break because distributor X decided distributor Y won, so it's not worth continuing. There is no value in having to do this extra work, this is not evolving. Other maintainers in the same situation might draw different conclusions and do things differently, so it's harder for users. This is a simple example that shows fragmentation very directly hurts the ecosystem as a whole. &amp;#x200B; At the end of the day, I think all they did is creating a Python 2/3 situation, but worse. Accelerating the release cycle does not accelerate the pace of evolution of the language/JVM, eg: * we have been waiting for \*very\* long for [a proper FFI](https://openjdk.java.net/jeps/191) * same for [value types and generics over primitive types](https://openjdk.java.net/projects/valhalla/) * same for [GPUGPU](https://openjdk.java.net/projects/sumatra/) The people that get their shit together are already out. Java was about productivity, but I feel like it's losing this battle.
Next week we are completing our migration to Java 8 from 6. The place I worked a year ago is about 1 year into a ~5 year migration from Java 6 to .Net. in my estimation, widespread Java 11 usage will take some time.
Kotlin is still better so I mostly used that. Havent played much with Java after 8..
&gt; This means your are asking for Java 10 Since *you're* being pedantic, it's worth pointing out that you should have used "you're" and not "your are".
Because `` could be confused for an empty string and it's not really friendly for all locals, for example on a standard German keyboard layout, there is no single key for that letter and you have to write a weird 2-key-combo (dead keys). Also ` and ¬¥ can be easily confused. Especially as ¬¥ is the default key on a German keyboard and the right char has to be entered while pressing shift.
As you wish.
&gt; but I can't wrap my head around the madness that Java seems to have become Genuinely, what madness? These changes to java haven't appeared overnight. Java 9 was released over a year ago, and the changes it brought had been discussed in length for months prior. &gt; releasing every 3 months or so? There will be a new version every 6 months, with an LTS every 3 years (next will be Java 17). &gt; What about the fact that the Java world is mainly enterprise, requiring a lot of maintenance and investment to switch to newer versions? Businesses can pay for LTS versions on older versions of java, or they can use one of the many alternative OpenJDK builds that are promising to backport vulnerability fixes to java 8. Oracle will provide java 8 support until 2025. You also seem to be forgetting one of the most valuable points of Java. Backwards compatibility. I've run plenty of java 8 code on java 11 with no issues. Of course old, large codebases might have some issues but you either spend the effort to upgrade, or spend the money on enterprise support. &gt; What do you think Java developers are supposed to do now: try to learn every new thing of the new Java releases, or stick to Java 8? These aren't just updates for the sake of being updates. They bring new, much needed and well thought out features. Each version will typically only bring a small amount of new features, which allows people to slowly bring themselves up to speed with the new versions rather than being hit in the face with an update consisting of five thousand new features. I'm not sure why you would be against learning the new features that java 9+ has brought. &gt; I personally think there is not a single serious Java 9 system in Production yet Arguably you shouldn't be using java 9 at all. Non-lts versions are now superseded as soon as the next version is released. Our system was moved to java 11 as soon as it hit general availability. Honestly, why wouldn't we?
Could you please elaborate a little on what exactly is wrong with the way generics are handled in Java now? I have seen this comment a few times in this sub and I just don't find a problem with how it is handled. 
&gt; Accelerating the release cycle does not accelerate the pace of evolution of the language/JVM Of course it does! It has been less than two years since Java 9, and we already have a new Java version with major-ish features like zgc or var. This is a massive change compared to the old versions - it took *three years* to get out Java 9, and every little change that was ready way before that had to wait. The big big difference with the new model is dropping the idea of "release drivers". Lambdas for 8, jigsaw for 9 and so on. These release drivers have, in the past, always lead to delays in the release of java versions because those versions would be too "underwhelming" to release without them. It's not about how fast features are being developed, it's about how fast they are being delivered. Comparing this to py2/3 is ridiculous. You could argue that the introduction of jigsaw lead to similar problems, but that is independent of the change in the release cycle. Upgrades between Java versions past 9 have been fairly painless.
I don't believe unit test is useless, By TDD, One can always practise test-first programming in which the programmer uses tests to correctly type in her preconceived design. I find that writing tests helps me uncover design problems more easily, but I could always choose to ignore them. Spring framework and laravel and other open source libraries both doing unit test Even so, I find that when I find difficulty writing tests for some part of the system, that usually indicates a design problem. I find it hard to give specific examples because that requires code, but I'll try to describe some general cases. Sometimes I have trouble writing a test because I want to check an intermediate result that the system doesn't make available. When I find it hard to identify any useful intermediate result worth checking, that usually points to high interdependency (high coupling) in a system. To make it easier to check small parts of the system separately, I end up having to decouple modules, which generally contributes to better design. (Constantine's coupling/cohesion principles.) Sometimes I see large amounts of duplication in a set of tests, making them hard to maintain. In particular, I see duplication of irrelevant details[1] in those tests, meaning that I duplicate code that isn't directly related to the things I want to check. (Think of testing a five-step wizard and having to executes steps 1 and 2 in most tests, even though you want to check the results of step 3, 4, or 5.) This duplication tends to highlight dissimilar behavior close together (low cohesion), which risks accidentally changing unrelated behavior when changing that part of the system. I could find many more general cases, but I hope this gives you an idea why unit test is helpful for everyone 
I think it's great, it allows Java to keep up with competitors. And with a world moving towards containerization, it will become easier for many big enterprises to keep up with the new release cycle.
OC is talking about syntax which is fine IMO but the way it‚Äôs implemented sucks. You might want to have a look at type erasure for more details. It‚Äôs been done that way to keep backward compatibility, but it means going through a lot of hoops to get anything but simple stuff done a lot of time.
&gt; What about the fact that the Java world is mainly enterprise, requiring a lot of maintenance and investment to switch to newer versions? That's what LTS versions are for: Java 8, 11, 17, 23, 29... you can skip the rest if you want to.
I'm looking forward your book &lt;3
Yeah but how long before it‚Äôs used in the real world? It‚Äôs nice to have an evolving language but java might not be the best client for this
We'll count the points in a few years, and see whether it was ridiculous.
Why not? You can decide to stick with the comfortable two-year cycle (or even longer if your support contract permits). I can go for the newer versions right now, knowing that the features I use will actually end up in the next release, and getting proper support for them. If there's a critical feature you really need, you can also go to a newer version earlier - even if the feature is too small to have counted as a release driver back in the day.
Also to add to the above, I realize we have IDEs and syntax coloring and what not, but I believe a potentially large literal cognitively requires large delimiters. HEREDOC may look clunky, but it's large it's visible, and it offers a way to avoid content collision, so you don't have to be eagle eyed spotting that tick in the middle of the string you have to escape so shit doesn't break. Plus, when we diff, commit, browse repositories, we don't always have the benefit of a full IDE analyzing the code for us, we just have our eyes and the text.
kotlin is mostly s. sugar the null verification is nice and hope they will introduce it in Java instead of @NotNull annotation
Shiet english 4
Not only the sugar. The whole library ecosystem is so much nicer. Live all the functional ops without having to always use .stream() and .coolect(...) at the end. Everything just feels a lot more Scala-ish and nicer to read. Oh, and extention functions? Yes please. (Yes, I know they are static methods with syntatic sugar for object acting on but still..)
We just moved to 10...
There are probably more cobol developers now than there were 30 years ago. Software development has expanded enormously, which is also why nearly all programmers are young. 
Is there anyone who can't type on demo console?
Agreed, but this was for a portfolio website. The most annoying thing these days is trying to find examples of how to implement something on an existing Spring Framework application since all the examples I find now are for Spring Boot which doesn't help me.
Sounds like you already have 
I don't follow you - I've not programmed in anything else yet, if that's what you mean. Prior experience with Matlab, but that's it.
I spent the time to get our application at work ready from Java 8 to Java 11. It was surprisingly a decent amount of work seeing that so many libraries broke between 8 and 9 and only recently has many popular libs have released fixes for these breaks. However, we're still using Java 8 because we can't find any decent Docker images for Java 11. The ones I could find are using Debian Sid or other unstable sources for the image. I'm not really even comfortable with AdoptOpenJDK anymore, either, after seeing their API which tracks the total number of downloads being disgustingly small. I think it's gross that Oracle made one of the largest breaking updates we've ever had and then fucked with their release cycle to encourage people to pay for Java 8 support and then be able the point and say "Well, it's fair because you're like 4 versions behind the latest version of Java!" despite the much shorter release cycles. I also feel like Oracle turned Java modules, a legitimate feature, into a trap by changing the Oracle JDK licensing as developers may unknowingly bundle the oracle JDK into their application. I actually really do like seeing faster releases from Oracle, but there is a huge hurdle going from Java 8 that'll likely result in years and years of people not going past 8 and more people going for paid support instead of fixing their shit. And, even within an organization where we can happily fix our stuff, since nobody programs in a vacuum anymore, we depend on others fixing their stuff for compatibility.
You have to start with something. Whatever it is that you choose, won‚Äôt be your last. If your boyfriend is an expert, should be easy 
People learn different things in different ways. There is no right or wrong langauge to start with. I thinknthe major thing is learning the concepts and fundamentals of programming. Once you have a good idea of this, then its just a matter of learning how to use the syntax of a language to apply that knowledge. Java can seem very complex, especially comparing a simple "Hello World" program between Java and Python. Phyton its just simply print ("Hello World") and you're done as opposed to Java where you have to create the class, then create the method, then tell the system what to do and how to do it! But even still, there is absolutely nothing wrong with starting Java first. Just remember to carry the concepts/fundamentals with you into other languages. Best of luck!
I would say java is a great first language. It teaches great concepts that are used in almost every modern language: typed variables, control flow, oop. I took a class in high school on java, and it made transitioning to c# and c++ relatively easy in college. When i look at python code the syntax is so different from anything else i can imagine it would be a pain to move to anything else.
Do you mean in this release? Can't find any mention in rel. notes about it.
as soon as there is a iota of state, i write a method as an instance of the class. Static is cancer. I repeat Static state (any) is cancer. the only static method i use are those that can be inlined and DO NOT have any state, including state in the code expression.
Everything kinda went off the rails around 2015, including java. I think the bizareness started eith Java 8 - here we have streams and lambdas added which I have to look at all day as "harder to read for loops" and it's a pain. Java 9/10/11 continued the madness. Maybe they'll pull it back together, who knows. But yeah it's very odd.
It sounds like you're already learning Java as your first language. And yes you should continue, wouldn't make sense to stop after 3 months and start over on a new language. And bonus when you've got easy access to a Java professional.
Serious question, just trying to understand: why not move to 11 while you're at it? Is there a specific reason?
&gt; Several people I've met have been very against me starting off with Java. Over and over again this quote remains relevant: &gt; Bjarne Stroustrup ‚Äî 'There are only two kinds of languages: the ones people complain about and the ones nobody uses.' 
If you're at a company and concerned about the fast cadence, boom this is the solution. Just like you had to migrate from 6 -&gt; 7 -&gt; 8, you just need to upgrade from LTS -&gt; LTS -&gt; LTS. Java migrations aren't all that hard either (IMO). Granted, if you've amassed a *ton* of technical debt they may be.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [Teaching Java with Jupyter notebooks \[x-post from r\/java\]](https://www.reddit.com/r/coding/comments/a8w7od/teaching_java_with_jupyter_notebooks_xpost_from/) - [/r/programming] [Teaching Java with Jupyter notebooks \[x-post from r\/java\]](https://www.reddit.com/r/programming/comments/a8w7jk/teaching_java_with_jupyter_notebooks_xpost_from/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Is good when you really wanted a function of some class which is part of a library which you are importing, otherwise writting loads of static methods for ThatClassUtils looks nasty and not as clean.
Many languages erase types, even Java pre 5 erases short/byte IIRC. It's a problem when your code is overly dependent on reflection. Even something like Guice doesn't have to do that, see Dagger (haven't used it, could be talking out of my proverbial)
The great thing about java is that you can start with a simple ‚Äúmain‚Äù only program, then add functions, objects, go on with JEE, web, Android. You can start with simple things but you can learn for years
I had a lot of success learning Python for my first language, but Java was way better for learning more complex concepts, especially OOP.
Here's the tip I usually give out whenever this question pops up: Most mainstream languages is a good starting place. It's really not the language that's important, but understanding concepts and how to apply them. Java is fine.
Been through the same. It's completely normal. If you like programming and can picture yourself creating stuff, then just fight through the frustration. I feel like programming is a difficult skill to aquire although the basics look so simple. So, in short: I felt frustrated, and desperate throughout all my years at uni. However, I love coding and the prospect of creating software. Just enjoy all your small victories and get all the help you need in the beginning. There's no shame in that. What you don't know now you will know in the future. All the best to you :) 
I still look up basic shit on a near daily basis and I've been writing Java professionally for 5 years, and working with software development for 10. I practically depend on Stack Overflow to 'remind' me how to do a lot of things. ‚ÄúNever memorize something that you can look up.‚Äù -- Albert Einstein 
No one knows everything right away. The way you‚Äôll get better is to try to figure things out before going online for help. If you have to find answers online, make sure you understand what you‚Äôre copying. Some of the worst programmers are the ones who do things without knowing why they‚Äôre doing them. Learn your data structures, consider when to use one over the other and just experiment a bit. You‚Äôll get it eventually, it‚Äôs not going to be something that you learn overnight.
We've had the opposite experience. However, we just have a webapp running in tomcat. Added back in a couple of libraries that was pulled out of the jdk and we were done.
well i came around a few months ago. I write my utility methods in a StrUtils as instance methods. Its clean once you organize your code with module contexts. The module context return the instance of the StrUtils. Static calls are fucking cancer. I am not going down that road again. All the code used by your app should dangle from the entry point. Statics are free floating entities. Virus. Cancer.
My team and I are exclusively building our project work around 11. I heard one of them mention that they‚Äôre happy that you don‚Äôt need an accompanying JRE download anymore.
its a never ending path.
Oh brother, look at that karma. Maybe if you stopped wasting so much time on this site you'd actually do something with your life. 
It was my first language back around 2002 and it‚Äôs worked out well for me. Never got in the way of leaning any other languages. 
I'm not sure. We are still on 8.
For me, java was hard to learn because right from the start it had a Main class, main method, public nad static keyword, String[] args etc. System.out.println() was confusing to me. Getting user input was complicated. Right from the start it had so many concepts I didn't yet understand because I never did programming before, and I basically had to copy paste a ton of code and had no idea how it works and how to fix it if it fails. I was in a loop, I had to use classes which I didn't understand to be able to learn basics and later to learn classes. It's similar to "you have to get a job for experience, but you can only get experience by having a job".
It's because it's their first introduction to programming usually and everything that goes with that (OO, data structures, algorithms, VMs, references, etc..)
&gt; wasting so much time Like trying to gratuitously insult strangers?
I don't understand why they didn't just go the Python route and use letter-prefixed string literals or triple quotes.
&gt; with an LTS every 3 years The current release schedule is stupid; designing languages can't be shoehorned in to a fixed schedule. That's why we're seeing these features get pushed back every time. But not until blogs spam the future addressable search space with speculative bullshit to waste our time later. If you like breaking changes to other libraries you use like gradle, groovy, and spock, then you should upgrade all the time. From the sublime to the ridiculous, that is the story of the jdk release schedule. Now its information overload about things you might not even get to use. This only does one thing, breeds apathy to the release cycle such that the only sane choice is to update on the LTS releases only, and just ignore everything else including the blog spam. 
There are two types of programmers-- those who prefer static typing and those who prefer dynamic typing. However only the latter can become so dependent on static typing that the most minuscule ambiguity bothers them.
Because Java, like any programming language, can be incredibly hard to learn and traditional educational enviroments aren't particularly well suited to teaching it. Drop out rates are huge for most first year computer science courses. It's great you managed to pick it up yourself, some people have more natural ability with these things, but that makes you rather an exception to the rule.
General lack of persistance. Most of the questions that grt posted are by beginners that don't want to struggle with anything. If they can't immediately figure something out they throw up their hands and ask for answers. I'm in university and I see it everyday with my classmates.
try brave browser..! :)
&gt; It's similar to "you have to get a job for experience, but you can only get experience by having a job". Tell me about it... Quick statement to anyone here, if you have a chance at an Internship: DO IT. Do NOT do the alternative internship class last minute like I had to do to graduate. I wish I had attempted an internship earlier in my college life because it came up to my final term and the college and myself failed to find anything so I had to do the alternative class to graduate. It has made finding a job very difficult.
I can see what you wrote happening with hobbyist scripters, but it doesn't seem likely with students in a university program unless the problems they are asked to solve ( versus the language ) are hard.
I don't have natural ability. I think I was just graced to find a program that didn't do weed out classes.
I always understand why we use something when I search for the answer.I make sure to legit understand why they were even put in the order they are. The other day I tried to create a simple rock papper scissor game and even though I didnt do it without help I understood why the guy wrote the code in his way, and I just started thinking of some other ways I could have written the same code. Even now I can picture how the code went even though I only saw it once, at least this makes me feel proud and give me hope that I can make it.
I guess what really worries me the most is the paper exam we have on our java subject. The final exam is all paper no computer no nothing which for me seems so unrealistic to how we would be working on real life... Thank you for the answer dude, gives me a lot of hope!
I do like it for sure, I can see myself living the life of a programmer. Thank you for the kind words!
People (including me) just find Java's 'hello world' intimidating at first, I think. Generally when you teach it, you're just trying to educate on basic syntax and control flow. So you hand wave away all the structural boilerplate and just say, "this doesnt matter right now." This might be frustrating to a lot of people coming from scripting languages that are a bit more "plug and play." One issue is that often students are validly told what they should ignore for now, but are not given a good reason why. The entirety of my first 101 course was spent thinking "wtf does public static void main(String\[\] args) mean?"
I was in that boat not long ago. If you have a Swing application and use Webstart, there are 3 things you need to figure out to move to 11: 1. Finding the replacement jars for removed j2ee apis 2. Figuring out how to use jlink and setups, passing additional options to the application that once were on the jnlp file. 3. You loose the log viewer from the Java plugin, so you might want to have your own in your application.
I literally couldnt care less about the syntax, I just wanted raw string literals.
Yes. There were a lot of topics. A lot of acronyms starting with J (JMS, JPA, JTA, JNDI etc etc). I've felt that there is just so much. That's why I was happy when I've decided to get OCA &amp; OCP certificates. For me, they've cut a lot of noise and put me on a path. Started from completely easy stuff, variables, loops, ifs and then classes, interfaces, inheritance, polymorphism and so on. Up till this day I recommend to begin with OCA. Whether certs are useful is another topic, but nevertheless I think a lot of poeple agree that topics which are covered in them are basic foundation. Later on you can start picking up other stuff, but in won't be that confusing. 
For paper exams I would use something like hackerrank for practice. When I was a CS undergrad I bought a book with Java puzzles, but hacerrank is basically the same thing. 
It's hard. What you're doing is correct. Concepts get easier to understand. You will have lots of "light bulb" moments if you stick with it. It's like playing a difficult video game. You spend hours on a level, only to eventually beat it and get moved on to a harder level. 
You'd be very surprised. My professor for data structures and algorithms had to go over basic java for the first 2 weeks because the amount of people that didn't really understand/remember what classes are, how they relate to objects and other super basic stuff like reading in data (the class was taught using java). I'm so glad to have just changed schools. There's a severe lack of genuine interest in the subjects being taught. A lot of people are trying to get into it simply for the promise of a good career, but what are they going to do once they're in the field and employers will expect them to be able to learn things, even difficult thibgs, without hand holding and backtracking through basic material.
My theory is that due to the new standard that no one needs a degree, and you can ‚Äúbecome a senior engineer after this 3 month course with no experience‚Äù type things, people want to be able to ‚Äúlearn‚Äù within 5 minutes and feel that they are actually useful. Java does take a tad more to do hello world than JavaScript, python etc but not much. And so when people come along and it takes a few hours of solid thought and focus to learn something they give up and assume it‚Äôs hard because it only took 5 minutes to get going with xyz other language hello world. 
Many people studying CompSci assume its gaming or an easy way to get moneys, at least from my own experience. Then you end up with only 3 people getting their bachelors done in a normal time out of 230 people you started with. And very many end up switching to economic compsci, which is less programming centric and more using programs. Once you get to masters though, people are generally willing to put in the work.
I've started from Python. And its was nice and dandy for small scripts, loops and ifs. I've even made a naive neural network for university's homework assignment. It ran like sheet, but I was proud. Also, everything was in one class. When I've decided to split it into smaller ones, and tried to be more OOP, I got completely lost. Maybe because __init__ and all those weird methods __name == '__main__' did not make a lot of sense. Then I started looking into Java. I remember how easy was to understand constructor. And how you would call new ClassName (or whatver name) and it would create new instance. It just clicked. Then interfaces and polymorphism were more clear cut. Anyway, I think for dipping into water, python is fine. But OOP concepts are more clear cut in Java. 
I will check the website out, thank you so much!
Thank you!
Thank you for the words man, it helps a lot seeing it this way!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;I'm having problems creating something literally from scratch without getting help I don't think I know anyone who starts with an empty folder and a blank file. It sounds like you're doing it wrong. Why aren't you using Maven archetypes? For example, do you want to write a [ReactJS frontend connected to a Jetty backend over a WebSocket](https://github.com/nullterminated/react-archetype)? I made an archetype for that. Mine isn't on maven central, but thousands are. I don't know anything about Apache Camel, but I can have it running locally in Eclipse in a few clicks using archetypes. In some cases, you may find there are no archetypes available, but there are frequently example projects up on github in those cases. The [vertx-examples](https://github.com/vert-x3/vertx-examples) is a good example of that. Either way, you can easily set up a hello world for most any library or framework.
&gt; Some people love putting toothpaste in tubes, some people hate it. That's true, but I see usually happening is that a few "easily bored" people with "architect" entertaining themselves to the point of making the code a hellhole for everyone after them. Architect: I watched some youtube videos on new language features do we have to implement them to stay up to date (rubbish excuses). Dev 2: I don't know, what we have is working fine and.. Architect: Oh so you aren't willing to learn anything new and want to end up out of date? (bullies thrm into it) Dev 2: Ok, ok, I don't want to end up in trouble with the boss. Architect: Ok, now we'll spend hours where I explain to you how this works. Dev 3: Hi, I'm new to the project, and - whoa - how does this work? Dev 2: I'm busy, figure it out yourself. Dev 4: Hi, I'm new to the project and... Dev 2: Busy, figure it out yourself. Dev 4: Well can you modify this as you wrote it? Dev 2: (Looks at it for a bit) Oh, I have no idea how this works any more. You figure it out 
From what I've seen, this is the difference &gt; When I went to college "Introduction To Programming" was a two semester class, taught in C++ Once you've stuck through learning C++, java is mostly just "oh look, bigger standard library and no pointers". But most people are learning javascript and python as their first languages now. For them java is "Ok I guess I have to compile this? What are types, why are some in these bracket things? What's this main method thing?". Basically, I think posts about C++ being hard to learn just turned into posts about Java being hard to learn.
Java the language isn‚Äôt hard. In fact it is extremely rare to have someone actually complaining about the language (Granted, I complain about the language, but not because of complexity). Two items related to Java are hard. 1. Learning the environment (JVM, which is huge). Big problem that new comers have is recreating things that already exist because they can‚Äôt find them. 2. Finding which 3rd partly libraries are the currently accepted best practices for their domain. Need to use Hibernate? How about Spring? What about.... Which application server you using? So many choices to make, each one a huge topic taking a lot of research to really learn. 
I don't completely agree with you become a senior engineer in 3 months with no experience. You have to know the quirks of SDLC . Yes its true you can become proficent in a language and a set of tools in 3 months time, but how do you work with others? How do you write reusable code, what if given a legacy application how do you go about improving it without a full rewrite. So experience is what makes you a senior, hence the word senior. Software development is an art, and we should take the time to learn it. Don't half ass and do it the right way. Hope I didn't come off rude :) happy coding.
Even right now, 20 years after I first started learning Java it would take me a few minutes to think how to do input from the console. I'd assume using a `BufferedReader` over `System.in`, but the code to do mixed input and output would be horrible.
20 years of Java here. I hit the Javadocs daily, occasionally even for simple things like `String`, `List` or `Map`.
I‚Äôm still considering whether or not to embrace the java 9 jigsaw modules. 
The introduction of collection streams in 8 was great, but jigsaw modules? I‚Äôm having a hard time finding justification to upgrade past 8. 
Exactly what I was trying to say! 
Yup, user input in Java is one of the most complicated I've seen out of any language I ever used.
I learned on my own and remember struggling for days about interfaces. Reading the Oracle trail again and again, going through tutorials and feeling like a dumb turd all the while. I powered through and the rest was fine. Next big struggle was events in javafx and the servlet paradox... I guess it's different for everybody but struggles are definitely on the menu. It takes a real interest and dedication to "get it" all.
You could just use a Scanner (Java.utils.Scanner), it even has functions defined to read specific types of input.
It was nice to unravel the mystery bit by bit though. Amirite ?
I can't imagine going from starting Javascript to any structured language, that must really mess with your mind =)
Being an Informatics Engineer with a certified degree by the Enginners College from a country, where signing as such without such approval is passible of lawsuit, that kind of misuse of "engineer" doesn't stop amazing me.
It‚Äôs depends. Java itself is syntax is just about the same as c++ and c#. It can be tricky if you are coming from say JavaScript or python. The thing is though is that programming is hard in general. Most people give up. For every person who gets it there are 10 more that don‚Äôt. 
What‚Äôs the server paradox I googled it with no luck 
Java's "Hello World" has a lot of information to process all at once. I used to think public vs private had something to do with security, but it's mostly about visibility. And I was coming from C# so how about an internal method that's only available to the current assembly? Oh right Java doesn't have a sense of modules before Java 9. And no auto magic getter setter properties. Luckily Kotlin was invented which is a lot more beginner friendly than Java I feel.
Because they come from JavaScript or Python and no longer have the convenience of coercion and have to deal with types being a thing.
Yeah I was only confused before you edited your comment. I definitely have done a lot of work in Java, but if that's a bad move for me and my chances of starting a career, I can switch. However from what I've seen here, I agree with and so I'll keep on keeping with Java! &amp;#x200B; Thanks!!
Maybe, but if you do a little digging into computer science class research, you'll see that courses usually have a reverse bell curve pass rate. Not many students just pass in the middle with Cs like it many other fields/topics. Usually people get high Bs, As or they completely bomb the classes. I started a thesis on this with my professor in college, never went anywhere with it though, I bailed on the masters once I got a full time job.
The new release schedule avoids pushing back features. With the old model, each of these features that gets pushed back a release would hold back every other feature with them.
I agree and I love Java. I think it's due to the fact that I've never in any of my jobs written any command line input in Java. Back in the day, it was all applets and Swing for input, and now it comes from JavaScript. Anything on the command line can be done infinitely faster in perl or python, and most CLI utilities into tools just call the REST API nowadays.
Merry -Xms
Very interesting, thanks for sharing the details!
Java is easy. OOP is hard.
Java isn't well suited for taking user input from a terminal in an interactive manner. It excels in taking input non-interactively (from the command line, from a file, network, etc.), or interactively from a GUI. 
From your description I doubt you have any appreciable depth of knowledge on it. I might be wrong but if you're at &lt;2yrs with the language right? If so you're barely a jr dev... If it's just casual contact you're like intern level. You don't know enough to know what you don't know. As far as learning it first no shit C++ is harder, but that doesn't mean java is easy. You learned Java already knowing a language and I imagine after a 4 year degree...it sounded like. You were quite unclear about it...I mean the whole post is all over the place. If you know java C++ is muuuch easier to learn. It's harder to go java to C++ because C++ doesn't have all the standard convenience tools from Java. &gt;I saw the programming homework friends had at other universities in intro level courses. The problems ( not the language ) were tough. Those departments were using the intro level courses as weed out courses. I don't see what this adds to your post. This seems like a non sequiter. &gt;Okay, there was the post the other day about a guy whose job wanted him to learn it from a cram course. Uh dude that guy was cramming Java plus Spring core, boot and jpa plus hibernate. I would consider that tech stack much harder to learn than Java core even on a deep level. This might be where your confusion lies. Just understanding that stack *properly* under the hood relies on knowing how a lot of crazy black magic shit works. Crack open spring core's src and prepare to be humbled. Have you used Java professionally like...at all? I'm not talking a little project that's 4 classes. I'm talking a 100k+ codebase with unit and integration tests. By his description it sounded like what that gentleman was facing. Hell do you even know how to build tests? Junit4 junit5 and mockito? If not you don't know java. Combine that with the aforementioned frameworks and it's orders of magnitude harder than what it sounds like you're referring to. Also your post kinda sounds like /r/iamverysmart ego stroking and denigrating some poor guy who needs help. That's shameful
I think calling Java hard to learn is a massive hunk of bs, but to be fair, Java is way less beginner-friendly then say python. You are forced to use a lot of concepts that you just can't understand all at once just for 'hello world'. **Small example in Python:** hello_world.py print('hello world') python hello_world.py **Same thing in Java:** HelloWorld.java class HelloWorld { public static void main(String[] args) { System.out.println("Hello World"); } } javac HelloWorld.java java HelloWorld **Conclusion** The Java version uses classes, objects, visibility modifiers, static, the void return type, arrays (or even worse - varargs), and a compiler. Also the syntax is less intuitive for someone who has never written a line of code. Python is really just a single somewhat intuitive line of code and a single intuitive command. That means nothing for the efficacy of a programming language for a seasoned developer, but the first hour or day into learning the language is *very* rough in Java if you have no prior knowledge. But over-all it's reasonably easy to learn Java - while Python is ridiculously easy to learn at the beginning. I think it evens out a lot later on. 
No Java is great, and will make higher level language easier to learn! 
**servlet**
Paper exams are actually alright. The ones I've done didn't expect perfect syntax, and there was a big reference sheet of keywords and common methods. Exams for introductory courses will be testing your ability to solve problems more than your knowledge of the language, though the latter will still be tested. 
-Xmx to you too
It's not Java so much as the fact that a lot of people's first exposure to Java was when they were learning about OOP at the same time, so there was a steep conceptual learning curve - and then once that's down you have to learn all the main APIs in order to be useful as a developer. The verbosity of the thing is hugely off-putting, too. There are ways around this, like using lombok for data classes, or learning Groovy (which is basically Java without all the blather), and a decent IDE will have shortcuts to generate all the boilerplate anyway. If you're learning Java as a first language, though, and your teacher insists on using Notepad / vi, then you have my deepest sympathy.
 Your skill will be close to proportional to the raw amount of time you are spending. A lot of times things will be very frustrating. Especially when you are approaching things with no background knowledge. try and find projects to do that are enjoyable to you, so u can put in the hours without burning out. If you can do that everything will fall into place. If someone else is enjoying themselves while you try to rationalize spending hours for some payoff you will get btfo. Enjoy yourself. Even if you finish college with a 4.0. You will come out of school a mediocre programmer, unless u go above and beyond. 4 years is straight up not enough time to teach you everything. You need to take your learning into your own hands. The info is all out there. Use videos,books, docs, whatever you want.
Yeah that‚Äôs what I meant - spell check. I looked up servlet paradox with no luck. 
&gt; I complain about the language, but not because of complexity /** * competyly useles engrish coment that dos not even * discribe the code that folows and porpabely was just * copiied from anoter unrelatd method */ AbstractSingletonFactoryFactoryGeneratorFactory .getInstance() .getMyReallyReallyReeheeheeheeheeeaaaaallySpecificUsingSomeStupidlyLongEngrishMethodName();
See also: ObjectiveC and Cocoa.
He sounds like he's not at the point of even fucking with any libs if he's writing rock paper scissors apps. Not saying he couldn't figure it out by reading the docs, but he might want to clear some basic language/programming stuff up for himself before touching anything else. He's a freshman tho. I go to a shitty school and a lot of seniors don't even know what maven or a websocket is. 
Yes, libGDX: [https://libgdx.badlogicgames.com/](https://libgdx.badlogicgames.com/)
Can you say the name of the book you have read.
Java isn't hard, but other languages are easy. Case 1: A Simple Program Python with flask and you can have a cool little we server up in about 5 minutes written in a language that somewhat looks like english. In Java you need to first learn about maven or gradle, how to set up your environment, how to make sure you are pointed at the correct jdk, and learn the syntax of Java. Ergonomics is a big issue with language adoption. Case 2: Language Features &amp; Learning Interfaces, annotations, overloads, inherantence, syntax sugar, lambdas. Each of these items are great, but they are hard to take on all at once. Part of this is tutorials. Most Java tutorials go from 0-100 and a lot of libraries assume you understand all of this. Other languages orientation tend to be geared at new to programming, not just new to the language. This is also an issue with teaching C/C++. A correlary to this is easily available outdated tutorials/information. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think you mis interpret my comment. I am 100% totally against the idea that someone could become employed as a software developer after 3 months of training let alone a senior one. I‚Äôm saying people should get degrees, I think we should be trained and have to learn all those things you mention.
It's currently the most widely adopted language in software development, so from that standpoint it's a great first language to learn. Java 8's lambda expressions are also a good gentle introduction to functional programming. 
If you think java is hard to learn try knitting or bug collecting.
Our bachelors is 3 years. Ive already started learning from a book(introduction to java programming by daniel liang) and am gonna be starting to use the hackerrank website, that seemed very good. Thanks for the words man.
Heredoc is *not* easily visible, because it can look like anything! For punctuation to be easily visible and identifiable it needs to be consistent. Arbitrary alphanumeric punctuation is insane. I understand the value as a delimiter in order to avoid using the contents of the literal, but if you also want to claim that being able to choose arbitrary punctuation carries its weight as a way to *improve clarity* then why stop at string delimiters? Why not allow us to write brackets as custom strings? Something like `####"this"####` is much more sensible and easily identifiable.
Because that still requires escaping if you want to use those delimiters in the string...
so true, I feel like a few brain cells die every time I use spring boot as it basically does everything for you with a few annotations and at the end of it I have no idea how it does what it does technically. 
Because most people don't understand the difference between things like hashmap and hashset. 
&gt; Arbitrary alphanumeric punctuation is insane. It's not arbitrary, it's similar to XML and HTML. You have an opening and closing tag of the same name.
That may have been your experience but that is absolutely not the norm at colleges. My Data Structures and algorithms used Python. We were expected to pick up Python on our own for use in some of the labs. 
No, it doesn't, or at least not in Python.
Read up on classloaders and how the JVM manages classes, memory, etc. It is essential at some point to understand it as it is how the classpath, etc work. I found that a bit difficult initially but eventually went on to build a full scale plugin engine very very similar to what Eclipse IDE used years ago. It was so much fun seeing the engine start to work and to be able to build a plugin outside of the main application, and see it load and reload instantly... similar to the hot reload of WAR files today. Made development super fast. But more importantly taught me a ton about the internals of the JVM.
Oh man.. definitely see this more and more. Today there is huge emphasis on making big money, and that knowing a programming language gets you there. Yet you see a ton of kids after 4 years of schooling dont know shit.. not because they should.. but because it takes years of investment, experience, real world use cases, etc to learn all of it. Those kids that dont have the desire to push through, usually dont cut it and either quit and find a different field, or sometimes keep on going job to job.. but eventually they wont be able to get hired.
It's not like that at all! In XML and HTML the element name has some specific semantic significance, typically in that it corresponds exactly to a schema. It's not punctuation, it's part of the data. And yes it is arbitrary. It's like if arrow notation in C++ allowed any old sequence of characters in the middle ... `receiver-thisIsAnArrow&gt;member`
&gt; It's not like that at all! In XML and HTML the element name has some specific semantic significance, typically in that it corresponds exactly to a schema. It's not punctuation, it's part of the data. The fact you spell the same tag in the end is not up to the schema, it's the syntax. You realize XML could just as easily have been defined to do this, for example: &lt;helloworld&gt;...content...&lt;/&gt; Yet they decided to spell out the name a second time, adding ZERO semantical content, but making it more clear what ends exactly at that point. Same with HEREDOC.
So python just doesn't let a string which is delimited with triple quotes also *contain* triple quotes? Because the only way to allow that if triple quotes are the delimiter would be to escape them. That's the problem that's solved with variable length delimiters.
I'm not talking about the fact that the end tag is the same as the start one. That's clearly not the problem I described I had with it. **The name of the tag in HTML corresponds to the schema.** For example, the name `script` has a specific meaning. It's part of the data. You can't just put in `&lt;randomfuckingnonsense&gt;content&lt;/randomfuckingnonsense&gt;` and expect it to work or make sense. But with heredoc quotes you can because it's not data it's *punctuation*. See the difference?
This + general widespread of java
Could you please expand on that? Perhaps with a brief Gist? It sounds interesting but I have a hard time exactly grasping what you're doing here and why your instance methods are a solution to extension methods (which I don't like in any case). Thanks in advance!
Vavr is for people who will be happier using Scala, but for some reason are not allowed
The opening tag is semantic, the ending tag is "punctuation". The ending tag doesn't have to spell out the name, yet it does. Those are two separate arguments. The idea you can only repeat the identifier, if the first occurrence is semantic, is a non-sequitur. You really have no point here.
Nonsense the ending tag is still semantic in the same way. It's *redundant* but the name still carries the same meaning. &gt; The idea you can only repeat the identifier, if the first occurrence is semantic, is a non-sequitur. Good job that's not what I said then! For the last time my problem was never with the repetition. That has nothing to do with it. My problem is with arbitrary alphanumeric punctuation.
Lots of things in your code have no semantic meaning. Comment contents don't have semantic meaning. Variable names have no semantic meaning. You just repeat the same variable name to get the same data. Class names, interface names, namespaces. Labels. If you get hung up every time we use arbitrary strings, we'd literally have to drop the entire language and start over.
&gt; it's like they're trying to scare people out of using the app. They are, and that's why their marketshare is dropping like a rock
That's why CS graduates can't find a job. They are basically shit devs, have no interest and only want to be a dev because six figures
[removed]
Programming is not History (where you can more or less copy-paste from online sources), English (ditto with a thesaurus) or Physics/Chemistry/Math (where you need trivial problem-solving skills at applying ready-made solutions and performing calculations). Programming needs serious attitude realignment from f.e. high school or liberal arts; there is a hard reality check on what works and what doesn't, and arguing otherwise is as useful as trying to talk to light switch.
There was research (apologies, no sources) that showed that there's a 10-80-10 distribution: 10% will take to programming like a fish to water (they'll like it so much that the hours spent don't "count" for them), 80% can become competent by just putting in the work (it's just another job, and how far they'll get depends mostly on the work performed), and 10% will never "get" it. 
No apologies necessary, this is casual conversation, not a pHd defense :). I'm in the 80%, hence my curiosity about all of the complaining.
Honestly, if you like problem-solving games (f.e. anything from Zachtronics) you'll do just fine. Re: complaining; I was a TA for a course that was essentially Programming for Engineers 101, and the amount of people that were trying to \*argue\* their way out of compiler issues was mind-boggling. And don't get me started with all the "hey, I'll just cram before the exams" types, when the actual exams were in front of a computer....
Python is going to teach you how to code in Python. Once you learn Java C++ and C# are extremely easy to learn. In fact most OOP programming languages become pretty easy to learn. 
I misunderstood what you meant, my apologies. Yes, then you escape the triple quotes. You can't have a comprehensive solution here parsing wise. No matter what you use for multiline raw strings, you'll need to end up escaping the sequence you use to mark the string.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a90tje/github_my_first_simple_java_web_project/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I don‚Äôt recommend getting the OCA and especially not the OCP until you have developed professionally for a year or so. Since you are still a first year, please just keep working on it ‚Äî I promise it will click eventually. The learning curve starts high and gets way easier as you gain experience. I do agree with this poster that the OCA/OCP are super super good in helping with foundational knowledge but at your experience level I think they will be too much. Especially the OCP.
I was that kid in intro to CS class that raised their hand every time they got stuck ‚Äî the learning curve for Java was *so hard* for me. After a year or two it just started clicking. After a few more years programming became nearly as easy as writing in English. Now I‚Äôve been in industry for 5 years, make an excellent salary at a great company. Please don‚Äôt give up if you can see yourself enjoying the job. The learning curve is harder for some than others but if you keep trying you will definitely get past it. 
There are some great libraries, such as Hystrix or Failsafe, that can throttle access to a specific resource. This won't completely stop a DDoS attack, but you can at least provide fallback behaviour, or protect other systems/endpoints that use a shared resource (ie. Database). 
Truth be told that's a much sadder thing than I was hoping for. They wanted to use VertX + Postgres, but I didn't know vertx. Do you know anything of those libs? I'm halfway hoping he sees this and goes on a rant about it haha.
There isn't anything about VertX + Postgres that is going to change the situation. Patterns to deal with high load gracefully are pretty consistent across all of web development and Spring probably has more options when it comes to built-in support than most frameworks/ecosystems. &amp;#x200B; If you want to move away from threaded/JDBC you can still use Spring and Spring Boot, just switch to Webflux + some data store that supports nonblocking like Mongo or Cassandra. You don't HAVE to use the servlet stack or JDBC with Spring.
Happened to me, asked like 2 newbie questions and got locked out for like 7 day.. Was kinda weird. 
Does test scope not work? If you need it for compile and testing but not in production? 
Without having a computer to check to be sure, set the scope of dependency A as "provided"
You'll find as time goes it'll start to get better once you learn a lot of particular patterns. With practice you'll figure out how to piece those patterns together to pretty much engineer whatever you want. And then, even for something as "simple" as a string, if you're working a SWE type job you'll have to start all over from scratch when you start learning a new language / framework! The only thing that'll stay the same is general design principles you pick up over time.
Today, Java is probably the most used language for back end web applications. You cant go wrong learning it and doing so well. But there are other languages that are doing quite well now too. NodeJS, with its strong ReactJS, Angular, Vue and other tie ins, plus being able to act as a back end as well, is pretty strong lately. Python as a back end is OK, but slow compared to many other options including Java. Easier to learn I am told but I am not a fan. Golang is one of the hottest growing languages right now, very very good for back end development due to its easy to learn (so I am told) syntax, compiled to binaries on all platforms, performance, built around threading/networking, and more. And every 6 months it gets better. Probably a big reason why Java moved to a 6 month release cadence.
yup
This is more something a network appliance should take care of. 
leetcode as well. I am apparently going to have to do this very thing to try to get a job soon since despite 20 years in the industry, it seems that we are all still required to pass ridiculous white board questions. Not a fan as I dont do well with those and it tends to basically be the majority way companies determine if an engineer, despite a really good long resume, is worth hiring or not.
Same. I was just talking to someone about how after 20 years today most of us refer to the web for examples and such rather than try to write things from scratch. It is almost always about efficiency and avoiding duplicating whats already been done 100 times before. If I can find a really good clean example of what I am trying to do, I will copy it, maybe modify it for my specific needs, and be done. Rather than try to rack my brain for how to do some algorithm. It is probably why I suck at white boarding.. because I rely on my tools.. internet specifically, to help solve the issue faster. I guess to many this is a bad thing.
I mean....that shouldn't be necessary for a simple site in the public domain should it? A ryobi or SAS or something shouldn't be necessary. I'm talking more about application or near-application level fixes. Cookie based solutions, rate limiting etc. 
Id deal with it at the server level then. Serve it through tomcat or websphere. If you proxy it through Apache you can configure Apache to deal with ddos. 
Ohhhhhh now this is a very good idea. Serving it through an nginx proxy or apache would probably mitigate tons of that shit combined with rate limiting on the backend endpoints. This is the kind of answer I came for here lol Looking forward to seeing the other stuff people come up with
Glad I could help. 
Haha it's just funny because I've served up so many terrible php applications behind Nginx/Apache proxies and never thought of this. 
Any other recommendations? I've built 10s of backend spring boot systems but it turns out public facing systems that may be a target well..I'm ignorant on.
I'm still locked out dude.
I'd look at mod security and mod evasive. Mod security is a bitch to configure with Spring, but it's good at dealing with DDOS and SQL injection. I only use Apache, so I'm not sure what Nginx uses. 
Well without the GBK charset using spring JPA I'm pretty confident against SQL injection. DDOS is more my concern, but I'll see what I can do. Is there some specific filter or class I can provide a bean for within mod security for this? Spring is notorious for having classes that are super useful, but if you don't know they're there to provide a bean for them they just don't work well. I'll definitely do some testing though with a few VMs and see what's up.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Can I know why I can‚Äôt post as b4?
LibGDX is exactly what you are describing.
I have seen many large scale systems without unit tests and programmers were too clever to "fix" the bug they saw. It ended up those "bugs" were introduced with purpose. Of course many people would say writing comments can help. But I seldom see people maintaining comments.
Try setting the packaging type? :O &amp;#x200B; [https://stackoverflow.com/questions/44297430/generate-war-file-using-maven](https://stackoverflow.com/questions/44297430/generate-war-file-using-maven)
I started with JS and then learned C#. It was okay. I just didn't fully understand the roles of some things like interfaces and super classes. I kind of liked the compiler keeping things in check. It felt like enabling cheats in a game. It warning me ahead of time that I dun goofed. But I definitely think JS was a good way to start. Less ceremony, more coding.
I came from the other side, microcomputer BASIC then into assembly, and then C was a godsend for exactly the reasons you bring up: the compiler keeping things in check. Of course there was a lot less "system" in the way then, straight to hardware, so my path made sense then like your path makes sense now. In the end we all end up at the same place, making things do stuff! Cheers =)
Http server in a DMZ bro. That's what it's for.
In my college (CE degree) we started with assembly, then C, then C++, then Java. &amp;#x200B; But to be honest programming is not as bad as people think. I think starting off with something like Java/Ruby/Python/Javascript is fine. &amp;#x200B; To be fair if someone starts off in Ruby/Python/Javascript might have a real hard time going to Java after. It's much more strict and rigid. But Java is very good at putting bread on the table, Always in high demand and always pays decent. &amp;#x200B; Glad your getting into coding as a lady. For some reason it tends to attract males more as a career. Idk why, but i'd love more diversity between the genders in computer science :D &amp;#x200B; (I presume your a lady, sry if i'm wrong. i'm cisgender tyrannical patriarch). 
Just an idea: you can put an nginx in front of the spring boot. And have the throttling there. Usually in enterprise projects you have a sort of an API gateway, so you can use nginx for that. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Can‚Äôt set scope of A as provided because embedded tomcat need that dependency
Then I'm confused. If it's required why exclude it?
Then I'm confused. If it's required why are you trying to exclude it?
No need to switch to another datastore than postgresql, there are plenty of projects that do non-blocking access to postgresql. I'm writing one of them here: [https://github.com/pgjdbc/pgadba](https://github.com/pgjdbc/pgadba) but it's not ready for production usage yet, but there are plenty more mature projects out there.
OK doing some more thinking on this, I think you're trying to do the 'wrong' thing with maven. The verb 'export' isn't part of Maven. A project builds one main artifact (and various attached classified artifacts, but ignoring that for now) I get the feeling that you want a project that you can run tomcat in for testing, as well as getting a war out of it when you run the 'package' goal. If you need the in-place war with mvn tomcat to be different than the one from 'package', you're in the realm of fighting against maven instead of working with it. My safe suggestion is make project C which depends on B (the war project), and put the tomcat7 plugin into project C.
Sorry, C++ is a diferrent _beast_. Please don't mislead others.
&gt; That's why we're seeing these features get pushed back every time. which features? the only one I'm aware of being pushed to another release is raw string literals.
I'm building a new javafx app on java 11 atm and it's going swimmingly. even got jlink capable of building a built-in runtime for distributables my build system generates. I'm working on making it capable of working with windows and mac osx installers, but that's more to do with getting my build system to work with the runtime I added than anything else.
Did you read the Java proposal? The delimiter doesn't need to be escaped, because if it occurs in the string you can simply choose a different delimiter which *doesn't* occur in the string. That's the whole idea of variable length delimiters, other languages have successfully done the same thing.
Guess some people have no chill :D
Maybe it's just me, but looking through the examples in the [JEP](https://openjdk.java.net/jeps/326), I found none of them convincing. Let's go through these one by one. * File paths: You shouldn't be hardcoding absolute paths in your program to begin with and as for relative paths the Java API supports '/' just fine, even on Windows. I'm not sure what happens if you try using '\' as a separator on Linux, but it's really fishy. * HTML/Polyglot: Unless your Java IDE is aware of those languages, you lose all the good features an IDE would get you by embedding them in source code as a String. It also just leads to an unmaintainable mess. Imagine you start working on a huge existing code base that embeds HTML everywhere. Good luck finding that piece of HTML your program just outputted. I just can't help but think "Who in their right mind would want to do this?!". * Regex: I think I'm actually okay with this one to some degree, but I rarely have to write lots of regexes and when I do, I try to avoid complicated ones. I've also never written a multi-line regex, this is a clear sign that your regex is just too complicated and you should be using something else. * SQL: I'm going to address this separately from HTML/Polyglot, because I think it deserves a special mention. I'm guilty of this too, even though I'm aware that I'm writing bad code. But I definitely wouldn't want my language to encourage bad style. Using an ORM goes a long way towards avoiding verbatim SQL. There's also nothing wrong with loading your queries from a text file. Simply put, I see very few use case where raw strings might be helpful and it enables and/or encourages lots of bad practises. In my mind multi-line strings are even less useful and add more unnecessary complexity (see the section about 'margin management'). I don't think it's worth the trade-off.
I can definitely see myself as a programmer, thank you!
Thank you!
You would think with 20 years of experience they would just hire you immediately... Good luck and thank you!
You didn' find any decent docker image just for all of them being Debian? I totally disagree with that. Java 11 has incredible better support for Docker, Openjdk docker images has alpine versions and with Jlink you can create your own Docker image with just the slices of the JRE you need.
Yes
I think it's rather interesting that your friend is 'experienced' enough to tell you to not do stuff but not experienced enough to help you you do the right thing. The solution depends a bit on where you're running your stuff. If it's on amazon for example you could just use their API gateway. If it's all self-hosted I would use a reverse proxy (Nginx, Traefik, Apache) in front of it to handle that. 
&gt; Several people I've met have been very against me starting off with Java. Java is successfully used in many CS courses as a first language so these people are objectively wrong. There's nothing wrong with Java as a first language. The only downside is that you pretty much have to learn OO programming alongside. But for that [this MOOC](http://moocfi.github.io/courses/2013/programming-part-1/) has you covered. 
&gt; OC is talking about syntax which is fine IMO but the way it‚Äôs implemented sucks Is he? I have no idea what he's complaining about since he cares more about complaining about downvotes than about explaining what he means. 
Some styling in JavaFX is only possible via CSS, sadly. 
I think it's a great language to learn as your first. I don't use it professionally anymore because I moved on from being a Java developer many years ago. Java was the first C like syntax language I used for a significant amount of time and it taught me a lot. It was also the first OO language I used. There are also a huge number of online articles to help when you get stuck. So it has a lot to offer. More recently I've been using a lot of scripting languages such as Python, PHP, Javascript, etc. But this week needed to use Java for something and although I was a little rusty I really enjoyed using it again.
I think redmans comment was that moving from Python to Java, C++ or C# will be harder than starting with Java and then moving to pretty much any language out there. I agree with it.
Random question: how do you pronounce his surname? Is it pronounced "goats"?
It is pronounced ‚Äúgets‚Äù.
I can't speak to spring specifically, so I'll keep it general: Let's call a 'request-lifetime' the entire act of getting called to handle a request (so, if using servlet API, the moment your doGet method is called), reading out whatever you need to know from the request, doing all the logic to handle the request, and serving all the bytes out. # The DB is not why a toaster can DOS your server if you do it right The easy way out for avoiding DB use to be a bottleneck is to move away from the model of 'I have an open connection to the DB for a request-lifetime'. Separate out the input phase, the calculation phase, and the output phase, and have a DB connection only for the calculation phase. Now that toaster can't hammer your DB anymore unless there is a page that takes a lot of DB resources to render that they can access, or they are on your local network: The sheer latency and network transfer will far outpace the DB's ability to handle your request. It is easy to mess this up with java's servlet model, but once you take into account that your DB should not open until all data is read, and should close before you start to send any reply, it's not hard to do this. # Async is not an answer async is no solution whatsoever. It sounds obvious that it would help against (D)DOS attacks, but it really doesn't: async is about buffer efficiency. Let me try to elaborate: When 2 server requests come in simultaneously, and you wish your server to be capable of handling both (because if it couldn't, a toaster could DOS your server), then you need to have a system whereby a single CPU core can 'hop around', working on dealing with a small part of one request-lifetime, and then hopping over to another whilst some part of the job of dealing with it 'blocks'. Common blockers are 'read the incoming data', which your framework can take care of optimizing, 'send the outgoing data', which, again, your framework ought to do that, and 'wait for my DB query to finish', which a framework cannot easily optimize. One way to have your CPU core 'hop around' is in the thread-per-request model. The thread that is waiting around for a reply from the DB will be frozen and some thread that was frozen will be woken up. This has a cost associated with it: The CPU core needs to swap around some caches and some other state. Also, there's a memory cost: Every thread needs a stack, and stacks are at least 1MB per thread (depends on your `-Xss` setting). The other way to go is an async model, but make no mistake: When the same thread decides to move over to work on another request-lifetime for a bit, you __ALSO__ end up with a CPU that has to swap around some caches and other state. The cost of this is the same order of magnitude as a thread context switch. However, unlike the threaded model, the async model does _NOT_ need 1 stack per request. It merely needs 1 stack per handler thread (which is usually 1.5 to 2 times the number of cores you have, so, quite limited). However, it _DOES_ need some way to store all intermediate data: If your code moves over to deal with request-lifetime B because as part of dealing with request-lifetime A you make a DB call and you are now waiting for the query to return, _somewhere_ in memory you need to store everything your server and your code needs to know about request-lifetime A in order to finish serving it. This is the only major benefit to async: You can manage that as carefully as you want to, whereas in the threaded model this data is 'hidden' in stacks and you can't manage the memory load of those. Before you get all excited about the opportunity to manage the memory load of a single request, note that you picked java because you didn't feel the bug-prone effort of managing object destruction was worth it so you wanted a garbage collecting language instead. Perhaps you should not be so eager to want to take on the burden of managing this, either. The problem with async is that ANY existence of blocking code in your async code means a toaster really can DOS your server. And yet there is no easy way for the compiler or any linter tool to tell you that you messed up, and it's really hard to figure it out from tests running on your local machine. Most local machines have a fancy, fast SSD so if some part of your async code blocks on a file, you probably won't notice. But the performance of this code is going to be horrible compared to threaded code. Java was never imagined as an all-async language (the only language that can reasonably be claimed as designed like that is probably javascript, though in practice [it isn't either](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)), which means trying to go all-async is very hard to do: Many libraries just aren't written with the maxim 'if you block, you silently break this server' in mind. # the real answers tend to lie 'before' your java code even runs Put in rate limiters in highly specialized and optimized code that runs before the request ever gets to your code: Use the powers of apache or nginx and cache libraries for as many pages as you can. If you write a blog engine, presumably one of your web handlers (the 'handle a request for the home page' one) will ping the DB to query for the 10 most recent posts, and then 10 queries + some calculation to create a preview for each of these 10, and then some more queries to produce the comment count on each of these 10, and then perhaps a wider query to produce a calendar view with the # of blog posts for each month in the past 24 months. That's a truckload of calls and calculations, and yet it's unlikely that any of this will change much between right now and '1 second from now', but don't try to deal with this in your java code. Tell your web handling layer to cache whatever response your code generated for the request to resource `/` and to serve up this cached version for the next 30 seconds or so. Note how making your homepage handler async solves absolutely no problems whatsoever. # Whether it is async or not, rate limit! If I send 10,000 simultaneous requests to your server, most likely your server is more or less effectively offline for reasons that are outside your immediate power to fix: The network pipe is saturated, or some reverse proxy or load balancer ups and dies. But if it gets to your server at all, it doesn't matter if you're async or not, bad things happen: If your server is async, your server attempts to deal with 10k simultaneously, attempts to store tracking and process info for 10k requests and thus dies because your server doesn't have that kind of memory. Or it doesn't die, but your DB engine is limited to dealing with ~50 queries at a time, thus 9950 request-lifetimes are stuck in the 'wait for DB resource' state whilst your server handles 50 of them. Which is decent enough, except it's never going to get through the remainign 9950 in time so most of those will end up timing out. It'd have been a lot more efficient to just block most of those ASAP. If your server is sync, you get a very similar situation: 10k threads, 10k stacks (even more likely to spell doom, as that's at least 10GB memory even in the `-Xss1m scenario`), 9950 threads blocking on the 'acquire DB connection' step, whilst your server is happily serving up 50 requests. Again weeding out a random 9000 or so of those would have been better for all involved. 
&gt;Is it pronounced "goats"? Did you think that because of his beard? &amp;#x200B;
You should put Apache or Nginx in front of your Servlet engine where possible, just because you have far more control over requests and responses. It's easier to do caching there, HTTPS, compression, logging, rewriting, header modification. The list could go on.
its not a magic bullet and requires some work.. Its ugly looking for all those people obsessed with 5 letters static method calls verbosity. i am still experimenting within my own project. I am writing a Pascal Coin Java Power Tool Swing application using this model. I will share on github once its done. The idea is every class of your application gets a reference to the module context. EVERY SINGLE CLASS. Every class belongs to a module by way of its module context. My swing classes all gets a reference to a SwingCtx. The module context provide access to previously static methods as instance method by way of Utility classes. All of them. Only static methods left are methods that will be inlined / are pure shortcuts. If a method won't be inlined, then it goes into instance. Any method whose contract could possibly be overriden MUST go into an instance. The SwingCtx is final in all classes, given by the constructor. You can now easily create custom behavior (testing and other cases) by thinking around the SwingCtx or other module context. Each code module has its own class that implements the ICtx interface.
I always say 'guts' from the Germanic form.
/r/javahelp is the place for programming help questions. Still, none of the subreddit takes well to being just a second opinion to Stackoverflow (actually, this is explicitly forbidden in most subreddits). **Removed**
That sounds like the Service Locator pattern. I would go a step further and model your dependencies explicitly and then inject them (via IoC container) thus using Dependency Injection. You get similar benefits: inject alternative implementations for testing but in addition you avoid having God classes which have to know about any possible utils you could need in a specific context.
[gets is dangerous and should not be used](https://stackoverflow.com/q/1694036) though ;)
It's a great first language. Switching to another language is super easy once you have a good understanding of Java.
I don't want to start a new thread, so just to add to this nice comment: you can get your LTS versions from different vendors, who will then provide the LTS support: [Oracle](https://www.oracle.com/technetwork/java/java-se-support-roadmap.html) (obvioulsy), [Azul Zulu Enterprise](https://www.azul.com/products/azul_support_roadmap/), [IBM runtime for business](https://www.ibm.com/ca-en/marketplace/support-for-runtimes), [RedHat JVM on RHEL](https://access.redhat.com/articles/1299013) (only available if you run Redhat Enterprise Linux with a valid support contract), [SAP JVM](https://help.sap.com/doc/saphelp_nw74/7.4.16/en-US/47/dc90b4ef17452289f9128b8c2bbd77/frameset.htm) (mainly for SAP products running on Java), [Amazon Coretto JDK](https://aws.amazon.com/corretto/) (for the AWS cloud) and the free (as in beer and in speach) [AdoptOpenJDK](https://adoptopenjdk.net/) group. All of these vendors will provide compatible versions. The versions might differ in security patches (e.g. special patches for the AWS cloud) and in operation tools (special garbage collectors or ops tooling). Some versions bring garbage collectors optimiezed for low latency, real time (predictable pauses) or for terrabyte sized heap spaces. Others have a profiler built in (Java Flight Recorder). Others provide always up-to-date cloud installations. But they all will fully implement the corresponding JDK version and be tesrted with the Java compatibility kit [JCK / TCK](https://openjdk.java.net/groups/conformance/JckAccess/).
I don't have a problem with Debian. In fact, we currently use a Debian and an Alpine based image in our systems currently for reasons I don't really want to get to. I have a problem with Debian Sid being used. I'd prefer it if it were using Debian stable and then using apt-pinning to get Java 11 or something. Also, I could not find a good Alpine image for JDK11 Alpine does not have packages available for Java 9 and above. The only one I could find was from AdoptOpenJDK which downloads glibc and friends from random GitHub repos and Arch Linux repos which makes me very uncomfortable. You could argue that I shouldn't really care what these images are doing behind the scenes as long as they do what it says on the tin -- which is a fair argument, but it's not a sacrifice I want to make on our systems nor do I want to wholly maintain full images. If you could link to good images, however, I'd be very happy to be wrong and grateful to you, though. 
I can totally believe that. But I also think there are many other companies, like us, where the process wasn't smooth or without some serious trade-offs. We also used to use a Gradle plugin to docker images for us. But since the plugin didn't work with Java 11, we ended up ditching it entirely and changing our build system. I think this change was for the better and was worth it, but I feel like other organizations with lots of projects would not have wanted to put in that effort.
That would rather be G√∂tz
Just like you pronounce "Goethe".
Not anymore, AFAIK. I heard they fixed that problem. Which ones you're referring to, though?
It sounds to me like you already know your way around a little in Java. What I really liked about Java when I started was that it allows you to try out the just-beyond-basic concepts of programming (methodology, design pattern, etc.) pretty well, without making you jump through hoops (ie. go create your own linked list implementation first before you can try out some other concept) yet stopping your when you do something wrong (ie. syntax errors, errors in some logical constructs, decent exception messages). It is good at encapsulating your problem (ie. stop thinking about how to implement a linked list when you just need a collection of some object, just use an existing black-box implementation). Also, because it is a popular language, there is a ton of resources, solutions to likely your problem, and people ready to help you. Having an expert next to you also really helps. There's also plenty of demand for java developers. I don't know Python, so I can't give you advise on that or compare it to Java.
Spring has a non-blocking, reactive stack. Though thats not going to save you from DDoS. You need to deal with it in either stack.
Java isn't a difficult language, I'd say it's one of the easier ones. People who say that probably think about the very first interaction with a language: with Python, you can just launch a REPL and type stuff, or write a single line of code and run `python3 helloworld.py` to get a result, while in Java you need several lines of code and preferably also an IDE just to get started. But it looks like you've passed that hurdle: &gt; I've really enjoyed learning Java and created several programs so Python's main advantage is already nullified. I recommend sticking to Java, and then later trying out C, Python, Haskell, and Javascript, in no particular order, to learn other approaches to programming.
I don't know why there is no openjdk image for 11-alpine, but there is one for 12 and it is very simple. Why don't you use jlink to create your custom and smallest posible images deriving from the base you want (alpine, debian, etc)? Even if you cannot use jlink (or you have so many dependencies that you have to include the whole jre) I think it is more important to have a updated Java version designed to honor memory/cpu limits Docker than to have a smaller image or some specific issue than can be easily solve by creating you own corporate image. Even if you don't want to, that is not a reason to blame the 6 month release cycle. Maybe the openjdk hub is not mantaining the extact stack you want, but they are several to choose from and they are very, very simple
And before anyone asks, Goethe is pronounced just like Goetz.
I learned a little java in highschool and I'm a bit rusty but i think i can help you out. When creating a class, you want to make getters and setters to make life easier for you. Getters will output the data back so that you can use it. Setters will allow you to change data in the class. For example. Lets say you have an integer for the number of students in a classroom. The setter would be defining the students in a classroom. The getter would be sending that information back. You should make the setter method accessible from main.
This helped a little , especially that last part . Thanks .
I'm working with Java 8, so it may well be fixed in newer versions, but one specific example is which side the graphic of a `TableColumn` goes in relation to the text.... 
At a very basic level, the reasoning behind getters and setters is to have control over what code can read (get) the value of a class variable, and what code can set the value. If you have a public field in class A, any other class that uses A can set or get the value, so what you do is make the field private. Then to more tightly control the population of that field, you can make it private or protected. If the value in the field is sensitive, you can make it protected or require some sort of authentication with a public setter. It's a good habit to just start out with a private field and use getters/setters to access the field outside of the class. &amp;#x200B; When you get into frameworks such as JPA, it completely relies on getters and setters to populate the data from a database, but that's an entirely different conversation.
At my work the past year we migrated from a massive monolith to a microservices architecture (also went from java6 to java8, javaEE6 to javaEE7, from SVN to GIT, MVC to DDD). While I have not been directly involved in the decision process (I'm a junior developer), it has been an insane experience to go through. The biggest difficulty I feel we had or still have is stubborn senior developers who are not up to date anymore. I myself am very into architectures/clean code. Just to name some examples; implementing ugly lambdas, rest endpoints where statuscodes don't exist, rest endpoint where paths are just wrong, logic that gets implemented in the wrong microservice, etc... This all might come over as very negative, but there of course have also been some very good aspects. DDD approach brought a lot more clarity to the code. I don't know if our legacy project had correctly implemented MVC, but as I remember it there were packages with 5-10 repositories in it with their interfaces, then 5-10 services in their package with their interfaces, it was just a lot harder to maintain as opposed to a more domain driven approach. Responsibilities have shifted from 7 devs on a monolith to 3 teams with 2/3 devs with each team being responsible for like \~4 microservices. This has made it a lot easier to get into the project on a much more functional level. I rely a lot less on analysts when it comes to business logic because I'm working with the same parts of the code more often. Lots of stuff to mention, but in the end I feel like the positives definitely outweighed the negatives.
good luck setting up a kafka cluster
Getters and setters come to Java from old javabean standard. From OOAD point of view is the best practice to avoid it. So, use the get or set methods only if you really need it. Not automatically, as many programmers do. Usually, you need many getters, but only few setters, if any. If you are really OO programmer.
The moduleCtx class is indeed kind of a God class. Its had getters and setters for all its utilities. That's logical. The swing root package controls everything down the hierarchy. The javafx root package as well. You write a module, you are free to do whatever you want. If you want to write a personal extension to another module, you subclass myModuleCtx extends moduleCtx and use that one instead. In my vision, the God Class is a feature not a bug. Per module! But God bless me, you have several gods. I will have a GodCtx class specific to my Application UI, One specific to the BusinessLogic. The MyAppUiCtx will have a reference to the SwingCtx and the BusinessLogicCtx. My code does not use any annotations similar to Spring. I want a pure Java solution. I know Spring does. But as far as i understood there is a drawback. I want to be able to create several different ctx of the same class inside the SAME JVM process. My contexts are not singletons. I hate JVM singletons. Virus. Cancer. In my book, there are only contextual singletons. Period.
Or better, Apache, which is by far, the best web server available.
&gt; CE is fine. It will be as good as Eclipse Wrong. I've tried that route and returned to Eclipse. Eclipse is the best IDE available today, for any language.
SPAM from the JetBrains crowd.
Agreed, and maintenance and performance complexity.
Spring is good but it isn't JEE which is what the original post is about.
Yeah was turned off by chapter 2 and his multiplication example was convoluted and over-engineered. Kinda hard to follow. Should I continue reading?
Hmmm..if you say so man
You‚Äôre right that Goetz is dangerous, though. :-)
I'm learning these frameworks too at this point in my course, also having difficulties with it! You're not alone :) Lots of luck!
[removed]
wat
No
I‚Äôve been coding in java, JavaScript and go. And I‚Äôm just trying to wrap my head around how you would code the bloom of bullets that come out of a rifle. For example in the game Fortnite. It really doesn‚Äôt have to be specific to the game. I‚Äôm just curious about how anybody would go about it
I‚Äôll take math and vectors for $200 Alex
I can see holding back on Java 9/10/11, but Java 8 was definitely an important release. If you're coding in Java, you ought to spend time becoming conversant, if not fluent, in the features you mention: streams and lambdas. This is how most Java is being written today.
I would fine actual open source game engine, better 2D for beginning and take a look. Language doesn't really matter, general architecture and math behind it does. You will not like what you'll see probably. 
I figured it was something I haven‚Äôt been introduced to yet. I just didn‚Äôt know if you could do it in a coding language. But thank you!
I use reflection extensively and "type erasure" really is a non-issue. Type information is retained almost everywhere you need it (parameters, fields, superclasses, etc). The only thing that is lacking is a convenient way of passing type information in at call sites without using e.g. [TypeToken](https://google.github.io/guava/releases/23.0/api/docs/com/google/common/reflect/TypeToken.html). This would be fairly straightforward syntax sugar and wouldn't require any changes to the JVM. Kotlin is halfway there with reified type parameters at call sites. Most people who complain about type erasure don't seem to be aware that concrete type information is retained extensively at runtime and is accessible through the reflection API. The only real limitation is that instances themselves don't carry around their generic type information so getClass and instanceof don't work well with generics. Both of these things ought to be avoided anyway - particularly getClass - so I don't really see the issue.
If your site is so simple, it should probably be running as part of a serverless architecture. Or at the very least an autoscale group behind an elb. Running your own servers sucks.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Its probably done as shaders, so it's not java at all, but opengl or similar, which would run on graphics card.
You COULD do it in any language. But it's mathematically complex and will be quite ineffective (slow). That's why optimized libs with gpu support exist. But it's possible and quite interesting, so you could try to start from scratch (theory, simple projections of triangles, light reflection calculations and tricks to replace the actual raytracing)
to be fair I wouldn't bother reading it any further. I am ditching spring cloud and just learning kubernetes which I feel is easier.
Hi and welcome! The right subreddit for questions like yours is [/r/javahelp](https://www.reddit.com/r/javahelp) Merry Christmas!
thanks man. na zdarovija!
[https://www.reddit.com/r/learnjava](https://www.reddit.com/r/learnjava)
those are 2 similar subreddits or im missing here something without closer inspection?
 I recommend sticking with Java, especially if your interest is in developing *software*, i.e., programs to be used by many people for a long time. Java is a good choice for that because it is object-oriented, strongly typed, statically typed, and is absolutely committed to back-ward compatibility. It's time-efficiency is similar to that of C++. These properties make it an excellent candidate for large and complex application development, and a myriad of large software projects is implemented in Java. Python is more useful as a scripting language, making it easier to try something out quickly (e.g., answer a specific data science question rather than software development per se). Because Python is an interpreted, dynamic language, small programs are often quicker to write but they need more testing, and their performance is comparatively low. 
For real just get a textbook and pound away. There‚Äôs no flashy answer, if you choose to learn via internet just make sure to make a plan and not bounce all over the place. Oh, and it‚Äôs gonna be uncomfortable, theres a reasons developers make good salary 
I would strongly recommend John purcels free course on udemy. Just Google udemy and make an account. John also has a website called caveofprogramming 
well the thing is when i learned i enjoyed that but i learned after work, long shifts n shit. I couldnt make that happen at the end. But well, ive changed my day job cuz i still need money but less stressfull. &amp;#x200B; I mean more like free courses from ground zero. Ofc there is like a lot if uacademy courses n stuff but not the best quality also, erlier i used [lynda.com](https://lynda.com) but thats not for my pocket atm. Prolly i will cont the colleouge at some point. &amp;#x200B; Thanks for answear.
thanks man. Im on it. Thanks for sharing :)
Learn to google effectively. No offense cuz obv we all wish the best for you, but if you can't immediately find the answer to the question you are asking in this thread and the 100,000 more you will have, you will have a rough time.
ur right but i can also say uacademy courses for begginers are real shit, sorry for language, like poor audio quality, broken eng and so on. So i just tried asking from expeirence. also google has a ton of informartion so i just wanted to TRY to find a schourcut. :) But thatnks for critic, its allways good.