Makes sense. LTS is for "real" projects. Non-LTS releases is giving more use than just beta testing or figuring out details. Then again, language design is something that is hard to change, even if you don't support old versions - but so far nothing gets into java too fast, so does not look like an issue yet (plus it actually avoids trying to push into release if you know next one comes in 6 months. Except if LTS is coming, in which case you will try to get it into that one.). Basically same as Ubuntu or other distro releases.
You're preaching to the quire man but...I did some C# development recently (though I usually stay away from it but I like the people at work); it seems it's getting a lot more common in that world, .Net, so I assume it will continue in the Java world. If you keep them compact, they aren't too hard too read and create/maintain. I haven't tried a benchmark yet, say the lambda v/s non-lambda version of a method run let's say, 10 million times through a loop. I stay away from multi-line lambdas though. For every reason cited in the article I linked to above. I wish FP had never been added to Java but it's here, I don't see it getting removed unless someone from the corporate world got involved to fix Java. Someone with influence tried to turn Java into the new JavaScript I think, without understanding long term maintenance in the enterprise. 
Who cares. All of my legacy apps are in Java 6 anyway.
‚ÄúAs /u/catapop clearly said: ‚Äòa big change ... to 10‚Äô. I don‚Äôt think this is the right move going forward and should be looking at contingencies and triages ^(that fit into my excel spreadsheet). Thanks! Great meeting everyone!‚Äù
I only recall that being true for pattern matching features.
- Android - Web Applications - Client Data Visualization
??? Surely 6 months after 10 they'll release 11 right?
Hmm. I should probably upgrade. Have one box running 1.6 and a few running 1.7. And one running 1.8. I was planning on upgrading all of them to 1.8 in about a year or so. But I guess I'll just stay with 1.6/1.7 running old versions of Tomcat. I suck.
No - I mean change the release/numbering scheme they've come up with (and keep changing).
But that‚Äôs orthogonal to /u/catapop‚Äôs point. If your organization is already on 9, then clearly corporate policy is much more willing to upgrade to the newest technologies. At which point the pain of upgrading is more related to the actual technical challenges not bureaucratic. 
Java 4 here... üòî
If you thought dependency hell was bad before, then you haven't seen anything yet.
Ignoring the obvious lack of knowledge, and assuming Java is per se (as a not new-and-shiny toy ecosystem) 30% legacy, trust me there is Java and Java legacy systems. And those are 3000% legacy using technologies deprecated even by the Java ecosystem's standards. These are the ones I meant.
There never was a Java 4. Version progression was: * Java 1.0 * Java 1.1 * Java 2 Standard Edition 1.2 * Java 2 Standard Edition 1.3 * Java 2 Standard Edition 1.4 * Java 2 Standard Edition 5.0 * Java Standard Edition 6
Oh, heh. When are they releasing 2.0?Or is that what 10,11 are -- 2.0 and 2.1?(e.g. 5=1.5, 6=1.6, 7=1.7, 8=1.8, 9=1.9, 10=1.10?, 1=1.11?)
What I am saying is maybe there is something wrong with the Java notion of *security* if it's critical to move to new language/jdk/vm? version *the moment it comes out*. Honestly I think you've got things backwards. If Java is about being a programming language, they should accept that not everybody needs or wants the entirely underlying ground to move constantly. If it's about providing a tool to business then the focus should be on doing what the business world needs which is less chance and more reliability and stability.
Yes, us freeloaders get some overlap between 8 and 11, but will there be overlap between 11 and 14?
No, you didn't respond to the problem that unit tests simply don't get maintained. Even in a company that values tests, you can get them to maintain end-to-end tests, but it's incredibly time consuming to maintain unit tests and really really hard to confirm that they're actually being maintained. For most companies the small slice of things that can only be covered by unit tests are not worth the enormous additional cost in time to implement, and I've yet to see a corporate-culture solution that leads to everyone not just trying to write short useless unit tests to pass a checkbox item off. 
More release but less things in each one too. So smaller breaking changes and so it is easier to stay up to date. In a lot of cases, you just change your JVM and you have nothing else to do anyway ;)
I was introduced to Java through AP Computer Science A, and just fell in love with the platform . My first language was C++, sadly.
So, I haven't done much programming in Java 9 yet, and barely learned any of the changes from 8 to 9, but what's the point of me learning 9 or even 10 when personal computers are still only updating to 8u161?
Through a job where part of my responsibility was supporting awful IBM legacy web apps from the 90s. Through learning that, I learned that Java was actually really good at a lot of things and that modern development wasn't nearly as awful as the legacy practices made it out to be. I was able to improve a lot of pieces of the system by upgrading to Spring Boot and Jersey.
I am just starting to get into web dev with Java. I don't particularly think I will use it, but I am curious how the Faces libraries work, because that looks quite powerful for interface development.
JSF? I don't see that nearly as much as Spring. I've honestly never used them. I just always discounted them crappy old Oracle cruft after learning it was XML configs. Java is actually used quite heavily in web development for APIs, though. I do not agree with GWT or Vaadin where you build your interface in Java and it compiles to JS &amp; HTML. I believe the web UI should be built with the proper technologies. Thymeleaf was ok, JSTL wasn't terrible, but the trend for all stacks is client heavy web apps and I personally work mostly in JS now.
The company I worked for got bought by a Java shop. &lt;cry&gt;
Only 20?
Since I was about 13 I would learn just enough of a language to scratch the itch and then move onto something else. When I was about 24 I decided to learn Java deeply because there was a lot of utility for it. I was a tester at the time and wanted to learn Selenium and picked the Java language binding because the devs I worked with we're Java programmers. I just kept working with it to do non test automation tasks and enjoying it so I kept going. 
There was a fallout between the two at the end of the 90's because MS wanted to remove Java from the map using their "Embrace, extend, and extinguish" tactic. 
And patches. EOL on Java 8. 
Maybe he did mean preaching to a stack of paper.
It‚Äôs just a 2. Try jumping from 1.4 to 5!
MSVC was driving me batshit crazy. Everything was just so fragile. That was in 1996. I installed JDK 1.2 and never looked back.
That. Guy works here too... sometimes it takes me 15+ min to figure out wtf...
Assuming you have the JRE installed and on your PATH variable, open a cmd prompt, navigate to the folder where the .class files are located. Type "java Pacman.class".
That build.xml is an Ant (http://ant.apache.org) build script. Google tutorials on how to install it on Mac, there seem to be plenty.
Knew I wanted a career as a software developer. Heard Java developers were the most in demand. Picked career as Java developer.
Introduced to several languages in school. My department taught all upper level required classes in Java. Got an internship writing Java and javascript. First programming job used java javascript. My current job uses Java, Pascal, Perl, python, JavaScript. Also c/c++ but to a lesser level and since I have no exp other than a basic class I try to let others pick up those bugs. I was not hired in my current position as a programmer. They just realized I can write code and debug ;) 
That's coming down the pipeline eventually.
I hope that's the case. Of course, we'll have to battle process and people refusing to fix technical problems along the way
Just talked the other day about this. I am not even reccomending an upgrade to 9. I want vars from 10 but won't get them until 11 because LTS. Security is more important than cool features :) Each time we touch the java upgrade it kicks off some fun things... upgrade the build agents, upgrade the ci upgrade the product. Then it's time for a regression pass and a full automation. Sure it's easier than it was but for now, no thanks. If it's not it's I don't want it.
Hehe thanks, yes choir. It reminds me of the BB episode where Amy's autocorrect caused Bernadette to think she was supposed to tell the gang about Penny's new romance with an astronaut. It was supposed to be architect. :-)
I believe it's just "java Pacman".
Yeah youre right
Java seems like the best place for me to begin since people act as if cpp entry level jobs don't exist. 
Head First JavaScript is from 2014. How can that possibly be on a recommended list in 2018?
It is going to be a mess... 
In other words, death to pixel-based sizing!
jdk1.7.0_80 Represent!
what is dead may never die
Yeah, don't want to add one more language to the stack... I can wait ;)
&gt;Nothing super interesting as far as Java dev or basic IDE features goes Sounds like the typical Eclipse update. /s I just wish they'd ditch this EGit abomination and directly interact with native git. It's very slow when dealing with bigger repos and it supports none of the recent git features. I use it for simple commits and resort to native git for everything else.
1.) Applets 2.) While I was taking a corporate paid for Java training week course, I wrote a web server one morning in notepad and stymied the instructor. It was 1997. I'd already taught myself Java, coming from C++ it was a breath of fresh air. 3.) It was very clear to me it was going to be huge starting in 1995. 
20 years from now someone might be saying that about your code. :-)
I coded PHP first (I know!), but the Java jobs offered much better pay.
I'm still waiting to figure out if Jigsaw panned out or not.
Ecosystem. I started my career as a C# developer. After two years of doing C# mostly and taking with Java guys I realised how rich and open Java ecosystem is. You can have a lot of choices in terms of frameworks/libraries/tools. And you can do that on Linux as well.
Actually, Microsoft wanted to extend the byte-code specification and add windows-specific extensions to it to make it easier to do system-level operations. The alternative was to go through JNI which was slow, error-prone, and difficult to maintain compared to their approach. Microsoft refused to implement JNI and RMI, instead providing their own implementation called "J/Direct". Their implementation, Visual J++, also supported ActiveX, further breaking cross-platform compatibility. Sun wouldn't allow them to do this, rightfully so as it went against the core principle of Java's design of portability as well as being concerned that this was an attempt by Microsoft to lock people into their operating system. Microsoft was in breach of their licensing agreement with Sun. A lawsuit followed, Microsoft lost, and their license to develop a Java VM beyond their initial release was revoked. As the Java language continued to evolve, Microsoft were locked out of being able to add Sun's new features to J++. Recognizing that there was substantial demand in the Enterprise for a better way to develop server-side software than Perl/CGI, wanting to hedge their bets against a competitor to ASP that was quickly surpassing their market share, and not wanting to miss out on the opportunity that Java had opened up as an alternative, they created their own competitor. They migrated their J++ users to C# and proceeded from there.
Honestly, what brought me to Java was being able to write programs in a real OOP language without having to resort to Smalltalk. But, this was in 2000, and I was a VB 6 "refuge" and I had no wish to resort to C++ to scratch that itch. These days, I would scratch the same sort of pure design instinct I had back then with something like Haskell, Kotlin, C# on .NET Core, or maybe Scala if I'm feeling complicated. But really, in the end, the really tenacious ones amongst us will do one of those in our free time and and stick with whatever we can get paid to do. :)
Making android apps brought me to Java. That was pretty much the only reason What kept me there was paying jobs. Since I love math; I wish I had chosen something else (like C++), because a significant portion of Java jobs are backend web services or enterprise apps, and that kind of work bores me and doesn't challenge me. If I could have done it again, I'd probably have chosen C++ (or similar) because most "mathematics" or "R&amp;D" style jobs I'm interested in (like graphics, gaming, etc) are usually in C++ or a similar langue &amp; almost never Java. I now work mostly with Scala, which is a lot nicer nicer, but still mostly building the same things (web backend). Of course a lot of programmers don't like math, so the above reasons don't apply to a lot of people.
Do people who planned this stupid release cycle work in an average company? I don't think so. Otherwise they would know that such upgrade cycles are not possible, due to dependencies to other tools and frameworks.
Personally, I find 99.9% of subreddits' CSS to be annoying and redundant. I just disable it in the user options. Everything looks much cleaner and I can focus on the content. 
It was actually WORA when compared to the problems of writing portable C and C++ code, back when most C compilers were still catching up with ANSI C and C++89 did not exist yet. Followed the same spirit of Smalltalk tooling regarding IDEs, being bundled with nice collection and GUI libraries. Even though it was interpreted and later on JITed, I always hoped the AOT compilation would be made available in the free versions, instead of having to buy it. Well, had to wait until Java 9 for it to finally start happening.
Work, I have a C# .NET certificate, but the work was in Java. I did Jave at university and switching from C# wasn't hard (although I still miss my automagic properties :'( )
I was looking for a JavaScript job and a Java company picked me up. I even asked if they didn't confuse Java with JavaScript but they told me 'yeah suree-ish'. I was without collage back then so how could I decline. Didn't wanted to take risks after being NEET for a year. Anyway I hated Java at first but now I enjoy it. And I better enjoy it because I ended up doing almost only it/kotlin with little web in sight.
I liked how source code looks. 
So it's basically another messaging system?
We won't switch until all the libraries we use support java 9, or at least don't produce a ton of warnings due to cross-module dependencies. I believe spring boot 2 is the last one we are waiting for ATM.
Please, for the future, address *programming related* questions to **/r/javahelp** as is clearly stated multiple times on the page.
Removing the overflow auto from the .md class thats attached to the div above the textarea works aswell. And it then allows you to actually widen the textarea. If you do want to prevent horizontal resizing, set resize: vertical on the textarea css.
Drop Java :D
I'm not sure how the whole process works or how significant this is but it looks like there are a number of important people listed as [contributors](http://openjdk.java.net/census#loom).
In University first year I have been introduced C/C++. The concept of pointer was so hard to understand to me. Then in OOP course Java has been introduced without no pointer (!!!). I found that the Java was simple, easygoing. Even there is no collection literals. That's the story. :)
I had a choice between Java and C#/.net. I chose Java because of research about need for developers in the job market. Where I live the need is mostly for .net but overall the trend I saw was Java. Now that I actually learned the language none of that has anything to do with anything at all... I actually like the fact that it's static typed rather than dynamic - helps keep shit clean when talking to the DB and I like how matchy-matchy types 'usually' are with mySQL and keeps me from polluting methods with the wrong values/types, even if a bit verbose it's readable, it allows for whitespace. For those reasons I prefer it over having to use JS (though improvements have been made with 'let' for scoping var and I can't avoid anyway if doing front-end anything), or Python which is still a really cool language.
me to. Thats a different thing though.
Learn some Rust. It will most likely start to replace C++ and is a great change of paradigm. This is always good as a programmer to see other ways of doing things. It often makes your code in the current domain better.
Work
Java has pointers. You just can‚Äôt do pointer arithmetic.
It was the last language I had a course at the uni, so it was the "most fresh" language I had knowledge of. Most companies hire "people with a set of skills", and Java stuff was on the rise, so it was the easiest way to score a job. And here I am, trying to get out.
What are youre file names?
1. create directory *com*, then create directory *zetcode* inside it 2. put the .class files inside the *zetcode* directory 3. run `java com.zetcode.Pacman`
Do you mean references? I think when people say "Java has no pointers", they mean mostly in the context of things like C interop, where you have to emulate pointers with FloatBuffer/ByteBuffer like structures.
Not quite. C has references as well. Pointers, to me, hold references to objects on the heap. Hence the name `NullPointerException` when you try to invoke a method with a `null` pointer (reference variable).
My computer science coursework was developed with Java in mind. Having mucked around with Python and C a bit (and BASIC way back when), I liked the syntax of Java and the rest is history.
Exactly two weeks to wait then. :\)
If the LTS versions ultimately bring more pain to its users, then maybe there is something wrong with the release schedule.
I see you haven't paid any attention to the release process. That or you're intentionally ignoring the LTS releases.
Use Lombok and you'll at least get val.
Yep. preferences &gt; display options &gt; allow subreddits to show me custom themes Fixed many annoying subreddits.
Money. I was looking for a language that would land me gigs.
Closest comparison I can think of is Dropwizard. Like Flask, it's a fairly lightweight framework used a lot for api development and has a large community. Spring boot is another popular choice, but it's a bit more feature rich and I would say it's a bit closer to Django or Rails. It's a bit heavier in terms of it's features, but uses convention over configuration to reduce complexity when you're starting a project. 
oh i should mention this app was running in web sphere 
I don‚Äôt know why the author didn‚Äôt actually put it in the list, but he says Effective Java 3rd edition should be the first book you read in 2018. 
This is what I meant with their "Embrace, extend, and extinguish" tactic, thanks for expanding it.
Why 20yrs? I'm sure they are already saying that about the code I left at my first job! lol
SparkJava http://sparkjava.com/
Another option, stick with swagger and create a template of your API. Then generate client (js) and server (spring boot for instance) code you need. Online Editor and code generator: https://editor.swagger.io/ Also, if you're comfortable with Maven, you have the generator plugin ( https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen-maven-plugin ) and a lot of languages you can generate the code ( https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen/src/main/java/io/swagger/codegen/languages )
Google: "What's the best and most popular programing language". Something in those lines brought me to Java.
Indeed
I like javalin.io
Hear ya loud and clear. We want folks to be able to choose their preferred DSL in the docs, and have some samples. Contact me if you want to help converting some build scripts :)
Also, https://javalin.io/ Made by the same guy
This! Really simple and easy to use
http://jooby.org/
Whether or not the arguments in this article are right or wrong is undefined, since _literally_ no sources for any of them were given. All of the arguments are solely based on speculation and hearsay.
Spring Boot - but it is a really complex framework. Play framework - it was used by Linkedin previously, you can code in Scala / Java.
https://www.owasp.org/
I have a tip, find some simple impls of Kademlia. It's not that hard, it's based on peer closeness based on peer IDs. I've done a couple of toy implementations. And don't do the networking up front. Just abstract it into an iface and have multiple peers using an in-memory impl of your network iface, then move to a legit networked impl later. The Kademlia paper is fairly easy to read, no need to jump to S/Kademlia yet. Everything is about ID/hash distance.
Lombok has a val keyword? 
I cannot recommend grails highly enough. https://grails.org
Thank you!
Yeah, apparently service bus technology is old and last year while event grids and other fancy names are the thing, even though its basically the same technology over and over. TBF Azure has been hurting for an integrated SMB solution for a while. you could always host a commercial one or roll your own but there was no one-click bus to plug into. so its not bad, just nothing special more than needed.
We are all older than you think
This can be counted as a "joke" answer, but I'd like to plug [Karate Test Doubles](https://hackernoon.com/api-consumer-contract-tests-and-test-doubles-with-karate-72c30ea25c18) which is relatively new. This will give you what I bet is an experience *easier* than flask. Here is a Dropwizard (recommended by others in this thread) example [ported to Karate](https://gist.github.com/ptrthomas/35ef9d40623cbeade7388b2cbb29a3b1) which shows how 8 files and 200 LoC became just 20 30 lines of code.
JGit is a Java implementation of Git. Egit is UI (eclipse based obviously) on top of Jgit.
Except you lose the two factor part here if you use email for both factors. Other than that it's fine.
 path("users"(() -&gt; { That looks wrong.
Technically, you're not reducing the number of branches, you're just hiding one branch inside Optional. A better solution might be to add another constructor for your ResultDto: public ResultDTO(Option[] results) { this.someOptionalId = results[0] == null ? null : ((Number) results[0]).longValue(); } You can test both branches in this constructor easily. Or make a another public mapping function that takes the Option[] and returns a ResultDTO. Again, you can test that separate function easily.
Who has not read clean code in 2017?
I'm open to running it locally, might be a not reasonably undertaking. Which would you say is the hard part? 
https://projectlombok.org/features/val
Well ... i just got interested in Java for backend
It looks like you wrote a lowercase I instead of an uppercase I. This has happened 5373 times on Reddit since the launch of this bot.
Before we go too far down the rabbit hole here. What sorts of numbers are we talking here. Roughly, how many API endpoints immediately? Will it grow ? Databasewise. where are you headed NoSQL ? some relational system? Mysql ? Postgres ? Finally what sort of user volume are you going to see? Is this Facebook? or is this a in-house system for a 100 person company ? Where/How do you want to run this thing ? on a server with 20 other items in a closet at work ? A data center ? Cloud ? Ec2 ? These are all important questions when picking technology.
&gt; you're just hiding one branch inside Optional. That reduces the number of branches, because due to the restricted semantics of the Optional type, the program now has less degrees of freedom. &gt; You can test both branches in this constructor easily. The dilemma posed by this question is regarding the choice of code structure vs. the number of tests cases to write to satisfy testing tools like SONAR.
I played with Struts2 and I really liked it. How similar are they?
Well. It's quite standard the architecture: microservices running on aws using dynamo'db and s3, potentially rds.
why spring? is it so good?
Spring is to Django as Spark / jooby / are to flask. If you like a framework that dictates how you do everything its good. If you want a minimal framework where you have more control you wouldn't like it. It also has a huge learning curve.
Imagine you plan to build an RV. Where do you want it to end up? Class A, B, C, Prius, pop-up tent?
University 
That Optional will likely be scalarised anyway so I wouldn't worry about using too many objects.
Ah this looks much better with all the global state.
I'd say its more like building a kit car vs building a car where you select the parts yourself. One you follow some directions the other requires much more knowledge of what can hook into what. Both can give a working car but the lower level one can give you exactly the car you want. With the minimal libraries if you know what you are doing you can build something superior to the kit car. If you don't know what you are doing you can build a car that doesn't start.
Struts2 is just the MVC part whereas Spring Boot and Play are more ecosphere frameworks (Spring Boot moreso than Play). For example, you could use Struts2 with Spring Boot just fine (instead of SpringMVC).
Spring Boot is incredibly powerful and capable of serving vast enterprise setups, but can also be bootstrapped to a basic REST server in 10 minutes. 
I'd be careful about any claims of replacement, but rust is brilliant. It taught me quite a bit about c++, too.
&gt; Personally, I find 99.9% of subreddits' CSS to be annoying and redundant. I just disable it in the user options. Everything looks much cleaner and I can focus on the content. While this is true, it shouldn't be considered an "out" for subreddits with poor UX. Particularly a programming subreddit.
I know that aws just tries to sell it as the database of the future but at the end people use it and regret instantly when they understand that the data-model is compromised by a bad datasource choice. I just want to use it as it is included for free in the free-tier.
Pacman.java and Board.java
I haven't taken an indepth look at Rust yet, but it's on my radar &amp; I've mostly heard great things so far.
Yeah i've done that already... Didnt work
https://docs.spring.io/spring-security/site/docs/5.0.1.RELEASE/reference/htmlsingle/
I have been leading you astray, sorry. I didnt notice the packages in the files. The guy below me is correct. Another way is to delete the first line from each java file that declares the package. Then run those 3 commands again.
G1 is in Java 8 but the parameters available to tune it were improved (simplified?).
Go reactive, go vert.x
bad bot
Again, so is RDS. I‚Äôll give you the same answer I give everybody - unless you have a very specific predefined usecase that maps perfectly to what Dynamo/Cassandra do, just use Postgres. It will be easier in the short term, cheaper, and you won‚Äôt be fighting your tooling.
Java 9 -&gt; Java 10 == Java 1.7.0 -&gt; Java 1.7.1
You have an incorrect mental model. If you think of Java 9 as being 1.9.0 and java 10 being Java 1.9.1, you‚Äôll be pretty close to the truth. The JVMs greatest strength is it‚Äôs backwards compatibility. Barring runtime bytecode generation, java agents or app servers that do unspeakably horrible things to the runtime, 99.9% of the bytecode that ran on a previous version will run, and 99.9999999% of the code that compiled under a previous javac will compile under a newer one.
A million souls just cried out in anguish, and then were silenced under the weight of a million OSGi plugins.
Making this a first class feature of the JVM would be essentially the best thing that‚Äôs happened to the platform in over a decade. Hell, don‚Äôt even put it in the JDK, just add bytecode level support for it - first class continuations/stack dehydration would be a revolution in code clarity, tooling and performance.
You‚Äôre doing God‚Äôs work. As a mainly Scala guy, I want powerful lowlevel constructs for stack dehydration and dehydration so badly it hurts. 
Yeah. I have to say that I was extremely impressed with the auto completion too.
Tell that to 1.5 and 1.7. Had to rewrite a metric ton of legacy code when we were forced to deploy those versions (years and years ago). When you work in enterprise, even the smallest change requires extensive testing, which is not going to happen every 6 months. People can downvote all they want, but it is still a horrible release model. Oracle is going to slowly kill Java
except it's much better.
You should look into VSCode. It's like Notepad++ or Sublime on steriods. Ever since going open source they've gotten great plugins like this article is about. It's my default node.js and React/Ember editor. 
I never understand why more people aren't using Mulesoft. This is a great use case for it. 
Using struts 2 and spring boot together is a great way to get fired
And not static
I wrote my bachelor thesis about a secure version of Kademlia, in which nodes could only join if they owned keys/certs of the same CA. I implemented it too (in Java) and tested it with a network of hundreds of nodes. It was super slow and very much useless. It was 10 yeara ago or so though. I will see if I can find it for you tomorrow. I definitely have the paper, but I am not so sure about the implemention. Not sure if I still have that.
Well, if you look at it from an input/output perspective, there's 2 input types (null and not-null) which map to two output types. In the abstract, full coverage dictates that you test both cases. However, the tool in question doesn't detect that Optional.of(xxx).map(yyyy).getOrElse(zzz) is the same as the ternary operator and a null check. It's entirely possible that a future update might be able to detect and flag this as requiring two tests.
All of you have loved ones. All can be returned. All can be taken away.  òÃ≤_ ò *** ^^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Block**&amp;#32;**me**](https://np.reddit.com/message/compose?to=friendly-bot&amp;subject=stop&amp;message=If%20you%20would%20like%20to%20stop%20seeing%20this%20bot%27s%20comments%2C%20send%20this%20private%20message%20with%20the%20subject%20%27stop%27.%20)&amp;#32;|&amp;#32;[**T“âheÃõ&amp;#32;LÃ®isÃït**](https://np.reddit.com/r/friendlybot/wiki/index)&amp;#32;|&amp;#32;[‚ù§Ô∏è](https://np.reddit.com/r/friendlybot/comments/7hrupo/suggestions)
&gt; I know that aws just tries to sell it as the database of the future They really don't. They are clear that it has very specific use cases. For a 'generic' use case they tend to push Aurora. 
What's the benefit of your code in comparison to using an enum?
I don't really understand how this is 'damage'? It's your choice to handle this yourself instead of using some kind of standard library or shared library. If you write code yourself instead of (re)using something it's more work, partially because you also need to test that work. Whether you use a monadic approach or 'just test' it, it doesn't really matter to me. That's personal preference. Both methods could be generalised into utility functions you only need to test once. And sonar is right to complain if you don't. 
It is not better than enum. I will add the enum approach now as well to make the article comparative to better or worse alternative implementations. 
Is it free? 
I waited it.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
While I‚Äôm not fond of Spring either, mostly due to bad experiences with the old versions of Spring DI. And lots of the problems in the early days of spring are fixed (like less/no reliance on xml anymore) I can‚Äôt deny that if you‚Äôre writing microservices, Speing Boot is probably the best fit. You get a running service really fast and the documentation is better than the alternatives. 
I'm sorry - I'm not sure what you're suggesting.
Exactly why I prefer Spring too. The ecosystem is rich, there are many side libraries which make things like social or nosql database integration as easy as it can be.
Frameworks are evil :) But pays well.... When I have the choice I use NO FRAMEWORK, just libraries. 
Without being too much into the things I don't see how prepared set of configurations, dependencies and etc makes you better or good developer. What it does though is to save you from repeatable meaningless boilerplate coding and in the majority of cases setting up the same "proven" configuration again and again. I do agree with you that this hides a lot of stuff but as someone already mention documentation is there and believe me if you want to read it and change something you are free to do. I believe that developers nowadays should concentrate on quality coding of new features instead of writing boilerplate or reinventing the wheel. This knowledge is important too but what is more important is to produce something that work properly as expected as fast as you can ( especially in startup environment or microservices). Using frameworks saves you time of testing your boilerplate code and configuration too since this is already covered as part of the framework testing itself. And by the way on the "obfuscating part" I can argue a bit since it is quite easy to debug in the majority of cases and as already stated quite well documented.
You shouldn't need to be "sold" on anything. Having an inherent bias towards something that you have little to no knowledge of makes no sense. It's out there and free, so try it out yourself. &gt; making you program only the way he wants There's nothing wrong with a framework being opinionated. Is there something wrong with the way Spring likes you to do things? &gt; sadly I cannot find any good reasons online to justify the goods of such monster I really find this hard to believe. Did you seriously find nothing when typing "benefits of spring" in to Google? To give you the benefit of the doubt, here are a few advantages: 1. It's easy to use - you can get an application up and running within a minute, especially with projects like Spring Boot. 2. It's modular - there are a slew of modules that can be included to do everything from security to databases to transaction management to service discovery, etc. 3. It's well supported - development is very active, feedback is taken into account, and they learn from past mistakes (e.g. XML). 4. It removes a lot of work from the developer - I don't want to start off every application by re-developing all the basics of what Spring gives me out of the box.
It's not the weapon the problem, it's how people use it. Spring is just a tool, there is nothing good or bad about it. Before using Spring, I thought it was a bloated aggregate of heavy libraries which only slow down your application. At this time, I only knew a few developers using it in the company I was working for. They were only creating IService interfaces, and ServiceImpl implementations. non-sense! They were also using the XML configuration (it was almost 4 years ago), which seems a huge step back from vanilla Java code. Then, I gave a try to Spring Boot. The way it makes it so easy to create new services and use them in Rest Controllers is kind of magic. It removes a lot of boilerplate code you would have to write by yourself otherwise (without dependency injection). I used to be a Guice advocate but the Spring ecosystem is so rich and pretty well designed that I don't see why I would use another framework. As a startup, we need to focus on business code not on factories and wiring code together. Spring does exactly the job for us.
Leveraging third party tools in order to let us focus on the unique aspects of the problem is not being a mindless puppet. It‚Äôs adding value for our employer and putting ourselves in a position to be tasked with the more interesting projects later on because we‚Äôve proven we can get stuff done. I used to not like Spring. I thought it did too much for you, was too heavy weight, used too much magic, etc. But these days my backlog is too big to not use Spring. I also recommend checking out Spring Boot
This. I'm working in Spring and Dropwizard frameworks on the job, and at home, I'm playing with other stuff. When I was migrating from the Spring to DW, the main issue was lacking some functionalities in DW which I had in Spring. At that moment I have realized how much did Spring spoiled me with some things. Don't get me wrong, I don't want to tell you that Spring is good/bad. Every programming language and every framework has pros and cons. Try it, do something "smart" in it (not just hello world) and see if it fits you.
Totally agree it is not perfect and yes it spoils but isn't this the idea of any framework - to make your life easier. Obviously when comparing few different frameworks they will have differences due to various factors but I think it is down to people to decide if certain feature is good or bad for them and that is how they pick which framework to choose. Again we can argue was it really spoiling or just nice thing that you had this sorted out there and not in DW. Obviously there is no right answer to this question since it is down to many factors and different people will have different opinion. Which is not bad actually :)
understand your (network) architecture. Layer your application. Protect your boundaries. Know your (organization's) limitations. Use SSL. Know the [OWASP top 10](https://www.owasp.org/index.php/Top_10-2017_Top_10) 
Damage in the sense that [DHH meant it](http://david.heinemeierhansson.com/2014/test-induced-design-damage.html).
**Doing things the hard way doesn't make you a good programmer. In fact, it proves the opposite.** You shouldn't have to be "sold" on frameworks. Spring is an industry standard that, not only prevents you from writing thousands of boilerplate code, but is really more powerful than a single person can hope to be. You've got to realize you have teams of people testing a framework that handles dependency injection, security, handling servlets, and virtually anything else you need to make a serious full stack application. You can try to learn all that stuff on your own and build it from the ground up, but you're just going to get outperformed by everyone else who doesn't have something to prove.
All automated code metrics are naive and should not be carelessly optimized for. If you are writing worse code in order to appease your code coverage requirement, stop and think about what value you want to get from test coverage. If there's a valuable test you can add, do that instead. If there's no valuable test to add, consider relaxing your code coverage requirement.
How about you sell us your view on why frameworks are bad?
For me, Spring is great tool for programming web applications and I think that's a really good way to demonstrate its advantages. Try to create a simple but not just-one-hello-world-page MVC webapp using java servlets. Then do same thing using Spring, compare the code/results and you're most likely going to see that Sping handles quite a lof boilerplate code for you - Dependency Injection, controllers, security. Spring is not 42, but it's a great tool imo.
For the same reason you use JDBC and don‚Äôt open a TCP port to your database server manually instead and reimplement the communication protocol. Or the same reason you use Java instead of assembly. It saves you from reimplementation of boilerplate code. 
&gt; Well, if you look at it from an input/output perspective The point is that switching to `Optional` lets me write less test cases *to pass SONAR*, as in, I'm letting metrics drive how many tests cases I write. More philosophically, extracting functions, using DTO classes instead of `Map` or using constructs like `Optional` instead of conditionals, let you get away with writing as many tests because you're operating at a higher level of abstraction. It's like the static typing vs. dynamic typing argument - you need more tests for a dynamically typed program because the type system does not provide enough information to the compiler to eliminate a large number of tests. &gt; It's entirely possible that a future update might be able to detect &gt; and flag this as requiring two tests. That is not how SONAR's *branch coverage* works, which is based on [cyclomatic complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity). The `Optional` version doesn't have any boolean conditions that can generate multiple branches, compared to the boolean condition `results[0] == null`.
**Cyclomatic complexity** Cyclomatic complexity is a software metric, used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's source code. It was developed by Thomas J. McCabe, Sr. in 1976. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Like I said, the point was to make SONAR happy without writing more tests, which could be considered "damage", depending on your perspective. In this case, as I also mentioned, another API is returning the result set as `List&lt;Object[]&gt;`, which would require redesign to fix. I would rather use `JdbcTemplate` to directly map the `ResultSet` to a DTO.
Everyone not writing their programs in assembly is spoiled. Somewhat relevant: https://xkcd.com/378/
This is a false dichotomy. You don't need to redevelop everything if you don't use spring - there are lots of other options out there for various tasks that are just as easy to get off the ground.
Mixing and matching nulls with Optionals seems dangerous - if I see code using Optional I would assume then that nulls have been caught at source and either filtered out to replace by Optional.empty values. In any case, changing code simply to keep a code coverage tool happy seems like a fool's errand - see [Goodhart's Law](https://en.wikipedia.org/wiki/Goodhart%27s_law)
**Goodhart's law** Goodhart's law is an adage named after economist Charles Goodhart, which has been phrased by Marilyn Strathern as: "When a measure becomes a target, it ceases to be a good measure." This follows from individuals trying to anticipate the effect of a policy and then taking actions which alter its outcome. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
He didnt say frameworks are bad, he said spring is bad.
Thanks.
The only really benefit is organizational. It's hard to keep teams organized, especially when they may have limited communication with each other, and having a common baseline that touches all the bases takes the guesswork out of things for them. There is no technically list of reasons why you would need to use spring.
I used netty and javaRX and worked perfectly, also had total control and code was quite lightweight, notice, I used two well known frameworks. I do not see how using anotations and letting framework handle everything for me would help me in the future when I face some problem that requires knowledge about how the protocols network protocols work. Do I fill a bug request in spring jira and wait while my webapp is down? 
I have same feeling but people keep telling me that I'm wrong
Keep in mind, not everyone may have you understanding or skill level. There are a lot of developers out that there get into the weeds very quickly without a blueprint. Tools like Spring often helps those developers to produce, and as a result they become very appreciative and supportive of it. Once you're in a team there is are psychological and productivity based concerns that extend beyond yourself. Don't take such arguments personally. Just learn Spring and put your shoulder into it -- it will be fine.
This is a false argumentation. Having other options out there does not mean that Spring is not useful (which is what OP pretends)
True but the same arguments goes for using/not using other frameworks and Spring. In general the majority of frameworks will have some "magic" behind them to make the things work. If the submitter is not happy with the Springs way of "magic" or think it is too much that is perfectly fine but not sure then what his problem is.
He was asking you for evidence that importing such a large system in to every project is useful, and if so why. I think it's a fair question.
&gt; I always believed that this framework was a cancer, that made you a worst programer by obfuscating everything and making you program only the way he wants, If our scope is Java ENterprise Frameworks, then Spring is the one that gives you the most freedom about your code as you can use it with POJO, with zero or standard dependencies. Your claim is objectively false. 
can you quote the part about "importing such a large system in to every project"? What I understood from the OP is that Spring is bad why are there so many companies that use it.
He called it a monster. And I think we need to accept that Spring does cross domains-of-purpose freely -- classloading, DI, web services -- its a hodge podge. Obviously you can make web services quickly and easily without Spring -- it's demonstrable that you can. So that can't be used as the reason why Spring should get large corporate adoption. Companies use Spring because it allows their teams to be productive by reducing the number of choices and decisions they need to make in the course of their development. It allows standardization and interoperation between their teams. It allows them to set expectations when hiring. 
The 32-bit ESR release of Firefox 52 offers Java applet support.
You're missing the point. These objections stand for any framework - whether we're talking about Spring or Bootstrap. 
Thanks
Sorry but you misread his post. He is being very specific about which framework he means.
Nice idea. And who would get the coins? Oracle?
You are making some free assumptions here my friend. :)
Should be configurable via system property or constructor parameter.
&gt; He is being very specific about which framework he means. Without explaining in any way what is supposed to be bad about it besides vague accusations of "obfuscation" and it being a monster. 
I used to have a similar feeling about Spring after learning a bit of it in the XML-only era. But I came back to Spring and now I like the Java config a lot. However, I even used a combination of Java and XML config what was a big time saver in that specific case. You can save a lot of time with Spring. Just look at the conversion service, for example. It can be used anywhere in the framework and can easily be extended with your own converters, and Spring figures out when to use what converter. Or think of the great configuration options Spring offers out of the box. It would be a big waste of time to develop this from the ground up.
https://www.reddit.com/r/javahelp You'll have a better chance at getting help there..
Why are you asking for people's views and then only reply approvingly to people validating your bias? I really cba to "sell" you spring when you only seem to want your unfounded bias applauded.
Any simple API that exhibits complex behavior obfuscates by definition. Any sufficiently complicated library that crosses domain boundaries will be viewed as a monster by some. Spring tries to give you everything that they think vanilla Java is missing. Any library that does both, no matter how useful, will be criticized. You shouldn't take it personally.
It's a fair point, and to add to the conversation, Most of the arguments, are use this because that feature is awesome, but that can be said for any other framework, in such case one can use a specialized micro-framework. 
As for JSON-B, we got that in Spring Framework 5.0: put Apache Johnzon or Eclipse Yasson onto the classpath instead of Google Gson or Jackson, and off you go. As far as I'm aware, this works in Boot 2.0 as well. 
I believe it to be one thread for event loop - style. Checking on that.
I don't disagree but they tend to emphasize the infinite scalability more than it's specific use cases. Later in their deck you then find fun stuff like this. &gt; However, if you anticipate scaling beyond a single partition, then you should architect your application so that it can use more of the table's full provisioned throughput. and &gt; One way to increase the write throughput of this application would be to randomize the writes across multiple partition key values. Choose a random number from a fixed set (for example, 1 to 200) and concatenate it as a suffix to the date. This will yield partition key values such as 2014-07-09.1, 2014-07-09.2 and so on through 2014-07-09.200. Because you are randomizing the partition key, the writes to the table on each day are spread evenly across all of the partition key values; this will yield better parallelism and higher overall throughput. To read all of the items for a given day, you would need to obtain all of the items for each suffix. For example, you would first issue a Query request for the partition key value 2014-07-09.1, then another Query for 2014-07-09.2, and so on through 2014-07-09.200. Finally, your application would need to merge the results from all of the Query requests. Because that sounds fun!
Web security is pretty much the same across all languages. * Security headers https://securityheaders.io/ * Salting and hashing passwords * SQL injection preventions * CSRF / XSS * Secure cookies / HTTP only * TLS / SSL If you need recommendations to implement a specific thing that is something that can be answered but in general the security requirements are the same as every other language.
This library could help you quite a bit with the communication between nodes / managing masters and slave election. http://atomix.io/atomix/ 
That's awesome man, thanks for posting! Did you not have to include any UML in your thesis? God I hate UML... 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Well then, lets add to the conversation. Spring is modular. You can use only small parts tailored to specific areas. Spring sub projects (as opposed to spring core) are even more optional (if being more optional than optional is even a thing) and provide great benefits if they fit your problem domain - and they integrate with spring. The obvious advantage is that the spring modules work with each other more seamlessly than a bunch of specialized micro frameworks. More advantages would be: Spring documentation is pretty good, as is configurability and ease of use. Depending on the micro frameworks, that might differ wildly. Spring is probably also more highly adopted than most of the micro frameworks, so new hires need less time to acclimate, and you probably have a bigger community able to help out with questions. You call spring a "monster". That's nonsense because it's modular. In the same vein, the JDK would be a monster, but nobody forces you to use all JDK functions or concepts. Obviously I'm only listing advantages because the task here is to sell spring instead of giving a balanced view.
Just look at the hello world app in the spring-boot docs. Creating a controller with routes via annotations on what is otherwise a POJO -- if that isn't complex behavior from minimalist code i don't know what is. If you make an empty project and add the dependency spring-boot you get dozens of transitive dependencies, many of them other spring libraries -- so they aren't independent, even if they are modular. Again, easy to verify and understand -- just look at the various libraries respective poms. If you're going to continue being intentionally obtuse, lets forego any further conversation. Arguing with an honest person on here is likely a waste of time -- this is even worse. 
Fair point, but it doesn't convince me particular, I don't want new hires who can only use one frameworki I want engineers who can solve problems. Today we might use xyz technology stack, but tomorrow we might use abc. Micro-frameworks, are good in the sense of using well known libraries that help you go around building something that might be too complex, if some modules of spring ecosystem can fill in that regard, I have no problem with using them. Problem is that people seem to forget how to program without all the spring features, and once you have a problem that the framework cannot handle, the beast becomes the problem.
It is not an assumption if the sentence starts with If. 
I have the feeling this whole topic is borderline trollish but I am currently running a performance test so I have some time to bite... "javaRX" What is that? Or do you mean RxJava? I will assume you meant RxJava. Netty and RxJava are great libraries I agree! (btw you can use both of them with spring as well) Anyway. How do you do these? - Authentication and Authorization? Authentication with OpenAuth2/username+password/remember me functionality? Spring has well designed, tested, battle-proven support for these. - Interact with relational db (together with transaction management)? Or MQ? Spring has well designed support for these. - Email sending? Spring has well designed, tested, battle-proven support for this. - How do you create your install artifacts during build? Spring Boot has integrated support for this (to create an uber jar for example). - Interact with Ldap? - Call other Rest services, Soap services? - Make sure that all these above work well together? Probably the list could go on but my test finished.
Awesome!
I think spring is fine, its core hasn't been right for any of my projects to date, but i'm sure its a great time saver. But, if someone else can do the same thing with other libraries, it is not wrong to do so. Depending on requirements, some of those ways may even be faster/shorter/better/more maintainable. The op was saying he was told that spring is "the right way" all the time, and he was asking for technical reasons why that could be so. He certainly doesn't appear to appreciate spring, but at least he's asking for reasons that could change his mind.
Correct me if I'm wrong, but I'm not sure that's the intent of the the Session, to be shared across users -- it's really for an individual's session. My suspicion is that you should roll your own based on an instance ID (that you create). Your choices are to create a new planning poker "game" or join existing. If you create one, it creates an instance ID, if you join one, you use the instance ID given to you (the instance ID is generated by @Id / JPA value) etc. You'd then expose it RESTfully, /instance/{instanceId} with verbs to join, create, delete etc. I just recently had a similar type experience when trying to pile onto the RequestScope, in my use case I use trying to store a user's personal API secret / username into a RequestScoped variable. In this case, each user has unique API keys for this particular website's service (not controlled by me). It'd be great if that was simply injected into each service. I was able to get it working in all cases save for an important one, using Quartz Jobs, where I interface with that service on behalf of the user. I ended up scrapping the whole thing and simply passing in the APICredentials object. I'm trying to help you out, I'm not 100% sure my answer is in line with what you're looking for, but the tl;dr is that I believe you are using Session incorrectly, as it's designed on a per-user basis, not to be shared. I'd also encourage that you do role some type of authentication, as it's not that safe to be able to arbitrarily access other people's planning "games". It could be as simple as the instanceId plus some significant password that the creator decides. best of luck.
&gt; But, if someone else can do the same thing with other libraries, it is not wrong to do so. Except for the part where other people have to work with the code you wrote and just might hate your guts for choosing some hip light-weight library-of-the-week they have to keep maintaining. From a project management / software maintenance point of view, Spring makes a lot of sense, it's a rather safe, well established bet that in contrast to the naysayers works quite well and fast if you don't fuck things up. All the bytes and microseconds shaved off mean jack shit unless they happen to happen in a performance critical part of your application that you found out about by thoroughly benchmarking your application. That usually does not happen, the most common effect is a slight increase in ramp-up time and minimal execution overhead. It is nothing that has a considerable influence on most software operations or the company bottom line. 
It is quicker to write useful stuff.
It's great if you want to rename and obfuscate every technology you use. * No we don't use content type and accept headers we use Produces and Consumes because its better. * Connections and transactions? No we use Sessions and StatefulSessions that have magic caching you might not even know about. * Gzip is a header? I thought it was just an option in some magic config that does stuff. * Middleware / filters - Why would we want those hardcoded in a sane place where the order is obvious. Let's scan our entire classpath and order them based on some `@Prioirty` annotation. That way we can accidentally pull in more filters without even knowing by adding more dependencies. * Oh you want to just test this one repository method? Well I don't really know how to run a main method that can do that. So lets boot the entire app and wait 2 minutes then call the REST endpoint that calls that method to see if it works. 
Hi! I don‚Äôt know what else I can add to any of the other hopefully helpful comments here, but I‚Äôd like to welcome you to the community and if you have any questions we‚Äôre always happy to help on gitter.im/spring-projects or spring.io/questions. We have some useful getting started content on spring.io/guides and of course I‚Äôd be happy to help / talk at josh@joshlong.com. Disclaimer: I work on the spring.io/team 
Thats like the MongoDB argument. Look how fast I can build shit. Just don't worry about that bad data in there a real database would have prevented it but... we want to develop fast because we are agile.
Your question and follow up comments are a perfect example of why people in the computer science field have a bad reputation. The question is really just posturing. Do you really want to sit here and act as if one individual is so skilled and intelligent, they're going to be able write code that handles all the things Spring has entire teams of professional senior developers doing? Then when people introduce evidence about why this framework is useful, you condescend to them and only concede ground to people who have complaints about Spring. Well let me ask you this, why are you even using Java? Just write everything in assembly, because using Java *just obfuscates everything and makes you program the way Oracle wants - making you a mindless puppet of a corporate.* 
Interestingly same applies to you. Do I have to answer each of the comments? May I find them fine, some I have answered some don't.
&gt;Interestingly same applies to you. Explain.
Do you have proof to validate your comments? Are your opinions as mine :)
All those things you said are solved in many ways, rather than just using the thingy and forget about how things work.
I switched from Spark to Javalin recently and have been very happy. Also the developer is very friendly and open to contributions. The code is easy to understand and modify. I got fed up with the slow pace of change in Spark. 
The Spring developers aren't some super elite programmers. They are the same as any other developers. There are good Spring devs and bad ones, some may agree on some things and some may disagree. Some may have PhDs while others could be 16 year olds contributing to the open source community. Remember most of Spring's functionality doesn't come from Spring itself. Spring is a giant opinionated wrapper around other libraries that other people work on. Why would it be wrong to choose to use those libraries directly? Arguments of productivity and ease of transitioning from one project to another could be valid arguments. They are also just opinions. Most of the Java frameworks all use the same underlying tech. Think Tomcat, Jetty, Netty, Undertow, Jackson, GSON... So are you not just assuming that the Spring team is so superior to everyone else that you won't even try another framework? Its difficult to deny Springs adoption, but that doesn't make it superior in every way. I can develop 10x as fast using lower level libraries than using Spring because I took the time to learn them and I don't know Spring that well.
So because there was a bug in MongoDb you should never use spring? 
There are many frameworks that are more judiciously scoped than Spring. Some of which have features or performance that compare favorably against the same.
No the bug was in the code because the developer didn't understand how MongoDB worked. Getting up and running fast is great for hackathons, not necessarily great for long term projects. I'm not saying Spring is bad but saying it's faster to write stuff isn't a very convincing argument. How often do you actually start new apps from scratch? How many companies have their own wrapper framework around Spring anyway?
Saw a pretty cool project of his on Hacker News a few weeks ago. It's a summary page builder for Github profiles built with Javalin: https://github.com/tipsy/github-profile-summary
I don't really agree with that. I think the cyclomatic complexity is the same in both cases. There are two code paths. In basic Java, you have objects and control structures, and they're generally separate things. Code coverage tools work by examining the control structures to determine flow, while ignoring objects. But monadic objects like Optional are objects *and* control structures in one. As such, they aren't detected as control structures by the code coverage tool. To me, this situation would be like SONAR ignoring classes which start with the letter 'A', and then you asking "Should I name all my classes starting with A in order to get a better score?' The answer is no. The tool is limited, and 'gaming' or exploiting the limits of the tool is not a good idea.
&gt; There are lots of well established libraries out there that do similar things in a clean, organized way. Again, what is the advantage of using them, then? Just because they're not spring? &gt; At one point spring was the new hip library, and people used things like struts or j2ee, and they made the same arguments you're making here. Spring had clear advantages over the pile of shit that struts was and also initially over JEE which admitted has improved over time. If you think Spring is bloated, you should see some JEE containers. &gt; they made the same arguments you're making here. The argument against struts is very clear cut and there's a reason why no one uses it anymore except for legacy reasons. JEE is another way of doing things, coming in many flavors. The arguments towards standardization apply there just as much as they apply to spring teams. I phrased &gt; Spring makes a lot of sense, it's a rather safe, well established bet somewhat carefully. Spring has a lot of good sides, but nothing makes it *the one* choice that rules them all. Project standards matter a lot. I see more people going from JEE to spring than vice versa though. Doesn't mean that your new hip framework necessarily will persist or is a good choice in any case, especially if the main selling points are the same but "more light-weight".
Spring framework was adopted an an **Industry Standard** for a reason. It's literally the most widely used framework for Java in the entire world -- and no, that's not an opinion. If you get a job anywhere in Java, they're going to expect you to know Spring. Even defense contractors that have extremely strict procedures on what frameworks can be used will have some version of Spring authorized. If you don't like it or want to argue that there are others that can be used, that's fine, but there's no denying that Spring Framework makes things way easier by reducing boilerplate and handling things that would take years for you to learn on your own. Do other frameworks do it? Sure, but not in as exhaustive of scope, as well done, or as widely used as Spring. That's why even college students are familiar with it. I don't recall saying everyone working at Spring is some kind of genius or that ever using another library is "wrong," but I do firmly believe that some dude talking trash on reddit is not going to be able to write a security framework, write code to handle dependency injection, and write code to internally handle servlets, including everything else Spring does from the ground up as well as the whole Spring Team does. **Yes, thank you for pointing out that not every single developer there has a PhD,** but there are still leading teams of extremely talented people working everyday to solve programing problems in Java. OP crossing his arms and saying saying "I'M NOT CONVINCED AND THE WHOLE INDUSTRY IS WRONG" is myopic. tl;dr - If you don't want to use spring that's fine, but OP coming in here and acting like he knows better than the whole industry is retarded.
That's a very poor understanding of the benefits of MongoDB.
Every time I use Spring in my projects, I find myself and my team wasting lots of time trying to understand how Spring does something, how to customize it, why is not working as I expected. So in my next project I don't use Spring at all, and I find myself and my team wasting lots of time trying to do everything Spring does for me. So, paraphrasing Greenspun's tenth rule, in my experience, any sufficiently complicated (Enterprise-like) java program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Spring (or JEE). Sometimes, even the ones using Spring
I think something has to replace current C and C++, even if it is a compiler that makes it impossible to have the bugs that have caused the many security exploits of the past years. If a company has a choice if writing in a language that does not allow them to happen or be liable for them, I think the change will be forces due to exposure and financial means.
Author here, I tried to break down DI with a simple example. I may have not covered everything, I'd love to hear any feedback on it, or stuff I missed/got wrong. 
I never said it was a benefit of MongoDB, its a con and a very bad one. People like MongoDB because they can use it very quickly and don't have to plan as much as say SQL. That is wrong. MongoDB is a great database but its only useful for certain things. It excels at many aspects but is worse at others. Now using it for a Hackathon sure you will build something very quickly. That doesn't mean it's a good long term decision. It doesn't mean its a bad one either. You need to consider the pros / cons of the design / requirements. But building something useful quickly isn't always the best argument. Over the course of a two year project who cares if I had the webserver working on day 1 or week 1. The long term of the project is more important.
1. Produces and Consumes is a generic term that is used across the framework. Spring isn't HTTP specific and also the terms aren't Spring specific. You can just make your own composed annotation 2. Wrong framework. 3. I don't understand what you are talking about. 4. That's the Servlet API 5. If this is how you test you are doing it wrong. 
&gt; It's kind of the "in for a penny, in for a pound" thing. Spring is modular. You're in for a penny with Spring DI, but that doesn't mean you have to bring the rest of Spring along for the ride. For example, you can ditch Spring MVC and use JSF instead. If you do so, you will have none of Spring MVC's classes or dependencies. &gt; The idea that my webservice is going to tell me how to do DI, or &gt; how to load my classes, seems artificially oppressive to me. You are describing Spring backwards. Spring MVC is a Spring module. It's not telling you how to do DI. Spring is built around the Spring DI container, so Spring MVC does what Spring DI tells it to do, such as how classes are loaded and instantiated. The Spring Framework and the Spring ecosystem are a collection of modules built around the Spring Framework.
&gt; rather than just using the thingy and forget about how things &gt; work. No matter what framework you use, if you forget how things work, that makes you an idiot. I use the Spring Framework quite a bit, and I study deeply how the various parts of it work, because I would be a shitty programmer if I don't understand how my tools work.
Internet Explorer was what I had to use to run applets in the past, though I expect they will drop support soon, too. 
Been a Java dev for 7+ years now professionally. Only one company I worked at used Spring, and no one required me to know it. Most of the companies used DropWizard or Jersey. So no it's not expected for all jobs, I would be expected to learn it if the team used it though sure. At Amazon some teams used Spring and some didn't it was up to the devs on each team to choose what they wanted. Many chose micro frameworks. &gt; and this delusional narcissism explains to me why you seem to think that you know than all the teams of PhDs working at Spring When did OP ever suggest they know better than the Spring developers? Maybe OP develops a competing framework or works on one of the lower level libraries that Spring uses how would you know? Or maybe OP is content with using competing frameworks that have equally competent / intelligent teams as the Spring team. Have you tried other frameworks / micro frameworks? Maybe your view is a little too myopic assuming Spring is the best. OP asked (maybe slightly aggressively) for people to convince them why they liked Spring. I have seen very few satisfactory responses so far. I personally don't like Spring because seemingly simple things sometimes take me a week to figure out how to do the Spring way. That's a personal preference though just because I don't like it doesn't make it bad. &gt; but there's no denying that Spring Framework makes things way easier by reducing boilerplate and handling things that would take years for you to learn on your own And I can deny the shit out of this. Every time I have used Spring it slowed me down. It would take me days to figure out how to do something very simple that I could have done in a lower level library easily. I'm sure that wouldn't be the case after using it for several years but its not some magic framework that makes everything better unless you learn how to use it.
Ok, sorry, but this is a silly list of things because none of this stuff is all that hard to do without spring. Spring may make some of this nicer, but most of it is "meh". Your first point is on point though. &gt; Interact with relational db (together with transaction management)? Or MQ? Spring has well designed support for these. JDBC isn't nearly as bad to deal with post Java 7. Try with resources solves 90% of the headache of using JDBC. Sure, spring jdbctemplate can make things nicer and the Transaction management stuff can also be nice when it applies, but none of that is particularly hard to do on your own. (and, in fact, spring gets in the way if you need to do more advanced stuff with your DB such as XA transactions). &gt; Email sending? Spring has well designed, tested, battle-proven support for this. So does java ee. Sending emails is not a hard problem and there are plenty of libraries and ways to do this beyond spring. &gt; How do you create your install artifacts during build? Spring Boot has integrated support for this (to create an uber jar for example). maven-shade plugin. Which, I think spring uses under the covers. Maven/gradle can do all of this though with very little configuration. Further, this is the sort of stuff that is setup once and forgotten about. &gt; Interact with Ldap? Google "Java Ldap" and find one of the 1000s of libraries that can talk to Ldap. &gt; Call other Rest services, Soap services? For rest Jersey, Retrofit, Apache Http client, OKHttp, the list is practically endless. For Soap I'm not sure, it honestly hasn't come up in my day to day. &gt; Make sure that all these above work well together? Is it really that hard to wire together different libraries? Do you ever worry about how you will make JQuery work with Angular, or react, or vue? The spring solution to these problems isn't some sort of mystical magic that fits together in a way impossible to achieve using other technologies.
&gt; I think the cyclomatic complexity is the same in both cases. It isn't. You can [do the math](https://en.wikipedia.org/wiki/Cyclomatic_complexity). &gt; There are two code paths. Not by cyclomatic complexity analysis. &gt; Code coverage tools work by examining the control structures to &gt; determine flow, while ignoring objects. Not exactly. Objects are irrelevant for control flow. Code coverage is looking at control structures and *functions* (which are always associated with an object in Java, excepting of course static methods). Functions decrease complexity by decreasing degrees of freedom. Every `if` statement adds edges to the *local* code path. However, when you pass over a function, that function's *own* complexity is not considered in the complexity analysis. Functions don't add edges to the control flow graph. That is because once you are in the function, you can no longer interact with the code path that lead to it (excepting of course global context, but that is not a part of branch coverage). This decreases overall complexity of the system by decreasing degrees of freedom. Using `Optional`, you are making a series of function calls. Thus, you aren't adding any edges to the control flow graph. The downside is that you more limited expression because you have to play by `Optional`'s rules. With a conditional, you are adding edges to the control flow graph. But you get more freedom of expression, at the price of increased complexity.
Great idea, but isn't that against the philosophy of building something fast based on a trusted framework? And isn't then the best approach to build it yourself or use the less external dependencies a possible?
I don't deny that it's highly modular, or that you can cherry pick parts -- or that they have provided some points at which you can call an audible and use another popular library alongside. But if you use their quick-to-start/framework-level facilities, you are going to get a largely monolithic spring experience. 
Valid points but isn't it a great way of understanding something by building it?
&gt; But if you use their quick-to-start/framework-level facilities, you are &gt; going to get a largely monolithic spring experience. Which ones? Because Spring quickstarts aren't monolithic at all. 
&gt; Speed, superior programming models/techniques, memory/gc efficiencies -- there are lots of reasons. So you claim. No one has yet to even name concrete alternatives here, let alone show benchmarks that show a considerable gains that are not just valid inside a micro-benchmark on artificial problems. Spring is not really slow in general. Startup costs largely don't matter. Also note that spring has not to be the end all. Instead of e.g. making my team using a totally different programming model to squeeze a few percent of static file performance, I might just slap a varnish cache in front of my spring app and call it a day, e.g. &gt; Beyond that, calling "you shall use Spring" a project standard is a stretch. As in standard for projects in Organization X. &gt; Using revision control, common build tooling, continuous integration, providing unit tests, providing javadocs/regular-docs -- those are project standards. Those are standards, too. Most often in form of a concrete sofware for each category, because the organization has committed or standardized to it. So Git, Bamboo, JUnit etc. &gt; To put specific libraries in your project standards To specify every library, sure. Most organizations most commonly define their standard platforms in some detail. Java/Spring/x, Java/JEE/y or they let teams chose between several options. &gt; without technical reasons/merit I quoted some organizational merits I see, there are a lot of technical merits. &gt; ensure that the most creative people on your team will be looking for other opportunities. Or they are the ones setting the standards in the first place?
Yeah, if my goal is to learn by playing around. Not when I'm writing production software.
1. Methods in Java start with a lowercase letter. 2. I personally think it's a bad practice to promote field injection. It's bad for testing 3. an alternative to @Qualifier , used only in specific conditions, is @Primary. Thanks for thanking time to create this content. Hope people will benefit from it
You're on the right track. I do believe I've exceeded my capacity to arm-chair debug =P. I find that building in stages with Spring is super helpful, so you can isolate the issues. Build out a user management system last, because you don't need it for testing, just know that you are exposing other people's planning "sessions" to the world (they just have to know the ID). Set up some nice DataJpaTests in your project involving creation of an instance, adding people to it, etc, and debug it that way. It serves as a repeatable test case for debugging as well as a permanent test to make sure you haven't introduced regressions. Best of luck!
Thanks! I was going to add @Primary, then I forgot when I did the video. Oops, I'll make sure to have my methods lowercase! I already saw someone down voted this video, hopefully people will still see it :)
HTTP/2 server push maybe.
Yes, it simplifies deployment. I have Dropwizard services that only serve JSON API requests for other services. Previously, if I wanted to eek out every bit of performance, I'd need to (first profile) deploy nginx / HAProxy in front of that app for TLS termination. Now, I don't need nginx or HAProxy as performance is on par. If you have a web app where (for instance) nginx serves static files and proxies to your app on the same box without TLS then you should be in good shape. Though I recommend thinking about what a TLS everywhere implementation would look like, this way if you grow enough to need to load balance between app servers you can sleep easier knowing all in-flight traffic is encrypted.
I'd just stop. I can tell this guy just doesn't like being wrong. 
https://www.techempower.com/benchmarks/ https://github.com/networknt/microservices-framework-benchmark I've used Vertx before, it had some nice features. Rapidoid does very well in microbenchmarks and is really easy to use. Light-java seems to generally perform best on the JVM in the recent Techempower benchmarks, but i know nothing about it. On recent projects I've used Akka-http, largely because i was already using Akka, and a few C++ frameworks (most of those efforts were integrating with high performance, vectorized native code that Java wasn't suitable for, often on embedded devices with limited memory). Beyond that I use Nodejs as a development environment for front end code, and for mocking/prototyping backend services. All of them perform better in Techempower than Spring. All of them are capable of producing maintainable HTTP/REST/WebSocket-based microservices. 
Thanks, fixed.
I don't understand why you wouldn't just write the test.
Most of what you're running into is a corporate politics thing. Management seems to be unable to assign any value to anything that doesn't have a buzzword. To management, a C++/Java/Groovy/Python/Microservice/Dependency Injected/Spring Security/Spring Boot/Dropwizard etc etc - the more buzzwords the better it must be. To anyone who's worked on this stuff, that's a godawful nightmare. Even though it's completely retarded, if you don't have buzzwords, it's hard to convince anyone in management that you're doing something important. And I don't just mean your manager - you manager has to convince other managers and his manager as well. There are some basic spring things that are fine - spring mvc + jsp's is the best common framework I've seen for rendering on the server side. Spring mvc + jackson returning json works fine for me. I think there's a lot of headache inducing horridness in there as well, I hate dependency inject (try tracking things down if something goes wrong). They're constantly trying to reinvent the wheel. 
Spring Boot is a product on its own (independent of the Spring Framework). By default, the Spring Boot parent POM pulls in a lot of extra dependencies, and the autoconfiguration includes a lot of stuff you might not need, *just in case*. You can trim down the autoconfiguration to enable only a small set of configurations, and you can add excludes to your POM to get rid of things you don't need. With Spring Boot you have to opt out of a lot of things, while with the Spring Framework, you have to opt in. You have the choice, and for many, it's opt out is more convenient since you don't have to spend as much time starting the project.
It could be case for spring when the team doesn't know it and has to get up with it, while using basic micro-frameworks will make you develop faster since you what need to learn is less.
As everyone here :)
Sure, build it all yourself and learn. But only do it once(or enough to get it)... one of the biggest points is so you aren‚Äôt stuck having to write boilerplate code for days over and over again. Notice how the phrase ‚Äúreinventing the wheel‚Äù has been used about 40 times in this thread. We don‚Äôt want to do that. Just because you use spring, or any other tool like spring, doesn‚Äôt mean you can never create a project from nothing with no tools ever again. 
Sounds a lot like Shenandoah. It will be interesting to see the two compared. /u/shipilev ?
If you use DevTools, you don't have restart every-time.
&gt; Eclipse ‚Äî a long standing leader in the IDE segment of Java Pretty sure IntelliJ has the most market share these days over Eclipse. Either way calling eclipse a leader is kind of laughable. It simply copies IntelliJ. Only innovative feature of eclipse I can think of is its compiler, which is indeed handy for not stopping on compile errors.
I get quite a lot of use out of the features that eclipse copies from intelliJ and offers for free. It‚Äôs not a bad strategy
Well, it's Java EE. So a dead tech marrying up with dead foundation is a good fit. Fuck eclipse foundation from all of my heart.
https://docs.oracle.com/javase/8/docs/technotes/tools/unix/appletviewer.html ?
Nothing to do with IDE. Lots to do with the fact that they offer a "platform" that people abuse. The joke of "shitty OS with a shitty IDE bolted on" apply a lot.
Since this is help with **Java programming**, it should be, as the plenty hints on the page indicate, posted in **/r/javahelp**. Please, before posting there, read the [**Posting Guidelines**](https://redd.it/48eykt) that tell you how to produce a proper post and how to format your code. **Post removed** programming help
It does. There are several interventions from Shipilev at various conference. If I understood correctly, they are working together on several common aspects; like having an API to insert read and write barriers into the compilers. Cache lines are getting larger (512 bits vs 64 bits not so long ago), and adding metadata to objects is getting cheaper. Shenandoah used that to have a level of indirection. ZGC has its own use, but they also said they intend on exploring further. I'm excited for things like usage-dependent memory layout: just like the JIT "prunes cold code", a GC could separate hot and cold data; and we could have pretty darn hot caches. Say you scan a column over a collection of JPA objects repeatedly. The GC would learn to relocate together the objects representing the values in this column. It would strike the perfectly balanced layout with the other uses you have of these JPA objects. Comparing to CPP, Java/JVM could be closing the gap more than ever performance-wise: * JITting is superior to AOT (you can make errors in choosing a PGO profiles) because you get the actual code usage. And you adapt by deoptimizing. * Having a workload-specific memory layout beats hypotheses you would be making in CPP. And you can adapt by choosing another layout.
What a *darn* shame.. *** ^^Darn ^^Counter: ^^62612
One is lame, the other is hollow buzzwords.
Jakarta reminds me of very early times in Java development. The Struts framework was called Jakarta Struts back then. Javarta EE is much better than Enterprise Profile, also because EE is not about profiles. It is not a social network.
There's a lot of legacy code in C/C++ that won't go away easily. There's also a lot of people who have experience in these languages, but almost none that have experience in Rust. Overall, Rust is a better language (with good tool support), also safer. But languages are often picked for economic reasons, not for technical ones. &gt; If a company has a choice [..] or be liable for them, They generally aren't liable; "Dear customers! Sorry, we lost your data. Please change your passwords. The end."
I‚Äôve the same feeling OP describes before using spring, I was suffering from not invented here syndrome inflicted by the company owner. Today I use spring and I can say that all that time doing stuff in-house was worthy. When I have any issue with spring I just debug the source code and docs to understand what I did wrong or if I‚Äôm trying to do something that is not supported, either case you would be able to find a way through it.
Look around the various toolchains in the industry. It's a disaster.
Oh noes! The Eclipse Foundation burn time and lawyer fees doing an extensive trademark search, but it's all for naught because randoms on Reddit deem it "lame". Tell, you what, jump into your blue box, go back in time 6 weeks and provide your inspiration for a name that is both recognisable, catchy and still available as a global trademark. 
Or, sorry we lost your PII, we are funding identity theft insurance for all 11.5 million of you at our cost. The exposure cost is not zero and dealing with it is not free and factors of brand loyalty are a harder to measure but real cost. Target is still feeling the effects of their security fail from years ago.
The introduction of various will most likely start some holy wars.... I like it though.
No, you're wrong. It won't start any holy wars.
That would just be final var if im mot wrong
probably.. but its not optimal since "final var" should be more used than "var" so a "val" would be a good alias for "final var" to make code more readable.
The only concrete issue you have mentioned is that you feel Spring obfuscates what is going on. I remember feeling this same way when writing Spring with XML: * I can make errors that should be caught by the compiler e.g. spell a class name incorrectly. * I have no motivation to prefer wiring things up in a way that could be caught by the compiler e.g. inject by name instead of by type. * I have no way to tell what is going on behind custom namespaces. However, all of that went away with that Java API. Now I find it very trivial to see exactly what is going on. In my opinion, Spring (with Spring Boot) manage to solve three issues simultaneously. I have not encountered another approach/framework that has managed that: * If I use no framework or a micro framework, I will end up writing a lot of code to solve problems that others have already solved. * If I use a bunch of independent libraries or decoupled frameworks, I will spend most of my time debugging the glue code that makes them all work together. * If I use a full stack framework, I will spend most of my time trying to understand why it does things in a way that I am not expecting. The decoupled nature of Spring, with the convention-over-configuration approach of Spring Boot, has created something quite unique and powerful. Spring Boot has essentially externalised the task of glueing all these libraries together out to the open source community. Now with every piece of functionality, I have the option of either importing the starter to get everything working quickly, or using the underlying library directly, when I need it to work in a more specialised way. I can also move from the fully configured to fully unconfigured in a gradual fashion. Overall, that means I find I spend very little time on the framework, and lots of time on developing the unique pieces that actually add value.
you could try it with WebSwing 
I respectfully disagree.
Why don't we have a holy war about whether it will start a holy war?
Indeed it will, but the arguments for implicit typing have won already in numerous languages. Java tends to adopt what works and implicit typing works very well. 
Pretty sure I'm going to go with Jakarta EE so that the bloody recruiters don't lose their minds. Searching for Senior Developer with 5+ years J2EE Experience 5+ years Enterprise Profile Experience
What tool chains are a disaster, why are they a disaster and what do any of these have to do with the Eclipse foundation?
I don't think we'll start a holy war about that.
Well yea but thats not how Java works sadly
Can't they just call it JavaEE? Nothing wrong with it. Why change it? Jeez
They considered the `var`/`val` as well as `var`/`let` and others. See Brian Goetz‚Äôs summary [here](http://mail.openjdk.java.net/pipermail/platform-jep-discuss/2016-December/000066.html). It turns out, `var` is pretty uncontroversial, but `val` vs `let` devolves into a holy war. I find the points he raises in the "Syntax" section to be fairly well-reasoned: &gt; - While it was not the most popular choice in the survey, it was &gt; clearly the choice that the most people were OK with. Many hated &gt; var/val; others hated var/let. Almost no one hated var-only. &gt; &gt; - Experience with C# -- which has var only -- has shown that this is a &gt; reasonable solution in Java-like languages. There is no groundswell of &gt; demand for "val" in C#. &gt; &gt; - The desire to reduce the ceremony of immutability is certainly &gt; well-taken, but in this case is pushing on the wrong end of the lever. &gt; Where we need help for immutability is with fields, not with locals. But &gt; var/val doesn't apply to fields, and it almost certainly never will. &gt; &gt; - If the incremental overhead of getting mutability control over that &gt; of type inference were zero, there might be a stronger case, but it was &gt; clear that many people found two different leading keywords to be a &gt; distraction that kept their eyes from quickly settling on the important &gt; stuff. If variable names are more important than types, they're more &gt; important than mutability modifiers too. In my opinion, adding `var` gives you the most value. `val`/`let` would be nice to have, but they're supporting characters. `var` is the star of the show.
This thread is awful. OP 's first sentence is that Spring is a cancer, in the rest of the discussion people saying doing this or that is retarded. I thought that r/java was made by professionals, not fanboys, i thought it was better than this. 
"The North East" is a common way of referring to the area around Birmingham, England. Make no sense to me either but that's what they call it.
So basically because people so narrowminded. Both are equally bad or good so why not just randomly pick one. The reasoning behind this is if you wait 10 years you are still going to have the same debate. I say that the lack of choice in this is a bad compromise which is because of weak leadership in the steering committee. 
&gt; So basically because people so narrowminded Haha, ok. I guess you're not interested in a real discussion. Bye.
&gt; I'm excited for things like usage-dependent memory layout: just like the JIT "prunes cold code", a GC could separate hot and cold data; and we could have pretty darn hot caches. That would be neat, but I'm not sure if the overhead for keeping the stats is necessarily worth it. Already, with compaction, stuff that is allocated at the same time will tend to end up close together. And that is all basically for free. Though, I am excited about low usage regions being pushed to swap. That is pretty fantastic for really large memory apps that don't necessarily need to read all that memory at once. I'm thinking of applications for things like really large LRU caches. The tail end of the cache could easily end up in swap space while the live end would make sense being in hot space :).
What a *darn* shame.. *** ^^Darn ^^Counter: ^^65181
I have not seen any holy .war yet :(
The discussion is about how this is handled. If you are blocking the progress of a language because of val vs let then in my eyes you are narrowminded. The same discussion will be there next time so it's easier just to pick one now randomly. Both of them have been in use in existing languages so both are equally good or bad. This could have been handled much better. Immutability is important and having a shorthand for it helps adoption alot. 
pretty much
Actually, there was a great reason for that - it changed my mind. Basically it's simple - var can only be used inside a method, a place, where every field if not changed is effectively final. Biggest "final" value is in class fields, which won't allow type inference.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The proposals look even worse than EE4J... Wondering what's wrong with OpenJEE that they didn't choose it for the final vote.
The proposed names are just crap. Is JEE really trademarked? (just the JEE shortcut, not the actual full name)
&gt; Immutability is important and having a shorthand for it helps adoption alot. Man it's fucking IMPOSSIBLE to convince some of my co-workers of this. "I've never seen mutable variables be a problem so it's fine to never have immutable variables". Uhhhhhhhhhhhhhhhhhhg
How dare you disagree!
The Eclipse compiler is very useful and very popular.
What's a better alternative for c++?
It‚Äôs not about performance, it is about writing safer code
Can it think of any company in the world that would name its product "enterprise profile"? This name on its own doesn't make sense. Jakarta is somewhat better, but sounds more like the past than the future. These poor names could be a bad sign for Java EE, since if the guys in charge don't get even the name right, I doubt that they have the right mindset for the job. 
I am not a lawyer, but I very much doubt that the three letters JEE are even eligible as a trademark. At a conservative estimate, the Eclipse Foundation has burned $5-10k getting to the point that they can confirm that these names are viable. Instead of bitching and moaning, how about ponying up some cash?
job :)
It's great when something compiles on my colleagues computer. But then when it gets to Jenkins it fails to compile. It's dumb imo.
Trademark.
EE4J is the name of the umbrella of reference implementation projects by the Eclipse Foundation. The suggested names here are for the new brand of the platform (which is agnostic to implementations).
Java EE becomes either Jakarta EE or Enterprise Profile. The platform will have multiple implementations: EE4J projects, JBoss, GlassFish, WebLogic, Websphere Liberty, TomEE, etc.
I disagree. Jakarta is a trademark (as for Java related software) by the Apache Foundation. Its use by the Eclipse Foundation was approved. I personally like this option because brings Eclipse and Apache foundations closer. Many - if not all - of the EE related projects (reference implementations and alternatives) use Java libraries from Apache. So, pretty cool this synergy happening this way.
&gt;Where we need help for immutability is with fields, not with locals. Ha, I wish, but compile-time guarantees on immutability have to be enforced locally as well. &gt;If variable names are more important than types, they're more important than mutability modifiers too. Bad reasoning from Brian here. We still get compile-time type-checking when using `var`, but we don't get compile-time immutability checks.
&gt;Tell, you what, jump into your blue box, go back in time 6 weeks and provide your inspiration for a name that is both recognisable, catchy and still available as a global trademark. Eclipse Winter.
I've liked dagger not just because it is really fast, but because it doesn't let me build with a broken dependency graph. I previously dealt a lot with Guice and when apps get big it becomes really awful to try and reason about why things are the way they are.
Go ahead and propose something better. If you pay for it, people might even listen to you.
Because it can't be trademarked, as is made extensively clear, munchkin...
Perhaps, but there's a lot of aggressive Spring evangelists as well, who always drop the words "container" and "heavyweight"... just saying
If you're going to rewrite it, rewrite the Groovy parts in Scala. It isn't as nice as Kotlin, but it's not as alien as Clojure.
If you are big enough, you may pay for a support contract w/ Oracle that gets you all kinds of stuff, including but not limited to security patches for versions that are otherwise unsupported. This is basically them saying they'll keep doing security patches even for us plebs. 
Some of the articles on that site are really weak How would UML Distilled be ahead of Effective Java or Clean Code
We can have a polite discussion. With knives.
Easier to understand too. When I'm reading new code, it helps to know that some things are assigned once and never modified.
I hate both options. They both include ‚Äúenterprise‚Äù, which does not describe the spec anymore. It did when only large companies had servers, but that‚Äôs just not so anymore. 
1. Trademark. There were issues with that incredibly lame name. 2. The spec may be open, but implementations will not be. Don‚Äôt hand IBM that kind of ammo. 
I know most support Google's side (probably because unlike Oracle they make shiny things, and spend a lot more on PR), but in my mind it's hard not to see the damage Google has done to the Java ecosystem. Unpopular opinion, but I hope that Oracle is successful, and Java is WORA again.
i despise the very concept of a 'copyrighted api', which is why i don't support oracle. not anything specifically about google.
Copyright over API is bullshit. An API is some kind of contract between client and server; contracts can't be copyrighted. The whole idea of using copyright as some kind of patent system forbidding people from reimplementing it is an abomination. It's like making a universal keyhole for all houses and then owning the rights to it, so suddenly you get a monopoly on all the doors in the world because nobody can change them.
There are many analogies to books, doors, etc, but the primary reason Sun chose to copyright Java's APIs is to ensure that all implementations are compatible. They made a little money from licensing implementations but it was never much; the primary motive was discouraging companies like Microsoft to 'Embrace Extend and Extinguish,' which they famously tried to do.
Google used the Java API differently from how APIs are commonly consumed. They baked this API into their own pseudo Java, presumably because the JDK APIs are good and millions of software developers are familiar with them. The success of Android rests on Java. Without the latter, Android would be just another of hundreds of Linux versions. But Google made billions, and Oracle paid billions. How is this fair use?
This would be great! I help teach Java to undergraduate students, and the ones new to the field often forget to compile every time before running their updated code.
&gt; but the primary reason Sun chose to copyright Java's APIs is to ensure that all implementations are compatible. That's the wrong way to go about it. If they were smarter, they wouldn't have hung their commercial hat on licenses and would make the TCK available for free. How can you claim to want implementations compatible but refuse to open the test cases to prove them so? If you really want compatibility, you should look at open languages that allow any of us to write implementations and test them against public specs. Good thing they stopped Microsoft and J#. Like JavaScript stopped them with JScript, or C with MSVC, etc. How on earth did those languages survive without the intelligent licensing scheme and opacity approach used by Sun/Oracle?
The WORA maxim has applied to Java more than to any other programming language. Android, however, represents fragmentation. I would be glad to see that mistake corrected. 
&gt; How is this fair use? I don't see in your comment where you are arguing against fair use, or maybe you are making up a legal definition that says fair use means things can't be morphed or it must be non-commercial or something. If you want to argue that Google violates ALL of the commonly accepted 4 factors, then fine. I don't believe they violate 3 of the 4.
James Gosling discusses Oracle v. Google on Triangulation, [here](https://youtu.be/ZYw3X4RZv6Y).
Video linked by /u/lbkulinski: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Triangulation 245: James Gosling](https://youtu.be/ZYw3X4RZv6Y)|Triangulation|2016-04-11|1:24:08|28+ (100%)|2,769 $quote James Gosling is a Canadian computer scientist known as... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/lbkulinski ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
C and its relatives are hard to port, certainly *not* platform independent, and incompatibility is all but guaranteed. 
Good bot.
Ok...what does that have to do with my comment? I was responding to "the primary motive was discouraging companies [...]" and saying how that motive is flawed. You responded with some shortcomings of one of the languages I mentioned which has no bearing on whether the business decisions to keep things opaque and closed do better for the language by keeping others from providing implementations.
&gt; without recognizing the damage Sun (ahem, Oracle) did to it. Like, what?
Just curious: why not create a little launcher yourself? I don't think it would be more than a couple of lines of code. Waiting for the JEP to land would probably take a few years.
And approximately 10 microseconds after release, Lombok will have a feature that desugars ‚Äòval‚Äô into ‚Äòfinal var‚Äô, everyone will use it and the Java maintainers will look like morons again.
Preventing other open source stdlib implementations, not adapting the language to newer paradigms, not being completely open source with the JVM implementation from the start, not being completely open source with the TCK, etc, etc. At least 3 of those are reasons Android came about and I would contend Android would not have reimplemented if the system were more open from the beginning. Java under Sun was too closed, too private, too business restrictive, too reliant on license monies, etc. It'd be unheard of to see a language and runtime created like that today, yet it was pretty common back then.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is this the reason behind Google's decision on pushing Kotlin more and more into Android development?
Things to remove: * Java
What an inane list. Three out of seven tools to "remove complexity of Java Development" are the three most popular Java IDEs? Compared to what, using vim?
I've never seen a better example of burying the lede like this article
IMO it is better to teach Gradle these days. Maybe show manually run javac/java as part of explanation of how compiler works. You rarely need to invoke javac/java directly in professional work anyway, always via some build tools. It just that the older tools (Maven/Ant) were more difficult to bootstrap. The newer version of Gradle with `init` sub-command is quite easy to use for [standard console application](https://guides.gradle.org/building-java-applications/). `gradle init --type java-application` would create a skeleton app with Main. To build and run simply do `./gradlew build` and `./gradlew run`. 
[removed]
Why Maven over Gradle?
Nope, it doesn't make much sense for Java. You can see it in Kotlin but it still has a type, the position of the type is just changed from the lefthand side to the righthand side, Java: `private final String foo`, Kotlin: `val foo: String`
It stands for "Elastic Edition" or "Extensible Elements" these days ;-)
An API is a catalog, Orcale is trying to copyright the equivalent to a product list or a table of contents in a book. Can a list of chapter names really be copywriteable?
You mean why Gradle instead of Maven? Gradle has sensible default values for creating a skeleton project. Last I checked, in Maven, you still have to specific package name and stuff (e.g. com.example.HelloWorld). Also Maven's "run" jar command is not built-in, you have install the Exec plugin. 
Many thanks for giving yet another proof how Google scummed Sun.
No problem! I thought people might like to hear from him! It may be more convincing then!
I am also on Oracle's side, and the interview posted by lbkulinski is yet another example how Google misbehaved.
A nice quick win! Also good to try out something small and silly on the command line, when the repl is too cumbersome (becaues the "small and silly" turns out not to be *that* small after all)
If you actually wonder why to choose maven over gradle: Maven is (mostly) declarative so leaves less room for people to do stupid shit in their builds, it makes deployment and cross-project dependency management a little easier, and it has better IDE support. Both gradle and maven have their advantages and disadvantages.
Just don't do it that way! These interfaces are meant to be a common foundation for higher level frameworks like Reactor or RxJava. All the the useful operators that you would need to be productive are not included in the low-level API. So, just use [Reactor](https://projectreactor.io/).
Came here with a very similar thought. Reminds me of a line from the movie Syriana where some American guy is in the desert with an oil family Arab who is letting him talk while tending to a variety of thing. The American says the oil is running out. Finally the Arab stops and speaks. "Tell me something I don't know".
Came here with a similar thought.
The idea being similar naming to MicroProfile I suppose...
&gt; Can anyone think of any company in the world that would name its product "enterprise profile"? This name on its own doesn't make sense. Is Eclipse MicroProfile close enough? So I guess Eclipse already has a track record with that kind of naming...
I really think they should do better. The biggest benefit of the "Java EE" name was that it implied being the 'official' standard when it came to doing enterprisy stuff; Java Enterprise Edition. Just naming it "Enterprise Profile" is IMHO a mistake. The strength the Java EE name had was the tie-in to Java. The term "enterprise" by itself is utterly meaningless. They'd probably see a higher adoption if they would just throw in "blockchain".
Actually, IE and (i think) Safari on the mac still support java applets as well, it's just a bit of a pain. We have a legacy system that uses applets, so i know IE works even today, but i haven't tried it with Safari in a while.
No it's more like manufacturing a lock with a very specific design and someone comes along and starts producing locks which work with the same keys to cut down their own costs by using yours. (It's not *much* like that though, but that's a closer analogy than the one you gave...) Asking people to pay license fees to make compatible locks doesn't give them a monopoly on all doors, that's silly. Anyone is free to design locks differently, and many thousands of other types of locks do already exist.
An API is nothing like a list of phone numbers and tbf I think that's a bit of a dishonest comparison. It's a *design*, at the very least. People complain about lawyers/judges/jurys discussing these things and making rulings without the technical background to understand it ... and "an API is like a list of chapter names" sounds like the sort of stupid shit they might say lol. Or what someone might say to try to mislead them.
Many companies are still using all the way down to Java 4 (1.4), the most "modern" ones are only now transitioning to Java 8, it will take a while before Java 9 is part of the standard IT developer image.
[Ehcache](http://www.ehcache.org/) and [Caffeine](https://github.com/ben-manes/caffeine) are two really common and really easy to use caching libraries. 
That doesn't make much sense for a caching layer. Why would it need a additional back-end? Just look at how Caffeine/Ehcache are implemented.
Especially for start-ups who are under pressure a statically typed language makes perfect sense. Often test coverage suffers in these types of situations and not having to deal with runtime errors due to mistakes that would've been caught in a static language saves a lot of time. I personally would go for a language that's both statically typed and null-safe like Kotlin though. But for a start-up to go for something like NodeJS is just a huge mistake IMHO. 
But why would I want to tie myself to a certain very specific persistence layer? If I want to for some reason migrate a microservice from Postgres to Dynamo I'm screwed. I really don't get the logic of tying these layers together. Quite often the caching is handled in the service layer, not in the persistence layer. You seem to have tied both together. And looking at the "REST" extension; you managed to sort of tie all 3 layers together. 
I know at least one big company is using it in Brazil, it's an online school called Alura, the developer said he's been using since day 1 and has published a book about Java 9 too.
Local variables are only used locally so you don‚Äôt have to worry about race conditions when assigning values to them. You do have to worry about those things when assigning to instance variables. That‚Äôs the point he‚Äôs making. `final` doesn‚Äôt guarantee immutability in Java anyway. It only guarantees single assignment. You can make local variables `final` if you think it makes your code easier to follow (I do), but that‚Äôs all it really does. You can still use `final var` to guarantee single assignment to local variables. It‚Äôs more typing, but it has the benefit of making those variables stick out. Evidently, many people think `var` and `val` are so similar that they‚Äôll be confused for one another. `var` and `let` might be better, but lots of people protested them too. `var` and `final var` is also more consistent with the language, which is worth something.
Most of the adoption is currently libraries preparing to modularize (as I've described in for example http://branchandbound.net/blog/java/2017/12/automatic-module-name/). Java 9's big problem is that Oracle decided to switch to a twice-yearly release schedule, with 9 and 10 (out next month) not getting Long Term Support. So, Java 11 will be when the bulk of the Java community gets to meet the modularized JDK, and gets the opportunity to adopt modules. Hopefully the ecosystem is ready by then. (disclaimer: I wrote [Java 9 Modularity](https://javamodularity.com) for O'Reilly)
How will they look like morons? They opted to not add a controversial feature but left the door open for tooling to implement it. Now Lombok can add `val` _and_ `let`. 2 years from now, the Java maintainers (who take a conservative approach to extending a 20 year old language with billions of lines written, almost all of which still work) can revisit this decision. If bunches of people are using Lombok with `val`, they can add `val` to the language. If they‚Äôre using `let`, they can add `let`. If they‚Äôre using neither, they can move on to more important things. 
I'm rooting for Oracle on this one. If they win they'll have more money to spend on Java development.
Before you assume you need a cache, what scale are you talking? How many users? How much data do you need to cache? Do you care if it's stale. Most people prematurely optimize, for side projects your probably don't need a cache.
You can question whatever you like. The people who get listened to are the people that commit resources and do the work. Which is as it should be.
No matter what Google did, the whole idea of a "copyrightable API" is frightening. Allowing that would open a can of worms worse than patents. All of a sudden somebody can claim that String manipulation methods are their own, having a function like "public String padLeft(String string)" (without caring for the actual implementation) in your application can be a copyright violation, that is scary. But that is only where it starts, if you can copyright APIs, why not data structures, too? Or design patterns?
&gt; There are only two hard things in Computer Science: cache &gt; invalidation and naming things. Don't introduce a cache unless you really *really* have to (as in, you have exhausted all options in optimizing your data model and database). Caches will complicate your architecture and introduce data consistency problems. For example, see [here](https://madusudanan.com/blog/understanding-postgres-caching-in-depth/#CachePurpose) about tuning Postgesql's *own* cache. Also, you mention web cache, which is actually a different thing, but also useful to reduce server load. HTTP has [cache control headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching) which can allow clients (like web browsers) to limit the amount of server requests. 
Quite the opposite, Google played an old style Microsoft move. Any Java library writer that wants to target Android needs to write their library on the subset supported by Android, or write it twice. Now with Java going in 6 month release cycles, it is going to be even harder to take advantage of modern Java features while trying to target Android as well. So basically Google has forked the Java eco-system, succeeding where Microsoft failed.
We tried to adopt it, but had a lot of issues with reflection in old dependencies. We eventually gave up. Realistically I don't think we'll migrate from Java8 until Java11 comes out (11 being the next LTS)
My company has just moved to java 8. Java 9 is not on the horizon yet, let alone the module system.
I don't like it, and it fucks with reflection. It will most likely never find it's way into my code. I have mvn and guice..so the module system is completely redundant imo. 
Java is by far not a productivity-oriented language, it requires an external codegen (Lombok) just to declare a simple data type. The most viable statically-typed language for a start-up right now is Scala, it's very productivity-oriented, has actual static type-safety (best in industry languages) and its large industry presence ensures that all the common development are trivial and all the required tooling is present. Also, neither Java nor Kotlin are good examples of a statically typed language, as the standard way to get anything done in them is through runtime reflection and code generation ‚Äì Spring Boot itself is a runtime codegen expanding macro annotations, technically it's a language on top of Java.
Thanks, well, I think most of those criticisms, or similar ones, could be made about any successful technology company today that came out of the 1980's or 1990's. Open source was still catching on. There's still plenty of closed source today. Countries have borders and companies have a right to defend their rights in court. These things help keep our world more or less civilized.
Perhaps we should abolish copyright for all works of art.
APIs are not a work of art. They are a contract between systems. The whole reason they exist is so systems and interoperate. If implementing an API is illegal, due to copyright, then there is no legal method of making a better implementation that will replace the original, while not requiring users to change their code. I think that is appalling. 
I feel your pain, but you do realise that you'll run into the same issues when nothing changes? I hope you contacted the library maintainers to nudge them towards Java 9 support!
&gt; They are a contract between systems. As far as I'm aware, a contract between computers isn't a legally enforceable thing. It sounds like Google is in the clear. I think we just helped the court solve the case.
We could argue this all day, lets just say calling the other person a fool and claiming they lack the background in the discussion is just making you look the fool. 
&gt;Local variables are only used locally so you don‚Äôt have to worry about race conditions when assigning values to them. You do have to worry about those things when assigning to instance variables. That‚Äôs the point he‚Äôs making. Not sure that scans from the section I quoted, but fair enough. &gt;final doesn‚Äôt guarantee immutability in Java anyway. It guarantees reference immutability, just not object immutability.
We're on Java 8 and will probably wait until the next LTS version before moving. The module system in Java 9 is a negative for us. It adds an unknown amount of potential extra work for us, gives us absolutely no benefit in return since it's solving a problem we never had. Though there are a few nice-to-have additions in 9, none of it is compelling enough to make us want to sign up for a mandatory 6-month upgrade schedule.
I've been using Ebean as an ORM for a while and I really like it. Despite the very small community, it works really well. I really enjoy support for Partial Objects, mapping Enums and a slew of other properties. I thought it deserved some attention here.
I‚Äôm keeping my .ear to the ground with this one
 For example: HttpClient client = HttpClient.newHttpClient(); CompletableFuture&lt;WebSocket&gt; ws = client.newWebSocketBuilder() .buildAsync(URI.create("ws://websocket.example.com"), listener); 
I think its a bit confusing to folks, it messed with me and this is my life. At the same time this thread appears to be brigaded by some folks who REALLY believe oracle is right. The irony here is they would not have affordable capable computers with operating systems connected to a public open network capable of interchanging messages if APIs were copyrightable. "Oh but we have all that now so its no big deal...." I ask What's next that our ignorance is shutting down before it has a chance. 
I guess you are unfamiliar with how Oracle does business. Look at OpenOffice and MySQL
Meanwhile HP focused on selling hardware and services to run any software the customer wanted in any ecosystem they had. Sun wanted to own your network like the borg. 
&gt; Not sure that scans from the section I quoted, but fair enough. I may have done him a disservice by only quoting from the Syntax section. He goes into more depth in the post: &gt; Immutability is important, but in reality, local variables are the least &gt; important place where we need more help making things immutable. Local &gt; variables are immune to data races; most locals are effectively final &gt; anyway. Where we need more help in encouraging immutability is *fields* &gt; -- but applying type inference there would be foolish. I'm all for making local variables `final` when possible and I'd love it if Java had chosen to make `final` the default back in 1.0. Unfortunately, I think it's too late to change that given Java's commitment to backward compatibility. I don't know that an abbreviation for `final var` makes my code that much more readable though. Would `final var` still be allowed if we had such an abbreviation? If so, all 3 of these lines would mean the same thing ``` final ArrayList&lt;Foo&gt; x = new ArrayList&lt;&gt;(); final var y = new ArrayList&lt;Foo&gt;(); val z = new ArrayList&lt;Foo&gt;(); ``` That's not necessarily a bad thing, but I don't know that it's a good thing either. Anyway, these are all my opinions. I'm happy that `var` is making it into the language. `val`, `let` would be nice to have (or what about making a bare `final` mean "single assignment with type inference"? I haven't really thought through the consequences of that), but I understand why they were left out.
I didn't claim they lacked the background. I'm sure they know full well that what they said isn't a particularly accurate comparison, I think they were just being disingenuous. I also never once said that I believe API should be copyrightable. Do not put words in my mouth. All I said was that an API is not like a list of numbers or a table of contents.
Now I see why you are being downvoted, someone has a disucssion with you, you assume they are arguing. Got it.
Fair enough, though I disagree it is just a list of names a numbers. A list of street names belies a design of a city but is not copywriteable as it is not the design itself. A list of components belies the design of a car or a train but a list of its components does not make a train or a car. A list of chapters belies the structure of a book but it is not the book. A list of method and class definitions belies the structure of a program but it is not the program itself. By trying to say APIs are something else you are complicating what is a simple issue so that it is difficult for the layman to understand. The fact is this is just like many real world concepts but just like everything else, in the digital world we just want completely different rules to apply. 
I'm afraid modules is something that can really kill java as a platform. A lot of hassle for current codebases to migrate, another thing to worry about for programmers and main added value is transitive dependency conflicts (since dynamic module loading/unloading is not quite "there" yet) and that is not really worth the effort. Maybe clearly defined public api is a bonus but if you are accessing internal classes you know what you are doing is a hack and won't be surprised when next version breaks it. So basically you will always want "-illegal-access=permit" JPMS is the first feature since starting the language that is forced upon developers , it will not be optional and you will not be able to escape it, all other features that were added to java are still optional, you are not forced to use autoboxing, annotations, lambdas, default methods, for-each, try-with-resource, string in switch and multicatch, you should cause they are awsome, but you are not required to rework your code to use them. You cannot escape (to an extent) enums, generics, varargs - but they are very convenient so why would you, and again current code is not harmed. Modules will cause stack traces where there were none before. With JPMS all your code code is forced in a sandbox that will protect you from shooting yourself in a foot but at the same time makes you trip over your own feet.
Sounds like a sane approach! And indeed, Gradle dropped the ball IMO wrt. module support. Maven followed Java 9 development pretty closely fortunately.
Yeah fair enough I can understand your position, sorry for reacting a bit aggressively btw! Was just needlessly escalating a minor misunderstanding :)
JPA mapping annotations work fine with value/immutable classes. You just can't mark the fields as final, but the class can otherwise be immutable. The real problem with JPA and value/immutable classes is that the entity manager tracks changes and immutable values can't change. Which means the only SQL statements that will be available to the entity manger are SELECT, INSERT and DELETE with immutable entities.
It will be the 'final var'
I've been preparing for Java 9 migration on a ~2000 classes swing application, its a lot of ~~pain~~ fun... The solution to let your module be reflected upon by other librairies (xml, frameworks, etc) is to declare your module as open to reflection, ie : **open** module client { requires java.desktop; etc. 
Looks neat. Need a Scala compiler that understands modules before I can migrate, though.
It is included. I increased the size of the link now.
* A little older state of popular libraries[WorksFineOnJava9](https://pbs.twimg.com/media/DOGS5IzUMAACXu1.jpg). More [here](https://twitter.com/hashtag/WorksFineOnJDK9?src=hash). * [Java 9 @ Elasticsearch](https://www.elastic.co/blog/elasticsearch-java-9-and-beyond)
And here is what I said about it. Pretty much in the same lines as David's blog. http://twitter.com/brunoborges/status/9614557‚Ä¶
Work at a large company, we finished Java 8 Migration in 2017, and are skipping to Java 11, though our key libraries are testing against the intervening releases. Modules will only be worth the trouble once enough other features have built up to make the Java 8 -&gt; 11 transition worth it.
I don't like them either. Also I don't get, why no one in the java community tried to create something like the "Entity Framework Fluent API" in the .NET world, where you can define mapping programmatically and type-safe. I think this would be especially easy in Kotlin, since the language supports property references. And in Java it could be emulated with method references.
There are always imperfections. This does not justify someone else, who is not even the owner, in doing even more harm.
Yeah because patent trolling is totally not a thing and you couldn't use this ruling just like a patent troll to quash competitors in court or shut down an OSS project you don't like. Oh wait, actually you could if this ruling goes Oracle's way and people will take advantage of it. We are in a letter of the law world we stopped caring about the spirit of it long ago. it takes thought and time to organize any list or outline but you cannot copyright a list if its an outline you have SOME rights however if I take your lines and color them in completely differently (API impl) then my work does not infringe.
Java's binary license says something about the topic and Google was well aware of the issue. 
I like it a lot, It's really well designed. hope it gets more popular.
If you follow the licensing terms you are legally safe. 
Respecting other peoples' work does not harm innovation. Stealing it, however, does. 
It could not be that Google simply did not want to pay? Java was was Google's choice based on technology, they even said this in an email. 
Been using Ebean for the last year or so and it's been a good experience. One thing I ran into was how Ebean does locking for updates. It uses optimistic locking by default, so be careful to make sure that data writes/updates in sql migrations are in the exact same format that entities use. i.e Dates, decimal places, etc. http://blog.matthieuguillermin.fr/2012/11/ebean-and-the-optimisticlockexception/
They'll have more money yes, but will they spend it on development? My gut says no.
This is a balance some stuff can be cached in a CDN like cloudflare ( still free afaik) some stuff can be cached in an application cache. If you think your application will scale out in the not to distant future then EH cache / other "caches" are essentially useless, so you should be looking for an distributed grid. If you are planning on something of this size, then questions about only system of record in the db. Do not use a TTL for your entries, postgre has a notification service so can update cache entries giving fresh data and saving you a headache. 
I love how people throw phrases around like that without realizing that the industry we have today and the insane growth and wealth we have seen is because of that sharing. Pulling up and re-defining copyright over and over to take rights away from the people harms innovation and raises the barrier to entry for all players. Lines like yours are used by folks who have something often after building on top of someone else already. My list of methods and class names is not where my work or effort goes its in the implementation. The only use oracles position has is to shut down the innovation of others, innovation that allowed this country to be the amazing tech powerhouse it is today. Finally there is very little proof rights like these actually help an industry. For example the fashion industry has traditionally never used copyright as it is used in other areas. Despite what folks like yourself with quotes about rights ownership pulled from a blog seem to think will happen to industry the fashion industry is thriving. You can try and tell me all day that someone deserves rights to their "innovation". I am not sure anyone deserves the right to disenfranchise his countrymen at his own enrichment but that the nation we have i am so glad you like it so. I find this kind of idea disgusting at any level. 
A cache is a cache whether its in the db or not, most db vendors support pub sub / event notifications, it is a trivial task keeping an external cache in synch with the data source. This gives big payoffs instead of trying to scale up / out or shard your db, this is harder and normally more expensive than adding a cache. All companies with a web under load are using some form of CDN, speeding up the delivery of content and reducing load on source systems. So i would include some form of proxy serving content as a cache also. End decision is cost, cost drives architecture and architecture drives performance. 
Thanks for the explanation
Ah, yeah, the full quote makes what he was getting at much clearer. Maybe I should have taken the time to read it in context before dismissing his opinion. ;)
when did they drop it? I have recently developed a play 2.6 App and Ebean was still the default orm
Thinking your line of reasoning through, one would have to conclude that Google, one of the richest corporations in the world, should get a free ride. But software licenses exist and they are enforced. There is no good reason why Google should be excused. 
I personally wouldn't recommend using Ebean. I have written multiple Apps with Ebean since Play Framework comes with it per default and decided to go back to JPA and Hibernate finally. Some issues I remeber from top of my head: * Standard stuff generally works but once you have complex queries things can get ugly. I remember an ocassion where a Iterator over a query result would simply not work. (each iteration contained the first element of the list instead of the actual element of the iterator position) So I ended up having to do rawsql for more complex queries. * Testing can be frustrating. Ebean entities need to be enhanced, the framework I used did this for me, however when running tests suddenly I had to do it myself which caused some headaches and nondeterministic tests. * Lots of versions. I think it already is at version 10 or something, when I was writing my first App with Ebean 2 years ago it was only version 3 
Yep, as other have pointed out, they both have pros and cons. Just that for this use case (skeleton console app for students), Gradle is easier to bootstrap. It is not by much, so if you are making a choice for production, you ought to do more research as there are lots of other requirements that might come up (dependency support, plugin requirements, repository integration, speed, IDE support, etc). 
Ok, I'll respond. First, Oracle is ramping up the Java release schedule. In his talks about pattern matching and the `switch` statement, Brian Goetz talks about delivering incremental language features at a more rapid pace. All of which is to say that you don't necessarily have to wait 10 years to see progress. Having said that, I don't see how this blocks progress. It leaves the options open for later if the community decides it really needs a shorthand for `final var`. And if it doesn't (like the C# community hasn't), no harm done. You're right that the same discussion will come up in the future. That's not a bad thing. If they had chosen "randomly" as you wanted, then we'd be stuck with the decision. What if they chose `val` and a large portion of the user community wound up confusing it with `var` in practice? We'd be stuck with it for the rest of time because the language maintainers made a strong commitment to backwards compatibility. Personally, I don't think making "random" decisions is a very good way to extend a language. You call it "narrowminded", but that word means "intolerant of other people's views". Given that they polled the user community and opted for the decision that upset the fewest number of people, I don't think you have a good argument there either. As far as I can tell, you're upset because they made a decision _you_ don't like. I get how that's frustrating, but I don't think you're being fair. Brian Goetz gave a very good talk called [Stewardship: the Sobering Parts](https://www.youtube.com/watch?v=2y5Pv4yN0b0) in which he talks about his approach to extending the Java language. You can disagree with him, but you can't deny that he has well thought out principles.
[Factor out ebean from Play Java, factor out anorm and use JPA and Slick](https://github.com/playframework/playframework/issues/1518). 
Adoption has been slow in my sector (fintech), given that our customers (banks) are pretty conservative. The very fast release cycles (and short support timeframes) have a lot of people worried. A lot of software doesn't even run on Java 9 out of the box, which isn't really helping with the whole adoption thing either.
Daddy needs a bigger yacht!
Fragmenting the Java ecosystem makes Java worse. If licenses and copyright help, I gladly take them over fragmentation. 
&gt; The Best Code is No Code At All A cache by any other name may still be a cache, but the cache topology you don't have to maintain is better than the one you do. The DB cache is the responsibility of the DB vendor. You can be sure that the maintainers of Postgres are making sure their in memory caches are consistent. Adding a cache topology isn't trivial, and it adds significant complexity and points of failure to an application architecture. Thus, until you get to the point where you would even consider needing to shard the DB, it is more cost effective to optimize the DB and the database model. That is one less thing to maintain. &gt; End decision is cost Which means choose the simplest architecture that can possibly work for the problems that you have today, the largest of which are likely business related and not technical. Being able to endlessly scale horizontally is nice, but pointless if you're not facing problems of scale.
Implementation of the resolver: https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java Not something I would like to dedicate my time to.
&gt; Spring Boot has integrated support for this (to create an uber jar for example). While I overall agree with you it also shows some problems with Spring. I don't believe people who wrote Spring Boot plugin had any idea as to how to write proper Gradle plugins. It breaks build cache for instance, and a fix won't arrive until 2.0 is released within the next few weeks. So sometimes you get a rather smelly turd you can't easily get rid of.
To be fair, that single guy maintaining the Ebean projects has done a really great job. Rob is very knowledgeable and responsive. The number of responses he has provided in Github and the Google Group is quite impressive: https://groups.google.com/forum/#!forum/ebean https://github.com/ebean-orm/ebean/issues Also just a nice guy who is very passionate about providing a great product which makes me want to support him any time I see Ebean mentioned.
I totally agree and I'd love to see the community helping him but no matter how much of an awesome guy he is, he is still human and we all need help and a single guy can't handle that work load.
Excellent, thanks.
nope - Mid march.
&gt; This is just a name A hotly debated name. &gt; Both of them are battle tested In languages that aren‚Äôt Java and use the names differently than Java. &gt; I promise you that the next time the decision will be equally debated and there won't be any new convincing information brought to the table. There will be new information. We will have had `var` for local type inference and we will have spent some time writing `final var`. That will help the community decide whether it needs an abbreviation for `final var` or whether it can live without it. &gt; it is an important thing to have. Can you explain why it‚Äôs so important? What classes of bugs are eliminated by having an abbreviation for `final var`? I wish we could go back and make everything `final` by default, but we can‚Äôt. I‚Äôm ok with this decison because it doesnt close any doors. Maybe we‚Äôll get an abbreviation in the future or maybe we won‚Äôt. The future success of the language will not depend on typing 6 extra characters. I‚Äôll take pattern matching, value types, and reified generics over an abbreviation for `final var` ‚Äî all of which are on the docket ‚Äî any day of the week. 
Dead software by any other name is still dead. Was slow decision making what made EE irrelevant in the first place?
This is a good question . I‚Äôve been asking myself the same question after joining a company that does java. Not many things are ‚Äòfluent‚Äô here 
We are speaking about APIs, if you think licensing arguments will get around the issue of putting APIs under copyright you are sorely mistaken.
License away, shoving API under copyright to assert more control screws over an industry because you hate using multiple IDEs and platforms.
&gt; vert.x You can never go wrong with this. It's fast and easy to use. Not as restrictive as NodeJS due to multiple threads event-loop and dedicated worker threads. 
wasn't painfully slow decision making killed EE to begin with, no changes here it seems, cue the zombie naming contest
Thanks for some more food for thought
An API is *not* a contract in the legal sense as computer programs are not considered legal entities. There is the notion of software design by contract. You can violate that kind of contract, which often causes defective software. Legal consequences usually only consider the defects not the contract as in design by contract. 
There was more than just number changes, the package names changed to something like io.ebean... that broke everything I was trying to learn because most of the documentation was outdated.
Slow (but steady) progress seems to be one of the reasons why enterprises use EE in the first place... A lot of the included technologies can be and are used independently, too.
&gt; The irony here is they would not have affordable capable computers with operating systems connected to a public open network capable of interchanging messages if APIs were copyrightable. You assume too much here. This assertion is baseless. 
Your language examples are not WORA, they do not compare well with Java. So, the owner of Java would be ill-advised to adopt one of those languages' licensing model. 
Lack of well-paid PHP jobs.
Not even dreaming of 9 in production. I played with it locally, some toy apps, fine. I'm on 8 in production and it will stay this way until 11.
The logo looks like a Tide pod. Now I'm hungry.
Why not have them use JShell, the Java REPL in Java 9?
Well currently we‚Äôre still on 8. I‚Äôve been pushing them to upgrade to 9, mostly because of JShell.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Java 9 also added way fewer compelling features than, say, 8.
We (Hibernate team) totally can see the usefulness of this and are open to adding this. So far just no one set down an spent the effort to actually implement this. If you're interested in helping out, let us know. It's an interesting task (I'd love to work on this, but I just don't have the time), as that fluent API would be quite big and a challenge lies in making sure that only those methods are exposed in the DSL which are valid building steps at a given time.
How is this related to Java? It's a (silly) Python tool.
&gt; You just can't mark the fields as final Yeah so that's kinda the problem if you don't want to write getters/setters by hand and use Lombok instead. For most DTO's / domain classes we just use the @Value annotation. 
Java devs can use it too. That was the intent.
Well anyone can. But it's not something you'd use in a professional setting and when I want funny commit messages in my personal projects your method really isn't faster than just `git commit -m "Made Sonar happy"`. 
really? you have to think of a funny commit message and then add it. the method is definitely faster. for my fun project, this one, I generated a couple of commit messages by running fcm -f | git commit -a -F - that is definitely faster than typing it out.
yeah but I don't want to migrate those breaking changes 10 times a year. Sure I could stay with an old version, however you still want to have the latest fixes, which you won't get that way.
Like I said; it's not usable in a professional setting and I normally use descriptive commit messages in my personal work too (because it's on github for all to see). I mean by all means go and have fun with a quirky tool you built. But when you post it on reddit you're going to get feedback. This is mine :) 
IMHO, java 9 module system is yet to see massive adoption because of breaking backward compatibility. Any typical java project has a crazy mix of libraries and all of them have to comply with module system and/or independent modules. Also all of them have to make sure they don‚Äôt rely on s.m.Unsafe and alike. This takes time and hence what we‚Äôre observing. With that said, Oracle is doing great job by pushing entire java ecosystem from language to vm. A lot of great features are lined up in the upcoming releases which I‚Äôm sure will entice everyone to adopt newer releases and do their due diligence to fix breaking changes. Also, bi-yearly release is a good idea and will hopefully bring back momentum and enthusiasm in java community. 
EE was never irrelevant... what makes you think that?
&gt; But it's not something you'd use in a professional setting Agreed. But either way, it's not something you _should_ use in **any** setting, commit messages are not the place for jokes. Unless you don't care about version control in the first place, I guess.
&gt; commit messages are not the place for jokes For personal projects that you just want to put on github you can throw in a funny message here and there. Your carefully crafted commit messages aren't going to be seen by anyone. Secondly the intent is for it to be the first commit message instead of "README" or "first commit". 
I this still the case? (just asking because the blog post is from 2012)
Maybe /u/rbygrave can pitch in on that?
While lambdas and streams are definitely shiny, I personally find the module system very compelling. Of course, adoption will take more time, since it affects architecture/design/builds etc. rather than just new language features. Also, checkout the list of JEPs that went into JDK 9: http://openjdk.java.net/projects/jdk9/ It's huge. Sure, not everything might affect you, but it still was a big release, the likes of which we'll (probably) never see again with the new release schedule.
Still playing with those toys? Or are you ready for some kick-ass SQL?
I think that's a really good question, and I definitely would have (and sorry for the late reply here). I really wanted to get my feet wet, then start using all Quasar's batteries when I understood why they were necessary, what work they're saving me, etc. And oh man, I wish I knew there was a maintained branch of kilim too before I started - I saw it on Stack Overflow and discounted it since it looked dead.
How about creating a git messages tool for a professional setting. I could use e.g. options to prefix / suffix my message with the branch name (prepared git hook for that) or encrypted / decrypted messages. Pack all sorts of useful options.
"Hibernate does not allow lazy loading beyond the end of it's Session scope and instead throws LazyInitialisationException" There's an annotation for that though. A very common one. fetch = FetchType.LAZY
This course is really great. I have refreshed my Java knowledge. Thanks author!
Your assumptions of the opposite are just as baseless. At least on my side there is reality and history and on yours it is pure fantasy. 
I've started with Ebean 4 or something and been able to migrate to version 11 so far without major headaches (sure, some grunt work). But things have been working out ok.
That's one the things I like in Ebean, once the ORM stuff gets in the way, it's very easy to go the SQL route. While I'm not a SQL ou ORM fanboy, I do think that using an ORM for those tedius insert/update/delete for CRUD operations is incredibly time-saving. When I need something more complex, SQL with it. Ebean makes it easy to create an [SQL query and map it to beans (or not map it)](http://ebean-orm.github.io/docs/sql/queries#whereraw) I don't see the purpose of not using an ORM just to be "pure" or whatever. It's a tool like any other. It has tradeoffs.
You should take a look at [jOOQ](https://www.jooq.org/) created by /u/lukaseder it can give you the best of both worlds. It has Pojo / dao generation. A type safe query DSL that reads like SQL. One of my favorite libraries out there. [An interesting SQL query with implicit joins in jooq](https://twitter.com/lukaseder/status/961221654788628482) [POC generic Dao class using jOOQ](https://twitter.com/StubbornJava/status/961469613732171776)
Or they can just make a decision on an incredibly low-hanging piece of fruit right now and stick to it. Whichever way they go, they're still going to have people saying *"Implementing let/val instead of val/let means Java is literally RUINED FOREVER."*; kicking the can down the road just gains them more criticism in that they aren't developing features fast enough.
There is no assumption in what I said. I just pointed out yours. 
If the community can‚Äôt come to a decision on how to abbreviate `final var` (survey results show that we can‚Äôt), and if it‚Äôs not clear that an abbreviation is even needed (we don‚Äôt even have `var` yet, C# gets by fine without one), and if there‚Äôs some legitimate concern that the two most popular proposals for such an abbreviation might make code _less_ readable (both are 3 characters, so they would align with `var`, which could make the differences between them less noticeable), then opting not to add the feature sounds like a prudent, not-at-all moronic decision. You‚Äôre right though. You can‚Äôt please everyone. No matter what they chose, some people would be upset. They chose the course of action that upsets the fewest people and leaves the most options open.
Hi /u/dartalley, thanks for the reply I'm aware of jOOQ, but haven't had the opportunity to try it out. It seems like a very good library. Have to try it out.
That's one library to rule them all
This is the sane thing to do :)
i've never seen the appeal for struts, even 10 years ago. why teams kept on choosing it it was always a mystery to me.
I've worked at 3 distinctly different Java shops in my professional career. All of them used Struts. It baffles me too. University: Struts 1 (eventually bastardized by Kuali) Company 1: Struts 2 Company 2: Struts 2 The reason why we still have it now is simply inertia. We'd have to rewrite so much stuff for such little gain (and countless bugs). I totally get it from a business perspective. But as a technology enthusiast my eyeballs bleed just a little bit when I make a new Action.
Struts? Now that's a name I've not heard for a long time...a long time. /#SSHstack
My project requires me to learn struts, It's too much work and boring. And that xml file, oh god save me.
Same reason as today - the need to have buzzwords to put on your resume and tell to management. Struts wasn't **worse** than servlets. 
That is not want is meant. FetchType.LAZY and EAGER (+ JPA FetchGroups) control how much of the graph is initially loaded. Then if you close the EntityManager/SessionManager and invoke lazy loading ... you will get LazyInitialisationException from Hibernate. This can lead to the use of "lead to 'open session in view'. The point is that this is a Hibernate specific behavior. If you use Ebean (or EclipseLink for that matter) you don't get this behavior (it just works) and that there are performance considerations for this along with the hassle it causes.
&gt; You just can't mark the fields as final, While this is true for the JPA spec ... this isn't true for Ebean (and so it doesn't have to be strictly true - a JPA vendor could support this if they wanted to). With Ebean we do not require a default constructor and we can have final fields. If you are into Kotlin with it's non-nullable types then this gets that extra benefit there and is pretty natural.
As an FYI this is no longer the case. Ebean no longer has the 'ALL Columns' strategy for optimistic locking. 
Has it ever occurred to these folks to hire some CI/CD experts?
Link doesn't work
My recollection is that before annotations spring mvc was only a little better, 2.5 brought annotations and substantial improvements. 
I'm Rob (Ebean maintainer) so maybe to fill in what I know. Play never actually dropped support for Ebean. When you goto the Play website now you will see documentation for both Ebean and JPA and the PlayEbean integration module is well maintained and up to date. That integration module is: https://github.com/playframework/play-ebean ... and I would say it has been well maintained by Play people for 4+ years. Now back in 2013 it sure did sound like Play was going to drop Ebean support. Play decided to modularize their code and pull out Ebean into a separate play-ebean module (and at least some of them said Ebean was not maintained and cited that as a reason for extracting Ebean). They did this all without ever communicating with me (which is ok but a lot of confusion and misinformation has resulted out of this). During the discussions about dropping Ebean it became clear that Ebean was not in fact dead and many people really liked it. However, extracting Ebean out into a separate integration module was always the right thing to do regardless (and so they did that and good on them). Now in the Play ecosystem Ebean competes with JPA, Anorm and Slick etc as it should. The end result is that we have integration via the play-ebean module that is well maintained and Ebean is still documented along with JPA as a persistence option. For Play Ebean users this is technically now way better as one of the prior issues was that 'Play Ebean' users were effectively stuck on a really old version of Ebean (which was tough to support). Now there is a separate Play Ebean integration module and that is well maintained everyone is a lot better off. 
Disclaimer (I'm the main Ebean maintainer). Thanks, some good points here. I'll give you some thoughts on them. &gt; when I was writing my first App with Ebean 2 years ago it was only version 3 There are a few things to suggest you were using Play. Early versions of play had a locked in version of Ebean which was pretty old and that meant supporting people on those versions was hard. If you experienced pain with that I can understand and sympathize with that. &gt; Lots of versions. I understand and agree it is far from ideal to bump major versions. Ebean is about 12 years old and we had gathered some 'cruft' in our API and feature set. Over the last maybe 2 years we have tried to address that via deprecation and removal etc and possibly guilty of being too aggressive with that. I believe we are at a nice stable API now. &gt; Testing can be frustrating. Ebean entities need to be enhanced Fair enough. We have put a lot of effort into IDE enhancement plugins for Idea and Eclipse so that this "just works". I see talk in Hibernate 5 land around enhancement and the benefits of it (partial object support etc). Back in the day Ebean didn't require enhancement and just like Hibernate supported both "dynamic proxies" and enhancement. We dropped support for "dynamic proxies" for some good reasons we think. It does mean we have to get the tooling right from a developer productivity perspective. &gt; once you have complex queries things can get ugly. Sounds like you hit a bug back in the day. Our github issues list is pretty good. I do know when Hibernate generates a sql cartesian product and I do know when Hibernate ignores the firstRows/maxRows and does client side paging. I don't mean to pick on Hibernate but that is who you have gone back to - so I hope you know those cases too. I know when it gets complex Ebean does the right thing in terms of SQL. If you use JPA FetchGroups Hibernate will not currently give you partial objects (limiting your ability to use covering indexes) so you probably change to use DTO's whenever you tune the SQL (so this then becomes a design issue). EclipseLink does better at the moment with partial objects and fetch groups but the JPA Spec requires the version column regardless (which hurts). I'd be keen to hear of any complex case that Hibernate or EclipseLink does better than Ebean. As soon as you get to tuning sql, partial objects, complex deep object graphs ... this is when Ebean really shines. 
JSF arrived first after Struts and it was much better indeed.
Hi Lukas, Does JOOQ have SQL 2011 History support yet or is that something that only toy ORM's have? Actually, I'm curious and would be keen to compare how Ebean and JOOQ go about building complex object graphs. Have you a JOOQ example populating a list of 'beans' that contains 2 OneToMany lists of beans including the use limit offset? Keen? Can you link to example that does that and then we could compare. Cheers, Rob.
Gonna be a no from me dog
&gt; io.ebean Yes, that was a tough decision - I hear your pain. In the end it was a "now or never" thing. We were on a 12+ year old pre-open source package name that I felt was ugly and confusing. Ultimately I didn't want to have that for the next 15+ years. If it makes it any better, we didn't make that decision for kicks - I had a lot of work to do for that. I'm pretty confident that I'll look back in 5 years and be happy about going to 'io.ebean'.
Wow I didn't expect that reply. Thanks for addressing those points I layed out and giving some insights. I very much believe that the current Ebean version is a lot better then what I was using back then and most of my points are solved now. I like the fact the Ebean is supporting partial objects. As you pointed out I am using DTOs for such a case currently. I also don't know about those client side paging cases of Hibernate, can you point me to a issue, example case for that?
Thx, fixed.
Nice meeting you Rob, &gt; Does JOOQ have SQL 2011 History support yet or is that something that only toy ORM's have? First off, don't make the mistake of taking my trolling comment too personal, of course ;-) jOOQ doesn't support the SQL 2011 temporal features yet. Even if they are really interesting and with DB2, Oracle, SQL Server supporting them to some extent, after quite some market research, it did not appear to be *the* killer feature to prioritise after all (yet). In other words, almost no one actually asked for the feature yet, or looked for help for use-cases, where temporal features would have been a solution. That said, I do think the features are really interesting, especially when they can be emulated on other databases that do not have native support. Of course, I've noticed that your product website puts this feature at a prominent location, so you do seem to have quite a different opinion on this topic. &gt; Actually, I'm curious and would be keen to compare how Ebean and JOOQ go about building complex object graphs. Have you a JOOQ example populating a list of 'beans' that contains 2 OneToMany lists of beans including the use limit offset? jOOQ currently doesn't offer too much help in this area right now (there are third party tools like simpleflatmapper). That's a conscious decision, because all pre-existing mapping tools (both ORM-based, or post-processing based) work on the same fallacy that it is a good idea to use SQL JOINs to create nested collections. The correct SQL-based approach to nested collections is to use the SQL `MULTISET` operator (native support in at least Informix, Oracle), which can largely be emulated by using XML, JSON, or arrays (DB2, MySQL, PostgreSQL, SQL Server, etc.) The use of `MULTISET` would also allow for nesting arbitrary tuple collections, rather than pre-defined, hard-wired nested entity collections, something that is overrated in my opinion. We'll see, once jOOQ supports (and emulates) it, how it will be adopted. &gt; Keen? Can you link to example that does that and then we could compare. So, you've listed 2 features that seem to be particularly important to *you*, but like with any vendor-backed comparison between competing products, such a comparison would only show that right now, your product is better at the 2 things *you* think are most important. Is that helpful? :)
&gt; I don't want to migrate those breaking changes 10 times a year Fair complaint? Yes. We don't want that for Ebean users either. The proposal is that Ebean has got there now in terms of a stable, clean, minimal, consistent API. To get to this point we took the approach of looking harshly at all our public API and features and over the last 2 years deprecated and ultimately removing the cruft. I'd say it is a long term choice to get the tech debt down to be very low both in terms of public API and internals. It came at the cost of asking Ebean users to bear some migration cost. Did we make those changes too quickly for some? Perhaps, but then again people can get involved and temper changes. Will the changes continue? No, we expect to be API stable now. We have 1 deprecated method but no other breaking changes planned (some additions).
Light-graphql-4j is another framework that supports GraphQL along with other style of interactions. I am the author of the frameworks. https://doc.networknt.com/style/light-graphql-4j/ https://doc.networknt.com/tutorial/graphql/ 
That's fair. Fixed it. "Alternatively, using GraphQL we expose a single endpoint (typically `/graphql`) which accepts a GraphQL query from the client and responds with the requested data. Here's an example: "
Why?
Jakarta has an association with Java, both wrt the island (Jakarta is Java's capital city), and wrt the history of Java the programming language. It's also quite close in feel JAkarta EE vs JAva EE. 
Yeah, I get that. But why does it have to be close? Doesn't that make the brand an order of magnitude weaker, if it's mimicking a deprecated brand (which was already weak due to the J2EE / Java EE renaming)? How about inventing a new, powerful brand that lasts for the next 20 years, rather than creating a brand that seems kinda, oh well, clever right now, and then for the next 20 years will need its silly historic context explained.
I'm serious I'm a newby at this and i dont have a clue what I'm doing 
How the thing works: In "main" you can call or text your friends just as skype or icq when you are in the app, you need to put informations in your profile about (age, gender, location, first language, second language, knowledge of) "notifications" is where you receive notifications ! it's a message "people" is the list of all that are online Lets say have a question about nebuchadnezzar You go to "people", use the filter and select "knowledge of history" after applying the filter, you find 32 000 matching people out of 500 000 online you send a notification to them they will receive the notification and will reply to you, also by notification or by instant message or by calling from the 32 000 , there will be like 15 that know the subject very well last step: call them and enjoy your instant answer ! 
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 100.0% out of the 3 submissions from /u/SarkhanRasullu appear to be for Udemy affiliate links. Don't let spam take over Reddit! Throw it out! *Bee bop*
Just had a look, seems like a nice library. 1 thing I noticed: Why not parametrize RetryConfig and RetryConfigBuilder to define valueToRetryOn of the parametrized type?
&gt; Just had a look, seems like a nice library. 1 thing I noticed: Why not parametrize RetryConfig and RetryConfigBuilder to define valueToRetryOn of the parametrized type? Just hadn't even thought about it but that is a good point. I'll probably update that to be parameterized instead of using an Object like it is now. &gt; I would recommend to move RetryListener configuration to RetryConfig, and making CallExecutor and subclasses fully immutable. You are right, I hadn't really thought through the ramifications of thread safety entirely. Between what you've pointed out and other stuff I had been considering, I may create more traditional builders for the config/executor and having them produce immutable objects. Thank you for the feedback!
&gt;1. Spring really shouldn't be used ~~ in command line apps. It's better for long running processes (server code)~~. Fixed that for you.
Crap... this sucks... I think this means my shiny new EE7/8 apps are already obsolete because their core technology isn't even called that anymore. Are they going to refactor the entire javax stuff?
Hahahahaha nope
&gt; jOOQ doesn't support the SQL 2011 temporal features yet. Wasn't most of the SQL 2011 revision about temporal features? &gt; The correct SQL-based approach to nested collections is to use the SQL MULTISET operator Why would MULTISET be the right thing to do if only a few "jOOQ Premium" vendors support it and it has to be emulated everywhere else? Maybe trolling you here :) &gt; by using XML, JSON, or arrays You'd still have to parse/deserialize every object in the collection to do anything useful with it, so what's the idea? &gt; We'll see, once jOOQ supports (and emulates) it, how it will be adopted. So, no idea. 
Checkout @ConditionalOnProperty. You can put that on a service implementation that implements a common interface. For each property value you can specify a different implementation. Then autowire the interface with constructor injection, not the implementation. This is part of Spring Boot btw. I see you're using getBean, which is what I came across when using non-boot spring and trying to do this.
Yeah, I was wondering that, too. I thought it just might be me.
We were using a pretty old version of Ebean. 
I can't even begin to list the reasons. Let's just confine ourselves to the one I mentioned.
it's irrelevant today. I wasn't saying it's always been. Seems like decisions are still getting made super slowly, I had hopes it would be different and things were changing for the better.
Please javadoc.
How does your application recovers in case it fails when procesing certain file or writing to the database? Are you writting all that logic? For applications that typically consist of managing csv files, moving and processing data, you may want to look into Spring Batch (the version that uses annotations and not xml) with Spring Boot.
I actually like to use Spring Boot for simple command line tools (with CommandLineRunner). If you keep your classpath lean and don't include too many starters it works quite well. But it always depends on the use case. If the tool doesn't do much work, it might not be worth paying the price for starting up the VM and starting up an ApplicationContext.
&gt; Wasn't most of the SQL 2011 revision about temporal features? Yes. Why? &gt; Why would MULTISET be the right thing to do if only a few "jOOQ Premium" vendors support it and it has to be emulated everywhere else? Maybe trolling you here :) I do hope that other vendors jump on this train eventually. And I do think that ORMs can exert some pressure on vendors, once they help make this feature available to users. &gt; You'd still have to parse/deserialize every object in the collection to do anything useful with it, so what's the idea? The serialised form of the collection would be optimal, rather than producing cartesian products. Of course, the cartesian products can be avoided by splitting parent-child fetching into several queries, but you'll still have duplication. Besides, if you nest collections in SQL, you'll be able to produce vastly more complex / interesting results. [See, e.g. this tweet](https://twitter.com/lukaseder/status/832939068933681152) &gt; So, no idea. Well, to be fair, we live off the survivor bias of previous vendors who happened to be successful. Many vendors in their own contexts were taking risks in implementing designs / features / products that weren't proven yet. We'll know in hindsight. I do believe that the status quo is not good and we can do much better.
&gt; We have exchanged emails in the past and had a couple of small conversations - so yeah - Nice to meet you again. Rob, I'm sorry I forgot. When was that? &gt; Sure. You in turn expected exactly such a response no doubt. No, I sincerely didn't. I do apologise. &gt; You are of course talking about some other ORM's and not Ebean. Just pointing that out here. You probably mean the fact that Ebean runs several queries to avoid cartesian products between unrelated parent-child relationships? I still believe that is not enough. We can do better. Cheers, Rob, and sorry again.
&gt; it can give you the best of both worlds I like JOOQ and it absolutely goes into places the Ebean doesn't go and won't go but the converse can also be said so maybe it's worth looking at that closer? If you are in the OLAP space and have things like SQL window functions etc then this is absolutely the space JOOQ provides an abstraction that Ebean will not. With Ebean we would just use raw SQL statements or a view for such things. If you are in the OLTP space then they overlap quite a lot. I would say that JOOQ is a relatively close abstraction to SQL and conversely Ebean (just like Hibernate, EclipseLink and Data Nucleus) has a slightly higher level of abstraction away from SQL itself (with the associated pros and cons that brings). You will likely know that all those ORM's above abstract not only over SQL databases but other databases as well. Now we don't care because SQL is king and we all love SQL (which is true) but bare with me. We are concerning ourselves with the OLTP space, as a massive generalization that is somewhat dominated by "row stores" currently. Fancy pants Oracle includes both row storage and in-memory column store and you are using Oracle so you stop reading now (maybe). What if you are not paying the Oracle tax? What if your OLTP database does not do both? How can you have both your row store and column store and offload your reads onto a "read replica column store"? What are the options JOOQ provides in this area? Well, with Ebean we can and do want to have this read scaling option. To do this our Ebean queries can hit ElasticSearch or our SQL store or an in memory distributed cache. ElasticSearch is our Yin (inverted indexes up the wazoo document store) to our Yang (SQL OLTP fully transactional row store) and it means we can have the best of both worlds. We are prepared to give up some read consistency for the benefit of getting massive horizontal read scaling and outright performance of inverted indexes (No big surprise here - Hibernate is big on ElasticSearch too). With Ebean our JPA/ORM model maps equally well to a 'Document' and our query language maps equally well to boot (yes, we do have a query language extension for ElasticSearch specific queries that don't have a sql equivalent). So for Ebean this mapping is quite natural and not artificial or 'forced'. JOOQ being an abstraction closer to the SQL language itself is going to find it tougher to map the model and query language to non-sql datastores. Maybe Lukas will put it on the JOOQ roadmap? 
This is all personal opinion, but: 1. I think XML configuration is better than Java based personally. That's in part because I've been doing Spring since before Java based was an option (I started when 2.0 was the current version!), but it's in part because I find it gets messy doing it in Java. 2. I think Autowiring, and Component Scanning, are horrible. I understand that Autowiring is necessary for some concerns, but I avoid it as much as possible. And I always avoid Component Scanning if I can. This is because they make it very difficult to work out how your application is actually built, and they make it difficult to have different implementations of things - the classic Interface, Implementation, Caching Implementation, Logging Implementation setup, for example.
For generating pdf reports, you can check www.ZetPDF.com library 
&gt; I think this means my shiny new EE7/8 apps are already obsolete because their core technology isn't even called that anymore EE 7/EE 8 remains that, and many vendors such as Payara, Red Hat and IBM will be supporting their EE 7/EE 8 implementations for a long time to come. Heck, all of those still have to release their official EE 8 implementation! Jakarta EE will largely just be the new name, very little to nothing will become obsolete from Java EE that isn't already obsolete today (i.e. EJB 2 Entity Beans are clearly already obsolete and have been for years). &gt;Are they going to refactor the entire javax stuff Nope, this has been mentioned multiple times. All existing javax packages and other namespaces will remain in place. 
&gt; it's irrelevant today. Why is it irrelevant today? What has taken its place? 
&gt; No, I sincerely didn't. I do apologise. All good Lukas, apology accepted etc. We chatted back in 2015 about Ebean/JOOQ integration. &gt; I still believe that is not enough. We can do better. Multiset should in theory be better I agree but we already pretty darn good. In Postgres with any(?) the bar is set very high so it is going to be interesting to compare in time. 
I prefer Java config, but I also use XML config in a certain case and I'm really happy that Spring still supports XML config. I can second your second point, too. I think autowiring and component scanning is a superficial productivity improvement. You pay for this little saved typing with longer analysis and refactoring times later. There is a good point in the [Zen of Python](https://www.python.org/dev/peps/pep-0020/): "Explicit is better than implicit."
It can be downright disruptive in some cases. I remember having to read through a significant part of a non-trivial codebase to work out what was wired in where, because there was no single place to look and see it all.
[HN Discussion](https://news.ycombinator.com/item?id=16346648)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
https://playframework.com/
Or https://github.com/rholder/guava-retrying There doesn't seem to be a shortage.
I'm upvoting you, not because I agree with you, but rather that you raise a lot of valid criticism of modern Spring development.
&gt; @Autowiring works best for Datasources, DAOs, and/or classes &gt; that depend on (Autowire) DAOs themselves. Autowiring is the heart of Spring. Spring, at its core, is a Dependency Injection container. `@Autowire` is how you inject dependencies. It is used extensively in Spring applications the way `@Inject` is used in CDI or Guice applications. In fact, `@Autowire` transcends Spring or even Java. Angular has autowiring too. &gt; @Qualifiers make sense if you're autowiring a something like a &gt; Datasource Spring autowiring is type based. Meaning if you have multiple `DataSource` classes in your application context and try to autowire a `DataSource`, Spring won't know which one you want. That's why `@Qualifier` exists, to let you tell Spring which specific bean you want. &gt; XML configuration is completely dead and should never be used. Not necessarily. I frequently use XML configuration for externalizing SQL queries using the util namespace to create maps, and then injection into the application. Java doesn't have multiline strings, but in XML, I can wrap the SQL in a CDATA and not have to worry it. Also, certain Spring projects I feel make better sense to configure in XML. In particular, Spring Integration. Since Spring Integration is defining a workflow, I find it easier to visualize the workflow in XML. XML configuration sucks for the vast majority of use cases and you should use Java config wherever possible, but don't necessarily write off XML config. It still has its uses. &gt; Spring AOP is terrible. This is one of the reasons I prefer Guice to Spring DI. AspectJ is good and all, but many Spring products already have already configured AOP for you (such as `@Transactional`). Use what Spring provides first before introducing AspectJ. With AspectJ, you are complicating your build process, since you need to activate compile time weaving to rewrite bytecode after the Java compiler has done its work. AspectJ, along with any other tools which manipulate bytecode, introduce dark arts into your Java code. Be careful when playing with black magic. &gt; I keep reading online that getBean should never be used. Because it defeats Dependency Injection, and like the Wizard if Oz, lets you see the man behind the curtain. Dependency Injection mean, "Don't call us, we'll call you". DI decouples dependency management from business logic, making things like the Singleton Pattern obsolete. But, injecting the injector defeats that. But, sometimes you do need to inject the injector, especially when you're doing very dynamic things or integrating with third party code that doesn't understand Spring autowiring. But this code should be isolated and hidden away in specific integration classes. The `getBean` method has its uses, but should be used in very special circumstances, not ordinary code.
There is way more than that actually. If you check out the bottom of the documentation on retry4j there are links to some other mature and well-maintained retry libraries including Spring Retry and Failsafe as well a fork of Guava Retrying called Re-Retrying. Resilience4j isn't one I had seen before so I'll certainly check it out. I have an issue open to add a section to the README comparing/contrasting to other retry libraries that are available.
XML vs Java is simply a personal preference. I started out on XML, and it's what I'm used to. I've got nothing against Java config at all though - and in some ways it can be a big improvement. Things like being Generic-safe - which the XML config isn't. Equally, Autowiring and Component Scanning have their places. For small applications, Proof of concepts, tutorials, things like that then it's fantastic because it dramatically cuts down on what you are doing. When you get beyond a certain size then - in my opinion, and I'm not going to even try and suggest otherwise - then it actually ends up making things harder simply because there is no big picture. I know that there are tools to alleviate that these days, and that's fantastic, but if seems that if you need to depend on a tool to see how your application is wired up you've got other problems.
Come work with The Andrews Group
 $ time Java Hello Hello World! real 0m0.217s user 0m0.125s sys 0m0.077s 200ms. Horrible!
&gt; JOOQ being an abstraction closer to the SQL language itself is going to find it tougher to map the model and query language to non-sql datastores. Maybe Lukas will put it on the JOOQ roadmap? I really hope this doesn't happen. Even abstracting over different SQL dialects is an incredibly complicated problem because they are so many differences. Other considerations * Models often don't match across data stores * ES generally has fully denormalized data where SQL is normalized * ES often adds extra fields or changes the structure of data to make search better. For example in SQL you might have the following columns for a user. `id`, `first_name`, `middle_name`, `last_name` but in ES we might have `id`, `full_name`, `also_known_as` which is an array of any previously known names. ES also either has multiple fields for using multiple analyzers or might be using multi field types. * Read consistency * You need to know that ES is an eventually consistent data store so a insert directly followed by a read could return no data. This is a tradeoff you are probably ok with in some cases but if you APIs are so abstract it doesn't care what data source you use it could be confusing to the API consumers. * Maybe you notice your Redis cache is getting invalid / stale data more often than you would like and you now need to implement CAS using Redis' `WATCH` command. * Mapping POJOs in ES or a cache is pretty trivial since you just serialize the object as JSON. Now an ORM that can map MongoDB, Cassandra, SQL could be nice but has many other tradeoffs as well. Personally every time I have used a generic ORM I have found myself deep in the weeds trying to solve something trivial if you used libraries specifically made for each technology. 
You make a convincing case. Where do I sign up?
&gt; Maybe Lukas will put it on the JOOQ roadmap? Nope, that can of worms will not be opened in jOOQ
Let's call it jee - jee ain't java ee
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Very much looking forward to Value types. Anyone have any idea on the timescale for them?
I‚Äôm thinking around 2020, but of course they haven‚Äôt advertised anything.
I like that.
&gt;it'll either "Jakarta EE" or "Enterprise Profile" wat
Its between the two **final** names : **Jakarta EE** as in https://en.wikipedia.org/wiki/Jakarta_Project or **Enterprise Profile** Poll: https://docs.google.com/forms/d/e/1FAIpQLSerWX0GwYZqxWXOnmM8D8shvzrw8PY0NH92TWwg6puCrttxsA/viewform 
**Jakarta Project** The Jakarta Project created and maintained open source software for the Java platform. It operated as an umbrella project under the auspices of the Apache Software Foundation, and all Jakarta products are released under the Apache License. As of December 21, 2011 the Jakarta project was retired because no subprojects were remaining. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Fuuck I thought that was just a joke. Then I realized it's 2 years away. I have anxiety now
1) We use Spring for command line apps and it works great. What problems are you having? The one issue I am aware of is that it can add to your startup time but I would only worry about that if it was a significant portion of the running time. Most of the command line apps I've written have some other bottleneck, e.g. network, so the startup time seems negligible. I wouldn't write a grep replacement using Spring (but then JVM startup is already too slow so I wouldn't use Java). 2) Autowiring works great for classes that are stateless other than their dependencies i.e. classes that only have final fields. I think the complexity is usually too great for the benefits if you try and start autowiring prototypes. I find it much easier to have stateless services and pass around state via manually created objects. 3) I agree with your usage of @Qualifier. I also like to wrap my qualified dependencies if I find that I am injecting them more than once, and then inject the wrapper based on type. 4) Yup! 100% agree with a couple of rare exceptions (e.g. autowiring into an abstract base class) 5) I would prefer trying to simplify the configuration over writing a GUI to make it user editable but if that is not possible then I agree PropertySource won't help you. 6) Yup! XML pushes a lot more errors to runtime and makes it harder to work out what is going on. Java configuration solves all of these issues. 7) I don't have enough experience with AOP to comment. Spring has great transaction/security support and I haven't had to touch either Spring AOP (although it is presumably using that under the hood?) nor AspectJ directly. It sounds like you have a pretty good grip of significant parts of Spring.
what's wrong with java mcJava face?
Man they‚Äôre really getting original here...
You are welcome. Good to see you take feedbacks seriously. Keep up the good work! 
Jakarta is so much better, please let it be Jakarta
You could look into [Kotlin Data Classes](https://kotlinlang.org/docs/reference/data-classes.html) in the meantime. Kotlin and Java get along very well.
Ah Kotlin's a hard pass for me
Last EE 7 major release :(
Why is that so? I'm by far not proficient in Kotlin but have gotten used to it. Not being used to it was the only reason it felt strange to me.
Doesn't matter. 9 out of 10 people will still call it J2EE.
Java is getting "data" classes as well. See [here](http://cr.openjdk.java.net/~briangoetz/amber/datum.html).
Combining the 2 best suggestions here gives Jee McJeeface
What about Java Jee McJakartaface?
Perhaps for the better, otherwise the EE 8 release may never see the day light
I would just call it JE. Call Java SE just JS.
&gt; Models often don't match across data stores When your world view is that SQL is the abstraction this would be the case. When your view is more "Object Graph" orientated then that matches very well to "Document" it can look a bit different. &gt; ES generally has fully denormalized data where SQL is normalized Absolutely - sort of like materialized views in a way. We can store an Order with all its order lines along with some product details (like product name, sku) along with some customer details (like customer name, email, address) as a document. We can control the amount of denormalisation and with this we get the usual pros and cons of materialized views (roughly). &gt; You need to know that ES is an eventually consistent data store Quite right. I would say that we generally still need and want our fully transactional OLTP datastore - it does a lot that ES will not do for us. &gt; Mapping POJOs in ES or a cache is pretty trivial I think that is true IF they are mapped as a "flat" document. Once you want to map an "Object graph" to a "Document" that has a ToMany association and some denormalisation then I'd argue you need at least some of the functionality we have in Ebean in order to do this well. It starts to get non trivial to do this efficiently and automatically maintain/update the document. For example, we can maintain our "order documents" that denormalise "customer name and email" etc automatically with partial document updates and we can bulk update a lot of complex graphs efficiently. We need and use Ebean's partial object support and ability to build complex graphs efficiently in order to do this well and maintain documents with "depth". When things are "flat" - yes, pretty trivial and you don't need any of that Ebean goodness.
open ee like openjdk
There's maybe 10 people in the world that actually still give a f* about this old and obsolete collection of bad ideas. And Eclipse is involved too. That's like two geriatrics trying to hold a beauty contest in a dementia ward.
Wow, I mean I knew it was coming. But damn. That was fast.
There will be a new release every six months.
A world with lawyers. Where a jar of peanut butter must be labeled "May contain peanuts". Relax.
&gt;eclipse Stop that.
That's my nickname in real life and I approve.
Ever notice how the more uncommon common sense becomes, the more warning labels we see?
We're making it too easy on the genetic algorithm.
Not when we're coddling and encouraging ignorance and idiocy as a society.
Has HttpClient left the incubation stage?
I thought they were moving to a new versioning scheme. After it is release will the version be known as Java 10 or Java 18.3?
I wish they would just update their documentation so I don't have to find common answers in blog and forum posts.
They abandoned that proposal. This release will be Java 10, the next one will be Java 11.
Where's the option for "keep it the same because you're just going to confuse people with your marketing bs" ?
Wow, thanks for posting your thoughts. I love it when "noobies" post this kind of stuff, leads to some great discussions. &gt; Spring really shouldn't be used in command line apps. It's better for long running processes (server code). This is probably too blanket a statement. Spring is a very powerful tool for Dependency Injection. For simple apps, this is probably overkill, but there are complex CLI apps. I'd also point out that simple apps have a tendency to become complex over time. &gt; @Autowiring works best for Datasources, DAOs, and/or classes that depend on (Autowire) DAOs themselves. Hmm, not sure what you mean here. @Autowire fields? Autowiring as concept (aka injection by type) works great, especially for design patterns, e.g. Strategy. Even if you have a single impl of a type, DI still makes sense as you have centralized lifecycle management of your beans, and have the opportunity to apply interceptors, etc... &gt; @Qualifiers make sense if you're autowiring a something like a Datasource, ie. a class included with Java and not something that you write and make a @Component. Using a @Qualifier to autowire a mock class into a unit test also kind of makes sense to me. Outside of those 2 scenarios, it's use seems a little gamy and I think the odds of you needing it are kind of low. Qualifiers are a way of providing a "hint" to the DI engine, for scenarios when type alone isn't enough. It's not frequently used in my experience, but it sure comes in handy once in a while. &gt; Field based Autowiring is a terrible practice and should never be used outside of unit tests for the sake of code brevity. I'd say field based autowiring shouldn't generally be used. I prefer constructor-based injection (declare your collaborators final and use Lombok's [@RequiredArgsConstructor](https://projectlombok.org/features/constructor) for awesomesauce!). Unit tests should use same "injection entry points" as real code, imo. &gt; Profiles are great and should always be used, but PropertySource is a little more circumstantial. The app we're writing, we want the configurations to be editable by the user. So we're storing the configurations in a DB and making a GUI for them since they're not that technical. Profiles are great. Always may be a bit too simplistic, but I've not come across a real application where they weren't helpful. Some folk used to use maven build profiles (i.e. env-specific builds, blech!) and this solves that problem rather nicely. &gt; XML configuration is completely dead and should never be used. I'd say more to avoid in general, the DSL being built up around the java configs is nice, especially with builders, insights, javadocs, etc... That being said there are some cases where the custom xml schemas around some of the extensions are still superior. &gt; Spring AOP is terrible. Go with annotation based AspectJ. Yes you need a maven plug in but who cares, it's easy. Also consider using the ".aj" language if you really know what you're doing. I think this documentation is pretty solid at explaining the differences: https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-spring-or-aspectj As to using Aspect files, I've not used it in some time (~4 years) but it would bog down IDE (Eclipse) last I checked. I also find that it becomes an alternate style to composing i.e. instead of modeling separate classes to contain concerns, they get put into separate aspects. This isn't necessarily bad, but again, with my experience of heavy slowness in the IDE, I avoid. Additionally, Aspects, like any other tool can be over used. You can put your core business logic into aspects, but should you? &gt; I keep reading online that getBean should never be used. And I think I agree. It just seems wrong. I think the scenario that fools people is when they have a classic GoF factory class that instantiates a type that depends on a DAO. Since you can't autowire the type returned by your factory, they think you can't autowire your DAO and so you need to use getBean (in order to get the juicy benefits of profiles and propertysources). However you CAN just autowire the DAOs into your factory, and then hand them off to the objects your instantiating inside your factory. Don't know what factory you need? Autowire your factories into an Abstract factory and then autowire that abstract factory into whatever class needs it. Sorry if this one is confusing. getBean and it's ilk (programmatically interacting with the app context) is often used when transitioning legacy code to spring. Using it in a net-new Spring app is probably an indication of a design flaw somewhere.
let's vote to make it Granny Android
Boaty McBoatface's.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The new http client is planned to leave incubation in JDK 11.
Fucking Christ. Where did you hear this? I can't wait for the bloody incubation warning to go away.
Giggles throughout all the corporate world, that's what we need
GGmcGGface
My company keeps working on Java 7... You are lucky.
&gt; mcJava Anyone can enlighten me what's funny about this name?
I've been hurt before.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This looks really excellent! Nice work!
I would've gone with Sumatra ...
Looks like it's still happening: https://openjdk.java.net/jeps/322
I like that better even
https://ratpack.io/
This is great. I always thought PrimeFaces' themes were absolutely exorbitant in price for what you got. Thanks for the share :) 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Very nice. Try http://www.pac4j.org/ if you want a good security lin for java.
3rd option: Not Spring.
Is nobody working on a fork which just changes the name to "Java McJava Face" and makes no other changes, though?
I think [Ilha da Queimada Grande](https://en.wikipedia.org/wiki/Ilha_da_Queimada_Grande) is still available for something...
**Ilha da Queimada Grande** Ilha da Queimada Grande, also known as Snake Island, one of many Snake Islands around the world, is an island off the coast of Brazil in the Atlantic Ocean. It is administered as part of the municipality of Peru√≠be in the State of S√£o Paulo. The island is small in size and has many different types of terrain, ranging from bare rock to rainforest. The island has a temperate climate. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Borneo? Celebes?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The YY.M versioning is not happening, this JEP is mostly about redefining the semver $MAJOR.$MINOR.$PATCH interpretation of a number such as 11.2.3
I've been trying to use it for my pet projects, but am struggling pretty hard with build tool support. With all the issues I've run into with gradle and Eclipse, I've (unfortunately) backed off for now. It seems like every time I start getting somewhere, I get caught in another build tool bug.
+1 for Vert.x. Red Hat provide support for it as well now, which should start to give developers and enterprise the confidence to use it. It‚Äôs never been a better time to start building asynchronous, event driven applications. 
java is a different word for coffee though, I don't know how the law handles it but it's the same as calling something: apple mcApple face
All "click here to learn more" links are pointing to udemy courses, so it might be a recycled advertisement..
The new layouts and themes are generally $59/590 or $89/890 for non-commercial/commercial usage...That doesn't seem that bad.
Love the changelog format...would be nice if it had dates.
Jerky McJerk Face Larry McJerk Face 
I had to do multi-tenant and Hibernate back in 2009. Still using | maintaining it today. There is a "global" database and a per-customer database. The global database has account login information, associated with customer information. Each customer record has hibernate connection properties as a CLOB field. In memory within the application is a hash table keyed by customer, of the Session Factory for each customer's database. It starts out empty. When the application is shut down, a loop iterates through these, removes each one and closes it. (The destroy() method of a master servlet.) A function is used to get the Session Factory. It identifies the currently logged in user. It looks in the hash for the customer ID to obtain the Session Factory for that customer. If none, then one is created and stored. (This must be the first time this customer DB has been accessed.) Once that function returns the Session Factory, you're good to create a session / transaction for the currently logged in user account. 
Ok maybe with a little context. Lots of people i know are using EE and PrimeFaces for productivity in small teams or solo projects for startup reasons and in such a case forking out that much hurts! Particularly if not spending dollars or a strong currency.
JEP 321, HTTP Client (Standard): http://openjdk.java.net/jeps/321 Mail from project lead: http://mail.openjdk.java.net/pipermail/net-dev/2018-February/011155.html
Just a question, does it support simultaneous multiple sessions for the same user? (Concurrent logins) or can you control this to enforce single session?
Agreed. You're paying for the convenience which helps if your main experience is not in front end (or particularly styling) 
https://www.elastic.co/support/matrix#matrix_jvm has the latest and greatest that is also linked to from this page of the docs https://www.elastic.co/guide/en/elasticsearch/reference/6.2/setup.html
I see this "field injection is bad because it tends towards growth..." argument all the time. I call bull. If a dev is going to slap a dependency in a class, they're going to slap it in a class whether it's at the field level or at the constructor level and nothing is going to stop them (except maybe a code review by a good dev). This is a _design_/_clean code_ problem, not a dependency injection problem. If testing a class using field injection is that complicated...again, that's a design problem 99% of the time. That class has probably assumed too much responsibility (as the main argument against field injection tends to claim), so break it down, simplify your class and your unit test. 
The docs still tell java users to use the transport client! Want to find anything out about the LL and HL rest clients? Gotta go look at blog posts. How about integration testing? Docs tell you to run some ridiculous clustering framework. Forum posts will tell you to run a docker image and test against that. It's pretty bad for a commercial offering.
Yeah but we're not talking about anal intrusion here. 
&gt; As an added bonus, since final fields can be initialised in the constructor, our dependencies can be immutable - as they should be! Amen to that. I find stateless/immutable services to be a lot easier to deal with. Why worry about object lifetimes when you can just make every service a singleton? 
not sure how that is irrelevant to your original point?
That their documentation sucks, that is my point. Your links only serve to remind me that even in 6.2 they suck as much as the previous version. It makes me even more suspect of the quality of their commercial offerings.
Java 10 RC1 is ready. Any news about asynchronous JDBC?
&gt; Java McJava Face Now that's all I want it to be. 
1. Initializing your fields in the constructor is not "extra ceremony". It is a best practice and allows you to best make use of the tools available to you such as the compiler and your USE. Think about the case where you have not initialized a field in your class. Using constructor injection the compiler will tell you immediately that the parameter is missing from the constructor. Using autowired you will have to start your app and find the "no bean def found" error. Feedback loops are important and your compiler provides the fastest feedback loop. 2. Again, whether or not you have ever seen an autowired field be reassigned, the point is that declaring your fields as `private` and `final` and initializing them in the constructor prevents them from being reassigned as it won't compile if someone tries to reassign it. 3. I would say that if you have to expose your private fields and methods in order to write tests then that indicates poor design. As well as this your tests will also be tightly coupled to the specific implementation of your class. If you change the private method such that the overall behaviour of your class is the same but you have a test testing that old behaviour of the private method you now have a failing test to update. In your case it gets worse as you are tied to the specific names of your private fields (the ide will help you with renaming these probably but it's still not good). So I wouldn't say your private methods have to be tested. I would say you should test the behaviour of the "unit" being tested (whether that's a class, method or group of classes) which should implicitly test the behaviour of your private methods. This avoids coupling your tests to implementation details making them easier to work with. Finally I would warn against always aiming for 100% code coverage as an end goal. Code coverage should be used as a tool when writing tests to indicate what you may have missed. But in the end you can have 100% code coverage and not have any meaningful tests. 
Agree with stateless and immutable. Disagree with Singleton. In my experience, scoping an object to the application when it is only needed in a portion of the application is a recipe to end up with 100s of small objects that can only be wired together with a DI framework. This mandates the use of a DI framework for more and more of the application, which leads to developers not worrying about object lifecycle and architecture. This leads to code rot. I approach lifecycle like scope. I minimize it until I have a reason to expand. For example, objects should only be scoped to the application IF they need to live beyond a request. Anything else smells like a premature optimization.
&gt; Think about the case where you have not initialized a field in your class. Spring's autowiring will fail regardless if you autowire in the constructor or in the field. If you are missing a required dependency it will throw an exception. The fact that it is not a compile time is in no way relevant because as soon as you start the application it should fail. (And I'm assuming that you are at least bootstrapping the application in at least one test). &gt;Again, whether or not you have ever seen an autowired field be reassigned, the point is that declaring your fields as private and final and initializing them in the constructor prevents them from being reassigned as it won't compile if someone tries to reassign it. But again, nobody in the history of computing has ever done this, you are "protecting" against a case that will never happen and the extra lines of code and indeed ceremony are not worth it, that case will simply never happen. &gt; I would say that if you have to expose your private fields and methods in order to write tests then that indicates poor design. As well as this your tests will also be tightly coupled to the specific implementation of your class. I would say that if you don't read the text that you are replying to and simply jump to write a reply that indicates poor self restraint. I have stated that spock has native access to everything private, your code does not change one bit, everything in your source code is still private. And yes, you should have tests for classes that have business logic inside them, yes even testing implementation details to make sure that it does what you want it to do. If you change the behavior of a class you still have to test that the new behavior is correct. It does not matter if that behavior is meant to be public or not, when you wrote that method you had a specific behavior in mind and you need to validate that it's doing what you thought it was doing. It may be because the dependencies are way too complex, or because that case is very difficult to create (imagine that you've compiled with the provided library but you want to test the case where that library is not in the classpath but all your other tests require it to be in the classpath, you're not going to create another test classpath for just this case, you will simply test the private method, at least i would) If you find it a good argument to say "having 100% code coverage does not indicate that you're doing things right" i can simply turn that around and say "having fields final does not indicate that you're doing things right". Going one step further "just because your code compiles, doesn't mean that it compiles anything meaningful". Just like with the nonexistent case "but what if someone reassigns an autowired field?" which i want to emphasize again, never happens, I have never seen a project that was in trouble for having too much code coverage but i have seen a lot having trouble for having too little.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I agree with you completely but I feel like you've ignored the most compelling argument: "Classes using field injection are non-final, but are prone to circular dependencies" I've got into situations with field injection where beans could be injected in the right order on one machine, but I got circular dependency injection problems on another machine. I don't know how this is possible and I don't want to know how. I do know constructor injection prevents me from creating such a situation. I've also got into situations where nulls are being injected. Spring will happily inject a null for example. There is no way to prevent this with field injection (that I know of?) but I can prevent it with constructor and setter injection.
&gt; Is Java really not verbose enough? Do you really need the extra ceremony of this.dependency = dependency in each class? If it's a big problem, you can eliminate verbosity with Lombok: http://www.baeldung.com/spring-injection-lombok
I would argue that the fact that tests are ignored for so long is not because it was field injection and not constructor injection. If it were constructor injection, they would have simply passed null as the parameter if the compiler forced them and you would be in the exact same place as you are today. Then people would have behaved the same way that they did now "aaah, let's just ignore it".
There are tons of tutorials for JAX-RS 2.0 (and Jersey 2.x). JAX-RS 2.1 did not change much, so there is no real need to update these tutorials. Also, the Jersey documentation is excellent, always up-to-date and a great resource for learning. Same goes for Jetty. Lots of tutorials and examples, great official documentation and any tutorial written for 9.x should still work.
If it is stateless and immutable, then also making it a singleton just reduces the amount of GC pressure you introduce. It can still just just as skinny or fat as it would have been otherwise.
How are failing tests not a clear warning that you've messed up?
The application I work on uses hibernate multi-tenancy. All usernames are fully qualified so the tenant id is the domain of the authenticated user.
Do constructor injected classes get autowired? I think I've grown too accustomed to field injection, how do I stop this? How are you injecting dependencies with the constructor? Are you instantiating new instances yourself? Does Spring not take care of that then?
I thought they were a thing of the past like Troy and the Victorian age :O
Pooling? Why add that overhead for objects that are ostensibly thread-safe? Making it a singleton is often as easy as changing one flag when you register it with whatever DI framework you're using.
I'd be surprised if my TL has ever run a test, let alone written one. I'm lucky that he bothers to compile them.
Hackerrank, codewars, etc
What is the recent /r/java attack on field-level injection techniques. I mean, whatever - you're entitled to your opinion, but all this FUD is wildly inaccurate. The thing is, I totally get it. Field injection requires your tests to use Mocktio (or equivalent), but the way it's laid out, you'd think I was using the ChildSlaveLabor-1.0.jar to unit test my code or something. Lay off it guys. Lets break it down: #1: Classes using field injection tend to become harder to maintain Only if you do it wrong. Nothing prevents you from putting 80 setters or 80 method args to your constructor. I understand your argument: doing that is painful so you won't do that. But it's flawed in that you can do that just fine. Is it bad design - sure, but you're saying "because you can have bad design, then it's a bad thing to do" and that's wrong. You can have bad design with Constructor/Method injection. It's just style guys, get over it. #2: Every time you use field injection a unit test dies This is just so blatantly wrong it's stupid. Every single point is a mishmosh of FUD. "What if I want to inject a real object" - well, I'd suggest an Integration test where you're using spring-test and a @ContextConfiguration. If you're wanting to construct your own "mock" - fine, create a setter: (`@VisibleForTesting protected void setMyThing(MyThing thing){ ... }`. This isn't rocket science guys. #3: Classes using field injection are non-final, but are prone to circular dependencies This is probably the closest point I can get behind, but you're wrong where it counts in your argument. It's not common but it does happen. One thing to remember about spring is that it generally injects proxies to your components as you load them so you can have references (even circular) just fine. In your `final` field constructor injected, you'll have a proxy finally put in there and you're not guaranteed the "real thing" until spring is done loading. You can still have circular dependencies. Okay, so where you're right is that if you're not using Spring, this will save your life. Any time I'm doing DI and not using Spring directly (even if Spring is doing it work somewhere), I 100% always use Constructor injection for this very reason. Your argument is simplistic and annoying to read. Also, as an FYI, spring is never immune to circular dependencies. Setter, Constructor or Field injection. Your statement: &gt; Classes using setter injection are immune to circular dependencies is wrong. It makes it less likely to get them (just like field injection). TODO: I wanted to double check that you can indeed get a circular dependency with constructor injection but I have a meeting to go to. I'll test it after lunch and report back. I'm 85% sure you can with spring proxies.
There are several, though the ones that are open probably have their answers somewhere. Honestly It's probably best to have your java devs come up with their own multiple choice questions and put it behind a password or something 
Fair call on pooling being heavy handed for thread-safe objects. Comment applies for other object types in general pattern of making all objects a singleton. With regards to the the DI Framework: it appears you are saying that all of your objects should be managed by that framework. I find once you walk down that road it becomes difficult to walk back and that in practice this leads to sprawling applications that have unclear wiring. I've been bitten too many times by people using DI frameworks as a catch all for handling all object lifecycle &amp; wiring, to the point that they forget about these concepts in code. For example, maybe there is a reason why it's difficult to plumb Object A through 8 layers of your application into Object B and that it shouldn't be as easy as adding a constructor argument. Essentially if people say wiring is too complicated to be done by hand for the application, their wiring will actually become too complicated to do by hand.
Yes they do get autowired. However, if you have a single constructor, spring allows you to omit the autowired annotation. If you have more than one constructor, then you must annotate one of them so Spring knows which one to use.
Oh don't get me wrong, I'm no fan of DI frameworks. 
While you are right about field injection encouraging growth being a design problem, I think it is also problem of specific type of injection pattern itself. Problem is that with field injection, the addition of yet another dependency _feels_ much ‚Äúcheaper‚Äù that it is almost easier just to add that damned dependency on your service than start thinking about those pesky concerns of responsibility and cleanliness. The reason why field injection is an _antipattern_ is precisely because of the encouragement it offers. And if all the legacy Spring codebases I‚Äôve seen over time is any indication, code using field injection tends to be indicative of unbridled proliferation of dependencies throughout the codebase. But there are also other, more substantial reasons than ‚Äúit encourages bad design‚Äù. For one, using field injection completely sidesteps encapsulation. Some external entity constructs your class and then simply reaches into the innards of the object and rearranged its state. This is evil. Besides being ‚Äúunclean‚Äù this also breaks the contract of a constructor ‚Äî a constructor should be responsible for making sure that any instances you get after its done, are in valid state, ready to be used, but when injecting dependencies using field injection, this means that the objects at not usable until all dependencies have been set by the DI framework. Now you have a broken object that can only be useful when instantiated by your DI framework. You‚Äôve just made your application dependent on the DI framework. 
&gt; However, if you have a single constructor, spring allows you to omit the autowired annotation. Just note that this behavior was implemented in Spring 4.3. So if you are using 4.2 or before, you still have to add @Autowire to your constructors. Though getting on more recent versions of Spring is always a good idea üôÇ
The main problem with field injection is that you are no longer able to unit test the class. And that is not bull.
Who's the vendor? That might help us figure it out. That said, if you feel comfortable with designing the questions, any online quiz tool (google forms, survey monkey, quizzbean etc) should be sufficient. Google Forms is my favorite: https://support.google.com/docs/answer/7032287?hl=en 
Pluralsight launch their Skill IQ measurements a while ago, which you can take for free (after registration). They have one geared at Java as well: https://www.pluralsight.com/content/pluralsight/en/paths/java.html It's an adaptive measurement, using questions from serious Java experts. (full disclaimer: I'm a [Pluralsight author](https://www.pluralsight.com/authors/sander-mak) myself)
Since you're using spring, you might enjoy turning your TenantContext class into a request-scoped bean so you don't have to directly muck around with ThreadLocal directly.
I'm not using Spring.
I use Enthuware. $10, updated regularly, and currently goes up to Java 8, but I am sure it will have Java 9 as soon as certifications are out for it.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
How about...none?
Hey guys! Take your time for reading how this really useful API works internally for redirecting an email address to the user's profile picture totally written in Kotlin using libraries like: - Ktor - Spek - Retrofit And can be used as an API or as a Java/Kotlin library.
Gotcha, that was my one concern, so looks like I know what I'll be doing from here on out.
Depending on the random questions, the Pluralsight Java Skill IQ test score can be highly variable. I am admittedly horrible at Server/Socket stuff and am not an expert when it comes to understanding Java performance/GC stuff. In one run-through of the test, I was asked about all of that and got a very low score. The second run-through, I was not asked those questions and was scored as a Java expert. I would not use these as a basis for job candidacy, unless you want to hire a Java expert like me, of course ;)
What are you smoking? I have a project sitting in front of me that uses field injection with 80% unit test coverage. You are making things up again Arnold...
So how do you replace dependencies? If you need to create a Spring Context for doing that, you are not doing unit testing.
In my unit tests, I mock them and inject them. I don't replace them. The core tennatn of DI is that your class doesn't care where the dependencies come from. They're "just there" and "do things". You know, composition, low coupling/high cohesion and all that. CS101.
I've been using Hackerrank. I don't love it, but its doing the job. 
No, it's not :( https://twitter.com/kmensah/status/963855618611208192 https://bugs.openjdk.java.net/browse/JDK-8188051 Apparently, it will be available in Java 11.
6 weeks studying using only enthuware and I made it. It's very good bank of well selected questions.
are you implying no screening of candidates' programming skills? or not using a 3rd party screen and performing the screening / interviewing in-house?
This is missing what I consider the most important reason for using constructors... [Class Invariants](https://en.wikipedia.org/wiki/Class_invariant). 
**Class invariant** In computer programming, specifically object-oriented programming, a class invariant (or type invariant) is an invariant used to constrain objects of a class. Methods of the class should preserve the invariant. The class invariant constrains the state stored in the object. Class invariants are established during construction and constantly maintained between calls to public methods. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
You'd want to use the [DecimalFormat](https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html) class.
Er... I don‚Äôt 
DecimalFormat like he said, then set the format to 17 digits on either side of the decimal. Then x.substring(0,17)
&gt; having all of the dependencies listed in the constructor makes that code review easier. And putting them in a nice neat block right above the constructor isn't easy enough to review? There are real arguments to use constructor injection. This is not one of them. &gt; Also, it allows the dependencies to be validated when the object is constructed. `@PostConstruct` I get it, you want language-level stuff. But if you're building an enterprise app - you trust your application lifecycle. If it doesn't work, the app doesn't work. Sure, there's "no guarantee" or whatever, but isn't that what all those tests the OP claims can't be written are supposed to assert? 
Option 1, use a constructor that enforces my rules. Option 2, hope the tests have enough coverage. Yea, that's a no brainer.
This won't round correctly. Also you would need to pad with zeros.
As /u/zayzn mentioned, you want to use DecimalFormat. It will take care of the rounding and string conversion. However, you have to create a new pattern for each number. The trick here is realizing that your pattern is always 18 characters long. The only thing which changes is the location of the decimal place. The location of the decimal place is equal to the number of integer digits. So: # Make a char array of 18 zeros # Find out the number of integer digits (logarithm base 10 would probably work) # Change the value at that location in the array to '.' # Convert the array into a string # Use that string as a pattern for DecimalFormat You may need to special case if the number is less than one. I'm not sure what you should display in that case.
If you're bottlenecked by the memory layout, you can already get the same effect with the struct-of-arrays approach. In fact it will still likely beat Value Types since you don't need to pull the whole type into the cache, only the members you're actually working on. They might however, make your code look nicer‚Äîat least for some definition of "nicer".
&gt; What is the recent /r/java attack on field-level injection techniques. I mean, whatever - you're entitled to your opinion, but all this FUD is wildly inaccurate. The thing is, I totally get it. Field injection requires your tests to use Mocktio (or equivalent) No. The point is simply that they are **dependencies**; your code depends on it. It should be impossible to construct an object that depends on other objects without it being provided all it's dependencies. By enforcing this through the constructor and making the dependencies final you can save yourself from some nasty mistakes down the line. In most of the project I've been on it's been a hard rule for that reason. 
My company wants to move away from their current online assessment tool because it's too simple and limited. The thing is that we only use it just to check if the candidate can write code at all (like Jeff Atwood once said https://blog.codinghorror.com/why-cant-programmers-program/). Both codility and hackerrank are an overkill (and pricey) for us because we don't need complex DP problems or things like that. Right now I'm testing testdome.com in which you can add your multiple choice questions besides creating your custom Java (or any other language as well as testing SQL skills) live coding tests. 
On my browser, a Firefox, the source code is all red. Would enhance the readability if you would use some kind of syntax coloring. 
These coding exercises can be useful and be used very, very wrongly. The latter is prevailent, I think. "Here's a useless riddle you have to decipher to even begin, now code out a solution with a timer doing down from 45 minutes while spending the first 30 understanding what the fuck we're actually asking you to do!" --- how most companies do it, i've found. On the other hand, I've had companies open a shared code document, and giving ME the ball. Like, you say you know Java? How would you make a singleton class? If you had a to make a list of a User class, how'd you do it? Pretty much allowing me to expose my thoughts, do simple implementations yet show that I know Java well enough. You can't assess whether or not someone is a rockstar programmer in these riddle-sessions, or just a regular programmer. All you can do is to sort out the people who CANNOT code at all, not the assess on a sorted list of who can code *the best*. 
I use this, it's quite okay actually. 
I'm not going to argue against Dropwizard as it's pretty nice indeed, but you can use as little or much of Java EE/Jakarta EE as you want for your applications. 
what's the differences between GreenMail and say, Wiser?
That is actually the best argument for constructor injection. I've said it before in some of my other WTFAREYOUTALKINGABOUT posts: I'm not against constructor injection. I like it, in fact. But all this FUD around field injection takes away from the real points. A political metaphor: I like candidate A and dislike candidate B. Someone I know says that candidate B eats babies. I know this isn't true - do I (1) say "dude, that shit is bull" or (2) do I share the post of facebook? This FUD shit is the facebook spam equivalent. Now, so I agree with /u/nutrecht's point here about &gt; your code depends on it. It should be impossible to construct an object that depends on other objects ... so naturally it's about style. If I'm okay tightly coupling myself to Spring, does it really matter? I'm in the camp that it doesn't really matter. Not in the enterprise world. The syntax sugar I get from field injections outweighs the warm fuzzies I get knowing that I can instantiate my `UserSamlLoginServiceFactoryServiceBuilder` outside of my enterprise application. Make sense?
You can try www.ZetPDF.com library
Wanted to try the trial period, but I am not entering my payment information for that. I can see why you want to collect the payment information before hand, but from my point of view that's BS.
This question makes no sense.
No - object is an instance of a Class. Class is a template for building objects. Spring has nothing to do with it.
The finalness doesn't prevent the assignment of null, I agree. However, injecting via setter/constructor allows you to check and throw if the injected value is null before the field is set. The finalness (if using a constructor) then guarantees that it doesn't become null later, somehow. I agree injecting nulls is doing it wrong. Constructor checks prevent me from doing it wrong unintentionally. Often I'm not in full control of the code base, and the code base is larger than any one person can keep in their head, so this also keeps other people from doing it wrong unintentionally, as well.
Anwer real quick, NO!
I have never met someone who thinks it is odd that arrays are objects in Java.
TL;DR 1. Java arrays are Objects. 1. Java does not have literal values for bytes or shorts. 1. Private fields and members are accessible within the class that contains them. Did I miss anything? Somewhat short of the revelation the title promised.
One point that I didn't see mentioned was with setter injection + constructor injection within the same Class you generally want to use setters for optional dependencies. Not a common occurance though. Good post. Jurgen Holler stated at Goto 2016 that he would remove field level injection if at all possible. It's just nasty and serves no purpose over constructor/setter. 
They didn't even mention that arrays are covariant, which is a far more interesting feature that led to covariant arrays in .NET.
Maybe an old time C programmer? I believe their arrays aren't heap-allocated unless they explicitly ask them to be.
Yes, but Java being an Object-Oriented language, so it shouldn't really surprise anyone. An array of size `n` in Java is synonymous with `malloc(sizeof(type) * n)` in C.
&gt; Consider that an overriding equals() method might be executed many times during an object's lifetime (perhaps during a sort or search operation). That method should run faster if it doesn't have to invoke an accessor method to obtain a private field's value. Isn't that why there is inlining and JIT-Optimization?
yeah, totally agree - coding interview questions can be (and mostly are) abused. determining whether you know by memory some intricate detail of a programming language is not helpful in determining if you'd be a good engineer to add to your team. neither is putting you on a timer and asking you to solve a complex solution under pressure and scrutiny on the spot. the only method i've used that i really liked at an old job was having a small homework problem (small meaning it should take you no longer than 20 minutes, but you're not timed so you can take longer if you need) that was sent out before we set up a technical interview. you implemented a method in an interface we provided. we'd plug it into a pre-written test class we had (bonus points to the candidate if they wrote their own unit tests) to litmus test it. it was an easily google-able problem that we could tell if they copy/pasted from the internet.
 &gt; Isn't that why there is inlining and JIT-Optimization? When removing a function call improves performance *considerably*, you're writing very interesting software. &gt; Also, it's convenient to not have to create accessor methods, which adds to the size of a class file, and enter their names just to access field values. Okay then...
I‚Äôm confused by ‚Äúlisting 5‚Äù that states private methods and variables are accessible without reflection. The example it gives shows a static main within the same class that declared private. That‚Äôs the definition of private, that only the declaring class can access. I believe the main beef is that one object _can access_ another object, even though they are the same type. That makes perfect sense to me. How else would equals and hashcode work?
Technically no, as the other responses have said. However, you may be confused because Spring usually only has one object that corresponds to a given class. For example, if you have a class BookService, Spring will make one BookService object and use that same object everywhere a BookService is called for. So in normal Java, you have one String class, and many String objects. In Spring you have one BookService class, and one BookService object.
**/r/javahelp** is for such questions - as is clearly stated in the many hints on this page.
The most important thing to say here: java.lang.object inherits from Chuck Norris.
The problem with all those Docker plugins is that they are based on a stable Docker API. At least in the past Docker has several times broken backwards compatibility making all Groovy/Maven plugins useless The most sane and future proof way it to just delegate to the actual docker executable (at least until Docker stabilizes the API) If you use any CI system (like Travis shown on the post) it is much easier to run direct docker commands (for building and pushing image) rather than handling Docker from the build systems itself (int this case Gradle)
Surely you must‚Äôve misread. We‚Äôre talking about Oracle here.
True. But in practice it is mostly confined to the browser. Even with Node it is limited because it lacks multithreading, static types. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Are they really worse than Google? I think both are evil as a $100+ billion company will be, but at least Oracle has an interest in seeing Java succeed.
This is a question about **Java programming** and as such it should be, as the *plenty hints* on the page indicate. posted in **/r/javahelp**. **Post removed**: Programming help
To test you.
Limited for what? Node offers a different model, that‚Äôs all. I‚Äôd say we‚Äôve seen very ambitious and widely used applications written in node, so I‚Äôm not entirely certain what you are referring to. Static vs dynamic typing is a horse that‚Äôs bean beaten too much.
Spring prevents you from initializing classes if it fails to inject a dependency. It does the same thing in practice as using a constructor.
Not every app is is a web app. For example, we use Java for embedded systems. For that kind of software, I want static types, and compiled code. I also don't want C++ because the same software runs also on desktop based systems. 
I know what you mean, but it's not relevant to my point. Spring doesn't (and can't) prevent you from creating an instance of a class in the same way a constructor does. Unusable unusable = new Unusable(); ... //Some time later... unusable.use() //NullPointerException maybe... There is nothing spring can do to stop this. A constructor, on the other hand, makes this impossible. Usable usable = new Usable(); //Fails to compile Good design makes it harder to do the wrong thing. In this case you can make it impossible to do the wrong thing. How is writing a class that is wholly dependent on the container to maintain class invariants when a straightforward approach to avoid it exists good design?
Not every app is an embedded app. Use the right tool for the job. Java has its limitations as much as any other language
I answered your question. If you believe JS is right for what you do, then congratulations.
I think the end result here is less that worthless. The original code being "fixed" is perfectly readable and if the goal is to share a common abstraction, then you have to formalize it and at that point you need to just wrap the field value into a new class. "ValidatedFirstName" is extremely useful in larger systems because you can change what the FirstName -&gt; ValidatedFirstName checks actually are and components nor involved with validation declare at a high level that their inputs have been validated by other pieces. That's valuable. This, is a waste of our valuable internet bytes. To summarize: - the lambda syntax is perfectly readable, you just have to bother to learn to read it. - if the lambda represents a meaningful abstraction boundary, then sharing that abstraction is valuable (and probably won't be a single lambda expression), and therefore should exist at a type level so that other components don't couple to your static function lambda implementations - don't waste your time trying to solve design problems at the language syntax level
Constructor injection represents what I hate about Java. It is something overly verbose and complicated to prevent you doing some theoretical error that doesn't really occur in practice. But it does have its place. If I am writing a library for others to use, I would definitely use constructor injection. In that case, I am not expecting the public interfaces to change much and want to make everything as explicit as possible. But working at a start up where all the code will be used internally, I find that field injection is more readable and flexible, allowing me to make quick changes while keeping a relatively clean code base. Spring injection is scary powerful and I am going to use it to my advantage. Occasionally a unit test breaks that would have been caught by the compiler, but that is a only drawback in my experience but it is simple to fix once discovered.
[removed]
Can you please elaborate what are the optimizations and performance improvements, besides the function call overhead?
&gt;If I am writing a library for others to use, I would definitely use constructor injection. In that case, I am not expecting the public interfaces to change much and want to make everything as explicit as possible. Unless it's some throw away code (even then, this shit has a tendency to live on), others will use it and maintain it. You yourself will feel like an "other" depending on how much time has gont by since you wrote it. &gt;I find that field injection is more readable I just don't see how that can be the case... You have to look at source vs constructor declaration. The declaration is available as a hint in most IDEs and javadoc. I've written a lot of crappy code myself and sure, a lot of the time it doesn't matter. I'll come back to it later and it will take me a little longer to figure out whats going on. Some shit will fail a couple times before I get it right. Eventually I make it work. This is probably how most people deal with shitty code. It's not the end of the world. But the joy I've experienced when coming back to code I got right is worth the effort. Put them shits in the constructor, you'll thank yourself later :)
Thanks for the comment. Will check the CSS property.
&gt; Put them shits in the constructor, you'll thank yourself later :) My experience is wondering why someone decided to put 15 arguments into a constructor. To each their own. If the worst thing about the code you are looking at is the injection method, then that is some good code.
That‚Äôs very interesting! Thanks for sharing!
F L.E L = Larry E = Ellison F = You know... Does that clear it up? ;-)
I am using jasper reports for reporting have a look please: https://plus.google.com/collection/QfVIWE Thanks
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
We used to use betterprogrammer.com as a filter but unfortunately the set of assignments is very small and the answers are too easy to just google. So currently we're looking at Hackerrank. Unfortunately it's a pain in the ass. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Struts LOL
&gt; you generally want to use setters for optional dependencies I wish Java had reified generics so you could just do `Optional &lt;Dependency&gt;`. Without DI a good solution is the Builder pattern, but with DI I haven't found one yet. Injection setters are not a good solution because I want my objects to be fully instantiated (into an immutable state) when the constructor returns. Setters also complicate lifecycle management and introduce new failure modes (e.g., the injection setters might get called after the object is already "in use").
I'd probably use undertow
&gt; It is something overly verbose and complicated I find quite the opposite. It's clean, simple and idiomatic. You have a constructor that gets your dependencies, you can validate them, you can throw to stop an incorrectly initialized object from being created if a dependency is invalid, you can have all your fields final, etc. Everything is explicit, simple and well-defined. Field injection is messy and complicated. I have no control over the process and I'm at the mercy of the (changing) internal semantics of the DI framework. I also cannot do basic things like validation, immutability and stopping invalid objects from being constructed.
I will take a look :)
You think that creation of the String literal is not avoided by the lambda variant of the call ??? Why that ?
Maybe see if Grizzly has something more to offer than Jetty or if Jetty can provide something that Grizzly can't. If there's no difference in feature, then go towards the easiest one to use :p In terms of performance, I'm pretty sure they can both hold their own.
Grizzly is pretty impressive wrt performance.
All of them? The JVM will inline a bunch of calls up to a set limit, then run optimizations on the resulting flattened code. Escape analysis, for example: If you pass a locally instantiated object to a method, you don't know if it escapes from the method, but if you inline the method you do know.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Returning `null` is useful in certain contexts, but with value types coming, we should be more wary of doing so.
Spring supports the use of Optional in constructor injection. Also, the reflection API has a way to get the generic class type to be able to do this, see https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/ParameterizedType.html I couldn‚Äôt find the docs quickly on the use of Optional but I remember doing this in the past (although was pretty rare I needed to do this)
The single constructor behavior is nice. Usually what I do these days is I pair this with Lombok and mark all dependent objects as private final fields then place a @RequiredArgsConstructor on the class. Keeps things clean and still sane when instantiating outside of the DI framework eg in tests with mocks. Before the single constructor behavior you also had to tell Lombok to annotate the generated constructor with @Autowired which sort of lowered the value of using Lombok in that situation.
 &gt; Regarding API breakage between major versions, which one does less breakage? I have no experience with JEE, but I have upgraded a lot of old Spring (3/4) to Spring Boot, and Spring Core is mostly ok, surrounding projects (aka Spring Cloud) may vary, 3rd party "addons" (like Spring Boot Admin) will probably fail. &gt; I've seen a rise for the use of JSF but is it overtaking Spring Web MVC in the job market? Not really, but depends on if you want REST style clients or not. &gt; There are a lot of job postings in my local area asking for the knowledge of JSP. I am going &gt; to assume It's just for legacy applications (since JSF is supposed to overtake it). Is it still &gt; worth it to learn JSP? Not really, but you should have an understanding of what it is for legacy projects &gt; When using Spring Web MVC, is Thymeleaf the expected HTML renderer nowadays? You should prefer REST over HTML, but Thymeleaf is fine, I prefer Freemarker myself. &gt; When the JPA was released, Hibernate made changes to its API to comply with the spec. &gt; Nowadays, do you write fully JPA compliant code to use with Hibernate or is it okay to use &gt; hibernate specific methods? For Spring, use Spring Data. &gt; Is there any advantage in deploying a Spring Application on a JEE server (Be it, Wildfly for &gt; example) over just using a servlet container(Jetty, Tomcat)? No, quite the opposite as (depending on your build pipeline) embedded is way easier to deploy to. 
Personally, I always just recommend trying to write code as if it were just standard Java code. Eg. I hate butchering class definitions just for the sake of some behavior of a DI framework (the fields would only be settable via reflection for instance). This may not seem like a big deal but I‚Äôve had to work with other developers where these conventions of these frameworks have bled into their other code such as having required arguments come in through setters instead of the constructor (java bean style is an anti pattern imo). I‚Äôve also seen things like unit tests that were written in groovy to workaround that field injection was being used and groovy allowed them to set private variables with mocks. Obviously, there was some lack of experience there but doing this seemed like a way to send developers down the wrong path. Anyway, it just comes back to trying to write code that is sane regardless of whether framework X or Y is being used. In regards to the boilerplate I would suggest Lombok although I know some have strong feelings against it. I like it because from the perspective of someone consuming a class that had constructors/getters etc. generated by Lombok it still just looks like standard java eg the ‚Äúmagic‚Äù doesn‚Äôt bleed out to your consumers. With this my classes look like they‚Äôre using field injection pretty much. I list out the fields as private final then plop a @RequiredArgsConstructor on the class then Spring picks this up as the only constructor and uses constructor injection. 
Great news! I very much prefer NetBeans over Eclipse and I'm happy to see NetBeans being actively developed. Anyone knows what are the plans for supporting JEE?
I wonder if NetBeans 10.0 will be out around the time Java 11 comes out. /s
Devs are too lazy to compile single source files now?
The hash bang syntax makes it possible to use a Java source file as a "script". One with horrible "start up" time, including compilation. #!/usr/bin/java package com.evil.pkg; import com.evil.tools.*; public class EatKittens { . . . . } Since you *can* put more than one class in a java source file (although it is not usually done), you could write various source code utilities, with multiple classes, in a single source file. Distribute it like a Python script. You could also put multiple static classes within the top level class.
While null can be useful, in certain contexts, when it comes to returning a collection, it is better to return an empty collection. I sure wish the Immutable collection types from Google Guava were in the standard. In cases where you return a collection, say a List&lt;Foo&gt; it could be declared to return an ImmutableList&lt;Foo&gt; instead. Instead of returning null, you could return the singleton empty ImmutableList as easily as returning null -- and without allocating any new objects.
If you neef an article to do it it was probably easier to just xompile
The cross product example is an example of zipping, which unfortunately doesn't exist in the Streams API. It does exist in Guava, though: Streams.zip( EnumSet.allOf(Suit.class).stream(), EnumSet.allOf(Rank.class).stream(), (s, r) -&gt; "Suit: " + s + ", rank: " rank) .forEach(System::out); Although, for something as simple as this, I agree simple iteration is simpler.
Nah, I would say it is used for whatever your business demands are. But there is a general turn in the market for JavaScript frontends on top (or in front of) of a more traditional application (wich could be node.js based instead of Spring, of course), at least where I live.
Yay!
I've used Jetty with pretty serious usage with a SSH (Spring, Hibernate, Struts) stack, and have had 0 problems. Vaadin has a version which includes Jetty, and that's my #1 webdev platform atm by a mile.
Is this in jest? This can't be a serious article. 
People have said the same thing about Apache. Both Apache and Eclipse foundations have robust ecosystems of active projects, along with a goodly number of dead or dying projects. It's the nature of the beast.
SSD or magnetic disk? I find that makes a big difference. I barely notice IntelliJ indexing but on an HDD it's pretty painful IMO.
They are really small projects. My laptop is 6th Gen I-5, 16GB Ram and SSD.
for me, IDEA boots a lot slower than netbeans. I like both IDEs though. As someone who "earned their stars" on Eclipse, I was very resistant to change, but I'm now glad my current company forced me off of Eclipse.
Yay!
Yeah definitely. I started with Eclipse but after giving IntelliJ a go I never went back. Eclipse vs IntelliJ feels like 2002 vs 2018. It just feels like a more thought out application, built with the actual user's efficiency and comfort in mind. The argument of one IDE over another is completely irrelevant, you can write perfectly functional code in nano if you wanted to. The tool you use to accomplish the job needs to improve over time. That's why we went from screwdrivers to power drills. I just hope the next logical step in IDEs is as much of a step as we've seen so far.
You should probably bother to add something to the conversation before just commenting "Yay" in multiple threads. You earned this down vote.
Thank you for this constructive comment. It has added much value.
You're welcome. I'm glad we agree that you failed to provide any value, and that by pointing out your failure we have improved the state of the community because at least one person (you) will stop generating worthless comments.
RX is mandatory for any non-trivial Android app
Tomcat has supported websockets since v7.0: https://tomcat.apache.org/tomcat-7.0-doc/web-socket-howto.html 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
- A Scalable Low Latency Garbage Collector - GC pause times do not increase with heap or live-set size - Claims almost non-existent pause times compared to the parallel or g1 garbage collectors (shows graph in doc) 
&gt; Spring will happily inject a null for example Happened to me too, probably a bug, because normally it just throws an exception.
Java development on Linux does not differ from developing on Windows since you should be using platform independent dependency manager like Maven or Gradle anyway. For other things there is an IDE.
&gt; It should be impossible to construct an object that depends on other objects without it being provided all it's dependencies. Rubbish. It should be impossible to construct an instance of a bean outside of DI framework, but since it is not feasible, who cares. Instantiation with dependencies is not enough, if the class need AOP or other features and expects Spring to provide it. 
Writing code inside an IDE is not the only thing Java devs do. Everday I spend quite some time in terminal for various reasons. 
cmder is quite good equivalent of bash with some embedded handy applications
It's not an argument against either. It's an argument against having spring maintain your class invariants when you don't have to.
&gt; Using constructor injection the compiler will tell you immediately that the parameter is missing from the constructor. Nope. It won't tell me shit because I also use @Bean. 
I prefer developing on Windows. It's not significantly different from other platforms. If you want to exactly replicate your Linux environment, well sure, you're going to have do things differently. But UNIX shells exist on Windows and Windows itself has a powerful shell. But the fact of the matter is that on Windows, I spend far less time on the command line. Re packages: Windows is easier in my experience b/c I can just download binaries rather than build most things from source. 
So you rather write and maintain shitload of the boilerplate more? Then perhaps you do not need Spring in the first place.
I switched to Jetty years ago and never looked back. Is there any compelling reason to give Tomcat another spin?
Windows 10 has the *Ubuntu subsystem* which has a full BASH, etc. Still, Java development is mostly independent from the OS. That myth that *nix systems are generally better for development finally needs to die.
Such as? Fundamentally, if your method can return a null, it is not returning the data type that you claim in the signature‚Äîinstead it's returning a sum type of two variants. If that's what you want to do, then you should do it explicitly (e.g., by returning an `Optional`).
I am not sure which distribution you tried and when, but besides Gentoo, most distros come with a package manager downloading prebuild binaries from repositories. They even have GUI for that. As for command line I'd say it's a matter of what one needs. I use shell scripts rather often to automate stuff, so when I was developing on Windows I maintained my own powershell which would build my environment on demand: cmder, cygwin, terminal tools, install languages and SDK... Nowadays I would use Windows Subsystem for Linux and run Ubuntu terminal for development.
Try [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10) - when I was stuck on Windows recently, I used it to recreate my development environment. I let me stay relatively productive until I could get back to Linux.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I wrote HDD explicitly, not everyone gets SSD computers from customer IT hardware pool for external services.
Git comes with bash and some basic command line tools, and the rest I can get with cygwin. Hardly necessary for Java development, but makes things easier if you're used to unix shells.
I'm wonder if NetBeans 9.0 (not beta) will be released before Java 11...
Light weight, easy to embed. I pack my entire WAR and the Jetty runtime into a single stand-alone jar. java -jar my.jar and I'm up and running. 
Sounds like pretty much the same using Spring/Tomcat.
Last time I used Tomcat I didn't like that I had to mess with server.xml to make basic changes like which interfaces &amp; ports it's listening on. With my embedded Jetty setup I can just do it in Java. Maybe I can do the same in Tomcat, haven't really looked into it, but it sure feels easier in Jetty.
\&gt; and \[com.bmuschko:gradle\-docker\-plugin\] is too difficult to set up. This really isn't my experience.
https://en.wikipedia.org/wiki/Class_invariant
I still don't know what you mean by that.
Clear and simple explanation. I hope people will read this before indulging in pointless debates about how to design the URLs for their web service to make it more "RESTful".
Git for Windows includes a bash terminal
Also checkout dropwizard. Somewhere between spring boot and sparkjava.
Wow! I am honored that this blog post starts with my quote! I guess I need to be more careful on what I say from now on.. 
&gt;Standards are very important for me. When you are professionally developing products, you have to ask yourself: Do I technically need an early adopter software or a long lasting lean product? This question is written like everybody knows the answer. However the true answer is "it depends". Case is point. I have an existing consul cluster and I want to connect my Java application to it. * Java EE answer : nada * Spring answer: just use https://cloud.spring.io/spring-cloud-consul/ So in some cases, yes you *DO* need bleeding edge stuff.
He-he :) I think that in general you are right. But my main reason to not use any gradle plugins to build a Docker image is that I'm trying to minimize dependencies and complexity of the project. Any new plugin adds to the project eco-system and your build becomes dependent on them. And in this case it's really easy to avoid that, so I wanted to share the way as I do that. If somebody wants to use plugins - fine, but if not, then they know - there is a choice.
Way to go, automoderator.
Fundamentally a method can return something or nothing. Nothing wrong with that.
For cross-platform scripting I use Nashorn/jjs instead of bash... The remaining *.sh files probably works only on Linux ;)
Even if you let each microservice have it's own api exposed they all have a relationship with the front end, is there any difference between those patterns in the end? Sometimes exposing all microservices isn't an option and sometimes (AWS Lambda for example) the services can't even have a http api. 
Where does an API gateway end and a micro service begin? Let's say you need to combine product data, pricing data and customer reviews in order to display product listings in an online shop. You want a single REST endpoint /api/article/list for your frontend. Is that a gateway or a micro service on its own?
I might (1) add a *real microservice for that, 'productsCatalog' which aggregates all this info (2) or assign this responsibility to the product microservice Both 1 &amp; 2 will not present a single point of failure for *all system requests, we also won't have one player that knows about all other rather a single case/service which orchestrate other. We minimize centralization this way How u handle that? 
1.) Correct that changes to the gateway service could have lots of downstream effects. In an ideal world, the gateway abstracts as much as possible, so there is little contract change, and also is relatively stable. 2.) A single gateway would be a single point of failure, but multiples are much more resilient. These services should be stateless so that users can be routed to any replicated gateway. 3.) Yes If you're building a small ecosystem, you may not need the additional complexity and resources to build a dedicated gateway service. The benefits just don't outweigh the points you mention. But, given a sufficiently large ecosystem it pays off to have the gateway become it's own service.
I think there is a danger that you build something that is in essence a monolith if you hide everything behind a single API gateway. On the other hand authentication and security is oftentimes something that needs to be centralized. If you operate some online shops it probably makes sense to have a gateway that handles all public requests. It is somewhat centralized. It can be a single point of failure, but you can mitigate that by building redundancy. It makes auth and security easier and on the whole safer. And on a certain scale you need service discovery anyway. I think it's a matter of definition if something that takes data and combines it is a *real* micro service or if that's part of an API gateway. Depends on the complexity of the operations as well, I think.
I didn‚Äôt mean the question to mean ‚Äúwhy would anyone ever use EE when there is Spring. I literally was just curious for an answer. I just started learning spring so I want to know about alternatives. 
I think that came across wrong. I just started learning Spring and I was just legitimately curious on the benefits and drawbacks of each technology. I think it‚Äôs important to know the alternatives and be able to defend why you choose one thing over another. 
&gt; On the other hand authentication and security is oftentimes something that needs to be centralized. Login is a concern of single microservice. Authenticating the token is *anyway the concern of all microservices (3 lines of code, decode JWT, save the user in the context) Isn't this simple and addresses the need? 
2. Point of failure means the entire service is down (e.g. bad deployment), failure in a single node/container is not the worst case 3. Maybe all the more in a large eco-system maintaining a huge monolith frontend service can greatly reduce the maintainability as it is coupled to ~50 microservices...
Why?
+1 for drop wizard and Jersey ;)
Yeah, you're certainly hitting at the trade-off here. You certainly want some resilient deployment strategies to account for this.
JavaEE by itself is outdated and cumbersome. Spring remove the pain-point of using JavaEE in addition to provide additional features not found in current JavaEE (e.g. [Spring Cloud](http://projects.spring.io/spring-cloud/), [Project Reactor](http://projectreactor.io/), [Spring WebFlux](https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html). 
Service code should be 100% divorced from any cross cutting concerns particularly security. I don't care how few lines there are.
It depends on what purpose your micro services serve. If you use them as scalable libraries of functionality, then API gateway is your application. If you are creating a set of unrelated end user services, then you don't need API gateway.
Ugh whenever I see that an app is using JPA and JSF I shudder uncontrollably.
If you are integrating with a system that uses null as a value, like a database, a null value can be a perfectly acceptable return value. In my experience it is often acceptable for the persistence layer to return null but the layer on top of that to convert it to some sort of default value.
It's useful for things like key management, throttling and request control, centralised or course grained authentication, perimeter security pattern implementation etc. Also in enterprise you will have existing services that are in all kinds of older technologies that need to work with newer services. A gateway lets you front and integrate those services until you can rewrite them. 
I don't understand how returning null is bad, but sometimes returning an immutable list is OK. They both have the same problems, just in different types of code (code that reads vs code that modifies the list). If you want to return an immutable list, then you should do so when there are and aren't any users.
Agreed. Gateway does course grained authentication of a token then supplies User principal as an http header to the microservice then the microservice enforces fine grained authn.
&gt; JSF is not anywhere near as simple or as easy to use as it looks. When you are using JSF you are building a JSF application with all the difficulties that entails, and you need people trained in the technology to be effective. Is there ANY technology where that doesn't hold? Are people born with Angular or Spring MVC or Thymeleaf knowledge hardwired in their little baby brains? 
How could i have missed that announcement, i'm gonna test that right now! thanks guys!
JSP is really easy to use mostly because you can ignore the fact that you are using JSP and write mostly HTML. You can really say this of any templating language which JSF is not.
If you can even take fine grain away and leave it to the security context. Rather than say "does this token have a claim or association I like?" say "hey security context, am I authorized to perform this discreet action on behalf of this user context?" 
I found that while JSF claims to make certain dynamic behaviors easier, in practice you still needed a solid knowledge of javascript. I found that the components were clunky and slow and depending on the component framework(I used Primefaces) just did not match what you can easily do with something like React clientside. If you are using JSF to avoid learning client side frameworks you are doing yourself a disservice.
This. Gateways are a valid pattern if you control all the services in your stack - it‚Äôs something more akin to a BPM process than a microservice architecture. However, if anyone else can have the effect of changing a contract and effectively pulling the rug out from underneath your feet, then you need to look at another pattern. 
&gt; If you are using JSF to avoid learning client side frameworks you are doing yourself a disservice. Likewise, if you're using React client side to avoid using server side frameworks you're doing yourself a disservice just as well. What's the difference? Maybe you used an old version of PrimeFaces, maybe you are just conditioned to having to like client side frameworks, or perhaps you actually do like client side frameworks. But the existence of client side frameworks does not specifically tell anything about JSF, as your hate would then be for every server side framework, so again nothing really specific JSF there, right? And client side frameworks have tons of disadvantages too, like for one JavaScript, for two the entire ecosystem that's in turmoil every day, and third, perhaps most importantly, that client side frameworks put much more load on the client, and the client doesn't like that (drains batteries, makes devices hot, kills other background apps because of lack of memory, etc...) 
Interested in how Red Hat sees Istio jiving with its 3Scale API gateway product. There seems to be some overlap there.
No mention of Shiro, Soteria, Spring Security?
&gt; whenever he see that an app is using JPA and JSF 
Dunno what experience you have, but personally, my professional experience of using JSF for over a year was full of pain and wasted time for a subpar result. If you get good results then I expect that you are among the few. I would even say given the complexity JSF adds to the server side and the harsh learning curve, it is worth recommending just about anything else before JSF. 
This is right on. Source: Did this at a Fortune-50 company and then worked with an enterprise services team as they rolled out this solution Enterprise-wide with Kubernetes and various tech stacks. 
It's turtles on the way down. The distinction is mainly about what is owned within your business unit, what is not, and how security is handled. Microservices oftentimes are protected by firewalls, but not auth tokens, while api gateways are exposed external to your business unit and handle authentication and (sometimes) authorization. 
&gt; that client side frameworks put much more load on the client, and &gt; the client doesn't like that Unless you're serving only HTML, if you're delivering a true application, client side frameworks can significantly reduce the load on the client device. You can push static assets to the client (HTML, CSS, images), and the client can then use HTTP caching to avoid having to download them again. The server then only needs to send JSON data, which is much easier to parse than HTML and requires less network bandwidth. A "warm" app will have already loaded the templates into memory, so generating DOM from cached data structures is much faster and less labor intensive than parsing HTML. Furthermore, by pushing code to the client, it is possible to let the app run in offline mode, until the network is available again. The [progressive web apps](https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/) technique is designed to created apps optimized for mobile, which requires understanding client side frameworks and browser technology. This *could* be abstracted away by JSF, but I would rather work with the client side with its native technology, which leads to better and more optimized client side code, than letting server side frameworks generate client side code.
Obviously :)
Actually, I am mostly using these things: * IntelliJ * Install https://mridgers.github.io/clink/ , to basically make cmd.exe get some "powers" * https://docs.microsoft.com/en-us/windows/wsl/install-win10 , which works great, don't exactly know what bugs you are talking about 
G1 parallel collector support to reduce hiccups during stop-the-world collections. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
None of them are as elegant as straight SQL via something like Springs helper
Perhaps it was not possible at the time but you can do the exact same thing with Tomcat now. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is the [Facade Pattern](https://en.wikipedia.org/wiki/Facade_pattern) an anti-pattern?
**Facade pattern** The facade pattern (also spelled fa√ßade) is a software design pattern commonly used with object-oriented programming. The name is an analogy to an architectural fa√ßade. A facade is an object that provides a simplified interface to a larger body of code, such as a class library. A facade can make a software library easier to use, understand, and test, since the facade has convenient methods for common tasks, make the library more readable, for the same reason, reduce dependencies of outside code on the inner workings of a library, since most code uses the facade, thus allowing more flexibility in developing the system, wrap a poorly designed collection of APIs with a single well-designed API. The Facade design pattern is often used when a system is very complex or difficult to understand because the system has a large number of interdependent classes or its source code is unavailable. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
No it's not. Zipping matches up corresponding entries in both lists, whereas the Cross Product example matches up all of List 1 to all of List 2. Given these lists: suits = [CLUBS, DIAMONDS, HEARTS, SPADES] ranks = [2, 3, 4, 5, 6] A zip would give you: * CLUBS, 2 * DIAMONDS, 3 * HEARTS, 4 * SPADES, 5 Whereas the cross product would give you * CLUBS, 2 * CLUBS, 3 * CLUBS, 4 * CLUBS, 5 * CLUBS, 6 * DIAMONDS, 2 * DIAMONDS, 3 * DIAMONDS, 4 * DIAMONDS, 5 * DIAMONDS, 6 * HEARTS, 2 * HEARTS, 3 * HEARTS, 4 * HEARTS, 5 * HEARTS, 6 * SPADES, 2 * SPADES, 3 * SPADES, 4 * SPADES, 5 * SPADES, 6 
&gt; GMail may take some work to warm up, but if you leave it open, the cost to the device is amortized over the duration that GMail stays in the browser window. By far not all web applications are gmail though. &gt;You can push static assets to the client (HTML, CSS, images), and the client can then use HTTP caching to avoid having to download them again. That's exactly how it works with JSF and other server side web frameworks as well, doesn't it? &gt;The server then only needs to send JSON data, which is much easier to parse than HTML You forget though that HTML after parsing can be rendered directly, while parsed JSON is just data. It still needs to be transformed into rendering instructions and thus eventually be rendered. The arrival and parsing of JSON data is roughly equivalent to having done a database query on the server. The actual transformation to a UI representation still has to start then. Depending on how heavy the client side framework is, this could possibly entail going through a large set of layers and many event listeners, interceptors, and what have you being called. All this takes CPU cycles and thus energy on the client. &gt; and requires less network bandwidth. Not necessarily. HTML/XML generally compresses much better than JSON, so the savings may be less than you think. Also, with JSON you typically do many small requests for all the data that the page needs. This is every time a client to server communication, which has a high latency. By contrast, server side frameworks get their data from small requests to other services on the server, which generally has a much lower latency. That data is then combined into a UI update and blasted to the client in one chunk, generally improving latency quite a bit. 
I was using Windows for Java development for the past year. It's perfectly usable, though I prefer to use a Unix-like system. I did end up dropping to Git Bash (no WSL on our locked down corporate Win10 images) for utilities like grep, but I'm sure there are alternatives on Windows. I have since moved over to MacOS, which I'm not a fan of as a general purpose operating system, but it works better than Windows for Java development with my preferences. 
If you have one monster facade over all your microservices; yes. If you have small facades (basically the [BFF](https://samnewman.io/patterns/architectural/bff/) pattern) then no. You don't want to have one monster facade because that way you destroy one of the (few) benefits microservices have: the ability to place ownership of a small piece of functionality in one team and have that service life and die with the lifecycle of the functionality. A facade is extra work (not that this is a bad thing perse, we're considering moving to BFF) and if you're not careful you'll end up with one big distributed monolith full of dead code. 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://samnewman.io/patterns/architectural/bff/) - Previous text "BFF" ^^Please ^^PM ^^/u/eganwall ^^with ^^issues ^^or ^^feedback! 
`.compareTo()`? That requires the objects to be compared to have the `Comparable` interface implemented.
Hi, You might like Spring Framework 5 functional reactive endpoint support. I wrote a simple Getting Started post on the topic for you here [1]. For more details, checking out the Spring guide [2] 1. http://joshlong.com/jl/blogPost/functional_reactive_endpoints_with_spring_framework_5.html 2. https://spring.io/guides/gs/reactive-rest-service/ 
&gt; Should I be using Spring MVC? The answer to this question is always: it depends. What are you trying to accomplish? Spring MVC is one of many Java MVC web frameworks, but carries the weight of Spring with it. If you are using other Spring products, then Spring MVC is great! If you're only doing some simple web stuff and some simple DB stuff, Spring can be overkill. There are many lighter weight alternatives. On the other hand, if your goal is employment, then you should definitely learn Spring (of which Spring MVC is one product), since it is heavily used in industry.
..or even JavaEE 6 ! 
&gt; Java EE answer : nada &gt; https://ee.kumuluz.com/ ?
http://www.msys2.org/
Makes sense. So they are not an anti-pattern but something to use when you really need. Many put those (smart) type of gateways by default to abstract *all the endpoints from the frontend which then become another layer to maintain, update, etc
Should I extract every system function, 100K functions, to a DI so it can be replaced? why not, is the strategy pattern wrong? Every pattern should be used reasonably and in the right context. Facade was meant to isolate the *domain* under a specific bounded-context, not 50 microservices
None really. It's just that monkeys like to type less.
It comes from the functional programming world. You can see some benefit in declarations like this: var s = "my string"; var map = new HashMap&lt;String, Integer&gt;(); i.e. writing the type of the variable actually makes the line of code less clear and is redundant. But, this feature can be easily over-used. I've written a lot of Scala recently and it's very difficult to discern the type of variables in Scala code.
Is there any way to stop var from being put into Java?
`var` is one of those things where a good IDE helps a lot, because said IDE can tell you what the real type is.
What else ***is*** targeted to Java 10 ***besides "var"?*** 
Spring Boot is pretty much the future, which builds on the ‚ÄúSpring Framework‚Äù. For a while it was a bit difficult to use Spring because it was all XML based. However since Spring Boot that xml config is gone and it‚Äôs much easier to get started with. They link a lot of (usually) up-to-date guides and tutorials [here](https://projects.spring.io/spring-boot/).
Var is the one thing that is ok to use if the return type is clear like class.getArrayListOfStrings() But not in cases like class.getBla() What is this line supposed to return? Don't know because var is used. And especially when declaring methods void doThis(var a,var b) What am I supposed to feed into this method
&gt; It comes from the functional programming world Type inference is unrelated to functional style. C+11 has type inference and it is really far to be a functional language.
https://en.wikipedia.org/wiki/Type_inference "It is a feature present in some strongly statically typed languages. It is often characteristic of functional programming languages in general."
They all do ORM. Once upon a time there were different OR mappers that each worked differently. Then the JPA specification came along and standardised OR mapping. So tools like hibernate also supported JPA. Now there's no longer need for specialised OR mappers, but some are better than others. So everybody supports JPA, but you still get to choose the OR mapper you prefer.
Adam Bien JavaEE YouTube videos are great for starting to get familiar with the JavaEE APIs and learn about the core features such as CDI (dependency injection), JAX-RS (RESTful web services), and Persistence (ORM). After that, it becomes easier to pick up the Spring Boot specific APIs. This one is a great place to start. **JavaEE: Heavyweight or Lightweight** https://youtu.be/LwimkQQDhio
&gt; void doThis(var a,var b) var can oply be used for *local variable declarations with initializers*.
Okay. I haven't read the article but just look at JavaScript. You don't even need to give a type when declaring functions function foo(a,b,dx)
Eliminate what you call redundancy does not bring anything special. There is a difference between readibility and conciseness. Please havea look at Prolog and you will see a nice example of non-redundant programming. Unfortunately Prolog is very hard to understand and to debug. Honestly what's the difference between writing int n=5 and var n=5 ? Why should we write var or int ? n=5 is enough. 
In addition it will be very hard to teach Java. Having several ways to do the same thing does not help to understand the concepts.
Some rationale can be found [here](http://mail.openjdk.java.net/pipermail/platform-jep-discuss/2016-December/000066.html). It's interesting reading (and seems to be based on surveys of 2500 people who actually try different variants) (link found in the article). 
&gt;`n=5` is enough No, the difference between `var n = 3` and `n = 3` is that the former *declares* a variable, while the latter only *mutates* one.
The bold words/phrases are corrections from the original. The linked article has pretty horrendous grammar.
Jersey.
It's not an important feature, I agree. But, if it stems the tide of boutique languages like Scala I think it's worth it. 
What's the difference between writing `Map&lt;Character,String&gt; fullCharName = new HashMap&lt;Character,String&gt;();` and `var fullCharName = new HashMap&lt;Character,String&gt;();` (And comparing Java to Prolog differs in much more than conciseness; they each require understanding a different paradigm. Comparing Java with Scala might be a fairer comparison.)
&gt; What is this line supposed to return? Don't know because var is used. You don't know because of bad naming. I actually noticed in using Kotlin that you're forced more to write proper code. If you name variables, methods and functions properly it's really not an issue. 
I think you should interpret it like that: **if you can use standards, use standards** 
Honestly a good IDE replaces the need for me. Code written by others and some codes will become unreadable. Look at recent C++: impossible to read 
For whatever reason, the whole industry is moving away from simplicity towards complexity. I can't understand it but there doesn't seem any way to stop it.
Since JavaScript doesn't have type hinting, it also doesn't support method overloading like Java and C# do.
&gt; I'm not sure what "rendering commands" you're talking about, but DOM management is the entire point of client side frameworks. Once you have the DOM, the "rendering commands" are implemented by the browser itself. I hope that was obvious, but let me clarify it. A JSON string is data. Say a `User` object with `first name` and `surname`. It's completely dependent on the application logic of what to do with this. A browser can't think; hey, a user object, let's uhhhh update the logged-in user that I see on the top right of the screen. Or uhhh maybe it's the user who just commented in the middle of the screen. So 'something', 'somewhere' has to take that user object and convert it into 'commands' (of whatever nature, maybe a call to a render update object, which then does the SHADOW DOM update, which then does the BACKING DOM UPDATE, which eventually does a DOM update, which then even somewhat later renders actual pixels on the screen, ...) So, again, you don't render JSON directly, but your application logic does something with it. This is different from sending over HTML (fragments). The application logic on the server already has decided how the data should be rendered and where it should appear. So basically all the client has to do is take the HTML fragment and hand it over. There's no logic on the client needed to determine how/what/where it should be rendered. The point is that this application logic may take time, and in fact, often does take time. The bigger the application, the bigger the client side framework, the longer this takes. &gt;No. JSON is just data. HTML includes presentation. The HTML version is far more verbose than JSON, simply because it encodes more information in a more verbose way. Sigh... I'm not sure if you know how compression works, but if there's a lot of redundancy it compresses better. Some text files can compress to 1/1000th of their size, easily. It depends on what exactly needs to be rendered, taking the user object again. Maybe it's just user, first name, last name all surrounded by the &lt;li&gt; elements, and a single update header to say where it should be inserted. Does it contain much more information in a more verbose way? Perhaps, but the "li/&gt;" part would e.g. repeat 6 times and can be replaced easily by a fast index token (could be a byte). The header is extra information, but compresses well again. All in all, the result could or could not be larger than the JSON version, but the entire point is that the difference is probably *not as much* as you think by just looking at the source. A point you somehow seemed to have missed. There's another effect, and that's that if you're not careful (and some devs aren't), the web service or API gateway, or even the federated API portals used by bigger orgs, send too much data back. I.e. not the user object with just first name and surname, but also age, and address. It's a bit of an art to tell a service exactly which fields are needed, and this gets more complicated with general APIs and objects with (deeply) nested objects. So the service being generic and the dev lazy or under time pressure simply calls an existing method returning the whole user object. Oops... there go all your hard wanted advantages of your JSON taking up less space... And if you've been in any serious development with a lot of different teams, who each have their own requirements, you probably know this happens more often than not.
I'm qurious why you want to switch? And which industry you're targeting? But to answer your question, 1.st that would be Java SE API, then you've multiple options - spring (single vendor standard), java ee (one standard, multiple vendors), then probably osgi and then various other frameworks. I'd go with CDI and JDBC first.
IMO, charToName reflects the map type better here, because it looks like a list otherwise. Maybe I lack the context here
If you downloaded and installed the JDK it should already have the JRE included. It probably installed it somewhere like C:\Program Files\Java, you can go there and check. You may have two "Program Files" directories, if so check both. Within the folder "jdk1.8.0" or whatever version you downloaded there should be one called "jre". If you have these folders and your server still won't start up you probably still need to add the jdk to your PATH. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; But let's be honest: [...] That's subjective. I've gotten used to read first the type when reading code, that "redundancy" helps letting things clear and concise (i.e. "this is String, and will always be a String"). Yeah, it takes more space and blah, but we are talking about GetClass().getTypeFactory().generateTypeElement() java code. I've seen enough chains of "gets" to make the type returned totally obscure for the developer. Still, I'm too used to this, so yeah, my opinion is also subjective.
I'm saving this for later read, thanks!
Thank you, you are right, in my Java folder, I have both jdk and jre folders. In that case, it must be something else stopping my server from working. I will investigate elsewhere, thanks for your help.
Because people like to change. Sometimes just to change. Industries are also too much guided by blogs, that contain only small code and that is interested in gaining some spaces
It is a matter of taste. I have no problem with the long sentence. Most exemples involve a new, so this is rare :-) 
Mainly just wanting to maintain a wide enough skillset to stay employable. I live near a military base with lots of govt. contractor jobs that are always looking for java devs
Of course, Java as a teaching-programming language is already awful, imo. (Java is a quite a good enterprise-level language -- just poorly suited to people learning programming for the first time.)
Thanks for the link. However this looks just like an alternative implementation. Is this an official JavaEE spec? Where is the JSR behind it (hint: there is none) So it is AN answer, not a JavaEE answer.
We agree then. The problem is that at any given point in time the JavaEE standards are a subset of what an application actually needs. Spring on the other hands attempts to cover all the possible new requirements of an app as they appear....
It is optional, and sometimes what matters the most "in a specific context" is the name of the variable
If you're looking at older code bases, configuring beans with XML will be part of it. Hopefully you will get on a project using newer Java Config. Spring MVC and Spring Boot are not mutually exclusive. Spring Boot is a large push button wrapper around all of Spring, including Spring MVC; with the goals being simplified dependency management and improved packaging and deployment options. 
IntelliJ might pick this up like they display anonymous classes as lambdas if possible. Although I have by doubts because var wouldn't improve readability that much, possibly making it worse.
You don't have to use Spring MVC but do your best to find a popular well maintained framework which you find simple and easy. If you're already using php check out laravel and symfony. Keep in mind that the framework is there to help and it's an abstraction you will use for common patterns and problems. Don't try to learn the framework fully or how everything works, just work through basic tutorials until you can figure out how to throw your code into it. Then start refractoring and making small changes. After a while you'll get more comfortable with the framework.
It seems to me the answer is yes, no and sometimes yes or no, also known as, it depends. Microservices are generic, every place will do it differently. Tiers were different. Etc, etc.
If you decode to use Spring, use Spring Boot. You manage your database woth Spring JPA, controllers with just annotations, a lot of good templating engines, etc. You can use spring initializr to get a project running quickly and there are tona of official and unofficial tutorials
&gt; I'm not really looking to change to java fulltime Spring Boot will provide a solid foundation for the coders who will end up maintaining whatever you end up creating, down the road. It's almost the power of Spring with the ease of Spark Java, sort of. Spark is fun but it doesn't have, in my humble opinion, enterprise potential. https://projects.spring.io/spring-boot/ Everything else is someone trying to sell you something. 
Looking forward to Jetty support. I'm almost certain it will use less memory than my current Spring Boot app that embeds Tomcat. I love Tomcat and for deploying multiple wars it can't be beat but for Spring Boot, it almost seems to be made for Jetty.
What has this got to do with Java?
I've written it somewhere else, but I have a small bias thanks to some years in shitty projects with average/below average developers (and as I said on the other answer, there were also good devs, but they are out of these concerns). My point is that leaving more "freedom" for a dev can (and usually will) led to bad practices, unless you spend more time/resources on code reviews (Which not so many shops do) an enforce strict code style rules, and I'm picturing devs reusing the same variable "aux" on a function over and over. Shit, I've seen someone even using "s1" and "s2" for strings and even checking nulls with, well, a try/catch and doing nothing on the catch. Today has been a infuriating day, sorry. Also, I don't really consider "redundant" a type declaration (no idea how to mark code here, so..): Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); String userCode = "0451"; Again, this is something subjective, but you can't declare a Map and then "force" yourself to only use the map methods to use it, and some confusion could come from a string code that only have numeric characters. Btw, take into account that I have a strong hate against weak typed languages (That's the name? English is not my first language &gt;.&lt;), as I'm way too used to declare everything and having it sorted. But wel... 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Hmm, I would agree that the `var` thing can be used to write even worse code, but fortunately I haven't had to work with devs as bad as the ones you described so I can't really comment on that. What we have in Kotlin for your map example is: `var map = mapOf&lt;String, Object&gt;()` `mapOf`'s return type is a `Map`, so the actual map implementation is automatically hidden. I think it's cases like this and the `Random random = new Random()` example that still haunts me from when I first learned Java where the automatic typing really shines. I share your hate against weak typed languages, and so I think it's import to point out that everything is still exactly as much typed as it would have been with the explicit type declarations.
This is clearly out my league. What is maven? 
I don't have problems (yet) but as I go deeper into what I'm doing, and trying to make it user friendly, it feels like I should be using some sort of framework and the only one I'm familiar with is Spring MVC. I just remember what a pain it was with all the layers so I figured to ask before I spent hours rewriting it and turns out there's something better suited. For example, I could use it myself in its basic form but if I wanted others to try, it will be really confusing. There's no validation at this stage xD so I started to think how to validate the one portion and that's when I realised it will probably be better to implement validation the way I used to when I worked... At this stage whatever I do will be useful going forward. Most job ads I've looked at have asked for familiarity with MVC.
Thank you! I'll cross post it there later when I'm at my desktop. I'll have a look at Spring Boot. I don't know what else exists out there since I've only worked with Spring MVC so I'll have a look at the ones you've mentioned. Thank you!
Maven is a build tool that allows you to specify the dependencies (usually code written by other people) for your program. It does a lot of other stuff, especially when you add in plugins, but in general it's there to make building your project easier.
I'm trying to build a web app that I want to host online in the near future to use for myself but it has potential to be used by others. I couldn't find an app on the Play Store like it, so I figured to make one myself and since I have no knowledge on making mobile apps, I thought to develop a web app. Please mention some which are more light weight so I can research them :) Also yes, I'm actually going for a job interview tomorrow and the ad mentioned familiarity with MVC and most ads I looked at asked for MVC so it is definitely good to know! I just didn't want to invest time in figuring it out (again) if it is overkill or if there's something better. 
I shall have a look at those. Thank you! That's true as well. When I worked before, I was literally thrown in. One of the guys in the team sat with me for a couple of hours explaining how the things "talk" to each other and then it was as if I was set free into the wild or deep end with just a small plank of wood and tools and expected to make my way back to shore hahahaha. I'll do what you've suggested though. 
Thank you, I shall have a look at this.
Hard pass thanks
I mean it just depends on what you're working on. My current class has 20+ entities in it. Writing all that by hand would take a ridiculous amount of time. 
writing all what by hand ? I found maintaining all the hibernate annotations painful. Only if you have the simplest most basic crud application would i ever possibly consider it again. Honestly I just don't get it: public Number create(Person person) { final KeyHolder holder = new GeneratedKeyHolder(); final String sql = "INSERT INTO person (name, extension) VALUES (:name, :extension)"; SqlParameterSource parameters = new MapSqlParameterSource().addValue("name", portalExchange.getName()) .addValue("extension", portalExchange.getExtension()); namedParameterJdbcTemplate.update(sql, parameters, holder); return holder.getKey(); } 
**Make (software)** In software development, Make is a build automation tool that automatically builds executable programs and libraries from source code by reading files called Makefiles which specify how to derive the target program. Though integrated development environments and language-specific compiler features can also be used to manage a build process, Make remains widely used, especially in Unix and Unix-like operating systems. Besides building programs, Make can be used to manage any project where some files must be updated automatically from others whenever the others change. *** **Apache Ant** Apache Ant is a software tool for automating software build processes, which originated from the Apache Tomcat project in early 2000. It was a replacement for the Make build tool of Unix, and was created due to a number of problems with Unix's make. It is similar to Make but is implemented using the Java language, requires the Java platform, and is best suited to building Java projects. The most immediately noticeable difference between Ant and Make is that Ant uses XML to describe the build process and its dependencies, whereas Make uses Makefile format. *** **Apache Maven** Maven is a build automation tool used primarily for Java projects. In Yiddish, the word maven means "accumulator of knowledge". Maven addresses two aspects of building software: first, it describes how software is built, and second, it describes its dependencies. Unlike earlier tools like Apache Ant, it uses conventions for the build procedure, and only exceptions need to be written down. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I agree with you in general, but I do have one quibble. Spring XML config is definitely not gone. We use it work all the time. For example, we have a generic player that can play back a stream of captured messages. Sometimes we want to play back one message format, sometimes another. We have several components that all implement a common "IPlayer" interface, and we can swap them in and out by just changing the classname in the XML. To do this with annotations would require recompiling. In fact, while I admit that I haven't used Spring annotations much so I could be missing something, it seems to me that annotations take away most of the power of dependency injection.
I worked on a distributed Java app for 17 years. As I was there at the beginning, I built in CPU and memory measurements every minute, and eventually added tools to graph what we knew. We could see the used memory line approach the available memory line, and shortly after that the CPU line would start to increase, and some time after that the measurements would be interrupted indicating that the system had crashed. We used a homegrown asynchronous buffer implementation, where would keep tasks to be acted on by processing threads. Each buffer had a name, and if it started growing suspiciously we'd start logging the sizes of all of the buffers. So when we saw the used memory line go up, we'd look for increasing values in the buffers as well. We had periodic full stack dumps, so if the buffers were increasing we would often get lucky and have a stack of the thread that was supposed to be processing that buffer, so we could see where it was stuck. We also monitored every SQL statement or Hibernate query we executed, and if it took more than 2 seconds we'd log that. Similarly for RPCs and other calls out to external services. So if the thread looked like it was doing something, it might anyway be leaving a trace of slowness. It was always nice when one VM reported "slow RPC" and another reported "took too long to process RPC", so we could track the slowness across processes. We also added logging of page opens and closes, so if we noticed a period of high CPU or memory leakage, we could figure out what was being done for that time period. I added two search and text highlight capabilities, so we could search for two different messages and try to match their behaviour. That was nice when we would notice that whenever the user opened such a page, an error would be reported in the logs a minute later. Over the years, the graphing tool gained all sorts of capabilities, such as being able to graph O/S performance logs in a separate pane, and being able to open multiple files and zoom and search all of them at once. It was truly a wondrous system which I dearly miss. In any case, if you're building a big app which does lots of interesting things (not just serving web pages), it truly pays to invest in some monitoring and investigation capabilities.
Maven is lib like graddle as I know
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Additionally add the jul\-over\-slf4j and cl\-over\-slf4j dependencies \(and log4j\-over\-slf4j if you're using logback\) to your project so all logging, regardless of api used, is sent to the output framework of your choice. One of the original things that brought me to slf4j was placeholders, so no more if \(logger.isDebug\(\)\) { logger.debug\("expensive.toString\(\) object:" \+ obj\); } With slf4j you can just do: logger.debug\("expensive.toString\(\) object: {}, obj\);
&gt; Spring XML config is definitely not gone. He probably meant it's generally not used for building new stuff anymore. And it generally isn't. Your 'swapping' requires a build too. Unless you don't test after a change. So moving that bit from code to XML really doesn't change anything. 
See my [reply here](https://www.reddit.com/r/java/comments/7ykw5z/what_else_targeted_to_java_10_besides_of_var/duhw1re/). In my experience with both Scala and Kotlin the "code becomes less readable" is purely theoretical. Code readability doesn't come from the type tacked on the front of a var. It comes from good clean code structure and proper naming of vars and methods. If you have a method 20 lines long and declare a List&lt;Person&gt; persons at the top you still know that 'persons' is probably a collection of Person objects not because of the declaration but because of the naming. If anything in my experience var/val lead to better code because it forces you to properly name vars and functions. 
Wait until you have to work with Ant+Ivy or SBT+Ivy. SBT has many features, but it's slow and uses Ivy a lot, which sucks... THAT's the dark side...
&gt; What is maven? Aside from the other comments; it's not something you can 'not know' as a professional Java dev. So definitely check out Maven and Gradle (same thing, different config syntax) and use them. 
You could use @Conditional or some spring boot version such as @ConditionalOnProperty and use a property to get a desired bean
Well, tbh I only ever used Maven and Gradle. Well, I say "used" Gradle - it was more like a messy struggle, at the end of which I'm exhausted, angry and in no way closer to having the project compiled. 
Yay, glad you liked the commands! I hope it's a great way for people to learn new ones, instead of "just" reading about shortcuts in a blog post. @Spring: The current ones are Spring Boot 1.4.x and Spring 4.x. The screencast topics (REST Services) are not really dependent on the specific Spring version, but in case you are wondering I'll cover the 2.x version in detail once it's released. And I also try to publish episodes like "What changed from 4.x to 5.x" from time to time...the backlog is growing :) 
Also, I get the feeling that you want to release something that works well with the smallest amount of effort. In that case you might want to stick to something like Node.js as,while JavaScript is a terrible language for the backend, you can build an app in no time as the framework does most of the work for you. Spring can sometimes be a pain to set up and troubleshoot even before you start working on your code.
Not a native speaker myself, but I pronounce Maven as "MAY-venn" and Gradle such that it rhymes with "cradle" 
If it's a program argument there isn't a reason to use XML over annotation based configuration?
That isn't new with Spring Boot 2. You can [use Jetty right now](https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/html/howto-embedded-servlet-containers.html#howto-use-jetty-instead-of-tomcat). 
What's the issue with gradle?
Microsoft made mistakes with .net which will be difficult to recover from. Instead of working toward platform neutrality like Java, they polluted .net with windows specific apis. Now as Windows is on the decline they are forced to try to backtrack but they are 20 years behind Java on this kind of research and technology. They lost on the server. They lost in mobile. The only thing they have is desktop which has been on the decline and their current framework WPF is painful compared to JavaFX which is the best, most modern UI framework available today. You can deploy Java very easily as well since you don't need to install it. With AOT, Java Native Packaging and the new module system you can create true "stand alone" applications. This is simply not possible in .net. 
Spring Boot has not only "almost the power of Spring", but the full power of Spring + a nice convenience layer. Whenever you need to, you can use all the underlying Spring mechanisms. To Sparkjava: I would prefer Spring Boot or JAX-RS (maybe with Dropwizard), because Sparkjava is engineered for simle applications. You can, of course, create large applications with it, but the programming model doesn't support that as nice as the other frameworks. JAX-RS and Spring both have superior tool support.
This is nice, but the author of the original post didn't mention any need for reactive programming (which can makes things a bit more complicated, if it not really needed).
His username is not in the sudoers file. This incident will be reported. In all seriousness, a mod might have saw it and flagged it for approval. 