The section on the use of Optional in the APIs is nonsense as well: * We don't like Optional. * Optional is "controversial". * In support of that viewpoint here is a random selection of blog posts about Optional, some of which are very opinionated and one-sided and others which aren't actually criticising Optional.
Nice write up 
Painfully true
Wow, that's amazing. I have sent you a PM with my contact information. Thanks!
Use the designer to create a xml based template. Read the template in your Java program. Set the values of your variables in the Java program.
A really good response, thank you for putting it all together. I also have no dog in this fight, but will have to deal with java9 incompatibilities for a range of projects when the time comes. I am more concerned by the emerging conflict itself. Java was never a perfect solution, but an acceptable - and standardized - one. Arguments like "but it is not perfect" and calls for drastic steps do not sit well with me.
Great post! Thanks.
Why don't people like `Optional`? It seems like a clear step in the direction of type and null safety. It really feels like something missing from the other APIs, not "controversial" for this API. The article links to some blog posts of users against optional, and I could honestly replace "optional" with "C++ classes" and move these articles back to 1999. "Apparently some programmers don't like null references". What a joke. Null exceptions and preventing them are responsible for millions of wasted person hours.
As if it isn't enough, I shit you not I saw a collection returned wrapped in an optional... I see only the purest reason of using it to inform users of your api that, "This thing sometimes returns null, prep yourself" Internally in my own codebase I really struggle to see the point as strongly.
well...I do not think you have gone in detail to compare the difference between Oracle's guidelines and what I published. There are items which are derived from my own experience like "do not use multiple return statements". Another example would be ""write small functions not more than 50-60 lines". I do not see such guidelines in Oracle's document. You are comparing a style guide with best practices. As to be "precise" guidelines are never precise that's the whole point....like prefer "simplicity over complexity" or "prefer composition over inheritance". Please read over again and if you can not understand feel free to discuss with me.
You are correct. It does, and this is contained in the documentation. You might get more help if you don't mark your request URGENT. What is URGENT for you likely is not for people reading your message.
Fair enough. I don't like the way Boot feels either. DropWizard might be worth looking at too.
Enlightening. Well done.
Just to make sure, the expected result for most folks would just be an empty collection, right? 
You are a fucking moron.
I don't know what ping you are talking about. The ping i know is a ICMP protocoll call, and as such goes all the way of the network stack (TCP socket).
Yes :)
Checked exceptions are one of the worst features in Java. They break encapsulation by forcing you to handle exceptions at the site where you called the throwing method, even if you cannot handle it meaningfully at that point. The only alternative is to rethrow, which pollutes all your method signatures. Checked Exceptions suck big time and nobody should use them anymore. There's a reason Java is the only language that has them. While I like Optional and think it doesn't suck in general, you completely missed the point the original author was making: The Jigsaw API uses Optional in places where it should not be used, in particular around Collections and as the result of getters.
You may as well ask for an explanation using interpretive dance.
Are you "the" Gavin King?
Seems like a bit of an over reaction.
The 10% or less of cases this happens are covered fine by documentation, like the rest of the JDK, than forcing the other 90% of use into ugly "if-ispresent-get".
And now millions of person hours are waisted in wrapping and unwrapping Optionals
Obviously not wasted, since you'd only be wrapping variables that has the potential to be null. The act of unwrapping is simply the same as always, albeit the syntax is a bit different. 
Even though you may not like Spring Boot - I would advise you to give it a try. It integrates with the spring ecosystem much better - and is a no brainer if you want to use Spring Data or other parts of the spring ecosystem. Due to work requirements, I had to convert my dropwizard uber-JAR to a WAR that I could host off the firmwide tomcat, but that was not a fun experience. 
im very curious if you can shortly describe how you are passing data the data from the facade method call to the service , im using the same approach but the facade interface gets bloated quickly , im thinking about using parameter objects 
Probably not the best question to ask, as each project and implementation has different requirements and different developers. The tools that you choose should reflect the problem you are trying to solve. Spring is not the right tool for every job, but it is certainly the right tool for SOME jobs. The same is true for most other tools.
The example with `Optional` would probably look more like this: getUsername().ifPresent(username -&gt; { // do stuff with username });
There is no "hello world" in java-ai in the same way there is no "hello world" in theoretical physics. Although some people would like you to think that AI is simply using some library, it is a whole field that requires a base of statistics and calculus, among others. If you really want to learn about AI, I would recommend http://aima.cs.berkeley.edu
I edited [one of the posts in question](https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/) and am not happy with it being listed as an argument against using `Optional`. &gt; And omg those are some opinionated posts. Fortunately, Math is not about opinions, so "Optional is not a Monad" is the bare truth, which you can't argue with. Whether that matters in daily programming is a different story and the post linked above tries to show the reader that it does. But it also explains why that decision was made (to make `Optional` more null-safe) without criticizing it. I personally even support that decision and have argued repeatedly [in favor of `Optional`](http://blog.codefx.org/java/stephen-colebourne-optional-a-strict-approach/). To cite this post as an argument against using `Optional` ruffles my feathers and I guess was caused by some superficial googling to find support for one's own opinion.
We had veeery little logic in facade classes. A facade only hides some service methods and therefore purely delegates or combines method calls from different services (depending on the use case) Suppose you have a website where you have a page, were you can write a message to some user, another where you can search for a user message and maybe one where you're actually displaying the message. For these 3 tidely related use cases you could have 1 facade which provides the methods: sendMessage(userId, msg) getMessages(userId) getUsers(userName) This "MessageFacade" will internally use multiple services for example a UserSevice just to search for users in order to write a message and e.g. a MessageService with whom you can store the message in the database, make validations such as scan for allowed characters etc. For getMessages(userId) the facade will delegate the request to the MessageService, whereas for getUsers(userNames) it would delegate to the UserService. But why the facade in the first place? A facade first exposes only the functionalities that you're supposed to see. Like the UserService might have much much more functions for deletion, altering (passwords, address, other fields, etc.), storage and of course fetching (maybe again depending on different criteria? = multiple functions). The MessageFacade however only needs 1 function so it only exposes that one from from the UserService. Facades are usually used to map REST calls and can furthermore provide, for the same service call, different access rights. You could have getAddress() be granted in one facade for any user and in another just for a certain user group while both facades delegate to the same Service. 
You'd need a loader program.
I haven't used Lombok but it looks good. Is there something better or more compatible I should look at to do similar data classes?
1. This isn't /r/javahelp 2. [Learn to Google](https://github.com/centic9/jgit-cookbook/blob/master/src/main/java/org/dstadler/jgit/porcelain/ListRemoteRepository.java)
1nb4 "Scala" / "Kotlin".
Usually the facade takes an object like "requestTO" i.e. a transfer object which which is the deserialized XML or JSON which you get from the REST call. If it is really simply delegating, then no changes are required for the facade even though the structure of the requestTO may have indeed changed. The changes are only reflected in the service which makes sense.
Microservice makes sense for us, as at peak times we reach a couple of dozens of thousands request per minute but not for all services i.e. some services will peak at x pm, some stay constant. However, I don't see how a proxy is substituting a layered architecture. What you describe is load balancing if I'm not mistaking? What I want to know, is how to organize code since the projects are now significantly smaller. You wouldn't have facade/sevice/dao for a hello world? This is overkill. But what else will I have? Is there maybe a pattern between nothing and a layered architecture? Edit: What I wanted to say with the peaks, is basically that there is an urgent need to scale. The number of requests changes drastically throughout the day.
&gt; its best if you can write it so the server is 'stateless' It's a bit out of the scope of what I originally asked but since you mentioned it and you are so helpful I figure I'll ask about this. The server side is composed of 2 types of processes: one is shared amongst all players and serves as the place players can match up for a game. The second is the process which handles a single game and one is launched for each game. The second is mostly utility classes, they contain static methods that operate on external data, however, there is some data (per-game) the server has to have access to and it is stored in memory (as fields in classes). 1. Should I make it so the stateless part is shared across all games, that is, only one process with them is running? Then I need a way for all game-specific processes to send their computation requests to that shared process. Is this something the application server can help me with? 2. Should the game-specific data be stored in the database instead of memory? If so, I could make the whole game server part stateless because it will just read and write to the database as needed without holding any of it. I fear that this will impact performance. I know I will be able to test this, but was wondering if there are known designs already. Thanks again for all this.
Feel free to share your new versions here 
[removed]
I'm not really convinced the world is a better place since XML/XSLT/XPath/... went out of fashion.
`Optional::isPresent` returns a boolean not an Optional and imo the recent surge of method chaining examples over single statements is not only ineffecient but needlessly roundabout and bad code. E.g: * https://dzone.com/articles/optional-ispresent-is-bad-for-you (initial example is perfectly fine) * https://dzone.com/articles/java-pivot-table-using-streams (last example is one of the most horrible I've seen recently)
yes in that situation it makes sense to just pass the data down , but there are cases were some logic happends in the facade 
Correct me if I'm wrong, but I believe that is not the itent of the facade pattern. If you're splitting i.e. doing half your business logic in the facade and half in the service, then you're not using the pattern correctly. Some conversions or adaptations to data before passing it to the service is acceptable, doing more than that is however not the way the gof intended to.
you might be right :) 
I used it for writing my own annotation processors.
On &gt; Binary vs text is a bit like spaces vs tabs It's much more than that. This issue is about how pratical it is to override existing module descriptors when assembling an application from several modules needing adjustment. E.g. say you use two modules which both happen to depend on JPA themselves. But one is using EclipseLink's API definition, whereas the other one is using Hibernate's JPA API definition (both are different JARs deployed to Maven Central). Or one of your dependencies is using Commons Logging whereas you actually want to use the jcl-over-slf4j bridge. In a Maven POM file you could work with dependency exclusions to do so. Or, related, override versions of transitive dependencies to converge to a single version of one artifact. All this is easily done by applying some configuration in your application's POM. Now take the approach of embedding binary descriptors into modules themselves. For applying this kind of adjustments, you'll need to: * Re-create the source representation of the module-to-patch's binary descriptor * Adapt that descriptor as needed * Re-compile the descriptor * Re-add it to the module-to-patch It's not undoable and there surely will be tools to support you (one is https://github.com/moditect/moditect which I am working on), but embedding binary descriptors into modules essentially creates a problem which you wouldn't have with text-based descriptors living alongside to modules.
I'm not going to argue further with you after this post because I've seen your posts on reddit before, so I know this won't really end in mutual agreement to disagree. But I'd like to clean something up. &gt; So, in fact, you know nothing at all about their motivations, and are merely speculating. Thanks for owning up to that. I haven't speculated as to their motivations in either my blog post or here, as there's no need to - they lay out their motivations quite clearly in the document itself. They want people to not to use Jigsaw. That's a perfectly fine opinion to have, but there's no harm in others pointing that out and it isn't offensive to do so. &gt; Precisely. Red Hat simply is not promoting any other module system as a competitor to Jigsaw, and the suggestion is risable. That is a ridiculous assertion. The blog post in question appears on the jboss.org domain and contains a direct comparison between Jigsaw and various alternatives that is quite, quite clearly designed to make Jigsaw look as bad as possible. Moreover Red Hat is promoting Ceylon - the language it pays you to develop - and Ceylon uses JBoss Modules on the JVM. If Red Hat doesn't believe the module system it funds should be used anymore, then it should state clearly in the README that it's deprecated. If that isn't the case, a reasonable person would assume that Red Hat is in fact promoting its use. Otherwise why continue to pay people to work on it? You appear to be looking for ways to be offended on the behalf of others, then demanding apologies. Someone pointing out the fact that competition exists is quite simply not offensive. It is a *statement of fact* and facts should never be offensive. There is no problem with competition existing, nor is there any problem with the people who developed competitive systems explaining why they think their design decisions are right and other people's design decisions are wrong. Heck, it's good that people do so. But it's even better to own it. 
Perhaps you'd like to respond to the specific counter-points I raised then? I only picked a handful, after all. You seem to think that pointing out the backgrounds of the authors is some sort of ad hominem attack, when it isn't. It's actually vital to understanding the context of the dispute and the origins of many of your criticisms. The document frequently refers to "best practices" and Jigsaw's "reinvention" which leads to the obvious question - what best practices, and reinvention of what? The Java ecosystem is almost entirely unmodularised today so these sorts of sweeping statements can't be interpreted without understanding that you and the other authors come from a background of working with and developing other Java module systems. &gt; Since you are happy to indulge in ad hominem, I'll see you and raise some tu quoque: maybe you are looking forward to Jigsaw for the same reason? No. I am not a consultant and, as I stated clearly at the top, "have no dog in this fight", so I have been open about my own affiliations in this debate from the start (I have none). Frankly, I am surprised that you are surprised by this sort of response. The document you signed contains many direct attacks on Jigsaw and the people who made it ("ideological", "non-technical", "feedback was ignored", "cleanroom reinvention" etc) and goes so far as to suggest to *the entire Java ecosystem* that it *completely ignores* the *primary* feature of Java 9 ... officially signed by Red Hat. Did you really expect that nobody would ask basic questions like who are these people, and why are they so sure they're right?
Sure you were - by using wrong methodology for the type of work your team were doing. But for other cases it works just right. Same with FP - it has weaknesses, it has strong sides, it works best if you know what in OOP works and what doesn't, what in FP works and what doesn't and pick the right tool for a job. In Java's case I've seen that people seriously abused OOP by lack og FP features and absolutely abused `null` by giving it some other meaning than `some FNG didn't initialize all variables and retarted compiler didn't catched that`.
I thought Mike Hearn's post was a lot better than the expert group open letter and he was right to call them on some their weak and specious arguments. OSGI is lousy, always has been lousy and always will be lousy. The OSGI proponents have spent the last 18 years as king of the hill by virtue of getting there first and pissing at everyone who even suggests of displacing them. OSGI is not still here because OSGI won a technology competition. As a technology OSGI should have gone to the dustbin a long time ago but the more than decade long saga of Java modularity has allowed it to survive. Jigsaw and the several other modularity efforts which preceded it have taken far too long, cost way too much (both in attention and development cost), are too complex and generally have fallen short. Jigsaw is the path forward though even if it is barely limping over the finish line. My biggest worry with Jigsaw is that decisions made in Java 9 will be what we are stuck with forever. Some of the points from the letter like new really annoying agent policy aren't exclusively driven by Jigsaw. The same is true of the Unsafe debacle. Both Oracle and the community could do a better job of separating the contexts for various key issues. Unsafe, for example, can be discussed without reference to Jigsaw. The primary issues with Unsafe and the solutions are mostly independent of Jigsaw; why needlessly conflate everything together?
Because it moved to GitHub??? :X
IIRC, Java modules don't try to solve versioning. IMO, versioning requires a deep knowledge of the system is being built.
Play. [LinkedIn uses it for all their backend API services](https://www.slideshare.net/brikis98/the-play-framework-at-linkedin). See https://github.com/playframework/play-java-rest-api-example for example.
Segmenting the JRE into modules dates back from the days of applets and JNLP, when Java had to compete against the Flash runtime as the go-to rich client browser plugin. The weight of a new JRE download was seen as a major barrier then. Flash won, and would have anyway because the Flash tools were more adapted to the production of multimedia content. Today, Flash is dying and HTML + js rules, for better or worse. Java is no longer a contender in the rich webclient game. Anybody who needs JavaFX will install the JRE regardless of size. High bandwidth makes download size a non issue. See that recent discussion about the Electron-based Slack client taking 100MB... So Jigsaw is too little, way to late. It's nice in theory, but the amount of effort that was spent to get there is disproportionate to its utility, especially since it does not do versioning, which is about the only thing interesting it could have brought to developers of modern Java apps.
Most of the DDD tactics were intended for single-process, single-thread desktop applications, I wonder if we aren't doing disservice to people by pushing DDD when talking about microservices. Some of the terms are still valid and useful (value objects, entities, aggregates, context boundary, anti-corruption layer) but that's about it.
it doesn't do versioning yet, but it can in the future, so i'm happy about that. size is still p important. my colleagues have project for doing cluster computation and having it managed by the JVM, and they have to ship around the JVM to the cluster nodes to make sure they can run the execution managers. With jigsaw it sounds like they could make a much smaller jvm + jars bundle that gets shipped off. The big thing I'm interested in though is that modules enable for a lot stronger encapsulation than java has had available before.
What's wrong with that?
&gt; The blog post in question appears on the jboss.org domain and contains a direct comparison between Jigsaw and various alternatives that is quite, quite clearly designed to make Jigsaw look as bad as possible. The people who wrote the document want Jigsaw to be improved to handle their usecases. Which is why they worked within the EG to raise the problems they saw. &gt; Moreover Red Hat is promoting Ceylon - the language it pays you to develop - and Ceylon uses JBoss Modules on the JVM. JBoss Modules is indeed one of the options for using Ceylon on the JVM, along with several other options, including OSGi, a flat classpath, Java EE, and *Jigsaw*. And we've said for years that our plan was to migrate to Jigsaw as the primary module system for Ceylon as soon as it was available in Java 9. And that's still the plan. Which rather undermines your point that we're somehow promoting JBoss Modules over Jigsaw. &gt; If Red Hat doesn't believe the module system it funds should be used anymore, then it should state clearly in the README that it's deprecated. Java 9 isn't even released yet, and the Java ecosystem will take time to migrate to Jigsaw. So of course we need to continue supporting technologies that provide modularity on Java 8. &gt; You appear to be looking for ways to be offended on the behalf of others, then demanding apologies. No, I'm trying to correct the perception you're creating that Red Hat doesn't want Jigsaw to succeed.
&gt; Once you're in the binary world you can as well stay there Only that it requires other tooling (e.g. ASM or something sitting on top of it) and learning how to use that, i.e. two ways to achieve the same thing. Plus, when dealing with this in a build context, a declarative approach is desirable (so you e.g can put the configuration into your POM or similar). That's much nicer doable with a text-based representation. Again, tools will be able to help with that, but it's establishing an extra level of complexity. &gt; two separate modules that provide exactly the same thing is best fixed by people agreeing on a single module to provide it I don't think that's possible in general. It may be possible in the JPA case where the spec may define one commonly agreed on module name so that API definitions get interchangeable, but in other cases it won't. E.g. the slf4j Commons Logging Bridge is meant as a drop-in replacement for Commons Logging, there is no "single module" to agree on here. Should jcl-over-slf4j re-use the module name of Commons Logging? That may work but it seems not like good practice to me (even more so when thinking about derived names for automatic modules). In fact the entire idea that only ever one module defines a package is flawed IMHO. E.g. take javee-api.jar which contains stubs of all the Java EE APIs and is perfectly fine for compiling EE applications against it. An application server will provide the different APIs in different modules likely though (usually depending on the spec implementations they happen to use). That's a valid development approach to take, I don't think it's a hack or something which should be prevented. E.g. in Maven you'd simplify specify "provided" scope for the EE API JAR and be done, whereas embedding binary descriptors into modules makes this use case much harder to work with.
Mailboxes are FIFO (at least by default).
IntelliJ supports Gradle out of the box, but of course this is IBM so the tutorial spends twenty pages setting up Eclipse. And why on earth does the tutorial not assume some knowledge - I mean Git from first principles, really? TLDR: &gt; git clone https://github.com/makotogo/ChaincodeTutorial.git &gt; Here's `putState(String key, String value)` &gt; Here's `getState()` &gt; Implement `getChaincodeID()` &gt; Implement `handleInit()` &gt; Implement `handleQuery()` &gt; Implement `handleOther()` &gt; Use SoapUI (!!) to submit JSON &gt; Welcome to the future (!!) PS: Justification for SOAP UI: &gt; Your browser can issue an HTTP GET, but to interact with the fabric you need to be able to POST messages. This means you need an HTTP client. Or you could just use a Chrome extension... I mean SoapUI is a massive bloated heavyweight tool because it's designed for the massive bloated thing that is SOAP XML. Whereas a browser extension is a thin tool that uses your existing browser UI.
LinkedIn uses it via Scala. Probably nobody uses it from Java, because it is such a big pain to use from Java. Almost zero documentation, all classnames are duplicated, integrations only halfway implemented. Biggest joke: Play Java depends on Spring.
AutoValues, FreeBuilder, Immutables.
I already tried that from my attempts to Google the issue but it didn't work - thank you though. A second reinstall of Eclipse seems to have fixed it - maybe I wasn't thorough enough the first time? Very strange.
Apache Tomee. Ok, yeh, I know, its a server....., which you deploy your apps to. BUT what exactly is the definition of a 'microframework' ?
[removed]
[removed]
ML has hardly anything to do with OOP or even Java. And it takes another few decades to get self-learning systems. Currently, the state of the art is either supervised, unsupervised or reinforced learning where unsupervised is probably the closest to self-learning, but it is only a fancy memory and has a hard time resulting new facts. You should probably read up the whole thing again. You will not understand the concepts from reading the definitions. It took me few months to get into that. A perceptron is an easy start if you want to get to it from the programming side, but if you want to understand it, you require the math and probabilistic models behind the algorithms.
&gt; LinkedIn uses it via Scala. Probably nobody uses it from Java, because it is such a big pain to use from Java: The userbase from downloads is about 50/50. &gt; Almost zero documentation, all classnames are duplicated, integrations only halfway implemented. Java documentation is here: https://www.playframework.com/documentation/2.5.x/JavaHome &gt; Integrations only halfway implemented Integrations with what? You don't specify. &gt; Play Java depends on Spring Play Java's Form Validation support depends on [bean validation](http://beanvalidation.org/) and uses Hibernate Validator under the hood. This is because there are basically two [bean validation implementations available](http://beanvalidation.org/1.1/certified/). Here's the dependency: https://github.com/playframework/playframework/blob/master/framework/project/Dependencies.scala#L86 Some people don't need that dependency, so in Play 2.6, the forms implementation is split out into a different module: https://github.com/playframework/playframework/tree/master/framework/src/play-java-forms/src/main/java/play/data Of course, Play is dependency injection agnostic, so you can run Play on Spring DI if you like (I see you opened https://github.com/remithieblin/play-spring-loader/issues/2 a few days ago): https://github.com/remithieblin/play-spring-loader But you can also do things like compile time dependency injection with [Dagger 2](https://google.github.io/dagger/): https://github.com/playframework/play-java-dagger2-example which is much smaller and lighter than runtime DI systems like Spring or Guice. Or you can not use any DI framework at all, and specify the application loader directly: https://github.com/playframework/play-java-compile-di-example 
I think that unfortunately there is none, other than just catching the super class of these, but this is not a good solution in my opinion. If you have many controllers, you can use @ControlerAdvice to write these handlers in one place for all controllers. Still, you have to write a handler for each exception. I don't know any other way.
This post is also being discussed in parallel, [here](https://www.reddit.com/r/java/comments/65kdm2/critical_deficiencies_in_jigsaw/dgb5zsm/)
It's broken by design: multiple Eclipse plugins can each claim ownership of the same keyboard shortcuts, and no sensible mechanism exists to mediate. You can't ever truly fix it, because Eclipse's plugin dependency management system is also broken by design. You might try and install a pre-baked Eclipse distribution, but then if you try and upgrade or install plugins (surely the whole point of having a plugin architecture), your workspace(s) will become broken in new and interesting ways. All you really want is to separate your source code into different projects, but in the strange world of Eclipse you'll find that the application's *behaviour* will then vary per project, thanks to the twin horrors of "perspective" and "workspace"; note that no other application has these concepts, because they are terrible ideas. Eclipse is an utter fiasco. They had their chance, and they blew it. Use IntelliJ, everyone else does.
I think the key is just to understand the tradeoffs of different programming paradigms and use the right paradigm for your problem. OO is not the optimal solution for all problems, but for most large-scale systems OO is an excellent tool. 
impression after a quick glance, your indentation is not consistent, and makes it hard to read and follow. An IDE plugin should fix those for you. Also look into replacing system out with a logging system. FXML elements should not need to have their type prefixed in their name. it looks as a cool project :) I dont know what IDE that you use but, try see if you can install the PMD and checkstyle plugins. this will also be a benefit for contributors if there is some standard to follow. https://pmd.github.io/ https://github.com/checkstyle/checkstyle
I definitely like streams better for "simple" collection operations, like finding certain elements and doing something with said elements. But I still use for-loops. The thing about streams is that you should aim to never use curly braces ({}) in your stream flow, this kills the readability and ease of understanding you're trying to achieve by using streams.
Get Intellij.
Oh thanks. This really helped me out. Do you know of any other articles or papers discussing the limitations of Javas networking ability?
Man a lot of programmers really like using fxml with javafx. I just put the declarations in my java files : ex. `TextField t = new TextField();` and then put the styling in the css file. 
That is pretty ugly, since Java doesn't have pattern matching yet. I'd agree that the more side-effecting your code, the less useful strong typing of values will be. But I think the strong, static typing Java uses assumes that much of the time you're transforming and using data, not just shoving it into some `Object -&gt; void` method and never referencing it again.
You got an SSL issue. 
Like: https://pastebin.com/1s66f0m9 *Edit: moved snippets to pastebin to unclutter post.*
Since you mentioned IntelliJ [here](https://www.jetbrains.com/help/idea/2017.1/keyboard-shortcuts-you-cannot-miss.html) are some useful keyboard shortcuts to make your life easier. My favourites are `Ctrl + Alt + L` to reformat the current file (that should fix your indentation!) and `Alt + Enter` when there's an error to highlight quick fixes.
Correct, JPMS does not try to solve versioning. My hope is that it will in the future. The spec has left the door open to do that, and I wouldn't be surprised if the did in one of the next major versions.
I find them all horrible. It's exactly the kind of code that happens when you don't do OOD. E.g. `Map&lt;String, Set&lt;User&gt;&gt;` bullshit code.
Immutables is good
I'm not into enterprise/business stuff but this looks pretty good. My only *real* criticism would be that you used buttons instead of a TabbedPane. If you did it would be easier to expand the GUI with new information and it would add a ScrollPane(? I don't remember the class) so if you have more than fits on the GUI it will still work. Besides that, you are also wasting a bunch of screen space on screenshots 2,3,5,6, and 8 that could be used to display more information... but that's just a GUI thing. BTW the License for a project on Gitub is stored in the license file which can be generated by Github somewhere. I think if you create a new file in the root and call it "license" it will auto detect and give you the option for specifying the license.
I'm on mobile so I didn't get a chance to look at a lot of the code, but in your MenuController you are using strings that you pass on to App to determine what view/page should be shown. Using an enum would be more efficient then comparing strings.
big fan of tabbed panes as well. Though I do like to put buttons on the side separate from that tabbed pane to interact with the information on that tab. So no matter which tab you are on, the core/universal interaction buttons (CRUD) are located at the same place.
https://i.imgur.com/PpV0evc.png
Using fmxl is still really part of your view. Personally, I find writing Java code to structure your view to be painful. I think using scene builder would be much better.
Holy crap... I thought this was about Ruby and Java...
Also you can use that shortcut to format entire folders at once if you select them. 
Similar to logback's [CVE-2017-5929](https://nvd.nist.gov/vuln/detail/CVE-2017-5929?cpeVersion=2.2)?
I mean, as someone really is used to swing, sticking everything in the V is a lot easier.
Another episode in "don't deserialize untrusted data". 
Sounds about the same problem in the same feature.
Thanks, I will try out TBD with maven release plugin. I tried jgit-flow plugin for Git Flow, and while it seems to work OK, it produces lots of merge conflicts and maybe is overkill for a 1 or 2 devs in a corporate environment. GitLab's runner is free (there is also commercial version of GitLab), you just put a config file for Runner inside repo (you include commands you would run with jenkins in there), and GitLab will run it on say push, if desired. It will run the jobs inside the container if needed, or localhost (for example bash commands). GitLab is being a candidate because it supports a all-in-one code/docker repository/CI/CD environment and it is easier for the system or ops team to maintain, instead of several apps. It would also make code sharing inside organization easier (it is very similar to GitHub)
Hi, I think the book "Just Hibernate" is very good to start to learn hibernate: http://shop.oreilly.com/product/0636920026174.do I would also recommend to learn spring data if you are into the Spring Framework because it is very useful: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ I hope this helps you!!
Thanks for your suggestions. "Just Hibernate" looks like an introductory book, so I'm not sure how much value does it bring over the official User Guide. I'm more interested in some advanced books that cover proven **best practices**, patterns and anti-patterns related to JPA and Hibernate
This is actually out of date it seems the site still has old links. The up to date version is here: https://github.com/akullpp/awesome-java/
Any Manning book is worth getting. They're the Oreilly of Java books. I did read the JPA/Hibernate book about 4-5 years ago and it was a good introduction. The second edition should cover a lot of changes over the last few years. I don't think annotations were that well used when the first book came out.
And you won't believe what sits under LIST OF USEFUL FRAMEWORKS / LIBRARIES / SOFTWARE on the sidebar of this sub-reddit...
Thanks. Manning offers the Java Persistence with Hibernate 2nd edition which looks very interesting. O'Reilley offers justs two books: - Harnessing Hibernate, which is from 2008, so it might be outdated by now - Just Hibernate, which is from 2014, but it looks like a beginners book, it has just 140 pages, and the score is 3.5 out of 5. From Apress, "Hibernate Recipes" has also just [3.5 stars on Amazon](https://www.amazon.com/Hibernate-Recipes-Problem-Solution-Approach-Experts/dp/1430227966).
@BlueGoliath Yeah, a tabbed pane sounds better indeed. Will consider. Thanks. @altrdgenetics Good idea for buttons!
No, its better because it is not condensed in some predefined method chain that is a pain to refactor and also debugs as shit. The reading flow is also horizontal instead of vertical. Btw I didn't programm Java for 10 years already by far. Maybe 3.
&gt; its better because it is not condensed in some predefined method chain that is a pain to refactor and also debugs as shit. Explain? I can easily set a breakpoint on that line and then evaluate the "userRepository.get(userId)" bit?
Does not include Java 8 but https://www.amazon.co.uk/Effective-Java-Second-Joshua-Bloch/dp/0321356683 fits the bill of the Java k&amp;R 
Missing integrations: Other buildsystems than sbt: Only experimental plugins available lacking features. IDE integration: require commercial plugins. Spring DI integration: requires 3rd party plugin, no support for testing in Java. Bean validation only documented for JSR-303, not JSR-349. Play2 Java does not just depend on Hibernate Validator, it depends on Spring. Just look 2 lines below what you've linked: https://github.com/playframework/playframework/blob/3c6eea8c9df51c519dceab7a0f0dde6386914151/framework/project/Dependencies.scala#L88
Make sure you use canonical links when linking to a file/directory on GitHub. On GitHub, you can press the "y" key to update the URL to a permalink to the exact version of the file/directory you see -- [source](https://help.github.com/articles/getting-permanent-links-to-files/). I've tried to fix your links: Relative | Canonical -|- https://github.com/playframework/playframework/blob/master/framework/project/Dependencies.scala#L88 | https://github.com/playframework/playframework/blob/3c6eea8c9df51c519dceab7a0f0dde6386914151/framework/project/Dependencies.scala#L88 Shoot me a PM if you think I'm doing something wrong.
Depends on what you want. Java has and probably always will have a much larger market share. Scala probably won't die any time soon though and it could make you stand out more than someone who just knows java. 
The third edition should be released this year.
so it's java rotated by 180-degree, see: http://blog.vavr.io/content/images/2017/04/vavr-1.png
@ArgTang and other, I just used IntelliJ IDEA's tool to reformat - does it look fine in your editors? Thanks :)
OP -- thanks a lot -- I was looking to ask some similar questions. Here is my post on /r/javahelp please chime in https://www.reddit.com/r/javahelp/comments/662v4k/what_are_the_relationships_between_jpa/
You don't have to build web applications in Play using Scala. [You can build web applications in Play using Java](https://www.playframework.com/documentation/2.5.x/JavaHome). I'm not sure where you got that idea. Play downloads have increased every year, so probably you're just seeing less media reports about it. This happens with every technology as the early adopters are all familiar with it and the pragmatists move in. Also, looking at your post history you seem to be looking for a framework, but it's not clear what your target is and where you want to be from a technology standpoint. What's your background? Do you have any experience with web applications? 
&gt; Other buildsystems than sbt Do you mean the [Gradle](https://docs.gradle.org/current/userguide/play_plugin.html) and [Maven](https://github.com/play2-maven-plugin/play2-maven-plugin) build systems? It helps if you have details. What features were you lacking? Spring integration hasn't been a priority in the past, partly because many of the people coming to Play are explicitly walking away from Spring, and are comfortable with JSR-330 type semantics. IDE Integration: I assume you're talking about IntelliJ IDEA and the Play integration there. We have no control over that. Bean validation: I think there's been some discussion, but I have not seen anyone ask for JSR-349 before. Looking at the issues, there's 2 closed bugs https://github.com/playframework/playframework/issues?q=is%3Aissue+JSR-349+is%3Aclosed &gt; Play2 Java does not just depend on Hibernate Validator, it depends on Spring It's Hibernate Validator transitive dependencies. Those lines are there so that Spring gets pruned down to the minimum.
After more and more research, I'm starting to reach this conclusion myself.
I liked ["Core Java"](https://www.amazon.com/Core-Java-I-Fundamentals-10th/dp/0134177304/ref=sr_1_1?ie=UTF8&amp;qid=1492525488&amp;sr=8-1&amp;keywords=core+java), but it is not as concise as Kernighan/Ritchie. 
Here is one way to fix it ;-) https://www.jetbrains.com/idea/download
[Java Concurrency In Practice](https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=sr_1_1?ie=UTF8&amp;qid=1492187231&amp;sr=8-1&amp;keywords=Java+Concurrency+in+Practice)
First of all, JPA is a standard or specification and Hibernate is an implementation of that standard. Spring Data allows you to develop faster since it creates for you a CRUD API so you do not need to implement manually the DAOs, your only concern is to write the query but everything that Spring Data does can be done implemented the DAOs manually.
First of all, nice to see some developers from Bosnia. Just some tips: In App.getView(String viewFile) you do: String viewPath = System.getProperty("user.dir") + "/src/main/resources/views/"; java.net.URL viewRes = new java.net.URL("file://" + viewPath + viewFile + ".fxml"); activeElement = FXMLLoader.load(viewRes); That is crap (sranje), because when you deploy the application you usually don't ship the sourcefiles, so the viewFile.fxml-Files won't be available. The correct way is to use a class and call getResourceAsStream("relativ-Path-name") on that. With this approach you can also get resources in a jar-File, which is otherwise impossible. About every Beginners-Guide to JavaFX shows this aproach. Your JDBCQueryBuilder is a really bad idea. Building querys with String-concatination is the highway into sql-injection. Always use PreparedStatements if working with jdbc unless you know what you're doing, than you won't do it. This stands not only for Java. But now you're using Hibernate. In App.showPage you are using "Magic Strings". The better way is using Enums (global accessible Constants). Is "newproduct" written with a Capital P or lowercase p? Enums solve this, by providing Enums and showing errors at compiletime.
Yeah, I love Core Java. 
[Thinking in Java](http://mindview.net/Books/TIJ4) is quite popular, though the newest edition is a little out of date.
/r/javahelp
IMHO this can be broken down into 2 categories of front ends, web and desktop apps. JavaFX or swing are typically used in desktop apps. They can be used in web apps also but it requires applets or java plugins (NPAPI) with neither being browser independent so are not the best choices when launching web apps but are great for desktop apps. Web apps work well when it is browser independent and that is typically achieved by dynamic rendering of HTML. The standard way is typically through Java Server Pages (JSP) or other templating engine (example of a new emerging one is Thymeleaf). Since these render HTML/JavaScript they don't require any special browser plugins and are more conventional in the sense of Java web development.
You can use play with java
It's far more than a "little out of date." If you were to learn Java from this book today, you'd find almost all code written in the last five years to be very foreign. This was a good book in its time, but can no longer be recommended due to how much the language has advanced.
Well, most of the time when you're talking about "front-end" versus "back-end", you're talking about a client-server type of app. Java would probably be okay for asynchronous connections, but since a synchronized connection is basically a state machine, the safer practice is to use something a little more snappy than an interpreted language like Java. On the one hand, you have a compiled language. You write the source, compile it, and it just fires up and makes calls right away to the graphics runtime engine. On the other hand, you have to build your Java project every time you run it, the bytecode has to be interpreted by the JVM, and the JVM has to juggle managing the bytecode and making calls to the GRE.
Is an excellent book in its own right, but is in no way a Java equivalent to K&amp;R.
It's ignored by APIs in favor of JSON, for the same reason a myriad of better protocols have been ignored by APIs in favor of HTTP: it's popular, everyone knows it, everyone has libraries for dealing with it, and it's text-based so easy to produce, inspect and debug. Most APIs are *not* in the business of saving 10% of their traffic on API messages, most of which are less than 1kb in size. Most APIs are in the business of reaching users and developers, and providing a service that's completely orthogonal to their byte-pushing throughput. Once bandwidth and efficiency becomes important, there are dozens of mature, efficient binary protocols you can send over TCP and UDP, like Protobuffs, Thrift, Cap'n Proto etc. Having a RFC at IETF doesn't guarantee your thing will be popular. JSON didn't have RFCs at IETF *until long after* it became popular. And it became popular because Douglas Crockford discovered that a specific declarative subset of JavaScript is useful for data exchange. And because everyone had JavaScript, it picked up as a data exchange format for browsers - the encoder is trivial, the decoder is built-in. Can't say the same about CBOR.
Look in upper right of page. See under New Downloads. Find Java SE 8 update 131. After following that link, find links to JDK, Server JRE and JRE.
For web apps I'd say the new paradigme is to create a restful api and then interact with that using a client side framework such as angular, vue or react. This way you can "easily" create a mobile app too.
The plugins to build and deploy? Well, it's most often just mvn clean package and deployment happens via copying a war. IDEs these days all support all current servers, so there's hardly a big difference there. And there are a number of custom features that your app can use, so it requires some porting, but the amount of work is often a few days to a few weeks at most. And yes, people do this. Where do you think the applications running on Orion and Geronimo went to? Your last point is shockingly inaccurate and actually insulting to both Java EE vendors and Java EE users. It's absurd actually. I talked to David from TomEE once and money is absolutely not pouring in, neither does it for Payara and JBoss, and to the best of my knowledge not even for Oracle. All of them have to constantly innovate their products and fix bugs. Just look at all the commits being done for the WildFly project alone each and every day, and then look at the commits for its components like Hibernate and Weld. 
From everything I have seen from the Jigsaw folks they'd prefer to ignore OSGI and not even talk about it. It could also be easily argued that OSGI has used political means extensively throughout their entire history and have aggressively sought to prevent any challengers without ever actually being good technology.
I thought Effective Java was more of a "best practices" for developers that are already fairly experienced with the base Java language? K&amp;R is more of a terse but comprehensive overview of the entire C programming language.
Spring MVC and JSF is probably the two most used.
I've heard good things about ["Core Java for the Impatient"](https://www.amazon.com/Core-Java-Impatient-Cay-Horstmann/dp/0321996321), also by Horstmann. It's still not as concise as K&amp;R, but it seems to be as close to it as you're going to get while still up to date with Java 8.
If I had to do a Java desktop app I would look at Java FX.
&gt; The comment about saving 10% payload size is disingenuous - when payloads are large arrays of doubles, message size can be halved. My comment is not disingenuous, I just know what type of content most APIs take and return. And structures/maps are a huge part of the content. String values are in the same ballpark. Integers and booleans are next, and last are floats and nulls (though well factored JSON has no nulls at all IMHO, but never mind). Formats like Thrift and Protobuff have a way to dramatically reduce the size of structures/maps and strings representing enumerated values, through the use of schemas. CBOR, like JSON, has no schemas, so a lot of your payload will have to be string keys and string values. I wouldn't be that rash and call your comment "disingenuous" for implying that "large arrays of doubles" are a typical examples of API data exchanges, but they aren't typical, so switching your format just for this would be a bad idea. And your own article demonstrates JSON being more compact on integers, and losing by 20% margin for text. Which is **before** compression. GZip those, as most HTTP APIs do, and the margins might end up around 10% for typical messages. Additionally if my API requests/responses are *atypical* anyway, and contain an abnormally large arrays of floats, I can always optimize for this occasion, and send the array as a packed blob encoded in [Ascii85](https://en.wikipedia.org/wiki/Ascii85) format, a parser for which can be written and/or assembled from existing components in less than an hour on any language. A significantly smaller effort compared to implementing the entirety of CBOR, just so you can get smaller floats. I'm just being pragmatic and realistic. 
Learn any SPA (angular, react, vue), disregard java as a frontend option.
Changes security-libs/java.security MD5 added to jdk.jar.disabledAlgorithms Security property This JDK release introduces a new restriction on how MD5 signed JAR files are verified. If the signed JAR file uses MD5, signature verification operations will ignore the signature and treat the JAR as if it were unsigned. This can potentially occur in the following types of applications that use signed JAR files: Applets or Web Start Applications Standalone or Server Applications that are run with a SecurityManager enabled and are configured with a policy file that grants permissions based on the code signer(s) of the JAR file. The list of disabled algorithms is controlled via the security property, jdk.jar.disabledAlgorithms, in the java.security file. This property contains a list of disabled algorithms and key sizes for cryptographically signed JAR files. To check if a weak algorithm or key was used to sign a JAR file, one can use the jarsigner binary that ships with this JDK. Running "jarsigner -verify" on a JAR file signed with a weak algorithm or key will print more information about the disabled algorithm or key. For example, to check a JAR file named test.jar, use the following command: jarsigner -verify test.jar If the file in this example was signed with a weak signature algorithm like MD5withRSA, the following output would be displayed: The jar will be treated as unsigned, because it is signed with a weak algorithm that is now disabled. Re-run jarsigner with the -verbose option for more details. More details can be displayed by using the verbose option: jarsigner -verify -verbose test.jar The following output would be displayed: - Signed by "CN=weak_signer" Digest algorithm: MD5 (weak) Signature algorithm: MD5withRSA (weak), 512-bit key (weak) Timestamped by "CN=strong_tsa" on Mon Sep 26 08:59:39 CST 2016 Timestamp digest algorithm: SHA-256 Timestamp signature algorithm: SHA256withRSA, 2048-bit key To address the issue, the JAR file will need to be re-signed with a stronger algorithm or key size. Alternatively, the restrictions can be reverted by removing the applicable weak algorithms or key sizes from the jdk.jar.disabledAlgorithms security property; however, this option is not recommended. Before re-signing affected JARs, the existing signature(s) should be removed from the JAR file. This can be done with the .zip utility, as follows: zip -d test.jar 'META-INF/.SF' 'META-INF/.RSA' 'META-INF/*.DSA' Please periodically check the Oracle JRE and JDK Cryptographic Roadmap at http://java.com/cryptoroadmap for planned restrictions to signed JARs and other security components. JDK-8171121 (not public) core-libs/java.net New system property to control caching for HTTP SPNEGO connection. A new JDK implementation specific system property to control caching for HTTP SPNEGO (Negotiate/Kerberos) connections is introduced. Caching for HTTP SPNEGO connections remains enabled by default, so if the property is not explicitly specified, there will be no behavior change. When connecting to an HTTP server that uses SPNEGO to negotiate authentication, and when connection and authentication with the server is successful, the authentication information will then be cached and reused for further connections to the same server. In addition, connecting to an HTTP server using SPNEGO usually involves keeping the underlying connection alive and reusing it for further requests to the same server. In some applications, it may be desirable to disable all caching for the HTTP SPNEGO (Negotiate/Kerberos) protocol in order to force requesting new authentication with each new request to the server. With this change, we now provide a new system property that allows control of the caching policy for HTTP SPNEGO connections. If jdk.spnego.cache is defined and evaluates to false, then all caching will be disabled for HTTP SPNEGO connections. Setting this system property to false may, however, result in undesirable side effects: Performance of HTTP SPNEGO connections may be severely impacted as the connection will need to be re-authenticated with each new request, requiring several communication exchanges with the server. Credentials will need to be obtained again for each new request, which, depending on whether transparent authentication is available or not, and depending on the global Authenticator implementation, may result in a popup asking the user for credentials for every new request. JDK-8170814 (not public) core-libs/java.net New system property to control caching for HTTP NTLM connection. A new JDK implementation specific system property to control caching for HTTP NTLM connection is introduced. Caching for HTTP NTLM connection remains enabled by default, so if the property is not explicitly specified, there will be no behavior change. On some platforms, the HTTP NTLM implementation in the JDK can support transparent authentication, where the system user credentials are used at system level. When transparent authentication is not available or unsuccessful, the JDK only supports getting credentials from a global authenticator. If connection to the server is successful, the authentication information will then be cached and reused for further connections to the same server. In addition, connecting to an HTTP NTLM server usually involves keeping the underlying connection alive and reusing it for further requests to the same server. In some applications, it may be desirable to disable all caching for the HTTP NTLM protocol in order to force requesting new authentication with each new requests to the server. With this change, we now provide a new system property that allows control of the caching policy for HTTP NTLM connections. If jdk.ntlm.cache is defined and evaluates to false, then all caching will be disabled for HTTP NTLM connections. Setting this system property to false may, however, result in undesirable side effects: Performance of HTTP NTLM connections may be severely impacted as the connection will need to be re-authenticated with each new request, requiring several communication exchanges with the server. Credentials will need to be obtained again for each new request, which, depending on whether transparent authentication is available or not, and depending on the global Authenticator implementation, may result in a popup asking the user for credentials for every new request. JDK-8163520 (not public) tools/visualvm New version of VisualVM VisualVM 1.3.9 was released on October 4th, 2016 http://visualvm.github.io/relnotes.html and has been integrated into 8u131. See JDK-8167485 Bug Fixes The following are some of the notable bug fixes included in this release: client-libs/java.awt Introduced a new window ordering model On the OS X platform, the AWT framework used native services to implement parent-child relationship for windows. That caused some negative visual effects especially in multi-monitor environments. To get rid of the disadvantages of such an approach, the new window ordering model, which is fully implemented at the JDK layer, was introduced. Its main principles are listed below: A window should be placed above its nearest parent window. If a window has several child windows, all child windows should be located at the same layer and the window from the active window chain should be ordered above its siblings. Ordering should not be performed for a window that is in an iconified state or when the transition to an iconified state is in progress. These rules are applied to every frame or dialog from the window hierarchy that contains the currently focused window. See JDK-8169589 security-libs/javax.net.ssl Correction of IllegalArgumentException from TLS handshake A recent issue from the JDK-8173783 fix can cause issue for some TLS servers. The problem originates from an IllegalArgumentException thrown by the TLS handshaker code: java.lang.IllegalArgumentException: System property jdk.tls.namedGroups(null) contains no supported elliptic curves The issue can arise when the server doesn't have elliptic curve cryptography support to handle an elliptic curve name extension field (if present). Users are advised to upgrade to this release. By default, JDK 7 Updates and later JDK families ship with the SunEC security provider which provides elliptic curve cryptography support. Those releases should not be impacted unless security providers are modified. See JDK-8173783 This release also contains fixes for security vulnerabilities described in the Oracle Java SE Critical Patch Update Advisory. For a more complete list of the bug fixes included in this release, see the JDK 8u131 Bug Fixes page.
The convention these days is to use Java on the backend for the so-called "heavy lifting" and put a REST API in front of it. Then use a native API on your client which then calls the API as needed to get stuff done. This is great for SaaS, 2 or n-tier architecture, and architectures where you don't mind implementing a different UI per supported platform. It's not typical for a desktop line of business (LOB) app that you want to use across multiple platforms though that won't be distributed at all. However, even most LOB apps tend to be distributed these days to some extent, so even if you do use JavaFX + Java on the client, you're probably still going to have a back-end aspect of it. Really, the only time you wouldn't have more than one tier these days where you could split using Java on the server vs. native on the client would be games like Minecraft. And even then, you could still split it that way depending on the needs of your domain. Java may have been intended to be WORA, but really it turned into "write once, run on any server". The client story around Java has been far less successful.
Does it need log4j 1.2.17? - what happens if my project uses a different version? &gt; You can use &lt;exclusion&gt; https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html or better let Maven do the work for you. Just check it with 'mvn dependency:tree'. Or even better you can do new branch for java8. 
I was thinking about how to get FXML source when deployed and now I probably have solution. :) Yes, the query builder is deprecated and I should remove it for sure. Enums, going on Todo. Thanks for suggestions.
JSON has won the "It's good enough" and "Easy to use and consume" battles. I was at an IoT company and we were looking at CBOR at one point because we thought customers would want compact binary encoded messages for bandwidth reasons. Nope. The demands were usually JSON or XML and bandwidth be damned.
These are interesting, but premature optimisation is a problem for quite a lot of these examples. In the vast majority of cases, readability and maintainability &gt; minor performance gains. CPU is cheap; developers are not. For example, in 6: public boolean oddOrNot(int num) { return (num &amp; 1) != 0; } Performant, yes. But sticking bitwise operators in your code is a surefire way to lose clarity. 
Sure, I just thought that usually you do a web application and a mobile... But very true, in lots of cases you also have a desktop app as well. But the important point to be made here is that nowadays we have a common API which clients interact with. Rather than the more embedded "JSP" approach.
It would be far better to just annotate the function as `@Nullable` and let your IDE warn you if you don't check in the calling code. An alternative is to return an `Optional` and force the caller to check, but that's possible an overkill for this example of a simple String. But, yeah, not even going to compile. Also, for #14, it's probably more readable to use something like Guava's `Preconditions.checkNotNull()` method. Also annotate the parameter with `@NotNull` too. And don't forget the javadocs :)
your right! My boss mentioned that to me
You can easily solve the problem with their code by inverting the condition. public boolean oddOrNot(int num) { return num % 2 != 0; }
I am still quite new to Java and chose Eclipse just because the guy doing the tutorials I followed did and it was easier to setup that IntelliJ. Am downloading now and will give it a go - thanks for the in-depth response!
I'm not trying to be a dick, but I don't know what the fuck you are talking about.
_30 Java 1.4 Programming Tips_
The problem IMO with Java's frontend UI APIs is that they are way too memory heavy. If you were to create a simple desktop application with around 20 UI componenets using a native language(C/C++) it might only take 20MB at most, however in Swing/JavaFX it takes 140MB. It doesn't use a native theme to it's host which is also pretty bad IMO. That's the only reasons that I can see using Java's Swing or JavaFX as bad.
Call the method isOddNumber, make it static and put it in util are more relevant than bitwise blackmagic, as long as that is in a well named function and not littered over the code
There's nothing to stop you from using Java + Scala together either.
Sounds like nervous rambling by a job interviewee
&gt; 2. Use Strings carefully Regarding concat, Not a problem in java 8 anymore i thought?
Apparently so is mywot.com https://safeweb.norton.com/reviews?url=mywot.com I clicked your link and immediately got prompted to download an updated version of chrome...
what? web of trust is a completely safe site.
I don't know if you're being sarcastic and I don't know how reliable the search results are, but a quick search for "is mywot.com safe" yields the following links with postings that seem to challenge your assertion: * https://productforums.google.com/forum/#!topic/websearch/JjgmtMoF2UI * https://www.quora.com/Is-the-WOT-Web-of-Trust-extension-reliable * https://www.trustpilot.com/review/www.mywot.com To be fair some of the negative stuff seems to me to have a conspiratorial tone, which is always suspect. 
This makes me feel so less bad about what I see on a daily basis.....in all fairness it's getting better and it wasn't long ago (and sometimes I still find myself) when I was doing some ridiculously idiotic thing that I just wasn't smart enough to know yesterday.
Yes, that's the recommendation. A Collection has the isEmpty method which you can test against and have your repositories return empty collections when nothing is found. 
RIP. I just went to the site on my desktop computer and it did the same chrome auto-download thing. Guess I'll be uninstalling. Such a shame since it was a good tool, but like many products like it, the massive amount of power the developers have with such a large user base often leads to corruption. Of course, it is hard to tell if any of the claims are valid like you said, other than the chrome download scam.
PERSONAL PROJECTS. Try and tie it into stuff you enjoy. Working for a company you are going to build what they are focused on at the moment....if their eye is not on the ball...yours won't be either. You're probably more likely to advocate for better stuff if you have a greater self interest. There's tons of cool things going on....Artificial Intelligence, Image Recognition and manipulation, interfacing with hardware components, data pipelines, microservices.....tons of cloud services and toys.... Think of what you do regularly that you don't enjoy, and find a way to automate or program it.....I think you'll potentially find some side projects that you enjoy and it will incentivize you to learn more. And don't be afraid to drop the project. It's important to stick to things and finish them so make it small, but if you accidentally bite off more than you can chew, drop it and move on. It should be fun...it's your life!
Pick one and stick with it. Python, Java and C# are all great for beginners. 
&gt;and/or I don't have any original ideas to pursue and excite me...). this
For the most part code wise your interfaces, implementations, and annotations should be the same. They all implement JAX-RS. Where I've found things being different is how you services are registered in the web app as each has multiple ways of doing this. You can use blueprint, annotations, or just plain java to register them when deploying in your container.
I certainly am. It's going to show up more and more in the APIs, it provides natural safe parallelism if you want it, and it's very clear. Having lambdas does tend to reduce the pressure to put as much into class hierarchies. For example, suppose I want a flexible object pooling system. I could have an abstract base class and then require that a user of this class subclass it to provide those functions (to create an object; to reset an object to its initial state). Alternately, using lambdas I could have a concrete class that just requires that one passes in lambdas for those capabilities: final ObjectPool&lt;MyType&gt; pool = new ObjectPool&lt;&gt;(capacity, MyType::new, MyType::reset); or equivalently (but less compact): final ObjectPool&lt;MyType&gt; pool = new ObjectPool&lt;&gt;(capacity, () -&gt; new MyType(), t -&gt; t.reset()); No need for a MyTypeObjectPool subclass. 
Thanks so much! 
Yeah when it mentioned `Vector` and `Hashtable` as typical collections at the end I double-checked the date on it.
YouTube is a great source to view tech talks. Just type in "java conference" and browse around. But the truth is there's plenty of work in Java and the ecosystem advances very slowly.
I haven't heard anything along those lines regarding the "+" operator to do concat. I believe Java 8 did add a StringJoiner class, but that just uses a StringBuilder under the hood
If you want to learn the foundation of computer science and fundamentals of computer software, Core Java is the best way to go. I think it is the easiest to learn about object oriented programming. Then learn python. It will pay off in the long run if you are wanting to learn python as your language of choice. C# is great to learn if you plan to cater to windows and web environments. However if you decide to join the Linux club then C# does not favor too well. (I guess none really do now that I think about it). On that note however, if you really want to learn what it is like to truly program a computer and get into the serious developer game, learn c (c first then c++). This will teach you exactly how programs work, and will make you a much better dev. Some will say that there is no need for c or c++ anymore but I beg to differ. Java has come a long way but most situations with Java require a JVM to run. All that being said, if you are just looking for a general knowledge on basics then Any one of them will work. Java is most popular and has the widest range of use. Python is newer and some consider it an "easier" Java. I haven't programmed with C# myself from scratch but from what I've witnessed, it seems to be the windows leaning version of Python. 
25 year career software developer here. Probably my most valuable source of the latest news for developers is the front page of Hacker News. I usually pick out a few articles to read each day. HN has a skew towards web/Javascript, but it gives a surprisingly broad overview of what's new and interesting, and if something interesting happens in the Java ecosystem it often is covered on HN. For example, I'm pretty sure I first heard of Dropwizard on HN. When thinking about keeping up with the industry, look beyond just the Java ecosystem. If you continue in your career as a developer, then the chances are good that 10 years from now you will be doing something very different than what you are doing today. That's a good thing! Change is what will keep your career interesting. There's a lot of velocity right now in the Javascript ecosystem and mobile (iOS, and Android). Keep up with what is happening in databases, since DBs are always relevant. Machine learning is growing fast, and its very different than what most software developers do. As for side projects, a good source of ideas is your work. Find a process or activity that you use at work and make it better/faster/easier/more enjoyable with a side project. Work on it on your own time after hours, don't tell anyone (yet), and use whatever technologies you want to learn (even if they are not optimal for this project). If it doesn't work out, you abandon the side project and take what you've learned. However if what you made turns out to be useful, then you can tell the people you work with about it and maybe everyone will start using it. And if you work in a good workplace your coworkers and manager will be happy that you made their lives better. Here's some examples of work-related side projects I used to learn something new: - A telecom protocol decoder -&gt; GUI programming with X/Motif (yeah, I'm old) - A system for automating code reviews -&gt; Perl - A network simulator for a telecom product I was working on -&gt; C#/.NET (years ago when .NET was new) - A web server for distributing builds -&gt; PHP - A test tool for another telecom product I was working -&gt; Java and Swing - A utility for monitoring my company's servers -&gt; Swift on macOS All of these started as something I hacked on in the evenings and turned into tools that were more or less widely used at the companies I worked at when I wrote them. I hope this has given you some ideas and inspiration, Good luck!
Keep at it. Don't let the idea that "other people aren't into it" keep you away from it. Honestly I wish I had learned Java at your age. It's smart to already look into it. I always say there are two professions that will ALWAYS be needed: Healthcare and IT. Having general knowledge (or even advanced knowledge) of a programming language looks amazing on a resume even if it doesn't apply to the job. And it's pretty fun and rewarding to create something intricate and amazing. I wouldn't stray too far from the web side though. It plays a more important role than you think in today's world (that is where programming is headed: distributed systems, client-based architecture, etc.) If I can help you out in any way, let me know. StackOverflow is a tremendous source of knowledge. I use it on the daily. 
I'm pretty sure that example was also the one for a list. 
great work!
/r/learnprogramming and there the [**Frequently Asked Questions**](https://www.reddit.com/r/learnprogramming/wiki/faq) The **sidebar** in /r/learnprogramming has a section **Recommended Resources** where you can find plenty online courses and quite a few free ones. Checking there is a far better option than asking such questions in a language specific subreddit.
Yeah, but it's also worth mentioning that JavaFX is a bit of a mess, as in: unfinished business, with a fair share of performance problems too. Unfortunately.
Even if you can't use it in your day to day job (due to having to work with an older version) not having any experience with them in an interview is basically saying "I don't care about keeping up to date" to an interviewer. I'll leave it up to you to decide if that's an issue or not. 
www.softwareengineeringdaily.com is a pretty good podcast for current topics. E.g, one of the leads on Spring 5 was on recently talking about reactive programming.
Not sure if all these skills are so important to get most jobs (hardly anyone writes algorithms rather than business logic), but still a very nice collection.
I keep seeing this on these blogs: @NamedStoredProcedureQuery( name = "calculate", procedureName = "calculate", parameters = { @StoredProcedureParameter(mode = ParameterMode.IN, type = Double.class, name = "x"), @StoredProcedureParameter(mode = ParameterMode.IN, type = Double.class, name = "y"), @StoredProcedureParameter(mode = ParameterMode.OUT, type = Double.class, name = "sum") } ) StoredProcedureQuery query = this.em.createNamedStoredProcedureQuery("calculate"); query.setParameter("x", 1.23d); query.setParameter("y", 4.56d); query.execute(); Double sum = (Double) query.getOutputParameterValue("sum"); Do people actually do that? I mean, I've maintained applications with hundreds of PL/SQL packages and thousands of procedures in the past. This approach would have hardly worked for me...
So let's assume you're using some service somewhere and in between is a network link. By its nature, those things can fail even after your third retry. So it's a very common scenario. What logging level do give that thing and what are you doing with those expected events?
Indeed. It's important to know about algorithms and data structures on a high level, but mostly, we're consuming them, not producing them.
Pattern matching is long overdue but I fear they will gimp it like they did with `Optional` and tell us not to use it how it's supposed to be used.
I find the streams code easier to read these days. Especially if you use named lambdas or function references. Then it's a case of learning a few verbs. Probably the hardest is the difference between map and flatmap.
Compare it to WPF and you'll see how much better JavaFX is. Cleaner, saner and better performing than WPF. 
I do not think it is used much. It is popular among bloggers and forum participants because it is new.
Depends on the circumstances, and the criticality of the operation. If it absolutely should have worked right then and there, then it's probably the wake me up at midnight. If it's something you've got several hours to process, then it's probably not a wake me up at midnight alert, and you'd likely be handling alarming through other out of the loop monitoring systems (e.g. monitoring the age of the oldest items still enqueued). Whoever is writing the code should be able to understand. That said, I'm not sure I agree with the blog post. I haven't seen any developer struggle to on board with the basic idea of what the team does for logging levels.
Go for the standard solution: Filebeat -&gt; Logstash -&gt; Elasticsearch.
Maybe in Java 15. come 2038.
The `Optional` that was added in Java 8 doesn't behave like monads found in other programming languages (Scala's `Option` or Haskell's `Maybe`). Which is fine, but it misleads Java programmers into thinking it is a general purpose option monad by teasing us with half-assed monadic properties and using nearly the same names as the nomadic counterparts. To add to the confusion, Java documentation doesn't explain any of this and Brian Goetz, a Java language architect at Oracle, [writes against its use outside of very limited use cases](http://stackoverflow.com/a/26328555).
It is the best language for this. https://github.com/AlmasB/FXGL 
Make sure you use canonical links when linking to a file/directory on GitHub. On GitHub, you can press the "y" key to update the URL to a permalink to the exact version of the file/directory you see -- [source](https://help.github.com/articles/getting-permanent-links-to-files/). I've tried to fix your links: Relative | Canonical -|- https://github.com/mschaef/waka-waka-land/blob/master/explore.js | https://github.com/mschaef/waka-waka-land/blob/fce8e00fd8507b141e347ff7ec9e985dcd04bc6c/explore.js Shoot me a PM if you think I'm doing something wrong.
All the important algorithms are in a library I can import. Now design patterns...those are important EVERYWHERE
* What kind of lunatic writes if (i % 3 == 0 &amp;&amp; i % 5 == 0) instead of if (i % 15 == 0)? * If you don't have 5 interfaces with 3 implementations each and a remote EJB executing somewhere, you're doing Fizzbuzz wrong.
3 and 5 are essentially magic numbers in this problem, if you multiply them you lose the original requirements. If FizzBuzz was actual business logic implementation you would make 3 and 5 constants with some meaningful name, you could still multiply them but it may not be clear at first glance why the dev did that. I see no problem with it to be honest.
This will be a summer project for when I have free time so your advice fits well, thanks. Implementing something like waka waka land is exactly the starting point I was looking for, although I would prefer code to be in Java. I'm sure i can dig up something similar written in Java.
Lynda.Com
Because it's other way around in this case. The link from the title leads to the _forked_ project of _up to date version_.
&gt; I'm sure i can dig up something similar written in Java. I am too... but remember that this is something like exercise. The point is less about lifting the weight and more about undertaking the effort to lift the weight. One other idea just occurred to me... there's a large number of developers that actively work on roguelike games (in the spirit of the original Roghe). These tend to be heavier on the complexity with the game mechanics and lighter on the visuals/art... they might also be a good source of inspiration. https://en.wikipedia.org/wiki/Roguelike There's also the 7DRL contest... which puts a 7 day limit from inception to completion for a game. If you can dedicate the time (I can't, personally), it may be a good way to focus yourself on an end project. Good luck, and keep us up to date. This could be a fun project. Edit: Unit tests are your friend, btw.
but things like lambdas can be confusing in that they can make it harder to determine the order that code executes in.
I think unit tests are kinda fun to write (sometimes) anyways. A roguelike type game is exactly what I want to make with turn based battles and light combat animations possibly. If I can implement a screen with a movable character and interactive environment/ inventory management with random turn based battles occurring. I will certainly be able to piece the puzzles together into a short game with skill points, various attacks, recolours of monsters or npcs to keep it simple.
Since this is help with *Java programming*, it should, as the *plenty hints* on the subreddit indicate, be posted in **/r/javahelp**. Please, **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there **before posting!** As it currently stands your post is **not suitable** for any programming/learning related subreddit. You have to remember that the effort spent on the help given is directly proportional to the effort spent in asking the question, or, in short: no effort, no help. **Post removed:** programming help
&gt; Python is newer and some consider it an "easier" Java. FWIW, Python is actually years older than Java, [python 0.9 release was 1991](https://en.wikipedia.org/wiki/History_of_Python). They're certainly quite similar in some ways, and Python was also a very early non-Java language on the JVM via Jython. They've both evolved substantially over time of course, in various different directions though.
[IntelliJ](https://www.jetbrains.com/idea/)
Thank you for your input
Yes, but anonymous classes are slightly better in that they don't hide much of their inner workings other than having a reference to the outer class. lambdas hide the method they're running (it is easy to figure it out, but not when skimming code) and the way that they pull the parameters out of the method makes them slightly harder to read.
Anybody want to comment on CBOR vs MessagePack ? They seem very similar.
People love IntelliJ and although it's really a good IDE, I honestly think Eclipse covers the basics better. Stuff like Javadocs, incremental compilation, showing errors clearly, workspace management - the stuff you will need as a beginning developer - are really well implemented in Eclipse. IntelliJ is an IDE that starts to shine when you start making large projects or Java Enterprise projects, then it will do stuff Eclipse can't do.
no you dont lose any requirements. and even if you make constants, you can have a 3rd constant that can say "DIVIDED_BY_BOTH=15". and really, you're arguing about "requirements" on fizzbuzz?
If you are in college, JetBrains will give you Ultimate for free. Community works well in almost all situations, though.
This subreddit is fine for anything java related and I'm sure there's a silent minority (including me) that would love to see some non-enterprise related stuff here. :)
So why is its use so widespread? And what's a better alternative? (btw you can develop both webapps and desktop apps with Spring right? or only webapps?  I've only used it for a webapp)
I just updated to 1703 on my personal computer, no problems here.
&gt;I'm having to rely on a lot of 3rd-party libraries and finding a lot of them confusing as hell. Is the following a normal design and if so, why? It really depends on how complex what you're doing is. But a lot of the times people use a good bit of libraries. &gt;- This library has a class I need to utilize, OptionsBuilder. &gt; &gt;- The OptionsBuilder has a private constructor which does nothing but invoke super(), which would be Object's constructor since the class derives from nothing else. Weird, but fine. A lot of IDEs will throw that in automatically. &gt;- Its public methods, except for one, aren't static. This is normal. &gt;- I must obtain an instance through a .options() method. This isn't *normal* but not *out of the norm* either. &gt;- To top it off, the package contains an Options class which does not derive from OptionsBuilder. Wait, does `OptionsBuilder.options()` return an `Options` or `OptionsBuilder`? Is there a non static method that *does* return `Options`? &gt;This seems unnecessarily obtuse to me. What am I missing here? This sounds like the Builder Pattern. Depending on the above answer it may be a "fluent builder" which works like `OptionsBuilder.options().withBlah().withFoo().build()`. It's just a different style, I can't really say if it's overkill without seeing the code.
Very true and great point.
JetBrains has an amazing student program, which I take full advantage of. 
If you want to help me with r/javelinrl during the summer, I'd be glad to have you. The project isn't exactly a simple, entry-level game project by any means but I think it beats creating anything from scratch as a first experience with coding games. I can definitely work with you towards a few beginner tasks to get this done and working with! When I say it isn't an entry-level project, it's because it's got a custom engine and a few very advanced concepts (especially the enemy AI, which is very advanced for a RPG and makes everything else more complicated to deal with). On the other hand, though, it seems to be exactly what you're looking for in terms of game style. I'm maybe a week or two away from releasing the 1.7 version, which is pretty big - but at this point you can safely download the 1.7 source code from GitHub and play that, which is 90% ready (you really shouldn't use the 1.6 download though since it's very outdated now). If you give it a try and get stuck on something, let me know and I'll help - just make sure you take a look at the BUILD.txt file too since it has a few things you should probably know before starting.
Its the [builder pattern](https://en.wikipedia.org/wiki/Builder_pattern)
Yeah! I do as well! I am so glad I don't have to pay to use CLion either.
+1 for Eclipse. Sharp learning curve to begin with, but provides so many quality-of-life improvements such as import suggestions. UI can be sluggish but I just found IDEA to be so tedious to use. Again, personal preference.
Because initially, JetBrains was called IntelliJ. So their product was called IDEA. I guess they wanted to keep the wellknown name, so after they renamed the company to JetBrains they called the software IntelliJIDEA instead of just IDEA.
You and me both! I mainly use IntelliJ, PyCharm, and CLion. It's a great company, and I am really impressed with their products.
Freudian slip? You answered your own question in your title
Looks like a lot of the posts are for help and not actual javafx projects...
It isn't. It isn't that I dislike lambdas or anonymous classes, thry can just make certain things slightly more difficult to read, that's all.
I enjoy jGRASP. Everyone at my college uses it though.
If you have real beginners, then this: BlueJ - https://www.bluej.org/ FWIW - Beginners don't need an IDE. It's just a distraction. They need a learning tool. That's what BlueJ targets.
I'll look into it. PM me man
Not sure if you noticed, but Brian wrote this too.
Yea
That title is breathlessly exciting, but what does it actually do?
Looks like a templating engine that compiles templates to fast(tm) java, kind of like jsp, probably with the same problems. 
So what? It's a great language feature and the fact that Scala has it shouldn't mean Java shouldn't have it...
They suggest jGrasp at Umass for their CmpSci class. Fairly straightforward and easy to pick up.
Yes.
&gt; extremely expensive unless an employer or other is paying for it. It is actually quite cheap when you are paying for it, not your employer, unless you work for peanuts.
Same as IntelliJ.
I sure am! You're more than welcome to help too! I am looking for artists as well but I assume you are a Java programmer too, right? (well, this is r/java after all) xD A first starting step would be for you to follow the same advice I gave OP: try to download the 1.7 branch and run the game from inside Eclipse (or another IDE of your choice). If you're having any trouble I can also send you a build of the current version, which should be easier to launch. (also, make sure you look at the "doc/BUILD.txt" file for some extra information) If you already tried to compile and run the game from the source code, please try again. I just uploaded a few commits since I had enabled an alternative game mode that is still in early development (Scenario mode). Now you should be able to launch the main game normally.
you didn't use popup javadocs? I use them every day.
what why?
In my first year teaching Java in AP CS we tried using Eclipse for a year. It was very painful. Probably more than it needed to be since the District's IT folks had a standing policy of wiping all student computers every single night. Had one student abandon it for notepad. IntelliJ just works. Simple and easy. 
Because they tell you how to use an API without ever having to do a google search or even open a browser. I don't think I could live without the little javadoc popup :D
&gt; There is JavaFX It really is in an unfortunate state. Just compare JavaFX Image to AWT BufferedImage. And now check what you can do with/to them (i.e. native methods, libraries, the whole ecosystem). So it's not just OpenGL, it's actually the whole image processing community stuck with AWT/Swing, unless they like to convert all the crap to JavaFX Image (and maybe back again...). There isn't even simple nearest neighbor interpolation anywhere available in the pipeline. No. It's all bilinear interpolation, and then you catch yourself implementing a software bresenham/nn-scaling for a stupid zooming pane... JavaFX is maybe nice for simple "office" apps, but other than that, it's a mess, and incredibly feature incomplete (JavaFX itself and maybe more so the eco-system). Not making BufferImage a first-class citizen was/is a huge mistake, if you ask me. Like many other decisions (e.g. that "browser/-tech fetish" instead of focusing on desktop applications and their own strengths first) that have been made since JavaFX 1.0 in 2008.
What I would really like to see is a high performance object oriented graphics API that acts as a wrapper over OpenGL or Vulkan. That way, it would be much easier for people to write UI frameworks because they wouldn't require the use of JNI.
Eclipse.
Seriously impressed with this. Whoever wrote this really took a lot of time making everything clean and readable. 
Are you trying to validate the message or the exception being thrown?
Get the intellij community edition. It's full-featured and free. Creating a new project is easy, and the ui is far more intuitive/discoverable than eclipse.
Your regex is wrong? Or there is some weird character throwing it off. Newlines caused it to fail in an older version.
You can always wrap your call to the method that throws the exception in a try/catch and pull the message from the catch block
When the exception is thrown it has the exact same message Im looking for in the reg exp.
On mobile and I'd have to see the code. Maybe your version of jUnit is old?
Share some code
They started doing algorithm interviews when they and several of the big name silicon valley companies were caught and sued for having an agreement with each other not to poach each others workers. This seems to be the new way they're doing the same thing without it being illegal - making the interview process require so much prep time and exhaustion that no one with a job right now could do it.
I can have some mock code up soon but i dont think im allowed to share my companys code
Love the name!
Especially for HTML it is imho crucial that the template is actually valid HTML, in order to allow easy preview and designing. If that is not possible the developer himself must also design the complete page alone and could not rely on a web designer. This solution seems to strive for a more oldschool approach like jsps. I would still prefer thyme leaf because of the above given arguments.
It does mention conditionals &amp; loops: &gt; Rocker uses an intuitive, tagless syntax with standard Java expressions for iteration, control, and values.
 Something no bigger than the following will demonstrate your issue (please excuse the formatting etc I'm on my phone and have limited signal) public class Test { public ExpectedException expectedException = ExpectedException.none(); @Test public void expectedRegexProblrm(){ expectedException.expectedMessageMatchingRegex(".*"); throw new RuntimeException("message"); } } 
This is super awesome. :-)
While I cannot answer this question personally, you might find real user reviews for Mulesoft and all the other major API Management solutions on IT Central Station to be helpful: https://www.itcentralstation.com/categories/api-management/tzd/c290-sr-50. Users on IT Central Station most often compare them to CA API Management. You can see a direct comparison between the two solutions here: https://www.itcentralstation.com/products/comparisons/ca-api-management_vs_mulesoft-anypoint-api-manager/tzd/c290-sr-50.
Java 9 has an updated webview as far as I know. I don't know if it fixes YouTube. But I don't think the web view is really meant to let you throw together a Chrome competitor in five minutes. Lots of features in modern web browsers boil down to hosting an entire OS in HTML. If you want to make an actual web browser it'd be better to just fork Chrome itself.
If you are new to programming, I would suggest using just a text editor for a while so you become familiar with some compiler commands and how things are connected. Otherwise I would say Eclipse. * defacto Java shop standard * online tutorials use screenshots of Eclipse in examples * many workplaces use it * if you learn it you will be able to cooperate with other Java programmers more easily * free of charge
It gets updated every now and then. JDK 8u131 got released this week and it contains a lot of javafx-webview fixes: http://www.oracle.com/technetwork/java/javase/2col/8u131-bugfixes-3565760.html Most notably item 31: https://bugs.openjdk.java.net/browse/JDK-8166999
Very nice looking library. It's good to have some choice, because so far the only "alive" graph library for Java was JGraphT. But how does Erdos compare to it? What is the roadmap for it? What are the use cases? Is scientific/analytical use case intended? From what I found, there there are less algorithms and no support for importing/exporting graphs (e.g. in GML format). Also, JGraphT has additional libraries developed on top of it, like [jgrapht-sna](https://bitbucket.org/sorend/jgrapht-sna) (Social Network Analysis). I myself wrote some [metrics calculation](https://github.com/Infeligo/jgrapht-metrics) for JGraphT - felt a bit frustrated that these were not included in the core.
Misleading title, this library is not by Google. It is just an old unmaintained library from the googlecode archive.
Just gave it a spin via Arch Linux's AUR Oracle Java package. It's still very broken ATM. Fonts are fixed but YouTube doesn't work and it looks like their is somekind of memory leak or something. I clicked on the "I'm Feeling Lucky and kept on scrolling down the page and eventually hit it.
IIRC The Windows Java installer also gives you the option to install the Ask toolbar or something and is enabled by default so my guess is that it's whatever is bundles with the Oracle Java installer. I'd do a quick look in add or remove programs, CCleaner(startup items), etc just to be sure nothing got installed without you knowing. 
Indeed teams only migrate when their Container is not supported anymore. That's how risky and hard it is. I said nothing about the amounts of money pouring in. I expressed the strategies of the big players behind Java EE. Their strategy is not to innovate to win customers. At best their strategy is to innovate to not lose existing customers, which requires much less innovation, especially when the existing customers are vendor-locked in so many ways. The amount of commits do not reflect the amount of innovation.
For Gradle, I miss the documentation about the ability to have a canonical Java style project (src/main/java, src/main/resources), separating unit tests from integrationtests, and multi-module projects with such structures. IDE integration: Play2 would not need any control over that if play just abided by the standards of the Java ecosystem, instead of having things like HOCON conf files and route files in play-specific DSLs. Java EE and Spring do well without those, and thus IDE integration is not a problem. For Bean Validation, the documentation only talks about HTML form validation. But a server application may need to do bean validation not just for HTML forms, but also mere REST endpoints, or data coming in from any other channel. For the Spring dependency, you really think Hibernate Validator has a transitive dependency on Spring??? That's hilarious.
&gt; so far the only "alive" graph library for Java was JGraphT Guava also has a [graph package](https://github.com/google/guava/wiki/GraphsExplained).
Not only that it can do CRUD, but it can also run [native SQL queries](https://vladmihalcea.com/2017/01/18/the-jpa-entitymanager-createnativequery-is-a-magic-wand/) so that you can do Magic!
Looks like a pretty step by step beginners guide / easy to understand summary of hibernate youre writing there. I like it even if you arent inventing the wheel :) 
For a more comprehensive tutorial, check out [this one](https://vladmihalcea.com/tutorials/hibernate/) which feature over 115 article about JPA, Hibernate and relational database systems.
Here is the link to the announce, after chatting with Geotrust's customer support https://knowledge.symantec.com/support/code-signing-support/index?page=content&amp;id=ALERT2248 By April 18, 2017, Symantec will decommission the "Legacy" timestamping service. (Legacy) RFC 3161 SHA128 Timestamp Service: https://timestamp.geotrust.com/tsa
Am I missing something, or is there a mistake in the `var` example, where the identifier `n` is used in two different meanings in the same scope (Once as the `Node` to be tested, and another as the inner value of a potential `NegNode`)? 
Me neither. But graphs are a relatively new additions to guava (added in v20 ~end of last year). Maybe they will add more in the future.
Okay so this won't help you learn new things but it will show you what you should know, warning it isn't very ethical. Post a job offer advert of the job you want to test( this can be your job or any job you want to get) List skills that the job requires with a negotiate fee or one you think is valid. Look at all the applications to your advert. This is known as market research and will give you: What skills you should have What skills everyone else has What is the rate for the position How replaceable the position is You don't even reply to them as this is practice of recruiters. Like I said it isn't very ethical. 
So, there are now several [Mirror](http://projetos.vidageek.net/mirror/mirror/) reflection libraries for Java, right?
seems really interesting. Well done. best. 
Absolutely, Erdos' biography is up there as one of my favourite math/entertainment reads!
I see what you mean, but it is hard to say. In the equivalent Scala this would be valid syntax. Each case gets its own scope, so the inner value of the potential NegNode would shadow the Node to be tested. At any rate, whether the compiler would allow it or not, it is not a good coding practice and probably should be changed in the paper!
&gt; For Gradle, I miss the documentation about the ability to have a canonical Java style project (src/main/java, src/main/resources), separating unit tests from integrationtests, and multi-module projects with such structures. You do that by adding [extra source sets](https://docs.gradle.org/current/userguide/play_plugin.html#sec:adding_extra_source_sets) and [extra modules](https://docs.gradle.org/current/userguide/play_plugin.html#sec:multiproject_play_applications). &gt; IDE integration: Play2 would not need any control over that if play just abided by the standards of the Java ecosystem, instead of having things like HOCON conf files and route files in play-specific DSLs. Map HOCON to JSON in your file types -- you can write a pure JSON file and HOCON will read it. I use Visual Studio Code and don't have any problems. For non-generated routes, you should use the [Play Routing DSL](https://www.playframework.com/documentation/2.5.x/JavaRoutingDsl). &gt; For Bean Validation, the documentation only talks about HTML form validation. But a server application may need to do bean validation not just for HTML forms, but also mere REST endpoints, or data coming in from any other channel. Validation into a domain type ("recognition" if you're into langsec) is done through [QueryStringBindable](https://www.playframework.com/documentation/2.5.x/api/java/play/mvc/QueryStringBindable.html), [PathBindable](https://www.playframework.com/documentation/2.5.x/api/java/play/mvc/PathBindable.html), and [custom body parsers](https://www.playframework.com/documentation/2.5.x/JavaBodyParsers). Ideally, you want to convert into a domain object rather than have stringly typed validation. There could be more validation mapping on the backend (i.e. Play WS response validation) -- that is usually handled through Play JSON with JsResult on the Scala side, but on the Java side it's straight Jackson so you could use annotations there. The big problem with most validation is that it's blocking -- it doesn't set up an asynchronous boundary (i.e. Future / CompletionStage). This is sometimes a problem when people validate against things like a password blacklist that may have external dependencies, and it's lousy when it comes to streaming. &gt; For the Spring dependency, you really think Hibernate Validator has a transitive dependency on Spring??? That's hilarious. I double checked -- you're right, it still has a dependency on Spring Validation (I guess at the time it was written, Hibernate Validator wasn't there yet). Added an issue: https://github.com/playframework/playframework/issues/7258 Thanks!
I wanted to use JavaFX on my Pi as well but it's not that simple: 1) Oracle dropped support for FX on ARM some time ago. You can use OpenJDK but: 2) Their build is broken (or at least it was some time ago when I was testing it). The native-webkit-binary-blob included with their ARM-JDK was actually a x86 binary so it didn't work.
Unless I missed it, it doesn't address third party containers being derived from the official images? Unless due to the way layers work, they wouldn't technically be distributing anything? Assuming they didn't merge layers.
I was about to post some reply which went something like "Dude, just use Artifactory and AWS" - so I went to their page: https://www.jfrog.com/pricing/#cloud Holy crap, they got expensive from the last time I checked. Still though, you need to compete with people who have the knowhow to do this: http://chrisjenx.com/sonatype-nexus-aws-ec2/
Yeah, setting up Nexus or Artifactory isn't the expensive part of operating them. It's the cost of having to hire someone with the know-how to keep it running smoothly. Our pricing is competitive even with the direct costs of a single ec2 instance but with none of the personnel overheard. I've seen sys admins demand 170k+ just to maintain and monitor tools like Nexus and CI systems. A lot of CI systems are moving to the cloud but for some reason the artifact repositories haven't. Probably they like licensing the same old software they've sold for ten years and don't have to host much themselves. That's where we're trying to add value to the community. Thanks for the comment though. If you want to give us a try I'll extend the free trial to 60 days for you if you PM with your account information.
I'm not in the market for a personal Maven repo, but I appreciate the offer.
I don't know what version you use, but for me it works. I have youtube player that uses youtube embed api and playing and all controls work just fine
What book(s) did you use to model this design? 
jGrasp. ;) Just kidding lol pls don't smite me. IntelliJ IDEA is what's preferred.
So what does the app do?
I like the fact you can pick the edit font, and size. There's a few look and feel options you can select to make it look better too. It also handles large files better. But, of course you'd want to write a .bat file or an .sh script and set java option: -Xms1G, or 10G, what ever you need. 
in this case it was the kilim weaver &gt; for which the support is implemeneted netbeans just lets maven handle it. that's what i mean when i say the pom is the netbeans project 
https://www.youtube.com/watch?v=eA8xgdtqqs8
&gt;[**DDDSample screencast [10:06]**](http://youtu.be/eA8xgdtqqs8) &gt;&gt;Screencast showing how the DDDSample application interfaces are used. &gt; [*^Peter ^Backlund*](https://www.youtube.com/channel/UCCSIFPajmH9uMnRrqaX3zlQ) ^in ^Science ^&amp; ^Technology &gt;*^16,623 ^views ^since ^Mar ^2009* [^bot ^info](/r/youtubefactsbot/wiki/index)
http://dddcommunity.org/books/
&gt; The JDK code base is very portable, supporting several different operating systems, CPU architectures, and compiler toolchains. However, the JDK source code has not yet been ported to Alpine Linux, or more specifically, the musl C library. That is, it turns out that the thing about Alpine Linux that sticks out/is different from a JDK source code perspective is the C library. &gt; The goal of OpenJDK Project Portola is to provide a port of the JDK to Alpine Linux, and in-particular the "musl" C library. The Call-for-Vote for the project was sent out on February 22nd, and was approved two weeks later (March 9). Does anyone know why this was necessary? There are already [official OpenJDK Docker images](https://hub.docker.com/_/openjdk/) based on Alpine Linux, and they seem to work...
But to be fair it is not necessarily needed within a local context! It is far more useful when exposing an object via a public API. On the contrary: Because in a local context it is an implementation detail and therefore one could probably optimize better with a concrete type.
No performance comparison against JSP :(
&gt;This is actually pretty common. It hides "unnecessary" implementation details Hiding implementation details from who exactly? &gt;and makes it easier to switch to another implementation (say LinkedList or a concurrent version) later But in order to actually use that specific implementation you'd need to type cast it anyway which, from my understanding, defeats the purpose and creates unnecessary objects(unless it's been optimized at byte code level or something?).
How is the DDD reflected in the code?
You can find the details here http://dddsample.sourceforge.net/characterization.html and here http://dddsample.sourceforge.net/patterns-reference.html
[removed]
Given the information you provide, it is impossible to properly help you. So, if you don't wisen up, you cannot be helped even with best intention. For you abuse of language, I am banning you from this subreddit. Learn to behave properly when you're asking for help. 
Well, as I understand it the Oracle JDK is basically "OpenJDK + some proprietary bits", so I would have assumed that whatever incompatibilities exist in the Oracle JDK would have implicitly been inherited from the OpenJDK.
What is web-application? Learn Servlet Technology? What is Servlet Request and Response?Javatutorialpoint Provide step-by-step tutorial on how two create, deploy and run a simple Java Servlet using Eclipse IDE and Tomcat server. For More Info :- http://www.javatutorialpoint.com/p/home.html 
What does separating the server from the app in the docker container buy you?
I prefer IntelliJ or NetBeans for Java projects. Notepad++ is also OK for simple examples.
All your apps share the same app server image, makes security patching a breeze. 
&gt; Docker is a containerization platform and there are no unique or special restrictions in the license for use or redistribution as compared to any operating system, virtualization or packaging format. It means we could use Oracle Java SE to build our images, then redistribute the image? There is a rumor that using Oracle Java SE on Docker would violate the license. Could anyone have some ideas about this situation? Thanks!
Thanks for your feedback! :)
Not sure but why would you? 
I think they work between them without any problems, but the built in support for git in IDEA is good. What are you trying to do?
Microservice, hate that term, aren't all REST services basically microservices.
&gt;Microservice, hate that term, aren't all REST services basically microservices. Absolutely not ... REST is more about the "look" per se, eg. json vs xml (soap), usage of HTTP methods, etc Microservice is (in very rough terms) about "separation of concern", making things small and handle only 1 thing at a time. You can have a giant monolith code that serves up REST API. You can also have microservices that communicate in something other than REST.
In the code above, is it is a REST microservice or a REST service? You can play words with separation of concerns, and small things at one time. What does that even mean? I guess my point, I thought REST services were generally considered to be lightweight and operate on one thing.
If you mean projects, start simple (as anywhere). Pong, breakout, tetris, asteroids. Try to finish and apply polish.
Java is Java and will remain Java. Now I develop in Kotlin and I can't see any reason to switch back to Java. Take a look to the other languages: Java isn't a silver bullet. Devoxx 2016: Java is dead https://www.youtube.com/watch?v=Q_Z_8HXt68k ... and I agree :)
r/gamedev
Why so many people use Java ? Java's rank on Tiobe is #1, #2 on IEEE Spectrum ranking. In my country, impossible to find a intership if you don't do Java (EE) or PHP. Don't know if it's everywhere the same but it's hard so change if you are alone. I'm going to give a try with Kotlin, seems nice.
Do Ceylon! And clojure!
The post you're replying to is just humor. Don't use it for decision-making. 
Absolutely. Ceylon is the better object-oriented Java. Clojure is the better functional JVM language. Kotlin is a better Groovy, but that wasn't hard to do. Scala wants to be everything to everyone, but just ends up acting megalomaniacal. 
They're not mutually exclusive. You can write your project in multiple languages and use them together. Want a simple data object, write it in kotlin. Write your tests in Groovy. Use Spring framework with any of them.
OpenJDK or Oracle JDK? Does it include JavaFX by default?
Why the downvotes? This was announced by Mark Reinhold today. 
That looks monolithic.. Audit/UserEvent should be managed by a separate service, as does session management
It is. Dont assume that made any sense. 
If one of those other languages enables you to express yourself better use them. If you're happy with Java you can surely stay there. 
&gt; Use Spring framework with any of them. I want to see someone build an entire Spring application in Clojure just for the masochism.
Likely your browser download was interrupted before it completed, but because of the way Oracle has it's server configured, you just received a partial download that isn't the whole file. Download it again and triple check file sizes.
Not, such announcement or update to webview yet. JavaFX provides a GUI WebView javafx.scene.web.WebView node to render HTML5 content onto the Scene graph. A WebView node is a mini-browser. When the code is executed inside a JavaFX WebView node, a native dialog window will not pop up. However the OnAlert event gets raised as a javafx.scene.web.WebEvent object. We can handle those events. To set up the handler, use the setOnAlert() method with an inbound parameter of type WebEvent.
You can use any Java code in Scala. If you use certain features of Scala you might not be able to use the code in Java though.
I like that it has a design doc, but looking at the design doc makes me want to see part 2.
"rest" has nothing to do with micro or macro. it's simply a formalism for service interaction; mostly commonly this is manifested with http and uris.
You can't learn to code in 24 hours.
I'm writing a Master of Orion clone (4X strategy game with 2D graphics) in Java. You can see lots of info here: www.RemnantsOfThePrecursors.com Java has not proven to be a hindrance.
It will be based on spring-security. +1 for adding support for OAuth, although I wouldn't like to do that right in the first round version. Probably that would rather be a "plugin" with which you can turn OAuth on.
Scala was created before groovy
They definitely will be implemented as separate services. From what do you conclude the monolithic nature of the application?
Java is a dumb and simple language which is a very ideal choice for collaboration in a large project. Although Kotlin is good, each developer might have their own style of writing code which may slow down maintenance a bit. 
Of course you can't. Did you read the article? It didn't say so, you can quickly glance through the article and see what it said about learning programming in one day.
Awesome! But shouldn't the API reflect that more? And further more... Sessions?
This Java online tutorial is specially designed for absolute beginners. No prior experience in programming is needed (although that would help you learn faster).Beginner's tutorial on Java programming, which teaches you to program from the ground up. For More Info :- http://www.javatutorialpoint.com/p/home.html 
and Apache Tomcat 9.0.0.M20 http://mail-archives.apache.org/mod_mbox/www-announce/201704.mbox/%3C59fcbbd4-9494-e9ca-c57b-8b3c87dc5a23%40apache.org%3E
This course will help you get an in-depth understanding of the basics of Java Servlets and server side programming.Java Servlet Tutorial Tutorial Online from best Java courses. Master Java Servlet Tutorial with javatutorialpoint Online. For More Info ;- http://www.javatutorialpoint.com/p/home.html 
Readibility. Having `(;;)` looks like a vampire ASCII emoticon. 
I think those are earlier because they're from last year.
No. HATEOAS is one of the key things everyone forgets about when doing REST. http://timelessrepo.com/haters-gonna-hateoas 
&gt; but Oracle has right to relicense OpenJDK, so not a very good argument by itself Can you elaborate?
Nice! Where is part two!?
Looks like a plain old REST service to me. REST API Accessing most of endpoints below require authentication, otherwise they return an UNAUTHORIZED status code. They also return a client error (FORBIDDEN) if the user tries to query an entity which belong to some other user, unless he has administrative privileges. If the specified entity doesnt exist the called endpoint returns NOT_FOUND. Creating a session (POST /sessions) and registering a new user (POST /users) are public and they dont require authentication.
the argument isn't good because oracle could distribute openjdk with another (more restrictive) license, so just the restrictive license isn't indicative of oracle jdk.
So far the design doesn't seem much like microservices, but perhaps they will split into multiple services later? This first post seemed more like an high level system design to me, without indication of how the system will be partitioned and deployed.
You can just use eclipse's code generation feature to implement hashCode and equals for you. However, HashCodeBuilder and EqualsBuilder are new to me and might come in handy when eclipse's generated code isn't sufficient. 
It bothers me that the domain model is displayed with an ERD. ERD's are for databases. I would rather see a class diagram. I don't like mixing persistence concerns with the domain model. But that's just me.
This series is divided to approximately seven parts and the next part will be released on next Friday.
Just wanted to say that is awesome! It's been so long since I played Master of Orion. I loved that game!
1. Java8, Dropwizard Framework 2. Create and store events from front end to mysql DB. Extracts functionality previously done by monolith. 3. No 4. MS size &lt; 2000 lines, project size &gt; 1,000,000 5. Alpine Docker Image, deployed to kubernetes. 6. Atlassian Continus Integration pipeline, Bitbucket &gt; Bamboo &gt; Kubernetes. 7. Not used Atlassian products bamboo is a nightmare hell hole piece of software. Edit: To be honest because Java runs on the JVM and the only dependancy is the JRE then adding docker containerisation might seem pointless for other languages such as ruby it becomes a greater advantage. Its the tools that have developed around docker thats probably the reason everyone is using it. I cant describe how much pain kubernetes has removed from the development to production cycle. No more worrying about scaling, dns, load balancing, monitoring it does it all that at the click of a button. 
for #2 there is some kind of FE (perhaps html, angular, react etc)? this FE invokes your MS as rest/http? one instance of your MS serves all clients? and your MS knows how to interact with mysql? ok. 2k loc is not "big" at all. make sense to me it is called something... micro... thanks a lot! 
Good point! I'll replace the ER diagram, as domain driven design is a database ignorant approach indeed.
I'll write the code along with the articles as I go.
I agree: COBOL is undead, I think same for Java
Looks good. Some nitpicks. 1. INode should probably be called just Node. Same for IUnionFind, IGraphAlgorithm, IGraph, ect. 2. FrequencySet smells like Guava's Multiset but is lacking features.
AngularJs (1.8) front end makes rest calls to service. The service is replicated in kubernetes across 2 datacenters. Each datacenter has 3 kube nodes. Each node has the service replicated twice. MS writes to an external mysql DB which is outside kubernetes in each datacenter. This is one example of 40+ services this maybe being the smallest and newest. Each using almost the same setup.
&gt; Scala was created to make the creator of Groovy feel bad that he didn't think his language out well enough. In my opinion, Scala was created to show me how stupid I actually am.
1. Vert.x (http://vertx.io) &amp; PostgreSQL 2. Monitors virtualization stack for changes. Streams the changes to a central console. 3. Uses Kafka/Websockets to stream data to indexer microservice. 4. 850 LOC 5. Docker 6. Docker/OpenShift/Jenkins/Ansible 7. Nothing
1. Java8, Jetty, RestEasy, Guice, jOOQ, Quartz, Postgres, RabbitMQ, ElasticSearch, React &amp; ReactNative 2. Logistics platform for dispatching, capturing paperwork, tracking, analytics, accounting, etc. 3. Yes, using Retrofit. 4. 40K server-side 5. Gradle zip distribution (bash + jars) 6. Ansible, running locally. Will soon be run via Jenkins. Would like to adopt K8S with Docker next year. 7. Switched away from domain services + event-driven architecture sooner, but it is the correct starting point. A metadata-driven architecture with 1 endpoint has been much more powerful and increased momentum, but required understanding the problem before we could design an long-term architecture.
Is it a microservice though?
Hey we basically do the same thing at work.. Take legacy monoliths and decompose to Dropwizard microservices using Angular on the front-end :D You gotta get on the new Angular grind tho. I can't imagine still being stuck using AngularJS.. It grosses me out looking at it now that i've been on Angular for a year now
I was describing the whole, which is decomposed into micro-services. Moving to a metadata-driven approach is shifting that to one primary microservice to orchestrate computations, which are external lambda functions. So it is transitioning to be neither a monolith nor many domain microservices.
1. Java 8, Spring Boot. 2. Extracts data from ZooKeeper, adds some meta-fields, loads it into ElasticSearch. 3. No. 4. That particular service is around 1k LoC, entire project is around 5k LoC of probably around 8k if you count frontend SPA. I try to keep LoC count as small as possible actually i.e. actively delete obsolete code in each release. 5. JAR in a docker container. 6. Update private docker registry image, run docker-compose on target machine, sometimes deploy additional configs. 7. I didn't add horizontal scaling to it in the start and this is exactly what I'm planning to fix in next release. 
Its common to use an API gateway between your FE UI and your microservice to enforce an API standard, validation, access management and some security aspects. Something like Axway, Apigee, Mulesoft, AWS API etc. 
i like your example the most so far because you are on aws and did not mention docker/virtualization -- i don't know much about that either and want to avoid it for my 1st MS, just to reduce complexity. i'm new to this MS business and hope you can help me some more: is this MS the only thing running on the EC2 instance -- e.g. is it supposed to be one MS per instance? and how many REST "endpoints" does one do? is there any supposed relationship between the number of endpoints on one MS?
I do consulting so it varies, but recent one is: 1. Dropwizard 2. Retail finance stuff 3. It's tiered between service tied to front-end, business-tier and then a tier interacting with specific databases or third-party providers 4. We ended up with like 40 microservices of varying size, but probably tens of thousands of LOC. It was actually way overcomplicated, IMO. 5. Fat jars 6. Proprietary build management system. Maven + Jenkins runs the builds, but versioning and releasing was all home grown. 7. Skip the microservices and go monolith. The release plan was always to synchronize releases of 40ish code bases (microservices, plus multiple frontend and backoffice systems). They never intend to version them independently, so there's no reason they couldn't park every single piece into a single repository with a parent POM structure. Every service had it's own dev/qa/uat/prod. Coordination was a nightmare and most servers were underutilized. Also, Sprint Boot is better than Dropwizard.
i have not yet worked with either. at my previous employer, we used docker to get around some weird platform issues between various flavors of unix/linux required by a 3rd party.
&gt;is this MS the only thing running on the EC2 instance In our case, yes. Each of our microservices run on a t2.micro instance. They could theoretically run on a t2.nano instance. The cost of these is small enough that running multiple services per instance isn't worth the additional hassle. &gt;-- e.g. is it supposed to be one MS per instance? "Supposed" is a strong word - there's no hard and fast rule here. However it's a good idea to isolate services from each other to prevent the possibility of a failure of one microservice affecting another. Part of the benefit of microservices is that a failure of one part does not entail the failure of the whole - so it's a good idea to avoid single points of failure. &gt;and how many REST "endpoints" does one do? Again this is something that has no hard and fast rule - there is a huge amount of debate over how "micro" a microservice should be. The main point here is that your microservice should perform a distinct, well-defined set of related tasks. Defining the boundaries between microservices is far more important than worrying over how big the service should be.
thanks a lot! and if you wanted more capacity: would you upsize your instance? or spin up more instances and add a load balancer?
Not much goes into the docker config for a lot of java apps. But there isn't much of a performance loss either. The upside is compatibility with tooling (container orchestration).
you can turn off ads during updates in the Java Control Panel [see here](https://www.java.com/en/download/faq/disable_offers.xml) as for why, they payed to advertise, before yahoo they were advertising ask!.
A lot of them are moving to Go instead. 
Nothing really goes into the docker config. What Ive found is that if my jar depends on other services then i can just run the dockerfile for those services and their running. No downloading languages and libraries, no playing with versions. Same works for other co workers who might not be using java. Also container orchestration in kubernetes has removed Ops from the develop &gt; production process completely. 
We already have multiple instances behind a load balancer, so we would add more instances. 
Yeah if you always have to coordinate releases that's just a distributed monolith. 
The EA builds are done weekly; the are updated as code changes. Of course the builds from last year were one year old.
If you want to keep it academic you could write a book.
Very interesting project! Thanks for sharing. That being said, some of the documentation in the README file should be moved into the main Spring.io documentation pages. As it is now, it is not very clear what the project does (and why). The roadmap and long term vision of the project should also be documented.
Maybe create some kind of address book / phone book. Maybe implement it using a simple hashmap or maybe an array.
Custom docker images that * route application logs to the proper locations automatically * set up jvm-level monitoring automatically 
It works for me without using this. (`super.` is optional.) class Parent { int parentvar = 1; } class Child extends Parent { int d=3; int e=super.parentvar; } 
Actually the parent has been created, but you can't use `this` in the member variables initializers. `super()` must be the first call in the constructor anyway. (I'm using openjdk version "1.8.0_121".)
also thank mr skeltal for good bones and calcium[^*](https://www.reddit.com/r/tmsbmeta/comments/5xnirl/about_thankmrskeltalbot/)
Can you tell us more about the last point - switching away from domain services. What problems did you have with that and what exactly was the new solution?
Docker provides a lot of benefits when it comes to things like port management. I can develop all my apps using port 80, throw them all on the same box, and then bind their ports however I like. Without docker, the programmer has to either agree on "who owns what port" or come up with a port configuration scheme that ops has to deal with. Or, virtual machines.
I am looking to implement a simple ETL in AWS and was considering using that same tech stack that you listed. I was leaning more towards using Node though as I have read that using Java for lambdas adds a bunch to the lambdas's duration (cost) for things like JVM initialization. Have you run into any issues scaling this solution?
&gt; Kubernetes Bamboo is a giant pile of Garbage. I have no idea why some teams love it so much.
Great languages, sure. Great ecosystems? Definitely not. Tools like npm and pip are practically stone age compared to maven.
Definitely nice, but it does put a higher load on ops to make sure security patches are applied properly on all docker containers. (Or the devs need to do that).
Serious question: why? I've used bamboo for a few years now and it seems pretty solid. Good things are green, bad things are red, running a manual build is a single click, setting up new projects is easy, the test reports are nice and I get notified of any failures via IM and email. What's missing or bad? 
In these scenarios, you definitely need to get the devs to own their stack. Ops can provider the underlying infrastructure (i.e where my containers are running) but devs need to own the responsibility for security patching their containers. In 2015, 30% of the containers on Dockerhub had security vulnerabilities of some description (source: https://banyanops.com/blog/analyzing-docker-hub/), and I doubt that's got any better. By if you've got a decent CI/CD pipeline, tools like OpenSCAP, Black Duck, Atomic Scan etc, then it doesn't have to be a particularly large overhead to managing that - and tools like Kubernetes make rolling updates out a breeze. 
I think the installer will launch the Java website to "make sure you can access Java on the web" after the installation is finished. You might be seeing a side effect of that attempt.
&gt;Docker wasn't invented for microservices either, Docker and microservces have very, very similar concerns. Remember Java (Oak) was originally invented for set top boxes.
I didn't mention ecosystems, but there are a whole lot of libraries for Python, and JavaScript. I use Anaconda (left pip a while ago), and virtual environmemts for Python dev, and currently use Gradle for Java, SBE for Scala. Java is verbose for a typical microservice. NPM needs, and is getting, a lot of attention.
I have been using node for Lambdas as well and have not really noticed an increased cost in java vs node. Maybe over time I will start seeing a trend. Really the language I use is dictated by the task. I have found that certain things are just easier or have better performance in Java. Probably due to the fact Java just has more mature libraries available for what I need. 
The problems was the overhead for a small team and the need to have a high degree of customization for customers. Typically one has many services (domain/platform/infra) which leads to a high API surface area. To avoid SPOFs and "joins" of data across services, event queues are used to denormalize data. Then a service read can be very fast, e.g. a k/v lookup to a feed story as the user information is copied onto the record. This results in lots of pipes, APIs, async calls, and repeated idioms for failure handling. When redesigning, you'll probably use a temporary data sync layer to push the data into both the old and new service(s) and try to migrate clients to the new API. A metadata-driven approach makes the data self describing. The entity specifies the schemas its using (e.g. json schema) and operates against a generic endpoint (CRUD &amp; analytics). For the frontend team it lets them dynamically generate the UI, validate, and write more generic components. The backend uses the schemas to dynamically create a processing pipeline. These are components for data definitions (e.g. address), triggers at the entity-level, workflows across entities. The server is then mostly orchestrating computations based on this metadata, is unaware of the domain logic, and there is easy reuse. The domain concerns (entities, workflows, business logic) can be stored as data (schemas, JS functions) and defined using UI tools for the sales (or customer) to customize the business processes. The computations may still make remote calls and those can be microservices. Now the UI/API are mostly focused on generic infrastructure, the domain concerns don't sprawl out everywhere, and it is less work to add new concepts. You do have to leave yourself escape hatches, since it takes time to build the frameworks and you'll discover limitations that you want to fix but don't want to block team momentum.
[Fixed](https://github.com/a-hansen/alog/blob/master/src/main/java/com/comfortanalytics/alog/AsyncLogHandler.java#L155) the mutable params issue, thanks for the advice. I redid the [benchmark](https://github.com/a-hansen/alog/blob/master/src/test/java/com/comfortanalytics/alog/AlogBenchmark.java#L75) in JMH. I made sure no records are dropped as well as the Logback queue would never fill. 
If java continues to slowly add the features its would be killers have, maybe never. That said, I am liking Rust.
I think it will be something like the JVM but natively supported by all major OS (being a core component and not just installable like Java atm)
Good stuff, thanks for posting.
COBOL is used only for legacy reasons
I can see how Kotlin is a better Java, but I want all the Haskell. The type system, pure functions, pattern matching, tail recursion, monoids, folds, applicatives etc.
I wonder how many of them are [running on a JVM](http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.visualcobol.eclipseux%2FGUID-DEAFFCA6-6D75-4AEA-A3B6-6DF0BDCF3E2F.html)
I'm pretty sure that COBOL will outlive us all. 
Cobol is rated far above Kotlin on the Tiobe index... https://www.tiobe.com/tiobe-index/ 
I am not entirely sure, but I believe Spark can do that after the file is first pushed to HDFS. Then one can process it with a library that takes lambda and does distributed processing. In here, we are talking about in-memory data grids that can get in-memory collections, pushed to a distributed data grid, and then the lambda can process all of that. Again, I might be wrong, but that's my current understanding.
Places running COBOL are places that cannot afford development, such as banks where if even a smallest bug exists it could cost trillions. So, one can argue there is no ongoing *development* of COBOL (sure, there might be small ones). In that sense Cobol is dead even though it's still in-use. In the long run most ATM machines, parking automations etc... will continue using JVM and so Java just because it doesn't make economic sense to replace them, but that doesn't mean people will continue developing Java.
&gt; Nothing that exists now. Why do you think this is the case? What about things like Rust or Go, why do you think they won't be as impacting as Java? (I kinda agree with you, I just want to hear your arguments)
JavaScript 
I think [it is the comment](https://www.reddit.com/r/java/comments/49y6iu/new_java_9_mapof_methods/d0vtuwi/) referenced at 34m
Serious question, why would you want that? How does it help you write programs better faster easier? I was an FP guy when Haskell was invented, but these days I wonder why relearning everything from the beginning is an attractive option.
I'm not sure if I understand you, or if you understood me. Your company has a Cobol server? Sure, that's exactly what I said. But are you, or a team in your company actively develop a new app in Cobol? If no, then as I said your company doesn't want to touch the legacy codebase in case they brake stuff, so they let the server be. If the answer is yes, I'm really curious why did they choose Cobol over all other languages available today, that sounds quite strange to me. I wonder statistically how many companies are there who have teams that *actively* write Cobol code.
That sounds like Go.
Java isn't going anywhere. The people on the Java Platform Group are doing some of the best work that I have ever seen -- no refinement is chosen without a deep analysis of how well it would fit into the language. I highly recommend watching a talk from Brian Goetz.
I sincerely hope it's Kotlin
Could you use links in your post? I have to google to find the projects' websites.
&gt; @springuni Why not something simpler in the first version? I wouldn't like to rely on database and/or framework (eg. Hibernate) specific ID generation mechanisms. The reason is that I'd like to reuse this user management microservice in various environments (eg. MongoDB, MySQL, etc.) I've already implemented that ID generation mechanism for another project I was referring to in the article. If you read the linked article from Insta's engineering you can see, that their ID generation technique is dead simple. Although I slightly tailored it, but it's roughly the same. &gt; Btw. One thing that you might quickly find missing is some way to find out who modified the records (&lt;- that's a user story) and some field in the UserEvent model (who triggered the change) I think you're right in that that I could have emphasized that more in the design doc. Most of the entities will have audit fields (timestamp of creation/modification and a user ID who did it) and the UserEvent (~audit trail) is for tracking logins, logouts, password reset requests, etc.
ASM is longevous.
The impending death of Java has been greatly exaggerated. 
1. Java 8, Spring Boot 1.5.2 2. The point of a microservice is that it has a tiny scope. So we have quite a few of them, not one. Stuff for users is done in the users service, accounts are handled in the accounts service, etc. 3. Yes, REST 4. A quick look in Sonar shows 56k lines of code in total. 5. Docker containers deployed in a Kubernetes cluster 6. Dev branch Builds get automatically deployed in our DEV cluster. Master branch builds get automatically deployed in your TST clusters. Deployments on ACC and PRD are done my manually starting Jenkins deployment tasks. 7. We use Cassandra as our 'main' storage which was a pretty big mistake. We 'manage' but tons of stuff would've been a lot easier with a relational database and we don't even really need the scaling Cassandra offers. Regarding your edit: 'doing' microservices and NOT using Continuous Integration and container orchestration would IMHO be borderline pointless. We can deploy something (doesn't even have to be a Java app) at any time without having to worry about version clashes. These three components, microservices, CI and container orchestration go hand in hand. 
I think overall it's a quite good comparison. However these are some things I would describe otherwise: Lazyness and reusability: Observables fall into 2 categories: Hot observables and cold observables. Hot observables represent async operations that already have been started - therefore they are not lazy and can't be reused. Cold observables only do work on subscription (are lazy). Backpressure: Pull-based APIs have backpressure by design - the producer will only produce a new item when explicitely asked for it. E.g. when a `CompleteableFuture&lt;Item&gt; result = producer.getNext()` happens. The consumer can then wait until the result is available (future is completed) until the next item is requested. In this scenario then producer can't overflow the consumer -&gt; Backpressure is working by default! Push-based APIs in contrast need extra care for implementing backpressure, because the producer by default won't get an extra request for producing each item and just pushes the item to the consumer once it is available. If it is faster then the consumer this might cause problems (e.g. memory exhaustion). Things like reactive streams are mechanisms for getting backpressure to work in push-based APIs.
Their fault was thinking they can skip having a versioning strategy. 
You seem to identify "using a language" with "developing _new_ apps", completely disregarding maintenance development. Plenty of companies run active COBOL software that still needs to be maintained and to have features added. My previous company had a team of 3 devs just for the COBOL part of one system -- you don't have 3 devs on a payroll to _not_ write code. And it wasn't even banking. Less used? Sure. Dead? Nope.
I picked up Tim's course a few months back for $10 or so. The content is very good and goes into more detail that Derek's (although his is great also). I think it is worth $10. I really enjoy Tim's way of explaining things. He goes into enough detail without going into too much if you know what I mean? Plus I find his relaxed Australian accent easy to listen to. I would say pick them up, you will no doubt learn enough to justify the 10 bucks. 
CJUG (Chicago Java User Group) usually has interesting topics
This is what I fear as well
&gt; when Java dies Did COBOL die? Exactly.
How much are you betting?
Java EE had a reference implementation of MVC in java 8 only I think. 10 years too late?
So basically the module name is the same as the BSN, for OSGi users. Of course any OSGi user will tell you that the BSN is insufficient for specifying a bundle dependency without also giving a version number/range. But oops, I guess the JPMS designers didn't notice that. Because hey they don't to care about versions in order to modularise the JRE, and who cares what anyone else needs. Much more interesting read, from the comments of the article: https://developer.jboss.org/blogs/scott.stark/2017/04/14/critical-deficiencies-in-jigsawjsr-376-java-platform-module-system-ec-member-concerns
I think there's some hope that webassembly will help curb this trend. Let's keep our fingers crossed.
It isn't dead in the same way punk isn't dead.
&gt; It will be a big bloated 50mb app, but it will be a big bloated working webapp in the era of super cheap hardware. This is so true with Spring Boot, however, if you go with straight spring jars, it's not nearly so bloated (just a small amount of bloat). 'Overweight', not 'Obese'.
Thanks!
So, JavaScript is the best in the same way Justin Bieber is the best?
Javascript can't be deported back to Canada.
The Spring Framework is a gateway drug. Spring MVC is what originally got me hooked. Then I discovered Spring Security, Spring Data, Spring Integration, Spring Boot, etc. Being able to seamlessly integrate Gemfire and repositories auto generating OQL queries from interface method names, things like these make Spring my drug of choice.
Instant is a more accurate replacement; really though, it would take a lot of argument to get me to represent a date/time value using anything more complicated than a long. It's been around since dirt was invented, and for the basic case of storing an instant in time, it's all you need.
Sorry, I'm on my phone.. 
I understand hateoas, and I've seen some api's use it, but it really never seemed that useful to me. I'd rather have a well written swagger doc. I really don't know if state should be included in REST as well. It feels like its duplicating efforts in some sense. 
As far as I know, Spring gives you tons of things you do not have in JEE. As an example, regarding database access, JPA is pretty much equivalent in Spring and JEE, but... * if you want lower level jdbc access, Spring gives you tons of small utilities that help you close resources automatically, map tables to/from objects, use named parameters in queries, etc. * In a higher level of abstraction, Spring Data pretty much generates automatically your repository code, you just create an interface UserRepository with a method named findByLastName and the whole implementation is generated. * From the integration point of view, a couple of extra annotations and you have a well defined Rest service with the usual methods, exposed with security and with a nice javascript client if you want * And the alternatives! You can use a non-RDBMS , like Cassandra, Mongo, and get pretty much the same advantages. I'm not aware of anything like that in JEE, but maybe I'm wrong, it's been a while since my last project in jboss 
to be fair, it is possible to test with JavaEE using one of the embedded containers but it requires a lot more setup. I've also found that there are minor incompatibilities between containers. They are rare, but annoying
well thats my point, this post would have been more useful if you had a write up about walking us through the code .
I am a tech leader: I drop Java in favour of Kotlin
I did read, and I did understand the article. Date is a misleading class and people try to use it to represent what it seems like it should represent (a singuar date), which it does not do well at all, and in those cases it is better to use LocalDate. Honestly if anyone tried to represent a date with a long in any serious application I'd quickly discard it. long is in no way a suitable way to represent a date, and only marginally useful for representing an instant; however I still think it is too unintuitive and too abstract for any practical application.
You can invoke Java standard library in any JVM language.
No one is arguing that java 8's date and time libraries are much improved, but a timestamp is universal. You can give that POSIX time to anyone around the world and they would know the exact time and date of that event in relation to them. Thats why its an instance of an exact time and date. Local date doesn't work this way. If I say April 24th, it means something completely different to someone in australia. 
Again: JVM doesn't require Java, you can use Ruby on JVM
One more reason I've seen out there in the wild: Spring experience is, in my experience, much more marketable. As in: "You have JEE only? Sorry, we need Spring experience." vs. "You have Spring experience? Well, we use JEE but we'll get you up to speed." Does that make sense and is it fair? Nope. But that's what I've seen.
"Tech leader": How much are you betting?
That's really the two most important factors when trying to explain why you choose something to your non-technical bosses.
It looks exactly the same, an exact clone, the main difference being Java based rather than Scala.
Agreed. Little "historical" note - I actually did functional programming (in Miranda and Scheme) even before Java. But when Java came up, it so quickly developed such a powerful ecosystem of libraries and server-side frameworks that it became very attractive to use it for any server application development. One of the big achievements of Scala is that it's a unifier, it supports both FP and OOP and so allows you to move into the functional world without having to sacrifice the vast Java ecosystem.
I didn't know this either, this should be way higher on the pros list.
There are some great points above, I'll add one: Spring's got a much better ecosystem. Because it's used a lot more, there is much more stuff on SO, much easier to hire candidates, many more integrations, etc... 
Darn it! Disclaimer: Red Hat Employee
You can preview and design just fine having a local server render the template. As you should, so you can actually test that the template works properly.
You still haven't proven how Java is going to die. Yes, you can run other languages on top of the VM. So what? Oracle is going to continue to support both the JVM and Java. And you can't honestly say that Ruby is a better language than Java.
Spring MVC isn't a REST framework. It's an action-oriented web framework, which is low-level enough to where it *can be used* to create REST services. It's not surprising that an API designed for specifically for REST is better at REST than Spring MVC. But then again, Spring MVC can be augmented with [Spring HATEOAS](https://spring.io/guides/gs/rest-hateoas/) or [Spring Data REST](https://spring.io/guides/gs/accessing-data-rest/) to easily create sophisticated REST services with far less work than the bare-bones JAX-RS. What makes Spring so appealing is all the other stuff that is built on top of it.
JVM works just fine on z/OS. Once COBOL gets mirrored into a modern DVCS like Git the barrier of logging in and juggling TSO screens is gone. COBOL's only remaining leg up over JVM is the complexity of JNI for native code.
JNI is the pain point. More and more systems need native components. Probably something like JVM+LLVM where you can statically compile in all the native artifacts you need. Also, JVM may not be the best abstraction for FPGAs. Clash is probably the best approximation of what FPGA code can look like, http://www.clash-lang.org/
Swift for Linux on Z boxen, not Swift for z/OS. Big difference.
Also IBM are huge jerks to Mac users in regards to WAS. Our building process requires some EJB stub generation tool that is not available for MacOS so I've got to work with VMs. They don't even provide IBM JVM for Macs, as this would be a huuuuge quality of life improvement for me, but noooo, why should we bother.
I've been using Spring since my first day as a software engineer so can't really compare it, but it's the best thing ever. 
So, erm, all of us using java 8 parallelStream with lambdas get left out?
Really? I'd think, that if SIMD requires inlining, which according to the article requires low byte-count instructions and simple-written language, that the chances of getting SIMD advantage diminish with an increase of more abstract features increases, like lambdas and streaming. In Java 8, the JVM seems to convert each lambdas into a class. And a Java 8 parallelStream() hides an awful lot of intricacies, especially when outside-scope variables get accessed by inside-scope lambdas. Inlining may be possible for the most trivial cases, only. Now I sure hope that much of the java core library is written trivially
&gt; can easily be used with classic MVC style Not really. After all, that's the gap that MVC 1.0 was meant to fill in the first place. To provide convenient binding between views and models, especially binding HTML controls to models and convenient error reporting. Then, there is the convenient routing between controllers and views. Operating at a level above HTTP, or far above if you're talking JSF-style MVC. Now, JAX-RS vendors do provide non-standard extensions, such as Jersey MVC, but these are pretty bare bones compared to a full blown web framework like Spring MVC.
12 static methods, 11 final classes...
I dislike both. I would much rather go lower level and work directly with the web server and any other libraries I need. I feel no need to have a framework do it for me.
They dropped it from the proposed JEE 8 specification a couple of months ago. Now it's just a Glassfish-based JAX-RS extension, though I have had some success getting it up and running on Wildfly. Project dependencies were a little hairy to get straightened out, but the end result is some surprisingly clean code. I definitely prefer the syntax over Spring's MVC implementation, since it uses plain JEE 6 CDI.
J2EE 1.4 was horrible. Back as a recent grad I thought it was cumbersome, but not realising it didn't have to be that way, worked my way through EE1.5 before finally working on a Spring project. Never looked back. I think this is this is really the wrong question to ask. With all the innovation and simplicity of a Spring project, (for the past 2 decades?) and with EE still floundering to figure out what it wants to cover with delays and cutting scheduled features that have been part of Spring for the best part of 10 years, why would I use EE?
What do you mean?
&gt; First, while in theory there is a single Java EE specification and each application server is supposed to be compliant, in practice there are some blurry areas where each server implementation differs. As an example, migrating an application from Websphere to JBoss is a difficult problem. It's true that there are differences, but it's not an extremely big difference. At least you have a chance of porting, as opposed to re-writing the application fully. I did this a couple of times and it was a few days to a few weeks for a multi-million line of code application. &gt;With Spring. there is only one implementation so you are not tied to an application server Those two don't quite follow. "With JBoss there's only one implementation so you are not tied to a JavaScript VM" would be a somewhat equivalent statement. It's a bit weird, isn't it? &gt; In fact you can just use a servlet container (Tomcat/Jetty) which is very lightweight. A servlet container, and only a servlet container is rather lightweight with respect to memory used, startup time and disk footprint, BUT... what you propose here is servlet container PLUS SPRING. Notice the "PLUS SPRING", and I'm very sorry, but that's not more lightweigt than say TomEE, Payara or WildFly, it really isn't. Those start up in 1 to seconds, use about 30 MB or RAM, and take about 60 to 100MB of disk. Servlet Container PLUS SPRING typically takes more. &gt;Third, Spring is where the innovation happens. One, the innovation part is not what Java EE is about. Indeed, it doesn't so much try to innovate directly but to standardise that what has absolutely proven to work. Spring jumps and everything and anything, whether it's going to last or not doesn't matter. Nice if they bet on the right horse, not so nice if it was the wrong horse. In practice it means leaving behind a battlefield of half abandoned things. &gt;Spring adds several new APIs and when they become successful, Java EE standardized them. This is giving Spring way too much credit. To look at some APIs; JPA is based on Hibernate and EclipseLink, which is not a Spring API and never was. CDI is based on Seam, Guice and it's own JSF Managed Beans and EJB bean model. Bean Validation is based on Hibernate Validation. The Interceptor Spec is based on EJB interceptors. Expression Language comes from old Apache JSP tags (on which JSTL is based), Servlet is based on several HTTP engines that were around in 1999 (Jetty being one of them). JTA builds on JTS, which is based on OTS. DI itself, has by far not been invented by Spring and was around in the early 90-ties in C++ and appeared in papers. Java EE (J2EE back then) and Spring introduced DI at exactly the same time. JSF Managed Beans, which are a fully featured bean model and DI system and Spring 1.0 were released at almost the exact same moment. Even though Java EE's role is not to innovate, Java EE lead the way concerning the no-XML movement and was already converting to annotations when Spring was still telling its users to use MORE XML. And CDI had many features when it came out that Spring did not have, like contextual injection and a really well thought out extension system. So while Java EE "innovated" on its DI and bean model, Spring rested on its laurels for a long time. &gt;Last but not least, if your application is a Spring one, it means that 99% of your libraries are in your WAR file and you can upgrade them at any time. In a Java EE environment, several libraries are part of the application server. Upgrading them is a PITA (Classic example is the XML libraries) It maybe comes as a surprise to you, but application servers are upgradable too. And if you think in terms of "installed Servers that can't be touched" (which is rather nonsense these days with Docket et al) then with Spring you still can't upgrade the Servlet libraries and all that comes with it (including WebSockets). With Java EE products like Payara Micro and WildFly swarm and especially when combined with Docker, the point becomes totally moot and you can upgrade everything and anything, and in both cases to upgrade burden and ensuring everything still works is on you.
If you're just using Servlet, you're mostly fine, I tried using more complex stuff like JASPIC and that's definitely not portable. So in the end, we had a Payara/Glassfish-application that in theory should work on other containers, but in practice it didn't.
That you need a standalone IBM Java SDK on MacOS. You know, feedback.
I don't see any other university other than Stanford mentioned in the article, and yet they are not completely ditching it but rather giving students the choice to between Java and JavaScript. I'd say this is a little misleading title.
&gt; giving students the choice to between Java and JavaScript. And JavaScript obviously is an excellent choice to teach OOP basics...
Given that since Java 8 this is a standard JDK feature, why should one still bother with third party tooling?
and still we have yet to get a single common dependency management system nor even a common entry point. Not sure if it is also that easy. Installing Java in a windows container is quite meh.
+ Early adopting + Much more easier to contribute
&gt; But oops, I guess the JPMS designers didn't notice that. Severe [Dunning-Kruger](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)... Did you ever consider that the JPMS was not intended to solve version selection because existing tools already do that? &gt; what anyone else needs. If you need a tool to specify and pick out versions of dependencies, may I introduce you to [Maven](https://maven.apache.org/) or [Gradle](https://gradle.org/)?
If you use Spring Boot you don't. You can run it as a standalone Java application - literally just `java -jar app.jar` and it will do everything for you to get the appropriate servlet container working. And yes, you can then run the main class in your IDE in a debugger and it does the right thing.
We learned C first. Then we did Java and Haskell. 
I do not like JavaScript, but it is an interesting option for an introductory course. Its main advantage in this case is that you get instant feedback: you can just write a single file with few lines of basic HTML/JS and open it in a browser to see immediate effects: no need to compile, no need to run a command in a terminal (which many 1st students have no idea what it is), easy to get a very basic GUI (it is just few HTML tags), no need to install anything on the machine (they already have a browser), works fine on different OSs, etc. 
&gt; Did you ever consider that the JPMS was not intended to solve version selection because existing tools already do that? Yes and I'm saying that I have a problem with that decision. The decision to only considering the versions a property of the artefact and not a property of the module. Modules can't specify which version of a module they depend on because such a concept doesn't exist. This is a straight up insufficient specification of a dependency. That information simply cannot be used to validate that a set of modules is correct. Maven or Gradle can provide whichever artefact version they want and JPMS will have no way to validate whether a module's dependencies are actually satisfied according to the correct versions, it will just have to give it a try and see if it works. Sure, if we trust our dependency maintainers this should mostly be fine so long as we don't have any special desire to swap out different implementations, even if we can't actually validate anything ourselves. In the case of version conflicts though it becomes especially problematic since they have no solution to that problem. Relying on Gradle and Maven to resolve our dependencies for a given module means we tightly bind ourselves to the specific module implementations it was built against. If we want to swap out a dependency for a different implementation there are of course ways to do this with Gradle or Maven, but it means the concept of versioning becomes practically useless as we have to manually manage it and have no means to validate it. This can only seem reasonable to someone who has never used a sane modularity system before. And that's not even touching on non-maven dependencies and jars without POMS. It shouldn't matter how a module is deployed, it should contain enough information for you to know exactly what the fuck it actually is. Without a usable module version it just doesn't. The fact that they insist on build time dependencies as having fidelity with runtime dependencies is another problem in itself. Edit: you can make lazy, condescending jabs about the Dunning-Kruger effect if you like, but I think the link I sent makes it pretty clear there are fairly prominent people and organisations which agree with me. See also: https://www.infoq.com/articles/java9-osgi-future-modularity
Yeah, this usually happens when it wants to install the public JRE, it launches a new installer for that.
I think you've hit on the real advantage - it's supremely satisfying when starting out as a programmer to see the results of your work visually, especially in a context you are familiar with like a web browser.
Kotlin and Scala have "interpreters" so you get a console where you can test your code snippets quickly. Java 9 is getting this too, iirc. Weird time to move away from the JVM and OOP. I do understand the argument, it's just that it doesn't really apply (anymore).
I mean, if we're talking Kotlin then 12 companion object methods and 11 classes since they're all final by default &gt;.&gt;
here we are talking of an introductory course, which I guess would be in the first semester of a 3-4 year degree. you can do all those other stuff from the 2nd semester on (or better in parallel since 1st semester). yes, you can have "interpreters", but then you need to install them, you need to teach how to use a "console" (which they will need to learn anyway at a certain point), etc. furthermore, you do not get GUI easily with Kotlin/Scala, unless you want to teach Swing/JavaFX on the very first class to students that have never seen any coding before. btw, do you really want to have Scala as language for an introductory course??? even experienced programmers can have problems with it :) 
I wonder why
[removed]
I wouldn't recommend starting here. For the behavior OP describes, Shop and Customer are completely sufficient. Once they add more functionality and the system becomes more complex, other concepts like Invoice will emerge. Fortunately, they'll have tests on hand to help with refactoring the system and extracting those concepts. Trying to divine the final set of business concepts up front is very hard, and doesn't usually yield the best solution.
Ignore. OP is a yet another [Kotlin troll](https://www.reddit.com/user/MassiveDiarrhea): &gt; I like Kotlin, you get the cross platform-ness of Java, world class IDE support, great performance, and productivity. &gt; Should just use Kotlin. Has all the goodness of C# while retain cross-platform + Java Ecosystem &gt; They should have tried Kotlin. Has the features of C# while remain cross platform + can retain their expertise in Java ecosystem. &gt; Java is a dumb and simple language which is a very ideal choice for collaboration in a large project. Although Kotlin is good, each developer might have their own style of writing code which may slow down maintenance a bit. &gt; Yay Kotlin!
The fact that it didn't work when I did it. IIRC (this was many, many years ago) it had something to do with activating CDI properly. Just having beans.xml wasn't enough. No, I don't remember which JEE version it was. No, I don't particularly care. Like I said, I'm sure CDI is amazing now. I bet it washes the dishes and parks the car. I still use Spring over CDI for the reasons above.
Well, the OP doesn't seem to know where to start, so I provided an approach how to tackle the problem. I didn't say he should create a class for each business object. But at the end of the day, there is always a flow of orders, checkouts, invoices, etc. in a shopping process.
The headline is clickbait and the only portion of the article that is relevant to the Stanford curriculum change is: &gt; Stanfords website explains that their new CS 106J course covers the same material as [older course] CS 106A but does so using JavaScript, the most common language for implementing interactive web pages, instead of Java. The rest is just BS made up by a blogger.
From the **sidebar** of /r/learnjava (where the question should originally have gone): **Free Tutorials** * [Java for Complete Beginners](https://www.udemy.com/java-tutorial) * accompanying site [CaveOfProgramming](http://caveofprogramming.com) * MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki * [Derek Banas' Java Playlist](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) * accompanying site [NewThinkTank](http://newthinktank.com/)
Every time this gets posted someone comes in and says this isn't the intro course. This isn't the intro course.
The fundamental problem with Javascript as an introductory language, https://en.wikipedia.org/wiki/Prototype-based_programming is the list of &gt; Languages supporting prototype-based programming
Which is anyway what any good developer is supposed to do, what is the purpose of creating a package without testing if it deploys as it should?
IBM are NOT big jerks to Mac users anymore. WAS is now called WAS Classic and everything is being migrated to their new server which is called Liberty. Liberty is small, fast, leightweight, very modular and runs perfectly fine on a Mac.
There is a difference between having a testing environment and a development environment, and the same person doesn't necessarily do both tasks. Even if they were, and you had all three systems anyway, it is still very beneficial to have a dedicated continuous integration / build machine instead of maintaining three of them. Final thought - what is the _benefit_ of not supporting cross-OS packaging? Is it really such a difficult task that the (very important, IMHO) feature was left out of the JDK tool? 
&gt; for REST services JAX-RS is 1000% times easier/better. I've used both and I don't find developing REST services particularly difficult in either. I have far more experience with Spring MVC than JAX-RS, so maybe I'm biased. I'm curious what makes JAX-RS 1000% better? I would rate it maybe 10% better just on the cleaner API, that doesn't carry around the assumptions of MVC (like mapping all HTTP methods unless otherwise specified). But again, from my experience, the things that make JAX-RS better than Spring MVC aren't enough to overcome the benefits I get from Spring MVC's integration with other Spring projects. &gt; Spring Integration is a tire fire I've cooked up quite a few EIP flows with that fire! Maybe Camel is better in some ways, but I've found Spring Integration so easy to use (or my needs for connectors aren't that sophisticated) that I don't feel like I'm missing anything, especially the combo of Spring Boot and Spring Integration. &gt; Spring seems like bloatware Technically, bloatware is software made unnecessarily heavy by the addition of unwanted and unneeded software. Like some of those older commercial JavaEE servers. Spring is an umbrella of related projects and is not a monolithic stack, so you mix and match what you want. Is it "bloat" if you *yourself* choose to load up on features? &gt; they built om top of it contain lots of magic I like the magic, that's why I use things like the magical repositories of Spring Data Gemfire. &gt; just as heavyweight and hard to use as Java EE I don't know about hard to use (I use Spring's various integrations because they make things easier), but the problem with JavaEE isn't being heavyweight. It can't be, because it's a collection of APIs. The problem with JavaEE has been the heavyweight app servers which were oftentimes bloatware (there's nothing wrong with heavyweight if you actually need the features). That's not true anymore. JavaEE apps and Spring apps are only as heavyweight as you *want* them to be.
Keep dumbing down the universities. 
I agree with most here that Java isn't going anywhere. But what's going to be the new up and comer? Who know? If C++ didn't have 20+ years of such crappy legacy, the new versions are nice and could catch on. But all that horrible code that's already out there will keep most away (including me). I'd bet on Rust before C++, but I still think that's a long shot because of it's complexity and difficulty of use. My bet would be on Go. It's a really nice language once you get past the lack of exceptions and inheritance. It has a lot going for it and is really starting to pick up steam. 
Why is a time zone necessary for representing a point of time in the future? Past or future, an instant is the same instant regardless of the time zone.
What's the stub generation tool called? Tell them we @ RT can get them fitted for a nice EAP subscription :) *shamelessplug*
So, I'm not arguing against CDI. The OP asked why I (and others) use Spring over JEE. I gave a response. You're turning this into a CDI vs. Spring argument which it wasn't to begin with.
createEjbStubs or something like that. Comes in flavours for most of the OSes, just not for mac lol.
&gt; To enable it you put an empty beans.xml file in WEB-INF. That's not complicated but it is silly. With the prevalence of IoC, I still don't understand why it's not baked into the Java language directly.
Definitely better to define what type of class you want with a string rather than, I don't know, a type? Pretty poor example.
Is Jython still relevant like JRuby? 
Sadly, no.
Sorry mate but that's rubbish. Liberty is just an unzip. Know your stuff before you post.
That's utterly ancient isn't it? Anything remotely modern in Java EE hasn't needed that for 10 years or longer.
What's not portable regarding JASPIC? Serious question.
1. ~~Code doesn't work - "CIRCLE" vs "circle".~~ (I missed the call to toUpperCase) 2. Method References aren't Lambda Expressions. 3. Why not just use Class.forName? 
He keeps saying lombok adds boilerplate during runtime. I think it actually happens in a pre-compilation phase... somewhere around the time the AST is generated.
Indeed, but even though our code should not be reliant on byproducts of this tool it here and there is so migration from it would be a huge process.
Way better name than [ButterFaces](https://en.wiktionary.org/wiki/butterface), another Bootstrap JSF framework.
Thanks for confirming my (wrongfully) assumption :-)
Less relevant that JRuby.
Yep, I believe it's using a Annotation processor. APs get involved prior to the generation of class files. Lombok actually changes the AST by adding methods, something which annotation processors aren't supposed to do AFAIK.
 IHaveReadTheDocs extends Exception void weirdMethod() throws IHaveReadTheDocs
r/java/comments/653vin/windows_10_1703_update_breaking_oracle_java/
And?
Good for them. I keep wondering what the next evolution for GWT will be. I enjoyed it a lot back in the day (~0.6 or 0.7) and for some rich web UIs it's still very very solid (especially with something like Errai).
alert("lol!");
It is pretty buried, yes, here in my mind at least, lol. Seriously though, kudos to the ones who can tame and profit from this framework, I have so much scars from the days I went down this Java-JS river.
I've heard that too, I'll look into it thanks. 
**Point 1 - Spring compatibility** I am saying that if I have a Spring .WAR file I can put it on Weblogic, Websphere, Tomcat, Jetty, JBoss whatever and I know beforehand that it will work exactly the same, as it is self-contained. Time to port from one application server to the other is exactly 0 (which is how it should be). You say that you spent a few days and (gasp) a few weeks to migrate a Java EE application, so I don't understand what is your argument here **Point 2 - People using application server specific APIs that are not part of JavaEE resulting in vendor lock-in.** You did not say anything about this, so I assume you agree with me **Point 3 - Who innovates, Spring or JavaEE** You said: &gt;Even though Java EE's role is not to innovate I said: &gt;Third, Spring is where the innovation happens Well we agree completely here, I don't think we are saying something different **Point 4 - Upgrading an application server** You said: &gt;It maybe comes as a surprise to you, but application servers are upgradable too This tells me that you have never worked with Websphere (or the now obsolete Oc4j before that) Docker is good but it is for greenfield projects. There are several existing Java projects which are on application servers (without containers). These are very hard to upgrade in comparison with existing Spring projects. 
Spring supported injection against all kinds of beans in a unified manner from day 1. In JavaEE (at least in the beginning) you had different injections mechanisms for EJB and different for JSF backing beans. These were not compatible among them. Hopefully Seam came along and fixed this mess (but this was much later) So if somebody tried injection at that time period between Spring and JavaEE, it is obvious which one was simpler.
I kind of fumbled that and you're right. The catch is that people habitually plan in local time. If you need something to happen "x from now" you'll be fine but if you need it to happen "at x", when x comes around you want to be sure it's the right x. When time zones don't change there is no problem but time zones change all the time.
I think only JRE are available in tar.gz format
&gt; you can use Ruby on JVM Yeah, because Ruby is so popular.
It might be application server dependent. For example weblogic need to be redeployed always.
I think it's better now, according to Arjan Tijms' blog about it: http://arjan-tijms.omnifaces.org/2016/12/the-state-of-portable-authentication-in.html Back when we started to use it, it was poorly supported by most containers except for Glassfish / Payara.
It is funny to seem reasoning about "portability". I would like to know who has seen significant number of cases when changing important platform (database, big appserver) was happened in real business. In my 15 years of experience it happened only once (JBoss to Tomcat). So portability is not so relevant.
Okay, that is something that Spring did had. In Java EE there were indeed different types, and JAX-RS made it worse by introducing yet again another injection type and bean model (@Context, the horror).
&gt; simple syntax Really :) ever created an inner class like this? `new Outer().new Inner()`. Or call a method from an anonymous class: (new Object() { public void method() { System.out.println("hello"); } }).method(); Crazy stuff like that was there from the beginning. But I'm not sure what you benchmark "pleasant and simple" with. C++? Sure, you may be right. Pascal or Ada? Not so sure. But beauty (and simplicity) is in the eye of the beholder. &gt; best engineers working on it So, the competition didn't have good engineers? &gt; open source Interesting. If only the SUN of 1997 knew what the SUN of 2006 was going to do with Java! &gt; Yeah, quite surprising. Designed for set top boxes and applets? Yeah, rather surprising. Not that my point of view will ever impress your survivor bias, though.
I don't have those statistics, and frankly I don't think anyone has. Probably nobody has statistics either on how many applications still use the crazy verbose Spring XML vs annotations, or Spring "regular" vs Spring boot. The point is though that the option is there. There are some statistics on which application server is used most, though as most statistics these are biased of course (open source devs participate more often in Internet based surveys), but it's fairly likely that JBoss (WildFly) and GlassFish (Payara) are used a lot. And for both these 2 servers you have the option to "run a war" or run an uberjar. So there you go.
&gt; Well we agree completely here, I don't think we are saying something different Indeed, we aren't. Different goals in life, with different advantages and disadvantages.
&gt;The OP asked why I (and others) use Spring over JEE. Or why they're using Spr over Java EE perhaps?
In my view the power of embedding a scripting language in your JVM has always been underappreciated, whether it was jython or rhino or nashorn or (a long long time ago) beanshell. These days I would say it would make sense to favour Nashorn that comes by default in Java 8. 
to me it's a great idea, build rich javascript applications without using javascript, and enjoy the benefits of strong typing, object orientation, code reuse across client and server, and compile time optimisations. Yes it's also a benefit to have strictly java devs involved in a web project, but that is hardly the main idea behind gwt...
See my response for other reasons it's insufficient to rely on artefact versioning. As for multiple versions of the same module ... it would take *significant* changes to the core design principles of the JPMS for this to be possible. Currently you can't even have two *private* packages from different modules that overlap, despite the fact that they clearly will never interact. The reason for this is the method of isolation in JPMS. They chose to implement the isolation barrier by making classes *inaccessible* to modules, but still have them be *visible* to all modules, because they wanted all modules to use the same class loader. You cannot have two versions of the same class on the same class loader, therefore you cannot have two versions of the same class in JPMS. If they had chosen to copy the OSGi model of isolation, which is not accessibility but *visibility*, they would not have this problem.
Since this is help with *Java programming* it should be, as the plenty hints on the page indicate, posted in **/r/javahelp**. Please, **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there **before posting!** Further: &gt; I would be very thankful if you more experienced guys can check the code or changes in new branch and give me some feedback. Check: yes, comment: yes, branch and fix your code: no. Neither here, nor /r/javahelp will change your actual code as this is strictly against the rules of the subreddit as we *help*, *guide*, but never *solve*. Even asking to "branch and fix" is forbidden and would warrant instant removal. **Post removed:** programming help
Of course you (as ad dev) could - but a designer could probably not (so easy). So it is still a better approach to me, if you can write valid HTML and test the blank template itsself.
&gt; I posted here b/c I need *advanced* Java programmer's comments and I didn't see them in the "javahelp" subreddit... So, basically, you're saying that all the people donating their time to help in /r/javahelp are not advanced. In the name of the community there: thanks for discrediting an entire community. Great attitude. BTW: the people helping in /r/javahelp will be the same people downvoting and reporting such posts in /r/java. &gt; If not let me know alternatives. Please, follow the rules and post in /r/javahelp. The only things that will happen if I reinstate the post in /r/java are that it will get downvoted to oblivion and that it will get reported as "Programming help".
Where i work my company ERP still use GWT as it's frond end we still maintain it. 
That's right. We've been publishing weekly EA builds for many years. The only thing that's changed is the URL, due to the impending demise of most of the rest of java.net.
on the other hand, anything that lets developers avoid writing JavaScript is a good idea
Although I've used Java and Spring for many moons I've just started using Spring Boot and it really feels like a breath of fresh air. A huge strength of the Java ecosystem is mature and battle-worn frameworks and libraries - though that can be daunting if you've ever had to debug an unexpected library interaction. Spring Boot puts those concerns at ease by managing those dependencies and getting you started with a sane but flexible system. And for me, seeing these regular updates gives me more confidence that Spring Boot is being fed and watered :)
...and? What have you tried? What did Google tell you to do? I highly doubt "post a question on the wrong sub Reddit" was the top suggestion.
JDK as well, only not on windows it appears.
To me the big advantage of an opinionated framework is that it frees me up to build the applications that my client wants, and quicker. I effectively delegate to pivotals best practice - and Im mostly fine with that
Java is definitely going somewhere. Java 8 added lambdas, 9 added modules, 10 will add compact value types, better generics, possibly more lambda stuff, possibly pattern matching. I've seen discussion of better bulk data processing support (vectors). Basically, all those other JVM languages only get better because java gets better, and yes, the line between the JVM and the Java language is sometimes blurry. Java has amazing people like Brian Goetz improving both the language and the VM.
I feel like Java development is living much more compared to C# but that might depend on the area. Here C# is mainly SAP or SharePoint stuff and thats it.
This is a problem I constantly run into with .Net, there's no real opinion on how to do anything so you're left piecing parts together. We have like 10 different internal .Net web applications that are all using different libraries and organized differently, meanwhile I can pick up any random Spring application and know how everything pieces together without looking at a ton of glue code.
Integer can be null and if you use it in a primitive context (e.g. a + 1) the results will be impossible to debug. Always remember to check before unboxing. Seriously, why is this still such a problem to effectively stacktrace?
Importing java.util.Set/List into every class you write.
I was a ASP. NET guy before as well and switched for Java in 2012. Had a lot of up and down, but today I prefer Java for his extensive library choice. For some reason, I find it easier to manage large projects with multiple sub projects with java than the C# counter part. As for the future of Java and the JVM, I think Oracle needs a serious change of direction to stay relevant with emerging fields such as gaming(on desktop), embedded systems, 3D infography, etc. Also, swing need to get obsolete soon.
&gt; Oh yeah, almost forgot about Spring Security integration. Then again, JAX-RS integrates with Java EE Security ;) https://github.com/javaee-security-spec/soteria/tree/master/test/app-jaxrs
&gt; You're not serious are you? You can almost not be more wrong ;) You missed the point. &gt; I'm absolutely not talking about the normal annotations and &gt; descriptor files. This is exactly what I was talking about. You add annotations and presumably the app server (or whatever else is implementing the particular JavaEE API) picks it up installs the extension point. You can use descriptor files to influence the container in much the same way, like faces-config.xml in the olden days. &gt; As far JSF I'm talking about replacing or decorating things Yes, I've done this. I replaced the default RenderKit to support HTML5 attributes for input elements (before I learned that OmniFaces already does it). The way I did it was adding my custom render kit to the factory element in the `faces-config.xml` (and copying some code from the RI). I don't know if you can do this with annotations, from what you're saying it seems like you can. But, how do you know what the extension points are without reading the JavaEE API documentation? I had to do quite a bit of reading to figure out how the various annotations work in JSF, because it isn't self-evident from the JSF API itself. This is why all those "magic annotations" remind me of the descriptors. I referred you to the Jms Listener Container Javadoc to show you how extension points are defined in Spring. I can figure out the extension points are from the JavaDoc, or (as I do most of the time) by opening the Jms Listener Container API class in the IDE itself. I was able to figure out how to extend RestTemplate to work on the goofy HttpsUrlConnection by looking at the constructor for RestTemplate itself. This is simple OOP, not magic annotation processing. I find with JavaEE I'm either reading the documentation or searching StackOverflow when I want to figure out how something works that isn't self evident from spec (BalusC's posts have been really useful for JSF). I find myself doing behavioral testing, such as when I was debugging why my `@ViewScope` beans weren't getting set properly, using something like [this](http://balusc.omnifaces.org/2006/09/debug-jsf-lifecycle.html). With Spring, I can usually figure out things for myself from the APIs or the Spring source code itself. For this reason, I'm far more productive in Spring than JavaEE.
And probably when you work with an array, you're really working with the List interface. And, much of the time what we really need is LinkedList rather than ArrayList. Interview Tip: don't talk about Big-O notation about a "List" with a hiring manager, unless you know which implementation he's referring to. ArrayList and LinkedList are not the same. Didn't get that job :(
When declaring classes of your own, I always recommended overriding hashCode(), equals(), and toString().
You got my upvote ;)
Don't use it, the dateparser is fucked in it. 
You should default to ArrayList in most cases. LinkedList has its uses but it's usually the worse option. You should know the benefits / drawbacks of each though so you can make an informed decision. 
Right, got you mate. This was certainly one of Java EE's darker hours. JASPIC is fine, but Oracle did not check at all if vendors implemented it (including its own WebLogic!). My guess (but nothing more than a guess): JASPIC is a spec created by the Sun team (which is why GlassFish/Payara implemented it so well early on), but Oracle and the WebLogic team had their own approach. Then when Oracle bought Sun the GF and WLS (old BEA) teams may have clashed over this and we all suffered.
ArrayList is preferable to LinkedList the vast majority of the time.
Read. Read some more. And then read some more. Java is a tool, and like any tool (hammer, drill, etc), you need to know how to use it. From your post, I'm not sure how familiar you are with the language. But, if you have a passing understanding, I'd suggest starting with Effective Java 2, Java Generics and Collections, and then go from there. But, again, to answer your question, yes. If you want to write code in Java, you'll have to memorize basic language features. 
I did kind of the opposite for a year. i.e. java -&gt; C# I found the language it self marginally better. it certainly benefitted from starting a few years after java and hence didn't have quite as many of java's mistakes. Java is slowly catching up, but I doubt java will ever actually catch C#. I'd say Kotlin is at least as good as C#, and if you're willing to get your geek on, then scala is better. Scala can actually be too powerful (read complicated ) in my mind. I found the C# ecosystem, to be not-nearly as good as java. Where java would have 2 or 3 top notch competing libraries, C# would sometimes have 1. There is simply a much larger open-source community. This applies to build tools and IDEs as well. I really didn't enjoy working on windows (I'm willing to accept that might be a personal preference), but the unix command line tools are just awesome. And no, all the hacks to try to make windows like unix just don't work. But onto your question. I don't think java will die anytime soon. There are certainly some industries where it will be around forever, just like for C#. 
Yep. Lombok is a compile-time preprocessor. It runs during the compile phase and adds the requested bytecode to your annotated classes. There are lots of libraries that do similar tasks. Immutables, Map-Struct and others do a similar task, but they generate source at compile time.
yeah..like ur controller class for no reason 
tl;dr: ArrayLists, static vs non-static, {} blocks which are always run Learn how to use java Collections objects such as maps and lists. You're going to be using ArrayList&lt;T&gt; objects more often than traditional arrays. Standard arrays (type name[]), in my experience, are usually used for buffers of data that have a known size and that isn't that commonly used. And if you're not familiar with OOP programming, be very, very sure you know the difference between static and non-static scopes. There's only one static scope which is shared between objects (and main is always static because you haven't instantiated any objects yet, thus there's nothing for it to belong to), but there's a non-static scope of every instance of an object you create. Also, initializer blocks are amazingly useful. An initializer block looks like this -&gt; { &lt;code&gt; } It's run when an object is instantiated, kind of like a second constructor except it's always called. You use them like a function except with no return type, no name and no scope (i.e. just plop them anywhere inside the class). One even MORE useful thing is the static initializer block: static { &lt;static code&gt; } static initializer blocks are called ** *before* ** main, and you can put anything you want in them that you could put in a normal static scope (say, main). For example if you had an array that you wanted to fill up with preset values but you didn't want to put it in main, you could use one of those. Keep in mind having too many can clutter up your workspace when trying to find a startup behavior, but they're still super useful.
Can confirm == with strings drove me to madness once upon a time
The real design failure was that everything has identity (and monitors)
you should be redirected to www.primefaces.org
I would say it only makes sense to implement the `hashCode()` and `equals()` method on classes that have meaningful identity. Otherwise, the default identity of memory location is fine most cases. For example, a utility class does not have meaningful identity. When defining identity it also makes sense to divide classes into objects and values. A pure DTO is a value class, and two DTOs are meaningfully equal if all their attributes are equal. So `equals()`/`hashCode()` can just compare field values. With a Person class its more tricky, because just because two people have the same attributes, doesn't mean they are same person. For objects, identity should be based on a natural key which uniquely identifies the person, like Social Security Number in the US. But what happens if you have two Person instances with the same unique identifier but different attributes? That's why I prefer go with default identity for objects, and manage uniqueness externally, like JPA does with EntityManagers (also why you shouldn't implement `equals()`/`hashCode()` with JPA entities). I would recommend reading Domain Driven Design by Eric Evans, which goes into great detail about this. Also, if you implement `toString()`, be very careful about what you put in the string representation. If the data of the class has PII (Personally Identifying Information) or sensitive information (like passwords), you might inadvertently leak that data, for example into a log. I work in finance, so I have become paranoid about this :-)
I think you're supposed to use `EnumSet` for passing multiple `Option` parameters.
As an ABCD (American Born Confused Desi), I'm exposed to a fair bit of Indian English, and this usage of the word "doubt" cracks me up. When an Indian engineer tells me he has a "doubt" about a requirement, I know he means that he has a *question* about the requirement, but what I hear is that he is questioning the *validity* of the requirement. Doubt implies lack of belief, not lack of understanding. Is this an American English thing?
No it just means you are over thinking it's just a word. I'm sure people understood what I was trying to convey and that is what matters. Thanks for sharing your opinions I'm sure there is some indian guy somewhere who gives a fuck and btw don't use that abbreviation ever again it's cringy af. 
First of all this guy is right you're communicating something you don't intend to, so you SHOULD give a fuck. Second we don't take kindly to assholes on Reddit, so your chances of anyone answering your question just went down a whole lot.
Java is an OOP language, so identity goes with territory, and proper definition of identity is critical for proper operation of objects in a collection. Monitors I can agree with. Every object has a bit of overhead just in case you might want to share it between threads, and root of all classes `Object` has the concurrency control primitives `wait`, `notify`, and `notifyAll`. So concurrency is baked into the DNA of Java, but concurrency could have been opt-in. But then again, Java is garbage collected too, and you can't opt out of that...
I see. I'm sorry it's just that as indians most of our cousins from USA act all high and mighty and most of them come off as people who generally show off on our faces and think we are rudimental no matter how great our achievement is. so I took it a bit harshly and also yesterday night I pulled an all nighter to study for my exams so that guy's comment kinda ticked me off because of the fatigue. 
I feel that lambdas have radically redefined the language. A lot of code that was formerly loops have become stream operations.
can you write some more about this? have you seen other examples of ambiguous English in our fields -- IT and / or software development?
I'm not offended in the least. My Indian heritage has taught me to identify the demon Krodha, and how to (mostly) avoid him.
no silver bullet. In my opinion,in the 21st century you need to choose the right language for the job. To write a Web page you need HTML,CSS and JavaScript you don't just use Java because it's the language you are the most familiar 
That's the only example of an *ambiguous* usage I can think of Others examples I can think of are just humorous, like *updation* isn't a word in standard English, and *thrice* is a really obsolete word, like thee and thou. When an Indian says *cum*, it sends me to the floor laughing (exhibition cum sale). It may mean *with* in Indian English, it means *semen* in American English. For the most part, people will know what you are saying, so its nothing to be self conscious about. But, taking training in effective speaking still has benefits when you have to deal with an international audience, as in IT these days.
thanks! that's great. i try to be very "precise" and expressive with my code. e.g. if i am using a json parsing lib, then i avoid using the word "parse" for my own types/methods and would go with something like "dissect" etc. 
I have a theory about this. I think non-native English speakers are mapping the grammar and idioms of their native language to English, and it doesn't always end up with grammatical English. For example, a lot of Indians don't use a, the or plurals correctly in English. In my "native" language Bengali, you don't need those extra things to form a proper sentence. *People in south United States drive car* is perfectly grammatical in Bengali, not quite so much in English.
I would probably just go with parse, to follow established convention, but the fact that you're actually thinking about it puts you miles ahead of many other programmers. Naming things is hard!
It only works with String literals, and that only by the "accident" of String pooling. It also sometimes works sometimes with the primitive box types, depending on how you got the instance.
Doesn't that make it a theory in the "scientific" sense, then? ;-)
Definitely! And it's more efficient, too, since it only has to make one pass on the data.
A microservice can run in isolation, and owns its own persistence -- that is, you should not share databases or physical servers between microservices. Any data you need from outside gets copied. If one microservice goes down, the rest keep going. 
There already is something like this. Most IDEs will warn you against deprecated method usage, and you can suppress the warning with `@SuppressWarnings("deprecation")`. I read this as basically acknowledging that there is a problem and that you know what you are doing. I use this a lot with `@SupressWarnings("unchecked")` when the compiler is warning me that I might be doing something stupid but it can't prove it.
Is Java 9 as big of a change as Java 8?
Really spend the time to learn your IDE. If you feel like you are writing the same boilerplate code, Google it -- seriously. I use IntelliJ, and haven't written a getter, setter, constructor, hibernate mapping, equals or hashCode, in a long time.
You have an example? I code in .NET and in Java with Spring every day, I've never experienced what you are commenting.
ASP.NET leaves you with nothing more than a MVC framework, from there you choose what other tools you pull in. Sure, we have a standard set of libraries we use, Unity, Entity Framework or Dapper, but even after choosing your data access and IoC libraries of choice you're left to put the pieces together. None of these libraries provide any useful AOP functionality out of the box, and you're left trying to re-invent the wheel for transaction management, message processing, security, the list goes on. Every time I pull up one of our .Net projects and see everything in our Unity container given a PerRequestLifetimeManager because the static-dispatch nature of .Net highly discourages proxies makes me cringe, we end up creating some huge graph of objects for every HTTP request and thrash the garbage collector just because we don't want to go creating database connections manually in our service layer. These are all issues that can be fixed, and Unity even has the ability to create useful proxy objects as to provide AOP support, but Unity leaves you with a bare-bones dependency injection library and not much else - you're left to search for other extensions or write your own to solve problems that Spring provides solutions for in the core framework. I completely rewrote an application using Spring Boot in 4-5 hours the other week, that's the average time it takes us to get a ASP.NET application bootstraped because of all the glue and redundant code we have to write.
I agree that the AOP of Spring is very handy, until it doesn't have something that you need.
Java isn't going anywhere and it's being improved with each iteration. If you're looking for a job and the potential employer uses Java then learn to use Java, and the same applies for C#. Anything else is just BS.
I call those the Big 3 -- if you implement one, you better be implementing the other two. 
&gt; Please seek help with Java programming in /r/Javahelp! for each neighbor in neighbors check if neighbor is not a wall move ghost on neighbor
Huh, was this created due to inspiration from the javapoet post a few days/weeks ago? It looks like a neat solution. I'll have to try it out sometime. 
My thoughts exactly. Well said.
Yeah we use it widely in banking too 
Eclipse. I've used both Eclipse and Intellij, they're about the same in my experience. I was very disappointed honestly when Intellij was just "fine" and nowhere near what the hype train claimed it would be.
inserting at the middle of a linked list is really inefficient. it's optimal for inserting/removing at the beginning. 
...so how exactly is your post is raising the quality level? I hope the irony that your post is still about Spring/Hibernate/JPA, but without any of the actual content, isn't lost on you. Also maybe you should actually read some of the links, then you'd realise that Spring is a framework, not a library.
You answer a bit between yes and no is. I think is more no since tomcat has jaspic and jetty has jaspic, but they not have Jacc no? But tomcat do what Jacc is you know, only is not Jacc (collecting constraints).
persist() Should be used for totally new entities, whilst merge() is for putting something back into persistence context when it was changed. EDIT: Didn't see this was a link. My bad.
Oh right, derp
Jython contributor here. The project is still kicking. The progress has been slow compared to other Python implementations as IMO we're not quite reaching critical mass. Jython is not Python enough to run everything out of the box. And it's not Java enough to be a great scripting language for Java. We're making progress on both sides, but it's slow and tedious. PM me if you want to help :)
&gt; Every object has a bit of overhead just in case you might want to share it between threads Does it? I thought the monitor state was in the mark word, which is there anyway for all sorts of things. https://github.com/openjdk-mirror/jdk7u-hotspot/blob/59ce8c06deba642d87ec3e5774a94664df3f254f/src/share/vm/oops/oop.hpp#L64
Number two is the most important one. Always close your resources. Otherwise bad things will happen (memory leaks)
Yes
if such data can be believed at face value, then it is really surprising that JSF (17.7) and GWT (9.6) are more popular than JAX-RS (3.6) and Dropwizard (2.3) put together...
Would you like to create another thread for that topic?
Arjan Tijms once wrote an interesting article where he created the needed components programmatically, the amount of factories, builders, callbacks and interfaces needed to accomplish a simple thing was mind boggling: http://arjan-tijms.omnifaces.org/2012/11/implementing-container-authentication.html
Magnolia is a rich and free java CMS
GWT is used very widely in the enterprise. I work in Banking and literally everything is GWT
&gt; like Social Security Number in the US. In this day and age you should NOT be using SSN for anything (other than SS), even examples, since some newb will start saving them in some database somewhere. Email address or employee id would be a better unique identifier for an example.
Many of you who have got to know my posts know that I really hate anything to do with Spring. However, I would choose Spring MVC anyday over that monstrosity called JSF. JSF is a wart on the face of JavaEE. 
Instead of swing people can start using JavaFX. I believe that Oracle sees javaFX as a next generation UI framework. It's to bad though that javaFX doesn't have a html/JS output, that alone would save a lot of UI frustrations when writing true web applications.
It's a job market oriented survey, not an internet argument oriented one.
You didn't get my point. My point is that the type system's top type is an Object with identity, and that sucks. The top type should be `Any`, which is a super type of all references (objects) and all values (primitives, structs, etc.) Many languages (including OOP ones) have shown that not everything needs identity. And note: I can totally have a collection of values.
The second part has got just released: https://springuni.com/user-management-microservice-part-2/
Well, IIRC you have html/js output for a single page, but it's really a pain to manage and won't works well if you try to go to the next page within the app(example: following href content). It's really a shame since it could be probably done easily by the JavaFX team.
Say what you want about JSF, but you can be extremely productive with it with great results. JSF's abstraction of the request lifecycle and the server side component tree make it possible produce secure and fast form-heavy web applications with a very small amount of code, resulting in lower maintenance. For example &lt;ui:fragment rendered="#{userBean.isAdmin()}"&gt; &lt;h:inputText value="#{adminPageBean.someSetting}"/&gt; &lt;h:commandButton action="#{adminBean.save}" value="Save"&gt; &lt;f:ajax execute="@form"/&gt; &lt;/h:commandButton&gt; &lt;/ui:fragment&gt; This code ensures that no malevolent user can modify the `adminBean.someSetting` or issue a call to `adminBean.save` without being admin. In a classical MVC framework or even with JAX-RS you would have to have 1. one check in the template, so the form part is not rendered 2. have a separate controller method that will parse a fixed set of form values into the backend bean, checking security and other aspects for each of the properties. - Basically you need to implement form handling for each of your controllers separately. While with JSF you can reuse backend bean properties and action methods in as many forms as you like with different security checks. 3. write some jquery ajax ugliness to call the controller via ajax 4. generate a new response which updates just the ajax page part 5. handle the json/html response on the client and update the dom Today this is already much simpler with React/VueJS but there are still more checks to perform than with JSF. So it is no wonder JSF is attractive for companies who do not have a large developer team and large code reviews. Of course JSF also has a lot of drawbacks: 1. It's really, really old by now and you absolutely see the missing and antiquated bits when writing an applications (XHTML 1.1 anybody?). The ecosystem is also very old now and apart from OmniFaces there is not really a lot of development going on in the open source community. 2. The source code is very complex 3. View expiration 4. High session usage, statefulness 5. VueJS/React offer a much better developer and user experience - but they also make available a large amount of their application logic to the user via the JS source code, which can all run on the server with JSF. (solution: SSR, but that's complex too) 
This. I built an optimizing scheduling application for my diploma. Mostly complex forms. Using JSR-303 annotations for write-once validations. I was amazed by just how few code I had to write using awesome widgets (PrimeFaces). It's not perfect, but for non performance critical projects (no new Twitter) I really Like it. Now if we just could get rid of the damn application server and run as fat JAR ... 
Yes, there are many advantages to REST APIs. In their classical form, they almost always require a large amount of code duplication and boilerplate though due to their separation of backend and frontend. Most of the time this code duplication is a desirable effect, since you can develop/maintain the frontend and the backend separately. The boilerplate is the result of converting between different representations and is often overkill for small projects. At the moment I'm working on a VueJS frontend, with a "representation-less" backend, that just does JSON-schema validation and some security checks before storing data in a NoSQL database. This is also very productive.
&gt; they almost always require a large amount of code duplication and &gt; boilerplate though due to their separation of backend and frontend What kinds of code duplication and boilerplate do you mean? I find that modern REST frameworks take care of much of the boilerplate, if you leverage the type system. Code duplication can be handled the usual way in OOP: polymorphism. Modern Javascript frameworks can react to the changes in the data, in effect automatically reacting to logic on the server, so you have yet another avenue to remove code duplication. The problem is that the REST representations will start looking like view models, instead of some generic concept. I see no problem with that. Premature abstraction is the root of all evil. The main duplication that I still experience is duplication of validation logic (client-side JS and server side Java). This is strength of server-side component frameworks, which can generate the Javascript validation code. Although, this has also been a feature of Struts as well, which has some sophisticated template processing while still being an action-oriented framework. Of course, Java these days can run Javascript, so there is an avenue to eliminate even more code duplication...
Oracle doesn't sell JSF, it sells ADF.
I haven't done a lot of spring, but in JAX-RS you have to transform request values to backend values somehow... traditionally this is done with separate data transfer / form classes that duplicate the model classes properties. Of course you could also deserialize directly into your model classes, but this makes it hard or impossible to deal with collections. Alternatively you end up with a frontend that needs to issue a multitude of ajax calls to save or display a more complex form, because each model class has its own endpoint (with classical SQL RDBMS). For large projects I think it's desirable to have multiple representations of data and be able to convert between them. But this conversion is largely non-trivial and cause a lot of extra work when building a rest-api. That's why I think it's overkill for smaller projects and perhaps one is better of with storing the data directly in a NoSQL db. With JSF one does not have this problem at all, because entities are never serialized/deserialized.
James only used Scala for a short time. He's back to using Java 8 but he had nice things to say about Kotlin last year at JavaOne NetBeans day.
I don't believe that the successor language has been invented yet. It will probably be at least another decade before it does. There are languages with incremental improvements over Java and Java itself is continuing to improve but none of them are sufficiently better to make it worthwhile to replace existing working Java code with code in the new language. As COBOL has demonstrated the real question is not what project you would start a new language in but what language would you use to replace working code. The replacement has to offer spectacular advantages to meet this standard and an incrementally better language, environment, paradigm rarely does.
&gt; traditionally this is done with separate data transfer / form classes &gt; that duplicate the model classes properties. As you note, you can deserialize directly into model classes. &gt; but this makes it hard or impossible to deal with collections. I can see that being an issue if your representation format is form encoding, but JSON handles collections just fine. &gt; Alternatively you end up with a frontend that needs to issue a &gt; multitude of ajax calls to save or display a more complex form This entirely depends on what kind of data representation you are using. If you're not using form encoding, then you are free to model the representations returned by the REST service in the manner most efficient for your application. So, you might end up with view models, but there's nothing wrong that. &gt; because each model class has its own endpoint A model class does not have to correspond to a representation of a resource. And a single endpoint can consume multiple representations (i.e. model classes), either through POST or by matching a root path and mapping path segments to other endpoint methods. If you design the REST API correctly, the AJAX interaction between the client and the server wouldn't be that much different than JSF, it would just look different. &gt; But this conversion is largely non-trivial l and cause a lot of extra &gt; work when building a rest-api I can see that, if you're using a very primitive REST framework. Spring MVC leverages Jackson to do sophisticated type conversion from JSON without all that much effort. JAX-RS gives you JAXB, which is similarly powerful and simple to use. &gt; With JSF one does not have this problem at all, because entities &gt; are never serialized/deserialized. JSF serializes/deserializes entities by reconstructing the component tree. It's the same problem, represented in different ways.
Very interesting article. I would like to add that simply installing Sonar is not enough. You also need to customize its default rules AND convince developers to monitor it and take action when something is not optimal
The article is a bit biased. &gt;When your application needs access to stream history, delivered in partitioned order at least once. Kafka is a durable message store and clients can get a replay of the event stream on demand, as opposed to more traditional message brokers where once a message has been delivered, it is removed from the queue. This is actually a major difference and one that is essential for several applications (e.g. financial). The article downplays its importance and buries it in a single bullet list, while in fact it is huge deal on its own. I also found this very interesting: &gt;RabbitMQ is often used with Apache Cassandra when application needs access to stream history, or with the LevelDB plugin for applications that need an infinite queue, but neither feature ships with RabbitMQ itself. Are there resources available for this topic?
Oh, so these are just changes to the spec to introduce generic enums?
&gt; It's really, really old by now and you absolutely see the missing and antiquated bits when writing an applications (XHTML 1.1 anybody?). This is true, there's lots of cruft in JSF that should be removed. Crazy stuff that was deprecated in 2005(!) is still in there. I'm personally not so much bothered by the Facelets templates being XHTML, it's only the template. The result is your normal everyday HTML5. Also, don't forget that JSF has extensible templates (VDLs). It's not that JSF itself is XHTML, it's just that the default templating language is. Anyone can write and add another templating language (but since Facelets, nobody really has, but there were like 5-ish orso ones before). &gt;The ecosystem is also very old now and apart from OmniFaces there is not really a lot of development going on in the open source community. PrimeFaces basically won the component libraries wars. Most other ones faded away (mostly RichFaces, IceFaces and OpenFaces). Trinidad &amp; Tobago are technically still there and even release occasionally, but practically I don't think they are actually used (I like to be proven wrong here). There is a small new slew of *Faces libs, just a few days ago there was the announcement here of a new version of BootsFaces. &gt;The source code is very complex Agreed, but it looks like that's being addressed. See all the latest commits here: https://github.com/jsf-spec/mojarra/commits/master Everything is about simplifying the source code and cleaning things up. Mojarra is now largely a proper maven project as well (some ant parts still lurk there, but I'm sure they will be dealt with in time). &gt;View expiration It is nasty, I agree here too. But it's not necessarily a fact of life in JSF. Since JSF 2.2 there's a stateless mode. &gt;High session usage, statefulness I'm not so sure about the high session usage. This was crazy high in JSF 1.x, or if you uses client side state saving ridiculous amounts of state were send to the server and back all the time. But JSF 2.x is really very modest. From continuously fighting with the session to keep its size down in 1.x, this problem nearly vanished in 2.x. Controversially, I've seen the total average memory usage of stateless frameworks like Spring MVC with Thymeleaf being HIGHER than was JSF uses. This is because that combination generates a ton of garbage per request. Granted, this garbage will eventually be collected when the server load comes down, but in a server that sees a continuous stream of requests the average memory consumption can be slightly higher. 
&gt; JSF serializes/deserializes entities by reconstructing the component tree. This is what JSF 1.1 did (the restore view phase). JSF 2.x doesn't do that anymore by default. You can still enable it. But by default it just loads the view template and applies the request values to it.
So Vaadin is just GWT? 
Nice homework. Where's your code? We'll gladly help you if you're stuck at somthing concrete.
At first, I wanted to make fun of you and laugh, but then I remembered that quite a lot of co-workers I have sound no less retarded than what you wrote when they think they're communicating, and now I'm irritated and depressed because it's my life to have to work with people like this.
We use flyway and it's the worst decision we ever made. It's a complete productivity killer .... once you put this in your code it becomes the biggest pain in ass. I spend at least 1 hour a day battling with fly issues.
What the hell is your problem? &gt;I'm newbie in Java dev
I believe so.
A limitation compared to what? JUnit does not support mocking at all. Mockito does not support static method mocking as well. I would agree with you if the title was "Spock vs Powermock". Actually I am preparing the next article in series which will be Spock versus Mockito. Stay tuned! 
[removed]
There is no language on earth in which that is not retarded.
What is the groovy answer to PowerMockito? There isn't one.
I didn't understand why changing a junit test from an arrange-act-assert/arrange-act-assert structure into an arrange-act-assert/act-assert structure was a significant improvement. Both approaches appear to violate the aaa pattern to me...
not that I disagree with you, but could you provide references for the 1%, 2% and 0.35% values you are referring to? My surprise is not just coming from what I read on */r/progamming*, but also from what I see when searching for jobs and I read job descriptions... although this latter is influenced by at least two factors: (1) the country in which you live in; (2) whether some specific technology (eg JSF/GWT) would be mentioned in a job ad for a job position that uses them
And externally accessing individual enum members.
with static analysis tools and Maven, you can configure Maven to fail the build if any High Risk problem is found. Of course, on legacy systems you first need to fix all the existing problems. But on new projects, you can activate this check from the very beginning of development
Why do you need PowerMock? If you need to mock static or private methods/fields, that has implications towards your code being bad (or at least not testable, which in turn implies problems with your code). The article was more on comparing JUnit, which is a pure Unit testing framework, to specification framework such as Groovy. If you look at some of the newer JVM languages that don't have all the limitations of Java (due to backwards compatbility), they tend to go for specification frameworks for testing, due to readability and clarity. 
One data point is Tiobe: https://www.tiobe.com/tiobe-index/ Another one, not specifically supporting the percentage references, is StackOverflow: * http://stackoverflow.com/questions/tagged/java * http://stackoverflow.com/questions/tagged/python Or RedMonk (stackoverflow vs github) * http://redmonk.com/sogrady/2017/03/17/language-rankings-1-17 This doesn't give you percentages either, but they both do show you that the /r/programming "idea" that Python and Ruby are massively more used than (say) Java does not hold. There's no question that Python and Ruby are popular, but it's not like they are at 80% together and everything else eats up the remaining 20%. Of course the exact source for the datapoints matter; if you compare indeed.com, stackoverflow, tiobe, github and few others you'll the percentages varying, but they all do correlate. E.g. given Scala 0.35%, Ruby 1%, Python 2%, Java would be approximately at 6~7%. One other takeaway is that there's no longer one extremely dominant language (and there hasn't been for a long, long time). There's a group of languages that are popular, with Java being in the top tier/top group in basically every datapoint you look at, and Python and Ruby often being in either the same tier or a tier just below that.
&gt; Now if we just could get rid of the damn application server and run as fat JAR ... what does this get you? 
&gt; Request tampering would result in a parse failure leading to a 400 Bad Request response from a REST service. I'm not 100% sure. I get what you mean, there's the model to validate against, but that's doesn't often protect against tampered values, does it? Additionally, far too often the model is not specialised for individual user roles, let alone combination of those roles. For instance, if I let the user select from an age list on a given rendering, say the values are 8, 12 and 16. These are bound to a Person entity's `'age` attribute, which is say an int. On a postback, the user swaps in a 9. Since 9 is not in the original list it will be rejected. Now in order to protect against this in JAX-RS, you need to have different endPoints, which different validators to post to, in order to achieve the same effect, don't you? As the model structure won't protect you against this (and int is still an int for age), and you can't validate the model structurally for the 8,12,16 constraint, since this is just for that one rendering. But if you're going to create endpoints for each rendering, you kinda give up the advantages of having an abstract REST service, and your endpoints (when taken to the extreme) almost become "pages" themselves. The validating against the model when parts are not rendered is not super easy is it, or am I missing something? Take Person again. Suppose there's a salary and a rating attribute or sub-entity on it. A user in role "hr" may update salary, and a user in role "marketing" may update rating. Are you going to create different models of Person associated with the "hr" role and "marketing" role? And if so, what about permutations? Or am I missing something here? 
???
To be fair most of the posts on these frameworks are out of date ways of using them anyway, this sub feels like it is stuck in a time loop 5 years ago. 
You can use SonarLint (plugin for IntelliJ, Eclipse, VisualStudio) to provides on-the-fly feedback. So you see result during typing, you don't have to wait hours.
Not having to maintain and configure another external "dependency". I remember stumbling upon a Glassfish bug where some JEE lib needed an update. I had to document all steps updating this lib in Glassfish to everyone. Otherwise a simple pom.xml update would have been enough... It's all JAR files anyways...
It's not looking good, that's for sure.
None of the language will be replace, developers will definitely be replace.
Hey, I know your pain, but if you're spending 1 hour a day on this you're doing something wrong. I spend maybe 1 day per quarter battling these same fires. What we do is when we have that "SQL hotpatch" on version 1.1 (when we have 1.1, 1.2, 1.3 out), we simply add a new version file in that branch for that version. our upgrade files are named: upgrade0101_0__JIRA-1234_description.sql upgrade0101_1__JIRA-1235_description.sql upgrade0101_2__JIRA-1236_description.sql upgrade0101_3__JIRA-1237_description.sql upgrade0102_0__JIRA-1238_description.sql upgrade0102_1__JIRA-1239_description.sql upgrade0102_2__JIRA-1240_description.sql upgrade0103_0__JIRA-1241_description.sql Okay, so say there's something that needs to go into version 1.1 and then get propagated all the way up. You don't want to (or can't) run out of order upgrades for various reasons (for us, it's how we bootstrapped Flyway in to begin with). So now we simply do this: Add the following three files with the _SAME IDEMPOTENT CONTENT_: upgrade0101_4__JIRA-9999_description.sql upgrade0102_3__JIRA-9999_description.sql upgrade0103_1__JIRA-9999_description.sql You put the first file in branch 1.1, second in 1.2, third in 1.3 (merging up appropriately). Done. I totally agree with you, it's a nightmare, but it's orderly and predictable. We try to minimize SQL fixes on older versions, but it's inevitable.
They're voting no on the "Public Review Ballot" that is due on May 8th.
Of course. It's not OSGI.
It's not entirely clear to me what will happen here... but here's one potential timeline of what could happen (although I think this is all unlikely). This is based off my reading of JCP process documents, but that is obviously not authoritative. * *8th May 2017* Votes from the JCP Executive Committee (EC) are due on Public Review Ballot for JSR-376 (JPMS). This JSR standardizes the Java Platform Module System... but it is *not* the JSR that modularizes the platform itself, it just defines the system that will be used to modularize the platform and the applications we write that run on it. * Per JCP rules: &gt; JSR ballots are approved if (a) a majority of the votes cast are "yes" votes, and (b) a minimum of 5 "yes" votes are cast. Ballots are otherwise rejected. * If JSR-376 gets voted down at this point the spec-lead (Oracle) has 30 days to address the concerns of the EC and resubmit. *My suspicion at this point is we would see Oracle cave on some of the easier to give up sticking points in the spec around the migration path offered to user (the numerous "requires classpath"/"strict module" proposals, for example)* * If the spec-lead fails to resubmit or the resubmission gets voted down too then the JSR is closed. At that point there is no JPMS. If this were to happen this would put the Java 9 Umbrella JSR (JSR-379) in an interesting position. The umbrella JSR only requires Oracle's vote to go through: &gt; Ballots to approve Umbrella JSRs that define the initial version of a new Platform Edition Specification or JSRs that propose changes to the Java language are approved if (a) at least a two-thirds majority of the votes cast are "yes" votes, (b) a minimum of 5 "yes" votes are cast, and (c) Oracle casts one of the "yes" votes. Ballots are otherwise rejected. The umbrella JSR however specifies that the platform will implement JSR-376 in order to become modular... but it obviously can't do that if JSR-376 itself isn't a standard any more. I guess at this point Oracle could fold the entirety of JSR-376 in to JSR-379 and therefore get it standardized... but this would be pretty politically damaging thing to do considering that a majority of the EC members would have just voted against it. What I suspect would be more likely in this eventuality is that Oracle would either: 1. Modularize the JDK internally but not expose the modular features for use by the public. At this point modularity becomes an internal detail of Oracle's JDK implementation which could be refined through the lifetime of Java 9 and potentially standardized and exposed in 10. 2. Modularize the JDK internally and expose the modular features as a *non-standardized feature* that would become a *defacto standard* through Oracles current market domination in the JDK space. **What I really think will happen** There will not be sufficient votes to vote down JSR-376. A number of EC members will vote 'No', and may get to say "I told you so" in the long term. Somewhere down the line someone has to eat some amount of humble pie. Edit: just realized I misread the voting procedure for Umbrella JSRs... I had assumed it was `(2/3-majority &amp; five-yes) | oracle`, but it seems it's `(2/3-majority &amp; five-yes &amp; oracle)`. This means Oracle can't push the Java 9 umbrella JSR through on their own. This just means the previous "politically dangerous" path is now an "impossible path".
I use Flyway as a currently solo developer but you may have sold me on switching to Liquibase. I believe Liquibase also supports rollbacks.
In case you have forgetten the context of this thread, the point is that the security features of JSF can be easily replicated with JAX-RS and JAXB.
I used it some year ago. I had mixed feelings... it was a wonderful tool to build business apps, the typical CRUD needs were easily available and a couple of code rows were enough to implement features. But it never hit the heart of developers, the widget set was limited, the editor really slow, so after one project I abandoned it. Now it seems it was heavily redesigned, the UI is improved, OSGI thrown away and the workflow is based on Maven. It seems a step in the right way but the visual form editor is gone, don't know if they will reintroduce it. Without it, designing a form is a PITA (you have a lot of classes inside classes, every widget is a subclass!) so I find difficult to recommend it.
Can these not be largely addressed by applying a couple of recommendations I've seen: to use semantic (or similar) versioning to your script numbering, perhaps with the addition of a time-based suffix to help provide a bit of ordering within that. That said, whatever tool you use, you are going to have to design your migrations, including their order, and at the end of the day that's a human problem. A tool can only help so much.
&gt; My opinion is that code should never bend in any shape way or form &gt; because of unit testing. I agree with this idea in general, that you shouldn't go randomly change code just to hit test numbers. That's the wrong motivation. But, the *idea* of "writing code to be testable" means that code *that happens to be testable* tends to also be better designed (depending on your definitions, of course), and by "listening to your tests", you get valuable design feedback which you can use to improve your code. That's why a lot of people don't want to mock statics or privates, because they see that as the test trying to tell them something about their design. Static methods are in totally cool *if they are stateless*. When you use them to start sneaking in global state, like with the Singleton Pattern, you run into the fact that [singletons are pathalogic liars](http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/).
Whenever I seen "alternate" test frameworks like fluent etc used, it makes it so much harder to understand wtf is going on. I know your supposed to be able to read the test like English, but the whole fact that the tests do not provide examples of how you actually use the thing under test, and are generally structured differently, adds extra cognitive load that I just can't be bothered with. I really dislike how they just magically take things and produce some tests and results.... Sorry
I would try to avoid jsf entirely. It could be difficult to scale out. The most reasonable option as I see it would be a neat restful API built with springboot. Then you can use any tech or framework you like to create the client. More flexibility and a clear responsibility for each logical module.
If you're wanting to confirm this for something like a conference talk I would just email the JCP PMO (Program Management Office) pmo@jcp.org and ask them. As long as you phrase things as process related questions you should be okay. (Remember Oracle pays their salaries)
That's beside my point. I'm criticizing the metric, not the tool
Smells like politics to me, given IBM's stance on OSGi.
There's a significant gotcha with Spock - Groovy is not Java. It's an obvious point, but one that's easy to miss. For instance, if you check for equality in Groovy (`a==b`), Groovy will first try to call `a.compareTo(b)` if such a method exists instead of calling `a.equals(b)`. This can lead to a test that doesn't test the path you think it tests. It's one more layer of complexity to keep in mind.
&gt; . That probably means a JVM/LLVM successor for JNI. There is already a JNI successor being designed for Java 10.
&gt; We Dont write for loop any more in java 8 I wish. Unfortunately there is currently no way to deal with exceptions in lambdas other than wrapping then in RuntimeException (which defeats the purpose of checked exceptions). 
2k+ monthly downloads for a library that you didn't touch for two years, and thus presumably didn't promote? And that you don't use yourself? With less than 50 issues total? And with very niche use case? I can't believe that number. My guess is on bots, e.g. mirroring the repo.
Hmm. You are right. Perhaps I will rewrite that section. The argument here is that with Spock you can easily argue WHY a test has problems. So if you see a bad Spock test you can go to the colleague and say "Look this test has 6 when: blocks and 6: then blocks. We agreed that we should have a maximum of 2". And now it is very clear to him/her why this test is wrong and how to fix it. So with Spock you have a common language on how a test should be structured. You could even provide Spock "test templates" with the acceptable block structure that your particular team wants to work with. This is not that easy with JUnit. But you have a point that it is not very clear in the article. Thanks for the feedback.
I tried to keep the Spock examples as simple as possible (and in fact I did not use Groovy constructs such as def which are confusing to Java developers). Especially in the mocking section I show the exact same test between Mockito and Spock. If you already have good JUnit tests, converting them to Spock is as easy as adding given/when/then labels and changing the assert statements to Groovy statements. No change in the test structure is necessary. Can you tell me which Spock examples you think that are structured differently so that can I look at them? What more example would you like to see?
Aha! You are right. I think I will include this as well in the article. Thanks!
&gt;With a large team working on independent branches I think the rule should be that you don't get to name your script with a version number until you commit to develop Or you can use Liquibase, which does not depend on the naming of the files (just their checksums) so you can name your script however you want even if you have 100 people in your team. Of course Flyway is better than anything if you compare it to custom scripts. But Liquibase is even better.
Yes. My point exactly. Depending on the name of the files rather than the checksum is a really bad design design for Flyway.
How about mocking a static method that reads a file and returns a result from it? Just as an example.
90% of tests I've written were for code that I didn't write myself and I don't want to change just for testing purposes. But yeah, the prototypical static method case I was thinking of was stateless.
No. I wont. There is a reason that Scala is at position 31 on the Tiobe index.... 2 positions *below* Logo !! 
Don't use a static method for that
Don't use a static method for that
Don't use a static method for that. This is a prime candidate for an interface called from *user* code. File manipulation is a low level detail that lives in the system interface layer, where you write integration tests and don't use mocks because you're testing real behavior.
That's interesting. 90% of tests I've written are for code that I write myself. Why are you writing tests for code you didn't write? The only other time I'm writing tests for code I didn't write are integration or functional tests (in which I'm not using mocks) or I have to improve test coverage (meh, whatever).
Well no setter but a builder that is used by the repository and potentially any client... when you create a new entity you should be able to set it but not modify after it is set...
&gt; Why are you writing tests for code you didn't write? Because there was a low level of code coverage in the existing tests, and more importantly, it was code that was being worked on, so my tests gave confidence to changes being made.
Why would I tell the authors of the JDK anything? Java has interfaces. I'm never going to mock any of the static methods in that class. I would only ever run those methods for real in an integration test.
[removed]
Meh, I have the feeling that IBM would adapt OSGi to whatever Oracle cooked up (grudgingly), but the big O went out of their way to make JPMS incomatible, in the process crippling it.
We've been using Spock for all our unit tests in my Dept for 3 years and never run into a problem. I like Spock a lot.
i have a (more or less unreleased) javascript library with very similar syntax to your new style. it makes creating DOM feel very natural. go with the new style i have some similar issues. i use varargs and will accept any number of children. if an argument is text, i check the first character. if it's a dot then i treat it as a class, if it's a # then an ID, otherwise it's a text node. you can explicitly made text into a text node with a text() method. i use some similar tricks for handling other properties i don't currently use java to do any html generation (i use my javascript library on the client side) but if i was going to, your library (with the new syntax) is exactly what i'd want
&gt; it does not depend on the naming of the files So how does it determine the order the scripts should be run? You don't have to answer, I'll be investigating Liquibase.
Then I don't understand what the problem is? The read-only values should be immutable.
You did not specify what is your current java library. It is just a library? Standalone? An executable? Does it use Spring already? Anyway. you should avoid servlets or JSF. The first is too level for what you want, the second is an overkill. Options * Use Spring Rest. It can be used without Spring-boot * Use Jersey/JaxRS if you want the JavaEE solution * Use a third party library like resteasy or restlet Dropwizard actually uses Jersey, so you can use Jersey by itself Spring boot is also not a requirement for Spring Rest (although they work together obviously)
yes they are. a rest service put accepts all properties creates a new entity with a builder and calls update on a service which passes it to the repository.
definitely use an IDE. some of them provide some code-generation magic, but just don't use that functionality. code completion and javadocs popups make learning the language much much easier my feeling is that netbeans is the easiest of the 3 to get started with, though many people swear by IDEA. i believe the consensus is that eclipse is the toughest to start with, but possibly the most powerful platform 
I never released it. There were so many other alternatives, and I didn't really think it offered anything special. I'll see if I can find the source if you're interested.
yeah, i'm in a similar situation with my "version"
Java 8 didn't make imperative programming obsolete, it just added some concepts borrowed from functional programming to **complement** existing functionality. This mentality of "migrating" completely from one style to another style of programming is insanity. &gt; We Dont write for loop any more in java 8 I know the worm looks tasty, but I pity the pour souls who bite into that hook.
I started with Eclipse, but that was before IntelliJ IDEA became popular. It's hard making a recommendation for beginners, because I don't want to recommend Eclipse because it's so bad, but IDEA might be too difficult for beginners to understand. I've never tried Netbeans, so I'm not sure how good it is for beginners, but /u/nqzero seems to think it's a good one for beginners.
I'm all for the syntax sugar available in Java 8; I use the lamba form for Runnables all of the time. But most of the functional programming techniques using streams run slower than imperative loops, so there's no compelling reason to use them. 
Sounds like every new oop language nowadays. Rust, pony, all eschew inheritance in favour of traits and other compositional mechanisms.
I have lost hope with Jenkins cleaning up it's act and am very happy to see Concourse beside it. It's a much better CI system that deserves to be discussed more.
I will happily give Liquibase an honest look, I really will, but it still has to be said: When even the shitty, not-invented-here migration script setup at my current work can, as much as it is greatly lacking in numerous other regards, be free of numbering and naming issues with dozens of developers having at it in a free-for-all, and as much as I'm sure Flyway has its problems (no down scripts, really now,) when I hear people blaming the tool and laying it on the wrangling of a sequence of files, _the tool is clearly not the source of that problem_.
Just use Eclipse or IntelliJ. Both are fine. They both will provide tools that make programming easier. 
Start with Eclipse, or any IDE. Once you have some experience, switch to a plain text editor and learn to compile yourself. IDEs hide some complexity from you, but it's valuable to understand. Once you understand, you can switch back to an IDE. 
I've been working with javapoet before, see my other project "zerobuilder". Please leave a feedback when you try it. Cheers!
I second this opinion. Scala is a natural successor because it can mix FP and OOP pretty easily. But the downside is that it needs significant time investment to understand, which is the nature of all FP languages. If we continue adding more cores per chip to keep up with moore's law then we need FP languages more than ever. 
As of today Intellij. In the near future, something like [Eclipse che](http://www.eclipse.org/che/)
Definitely this. IDE later, when you know how everything works. 
Ah, it sounds like you are asking a more general question. As in, you are exposing a resource through REST with a GET, but you don't want to allow the PUT to update certain attributes? From a REST perspective, if the PUT is updating immutable attributes, then you could return 400 Bad Request, and the response body could list which attributes you can actually change^1. Or, you could allow the PUT to go through and ignore the invalid inputs, but then the subsequent GET wouldn't match the PUT, which is kind of inconsistent. This sounds more like a question of input validation that would be happening before you even hit the repository. Also, I'm not sure if a resource mixing mutable and immutable values is necessarily a good idea. It seems like smaller more focused resources that don't mix up different kinds of values would result in a better user experience. In the repository, you probably have a `create` method and an `update` method. In which case, if you are creating, pass all the fields to INSERT statement, and only pass the mutable fields to UPDATE. This would work because the entity is fully encapsulated, which is a guarantee you can maintain on the Java side. ^1 You'd probably have to do a SELECT first and pass a fresh entity to the constructor for comparison, unless these values cannot change at all in any other circumstance. What you got by GET might not match the current state of the database when you do a PUT, so even if you didn't change the values, it would still look like a change.
I'm not judging you. Also, it is a subtle difference in English that confuses even native speakers. So I thought an explanation would be useful, demonstrating why "technical debt" as a metaphor is useful. Because treating it as an analogy for real debt isn't useful.
Interesting. . . can you summarize why composition is considered better? 
&gt; The Tiobe index is a bad way to measure programming popularity, where it puts PHP above swift. You just need to understand the measurement and its limitations. However, I believe its accurate when it comes to PHP being above Swift. There are more web developers than iOS developers. Not to mention, PHP has been around long enough to have a large following. Scala is not as "hot" as it once was. It's not the only language bringing functional computing to the JVM. Java8 slowed down some of its adoption and Kotlin is attracting more new comers. 
My first few weeks I simply used the notepad and the command line. Afterwards I tried to use eclipse but I had no idea how tf to use their interface for creating a simple program. I then decidedto download netbeans and it was waaay easier to learn how to use it. But that's just me.
I am surprised nobody said this ITT, but one can use PowerMock with Spock and mock static methods. I am not saying it is a great solution, nor I am advocating for any design pattern that would lead to untestable code. I just wanted to say that it is possible.
I hope somehow enough vote "no" and the JPMS gets reworked until it is useable.
Honestly. I've used both and eclipse is not garbage. In fact there are plenty of things eclipse does better. At this point I still prefer IntelliJ, but it's not black and white like you make it out to be.
That's probably the best part of Java 9. So powerful 
we used JSF, hated it. Then spring mvc with spring security (which I prefer) but now PHP/JS/node team handles UI and we only handle backend stuff
This was poorly written... Also, all your examples say from given list but you're starting with Stream.of() which isn't a list it's a stream. 
The Tiobe index is complete rubbish. It measures the amount of hits on &lt;lang&gt; programming. That's all. I hope you can understand why languages like C, C++ and C# get a lot of hits in text indices. There's a reason Google won't show you the long tail of search results, you'll get a lot of hits on "Arthur C Clark" for example. Stuff like SO questions, github contributions and Indeed job listings are much better measurements. 
IntelliJ, there is a free community version. Use it. When you compile in IntelliJ you know how to compile in cmd, InteliJ shows you the exact options it uses to run and compile as you would in the cmd line. Recent study shows Eclipse is losing ground very fast. http://www.baeldung.com/java-in-2017
Well, that sounds horrible. Luckily java can be learned independently, so if you need to really learn it, the teacher isn't necessary. I think I stopped going to java lectures after the first one and only visited the practical exercise class.
Oh, we are same. Can you tell me your story?
**Plagiarism!** This post is copied nearly verbatim from: http://programtalk.com/java/java-9-new-features/ which was written on March 5^th 2017, over a month earlier. **Post removed**
You might want to do [this course](http://mooc.fi/courses/2013/programming-part-1/) in parallel if it's really that bad. 
you can do all that without a specifically wired entity manager....
The things that I really need help with is how am I able to transfer with this college? I am still having other class which needs to pass like physics one two three.
You can unwrap the EM into a Session, that's true. With Hibernate 5.2, the Session is now implementing the EM interface too.
That was pretty much my experience with most classes in College/University and I'm not in US. Just be lucky you have youtube videos and online lectures of almost everything now. When I was studying there was only the library.
When you press run you can see the exact command line in the output window (on top kinda hidden) to execute to do the same as you would in shell. So, you're wrong. 
You know the repositories also use the EM? If you just extend JpaRepository? 
He was specifically asking about Spring Data REST which can directly expose your domain object as REST resources with minimal programming involved. Ideal for quick prototypes, not so much for production applications IMHO. 
And if you unwrap the EM, you get access to even more features that will probably reach JPA in 5-10 years. So, from a JPA perspective, using Hibernate is not like you are living 5 years in the past, but 5 years in the future.
You are right. I hate reading. The only thing I have read is just online tutorial. 
This leads to massive confusion and unneeded frustration.
yes I agree with you, I just wanted to make it short. I am just trying to show potential of java 8 for people who are still using java 7, so just wanted to showcase sneak peak of stream api and lambda expression in short.
Multiple Inheritance is tricky because of the "diamond" problem, while single inheritance locks your classes in a certain hierarchy, which often becomes more of a hindrance as the code gets more complex, because of cross cutting concerns that cant all be addressed by a single tree. Shared utility methods are often a better way to share behavior between related classes than having a rigid, unique, common ancestor. 
I would actually say that Spring Data REST's biggest flaw is that it actually does *not* provide full customization over its components, as you might expect from a Spring application, and instead assumes that certain functionality must be consistent across all implementations. I am not saying this is bad or wrong, it is just something that needs to be considered when using SDR. SDR makes a lot of things much easier, but that power requires giving up control over some components. 
I am actually a recent convert to Spring Data REST. We use it in-house at a small-ish biotech company to sit on top of our warehouse of ~1 TB of processed genomic data and serve up data to several web applications within our network. I find SDR great because of the ease of creating or extending the data model, the standardized representation of the data, and all of the other great features that come with Spring. There are some downsides to using SDR over a custom web service application, primarily limited customization of the SDR components. Overall, I am happy with our move to SDR, I would definitely use it for other apps.
After decades and making millions using it, I am not sure that even if there were 90 awesome new features I would ever want to move back to Java as my primary production language. These seem so... pedestrian.
The maven central badge is grey because it's not indexed yet. But it's already released and usable, see the xml tag at the bottom of the README.
Thanks Oliver. I am not promoting it, but I like the course on SDR by teamtreehouse. Have you had a chance to look at it and what do you think?
The components I wish I had more power to change control hypermedia creation and query-string-to-repository-query translation. Adding additional response media types could also be easier.
Might need an asterisk next to JPMS/Jigsaw as both IBM and RedHat have major concerns with it in its current state and Spring won't be fully supporting modules until Spring 6, which is schedule for 2019+. I guess it's too late to pull Jigsaw out of the Java 9 release, but as a friend put it, when you have to add a kill switch to turn off a feature, you have to start questioning if that feature is implemented correctly and wanted at all. 
Interesting. So have you had a succesful hateoas implementation? I like the idea, but i am yet to see a client capable of fully utilizing hateoas. Do you know of a good example of such client?
You could attach the enter &amp; leave through bytecode runtime weaves using https://eclipse.org/aspectj/ In fact they have code already setup for you to do just that: 1. http://www.eclipse.org/aspectj/doc/released/weaver-api/org/aspectj/weaver/tools/CommonsTrace.html 2. https://github.com/eclipse/org.aspectj/blob/6d6738cfece6328027916681e67e54225531db38/tests/other-systems/util/TraceAll.java
This is literally r/java so why are you here?
Unfortunately, I don't know of a good example project somewhere that demonstrates this, but I am sure there is one. It is nice not having to hard-code URLs in client applications, but rather have it follow the links in the SDR-returned records. In theory, this would allow for smoother transitions between updated API versions and easier discoverability of new resources, but our apps are you enough that this is not an issue we have run into yet.
nothing in that list seems compelling - a huge amount of disruption for no tangible benefit. after the amazing improvements in 7 and especially 8 this is disappointing
That is the common response I get. I have never seen any clients that actually inspect links and use it as the application state. It's like everybody is repeating this mantra, but cannot actually show any instances of where it is used. 
&gt; but as a friend put it, when you have to add a kill switch to turn off a feature, you have to start questioning if that feature is implemented correctly and wanted at all. It can be the best implementation possible and there would still be concerns over backward compatibility. I don't see the existence of a "kill switch" as evidence that the feature is ill-conceived just potentially not backwards compatible. 
I wrote my own mapper that uses generics to analyze the source and destination class. It checks if there is a getter or setter with the matching data-type and uses that. If there isn't, then it sets the protected property directly. It's responsible for also checking the permissions. EDIT: looks like it might be possible to do this with JSONViews: http://stackoverflow.com/questions/17276081/spring-3-2-filtering-jackson-json-output-based-on-spring-security-role
There are many differing opinions on which language is best suited for a particular task. Some become mainstream while others become niche. it's the nature of the market.
I suppose that's fair. Though I definitely think Jigsaw is also very far from ideal. Put a lot of time into reading up on it and it just doesn't seem worth it. There are some benefits to modularity to be sure, but the juice is not worth the proverbial squeeze. At lesser in my opinion.
https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/time/FastDateFormat.html http://stackoverflow.com/questions/4541636/alternatives-to-fastdateformat-for-efficient-date-parsing
Not that I've done it with these technologies but map the json response to entities. You could probably use something like dozer for this.
Make a todo application. Make a web interface that you can add things to do. Add some todo's like user logins, remove items, edit items, share items, send alerts.. and so on
Check "Going Native" and "Machine Code Snippets" http://www.oracle.com/technetwork/java/javase/community/jlssessions-2016-3114175.html
[removed]
[removed]
Thanks for the clarification
Then just extract the roles and use an if statement to make sure it has the right role?
Never mind local variables, it has a much larger impacct when used on classes and fields.
It's more than just OS. It is also Z chipsets.
A not so good example of why parameters are sometimes final. public void doWithValue(int anInt){ if(anInt &lt; 1){ anInt = 1; } .... } If someone calls doWithValue, they may think the value passed in won't change
I really don't get Javadoc like why not just look at the class itself it's way quicker..
[It won't](https://ideone.com/9xsMst). Java is pass by value. The int passed to `doWithValue()` will actually be a copy and not a reference to whatever int you used as an argument. This can be confusing because if you pass an object reference you will work with the actual instance in `doWithValue()`. In that case though you are passing a copy of the object reference which happens to look and function almost identically to the original.
&gt; List&lt;String&gt; strings = List.of("first", "second"); It only took 20 years to get it right. But I guess we are so used to the inconvenience already, that we barely even notice.
Personally, I discourage use of final for *local variables*. It only makes the code more verbose. Whenever I see this in the code, I am thinking to myself "Wow, this programmer surely doesn't trust himself!". In fact, I suggest avoiding re-using (reassigning) variables altogether and prefer the functional style of writing code. The only place where I see it beneficial in a modern Java code, is *member variables*, for immutability.
Just start to write code, make mistakes and fix them. Start simple and then make something more complex. Understanding comes from experience. That's the way I learned to program. Viel Glck!
This article fails to mention the most important feature in 5th point: http://download.java.net/java/jdk9/docs/api/java/util/Map.html#of-K-V- How can you not mention shorthand creation of map? Nobody cares that much about lists and sets as both could have been one-lined with Arrays.asList()... (not talking about guava here)
I don't trust anyone - myself least of all. After all, the vast majority of bugs I've encountered have been written by me.
I believe using Spring Data and NOT using Spring Data REST gets you to a sweet balance spot where you: * don't need a lot of boilerplate for the boring persistence part * have full control over your REST API, fully utilize Hypermedia (not only CRUD, but also for business actions) and adapt to your mobile or web client needs. That's what I've used for the past few projects and it technically it worked out pretty well.
any exception it gets them fine.
when first designing the db in dev we sometimes do, but environments after that (especially production) we don't
Fair point! Also, [Map.ofEntries](http://download.java.net/java/jdk9/docs/api/java/util/Map.html#ofEntries-java.util.Map.Entry...-), I find the alternating key/value params in `Map.of` a bit more awkward. 
Java is not pass by value. It passes primitives by value, it passes objects by reference.
I've been following Jigsaw since its inception, and I think Oracle really hurt themselves by being so secretive about it. I was hoping that the secrecy was only for the public, but given IBM's and Red Hat's reaction, it sounds like it was pervasive, and they're both now pissed. I'm not sure what Oracle's next step is going to be - they're paying the price for not being open and collaborative. Ideally they would reboot the effort and include more parties and use cases in the design, but that's a tough road so close to Java 9's release.
Wow! Seriously? and what is the object reference?
Guess, it's a sarcasm: vavr as in the logo is "java" if you flip the letters. 
I wanted something more generic instead of hard-coded if statements in the mapper. I annotate my properties in the DTO something like this (excuse the incorrect syntax): @DTOMapper(write="USER") protected String name; @DTOMapper(read="ADMIN", write="TENANT_ADMIN, ADMIN") protected String someAdminField 
Really? I find the first one easier to read. I look at the append statement in the second example, and have to think about what its doing and then start worry about edge cases and whether they are covered in the unit tests. 
So. Was that effectively a "fork" of the OpenJDK?
Do you have anything better to do? Don't have a job eh? Too bad for you. 
It's not constant, though. You are free to do anything with a final member except reassign the reference. ie final List&lt;Foo&gt; foos = new List&lt;&gt;(); foos.add(new Foo());
Here we go again.... The never ending debate over semantics. It's pass by value. Primitive types and references alike.
Here's a very simple way to demonstrate that Java is pass by value. How would you write a swap method with the following signature? void swap(int a, int b) C# can do [pass by reference](https://msdn.microsoft.com/en-us/library/t3c3bfhx.aspx), so it's no problem: void swap(ref int a, ref int b)
Can you compile the software with the 32 bit JDK and see where that gets you?
It was not secretive at all, Jigsaw has been public discussed for the last years and both companies are on Java development mailing lists. This is just plain politics.
When i started to teach myself the books that I used did not create a complete program in the sense that I would think of. There was no "larger picture" program to the lessons I followed, i might have just picked the wrong book. Once I started to look at and use an actual program, about a week. Then it took about a month to really understand what was going on better and be proficient in coding.
In [jOOQ](https://www.jooq.org), these are always final per default: - Classes (except if they're called `DefaultXY` or `AbstractXY` to clearly indicate that subclasses are desireable) - Static and instance methods (except if there's a really good reason or wonky workaround for some edge-case overriding, or if they're inside of above `DefaultXY` or `AbstractXY` classes) - Static members (almost always) - Instance members (whenever possible) - Our opinions on the `final` topic, when someone dares challenge our opinions These are only final when needed (i.e. when an anonymous class needs to access them (jOOQ is still mostly Java 6 compatible, so no effectively final feature usage there)): - Parameters - Local variables The reason is that making them `final` wouldn't change / improve the API as it has no effect on the API's consumers and / or performance, so we can avoid the visual mess introduced by the extra verbosity. So, in other words: Everything is always `final` until there is a *very* good reason to make it non-final.
&gt; The runtime and JIT are smart enough to detect that something is "effectively final" You mean, as in effectively final members? :)
Haven't encountered a need for it yet ever.
&gt; the number of times I've had to override something in a piece of legacy code So, what's the chicken and what's the egg? Perhaps the code has become legacy because you started overriding, instead of refactoring...? (this was maybe downvoted because it sounded harsh. Sorry, wasn't my intention. But I'm serious. You shouldn't override things. It just makes the design worse)
Likewise, except we elected to use Flyway.
Would you do this even for parameters of interfaces?
The type system is more complex than we need in a programming language. When we talk about Scala we talk about monads rather than for loops, when they're achieving the same thing. It's like programming for aliens - in the end it's practically the same, but the language is all different. As a programmer, I don't care about the mathematical underpinnings, and I shouldn't have to care.
A crap, I was in a rush. Thanks for the correction.
Method parameters are a common place to include the final keyword. The purpose is to prevent functional side effects.
I second this. It's so much better and easier to read than JUnit Theories.
A new internet.
Question: why would jlink need jigsaw modularization anyway? Couldn't it just scan used imports?
I'm not sure you have a full grasp of how Spock works or what it's uses are, (outside looking in) sorry buddy. Spock can do everything that any Java testing framework can do, save Powermock and JMockit. Interestingly enough, if you have JMockit tests that sit along side Spock tests, you'll get random tests (from either JUnit or Spock) that won't run. This is due to a known issue with how JMockit messes with the classpath. But, I digress. If you actually have a reason to mock static methods from some antiquated library, you should probably wrap and isolate those behind some other api and use PowerMock or JMockit to test that wrapper api. That'll let you isolate those dependencies from your project (hopefully rewrite them as you go). Then you can use a sensible mocking framework (if it be Spock, Mockito, JMockit, or whatever) to test your code. But, afaik, that's it to Spock's limitations. What we really like about it is, our QA write their gherkin tests off the bat, and we get to write our integration tests from those. We write unit tests in Spock as well, and our JMH benchmarks show them to be comparable in execution time to those written in JUnit and with Mockito, and faster than any written with JMockit (most likely due to the classpath issues I mentioned earlier).
Why is this better than just using an intellij plugin to build a builder class or lombok? 
I don't think they'll all that sparse, you should probably attend some job fairs and talk with some recruiters.. what area are you in?
Can anyone explain the benefits of the proposed Module module system (aside from a modular JDK/JRE which sounds entirely reasonable)? From what I have seen, I don't see any upside for most applications, and given that this is destined to be a mandatory feature, that is a steep cost to pay for very little (if any) benefit. If I needed or wanted a module system, I would opt-in by using something like OSGi. But for most uses, I ship my dependent JARs and move on, and everything works great (could we use a better way to assemble and ship executable applications in a single package? sure - but that's definitely what we have here). My biggest concern is the way the Module system will restrict application in ways that we don't yet fully appreciate. I think that one of the things that made Java so powerful and encouraged its popularity was that it was easily extensible and everything could be introspected and manipulated at runtime **in ways that the language designers could never have possibly envisioned**. Look at frameworks like Spring that go through the classpath and change behavior based on annotated classes, application containers like Tomcat that can load and run arbitrary code while keeping it isolated from other applications using classloader magic. In a modular world, many of those techniques won't be possible anymore (or will be more difficult), and I worry about what that will do to the ecosystem and viability of the platform.
Write an application that tells you which numbers are divisible by 15 or 5 or 3.
I think he's looking for a guy in marketing
Make a program that programs itself to do different things. It could be anything, just find a way to make a program write code.
I know it doesn't answer the question, but I want to advise you NOT to use RXTX. We used it for a project I was on, and it was nothing but pain. Have you yet hit the concurrent access bug? It builds a list of connections (in the C code called through JNI), and if it tries to access the list while it's changing the list, it will crash the JRE. Your whole app dies with no recovery because of unsafe programming. That's the most obvious thing it does wrong. Since you're still in early days, I would recommend using something like JSSL (the Java Simple Serial Library) that provides open, close, read and write ops without crashing your entire application. We made that switch and the speed and stability improvements were immediate and palpable.
Honestly if you read the breakdown it's far from just politics. https://developer.jboss.org/blogs/scott.stark/2017/04/14/critical-deficiencies-in-jigsawjsr-376-java-platform-module-system-ec-member-concerns?_sscc=t
This. And it's not just debating semantics, it's critical behavior to understand. To be clear: Java object variables are pointers (not references). When you pass an object to a method it copies the value of the pointer. It is pass by value, always, just not the value of the object itself. So the variable you use in the new stack scope is a *different* variable than the previous scope, but the value of the reference is the same. A pure pass by reference would result in the two variables being identical in both scopes, meaning an assignment operation in the method scope would change the value of the object referenced in the parent scope.
The MEAN stack is the new hotness. Is there a reason why you want to limit yourself to JAVA web development? My best advice to you is to learn every language and technology that you can and then use the best tool for the job. You will find yourself more employable especially early on if you skills are more diverse.
Usually when the method declares and starts a thread (or anonymous class) which needs to access a parameter value--in which case the parameter must be final. 
The Illuminati almost succeeded in destroying Java, fuckers
I managed to understand java as a language fairly quickly, but that's because I picked it up after 10 years of programming in other languages. I'm still scratching my head about some of the core SDK api, though, and that is likely to continue with the upcoming 1.9 version. The first programming language I tried to understand was AppleScript. I failed miserably. It had a script recorder that would put my actions into code, and then I'd look at the result and tinker with that. But creating it from scratch? I never managed that. The first programming language I managed to understand was a declarative one: HTML. It took me about 3 months and lots of trial and error, to feel comfortable. That's 25 years ago. Today, HTML5 still manages to surprise me. And that's why I like it.
No. Brian disagrees. He said in his article on the IBM network in 2008, that its effect on classes and fields is overstated, barely measurable, and usually done for wrong reasons. He went on to advise making member variables final instead, almost always, to ensure immutability, which does have impact.
We use final _almost_ everywhere. Only classes designed for extending (or a framework requires it) are non-final. However we don't religiously mark methods of these non-final classes as final, even for methods that aren't intended to be overridden. However the whole team marks local variables and, after being bitten by a copy-paste maintenance bug, parameters as final. All fields that can be final are. I agree it's a lot of code bloat, but the code is constantly refactored and altered by many hands and finals help show intent. The bloat is a fault of the grammar, not the developer. There's a reason that languages are moving towards final as the default (rust being one of the extreme examples) - there are classes of coder error that simply can't happen without them also loosening the declaration. That said, if we were distributing libraries for others to use, we might be less inclined to make some classes and methods final - purely to leave the door open to patching issues outside of the release cycle.
What I wrote after reading it again did sound like a commercial for mean, I didn't really intend on that. I would agree on the nosql front. I've yet to really come up with a good reason to use it. I have to disagree about angular going away though. React is great but I feel like angular 2 is edging it out in many ways. My advice to diversify both languages and tech stands though. Not that JAVA is necessarily bad or good, but if there jobs in your area won't support it, love for the language won't feed the kids. That was more what I wanted to say but tried to shorten it too much the first time.
&gt;effect on classes and fields Classes and *methods*. &gt;He went on to advise making member variables final instead Fields are member variables. 
Try applying for internships at established larger companies. Look at the job desc for the more senior level positions to see if they use Java. If so, they're likely to be using Spring (maybe the desc explicitly says otherwise) and you'll likely walk away with a little experience with it. I'm starting to see a lot of Spring Boot in job descriptions lately, maybe it's where I'm at though. Don't confine yourself to Spring though, for web dev there are other stacks in use such as Play and Dropwizard (I see this a lot actually). It's the Java experience that counts if Java's your choice.
It's an unwillingness to make the initial investment.
PM me with your resume please, I'm looking for an intern soon to help maintain/develop my current suite of software which is 100% Spring Boot. (I'm a one man shop, but have lots to teach. Obviously if you are looking for a bigger company, I get it). I don't know why there aren't many opportunities as Java is still the most popular language for apps. I think Java loses the culture war bigtime and is just about never what the "cool kids" are using.
I'd imagine partly because they are hiring for the work they need now, and not the work they need a year from now.
If you're hiring for work you need now, you're already too late. The domain knowledge purely local to the company  not to programming, or even the industry  should take a few months. So it may be more of "hiring for several months from now" rather than "hiring for two years from now". 
Do you want me to list the amount of public sessions about Jigsaw at JavaONE, Devoxx, FOSDEM, Java Languages Summit, including workshops? It is naive to think they weren't able to get any info beforehand.
they don't know what they're doing, they don't know what to ask for, they have no fucking clue what they need. with that being said: nothing much you can do about it, except apply to a "side" job and go from there into java (if that's your thing). 
I'm not sure what you're point is here. As I said, I've been following this for years, and I've been to some of those presentation. A presentation is not a dialog - it's a one-way avenue, especially in large public forums like that. Do you expect the design leads of JBoss Modules and OSGi to get in line, and provide their comments in the 5 minute Q&amp;A blocks at the end?
In the world of microservices over HTTP, it's all rest calls all the time. In that world, Java is a first class language. However, it's delivering JSON or XML to another service rather than HTML to a browser. If you're looking for a single cohesive job that touches the customer facing front end and a Java back end, those are pretty rare. However, if you expand your search into things that might use web technologies but aren't necessarily customer facing, you may have better luck.
&gt; Whenever I see this in the code, I am thinking to myself "Wow, this programmer surely doesn't trust himself!". A while ago on a project where I advocated in favour of doing peer reviews one of the developers (internal, I'm external) responded with "why do you want reviews, don't you trust your own code?" as a counter argument. No I don't trust my own code. And you shouldn't either. 
Coding even in its simplest form can be pretty complex if you really "look under the hood" to quote my CS teacher. Truly, the best way to learn with any language, Java included, is to get your hands dirty. Try something very direct, say adding two integers. Then change them to doubles, and see what happens. You can learn a ton just from practicing the above. I've only been coding in Java for maybe a year now, but I still fall into the phase of "Oh shit, what do I do here?". Be patient with yourself, and don't panic if everything doesn't happen all at once. 
I can agree with that perspective, but for the more novice roles than mid I think it's more likely because they don't want to spend the time and money on someone just so that the shop on the other side of town doesn't get away with not having to. A common side effect of this is brain drain.
Focus on integrators/consulting companies. There is a shift to per-project work and most enterprisy companies that 'do' Java hire a lot of externals. Those consulting companies do train newbies (they have to). 
Thanks!
&gt; Interesting. So have you had a succesful hateoas implementation? We use it. I don't really see why so many people see it as problematic. We had some front-end devs balk at the idea but they're now fully on-board.
It really isn't. Angular usage has fallen massively in favour of React over the last few years and most companies have realised you need to use relational databases to store relational data. Neither of those choices exclude a Java web service either. 
Nobody who uses OSGi is interested in JPMS at this point so long as they can find a way to keep it out of the way and ignore it. It simply doesn't solve any useful modularity problems so we don't care. We just need our tooling to automatically generate the minimum necessary metadata from the OSGi metadata so we can forget about it. Nobody who has any part of their business built on selling OSGi will feel threatened by JPMS that's for sure. In other words I can see no business case for them to hold back JPMS other than the legitimate, sincere opinion that it's bad, but maybe I'm missing something?
It leads to exactly the opposite.
Tl;dr Juniors are a big investment (time and money), and generally are only just productive for the first 9-12months. From my experience (I've got around 7 juniors at the moment, most straight out of uni or similar), that Java web developers tend to have a slow ramp up. It takes a long while for the 'average' graduate to get to the point where they're self sufficient at tasks that are beyond trivial. There are only so many tasks that you can give to junior Java web dev, and that's mostly crud, maybe some more interesting service work like batch jobs or reporting. But the chances are if your building your app In java you've got some big business logic somewhere and generally juniors struggle with that. This isn't because they're incapable, but because they have to think really hard about the implementation - leaving little time to really understand the domain. If your in the UK though, pm me. 
&gt; Naturally that only works as long as an application just uses a single version of a given module Not true. It is entirely conceivable to have a module system resolve dependencies and create a module graph without heeding any version information. For example consider this command line flag: --resolve-dependency com.company.foo/com.google.guava=mods/guava-v20.0.jar Or, on a different level of abstraction: --resolve-version com.company.foo/com.google.guava@20.0 (Even the current implementation already supports storing version information in the module descriptor, so this flag would simply have to read that info.) There are various reasons why this won't currently work ([eliasv mentions some of them](https://www.reddit.com/r/java/comments/677sgu/java_se_9_jpms_modules_are_not_artifacts/dgro67l/)) and I'm not saying this is how it should be done. Just that an external tool that already has to deal with the whole versioning kerfuffle could advise the module system how to handle different versions _without_ the latter having to reimplement the entire feature. 
I'm a junior Dev and I know your struggle. It's a huge investment for the company you're looking to join and there is a high risk of juniors leaving very quickly if they realise that it isn't for them. I would recommend to write as much code as you can and publish it to a git repository (you can make if private if you want). You can then show your interviewer some code that you've written if they request it (or you can mention that can show some code). http://www.exercism.io is a code place if you're stuck with ideas. Just keep going, you'll get what you want.
Swift is slowly finding its way into the serverside, as has JavaScript through NodeJs.
Okay...
&gt; they should have raised the red flag last year In all fairness, at least the OSGi people did. There are many critical posts by Neil Bartlett and David Loyd on the mailing list.
As others have mentioned, dont restrict yourself to just spring boot and java. I have created web-apps in PHP, Ruby-on-Rails, JSP, etc, depending on customer demand and if the framework was already decided for whatever reason. There is nothing wrong in node/express, given them a try. For my latest project, i went searching and learning the latest and greatest and dribbled first with Angular 2, then VueJS and finally settled on React for frontend(took 3 weeks and plenty of online reading, youtube and small projects to try all of them). On backend i used Spring-boot and elasticSearch. Yes ES as my only DB, but then after facing some challenges (nothing serious), i moved to Postgres. So my current stack is React + Spring Boot + Postgres.
I wanted to use it, but my project has multi-tenancy (multiple customers and multiple users under each customer). Now for each user-action like read, update, i want to ensure it can only access the data for the customer it belongs to. My tables are multi-tenanted too. The way I do it today is in the controller, i fetch the user making request, then find the customerId of that user and then use customerId in all service/repository calls. Is there a better way to do it with Spring Data REST? Any guides?
I don't think they waited until the last minute - as my previous link showed, the OSGi folks were trying to give feedback back in 2012, and were clearly frustrated. From your perspective, how should IBM and Red Hat replied if they felt their perspective was being ignored? Do you any comments on the JBoss blog post regarding flaws in Jigsaw? 
I knew it was about LLVM, didn't expected to be so soon.
&gt; I said it comes with baggage. Monads are stuff that you don't need to know to program, yet there they are in every Scala textbook I agree with this point. But the problem is with the scala textbook. The authors have not made efforts to isolate the OOP part and explain it separately. TBH, I learnt this the hard way. But found scala to be a very good OOP language as well. &gt; A programming language should only be as complicated as it needs to be, and Scala has more than it needs Java's swing has needless components that is built in part of the JDK. I can also argue for many other things. But the fact is all languages have this baggage. The compiler being slow is agreeable, but definitely not a new language kind of a problem. &gt; This makes the compiler slow and (in my experience) unreliable. I am thinking that you have tried either an unstable/beta version or tried it pretty long back. Things have improved now. Dotty is another improvement that is coming up. 
If it can be done by a junior, it can be done on the other side of the planet.
JPA is a specification for a standard persistence API. Hibernate is an object relational mapping tool (let's you write code that expresses sql queries in terms of your model objects). Hibernate does provide an implementation of JPA (they aren't the only ones though). At the end of the day Hibernate can be used with or without JPA in your project. JPA is just a spec and must be used with an implementation (like hibernate) 
[removed]
Apart from that it doesn't compile, it looks like it would leave a trailing space of the number of files &gt; 1.
You're right, my first comment wasn't very useful or constructive, I apologise for that. But even if we put aside the multiple coexisting versions problem, I still think a module system which can't reliably validate that a set of modules is correct is a bit naff. I accept that we can still manage our dependencies with external tools in the same way we always have ... but then the module system hasn't really brought much to the table other than the isolation aspect, (and that's problematic for a number of unrelated reasons). The inflexibility wrt module substitution I described is still there. Perhaps external tools built on Maven can be modified to semi-validate replacement artefacts based on whether the module names match, but it still reduces us to manually managing versions. If there is no formally specified versioning of modules we can't necessarily assume that two providers of the same module follow the same versioning scheme! Yes, we know we can work around all of these problems, because we already do. I'm just personally disappointed that we're getting a modularity system---something which *could* and arguably *should* address these problems---but the designers chose not to.
Accept that Jigsaw never was intended to be an OSGi replacement, which Sun and later Oracle always made very clear.
That is the point, Jigsaw never was intended to be an OSGi replacement, which Sun and later Oracle always made very clear.
&gt; If you're looking for a single cohesive job that touches the customer facing front end and a Java back end, those are pretty rare Can only speak about the UK but I'd disagree and say that's actually pretty common in the finance sector.
Thank you! I stand corrected.
You need to be careful not to assume the _content_ of that array cannot be changed. It can. Only the reference cannot.
I wouldn't call an immutable field constant unless it's also static. The idea is that there is only one instance of a constant.
Where are you looking is probably my biggest question. For junior level you're going to want to focus on larger, enterprise companies since they have the infrastructure to help a junior dev succeed. You work there for a few years and now you have a resume that others will actually look at and the skills to back it up.
Java is "enterprise" development for the most part, used by large companies still. So they want you to have experience.
My example was not ideal because _com.company.foo_ looks a lot like the application. It was meant to be your _A_ or _B_, meaning `A/guava@20.0` and B/guava@21.0` would be the answer. &gt; at least it must have the understanding that there can be different instances (i.e. versions) of a module with one id I don't think so. If the module system would do what it promised, i.e. sufficiently isolate modules, so that two modules can have the same packages as long as they don't export it to the same third module, then we have everything we need to have different versions of the same module without any explicit notion of versions. We could also handle module renames, project merges, etc better, which are all jsut special cases of package conflicts across modules. I'm not saying that's the best way to go! I just think that its worth pursuing solutions to version conflicts that (a) by default create a module graph that contains each module exactly once and (b) does not require the module system to implement features the build systems already provide.
Look for career development programs at larger companies. Those are entry level and pretty much a guaranteed job for a few years
&gt; Instead, you break apart your data. Small chunks of data go into their own nosql tables. You can partition data into multiple independent SQL databases as easily as for NoSQL. It's not uncommon if you want to have a small independent service to give it its own database. &gt; There's just simply no need to use a DB as heavy weight as a SQL Implementation, the end to end systems architecture doesn't require it. What do you even mean by heavy weight? Are your SQL databases consuming too many system resources for small databases? Is the installation and setup that difficult? I'm honestly not even sure what you're implying. The advantage of SQL is that you have constraints on your data, guaranteed with little work on your part that make it much easier to reason about your data and write code that works with it. Overall, this strikes me as "lighter weight" in the important ways. &gt; And lastly: what are you going on about nosql being less reliable? In what way are you sacrificing reliability? This was a little redundant of me. The main thing you're sacrificing is data integrity. This *does* lead to less reliable apps because without strong guarantees of data integrity you're going to have unexpected bugs and errors at a higher rate, but that's more of an indirect sacrifice I guess.
From the various discussions I have a feeling that the final (stable) version is quite likely be released within this year. Maybe as soon as this summer. As to migration being expensive- you can quite easily run legacy (Vintage) tests in JUnit 5 runtime without any changes. All new tests can be written using JUnit 5. It doesn't need to be al or nothing proposition. 
I'm not an expert, but I would say "no". Development and even minor bug fixing can be so time consuming, it takes a long time to learn an existing code base, and people work as teams. All of that makes it difficult to have a part time developer. BUT as you know programmers tend to be overly pessimistic and wrong :). If you have a Master's degree you can teach programming at University Of Maryland, University College. If not, at least back in the day, you can get a part time job there tutoring people in programming courses or working as a lab assistant.
[JPA portability is a myth](https://leanpub.com/high-performance-java-persistence/read#leanpub-auto-jpa-vs-hibernate).
&gt; I think validating that all modules are present an no ambiguous situations occurred are still upsides but I get your point. Okay sure I guess partial validation can be better than no validation at all so long as you know not to rely on it, but I'd have been happier with something more complete. &gt; I don't quite get that. The module system is pretty strict and existing modules are close to immutable. Currently you can exchange an artifact for another as long as both claim to have the same module name. If versions were part of JPMS, that they would also have to claim they were the same version (or at least in the same range) ~&gt; less flexibility than today. Yeah okay I guess I didn't put that very well. The only way to guarantee version compatibility (as best we can, that I can see) is to rely entirely on the selection mechanism of e.g. Maven with no manual overriding, but that locks you in to the exact transitive dependencies specified, which is pretty inflexible. If we *do* want the flexibility of manually specifying a replacement for a transitive dependency we can do this. But we have no general mechanism to verify that the version will be compatible, so that flexibility comes at the cost of reliability and the manual effort of reading whatever documentation we need to. In other words, sure, it's more flexible to be able to swap out anything with the same module name without needing to check the version ... but only in the sense that it allows you to use an incorrect version of a dependency, and that probably just defers the error from build time validation to runtime. I don't want that sort of flexibility! (That claim does assume that in the theoretical module system *with* versioning we can actually rely on people to specify versions, and version ranges for deps, correctly. To be fair this is only relatively recently becoming true in OSGi thanks to tooling support for automating and enforcing semantic versioning ... but JPMS could have learned from those mistakes and got it right the first time.) **Edit:** You've half-way persuaded me that I may have overreacted a bit ... but I do still think it's a bit naff. But then I was never going to give up the requirements/capabilities model of OSGi anyway so I guess it doesn't really matter to me so long as I can keep it out of the way. Thanks for talking.
Seriously this; I'm intermediate now (couple years in) and the thing that killed me in the beginning was all the business rules. It's hard to learn their stack, etc. while also trying to keep the domain stuff straight. Pretty much any project and domain you see in your first real job is going to be a lot more complex than anything you do or see in college, unless you do a lot of open source work. My suggestion is to find an internship, that's how I landed my first job after graduating. 
OP, I'm in the US fwiw, happy to do things remotely if it interests you. I totally agree with this... I'm still finding new things in the Spring eco-system. Lots of it you take for granted until you need a one-off, then you dig in and learn and realize just how much software is provided in Spring's offerings. I've been using Spring for almost 9 years and there's lots I don't understand, though I generally know where to find the answers (honestly, stepping into the code when a request comes through is one of the best ways to learn). It's not the most intern-friendly tech, but it's impressive that OP is jumping in. I think it's worth the time mastering, because there's tons and tons of projects currently using it, with new Spring projects being deployed daily, that will have to be supported throughout their lifestyle, even if it losing favor (which I don't think it is).
Java is dying fast and that's why. Don't let anyone else tell you differently for ego reasona
There's a lot of good suggestions already. I'll just encourage you to find a major company (you'll have to relocate most likely) and get hired on as entry level, then work your way up.
You really don't know shit
Might be region and industry dependent then, I didn't think about that. 
I have no problem using 99% javax (JPA) annotations with Hibernate.
The first one is clearer to read. Would definitely be nicer if Java collections had higher order functions (`map`, `filter`, etc.) defined directly on them so we wouldn't have to do `Arrays.stream` everywhere, but still.
gc, hundo p
Hey I'm in the UK. Hire me!
Go to upwork.com and reply to jobs. But know hiring people are getting a lot of replies and it's easy to sort by hourly wage, filter out regions, or only go with applicants with a history of success or that have passed tests. So first few projects may need to be at a low hourly wage. Don't get a bad review-- if the job is too hard admit it and refund them. 
And if we don't watch out, Assembly will take over the web! Be safe brothers. 
Yes, proper isolation would be the minimum thing needed. Also at least some "pass through" of version information would be highly beneficial e.g. for displaying module graphs with multiple versions of one module (I think that meta-data can already be conveyed). Though specifying all that information in the way you suggest really reduces the value of a module system, it should be module descriptors themselves which define all this meta-data.
My point is that final obviates the need for any of that. You can just pass the object somewhere, and whether or not it crosses a synchronization boundary, its internal state will be published safely. This can have (often minor, but sometimes major depending on contension) performance benefits. Keeping track of what's safe and what's not is always the hard part. I will, however, agree, that the vast majority of java developers may not need to care, since they will be operating atop a framework that will render this a non-concern in many cases. In OP's case it's unlikely it will be a concern in the near future, but for some java developers it can be.
I've also noticed that "web" development often means front end stuff and maybe by extension back end stuff written in JavaScript, e.g. Node.
Yes. Functional programming seems perfectly suited for the stateless concurrency you need with, for example, micro-services. On the client, parallelism hits a performance bottleneck very quickly on the client side. You only get 4 cores! Java is an inherently descriptive language, imo, and readability concerns are always subjective and generally overrated. In fact, I'd posit that a sizable percentage of Java developers think that the terseness of lambdas negatively impacts readability. But none of that is the issue if you have performance concerns. The most important thing then is that the compiler can parse the intent of your code and that your variables are co-located efficiently. This means fewer object references and a much heavier use of primitives. If something is not clear at that point, then you clarify with comments. If your comments are clear and another developer still complains, then maybe he should work on a different application.
I was looking for this, life saver xD 
Nice to hear :) What are you going to use it for?
My company seems to be always hiring, and they have a global presence. Chances are there is an office near you, but it would be possible to be a remote employee as well. There would definitely be travel involved, however. If you're interested, PM me.
Java + Node.JS + Raspberry PI project. I'll be using Java as on a more powerful pc to process certian tasks. And the data is going to be sent and received via a web socket. 
The JPMS can not replace anything. In fact it is completely unusable in any open source scenario.
Please read the sidebar.
The mobile reddit giveth, and the mobile reddit taketh away. Much appreciated 
[Oracle intro to java](http://www.oracle.com/events/global/en/java-outreach/resources/java-a-beginners-guide-1720064.pdf) [Oracles lessons](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/) [Derek Banas goes through everything](https://www.youtube.com/watch?v=TBWX97e1E9g&amp;list=PLE7E8B7F4856C9B19) [Codingbat for exercises](http://codingbat.com/java\)](https://www.youtube.com/watch?v=TBWX97e1E9g&amp;list=PLE7E8B7F4856C9B19)
Thank you very much!
&gt; But as the NoSQL db gets larger and goes through more developers, it gets more and more chaotic and unmanagable because what is in a table and the relationship to other tables is undefined. Then you've architected your software poorly. The data your application stores in NoSQL should be small and clean. You have a component that manages that data (a web service, for example), and exposes that data to other components. If your data has references to other data, that reference would be managed through another component. Whether that other data is stored in NoSQL, SQL, flat files, S3, whatever, is totally irrelevant, because from your component's perspective that data is stored _in another service_. That's the whole point. You use NoSQL when your end-to-end architecture breaks apart data ownership to the point where there is zero need for consistent database access between disparate software components. That way the database choice is localized to the specific piece of data you need to store. Once you go that far, a majority of data can be stored in NoSQL because there is no need for more than one table. Have a service that stores addresses? Cool, you have an AddressID and a simple table to store address data. Maybe, only maybe, you might actually need secondary indexes on some of the address fields, but thats the most you might need. Every other component in the platform would call the Address service to get address information. No other component needs direct access to the database nor does it need to care at all how the data is stored. This architecture is what major tech companies have been doing for years. It is a very robust solution that keeps components and data ownership simple and easy to maintain. There are no chaotic and unmanageable relationships in your data because data dependencies are all defined through component dependencies, which are explicitly defined by what use cases each component needs to support. Doing that implicitly in the database is completely backwards from the way software should be controlling application flow, but it is the way most software had been built for decades which set a very bad precedent. Edit: To put it simply, NoSQL isn't the goal. NoSQL isn't some virtue to strive for on it's own. It's the conclusion you come to naturally when you design your software components for service-oriented distributed systems, which is exactly why NoSQL was developed in the first place.
&gt; On the client, parallelism hits a performance bottleneck very quickly on the client side. You only get 4 cores! Yeah, and even that is less guaranteed than on the server side, since users like to run other applications along with yours. I wonder if we'll see the core count grow on the client side same as it has on the server side? If so, parallelism might become a better strategy. Network parallelism is also already a potential speedup (in fact, most of the server-side parallel optimization I do is around IO calls), though I guess you have to worry about client-side bandwidth limitations. Man, I don't know how you hack it, I can't live without my `Future.sequence(listOfEveryIoCallInTheUniverse)`. :p &gt;Java is an inherently descriptive language, imo, and readability concerns are always subjective and generally overrated. I'd say verbose instead of descriptive, and note that I often find some Java code that's very difficult to understand, though I am also a Scala dev so definitely an outlier in the kind of language I prefer. My general point was that I see too much cargo culting around "performance" (instead of more justifiable profiling-guided optimization) that turns something that could be expressed in an elegant, declarative manner into some imperative, looping nightmare straight out of a C monolith from the 80s. Now, there definitely *is* a place for horrible-to-read-yet-hyperperformant code, but it's in the critical loop of your program and libraries likely to be called thousands of times a second, not in your standard bizdev software. It seems like there's a lot of developers out there who optimize without profiling or even thinking, and yes this does also include the people who use parallel streams when a sequential one would do just fine. But, again, I am a Scala dev, and we have some particular views on this subject. ;)
No I mean as in any variable that is effectively final. Any variable that is assigned exactly once is treated as "effectively final". It can be used in lambdas and anonymous classes. See my response to /u/ChickenOfDoom
Good. While I would be glad to not include a whole bunch of nonsense classes in my final products, it's simply not that big of a problem. It's really only a problem for people who want to put java on limited-resource devices. I mean, how many of us here aren't just doing server backends? A few? A dozen? The original proposal was a good one. It's when they started gilding the lily that everything went to shit. 
well, I agree with everything you said, but it also seems like being a major backer of OSGi (or any of the other module systems) presents a pretty clear and present conflict of interest. Are they ever going to vote for something that may eat some of their core revenue streams? 
That just isn't true. For instance with Android development default support for 1.8 is not yet there.
May be I'm just old and spend a lot of time working on back-end Java system which have their fair share of less than stellar code. I haven't had to do it for a couple of years. I think the last time I did it was try to test some code that was calling a 3rd party API that used some static methods. ISTR that we put a non-static proxy in front of it in the API in the end but we wanted to get some tests around the API usage before we did any refactoring.
I mean yeah that's the point of powermock for shitty java code all written in statics. But for any new code you won't need it the whole point of mocking statics is because of idiots years ago messing up. 
Thanks!!
Good question. Note that in the OP, Neil Bartlett has a comment with some insight (in general). And /u/grumpy_purple_midget has written thoughtful replies re: JCP process. I am prepping a presentation on Jigsaw and trying to understand what can happen re: Java 9. I'm nervous. My heart goes out to those working on books, online courses, etc! Jigsaw has been highly contentious for nearly a decade, and I thought, based on Devoxx videos (by Oracle staff) that we were getting close to a resolution. Perhaps we are. I don't have a horse in this race but am dismayed that old wars are still being waged. 
Looks interesting. Do you have any plans for those? - HTTP proxy support (including auth) - STOMP abstraction layer
Original: https://www.azul.com/press_release/falcon-jit-compiler/
I've considered switching from final-everywhere to Var, but I would want more rigorous enforcement, for example I would *definitely* want fields to be final-by-default. Also I use several static analyzers and error-prone is the only(?) one that would understand Var (and the rest would be complaining about things *not* being marked final).
i thought he died in the second one
I don't think anyone expects Jigsaw to be pushed out until 10. Options in order of likelihood (imvho): 1. Not enough 'No' votes materialize, Jigsaw goes through unmodified. 2. The first public draft gets voted down. Oracle makes no changes, asks for a second vote and it then goes through unmodified. 3. The first public draft gets voted down. Oracle makes some small changes to please people. Second vote goes through. 4. Oracle pulls 'external' modules as a feature of Java. Jigsaw remains a feature of the Oracle and OpenJDK VMs. Becomes an official standard in 10. In all of these cases everyone still gets their Jigsaw.
Final does not obviate the need for safely synchronizing threads. If you're relying on final fields to make field reads thread safe then it means you are sharing the object reference itself in a thread unsafe manner. If you are doing this unintentionally then your code has problems that final can't solve. If you are doing it intentionally then you're probably a library author deliberately writing code with a "benign race" as an optimization. Even in cases where you might want to rely on safe initialization via final fields, it will not save you the trouble of actually synchronizing. Your object reference is racey - there is no guarantee that the object will "show up" in other threads at all. It's suitable as a lock hint but that's about it. &gt;You can just pass the object somewhere, and whether or not it crosses a synchronization boundary, its internal state will be published safely If you are passing the object (rather than just expecting it to show up in an unsynchronized global variable or something) then you are already creating whatever synchronization edges you need. As a rule of thumb, if you can safely expect to see the object at all in another thread, then you can safely expect to read its fields (as long as they haven't been changed since construction).
It's a cool sounding but how would you justify the price? ~~Say it improves your throughout by 20%. Well, you could have 10 c2.4xlarge hosts for the price of one server license of this jvm.~~ Edit: Wow, that will teach me to try and use the AWS calculator on my phone in the wee hours of the night. Totally botched the math. Here's another attempt (again, all sticker prices and not any negotiated or bulk pricing): c4.2xlarge for 1 month is $291.34 Zing cost = $3500 annually = $291.67 monthly So, using Zing would double the cost of using these servers vs. a free JVM, but if using Zing would double your throughput then it comes out even. That makes it more within the realm of reasonableness. 
&gt; It's a cool sounding but how would you justify the price? If you are required to run on-premise, run processes that aren't easily parallelizable and/or have performance requirements that aren't being met, despite relatively insane hardware. Also if hardware is otherwise limited for some reason. I can see this being using un automation/scada, certain areas of hi-freq trading, and things that may fall under similar restraints. There are still many industries that can't operate on the cloud, whether it's due to air-gapped systems, other security concerns, latency, etc. This sounds neat.
I'm not sure if it'll break OSGi per se, but OSGi has already gone through all the edge cases of modularization in Java, and JPMS has ignored those lessons. One big problem already different between them is that modules don't have a version number attached to them which makes real world usage harder. I'm not sure on the specifics, but I keep hearing complaints that it's incompatible with OSGi, Maven, and other module systems.
Luckily, this video is now [available without registration](https://www.youtube.com/watch?v=DXbmfcgOvUI).
Tad late to be bringing this up now. Java 9 is almost out the door already.
What interest does Oracle have in letting the JCP exist at all?
&gt; That sounds an awful lot like NoSQL. Because this a completely artificial example. In reality no applications are that simple. Also no application gets designed 100% up front without any additional features being built. If you read some of the blogs about how people for example figured out that Mongo wasn't a good fit for them it was always when they started growing the application and found out a ton of stuff wasn't easy to implement at all. 
From the **sidebar** of **/r/learnjava** (where your post should actually have been posted): &gt;**Free Tutorials** * [Java for Complete Beginners](https://www.udemy.com/java-tutorial) * accompanying site [CaveOfProgramming](http://caveofprogramming.com) * MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki * [Derek Banas' Java Playlist](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) * accompanying site [NewThinkTank](http://newthinktank.com/)
5\. Oracle dissolves the JCP and does whatever the fuck it wants.
Not having a visual editor is good if the GUI building was designed with this perspective. I prefer a text editor even for UML, if I could find a good one... But Scout has a strong need for a visual aid. Every column of a Form is a subclass of a widget, this is all but comfortable for the developer. Think of a complex form with layouts, containing layouts, containing columns... Good UI layout design should be in declarative IMHO. I'm not blaming at all Scout developers!! I was an early adopter, and they are a small team of really smart and kind guys, I'm sure they had no time for redesigning the old visual editor, and will do with next releases. The general architecture is really good, so the GUI editing is actually the main problem for me to adopting Scout. At this time I can only suggest to continue to take a look and avoid using it in long term projects. 
Getting everyone else to adopt OSGi instead of doing the work of integrating Jigsaw.
They're *not* "just bringing it up now". This is stuff they have been discussing the whole time but were largely ignored. That's the whole point here.
And they expect to stop being ignored because?
Because ostensibly they have been put in a position to participate in the process for a reason and it would be stupid not to exercise that privilege if they believe they have an important contribution. Because their concerns and ideas have value and they hope that Oracle can see that value before it's too late to make those changes. What exactly is your point here?