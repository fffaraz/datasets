Heads up, Google Guava Java libs adds string split/join and a ton of other useful functionality and data structures to Java
I could be wrong but shouldn't it be while KeyEventVK_SOMEKEY not if and also I think you can just do while keyeve
yet.
Having to write boilerplate constructors, and equals &amp; hashCode methods for simple immutable record style classes. 
what do you mean parallel execution? I thought lambda is just a niciness to not to write anonym classes for those who don't want to.
I created my own helper function map(Object...) that will take key-value pairs and spit out a HashMap containing them. Now whenever I need a static map, I just use this function. Yes, it may throw ClassCastErrors if the types won't match, but unfortunately, Java's type system does not allow to specify variadic argument type tuples...
That's really not the sort of thing most people do in their first week of Java. But, yes, that's true, it's non-trivial.
Even with every major IDE supporting generation of them?
Type erasure. I mean, I understand why they had to do it that way at the time, but now that generics are commonplace it just seems like a silly limitation.
Too many layers of abstraction. You can never tell what objects are _really_ being used where because they're only referred to by the interfaces they implement. Well, you wish you could, but they actually implement a subclass of a subclass of the interface.
Well the underlying principle has remained the same. It tries to shield the "backend" developer from having to write javascript/css. Imo that approach is flawed.
I suspect he means an ArrayList that is populated with values. Eg. List&lt;String&gt; strings = Arrays.asList(new String[]{"a","b","c"}); edited: ArrayList -&gt; List.
What you're asking is something along the lines of, "How do you disable a car remotely in case it's stolen?" That's a really really broad question, with an answer that depends on the kind of car, the manufacturer, whether it even has such functionality at all, whether such functionality can be installed, etc. Your second question is something along the lines of, "Can this be done with a screwdriver?" In other words, the answer is technically "yes", because you probably need a screwdriver at some point. What I'm trying to say is that we need more info. And generally speaking you probably don't.
Start using static code analysis and copy paste detection tools. It makes life easier.
IMO you comment is flawed. Every framework shields you from things and provides higher level abstractions. JSF is no different there. Vaadin and GWT for instance go much further in abstracting away HTTP and trying to give the illusion of working with a desktop toolkit. JSF takes the middle ground. You still write pages and deal with HTML and CSS, but you can organize your stuff more easily. But alas, it's popular to scream that JSF abstracts from HTTP and HTML and people like you just parrot that, without realizing what JSF actually is or does.
&gt; probably going to be considered a dated approach for web. Why, because it's *really* dates, or because the hipsters at HN are currently raving about the approach and you can't do anything but follow suit? The big proliferation of different JavaScript frameworks (there's a new one almost every day) and the still messy approach and bad performance wants me to avoid this for a while. Don't forget that Twitter went back to serverside generated HTML because it's simply faster. Also don't forget that before long websites are going to have to state minimal system requirements with all that overuse of JavaScript :X
complex sql or jpa queries without multiline string support
Getters and setters. Let me write real methods, not this filler crap.
UI frameworks. 
Yes even with every major IDE supporting getters and setters. It is just a pain to create them and then they take up so much space, rather than a simple one line shorthand.
If you need to write getters/setters all the time you are doing something wrong. And i dont mean you can generate it. 
What do you mean by not generating then? Also I tend to write getters and setters quite often as I tend to break down my code into many manageable classes. Also as I mentioned above it looks a whole lot neater when shortened to one line. Person simon { get; set; } EDIT: Also if you have read Effective Java 2nd you would note that the encapsulation of classes and making classes immutable is a pretty important part of designing software. Also if you wish to change further generations of your project down the line, it will not break clients. Getters and setters would be a nice short cut.
3 decimal places from where? If your answers are integer, what should rounding do with them?
Check the /r/javahelp wiki - plenty of resources there.
Please, don't post screenshots of code - use pastebin.com or gist.github.com
[Lombok](http://projectlombok.org) has got you covered.
Sorry. I edited.
[Lombok](http://projectlombok.org) has got you covered, too. :-) @Data will generate all setters, getters, a minimal and full constructor, equals, hashCode and toString without another line of code needed, with great support for eclipse and workable support for other IDEs, AFAIK.
Resource system. Actually I encountered 2 features on other platforms that we could benefit from in Java: * Accessing resource like normal file (know this from Qt), for example by reserving JNDI prefix for resources only. Imagine getting resource file like that: File fileInJar = new File("resource://included.properties"); * Declarative way to define resource, like Android has. It could solve those ugly sql queries embedded as string in java code.
Eclipse has this nifty feature where it auto-escapes things whenever you copy them into a string constant. To activate, in Preferences, under Java → Editor → Typing, check "Escape text when pasting into a string literal" and click OK.
[Lombok](http://projectlombok.org) has got you covered. Just use @Data
This is much simpler in Java 7, look it up.
In multitier applications DTOs are used quite heavily - e.g. domain entities shouldn't leak into presentation logic, also I often have to write DTOs specifically for repository layer (because fetching domain entities with their lazy loading attributes isn't fast enough). So I often get stuck with 2 DTOs for one service method.
Why not use: ArrayList&lt;String&gt; strings = Arrays.asList("a","b","c") ?
Non-standard solution isn't workable for most projects. It won't work in corner cases, project can be abandoned in the future, as you say IDE support is incomplete ... It doesn't seem to be worth it.
Ok then. I personally dont see that as too much. If you dont use notepad as an IDE of course :D
Also Java 7 solves most problems described here
&gt; Non-standard solution isn't workable for most projects. It already works for a lot of projects. &gt; It won't work in corner cases I have yet to encounter a case where Lombok failed me. &gt; project can be abandoned in the future It's open source, so it won't vanish. Also a good number of people already depend on it, so there will be enough interest in keeping it alive for the foreseeable time. Also you can run delombok which will generate clean lombok-free source, so even if you decide to leave lombok, you have a clean and easy migration path. &gt; as you say IDE support is incomplete I just re-checked and was surprised to see that the IDE support gap has been closed; Eclipse, NetBeans and IntelliJ are supported now. &gt; It doesn't seem to be worth it. It certainly is for a bunch of people. But since that's a matter of personal preference, you're of course free not to use it. TL;DR: Don't listen to the FUD.
JavaFX 2 is good actually... unless you stuck with Swing. For web you have GWT or JSF + Primefaces which is not bad either.
care to try JavaFX 2? It's the new UI for Java and designed to replace Swing.
Install Java 8 RC and you can use them :)
safari, mac
Could not jufge JavaFX but JSF + PF is not pain in the ass. It is straight way to the suicide. I am working on third project which uses this technology over two years, but i aged like 50 years during this period. 
This is huge. Needing to pass `Class clazz` is at least a minor annoyance, but a significant problem comes with implementing generic interfaces. class Foo implements Bar&lt;Baz&gt;, Bar&lt;Qux&gt; ...is impossible because of type erasure. 
Multiline string support in general. I always put any text I need in text files in the JAR and load them at runtime with Class.getResourceAsStream(). It's such a pain.
I agree. The IO in Java &lt;=6 is a PITA, but 7 fixes a lot of it.
If you don't mind some pre-processing magic, Project Lombok can do getters and setters with annotations.
First of all, you seem to have a wrong variable (copy/paste) error in line 93 of the pastebin. (Also, eligible is spelled with a single "l") Line 91 onwards: if (letter == 'F' &amp;&amp; age &lt; 21) { System.out.println ("Your BAC is " + BACMale + "."); if (BACFemale &lt; BACMinor) System.out.println ("You are under the legal limit for a DUI."); if (BACFemale &gt; BACMinor) System.out.println ("You are over the legal limit and eligible for a DUI."); } Shouldn't there be **BACFemale** in the first System.out.println? **EDIT** you don't need the second if, an **else** will do just fine. Like: if (letter == 'F' &amp;&amp; age &lt; 21) { System.out.println ("Your BAC is " + BACFemale + "."); if (BACFemale &lt; BACMinor) { System.out.println ("You are under the legal limit for a DUI."); } else { System.out.println ("You are over the legal limit and eligible for a DUI."); } } **Always** use braces **{}** when writing **if** statements and properly indent the code. It is easier to read and avoids errors. In IDEs there is a shortcut for formatting code (in Eclipse it is Ctrl+Shift+F) make frequent use of it - it helps - really. ---- If you want to print any number with 3 decimals only, you have several ways: 1. Multiply the double value by 1000 and then round to int, then back to double and divide by 1000. int tmp = (int)(BACMale * 1000); BACMale = (double)tmp / 1000; System.out.println ("Your BAC is " + BACMale + "."); This way does not round anything, it truncates only the digits after the second decimal. 2. Use String.format to only use formatting on the output like: System.out.println(String.format("Your BAC is %04.3f.",BACMale)); That way of displaying does business rounding on the last digit as well. ---- A few more comments to the structure of your program: Regardless of the gender entry, you calculate both, the male and female BAC and only decide what to print later. It would be better to just have a single BAC calculation (with the appropriate formula based on the gender selection) and only change the printout for minor or adult. The maximum permissible BAC constants for minor and adult should possibly be declared as static final at class level. I see a lot of "magic numbers" in your formulas, better change that to meaningful constants also declared as static final at class level. Example: Metabolized = (0.015 * hours); // here you have 0.015 - should be a constant alcoholMale = (((3.701 * drinks) / (weight * 0.73))); // here the 3.701 and the 0.73 should be constants alcoholFemale = (((3.701 * drinks) / (weight * 0.66))); // here 3.701 and 0.66 should be constants Changed with constants: Metabolized = (METABOLIZED_PER_HOUR * hours); ---- Your naming is inconsistent: + In Java, **class names** should start with Uppercase letters and use CamelCase throughout + **Variable names** should always start with lowercase letters and use camelCase thoroughout ("Metabolized" should be "metabolized") + **Constants** (static final) always use all UPPERCASE with Underscores like "METABOLIZED_PER_HOUR" **EDIT #2:** I have created a pastebin with updated and optimized code: http://pastebin.com/1f4JzvjF
What's wrong with this? All you should need to know is what the interface tells you. If you really need to know more, debugging in Eclipse will be able to tell you what you need to know.
I am always so very hesitant to use something that exploits internal APIs. At least in this case they are applied at compile time, so you shouldn't face runtime issues. Still, this slightly uncomfortable feeling remains.
I wasn't familiar with that syntax. I was just trying to show it was a comparison to: List&lt;String&gt; strings = {"a","b","c"}; 
Yes, state management is one area where I think the JS frameworks have work to do. In fact, in my current project we are delivering a consumer facing application (for a large, corporate client) that cannot function without multiple enterprise LOB systems working together. The folks that are responsible for the consumer apps / sites are all about JS + RESTful services, but the challenge so far has been to feed those with LOB data and maintain key state information.
I hear you. That's why I like the idea of having a delombok around. You can have your cake (don't need to read or write boilerplate) and eat it (having the boilerplate in your source), too. If you never publish your non-delomboked source, no one will even know you use it. And if for any reason you should no longer be able to use lombok, just switch to the delomboked source.
The typing and clutter isn't an issue for me at all. It's one of those things where sure, shorthand would be cool, but it wouldn't actually help me solve any problems. The main thing I'd want from properties is the ability to document each private field once and have that documentation show up on both the getter and setter. Right now I do a lot of copy and pasting. Does Lombok help with that?
I'm hoping value types solve this. It's the feature being discussed for Java 9+ that I'm looking forward to the most. http://openjdk.java.net/jeps/169 Google's AutoValue might also help. AFAIK it's a preprocessor like Lombok, but targeted specifically at the problem you mentioned. https://docs.google.com/document/d/1THRUCIzIPRqFSHb67pHV8KMbo55HphSXqlQcIx9oUiI/edit
That list is long: - Verbosity (Compiler even lacking local type inference) - Runtime type erasure - Annotation processors can not modify code while compiling ( would be a way to get rid of having to write accessor methods if a @Property annotation could generate the accessor methodss) - Having to re-implement common functionality over and over (Listeners anybody?)
I tend to use Guava for Java &lt;= 6 ... Guava IO is similar to Java 7.
TBH I'm on the edge of having "Properties" in Java. Yeah, it's a lot more explicit about what the methods are supposed to do, but it does a poor job representing what they are - which are methods, not properties.
Boiler plate ... So much boiler plate 
Yep: https://code.google.com/p/projectlombok/issues/detail?id=59#c14 It's not necessarily the best way to do it, but it's there.
Circle has keyPressed() in it but doesn't implement KeyListener and isn't registered as a KeyListener as far as I can tell. Instead of registering Roomba as a KeyListener, try registering the circle which represents the Roomba.
That has nothing to do with the Java programming language. This sub is for the programming language, not for the island.
What you are looking for here has nothing to do with type reification. It is the concept of union type, such as in Ceylon.
JDK 8 adds new [utility methods](http://download.java.net/jdk8/docs/api/java/lang/String.html) to join Strings.
dang
&gt; I have yet to encounter a case where Lombok failed me. Simple use case: Create a Point class, with two int named "x" and "y". Now, just switch the declaration of those fields inside your class. Boom! Plus default equals &amp; hashcode are generally worse than no implementation at all. &gt; I just re-checked and was surprised to see that the IDE support gap has been closed; Eclipse, NetBeans and IntelliJ are supported now Only Eclipse has full support. IntelliJ &amp; Netbeans support is partial.
Saving this...
JavaEE. It is always running behind to catch-up with common use cases. I am not saying that everything is to throw away (CDI is quite nice), but the fact that it is always the biggest common denominator means that you nearly always end up using proprietary extensions, unless your program is really basic.
I was a little disappointed that these were static methods as opposed to instance methods. I would have preferred ", ".join(a, b, c) to String.join(", ", a, b, c). But yes, thank goodness these are finally here.
In Java 8: String.join("Q", "a", "eee")
Damn you Oracle
You can also achieve similar results with Type Classes: trait Bar[T] { def consume(t: T): Unit } object Bar { implicit object BazIsBar extends Bar[Baz] { def consume(b: Baz) {} } implicit object QuxIsBar extends Bar[Qux] { def consume(q: Qux) {} } } val x = new Baz implicitly[Bar[Baz]].consume(x) //You can add this inside object Bar implicit class Barable[T](t: T)(implicit bar: Bar[T]) { def consume() {bar.consume(t)} } //and then you can do this x.consume() Not that overloading working with type arguments wouldn't be nice.
&gt; I don't have to delve into the depths of JSF generated javascript. But you do need to delve then into the depths of the "wide variety of rich HTML5/js frameworks available", don't you?
Yes, this is sad that Java didn't have multiline string... Anyway, some guy do some multiline using annotation: https://github.com/benelog/multiline Other alternative is to use Groovy ... 
Perhaps not what you're looking for but the whole build infrastructure. This may not be unique to JAVA, but my recent experiences with maven and ant and all that stuff make me have nightmares. This is probably due to a bad infrastructure setup and my incomplete understanding of the matter, but I feel I wait more time for some build than I use to actually write code.
This is actually a good thing, as long as it's done correctly (not leaky kind of abstraction). You can focus at what the interface provide, and only do the other stuff as needed. 
You should try Spring version 3 and greater. 
Ever tried Java EE 7? It's very complete by itself, but then again I don't see why it's so bad to add some extra things. Do you also expect to be able to code a C++ app against just its standard lib? Or a Java app desktop app against just the standard Java library, etc?
Or StringUtils.join() in commons-lang3 (admittedly, not a part of the JRE proper).
- When creating an arraylist or hashmap, you have to create the hashmap/arraylist, then add values, then add some more values, while in just about every other language, you can add the values to the list while instantiating. You can use Arrays.asList("a", "b", "c") for a List, but there's also no equivalent for Map. - Yep. - Yep. - If you're doing unserialization, or any sort of code where you need to cast an Object, it will complain. - "a", "b", "c" joined with "+" becomes "a+b+c". It's a feature in just about every language except Java.
So it won't be usable for years to come until Java 8 is standard. It's a change that should have been made 5 versions ago. 
Guava's essential because of the lack of those essential features in Java.
If you didn't mind to spend some money, try Intellij IDEA ultimate. You'll never come back to eclipse again... Or you may try the community edition / Android studio first then decide whether to buy the ultimate version.
Text processing in Java 7 with NIO 2 and Automatic Resource Management is easy. Regex still sucks because Java don't have the concept of raw string ... but at least there's Guava's CharMatcher. 
I did tried Java EE 7. The difference with the version 6 are pretty small. A do not expect to code a C++ app against just its standard lib because it never made the promises it would be enough for 90% of the apps out there. JavaEE tries to do so, and the extensions are part of the vendor solutions so much that you cannot mix "additional feature A" of vendor alpha with "additional feature B" of vendor beta without running very quickly into some troubles.
What's wrong with stringbuilder?
It had to have been an NPE.
I am guessing you do not build web applications.
FYI, that can be: public Person simon { get; set; }
But JSF does not "generate code" so much if at all. What you see are the JavaScript files that are included by PrimeFaces, RichFaces etc. JSF is not a code generator like GWT, but mostly a templating framework.
I think you mean: public Person simon { get; private set; } But no problem :)
No, things like additional features of Jersey that are not available in RestEasy and vice versa. Both implement the JAX-RS part of the JavaEE spec, but it is a all-or-nothing approach when you want to benefit of extensions outside of what is defined in the standard.
That doesn't join arrays. 
Some of my m8 are actually Indonesian. They're Javanese, code in Java, while drinking their Java coffee.
yeah for my last project I configured with xml. Might have to try using the java based configs next time around 
They're building Java 8 inside that volcano ... 
CDI extensions are portable, as are JCA connectors, JACC providers, JASPIC auth modules and UI components in JSF, to just name a few things. You are right that there are some extensions that are tied to a specific implementation and are non-portable. I personally don't like those a try to avoid them whenever possible. Occasionally it indeed concerns a must-have feature (like the Hibernate converters) and then it really should be included in the spec.
Having been forced to use JSF at one point, I'll have to admit that I'm completely biased. It was fine until you wanted to do anything outside of standard web forms. My point is that JSF had been around longer than almost any other framework and I still don't see much adoption. Maybe I just know too many old crusty java developers.
Project meetings
&gt;I know static typing in Java is not state of the art like in Scala I don't really get what this is / means (i've just started learning programming...) Is this relating to case sensitivity or something else? 
Because this is the standard way of sending information from the server to the web client. That is how Java beans work. I am curious what do you do instead? 
If you are creating any kind of MVC application, EJBs, persistence layer DAOs, web service interface, or REST applications and don't have a modeling tool, you'll probably end up writing your own POJOs. Automated modeling tools can help, but it will still require POJOs with setters and getters everywhere.
This gives an list to which you cannot add further elements. It's often fine though.
After spending a semester with Groovy, I miss not having to write parens for methods and all those setters and getters. It's so nice being able to do: customer.bankaccount.balance instead of getCustomer().getBankAccount().getBalance();
Well, I have been responsible for developing a few JSF based components in enterprise projects and while I am fully aware of JSF 2.x improvements, I don't miss any bit of it.
Have you ever spent hours debugging lifecycle bugs? Or trying to mix components from multiple JSF frameworks? 
The JVM is super awesome. Java is portable, secure and maintainable, but you can compromise any of these for more performance if necessary. The core libraries are more or less awesome. There are high quality third party libraries for almost everything. High level concurrency with a lot of usable third party concurrency tools. Java more or less encourages proper object-oriented mentality, although there are a few antipatterns here and there. The negative side: &lt;http://www.reddit.com/r/java/comments/1xve3q/what_aspect_of_your_java_programming_is_the/cff5yh8&gt; 
&gt;tons of libraries Best part about it IMO. 
Stable libraries. Coming from Python, Python has a lot of libraries, but many are just not stable. Also, making a gui or android application is far easier than in python.
Regarding maps, not as clean as other languages, but you can do this: Map&lt;String,String&gt; test = new HashMap&lt;String, String&gt;() {{ put("one","ok"); put("two","bad"); }}; 
There is the nice brevity in avoiding anon inner classes, but one thing modern languages need to do is take advantage of multicore processors. Jdk 7: List&lt;Item&gt; items = getItems(); for(Item item : items) { item.doSomething(); } This will chug through the list processing each item. This operation can only occur on a single thread as the foreach promises to process each item in turn. What if the ordering is unimportant and we just want the list processed as quickly as possible? In JDK 8 Collections are be improved to allow parallel processing via Lambdas and streams... List&lt;Item&gt; items = getItems(); Items.parallelStream().foreach(item -&gt; item.doSomething()); The ordering is not important so the calls to item.doSomething() can be automatically pushed onto different threads, which can the be scheduled onto available processor cores. Imagine doSomething() took one second to execute, and there's one hundred items. A quad core processor would take 100s with a foreach, but only 25s with the stream. Actually 12.5s if the processor supports hyperthreading. The syntax is more clunky, but there's another new way to call methods in Jdk 8... List&lt;Item&gt; items = getItems(); items.parallelStream().foreach(item::doSomething); This is why jdk 8 will be awesome! Free multithreading, with compact syntax.
That also has some additional overhead, by generating a new anonymous inner class for each map.
You have two options for multiple exceptions. If you don't care at all, just do try { ///something that throws an exception } catch(Exception ex) { } or if you want to handle multiple types of exceptions the same way try { //something throws an exception } catch(IOException | SQLException ex) { //do something with these two } catch(Exception ex) { //other type } 
I mean, you can then do new ArrayList(Arrays.asList("a","b","c"));, but that's ugly as well. I've sometimes just defined a static method in That Miscellaneous Utilities Class just to do it, but I would like if Java had it in the core language.
For what cases? Do you want pointers to be able to access external resources, like in the old days of pointing to a COM port address or do you want pointers to manipulate memory buffers? 
It's a private variable (that the compiler will generate, hidden) with a public getter and a private setter.
http://eclipsecolorthemes.org/ has a good number of dark themes, one of which I use. Actually, [this blog entry](http://blog.scramcode.com/post/4/6-tips-to-make-eclipse-lighter-prettier-and-more-efficient/) is good to know for Eclipse in general.
No, I am using windows 8.1 
They're really not. Don't take me the wrong way, they are powerful and they are absolutely solving the problems that they were built for. They're not "nice" though. (I've not used sbt, so perhaps I'm wrong about that one). XML as a build configuration language is a ridiculous choice. XML isn't human readable. It's plain text, I grant, but writing XML is horrible. Maven itself is incredibly complex, with it's million plugins and multiple repository maintenance. Gradle, I could possibly grow to like, but even then, it suffers in the same way that Maven does -- too much complexity to do simple things. I understand that they're all good projects and are the best we've got. They're without doubt the bit I find the biggest pain in the arse though. And woe betide you if you want to do something in a non-idiomatic way. --- I'll give an example. I have an Android project that needs to build a library jar from multiple other jars (I have to do this because Android's support for making library code is non-existent). I ended up doing this with a Makefile, because getting ant (or Maven, or Gradle) to do it was utterly beyond me. mylib_withdeps.jar: bin/mylib.jar \ ../AndroidModule1/bin/AndroidModule1.jar \ ../AndroidModule2/bin/AndroidModule2.jar \ ../opensource/androidsvg/bin/androidsvg.jar -rm -rf tmp mkdir tmp cd tmp; for j in $^; do jar -xvf ../$$j; done cd tmp; jar -cvf ../$@ . unzip -l $@ Utterly platform-specific; but also done in 5 minutes. 
PMD comes with CPD (Copy/Paste Detector), and I usually have them running reports in my Jenkins builds. In addition, I usually use Findbugs and Checkstyle as well, with a healthy helping of Clover or JaCoCo reports on top.
Yes it does, but it is an option. You could also create a support utility which does what other languages do with syntax: static &lt;K,V&gt; Map&lt;K,V&gt; makeMap(Object... values) { Map&lt;K,V&gt; data = new HashMap&lt;K,V&gt;(); for(int i = 0; i &lt; values.length; i += 2 ) { K key = (K)values[i]; V val = (V)values[i+1]; data.put(key, val); } return data; } (the cast triggers a warning) Map&lt;String,Integer&gt; test = makeMap("one",1, "two",2, "three",3); 
I've done basically that same method before in That Miscellaneous Utilities Class.
I imagine most of us have a collection of miscellaneous utilities we reuse.
Not just portable but I love that I can use my language knowledge in so many areas. Whether its big data, desktop apps, web apps, backend rest services or even embedded controllers I just need to learn how to use a library. My language knowledge is easily transferrable.
And many/most of those features could be added without breaking backward compatibility.
No I have not. I have no need to mix multiple JSF frameworks because PrimeFaces has everything I need. Actually it has way more than I need. If I did need something they did not have I would probably just fall back on JQuery and make my own. I have saved countless hours by using built in themes, components and state. 
[Liskov substitution principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle). You shouldn't care which concrete implementation you're getting.
No. Static typing is the compiler knows exactly what type of data is in a variable, and ensures that the way you use the variable in your code is compatible with the type of data. If you make a mistake, you discover it when you try to compile the code, that is, rather immediately. Dynamic typing is the compiler does not check the type of data, and you can write things such as putting an integer in a variable, and then trying to insert a character in it. There will only be an error when you run the code, that is, rather late.
Updating java...
&gt; Have you ever spent hours debugging lifecycle bugs? Not really, which bugs are you specifically talking about? Are you implying that other frameworks don't have bugs? I've spend countless hours working around browser bugs, or working around bugs in jQuery, or working around bugs in RoR. I think you're just a hater. Someone who has picked up the term "lifecycle" and learned its a pupular stick to beat JSF with (whether it makes sense in a given context or not). Also there are not really multiple JSF frameworks. There are multiple JSF component libraries. Even though I rarely need to mix those, they actually mix pretty well. I use components from PrimeFaces mainly, those from OmniFaces and a handful of custom ones. It's also possible to mix PrimeFaces and RichFaces, though this wouldn't make much sense it does work. They didn't mix in 1.2, when they had their own AJAX implementation.
&gt; and I still don't see much adoption There is no single framework in Java that has *much* adoption; the space is pretty fragmented. JSF is typically in the top tier though. See http://henk53.wordpress.com/2011/10/12/reply-to-comparing-java-web-frameworks for some results from surveys. Especially see this one: http://henk53.files.wordpress.com/2011/10/stackoverflow_webframeworks.png
oh right... what would constitute 'state of the art'? It seems like it's something it either does or it doesn't... Sorry if the q's a basic! 
&gt; Gradle, I could possibly grow to like, but even then, it suffers in the same way that Maven does -- too much complexity to do simple things. The complexity is there for when you really need to do complex things. I also think the simple stuff is simple enough in gradle, you just have to get past the learning curve. Also a question, as I'm unfamiliar with Make, but does it do any kind of dependency management? 
http://www.slideshare.net/dgalichet/demystifying-scala-type-system http://steve-yegge.blogspot.com/2008/06/rhinos-and-tigers.html http://neopythonic.blogspot.com/2008/11/scala.html http://www.infoq.com/news/2011/11/scala-ejb2
Applet should be put into museum of failed technology for future generation to learn from and not to make the same mistake again.
I forgot those. Bad, bad applets indeed. Safe is the word I should have used instead of secure, as secure primarily means that it is hard to compromise by a malicious attacker. 
&gt; I think you're just a hater. No I am someone that spent 2008 - 2010 timeframe developing JSF components for integration with multiple JSF frameworks. Components that had to work both JSF RI and MyFaces. And be able to integrate with RichFaches, Tomahawk and ICEfaces. Many times we had integration issues that could not be found out by turning on full debugging and required stepping through the source code of the said frameworks. Nowadays on my consulting projects I always advocate for other view solutions.
Null. There should be no null. I never know if your method is going to return null, so I have to check for it. I never know if you're going to pass null into my method, so I have to check for it. You might have put a null in a collection, or as a field on an object. It's everywhere, and I'm constantly checking for null because I can't trust you. Half the time you've returned null because there's an error, the other half because no results were found, and a third half because the thing just hasn't been populated. Quit using null to mean everything and anything! "I call it my billion-dollar mistake. It was the invention of the null reference in 1965." -- Sir Tony Hoare EDIT: Yes, I understand, null is not entirely useless; my point rather, to answer OPs question, is that it is a big pain in the arse.
That my bloody customers keep using old versions of the JDK. "Oh, we are JDK 1.6... sorry... can you not use try with resources or any of the current features. I'm not talking JDK 1.8, but 1.7 stuff. Same has been true about every major update.
Look over at the /r/javahelp wiki - plenty of resources there.
Super awesome post. It may help alleviating those pesky error code / flag or exception flamewars. It's rare to see such well-written and comprehensive article about the topic, I am going to make sure to read everything from Aleksey in the future.
As i said in this thread. I see getters and setters reasonable only in DTOs. 
I don't have a number though. I need to round off a number equated from user generated information 
Not the way you mean, no. Make is more like a way of keeping lots of little shell scripts in one file. It does dependency management in that you can list that "to build A needs B; to build B needs C, C will have to be a file". I'm certainly not advocating it as a Java build system. It's missing package dependency resolution and is platform specific -- obviously a no-no for Java. I'm yearning more for something as simple to understand as make but for Java. Something that is extensible enough to do project-specific special tasks that I might want, even if no one has written a plugin to do it. I'm not really attacking the build systems we have; I'm just answering the question the OP posed: what's the biggest pain for me.
I've implemented similar functionality in sbt by defining new tasks. Maven is a lot tougher to deal with in that regard.
thanks! :D
&gt; I find it absolutely terrible when you have duplicate try catch blocks just to get past interface methods not throwing exceptions Can you explain that for the rest of us? I like to think I know a couple things about Java but "get past interface methods not throwing exceptions" &lt;-- what?
That sounds like a mess. The problem here is not JSF but the haphazard way it was being used. It also sounds like you were working with version 1.2 based on your mention of JSF RI witch is now Mojarra. 
Compile Errors! After doing groovy. I now appreciate compile errors for typos and etc.
This is exactly how I felt when I first encountered it. Then I used it in a project. It is remarkably mature and works extremely well. I have never had an issue where Lombok was the cause, despite having a vast number of extremely obscure issues with the codebase using it. At this point Java is essentially unusable without it for me.
If you deal with 2m lines of code, the static type system along with Eclipse' 'Show Call Hierarchy' saves lives on a daily basis.
I really like @Data from the lombok project. 
Overuse of checked exceptions. Should really only be used in IO situations.
So what would you rather? That there were standard error types returned instead of null?
Yes, the components had to be usable in Tomcat and Websphere servers. 
It is an ArrayList, it's just java.util.Arrays.ArrayList and not java.util.ArrayList. 
The thing is, null is used to solve so many problems, there's no single answer for them all. But yes, as one example, in the case of null being used to indicate an error, throwing an Exception would be preferable. JSR 305 defines some annotations that can be used to indicate where null is not allowed (e.g., in a method parameter, or return type, or on a field). But at this point it is only enforced by third-party tools like FindBugs or IntelliJ IDEA. Ideally, I'd like to be able to say "you may not pass null into this method" and I'd be able to safely assume that the parameters are never null. I will admit, null is not entirely useless; my point rather, to answer OPs question, is that it is a big pain in the arse.
Not ready for primetime. Before you downvote me, I have many reasons, but I'm too lazy to type them all. Here's the first (of a fair number): https://javafx-jira.kenai.com/browse/RT-22988 The fact that hasn't been implemented yet really pisses me off, among other things. I feel pretty burned working in Java FX2.
It's the only way to Spring.
/ agree on Hibernate Spring (as mentioned elsewhere) is a lot better with Java/Annotation config.
I like having them as an option, but they're way overused.
Doing I/O correctly with plain try-catch-finally is far more complicated than it is in other languages. It's the whole reason Java 7 introduced try-with-resources. In Java 6 this is the minimum code for opening a stream, using it, and closing it. InputStream stream = new MyInputStream(...); try { // ... use stream } catch(IOException e) { // handle exception } finally { try { if(stream != null) { stream.close(); } } catch(IOException e) { // handle yet another possible exception } } Source: http://stackoverflow.com/a/17739460 
The problem isn't null. It's how programmers use it.
It does if you want to modify said concrete implementation.
For me, it's my CTO (through customers needs): Must support Java 1.4 :( Oh, and we don't ship the Retroweaver runtime jar. myMap.put(new Integer(4), "A String"); ^^ If I need to "new Integer" one more fucking time...
I believe that is a huge part of API design--anticipating usage patterns and designing in such a way to encourage good practices and discourage poor ones.
Because I don't care about the interface; I need to modify the implementations.
Emphasizing code readability over shorthand. I can type 100+ WPM, and code-completion and templates make me even faster. I'd much rather have verbose code that's easy to understand rather than abbreviated code that's difficult to grok. I am a bit concerned about lambdas, in that regard. I would have preferred a new keyword, but I guess that would run the risk of breaking existing code, which the () -&gt; {} syntax avoids.
IDEs let you generate these. In Eclipse, Source -&gt; Generate getters and setters... Or you can right-click on a variable/member. Of course the methods still take up space, but I usually just shove them out of the way.
... said no sysadmin ever. 
I don't care about the interface or its uses. I care about modifying the implementation of the interface, and it's impossible to tell which implementing class is the one I actually want to modify.
Most lag from the GC can be significantly reduced by scopeing certain variables a Iittle higher. Even though C let's you manage memory better, messing up the men management code will actually cause more lag and leaks than just using java. Therefore, for indie devs who aren't professionals at memory mgmt, java is actually better on average.
[Open-closed principle](http://en.wikipedia.org/wiki/Open/closed_principle). Classes should be open for extension, but closed for modification.
so you are having an issue with this line for(int ROWS=0; ROWS&lt;t.length; ROWS++){ In the toString() method along with this line: for (int COLS=0; COLS&lt;t[0].length; COLS++){ and the line: result = result + " " + t[ROWS][COLS]; the answer is t is not in scope since you are now in a different method then the method it was declared in. edit: also arraytest1 is not a percolate object so the line arrayTest1.percolate(); won't work. 
That's awesome, I didn't know about that. Thanks!
There are many things I like about Java, but James Gosling himself said it best in 2005: &gt; As I suffered through the nth application crash of the day, I couldn't help thinking of my favorite underappreciated Java feature: fault containment. Between try{}catch and the tight memory model, failures tend to happen close to where the error is, and they can be caught with a very good chance that there has been no corruption of neighbouring data structures. So if you're using some sort of editor and one of the commands has a bug in it, if it's written in Java you usually get a little pop-up box that says something like "error in command", and you can carry on working. In C apps, one bad pointer and you're blown out of the water, with all of your editing lost. ... -- https://blogs.oracle.com/jag/entry/fault_containment_an_unsung_hero Beyond that, I like the way Java manages namespaces. The explicit imports and multi-segment class names make it easy to avoid name collisions. *(Can you tell I come from a C background? :-)*
So, what, I can't modify classes after they've been written once? The implementation as it exists now is definitely wrong and needs to be changed. I'm not going to subclass an incorrect implementation just so I can avoid modifying the original. That's preposterous.
t is declared in the percolate method, not at the class level. Use array instead in your toString method
Not sure what that has to do with anything. You can use either JSF implementation with Tomcat. I assume the same is true with WebSphere but I am not certain. There is very little difference between the two anyway. My application runs on either and I did nothing special to make this work. Using all those different component libraries is unnecessary. That kind of environment would be bad with any framework. JSF 1.2 was not good at all. I can see why you had a bad time. 
There are none. And there's no one before you that has asked this question either here or any one of the other subreddits linked in the sidebar. Also the last two sentences were influenced by sarcasm. 
I find making REST services using Jersey is a breeze and actually kind of fun.
Hey that's excellent. Thanks very much. I'll give that a go this evening.
There is a single reason why big retail company such as Amazon will not move to client side render. That is the server side rendering is a gazillion times faster than doing it in a browser, not to mention security. "Dated" technology just won't cut it when it comes to choosing one over another.
This isn't just a good post about the phenomenon they're measuring, but I especially appreciate the fact that it contains some good points about benchmarking itself. xpost this on /r/programming if it's not there already, they might like it.
You're welcome. And yes, it's an awesome feature. I use it all the time to paste data for unit tests right into my code.
Sorry, I must have misunderstood your meaning. Of course you can fix bugs in the implementations. &gt;Bertrand Meyer is generally credited as having originated the term open/closed principle...The idea was that once completed, the implementation of a class could only be modified to correct errors; new or changed features would require that a different class be created.
&gt; Have you ever spent hours debugging lifecycle bugs? The JSF lifecycle's reliable in isolation - only time I've run into problems with it was when I was using JSF 1.x for portlets, and even then the issue was with the portlet vendor's JSF portlet bridge code rather than anything fundamental to JSF itself.
Maybe I'm overly optimistic, but I think the Java community will figure out how to use lambdas to aid readability. Of course there will be misuses. But on the whole I think it's a win.
As I [commented](http://www.reddit.com/r/java/comments/1xve3q/what_aspect_of_your_java_programming_is_the/cff30h9) in an earlier thread, Eclipse has a cool feature to help with that.
Wrapper for Console.out.print
Java has basic types, and these are statically typed. They are doable by the compiler, instead of errors being found at runtime. This stops you from doing `String s = 12;"`. --- Java has inheritance, so you can have a type hierarchy - some types are sub-types of other types, and so inherit their behaviour. abstract class Feline { String sound; } class Lion extends Feline { String sound = "roar"; } class PetCat extends Feline { String sound = "meow"; } class Kitten extends PetCat{} I can now have a `List` of `Feline`s, or `List&lt;Feline&gt;`. It can contain both `Lion`s and `PetCat`s, and I can get their sound from both, since `sound` is a member of `Feline`. I also know that `Kitten.sound = "meow";` because it inherited `sound` from its parent class, `PetCat`. --- Java has generic types, which are types where you supply it another type as a parameter. This lets things like Lists work safely. It means that `List&lt;String&gt; sList = new ArrayList&lt;String&gt;();` will only contain strings, and that `sList.add(12);` doesn't work. --- Java's generic types can be restricted, which is where you only allow certain types in the generic parameter. This gives things like `class CreatureList&lt;T extends Animal&gt; extends ArrayList&lt;T&gt;` which only accepts type `T` if `T` extends `Animal`. --- Java is soon to have type annotations, where you can supply additional restrictions on the type of an object. This will let you do things like `@NotNull String s = "This is a not-null string";` and the compiler will know that `s` will never be null. It will also stop you from doing `@NotNull String s = null;`. This will prevent a *lot* of NullPointerExceptions. --- But this is pretty much the extent of Java. --- Scala has `case class`es and pattern matching. Case classes are classes where the constructor arguments are stored, and can be used later in pattern matching. Pattern matching uses code where the code is missing a piece of information, and trying to make the piece it is given match the hole in the patterns. class Option[A] case class Some[A](value:A) extends Option[A] object None extends Option[A] def tryToGetWebpageString(url:String) { val possibleResult = queryWebsite(url) possibleResult match { case Some(s) =&gt; return s case None =&gt; return errorMsg } } This is pretty state of the art (SotA) for imperative or object-oriented languages, but has been around in functional languages for decades. Languages like Haskell thrive off of this functionality. -- Scala has mixins and traits. Mixins are ways to get around multiple inheritance - a class that `implements` a trait with a mixin has that mixin 'mixed in' with its existing code. class Person{} trait CookingAbility { val canCook = true } class Chef extends Person with CookingAbility` In this example, a typical `Person` has no field named `canCook`. The `Chef` however has the trait's features mixed in, and therefore does have the field `canCook`, despite extending `Person`. --- Scala has type-level fields and methods, which allow computation to happen at the type level as opposed to the normal level. `trait TypeLevel { type Field = List[Int] }` has a type-level field that is accessed with `TypeLevel#Field`. This also allows fancy things like type lambdas, which are type-level anonymous functions, often used for messing with generic parameters. This isn't considered SotA by some, but does allow a whole slew of things. --- Scala has Monads, which are certainly SotA in non functional-programming circles. Every time someone does a writeup of what monads are~~n't~~ it confuses people, but it lets programmers chain together operations in a type-safe way that is different to other techniques. In Haskell, it is seen as the holy grail by many, but the evangelism (and all the so close yet so far blog posts on what they actually are) has obscured them from the rest of us mere mortals. In Scala, it is something that can chain itself to other monads to form a pipeline that the data flows through. It is very useful for many things in these type-rich languages. --- Scala has implicit functions and types, which lets you cleanly extend objects without fussing around with their definitions and breaking things, as the compiler simply slips your implicit conversion in at your end, instead of at the base class. --- Scala also has structural typing, which is type safe duck typing. This lets you do a function that works on all objects containing a `canCook` field without requiring they all implement a `CanCook` interface. This is done by def makeSauce(chef:{def canCook:Boolean}) = { if(chef.canCook) "freshly made duck sauce" else "shop bought ketchup" } which applies to everything that has a method `canCook` that returns a `Boolean`. --- Scala has a few other type features that Java doesn't have but seem mainly academic rather than practical. Both languages run on the JVM, so both are compiled down to the same basic bytecode, and yes, since both are statically typed, they are the same in the regard that both should not run in to type errors at runtime. But in Java, many things are much harder to do than in Scala, since Scala's type system is more rich and featured. The same functionality is certainly possible to achieve in Java, but it's just nowhere near as simple. Java is designed this way - simple things are simple, and complex things are complex. The language is designed to do what is spelled out for it, no more, no less. Scala meanwhile has many more whizzes and bangs, but these can get in the way of developing simply and safely, as there is plenty of temptation to do the wrong thing, whereas in Java, the only way is the enterprise way.
- Autocomplete, error checking as you type, and quick-fix (Ctrl+1 in Eclipse, my favourite shortcut) make Java's verbosity a non-issue and allow quickly writing code that often simply works as intended. - You can export your whole project with all dependencies into a single, monolithic .jar and run it on another machine. This might not seem like a big deal if you come from a C++ or Java background, but the lack of a similar functionality is actually one of Python's biggest shortcomings. 
Not to be a killjoy, but you don't only have to *write* the verbose code, you will also have to *read* it. Visual cues like syntax highlighting can ease some of the pain, but coming from functional languages, Java code seems very beaurocratic. On the other hand, you mostly know what types you deal with from a local inspection of the code. And on positive note for Python, there are py2exe and pyinstaller. To be fair, you will need a version per OS, whereas with Java, you are only beholden to the latest JVM you compile against.
After having to learn c in a week and a half, what do I like about Java? *everything*
But C gives you much more control over how your code is run (at the cost of having to control how the code is run). ;-)
I think you read a bit too much into what I wrote, but no harm no foul. My position is that as a person with hands on usage of JSF (and other server side java web app frameworks), who now does technology program strategy &amp; management, I can see advising my clients to choose to develop their web UI frameworks using client side technologies over server side (java or another language). That is it. I am not trying to say JSF is better / worse / even with other server side frameworks, but I do think most of the innovation is being done on the client side. And the commercial companies (which fund much innovation) that do support server side java, don't seem to be putting out tools that are cutting edge in this area. To me, it seems Oracle includes JSF in its offerings because it is just one piece of a big package.
Ace thanks for that! I've never seen Scala before... I wonder whether many of these will be brought in with Java 8 ( I know the lambada thing is...) One question... How do you do the mono space font within other text on here?? Thanks! 
&gt;In Java you always need to spell out the type of each parameter and variable. In more advanced programming languages (like Haskell, or anything that has a Hindley-Milner type system), the compiler works out the type for itself So does Small Basic.... I think? I've heard that Haskell's pretty dense.. Cheers 
The Eclipse IDE. Honestly after using it for a few years, VS just feels clunky.
Google's Autovalue provides a much better approach for value classes: https://github.com/google/auto
As others have pointed out as well; it's the same thing over and over and over and over ad infinitum... People came into contact with JSF 1.2 or even worse 1.1. Left for something else, never looked back. Can't fantom that things can actually change and improve and now keep evangelizing how bad JSF is.
&gt; The most recent version may be fantastic but most developers got a nasty taste in their mouths from previous versions and have never bothered to go back. When I first saw 3D games in the early 90-ties they were really crappy. 2D games looked way better. It left a bad taste in my mouth so I never played a 3D game again and till this day exclusively play 2D games. After al, technology never ever changes, does it? 
Can I make a suggestion? I and many people don't like to download random executables and run them on our computers. And the part about needed CMD also makes me nervous, Java CLI apps don't require Windows. Create a GitHub account and post your *SOURCE* there if you want it reviewed. Make it easy for other people to build too.
&gt; Taking about Java pains - the fact that Arrays.asList doesn't give you back java.util.Arraylist is one of them Programming by interface is much better. It allows them to use what's appropriate. If you really want an ArrayList, you could create your own.
Is that supposed to be a bad thing? Java 8 - Forged in the heart of a volcano! Sounds like the one ring :)
&gt; I know static typing in Java is not a state of the art thing like Scala, but it's simple and powerful enough to get the job done. It's actually too simple and on the other hand too complex like in `List&lt;? super Blubb&gt;` Too simple, because you can't even give equals() a sensible type. 
p.s. The JSF lifecycle is most likely not tested. I assume it concerns single independent GET requests here. In that case the JSF lifecycle only has render response in it. In other words, there's no lifecycle to speak of. It directly processes the template in a top to bottom single pass and spits out the HTML. (When you get really technical, there's one potential weak point in JSF here; it will still "build" the template for each request. It's not that dumb that it will read and parse the .xhtml source file (that part will be cache in the Facelets cache), but it will build the component tree and process includes if any are used. All this work is useless if the component tree is static anyway)
Not sure, definitely gonna mess around with that once I get closer to a stable release though
For Java programmers that have seen a bit Haskell and whish they had something like that on the JVM, there is [Frege](https://github.com/Frege/frege), which is essentially a Haskell 2010 dialect + higher rank types + the possibility to use Java classes as abstract types and their methods as functions.
No doubt it's useful, it's just hideous and icky. Strtok blows. 
Lack of Regex literals. Instead you must type your regex as a String, thereby quoting each and every backslash and quote. Want' to match 2 backslashs? Nothing easier than that: "\\\\\\\\\\\\\\\\" Which makes the regex not exactly more readable. Plus, it cannot get checked at compile time. Instead, you get a PatternSyntaxException at runtime. Plus, some methods interpret their String argument as regex. Surprise.
This is a big one. A lot of people seem to hate Java's verbosity, but I feel like the speed at which you write code is the easiest thing to augment with an IDE. Readability is harder.
It doesn't use double inequality signs for printing to the console. Up yours, C++.
&gt; Excessive mutability is a cancer that spreads, especially nowadays when generating getters and setters automatically with an IDE is a second instinct for many of the programmers. It asks what methods you want mutators and/or accessors for. It doesn't assume that you want mutators for all of them. 
oh ok Thanks!
&gt; pointers As opposed to Handles? You want to manipulate internal structures or do some hokey casting? I'd rather not see that.
Why not just import static java.lang.System.out; 
That was mostly a joke, since I encounter that issue the most. my situation often follows a format similar to this: try { File file = new File("C"); List&lt;String&gt; input = Files.readAllLines(file.toPath(), Charset.defaultCharset()); for (final String line : input) { new Thread(new Runnable() { @Override public void run() { for (char ch : line.toCharArray()) { System.out.println(line.charAt(ch)); } Thread.sleep(100); } }).start(); } } catch (Exception e) { // abort } What I want is 1 try catch block, I dislike having to clutter my code with all of these random try catch blocks.
Great post, and convinced me to use Vaadin in my next appropriate little side project. Thanks!
It's literally like 2 seconds... But if that's too much Scala does it much better since getters and setters are typically needed for value classes.
Just go Scala for this stuff. Scala is totally Javas Coffeescript.
If you use an IDE you can debug and see which class is being executed in realtime no matter where it is executing, on a remote server, or locally etc. You can also find all implementing interfaces during development, typically by clicking the interface with your IDE and choosing "show implementations" or whatever feature you have. If you are not using an IDE there isn't a point to using Java, use something else. Static languages are static partly so that tooling can grow to lengths of great convenience.
WHY are you being downvoted, this is the most accurate post here. I've used them all I think, Ant, Maven, Ant+Ivy, Gradle, sbt, leiningen. Except for lein, I hate them all. Lein has some inconviences with them still. Gradle is slow and ridiculously arbitrary and built of the worst JVM language (groovy). It's like a Javascript on top of Java, do anything you want anytime. Why do we need Javascriptv2? I'd literally rather have a JVM build tool written in Javascript instead of Gradle. It's really sad that Google switched to use it for Android, to me that shows a clear lack of technical mastery over at google, they're choosing fashion over common sense. Maven is great for simple projects when everything follows maven layout expectations, but deviate even slightly from that and it completely falls apart. Ant is sort of easy to use, but horrible to code in and completely inconvenient with no built in modularity and package management. It's also old, with no real attempts to update to modern build requirements. Ant+Ivy is not completely hateable, but still based on Ant. Sbt is like gradle without features. You get a quasi scripting language with dep management you code instead of declare. It doesn't have decent ide integration anywhere, so enjoy using that text editor to update and break its fragile syntax. Lein finally does modularity right but thats thanks to the language it builds (clojure). It's plugin system is easy and it has easy dependency management. Like maven you can pull in plugins with configuration. It's literally the best tool out there but its for clojure folks. There have been some attempts at using it to build Java. I plan to start exploring that angle too since I dislike everything else.
Yeah, that's one way to get it to work, but to be honest, if the project would be larger than two classes, I'd use SLF4j instead.
Run it on the command line so you know what exceptions are being thrown: &gt;java -jar yourjar.jar It may be an issue of not having your libs folder in the same place as your jar.
It may be just your vision, or maybe you are top sensitive to hypes? Yes, we see a lot of kids now telling about client side, but this is what hypes are about! Lots of kids following each other suddenly, then next year everyone forgets it and hypes something else When I look at server side frameworks, there is as much innovation and development as ever.,, maybe even more. If you really look at tech you see this too! But if you only read popular comments on reddit made by the cool kids who love hypes, you think everything happens on the it client side, but this is not true... Just kids talking cool and so called serious managers and serious analysts following them without thinking too much
Send me a link to a good site that provides an example. I'm happy to see what's out there. 
Site that provides info about JSF or that uses it? Google for BalusC, or check his page on https://jsf.zeef.com For sites using JSF google for real world JSF links. There are a couple of pages that provide good list if examrx.
You'd really like Groovy then. 
agreed
You either surround it with \` (like \`code here\`) or start each line with 4 spaces for multiline code.
nice one cheers Tipaa.... I can understand this comment ;) 
The wealth of frame works and libraries such as Spring, Hibernate, the various Apache libraries and Google Guava. Apache Camel - is awesome for writing highly scalable software. Static typing - finding errors at compile type rather than at run time. JMX! The power to inspect and act on a running application is awesome! 
Center something to the screen. SWT and the Graphics library don't have a method to center something to a screen so I make one myself. 
the fact that I can use something else. /trolling 
Define "doesn't do anyone". First I'd recommend using `for` loops instead of `while` loops to make the code easier to read. A `for` loop is typically used when you have an idea of how many times you need to loop before you start looping. A `while` loop typically is used when you aren't sure how many time you'll need to loop. Also do you understand that the `name` variable on line 9 and the `name` variable on line 27 are completely independent from each other? Your fix name method returns a `String` but you don't do anything with that String when you call `fixName`. And think about how many times you need to fix the name.
You can use it to bootstrap Clojure, Scala, JRuby or Groovy :-)
Are you coding in Eclipse? One of the most beneficial things to know about is setting breakpoints. Set a breakpoint and go into debug mode. You should also comment your code. I'm not sure it's even doing what you want. I agree with JavaTrainer, use a for loop for this.
I have a general-purpose logging class that I bring to all my projects. It takes a string as a console parameter, and tags all console outputs with it. I create a new instance for each separate part of my code, and so all my outputs are tagged such as "[NET]", "[RENDER]", etc.
I'm working on a simple text adventure game project with turn based elements and hope of some random monster and equipment
Write a Simple chat client using sockets
Chat system with sockets is pretty easy when you use serialized objects. What i've been thinking of doing is a skype type replacement, but completely decentralized and encrypted. Wouldn't mind a partner for a casual project like this.
 &gt;it just doesn't seem to work as well as eclipse. You lost me there.
Sounds like an applet, but hard to say anything beyond that. Is it one on some general website, or one you're trying to drop into a page? Hard to say really but most likely the applet parameters aren't configured properly, start looking at the codebase property.
I've come across a fun compatibility issues in the past year, but the following is my favorite. A client reported that some software parsing an Excel file was failing, but I couldn't reproduce the problem locally -- I was getting a completely different error. It didn't take me long to pinpoint why this was happening: I was running 7 and the client was running 6. So then the question was, what changed? I managed to isolate the error down to the Excel library we used, [JXL](http://jexcelapi.sourceforge.net/). What had been happening was that the Excel file the software was parsing had stored dates with the format "YYYY". [Java's SimpleDateFormat in 6 only supported "yyyy"](http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html), though, and so parsing the date cells would throw an exception in the libary. JXL caught this exction, though, and would simply return a date string in a default format. Our software, then, was written under the assumption this default formatted date string was the proper representation of the date. In Java 7, however, ['YYYY', or Week Year, became supported](http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html). Because this was a supported format in Java 7, no exception was being thrown, and the date string was returned in a different, intended format. The software didn't know this intended format existed, and so failed whenever the SimpleDateFormat object was called on it.
&gt; ut most likely the applet parameters aren't configured properly, start looking at the codebase property. I'm assuming by "writing" you mean coding. What I'm talking about is trying to make a game work, but the client won't load and I don't know why, it has something to do with Java. And thanks for the advice 
With Java 8 web projects: @FunctionalInterface public interface LambdaFilter extends Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; @Override default public void init(FilterConfig filterConfig) throws ServletException {} @Override default public void destroy() {} } then return (LambdaFilter) (req, res, chain) -&gt; { req.setCharacterEncoding("UTF-8"); res.setCharacterEncoding("UTF-8"); chain.doFilter(req, res); }; 
I'd certainly pass on that. Not only would you be limiting yourself to one book but you would be limiting yourself to one from 15 years ago. Search online if you want a better book but also check other avenues for information (wikis, videos, etc). Your going to want to know Java in it's most up to date state for the benefit of knowing it's libraries and their respective uses.
Alright. I will try to return it soon then. By an off chance, do you happen to know any great online resources that would have as much content as a big book?
I can really only speak for this one.This book is really great. There are tons of examples and everything is explained in detail and there is nice highlighting and different fonts that make it easier on the eyes and for the brain to follow the code and explanation of said code. [Here it is.](http://www.amazon.com/Program-early-objects-Edition-Deitel/dp/0132575663) I used this book for Java and Advanced Java and actually am currently still using it for Data Structures. It is worth the purchase and once you start grasping the big picture with objects you'll start to have fun with it. Others posting may have some different thoughts. Read into different paths. The more you do and especially the more you code the better you will be. Code code code. Hope this helps.
Keep in mind I have absolutely No experience with sound or videos in terms of programming, but it sounds like a fun project in terms of learning opportunities. 
No exceptions. Actually no out put at all. I got System.out.println() first thing in my main method and even that wont be executed. Still window shows up which I create after that main method, but in that window there's no logo image or progressbar not moving.
Shoutout to Maven for solving all our enterprise problems.
FileFilter based on extensions, wrapping Iterator&lt;T&gt; in an Iterable&lt;T&gt;, reading long strings from text files in the same JAR using Class.getResourceAsStream(). I know that these exist in libraries, but the code required for them is so simple that I don't add a dependency for it.
What's wrong with the Spring MVC tutorials? The PetStore example that used to come bundled with Spring is a great learning tool with some excellent design patterns.
1. Deploying a self-contained WAR is *so* much easier than dealing with the BS that Python and Ruby bring along. (Virtualenv/rvm/bundler anyone?) 2. Similarly, that the JVM is both self contained, and... 3. It runs at near-native speed.
*Most* tutorials are bad, yes, because people who write them are around code all the time and make subconscious assumptions about what is common knowledge. 
You're absolutely right. In short: it will take some time while you find a decent guide, a blog, or person to follow when it comes specific technologies. For examples, back in the days when I started with Java EE I read almost nothing but Bauke Scholtz's blog: http://balusc.blogspot.com/ The amount of low quality resources gets bigger every day, and I think the reason behind it is: 1. lack of experience: people without any experience promoting their blog and Hello World class applications. Yes, I can confirm, even a Hello World application, a really basic Java Applet, JSF, JSP example can be so badly written that it literally hurts when you see it. It's really frustrating I know how you feel, read BalusC's rant about roseindia: http://balusc.blogspot.com/2008/06/what-is-it-with-roseindia.html 2. education: some countries are pushing this programming thing so hard and with such a low quality that it's stunning. It's also important to note, that you probably won't find any resource about the really cool things like working efficiently with big data, writing heavily multithreaded application which won't just fall apart, etc.. People who figured this out already making tons of money from it and don't expect that there is a how-to-guide for these things, you have to figure it out for yourself. :)
People won't stop calculating stuff in Java memory that the database could calculate so easily for them.
Yes but the method signature returns List and java.util.Arrays.ArrayList is private so you wouldn't be able to create a variable of that type. 
No, it's definitely not immutable. But it's not dynamic, it won't resize when you add more elements. 
Not.
Sounds like you have a problem with the whole concept of OOP and inheritance rather than specifically Java. If you need to find out what the actual type is at runtime so that you can modify the implementation, then debugging in Eclipse can help you do that, or there is a command in Eclipse which can show you the inheritance hierarchy, just press Ctrl + T while your cursor is on the class/interface name in an editor. 
I was an Eclipse fan for most of my career and also didn't like IntelliJ, but it really has leapfrogged Eclipse in the last couple of years. If you haven't tried it in a while, I *highly* recommend giving it another shot. It really is better in every aspect.
Read some books! You can usually find free .pdf files if you know where to look and most come with a github repo. I've never had trouble finding more solid tutorials than I have time for. http://shop.oreilly.com/category/browse-subjects/programming.do
use maven or gradle, and never worry about jars again
oh the day i discovered maven... It is so helpful.
I think it is lazy approach to search the internet and scan some blogs and short tutorials and then not understanding anything. I always find myself doing that though and often it works, you find something that you can use, another thing that will maybe change your way of thinking. But at the end of the day if i really want to understand and know what i am doing i just need to go and read the documentation or find some books about the subject and really dive into it. But you know, it depends on how complex the thing is. 
I don't think you even need a book to learn Java nowadays. I would start with the [Oracle Java Tutorials](http://docs.oracle.com/javase/tutorial/java/index.html). They are always up to date and you can just copy and paste the examples to try them out.
1. Trivial refactoring. 2. IntelliJ. 3. Libraries for anything under the sun you want to do. 4. Static typing (makes it much easier to return to code you wrote months ago than say Python or Ruby...) 5. Have to write a lot less tests than in dynamically-typed land, the compiler catches lots of mistakes for you.
John Sonmez and John Purcell have some excellent java tutorials on pluralsight
&gt; used to 
Same feeling. I have been using Java for a few years, the more "tutorials" I read, the more I feel that doing proper and good documentation is important. I would suggest you to visit the official website of the tools (e.g. Spring, Structs, Hibernate, Jersey, Maven, etc.) and read their official guides to pick up the skill set, you will have higher chance to learn from correct sources (although that tutorial of Jersey 1.x is poorly written as many pieces are missing, IMO).
This happens the same way with PHP (or any fast-changing "web language"). Newbies run across tutorials and other articles that solve their problem; only the article was written back in ~2006 and the solution is long deprecated. Of course, these blog posters are usually fly-by-night, and never return to update or remove their posts. So it's not difficult to find people whose code is in dire straits due to this. 
On the other hand, C is used to bootstrap perl, cpython, ruby, ATS, luajit and a load of other languages. C++ is used to bootstrap java, AFAIK.
I disagree, the lack of up to date tutorials is *devastating*. Look around on how to read a file in Java. All the advice is different, some of it is crazy out of date. That's the problem. There are plenty of good programming tutorials around, but they are lacking in keeping up with best practices.
&gt; type inference will always have performance issues since the runtime &gt; needs to check and change/raise types depending on every calculation That's totally wrong. Type inference happens at compile time. The resulting code is the same as if you had specified the types explicitly. There's no runtime performance impact at all.
Same thing, only I'd use log4j2.
Why not use a proper logging framework?
but I have no idea what to provide, idk how to get the coding &amp; stuff for this :/
Pardon my ignorance, but is its API better than slf4j?
The API is mostly the same (though some nifty additions are worked at). The performance with async loggers is qualitatively different from all other logging frameworks available today (though currently there is a bug that may make async loggers lose messages on shutdown. It's being worked on atm).
I always thought this is common sense.
I have used books as some of you are suggesting but I also find myself getting lost in these books at times such. These resources are important and are sometimes excellent guide books but at this point i would treat these beginner books as nothing more then reference books in case i need to look something up. There are plenty of books aimed at beginners for learning programming and its concepts but wheres the "intermediate" books. Theres enough resources out there for anyone new to programming to pick one of these books up and become an efficient programmer after some time and hard work but are you just magically supposed to know where to go next? At times I feel as if i have never been more lost with technology. 
If it's just *pure* Java, please consider looking at Oracle's official javadocs. If a tutorial exists, and is lacking in best practices -- why can't you look at it, distill its essence, and slap on whatever coding style your company requires?
Any code design algorithms are easily transferable between languages, so while I read some papers with C++ demo implementations, I can implement them in Java. That said, English is a lot better for communicating these sorts of things so maybe just read the texts and ignore the code if it is bad. Usually the javadoc + two or three crappy tutorials (or one good one) is all you need. Now finding good, non-deprecated tutorials (or even code) on opengl... That is some shit. Its really a pepertuating cycle that they're trying to fix. IMO the opengl community is a mess... That is slowly sorting itself out. But seriously, use maven or some other build system (while you're at it do git too [not sure if you have that, seeing as your missing maven]) and pickup a few books on frameworks that interest you. You learn a lot of useless bullshit in most universities I find...
Im not using spring through my university, it was a side project for an app that would run on top of the spring framework. 
 Scanner s = new Scanner(System.in); int input = s.nextInt(); switch (input) { case 1: //... break; case 2: //... break; default: //... break; } Also, check out /r/javahelp. We're always happy to help with simple issues over there.
Why not just google it you lazy asshole. Do you homework yourself.
I think it's better for you to start looking for another language if you are searching for web technologies, like Perl, Python, Rudy.
Have you actually tried? There is something called the **Javadocs** - it's from Oracle, a company that is famous for actually having the rights to the Java language. http://www.oracle.com/technetwork/java/javase/documentation/index.html And if you had searched a little inside the documentation, you'd have come across this: http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html and there, you'd have found: http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt() So, I call bullshit on your excuses.
*Ruby
How so? I'm sorry, I'm still learning this language. Edit: I've got it, but i still have that extra space between "Carbon :" and the text field.
GridLayout is always going to make all the columns the same width. SpringLayout is good for this sort of thing http://docs.oracle.com/javase/tutorial/uiswing/layout/spring.html Also MigLayout is wonderful (but it requires the inclusion of another library)
I thought these were known as anonymous inner classes?
if there was something to be less excited about I'd like to know what it is
actually it depends on the language how easily transferable they are... unless of course your scope of languages is small
I can view the type hierarchy fine; that doesn't tell you which class is being used when. For reasons outside the scope of this discussion it is hugely impractical to use the debugger.
that was java's previous way of expressing something good in it's typical insanely verbose fashion with a slightly less insanely verbose version
I hear floats are best... 
I've been playing with netbeans 8 for a few days and... I gotta hand it to the netbeans team. Their stuff keeps getting better. I've been using IntelliJ for the last couple of years, but the really amazing maven integration in netbeans has me very impressed. Besides, the way netbeans behaves by default is very close to the way I end up configuring intellij to behave. I'm pondering making this switch permanent. Gotta do some more work in it to be sure.
Most of us at least try to do a good job, as far as I'm concerned. Why the attitude?
Easy; the new version of Python?
Commonly int and the values stored in the smallest unit of currency (cents, pence, etc.)
Why not join an existing project? The good thing, as with standards, is there are so many to choose from. Look around on github or bitbucket or sourceforge or wherever until you find something that you want to code on.
Kneeslapper.
BigInteger if you overflow int.
What game are you trying to run and where are you trying to run it. You need to provide much more information. Your query is equivalent to saying - "Does Kennedy Drive get me to Lincoln Lane?" We could tale wild guesses and help but without knowing geography, it would be rather difficult. The specific error you are getting is telling you that the program is missing some important information, without which it cannot run. You can try posting in r/fixit since they say they help with all issues and fixes.
thanks for the advice. 
Could you provide an example to make your point, I've never... Ever run into a situation where they cannot be easily translated.
IntelliJ has an in place editor and it shows it unescaped when you are not editing the line. You can also test the regex there.
If you are designing systems, choosing appropriate frameworks, supporting them operationally, making sure they scale, etc. in my mind that qualifies as an engineer. If someone gives you a task to implement an interface or write a script to do X, you are just a programmer. Totally subjective. I would say software engineers are a subset of programmers.
&gt; `float`: ...This data type should never be used for precise values, such as currency. For that, you will need to use the java.math.BigDecimal class instead. [Source](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
Honestly absolute majority of the projects I see when I search for "language:java" on github are something I have absolutely no idea how to put into use. Most of them are not "applications", but libraries if what I am saying makes sense. That seems rather hard to dig into straight away. 
Depends of the place, a lot of people call themself software engineer, because they do the same job as a "software engineer". But sometime people ask you if you do have an actual diploma and the [Enginneer's Rings](http://en.wikipedia.org/wiki/Engineer's_Ring).
no attitude..just the truth about what i like about java
I stand corrected, but I think I heard that in relation to doubles...
you win this time 
For smaller projects I try to keep dependencies to a minimum.
"Software engineer" to me sounds considerably more math heavy than anything I ever do, like writing a physics engine or something. I tend to prefer "software developer" to "programmer" though. "Programmer" has this connotation of strictly writing code, whereas "software developer" implies more involvement with planning the project as a whole. That's probably not standard though.
Are you asking under what circumstances in social conversation I would describe myself as a "programmer" rather than "software engineer", or are you asking under what circumstances would I consider work "programming" vs "engineering"? EDIT: OP edited the post to include this information, so now my comment is redundant.
They're basically interchangeable.
It depends whether the job is more an issue of design or implementation. My go to definition is, if you are expected at hiring to occasionally do something that's never been done before or in a way it's never been done, you are an engineer.
This is what I say as well. Engineers are more in-depth and dirty, writing things like drivers, compilers, etc, whereas developers use these tools to develop applications for consumers.
That's kinda the point of my question. It's about how we relate our profession to others.
:D
Thats not how it works in 'merica.
Kindly scroll through a few posts to find the same or similar questions already answered countless times. For the lazy ones: /r/javahelp has a wiki with plenty of tutorials.
I think it's called codingbat.com. 
High Wizard or Archmage.
Officially, my job title is “Scientist”.
Not quite. Some [people and places are pickier than others](http://www.freerepublic.com/focus/news/879964/posts).
Um...is this a thing? My job title is Software Engineer and I want to be in this order...
I'm in the Order of the Engineer and am a Software Engineer. It was offered in college to graduating seniors. Apparently it's much more prevalent in the northern United States/Canada. I've only ever seen one other person wearing the Engineer's Ring. 
I used to refer to myself as a "programmer". I recently got hired into a company where they told me my title was "Software Development Engineer", so I've tentatively started referring to myself as an "Software Development Engineer", but I still like the label "programmer" better.
Why? Properties at the language level is lousy idea. * They hide performance deficits in code * There's no good convention for them * They make code complete less useful What alt-insert is too much for you? 
Link doesn't work.
For good reasons. Java aims to be pure. If you want DLL hell go with .net.
I never use either, it's always App Developer, it's like the fucking rockstar of programmers and every dumb girl understands it in simplified terms.
Whenever a pompus douche says well "... well I went to engineering school." Then I refer to myself as a software engineer. If a rando at a party asks what I do, I say applied mathematics. So I don't get the inevitable : "My printer won't print, do you think it is related to my adobe update?" If the looks like they might later proclaim them self as a hobbyist programmer because they built a website on GeoCities, I say automated IT developer. If the person is in IT, I say linux systems maintainer. Finally, if the person seems decent, I tell them about a project I am passionate about. In the US there are no(or few) state mandated tests to be anything in the computing world. You have to pass the bar to be an attorney, and to do certain medical things you need to pass the MLE. There is no such thing in the computing world, so legally you can say any or none of those things. I personally cater it to my situation. 
I'm just an Apprentice Alchemist, grade 3. Always learning though. 
People I am trying to impress: Software Engineer (actual title). People who are familiar with technology: Developer. People less familiar with technology: Programmer. My Grandma who still uses CompuServe 2000: I work on computers.
In Retail, an Inventory is generally a set of the things customers can purchase from the retailer. Its purpose is for financial accounting. The modeling really depends upon the needs of the system. Inventory could be simply a count, representing the total number of units for sale in, say, the dry cereal department. One way to model a retail store is like this: A Store has Items. Items can have one or more Stock Keeping Units (or SKUS). Each SKU is known by its unique barcode. Each item is known by its unique Item Number. An example of an item that can have many SKUs is a box of Wheaties Cereal, manufactured by General Mills. The item is Wheaties, but the store might have cereal boxes on which appears a picture of a different sports star. Each unique box is a different SKU. An inventory could be calculated for just Wheaties, or just items manufactured by General Mills, or for the entire Dry Cereal Department, or for the entire store.
lold
Read "Head First Java".
day-to-day vs c.v/interviewing/linkedin.
That is not going to really teach you how to program. It is a bunch of short problems to solve if you already have a grounding in the language. 
If someone takes his money, have a little fun and submit the work to some of the antiplagiarism web sites, whether or not he stiffs you, like this kind of person probably will. The only material needed to complete this is http://docs.oracle.com/javase/tutorial/
Feel free to consult [Martyr2's Project List via DreamInCode](http://www.dreamincode.net/forums/topic/78802-martyr2s-mega-project-ideas-list/)
Software engineer for programmer reminds me too much of sanitation engineer for garbage man.
The word App instinctively makes my eyes roll. To reference the 3+ million line enterprise applications ive worked on as "apps" feels like a derogatory term. I guess the reality is that PhoneGap is dominating the mobile marketplace and so javascript reigns supreme there too. App. App. App. Is amazon an app? Flappy Bird is a cool app.
Browsing order-of-the-engineer's website, instead of selling you a giant ceremonial ring, they give you the schematics. Legit.
I do computer shit.
My official title is Software Developer, so I go with that.
&gt; WTF is wrong with your mindset I've been a programmer for over 20 years+ and am cynical and jaded. 
OK, what is your course and who is your lecturer?
Suggestion: pull down your site, develop software professionally for a decade, and then start anew.
&gt; you are just a programmer I honestly thought you were coming at this from the other angle until I read that. Each is a different skill set, that may overlap. I don't think it's helpful to say things like this.
&gt;&gt; I'm a man of my word, and can provide any proof needed. 
Engineering is a defined discipline that implies rigor. Unfortunately, software is not quite there yet...software is horribly bad, if bridges were like software, you'd be taking your life in your hands every time you cross one. So I say I'm a software engineer because it carries that weight with it, even though what we do is somewhat of a joke compared to other engineering disciplines.
Bioinformagician.
You need to google DecimalFormat
&gt;My printer won't print, do you think it is related to my adobe update?" I work in data mining and I get questions like this all the time. 
"software engineer" is mostly what an insecure programmer calls himself. You should still say it to non technical people though because it indicates that you are a trained professional.
Why would you make a script to "do" X? I would make a script to start X....
So I call myself software developer since programming is the maybe the least important and not a time consuming part in my job. I'm basically a mason. I have bricks which I place on top of each other according to certain rules, but first and foremost I have to think about how to do it the best way possible in this situation and according to the specifications of the architect and customer. Additionally, I also have to think about the consequences and effects in a few years when another poor mason comes and want to add something.
An array supposes the input size is finite and known in advance. And it may well be. But two years later that input might change due to scalability issues so the small overhead of an ArrayList or a LinkedList is worth the cost of admission?
According to the "Orders" website, they don't consider "Computing Professionals" to be engineers. The Engineering homepage links to this other order that they created to make software people happy: http://www.computing-professional.org/
There's delombok in case you need to get rid of lombok for some reason... But I love it so much, I wouldn't want to go back. 
What do you consider to be an "actual engineer"? I don't care if the other engineers on my team wear a ring or have a degree from a fancy program. What I care about is whether they can do their job and have the skills to contribute to our software. In the real world of software development, where you got your education rarely comes up, its your work experience and concrete skills that matter. I'd probably think less of a person if they actually believed that a ring alone meant they were better than anyone else.
"because it is mandated upon us" You probably shouldn't be in this field.
The most universal answer is "it depends". If you're dealing with a special case of an application or have a very math-heavy problem, like audio/image processing or any form of matrix multiplication then sure, go ahead and use arrays. In any other case the production code _should be easy to understand first_ IMO. Most of production code in my experience is _read_ more often than _written_, so it makes sense to save yourself the headache and the "wtf was i thinking?" moments when working on code. Java collections (let's include parts of Guava to that) also convey _meaning_ behind the data structure - in List&lt;&gt; the order of elements matters, while in Set&lt;&gt; does not. List&lt;&gt; can contain duplicates, while Set&lt;&gt; cannot*. ConcurrentMap or ImmutableMap are a-ok to use when dealing with multithreaded code, while the ordinary HashMap in that situation should be avoided like fire. Raw arrays don't give you any of these benefits, but they give you ArrayOutOfBoundsException if you make even a slightest mistake. IMO in 99% of applications the minuscule performance differences (like array access vs. .get(int) methods) should be ignored in favor of code readability. JVM is an awesome piece of technology, so let it do its work (JIT, code inlining) and focus on making the development easier for you. And besides, one might say that ArrayList is just an array with tons of convenience methods. 
One does not simply learn of Java 8 new features from a book.
EDIT: After reading more comments, it seems like some people would use the word "Developer" for what I describe below. Clearly the vocabulary in our industry is very subjective. But most of us are in agreement that "programmer" is close to synonymous with "code monkey." It really depends on what you are doing at your job, not what the company labels you with your title. Software Engineering is a super set of Programming and Developing. The B.E. kids out there will probably get all whiney about the use of the word "Engineer", but get over it. Software Engineers own entire products, are responsible for identifying requirements, documenting specifications &amp; design, building new features and improvements, considering the performance and integration implications of their choices, delivering, and maintaining all without being told what or how to do it. An engineer plays the role of architect, programmer, QA, manager, support, oncall, all in one. I've definitely had jobs in the past where I'd consider myself a programmer, and at the time I never understood what exactly the difference between that and an engineer was supposed to be. Once you work as a software engineer, you understand the difference very clearly.
Are you asking in connection to some specific domain?
I'd be more worried that code would be extremely messy in two years time... and when the business requirements change, I wouldn't be surprised if had to basically redo the whole thing. As I said in the other comment, unless you have a very special case, go with collections. The get(int) method in array list _is_ just an array access with a range check. 
For me the distinction is between application developer (and I'm not really talking about smart phone apps) and software engineer. The latter writes supporting technologies (like an OS, language, server, framework...) whereas the application developer will use the output of the software engineer to write a product or service offering specific functionality for the person purchasing it. Very often "application" is replaced by a more specific term like web, app, game...
Yeah, the third-raters have started with their relentless blogspam of misunderstood and poorly communicated ideas.
So are you saying that the line between developer and engineer is simply the interface into the software that you write? If I write a service application or a framework library, I'm an engineer. But if I write an application that has a pretty UI, I'm a developer? That seems somewhat arbitrary.
See static method String.format
So true. In the past months I saw a poster of a collegue that explains perfectly why **you must always say "I don't know anything about computers"**. 
Amateurs. And people who feel the need to develop their own databases when they should be developing the application.
Here, in Italy, there is an Order of the Engineer, but I always think that there aren't equivalent orders across the World. TIL about the Engineer's Rings. 0.o P.S. In Italy we have an *Engineer's rubber-stamp* ([image](http://datastorage02.maggioli.it/data/thumbs/data/blog/images/DV7ss8cl9X/KSBWAc5Idx240_180_75_0.jpg)). 
* *applied mathematics* * *automated IT developer* I'm writing back this titles to use them to avoid answers like: "I have to backup my iPhone and I need your help in order to install iTunes and transfer all the data". 
This discussion had to be posted in /r/programming IMHO. That subreddit was more pertinent to the discussion. Many others *software engineers* could take part to this thread.
i make software.
I just say: I'm just a computer programmer. And leave it as that, if they ask who for etc and what I do for them, then they get it some more. My wife does the same, she earns well over $160k, and brings in herself around 130million a year for the company she works for 'I just do some accounts stuff for X'
As far as I know there is only one: "Java SE 8 For the Really Impatient" by Cay Horstmann I read it, it is good.
Take it easy folks. If only a developer had a great English, would we not had more Shakespeare than engineers. So, Chill!
This is a bit of a simplification but someone who's studied to be an "engineer" (particularly a chartered one) will have had to study things like ethics, how their work interacts with other systems, systems thinking or Systemics and a variety of similar big picture things, rather than software development per se. 
I usually tell people I'm a programmer, or for most folks that I "tell computers what to do", since the vast majority aren't technical.
If you just need to print rounded, try format method: System.out.format("%.2f%n",result); 
Nice one! I see it's the same author as Scala for the impatient which was also very good. Looks like it's about $20 for the Kindle edition: http://www.amazon.com/Java-SE-8-Really-Impatient-ebook/dp/B00HSH2QT6
Haha, I intend to actually use the features. I've used similar features in other languages, so in many ways it's more a matter of becoming familiar with language-specific nuances and syntax.
I don't know. Probably. Who cares? Regular users don't use XP, servers don't use XP, and Microsoft is going to stop supporting XP soon. They have a countdown timer: http://www.microsoft.com/en-us/windows/enterprise/endofsupport.aspx
Some one sure [does](http://www.netmarketshare.com/operating-system-market-share.aspx?qprid=10&amp;qpcustomd=0)
At first this seemed like a pretty minor gripe to me but then I followed the links to related articles and changed my mind. I had the same mindset of one of the writers where I was aware of the constructor vs setter injection arguments but mostly viewed them as academic and not very worthwhile. After reading those I am definitely on board with constructor injection.
It's still a minor thing. I've not used mockito in a long time since my team has switched to using spock for all of our restring... Mocking in spock is much more intuitive as are assertions. In Spock, it's easy enough to mock setter or construction injection with mocks necessary for whatever you are testing. 
Good thing my degree title is BEng Software
I'd say programming is just implementation while software engineering encompasses everything in the SDLC.
http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html
To be blunt (and possibly pretentious) , I stopped referring to myself as a programmer after I graduated college. The folks I've run across that say they're programmers vs software developer or engineer tend to be the sort that don't have the same fundamentals you get from a formal education. Similarly, if you look at the job market, the positions for "programmer" and "software developer/engineer" (or SDE) have very different qualifications. 
Wait a second, I'm hesitating in advance about deploying Java 8 on modern servers. You're talking about people stuck in 2002-2003. The cross section of those people with the ones who even have Java 8 on their radar must be vanishingly small.
&gt; The cross section of those people with the ones who even have Java 8 on their radar must be vanishingly small. I don't have the data to evaluate that statement. I do know that a large quantity of installed Windows OSes are still XP-era despite MS trying to end-of-life it. There will be people, presumably like the OP, who want to know if Java 8 will work on their systems. I work for a client who is still upgrading desktops to Windows 7, and that only when people's actual hardware gets upgraded -- so they have a large installed base of XP desktop machines and Windows 2003 servers in production. Yet they will upgrade desktop Java to the latest version to keep on top of security patches. So to your original question "Who cares?" -- the answer is obviously more people than you think. The reality of the business world, as well as a certain segment of the consumer user base, is that a 2003 era OS is working just fine for them, and it costs a lot of money to upgrade, beyond just the license costs. Therefore, asking if Java 8 is supported is a valid and pertinent question.
What?
Yes I understand that some people still use XP for whatever reason. They'll stick with XP long after it's been abandoned by Microsoft. Great. Who cares? &gt; the answer is obviously more people than you think. No, it isn't. I went through the whole IE6 thing. Really, I understand. How many people stuck on XP do you think are running Java 7 and considering upgrading to Java 8? If they're stuck on XP, I can't imagine that a *Java* upgrade has even entered their minds. Even if it did, remember we're talking about either: clients, who apparently need Java 8 to run a Java 8-specific applet, or servers to run a Java 8-specific server... and even the sysadmins are stuck on XP for some reason. That situation is so rare that it's not worth talking about.
&gt; Regular users don't use XP Windows XP has 20%+ market share (more than Mac + Linux together)
JavaScript doesn't have type inference. Note that there's two kinds of type inference: one is the kind that happens at compile time, which is what I was talking about. The other is an optimization technique for dynamic programming languages where the runtime works out that while a variable could in theory hold any kind of value, in practice it's always, say, an int during actual computation. In that case, a JIT compiler could kick in and produce machine code which assumes foo is always an int. PyPy does something like this, for example, and there's been research on it for JavaScript. But it's something completely different from what I was talking about.
You're looping twice, and do not need to. As long as both arrays are the same length then use grid[0] in the i loop. If the arrays differ in size you have other problems anyway. Try this out: public static void main(String[] args) { int correctAnswer = 0; String[][] grid = { { "Alabama", "California", "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Kansas", "Lousiana", "Maryland", "New Mexico", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", "Texas", "Utah", "Virgina", "West Virginia" }, { "Montgomery", "Sacramento", "Dover", "Tallahassee", "Atlanta", "Honolulu", "Boise", "Topeka", "Baton Rouge", "Annapolis", "San Jose", "Salem", "Harrisburg", "Providence", "Columbia", "Austin", "Salt Lake City", "Richmond", "Charleston" } }; for (int k = 0; k &lt; grid[0].length; k++) { System.out.println("What is the capital of " + grid[0][k] + "?"); String capital = input.next(); String answer = grid[1][k]; if (capital.equalsIgnoreCase(answer)) { correctAnswer++; System.out.println("Your answer is correct"); } else { System.out.println("The correct answer should be " + answer); } } System.out.println("The correct count is " + correctAnswer); } Edit: A quick note, on OS X in Eclipse I had to remove the .useDelimter from line 6 to make it work. I don't know if this needs to work on all systems or not, but you may want to look into that if it is a requirement.
the "/r/n" delimiter is the default for Windows systems. In Unix-based systems (Linux, Mac, etc.), the new link delimiter is simply "/n"
You didn't write your getters or setters. Also, you didn't implement reducePrice() the way your assignment said to, read over that again 
Along with the comment below from /u/Syath, you should also not be using the useDelimiter method. Instead, remove that method entirely, and in your loop use input.nextLine() instead. That will make your program work on Unix-based systems as well as Windows.
Reduce price should actually multiply by .95
Or it can be done this way to simply give you the reduced price. My way of .05 would cause you to then have to subtract from the original price to get the reduced price
Yeah, but Java naming convention would suggest that "reducePrice()" would reduce the price, wheras "getReducedPrice()" would return the 5% value.
What do you mean by support? Do you mean support in terms of security patches and bug fixes or just - will it run? If the latter, companies do usually backport security patches and test them on wide variety of systems. If the latter, your guess is as good as anyone else. Windows XP will soon lose support from Microsoft. Of all the users running XP, a small fraction will use Java and even smaller fraction will have it on the client Why would Oracle spend money and effort on supporting it?
for some reason it put a "%" but it was a -5.00 So I just need to reduce it by -5.00
Make sure you wrap ProductPrinter's code in class ProductPrinter { //code }
That's an interesting solution.
&gt; The reality of the business world, as well as a certain segment of the consumer user base, is that a 2003 era OS is working just fine for them, and it costs a lot of money to upgrade, beyond just the license costs. Liability will (or at least should) push the remaining businesses clinging to XP to upgrade. Businesses typically carry insurance policies to protect against losses due to a variety of events, including "hacking". April 9, 2014 comes around and sometime afterward, a business still clinging to XP is "hacked" and quite a bit of money is lost. The insurance company is going to say, "Oh, you're still using an OS that isn't supported anymore? Yeah, we're not coving your losses."
=[
Yes. A well implemented hash map lookup is effectively `O(1)`. A naive search through an array is `O(n)`. Edit: assuming the hash calculation in `O(1)`.
I do not concur with several of the statements made here: &gt; Using less memory has several advantages: less time is spent on garbage collection Uh, no. *churning* less memory means less time is spent on GC, but just allocating memory and then holding onto references to it doesn't touch GC performance. Additionally, GCs have run on a different thread [and don't block the JVM] for a long time now, which means time spent inside GC just doesn't matter like it used to. &gt; bigger data sets can be processed [...] we have doubled the size of the data sets we can process &gt; [...] the O() notation is a guide to the behaviour for large values of n, but may be misleading for smaller values of n. [...] The exact value for n is not a constant. I've seen figures of both 7 and 20 being cited. So, wait. I want to work with huge datasets, and use terms like "doubled", then note that "well, O(n^2) is fine so long as I have 7 or 20 items". What? Yes, I get that that's an example, but seriously... Additionally: as soon as you start using the word "doubled", you better be looking at O(log(n)) or O(m) algorithms, like hashmaps, or this is going to doom you. &gt; Testing it, what I find is that memory consumption with the compact record implementation is just 50% of that with the old implementation. Runtime performance varies a bit, but is better for most data sets, and slightly worse for a few. Runtime here combines the effects of searching with the memory compactness benefits, so that's the overall figure. That seems mighty hand-wavy. In the end, yes: the author can manage datasets of double the size without hitting disk, which is good. But I don't think this article makes a compelling argument on the subject in general.
Do you still need help?
[?](http://www.youtube.com/watch?v=TGDQ85Dg-ss&amp;feature=kp)
The compiler doesn't know whether whichmessage &gt; 0, and so it can't tell whether either of the while loops will be entered. You should initialize outCome outside of the loops.
&gt; Of all the users running XP, a small fraction will use Java and even smaller fraction will have it on the client Can you provide a specific numbers (or source)?
You're off on both, I believe; a well implemented hash map lookup is O(m), and a naive search through an array is O(m*n) [in both cases, 'm' is the length of the key you're looking up]. I don't recall, but String may only hash the value once and cache it [seeing as how Strings are immutable, that would make sense], which would indeed make it O(1) most of the time. The author in this post is asserting they have a large number of items, [hence they care about memory usage], so I would expect the keys to have nontrivial length in many cases.
That's right petercooper. Here's a link for reference. http://www.engineerscanada.ca/accreditation Dunno how it is in other countries but "engineer" in Canada means that you are an accredited engineer. This comes with a huge set of extra responsibilities. What ticks me off is when I see job titles like "front end engineer". An engineer does not go though the hell that is engineering to become a "front end engineer".
Woops. I didn't even realize this was a link to a post. I thought it was just a question. I agree with you; my response answer the hash function is approximately O(1).
Well, I asked for an an example because you're being overly vague... I've seen c ports/front-ends to several heavy oop applications (ie the winapi is a good example of this, same as openglwhich is heavily state based.)
The problem is that I'm getting the values between } and { as well, like you said. I was wondering if you knew how I could ignore those values and just get the ones that are between { and }.
In the file you are trying to read, is there anything in between the '}' and '{' (in that order) if not you can just make an if statement to jump over empty strings: if (str.trim().equals("")) continue; // this will skip to the end of that iteration of that loop
That would make sense since they both except regex. So wouldn't this be helpful? I mean just use that regex statement in the .useDelimiter and you wont get data between } and {. the only problem is you'll still get a { on the first read and } on the last.
I think the second replace all would be better since the first character may or may not be a curly brace.
I think the point is that complexity class does not tell the whole story when it comes to wall clock execution time. An O(n) algorithm may very well be faster at small enough n due to trade offs needed to maintain O(1) properties.
As a student I've been introduced to both of the following sites as problem sets to help expand basic skills and learn a bit more about the language. http://codingbat.com/java As for this second one, any language works well here, especially the early problems. You can test your knowledge of the language and expand your math skills at the same time. https://projecteuler.net/ Hope those provide some sort of help! 
Neat, so you would create a matcher and use .group()? 
Not sure if this has been explicitly mentioned... but I find debugging Java to be infinitely easier than other languages I've worked in.
Sorry, I'm on a mobile phone so I can't really type out too much detail, but if you Google the design pattern "singleton" that may help you out. Basically, it's a pattern that guarantees you only ever have one instance of a class, so you can use that class to store"global" variables and stuff like that. I will say, as a very general guideline and without looking at your code, that globals are usually to be avoided and the fact that you are using one may be a sign that you need to change your design. Your mileage may vary, however. 
Use the string split method with "} {" as the regex. You'll get an array of the info strings, only problem is the first one will be "{info" and the last will be "info}". However, this won't suffer from the problem that /u/irocgts outlined. 
Yes, there are several ways to do it. The (usually wrong) way to do it is to make the member variables of your class public - that means that any other class can access those variables directly. For example, if you had a class Screen, an instance of that class screen and gave it public member variables xRes and yRes, you could access them like so: screen.xRes = 42; System.out.println(screen.yRes); Et cetera. This is usually frowned upon for a couple of reasons - one is that it exposes more of the class than you probably want, and another is that you might want to restrict the ability to change the values of those variables (for instance, making sure you don't accidentally set them to a negative value). The better way to do it is through getters and setters. These are very basic methods that either get the value of that variable, or set the value. For example: public int getXRes() { return xRes; } public void setXRes(int res) { xRes = res; } This is preferred, so I would recommend going that direction.
It sounds like what bothers you is simply the fact that someone didn't go through the same education / training as you, even though they may be just as capable (if not more) to do the same job.
I would certainly hope any qualified software engineer has the mindset to consider the same variety of big picture "things", most of the software engineers I know do just that. You don't need to wear a ring to know how to do that...
There's a type in the swing awt and/or javafx library called Dimensions I forget the package. you sound like your about to hurt yourself, don't hurt yourself :(
I've been reading documentation, but much of what I've read lacks either context or annotation.
That they've pushed back like 3-4 times. They need to put there foot down =/
Thanks so much, this fixed it up quite nicely
As /u/thirdworldprobs mentioned, try initializing outCome with an empty string. Also, I took the liberty of reducing repeated code, and added variables for values that are conditional: public static void evenGame(double[] funds, int dice1, int dice2, int sum, int whichmessage) { double bet = 0.50; System.out.println("\n You've chosen the even game!\nHmmm... now lets see. You bet $" + bet + "."); String outCome = ""; BufferedReader in; String messageFile = "winningmessages.txt"; if(sum % 2 != 0){ messageFile = "losingmessages.txt"; bet *= -2; } try{ funds[0] += bet; in = new BufferedReader(new FileReader(messageFile)); while(whichmessage-- &gt; 0){ outCome = in.readLine(); } in.close(); System.out.printf("%s\n\n",outCome); }catch(IOException e){ System.out.println("There was a problem with "+ e); } }
Yes. The basic logic would be something like this... private static final Pattern CURLY_DELIMITER_REGEX = Pattern.compile("\\{(\\w+)\\}"); // .. some code Matcher matcher = CURLY_DELIMITER_REGEX.matcher(&lt;INPUT STRING HERE&gt;); while(matcher.find()) { String value = matcher.group(1); // do something with value } Usually, I would just build a List&lt;String&gt; and return it back from some method. It makes the code fairly clean that way. 
Thats actually what I ended up doing. Worked like a charm.
install eclipse if you haven't or any proper ide netbeans intellJ ect That will highlight things like { } mismatches for you, and a bajillion other neat time saving things. autofill is amazing and it gets more so. Pain in the ass the first time you install/use one though, eclipse is easiest in my opinion just unzip and make sure java is on the PATH env variable. Also give yourself time to figure it out, you'll thank me when you realize that ide could've written this assignment for you with no more than 10 seconds effort from you, you'll be happy you learned that tool. The alternative is every weekend, for as long as your taking programming classes will be spent playing brace hunter.
Given the date, and assuming you want an actual physical book, I would return it and find something more inline with at least Java 1.5 (AKA Java 5) (which was released in 2004). The books that I typically recommend to newer Java developers are, * [Thinking in Java](http://www.amazon.com/Thinking-Java-4th-Bruce-Eckel/dp/0131872486/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1392614633&amp;sr=1-1&amp;keywords=bruce+eckel) * [Head First Java](http://www.amazon.com/Head-First-Java-Kathy-Sierra/dp/0596009208/ref=sr_1_5?s=books&amp;ie=UTF8&amp;qid=1392614661&amp;sr=1-5&amp;keywords=Java) After reading those two, I usually point them to, * [Head First Design Patterns](http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1392614762&amp;sr=1-1&amp;keywords=head+first+design+patterns+4th+edition) * [Effective Java](http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1392614661&amp;sr=1-2&amp;keywords=Java) * [Java Puzzlers, Traps, Pitfalls](http://www.amazon.com/Java%C2%BF-Puzzlers-Traps-Pitfalls-Corner/dp/032133678X/ref=la_B001CDCVUG_1_2?s=books&amp;ie=UTF8&amp;qid=1392614792&amp;sr=1-2) You can actually save yourself quite a bit of money if you get a [Safari Books Online](http://www.safaribooksonline.com/) account and just read them there (except Thinking in Java, it's not on there). Of course it's a subscription fee...so you only save money if you terminate after you've finished reading :)
That's hoping that there is nothing between } and {
Oh, I assumed from the format of the post that there wasn't.
Thank you, I returned it yesterday and got [Sams Teach Yourself Java in 21 Days](http://www.amazon.com/Java-Teach-Yourself-Covering-Edition/dp/067233710X/ref=sr_sp-atf_title_1_2?ie=UTF8&amp;qid=1392616427&amp;sr=8-2&amp;keywords=sams+teach+yourself+java+in+21+days+covering+java+7+and+android)
Awesome! That looks much better, it also appears to cover 8, which makes it even more worth it! :)
Oops I think I posted the wrong one. I must have the previous addition or something because mine says it covers Java 7 and some android.
This is just plain wrong. The issue here is not volatiles. The issue is that there's an invariant that i and j participate in (i==j), and that invariant is not correctly enforced (in any of his code). The way to correctly solve this problem is through locking, e.g., his "one" and "two" methods need the synchronized keyword.
Can you summerize what you like? I still find it the lesser choice maybe I missed something.
There are three "cardinality" meta-characters in a regex: - `*` - the preceding match zero or more times - `+` - the preceding match one or more times - `?` - the preceding match zero or one times
Im guessing the client is a webbrowser and Java on the backend? A popular way to do it is to use [JSON] (http://en.wikipedia.org/wiki/JSON) as a transmission format. There are several frameworks which can facilitate this on the server side.
I think you need to realize that there are three different "delimiters" as far as the scanner would interpret "delimiter" 1. `{` - which only occurs at the very beginning 1. `}{` 1. `}` - which only occurs at the very end So you might try to fashion the regex as an OR of these three alternatives making sure that #1 and #3 only match the very beginning and the very end respectively.
No, the issue is correctly being addressed. Look at the JLS, it is a demonstration of the same problem, except that in their example they allow multiple reasons for j to be greater than i. In the example at the very bottom the problem is demonstrated and solved by using volatile. I have an example that uses locks to product the same result, but it is a bit more complicated. 
There is webbrowser client and also java desktop client. JSON sounds good idea I take a look at it. Thanks.
long if you overflow int. BigInteger if you overflow long.
To my understanding, technology has less to do with code messes than the people who make them. That being said, plain JS sucks :)
&gt; Uh, no. churning less memory means less time is spent on GC, but just allocating memory and then holding onto references to it doesn't touch GC performance Actually, it does, because the more memory you've allocated, the more memory the GC has to hunt through, and the more objects it has to move around when doing compaction. It's well known that once your heap size goes over a few GB the cost of GC can become crippling, even if you don't churn. Hence, projects like MapDB and Stardog have moved to off-heap allocation in order to keep the cost of GC down. Stardog reported a 50x performance improvement, so this is not a cosmetic difference we're talking about. &gt; I want to work with huge datasets, and use terms like "doubled", then note that "well, O(n2) is fine so long as I have 7 or 20 items" You need to read more carefully. I have millions of records, but it's very rare for any record to have more than 10 properties. So what we're discussing is the time to look up all properties of all records, which is something like millions * O(10^2). &gt; That seems mighty hand-wavy. It would have been better if I'd given the actual numbers, but I was too busy experimenting with something else, and wanted to get the post out. &gt; I don't think this article makes a compelling argument on the subject in general. That wasn't the intention, either. The purpose is to get across that a simpler, more primitive algorithm can be much faster than doing it according to the textbook under certain circumstances. Obviously, those last three words are crucial.
I used to work at a bank and we used BigDecimel 
The only concern I have with Spring's jdbcTemplate is the throwing of runtime exceptions, specifically, EmptyResultDataAccessExceptions when the query returns no records. It should rather return a null instead.
Fifteen years of Java and I've never used it. Anyone have legitimate examples using finalize()?
So how should I fix this? Should create the arrayTest as a percolate object? I cant seem to get the driver to accept the 2-d array as a percolater object.
As a general rule, finalize shouldn't be used. Its behavior is too unpredictable. The rare situations where it is used involve closing out resources. For example, InputStream uses it to close the stream if the user doesn't correctly close it before the object is killed. 
Other than the three words having final in them, how do they belong in the same blog post? That's like having a blog post entitled "Getters and Setters | Lamdas | Method Overloading". It's not wrong or anything, it's just - why?
[] means "anything in this group". + means "one or more" So that pattern would match {, }, and any combination or repetition of them. That also means it would match, say, {{, and that's why I usually use a state machine to parse. But if your input is well formed, it should work.
The original example that I show is from the JLS specification. So your first paragraph is exactly what I am pointing out, in the example posted in the JLS there is distinctly an ability for j to be larger than i in a manner that is not guaranteed by volatile. The JVM is not free to execute j++ before i++, but it is true that other threads might perceive the update as such. Volatile ensures that these values will be read/written to the 'main memory'. I quote 'main memory' from the JLS, but I have not gone through their memory model section in detail. Also from my understanding 32bit operations are inherently atomic, but 64bit operations are not. So volatile will make 64bit operations atomic. I am still paraphrasing from the JLS. If you have something that shows j++ could be executed before i++ I would be interested in seeing it. 
Agreed, I died a little when I opened the page.
Thank you, This web-site is not for software developer but also who are at initial stage of various programming languages. I dont need to take decade to develop software. I am a developer from last two decade. If you need any help feel free to ask me. thank you....
That was a very digestible blog post. Now I know what JUnit Rules are and how to use them. Outside of the use cases of this blog, has anyone seen any interesting uses of JUnit Rules?
Everyone thanks for the help, I decided to drop it (Along with 95% of the class) and wait to take it with a different professor next semester. This guy is just god awful. 
I recently came across http://www.ninjaframework.org/ simple yet very powerful. Take a look if it suits your needs.
It's impossible for me to believe that someone who wrote the code on your site has developed professionally for more than a few months. Many of the examples contain severe conceptual mistakes and misunderstandings which should become clear to anyone who either tested the code, or tried the concepts in practise. An applicant who showed code like this as a part of their entry test wouldn't successfully gain even a junior position.
I don't have any experience in JSP or JSF, but I've been working for one year with [Vaadin](http://vaadin.com/) framework. Easy to start using it and it provides wide variety of functionality out of the box. For basic usage it doesn't require any knowledge of web frontend technologies, so once you are familiar with Java, you should pick up the API pretty quickly.
Vaadin looks really easy to pick up... I'll look into this.
&gt;The JVM is not free to execute j++ before i++ Yes it is. Reordering is used in many optimizations. As long as to the executing thread it appears that A happens-before B if A comes before B in the code flow, the JVM is free to do what it wants. In this case there is no difference to the running thread in which order j++ and i++ get executed and therefore JVM is free to reorder them. &gt;I have not gone through their memory model section in detail You should. It's *the* most important and basic thing to understand before writing a line of concurrent Java code. &gt;Also from my understanding 32bit operations are inherently atomic, but 64bit operations are not. So volatile will make 64bit operations atomic. Reading/writing to volatile 64bit value is atomic. The ++ operator is not atomic, even for volatiles. It's a common mistake people make, looking at i++ and thinking it must be atomic since it's so short or whatever. But it's non-atomic combination of read-increment-write, if you want atomic increment you need to use, e.g., AtomicInteger. &gt;If you have something that shows j++ could be executed before i++ It's legal according to the specification and therefore you can make your own JVM that does that if you want. You should write your code against the spec, not against what happens to work on your current setup.
I've got the PrimeFaces documentation printed out already and will be looking over it for the next week. Is it really simple enough to use as a 'one off' every now and then, rather than devoting a lot of time to it?
Just start with regular JSF, if you don't care about the look too much and the functionality you need is mostly form or table based type stuff it will be the easiest starting point IMO. You can customize what you need to customize with simple CSS or just regular html. If there comes a time you need something that you can't do with plain JSF easily, plugging in/replacing your JSF components with PrimeFaces/RichFaces/IceFaces components requires minimal work.
Depends upon how you want the percolate class to work. Myself I would do one of the following. 1. Create a constructor that takes in the array and then use it in the class. or 2. Make getters and setters for the array in the percolate class and then use those to set the array in percolate class. or 3. make the methods take in an array and work with it locally in the methods. or 4. use a combination of 1 and 2. Depending upon what I wanted the percolate class to do most likely I would choose option either option 2 or 4. Using getters and setters provides better encapsulation. 
Personally, I use Dojo for front-end work. It's incredibly powerful and flexible -- the learning curve can be steep, but well worth it in the long run. And it's actually backed by IBM, which is nice: http://dojotoolkit.org/
I'm not sure I follow ... all books can be read in bed. They are analog.
There are so many factors to consider. Are you aiming for a single page application? Does it have to work well on mobile devices? Is this a one-off kind of thing with 1 developer or will it turn into a team effort with a diverse set of developers? Do you have to support IE8 or worse? How many users will your app have? Dozens? Hundreds? Thousands? Do you have QA resources? Which tools are they familiar with for testing? There are sooo many choices, it's insane. Here's an article to get you started: http://zeroturnaround.com/rebellabs/the-2014-decision-makers-guide-to-java-web-frameworks/13/ Personally, I'd make sure to have a kick-ass REST/Websocket back-end and then choose a JavaScript library that suits my needs and just does enough magic to justify the investment to have to maintain JavaScript code. Current favorite: Ractive.js 
I am probably not the one to listen to, and probably the only one with this opinion, but I really like Apache Wicket. However, I'd like to raise a flag. You want to replace a training system, something made while learning, with a more updated learning/training system. I'd recommend whatever framework you use to learn in detail before designing production systems, or it'll only lead to headache.
I spent time with Dojo, but last I checked it's a Javascript web framework. I did PHP/Dojo at a past job.
A piece of code with no explanations of how to run it (will need at least some DB drivers) nor on how it works and why. Also having some weird variable scopes and unused assignments. And all this code, which is doing a pretty basic stuff of connecting to a database, which is pretty much the same on servlets as it is on desktop applications, is labeled *advanced java*. I do not really think this have any educational value for anyone whatsoever. 
Depends: 1) If all you care about is a getting a web interface out and don't mind using outmoded architectures, then JSF and a host of other server-generated HTML/JS frameworks will do the job. 2) If, however, you think you will need disconnected mode HTML5 page applications, then those frameworks aren't built for the HTML page as application architecture that leverages local storage and other HTML 5 capabilities (especially important for mobile apps). In this case you move towards Javascript frameworks and a REST/service-oriented backend like SpringMVC-REST. IMO these haven't matured as much either. But you just want a stupid dashboard / push-button admin page.... and you (or your company) is cheap, so just do the cheapest thing until the money makes it more worthwhile.
&gt;j++ and i++ could be updated out of order, but declaring them volatile prevents that. Yes, but your code snippet (3rd one) that I was referring to does not declare i and j volatile. As you've found out, volatile stops the JVM reordering in this case because it would violate the memory model. However, the point I've raised many times now is that this is a very bad example. It's really not about volatiles and how they work. It's more about enforcing the invariant that i and j participate in, which should be done through locking. I highly recommend the book Java Concurrency in Practice, it will make these concepts a lot clearer to you than reading the language spec.
I think Google's Java code style document sums it up pretty well: &gt; Tip: Don't do it. If you absolutely must, first read and understand Effective Java Item 7, "Avoid Finalizers," very carefully, and then don't do it.
I was looking at the last bit with the actual example, where I had made i and j volatile. Somehow I dropped the volatile in example three. I have read much of JCIP, though it has been a couple of years. Thanks for the heads up. edit: actually at that part, I think it should not have the volatile because it is supposed to demonstrate m &gt; n in which case the values j and i were read out of order. the keyword volatile would prevent that error.
Note this phrase: "BONUS for **exceeding** 3000 in sales: 100 " Then note, that you say you typed in **3000**. Then check your if statement: **if (sales &gt; 3000)** Everything should become clear.
I changed it. It's greater than or equal to. So if I type in 3000 it should print the bonus. But it isn't. if (sales &gt;= 300)
I don't understand how you are setting sales. From the looks of this, you set it to 335 and never touch it again.
Yes, I see that you are printing that. Now how does the user's input make it into your variable 'sales'?
Yeah, after re-reading the OP, he did say he's looking for a Java-based one. My bad, I originally thought he just wanted a client-side / UI framework. It's a preference, but I really like sticking to JS on the client side.
This. Java dominates as it should for the business logic on the backend. Java is terrible as a web framework provider. Unless you have some sort of need to support IE 6/7 or non-JavaScript clients (may God have mercy upon your soul), the day of server side HTML is pretty much over*. .* ^^nope, ^^not ^^even ^^justifiable ^^for ^^"SEO"
+1 for Wicket. I've found it an absolute joy to work with. I might be a bit weird, though.
&gt; So if I type in 3000 it should print the bonus. No, it shouldn't. You set your sales variable equal to 335. Your 'if' statement is telling your computer, "If 335 is greater than 3000, print the bonus." This will never be true, so the statement will never print. Why is sales being set to 335 in the first place? Isn't the value of "sales" dependent on whatever your user types in?
Yeah, I fixed the problems I was having. Figured reddit would have been more receptive to someone trying to learn, instead I'm downvoted and not even given an answer but told to "look for answer". Funny. Thanks anyways. 
These people are trying to help you by giving you clues and allowing you to solve your own puzzle!
After getting the answer from the user, what are you doing with their reply?
I just re-read all the comments and didn't see a single rude remark from anyone, and everyone who answered gave you hints towards the flaw in your code. You can say you're "trying to learn," or you can ask people to fix your code for you - not both. (Also, the downvotes were likely due to the jacked-up formatting on your post, which made it a lot harder to read.)
im no expert but you need to use @Override before the A and B class compare methods. it would just be -@Override -int compare ( obj ) { ... } you might need to change the base compare method to an abstract method which means it has no body --&gt; int compare ( obj ); then make Base an abstract class by adding Abstract to the first line --&gt; class Abstract Base { ... } i hope this helps EDIT: you should look into the override command and how to implement it because it might go in the base class. its been a while since my last java class.
Also what you might wanna do is in your Classes A &amp; B. Don't make int prob a public object. the conventional way is to make it a private variable. wich you will be able to set. Example private int prob; public class (int prop) { this.prop = prop //this is the main constuctor.. not needed } public void setProp(int prop){ this.prop = prop } ----------------- Main class: ---- public static void main( String[] args ) { A test = new A(); test.setProp(50); ... } Hope this is usefull aswell
JSF is far from outmoded. It is very popular and in wide use. It is probably the most popular choice for new Java applications. The solution you offer is expensive as you say because it is overly complex. Modern solutions require less developer hours and are cheaper to complete. This is a good thing.
I am not sure if it will be simple enough to use as you want but I think it is the easiest solution available. Someone else recommended just using plain JSF. If you do not care much about cosmetics that might be a great choice. I do not know what IDE you use but I really recommend trying the Netbeans tutorials. They have have simple tutorials on all the major web frameworks. It installs with a .exe complete with two application servers already configured. NetBeans IDE (pick the Java EE version) https://netbeans.org/downloads/index.html Tutorials (Scroll down to the bottom for the web frameworks section) https://netbeans.org/kb/trails/java-ee.html
I think it's outside the web paradigm as most people are used to, I don't think that makes it any way incorrect, just that it has a different view of client/server programming. It just requires a extensive desktop and web background, and then it is a joy, otherwise it's just a massive learning curve full of magic.
Your compare methods in the subclasses have different signatures to the compare method in the base class, as the argument types are different. This means that your compare methods in the subclasses are not actually overriding the compare method in the base class. If you try adding the @Override annotation, you will see that you get an error because of this. One solution is to make all of your compare methods accept a Base argument and use instanceof to determine if the actual passed object is something you can compare to. If you call compare on a reference to the base class then the signature of the method to invoke is determined by the methods in that base class only. Because your subclass compare methods do not override the base classes one, you will still be calling the base classes compare method. The details are [here](http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12)
http://imgur.com/MlPpPFj I made this for you. Each class simply has a move method in it, and that move method outprints "Car/Plane/Vehicle move" Look at the output near the bottom. to clarify - the output of the following statements: test.move() - Vehicle move test2.move - Car move test3.move - Plane move test5.move - Car move test6.move - Plane move
right before the if statement, do a System.out.println(sales); this should very quickly show you where your program is broken.
At what point did I said there were rude comments? Can you quote me that? I asked people to help with a program. Now, what that would mean is an answer to my question then telling me what I did wrong. Instead, I got "[–]locomotato 1 point 54 minutes ago After getting the answer from the user, what are you doing with their reply?" Oh, and that's how the code came out when I pasted it in. Nevermind reddit, shit. Didn't really needed to be bombarded with questions. I'm out. 
I think it's a joke referencing the X windows manager.
@Override isn't required. It's just a decoration for the reader and an extra check for the compiler. If you do use it, it goes in the sub class.
Well I just finished the first tutorial (Introduction to JavaServer Faces 2.x) and NetBeans made it very easy to follow along. I see how I could duplicate it in Eclipse easily though, but for the tutorials I'll stick with NetBeans to keep it simple. JSF seems pretty straight forward. So far I like it. If I get a handle on this, adding PrimeFaces on at a later date would just be extending it rather than switching gears, correct?
I've been so caught up with projects that I never properly thanked you. I really appreciate the time you put into correcting some of the minor things so that I can learn from it. Thank you sir. Edit: Have some gold
http://javalite.io/ ActiveWeb &amp; ActiveJDBC from the JavaLite project are a great set of tools to start working with web and database in Java. There's less BS than Spring and company while being adequately powerful to work under heavy daily load. It's relatively easy to get started with and the opinions are reasonable and consistent. Igor Polevoy (the creator) created the toolset after working with nasty Java frameworks for years and becoming dissatisfied with how complex and convoluted they had become. These tools are being used in production at a big daily deals site that starts with a G. I know this because I put them into production! ;) Also Igor is using AW&amp;ActiveJDBC for his company [Express Pigeon](http://expresspigeon.com). I'm not the original developer but I've worked closely with him and can confidently say that the framework is probably as clear and concise a native Java web+database framework I've ever worked with. Igor is also very active in the community and support of the JavaLite suite of tools. He's a great guy too and will talk your ear off about Java architecture if you give him the chance.
&gt; It is possible, however, that any given invocation of method two might observe a value for j that is much greater than the value observed for i, because method one might be executed many times between the moment when method two fetches the value of i and the moment when method two fetches the value of j. From your own example.
GWT + GWT-bootstrap There are a few concepts to grab (specially asynchronous calls), but you end up writing just Java code. 
Downvoters, care to explain? Or is it "It's not my framework/I don't use it, so I'll downvote to oblivion"?? grow up guys!
I have a few PDF versions of books, and the full sized iPad is great at viewing the pages with minimal scrolling. The nexus tablet or iPad mini are ok for non technical epubs or Kindle books, but I've found that the code block formatting can be hit or miss on the smaller screen. 
I only spend ~20% of my time "programming" and closer to 75% of my time "engineering" solutions, so that's one reason I sort of prefer the engineer title. It all depends who I'm talking to though -- sometimes I just say I "work on software."
The problem is straightforward, and there's a simple fix! The reason you get NaN is because you are taking a square root of a negative number. If you follow the logic in the "getRoot1" and "getRoot2" methods, you'll see that you are taking the square root if and only if the discriminant is negative ("if... &lt; 0"). Essentially, you've just switched what should be inside "if" block and what should be inside the "else" block. If you just switch those two blocks, you should be golden. Alternatively (and equivalently), turn "&lt; 0" into "&gt;= 0", and you should get what you expect.
Serious question, are there people actually using JavaFX?
1. Single page - definitely not. It's going to be accessing a MySQL database that keeps track of inventory and an MS SQL database that holds information on orders/returns/shipping etc. (everything order processing) 2. Mobile devices - No. 3. One developer right now. If we expanded our online presence enough and I couldn't keep up with the workload, we'd hire another. This isn't really being considered for the present, but I would like to have the code manageable enough for me to maintain it a few years from now when I don't remember what I did. :) 4. Any browser I want - the people working with it will get the browser I give them. 5. Users will be dozens right now. Very, very unlikely to be thousands. (Although that would be pretty cool) 6. QA Resources - nope. The only QA is me making sure nothing obvious breaks. Really, it is more of a 'one-off kind of thing with 1 developer'. The article seems to heavily favor Vaadin, but I don't see that discussed much here. I think your response is the most upvoted because (disclaimer, it's good advice - read up and decide for yourself!) it didn't offend anybody. Unfortunately frameworks can be very subjective, and I've seen a lot of arguments over why mine is best and yours is useless (just like programming languages). A lot of these replies here have a single post saying 'I like x' with some downvotes, with nobody giving any reason as to why they don't like those frameworks. That makes it tough to get any sort of community based help. So really, this probably is the best advice. Find out what works for you. I'm leaning towards JSF (it's somewhat a standard) and Vaadin (looks really easy to get going in).
Just to address point 1. I dont know if you and the poster meant the same thing about single page. Single Page Applications are (frontend) JavaScript applications which retrieve data from a server (usually) via REST API. Not just a simple page with no database.
Aha. SPA is really not necessary, unless it's for some reason much easier to implement, it seems like more complexity than I'd need.
"I'm a cleaner." (Senior Software Engineer IRL)
Already using Spring by chance? Check out SpringMVC with Thymeleaf. 
What are the common front end languages and what exactly is a framework?
Look at Glassdoor.com and hopefully find the company you're applying at. Sometimes they have salaries on there and that'll give you a target.
"Note that I wouldn't be making JSF + Primefaces my primary focus either... so if there's something simpler out there" Consider using HybridJava + jQuery. That IS simpler.
Sure lots of JavaFX stuff is going on. Once Java 8 comes out with the 3D support I think you'll see a bigger uptake.
Looks like the range starts at 93.5k for a basic programmer job on Long Island. Source: http://www.roberthalf.com/technology/salary-center?lobId=roberthalftechnology Note that this site usually lists higher salaries than some others, which is why I like to use it in negotiations :)
Ya research on glassdoor. Could be 50 in the Midwest or 120 at Google. I have left blank on applications before.
My first real gig (I had *extensive* co-op experience, but nothing full-time) was something like 65k per year back around 2004. This was in Atlanta, which is a major city, but still has one of the lowest Cost-of-Living adjustments going. Don't undersell yourself just because of where you live. Like other posters said, research on GlassDoor.
This. Also ask for 10k more than you actually want/need. And never say anything like "at least 60k", or "from 60-90k" ... you will get the lowest number you say.
As someone who hires developers, I always recommend you leave blank or put "negotiable". The amount we offer someone routinely varies depending on the interview, so don't put something that could be bad in an application cause you may never get the interview. That said, if during the interview the question comes up, I agree with the other responses-- you should have an idea of what entry level is going for so that you don't end up in ludicrous land. Honestly though, the hiring company probably has a pretty good idea of what they pay for entry level unless you've got some real-world experience to back things up. As you get more experienced, salaries become a more nuanced thing.
If the point is to do it in Java, then let me to throw out another suggestion-- http://dropwizard.codahale.com/ I've found it to be super straightforward to set up and use and has really good docs to get started. You could do HTML templating server-side (mustache or freemarker), or my preference which is just REST/JSON endpoints (simple with Jersey) and AngularJS front ends. If you want to stand up a web app really fast and don't care about language, use Rails-- but if Java is a requirement I'm a big fan of DW.
I'm a hiring manager in NYC. Depending on what experience you bring to the table from your co-op, how you fared with our technical interview and perhaps an agreement about a probation period, I would probably make an offer between $65-75k. If after the probation period, you are performing at the level beyond junior software engineer, a salary adjustment would be considered in the $85k arena, to be fair to you. However, it is very unlikely that a junior engineer without any full time corporate experience is going to be able to perform beyond junior level without something like 2 solid years of full time experience. Being in an office also means understanding corporate culture and getting along with others. The folks writing crazy stuff like Google job starting at $120k are really talking about a few very lucky individuals. No one I personally knew made this kind of money right out of college.
65,000/year is average pay out of undergrad for computer science majors in the united states, so that's a good place to start. if the interview is going well, bump it up to like 68/70
Prepare for disappointment. With no practical experience, you'll be on the sidelines after the planning phase closes. Non-coders usually have a hard time doing anything besides technical advice and looking up references. DON'T be discouraged - do your best and get psyched for the next one.
Yeah, it doesn't really make much sense now that I think about it. Ignore me, I didn't have my coffee this morning.
This is right. The high numbers may be nice to look at but I would never hire an entry level dev above 65-70k, 75 for someone really really special. 
This is solid advice. I grew up about 5mins from a intel plant, oracle, Nec (when they were big), Hp... all very close. Almost everyone I went to school with went into tech fields. Of all the people I grew up with only 2 got jobs out of college for over 100k and it was clear even in high school they were in a different arena all together. Unless you can prove you are bring more to the table than your competitors there is no reason for them to play more. 65-70k is good money and if in a couple years you feel you can do better get an offer and express to your boss your desire to stay if they can match the offer.
Sheeet you Americans make some dough.
I just started learning Java and saw a comment like "are people actually using Swing to make GUIs? It's ugly as sin" So I started learning JavaFX right from the start...I like being able to drop the default caspian.CSS into the project and having a nice looking program without any effort... Then again I'm a complete beginner, but why would anyone keep using Swing?
Try to go java (servlet, REST or whatever is supported in Java SE 7) and angularjs for the ui. Depends on what they need you to do.
Well, there are a lot of new tools for new, but you have not mentioned e.g. Comindware Tracker (http://www.comindware.com/tracker/) that is able to track in real time,help to set real time communication with the colleagues or team members, makes it possible to run ready-made business applications etc.
Every good programmer must master the complex art of manipulating "Google". https://www.google.ie/#q=java+drools Judging by your question, this probobly isnt a good starting point for you
Hi there, Our Library isn't open source but if you're working for a non profit or organisation in the education sector we might be able to help. http://bfo.com/products/pdf/ Drop us a line if interested. Cheers BFO Team
Don't. No, seriously. No one should use applets nowadays. Even if you just want to learn java pick something that will be usefull(like swing) and not something you will never use. Especially after many security vulnerabilities applets are blocked by defaulft If you want to do some web stuff use html,jsp, javascript. For desktop(and learning) swing will do.
Found [this article](https://weblogs.java.net/blog/editor/archive/2014/02/11/poll-result-top-3-java-ides-really-do-dominate-developer-desktops) there just now. Basically the numbers are: 44% Netbeans 38% Eclipse 11% IntelliJ It surprised me that the number for Netbeans is so high. It's a great IDE, but here on Reddit it seems to be all IntelliJ or Eclipse. Granted, it's only valid for the visitors of java.net that participated in the poll and by no means representative, as stated by the author. Still, the numbers surprised me.
Don't write an applet. Applets are 1990's shit. Java is mainly used as a server-side programming language these days. 
Like others said applets never really caught on. So you may want to focus your learning in other areas. Where Java is really strong is in server side enterprise applications, so you may want to focus on those, things like JSF, EJB, JPA.
This! Exactly what I was going to say. 
What about woodstox? http://woodstox.codehaus.org/
A lot of times I simply copy an existing java installation to the root of my drive. For example, in the company I work for it is usually a lot of time to get IT to install java for me. So what I do is look at the shared folders to find java installations and copy it to D:\jdkx.xx . The reason I copy it to the D drive is because most of the times I do not have write rights to the C drive. Then I create/update the following environment variables. 1. PATH, to include the new java path 2. JAVA_HOME, to set java home directory to the new location. That's it, most of my java programs or apps work without issues.
If you live, or will be in the San Francisco Bay Area, March 26, this is a pretty cool and free conference. In previous years, I seem to recall a lot of good talks and some giveaways from AWS staff and companies using their various services.
SCJP Sun Certified Programmer for Java 6 by Sierra &amp; Bates. Unfortunately it is for Java 6, but IMHO it's a very good book for beginners Java programmer who has some experience in any programming.
All the money you have.
Wow, thank you! Wasn't necessary, though. I did just give some advice that might help in the future. (Sorry for the late reply, but I was offline for the past three days - some vacation time ;) 
Leave it blank if at all possible. The time to be negotiating salaries is after the job offer, not before...
unable to leave it blank or i would have 
I hope I can. Most companies have a shared network drive that teams can use to dump their backups. For example, my team has been allocated 1 TB of space on a shared network drive to keep its documents, letters, videos and whatnot. Developers are given their own space within this shared space. This shared disk space should be usually accessible by a name. In Windows, it is like this. \\\\THECOMPANY\\TheTeamsName Within this, each developer creates his own folder \\\\THECOMPANY\\TheTeamsName\Developers\MrMadras \\\\THECOMPANY\\TheTeamsName\Developers\AnotherDev What I usually do is search for the java directory in the developers space. Someone is bound to have it. If I don't I just ask someone who has it to copy it to this shared drive and I copy it from there. Did this help?
I think im going to put 65K, I feel as if this is such an unfair question to ask especially at an entry level position. 
Java How to Program 9th edition. I am about half way through am really enjoying it. Make sure you do the exercises. I saw many, many recommendations for Head First Java but the writing style annoyed me no end.
Big Java: Early Objects by Cay S. Horstmann
I wonder if json would be faster?
Well, this has very little to do with JSON vs. XML, maybe apart from the cultural differences. The post is saying the default implementation of the DOM parser shipped with his JRE is slow when processing tiny XMLs due overhead to init its internal structures. Now there is no API for parsing JSON defined in Java SE and therefore there is no default implementation to compare with. There is JSON API defined in Java EE 7 (JSR 353), but each vendor is free to choose own implementation. EDIT: Both WildFly &amp; Glassfish are shipped with the reference implementation of JSR 353; Therefore the comparison would be sense, but it would be still a comparison of the quality of reference implementation, nothing to do with the JSON vs. XML discussion.
It would still be possible to compare the initialization performance of common and trusted JSON libraries against the default Xerxes parser and the Piccolo parser. If I were going to be parsing a whole lot of small documents, I would not just choose the best parsing library, but the easiest document format for parsing. I might even compare to protocol buffers, which should be MUCH faster. But depending on where your data is coming from, they might not have a good way to produce binary output. Culture doesn't even enter into this, unless you mean a culture of choosing the default without regard for the performance ramifications.
Hell, I would not choose XML any more EVER. Regardless of how performant the processors are. If you can choose what you output, you're going to be outputting in JSON these days. 
IF I found that XML parsers were faster than JSON parsers, I would check my testing framework and see where I screwed up. But if I could confirm it, I would use XML. When speed matters, you take what's fastest, not what's trendy. Of course, that seems wildly unlikely to me. JSON is much simpler to parse as a rule, so there's no reason it should ever lose the race. I mention protocol buffers, because I expect them to be much faster than JSON. There are probably other obstacles that make them unsuitable, but they should at least be considered for raw speed.
It sounds interesting, but in practice we ended up hating it. This just came in: https://sourcegraph.com/blog/switching-from-angularjs-to-server-side-html Big companies like twitter partially went back from this approach. JSF + PrimeFaces + OmniFaces is a pretty solid approach that's easy and performs really well as a bonus.
Well, does choosing Java makes you dependent on Java classes? Why is it a pain to write your own components? You put some markup on an XHTML page and by convention it's a first class component. What's difficult about that? And if you do it in Java it's not difficult either. Check this and tell me what's difficult about it: http://jdevelopment.nl/simple-java-based-jsf-22-custom-component 
I think people were just tired of yet again another we framework. We had endless years of discussions of JSF vs spring MVC and tapestry and wicket and struts and play and GWT and Vaadin and stripes and ... It's great to have so choice but the Java web framework market is completely fragmented. Everyone just shouts about his personal framework any when you'r looking for a Java job every company always uses another one, forcing you to learn most things all over again (and agar and again). And then you come in and present us with... YET ANOTHER ONE... It's a bit tiring...
Do you get access to the exercise solutions if you purchase the book?
Thanks didn't know about this one. Will have to check it out. So far I'm really liking GWT but was not sure if I wanted to move to Vaadin or just stay with plain GWT. 
Saddly I had this too. Try asking as a group if you could have diffrent topic instead on applets. Even then it should be fairly short( I had 2h lab) If you still want to learn sth, try this: http://docs.oracle.com/javase/tutorial/deployment/applet/index.html You will find there everything you would need to create and deploy applet(skip JNLP deployment and use applet tag - as said before you will never again use applet so there's no need to waste time) Basicly you need to extend Applet class, define init method, create security file, compile everything and deploy in applet tag
The general lesson here is to be aware of the demands in setting up and tearing down resources like parsers, DB connections, etc. Design accordingly.
Java is not Javascript, you might have better luck over in /r/javascript 
Tank u
Hello. Does Google use Java for any non-server, internal applications or utilities? Perhaps, even desktop apps for internal use. Or, is Java basically only used for server apps and Android? If Google shares code between their Android and iOS apps, how do they do it? How do you all see the future of Java vs. C#/.Net/Mono in terms of platform penetration? Will we ever see a Xamarin-equivalent for Java? I wish Google would have bought Sun for Java's sake.
A huge thank you goes out to all of you for making developing in Java a little less painful. I don't even like to think about writing Java before I found Guava and Dagger. When I work on Android projects, I try to avoid Guava because of the size of the jar. Have you guys considered splitting up Guava into a core library with extensions that depend on it?
What's your involvement with the Android team at Google? Do you poke them from day to day to upgrade to Java 7 / 8? :)
What's the one thing you dislike (hate?) the most about Java?
I suggest trying to teach yourself in the mean time: [Here's the website I used to learn Java in high school.](http://chortle.ccsu.edu/CS151/cs151java.html)
Have you considered providing Scala wrappers for your libraries? A bunch of us Scala developers love using your libs even though we seldom use Java anymore.
Hi! any updates to Google Guava planned with Java 8 features coming out soon?
This should be in the banner.
Do you plan to expand Guava to do more things like apache commons? (e.g., compression codecs, math, statistics, networks, etc...). What I really like about Guava is the succinct well thought out API, which doesn't always exist in external libraries.
Thanks a lot for Guava! I am using it daily and it makes life much easier :). One question: is there an active effort to get Guava functionality standardised and added to the Java class library (like Boost feeds new C++ standards)?
Why is there still no flatMap on Optional?
And why is map called transform?
Personally I think transform makes more sense in the Java world. 
Is there any chance we could see you this year at a Java convention talking about some of your creations? Maybe in Europe, even? Or at least in an online talk? It's been a really refreshing experience to hear Kevin on the Java Posse since I haven't seen you (heard of you) guys in like two years anywhere.
Ok, well, I'd definitely settle for transformAndConcat on Optional.
Is Dagger the direction Google intends to go for future new projects? Guice 4.0 is in beta, but its changes over 3.0 don't seem to be documented. Is that because you all are ambivalent about Guice's future?
Holy crap. * The class names of `Comparable` and `Comparator` are capitalized incorrectly. * The examples contains code that is generated by the IDE’s templates. * The example code for `Comparator` does not even compile! * `Comparator` is a genericized class, for heaven’s sake! * The source code formatting in general is horrible. prem, whoever you are, please take this site offline and don’t ever do this again. You obviously suck at it.
I think it's around $3000/month for a one bedroom apartment.
I just work in a mixed Java/Scala shop. I know I've been asked how the "map" method creates a Map instance, and how that is used by completely confused Java devs several times. 
Java 7 features are in preview right now. Both in the Android Studio preview as well as the Eclipse Android tools (ADT) preview. "Support for language features like multi-catch, try-with-resources, diamond operator, etc". *And it all works with* android 2.2+/froyo/sdk 8+ except for try-with-resources which requires android 4.4/kitkat/min sdk 19. For example see the Eclipse ADT 22.6 Preview: http://tools.android.com/recent/eclipseadt226preview 
You're writing an animal fighting simulation, using Guice, to train Google's robot army. Which combatant provider would you choose for your MurderousAnimalModule, and why: @Provides @Singleton ImmutableList&lt;MurderousAnimal&gt; provideDuck() { return ImmutableList.copyOf(DucksFactory.create(Sizes.HORSE, 1)); } or @Provides @Singleton ImmutableList&lt;MurderousAnimal&gt; provideHorses() { return ImmutableList.copyOf(HorsesFactory.create(Sizes.DUCK, 100)); } Also, please provide the runtime complexity of your robot army's battle algorithm.
See [GWT](http://www.gwtproject.org/) which is for creating web apps in Java by generating HTML/css/js from Java. It suffered a blow when Google distanced itself from it (probably due to Oracle issues) but has shown remarkable resilience since then. AFAIK, GWT (and therefor Java) are used in Google Moderator and Adwords. I think that most people wish that Google (or IBM?) had bought Java, but I must say that the idea that Google must own and control the languages it depends on is also distasteful. The Dart language makes a lot of sense to me, but the re-purposing of Go as a general purpose native language appears to be just a manifestation of the 'must own and control' sentiment.
This book to teach somebody Java? This is an advanced java book and doesn't cover basic java concepts at all.
I like the composable style and use it myself in Java, but `pure(v).bind(f)` doesn't appear to be equivalent to `f.apply(v)`, so I'm not convinced this is actually a monad - it fails the left-identity rule. Haven't checked the other two rules.
Does not compute. Evidently not many Reddit readers did the poll...
nothing special here, really, every comment of these applies also for backbone, knockout, ember and what not.
Whenever you ask for advice, you get a lot of people suggesting their own custom niche frameworks. Problem is, from your description of what you're looking for, you don't want to be messing around with something that's going to go out of style and no one will be using in 4-5 years. That's the problem you have right now with CodeIgniter. The most common and popular frameworks for java are Spring MVC and Jsf. Since you've already invested time into learning JSF - stick with JSF. I've never even heard of the Vaadin framework. Whenever someone claims that they're framework lets you write web apps without learning html, css, javascript, etc, you should pretty much assume it's a terrible framework. You'll end up investing a lot of time into it, only to find out that it there's things you cannot do with it and suddenly you're stuck. You'll hear a lot of enthusiastic "oh, that will be in the next release!" but they'll never ever actually cover everything and in the end you'll have to throw it out and write what you need by hand anyways. JSF is an excellent choice. It's good to have on your resume, it seems to work well, and it lets you do everything that it's possible to do in a web app.
Thanks a lot for all your hard work and dedication! Regarding AutoValue: Is it possible (in the future) to annotate accessor with custom annotations which are retained during compilation similar to *@javax.annotation.Nullable*? Example: @AutoValue public abstract class Example { public static Example create(String name, int integer) { return new AutoValue_Example(name, integer); } public abstract String name(); @MyCustomAnnotationX public abstract int integer(); } What i expect here is that the field *integer* will be annotated with @MyCustomAnnotationX in the class *AutoValue_Example*. Current code just ignores these Annotations. Can't open an issue, nor pull request nor contribute any code to this specific questions. Just asking - thanks again!
This it's the most important question that can be asked.
&gt; Tomorrow morning (Wednesday 2014-02-19, U.S. time) we will be here answering anything you want to know. Questions now, answers later.
Can I throw a request? The text message format parsing in java is still horribly, horribly balkanized. XML, YAML, JSON, etc. It would be REALLY NICE if someone could centralize the parsing of these tree-based constructs in a single functional api: - deserialization/serialization - streaming - common XPath/JSONPath etc expression engines for manipulation, transformation, data extraction that works on the common tree format - validation This could probably be also applied against binary formats like thrift and protocol buffers that also are tree-based structures. My gods, the convenience would be earth shattering
 i personally hate when people recommend that book when people are trying to learn the language, not best practices. I am thinking most of them say it just because others say it, because how can any one learn java by this book alone? get head first java
Recently I wanted to micro benchmark some code, I've heard about caliper on Java Posse so I googled it, watched tutorial video, got through code samples on the site, and then tried implementing simple benchmark and... asked myself, why there is no 1.0 beta 2 released? All the docs, video are using beta 2 which introduces substantial changes to API, but you can't used them if you are not willing to build the library by yourself.
Have you heard of [protocol buffers](https://code.google.com/p/protobuf/)? We use them pretty much exclusively at Google, which is why you might not see so many cross-format message parsers.
That puts things in perspective. I'm always jealous how entry level devs get so much money in SF area, but I guess they HAVE to get that much to get by.
So by "And it all works" you mean "All but the most important?" While still of course leaving out all the NIO2 improvements from Java 7 as well. Diamond is just sugar; using Eclipse's content assist to fill in generics is really not that bad (or using Guava's builders). Multi-catch is nice in that it keeps people from just catching Exception or Throwable, but it also doesn't really give me anything much over the IDE...it doesn't give me the warm fuzzies for ever seeing lambda support on Android.
I don't know, I have found the exercises straight forward and not felt the need to check against another source. I just noticed that the tenth version is due out very soon, not sure why there is now two versions (Late Objects and Early Objects) or what the difference is.
This code doesn't compile. Have you even looked at the API documentation?
Maybe I'm missing something but what's this post connection to Java besides the language name?
JavaScript has nothing to do with Java.
Not one of those guys, but AutoValue is for your "leaf" value classes, which is a class where you can simply make all the fields final, and not have to worry about all the boilerplate of creating hash code, equals and toString using the hash code, equals and toString from the fields. I haven't used it in any of my projects personally, but that's the idea. The case classes from Scala use pattern matching on the type and format of the input. Like a switch statement over an enum on crack.
I guess I liberally interpreted "teach".
Any plans to bring CodePro Analytix back from the grave? 
Ahh the old "read everything before making an assumption"
What exactly do you expect from this post? 
Sure it is. You can use ProGuard rules that keep the external interfaces consistent and publish the ProGuard file.
sorry, I just need a reason why I'm getting an "out of bounds" error
I don't know if you guys work on Protobuf-Java or whether that's a different time. But it's a really great project :) I guess I'm supposed to use this for a question... so, what's a standard day in the Google JCL team like? 
Java web framework world was a shitty place once. People came up with better solutions (Play for eg.) as they felt it could be better. And its the same case with every other mature language... Python/Ruby got plethora of frameworks. Its when people experiments/think/research/complain better things born and a good thing IMHO.
The guava hash functions are kind of nice. The Boom filter is cool though I ended up not needing it. I did need a consistent hash and the only one in guava only grows which isn't useful. I ended up having to write my own which could shrink as well as grow. Also allowed load balancing which was kind of nice. Anyway, it was kind of strange guava not having that since consistent hashing would seem like it was a core Google technology. Any change of guava getting a decent consistent hash?
Case classes do generate an unapply function for (for use in pattern matching), but they also generate an equals, toString and (probably) a hashcode method. The pattern matching aspect is great, but case classes also encourage you to encapsulate your data inside immutable struct-like objects, similar to 'leaf' value classes.
Have you learned about state machines?
This code looks awful, but immediately I can see that indexOfEmEnd is calculated wrong. You're getting an index relative to the substring. Instead, you should be using indexOf (str, offset).
Except that RESTlet can act as a very good backend for such a service, and the experience this team had in that type of environment can be reproduced in Java. The various build tools popular in the JS community can be tricky to integrate well with a Maven, Ant or Gradle lifecycle and it can certainly make your development process much slower. I think that's a good reason to post this here. I had similar experiences with Jetty running RESTlet and the JS front end was done in Backbone. It makes things a little trickier to get right and it can slow down development.
&gt; Wrong subreddit I disagree. Java backends are common for JS frontends. The points in the article stand for any JS frontend. One place I was at had a backbone front end with Java backend (RESTlet). In order to do some performance optimizations on the client side load time it was necessary to generate a lot of static JavaScript on the backend. That's when things really start to get complicated and this article is a good heads up for people new to this cross-platform problem. Is it so bad someone makes a heads up article? 
I apologize that my code offended you, I'm still learning. But I thank you for the help, the change in calculating the indexes and some other tweeks fixed the code!
&gt;but why would anyone keep using Swing? Existing projects. There's a lot of swing out there that can't be simply replaced by JavaFX without a lot of rewriting. It isn't a matter of the UI, it's a matter of all the events, models etc that are also wired to the UI. Additionally if the app is using some kind of framework (like Netbeans or Eclipse platform) to base their app on, it's quite hard to integrate JavaFX into 3rd party frameworks that aren't made for it. So it will be a gradual process with new stuff using JavaFX, and the old stuff slowly migrating to it. However as desktop becomes less and less important, less and less desktop only apps will be made. 
65k in NYC? Factor in cost of living. Or just write "negotiable" and see if they offer later
Probably before
I used [YourKit](http://www.yourkit.com/) when I was profiling Guice for the 2.0 release.
The correct method to use will depend on the definition of the trigram. For instance AAABAAA unambiguously contains AAA twice, but does AAAAAA contain AAA two or six times? It depends on how you count.
Where are you located? The Midwest/south?
Which non-Google libraries do you recommend?
Now that I'm on a laptop it doesn't look quite as bad (I saw this post while on my phone), but as /u/IAmASocketMan hinted at, you'd do well to look into state machines. That ugly block of indexOf() statements is going to cause you trouble on anything mildly complex.
~linear method: for i = 0 &lt; length-2: map i+(i+1)+(i+2) to a hashmap, the mapped value is the old value+1 or 1 if there is no old value find largest value and find that key High overhead, but at least it's not quadratic like a nested for.... 
Kevin, your [post a couple years ago](https://plus.google.com/113026104107031516488/posts/ZRdtjTL1MpM) about patches to Guava really lingered in my mind. In fact, even though I use Guava every day, I hadn't thought of the no-patches topic until I saw this AMA (edit: then I quickly remembered that post). So here's my question: if you don't accept patches and there are no non-Google-employee committers on any of these projects, what's the point of releasing them to the public? It's a lot of extra work, and you're not getting any community help this way. Why do you do it?
I'm assuming trigram is only three letters. I would creat a map&lt;string, integer&gt; then I would do a forloop for the length of the string. For (int I =0; I &lt; std.length - 3; I++) then I would get the three characters starting at i. Then check to see if that string is already in the map. If it is then increment the Integer. If it isn't then add it with integer = 1. . . You'll have a map with the three letter and how many times they appear. 
I'd recommend a request-based framework such as spring-mvc, JSF is kind of a dead technology, or at best very niche (read: used all over in Enterprise apps, but is that really a good thing?). The problem with JSF and it's component libraries, is they tend to not be very flexible if the customer asks something like..."hey I saw x website do y cool thing, could you do that in this UI you're writing for me?" JSF tries to be smarter than the programmer and abstract away a lot of the "cool" stuff which is usually related to custom javascript stuff from the developer when a customer asks for something like this. Considering meshing javascript and JSF **CAN** be done, but is not really recommended, it can lead to code smells, and head aches. JSF is also a completely different paradigm from ~~every other~~ **most** other web based frameworks out there. You need to start worrying about scoping your beans correctly, what should go where, and can kind of lead to spaghetti. Lastly, JSF tends to not play very nice with RESTful URLs requiring an external library such as PrettyFaces to get nice URLs, but this introduces another configuration file that needs to be maintained. That said, if you choose to use JSF due to it's (at least initial) simplicity, it's got a pretty major learning curve after learning the basics (can you tell I work with JSF at my current job, haha). Honestly, if it were me, I'd use a javascript single page framework for the front end such as Angular or something, and leave the Java side backend for RESTful calls with either spring-mvc or something like Jersey. This way you can leverage the thriving javascript community for helpful stuff like web page optimization, command line tools like grunt, etc. Finding help on the newer front end technologies on sites like stack overflow will be a lot easier than JSF, unless you get the almighty BalusC to reply to your questions. EDIT: correction
Vaadin is basically GWT, or...let's mesh Swing programming paradigm with a web framework, yay.
Pretend that i have no idea what platform you are targeting.
Desktop, I am using a JFrame but I could swich.
Single Page Webapp != A single page Website. Single Page Webapp drives its views through a javascript library (backbone, angular, ember, etc.) and uses Ajax to make calls to the service layer for database persistance, querying, etc. It's actually quite neat, allowing for: * Testable Views (yes, views, not logic behind views, like...expect to see 5 list items on this page, etc.) * Testable Business Logic within the javascript controllers * Very Responsive * Easily Mock Data without a backend to present mock ups that are interactive. Now, on to the JSF stuff. The one thing I will really stress is, finding help online for both JSF and Vaadin if you get stuck can be challenging. Sure, there are tons of sites showing you how to display a 'hello world' type page with some simple bean lookups. But, are there many resources about how to properly architect and design your Beans so you optimize what you store within the session, within the view, within the conversation scopes...not really. JSF is a really powerful framework, almost too powerful. In my opinion it leaves far too much up to the **developer** as to how to design something. It's very easy to badly program a JSF app, such as bloating the session scope with too much leading to memory issues, improper use of scope such as application scope on stateful fields leading to threading issues, etc. Also, the design just feels...weird, Oracle's idea was to COMPLETELY seperate the view from the controller. They're idea was to keep the view as simple as possible (maybe due to the flexibility of JSP to allow full on java code to be in the view?), and have your controller (scoped beans) maintain all of the logic. That's fine, but sometimes you'd rather do something as simple as validation on a form without requesting an entire redraw of the component backing that form (the component render chain is quite complex and very slow compared to more modern ajax solutions). If you do go down the JSF path, make sure to bookmark BalusC's webpage: [BalusC Page](http://balusc.blogspot.com/) Considering he wrote his own component, and helper JSF library (OmniFaces), he's a pretty good knowledge source of information. The one problem is his explanations can be a bit verbose so if you just want an answer to something simple, can take a bit of reading.
On paper, yes, i'd look at each group of 3 characters, moving my pointer(eyes) over one letter at a time, and increment my counter +1 for every time I see it. I just can't think of how to program that. I can do it with one letter but i'm not sure how to do it with 2 or more.
Sorry, Phoenix
You usually get more help from reddit on /r/javahelp and you will almost always get more help if you post what code you have already. Lets start from the beginning, do you have your java program taking and storing the input?
I just noticed Kevin described Guice as "Dagger's reflectiony predecessor", which certainly implies that, well, Dagger replaces Guice.
* How has the presence of Go affected the use of Java at Google? Obviously, older projects are unlikely to be ported from Java to Go (a lot of work for little benefit), but how does Google decide whether to use Java or Go for new development? * How would you compare/contrast your efforts which improve Java at the API level to Scala, Groovy, Xtend, which improve it at the language level? If Google were to pick one of these newer JVM languages, which one would it be? * Which tool does Google use for code quality analysis? SonarQube or something else?
The definition of a trigram is clear in computational linguistics: it's every sequence of three characters (or words). So, AAAAAA contains the trigram AAA four times. http://en.wikipedia.org/wiki/N-gram In the case of trigrams, you can simply go through a text by character index, and count the substrings [i, i + 3) until i + 3 is larger than the length of the text. If you want to be able to get the frequency of an n-gram of an arbitrary length, it's better to use a suffix array: http://en.wikipedia.org/wiki/Suffix_array Once you have constructed a suffix array, you can look up the frequency of an n-gram of an arbitrary length using a binary search.
It does exactly this - generates all the boilerplate in readable, debug-steppable java source.
My point was that a given application usually uses inclusive or exclusive trigrams and that should be taken into account before development (discounting the fact I evidently couldn't count =) I've also seen definitions used where ABABA has trigrams ABA and BAB each once because while characters may be reconsumed, they may not be reconsumed by the same trigram more than once. Stilted definitions are a reasonably good way of making students think about problems so they can't just lookup the answer.
Most java-projects are web-related and web without javascript is pretty much plain failure..
Protocol buffers are, in essence, an interface-definition-language - a language neutral wire format specification that has compilers to create custom language-specific APIs. It creates complex builders that are suitable for complex data you need to serialize over the wire. AutoValue creates small value types that you need in a variety of internal use-cases, like "pairs" and "tuples" - complex return values, etc. These may be tossed into lists and sorted, etc., so AutoValue does all the boilerplate of high-quality hash-code implementation, constructor implementation with rote assignments, toString, equals(), etc. These are things that one would have to write one's self, and it's a pain the ass, especially as the property count grows. 
*My point was that a given application usually uses inclusive or exclusive trigrams* Right, I wanted to point out that n-grams are clearly defined, so it cannot depend on the 'definition of an n-gram' ;). n-grams, and by extension trigrams, are a clearly defined notion. Every contiguous sequence of n characters (or words) is an n-gram. Regardless your application, there are always two trigrams *ABA* in *ABABA*. It follows from the definition. So, your application would be: from the multi-set of n-grams, I want the sub-multi-set of n-grams that are not self-overlapping. Which, I agree, is a fun exercise.
A [Trie](http://en.wikipedia.org/wiki/Trie) can help you.
AutoValue uses annotation processors precisely to avoid this sort of obfuscation. You want to know what it generated? It's in your generated-sources output directory.
Could you guys consider creating a Guava lib. for Scala? Quite of few of us ex-Java guys have grown to know and love Guava, but it feels very limiting having a library which is limited to Java-only language features (even with the potential addition of Java 8 features).
Yes please!
I really don't see them as competitors. First of all, Dagger is a collaborative work by Square and Google. Second, Dagger is designed with mobile (specifically, Android) constraints in mind. It's very heavily statically typed at the cost of more manual work to perform the injection. It also has a lot of very nice features that are relevant for mobile only (mock modules for networking, GPS, etc...). These advantages come at the expense of assisted injection, which I find invaluable in Guice ([here is an example of what I mean](http://beust.com/weblog/2012/08/21/advanced-dependency-injection-with-guice/)). Bottom line: for Android, Dagger. For everything else, Guice. 
I would choose the Oracle tutorials over any book.
Why is this being downvoted? 
Or at variable names?
what is your use case for Jimfs?
AutoValue seems interesting, but a maven plugin? :x I think I'll stick with actual (as in non-magical) code-generation instead. Besides, I like having chained MyClass.create().withX(1).withY(2).etc() stuff rather than having to decide on the constructor order up-front and having obj.copyWithX(3) later on. What was that about JDK 9 though? Are value types being planned as an actual feature for Java 9? 
What are your preferred books about Java?
Google adsense can't be used with software applications, with the exception of Admob for mobile apps. They must be embedded on a website. I'm not aware of any high-profile desktop ad networks similar to adsense. Source: https://support.google.com/adsense/answer/48182 
RBAC?
Any major changes to be aware of? Also, is there any built-in support for authentication and authorisation of users?
Reflection used to be painfully slow on Android devices, and Dagger was an attempt to remove the reflection from Guice, and replace it with static types, like you said. This was the biggest reason the projects deviated, I think. And crazybob needed to cut his teeth on another fun project. 
How to become a commiter in one of these projects? Is it just about making lots of contributions/participating in mailing discussions or there are other (better) paths to get this title?
Great, although I can't find anything more specific in any of the other documentation? Don't get me wrong, they've provided plenty enough to implement it, but I'd expect something is already implemented.
Do you use Java or one of the Java languages to make your life easier?
At Square we use Dagger in all of our Android apps, and Guice in all of our web services.
What's the difference between actual and non-magical code generation?
They might not be getting help from the community, but I think they are definitely helping the community
a lot of people seem to see anything that a Maven plugin does as "magic" even though their IDE has a plugin that is doing the exact same thing (and often it's far easier to read the source to the Maven plugin to see how it works)
The Jackson library (which you might know mostly as a JSON serializer/deserializer) can also work with YAML with some plugins. Very simple
because it's not a question, off-topic, and not funny
How hard do you find it to maintain and balance the internal vs external pieces of Guava and the other libraries? Is the same codebase used for internal Guava, or does code that is deemed worthy of releasing have to be ported to the open-source tree?
Ayup, using it now. Loving it.
Does your team only specialise in Java or have you worked on useful modules in other languages. 
This is a ~~repost~~ [crosspost](http://www.reddit.com/r/programming/comments/1y5tmu/why_how_i_write_java/) from /r/programming, with a discussion (to which this article links BTW).
lol, thanks for the downvote on something you disagree with me over, not necessarily something I'm wrong about. Also, thanks for jumping to conclusions, I've used JSF 1.2, and 2.0+, which is another bone I have to pick with Oracle. Really annoying that people started calling JSF 1.2 "JSF 2", so when you're looking for help on JSF 2.0, you start getting really old articles based around JSF 1.2. The reason it tops surveys is due to Corporate development. Corporate approves JavaEE as standard, JSF is the standard web framework within EE, therefore it is the most used. This is not necessarily a good thing, it just means it's used (and used badly) over many applications. Given the fact that JSF development is not exactly trivial, and new developers are usually given simple UI pieces, JSF leads to technological debt over release iterations due to differing levels of skill being used within the same application. Unless the application is EXTREMELY well documented, and new developers are hand held through the entire process, code smells can easily slip through cracks within JSF, even with code review. You have to agree with me component based frameworks are the exception to the request framework rule. Yes, .NET has their component library, but current gen development, and future development efforts have been moving away from component based in favor of request based frameworks due to them tying your development efforts down to their own tag libraries rather than using perfectly capable and simpler HTML, also for the fact that JSF introduces state within the HTTP protocol, a stateless protocol, as mentioned later within a linked article, a flawed design from initial conception. As for "Your holy Angular", first of all, I don't even develop in Angular for my job, yes it's something that interests me on the side, but it's not what brings home the bacon. Does Angular have it's problems? Of course it does, I never stated that if you use Angular "All your development worries will be solved!" I actually agree with you that Angular can have a bit of a learning curve as well, especially with the way it handles scoping of objects between views, etc. but at least learning would be put towards the way the web is moving, not towards something the web is moving away from. Plus, with the amount of frameworks out there for single page webapps, if Angular doesn't fit your fancy, choose a different one, like to write your own framework? try backbone, want a convention over configuration approach? look into Ember, etc. The one thing Angular has going for it over all the rest is it's backed by Google, which means to me that it will be around for a while. I am simply recommending someone coming into the Java web scene avoid JSF like the plague. Sure, it gets the job done, and can (initially) provide a quick and simple UI. But, why not put those learning efforts towards learning something like Spring Web MVC, which lends itself much better to separation of concerns, has DI container built into it (which! if you want to, plays nicely with JSF), rather than relying on something like Guice, or another third party JSR-330 implementation for your DI container. With Spring as well, at least you're not dealing with EJBs, something that is also ridiculously over architected, and confusing to someone just coming into learning a new technology. Lastly, even [ThoughtWorks, who has teamed up with Martin Fowler](http://en.wikipedia.org/wiki/JavaServer_Faces#Criticism), yes, of gang of four fame, recommends against JSF. EDIT: Spring wording correction. EDIT 2: Response to the survey point made.
There are non-Google-employee patches, but they are extremely rare. Proof is in the authors file. Googlers don't get their names in the authors file, but external committers do. It just so happens that everyone who has committed to Guava now works at Google.
It's a bit of a silly argument if you ask me. If you choose HTML and JavaScript your are "locked" to that? Sometimes you just have to use things. How often would you normally swap out your framework, or database or programming language got that matter? That said, JSF components are often just the connection between HTML and the server. It's just a tool to organise your HTML fragments. You of course still work with HTML, JavaScript and CSS. Just like classes only encapsulate Java methods and statements, components only encapsulated HTML. JSF backing beans are supposed to call into clean services and not contain the logic themselves. These services can be EJB beans or perhaps JAX-RS resources. You'll use them pretty much the same way as a completely external UI would use them. So you can have JSF backing beans as one client of your services and an iPhone of Android app as another client. Personally I think that with a reasonably well designed app there is far less locking in than what you make it appear to be.
I remember this black belt site too. It wasn't a demo, but a real live site by a Belgium team of developers. The idea was great; you had lots of exams that you could try to pass and thus earn belts. The community could contribute questions and even complete exams. This would give you credit needed for taking the exams. You could also just buy credits if you just wanted to do exams. It was a pretty neat site, but after they switched to Vaadin it became a rather horrible place and they were dead within a year or two. Since it was the biggest public site using Vaadin it became known a bit as the poster child for Vaadin.
With non-magical code generation you see where the "spec" goes in and where the generated code comes out and everything else is abstracted away and properly isolated from the rest of your code/project. Example #1: Drawing a GUI in a GUI-builder like VisualStudio or WindowBuilder for Eclipse is magical. You put some shapes onto some other shapes and the IDE does .. well *something*, and if you're lucky, it all works in the end. Example #2: Generating .hashCode() in Eclipse is not magical, because the input is a source file that is independent of Eclipse and the output is again source code independent of Eclipse (albeit in the same file as the input). "Independent" in this context means you don't need Eclipse to open/read it, syntax-check it, run it, debug it and even maintain/modify it in the future. The crucial difference being that with the non-magical version, if something were to ever go wrong, you'd know who to blame. If the generated .hashCode() method ever fails, but the rest of the class works fine, you'd know Eclipse messed up. If your class failed to compile to begin with, then the errors in the generated .hashCode() are your fault. Should Eclipse ever mess up .hashCode() for whatever reason, you can turn to other tools for generating the lines you need, or even resort to writing them yourself .. because the (generated) code is/was *independent* of Eclipse anyways. With WindowBuilder on the other hand, should something ever fail to compile, you're .. well, [SOL](http://www.urbandictionary.com/define.php?term=S.O.L.). If you can't manage to find help online, your only other options are to either hire the original devs or start praying. You can't really draw just that one part of the GUI that doesn't work in WindowBuilder somewhere else. Worse yet, if you're having a really bad day, WindowBuilder might in fact even mess up other parts of the code, or of its own configuration/property files, unrelated to the parts of the changes you made, because in order for WindowBuilder to work its magic, it needs to actually be so deeply embedded and ingrained into every part of your (Eclipse) project. And let's not forget about trying to merge changes/conflicts in one of those internal configuration files.. Having said all this, let me add that WindowBuilder is *awesome*. I have not had any problems with it so far, but I have had enough problems with other GUI builders that followed the same paradigm/principle. My criticism here is not specifically of WindowBuilder or of AutoValue, but of the underlying principle. I'd much rather prefer an *external*/standalone tool that would allow me to generate my GUIs and value types, to one that was integrated in Eclipse, even if that meant copy-pasting the generated code into the Eclipse project manually (with all that that entails, like bindings, etc.). Oh, and let me add one more thing, what I said about WindowBuilder does not apply to Maven. Maven is the opposite of awesome, i.e. it's horrid, *absolutely horrid*, (and arcane). What I like(d) most about Java is/was that unlike with other languages (an especially glaring example of this being the Linux bash), when you copy-pasted bits of code from web pages, you could actually understand what they were doing. Thanks to Maven, ~~we're~~ I'm now back again to copy-pasting bits I *don't* understand.
True, but it's not 2001 anymore. We have close to one hundred Java frameworks now, from famous ones like Java EE and Spring, to obscure ones like Simple! and Micro. The Micro guy was also totally convinced all frameworks sucked and his one was better and simpler. But have you ever heard anything about Micro again? Exactly! Java EE sucked in 2001, but it's pretty neat now. It's also really extensible. Why not take advantage of one of its many extension points (CDI extensions, JCA, JASPIC, ...) and build on that?
You should make the Rampart library and have it randomly output quotes regarding Rampart from that AMA to the log.
Wait, last time I was doing jar/war packaging (long ago) it was a massive annoyance, exactly because of packaging deps within it. Did something change?
Seconded. I literally taught myself Java using (mostly) the Tutorial. Granted, at the time (pre-2000) there were hardly any Java books on the market.
What do you use instead? My main experience is comparing jar/war to Python virtualenv.
MigLayout has been on my list of things to try for ages. I rarely get the chance to do GUI stuff anymore, though. Thankfully, honestly. Although my toy projects with interfaces were fun 
Whether you like JSF or not, you stated that JSF is dead which IMHO is factually wrong. 2.2 just came out, PrimeFaces, OmniFaces and RichFaces just released new versions and the mojarra tracker and svn repo is very active. Maybe it's dead to you, but clearly not to the community at large. That's the reason for the down vote, not the general disagreement.
Even my small projects use slf4j. Starts with console output, then it's trivial to switch to file/etc if the need arises. 
Have they fixed the issue with log4j2 preventing jvm termination yet? That's the only reason I haven't switched to give it a try. 
I didn't say it was dead, I said it was basically dead, I even stated it's being used across most corporate development efforts, due to it being the EE standard. Yes, it still has releases, but most of the releases have come from third party development efforts, not Oracle themself. And it's not dead to me at all, it's the beast I live with daily, why I try to get people to avoid it! ~~Also, I don't consider [nearly a year since release](http://en.wikipedia.org/wiki/JavaServer_Faces#JSF_versions) "just came out".~~ Edit: Retracted as this is a spec release, not actual implementation release as stated below.
https://code.google.com/p/guava-libraries/wiki/FriendsOfGuava has a few. I want to especially call out Joda-Time and ICU4J. To try to accomplish the things they do any other way borders on negligent behavior. For asking that question I was tempted to edit YOUR libraries out of the page. :-)
http://www.mkyong.com/featured/top-5-free-java-ebooks/ Thinking in Java is supposed to be decent... Aren't there codecademy ones too?
You'll be fine with JDK 7. closures won't hit mainstream in java for a year probably...
In general learning the Stax api is a great investment for Java xml work.
Testing, mostly. It should be considerably faster than a real file system in general. It can also be used to emulate a different platform for testing; for example, testing with a file system that acts (to some extent at least) like Windows (i.e. NTFS) on a Linux system. It can also be used to test how things work when certain file system features (e.g. symlinks) aren't supported on a platform or, say, what happens if you run out of disk space. I can also see some other potential use cases for it, but I really have no idea if they're something that anyone will ever actually want to use it for. Jimfs was initially a personal project for me, to help me learn the java.nio.file APIs and about file systems in general more deeply. And because it was just interesting to do. Alternative file system implementations (including in-memory) were one of the promising things about having an abstract file system API in Java 7, but so far I hadn't found any full-featured in-memory implementations, so I ended up putting more time into it.
I don't use anything like that, I meant that packaging jars/wars is not something that's part of my tasks and hasn't been for a long while.
&gt; Does Google use Java for any non-server, internal applications or utilities? Perhaps, even desktop apps for internal use. Or, is Java basically only used for server apps and Android? Essentially all of Google's internal apps *are* either server-driven webapps -- many of which are written in Java on the server side, and often in GWT on the client side -- or command-line tools, which frequently redirect to servers, many of which are written in Java. The only "desktop apps" I really use on a day-to-day basis are Eclipse and Chrome. In other words -- you say "only server apps and Android" as if we do anything else. ;)
heres a pretty good one - http://programmingbydoing.com/
1- I'm 23. 3- You're almost certainly writing code that's more complex than it ought to be. (And I'd say that learning that was the basis for my "intermediate-to-expert" transition you mention in 2.) 4- Yeah, I'd say Java is my favorite. Really, I only program in Java and Haskell. 6- I'm not sure "stay current" is the phrasing I'd use -- I follow r/programming to keep myself entertained, I guess? 7- Send your resume places? "Connections" aren't that much of a thing. (Open-source contributions are probably the best thing, though.) 8- The [Google Guava G+ page](https://plus.google.com/+googleguava) ;)
Thanks for the compliment -- most people will never know how much effort it takes to make something "succinct!" :-) We are always expanding Guava (if slowly). I should point out that we have never used existing libraries or any other external resource as "checklists" of features to implement. We depend on your feature requests, which we mercilessly evaluate for their level of utility and of *broad* applicability. Many merely-good method ideas died to bring us this class's compact API...
I've been using GWT to develop some internal, and external webapps. It's pretty awesome to use. Best part is you don't need to worry about cross browser implementation. If you have a Java backend, integrating with GWT is extremely simple. You create an asyncronus RPC service, and can pass objects back and forth. The documentation is also very good. 
Well, that's a start. Thing is: you will need three JOptionPane(s), one for each of the three questions. And the JOptionPanes should be of type showInputDialog. Also you don't need the Scanner. The input is retrieved directly from the JOptionPane. Since JOptionPane only returns Strings, you need to convert the value for the minutes (to int) and for the dataVolume (to double) - here the methods Integer.parseInt() and Double.parseDouble() will help you. For the Package selection, there are several options. One is similar to the one presented on the Oracle documentation for JOptionPane: Show a dialog asking the user to select a String: Object[] possibleValues = { "First", "Second", "Third" }; Object selectedValue = JOptionPane.showInputDialog(null, "Choose one", "Input", JOptionPane.INFORMATION_MESSAGE, null, possibleValues, possibleValues[0]); The other is to simply ask for a String, truncate that string to the first letter only (subString) and convert it to uppercase (toUpperCase). So, for the input part you could have code like this: JOptionPane.showMessageDialog(null, "Welcome to Homework"); // Ask the user for the data Package do { userInput = JOptionPane.showInputDialog(null, "Which telephone package do you have(A,B,C)", "Select Package"); dataPackage = userInput.substring(0,1).toUpperCase(); } while (!("ABC".contains(dataPackage))); // Ask the User for the minutes userInput = JOptionPane.showInputDialog("enter how many minutes you used"); int minutesUsed = Integer.parseInt(userInput); // Ask the User for the Data Volume userInput = JOptionPane.showInputDialog("enter how many MB Data you have used"); double dataUsed = Double.parseDouble(userInput); From here, you have: + a single character uppercase String **dataPackage** which describes the package (A, B, or C) + an int value **minutesUsed** for the used minutes + a double value **dataUsed** for the Data volume used Now you need to branch off depending on the data package (A, B, C) - which will need a sequence of **if...else** statements. Inside these statements you need to calculate the total as follows: + take the base rate for the package + add the minutes over limit times the price per minute + add the volume over limit times the price per MB and you have the total cost which you can then display in a nother JOptionPane.
Two weeks are up again, eh? http://www.reddit.com/wiki/faq#wiki_what_constitutes_spam.3F
You should post this over to [/r/javahelp](http://www.reddit.com/r/javahelp) instead of here. You'll probably get a better response.
Maybe my teammates will have something to say, but the general and honest answer is that we _don't,_ much, because we're Java library geeks. Sorry to disappoint :-)
Thanks very much!
And to your specific examples: * compression - no plans * math - no plans beyond the cool stuff you already see [here](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/package-summary.html)! * statistics - we're working on some basic but useful stats calculation stuff, but I'm not sure if it will make 17.0. * networks - meaning? 
Just adding to what Louis said: The one desktop utility that commonly gets run is the build system command line interface, which is written in Java.
&gt; Is Dagger the direction Google intends to go for future new projects? Where the Dagger feature set is sufficient, yes. But where it is not, no. :) &gt; Guice 4.0 is in beta, but its changes over 3.0 don't seem to be documented. Is that because you all are ambivalent about Guice's future? Guice is pretty stable solid - we have been running at HEAD for years so the slow-down reflects the long-tail of things we simply can't prioritize to get to. We bumped the version to 4 because we had some API subtleties that we altered, and wanted to mark that. Guice is being worked on, but it is quite rich and developed, and there really aren't a lot of new features in the core that it needs. Most guice-related development is on higher-level frameworks above the core dependency injection framework, and we may open-source some of them. We definitely will be working over the next two years to ensure that, where possible, these higher level frameworks can benefit from Dagger. To give context: Dagger is a joint effort by Square, Google, some individual contributors from other places such as Nextflix, and is descended conceptually from Guice - specifically from MiniGuice. It addresses some key challenges our users faced with Guice. From Square’s side (/u/swankjesse can clarify this) it was the need to get high-performance, low-startup dependency injection on Android. From our side, it was that and the desire to trim the API weight of dependency injection, to reduce the user confusion that comes from reflection and bytecode generation in stack traces and debugging environments, and to get early validation of your graph’s wiring. Dagger is a substantial direction shift for Google, and we are investing time and resources in it. Guice will always have a superset of features compared to Dagger, though we do have projects using Dagger on the server and in stand-alone java apps. But Dagger is not as evolved in terms of the surrounding "scaffolding" code (servlet support, etc.) as Guice, and won’t be for quite some time. Additionally, some teams will need or want some advanced Guice features that will never make it in to Dagger. Those teams may well continue to use Guice until there is a compelling reason for them to switch.
1. I'm 28 2. I wrote my first line of Java code the first day of freshman year of college (majored in CS). Before that, I hacked my way around mIRC scripting believe it or not. When I look at my colleagues, I'm still not sure that I'm an expert. 3. Don't be afraid to experiment. For the most part, you can't break anything, so always keep tinkering. 4. If I owned a car, my license plate would be JAVA4EVER. 5. vim 6. I honestly don't tinker with new languages as much as I probably should. 7. Contributing to open source projects, building Android apps, etc are great ways to get noticed (and make great bullet points on your resume). 8. I post lots of random (maybe interesting?) stuff on my [G+ page](http://www.google.com/+KurtAlfredKluever)
We have indeed kept a very low profile, conference-wise. I believe the only two we've been at in the last two years were Devoxx France and QCON SF. Why? Part of it is that we can't get personally interested in selling/evangelizing Guava. It feels like time we could have spent actually making it better or adding more functionality to it. In a sense, having it "out there" where people who are "in the know" *can* find it and use it accomplishes 95% of any goals we could ever have for it, so it's hard to find the motivation to spend time spreading the word. That said, there's plenty of room for us to get out there a little more without it overtaking our schedules. Which, in your opinions redditors, are the biggest and most important conferences to be at? I know about JavaOne and Devoxx.
Have you been using maven, ivy or gradle to build these jar/wars? They have dependency management tools to take care of packaging third party dependencies.
"can't get personally interested in selling/evangelizing", I said -- yet, look at this, here we are on reddit. :-) Maybe there is hope.
I'm the primary owner of the hashing stuff, so I like to think that the hashing APIs are kind of nice too ;-) And yes, bloom filters are a really cool, not-well-known topic. People often get a WAT? look on their face the first time they hear about BFs and you tell them that a BF has a "boolean containsMeMaybe(T object)" method. They can be immensely valuable to avoid expensive disk or network I/O. Re a shrinkable/growable consistent hash function: this is the first request I've seen for it, so I filed it [here](https://code.google.com/p/guava-libraries/issues/detail?id=1675). If you have a particular algorithm in mind, please update the bug. Thanks :-)
We do have Guice/Dagger migration/integration easing plans, including a Dagger-&gt;Guice module converter, and are considering different ways of tweaking Guice or allowing supplementary annotation processors to better support reusable library developers to have a very low burden to support JSR-330 DI in Dagger and/or Guice, where feasible. Ranging farther (and more speculatively) is the impact of Dagger 2. Dagger 2 is even less of a generic run-time (the Injector/ObjectGraph "locus of entry to the graph" will be _your_ strongly typed interface) and is closer to the "auto-generated manual injection" principle we were going for... the "manual D-I you would have written yourself, but letting robots write it for you" approach. I mention this because there are as yet undiscovered but interesting ways in which one might use Dagger 2 generated code with Guice in interesting crossovers (though 90% of the time you shouldn't need to). But, fear not, you should have a smaller integration burden for leaf nodes, even in the shorter term.
If I were my boss, I would be Jeremy Manson (of Java Memory Model renown), which would be awesome. Only then I wouldn't be my own boss anymore. But I would have kevinb9n working for me... okay, I've confused myself now. In a real sense, we are each of us "our own boss" -- just subject to the periodic performance review of our peers and manager. I can sort of "do whatever I want", but my choices could ultimately lead to either a promotion or, on the other end... very uncomfortable conversations with Jeremy. Fortunately I pretty much agree with the basic yardsticks by which we judge each other. Plus I essentially created my position -- literally wrote my own job description and shopped it around to directors and VPs until I made the sale. Because of these factors, I always feel like I'm in the driver's seat, which is an absolutely amazing thing to have in a job. 
Is static type the best term or I like, "compile time type checks". For example, you can by pass static type checks with Java?
My day-to-day job is to write and comment on documents all day long. &lt;sigh&gt; :-) Documents with titles like "Google Java Deprecation Policy 3.0" or "So you want to stamp out a Java coding anti-pattern" or "How to change a lot of code in google3 [our code depot] at once" or "Guava, JDK Versions, and Pain". I don't get to code so much anymore, but every now and then I do rewrite some javadoc!
[AutoFactory](https://github.com/google/auto/tree/master/factory) replaces assisted injection and is separate from the DI framework. We think Dagger will be a better choice than Guice for more than just Android apps. The code-generated approach carries many important advantages that I'm sure Christian or Greg will elaborate when their window of allowed posting comes up again. &lt;sigh&gt;
Sort answer: there’s a single codebase. Guava is a subset of the common libraries that we own. We have a [moe-java](https://code.google.com/p/moe-java/) script that one of us (on a rotating basis) runs every work day. It scrubs and then migrates our open-sourced changes from the internal codebase to the external git repo. The hardest part of the whole process is that we need to make sure that Guava can still be built with JDK6 while the rest of Google (minus Android apps) is on JDK7. The Guava JDK5 backport further complicates the matters. Regarding the life of an API, it basically goes like this: * 1) If it’s a common-enough piece of code that we think many users (Googlers, and eventually open source users) will want to use, we take ownership of it. It gets checked into a “labs” package (com.google.common.labs.foo). * 2) We watch adoption of the API over time. If many people seem to like it, we study usages and put it through rigorous API review. It then gets moved into it’s (hopefully) final home (com.google.common.foo). At this point, it’s still “google internal” and denoted by a special annotation (@GoogleInternal). It is not yet part of Guava. * 3) Basically #2 all over again, but instead of moving it again, we just remove the @GoogleInternal annotation and mark it @Beta. At this point, it becomes “part of Guava”. * 4) Basically #2 all over again, but instead of removing @GoogleInternal, we remove @Beta. At this point, it becomes API frozen. Some more information about how the @Beta annotation can be found [here](https://code.google.com/p/guava-libraries/wiki/PhilosophyExplained#Iteration).
I agree that static isn't as descriptive as it could be, but it is well entrenched. If you broadly defined "testing" as activities done to gain confidence that your software does what it should, then it might make sense to use the term "compiler tests" to describe whatever verification can be done at compile time (statically). In addition to static type checking, this may also include other forms of static analysis such as FindBugs and PMD. 
Er, crazybob didn't start dagger; that was /u/swankjesse (with Bob's involvement, sure). The first time Bob said to me "we should do this with code generation instead of reflection" was about 2 weeks after we released Guice 1.0. :-) We always thought it would be a good way to go; we just didn't really have the means to pursue it at the time.
This is very much a question on our minds -- on my mind, in specific. What we have so far internally -- which I hope to dump to GitHub in the not-too-distant future, without making any support or compatibility guarantees -- is a fork which is intended to sit in an “intermediate stage”, helping people to migrate from Guava to JDK8 features, where those overlap. For example, our Function extends their Function, our collection implementations have efficient stream() implementations, our Joiner (which we still think is much nicer than JDK8’s StringJoiner) has a Collector view, we have tests for all the new JDK8 collection methods, etc. That fork is passing tests. In an ideal world, we could put together a version of Guava that will work in both JDK7 and JDK8. The main obstacle to that is common.reflect, since many of the reflective interfaces were changed significantly to allow type annotations. Most of Guava’s other packages don’t depend on reflect, but most of our tests do. In the long term, we will probably want a version of Guava which depends on JDK8, and which has removed those features which overlap between 7 and 8. That’s a fair ways off, though. One other thing worth mentioning is that as we open-source tools like Refaster, we hope to be able to release automatic migration kits to help with the conversion, and to smooth out any bumps.
"If Dagger evolved from Guice, why is there still Guice? Checkmate injectionists!" But seriously, Dagger only replaces Guice when you don't need Guice's advanced features and you value the code generated approach enough to prefer the less mature product (many Googlers do).
&gt; Also which java build tool are Googler's using (maven, ivy, sbt, gradle, ant)? None of the above -- we have our own build infrastructure, built to Google scale. The [Google Engineering Tools blog](http://google-engtools.blogspot.com/2011/05/welcome-to-google-engineering-tools.html) has some detail here, but probably the main point is that all development is done at head and all builds are done from source.
Guava-users are lucky and get to see only the "crème de la crème" of the libraries that we maintain. There are tons of ugly legacy library warts that we own and need to stamp out. I do a lot of this work. It involves changing thousands of lines of code across hundreds of different projects on a daily basis. We have lots of tools that make this easier (a way to run all tests that are affected by a given change, a way to shard large changes into smaller changes, etc). That being said, it's still a lot of work. A lot of my time also goes into code reviews, emails, API designs, docs and feedback on docs (like the ones Kevin mentioned), planning and grading goals for our team, etc.
I'm not sure what you mean about a maven plugin. It should work with no need of a plugin. Value types as a JDK feature are not simple; I would be surprised if they could make JDK 9, but I definitely think they should be actively explored. 
* Project language decisions at Google are made largely based on factors like available libraries and developer expertise (and social pressure to adopt particular languages, which differs based on what part of the company you are in). Go is gaining significant ground at Google, but mostly not in places where Java is used. It replaces Python, which is not usually a great choice for large scale development, or it replaces C++, which is not usually a great choice for simple projects. If programmers are familiar with or already using Java, they usually stick with it. * There are a lot of significant challenges with supporting languages at Google. You have a huge user base, tons of internal infrastructure that needs to be interoperable with it, the need for a style guide, a process to enforce the style guide, static analysis, the need to make sure all of the code keeps compiling when the language is upgraded, the need to be teachable to new grads and old hands alike, the need for a comprehensive set of existing libraries, and so on. As a result, we try to pick relatively mature languages, and only those that provide a compelling reason to use them. * Google will probably never stop using Java, since we have a huge investment in it. Even speaking purely hypothetically, the use case for, say, Scala, is different from the use case for, say, Groovy, so you can't really talk about picking one or the other. If pressed, my suspicion is that we would try to provide a language with roughly the same value proposition as Java, which means we would either adopt Scala, or drop JVM languages altogether in favor of something like Go. * Google builds its own tools for code quality analysis. Basically, nothing else makes sense given our development environment, at our scale. We provide them open-source, when we can. See, for example, [Error Prone](https://code.google.com/p/error-prone/).
The term "magical" as applied to technological innovations is so subjective as to be practically without meaning. As it's used, it tends to mean "I haven't acquired an understanding of it yet" (insert Arthur C. Clarke reference). That's the sort of *hopelessly* subjective form. I try to use it to mean (well, I try *not* to use it, but when I do) something like "It is not easily integrated into users' mental models of the world, given the existing state of the art we can expect them to be familiar with." So, by that yardstick, we designed AutoValue to be the **least magical** of all proper solutions to the value type problem. 1. You leave a class abstract. 2. You add one annotation. 3. You now have a generated class; you can read it and see exactly what it does. That's really all there is to it (assuming your build is set up properly, of course). [These slides](https://docs.google.com/presentation/d/14u_h-lMn7f1rXE1nDiLX0azS3IkgjGl5uxp5jGJ75RE/edit) walk through various alternatives to AutoValue and why we didn't like them.
`Map` was claimed by `java.util.Map`.
Gin &amp; Guice. Which one of you is the Snoop fan?
&gt; Dagger is designed with mobile (specifically, Android) constraints in mind. True, but Dagger 2.x is designed with a combination of Android and server-side performance considerations (turns out, a lot of classLoader.load(...) statements run over and over is expensive at high QPS). We fixed a LOT of server-side performance issues in Dagger 1.x, but the design of 2.x evolved under the heavy pressure of lessons-learned from a server-side team. We really hope we're going to hit best of both worlds there. What is still being worked out is how to best help large-scale apps with complex graphs manage their configuration information cleanly (because tortured nests of modules are no fun for anyone). 
Why not just do this in javascript and use google charts to show the data.
approximately how many of those common pieces of codes does your team have ownership of currently? being the "common java library team" at a large company sounds fascinating and awesome
2) Why not Iterables.removeIf(cache.asMap().keySet(), keyPredicate)? A remove from the asMap is treated equivalently to an invalidate. Generally speaking, it's usually better to provide lots of little pieces that can be stuck together to do things than to provide specific methods for every little thing -- or else we'd need to add cache.invalidateValues, and lots more things that are better done by sticking pieces together.
My favorites are Effective Java, Java Puzzlers, and Java Concurrency in Practice. I also like the Head First book on design patterns (and they have a Java book which may or may not be good).
I wish i could, but I wanted to show my son how the code is laid out, how it can then be viewed in an applet viewer and also how it can be viewed online. I wish it didn't have to be so specific, but due to certain circumstances, I want to show him this way, as it will be something that he will thoroughly enjoy and would cheer him up.
Thanks for prompting me to reread that post, which I hadn't done in a while. It touched off a *small* firestorm at the time, partly due to our actual stance and partly because of the suboptimal way I phrased things. Basically, it was a very easy post to misinterpret in many ways (so easy to "misinterpret" that the fault has to be mine). And -- and I mean this in the friendliest way possible -- I see a couple of those misinterpretations here in your comment. "you don't accept patches" -- as a generalization, this isn't true. If there's a valuable feature we're missing, and you/others argue successfully for it, and we want it in Guava, and we all sort out the difficult design issues, and it's not one of the many things we already implemented internally, and it actually has a nontrivial implementation, etc. -- then your saying "and I can do this for you" would be greatly appreciated! You can just see how that's a rare confluence of circumstances. In *practice*, you may say that's equivalent to our not accepting patches, but I think it would give a very wrong impression to just say "Guava doesn't accept patches." Second, your "what's the point" question shows that even after reading the post you're continuing to think of contributing actual source code as the main way to help a project. I guess it's hard to believe that mere high-quality issue reports and high-quality, insightful *comments* on an issue report could constitute actual help, but they really do. Clear examples and clear arguments help us make good decisions. The point of my post was to try to convey that THE hard work of Guava is the "making good decisions" part, not the coding part. HTH?
We don't work on protobufs, but yes, protobufs are awesome and are probably the #1 used Java API (other than Guava) at Google. Some of the "day-to-day" stuff was already answered [here](http://www.reddit.com/r/java/comments/1y9e6t/ama_were_the_google_team_behind_guava_dagger/cfipenz). Another interesting fact: our team has 7 engineers, in 4 different offices, across 3 different time zones. This is an improvement from a year ago when it was 5 different offices and 2 different countries ;-) * NYC (New York City): me * PIT (Pittsburgh): beigetangerine, cgdecker * CHI (Chicago): gk5885 * MTV (Mountain View): christiangruber, LouisWasserman, kevinb9n But I think us east-coasters have it better since we get to sleep in a bit more than the MTV folks ;-)
Do a hashmap with counts as you iterate through the string. So... how many TLAs are there for memory purposes... about 6000, is that right? 26! / (3! x 23!) ? Yep, constant size, O(n). Not going to get much better.
Looks awesome. Very play esk with a java slant. And no SBT.
1. I'm 41 2. Hard to answer - I think it was when I realized that people were asking me questions on how to do things and I was giving reasonable answers without having to look up a lot of things, or at least fast pointers about where to find the information. No idea as to a timestamp on that state. 3 Don't over-engineer, don't over-use obscure features. Try to write the code that Future-You won't hate you for. 4. Java is one of my favorite languages - but mostly because it's the thing I can most quickly get things done in. I'm also a fan of Kotlin (it's very close to noop - a little short-lived experimental "improved java" language that some other googlers and I started to work on back in 2009). I like Clojure as well, and find it a really nice way to bridge pure-functional languages with the practicality of O-O language. Objective-C was my first serious language back on NeXTSTEP boxen in the early 90's, so I have a soft spot for that. 5. Eclipse - again, mostly the devil you know. I keep trying to work in IntelliJ and, while I like much about it, have yet to feel comfortable in it. I miss NeXTSTEP (no - XCode isn't the same...) 6. I'm a brand new redditor, so I'm still exploring. I've enjoyed [r/AnCat](http://www.reddit.com/r/AnCat) very much. 7. If you are referring to tech-work specifically, write code. Then write more code. Release toy apps, make them more interesting. Open-source your code, contribute to the libraries you use to open-source (BSD or apache, please... heh... let the flames begin...). But seriously, as math teachers would tell you in grade-school, "show your work." Also, if you're applying at Google, make sure you bone up on algorithms and data structures. 8. I'm on [Google+](https://plus.google.com/u/0/+ChristianGruber/posts). I'm also on Facebook but not particularly public. I used to have a [blog called GeekInASuit](http://www.geekinasuit.com) but haven't posted in a while. (My last post ws about how I suck at blogging). Likewise twitter @geekinasuit. I should probably post more. &lt;sigh&gt;
I'm quite fond of Haskell, though I don't do much of it these days. I have contributed a small amount of code in the Haskell core libraries, and I think the Great Language Shootout is still using some of my entries for Haskell.
We dislike the way lombok modifies your classes in-place, so that what's running in the VM is not seen anywhere in source code. My colleague Eamonn, who wrote the AutoValue processor, was particularly burned by this "magical" behavior of lombok in his past life at Sun/Oracle. We designed AutoValue to be the "least magical" solution to the value types problem possible until a language change should materialize -- but please see [this comment](http://www.reddit.com/r/java/comments/1y9e6t/ama_were_the_google_team_behind_guava_dagger/cfjdoes) to unpack what I mean by that! 
In 2011 I was simultaneously helping with Guava's [CacheBuilder](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/CacheBuilder.html) and implementing Android's [LruCache](http://developer.android.com/reference/android/util/LruCache.html). These two classes address the same problem in very different ways: CacheBuilder is composable and highly concurrent; LruCache is limited and lightweight.
I don't know what paintComponent is, I use public void paint(Graphics g). Could try that. 
Hi Christian, &gt; If it isn't solving your particular needs, please file issues on the auto project. Sure. You and I have already exchanged quite a few emails on the subject, so you already know where I stand :) For what it's worth, AutoFactory is a bit intimidating for people not familiar with the way Guice performs injection so I'm a bit reluctant introducing it to my work. Assisted injection is more palpable and more familiar. 
We have a goal of at least starting to open-source Refaster this quarter; we're just waiting on some final approvals. I swear, it's coming!
With the same caveats (I'm a libraries guy, and I could go on for a while, thanks to 20 years' hindsight), one of my personal favorite wishes... I wish that there were more emphasis on immutable collection types and on [declaration-site variance](http://confluence.jetbrains.com/display/Kotlin/Generics#Generics-Declarationsitevariance) to take advantage.
Most of our existence is on the server side, and Dart, while being potentially viable as a server-side language, is primarily expressed in the browser. So we don't get much chance to look at it. I like aspects of it, as there are things about Javascript that drive me nuts, but most of us just haven't had much web-app front-end development time, given our day-to-day priorities, so opportunities to really learn it and get a solid feel are sparse. 
My advice is start with the point class. I don't really understand what you are having troubles with. Do you have to make a GUI that shows and x,y plane? You won't get the answers here. We can only help you grasp the problem. Looking at the Java Doc you sent us, (these are the classes you have to make right? With these specific methods?). Then the Point class should take all of 5 mins as it only has a method. Triangle class should be fairly simple too. I think you might be over thinking the problem at hand. It seems fairly simple to me? Have any specific questions, I can try to clearify it with you. (I cannot tell you how to do the project or what you should or your way to go about answering said portions of the project). EDIT: Also stuff like this belongs in /r/learnprogramming and you should have a clear title. "HELPPP" is bad reddiquette. 
`Vector`, `Stack`, `WeakHashMap`, `Thread.stop`, `InputStream.skip` (use `skipFully`), methods that take a `Charset` as a *string*, `new BigDecimal(double)` (use `new BigDecimal(String)`, seriously), `String.trim()` (because I bet 1% of people who have used it even know which characters it does and does not trim). Who knows what `Integer i = Integer.getInteger("5");` does? (And *would* know even if my question wasn't making you suspicious? :-))
&gt; Clear examples This is key. Use-cases are crucial from open-source, as we have our own idiomatic environment and culture and development history at Google, and we may simply not have encountered the problem you are hoping to solve in/with our library. Helping us understand what you are really trying to get done helps us figure out if it could be done using existing Guava, if we have libraries internally we haven't open-sourced to do this and should consider it, or if the problem is simply not one we have because of our particularities internally. So please, file issues, give examples of bugs, traces, or desired usage sample code, etc. It's how we can most effectively figure out how to proceed. 
1- I'm 30. 2- Personally, I don't feel that it's easy to define "beginner vs. intermediate vs. expert programmer". As such, I don't know when these stages occurred or if I'd even call myself an "expert" programmer. There are some things I feel I'm strong at and other things that I have no clue about. That said, I think a big change for me came when I started internalizing ideas about loose coupling and testability (dependency injection) and reading and learning from open source code. 4- Yes. =) I'm a fan of a lot of the ideas in Kotlin, but I haven't spent as much time actually using it as I'd like. 5- IntelliJ IDEA! 7- Like the others have said, contributing to open source can be a good way to get noticed. Of course, you can't just go out and "contribute to open source". You have to find something that interests you and then figure out how you can contribute to it in a way that's useful to the project. I used to be an open source contributor to Guice and Guava, but did little in the way of code contributions. I mostly followed the mailing lists and issues and, once I had a better understanding of the projects, answered people's questions there and on StackOverflow and discussed issues. That's kind of how I ended up at Google. Edit: Just noticed that the formatting ignored the actual numbers I wrote and made it a list from 1 to 5.
Here are a few random things that come to mind as often missed by users: * `Multimaps.index()` and `Maps.uniqueIndex()` * That all ImmutableCollections have deterministic iteration order and a no-cost `asList()` view * That there's very little reason to do integer arithmetic on the values of a map yourself -- if `Multiset` doesn't fit the bill, `AtomicLongMap` probably does 
Wake up at 8, take the 8:30 bus into work with my wife (also a Google engineer). Check blogs, mostly [Mark Reads](http://markreads.net/reviews/). Browse StackOverflow. As for what I actually *do* during my day...that varies week by week. Lately I've done a lot of research on collecting all the worst [antipatterns](http://www.reddit.com/r/java/comments/1y9e6t/ama_were_the_google_team_behind_guava_dagger/cfjch6n) in Google code to automatically detect. That usually entails browsing through code, finding particularly awkward constructs, designing a pattern, and running that over the Google codebase to see how common a pattern it is. Relatedly, I do a fair amount of collaboration with the [Error Prone](https://code.google.com/p/error-prone/) folks, helping them to clean up the codebase for things we want to turn into outright errors, not just code review comments. Before that, I spent a lot of time writing and improving our refactoring tools, and before that I spent most of my time working on random library features and optimizations, like RangeMap or Ordering.leastOf. Like I said, it's varied week-by-week and month-by-month what I'm actually up to. I usually take the 5:00 bus home, though on Tuesdays and some Fridays I go do dance things after work. Bedtime is around 11, so 9 hours of sleep a night.
Our chief weapon is fear. Fear and surprise. ... our *two* chief weapons are fear, surprise, and ruthless efficiency... ... our ***three*** chief weapons are fear, surprise, ruthless efficiency, and an enormous fanatical devotion to the Bloch. I'll come in again...
They died. Slowly.
I wrote a bit about this above, but Dagger/Guice are used in a lot of CLIs, tools, etc. I just submitted initial code to move [moe-java](https://code.google.com/p/moe-java/) from manual DI/Static-variables to use Dagger. (It's not been synced yet as I haven't finished the transition) We use combinations of Guice/Dagger, AssistedInject/AutoFactory, and related tools in a variety of non-web, non-android services. Moe-java will be using a root graph for singletons, and a per-task/directive graph (scope) to roll up the appropriate objects needed to execute a given moe directive. That's largely a function of the current design than a fundamental need for a second graph layer, but still, it highlights using DI in a non-mobile, non-server context. That said, we use Dagger on android, and both Dagger and Guice on the server. 
&gt; Integer i = Integer.getInteger("5") What the hell!?!? There's no way I would have guessed or expected that (after &gt; 10 years of Java development) For the curious: (the first line of the java doc) Determines the integer value of the system property with the specified name. 
It is fascinating and awesome. It's the best job I've ever had, and I've had some really good jobs. Google perks aside, this is a fantastic bunch of people to work with. 
I'm sure every story is different but how did people on the team find their way into working on the internal libraries team? My recollection from when I interviewed there that the team you ended up on if you were hired was mostly a crapshoot for most people
I'm conversationally fluent in Objective-C though out of practice. I'm an increasing fan of Kotlin, and like Clojure quite a bit. I fondly remember a little pure lambda calculus implementation called Miranda which is, sadly, not open-source. I can do C# which means I always end up doing job interviews for C# folks, but I am so far out of date with it I should remove that from my official list of languages. I'm conversational in C/C++, have enjoyed learning Go. But we're a Java team. That's 90%+ of our lives. 
What is the best place to start contributing to these OSS libraries? I have experience in Java but haven't dealt with it in any OSS capacity. 
Size of the jar. Yes, this is a perennial. Here's the problem: there are as many ways to wish to split that jar as there are users. It simply does not happen that a project has a valid need for 50% of libraries A and B and 0% of C and D. If you are sensitive to binary size, then our breaking Guava into pieces would not save you from having to run ProGuard. You'd have to run it anyway. So what did the painstaking split gain you? What breaking into pieces would do, though, is introduce a new world of pain. In which library X that you depend on uses version 12.0 of base, primitives and io, while library Y needs version 15.0 of base and collect, etc., and you were using 14.0 yourself. The potential for mystifying interactions between skewed versions of all the little pieces of our library is extreme. To say nothing of all the micromanaging overhead that would pull us away from actually improving the libraries. TL;DR: Our saying "use ProGuard" is not a cop-out; it's simply the only thing that really works. (Of course, for this decision we are soundly convicted of crimes against humanity in the court of public twitter opinion, and probably always will be. Sigh.)
To use AutoValue/AutoFactory/Dagger/etc. you need only include the annotation processor dependency as an optional dependency in your project. Maven already auto-configures the classpath of javac to load the processors - no further integration is needed. For Eclipse integration, M2E can also automatically handle maven-managed classpaths with annotation processors, but you need to enable it in the maven preferences on your project. (Can't speak to other environments)
When engineers start at Google, they're asked for their top N teams they'd like to work on. Of course the team you're placed on depends on headcount for the team, location of the team, etc. I ended up on a C++ infrastructure team and did that for about 2 years until I *needed* to write some Java code. To satisfy my urge, I started 20%'ing for the Java Core Libraries team (mostly doing small cleanups here and there, occasionally contributing new classes). A year or so later, an additional headcount was allocated to the JCL team and I jumped at it. Haven't looked back since ;-)
Heeeeee. In 2010, I was an intern on another Java team at Google. (/u/gk5885 was there, too, actually.) About halfway through my internship, I discovered the libraries, and started 20%ing for them. This was when I started to learn what was actually involved in library development, because about 90% of my ideas were shot down. (Rightly so, in retrospect, and several of the survivors *ought* to have been shot down.) While most of my ideas were shot down, I was at least making a fair number of useful contributions, in code and on mailing lists. I came back for an internship with the libraries team in 2011, and continued working with the libraries through open source after leaving my internship. (In particular, I started the Guava wiki.) At that point, it was pretty clear that the libraries team wanted me full-time, and I wanted to be there full-time, so we made sure the recruiters set that up properly when I applied to start full-time out of college.
Great answer to an almost unfair question. Hopefully in the future you guys will be acquitted of all crimes against humanity charges!
BalusC is a great knowledge source indeed! OmniFaces btw is not just created by him, there are two main developers and a hand full of contributors.
I had some interest from one of the Google recruiters. What kind of things should I expect and if I was to come to Google with something interesting, would it help me?
What's the deepest thing you've learned about software engineering from working in Java specifically? Yash from the MOE team (formerly) here, hope you're all well.
I'm one of the OpenJDK core libraries developers mostly working in collections, streams and to a lesser extent concurrency (though I certainly pay attention to activity there). We do definitely pay attention to what is in Guava and have already cherry-picked some **small** bits inspired by Guava into the JDK. In Java 7 we introduced [StandarCharsets](http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html) which was the first addition inspired by Guava functionality. In Java 8 examples of small Guava inspired JDK additions include static hashCode methods added to the primitive types. Inspirations have frequently come from the Guava team either directly or indirectly. For Java 9 the most likely to be added will be utility functionality similar to Guava's primitives and math and packages. More importantly in Java 8 the design of Optional and the java.util.function functional interfaces we explicitly tried to both learn from what Guava did, learn from Guava what *not* to do and we tried to avoid be gratuitously different from existing Guava functionality. The goals of Guava are somewhat different than the JDK though and Guava is, by design, less general and not as conservative as the JDK. There's definitely a contingent of people who think we should just import Guava into the JDK libraries. This won't happen. Whatever imports there are from Guava into the JDK libraries there are will be very selective and extremely conservative. Some things like BiMap, Multimap, Multiset and collection views we are unlikely to implement for a couple of different varying reasons. These include; incomplete adherence to the whole contract of the base interface (semantic difference of Multimap.remove(key) being an example), lack of general utility, insufficient bang for buck (new Map default methods reduce value of Multimap for example), interface size, etc. Decisions about what to include are fluid and certainly change over time though we do try to decide fairly early in the JDK release cycle what we are going to include. This process is currently in process for Java 9. Arguments, bribes, threats welcome, core-libs-dev@openjdk.java.net Yes, I do use Guava in my personal projects. It is usually the 1st library I import. :-)
:) Hey Cedric. I should resurrect that email thread and figure out what is missing. I'm not sure how/why AutoFactory is more intimidating than AssistedInjection. AutoFactory literally just generates a factory impl for you, which you can bind(MyFactory.class).to(MyFactoryImpl.class) in one line - done. I think we need to beef up the documentation with examples of integrating in Guice and Dagger, but I"m trying to figure out how, aside from familiarity, AutoFactory could be more intimidating than assisted-injection. :/ Maybe I'm too close to the problem. 
Can you show or point to an example that shows what the code would look like before and after using Dagger?
Hey Yash. I'm in ur code, slicing it with Dagger. ;) The deepest thing I've learned from working in Java is to beware your own cleverness. I have written code I have hated myself for, because I wrote it in ways that were ever-so-clever at the time, and then were an opaque mess later. This isn't Java specific, but a lot of frameworks do crazy things to eliminate boilerplate, reduce the annoyances of Java, but it's a balance. Eliminating every last teeny piece of annoyance in Java may leave you (or your team-mates) unable to understand what you did. 
Thanks for asking us these fun questions -- people might almost think you're a plant. 1. I turn 40 this year! I'm excited. Every decade of my life has without fail been better than the one before and I see no reason that will change. Plus, age is helping me to seem more "mature", which impression the general experience of interacting with me doesn't strongly tend to engender. 2. The beginner doesn't know the rules. The intermediate knows the rules. The expert understands when to break the rules. 3. Nothing is more important than **reviewing each other's code**. Review it to death. That is how you learn. Mandatory code reviews are the religion at Google, and should be at every self-respecting engineering organization. Your stamp of approval on a code review (which we call a LGTM, for "Looks good to me") means that you stand by its quality just as much as your own code. 4. Yes, I love me some Java. Familiarity did not breed contempt in my case. It gets a bad rap simply for not having conciseness as a design goal, but conciseness is a bit overrated compared to easy readability. 5. IntelliJ all the way. 6. Well, I stay current by *cheating* and being surrounded by people who are moving the state of the industry forward. I don't have to learn what they did later. :-) 7. There's no royal road to this. Devote yourself to your craft and build great open-source things. One of Temple Grandin's many great pieces of advice is "sell your work, not yourself." 8. I post here: https://plus.google.com/113026104107031516488 - but please note the standard disclaimer that these are my personal opinions only, some of them unpopular. (Thanks for asking! Maybe this could be the bump that helps me finally clear 10K readers? Then I'll have to think about making my posts better.)
Maybe it is the cynic in me coming out, but your desired program being &gt;if I entered "I am a Cat", then the output would be: "There are: 2 words of length 1, 1 word of length 2, 1 word of length 3" sounds a lot like a home work assignment and your excuse that you want to show your son what an applet is and cheer him up sounds like a cover story to get someone to do your homework for you.
All the time. I use Java, get paid by Google to do so, and my life is thus made easier. (nailed it...)
I'm not sure what you mean by either of those questions? Steve Yegge's [post on Google interviews](http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html) is probably the canonical source of "what to expect from the interview process."
My acknowledged weakness is not being a polyglot. I've worked in Java since 1996 (18 years!?) and never felt the desire to go elsewhere. Part of the reason for this stems from my bias as a "libraries guy"; I get excited about ways to improve developers' lives through better libraries and better usage of libraries. The appeal of cool new language features that Java competitors have... just isn't that seductive for me. There are a few though. I greatly envy how in Kotlin `String` and `String?` are distinct types meaning non-nullable and nullable strings, respectively. That is elegant and useful.
That is not the case what so ever. If people believe that and proof is needed, then so be it.
I asked the original author of Gin. It was intentional. The naming doc from April 2007 even linked to http://en.wikipedia.org/wiki/Gin_and_Juice I'll leave you with one of my favorite Snoop Dogg jokes: *Why does Snoop Dogg carry an umbrella? Fo' drizzle.*
There's a bunch of good information at on our wiki: [how to contribute](https://code.google.com/p/guava-libraries/wiki/HowToContribute)
Thanks for the help, I think I've got it now! :)
There was one issue where the AsyncLoggerThread was not made a daemon thread, but that was fixed in beta 7. Currently there's another issue (LOG4J2-537) to the same effect. I can't say anything about it, though, as I couldn't reproduce it yet.
Thank you, that explains it nicely. I will probably still keep using Lombok (and delombok is part of my build). But it's good to know that I have some choice.
That's great to hear. Keep up the good work! :-)
Google interviews are technical and will mostly focus on algorithms, data structures, and complexity. For more senior candidates, they will focus more on design. We don't ask trick questions (if we ever did, I apologize to those candidates).
This. What is stylistically appropriate in Java is *not* necessarily stylistically appropriate in Scala, and vice versa, and so on for any other pair of languages.
Oh yea, here's a deep quote by Dijkstra that I like a lot: *Computer science is no more about computers than astronomy is about telescopes.*
There's no particularly good reason. I'll definitely try to bump the priority in my TODO list.
It's called `map` on `Stream`, though, right?
Huge +1 on #3. Can't. stress. this. enough.
&gt; Lastly, even ThoughtWorks, who has teamed up with Martin Fowler, yes ThoughtWorks are clearly a bunch of fools with that studiously ignorant recommendation and got a lot of critique about that. C'mon, J2EE??? Seriously!? Being aware of 2.0, when 2.2 is the current version. Abstracting CSS??? I'm still very curious to see an example of how JSF abstracts from CSS. I've read the spec cover to cover and back again, looked at every possible example, asked BalusC and Ed Burns himself, but nobody is aware of any such abstraction. Yet, ThoughtWorks in their infinite wisdom is sure JSF abstracts CSS. They very clearly just read a blog from 2005/2006 and didn't do any research of themselves into the current state of affairs.
Do you guys have anymore goodies in store for us related to String decoding/encoding ? I've noticed some new shiny hopefuls in recent https://github.com/square/okhttp commits along these lines but can't help imagine it is not a new concept internally.. It was new to me until recently certainly but I always assume you guys know everything now. =p
A jar/war is a self-contained deliverable; I'd say they're closer to eggs in Python. Virtualenv in more akin to the dependency management you get from tools like Maven/Gradle/Ivy.
Thanks for your response! &gt; trying to coerce it into a Functional language can be (while powerful) tortured I've always felt a conflict here with respect to `Optional`, because it has `transform`, but not `transformAndConcat`, unlike `FluentIterable`, which has both. Leaving off both seems to advance the goal of discouraging FP in Java, but the choice to have one without the other has always puzzled me.
Have you seen our [BaseEncoding](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/io/BaseEncoding.html) class? It's for things like Base 64, hexadecimal, etc. encoding and decoding.
I'm unaware of clojure being used in anything but experimental projects. I'd enjoy having it but we try to not fragment the language space too much within google. Much harder to maintain such a codebase I we require massive polyglottism from out devs. 
For client-side apps (web apps), we try to make sure our libraries work with GWT, but that's all the involvement we have. However, I've heard that on Saturday nights in the basement of building 43, the GWT and Closure teams are involved in a Fight Club...but wait, I just broke the first rule.
&gt;Also, I don't consider nearly a year since release "just came out". That is the spec version my friend. Spec versions are released on average only every 2 to 3 years. As for the implementations, Mojarra 2.2.5 came out last month: https://javaserverfaces.java.net/nonav/2.2/releasenotes.html PrimeFaces 4.0.8 came out 2 weeks ago: http://blog.primefaces.org/?p=3033 OmniFaces 1.7 came out 1 month ago: http://balusc.blogspot.com/2014/01/omnifaces-17-released.html 
The problem is, once you start down the path of custom components, or even investing your development effort down a component library such as PrimeFaces, you ARE locked in. Good luck reworking your entire UI without all of the helper components given to you through a library such as that, even if they are mostly driven off of JQuery UI. As to your point about UIs changing technologies not very often, I consider that just as silly as an argument as you stated mine is. Sure, for the most part they don't, but who knows, wouldn't you want the ability to move between view technologies easily? I didn't say anything about the service layer, so I'm not sure what your point was about designing the app to avoid coupling JSF to your service layer, I was assuming that was a given.
I'm imagining javaz already... in my nightmares.
I think Scala is successful at doing what it aims to do. It simply doesn't pursue the same point in the power-vs.-simplicity spectrum that I think we need most in a new language.
True, I'll retract that argument, my bigger issue is with the overall design and use of JSF. I feel like people just use it cause it's the first thing they see on Oracle's website, and don't bother looking at other web frameworks based in Java. Personally, having used a bevy of the available frameworks in Java, I personally feel like JSF is clunky, and not something that someone coming into Java development should learn. It doesn't follow a convention out of the box, so developers have to create their own. It introduces complexity to the HTTP protocol by abstracting it away which if you only know JSF and nothing else, most other web frameworks will look foreign to you.
Google develops in a small number of widely used languages, each of which have compelling reasons to be "the language Google uses". There are a few reasons why: every language needs to have toolchain support, be teachable to new hires, support interfacing to our infrastructure, have solid support libraries, a population that's willing to review code written in it, style guides, and so on, and so on. No one is really pushing hard for Clojure, but my suspicion is that it would fall short on a few of these metrics.
Oops, wrong method. I meant the new Map.remove(key, value) method. It asserts that following the operation Map.containsKey() will be false. For a MultiMap if there are other values then containsKey() will still return true. The MultiMap behaviour isn't terribly weird and doesn't break the Map contract in any tragic ways (it is less weird than IdentityMap, for example) but combined with other issues like the type of the container for values, etc. it is unlikely we will pursue including MultiMap for the JDK.
I had never even heard the song, just this, umm... rendition... http://www.youtube.com/watch?v=q-9CCKB8ii4 (obviously NSFW)
I think I'm unable to account for the "from working in Java specifically" part of your question, since working in Java is all I've really known. I'm going to self-interestedly answer the rest of the question without that. The deepest thing I've learned about software engineering is that it is gardening. You plant, it grows, it bears fruit -- but you are not finished. You MUST tend the garden. You must water it, weed it -- cultivate. Things that were formerly fine will have become gnarled and rotten and must be dealt with. A vine that was supposed to grow in this direction grows that way instead. The initial event of planting these things the first time was nothing in the grand scheme of things. But in software we treat it like it's everything.
&gt; JSF does abstract CSS through the use of components. The markup within your xhtml should be JSF tags only, no styling, javascript, nothing, just the standard and custom taglibs. We may have different opinions about whether JSF is useful, clunky, or whatever and that's fine. To each his own. But this particular statement is just absolutely wrong. First of all JSF is most definitely **not** about using JSF tags only. On the contrary, JSF embraces plain HTML with special attributes that the JSF runtime uses to see it's a component. See e.g. the example posted here: http://blog.primefaces.org/?p=3035 Even when not using the HTML-tag style (officially called "passthrough elements"), then you never see real life JSF pages with only components. That just doesn't happen, it's always mixed with plain html. Always. I've seen many different JSF projects from different teams and never seen anyway using pages with only components. &gt;no styling, javascript, nothing, The styling part specifically is not true. You always provide extensive stylesheets with your JSF app. Every component out there has attributes for style classes and inline styling. You can't just put random components on your page and expect to see a coherent look. The standard components have no default styling of themselves at all. Components from the PrimeFaces lib have, but you typically override them unless for quick mockups where the default PrimeFaces styling is enough. And the no JavaScript part is really not true either. Most every component has onXYZ handlers where you are supposed to insert your own JavaScript. PrimeFaces publishes and documents a JavaScript variable corresponding to each rich component you put on your page, so you can interact with it using JavaScript in whatever way you want. I'm not sure whether you read about these supposed rules somewhere, or that you looked at JSF and thought this was the intention, but it's really not the case. In JSF it's the full intention of the framework that you use HTML tags, apply CSS styling and use your own custom JavaScript. &gt;I can't tell if you're trolling me with your comments about ThoughtWorks I'm not trolling. I absolute stand behind my statement that ThoughtWorks did a bodge job with their JSF assessment. How can you take any party seriously that uses the term "j2ee" in 2014? This term was abolished almost a decade ago. I contacted them via Twitter and asked for an explanation, but they couldn't really give me one. I'm sure they do a fine job at other areas but they didn't do so for JSF. As someone working with JSF daily I'm well aware that there are certain limitations and points that can be improved. Almost every serious JSF developer knows what these points are. So if ThoughtWorks for some reason or the other would have wanted to post a negative assessment of JSF they could have easily used those points, and people would have respected them for that. Instead they go babbling about "j2ee" and "abstracting css". Poor job... can't say anything else. 
Whoa, back the train up buddy, I'm not out to condemn Oracle, I'm out to condemn JSF, haha. I personally feel JSF is an antiquated technology that is used amongst mostly corporate environments for simple one off UIs for backoffice operations (ironically, what the OP wants, but I digress). Find me a JSF driven front facing popular website, and I'll stop my charade. The OP asked for opinions on: "something simpler out there that an intermediate level Java developer could grasp relatively quickly and getting working internal web applications working, any direction would be appreciated." Given that this is in and of itself an opinionated question, you have to expect opinionated responses, no? **In my opinion** time would be better spent learning a request-based framework over a component based as they are the more **common** approaches web frameworks amongst all technologies, not just Java. JSF abstracts the requests through FacesContext, in order to maintain state within the application. Something like Spring MVC allows you to (more easily) have direct access to HttpServletRequest. edit: wording
There is not always a reason why X is not in Guava. 99% of the time there isn't. On the contrary, our job is to make sure there is always a clear and compelling reason why all the X's that are *in* Guava are *in* Guava. Many, many (many) probably-worthy ideas get stuck in the large gray zone between "clearly justified and good" and "bad". Here's the only FR we've gotten for flatMap: https://code.google.com/p/guava-libraries/issues/detail?id=1450 It's extremely tepid. It's phrased as "it would be nice if" and doesn't actually say "here: look at these examples of what we could do if we had this, and here's why I believe the need for this comes up a lot." Not even close. We would be negligent stewards of this library if we added half the features that were justified so weakly. (Now, all the criticism we've noticed on twitter and the like, about what morons we are for not having this method: that's been less weak. Just not constructive.)
First off, pretty cool post on that PrimeFaces blog, nice to see strides are being made for a more HTMLish feel. For those that are stuck without the cool new features of JSF 2.2, I have the following to say, lol. I didn't say you can't use HTML in JSF, I don't know how you would write components otherwise, I was saying those are abstracted away within usually either: * custom taglibs * templates I completely understand this, and that's fine, my point was your main view templates / fragments, whatever should contain only tags, with the HTML, CSS, and Javascript abstracted away within tag libraries. I'll concede that there will be HTML within the views at some points, my point was the majority of the actual layout, styling, etc. should be contained within your templates and components. I understand there are onEvent attributes within the tags. My problem with it is the functions you pass through these javascript methods are usually extremely coupled to JSF, making something simple like a popup window require major refactoring if you're going from JSF to just straight HTML. i.e. [PrimeFaces Dialog Login](http://www.primefaces.org/showcase/ui/dialogLogin.jsf) You'd have to port over whatever the primefaces (PF) namespaced javascript object is doing, in this case looks like a factory method creating a dialog box with a jquery ui shake effect on it if login fails. Into your own custom javascript if you choose to move technologies. The other part that bothers me about JSF javascript is the confusing nature of how id's are generated for JSF components, but that's another whole thread. Edit: Relates to new 2.2 features.
`Multimap` actually doesn't implement `Map` because, as you mention, the semantics differ. We've tried pretty hard to ensure that our implementations of JDK APIs don't violate the specs.
Yup. Your point? :-) I mean, I interpreted the question as what was *our* reason for naming *our* method `transform`, and that's what I gave.
crosspost*
Frankly, I've always been under the impression that we're more careful about the spec than the JDK itself, though y'all have been fixing some of those bugs lately. (TreeSet containing a single null element comes to mind, as does EnumMap.entrySet.)
What is the nature of the code before dagger? Is it using Guice? Is it using static mutable variables? Is it using the service-locator pattern? I'd love to answer this, but I need a good "before" to know what the "after" might look like. 
The program I got hired into, the [Test Mercenaries](http://mike-bland.com/2012/07/10/test-mercenaries.html) was disbanded two weeks after I joined. I cast around a bunch and worked on everything from logging analysis to project dashboards for our (then new) continuous integration system for teams that were used to certain functionality from their under-the-desk stuff, to taking care of some of the infrastructure around iOS development. But in that time I had expressed opinions about dependency injection. So they made me be part of wrangling it as a newly expanded role for the java core libraries team (beyond just Guava, etc.) But yeah - it was largely a matter of growing a network of interesting colleagues and having a wonderfully suited opportunity around the time our department was consolidating offices. 
sure
&gt;In my opinion time would be better spent learning a request-based framework over a component based Request-based vs component-based is a perfectly valid discussion. JSF is part of that discussion, but it's an entirely different one than a supposed JSF vs "the world". JSF mainly adheres to the component model and in adhering to that does not introduce any weird model that's way outside of that scope. It's a bit like the frequent debates about Java over at /r/programming, where the in crowd there tries to blame Java for being a weird language that does things differently then their favorite language, which in /r/programming is predominantly functional and dynamic. But that's also absurd. It's not Java vs "the world", but static and imperative style languages, mostly C-style languages vs functional and/or dynamic ones. Do note that JSF is becoming more of a hybrid style framework. It has adopted the [view action](http://jdevelopment.nl/jsf-22/#758) in JSF 2.2 which has a more request based style and feel. Mojarra just went a step further and is busy prototyping a more direct support for the action/request based paradigm. See this blog entry from the main Mojarra committer Manfred Riem: https://weblogs.java.net/blog/mriem/archive/2014/01/13/jsf-tip-56-using-action-based-prototype-mojarra &gt;as they are the more common approaches web frameworks amongst all technologies, not just Java. I'm not sure about that, especially not for Java. A while back I did some investigation into the relative popularity of web frameworks and it didn't seem that request based is the more common approach as well. See http://henk53.wordpress.com/2011/10/12/reply-to-comparing-java-web-frameworks It might be a case of that in your local universe everyone happens to use request based, so you automatically assume that in every universe everyone uses request based. You see for example that JSF scores high, but Spring MVC scores high as well, so that's 50/50 for component and action, but then you also see that Vaadin scores high in some surveys and it's definitely not request based, and Wicket scores in the middle tier and it's not request based either. &gt;JSF abstracts the requests through FacesContext This is also not entirely true. There's barely any abstraction for the request itself going on there. The FacesContext is intended to provide a common API for both Servlet and Portlet requests. From the FacesContext you can obtain the ExternalContext, which you then cast to an HttpServletRequest. This is a pretty normal thing to do, and is used often in backing beans to do advanced redirects, set specific headers or iterate over the request parameters in a special way. The FacesContext is a bit verbose with its deep hierarchies, I'll give you that, but it doesn't prevent direct access to any HTTP methods, nor does it try to preach this as a best practice. Utility libraries like OmniFaces do provide a wealth of methods that make the interaction a bit less verbose, see e.g. http://wiki.omnifaces.googlecode.com/hg/javadoc/1.7/org/omnifaces/util/Faces.html But OmniFaces does not hack into the FacesContext and does nothing that you wouldn't be able to do with the plain thing as well. &gt;in order to maintain state within the application. I'm afraid this is not correct either. State is stored inside components while JSF walks through the component tree. At the end of the request this state is then collected from those components and either stored in the session (partially, based on deltas of the initial state) or encrypted and stored in a hidden field and then send to the client. The FacesContext doesn't specifically comes into play here, other than that it's often a convenient entry point into the component tree. 
What's Crazy Bob up to? I see his name all over the guice source.
CTO of Square.
The types of devs asking that question aren't the types to spend their freetime on Coursera unfortunately. Honestly I think that course should be mandatory. It is so well done, and I feel like much of it was useful even when I'm writing Java code. 
Burke + Crazy Bob. That's legit.
I totally understand this argument for restraint, and I agree that it's one of the reasons Guava is so good. What I don't understand is how, in this particular case, the Guava team saw a "clear and compelling reason" to add `transform` but not `transformAndConcat` to `Optional`, making it a sort of neutered half-monad. Map and flat map are like peas and carrots. `FluentIterable` has them both, but `Optional` has only one of them. `Optional` having _neither_ would even seem justified, but it indeed has only one without the other. In that context, I don't think the feature request is "tepid", because it honestly just seems like an oversight in an almost complete implementation of a [long understood abstraction](http://en.wikipedia.org/wiki/Option_type), not an intentional choice.
I love it. Basic examples but sometimes extremely helpful. 
/u/LouisWasserman, why is your brother such a nerd?
&gt; if you don't accept patches and there are no non-Google-employee committers on any of these projects This fact is simply not true when you leave Guava (you said "projects" after all). It's not difficult to get patches accepted on the GitHub projects since they are much smaller in scope. I have had patches accepted to a few of their other projects.
Without knowing *exactly* what line the error is on, it's hard to tell, but it could be this: if (cellplan.equals ("A")) { overmin = 0; if (minutes &gt; 300); } overmin = minutes - 300; } That if statement looks a little off, maybe you meant: if(cellplan.equals("A")){ overmin = 0; } if(minutes &gt; 300){ overmin = minutes - 300; } 
&gt;public class reddit help { Also keep in mind that `reddit help` is not a valid class name, as identifiers cannot contain whitespace. The class name must also be the same as the name of the java file (eg. RedditHelp.java contains `public class RedditHelp {}`)
I've seen it but felt inadequately knowledgeable enough to see any obvious benefits in situations like this:(my use case was in decoding from postgres/vertica resultset.getstring(s) .. Like all gateway drugs it lead to delimited file parser using and moar and moar n-hundred thousands ops per x-seconds with m-total alloc memory., it's never enough): http://psy-lob-saw.blogspot.com/2012/12/encode-utf-8-string-to-bytebuffer-faster.html I did some "things" locally in a project, like delimited file parsing and replacing resultset.getstring with getBytes() &gt; faster decode &gt; string but ultimately I felt unfulfilled and not happy about things. Especially when deadline people said I had to stop getting "moar performance" and finish project first.. *sniff 
Write a program that says "Hello, world!"
overmin might not be initialized because you never set it to anything except for in an if statement. where you declare int overmin; change it to int overmin = 0; 
You should have a call to super.paintComponent in your code. The call to super will initialize the drawing area, just like the two lines of code from your book. class MyDrawPanel extends JPanel { public void paintComponent(Graphics g) { super.paintComponent(g); g.setColor(Color.orange); g.fillOval(x, y, CIRCLE_X, CIRCLE_Y); } // close paintComponent() } // cl
Why 4k default buffer sizes in io operations? Not a pressing demand for explanation, just curious as I worked on a system at last job which had to do a lot of file/io operations in many varied hostile/inconsistent envs and was certain I had landed on something higher than 4k being more ideal. I almost assuredly didn't do it as scientifically as google must have so was interested in knowing the story/lurking knowledge behind that constant.
I wouldn't care if it was your homework or not. I just like to show off. With that being said I do not know anything about applets but if it uses java then I would do something like this: int[] wordLength = new int[26]; //doubtfull there is a bigger word for (int i = 0; i &lt; wordLength.length; i++) wordLength[i] = 0; words = str.split(" "); for (String word : words) wordLength[word.length()] += 1; System.out.print("There are: "); for (int i = 0; i &lt; wordLength.length(); i++) if (i &gt; 0) System.out.print( wordLength[i] + " words of length " + i); //This has bugs, or it should considering i just typed it in this comment box and not an ide
It means that the variable hasn't been allocated a value. Try declaring it as int overmin = 0; instead.
Essentially, the compiler is saying, "what happens if that if statement isn't executed?". You declare your variables, but, as /u/irocgts said, you haven't *defined* (initialized) any of them. A simple way to fix this is by adding a default value to `overmin`: int overmin = 0; //initialize overmin to 0 As for all of the other variables, you don't need to declare them at the top. Define and declare in one line, like this: int overmin = 0; //the only one you really need to define on its own //you can declare where you define! also, you don't need to store it in another variable (like "input") before you assign it to something String cellplan = JOptionPane.showInputDialog("Enter your plan: A, B, or C"); int minutes = Integer.parseInt(JOptionPane.showInputDialog("Enter how many minutes you used")); double data = Double.parseDouble(JOptionPane.showInputDialog("Enter how many megabytes of data was used")); if(cellplan.equals("A")){ overmin = 0; } if(minutes &gt; 300){ overmin = minutes - 300; } double cost = overmin * 0.25 + data * 0.75 + 29.95; A lot of this is for readability, but I would highly recommend writing it like this. The only actual *error* was not defining (initializing) `overmin`. *edit*: style
This is something you can find out for yourself. The source code is available at http://hg.openjdk.java.net/ http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/b49e33de40ea/src/share/classes/javax/swing/JPanel.java http://hg.openjdk.java.net/jdk7u/jdk7u60/jdk/file/0dd27693876d/src/share/classes/javax/swing/JPanel.java
What is that? Five years?
&gt; The points in the article stand for any JS frontend. Perhaps you're correct, but is it specific to the Java (backend) + JavaScript (front-end) combination? I don't think so, given that (RESTful) web services can be implemented not only in Java, but also C#/ PHP/ Python/ etc. I just did a quick search on the article, the only place Java being mentioned is in 4th paragraph (about installing dependencies for testing the site). * First paragraph is about SEO. Pages dynamically generated with JavaScript doesn't work well for search engines to index the content. Server can choose to generate static pages for search engines but there are risks. *This paragraph is not specific to Java.* * Second paragraph is about statistical information gathering. This paragraph completely focuses on the client-side. *This paragraph has nothing to do with Java.* * Third paragraph is about build tools for JavaScript applications. *This paragraph has nothing to do with Java.* * Forth paragraph is about testing applications. You still have the same problem no matter your backend is written in Java or C# or PHP. *This paragraph isn't specific to Java.* * Fifth paragraph is about responsiveness of JavaScript codes on client-side. The article mentions that pages rendered completely (or mostly) on backend may get blocked if one of the API calls is slow. *But this isn't specific to Java too.* Now tell me, what do you find *from the article* that you think it makes the article specific to /r/java, but not /r/webdev? BTW, why would you choose RESTlet but not Jerset, RESTEasy or even Apache CXF? AFAIK RESTlet doesn't implement JSR-311 or JSR-339, which means you have one and only one implementation only, while there are several implementations of JAX-RS.
You don't. Just use one of the enum constants - they're automatically singletons.
Could you elaborate on how to do this? Thanks.
You'll notice it's crossposted to /r/webdev as well. I would agree with it being posted in other language forums, too, but OP chose not to do that. I still say it can fit for /r/java but clearly we won't agree on this point and I am in the minority opinion here. BTW, you can get JSR-311 via http://restlet.org/learn/guide/2.1/extensions/jax-rs and I'm not the one who chose it. We've shipped software with it and that's all that matters. I'm not going to go around willynilly replacing a framework that works because there are 4 or 5 other implementations of the same JSR. http://www.codinghorror.com/blog/2007/07/yes-but-what-have-you-done.html
Sure: public enum PleaseWriteClassesUppercase { AegisCruiser, Fighter; //add others } then in other code, just use e.g. PleaseWriteClassesUppercase.AegisCruiser, which will be of type PleaseWriteClassedUppercase and have the ordinal 0. Did I mention you should start your classes with an uppercase character?
Probably depends on the mix of messages. If most messages are smaller than 4 KiB, larger buffers just waste memory.
Thanks for answers!
I'm tempted to spin off OkHttp's buffered I/O package as a standalone library. Though it's pretty low-level. How many programmers are frustrated with limitations of byte[] and ByteBuffers?
Yep. As I said, I haven't reproduced it (though maybe that's because I'm on Java 1.7). There are folks who seem to have a problem with the "Async all the things" approach. Obviously, when logging messages containing objects, one should make sure the objects are still available and in the same state when they're committed to the log; also the interactions with thread local objects may lead to strange and fascinating errors. :-)
Thanks, By networks I mean utility classes to make socket handling easier. I really think Java's stdlib could be improved when it comes to handling sockets. Especially SSL in Java...
About your ideas: 1: (mapping the room): you would need to use the motion sensors to try to track the movement, and the app would need to be running all that time 2: has been done. Advanced picture analysis 3: I would think this would be fairly hard. You'd have to lean on some face recognition algorithms, then maybe a neural network trained to recognize some basic emotions. First stage would be to identify head angles, even recognize open mouth and eyes is non-trivial. On a related note: Apps have been made that use the camera and facial colour to identify heart rate. Some notion of "livelyness"/activity level might also be analyzed. 4: Much the same as #2. I don't think infrared would help if you can use camera and image processing. A couple of ideas up your alley: A virtual sculptor (similar to existing ones), where you use the phone as a chisel/axe, that is to say that you walk around the virtual object and chop, chisel, paint, bore etc. In visual mode, you would see your sculpture superimposed on the camera picture. Facial recognition in eye reflection. It has recently been described that one can recognize faces in reflections in pictures. Make a desktop utility to traverse (automatically or guided) a picture library to tag all faces, including ones reflected in eyes, glasses, car doors, screens. A configurable reminder app, with extensible set of triggers. Calendar triggers are of course standard, but location, person accessibility (meeting, phone call, chat), person proximity (near field, facial recognition in photos), sensor input, combinations - so you could set reminders based on "next time I am near Home Depot during opening hours". Good timeline applications: A visual presentation, filterable, of everything this phone knows about: what happened during this day etc. (Timeline filtered by person: all interactions with person: SMSes, phone calls, chats, tagging of pictures, meetings in calendar, altering of contact information... Timeline filtered by geography/place, type of activity... Possibility of adding information, adding or categorizing events into the timeline by hand) I suppose you need to set some hard limits on your work: Only this class of phone (os/hardware), only this hardware/pc, only this file extension/picture format, only handle these few exceptions/error conditions/complications...
I feel like I need a shower after seeing code which uses Lombok.
The fact you have to declare your project pom as child of spring boot smells.
Why would you use a parser for this? Why not do a search and replace.
When they mentioned the creators of the algorithm not subscribing to the young/old gen model, I remembered that the Java 7 compiler now does escape analysis, allocating short-lived objects on the stack. Do we need the young/old gen model anymore if the young gen are destroyed immediately instead of becoming garbage?
I have currently a program that reads a text-file, counts words/sentence length etc and compares it to other text files. That's about the level I'm at now, and it was indeed a good practice. What did you continue with? :)
&gt; Yeah, virtualenv used to have a --relocatable flag, but it's been broken for years. I think the wheel format might be heading this way. Another point to Steve's maturity comment (although Python's world is a lot nicer than the other scripting languages)
&gt; We've got a bunch of legacy Java code which uses Lombok [...]. It also wreaks havoc on lots of our tooling [...] Well, what do you suppose delombok is for? Btw. Lombok is now working across 3 major JDK versions, 5 Eclipse versions and (with reduced functionality) on current NetBeans and IntelliJ so as Reinier Zwitserloot says 'it's not completely fragile'. And yes, for Scala, IntelliJ is probably better. I'm currently working in Java 1.7 using Eclipse, and while I have recently tried IntelliJ (again), it just didn't click with me (again). To each their own, I guess.
&gt; The reason it tops surveys is due to Corporate development. Corporate approves JavaEE as standard, JSF is the standard web framework within EE, therefore it is the most used. Other people have tried this argument before. Java EE is only popular because it's forced down people's throats by corporate managers. But this is not true. When J2EE had stupid APIs, it's popularity plumetted. But corporate managers don't care about sane APIs, they only care about the IBM or Oracle brand, right? Then when Java EE got better APIs and became easier and more lightweight, it increased in popularity, yet managers still don't care about that. In surveys for developers where the question is "what do you LIKE" or "what do you WANT to use", Java EE and JSF scores just as well. So sorry, but "JSF is only popular because it's a standard" does not fly.
p.s. &gt; also for the fact that JSF introduces state within the HTTP protocol, a stateless protocol, as mentioned later within a linked article, a flawed design from initial conception. JSF does not HAVE to use state. If you don't use forms there's not state, AND there is a stateless mode. See http://jdevelopment.nl/jsf-22/#1055 And state is NOT a flawed design. So called stateless architectures more often than not are stateful anyway, but all that state is sucked in at the start of each request and then dumped at the end of it to some central database. If you think state is flawed then maybe the entire concept of deploying applications on the web is deeply flawed. HTTP and HTML were designed for HYPER TEXT. HYPER TEXT, do you know it? It's even in the name; HTTP = Hyper Text Transfer Protocol. So instead of blaming JSF to introduce state, you should maybe blame yourself for introducing applications. JSF is not more or less wrong then everyone else. We're ALL abusing the HTTP protocol and HTML. Many other frameworks have explicit state and sessions and hidden state just as well. Many things in applications by their very nature are stateful. You can't wish that away just by proclaiming that HTTP is stateless. And btw WebSockets are getting really popular and are not stateless, so there you go. 
p.s. 2 &gt; . but at least learning would be put towards the way the web is moving, not towards something the web is moving away from Who decides what the web is moving to? All I see is some people screaming that everything should be client side, just as a few years back some people screamed that everything should be Ruby on Rails and that all development in general is moving to Ruby on Rails. But are we all programming in Ruby now? Another example; in 2005/2006 there was a trend going on for 2 years where dynamic programming language usage increased and static programming language usage went down. So people yelled that all programming was moving towards dynamic and moving away from static, and thus that any continued usage of static languages was nonsense since... it was in the direction that programming languages were moving away from. But then in 2007/2008 the trend reversed, and currently it's pretty steady at some 70% static, 30% dynamic. Static languages have tons of advantages and dynamic ones ton of disadvantages and the idea that programming was completely moving to dynamic was thus completely wrong and just based on a local observation. I know more than a few companies who jumped on the client side bandwagon because of all the hype, got burned and moved back to server side. 
&gt; To a person coming into the app, it can be hard to follow how things flow through even a well designed JSF application. The conceptual entry point is the page, which incidentally is also what people see in their address bar and is often the first they look for anyway. Request /foo thus look at page /foo.xhtml. Simple, not? The page references beans and pulls those in. If on a page there `#{helloBean.text}` then there's the bean "helloBean" involved.
In that case, a) a static factory method will suffice: public enum AvaliableUnits { AegisCruiser, Cruiser, Destroyer, Fighter, Bomber, Infantry, Armor; static Unit fromType(AvailableUnit unit) { switch(unit) { case AegisCruiser: return new AegisCruiseImplementation(); ... } } }; Apart from that, I wonder why OP wants to use an enum?
I don't think other response is what OP is looking for... He wants to be able to create a (separate) instance of the class associated with each enum value, every time some method is called on it, yeah OP? I did something similar just today using a Factory class, but even easier, just have the enum implement an interface. Here's what I think it should look like (including my own recommendations for capitalization :) ) -- public enum AvailableUnits implements UnitFactory { AEGIS_CRUISER { @Override public Unit createUnit() { return new AegisCruiser(); } }, CRUISER { @Override public Unit createUnit() { return new Cruiser(); } }, /* etc */ ; } ////////////////////////////////////////////// // Stuff that should probably be in a separate // file but I'll put in here for brevity ////////////////////////////////////////////// interface UnitFactory { Unit createUnit(); } interface Unit { } class AegisCruiser implements Unit { } class Cruiser implements Unit { } Then you can have your instance of AvailableUnits and call createUnit() on it. E.g. AvailableUnits au = AvailableUnits.CRUISER; Unit unit = au.createUnit(); 
Nice but, most terminals can handle an arbitrary numbers of columns, why the box must have a fixed width? What happens if a line is too long?
People have been doing all kinds of crazy abstractions over desktop toolkits in the passed, just to be able to switch them. It's a big anti-pattern and a colossal waste of time and resources in most cases. Programmers always cry about being independent from everything and being totally flexible and fully scalable - and then get so lost in that that they forget to actually build the software the business requires. Read the lean startup and learn about the minimal viable product.
Yes I appreciate the author's work, and my original idea was that /r/webdev is a better subreddit for it, that's it. You're not the OP, it's not your fault (and it is not a fault for posting this article). And for the RESTful web services... Whoa. I asked about RESTlet just because I'm curious, perhaps you like it, perhaps you used to it, perhaps its performance is better, perhaps you just use it without reason... But "go around willynilly"? You emphasize that how relevant and important what the article talks about (i.e. *JavaScript* frameworks, testing of applications written with *JavaScript*) but "go around willynilly" for implementing something with *Java*, in /r/java? Really? I thought you would elaborate more on how Java-implemented RESTful web services can work with JavaScript on front-end in better and more efficient manner.
Yes, java can haz concurrency. But it's not what I would call "painless", compared to other *cough*erlang*cough*clojure*cough* languages.
Maybe Spring is just getting a little too complicated if you need another complicated project to set it up. You could take the easy way and just use Java EE since it is simple, powerful and the language standard. Spring was the best thing around in 2006. I do not understand people who are so resistant to learn new skills when it will make them more productive. I would have said the same about people sticking with J2EE when Spring was much better. When you start a project evaluate the tools available and pick the best one. 
The Escape analysis is done for only extremely short lived objects that are also of a certain size/volume, so the traditional Young Gen heap space is still required (for now).
Right, but where is hello bean defined. Is it injected? Is it defined in a managed bean XML? is it annotated somewhere within a package hierarchy. This is exactly my point, there are top many ways to skin a cat in JSF, and unless the development team has a convention and sticks to it over the application life cycle (something that rarely happens with legacy apps), I can get very confusing, very quickly.
[Relevant](https://blogs.oracle.com/hinkmond/entry/whatsapp_chat_messenger_available_for). By the way, the author of that blog has an interesting series going on about using JME on the Raspberry Pi.
You could do it with an enum like this: /** * Enumeration to represent the available types of units, all of which implement the Unit interface. */ enum UnitType { CRUISER, DESTROYER, FIGHTER, BOMBER, INFANTRY, ARMOR; public Unit buildUnit() { switch(this) { case CRUISER : return new CruiserUnit(); case DESTROYER : return new DestroyerUnit(); // ...and so on. This is assuming you have a class for each // unit, all of which inherit from some base Unit interface or // abstract class. } } } EDIT: However, it's worth mentioning that I think you're a bit confused about enums. Enum constants are just that - *constant*; i.e., they can be thought of as singletons. So, if you want to use an enum to represent the various types of units, that is OK, but to create multiple unit instances, you will need separate classes for each unit. EDIT 2: An example of how to use the code above to create a unit (in case it's not clear): final Unit fighter = UnitType.FIGHTER.buildUnit(); EDIT 3: I realized I should also mention a couple conventions that you should be aware of: * Java class names and enum names should be written in [camel case](http://en.wikipedia.org/wiki/CamelCase). * By convention, [enum names should be in the singular form](http://stackoverflow.com/a/15756009/2631700). So, instead of using "availableUnits" as your enum name, a better choice would be "AvailableUnit". I thought "UnitType" was a bit more to the point (as "types of units" is really what your enum is representing), which is why I went with that instead.
Yeah, last question key point. I'm also not sure I thoroughly understand problem enough to know what feels so wrong .. Looking through some other projects out there which you might say did "big data" things if you didn't mind sounding like a whore appear to inevitably land on an alt java.lang.String object which they pass around.. "Text" or whatever. Appreciate instinct to re-share code either way, I've learned a great deal of things simply watching the guava / square+ commit logs from time to time. Good healthy thing to do, keeps me grounded and free of any delusions about being an expert at anything.. =p
&gt; please find me these surveys that say people WANT to develop in JSF http://jaxenter.de/news/das-populaerste-Webframework-ist ---&gt; What is your **prefered** webframework http://www.flickr.com/photos/bejug/8191938707/ ---&gt; I **prefer** to build business app ui with
true, but if you're stuck with devs who don't want to ever take any time to improve their craft you are in a whole world of pain :)
Who decides...usually the larger technology companies like Google, Microsoft, and Oracle. Considering all of them have embraced HTML5 (JSF being the last with the most current release), yeah, I'd say the web is moving. FYI, Rails is as strong, if not stronger, than ever. It's a mature platform that [new development efforts](https://github.com/discourse/discourse) have been using just as much. Just cause you're not using it doesn't mean it's still not popular. How do you not see the trends, NodeJS is currently the hot button, all the cool San Francisco kids are doing it, but it will take at least 1-2 years of maturity before larger development efforts trust it. edit: formatting
I did some basic JDBC stuff, but I am a data analyst. I would try and explore the libraries a bit.
For future reference, any time you get a compiler error and you want to ask people for help about it - tell us what line the error was on!
I'm aware of the minimal viable product, I've been working in corporate long enough to have this shoved down my throat at every turn. I'm not asking for completely flexible and scalable, I'm asking for a **framework** which allows for development **teams** to follow **convention** easily. JSF does not provide this, it provides you with an API and a blank canvas of which you create your own conventions. This leads to different team members and different teams doing things slightly different and no cohesion, not a good thing.
So, a German Java based website? (Slanted results) ...and a picture of a team brainstorm...at your workplace? I hardly consider this to be sweeping results.
I am not sure but here is a note from the Embedded server guide. I do not know if this is saying it will be looked at in a latter version or if it it not being developed futher. &gt;Note: The main thrust of the GlassFish Server Open Source Edition 4.0 release is to provide an application server for developers to explore and begin exploiting the new and updated technologies in the Ja va EE 7 platform. Thus, the embedded server feature of Gl assFish Server was not a focus of this release. This feature is included in the release, but it may not function properly with some of the new features added in support of the Java EE 7 platform. https://glassfish.java.net/docs/4.0/embedded-server-guide.pdf 
I don't think Rails is as strong at all. Rails is a subset of Ruby usage, and it hasn't gained anywhere the popularity that people thought it would get. Ruby hovers around the 1% usage according to Tiobe; http://www.tiobe.com/index.php/content/paperinfo/tpci/Ruby.html Other sites don't show radically different figures. This is not even close to the total market domination. Didn't they say that RoR was so incredibly productive that no company could afford not to use it? I heard this line multiple times. According to the smug guys with their sandals and hip mac books (nothing against mac btw), RoR share would be about 70~80% in only a few years. And look at the marketshare now. It's LESS than 1%! Yes, RoR was influential, but it never dominated the entire marketplace and it's not even close to the numbers that the hipsters who arrogantly proclaimed to know everything and knew exactly where things where going (since they were the hipster and right on top of every new development and trend) predicted. Now the hipsters say the web is moving towards client-side only. The server will play a minimal role or may altogether disappear even. But I've heard such wild predictions based on a small period of observations too many times. In 10 years we'll know if they were right this time, but my guess is they'll be probably be wrong, again. &gt;How do you not see the trends, How do you not see between the hype? As I just explained above, RoR was once a hype and it died, Dynamic programming was once a hype and it didn't become dominant. In Java GWT was a big hype only 2 years ago and it's pretty much dead now. When I was sceptic about GWT at Devoxx '12 just 2 years ago, people said the exact same thing; how could I not see the trend? One year later Google announced dropping GWT and now Angular is the trend. &gt; NodeJS is currently the hot button, yeah right, with its slow cpu cycle burning code, and its eternally immature modules and its inability to use multiple cores. It was hot a year ago, but hipster paradise HN doesn't think it's cool anymore either.
Who said anything about marketshare, I said new development efforts are still using it. Also, marketshare isn't everything, of course the big three (php, Java, .NET) are going to rule marketshare, they employee the most people, and are the most hit websites. Does this mean other frameworks aren't used?
Thats fair. Before is the service locator pattern and after is dagger. Thanks
Does anyone know of any whatsapp platform/user statistics showing the numbers of users actually using J2ME versions of it? I tried looking and couldn't find any though.
After playing around with Nashorn and JavaFX today I am totally sold on Nashorn. I don't think JavaFX is worth using at the moment. A big part of that is because of compatibility. I create a javafx program that I start with a main. It works fine. I export that to jar. It works poorly with java 8 and does not work at all with java 7. You have to 'bundle' a special way and what not. It is a landmine of issues right now. Maybe when java 1.8 is the standard javafx will be worth using.
Good eye, thanks! I didn't see this through my foray into the guide. The current embedded libraries are at version 3.2, do you think this corresponds with GlassFish proper?
Horrible ads on this page, do not click!
I usually find [java.net](http://www.java.net) to be pretty good.
This thread has been linked to from elsewhere on reddit. - [/r/gwt] [LouisWasserman and other Java lib developers at Google comment on GWT usage internally at Google in an AMA in /r/java](http://np.reddit.com/r/gwt/comments/1ygc95/louiswasserman_and_other_java_lib_developers_at/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Send ^them ^to ^my ^inbox!](http://www.reddit.com/message/compose/?to=totes_meta_bot)* 
I read [javalobby@dzone](http://java.dzone.com/) and [InfoQ](http://www.infoq.com/) once in a while.
Unlike SOAP web services that have a WSDL that functions similar to a Java interface, most RESTful web services don't have something similar. Some have a WADL file but usually you don't have something that parses it to generate the client library. So you have two options: * Some REST providers code up a client library that you can use. Lacking that you... * Create your own client library by hand. You use *something* that can generate HTTP calls of the various GET,POST,PUT,DELETE types. Java SE has `java.net.HttpURLConnection` that you can use but don't, it is low-level and ugly to use. If you are using JAX-RS 2 there is an official client API you can use. If you are using JAX-RS 1.1 then get the Jersey client library, it served as the basis for the JAX-RS 2 client API. If you are talking about a SE application then you can go out and get the JARs for Jersey 2 (the reference implementation for JAX-RS 2) and add them as library JARs.
I've done it with and with the call to super.paintComponent(), but I get the same things with each. https://www.youtube.com/watch?v=-x048ZM4nFY
If you have zero experience creating an application and you want a project that forces you to look at how an app might be put together using MVC then it wouldn't be a bad thing to do, from a resume building standpoint it isn't a commonly looked for cert. OCJD also has a [course attendance requirement](https://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=458&amp;get_params=p_track_id:JSED6) that may or may not be an issue for you. Honestly if you want to get another cert I'd recommend you look into an EE 6 cert like the Java EE 6 Web Component Developer or the Java EE 6 Web Services Developer cert. 
Yeah, not sure how I feel about that as well. Wonder if the packaging target allows you to create a project without the boot dependencies, that'd be awesome. Sort of like an opinionated archetype generator. Still, feels like a lot of work for not much gain.
Feel like general "Java" newsfeeds would be too generic of a feed. You yourself even stated ".NET" which is a subset of either C# or VB, whatever. Feel like Java sort of partitions itself among many different categories since it's just a language, i.e. web stuff, EE stuff, design patterns, etc. So, depending on what you want to know about specific, I'd look towards there. i.e. * [Spring Blog](http://spring.io/blog) * [Oracle's Java Blog](https://blogs.oracle.com/main/tags/java) Sometimes what I do as well is just browse more recent questions on Stackoverflow tagged with Java, or whatever I'm using. Opens me up to new up and coming stuff. Just some thoughts. 
Oh, are you just referring to Charset encoding/decoding? In that case, I don't think we have anything planned. Is your issue with the normal ways of doing this just that it isn't fast enough for you?
Pretty sure it's facetious....
Historically that's certainly true. We've significantly "upped our game" for testing post-Oracle acquisition and continue to do so. The amount of technical debt accumulated in Java is staggering but certainly diminishing. I'm more direct than most in saying that during the late waning days of Sun (2007-2010) Java was a zombie. That is no longer true. Oracle has breathed in substantial new life (and strapped on a jetpack). Interestingly the [TreeSet bug](http://bugs.openjdk.java.net/query/JDK-5045147) was a known issue for seven years before it was fixed. There was an attempt to fix it just before Java 5.0 was released but the fix unfortunately broke application code including test suites and the fix was backed out. The bug was then forgotten through multiple generations of maintainers until I found it during my initial review of bugs coming onboard to the core libraries team. When we reapplied the fix to Java 7 we, surprisingly or unsurprisingly depending on how you view the world, found that once again a number of tests and apps relied upon the broken behaviour. Luckily though we had enough time remaining in Java 7 release cycle to fix the broken usages and publicize the fix. The Java 8 version of this situation seems to be [JDK-4802647](http://bugs.openjdk.java.net/query/JDK-4802647), also a very longstanding bug who's fixing has revealed problems in ANTLR3. Fixing it was the right thing to do though. The moral of the story is that sometimes, unfortunately, JDK conservatism extends to **not** fixing even evident bugs. We end up spending a lot of anguished deliberation and effort in providing fixes that are in the best long term interest of the platform and yet aren't also unnecessarily disruptive to developers. We always nonetheless end up disappointing somebody. Hopefully though developers see that the OpenJDK effort and Oracle is making prudent choices for the long term viability of Java.
German **Java** based website, i.e. the visitors of the site are going to have a predisposition to using Java in the first place, therefore have slanted opinions. This isn't a survey across developers across the industry as a whole. As for the picture, you're driving home my point even more considering JSF wasn't even close compared to Javascript / HTML5, rofl. You'd think with people purposely there for Java specifically would elect the languages primary source of webapp, but guess not!
Also, forgot both Github and Soundcloud are written in RoR, and Twitter, initially at least, they've moved the backend into a more scalable JVM application. I'd say those are some pretty popular websites.
My issue is mostly due to Yourkit combined with too much curiosity.. I had profiled a certain app many times previously but did not have jdbc source to find out why getString() -&gt; new String(byte[], charset) was taking so long ...Then on diff driver I did have source for I saw this same thing pop up in profiler yet again. So blame yourkit. If you have no idea what profiling hotspot I'm talking about then "you got no problems" I'd imagine. Carry on .. carry on. Netty is doing some awesome stuff in this area, even though it's not as easily usable as a nice guava lib: https://github.com/netty/netty/blob/write_charsequence/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
http://htmlunit.sourceforge.net/changes-report.html#a2.14
Interesting but why did the guy do a screenshot of the update screen!?
Take the first part of University of Helsinki's massive open online course: http://mooc.cs.helsinki.fi/programming-part1 When done, go to a little bit advanced stuff in part 2.
I am looking for some random generic news feeds. That way I can see what is going on in the Java world other than the stuff that I am working. It is a good way to keep me innovative by thinking of new frameworks to try or introductions into different technologies in the java world.
Dunno. Maybe Hinkmond's a very visual guy?
http://tapestry.apache.org/
&gt;German Java based website, So what? The numbers show what **Java** developers are interested in and **Java** developers clearly care about Vaadin and about JSF, which both aren't request based. &gt; you're driving home my point even more considering JSF wasn't even close compared to Javascript / HTML5, I'm not driving home anything with that picture. I just said it was taken at Devoxx. But if anything, it shows that JSF is not the obscure technology that no one likes or is not used to, which is what you are trying to say? Here JSF comes in third, which is right after Vaadin and way ahead of Play!, Grails, Angular and a bunch of others. There are 3 votes for OmniFaces as well, which may intersect or overlap. PrimeFaces is curiously missing though. Surveys do tend to differ a bit, but never that much. In nearly all of them JSF is in the top 3. Often second place, sometimes first, sometimes third. Again, one way of the other it's not that the entire community is used to request based and JSF is something strange and odd. This is a picture you are trying to paint, but it's just not true.
What is your "huge set" of extra responsibilities exactly? 
IIT: Reasonable people trying to avoid fixing friend's printers and ridiculously arrogant, ring-wearing, "*real* engineers" who want to condescend.
Yeah, what I was trying to get across is I'm not sure that really exists (killer app idea maybe?! PM me!). The way I discovered Play! (haven't really messed with it, at all, though), and Grails was through StackOverflow and Spring's website respectively. It's kind of a bummer, cause there are certain sects within Java development which go either one way or another. The "hipper" crowd tends to use frameworks such as Play! or JVM languages like Scala and the Lift framework. While the "more boring" or corporate developers tend to stick to EE stuff such as JSF, EJB, and Spring. That said, it's kind of interesting cause EJB 2.x stunk so much it got a bad rep, and people started turning to Spring as a replacement. Now, Oracle seems to be trying to rebuild it's reputation, but is fighting an uphill battle with all but the most battle-hardened supporters.
Clearly, Cayenne is inevitable for artist performances: SelectQuery select1 = new SelectQuery(Painting.class); List paintings1 = context.performQuery(select1); "perform" a query. Let the CBO orchestrate the ballet performance! (from [here](http://cayenne.apache.org/docs/3.1/tutorial/ch07.html))
On a side-note. How many Apache database access frameworks are there? - Cayenne - DbUtils - JDO - MetaModel - OJB - OpenJPA - Torque - ...?
Bringing up how many frameworks implement a specific JSR so you can "swap it out later" is what I meant by willynilly. Very rarely, even though you can, does anyone ever seem to swap one framework for another (even if it's just removing some jars and adding others). Regardless how many implement JSR-XYZ most projects choose one and stick with it, and that one chosen is probably the one that the senior person has used in the past.
The differences between surveys can be remarkable indeed, but those two again do not show JSF at an obscure bottom position. The InfoQ public puts it at 4, which is lower than many other surveys but far from the bottom. ZeroTurnAround productivity report puts JSF at number 2. Remarkable is that this specific survey puts Vaadin at the rock bottom position, while in two other ones it's at the top. JSF at 2 is however completely in line with other surveys. p.s. Here are yet some more surveys: http://henk53.wordpress.com/2011/10/12/reply-to-comparing-java-web-frameworks
Thank you so much for the time you took to write this down. Much appreciated. I have talked with my teacher and apparently out of my initial 4 ideas the 3rd one is the best one so far, but still have some time to find another one if i so choose. The sculpture idea sounds fun, sadly it's required to have a real use, and not just for show. The reflection idea : Not 100% sure i understand with my limited english, but what i would have to do is identify faces in pictures that have some kind of reflective surface. Meaning detect faces in pictures that are found on such surfaces, and maybe match the face to a known face out of a pool of other pictures ? If so, it sounds quite complicated, i mean you would have to recognize a face on angled surfaces... don't completely understand what you mean by "eye reflection". Reminder app : This sounds really cool, and i really like the idea. And i am pretty sure i would enjoy making it, but wouldn't you need a pretty impressive database to store all the locations you pass by, and not only that but specific things about them ( like opening hours, closing and other). Timeline app : basically make an app where everything is centralized, what happened with your contacts, social media, camera, maybe even sensors. It looks really good, also something i am really considering of doing. Great idea. Also it seems to me that it's the easiest of them all, to make. Tho i wouldn't be surprised if it's already been done. Hard limits are happening, and for starters i will make them as strict as possible. Once i get the ball rolling maybe i will loosen them up. Thank you so much for your feedback and help. If possible i would love to hear your input in the future as well, if you can and are not bothered that is
Yeah, I don't think I ever stated JSF isn't used. My position is it's used a lot, but not necessarily used well.
I think we can all agree with that ;)
Paste bin seems to be down. first thing I would check: if the input is a string are you using .equals(str)
It's just a bootstrapping mechanism. The parent POM, coupled with an annotation on your main config class, causes some Maven dependencies to be loaded and some sensible defaults added to the config class (e.g. JDBC data source, web view resolver, etc). Once you're up and going, you can strip out the parent POM and the config class annotation. Add all the dependencies you need manually, and add those resources to your config class by hand (changing them to something other than the defaults if you like). It's a bit of a hassle, but it's the *exact same hassle you have to go through to setup a new project manually anyway*. That's all there is to Spring Boot, and that's all there is to removing it. It's just a means for spinning up a new application and jumping into the code within minutes. Rather than the usual process of reading the manual and doing some Google searches, to re-learn all the latest boilerplate before you can start being productive with a new project.
Try using Double.compare instead of == Tutorial: http://www.tutorialspoint.com/java/lang/double_compare.htm
You had me with the first sentence... and then lost me with the second ("JEE == simple"?!?). :) I've used both Spring and JEE over the past decade, and I do try to employ standards once they're solid enough (e.g. these days I always use Hibernate as a JPA provider rather than sticking with the native Hibernate API). However, I've always tended to prefer Spring for two reasons. One, it's always a step or two ahead... JEE feels a bit "designed by committee", and always running a bit behind. Secondly, the Spring community is just so much larger and more helpful. Post a question about Spring on StackOverflow, and you'll have helpful answers within minutes (assuming there wasn't already an answer when you searched in the first place). Post a question about JEE, and there's just a smaller community of users willing and able to help out.
Fair enough, there are some legitimate differences of opinion there. I do like XML config in a web project, to the extent of having all your URL-to-controller mappings in one central place like most other frameworks do it. Otherwise, wiring up your beans through Java code, managing field-to-database mappings in your JPA classes, etc... almost everything else seems so much more natural and manageable outside of XML to me.