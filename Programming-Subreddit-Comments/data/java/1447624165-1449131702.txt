Also take a look at: - https://github.com/jhalterman/sarge - https://github.com/jhalterman/recurrent ---- *Sarge* is for simple object supervision (for when stuff goes wrong) Sarge creates supervised objects which automatically handle failures when they occur by performing retries, state resets, and failure escalation, allowing for easy and robust fault tolerance with little effort. ---- *Recurrent* is a simple, zero-dependency library for performing retries. It features: - Flexible retry policies - Synchronous and asynchronous retries - Asynchronous API integration - CompletableFuture and Java 8 functional interface integration - Invocation Tracking - Event Listeners - Supports Java 6+ though the documentation uses lambdas for simplicity. ---- This comment was originally from [this thread] (https://www.reddit.com/r/java/comments/3omyi3/retryable_operations/) about another retry library.
Those both look extremely slick, thanks for posting them! Here is one more that I had investigated when trying out retry libraries before writing my own: https://github.com/rholder/guava-retrying
Nice! I like that you have exponential backoff strategy built in. As an idea, you may want to add a feature to expose retry counts as Dropwizard metrics.
Basically for the code you are writing and running, java is a fine choice. HOWEVER, if you application needs any real-time aspects, then java may not be the best choice. In fact any language which has a generalized GC system could be problematic. I would recommend writing anything which requires responding to real-world events within a bounded period of time, in a small bit of C code. Keep the amount to a minimum, and use a well worn technique like operating system pipes to move data between that system and your java code. 
The _major_ force of Java is the amount of libraries (such as Netty) that allows one to build applications quickly using proven building blocks. If you wanna keep coding Java from scratch to preserve C++like patterns, you will eschew an immense body of work waiting for you and will most likely end up writing Java code that other Java programmers will find non-idiomatic. As long as it's just hobby projects, that's fine, it's just for you. But if you intend to develop marketable Java skills, I believe you should try to also learn about the libraries and practices of the ecosystem.
...but but but, that doesn't even loop :(
In case you are wondering, Oracle Labs solution will probably be better, but tinkering around JVM is simply too much fun. I'll do mine anyway. I spent couple of hours and I mapped all places I need to change (allocation is fun, there are many different paths in which JVM actually allocates something). I have a new bytecode that passes verification (and not in a hacky way) and works (x86 only). That was fun, I want to continue it even if it never becomes part of OpenJDK. 
This is a paramountly bad idea. Why not accept a long + TimeUnit?
Thank you for the reply. I did not read the sidebar, my apologies. Will delete the post ASAP.
Haven't used spring web servcies yet. I write this tool for the purpose of testing mybatis mapper and spring beans through postman(a chrome plugin). 
This asshole: showing up in every Java post. If you want to write code that can only be deployed on a Microsoft server then go right ahead.
Didn't know JavaFx is still a thing.
As far as I remember there is a setting to resolve unambiguous imports automatically. Somewhere around "optimize imports" 
Yep, I have mine setup the same way.
Not everyone likes it. There are however a very vocal and small minority that swear by it no matter what (aka fanbois). It has a bazillion flaws. Eclipse has a bazillion (different) flaws as well, it's only a matter of preference: who's problems do you prefer? I prefer Eclipse's. Used intellij for 2 months every day, fuck that shit. Gave it a honest try (which you seem to do as well), don't like it, move on. 
Yep, right, thanks. 
Java doesn't have green threads (since 1.1) and instead maps 1:1 to native threads, i.e., OS runnable tasks, typically called "processes". In the Linux kernel, for example, there is really no distinction between "process" or "thread" or "task". It's just executable tasks with different levels of sharing between them (e.g., sharing the address space). The point being that creating a thread in Java causes the overhead of a kernel schedulable entity.
sounds more like iq lack
http://blog.live-forest.com/2015/11/16/AARF/ 
Nothing. It's just people who think that the web and mobile is the solution for everything.
I googled the title in quotes and added .pdf and this was the first hit: https://sites.google.com/site/summanusnarcisorfer/java-methods-object-oriented-programming-and-data-structures Absolutely no idea if it's any good. You have to judge for yourself.
http://hs.nyackschools.org/download.axd?file=ac2896c5-5641-4546-a986-a0b5c54ae5d7&amp;dnldType=Resource
you are amizing
The quality of an application is inversely proportional to the size of its manual. How many pages is your iPhone manual? Oh, that's right, it didn't come with a manual. I have used Eclipse for years and have never needed to RTFM. IntelliJ is not what it's cracked up to be.
Java might be "too big to fall" right now, so even if Oracle drops it entirely, OpenJDK and the likes might keep it alive for many more years. The only problem could be license stuff.
I'd use (and am using) Oracle JDK :)
When in doubt, use the official thing. Less trouble that way.
Tiny WAR deployments is the biggest lie in Java EE development. 1) You're tied to the specific library versions that ship with your server. Want to switch servers? Your software no longer "just works" because the new server bundles different libraries of different versions. So really, you're not writing software for Java EE, you're writing specifically for TomEE/Glassfish/Wildfly/WebSphere/WebLogic. 2) Your libraries got patched? Wait for your vendor to bundle the patched library downstream. Enjoy waiting months if not years. Because all your libraries are patched all at once, you can't stagger the migrations, because any WAR that relies on only a partial count of patched libraries will not be deployable to either the older or the newer server versions. 3) Your developers are disincentivized from using new third-party libraries, because bundling them into the WAR will bloat the WAR beyond an acceptable size, and it's too difficult to get the library folded into the application server installed everywhere from prod to staging to integration to dev so as not to break anyone's build. At the end of the day, you really do have to deploy the WAR + libraries + server at the very least, not including the JVM itself. And the server is almost always relatively massive.
You're not making a bit of sense here, dude.
Maybe you are just using it wrong? See: http://blog.agiledeveloper.com/2015/06/lambdas-are-glue-code.html for some best practices
exactly
async await?
So you were completely used to using a different IDE before trying Eclipse and has no trouble using your old habits and shortcuts? because otherwise you are no apples to oranges. 
If you haven't seen pi4j yet, you will probably want to check it out. It's a library to access the hardware of the pi from Java. http://pi4j.com/ 
Remote with new skills, in my opinion is not terribly desirable. Perhaps you can find opportunities locally. 
&gt; XML /u/avoidhugeships what they use now, JSON?
Like the sidebar explains, for these kinds of questions there's /r/javahelp
It took me about a month to become a convert. During that time I did have to do a lot of documentation reading though. I still prefer Netbeans' Maven support but other than that I think IntelliJ is pretty good especially it's refactoring support.
I have done tiny war deployments for years. It means I can undeploy / upload / redeploy a new version of my app within seconds. My server library also includes a copy of Postgresql driver and mybatis / mybatisEE jars. It means I dont need to include it in my war, to keep it trim. YES, I don't want developers including new third party libraries..... there is nothing stopping them experimenting....please go ahead, and if it is proved that it is beneficial, then we can add it... 
No one is suggesting zero learning curve. But the greater that curve, the poorer the design.
thank
No.
I you wanna an open-source - Zulu is the best choice. link: http://www.azul.com/downloads/zulu/
This is vendor lock-in. Don't use this.
So the cost of your fast deploy workflow is additional bureaucracy. Why should a developer have to prove beneficiality? You gave the developer a feature request, the pull request implements the request with the help of the library, which is in and of itself proof that the library is beneficial. There's nothing to talk about and nothing additional to prove. Now, the exception to this is if a junior developer uses a library that duplicates a bundled library's functionality because he's more familiar with it. Say, the developer added in commons-lang when Guava is already a bundled dependency. But the redundant library comes up in code review which is subsequently rejected with the instructions to replace with the library already in use. The difference is whether to reject or accept additional dependencies by default. Rejecting by default is premature optimization unless your product has pre-defined, specific and rigid size/performance requirements, which most Java projects (by virtue of being Java projects) do not, and the cost of this premature optimization is lost developer productivity. Focusing on deploy times is a canard especially when the alternative is no-deploy embedded applications.
Hey- this is really great advice. I appreciate you taking the time out to write it. I am going to stick with IntelliJ for the time being and I'll post a follow up at the end of the month.
Correct, OpenJDK != Oracle Official JDK != Oracle Embedded JDK, and each has different supported architectures, performance characteristics, memory footprint, and licensing schemes.
The new API is useful when you parse _a lot_ of strings and don't want to allocate temporary objects (for performance reasons): String data = "config=666"; int sep = data.indexOf('='); // OLD: temp. new String allocation System.out.println( Integer.parseInt(data.substring(sep + 1)) ); // NEW: no garbage, but more ugly and possibly more error-prone System.out.println( Integer.parseInt(data, sep + 1, data.length(), 10) ); StringBuilder buf = new StringBuilder("666"); // OLD: temp. new String allocation System.out.println( Integer.parseInt(buf.toString()) ); // NEW: no garbage, StringBuilder is CharSequence System.out.println( Integer.parseInt(buf, 0, buf.length(), 10) );
I would really, *really* hate to work on your systems. I work on a system, where the time from bug report, to fix deployed, is measured in minutes. Where there are no perm-gen issues. Where things just work. And, the benefits from this workflow are worth the cost of restricting what goes into the war. 
This is not a problem with Java as such, but with your connection. The error message only tells that the received data is invalid. You can re-install Java for as often as you want it won't fix your problem as this is not related to the Java system, but to the connection to the server.
Finding anything in settings is easy. Ctrl-Alt-S to open and then there is a query box. Results show you every place in the settings where you can affect changes related to your query. There's no dicking around trying to find where to set something up. Not only can you set auto import but you can set reformat and rearrange options (including only VCS changed code.) Ctrl-Alt-L.
Same session on youtube: https://www.youtube.com/watch?v=7uii6osglDg
&gt; Spring [does things] automatically [...] Some people think this is a good thing. This seems very characteristic of Spring. I really wish it didn't have so much mind-share.
That's why i configure my Spring apps manually. I dont see any benefits of boot for me, especially when i use Spring only for DI and ORM.
See, from what I could understand, intellij wants to do things its own way. Yes, there are settings for just about everything, but I found it to be a constant fight if i wanna change the way it behaves. I am not willing to change my ways for the sake of changing my ways. Not without a return on my investment. And intellij didnt seem to provide any. I am willing to learn, but i want a benefit out of it. Otherwise, I can use the tools I already have that work the way i want them to, not me to work the way they want me to. 
Then java is totally ok for it
&gt; Say, the developer added in commons-lang when Guava is already a bundled dependency Developers as the FULL TEAM should be able to add whatever library they want IF THE TEAM DECIDES THIS. But an individual junior developer just adding a library at will? Even in the most liberal of places that's just asking for trouble if the team size is anything beyond totally trivial (say 1, duh! or 2 persons).
it's a good thing when you want to quickly build a prototype or proof of concept
I also struggled with it for a while before getting used. It's not just a matter of RTFM. It's a matter of goggling every 5 minutes to find out how to do stuff, and learning to live with the things that simply won't work as in eclipse. Here's a few things I took note because it was a PITA to figure out at first: ### Compiler settings ### Go to `File / Settings / Build, Execution, Deployment / Compiler / Java Compiler` and choose: 1. the **Eclipse** compiler. 2. check **proceed on errors`** 3. Add the following to **additional command line parameters**: `-Xlint:all` (my main grip with this is that the warnings won't disappear from the problem list, even though I have appropriate @SuppressWarnings in the code) Then, go back to `File / Settings / Build, Execution, Deployment / Compiler ` and: 1. tick **Make project automatically**. ### Keymap ### Open `File / Settings / Keymap ` and: 1. Choose **eclipse** and make a copy 2. On the search box, type *paramter info* 3. Double click the entry and choose *add keyboard shortcut* 4. Assign **CTRL+P** to make method parameters popup on the editor. (this saved my life, it will work almost like CTRL+SPACE in eclipse) ### Others 1. Editor &gt; General &gt; Code Folding 1.1. Disable folding for `one-line methods` and `simple property accessors` (I hate the default code folding) 2. Enable `Add unambiguous imports on the fly` Hope this helps. ### The following is something I REALLY, REALLY miss from eclipse: Eclipse displays warnings, FindBugs' errors, and compilation errors on the fly. As soon as I hit the keyboard I get notifications popping up (a marker in the editor, and an entry in a "problems" tab). In IntelliJ I can make the compilation errors appear on the fly (after enabling make automatically). However there's a delay of 1-2 seconds. Warnings, code analysis warnings, and FindBugs' errors are not displayed in the same panel that displays compilation errors. Also, I find the code analysis in IntelliJ very good but running it manually every time feels much less efficient than to have a table that is automatically refreshed while I type. I really miss find bugs because it reports the errors the matter the most. IntelliJ code analysis works too but it's just slower and I have to filter a lot of stuff out. Finbugs for IntelliJ sort of works but it looks awful and the problems are reported separately from the "problems" tab.
anybody here using the Actuator monitoring and diagnostic endpoints exposed with Spring Boot? i've toyed around with them while doing some local dev but never taken advantage of them heavily outside of that...
https://netbeans.org/kb/docs/java/native_pkg.html
Epic! I wonder if there's a way to do something similar in Eclipse instead of Netbeans though.
&gt; Github's Electron platform is dominating desktop app development right now in terms of job. I'm sure it's real popular with that one "job". LOL.
Anyone get the live class reload functionality working? I'm using IntelliJ and Gradle. So far, no luck. Do I need to do anything in my `build.gradle` or elsewhere?
Nice they added better OAuth2 support. The colorful banner.txt files are a nice feature too. However, I really wish Spring would stop pushing thymleaf as the default View technology. My god is it difficult to work with, it's way too strict with the way tags must be closed and the syntax to pass model attributes to the view can feel clunky and difficult to work with. I felt like JSPs with the core tag library and the spring tag library were way better.
use launch4j. you can test on your Mac with eclipse and deploy on a windows box no problem. http://launch4j.sourceforge.net/
You can if you make an Eclipse RCP application. Might be overkill depending on what you need thugh...
Still no cure for setting up Spring for production usage..
It will create actual .exe file. With launch4j you can create an .exe file wrapped around a jar (most common use) or build the exe with the jar contained in it. I have maven pom examples for both if you are interested. On the phone right now and won't be able to get to my computer till tomorrow morning.
Follow this link: https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html#howto-reload-springloaded-maven It works for me:)
What are you referring to?
I don't remember exactly it's been a while. As I have a moment check it out and let you know. While nothing has changed I can crash it in an hour. 
+1 We use that in our Mac/Windows Codename One desktop builds. Works really well. This also solves the need to have a Mac &amp; a Windows machine.
&gt; way too strict with the way tags must be closed That's a god-send (I've worked with Velocity and FreeMarker) - debugging templates is Not Fun(tm). &gt; syntax to pass model attributes to the view can feel clunky Wot? It's just delimited (don't tell me the 2 extra characters are bothering you....)
That's why you have liquibase in your *test* classpath, but not in your normal one. Still, we've precautionally added a configuration class that makes the app break when specific beans are in the application context...
Are you sure I'm an idiot? Maybe I'm just exacting and you are satisfied with just anything? I was using all available IDE's for many languages, all available OS'es through many years, so I've got something to which I can compare. Not only in terms of stability.
I think the main issue here is with the multi-line lambda. They really disrupt stream pipelines. I'd suggest refactoring that into its own method, one that takes an int and returns a `Result`. For the sake of example, call this refactored method `fullComputation`. Now the stream pipeline becomes List&lt;Future&lt;Result&gt;&gt; result = IntStream.range(0, n) .mapToObj(i -&gt; exec.submit(() -&gt; fullComputation(i))) .collect(Collectors.toList()); This is much nicer, in my opinion. It still has the nested lambdas, but it's pretty easy to see what's going on. It also makes `fullComputation()` much easier to unit test. Avoid multi-line lambdas.
Yes, I am sure. 
A JBoss developer answers the question whether JEE is still relevant. I really wonder what he could say!
I don't really get how this build is different from OpenJDK?
When its this fast, then what is the problem?..... If something else has broken because of the fix, then like 20 seconds later, the previous version can be restored and up and running. Or that bug fix made and deployed. Its that simple. 
https://github.com/libgdx/packr, also packs a JVM.
Java EE encompases everying that Java SE has. And then adds additional stuff on top. 
FYI: Control+3 in eclipse for context dialog does a similar thing. Disclaimer: i am not advocating holy war. Just leaving this here as a piece of information for any IDE agnostic developers like myself. I think both have their merits ^^^IPreferEclipse
Here I tried to collect all information about this JEP https://stokito.wordpress.com/2014/11/10/deprecated-java/ Also interesting to see how it may looks like http://marxsoftware.blogspot.com/2015/11/what-might-new-deprecated-look-like.html
If you don't have a reason for why to use it, then don't. And I mean it. Seriously. If you're just interested in what it might offer, then starting with [Java EE at a Glance](http://www.oracle.com/technetwork/java/javaee/overview/index.html) might be worthwhile.
Check out https://github.com/codecentric/spring-boot-admin. It is a great UI on top of most of the Actuator endpoints. 
So many troll in almost every Spring related post. I wonder how much they get paid by Oracle because I want to sign up too if the pay is good.
No, but it's always fun to say
Sometimes I'm amazed by how little of substance can be said in an article like this. Does anyone seriously find an article like this valuable and informative? About the only thing useful in the article is the quote from Martin Fowler! Oh well. I guess I'm a bit too sceptical. I never see any of these articles answering a few fundamental questions with regards to the use of microservices, especially when it comes to orchestrating (read: main loop, code flow, order of execution, passing results, etc) many microservices to actually create an application that does something that's not "micro".
But then you fall into a cycle of a fix breaking a fix breaking a fix breaking a fix, unless your systems are so small that it's possible to comprehend the entire system and fix what are mistakes rather than misunderstandings. If your system is that small then your dev team also ought to be really small which avoids all the problems I brought up anyway. In the meantime your users are pissed off because the system can't stay fixed, your support reps are pissed off because they have to say the same thing to a bazillion angry customers over and over again, your ops (and devs) are pissed off because the 3 am phone calls won't stop. Pretty much the only people who are happy are your testers... but they're not, because they're unemployed, since you don't seem to need to hire any. Or you can do proper QA and have happy customers.
Distributed transactions, anyone? That is the biggest problem in the microservices architecture and I've never read a single article of this "a buch buzzwords/trends article" solving this kind of problems. Martin Kleppman said something about it: https://speakerdeck.com/ept/transactions-myths-surprises-and-opportunities?slide=76
I’ve been working as a Java developer for almost 20 years now, and I have never worked with JEE, J2EE (and whatever else it has been called over the years), despite working for companies that have millions of customers.
I really would not like to work on your systems!! Just Listen to yourself! - It is you, *you* that think that its good throwing whatever a developer wants into a war is a good thing. You who wants weeks of QA / testing. You who wants the long risky deployments. Honestly, I don't have the problems you have, or suggest that I have. Maybe its because the system is run for programmers, by programmers. Everything we do is to increase maintainability, refactor out old code, make it easy....EASY to maintain. The programmer is number one. Everything else is secondary, including business requirements. Maybe......just maybe you might be doing it wrong? 
What has your experience been?
10 years experience.....! 10 years ago, java 1.5 was the latest. Maybe they want someone who knows about that. 
Oracle sacked all their evangelists, didn't you know? Maybe its simply because we're just fed up of Spring.
Why?
What in the hell are you talking about?
Whoever said weeks of QA / testing? We're talking about a few hours to run automated tests, overnight tops. Bug report comes in, dev marks issue in progress, dev submits the change, dev marks resolved, CI tentatively merges in the change, marks issue "in QA", runs tests, if the tests succeed then begin automatic deployment, if the tests fail then CI re-opens the issue; if deployment fails and the deployment is rolled back then the issue is re-opened. Simple. Customer sees clear progression from open -&gt; in progress -&gt; in QA -&gt; resolved. I fail to understand how you claim that the programmer is number 1 on one hand and on the other prevent programmers from bundling in the dependencies they desire. Deployment times, although longer than your "quick" deployment times, are not perceived as long (which is what is important) and strict Maven builds made dependency hell ancient history. Disk space is cheap. Developers have tons of freedom. What's not to love?
Why assume it's Oracle? They should be happy about any popular framework using their language.
don't just "save" files but trigger a project compile "Make".
I'm honestly surprised that's the best answer they've come up with. There are several 'distributed transaction management' solutions/frameworks/patterns out there. 
That makes sense. I understand what you're saying now.
Yeah, but none of them are really easy or that straightforward, especially as you continue to increase the number of broken out services that need to engage in the transaction. Yeah, It's doable, but the pain involved is often not worth it, particularly when you could still write more of a monolith application that just encompasses the the entire transactional boundary. Services that are more ancillary to the actual core transactional business behavior are better candidates for breaking out as a microservice. Things like calculators and finders and such, which themselves don't execute updates, but can return some result back to the core service which then is part of the transaction.
Your personal experience is probably a little outside the norm but it is not shocking. There are a lot of different ways to build Java Applications. Just because Java EE is the most popular does not mean that everyone uses it. Still as a Java dev it is good to at least be familiar with the top two frameworks out there (Java EE and Spring). I am curious what you have used? Do you use Hibernate?
That simplification will make a newbie think they need to 'learn EE' now that they've made it through codecademy's java course if they want to serve a webpage using java, because that is 'server' and not 'desktop/client'
i've never tried
Not sure if it's "great" per sé, but myself and a few others started work on a JavaFX application the other day. Most of the interface that you currently see was designed within the first day. It was my first experience with the framework, and honestly the biggest takeaway is that it's a much nicer development experience and results in more modern-looking programs. The API makes more sense, and it's less effort to implement most things (e.g. GUI elements like tabs, lists, etc., dialog boxes, menus and menu-related features) than in Swing. Also, FXML makes it a lot easier to design the general interface than writing it out in Java code, and at the same time meshes really well with the implementation code in an IDE. Relevant links: https://github.com/LapisBlue/Nocturne http://ci.caseif.net/job/Nocturne (precompiled builds) Side-note: I'm not trying to plug the program, since it's still in its *extremely* early stages, and very niche and therefore unlikely to appeal to most people anyway. Aside from this, the only other example I can give off the top of my head is the Minecraft launcher, which actually has a very intuitive interface and is very nice-looking.
Everyone seems to be using Netty. I gotta get on that.
https://github.com/chriscamacho/LogicEdit a tad hacky but has curvy lines to wire things up with - which always looks messy I mean cool....
Having a strict syntax is nice for more complicated applications, but one of Boots main strengths is being able to quickly bootstrap applications. Most times I just want to do ${attribute} and pace it to some javascript code. Obviously, for large applications Thymeleaf can be beneficial but it doesn't make sense as the default.
Take a look at https://www.vinumeris.com/lighthouse and watch the video. Or read https://www.vinumeris.com/lighthouse/usage (disclaimer: I wrote it, took about 7-8 months)
Spring Boot is great for startups but there's a legion of us out there waging war's and ear's and the docs have all shifted to Spring Boot. Many of us are still dealing with heady Spring config files from years ago. A tool to convert the mess to Java config would be nice. At least, bring back the war/ear docs for WebSphere, WebLogic, JBoss, etc.
I have no idea what that does and it doesn't look like Java to me.
He seemed interested in the advantages over Swing, and wanted to see a practical use of the framework. I was just providing the best example I could at the moment since I'm not aware of too many programs which use it, and explaining my initial impressions.
[**@craigday**](https://twitter.com/craigday/) &gt; [2015-11-12 01:20 UTC](https://twitter.com/craigday/status/664613587084664832) &gt; Here’s a screenshot of our Trading Platform (TradeCentre) written with \#javafx :) &gt;[[Attached pic]](http://pbs.twimg.com/media/CTkuh-BUEAAZekY.png) [[Imgur rehost]](http://i.imgur.com/sFRjfRU.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Inspiration: String Class https://docs.oracle.com/javase/7/docs/api/java/lang/String.html Method: toCharArray() Converts this string to a new character array. Cool! Did not know that one existed! 
https://jaxenter.com/netbeans/developing-nasas-mission-software-with-java has some screenshots of some tools NASA uses developed in JavaFX, saw a demo of it at JavaOne and its pretty cool stuff
Try String.CASE_INSENSITIVE_ORDER: Collections.sort(stringList, String.CASE_INSENSITIVE_ORDER); Useful...
:D TIL
So you're a second rate Java developer then? Coming from being a Perl kiddy and all.
That's very useful, thank you very much!
Hmm. Usually I use it just like a `Map`, except I'm dumping data into it from multiple threads. This comes up a lot in the context of HTTP servers. Users are making HTTP requests and your app is handling them all in parallel, and you want to collect some information from the requests into a map. In those situations, `HashMap` simply doesn't work and `Collections.synchronizedMap(new HashMap&lt;&gt;())` is often too slow (because if one thread is accessing the map, all other threads that want to access the map are blocked). One method I use a lot is `ConcurrentHashMap.newKeySet()`: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#newKeySet-- That's nice if you need a `Set` instead of a `Map` and you still want the "concurrent" aspect. `computeIfAbsent` is cool if you're grouping data: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function- The class javadocs mention an example of making a histogram with `ConcurrentHashMap&lt;String,LongAdder&gt;`. I suppose you could also make a sort of concurrent multimap like: ConcurrentHashMap&lt;K, Set&lt;V&gt;&gt; multimap = new ConcurrentHashMap&lt;&gt;(); // some time later... multimap .computeIfAbsent( someKey, k -&gt; ConcurrentHashMap.newKeySet()) .add(someValue); removing key+value entries from the multimap might be a little weird there though, if that's something you need to do.
sun.misc.Unsafe - cool stuff :)
Nice to see FAF is still alive and continuing
Possibly the same question: When do I stop hacking stuff like Weld, Hibernate, Quartz into SE, and start using EE? Where is the point that the effort is not worth it?
It does not. Using literals, and thus `int` values as per the title of the "article", 1000 == 1000 will always return true. It's only when using `Integer` objects that the `IntegerCache` object instances come into play (for small values).
Wow, this is just like 2004 all over again!
Without a doubt. Mark should open the next keynote with this discovery! :P
Those are all eclipse plugins? Unfortunately I don't use eclipse. But lists of good software are allways welcome.
Java SE is the core language. It's THE Java. Java EE, on the other hand, is a package that contains JavaSE at it's core and then shovels a mountain of functionality (built using that JavaSE core) on top of it. That functionality is what allows you to build websites, for example, without having to rediscover on your own how to handle the HTTP protocol in Java. You just use a component designed long time ago by someone else and packaged in the JavaEE package (Servlet in this case). So, JavaSE is basically Java, while JavaEE is a package of "solutions to common problems" (in a very simplistic approach) added on top of it. When to use one over the other? It's one of those questions that is hard to answer but it's easy to just *know* the answer to once you get more experience. Use JavaSE for your fun projects, small desktop stuff, etc. and optionally suplement it with proper dependencies that solve some common problems - no need to reinvent the wheel, unless you do it for the fun of it (or to do it better). Use JavaEE once you start approaching problems that you feel "someone must have solved already, I mean, it's used all the time!" and that "there must be a package that makes all of this complicated mess easy to accomplish". Nothing is easy with JavaEE, but it definetly is easier to learn it than to try and accomplish what it's doing on your own.
" The relevant piece is the servlet, which is too low level for web development." Myth. I would rather, *by far* make a raw servlet + JSP web app, than use something like Struts. And, honestly, they are not as 'low level' as you think. 
No. I'm not angry at all. I'm just pointing out that the headline seems a bit misleading.
It's not included in the CE, which is a shame.
While Spring aren't developing new versions of this there is the Groovy and Grails Toolkit for Eclipse : http://spring.io/tools/ggts/all 
Yeah that's right. Luckily I am sitting next to someone who is even less competent at Java, so it masks my failures. 
Well, I learned something. I didn't know about the IntegerCache, although I'm not sure I would've ever ran into it.
Java 5 was released – and with it the autoboxing feature was introduced, which is used in the article's example code.
Damn, they way you wrote that, I thought this meant that equalsIgnoreCase was a built in static function of the String class, hopefully offering null safety for input arguements. Was thinking "How did I miss this!?" Nope. It's an instance method. I'll stick to commons-lang3 and StringUtils.equalsIgnoreCase(String str1, String str2) to ensure null safe, case insensitive, String comparisons. Similarly though, since Java 7 you can use the static Objects.equals(Object obj1, Object obj2) in order to perform nullsafe object comparisons, instead of obj1.equals(obj2) which would throw a null pointer exception in the case that obj1 is null.
I like JDBC. It's rather low level, yes. But it was very visionary when introduced in 1997 and it's really timeless, too. You can build great APIs on top of it.
- Yes, there are some features that exist only in Eclipse. - Yes you know them and you're missing them. - No, you haven't discovered all of the features that IntelliJ has and Eclipse doesn't. - Yes, you have come to a conclusion after 4 days, unwilling to review that conclusion. It's OK. It's hard to rewire old habits. I'm still using Eclipse after ages of working with PhpStorm and sometimes IntelliJ for Scala and some Java 8 type inference stuff that [takes decades to compile with Eclipse](https://bugs.eclipse.org/bugs/show_bug.cgi?id=476718). I don't think it's IntelliJ's fault that I haven't yet switched. I've used Eclipse since the early 2.x versions. I'm just too old to learn this "new stuff", I suspect.
Of course it's still relevant from a business perspective. But in the hearts and minds of developers, is it still relevant? Every time I hear about new or upcoming features in EE, I think to myself, "Oh look, another feature Spring has had for years". Nobody is really excited by new EE releases anymore. Any resemblance of such is developers required to use EE at work who breath a heavy sigh and say "finally...".
Pfft, that's nothing - using the Integer cache you can [make 2 + 2 = 5](http://codegolf.stackexchange.com/questions/28786/write-a-program-that-makes-2-2-5#answer-28818).
JHipster may be an option.
It's not a mystery. There are well-established solutions like two-phase commits (taking locks), transaction logs, eventual consistency, CRDTs, idempotent actions, event subscribers with broadcasters that support replay in case of failure etc. And they're well established, because that's how transactions actually work in your favorite database, but the mechanism is implemented for you and you're just using it. When you do cross-microservice synchronization, that luxury is not available due to encapsulation. No well-designed object or service would just spill its implementation guts to 3rd parties to run raw transactions against, that would be very short-sighted. Of course, you'd want to maximize your use of that "luxury" as much as you can, to simplify your code and avoid mistakes of poorly handled edge cases, this is why microservices are typically designed around consistency boundaries (much like aggregates in DDD, they are an analogous concept). There is such a thing as a microservice that's a bit too "micro". The commonly heard meme that a microservice should be up to 100 lines of code is a hilarious example of that. But don't forget that most real-world services out there work through distributed, eventually consistent transactions. No external client is running BEGIN TRANSACTION directly against your bank's MySQL server, instead, it's handled through a custom process that allows entities to cooperate in a transaction that spans parties all over the globe. It works fine, and there are a myriad available techniques to handle exceptions. As usual, everything depends on the specific issue to solve, so if you want, describe an example.
But is it really required? I mean, if I funnel each access to a simple HashMap through a synchronized(sameLockInEachCase){}, doesn't this have the same effect?
Ahh ok. Fair enough. Servlets on their own are not enough, and need a 'view' layer. But, servlet/JSP is good enough to stand on its own as a built in 'framework', even though It might not have all the bells and whistles of say Spring MVC
Very well written article with some excellent original research to back up the claims.
I didn't know that javafx is on the decline. Quite on the contrary, I thought it only started and would grow well rounded and better years to come. Picked it up with java 8 and was finally satisfied with building GUIs for applications + Lamdas &amp; Streams. Breaks my heart a little bit. Thanks for the write up.
By that definition core will be defined by the project in question. If I am not using java.net packages then that too is not in core according to your definition :) Backend stack is still relevant as data supplier and business rule engine / business logic executioner.
I evaluated JavaFX for my desktop app's UI last week. The Modena skin looked just bland compared to native OSX widgets. There was a 3rd party extension that would have provided the OSX look, but there were some issues with it and I didn't want an emulated approach. I switched to SWT and the app looks as it should. Except, now I need to hack the application menu and the app icon because SWT provides those on its own and the defaults are not easy to modify. I guess there's no silver bullet, but at least for me the native widgets were a definite requirement.
[Context](http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
Ok, so we have a sample size of only ~1.3k JVMs, and all of them are Plumbr users. Which rules out most enterprise environments, as for example my workplace would never allow our datacenter to send random data to some external 3rd party performance analysis service. I don't think this gives any meaningful results.
Completely correct remarks, the sample size was 1.3K JVMs and all were using Plumbr On Demand offering. Plumbr disclosed the information in the very beginning of the post to avoid any kind of confusion. However - can you point towards a more relevant dataset being published from real environments? By real environments I would mean that the data is gathered from monitoring the real deployments and not based on surveys/questionnaires? If yes, I am all ears. Full disclosure: I am affiliated with Plumbr.
&gt; "Oh look, another feature Spring has had for years" Like no-XML? Or contextual injections? Or portable extensions?
You use TLDs instead of tag files?
Awesome explanation! That's the things we should be posted to reddit, not language/framework wars :D Thanks for spending your time writing such a big comment!
Great tips, thanks. Any idea how to remove websocket capabilities in spring book's embedded tomcat? 
Did you read and follow the instructions in the **README** file inside the compressed archive?
&gt; AFAIK World will burn if they get rid of it ... :(
The data set we published did not contain any major outliers, there was no single shops with 200 JVMs connecting to a single DB vendor biasing the numbers. Not even close. But indeed, with a so small data set, having such concerns is a valid point as examples like this could skew the results significantly. However, I do not agree with the "I do not know" part being better than data-driven approach to verify or disprove the gut feeling one can have. Indeed, the data can and will get more precise over time. Having more data points a year from now will give a stronger base to back the claims with, but just sticking with "I do not know and I will not do anything to change that" is not the approach I am used to. 
I didn't see how old this was until I read this bit: &gt; Even on my vanilla Pentium/100 using the vanilla Sun JDK, it was obvious that Java was being stretched to its limits by this implementation of the LZW algorithm. Heh. Good ol' times :)
Try adding &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; To the dependency that contains tomcat (probably spring-boot-starter-web) It didn't save me more than 0.1 sec tho...
Yes, just like jstl.jar &amp; friends
Yes, I like Jetty too. 
I suspect that across all of the industry, we would have *very* different results. This reminds me of the surveys executed by ZeroTurnaround, which came to similar conclusions that I personally wouldn't confirm, living more in an Oracle world. I think that this is still a better way to assess popularity of RDBMS: http://db-engines.com/en/ranking
It would be helpful to get some actual explanation about why it's ok to do these things and what they actually affect. What does the jar scanning actually do and in what situations would you not be able to set `tomcat.util.scan. DefaultJarScanner.jarsToSkip` to all jars, for example.
I think you meant the signed 8-bit integer -1 is equivalent to the binary representation of the unsigned 8-bit integer 255. 
Good catch! I propagated the article's typo forward.
Http://sparkjava.com is a great place to start.
Java is typically used on the server side, where javascript is used on the client side. Something simple like a tempurature converter really doesn't need any Java, I would suggest just hacking it together in javascript (javascript has nothing to do with java, its an unfortunate name, javascript has had many happy accidents in its life time, you'll learn to hate it, love it, hate it again and finally just accept the fact that your feelings are mixed). You can run Java in the browser, but this technique is outdated and you probably shouldn't waste your time on learning how to do it.
I'm partial to [Apache Tapestry](http://tapestry.apache.org/). Try out it's [20 mins quickstart tutorial](http://tapestry.apache.org/getting-started.html).
Why do you recommend Struts 2 over Spring for a beginner? I started with Spring as a novice and I dont think it is hard. And for a beginner, I'd recommend a simple Servlet. It is the most basic structure for web applications.
The question specifically asked for java web development..
Peeling back the onion? That's easy to say once you understand spring and can look backwards but not so easy when starting out. Cryptic error messages and conventions that abstract away functionality needed for understanding will make for a very difficult learning experience, I've been there.
[removed]
Which can mean a bunch of things depending on your experience and context. He said he knew html/css/Java, its a strange way of saying it so I suspected he didn't have a lot of experience.
it's not really Java vs .NET. It's more the JVM vs .NET and C# vs Java. The JVM has Jython, Groovy, Scala, JRuby, Kotlin , Closure, etc.... 
I never thought JavaFX was bad. Desktop Java apps are on the decline and some super-duper Java gui library isn't going to cause a renaissance in Java thick-gui apps.
I've been a lot of places the past several years. I see Spring and even JEE in places but never Struts or Tapestry.
You can use Grails for the backend and Angular/React/etc for the front-end. Grails 3.x has a web-api profile that leaves out all the view stuff.
Play! Framework (big business framework, don't let the name scare you) and Lift are two excellent big frameworks too that do the work in two entirely different ways, but are great at their styles. You should look at them as well, both are great, I've used both and each have their strengths. 
I think we can all agree that we aren't going to switch to .NET just because it is OS. However, some of us might start using .NET on Linux just to blow the .NET teams' minds :)
If it's for an assignment, stick to the teacher's frivolous standards. Otherwise, do what you want. You're the programmer
The framework my company uses is typically JSF based. You could get a simple start with any of the tutorials that catch your eye with the google search "JSF Hello World"
And that's how we got geocities....
Moreover, after doing all of that you may very well come to the conclusion that you don't really need much more, depending on your needs. And you absolutely may not be wrong to conclude that. 
Generally you can follow any other [desktop HIG](https://en.wikipedia.org/wiki/Human_interface_guidelines#Examples_of_HIGs). [Swing layout guide](http://www.oracle.com/technetwork/java/hig-136467.html#55417)
As much as I love jhipster, I think it would be overkill for a simple project such as the one the OP mentioned.
Try out the Ninja Framework. Quick and simple. Only need maven and a jdk. Should provide a good learning experience.
I didn't understand why you guys kept preaching to use just servlet for web development. I was not sure whether it's trolling or just pure ignorance. I mean you could use servlet to develop web app, just very painfully, using response.getWriter().println() for all the html. That's why servlet is too low level for useful web development. I mean you could use TCP to handle HTTP to do web development, but do you really want to do that? JSP is not servlet. It's a template engine. It uses servlet underneath. Most of other web frameworks, like Spring MVC or Sparks, also sit on top of servlet. Asking question or making statement on using servlet for web development is pretty nonsensical, because all these frameworks use servlet. It's like asking, do you use TCP for web development? 
JEE 7 is my jam, baby. Well, with a little bit of Apache DeltaSpike mixed in. For any CRUD-heavy workload, Apache DeltaSpike Data repository classes plus JSF 2.2 makes building CRUD pages incredibly simple (especially if you use template composition directives in your Facelets markup). If you need to expose that same data over REST for outside clients, JAX-RS endpoints are just a couple of annotations and a method call or two away. The JEE steering group goons have spent three versions now on improving quality of life stuff, and it really shows. Hell, even the proposed MVC module for JEE 8 looks cleaner than anything we have in Spring 4 right now. I'm going to go out on a limb and say "highly inappropriate" for a total beginner, though. Heh. "What? You want to develop a Web app? OK, first download this 200 MB .tar.gz file, install this full-blown application server, configure its management interface, oh and by the way, you have to change the password from a command line console... OK, now you have to enable CDI, and don't read those tutorials and CodeRanch/StackOverflow posts from before 2013 because you aren't supposed to use @ManagedBean anymore and everything under javax.faces.bean is deprecated. Oh, and you can't use raw HTML and Javascript in here because the server thinks it knows best, so if you really need to do weird shit, you're going to have to write a custom component, which is easier than it sounds, but god damn if it doesn't sound like getting raped by a pack of rabid dingoes." There is... A slight learning curve.
I got that feeling from it, too. Unfortunately, when we tried to integrate it in a Java EE 7 project, we couldn't get our EJBs to inject properly, so we had to drop it in favor of a mix of Spring MVC and JSF (for different parts of the application suite). This was under an EAR deployment, and the EJBs were in a separate subdeployment, and for whatever reason, we just couldn't get Vaadin's CDIServlet to see the CDI-injectable classes in the other subdeployments under the EAR in WildFly. It was a sad day; our frontend developer had rolled this absolutely gorgeous interface using Vaadin widgets, all over the course of maybe two weeks.
Apart from this framework here, there must be at least 10 others that use the exact same programming style, e.g. [Spark Java](http://sparkjava.com/) Someone should write a feature comparison list of all the available options in these frameworks.
and rather confusing for a newbie. 
No one is arguing that Java is popular at the moment. However, Java is high there thanks to Android and the continued Java EE traction. I wouldn't trust the reliability an index that puts Delphi/Pascal at number 12 at this point in time. I loved Delphi back in the day and Pascal was one of my favorite languages of all time. According to Gartner etc. Java had 9M active developers (people actually writing code in Java not people who know Java) a few years back. Its now down to 6M (sorry I don't have the link, I saw it in a PR from Xamarin), this is troubling. Java is still on top because at this very moment in time there is no real alternative. JavaScript etc. aren't ready. This can flip instantly just like any game of chess.
Yeah maybe, I just like Eclipse,it is a love hate relationship
That's problematic. The .net CLR has many things that don't translate well to the JVM and visa versa. I worked on a [Java bytecode translators at Codename One](https://www.codenameone.com/) and while it is technically possible to translate between the two. Its difficult and inefficient. E.g. unsigned math exists in CLR but not in the JVM.
I'd recommend (and have recommended in the past, and will recommend again) the [Play! Framework](https://www.playframework.com). Make sure to include it in the list of frameworks you evaluate.
For an incremental step-by-step tutorial about building Java/JPA/JSF web apps, see http://web-engineering.info/JavaJpaJsfApp
Its kind of obvious why people get put off using java - there are so many different options. I guess that is both the ecosystem's strength and weakness. To add to the list, download an app server, eg wildfly. Include the java ee api as provided maven dependency. Create some endpoints, build your war or ear file, copy to deployments directory and start you server. Or use google app engine, with java its a really nice PAAS : https://cloud.google.com/appengine/docs/java/gettingstarted/introduction 
I never knew there was a competition?
I think one thing to add to this list is how JSP works, and how their interaction with servlets can be used for seperation of concerns (controller logic in the servlet, view in the JSP). Putting all the HTML into the servlet, though possible, might leave a beginner looking for a separate framework straight away.
So Agree. I notice that someone mentioned 'Spring Boot. Great tutorials.', and was up voted to 44..... This is a beginner... If they start using Spring boot, having to set up gradle, setting up using java config the @SpringBootApplication annotations, setting up controllers, requestMapping.... how the controller interacts with the view.....setting up the view as a thymeleaf template..... And, when its all managed to get going, it ends up a multi megabyte jar file, which is difficult to integrate with an existing website. Compare this to doing a hello world in PHP, where typically it only takes 1 or 2 .php files, dropped into an apache HTTP directory. PHP is orders of magnitude easier. Java can be easy also, but you need to avoid these frameworks to begin with. 
That surely seems to be an interesting website. domain submitted from|count|% :-|-:|-: [vmlens.com](/search?q=%28and+site%3A%27vmlens.com%27+author%3A%27ThomasKrieger%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|5|100% subreddit submitted to|count|% :-|-:|-: [java](/r/java/search?q=author%3A%27ThomasKrieger%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|5|100%
I've not used Vaadin, but I am a big advocate for GWT. However GWT is going through a transitional period at the moment. Version 2.8 is slated for release next month, which is bringing a new system called JsInterop that is supposed to make wrapping javascript libraries much more straightforward. When version 3.0 follows, they are streamlining, removing a lot of old core functionality like the widget library. The idea being that we can use JsInterop to interface with much more modern libraries like Angular and [Polymer](http://vaadin.github.io/gwt-polymer-elements/demo/#gwt/JavaApiWidget). So we get all the benefits of modern javascript tech, as well as the added benefits of a type safe, OO language, and compile time optimisations. So I definitely recommend GWT, but maybe wait for version 3
Yeah, JVM cs CLR, Java vs C# and .NET vs Java SE libs/Java EE. 
The problem with the Pascal rating is the up arrow more than its actual position. If this was maintenance only it would be declining. Also as a guy who used to do a lot of assembly I find that ranking odd. I noticed Oracle didn't highlight the 9m number as much in the past year. I meant flip against the Java being in the first/second place in all the language rankings. Our company is hugely based on Java and marketed as such, this would be horrible for us.
JSF2 can be used for that kind of app. This tutorial helped me get started. http://www.coreservlets.com/JSF-Tutorial/jsf2/
"No-bullshit" is in itself a bullshit term.
The JVM does have an official and decent javascript implementation. But I agree with you. Even if it is Scala, which I don't particularly enjoy, we should have an official JDK-included, Oracle-blessed language. I'd love to have an official F# port....
Building it isn't that much of a problem. Maintaining it, over years and years . . . that is a problem. Refactoring becomes a dirty word.
If you are a student, you can get it for free. Otherwise you have to pay for it. My company pays for enterprise licences. Well worth it. 
My company uses eclipse but it might be worth getting it to try it out. I've never used anything other than eclipse or RAD.
Begin with Java EE and the plain technologies it includes like JSF, CDI, BeanValidation and JPA. Then add PrimeFaces and OmniFaces, and if needed DeltaSpike. Best. Stack. Ever. :)
APR c-code really saved me when I was doing some filesystem work at HP. This looks good too.
What version of Spring did you start with? Annotations or xml? I know Annotations is sexier than xml, but many projects in enterprise are done with xml still, and they refuse to change what is not broken.
Yeah, learn the hard way first, then learn the easy way. If OP's intention is to find a job with that stack, I'd say he can gain a lot of knowledge doing that.
To be honest I've not really seen a lot in Java or any other JVM language for that matter. The few things I have come across are the following http://neuroph.sourceforge.net/news.html http://www.simbrain.net/ https://github.com/ron-noble/Scala-Neural-Network It seems most AI stuff is done in Python, using Tourch or something similar. There is obviously also the new TensorFlow framework from Google as well. http://www.tensorflow.org/ https://github.com/aymericdamien/TensorFlow-Examples
You can write Delphi and deploy to the iPhone... Given these facts, I think that whatever happens, "horrible" is postponed for another decade or two for you. Don't worry.
Because it's not very good.
Just saw http://github.com/briljant/mimir seems pretty new and untested though. 
I don't know why you're getting downvoted, GWT is an excellent framework that also allows you to leverage java expertise.
It's not very good because it's such a lightweight solution. Not everything is going to be production-ready development.
Spring Boot packages tomcat inside of the jar, so that's why it is as large as it is. I believe you can package spring boot applications as a war file, though.
I wasn't pointing out that OP should stay away from spring, I was pointing out how the "it's not very good" comment is insanity. Spark is a light weight framework that would be good for OP, and him saying that comment doesn't help this discussion thread very much. No where did I say that OP should go to spring.
Sorry, misinterpreted your comment. Thanks for clarifying!
&gt; It seems most AI stuff is done in Python, using Tourch or something similar. You mean Theano. Torch is for Lua (though many parts are written in C/C++).
https://github.com/guoding83128/OpenDL
TensorFlow seems to be cpp and python. Curious why they didn't use Go. Java must not be big at Google besides (some of) Android.
thanks for sharing, but method marked with @After runs after each test, so it's not very useful if you need to test more than one case. Also @After is not commonly used to do asserts.
Although I agree with you, that really depends on the container. *Disclaimer: I say this as I currently feel like pitching Glassfish out the window I've used Spring in the distant past (back in 2007-2008) and while it was LEAGES better than raw struts plus jsf, it still felt a little restricting. For the purpose of understanding webapps in general, learning j2e containers is a good idea. For shrinking the learning curve, Spring is useful.
Awesome. Looking forward. Be sure to link the comparison, here! :) And thanks for the nice words. Cheers
Java is very popular for AI work. For Deep Learning in particular, see DeepLearning4J. There are plenty of other AI related libraries for Java though. See: http://mloss.org/software/language/java/ Mahout for Hadoop and MLlib for Spark are very popular if you're looking to do machine learning at scale. OpenNLP is pretty popular for Natural Language Processing. I don't know of any Java native stuff for computer vision, but I think there are Java wrappers for OpenCV if you're doing anything in that area. 
Thanks! The main difference is that Rapidoid is a web server - [unofficially the fastest Java server in the world](https://www.techempower.com/benchmarks/previews/round11/#section=data-r11&amp;hw=peak&amp;test=plaintext), and a web framework which provides a high-level API, also a HTML GUI framework, and much more... On the other hand, Spark is just a wrapper API on top of other web servers. About the SELECT - yes, the forms can generate a SELECT, as well, e.g. from enum. I will provide more documentation about the GUI components during the next few days...
Scale meaning network connections involved I suppose. I'm trying to stick to simple multicore for now. Keeps things simple. Computer vision may need more beef, but the basics can be done on 32-bit two-core ARM.
Well said. I'm getting back into Faces and they are finding ways to improve it for sure, same for JEE. Spring's new Java config is also nice so really can't go wrong with either and yes, JAX-RS makes REST pretty easy. I was a fan (still am sort of) of Spark Java and it's nice for very lightweight sites.
Bitsquare a P2P Bitcoin exchange use JavaFX: https://bitsquare.io/blog/bitsquare-v0-4-payment-methods-and-arbitrtion-system/
&gt; start with SQLite No, no, no! This is Java land. You don't want to depend on a C library.
I use Weka all the time for both work and algo-trading systems I write on my own.
I've always thought of Spring as a very heavyweight framework, is that not the case with Spring Boot?
Subset of AI, for machine learning I've implemented my own library JSAT which has some multithreaded algorithms https://github.com/EdwardRaff/JSAT/tree/master . Made from my frustration with Weka. 
I knew nothing about this, thanks! I love social interaction..when I'm safely behind my computer.
I don't know much about the average person, it seems. To me, there is no good reason to use the browser plugin, and there are lots of good reasons *not* to use it, e.g. I once visited a webpage that supposedly had free Minecraft on it - I just wanted to check it out, I already owned it. When I visited it, it *immediately* began to *install files* on my harddisk in the Minecraft tree. No request, nothing. - Ok, nowadays the browser developers have reacted and don't allow the Java plugin to run without confirmation, but to me it's only a significant improvement that I am asked now whether or not to step off a cliff, but it's still something I never want to do. There are friendly uses of it out there, but I have never needed them. And because of the security problems I can only recommend that nobody uses it. Btw., all those Java updates you'd have to make every month would almost exclusively be necessary because of holes in the sandbox that have been found and fixed. Another reason not to start with that avenue in the first place. Btw., I am convinced that this Minecraft incident was *not* a security issue that they would fix: That is *normal behavior*. How sick is that? (I could be wrong, but I don't think so.) The JDK's JRE also doesn't install the update-nagger. There are lots of good reasons to install Java, all of which in the form of downloadable software.
&gt;Deep Learning in particular, see DeepLearning4J Ehh, no - not really for Java. For Deep Learning the python ecosystem has put out a lot of much better options and tools. I love Java, but for work - almost everything with Neural Nets we are doing in python. 
I have to say, when it comes to machine learning, NN, and AI, the Python platform is the absolute winner. It's difficult to start a project that has to do with any of the above, without stumbling upon tons of tons of Python libraries. The Java platform offers a just as equally large number of interesting and useful projects, yet nothing like a good beginner's guide for Java developers. I have been looking for a bit of time recently, in order to sit and compile one such guide of my own. Do make sure to check out the links posted here. All of them will be really helpful.
You are incorrect sir. IntelliJ is like soothing warm blanket fresh out of the dryer on a brisk fall morning, and eclipse is like a syphilitic condom wrapped around a frozen bottle of Sriracha being forcefully inserted into your rectum. In all seriousness, eclipse is simply a crap IDE. I gave it a very serious try a while back for about 4 weeks, really trying to see if I could use it for work. In the end I bought another license for intelliJ out of my own pocket (no reimbursement from my company). You see all kinds of info going from Eclipse to IntellJ including (the most important for me) keyboard mappings, but you almost never see anyone going from IntelliJ back to ecli
I don't know how far you've gone into Spring, but spring offers Spring-Security that takes care of the nitty gritty for you. It will allow you to configure pretty much everything from the login page variables to specific paths you want to secure with optional roles/groups. The only advice I would give you is to chose your password encoder properly (BCrypt), since storing passwords in plain text is plain dumb. (ha-ha, see what I did there? *stands in corner*) Take a look here: https://spring.io/guides/gs/securing-web/ **edit**: if you want production quality asap, don't build it yourself. At the very least I would use some out of the box solution with an active community to patch security flaws quickly, while you learn how to custom build your security layer in your personal test bed that isn't getting merged with production.
&gt; There isn't single best IDE in the world. Every IDE has pros and cons. There's soooo many people – here on Reddit and elsewhere – that just don't get this, it's mindboggling. Every tool has it's advantages over others, it all depends on your use case. Some people like IDEs, some like text editors, others use vim. Some use Windows, some use Linux. Just use what you want &amp; gets your work done. 
Perhaps she/he is locked into the IDE by other factors and can't switch. E.g. the project I'm working on uses a custom (company internal) Eclipse plugin for code generation.
I highly recommend https://www.owasp.org There might even be local chapter where you can ask questions and see free talks. 
I came here to say that haha! I started with Eclipse, soon tried NetBeans and IntelliJ and ended up sticking with IntelliJ!
Don't feed the troll: /u/kevinmarenger
Spring MVC is a web framework. It is really more of a Model, Controller framework since it is not offer much for the view. It is very complex to set up and work with. Spring Boot is sort of an additional framework that attempts to make Spring easier to use. 
If you have the option to changing JVM's from hotspot then the most secure JDK on the market is Waratek's AppSecurity for Java. It implements Runtime Application Self Protection. In a nutshell it allows you to run your JVM in a non permissive mode protecting against command line injection, cross site scripting, SQL injection and more. See http://www.waratek.com/wp-zero-downtime-for-zero-day-vulnerabilities and http://www.waratek.com/wp-applying-knowit-principles-when-deploying-waratek-appsecurity-for-java I believe they also provide a plug-in for hotspot now as well.
It's not a tool you install, but Runscope.com is quite good for testing and monitoring REST APIs. 
Java is actually very popular at Google. A lot of their systems are written in it. 
All machine learning done in python is really just pasting a bunch of cpp and c libraries together. It's great for that task because its native interop is excellent. 
But why, though?
I like rest assured. Very concise with a fluent interface. Not sure of its load testing capabilities though.
Android??
Cheers. What is the the JDK's JRE and where and how do I installed it on a Mac? Aly links to the download page. I find this all exceedingly confusing.
More than anything fat clients and desktop software just isn't as popular as web based clients and web based software right now. And lots of things can be pushed to the web, so only the things that explicitly need desktop stay there and that's not really many things.
I like the JAX-RS 2.0 client. Guide: http://www.adam-bien.com/roller/abien/entry/the_executable_feel_of_jax For SSL read here: https://jersey.java.net/documentation/latest/client.html#d0e5128
Android uses the same syntax as Java but it is not Java. Large numbers of Java classes are simply not in Android. You cannot just swap across Java and Android applications unless they are written to a very specific subset
Java has no more security issues than any other solution. The biggest issue is getting people to move onto the latest secure versions.
Most developers have moved onto browser-based user interfaces (with Java backends) because desktop Java: 1) Requires end users to install and upgrade Java 2) Requires end users to have admin rights 3) Require distribution 4) Requires end users to install and upgrade your program 5) Had image problems of being insecure in the past 6) Looks and behaves differently from native apps (mostly) thereby confusing end users 7) Don't work on most phones There's nothing "wrong" with desktop Java but it became cheaper and easier for end-users and developers to focus on browser-based systems (with Java backends) which also happen to work on mobile phones. Imagine if Facebook or Reddit were desktop Java apps instead of browser-based. They wouldn't have as many users and wouldn't be as successful. 
Minecraft is Java, IntelliJ is Java.
&gt; What's wrong with desktop Java? Deployment, bugs on Linux, deployment, poor native integration, executable .jar (good luck with that), ...
I wanted to interact with it through Java, so maybe with an API
jeeeyuls theme plugin has some really good selections in its theme store (a menu option after you install plugin). 
Mainly it is the fact that the narrative is so bad. A couple years ago the Department of Homeland Security issued a warning for users to disable Java due to a security exploit that allowed attackers to execute code on a PC running Java. Oracle did fix this, but the damage was already done, and left a bad taste in the mouths of users. Mac was praised for disabling the Java plugin for browsers on new computers, and it was popular to hate Java for a while. A lot of people never got over this. Like other people here have said, Java's GUI is not easy on the eyes, and applets never worked quite right. And if you have ever supported a Java program, you will frequently hear customers complaining about installing Java, or the frequent "update java" popups they see. All this made Java hard to defend for client side applications. Server side Java applications avoid a lot of these grievances though. And servers are typically managed by people less influenced by hype.
Thank you very much.
Rofl, you're the one who started this. If you enjoy Eclipse then why make it more like Intellij?
That book is phenomenal by the way, I really like how it was written as small digestible tips too.
Facebook and reddit are social communities. Social communities (forums) have always existed. There's massive advantages that desktop apps have: 1. it allows the consumer to effectively own the software; no one can take it away from you 2. you don't rely on someone else's server 3. better privacy (data doesn't leave your network)
Sigh, package the JRE? The JRE is like 30+ megabytes. Why can't Oracle just compile java to native like Microsoft does with C#?
I think it is mostly due to the fact that in most of the areas Java focuses on, you can have a web app perform as good as a desktop app. What are those areas? Mostly business applications which doesn't require too much of an integration with the local machine it is running on. In those scenarios, having a desktop app is just a burden without any real advantages. However, if you want to create an application that needs to use a lot of resources, uses heavy I/O etc... then you create a desktop application. Now I am not an expert in developing that kind of software, but I think having a language that integrates better with the platform and integrates with the high performance libraries provided by the platform would be a better choice for those applications. Since Java kinda prefers to give up on performance than giving up on portability, it is not the first language of choice.
&gt; Java still suffers from a fear of using C libraries today I find this to be a huge advantage. I built my own trading platform which has dependencies (like a nonstandard database) that are also pure Java, and I can deploy the entire shebang to my Raspberry Pi, Windows ~~desktop~~ laptop, Linux PC, and - soon - an Amazon cloud server, without even recompiling. In fact I'm experimenting with Akka (concurrency package) to scale the thing across platforms. C libraries in any part of this, no thanks.
You can use the vast majority of java libraries on Android. The best java libraries work with both Android and a JRE. This is no different than C on windows vs UNIX.
Java the language, stuck at version 7 for &gt;= 4.4 devices and Java 6 for lower devices. With the upcoming changes in Java 9 &amp; 10, the language, Android will no longer be compatible, if current Google's behaviour doesn't change.
Just wait when they start adopting modern Java features. I doubt many developers will want to keep parallel versions, or give up on the 8 features, or the upcoming 9 &amp; 10 features.
Source? AoT implies no runtime is needed.
I agree with this. Android is Java, and I think mobile dev is just the way people are heading. Speaking of that, doesn't Android use the same dev model as JavaFX? 
Nobody said web apps have to be hosted outside your network. There are tiny, simple web servers that run fine on your desktop, or in a container, that will run that web app privately. Which brings up another advantage of web over native UI: same app can be hosted on web or lap.
For open source, maybe only Avian. I think they also do AOT. RoboVM is no longer an option, as they didn't got the support they expected from the community and accepted the Xamarin's acquisition offer. GCJ is dead since 2009. The other ones I know from name, are all commercial. Also note that the AOT compiler Oracle is currently developing, might only be available with the commercial JDK similar to how Mission Control and Advanced Java features are licensed.
 I don't think it is dead. I think it less popular than it was and it is unlikely to ever be dominant but there will be plenty of us using it long into the future. I still see at-least a half-dozen questions on StackOverflow for both Swing and JavaFX everyday. I use Java to develop desktop applications and I think for my purposes it is the best choice. I primarily earn a living producing reports and papers with the software being a by-product. I use lots of Java desktop applications to visualize data and run tests to eventually produce those reports. Some people in our organization use it but I'd probably still have a job if they didn't. Java desktop applications are less popular than they were because all desktop applications are less popular. I've done a couple of them as web-applications and they seem to be considerably more effort for the same number of features. Online IDE's are fine for small snippets but they pale in comparison to power of the desktop competitors. I think if you want to develop Java Desktop applications you may want to focus on an audience that is less driven by aesthetics and hype and more appreciative of more complete functionality. Perhaps internal application within an organization or a tool for professionals, an IDE or a plugin for one of the existing IDE's. 
In my opinion the cause is twofold. Desktop Applications that where traditionally written in java were meant to be ubiquitous and did not tap into the machine and its resources that much. That means no fast bulk data processing or taxing graphics. These applications at large have moved to the web and so did Java (at least to the backend). Applications left on the desktop are those that interact on a lower level with the OS and hardware and java was never meant for that. Secondly there is a huge resentment against installing java on something else than a server. It is classified as a security risk by many and oracle does not do a good job on changing that image, neither for consumers (by doing stuff like including McAfee and Ask Toolbar in the installer) nor developers. It's really tedious to deploy a java desktop application since you do have limited controll over the environment for example which version is installed if any. So most the time you end up bundling a jre with your Application which (due to Oracles bonkers licensing) is huge. On the topic of speed: "the rumor that java is slow is not true (anymore)" is only part of the truth. The speed of the Jvm has improved vastly and for servers it is great but there are still problems. Due to the culture in the java community to depend on everything and their mother (guava, spring, ALL the apache commons, slf4j, log4j ...) you end up with lots and lots of libs that you have to distribute as well. And these take time to be loaded. Combined with the way java loads classes and the fact that your bytecode only gets fast once it has run for some time due to the [jit compiler](https://en.wikipedia.org/wiki/Just-in-time_compilation) means that even your moderately sized apps will take a while to load an perform well. This is a hurdle especially for desktop apps since it makes them feel slow.
Most Java developers never touch Swing or JavaFX, we write code for servers and web applications. Java is still extremely relevant and will still be after you get Effective Java, don't worry.
You're getting down votes because you posted FUD. Just sayjng "I might be wrong" doesn't change anythjng - the post itself deserves to be voted out of sight. 
Not just the java desktop dead. All desktop based app. dead. by the way if you want challenge try java ee.
Owning the software? software ownership is somewhat foreign to the general consumer and unless its opensource you don't really own the software. When you say that the consumer "effectively" owns the software that may not even be desired by the developer. No dependence on external Servers? Most of the apps that do interesting stuff will want to communicate with a server, most often one that the Software distributer owns. For example for DRM. If that one is gone, you can trash the software. Happens all the time with games. Better privacy? A Desktop app will always run in a more privileged position than a webapp. And since most of them require network access to work you are even less save.
Java is ugly because of the syntax. The fact that devs are lazy is a whole another subject. In my experience, the only people who say Java is not ugly, are people who have very little experience with other languages. Though, I admit, Java 8 with streams and lambdas helps it.. a little..
I don't find Java that ugly and have been coding since the mid-80's. Lost count how many programming languages I have used since then.
&gt; Why can't Oracle just compile java to native? Huh? That's the whole point of Java! It will run anywhere. Do you know how annoying it is to have a C program that has to be recompiled on every different machine that I want to use it on? (well, this is a few years ago, so think WinXP and Ubuntu)
the security issues are in the Security management java uses to execute untrusted code. The main use for that are java applets.
and what else do you need? Isn't Eclipse written in Java too?
Good is a relative term. 20 years and with giant companies backing, its functionality is shockingly limited: no dialog until this year, no docking system, no desktop notification/tray, no OpenGL integration, and no standardized tooling/API to extend GUI designer for custom widgets (something MS has done for a decade).
Not quite. It will run anywhere there's a JRE. The core of which (i.e., the JVM), is written in C++. C and C++ are potentually much more portable than Java, simply because there are C and C++ compilers for many, many platforms to which no JRE has been ported.
Nope it doesn't. AoT has nothing to do with bundling of dependent libraries.
I suppose the desktop applications in general are in recession. Seems that everything is for the web now. But, just to have a better picture, how are Swing and JavaFX compared to other GUI frameworks, Java and non-Java. 
Due to concerns over legacy systems or software, the "latest and greatest" version of anything rarely gains immediate acceptance. The vast majority of Java applications may be able to run on the latest JVM but most don't use the latest language features. This is true no matter the language. Take python for example, since Python 2 still has a lot of traction while Python 3 adoption rate is slow. Eventually Python 3 will overtake Python 2 but no one *really* expected Python 2 to be replaced quickly. I wouldn't expect anything different for Java.
DRM is hardly a success case. It is ineffective and can considerably reduce the value of the software.
Because he enjoys features from most but wants to use spring tool suite?
Exactly, yes. And even if it doesn't appear like a useful language (which is not the case), learning Java opens a wider door on programming methodologies and good practices.
That is not the same thing. Python 3 is not backwards compatible with Python 2, hence why the slow uptake.
Intellij the one java desktop app I do use, is going to be breaking 1 and 2 on your list soon enough when there new license model rolls out.
I think you just proved yourself that claiming facts based on anecdotal evidence is a silly thing to do
Best way to learn :)
Yeah but it's dedicated natively. In other words the the OS is tied to the Android instance. Besides it's irrelevant because the popularity of device use has simply taken away from desktop development. The cause outweighs the reason.
The point is that the standard Android user interface is inherently Java-based. In the context of a discussion of "desktop apps", that's the important aspect. The underlying OS really doesn't matter here.
I use retrolambda and Guava APIs for Android. Nothing in JDK9+ is that inspiring given that I don't trust Oracle enough to accept their proprietary extensions. They're doing a bang up job at making the JCP irrelevant to their own release train.
Thank you for clarifying. I guess I'm not mentally prepared to make a switch for good. But I don't think that post premise is ironic. Why not take good stuff from IntelliJ and put it in Eclipse? IntelliJ does the same: for example default keybinding in IntelliJ sucks so first thing most people I met do is set different keymap (Eclipse, Netbeans, something custom etc.). IntelliJ even contains such settings out-of-the-box: https://confluence.jetbrains.com/display/IntelliJIDEA/Configure+Keymap And don't get me started about all similarities of these two IDEs. Based on response of this harmless blog post most people would stone me to death :-)
It already has, they rolled it out simultaneously with IDEA 15. https://www.jetbrains.com/store/
&gt; All desktop based app. dead. as you use your browser (a desktop app) to write this. 
I'd still like to see a source. That seems like a serious drawback
Oh nice, a DRM upgrade!
Sounds nice. I will try to give it a go. Thanks
Hi, just added the ability to use UnixStream as a library of reusable predicates and functions 100% compatible with the standard Java Stream API: Stream.of("1,foo", "2,bar") .filter(grep("a")) .map(cut(",", 2)) .forEach(System.out::println); //prints: //bar Now, the user has the choice between 3 styles. See [here](https://github.com/benas/UnixStream#3-or-use-functions-and-predicates-provided-by-unixstream-with-the-standard-stream-api)
Not with .NET Native. It basically links the required parts of .NET to your app and compiles it to native code. Only works if you are targeting Windows 10 tho, so it will take quite some time until .NET Native becomes a standard.
Or you could use the free and open-source "Community" edition of their flagship product, that they've been backing for years. Or one of the numerous OSS alternatives. I don't really mind the subscription model, as opposed to buying a lifetime license for a version of a software application that'll be obsolete in 12 months' time. Not to mention I pay less per year under the new model, and haven't noticed any interference from the DRM.
That is not what portability means in terms of Java. Java compiles to *bytecode* so that the same *executable* will run anywhere there is a JRE. C and C++ programs *can* be made portable, in that the same source can be compiled for different platforms, producing different executables for different platforms. But, speaking from experience, to write a C or C++ program that is as portable as a Java program is a huge undertaking. Getting programs to compile between UNIXes is one thing, because there is at least POSIX, but it's not perfect compatibility, if you use the native `libc`. Unfortunately, different UNIXes implement POSIX differently, so you'll need some `#ifdef`s to account for the variation. And you want your program to run on Windows, too? Forget POSIX, better use the Windows API. You'll need some more `#ifdef`s. This is where the GNU toolchain shines. GNU provides a common set of libraries anchored around `glibc` which behaves the same on all platforms where it has been ported. Even Windows has a GNU toolchain, MinGW, so you can get GNU programs to run on Windows, more or less. Hopefully you aren't using `fork()`, because the Windows process model is completely different than UNIX. Thus, in order to develop truly cross platform C and C++ programs, if you don't want to splatter your program with `#ifdef`s, the only practical solution is to use libraries which abstract the platform, like GNU or Qt. And then, you're in the same boat as Java. Except that Java externalizes the problem with platform specific JREs and platform independent bytecode, so at least the executable is platform independent, and you don't have to build separately for each target platform.
None of them are part of Android. Just community workarounds Google's stubbornness to provide proprer Java support. Oracle owns Java and is free to drive its development however it pleases. JCP is actually working better than during Sun days.
1. Widows comes bundled with a decent enough version of Java. 2. Seriously ? 3. ok 4. You can circumvent that
The most common trading platform still runs on Swing.
Android's kernel is irrelevant. Google could replace it tomorrow with QNX and no one would notice. Even the APIs that are exposed ind the NDK to C and C++ are only a POSIX subset.
I imagine it's probably still pretty big with niche enterprise software. From personal experience this is the case and I doubt we would be unusual in selecting Java for his kind of application. 
Isn't "Java Desktop" it's GUI libraries especially are completely unrelated to Swing et al
I have those particular settings on this project since it's a template for another project which authenticates from a really shitty OAuth2 service, and thus requires some ridiculous workarounds which don't play well with all the components which would normally take care of business.
There are a couple of amazing things to spot when thinking about Java: The monolithical structure revolving around a single pillar called JVM. A team of programmers can build an insanely massive application, append their own libraries and bundle it with a current version of JRE. The app can even be taken down a notch whereas the javac version is concerned, adding two or three years of compatible devices onto the top of the stack. Now, where do we stand with Object-C and C++? Well, the "great" application can be a rollecoaster experience with tons of inovative features, customizations and exotic hardware support. And then comes *the deployment strategy assessment* - how to make your application go hand-in-hand with every virtual interface design, just about any OS core/version out there and almost every single library and its version, riddled with their own little mutual conflicts? I know there are guys out there that enjoy making everything from scratch, and from their early teens. Some girls do too, but either way - these character types are not commonly programmers. C++ serves that exact purpose, stripping everything down to its gears and building software on top of hardware. The last decade or so, hower, taught us things like : * Search? There's Google; * Blog? There's Wordpress; * Make video games? There's Unity; What Oracle's been trying to explain, in a nutshell : * App Development? *Try Java*.
It gives you a higher quality product in return for a container. The producer doesn't need to make one UI per platform plus one for the web. They just need one total, where they can devote all their attention.
Web UI vs what JavaFX offers in terms of platform integration is not an higher quality product, given the current state of HTML 5 adoption across platforms. I also don't consider an application that totally disregards the UI guidelines of a platform, high quality.
Shame on you for trying to scam a newbie.
&gt; the first few have nothing to do with GUI Not with that attitude. Yes those can all have user interfaces. &gt; Games, too, don't really use GUI What??? &gt; how many people make the rest? A hell of a lot more than the "nobody" figure you cited earlier. &gt; For 1000 web apps written, maybe 1 desktop app is written Where are you getting this? I agree there are a lot of websites, but unless you can cite your sources I'm calling bullshit. Look at how many Linux packages alone there are, and how much effort goes in even now in 2015. And that's just the open source world. **EDIT** Check [these numbers](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html). The C programming language is at the #2 position. Do you honestly think people are writing websites in C? 
&gt; no dialog What do you mean by this? 
Yes, but it's free. OP was asking about commercial viability of desktop Java apps.
Don't listen to those naysayers. COBOL will be relevant forever. :^) 
&gt; Oracle owns Java and is free to drive its development however it pleases. That's the most true thing you've said. 2010 - Apache quit the JCP 2013 - Doug Lea quit the JCP &gt; I believe that the JCP is no longer a credible specification and standards body http://alvinalexander.com/java/doug-lea-leaving-java-community-process-jcp 2015 - Oracle may be planning to abandon Java as an open platform &gt; The company is slimming down Java EE (Enterprise Edition), but it also doesn’t want anyone else to work on Java or Java EE and is sidelining the JCP (Java Community Process). “They have a winner-take-all mentality and they are not interested in collaborating,” said the email. https://jaxenter.com/even-if-oracle-is-losing-interest-in-java-should-you-worry-122390.html
Doesn't Java run on Android? 
Just shows I'm well rounded. :)
Java resource usage has been pretty much equal to that of other language software in most regards, at least with the more recent java versions (7+)
Java, the language does run on Android. But a Desktop Java application needs a graphical user interface and libraries for communicating with the mouse, keyboard, networking, persistence, etc. Java, the platform, is not compatible with Android. You wouldn't be able to take a Java desktop application and run it on Android.
You can't write files directly, but you can always generate a file for them to download. If you have a program that explicitly needs to write and manage files on the client machine, maybe web based won't work for you. But that's hardly a requirement for lots of software. And just because Java desktop (and desktop in general) is labeled as dead or dying doesn't mean that it's nonexistent, has no use cases or usefulness, has no proponents, or no one developing desktop apps anywhere and that doesn't mean there's no arguments for it. It just means a large part of the community has interests elsewhere and desktop development just isn't evolving and there's not a lot of new territory to cover. It's like email. Sure lots of people use email. But how interested are you in developing a new email client or improving email? There are people working on these things, but what are they going to do that really changes anything? It's just largely static, bland, mundane technology that doesn't have much reason to change. It's just not that interesting of a topic. If you love Java desktop development, go with it, I'm sure there will be plenty of Java Desktop development jobs for years to come. And eventually you'll either grow beyond that, or who knows maybe everything will circle back around to desktop development. TL:DR; Dead doesn't mean it's never used anymore. It just means there's just not much of interest going on.
In the early days of Java the major problem was running even a trivial application tapped *all* of your computer's resources. The JVM and class libraries took forever to load from the disks of the era so the simplest class took a long time to launch. Even today launch performance of Java applications isn't fantastic. It's immaterial in long running server instances but a major detriment to much more transient desktop applications.
It's there any other _Spring_'s I should know of?
Not sure why you were down voted. I agree that the UI guidelines are worth sticking to!
&gt; the Java bytecode is useless. Irrelevant. A PowerPC binary is just as useless on an Intel box without a virtual machine to run it. &gt; it's still objective truth that there are more platforms that can run code &gt; written in C or C++ than Java today. As a whole, of course C and C++ programs run on more platforms than Java programs. But how many of those programs are tied to a single target platform? And, how much effort is it to make a *single* C or C++ program compile and run on multiple platforms? &gt; That's not to say that you couldn't write tools to allow Java to run on those &gt; additional platforms The difference is, that once you port the JVM to run on new platform, then *all* Java binaries that are compatible with that version will run on the new platform, unaltered. On the other hand, if GNU or Qt are ported to a new platform, a new executable will have to be created and distributed, if you want to run the program on that platform. &gt; if inefficient WRT compute resources. In the vast majority of cases in which Java is used, and Java is used in very high performance applications, the "inefficiency" is not large enough to worry about. &gt; In some cases, though, it isn't a good fit, and in a few cases just isn't an &gt; option. Yes, of course. Java isn't a Golden Hammer.
&gt; Games, too, don't really use GUI *You are standing in an open field west of a white house, with a boarded front door. There is a small mailbox here.*
No, it has not. Java requires more memory (both real and virtual). This is both because of the GC design, and because of the object model. Values types will help for the latter once they come in Java 10 or 11, but I don't see anything on the horizon that will significantly reduce the need for extra memory for the GC. The code generated by the HotSpot JIT has gotten to be quite good, but there is still inescapable overhead due to GC. In addition to the pure CPU load, the GC also tends to pollute the cache. Java is an awesome tool, and HotSpot is an amazing accomplishment, but both are a product of engineering, and engineering is primarily a matter of trade-offs. The JVM trades off some overhead for a reasonably ergonomic programming environment. Nothing wrong with that trade-off, if it fits the needs of a project. OTOH, I'd really like more attention paid to more efficient code. Just because we have systems powerful enough to waste cycles, bandwidth, and memory, doesn't mean there aren't upsides to being more efficient: * Reduced heat * Reduced energy costs * Longer battery life * Potential to use less costly hardware, or smaller hardware, or lower powered hardware. * Alternatively, keep same hardware, but have headroom for new functionality * Spread more functions or users across same amount of hardware 
I know it works in Chrome. Google Drive allows the user to drag-and-drop and upload a folder.
the problem is ... when does the jvm get to upgrade.... and will that break the app it was bundled with?
&gt; Only works if you are targeting Windows 10 tho And why is that? My guess: (since you said it doesn't require runtime) is that Windows 10 has whatever it needs pre-installed. 
if nothing else, strong desktop dev skills give you an in at Oracle. They still have a crap top of server + fat client software they sell / license.
don't forget writing a better toString.
How about something like: void fooConcurrentPart() {...} @ConcurrentTest("fooConcurrentPart") void foo() { // add asserts here. } The idea is the method named in the annotation is what's run multiple times and foo() does all the asserts. You could also have an optional annotation member that sets concurrency (so here you would run 10 at a time): @ConcurrentTest("...", concurrency = 10) If you're willing to limit this to Java 8, you could require a method reference instead of a method name. 
the native cached image is not per-application but per-assembly (per-library). You can't just run a standalone executable without all the dependencies. It's just a caching mechanism.
there was no dialog box before version 8u60. You had to use 3rd-party libraries such as controlsfx for it.
you should check your own source of .NET having full zero-runtime AoT instead. There is no implication of such thing ever made by Microsoft. There is a 3rd-party app doing this though.
The fact that they don't even support a JavaFX graphical layout tool anymore... Yeah. Just terrible. That functionality needs to be built into NetBeans. But it's not.
This is false. If you pay for a year consecutively, you get a "perpetual" license, which is basically what you had before. If you want, you can pay for a year all at once to get your license immediately. You can use the version you have when your subscription ends forever.
Yes, but it still requires the CLR VM to run. Here it is: &gt;In addition to your main application assembly, an app requires that the following be present: &gt;1. Any additional class libraries or third-party assemblies that are required by your app. These assemblies similarly include metadata that describes the assembly, its types, and their members, as well as the IL that implements all type members. &gt;2. The .NET Framework Class Library. This is a collection of assemblies that is installed on the local system with the .NET Framework installation. The assemblies included in the .NET Framework Class Library include a complete set of metadata and implementation code. &gt;3. The common language runtime. This is a collection of dynamic link libraries that perform such services as assembly loading, memory management and garbage collection, exception handling, just-in-time compilation, remoting, and interop. Like the class library, the runtime is installed on the local system as part of the .NET Framework installation.
Unfortunately there are no easy answers: https://www.codenameone.com/blog/should-oracle-spring-clean-javafx.html Java is "supposed" to be cross platform but hasn't fully been that way (to mobile) in quite some time. Disclosure: I work for [Codename One](https://www.codenameone.com/) where we try to make Java cross platform again.
Not really. True native apps, like those written in C/C++, don't require the overhead of the CLR VM so they'll never be truly native from a performance perspective. 
You're a real conversationalist dude. &gt;What??? Games don't use GUI *toolkits*. They have nothing to do with usual window/button/textbox apps, and hence nothing to do with teh OP's question &gt; Not with that attitude. Yes those can all have user interfaces. Really? You'll use a Java GUI framework for making interfaces for a microcontroller? &gt;A hell of a lot more than the "nobody" figure you cited earlier. Yeah, everything must be 100% literal &gt;Where are you getting this? I work in the industry. &gt; The C programming language is at the #2 position. Not for writing Desktop GUI apps. that's for sure. Also, I think I've made my point. I was really just making polite conversation, you went full reddit on me. I'm out. 
Fair enough, haha. 
JavaFX is the way forward on the Java platform. Learning Swing might be valuable because apparently there are more Swing jobs right now, but FX has some cool stuff like CSS integration.
Swing is horrible, from a usability point of view where random parts of your window update by themselves but others require you to force a repaint, to the coding side where it feels like someone decided the Date api was awesome and proceeded to write the interfaces after taking plenty of drugs and then outsourced the rest of the implementation to the cheapest company. I hear JavaFX is an improvement, but after being burnt with Swing I will stick with web apps.
It probably doesn't help that end users will be recommended to avoid Java because of the bundled Adware, and that people are used to the Java web plugin getting flagged as an issue by most web browsers. Seriously, who the hell still writes applets?
Swing is not going to be enhanced anymore, it's in maintenance mode. JavaFX is not as mature as it could be for a Swing replacement but if I was starting a new Java project I would use JavaFX. 
Excellent point. Now we should have a discussion about the future of NetBeans :)
One major issue is to make apps feel native with java or rather look native. Also, hate for languages is true for all the major ones. 
Swing is crap and you should avoid it like the pest.
Anyone that understands about compilers knows that is a language runtime, not a VM. C also has one, even if tiny.
You could listen to the folks here that recommend JSF but 1. They tend to recommend JSF for *everything* 2. JSF has a steep learning curve and depends on tons of other Java EE things. For your specific use case, I recommend using only JSP, perhaps with JSTL, run the thing in jetty and be done with it.
That's quite verbose for the fact that it still doesn't really feel like a record/tuple/value type/case class
&gt; better privacy (data doesn't leave your network) To be fair this isn't really guaranteed 
Unless you need CPU/GPU specifically there's no real need to install a desktop app for your standard read fromDB display on screen apps, also its a LOT more convenient for everyone to manage as a Web/Mobile App
Swing is abandoned by Oracle, so it should be abandoned by all new projects as well. Also, it promotes really bad code practices and design, so JavaFX should be the way to go.
[SWT!](https://www.eclipse.org/swt/)
It upgrades when they upgrade the software. There's no reason to upgrade a bundled JVM. There's no security risk since it can only run our software. I'm not aware that we've ever had problems with upgrading to a new JVM.
Pretty much. But on a sidenote, Intellij IDEA was built in swing...
Of course some desktop app still running. My point is enterprise based application. 
yes, but if you do that you have to override hash() too. [I think that's what it's called. Haven't done it yet, I normally don't need to override equals() for my simple programs, just toString() ]
Did you even read that article? Since you seem to lack any reading comprehension and are quick to get aggressive with people, here: &gt; It replaces the full CLR with a refactored runtime that primarily contains the garbage collector. The refactored runtime is found in a library named mrt100_app.dll that is local to the app and is only a few hundred kilobytes in size Notice the "local to the app" part.
&gt;JavaFX is not as mature as it could be for a Swing replacement Is this the reason why its documentation is not included in the [java SE doc](https://docs.oracle.com/javase/8/docs/api/)?
I hate stupid simplistic platitudes from people who act like they know what they are talking about. After reviewing my replies I don't think I was wrong.
And in 2 years people will say exactly the same thing about JavaFX Just like AWT then and SWT now. Just bite the bullet and use the native GUI library for building UI's.
&gt;I hate stupid simplistic platitudes from people who act like they know what they are talking about. After reviewing my replies I don't think I was wrong. I never said you were wrong, I said that your response was dickish, which it was. Just because you're right about something doesn't mean you need to be a dick.
Community doesn't support web applications, so good luck doing anything with spring or grails
first of all, there is no such thing as an "enterprise based" app, there are "enterprise level" apps, which is what you are probably referring to and there are MANY, MANY desktop apps that are very important in running an enterprise level IT department
That's correct, which is why I need the Guava library for functional stuff.
Not in JavaFX. JavaFX shares nothing with Swing or AWT.
Didn't you say that .NET native apps didn't need the CLR? Looks like the article says it still needs a refactored subset of the CLR so it's still reliant on the CLR regardless of whether it's refactored.
It uses the CLR right? Let's examine what Wikipedia has to say about the CLR: &gt;The Common Language Runtime (CLR), the virtual machine component of Microsoft's .NET framework, manages the execution of .NET programs. A process known as just-in-time compilation converts compiled code into machine instructions which the computer's CPU then executes.[1] The CLR provides additional services including memory management, type safety, exception handling, garbage collection, security and thread management. All programs written for the .NET framework, regardless of programming language, are executed by the CLR. All versions of the .NET framework include CLR.
Thanks!
I'd also recommend http://codapps.io/ if you are a complete newbie to programming altogether. 
No, it uses another form of CLR optimised for AOT compilation. https://channel9.msdn.com/Shows/Going+Deep/Inside-NET-Native Unfortunately people that don't have proper means to learn about compiler design keep failing to understand the difference between runtime and VM.
The OWASP cheatsheet especially: https://www.owasp.org/index.php/Web_Application_Security_Testing_Cheat_Sheet
This is a great answer, I just wanted to add a couple of things. Java's promise was that you could write software that could work on any platform because of the Java VM. It's stuck around for server software because its runtime is pretty zippy and decent. Old Java Swing apps did not look like native applications though, they looked like crappy Java Swing apps. Because of this, and because the internet was roaring more and more to life at this time, people who wanted to do **cross platform** UI development just made web applications. People still write desktop applications. Like mobile apps, in order to get the best user experience you'll end up using the platform's intended development kit (e.g. .NET, Cocoa). If you want **cross platform** software, there are a variety of options, but they are usually based around web technologies (e.g. Slack and VSCode use electron, which is desktop NodeJS runtime with a browser frontend.)
Oh, so you now complain about support for technology. Sure, that's fine, yes you do want support for a certain technology for as long as your application is supported. And of course, we don't know what Oracle will do with JavaFX. Apple presumably still supports Objective-C even though now Swift is the new darling. But that, obviously will change at some point, no matter what. Swift will get replaced too at some later date. Still, java-land is in much better shape in terms of support that libraries get, as opposed to ... let's say ... javascript, where libraries are created and abandoned at a scary rate. By very well known companies, nonetheless. 
That's fair. Is there a good source for, how do I say this, "most used in production" languages? It occurred to me to look at [github statistics](http://githut.info/), but github is often pretty different from the corporate world. It seems like TIOBE solves this since almost all developers (open source and closed source alike) google their issues. 
The Android ART runtime also compiles apps to native code, but it still relies on the ART runtime in order run apps. This is similar to .NET native. Even though the apps are compiled to native code, the app still relies on runtime resources to provide such services as memory management, garbage collection, etc. Regardless of what they call it - it's still a runtime based on their CLR runtime. 
Well holy shit, then C/C++ isn't native either.
C/C++ isn't hobbled by the overhead of a VM environment. Go ahead and post some .NET native benchmarks and compare them to some C/C++ benchmarks. The C/C++ scores will smoke the .NET native benchmarks. 
Fuck dude, anything that needs memory management and garbage collection is reliant on a VM. This explains why the benchmarks for .NET native are so bad compared to C/C++ benchmarks.
Ok, you are a slow one. Let's go over it one more time: .NET Native does NOT run on a VM. What it does is, it takes the garbage collection and memory management portions of CLR, implements it as a library and links it to you app. It is NOT a VM anymore. You app itself runs the memory management and garbage collection.
OK? Then ride the IDEA Ult/PyCharm/WebStorm/PhpStorm/RubyMine EAPs like every other cheapskate (including myself sometimes), or just use something else. I really don't understand the entitlement here. How do you guys think a company like JetBrains is supposed to support itself?
Jesus, I only mentioned a crucial limitation of using the community version, which means that depending on your needs, it may not work. Don't take things so personally
I agree!
Sorry, that was the RT used by .NET core. Looks like the RT used by .NET native is MRT. What a clusterfuck of runtimes and names. As for the benchmarks, well they prove just how un-native the performance of .NET native really is.
Now we're getting somewhere. Now the fun part of MRT is that it get's bundled into your app as a library, get compiled with your app (so it has only the functionality you really are using in it) and runs with it. No VM needed. Performance has nothing to do with this discussion. We are talking about wether .NET native is native or not. And I have 0 idea on what makes you say it's performance is "un-native". What are you comparing it to? C? Since when did C become a standard for what "native" stands for. What about other compiled languages? They aren't native? Being native has nothing to do with performance. It all depends on how bloated the language is and surprise-suprise, C is probably the most light-weight language there is.
Well, that article has 0 value whatsoever.
That's a lot of duplicated code and fields. Is there a more streamlined way to make a builder?
It's ok :) grails was my main platform at my old job and it sucked to not be able to use IDEA, they wouldn't buy licenses. GGTS just sucks these days
Yikes, that's rough.
What code are you talking about? I can't really see much duplication of code.
simple: don't use the java serialization API. Its security issues aren't the only bad parts of it. Disable it for good using [notserial](https://github.com/kantega/notsoserial) and serialize using something else like [Jackson](https://github.com/FasterXML/jackson) or if you need small output [Protocol Buffers](https://developers.google.com/protocol-buffers/?hl=en).
Last time I checked, both C and C++ have a runtime as defined by the ANSI Standard. So they also have a sort of VM environment according to your own words. See? I am already learning, thank you!
You're correct - community is for mostly vanilla Java SE. That said, what are you doing with Spring or Grails that isn't business related? If business related, I'm having a hard time seeing where the JetBrains licensing is even remotely expensive. If you're a student, JetBrains has free student licensing.
You can use Arquillian to do this and then integrate it into your continuous integration builds.
The Protocol Buffers code looks pretty handy, but what about using externalizable instead of allowing Java itself to handle the serialization? I ask because in some business cases it isn't really viable to be implementing an "ideal" solution constructed from multiple components like this, and with externalizable you have more direct control over the serialization of the objects you're using, though admittedly it is kind of tedious and certainly not 100% bulletproof.
If you do not care about object mutability, fluent setters would do the trick: new MyObject() .setProperty1("aProp") .setProperty2("anotherProp"); Basically have your setters return this.
Great intro to a great pattern, but this: "A method has two parameters is good. A method has only one parameter is the best. And a method has no parameter is ideal." No! A method that takes no params probably does it's thing by mutating a shared state therefore being hard to maintain, reason about and keep thread safe, all of the things that a good design and immutability promote.
It has its own documentation including its own examples
There is one thing about the Builder pattern that gives me pause. My understanding is that good design asks that an object be ready to go when it's constructed. Applied to the Builder pattern, that means once I call `build` and get an instance, that instance should be viable. So, the way I see it, the mistake a person could make is to see a Builder as a cure-all to constructing objects that need a lot of configuration. But, to me, it doesn't work that way, unless there is some default build. I think you should be able to do the following and get *some* default version of the object that is ready to be used: MyObject obj = new MyObjectBuilder().build(); If that's not possible, then I would prefer something like this as a foolproof minimum: MyObject obj = new MyObjectBuilder(foo, bar).build(); In the above, there are two key points. One, the builder does not have a parameterless constructor. Two, all other customizable fields for the object we're building will have some kind of default value. With those restrictions in place, then, if you wanted, you could customize the build like this: MyObject obj = new MyObjectBuilder(foo, bar) .setFee(fee) .setFie(fie) .setFoe(foe) .setFum(fum) .build(); The key is to restrict the client to building some kind of default object no matter what. I think it's bad form to allow the client to build an object that's going to throw an exception because it's not fully setup.
The class would be constructed with the values that would have been passed as arguments though, so saying there are fewer permutation to test doesn't sound accurate. Those permutations just moved from the argument of the function to the constructor. Maybe I'm misunderstanding something?
I'll just add that you should care about mutability.
Also Kryo (https://github.com/EsotericSoftware/kryo) which is fantastic.
But then your objects is mutable and you probably don't want that.
The builder pattern is awesome when used correctly. It's great for creating immutable objects within your api. I like to use it in combination with enumerations This article was terrible, the examples were trivial and nonsensical at best, and then it references "effective java" at the end for more examples. Effective java is a book that should be required reading before starting any professional java development work. Don't read this article, read effective java. 
Definitely not Swing. But you may not want to waste your time with either one if you aren't actually writing desktop applications.
OP, do yourself a favor and ignore all of the framework suggestions for now. This is unfortunately an area where sometimes too much choice can be bad. If you are trying to create a simple app and start with something huge like Spring or Struts you're probably going to give up on Java altogether. This really wouldn't even have been a problem if Sun hadn't made the original J2EE so complicated to begin with. The thing with all of these frameworks is that they all in one way or another build upon servlets and JSPs (java server pages). If you're building something simple, then this is the best way to go. Once you get more comfortable, then I'd look at some of the frameworks that are out there.
I agree that it's best to use object constructors over the builder pattern wherever possible, but the builder pattern really does shine when you have an unwieldy constructor, as the builder allows you to hide the details of the constructor behind a much more fluent API.
Not free, unfortunately, but [this](http://www.amazon.com/Programming-Concurrency-JVM-Mastering-Synchronization/dp/193435676X) is an incredible book
I don't think mongodb has any business in just learning Java.
Java Concurrency in Practice is a good book, not free but you can find an online copy.
Maybe I'm misunderstanding it, but the Person object doesn't have setters. It's fields are populated by the data from the Person.Builder at construction time.
I've used mxGraph, aka JGraph. It works, but the api is a total bitch.
In more than 15 years of professional java I never once had a server that exposed a public object serializable interface from my own software. Even if the app server did that, it was always behind at least two layers of firewalls, so that every time we needed to talk from one server to the other, we had to tell the sysadmins which ports we needed and why. If these are the biggest threats against java, I think we're very safe. 
Neo4j is a graph database, not a graph visualisation tool.
You could output [Graphviz](http://www.graphviz.org/) [Dot](http://www.graphviz.org/content/dot-language) format and then render in whatever format you like via the cmd-line tool.
I read a O'Riley book called pThreads (this was long time ago). But it gives an excellent intro into threads at the OS level. I feel this is crucial in understanding how a higher level like Java handles threads. 
You can enforce a set of mandatory parameters in the builder constructor, as was shown above. The optional ones can either have defaults or be left empty. The limitation is that if you have multiple permutations of mandatory parameters, then you get back to the multiple constructor problem that builders try to avoid. In general a constructor should always validate its parameters, and it's perfectly possible to pass a set of parameters that don't fulfil the preconditions and results in a runtime exception. This applies to Foo(Foo.Builder) as well. E.g., if you take a string, you might not accept the null or an empty string, or you have some maximum length etc. These are typically not checked by the type system in Java, unless you go down the rabbit hole of defining types like NonEmptyStringLessThanTenCharacters.
I discovered Pippo through this reddit message (and i'm going to give it a try soon as it seems to really cover some of my needs), so it's great for me to have published this information here. But. Like every other announce of that kind, there is absolutely no context explaining what the project is. A quick introductory line (when published on medias like reddit) would be a good idea (most of the time i don't even try to discover what the project is about when i see a list of new features / bug fixes for a project i've never heard about before).
&gt; deserialization on **untrusted data**
you should also consider Rich Client Platform(eclipse rcp) and don't forget that the most popular IDE today ==&gt; intellij suite is based on swing
Aside from great libraries like http://deeplearning4j.org/, we should also remember that the [most impressive AI application ever built](http://www.ibm.com/smarterplanet/us/en/ibmwatson/) is written in Java.
Oh but you can make the compiler complain: public class Person { public class Builder { public $1 setName(String name); } public class $1 { public Person build(); } } This is drastically shortened but shows how you can leverage every decent IDE’s auto-completion feature to make the list of parameters and their requiredness very, very obvious. However, it does increase the boiler plate so it’s probably only useful for objects that are relatively large and complex in their parameter dependencies.
Step Builder pattern is better: http://rdafbn.blogspot.ie/2012/07/step-builder-pattern_28.html
Title should be JavaFX links of the week...
Doug Lea's "Concurrent Programming in Java". Doug wrote most of util.concurrent
Sorry, starting with Struts is terrible advice.
Don't worry about one of the gazillion Java web frameworks but focus on developing a HTTP API instead. It would be a bit silly to write that from scratch with the Servlet API instead, so use Spring Boot (or Guice, which I like better, but that's probably harder to get started with). Use jOOQ for database access - there is no comparison, and Gradle for managing your dependencies and build. 
[This article](http://www.darkreading.com/informationweek-home/why-the-java-deserialization-bug-is-a-big-deal/d/d-id/1323237) provides some actual detail.
https://github.com/encog from http://www.heatonresearch.com/. 
Most of the time, sure. But there are Swing / Griffon / Whatnot news too from time to time.
&gt; this Hardly--that's the most lightweight book on the subject I can imagine. Don't waste your money on the book mentioned in the link. Instead, go for "Java Concurrency in Practice" which is awesome and well written, unlike the lightweight book mentioned, which I read and despised.
I'm not advocating serialization, it has its problems. But the concept of whitelisting revolves around only approving serialization for classes you have tested an know to be safe. Unless you audit the collection classes you'd never whitelist them. You design your DTO classes and whitelist them and their dependencies after you audit the entire dependency graph for your DTOs. You wouldn't whitelist a class just because it was shipped with the JRE. The way the article is worded it implies that the exploitable class is loaded even when using look-ahead and that simply is not the case.
I've never seen an abandoned project posted here before.
That is the basis of some nightmare Java code there. 
Hah, no kidding. When I saw this, I was hoping it meant it was alive again. SFML (the core version) is a really nice framework, but even on the front page, you can clearly see that last time this project was updated was almost two years ago.
I dont know if its "legal" to ask it here but can you tell me where i can "buy" it online?"Buy"..cuz i have searched and nnothing.Send me a pm if you can help me plz!would be really appreciate to you!
Thank you guys.Have 3 weeks to do my final project of the the course and you helped me alot.Those 2 books that people said i already knew but sadly i can "find" them free..maybe a bit of a noob hehe. Thanks for the free courses and tutorials that you said to me.They seem to be really well made and will surely help me !Thank ya!
What do you think of these exploits? https://github.com/frohoff/ysoserial They're pretty scary, and the one on a standard Jenkins install makes me nervous for all the random build servers that get set up in datacenters... https://tersesystems.com/2015/11/08/closing-the-open-door-of-java-object-serialization/ From this article, it looks like if you have ObjectInputStream in your classpath, then you're vulnerable, even if your ports are non-obvious.
http://www.wikihow.com/Create-an-Executable-File-from-Eclipse 
Why
Wow, looks bad. Luckily, Pinn (the java multicore general intelligence) will surely design java better (being written in java).
There is a free community edition, which has most of the goodies.
Wow, just found this. Great little project!
If the attacker hits you from inside once again you have other things to worry about...
But it doesn't matter. You need to harden your systems to minimize the damage from the (now nearly inevitable) occurrence of a compromised machine. You will be compromised. Plan accordingly.
&gt; You will be compromised. Plan accordingly. I'm not sure what kind of mickey mouse operation you're working with but that's a terrible approach. Shit might as well leave the front door open then...
&gt; The way the article is worded it implies that the exploitable class is loaded even when using look-ahead and that simply is not the case. Well good, because that's not the implication. The implication of "the bite of the poisoned apple" is that Java object deserialization will deserialize objects and allow unbounded amounts of processing to make that happen. In the case of existing code that serialize HashSet and java.net.URL over RMI, the classes look harmless enough to be whitelisted. They certainly wouldn't fail an audit individually. It's only when they're combined in interesting ways that you end up with denial of service attacks.
Wait, so you *don't* manage your [edit: individual] servers as if the other servers in your datacenter might be compromised? /EDIT: I haven't downvoted yet... wanting to see where this argument is headed first.
Just [download](http://jsfml.org/?page=download) the latest (test) release - from December 2013… 
Presumably you would need to store your data in Neo4j, in order to visualise it.
I might be missing something here, but I don't see how one can be bitten if he maintains a whitelist of LAN IPs and the specific ports between them. T3 was always a security risk, it's a bit like exposing your JMX channels. 
That is just one particular attack using this vulnerability. In general, if an application deserializes data from an untrusted source, it is vulnerable to this. Doesn't need to be an admin port.
Yep. Executable jars are great. I was just looking if there was a way to create a Windows .exe file from mac. I think a virtual machine is my best bet. Thanks!
Haven't heard of rcp. I'll check it out.
Yep, I'll be writing desktop applications. I don't ever plan on getting into Java mobile development. I was also turned off by applet development because chrome doesn't support it anymore.
This book predates the current memory model. It's only of historical interest.
Okee dokee. I hope Oracle continues to support JavaFX - it's the most modern UI toolkit out there. 
&gt; The JVM does not deserialize classes that it cannot access Right but the issue is that it's possible to modify the serialized data to run arbitrary Java code when the deserializer is reconstructing the objects. It's the same kind of problem with the XML encoder. The problem stems from Java being able to reconstruct any kind of object instead of only simple java bean styled objects. The best bet is to avoid this kind of serialization and use basic JSON instead since JSON only talks about data objects.
Pthreads is a user-land multi-threading API, and provides pretty much the same primitives as you'll find in Java. So you might as well read about Java concurrency instead. If you want to understand how threading works at the OS level, you are better off reading an OS book.
[More information](http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
How is having an annotation limiting reuse of the POJO?
Why not? It starts from the basics IIRC.
Sure that's fine, but that's exactly what I was saying. You have to be able to provide sensible defaults in the builder. You can't build the object in an invalid state or you've defeated the whole purpose of type safety. The example in the article definitely doesn't do this.
Externalizable has similar problems as Serializable in that it executes custom code while serializing. The nice thing about libraries like Jackson are that the serialization code is in the library and not written by the developer. This makes it by no means secure but securer than boilerplate that is repeated over and over again (and Externalizable is very prone to that). Aside from backwards compatibility I really can't think of a case where I would serialize data using the standard jdk mechanisms. And when I did use them I regretted it very fast. The criteria for a serialization mechanism for me are *speed*, *size* and *readability* none of which the java serialization mechanism succeeds in. In addition to that has it a limiting architecture that makes it really hard to separate the logic from the data using them. Sorry for the rant but I learned to hate this feature a lot and can only recommend to stay away from it as far as possible.
The fun thing about these vulnerabilities is that the frameworks expose them for you. Ever run a Jsf with client side viewstate?
&gt; This book is almost essential. The book is overrated. You don't need a 300+ page book to learn about concurrency but most the Java community makes it look harder than it is.
Not following. Why not back both forms with the same POJO?
[This] (http://www.amazon.com/Art-Multiprocessor-Programming-Revised-Reprint/dp/0123973376/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1448327345&amp;sr=1-1&amp;keywords=art+of+multiprocessor+programming) was quite nice during my undergrad. It does a really nice job of exposing concepts while using Java as the tool.
seems interesting. Needs a lot more example projects and documentation.
The question is this: Does your graph change much, on the fly? Or is it a "my program creates it then does a bunch of stuff with it, and I want to see the changes and stuff" kinda thing? If it doesn't change, then I'd suggest writing a GEXF export function. In my code here, the GEXF export is &lt; 100 lines, of which almost all are wordy java XML boilerplate. If it changes, you'll want to use jung2.
I found it great. I was already familiar with basic concepts but this really helped solidify in my mind that it was more than just multiple streams of execution and how to avoid common problems and pitfalls. I also only paid like $20 for it. Unless that's not what you mean by 300+.
All form annotations on that object describe one form, so it follows you can't map a second form on the same object... I feel odd I need to even say this. You can't expect the field names and formats to match every time you want to describe the same object on every different form. Having the same resulting data doesn't mean the source format and field names are the same. Annotations typically don't provide a mechanism to describe such variations (as is the case here). If you're still not following, try to write and paste a link to an example that describes two conflicting form mappings on the same object via annotations, and let's see how this works. And even if annotations could be extended to support multiple form definitions on one object, it's still a problem that the object has such external concerns on it, because it's very naive to assume the object owner also is the owner of the forms, and is also the owner of code that wants to map a form into said object. In any larger project, it's typical that N component vendors want to parse M different forms from P other vendors into the same object, so those vendors can't all edit the object, it's third party code to them, they're just using it. Where would you put annotations then? It's the most common misuse of annotations - embedding concerns on an object, which concerns don't even belong in the same component the object is defined in. It's a recipe for producing tons of throw-away, tightly coupled code. "Reusable code" means code which you can use in different components without editing its source. If you need to refactor or edit the code to "reuse it", such as editing annotations on it, then you're not reusing it. If you don't think this is a problem then you're either dealing with small projects, or large, but monolithic ones where form definitions, form mapping and target objects are all maintained by the same team/person, and no one else has a say into how it all works. That's fine, but it's an increasingly rare scenario, because it doesn't scale in terms of maintenance, and results in a leisurely rate of change that makes the project uncompetitive. Modular code and mixing concerns like that don't play well together. In larger projects what you map from, what you map to, and how you map between them are three separate things, that may be controlled by three different parties, and this separation is very natural unless it's explicitly made unnatural through mechanisms like annotation abuse. And as I already noted, it's best to stop calling an object with framework-specific annotations that modify its behavior and interpretation "POJO" because, as outlined in the first comment, it's not one. POJO is supposed to mean "a Java object which does not follow any of the major Java object models, conventions, or frameworks". Having form annotations means this object is bound to be used in a specific way by a specific framework. If you want to say "an object", we already have a word for that and it's called "an object".
Especially cause dropwizard uses jetty... All dropwizard is is some glue. 
These tests mix a lot of choices together: front-end server, database backend, OS, etc. Some of the entries don't even have a front-end server. It is very hard to compare a particular metric when the other metrics are not controlled.
The whole premise of generalizing with hard numbers is inherently flawed.
I'm curious, what would you use this for on Android?
What not make the helper class in technique #2 immutable? I don't see how technique #3 is better design than the helper class approach. Can someone please explain?
Actually, it is Java 6, for this kind of compatibility reasons. ;) (Only the Rapidoid Fluent framework requires Java 8, since it build on top of the Java 8 streams.)
That's amazing. Kudos for the great work.
For the Plaintext test (no database access, just a plaintext response): - PHP: 177K req/sec, - Spring: 123K req/sec. Yes, it looks funny! :) Is it Spring Boot? I couldn't find Tomcat in the results, to compare.
Thanks a lot! ;)
I'm not a british guy but few things to remember: &gt;1 bring with you 2 ids &gt;2 arrive at least 15 min before. &gt;3 choose carefully your test center visit some of them. &gt;4 results are available ~30 min after the test. 
why is it questionable ? spring is hardly lightweight. Id expect that.
Thanks for the head up!
Not really. Granted, it’s even more verbose than a normal builder but users of your API quickly begin appreciating that your API makes it syntactically impossible to be used incorrectly.
/r/dailyprogrammer Just start doing some. You could sort in on top. I also recommend trying to do some of the easy ones in other languages (python, C, bash, scala), and using as much of the language features as possible. Its also fun to try solving some of these with a library, its technically cheating but knowing how to use libraries (finding installing etc.) is a *very* useful skill to have IRL.
Doesnt look funny to me, its due to the overhead of the framework. But compare raw PHP to using a popular framework - Laravel 1K req/s only.
Looking forward to it:)
I agree calling it perfect is a bit too much. And technically the method name is a parameter itself, an enum value sent as a message to the object. We are used to treating it differently for pragmatic reasons, but conceptually, it's impossible to tell an object something without saying anything.
Maybe this is to keep modules seperate inb4 Java 9? It was developed as stand-alone plugin with own editor, documentation and examples.
Looks really really good..... It only takes 1 java framework like this to prove that Java can keep up with C. I was thinking of using it for a facebook game I am writing, .....but then thought... what about SSL, does it support SSL? If not, does it support ajp to let apache HTTPD do it instead? Then, what about database access... yes, I guess I can use a connection pooling library. I am no fan of ORM, prefer MyBatis.... but then what about transactions...etc... Also, what about Dependency injection? I really want to use these technologies.....they make it easier for me to write code, and less lightly to end up in a spaghetti mess. So, I am staying where I am at the moment with TomEE. You have a lightening fast HTTP library. If you can turn this into a Java EE Web Profile *standardised* HTTP library, while keeping the same speed, then I'd be really interested. But, dont take this as a put down. Please keep up the good work, its really refreshing to see something as fast / lightweight. Given time I can see this becoming a great competitor to the usual Tomcat / JBoss etc etc type installations.
Is there anything released in java 9 without an open implementation?
An API is supposed to be as intuitive to the user as possible, so I'm not sure what you're talking about when you urge pragmatism over blindly following rules, as you put it. A fundamental rule in user-interface design (which isn't really much different from API design, if you ask me) is to prefer restricting the user from doing something wrong in the first place, rather than letting the user do whatever and checking afterwards. With respect to API design, RTFM gets old after a while—unless, of course, the programmer is using the API all the time, to the point where it has become second nature, or the programmer has an eidetic memory. As to your second point, if it's just a question of named parameters, rather than providing configuration for a relatively large number of fields in what will end up being an immutable object, then I think static factory methods are a better solution than the Builder pattern. In Java, for example: MyObject obj = MyObject.withFooAndBar(someFoo, someBar); You then get labeling that is something like what you get in Objective-C. Say, if you don't mind, what language or languages are you talking about when you say: "Some languages support declaring which methods should be called, how many times, in what order [...]"? I'm not familiar with that.
Neat. Is this the point of codename one? JS port of java?
No, that's actually TeaVM. It just shows how portable Codename One can be while still preserving Java 8 semantics and a Java style component model. Notice there are also native versions and desktop versions all with a single code base.
That's correct. It does. However when you read further, there are more like design considerations.
Ye, only Sith do that.
Not sure if this is overkill, but take a look at [Apache Shiro](http://shiro.apache.org/). 
[JHipster](http://jhipster.github.io/) gives a lot of this for free. The nice part is that projects generated by JHipster have almost no dependency on JHipster itself.
Most of this stuff is available in Spring Boot, JHipster is basically Sprign Boot, plus some UI boilerplate and other bells and whistles.
If you know Spring MVC, use this. However, if the security is simple, then just use the security built into tomcat (realms), https://tomcat.apache.org/tomcat-7.0-doc/realm-howto.html#JDBCRealm You will have to create screens for password recovery / new users etc and decide where you're gonna store this data...., but this shouldn't take more than a day or so if you pull your finger out! 
Grats on building your 'java multicore intelligence': https://www.reddit.com/r/javahelp/comments/3twko5/code_review_plz_general_artificial_intelligence/ ^^nutjob
&gt; so branching off into a more minimalistic IDE probably won't be an option for me. No so, young padawan. Ask them if they require actual IDE project archives to be submitted. Chances are they just want java files or jars which can be edited, compiled, debugged, and run from Terminal. Choose your weapon well and it will serve you long.
Well just recompile it with a compiler that will, the Java language is the same just the target is different, all native compilers do this anyway, one source language with multiple target platforms. I think what he was saying is you can't write an application that uses Swing for the desktop then expect it to work on Android.
According to this article yes: http://www.infoworld.com/article/2874861/application-development/google-web-toolkit-major-upgrades-no-backward-compatibility.html I am still using 2.7 though.
I went here: NEXGENN CONSULTING LIMITED MARITIME HOUSE 18B ENSIGN STREET LONDON E1 8JD UNITED KINGDOM The toilet was clean (girls toilet I mean)
Upvoted!! Questioning the 'norm' is the only way things can get better. MongoDB has very few use cases....
I run IntelliJ on my Chromebook. It has 2GB of RAM. It'll run on your computer just fine. Any of these three IDEs will, especially with projects as small as you'll be working on. 
But it is mentioned, did you read the article? 
I would remove the Netbeans files from source control. Add a [`.gitignore`][1] file, please :) # Example # Java *.class *.jar *.war *.ear .mtj.tmp/ hs_err_pid* # Netbeans nbproject/private/ build/ nbbuild/ dist/ nbdist/ nbactions.xml .nb-gradle/ [1]: https://github.com/github/gitignore/blob/master/README.md
I would rename suite to suit.
Totally agreed. It's a bit of a nightmare
Sounds a bit like premature optimization. Have you used any of them and actually had a problem? I've done most of my recent Java development in Eclipse on a 2008 Macbook with only 2 gb of ram and have had no problems (Windows 7). I do Android stuff (Android Studio ~= IntelliJ) on my 2011 Macbook Air which has 4 gb, again no issues (Yosemite).
IntelliJ, for me, consumes about 700-900 MB with a medium sized project, will be fine unless you're multitasking a lot on 4 gigs
Sublime Text is real nice for Java, to a limit. When you start using external Jars or more complicated things IDE's can really shine brighter
What's the point of the method: `void foo(void)`? It takes no input, and produces no output. It's useless unless it has side-effects, like mutating the state in some object. Sometimes we have to write them as there is no other way, but that's like picking the method of your own execution. It's the least bad thing from a list of even worse things. It's not really a good thing.
What about connect four? Inputs: which row you put your piece in Outputs: an updated view of the game board Loops: Keeping the game going, drawing the board Conditionals: Keeping track of if a player has won or not, valid position checking for pieces Strings: Pieces can be represented as Xs and Os or anything else (maybe a stretch) Arrays: Representation of the gameboard as a 2-dimensional array All of this can be pretty easily implemented in the console! The same general ideas could be applied to Tic Tac Toe, or any similar games. I hope this is what you meant by "text-based" games.
Thanks, silly mistake.
I have a gitignor in the root that includes **/private/* I have no idea why that isn't working... 
I don't get the idea that you would get some 'cred' or whatever for writing everything in a text editor, when in reality you'd just be a lot less productive when you're manually writing all the repetitive bs, managing resources, etc, etc, etc, that should just be handled by the computer. At the end of the day, people only really care about *what* you create (and how long it takes you). You don't get bonus points for doing it the hard way.
This is what i was looking for. All of the code ideas online were too complicated for a bigginer like me. Thanks for your feadback!
I have a serious issue with any research effort that takes industry sponsorship as these guys do. That's why we stopped promoting them.
You could: + Write a "Choose your own Adventure" style game - also known as ["Interactive fiction"](https://en.wikipedia.org/wiki/Interactive_fiction) (there were prominent books called ["Fighting Fantasy"](https://en.wikipedia.org/wiki/Fighting_Fantasy) and the infamous text adventures from Infocom) + Write a "Battleships" game + Write a "Minesweeper" clone + Write a text based version of "Monopoly" + Write basically any type of dice game (Yahtzee, etc.) + Write a [Roguelike](https://en.wikipedia.org/wiki/Roguelike) game (Dungeon Crawler) More inspiration can be found in the [Programming challenges](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) page of the /r/learnprogramming wiki or in /r/programmingprompts
Yes, spring boot is the way to go! 
Yes. The object gets built in a valid state. Exactly the same way as if you had called a classic constructor without that parameter present.
Could you give an example for a "more minimalistic IDE"? I'm seriously interested in productive solutions beyond the trifecta that is Eclipse/NetBeans/IntelliJ.
Spring Boot with the web and security starters. Use https://start.spring.io/ for bootstrapping.
Spring Security seems pretty heavy indeed. I've to use Mongo, there is no options for it.
I've played with JHipster a little while ago, but how hard is it to maintenance? Seemed to do things quite magically.
http://jwt.io/
[The original content by Adam Bien](http://adam-bien.com/roller/abien/entry/java_8_infinite_stream_of) was published under a CC license which requires you to attribute his work to him, which you didn't. In fact, the original license doesn't even allow any derivatives, so you should've reproduced the exact original content (in principle). In my opinion, this act of reddit moderation (?) goes a bit too far. As a frequent reader of /r/java, I'd like to learn more about the rationale of your act, and why you proceeded the way you did.
Connect Four is beginner friendly while being more challenging than Tic Tac Toe. You can also take a look at 'Chomp'
Again, I'm really a bit surprised by the act of "hey this is *clearly* spam, yet the content is really cool (= *clearly* not spam), so I'll just seize the content and republish it under my own name, without linking / attributing to the original author". I'm surprised that a moderator of any platform would expose this behaviour and defend it by referring to unwritten "rules" or "justice". But oh well. I don't really have a stake in this. You can do whatever you want, I guess. I was just surprised, and perhaps, a bit disappointed.
&gt; republish it under my own name Could we stick to the truth, please? Thank you. &gt; Again, I'm really a bit surprised by And you could just say what you think instead of playing childish word-games. &gt; "hey this is clearly spam, yet the content is really cool (= clearly not spam), 1) The content was not really cool, but it was proper content as opposed to just explaining that String should be compared with equals. Now, to repeat myself: The post happened to punish the spammer, not because the content was "cool". I realize that I made the mistake of assuming that the one who posted it was the one who wrote the blog or is acting on their behalf. 2) Whether or not the content is cool has no bearing on whether or not the blog page itself is a spam page. And spammers should get punished. Are you still "surprised", or are we *talking* now?
I'm having my class work through a text adventure game. We'll have arraylists of items, rooms. Possibly a hashmap if I have time to teach that too. Then a player object with an inventory. (Personally I don't like having exit objects, I make do with putting the exit information into the rooms.) We'll also do some simple command parsing. I'm happy to help you or any others work along with us.
I would agree the content was trivial, yes, but ok. Not sure why you think it was spammy. Adam Bien is a very well respected personality in the Java community, and I like his work. When I said "surprised", I meant that I thought you were perhaps a bit overreacting. Both to the link itself, and also to my criticism. But again, I don't really have a stake in this. You seem to do. I'm sorry if I'm misunderstanding something here.
For everyone not following the mailing lists. Yestery Mark Thomas held a interesting Webinar: "Apache Tomcat 9: HTTP/2 Quick Start". https://www.youtube.com/channel/UCpqpJ0-G1lYfUBQ6_36Au_g
&gt; and also to my criticism. Dude, you accused me of plagiarizing, which is quite heavy, and you solely did so because you felt you had to add some more energy to your whole "I'm surprised" routine.
I'm in AP computer science, I made battle ship a week ago or so.
I made 21 Sticks, also in AP Comp Sci.
I know, I'll get many down-votes, but anyways... I know its very personal and psychological, but I just cannot understand how so many people could possibly like Spring Boot. For me its total garbage. It looks nice and allows you to write some quick Rest APIs at first, but sooner or later, when you'll try to do something more advanced, you'll be forced to spend countless hours investigating why something is not working. Spring Boot == masochism.
What's 21 sticks?
You start with 21 sticks, and two players take turns either taking one or two sticks. The player who takes the last stick loses. It's a fairly basic game to make. I actually found [this website](http://www.java-made-easy.com/fun-java-game.html) that give you a fully explained guide on how to make it. Wish I had that before lol
I would say that the style of functional coding that Rapidoid uses (static functions on classes, e.g. On, etc) potentially makes DI engines like Spring obsolete altogether. But that is not so typical yet in Java programs, it only started appearing with all the new features in Java 8
We do it in my team, some use intellij, some use eclipse. Just add the IDE specific stuff to your .gitignore You can use http://gitignore.io to generate .gitignore files that will exclude Eclipse and IntelliJ files very easily. The other thing we did was create a code formatter in Eclipse originally and then import it into everyone else's Eclipse and IntelliJ Edit: Here you go... https://www.gitignore.io/api/intellij,eclipse,netbeans,java,maven,gradle
It depends on how the team wants to work and how the projects are set up. If the projects are Maven projects with a proper pom file, then the .project and .classpath files become secondary, and don't need to be checked in. Gradle and ivy probably work the same way but I haven't used them for anything non-trivial. The .project and .classpath files get generated by the maven plugins. If the team doesn't work like this, it could be a major change that the rest of the team doesn't see any benefit to taking on. I have been on teams where there are a variety of editors being used. As long as the pom.xml or equivalent becomes the 'source of truth' for the project, then the IDE can generate its own project definition files locally as needed. Not all teams want to work this way. Some prioritize standards and fast developer environment setup over IDE neutrality. Keep in mind that it used to be more effort to import a maven project and there were two incompatible versions of the eclipse maven plugin for a while.
The biggest hurdle (in my opinion) is the missing ability to have a different classpath in the launch-configuration than project setup. Some teams use that - you can work-around this by just giving IntelliJ the "all"-classpath, but be prepared for teammembers not being able to build, because their classpath is only a subset of yours. Also: Specialised build tools - other than that I've not found any big problems (you might have problems due to conventions of only checking in code where the eclipse-compiler doesn't say anything with *those* specific settings, etc.)
If you want IDE-independent projects, you need to use a build automation tool like Gradle or Maven. Your IDE of choice can then import the Gradle/Maven project and it will work for everyone without putting any IDE-specific files into the repo.
Hilarious that you've [spammed this to /r/ProgrammerHumor](https://www.reddit.com/r/ProgrammerHumor/comments/3u832e/geeklistener_v4_developers_tweets_commented_with/), too. domain submitted from|count|% :-|-:|-: [fruzenshtein.com](/search?q=%28and+site%3A%27fruzenshtein.com%27+author%3A%27Fruzenshtein%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|14|78% [udemy.com](/search?q=%28and+site%3A%27udemy.com%27+author%3A%27Fruzenshtein%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|2|11% [self.starcraft2](/r/starcraft2/search?q=%28and+author%3A%27Fruzenshtein%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|6% [fruzenshtein-school.usefedora.com](/search?q=%28and+site%3A%27fruzenshtein-school.usefedora.com%27+author%3A%27Fruzenshtein%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|1|6% subreddit submitted to|count|% :-|-:|-: [java](/r/java/search?q=author%3A%27Fruzenshtein%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|7|39% [ProgrammerHumor](/r/ProgrammerHumor/search?q=author%3A%27Fruzenshtein%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|3|17% [softwaretesting](/r/softwaretesting/search?q=author%3A%27Fruzenshtein%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|3|17% [QualityAssurance](/r/QualityAssurance/search?q=author%3A%27Fruzenshtein%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|3|17% [programming](/r/programming/search?q=author%3A%27Fruzenshtein%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|6% [starcraft2](/r/starcraft2/search?q=author%3A%27Fruzenshtein%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|6%
&gt; and is not blatant advertising. Of course it is. This account's sole purpose is to submit the same site over and over again. Its not contributing to any discussion, it's just trying to drive traffic to the site. Classic spam. And it's also against Reddits site-wide rules (linked at the bottom of each page). 
Note sure why I am getting downvotes, Jetbrains themselves recommend putting .idea in version control with a few files as an exception. Details here: https://intellij-support.jetbrains.com/hc/en-us/articles/206827587-How-to-manage-projects-under-Version-Control-Systems
No, not really. This is oft-cited as gospel, saying that it causes problems, but it's cargo-cult thinking. At least with Eclipse (and I'm pretty confident IntelliJ has a similar story), you can avoid putting filesystem paths in project files (you can set up variables), which is the most common reason given to avoid checking in project files. &gt; Once you do this your team can use whatever IDE they like Not a reason for checking in project files. You can even check in both Eclipse and IntelliJ settings if you like. Checked in project files have advantages, and most disadvantages I've heard can be easily avoided. It is nice to have projects easily setup. OTOH, if you are generating the project files with Maven (there's a Maven Eclipse plugin) and you are happy with them, it's probably best if you don't check in the generated file. As far as I aware, though, it's not a perfect solution. Addressing points in another posts &gt; Files which store the state of things like editor preferences should not be shared in my mind. Why not? If there are project guidelines and IDEs can be automatically setup to do so, it's idiocy not to do so. What is a big no-no is using your IDE to build. But checking in IDE project settings is orthogonal to that. 
I've done it personally. But would not recommend it for a large team (everyone using both)) And the ide specific files shouldn't be in version control anyway. I generally let developers use what ever IDE they like.
we still plonk? nobody actually kill-lists anyway, it's just saying "ooh burn".
Sorry, but I wasn't replying to what you quote me replying to. You *must* always be able to build without an IDE. I was replying to keeping IDE settings outside of source control. 
Gmail is pretty nice.
No problem. I produce music for fun and was using it without even noticing it was a Java program until a few days ago, lol.
It is written in java and compiled to javascript
What do you guys think of https://lmms.io/ in comparison?
It's a good free alternative. I actually recommend it on my music production related blog as a good free alternative. Do you know if it is Java?
Thanks for that! I'm interested in that since Java applets are pretty much dead(IMO). 
HTML5 does seem like the way to go for modern web apps, but I also really like Java. I'd definitely be interested in at least knowing how to do it.
* [Scene Builder](http://www.oracle.com/technetwork/java/javase/downloads/sb2download-2177776.html) - the JavaFX Editor written in JavaFX * [JavaFX Ensemble](http://2.bp.blogspot.com/-wXSkXwW06FI/UGCr1wbLWSI/AAAAAAAAAsU/RVSgLdrL-QI/s1600/Ensemble.png) - the demo for JavaFX * [Henley Sales](http://docs.oracle.com/javafx/2/best_practices/img/livetab-small.png) - an application written in JavaFX to showcase performance of JavaFX by using live feeds processing and displaying large amounts of data * If you are listing Minecraft, Android would also count?
Poker Copilot (https://pokercopilot.com) is written in Java. Is the UI beautiful? As I wrote it, I'm not impartial at all. But I like it! 
I believe @AfterAll is just a new name for @AfterClass. Perhaps you can add a @BeforeTest(testidentifier, concurrency): @BeforeTest(foo) void fooConcurrentPart() { ... } @Test void foo() { ... }
Does it use UTF-8?
It's also called NIM -- and uses stones. Mancala is more complex but more fun
Great explanation! Thanks!
Cool tool!:) Out of curiosity, was it made using Swing?
By "real business application" do you mean it's actually being used currently? If so, that's pretty sweet!
I don't really agree that a download counter on Maven Central would provide much benefit. MC isn't used to discover new projects, it's just a big directory you use to retrieve libraries you've already discovered from other sources.
&gt; nbproject/private/ No, your top-level [`.gitignore`][1] defines that pattern as: &gt; /KitchenSink/nbproject/private/ You should change it to: **/nbproject/private/ But what I was recommending was eliminating the Netbeans files altogether. **/nbproject/ Some people like Eclipse and others may like to use IntelliJ. They may not want to see those files checked into source control. This is just a suggestion though. [1]: https://github.com/codenameone/codenameone-demos/blob/master/.gitignore
Good point. I guess I am mostly trying to get at nice-looking java applications, rather than just menus and various controls. I'd still consider Minecraft's UI pretty nice since it is all custom.
Looking at the source code lmms is written in C++
[src diff](http://hg.openjdk.java.net/jdk9/jdk9/jdk/rev/4f6e52f9dc79)
ISO-8859-1/Latin-1 or UTF-16 from the sounds of it. 
[removed]
I wonder why UTF-16 was chosen? Doesn't it basically only have disadvantages compared to UTF-8?
AH look mvnrepository.com is something something like this: http://mvnrepository.com/popular
UTF-8 encodes characters in 1, 2, 3 or 4 bytes, whereas UTF-16 uses either 2 or 4 bytes. For most European languages, UTF-8 is usually better, as all ascii characters can be encoded as 1 byte. Chinese and Japanese characters however are well above the the 1 byte threshold and depending on their position in the Unicode table need to be encoded as at least 2 or even 3 bytes in UTF-8, but only need 2 bytes in UTF-16. This stackoverflow question has some good answers, if you are interested: http://stackoverflow.com/questions/4655250/difference-between-utf-8-and-utf-16 Also, UTF-16 has been the default encoding for strings in java since it's beginnings, I think. 
If you have several free weeks, then go on ... It isn't as easy as it sounds. 
You do your back-end in Java, and your front end with javascript.
AutoModerator removed it for spam suspicion, but I think the article is ok. It's also pretty naked: Not wrapped into five thousand "Look here, too!" links or banners etc.
No, they are really not.
It's bad advice. Your project build should be ide independent. And that is what should be in source control. The idea directory contains compiler home directory for example. This won't be the same between developers using the same ide. 
but it's 2015 - why do we need another Pattern article?
I hear Wakfu is java game too http://www.wakfu.com/en/mmorpg/media/screenshots
Drives traffic I guess. Same as with all the other basic tutorials that get posted here.
Point taken, thank you! We are about to push the first version of the [Excelsior JET Maven plugin](https://github.com/excelsior-oss/excelsior-jet-maven-plugin) to Maven Central. Do you think making all options available in that plugin is the right way to address the issue you had with configuration files?
As far as I know GMail is not based on GWT, but Closure. See this [question](https://www.quora.com/Is-Gmail-built-on-Google-Web-Toolkit).
&gt; And what about open-source non-corporate software? We are used to provide free licenses to public non-commercial projects. The only problem is that the Excelsior JET Runtime license is not GPL-compatible as we are a commercial Java licensee.
This question assumes as if we chosen some random existing coder and rewired everything to Latin1/UTF-16. This is a puzzling way to think about it. A more straightforward way: Strings are storing the character data in char[] now, as UTF-16. JEP 254 introduces a special (but very ubiquitous!) case when those chars have a zero higher byte, which means we can store only the lower bytes, in byte[]. This is simple concept-wise, has almost no suprising performance problems (e.g. the conversion between the forms is very straightforward, the asymptotic complexity of most ops is the same, etc). By a sheer coincidence, that also similar to storing character data as-if encoded by Latin1, hence a handy alias for the storage scheme.
This is not a case for /r/Java, this is a case for /r/techsupport. I really do hope that you didn't restore to the same Hard drive because otherwise the file might have already been overwritten. One lesson to learn from that is to use Version Control with remote repositories (like git). Commit and push often. **Post removed:** Has absolutely nothing to do with Java.
Someone likes adding braces to places they were irritatingly missing. I like that
Also it's a shadowbanned account, with a history linking to [the very same site beforehand](https://www.reddit.com/search?q=romiz_rahaman&amp;sort=relevance&amp;t=all).
I think everyone knows what fibers are at this point.
I desperately wish the JVM had native support for continuations. I think it would make things like this way more powerful. Not to mention the usability would not be just for libraries, but can be enjoyed by all java developers.
My apologies. But to me it appears the help section is mostly utilized for instances where there is an actual coding problem that requires help via an advisor. Wouldn't my question not be more of a technical discussion? as it is related towards my interest in Java programming? (not intending to come off as a smart ass)
That would be an ok option for the compiler itself. The .prj file format is already plain text, so just having a solid documentation for it would suffice nicely for us. The Jetpack project file on the other hand is just obscure binary, and looks like the Maven plugin doesn't address this at all. My two wishes would be: 1) Make the jetpack project file human readable. This would also enable us to manipulate build configs automatically, and store the config files in git. 2) Let me to supply .pfx file with password, and end up with a signed installer that delivers a signed .exe. Now I need to run jetpack twice, first to generate the image, then sign the .exe in the image manually, and then rerun it to wrap the image into an installer.
I'm quite happy with the UI I was able to make with JavaFX for Lighthouse. There's a video on the website or check out the usage pag for screenshots. The GPU accelerated animated blurs are especially nice. https://www.vinumeris.com/lighthouse
where or how can i get splitted version of this session? Can't google it
Just added it to the list. That's pretty epic; I'm not gonna lie. (I'm a big fan of Bitcoin as well!) My question is how do people donate after you setup a project? Is there a web version for it?
Nice! 100% java?
.project indicates that it's a Java project, instead of (or in addition to) one for PHP, or Python. .classpath file indicates where sources are, which JRE and .jar files to have on the classpath when building (and later when running classes in the project), and where the output folder(s) for the class files are. None of this relates to in-editor preferences such as syntax coloring, the handling of whitespace, or any extra templates that might have been added for use in Content Assist. If you're going to disagree with me, at least explain why.
see this thread: https://www.reddit.com/r/java/comments/3u91g6/programs_written_in_java_that_have_the_most/ 
Because: public class MagicRemover { public boolean equals(Object anything) { return true; } } // This worked before generics List&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); integers.remove(new MagicRemover()); Not that this would've made any sense in the first place, but the contract of `hashCode()`, `equals()` and much of the collections API is so heavily intertwined, it just seemed for the ever so conservative Java language designers to be wiser to have an irregular language / API, rather than to break backwards compatibility. You have to give them credit for actually having thought of all of these compatibility edge cases (which probably never happened to anyone)! [See also why you can still declare `abstract` on interfaces](http://stackoverflow.com/a/7202659/521799). **TL;DR:** [If in doubt, blame backwards-compatibility](https://www.youtube.com/watch?v=2y5Pv4yN0b0).
reasons for Spring before basic Java EE?
Imagine a huge corporation that misconfigures their Maven caches. You'll get 1 million re-downloads. Meaning? Nothing.
I'm a bit disappointed that the only remotely "commercial" approach here is the "no-license" approach, which is really not a good idea at all. During the past years, I've met many library developers who've been inspired by our own library [jOOQ](http://www.jooq.org)'s business model - a self-sustainable library that pays the bills and continuous maintenance without depending on a [corporate sponsor that might just jump off any time they please](https://www.quora.com/Why-is-Pivotal-ending-the-sponsorship-of-Groovy-and-Grails). These developers are just as passionate as the ones that might blindly go into all-open sourcing their work, without thinking about the interesting business aspects of their software. They're looking for solutions that: - Give them a distribution platform - Help them evolve and grow - Implement open source to some extent if they wish - Don't make them the slaves of their communities Just picking any of these Open Source licenses is not enough. Developers should pick a more farsighted strategy. There's a world beyond GPL, LGPL, ASL, and MIT...
This program that you're describing is sufficiently complex to that point that any programming language would be reasonable as long as it has support for a few things: File I/O, OpenGL or another 3D graphics library, math libraries, UI libraries. You are in luck that Java is sufficiently powerful that it has easy support for all of these. It sounds like you haven't had a lot of experience with building large software projects, so my general advice to you would be a few pieces: - Try to use libraries when possible. Don't roll your own everything. Sometimes there won't be a good library, like your particular snapping logic is going to need to be written by hand. - Keep a list of features. Start small. Build slowly. Don't be afraid to rewrite or throw away sections of the code that slow you down. - OpenGL for Java (JOGL) is a potential choice for the 3d display, but there are a few other libraries. Whatever you're comfortable with is fine. - Use version control. - Use a build management tool like Gradle (or Maven) and keep the build description in your source control. I would be happy to advise you on your programming project if you want, but you have to understand that what you're talking about sounds non-trivial and it's going to take a lot of nights and weekends to make it real. Feel free to send me a PM and we can try to set up something more specific, email / code reviews / skype meetings / whatever.
I followed Jetbrains' recommendations, and had problems... YMMV
Good point. Closed source does prevent people from knowing what dependencies it has. So you won't know absolute usage numbers. I guess there is some question as to if closed source and open source have similar usage patterns. If the patterns are similar, then the open source can be a proxy.
I always figured it was because many of the collections structures use an array of Objects internally, since you can't make an array of the generic type?
Spring is now in much higher demand than EE... It's better at all levels and it's free.
Do we really need a new buzzword for a Thread ?
Spring is not a build tool. Spring does have guides for getting started with Maven ( http://spring.io/guides/gs/maven/ ) or Gradle ( http://spring.io/guides/gs/gradle/ ) though.
It's a different concept. It's language level threading rather than OS level. That being said, couldn't see myself using it 
I totally agree with this! The auto-magical behaviour of the heavy DI frameworks like Spring takes the control out of the developers hands. Instead of configuring this black magic, the developers should just write Java code to configure the components and wire them together. And it will be much more cleaner with pure Java 8 + proper DSL than Spring's "learn the convention + find the right configuration + hope that it works" approach. Coming soon - in Rapidoid 5.1 or 5.2.. :)
Well, there's a graph right at the main page: http://mvnrepository.com/
If you run you fibers on thread pool, then obviously, yes. If you use single thread, then no.
Thanks, I am doing my best about the documentation, so it gets improved often... I will be happy to get some feedback about which part of the documentation is confusing, what needs more explanation, etc.
If anything, we need something more restrictive than threads, not another implementation of threads.
Read about the early days of EJB and how Spring's IoC container came along and did better. To answer your question, no, you'd be starting with the basics with either choice. I think I know where you're coming from though. Read up on 'Servlet', which has been around since the early days of Java EE, as Spring MVC doesn't seek to replace it, but enhance it. The core concepts of Servlet are really simple and worth the read as Spring MVC and Spring Security as it applies to Spring MVC build a ton on it.
Pretty sure it's not new. Also it's a specific kind of thread https://en.m.wikipedia.org/wiki/Fiber_(computer_science)
&gt; Thus, since the return type of remove is boolean, we are in no danger of taking the wrong thing out. And because remove doesn't add anything to the container, there is no danger of corruption. So why should remove have a type bound instead of just taking Object? But removing an `Integer` from `Set&lt;String&gt;` is always going to be a no-op and probably a mistake. Why not catch the mistake at compile time? 
**Collection literals** Pretty sure there's a strong logistical argument against this for one reason or another. Too tired/lazy to find it atm. **Structural Typing** This is a *fundamental language change*. Java is not a ducktyped language, and it is extremely unlikely if not impossible for it to become one simply because of how, again, fundamental a feature that is. **Dynamic call sites** Again, *very* fundamental aspect of a language. Java is most definitely not a functional language, even with the inclusion of the Streams API. (Assuming I understood this section correctly; again, I'm very tired so I might have misinterpreted it.) Also, last I heard long array indices was slated for Java 10, although this has been the case since long before the release of 8 and may have changed in the meantime.
My biggest issue with moving from one IDE to another is the difference in code formatting. As hard as I try, I cannot get the different editors to format my code EXACTLY the same as each other. So when I commit the code to my repo, many unnecessary changes are stored simply because of these whitespace differences. I wish the three editors would agree on what formatting is possible and come up with a standard formatting save file that could be used interchangeably.
That chart shows how many artifacts are in the Maven repository. Not downloads.
The important ones are covered by Scala anyway.
so are you telling me I can use it to make my application web scale? because my CEO says I need more web scale for making our Ninja platform connect creators and producers in a crowdsourced way. Our 14 market leader users are using our innovative platform to make game changing gains. If We could use Fibers to synergize our platform for the next generation of web scale development VC will rain money on our glorious endevour. 
Code high in fiber will turn out good shit code
What is the default?
Not really. EE came before, spring then came with the goal to fix it with quite different approach, then the newer version of EE copied a lot from spring to catch up... Focus on your goal, there is no dependency between them when learning them.
&gt; then the newer version of EE copied a lot from spring to catch up... So JPA and CDI were inspired by Spring? Don't think so! JPA is based on TopLink and Hibernate, nothing Spring there. CDI is from the Hibernate creator Gavin King and based on Guice, JSF Managed Beans, EJB, and SEAM. Nothing Spring there.
No reasons for that. Start with Java EE ;)
This question does fall in a bit of a gap - it isn't really programming help with Java, but you should bare with some of the people here who are sick to the back teeth of homework being dumped here! That aside .... Libgdx - high(er) level 2d and 3d graphics - UI better suited to simple game UI's (can do mobile as well as desktop with same codebase) (tiny stub for sub platforms like mobile, desktop etc) LWJGL - very flexible but much lower level - good way to learn the basics of modern OpenGL (could be a good way to get a grounding with GL) JavaFX - can do 3d but sadly no support for shaders (but can just manage lit textures) great for UI's You *might* be able to hack a JavaFX UI working with a LWJGL render I would strongly recommend tackling a decent number of much smaller projects for the purposes of learning - try different (and NO) IDE's Good look (you'll need it with a mammoth project like that!)
Thinkorswim has a nice UI as far as day trading software goes
I tried it out. Looked quite interesing. pure java from UI to server side + CRUD + cuba rad studio + visual interface constructor + ready enterprise components (charts, text search, ...) makes it very attractive for LOB and enterprise app development. Actually I heard about Cuba platfrom at DZone about half a year ago. Then as m$ developer saw them at http://blogs.msdn.com/b/lightswitch/archive/2014/12/05/where-we-are-and-the-road-ahead.aspx?PageIndex=10. Then reddit. Seems their community is growing. Also support forum is active https://www.cuba-platform.com/support/.
Gains are not marginal. Threads have difficulty scaling to large numbers, that's why you see single thread stuff like node.js or lmax disruptor gaining ground. Problem is that these things change programming model (arguably for the worse). Fibers are middleground - same programming model for much smaller price. Recently we needed to create an application which was running concurrent lightweight "processes" numbering in low tens of thousands. We initially tried to do it with threads, but performance was not good and we hit some OS limits (ulimit etc.). We had to go with similar approach as node.js, but it complicated the code in unexpected ways.
Reading code like that makes me want to punch people. Not you, you are just giving an example, but anyone who wrote stuff like this for real and it ended up in production. Just so wrong...
Interesting...... Personally all things being equal I will always choose a for-loop as its easier for my brain to process. and for a sequential stream it looks like for-loops would be same or quicker...not surprising as only a single thread will be processing this. However, If I have a quad core i7 (4 real cores and 4 hyperthredded virtual cores), and I want to write some code to process stuff as quick as possible then I would have to 1) Find number of cores 2) Launch certain amount of threads 3) use seperate for loops for each thread 4) concentrait on threadding, synchronisation, locks, etc. At this point, the for-loop method becomes much more complex for my head, and error prone. So, I would then switch to using streams, to make it easier for me. I will point out that for web development / OLTP the use cases for having to write multi-threaded code for performance reasons, is few and far between, especially since this type of code would actually slow down other requests. 
As guys are saying, CUBA platform is fairly new in the international market. However, it has been used internally in our company for 5 years for the real world projects (some of the projects are mentioned here https://www.cuba-platform.com/solutions). In fact all our solutions are built on CUBA. You are welcome to give it a try and share your experience!
Does the Java stream api do the [par thingy](http://docs.scala-lang.org/overviews/parallel-collections/overview.html) to?
I had an interview that required a Java developer with experience in Spring, but I didn't have working experience with Spring. They were ok with me studying Spring and reinterviewing in 2 weeks. So I studied just the Spring annotations. Their questions were all XML. I didn't get the job.
Articles from JAXenter are usually good. Especially if they are from Angelika Langer! Bad AutoModerator!
Seems very similar to the performance hits you see from using for each loops. Allocating and collecting an iterator can dominate your run time if your code is otherwise comprised of tight loops, but if this code is part of a more complex system where allocations, and IO are already occurring, the performance difference is pretty easy to swallow.
https://i.imgur.com/cU0iqUH.png Eh? Eh?
From a comment below it would allow for compile time error checking. I'm curious if they would be written the same way today.
&gt; Collection literals &gt; &gt; Pretty sure there's a strong logistical argument against this for one reason or another. Too tired/lazy to find it atm. https://www.youtube.com/watch?v=OJrIMv4dAek Nice talk about the Java 9 Collections enhancements proposal (a.k.a. Builders) that also explains why this path has been chosen over Collection literals 
&gt; But removing an Integer from Set&lt;String&gt; is always going to be a no-op and probably a mistake. Are you sure? What if you wanted `x.remove(1)` to remove `"1"` where `x` is `Set&lt;String&gt;`? For example, if you were implementing type juggling? Of course you can't do this with the ordinary JDK types, but what about your own type hierarchy? The equality contract allows you to implement exactly this behavior, by requiring only symmetry, transitivity and consistency. The [spec](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#remove-java.lang.Object-) of the `remove` method: &gt; removes an element e such that (o==null ? e==null : o.equals(e)) The contract of `remove` states that the method will remove any element which satisfies the equality contract. The equals method takes `Object`, it is not parameterized on the type of the class. This is from the original spec of the Collections API. The JDK class designers only added generic type bounds where it did not conflict with established contracts. Thus, `remove` must take `Object` to satisfy equality.
I have been using streams a lot lately. Mapping, flat mapping, and filtering are such absurdly useful features. It's not even about the ability to loop over data. I use it because it's easier to transform data. Then of course the ability to make it parallel by adding one word to the code is super nice.
 int m = Arrays.stream(ints).max().orElse(Integer.MIN_VALUE);
Except that we don't only have experienced developers working on the code. And we might have had a good reason for &lt;= instead of &lt; at one point. And even if we didn't have a good reason for it, it's lost in the other characters all around and isn't immediately obvious that it's there. And even though we can all read for loops and if statements, it's extra work for our brains to do that we wouldn't need to do with the more concise, readable version.
I think streams are very handful, much better then foreach loop. Their are not as readable as other programming languages, but you will get used to them.
The for loop relies only on language constructs, the streams example depends on a library. How anyone could understand what reduce(min,max) means without looking it up is beyond me. On the other hand, everything you need to know about the for loop is right there.
You can donate with the desktop app too (and revoke your pledge). Someone also made a web app version, but I don't recommend it be used, as otherwise the private key is something you need to save in a bookmark. It's a bit too easy to destroy money this way!
Epic! Thanks for that. I added it to the list. Do you personally use the software?
Fair enough.
That's true, but /u/Nolari's example using Stream.max() is much more readable than using reduce, and much more obvious as to what is intended than the way the for loop is written. Map and Reduce are complicated beasts. Streams aren't. And whilst Streams may not be as performant as traditional for loops, the fact that they can make understanding the code easier was my whole point. And my whole point about experienced programmers wasn't that they would find the Streams easier, but that they would possibly be more likely to put the off-by-one error in the for loop, and they would possibly find it harder to see what's wrong with it. The Streams method actually makes it significantly to put that kind of error into your code, which can only be a good thing.
You are correct there is no such thing as "language level" but you both are essentially correct that the thread of execution is handled in the user space instead of the kernel. Nothing prevents fibers (aka coroutines) from being a feature of a programming language where syntactic sugar can make creating and managing fibers easier. Regardless of it being supported natively by a language or by a library, fibers will still function within the user space of the application (process). You are incorrect when you assert it's the same concept. Fibers differ from green threads, since fibers use cooperative multitasking while green threads emulate preemptive multitasking within the application (process).
&gt; The for-loop is substantially faster that *[sic!]* the sequential stream.... It is faster for a different, simpler computation in each iteration. What the stream does is closer to: for (int i = 0; i &lt; e; i++) // if (a[i] &gt; m) m = a[i]; m = Math.max(a[i], m); At least in my microbenchmarks, performance becomes mostly equal (i.e. the above is as slow as the stream version). Sure, there is some overhead expected with streams, but if the loop version doesn't get optimized when doing `m = Math.max(a[i], m)` instead of `if (a[i] &gt; m) m = a[i]` one cannot really expect the stream version to do so. The author should have presented a fairer comparison. Having said that, she could have focused more on the limited expressiveness of streams (by design or not) and discuss the pros and cons of that. After all, it is not possible to express the exact same computation with streams. Someone here presented this version: Arrays.stream(ints).max().orElse(Integer.MIN_VALUE); This does essentially the same work: // From the implementing IntPipeline public final OptionalInt max() { return reduce(Math::max); } Which eventually leads to a sink: private boolean empty = true; private int state = 0; public void accept(int t) { if (this.empty) { this.empty = false; this.state = t; } else { this.state = operator.applyAsInt(this.state, t); } } Where here this essentially becomes (after mentally inlining etc.): private boolean empty = true; private int state= 0; public void accept(int t) { if (this.empty) { this.empty = false; this.state = t; } else { this.state = Math.max(this.state, t); } } 
I really think this is a false distinction. Nothing mandates that user mode threads can't be cooperative.
Well if you don't know what map/reduce/filter functions are then you are not really a good programmer, they are not java constructs.
&gt; The primary reason is because they compare int to Integer. Where? `Arrays.stream(int[] array)` returns an `IntStream` (a `Stream` specialised for ints. `IntStream.reduce(int identity, IntBinaryOperator op)` (and `IntBinaryOperator`) also operate on ints. Where do `Integer`s get created?
Java 10 hype then. Maybe.
Well, I would argue that this kind of attitude is very narrow-minded. Hear "trigger-word" -&gt; dismiss regardless of content. Reminds me of two relatives discussing politics and basically agreeing on core things, but when both mention certain keywords in some irrelevant sentences - both get triggered and go into stupidity mode. One immediately labels another as socialist-communist, another labels other right-wing redneck and discussion is over. In my view article correctly talked about xml and then explained about annotations.
This is exactly how spring went for me. I loved it when I was young and building a new app. All the complaints about hard to understand I brushed off as idiots who need to RTFM. Older wiser me has learned if I'm calling someone an idiot because they don't understand the library it probably means the library is too complicated. Also the version conflicts are frustrating at best. Let a stable library be that uses spring 2 and the new apps using spring 3 break at runtime.
"XML? If you don't like it use annotations that are magic?" Did you hear about Java config that is being pushed around for like 5 years now, it's totally typesafe and easy to maintain? Also Spring is full of magic for those who don't understand the magic happening, to me it is really simple, most of that magic is object proxying, nothing more or less. Furthermore, Boot is only a Spring evolution, and more like a framework to help you and make using the Spring framework itself easier. It's really not unusual to take an existing framework and build something on top of it to make it more general and easier to use, a good example is Netty, alot of frameworks build on top of it, so is it also a framework that needs a framework? Boot is just an autoconfigured Spring that fits most users, but still leaves you all of the power and free hands for writing anything you want in the "real" Spring.
While I agree you're not seeing the effects until runtime, you should absolutely have enough automated tests in your code to capture those breaks early on.
Yeah you should but it doesn't always work out that way. Most codebases I've seen are at best 80% covered or use so much mocking that some runtime errors slip by.
Well, it's pot meets kettle at best. I mean, this point (and the article doesn't make any other besides XML and complexity) has been talked about to death. Why do we need another rant by some random Joe I never heard of?
But at that point, why bother with static typing at all? If your answer is "unit tests" for everything, you might as well just ditch Java and use Python. The problem with unit tests is that you can never know when you have enough (please don't say coverage solves this problem). With type-safety you have a universal quantifier. You can only check what your type system allows, but whatever you check you know that it applies to every input your program could ever possibly have. This is incredibly powerful and its not worth giving up to make writing the code slightly easier. 
There is a common misconception here. Threads don't have pitfalls per-se. It's the mechanisms of sharing data across threads that is tricky. Every approach that works with threads also works with fibers, but as the the task-switching cost is at least an order of magnitude (or two) lower, some things are just cheaper. Yes, you can use locks. But it might be better to do what Go and Erlang programmers do with their threads, which is to exchange messages among threads across channels or as messages to actors. Quasar has full support for Go-like channels (including selection) or Erlang-like actors (including selective receive), each available for use either by heavyweight threads or lightweight threads (fibers).
&gt; The author should have presented a fairer comparison. Why do you think it's fairer to make the loop deliberately more complicated just because the stream version needs to be? If not using Math.max() turns out to be faster and is trivially avoidable in the loop but not in the stream version it's still a fair comparison that just shows that the limited optimization potential of stream based code.
The default is the same as (the current) default in Go and Erlang -- a work-stealing scheduler employing multiple kernel threads. Unlike with Erlang or Go, you can assign each fiber to a different scheduler. Other than that, Quasar fibers work identically to Go's goroutines or Erlang's processes. What's cool is that you can also run traditional code in fibers, such as tell Tomcat/Netty/JBoss to schedule servlet processing on fibers instead of heavyweight threads.
&gt; If anything, we need something more restrictive than threads, not another implementation of threads. Restricting a thread's handling of data and thread implementation are two completely orthogonal concepts (in Quasar and in general). If you have linear execution of code and a call-stack -- you have a thread.
&gt; fibers use cooperative multitasking while green threads emulate preemptive multitasking Quasar fibers are preemptive, but not time-slice preemptive. Not because they couldn't be. In fact, early versions of Quasar had time-slice based preemption, but we took it out because it provided no benefit. I can explain why if anyone is interested. Green threads and fibers are the same thing. However, the term green-threads is not longer used much, and when it is, it usually implies fibers that are all scheduled to a single kernel threads, while fibers are often scheduled to multiple kernel threads, so they offer true parallelism.
So did the xml though. They're not immune to static analysis, it's all static final. Just no one's made a good tool for it. I just like not having to keep two files open.
It's your fault if you let implementation details leak out of your interfaces. As others have already said Spring hasn't been pushing XML configure for years now. Finally, what is the alternative for handling class dependencies? Neither vanilla Java nor JavaEE offer a superior alternative (indeed inferior). I don't know of any other third party frameworks that do as good of job with class dependencies as Spring or have nearly the support, battle testing, and wide spread acceptance spring has.
&gt;XML I don't like my own methodology, and have decided to make no attempt to update/change it in 5+ years. &gt;magic You can manage interfaces, types, and provide qualifiers where that's vague, to manage a simple concept that has exists in j2ee using the exact same annotations. FFS you're a god damn wizard Harry!?! &gt;Importing other Spring files : I really do wish it had an optional for junit testing =/ that's trying to solve something that should be handled with those spring profiles anyway though. Not like the dependency wasn't already there. Say you have your datasources.xml that provides an entitymanager off in the dao jar, not like your application is going to run without something providing that entitymanager it's asking for all over the place anyway. &gt;Complexity You string them up for the configuration, then they remove most of it by providing you with prepackaged common defaults and you string them up for that too. Really? I mean yea basically shoving a full j2ee container into that shit was probably going too far, but attacking it on the idea is kinda cheap when it was to fix the shit being compained about farther up in the list. It's like calling someone guilty for apologizing.
It's fairer because it compares apples with apples instead of oranges. The author's argument was that a simple benchmark is to be used to properly compare the two implementation methods. However, operationally they do not perform the same thing in the variable part of the respective patterns (loop body and reduce operation respectively). So can you conclude that choosing loops is faster for such tasks than streams? No. A benchmark cannot be equal, after all you are comparing two different things, but first you have to put them on comparable footing. Maybe the argument should have been "streams are not as expressive as for loops, here is why..." To support this claim the code would be fine. However, the claims and analyses presented are about overhead of a library vs. a language primitive, and that the JIT compiler can optimize a loop while it cannot well optimize a stream, cache lines, hardware, cores etc. This is not substantiated. P.S. I don't think the loop body is artificially complicated. It is quite easy to understand with the max call and it appears likely to be optimized (though it isn't), so I would not at all be surprised to see something like that.
Ah ok, I didn't realize that you took it from the article. But then I wonder why the author of the article didn't use range based for. You are right that ranged based for would use iterators if it were a Iterable subclass but as it's a plain Java array the performance of ranged based for is at least as good as when you use an incremented index. Actually with ranged based for on naked arrays you can be sure that the JIT will always be able to avoid superfluous array bounds checks which may otherwise not always be the case depending on how you calculate your loop bounds. I understand the not part of the core language argument and it may be valid in some environments but I think it's a rather weak point especially considering performance critical code. Eventually you have to start to rely on proprietary code anyway in any non-trivial program and several aspects of the core library are so poorly implemented that it's often an option to use them. For an example just look at the implementation of the nio file API introduced in Java 7 or pretty much anything else in nio.
But the guy clearly isn't up to date on spring. If he chooses to remain ignorant on a subject he chooses to write about and authoratatively declares he "hates", it becomes hard to take him seriously. Not to mention some of the issues he ran into to aren't issues idiomtic of spring, but idiomatic of poor design. If you choose to make an application and then have its sub-dependencies/modules depend on different versions of a third party library the fault doesn't lie so much with the third-party library but your inability to manage your dependencies. His criticism of Spring Boot doesn't make any since either. Spring Boot is about containerization of Java applications and handling a lot of the boiler plate of spinning up a new application. Again, this is an issue regardless of what framework you choose to use. The guy brought nothing to the table and everything in his article suggests he is much less smart than he thinks he is.
first one is more readable to me and yes i noticed the &lt;=
Thank you! I've hated spring for years, but always been told I was wrong. I hate using annotations for configuring - it often leads to tight and unnecessary coupling. That's actually where I prefer external config, but it's a fair point that it's harder to test etc.
Scala has compile time checks for dependency injection. This article describes [three methods](http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/) without using a library.
In Java 9, not even 10? That would be very nice. Any links to JEPs, discussions, ml-threads?
That's an issue with Java and its tooling, not with Sprig though. It's not as though you could hope to switch between languages over such an issue either (unless you work for a start up). 
Not sure what startups you are referring to, all those I've been involved with have moved way too fast to be willing to go back and change tech, as it's fairly little value add for a while. We just start new projects in the other thing we think solves the problem better.
Spring is broken into a ton of pieces you can compose together, saying just "spring" anymore doesn't really tell you a ton. Though isn't spring boot more of just a sane default set to use with spring, not really a meta framework..?
That's kinda my point. With well established companies, it's typically difficult to introduce such new and radical changes because all the employees know X language. Whereas with a startup, there is less investment in a given technology.
I used to work with /u/vermooten, disregard what he says.
Intellij or Eclipse both handle clicking through spring injected objects.
yes, you can't reasonably expect for people to know what classes in the standard api do.
If you're worrying about performance optimizations you must have a very good piece of software already.
Redo of the collections API? You mean the component container hierarchy?
Yeah, the off-by-one error was the first thing that struck my eye. I don't see how anyone cannot notice it. Personally, I find the following the most readable: int m = Integer.MIN_VALUE; for (int i: ints) { if (i &gt; m) { m = i; } } 
Meanwhile in the mystical land of Java EE with TomEE... https://www.youtube.com/watch?v=fQOqzjtteDE Code change causes hot-redeploy taking 1 second! But, like I am moving everything over to Spring boot, giving up the 'heavyweight' Java EE, because Spring and Spring boot with Automatic Restarts are like so the future! &lt;sarcasm/&gt; 
The guy says he writes his own application context. Because AOP and bean scopes is easy to develop.
I really, totally hate spring. It has nothing to do with DI, but more the mindset that spring brings along with it. For example. There is spring profiles, where you have a configuration file that can have different configurations based on a setting. http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html So, for live deployment, you have a different profile, than say development. The thing is, its totally idiotic to have such things.... It leads to large complex configuration files, maybe even per-developer configuration that ended up been committed to Subversion. In short, it leads to a mess. The correct way should be to let the application pull information about the environment it is running in. Maybe by JNDI? This way, if say a database URL changes, then a whole new build/redeploy doesn't need to happen. Ops just do the update themselves. and bam....done. Then this Spring Boot thing...... Where webserver and app is all rolled into one...... perfect for microservices...... We have several of these spring boot apps running on a single server..... the memory requirements are huge, to allow for caching. Hibernate connections have to have caching turned off as an update by one service might not be seen by another.... its really slow. its not the way.... then you have things like Spring Data Rest, which " makes it easy to expose JPA based repositories as RESTful endpoints. " Why does noone scream this is a very bad idea!! - it makes it so that you cant change the JPA repository, without changing your rest interface!.... the correct way would be to have some kind of MVC layer that interperates Rest requests, gets data from the datastore in whatever way it needs to, populates a DTO and sends it back. In the end, the amount of spring projects I have worked on that end up just a mess, because people have followed these principals. Spring DI is ok, however the way it is advocated using it is to have a big service layer, and anemic domain. which is procedural code.... This isn't a fault of DI, but more of the 'Spring Way' mindset. Spring, in my opinion, has done more to hurt Java than anything else. 
Disclaimer: I am the project lead of Spring Data. &gt; Why does noone scream this is a very bad idea!! Why do you think it's a bad idea to remove boilerplate code from software projects? &gt; it makes it so that you cant change the JPA repository, without changing your rest interface! No. Evolving APIs is hard, with or without Spring Data REST because once you've gone public with an API there are only certain things you can do to it. Whether the code that produced that API is a library (which helps you simplify things in the best case) or your custom code doesn't make too much of a difference. SDR actually leverages hypermedia intensively (ironically something people have complained about) which *improves* changeability. So one could argue that by being sent down that route by the framework, it's more likely you really get to use REST's beneficial parts (which evolvability is a key part of) rather than the usual "I flip some database tables by 90° and throw them as JSON over HTTP and call that REST", which is — in my experience — rather the default than the exception. &gt; …the correct way would be to have some kind of MVC layer that interperates Rest requests, gets data from the datastore in whatever way it needs to, populates a DTO and sends it back. As that's sort of what SDR does I have to assume you haven't spent too much time on it. You're right, it doesn't use DTOs, but there usually are a few ways to skin a cat. The SPIs, the projections feature and Jackson customizations have proven to be a useful toolbox for all kinds of customizations. And again, that's nothing the tool makes you having to think about, designing representations is the tricky part and the defaults we chose are in place for a reason (as usual: experiences from real-world projects) but can be differred from if needed. If you want to have a look at amore involved sample, here is a Spring based implementation of the RESTBucks sample from the RESTful web-services book, that uses SDR for the CRUDdy parts but then hooks in custom implementation code to implement the more advanced parts using hypermedia etc. https://github.com/olivergierke/spring-restbucks It's all about taking the pain out of the boring parts. Now tell me you really really would've liked to code all the boring stuff you get out of the box yourself ;).
Spring Boot also has hot swapping - https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html
As far as I know, you can redeploy code if you change only the body of a method, not its signature using an IDE. To use broader redeploy options one should lean on a premium tool like JRebel.
&gt; For instance a guy called an @Transactional method from within a service, but because he was calling it from the service the proxying didn't work, because it only proxies outside calls. This behavior is clearly [documented](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/transaction.html): &gt; In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation, in effect, a method within the target object calling another method of the target object, will not lead to an actual transaction at runtime even if the invoked method is marked with @Transactional. Also, the proxy must be fully initialized to provide the expected behaviour so you should not rely on this feature in your initialization code, i.e. @PostConstruct. So you have developers using things they only half understand and it even works most of the time.. Now you hate spring and make it all constructor injection. Now your aforementioned Bozos have to implement all transaction handling by hand, every time. What makes you think that will lead to less fuck ups?
The gradle DSL is a mess. XML (ant, maven) is ugly and hard to parse visually
You have to say more than that. If you don't, I'm more apt to ignore you than the author. Not because I think you're lying, but because people who express their opinions of people and things the way you just did without any further explanation aren't usually worth listening to. 
My issue with this is that someone trained in FP would find the second more clear. And someome trained in OO would find the first one more clear. Familiarity isn't equivalent to clairity
I'm a bit surprised people here are comfortable with classical inheritance and interfaces but find a simple map too difficult to reason about
For me AOP would be fixed if the IDE was smart enough to tell you what was called when while browsing the code. Right now it appears magic, but it's nowhere near as bad as goto... 
By "basic constructor injection" I mean not using an inversion of control framework at all.
The problem is there is so much non-intuitive behavior. Those little pitfalls cost a lot of time and for someone to forget a detail like that when coding isn't that far fetched not to mention most people don't read the manual. Yelling that they need to doesn't fix it, people won't read the manual.
Right. I was pointing out a situation that the author might have found themselves in. Since they had moved to a different project, perhaps they were no longer in a position where they could change XML configuration over to Java based configuration. Instead, they publish a blog post about what they found wrong with XML based configuration and all its pitfalls. Now you tell me, is that so wrong? It could well have been their way of documenting all their mistakes? :-)
Dagger provides DI with compile time checks for Java. 
Xamarin forms is generally the less popular option. Its performance is problematic since it uses native widgets (really...). The problem is that iOS and Android differ too much and taking the Microsoft Windows XML UI format and applying it to those platforms requires a lightweight API. So they tried to squeeze it by with heavyweight widgets and as a result they ended up with an interesting compromise where you can share more code in common but its mostly good for lowest common denominator apps. Sort of like AWT was for Java developers. E.g. the concept of Activity has no equivalent in any OS other than Android. They are CORE to the Android API (e.g. Tabs). On iOS you have Controllers which have some common top level concepts but they are pretty far off. When you get lower into the API hierarchy the differences become far greater.
I find it easier to do most things on the command line but I like committing files using egit and deleting many remote branches is much easier with egit.
It does exist, for instance in scala you can make a transactional block which does not do anything magical it just wraps one function in another function. Even in Java its probably possible now that you can pass functions to other functions easily. Anytime you see proxying like the @Transactional annotation it can be replaced by wrapping a function in another function or higher order functions which are more predictable and can easily debug even.
isn't this just micro-stackoverflow? 
/r/graph
PM sent.
Thanks! I don't know either. Everything works without any issues in terminal. I might troubleshoot it a bit more later.
Nope, you can make projects with anyone and also just talk with everyone, lots of people from different places, it's fun! 
Why the down votes? I think this opinion is very valid. Actually there are DI frameworks without annotations and XML, like StructureMap (.net).
Make sure your SSH key is in the private key list in Window &gt; Preferences &gt; SSH.
What about this one: https://www.youtube.com/watch?v=APHJ-8FVA6U It's a pure Swing application.
I generally dislike IDE version control. I used to use tortoise for SVN and command line for git. Once you put in bash completion and git prompt, command line git is pretty awesome. 
I think I'm getting down votes because it's not a popular opinion. People like to use annotations because it's easy and they figure the coupling doesn't matter (if they even consider it, which, I imagine, most don't) because they'll always use this framework. Easy trumps good design every day in development and all of us, myself included, have been guilty of it.
And there's a JavaFX application: http://de.slideshare.net/TomSchindl/java-fx-ap-is Slide 21
Yeah sure.. the bozos that can't even *use* Spring suddenly are all proficient in Scala. Now with Java8 it can be done without much interface implementing. Java8 still isn't possible for everyone. 
^ This! *Slowly takes out a knife of his back pocket*
Hey thanks for this great response. I'm trying to understand the challenges at hand and its kind of tough without having personally experienced them. You're describing Databus's first scenario-- dual writes -- correct? http://www.slideshare.net/ShirshankaDas/databus-socc-2012 
&gt; you'll be forced to spend countless hours investigating why something is not working Spring is complex, but is very flexible (the cost is that it's sometimes hard to setup the right way). The problem with other frameworks is that: 1) either they use The Right Approach and there is no fucking way to change this to what you want 2) or you need to write it from scratch
Is there a link or something?
i've been using egit for 3 years now, never had an issue with it on either Ubuntu or Mac OS. That being said, every time I need to do something a little more complex than the usual commit/push/pull/branch, I rely on the command line. I think the 80% rule applies here though, so it's very convenient to have the basics covered in just 2 or 3 clicks
Nice! What's it called though?
No. I could never be sure if it'd do what I was expecting it to do, if it worked at all. I had more luck with Mercurial's Eclipse plugin. It was consistent with how the hg cli command worked.
https://github.com/google/auto/tree/master/value That said, I prefer to do these by hand.
I'll try that out. Thanks for the suggestion!
it has that. when you commit, one of the buttons "commit and push"
I love using the command line for all the git stuffs. I have 3 other devs on my team and 1 uses source tree another uses egit and neither have any issues the last guy is a cli enthusiast like me.
Indeed, what I meant was a *keyboard shortcut* (for exactly that button)
I said 'Easier'..... In the same way I would prefer to use composition over inheritance..... doesn't mean i dont know inheritance, just its easier for my brain to understand. 
it's like they hybridized them to act like stacks you don't have to manually pop, I guess making use of the new streams stuff. I only did one fx app for fun before dropping it about a year back so my memory is foggy but the tables used them extensively. they missed a bit of an oportunity to subclass those to the regular collections api, data driven pushes can be usefull for more than thick client ui.
Is it any language, or just Java?
&gt; Nice! What's it called though? It's the app of the german stock exchange based on e(fx)clipse. I don't know more details.
That is how I use it too. Though I honestly don't find the visual cues too useful.
As a developer whos company chose ember as the "direction of the enterprise" and who has worked with angular, I strongly disagree. The documentation is atrocious when compared with angular, and tooling is almost forced on you.
Here's a good video to understand git deeper https://youtu.be/dBSHLb1B8sw
Well, I standard corrected. By like 22 people. :-)
You can have a "reduce" method which operates on an array, making it as readable as streams and as fast as a for loop (because inside it's a for loop). So the performance of streams does still matter, because they have a best use case scenario, and using them for "readability" is not it. A stream represents a lazy pipeline of operations applied on a single item at a time, vs. an eager single-instruction-multiple-data loop. They're literally orthogonal to each other. Very different characteristics. Additionally, you have no enough context to decide *in general* of the performance of a loop matters, or doesn't matter. If you write a lot of stream code without considering your overall architecture and its performance characteristics, it may be quite hard to untangle to speed up later on. 
Xamarin forms means you don't get a native look and feel. You can't have your cake and eat it too. :p you either get native look and feel accross all platforms (by spending more time writing UI code for each platform) or you get a mediocre lowest common denominator look and feel but with the time savings of only writing one UI. Or you go completely native accross all platforms and get the best of backend and UI on all platforms, at the cost of having to write the most code.
I don't know. I *am* familiar with marble diagrams, but for me, it's much easier to just read the description which basically gives the type information I need to understand it. I fully understood the purpose of the class before I even looked at the diagram, and still got tripped up on what the diagram was showing.
After the original peak of inflated expectations, the author is clearly in the trough of disillusionment now. It's OK, author. You'll reach the plateau of productivity with Spring, eventually.
It's similar to a flatmap, but they aren't the same and have very different use cases.
No its not a flatmap, it does some flattening, and then some folding. I just can't wrap my brain around it sorry, I give up.
I'm in a windows shop so I use posh git in powershell. It's got some pretty nifty features. Kdiff for code reviews.
Too close to Bejeweled. Cannot focus on the diagram, I just want to form triplets.
Buffalo buffalo, buffalo Buffalo buffalo, buffalo Buffalo buffalo.
I haven't used EGit, but using the terminal has this annoying problem that if I use the built in Eclipse rename/move functions, the git repo thinks I've deleted and added files, but if I use `git mv` on the command line, I need to manually fix a bunch of compilation errors. Hopefully EGit doesn't have this problem.
They are, with the connotation that green threads usually imply N:1 scheduling (i.e. employing a single kernel thread), while fibers usually imply N:M scheduling (i.e. employing multiple kernel threads). Other than that, they're both simply userspace threads. Green threads, fibers, lightweight threads, userspace threads, goroutines -- are all the different names that different implementations have given the same thing: a (preferably lightweight) userspace implementation of threads.
&gt; This is a fundamental language change. Java is not a ducktyped language, and it is extremely unlikely if not impossible for it to become one simply because of how, again, fundamental a feature that is. It's possible and lambdas are already "structurally typed" for functional interfaces. It's only a matter of will, and finding a nice syntax for it, so it's not confusing to have both nominal and structural. Say the type for an argument may be specified like "Foo bar" for bar of nominal type Foo and "~Foo bar" for bar of structural match for Foo. Clear enough.
It's not unsafe, it can be implemented unsafely. I'd even go further and propose integral types should allow for arbitrary precision as a built-in feature.
&gt; Fibers are cooperative. Green threads are preemptive. This is not a distinction that is well-accepted. Both fibers and green threads refer to essentially the same thing, and so either could be preemptive. Quasar fibers are preemptive.
Not complex at all, the opposite: just the same old blocking code, only more efficient. Async is complex and anyone that used it seriously will tell you. Or get your server to answer each request with a thread, let me know what happens when you get to few tens of thousands (no, "I'll make requests wait behind a pool" doesn't count).
It produces for you the objects produced by the most recent thing. It forwards them to you, but as soon as a new source of objects to forward comes in, it abandons the old source and forwards objects only from the new source.
I thought the first one was easier to read. 
Is there like a starter's guide for Spring Boot anywhere, from the perspective of someone not already entrenched in the Javasphere? I picked up Vert.x in a few hours, and had a basic web application going within a day, but before that I was lost trying to figure out how to do the same things with Spring Boot. What's the equivalent of Rails' "15 minute blog" for Spring Boot?
its a mess as far as I can see and I have a few years spring dev exp before they started pushing java based config.
To be fair to the spring guys (and I very rarely defend them), you can build a spring boot app to a war file and deploy to tomcat as usual. But, its not the expected way to do things. 
You can generate a project from the Spring Initializr and have a running web app within literally two minutes so you clearly didn't try very hard.
But to be a little bit less snarky: https://start.spring.io/ https://spring.io/guides/gs/spring-boot/
Again, not entrenched in the Javasphere, no idea what 90% of those options even mean on start.spring.io, so I wouldn't know where to begin when it comes to options. That's why I asked for the equivalent of the 15 minute blog -- it walks you through everything as it goes along. Generating a bunch of code without explanation isn't particularly helpful. 
This should scare you off: Last Published: 14 March 2010 | Version: 1.0-SNAPSHOT. I've always done it myself, it's super easy using JAXB.
PM sent - let's do something, right man!! :-) www.tinybrain.de / javax.tinybrain.de
&gt; Spring boot is pushed is really hard to avoid jar hell it would seem Not exactly. The Spring Framework (which Spring Boot builds on) is complex because it is very configurable, but the problem is that for all the choices that the Spring Framework allows, it *forces* you to make those choices and you have to really read the (excellent) documentation to understand the choices. Later versions of Spring added XML macros like `mvc` which configure Spring MVC to some sane of defaults. But, by and large, the raw Spring Framework still requires you to make a lot of choices. For some people, this is preferred, because making explicit choices means you know exactly what choices are made. Spring Boot configures the Spring Framework based on a strong set of opinions, guided by classpath scanning and a configuration parameters in the `application.properties` file. For example, instead of being forced to manually specify a data source (for Postgres) and manually configuring JPA/Hibernate to use the Postgres dialect, Spring Boot will detect that the Postgres driver is on the classpath and configure the data source and JPA for Postgres. You just have to provide the connection details. Spring Boot does heavily promote the microservice model of a single application executable, the fat JAR, because that's Spring Boot's *opinion* of how you should package applications. But that opinion can be easily overridden and you can just as easily produce a WAR. &gt; Blogs like this make me think its the beginning of the end for spring. I highly doubt that the Spring Framework is going away anytime soon. There is simply too much new and interesting technology out there that Spring is integrating for Spring to "end".
I disagree as well: if you start having 5+ dependencies (that you have to mock to unit-test), then your design can be improved. Mockito treats the symptoms, not the illness.
So you've shifted from defending Spring religiously, to making inaccurate claims about it?
Why there's a Spring Boot besides the Spring Framework (and a Spring MVC) in the first place? 
My only experience is with Dropwizard, can't say i have too many complaints, but I also have no material experience with Spring either. 
My very anti-spring opinion would say its because with Spring Framework you still needed a java servlet container to run your app. Tomcat or Tomee. Spring wrapped the servlet containers API. Making them no longer needed..... Spring boot is pivotals attempt at commoditization of servlet containers.... 
&gt; Dont use Servlets, you use Spring MVC Spring MVC is a web framework. It does a lot more than just "wrapping Servlets". &gt; Dont use hibernate, you use Spring data JPA You're confusing products. Spring Data is one product, which provides a consistent programming model over several persistence providers, one of which is JPA. You can use the same programming same programming model on top of MongoDB, Redis, Solr, Gemfire, etc., etc. &gt; Dont use RestFB, you use Spring Social Same thing. Spring Social provides a common programming model to allow access to a wide variety of social networking platforms. Facebook, Twitter, LinkedIn, etc., etc. &gt; Dont use Tomcat, you use Spring Boot. Spring Boot *allows* you to run embedded Tomcat to support single-executable applications. It's not telling you to not use Tomcat. &gt; Dont use Websockets, you use Spring Websocket API Same thing. Common programming model. &gt; Dont use JDBC, you use Spring jdbctemplate Raw JDBC sucks. &gt; Imagine if microsoft starting wrapping the API's of the ISO standard, with their own proprietary, and &gt; stamping their own name on it.... Which is exactly what Microsoft is doing with ASP.NET 5. ASP.NET is being redesigned as an integration framework based to allow non-Microsoft technology to play well together in the same application based on a common programming model to smooth the edges between technologies. &gt; Things like TCP/IP became microsoft internet This already exists. It's called Windows Communication Foundation, and defines a common programming model that allows you to develop networked services independent of specific technologies, such as TCP/IP. Which is what the Spring Framework has been doing from the beginning. Integrating different technologies on the same platform to make them easier to use. You're arguing against the secret to the Spring Framework's success, and which will continue to keep it relevant for a very long time. &gt; for example JSP, you just make it so its hard to use them. Spring isn't making JSPs hard to use. The deployment model of a single fat JAR with an embedded container, where you don't have a filesystem and tools to generate classes from JSPs, makes JSPs hard to use. Simple templating technologies like Thymeleaf and Freemarker are just simpler to deploy because the templates don't compile to classes. &gt; If you really wanted to help java, you would make sure you were best of bread Java EE This is why I like Java. There are many platforms besides Java EE, which allow independent evolution based on different goals than the goals of the JCP. The Java world does not always follow the lead of Sun or Oracle, unlike the Microsoft world. There are plenty of independent operations who can promote their own visions of how things should be. The Java world has the benefit of "hybrid vigor". A foolish consistency is the hobgoblin of simple minds.
because to manage all the incompatible libs, they needed a new framework.
Jeepers, you are listing the spring mission statement - do you not think you might have invested a little to much into the spring kool aid dispenser ?
&gt; Er you were defending spring by listing spring social as a benefit? You're confused about *what* I am defending. /u/tonywestonuk made the claim that the Spring Framework practice of creating common programming models is some evil, Microsoft inspired strategy. It's not, and Spring's success on creating these programming models (some hit, some miss), is not undermining Java. In fact, the existence of the Spring Framework *strengthens* Java. Hybrid vigor. Spring Social is a *good thing* in that it is a common programming model. Spring Social may not be a *good* common programming model (I've never used it, so I can't say), but that is a different argument. But, even if it isn't, that is 1) irrelevant to the point, and 2) something that can be improved, especially with the developer mindshare that being a part of a large project like Spring will bring.
&gt; Spring Social may not be a good common programming model (I've never used it, so I can't say), but that is a different argument. Er, no its not. That the point. So you think spring is good, even if it provides bad programming models. Because at least they are common. Yeah, I'm done here.
&gt; Er, no its not. That the point. That's not the point, at all.
I chatted with one of the spring dev's and thats one of the reasons why they said spring boot had been created. They are hardly going to say on their website, we created spring boot because everyone is migrating to drop wizard and rat pack and all the different libs are confusing for newcomers. But yeah, I'm the zealot. 
Your response is an anecdote which has the virtue of being not verifiable and not representative of the Spring Boot project as a whole. A response which is worth nothing. Then, you proceed to claim that Spring Boot's documentation is *lying* about the purpose of Spring Boot. And making the dubious claim that *everyone* is migrating to Drop Wizard and Rat Pack, and so there is clearly some hidden agenda at work here. This isn't an argument, it is pure politics. Yes, your responses indicate zealotry.
a quick google: http://critical.eschertech.com/2010/04/07/danger-unsigned-types-used-here/ The issue is that usually you'd want unsigned with a for loop as an indexer but there's nothing to prevent someone from using them in math. The solution for Java might have been to have an indexer type specific for this purpose which does not extend from number. 
spring boot/rest reminds me of dropwizard a lot
spring social is bad, but that's like saying "apache is bad because apache mina sucks"
The best thing to do is just use the maven archetype project as a starter. I think you can get a Spring Boot + Spring MVC + Hibernate archetype that has a sample hello world controller. Once you have that it's easy to start playing around.
What exactly is jar hell and why do you think spring boot solves it? Whether you build a fat jar or war file all the dependencies are zipped up inside one archive. Sure the detail of how the dependencies end up in the jar are a little different, but from the end user perspective the process seems much the same.
knowing exactly which jars are required, and which versions are compatible with each other.
but that's your straw-man. No one is saying spring is good because of spring social. 
There are things you absolutely can't do without @Captor, so you need to use annotations. Personally, I like MockitoAnnotations.initMocks. It avoids @RunWith(MockitoJUnitRunner.class) Is there really an initMocks in the Mockito class? [I can't find it in the online docs.](https://mockito.googlecode.com/hg-history/1.6/javadoc/org/mockito/Mockito.html)
I've always liked [*The Java Tutorials*](http://docs.oracle.com/javase/tutorial/). Even as I've matured as a programmer, I still find them useful and well-written.
Thank you man
&gt; Always use constructor based dependency injection in your beans. I hope this becomes a thing in the Enterprise world, field injection gets under my skin.
The usual trolls /u/tonywestonuk and /u/NimChimspky are out in full force today.
&gt; I consider coroutines and fibers to be synonymous. Now that is just wrong. Fibers are threads, and coroutines aren't. Fibers (and all threads) are coroutines (continuations) *plus* a scheduler. 
* /r/javahelp * /r/learnjava * /r/learnprogramming All these subreddits are full of resources &amp; advice. Check out their sidebars, FAQ and wikis.
With Spring Boot and a tutorial consisting of a single DIN A 4 page I had a restful service for my RasPi up and running in under 20 minutes. It did not have much logic at that point, but I was stunned how god damn easy that was. But I would consider myself "advanced" in java. 
Codecademy.com is developing a section on Java basics which you can preview at the moment. It only has 3 chapters but you might want to check that out if you're a beginner.
Hey, not all of us.......!!!
I think we will disagree on this point. It is a good business policy, but completely evil. It weakens Java EE standards, especially when you have a company the size of pivotal dong it. Microsoft tried it with Java, they wrapped the java API, but called it java so they were sued by Sun. If they had just made their own java wrapper with microsoft enhancements, then maybe they could have got away with it.
Very nice article! And this comes from a "Spring hater". However I think the problem lies a bit deeper. One side hates, other side can hardly understand the reasons. Only recently I started seeing some clues. **Psychology** I believe it all boils down to psychology, personality types and terms like "Tool" vs. "System". Terms are strictly psychological and have nothing to do with software. People have natural preference to one or the other when are reasoning or forming conclusions. For me specifically, Spring is terrible, because I naturally gravitate toward "system" view. However, after I become more aware of this, I understand, that Spring is very good "tool". Tool vs. System in psychology can be a bit long to explain, but in very short examples: * System - priorities are perfection, consistency, accuracy - it is designed perfectly, rules are smallest possible, there are almost no exceptions. You can reason and use it without constant reference to manual. * Tool - priority is your goals - it can have as many exceptions from the rules, as long as it helps me achieve my goals. Specific example (again highlights extremes): * Tool - foreign language helps me achieve my goals - if asking for stake and beer uses different grammar - its OK, it's also OK to look things up in a book "Most popular phrases in X language" (manual). * System - I want to understand how to create sentences, if grammar of sentence differs when asking for different food - it's terrible, inconsistent, not clean, terrible. **Summary** So for me Spring is terrible "system", but very good "tool". The problem is, that since I naturally prefer "system" world view, Spring annoys me, even now, when I am aware of all of this psychology.
&gt; This block is guarded by a key, which can be either a string or an object. Yes, please, use a `String` to synchronize on and wonder why the fuck it doesn’t work as soon as you’re trying to access something from different classes. &gt; synchronized (this) … For related reasons, don’t synchronize on `this`. &gt; The following example creates a copy of a list (ArrayList) and returns only the copy of the list. Uh, no, it doesn’t. `Collections.unmodifiable*()` returns a wrapper around the original list: the caller can not change the list but can still observe changes to the original list.
Servlets, JPA, WebSockets, JDBC are all very much low level APIs. Because of that, they are very crappy to use. &gt; If you really wanted to help java, you would make sure you were best of bread Java EE. You drive the JCP process, pushing for better standards, for everyone to follow... And expect them to be usable in about 10 years. How much is Java EE MVC late to the game compared to Spring MVC? And it's part of not finished standard which will take again some years to be implemented and again some years to be widely deployed. 
The DJ example is my favourite
This!!! - Exactly!!
&gt; Or when something goes wrong and it's not something you've already spent days finding out why, you going to spend days finding out what happened. Basic constructor injection isn't hard or even very verbose compared to spring. You can make static methods or factory singletons and your code will be much simpler and easier to debug. This is it exactly. Spring removes being able to trace back to the root of your problem. And it replaces existing constructs did the same job and did allow you to trace back to the root cause. It's like adding goto back into the language, just with assigning objects rather than going to a code point. 
Maybe you'd prefer a world where no-one questioned the status quo?
&gt; Nothing like a bitchfest article from someone living in the past. Just joined a job this year who's "new" project is using spring with xml configuration. It's for a large major company. That's just one thing on a pile of bigger problems. 
I think you're right.... The way I 'think', when it comes to anything, not just computing, is I use my past experience to solve the problem at hand. I don't like to remember a load of exceptions to the existing rules, or have to learn a brand new skill just to be able to do something new. I was never good with foreign languages at school, probably because exactly this, it was a bunch of new rules and exceptions, which I didn't want to go through the pain of setting them into memory. I think though, my priorities are consistency and simplicity. It doesn't have to be perfect, just so long everyone agrees.
If I understand you correctly the concept of "becoming successful" is what Java EE copied from Spring? So AngularJS also copied from Spring because it became successful? And before that, Windows 95 became popular. Did Windows 95 copied from the Spring that did not exist yet?
Are the Java EE standards so weak that they can't stand competition? The fact that companies like Pivotal can exist in the Java world and challenge Oracle is awesome, which is what makes Java so much better than Microsoft. Competition is not evil. Microsoft tried something very different with Java. They licensed Java technology, and proceeded to violate the license terms by adding language features which made the resulting executables unusable on other platforms, violations the run anywhere principle of Java. On the other hand, Pivotal does not implement a Java EE app server, and this is not subverting anything.
Funny I wrote something similar over the weekend. Not as powerful though only simple POJO to POJO Mapper using code generation at runtime (no reflection). Cool Project! 
Funny how people who have an opinion against Spring are always either trolls or Oracle shills, yet the same names who always have an opinion against Java EE (and while at it, always praise Spring) are the people's heroes. According to those Spring fans, of course. Looks like there's a little pot and kettle going on here if you'd ask me.
What's low level and high level is probably too subjective. Important thing is that it's probably too low level for a lot of people and use cases to be used directly. Which is totally fine, because Hibernate/JPA should not be expected to provide everything. Even if you consider some of the higher-level features - like HQL or Criteria API - they are crap and it would be probably better if there were left out. Things like QueryDsl or JOOQ work much better as an abstraction over JPA. Hibernate/JPA is great at its core, but it doesn't provide quality high level abstractions.
The original feud between Hibernate and Spring had to do with the `HibernateTemplate`. But, back in the days when `HibernateTemplate` was created, it actually did provide a very valuable wrapping. Back in those days (Hibernate 2 or so), if you wanted to use Hibernate with Struts or Servlets, the common pattern was to create a `Session` and associate it with a `ThreadLocal` attached to a global accessor method. You would have to do all transaction management yourself. In the days before I started using Spring, I'd write this code in every web app that used Hibernate (actually, copy/pasting the servlet filter that used to be in Hibernate's documentation). Modern Hibernate *now* provides context management, and has a method `Session.getCurrentSession()` which provides the thread-bound `Session`, which Spring now recommends you use. `HibernateTemplate` was actually quite a useful wrapping because it did all of this management of the `Session` for you as well as managing transactions declaratively with `@Transactional`. `HibernateTemplate` has long been deprecated, but demonstrates the value that Spring provides. Spring automates implementations of patterns already used in industry within the framework. Today, while JPA is a high level library, Spring Data is higher level still, and provides useful capabilities like automated repository generation with common methods and query derivation from method names. Also, Spring Data is not dependent on JPA, which is heavily tied to the relational model. Spring Data provides the same access model to non-relational data stores like MongoDB and to big data stores like Hadoop. Spring Data REST even lets you automate mappings of repositories to REST web services. TL;DR - what is considered "unnecessary wrapping" is clearly in the eye of the beholder.
Or that you're just constructing strawmen. I'm not bashing Java EE, nor am I saying that Spring is perfect. I'm just pointing out the constant anti-Spring trolls. If you have an axe to grind with certain people, maybe you should respond to them directly?
A shame that it seems so tightly bound to Eclipse. After two years away, there's no debugging tool on earth that could lure me back to that IDE. I'm not sure why an agent-based tool like this would need to be tied to any particular IDE in the first place.
Um, yes. What's your point?
Do we really need Java J2EE Tranning? :)
(AutoMod thought this is spam. :P) See also: http://showcase.omnifaces.org/whatsnew https://en.wikipedia.org/wiki/OmniFaces -&gt; License is Apache 2.0
&gt; TL;DR - what is considered "unnecessary wrapping" is clearly in the eye of the beholder. Just mentioning that Hibernate wasn't happy that their brand new API was being wrapped. They took it as a bit of an insult, as it says that their API is not good enough and needs wrapping in order to be useful.
if you're smarter than the teacher i'm sure you'll figure it out 
Why? 
&gt;What makes a UI attractive to the user? **Members of the Reddit community** have thrown up their hands in support of beautiful Java UIs to gain inspiration outside of the IDE space. Here we show a couple of examples of how good-looking a UI can be. Well yea, they say that in the first paragraph.
You're really playing thick. They looked at what made spring successful ie the right mix of different concept (most if not all not invented by spring) with a good implementation.
Great article Oliver. One of the main reasons I make for using frameworks (Spring is my favorite) is that studies have shown that it costs $32 per line of code your team writes. The more code you write the more expensive your application is going to be to maintain/develop. Why not use libraries/frameworks that have solved the problem (and are well tested)? A lot of time I feel the people that hate Spring have never developed and maintained a large scale application.
No system is perfect, and it's pretty obvious Spring is a tool to use in the Java ecosystem. 
As a major Spring user, this is my biggest complaint with Spring. I have to teach other people how to read Spring stack traces among other Spring specific debugging techniques.
Even more XML examples for Spring. 2015 (almost 2016!!) people. Stop plz.
The tutorials are good.
We use TFS, and for the most part, works exactly like git. There are some quirks to it because it's actually using a db under the hood, unlike traditional git. That being said, the quirks are rather rare, and the only one I've come across had to do with eGit. I'm not experienced with Team City, but I did like it's automatic creation of builds based on branches. Jenkins (what we use) can do this too with extension, but looks a little messy. 
Most of the time [immutable Collections](https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained) and [Observables](http://reactivex.io/documentation/observable.html) do the job. Unless your usecase is very specific or there are some other constraints use them. They make concurrency soooo much less painful.
Read "Top java 5 profilers" at first. *shudder*
A million times, this book [Amazon UK link](http://www.amazon.co.uk/Intro-Java-Programming-Comprehensive-Version/dp/0133761312/ref=dp_ob_title_bk)
That is not what je suggested with his question. He said the teacher isn't any good, but most likely still better than te students. Maybe the teacher has a lot of knowledge but is really bad in explaining his knowledge to a class
I would not say I hate Spring. I really do not like that any post on this forum that does not praise it is attacked by fans and pivitol employees. I did like Spring alot when it came out. I don't like to use it now since Java EE is so much easier to work with.
I've found YourKit to be well worth its license price, which translates to less than the cost of 4 consultancy hours on public sector tendering. I won't recommend Mission Control until the people responsible for its production license pricing and license terms stop smoking crack.
I didn't have any issues with the egit Eclipse plugin, I think it was in conjunction with a particular older maven library that used it. Realistically, I haven't run into any major issues using TFS. I yearn for a better webUI, but it's functional. Personally, I found eGit horrid to use in Eclipse (or maybe I wasn't any good at it), but that's another discussion entirely :P
Just add Spring mvc 
Maven plugin please?
No, you dont need to use annotations. You can get an argument captor statically... ArgumentCaptor.forClass(Clazz.class); I initialize pretty much everything in my unit test "explicitly". I statically import mock() and other commonly used functions, and only use JUnit annotations in my tests (if possible ofc, not a checkstyle rule). I find mixing annotations to be a smell, even in test code. Also, i believe mock() fits in better with the fluent design of the Mockito api. 
Or, get with the times and go REST + JS UI.
Or that too. That's the beauty of the Java world. You are not locked in. Lots of options.
Pardon me for asking I started doing JSF this year so far I like it. What's the problem with JSF?
I believe NASA have a [similar tool](http://babelfish.arc.nasa.gov/trac/jpf) that can be used independently from an IDE. We used it to detect deadlocks. 
Nothing. Being stateful used to be an issue, now you can have stateless views it's fine.
First of all, thanks for the detailed reply. &gt;what it basically boils down to is writing emails to a mailing list or creating a ticket in a bug tracker for a software project that sees a release every 4 years. I don't know how the JPA EG exactly works, but the JSF EG asks all the time for EG members other than Oracle to actually code up the proposed features and then submit them as patches for the RI. If I'm not mistaken that's what the new MVC EG does too. That one is a bit more modern even as it accepts pull requests via Github. If Pivotal wants a feature, and as an expert user you probably know exactly what's needed, would it not be an idea to ask the EclipseLink people about their willingness to accept patches? That could hopefully speed up things a little. &gt; a software project that sees a release every 4 years. Frankly I think 4 years is ridiculous. There's no need to release every year or faster, that would be the other side of crazy, but around 2.5 years would IMHO be a much saner schedule. 
&gt; since Spring only uses JPA, it doesn't implement it. An EG typically consists out of vendors and users of various kinds. Like the JSF EG has the PrimeFaces guy. He doesn't implement JSF, but just like Spring uses it to build his component library on top of it.
Spring MVC is in fact being standardized for usage in Java EE, and it will be included in Java EE 8. Personally I think its nuts to have two fairly similar MVC frameworks in one full stack framework, but that's what's happening. From Java EE 8 on, Spring users actually can say truthfully that Java EE directly copied something from Spring, for better or worse. 
And a decent way to handle security. What would be nice as well is a standard way to configure your app and app-server, but that JSR was sadly pushed back.
Sounds suspiciously like this may be OPs teacher! It's a trap OP don't reply!
I've submitted tons of tickets to individual JPA implementations for bugs I found in the course of developing Spring Data JPA. That's how I actually got to the point realizing that the TCK can be considered swiss cheese (to phrase it politely) as I would've expected it would catch e.g. core methods on EntityManager not being implemented correctly (EntityManager.createNamedQuery(…) was implemented incorrectly on two minor EclipseLink versions without the TCK catching that). See the interview and lengthy discussion here: https://jaxenter.com/tck-access-controversy-chat-with-jpa-2-1-expert-group-member-oliver-gierke-105703.html. I am not too eager to get into individual implementations actually as even i they implement something I'd like to see I don't want to scatter provider specific implementation code in Spring Data JPA more than it already has those quirks. I mean, that's exactly why we build on top of JPA and are involved with the spec in the first place. I don't want to have to tell users: "This works if you use EclipseLink as JPA provider, this doesn't." I've spent quite a bunch of emails to the EG mailing list arguing about features, outlining usability problems with new additions (fetch graphs, attribute converters) that have mostly beed disregarded and deemed too complex. Re: the 4 years — unfortunately that's what it boils down to: JavaEE 6 - 2009, JavaEE 7 - 2013, JavaEE 8 scheduled for 2017. I gave a few suggestions mid JPA 2.1 time frame (2012), they were deemed to late and resorted to the bug tracker. That means it won't be available before 2017. Now we don't have any communication on the EG mailing list for more than half a year. Is there any sane reason I shouldn't rather spend my time on Spring Data JPA that allows me to actually ship features within finite time than writing emails into a black hole?
After completing the algorithm run then just need to show the result of that graph in visualizer. Do I go for GEXF ? And could you give me some code for GEXF ?
I've used Jira for years with our Java project until our company switched to TFS. TFS seems more retarded with file merges sometimes - but that mostly affects the .net side. TFS in visual studio can be painful because there's no support for spell checking (don't want to upset the Office team) - but using the web interface with Chrome can solve that. Jira has better workflow management - you can specify email notifications on workflow changes while TFS supports only basic email notifications. Jira gives you a better picture when you look at a case since it shows the history as comments while in TFS you have to view the history and look at each change one at a time. TFS has better integration with windows as far as domains and user groups etc... 
'If one transaction fails...'? High quality material.
I would suggest having a core "product" that is as free from dependencies as possible (a la standalone). Then add integrations on top of that as you have capacity to do so, and hopefully the community will respond by helping out with additional integrations. Tying it to Maven creates the same fragmentation problems as tying it to any IDE. A lot of late-adopter shops are still using Eclipse and Maven (and perhaps always will)... but much of the industry is moving on to IntelliJ and Gradle. There's no telling what standard(s) will be in five years, but you're sure to make yourself look dated by picking one. The Java world is just too big with too much fragmentation in tooling. 
It is not nuts. The truth is that many people prefer action-based MVC frameworks. If they standarize an action-based MVC framework then there will be less reasons to use Spring, the main competitor of Java EE.
JavaFX's growth seems anemic to me... anyone doing a non-enterprise application with it want to pitch in? Same author posted this in October 2014: https://dlemmermann.wordpress.com/2014/10/27/2015-the-year-when-javafx-takes-over/ &gt; Based on the feedback I am getting from the community and also on the projects that I had contact with I foresee a rapid increase in JavaFX usage (and Google searches) over the next 6 to 9 months. &gt; [...] &gt; So that’s my prognosis, please make sure to check back in Q2 2015 to see if I was right or wrong. This is what the trend looks like a year and a month later: https://www.google.com/trends/explore#q=%2Fm%2F02r0tn1%2C%20%2Fm%2F01nr40&amp;cmpt=q&amp;tz=Etc%2FGMT%2B5 I don't have anything against JavaFX -- I'm building a greenfield application with it myself -- but it seems like there's no real forward momentum with JavaFX outside of shops already using Swing. I doubt it will go away, nothing Java-related ever seems to get deprecated, but that's different than a healthy growing ecosystem. COBOL is still in use, for instance. To be fair, my view is mostly from an outsider's perspective: I've only recently come back to Java due to the need to explore my options for a particular project, so I've been slowly immersing myself as much as possible. Despite that, I didn't see a lot of current evangelism for JavaFX until about a week ago.
It remains to be seen if people truly prefer action-based, or if they just used Spring MVC. Remember that Struts was action-based too and people didn't actually prefer it so much. But there's nothing wrong with action principles per se. JSF is likely flexible enough to could have incorporated it. In fact, it already does to some extend. It's true that there's already Servlet/JSP too, but that's lower level. The foundation of JSF in a way. There's JAX-RS, but that's not an MVC framework and itself usable by either client-side MVC frameworks or just as general web service for server to server communications. With Spring MVC in Java EE it's the first time you really have 2 functionally identical things at the same level within the overall framework. People are asking all the time if Spring MVC will replace JSF, and it will confuse people what to choose when they are new to Java EE and web programming in general. For Java 8 Oracle choose to incorporate functional concepts. They did not just standardize Lisp instead and offered that as second choice next to Java, did they? 
&gt; get with the times and Or be ahead of the times and go server side MVC framework. It changes all the time what's "with the times". A couple of years ago too everything had to move to the client, then suddenly everything moved to the server and doing things on the server was "getting with the times". Then it was to the client again. You don't have to have much foresight to predict it'll soon be all about the server again. The thing is, every generation wants to do it differently then their direct predecessors. So if it's client now, it'll be server next. And without a doubt, client after that, and then server again. All this has happened before and will happen again... 
As a sidenote, I really recommend the author's other posts on JavaFX, particularly the "JavaFX Tip" series. They seem pretty useful at a glance, so I'll definitely be coming back to them when the time comes. 
Of course Oracle is committed to support it. But that just means they not gonna completely ditch it like, say, Google does with its pet projects. It does not mean there will be active (really active) development of JavaFX, or that Oracle will push hard for wider usage in the desktop ecosystem.
Jigsaw has been being kicked down the road for a long time.... seems pretty huge to Java, but also a huge change.
What I find most interesting in the post is part of the quote from Oracle's Don Smith: &gt; ... I understand that while there is both Swing and JavaFX available that people will continue to question the existence of each — so be it. Each has it’s own niches and benefits and our strategy, as it has been for years now, is to continue with each. Previously Oracle reps have been saying that Swing should be deprecated in favor of JavaFX. Perhaps I'm reading too much into this quote, but this makes it sound like they may be reconsidering that stance, perhaps due to slow uptake of JavaFX? 
I think you're using this account to promote your product. domain submitted from|count|% :-|-:|-: [cloudrail.com](/search?q=%28and+site%3A%27cloudrail.com%27+author%3A%27ua111%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|3|100% subreddit submitted to|count|% :-|-:|-: [Android](/r/Android/search?q=author%3A%27ua111%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|33% [java](/r/java/search?q=author%3A%27ua111%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|33% [androiddev](/r/androiddev/search?q=author%3A%27ua111%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|33%
&gt; I have absolutely no time to go through this and learn coding as I have no previous experience. With an attitude like that, we don't have time to help you. If you describe exactly what you're having a problem with we will help you with that, but we're not going to do your entire assignment for you. Show us what you have so far.
&gt; why would a new project use FX? Because it's an easy way to ship an HTML/CSS UI and still have something other than just Javascript to write the rest of the program in. In fact, this is precisely what I've been looking at using JavaFX for recently. Throw up a window with a WebView in it, and wire the WebEngine up so mot of the actual program logic resides in a JVM language with some minimal JavaScript glue.
1) Client wants a desktop app 2) Requirements for said app include using resources physically connected to the desktop machine, the drivers for which are accessed through JNI and as such you really do need a desktop app and not a web app 3) Said app communicates with a Java EE back-end with a bazillion beans which you will not get the resources to rewrite. This list of requirements is fairly common in enterprise and it doesn't leave you with much of a choice when deciding upon a stack. Migrating from Spring to JavaFX is warranted by sharing Web assets between the enterprise's public-facing web portal and the enterprise's hardware kiosks, preserving a uniform look/branding throughout the customer UX on all platforms.
Wait until they start trying to fix it after the fact!
All of this would be unicorns and rainbows if it could target *any* growing platforms. I love JavaFX - the API. We *really* need a way to deploy a bundled JRE with an android or IOS app. JavaFX practically cries out for mobile targets.
This year's analogy is a ship, only that set sail last year. 
Java 9 comes with the modular packages which should reduce the memory footprint of the JRE making it more portable to lower powered devices like mobile. Until java 9 happens, the JRE is a massive memory hog. This is also part of the reason why google has created their own implementation of java for android.
Just get it right guys. I'm pumped for Jigsaw, but a half baked solution is worse than no solution, and way worse than a slightly later solution.
&gt; who has need for JavaFX? We did. Specifically, we wanted a fault-tolerant uploader client for our service, so it had to be fat client and cross platform. With those objectives in mind, the alternatives all seemed like a lot more effort than JavaFX. And having used Swing before, it's a welcome improvement in a number of areas.
Can confirm. Am IBM mainframe. 
Well, with today's news, it seems that all is not well in Java 9 land. Looks like they're going to be delayed another 6 months because of Jigsaw. Honestly, though, it's only one piece of the puzzle. They would have to implement JavaFX for the Android Framework and Cocoa Touch. They would have to come up with a build story that allows the JRE to be built into the correct types of application bundles. ...and they'd need to get Apple to let them do it. No JIT compilers, remember? BTW, Google did not create their own Java implementation. They created a compiler that translated Java bytecode into a different format to run on a different kind of virtual machine (Dalvik). The new runtime takes that a step further, and compiles *that* bytecode directly to machine code. While Java is the language used to write for the Android framework, the platform is not JavaSE. I guess all I'm saying is that I really want the JavaSE umbrella to cover mobile devices, too :-/
if that response was auto generated, ill buy you a steak dinner.
Yeah, but as a whole the Java language platform is moving at a snails pace. The newer, more diverse JVM languages like Scala and Clojure are definitely advancing much faster than vanilla Java.
True, but that partially because they can break stuff. Scala 2.10 does not compile for scala 2.12... whereas you can run 10 year old Java 1.4 code on a modern JVM. Different languages for different goals... (And I am totally a Scala guy, but I see why Java does what it does).
I agree. As soon as a new paradigm is discovered, all of a sudden the previous way of doing things is marketed as being completely useless and outdated. These days, it's functional programming. Functional programming is awesome for solving all those problems that OOP made overly hard, but OOP still has its place. The most self-aware programmers will learn all of the paradigms and use them each as appropriate. It's all just more tools in the toolbox. tl;dr: Someone just invented a hammer! Every problem must be a nail!
from the article "Proper Object-Oriented code, makes it clear to understand and extend while keeping the complexity low." Just disproved his own point didn't (s)he? not what I'd call a fail...
JSF is one of if not the most popular Java web frameworks. That is quite a feat considering just five years ago Spring was really dominant. I have been using it for 5 - 6 years and love it.
All of that sounds like "It was hard so we did something else." I get it, though. I do the same thing. At the end of the day, though, if they can't make it work, then its relevance is basically zero. Sure, a few desktop apps here and there will be made with it, but there are technologies that let you make desktop GUIs *and* mobile GUIs that work pretty nicely. Unfortunately Java is not one of them. If all of the "not technically feasible" is true, then I guess it's time to work on a new application framework.
There are AOT compilers for Java, including iOS. Just not from Oracle, which keep ignoring mobile OSes. Thanks to this attitude, C# and C++ are now the languages to go to for native mobile apps. I doubt this will improve. 
This article is rather poor. First, it confuses the name `ConcurrentModificationException` with multithreading. While CME can indeed occur when another thread modifies a collection during iteration, it most definitely applies when the *same* thread that's iterating the collection also modifies it. Second, the article uses the term *fail-safe* to describe the behavior of some iterators. This term isn't used by the JDK, and the description in the article is sloppy. (The article describes *fail-fast* reasonably well, and this term is used by the JDK. Most collections in `java.util` are fail-fast.) Here are some other policies that iterators in the JDK use. * *Snapshot.* A snapshot of the collection is logically taken when iteration commences. Subsequent modifications to the collection are never visible to the iterator, and `ConcurrentModificationException` is never thrown. Example: `CopyOnWriteArrayList`. * *Weakly consistent.* See the [JDK's definition](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#Weakly). This is actually somewhat imprecise, but it essentially means that every element that is visible to the iteration was present in the collection at some point. `ConcurrentModificationException` is never thrown. Example: `ConcurrentHashMap`. * *Undefined.* Modifying the collection might cause elements to be skipped or duplicated, an infinite loop to occur, an exception to be thrown, or possibly even other unexpected behavior. Example: the `Enumeration` returned by `Vector.elements()`.
I found REST Docs less than ideal. I already test my controllers in various ways, driven out by TDD. I'm not going to backfill tests for some documentation. It's just another suite to maintain. I would prefer a tool that uses context scanning to find controllers or something integrated with HATEOAS. Compare it with something like actuator... Its kind of lacking.
Worse, is that all successful FP languages are actually hybrid, but lets not let that stand in the way of bashing OOP.
At first glance the following popped up: ###Rule 3 - Overriding `static`: You have declared: public class Animal { static void sleep() { // animal sleeping code... } } Note the `static` keyword here! Then you try to override: public class Dog extends Animal { public void sleep() { // Dog sleeping code... } } `static` is missing in this snippet - that's actually why the compiler throws an error. You are trying to make a static method non-static which is not allowed in Java (and in most other OO languages). ---- The following is perfectly valid: public class Dog extends Animal { static void sleep() { // Dog sleeping code... } } Note that I'm using the `static` keyword again! Technically this is *method hiding* and not *method overloading* because the `sleep` method in the subclass hides the `sleep` method in the superclass. It is not possible to change a method from `static` (i.e. Class related) to dynamic (i.e. instance related) - so far your statement is correct. ---- Later, in rule #8, you explain what I stated above about method *hiding*, but the code example in rule#3 is simply wrong.
Rule #0 - always use @Override annotation ;)
You should 1) post in the right subreddit: /r\/java is about the language in general, not about someone's personal code. And 2) you should put some content into the post itself. What you have here instead is just a headline. In case "for money" means that there will be a reward: Forget about posting this to /r/javahelp. But if you meant that the program deals with money, go right ahead. But please put *sufficient information* into the post. Read the side bar before posting.
This was the right thing to do, imho.
The author missed one... Rule #0: Favor composition over inheritance.
Very nice! I'll give it a try. Thank you!
Really, do tell. Were I to tell my customers that suddenly their business results are going to be a year late because "software estimates are hard" they would ask, with good reason, why I didn't alert them 6-9 months ago when the schedule started slipping. They would be correct in calling such project management grossly incompetent.
This is pretty excellent explanation of monoid and functor, and how to use them in practice. The example code really help to clarify things. 
Thanks for the feedback. Now, I see how important it is to pick the right title :) What the post really says is that OOP is great but difficult to do it right. Many times I saw failures for which OOP was blamed while in fact people used it inappropriately. Chewing over the better title...
There's *a lot* of effort being put into Jigsaw, and it's very far along. Remember how many times lambdas were pushed back? Yet, in the end, they delivered. Features not being complete on time is common in software development, let alone when the specification has to be just right and serve many customers, and let alone in the second-largest open source project in the world. 
Second-largest? TIL. Is there a top ten list somewhere?
Can I ask you why? http://stackoverflow.com/questions/1372396/use-lgpl-libraries-in-closed-source-software 
You mentioned memory mapped files but not [FileChannel](http://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html), which is the Java implementation. I'm wondering if you tried it?
Hi, I just forgot to mention that is how I did the mapping. The source code is on github though. Thanks for the heads up - AJ
&gt; WebJars Thank you for your comment, here it is http://www.webjars.org/.
 // as wife knows it all, better check with her All this time I've been hoping that people would start coming with manuals... looks like all I had to do was just read the source code comments instead. 
We use jbake https://www.codenameone.com/blog/jbake-new-website-coming-soon.html Quite a while after that post when we already migrated I'm still pretty happy with it. Search isn't available there but you can always use Googles custom search. The ability to host on github or other places is really cool. In our case the site is pretty huge and the fact that everything is static is a huge boon because we can use cloudflare as a proxy and save on server resources while improving performance. We still have dynamic content due to the nature of our product but I'm of the mind that if something can be done ahead of time it should...
Hard != impossible I work for Codename One which is an open source framework that does exactly that and has been doing it since before Java FX was available (it has origins at Sun as we are ex-Sun guys). The problems in mobile are unsolvable for a product like FX that needs full control over every pixel and can't be flexible about accuracy. E.g. fun fact. There is no portable way to discover device DPI's in an accurate way... Apple doesn't provide it (there are some hacks but its really hard to distinguish iPad from iPad mini etc. Android is worse, they have an API but they just don't test it. So you can get a vendor that didn't implement it correctly and then things go crazy... The problem is that these sort of things don't show up during development or small scale deployment (especially with engineers who all have Nexus devices).
 void doStuff() throws IOException { throw new IOException(); // or some other cause } If you keep adding "throws IOException" to the method declaration up the call hierarchy incl. main, then the exception will take place, but nobody will notice. I wouldn't call this "catching", though. I don't think you can win this one. Of course there's a way if you use some kind of uber-crowbar, because it's all just bits and bytes after all, but I don't think that counts.
Ehh, that counts as catching...
I think if you rewrite a try block to be an awkward if statement I think this is a good answer. The only problem is if you extend or implement a library that throws shit.
The whole thing about immutability has been brought up for nigh on a decade now by Joshua Bloch in "Effective Java" - if not before and by others... Should be pretty much a known thing by now.
This is true and yet without immutable collections it's hard to create immutable values of any complexity. So most projects if they use immutable pojos are just scratching the surface of the guarantees and safety that "immutable" all he way down data structures can help with. It is a bit of a rabbit hole though, as once you have immutable data structures then you start wanting lenses. 
I don't think so domain submitted from|count|% :-|-:|-: [projectmooc.com](/search?q=%28and+site%3A%27projectmooc.com%27+author%3A%27raushanraj88%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|8|80% [self.learnpython](/r/learnpython/search?q=%28and+author%3A%27raushanraj88%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [self.learnprogramming](/r/learnprogramming/search?q=%28and+author%3A%27raushanraj88%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% subreddit submitted to|count|% :-|-:|-: [artificial](/r/artificial/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|2|20% [EngineeringStudents](/r/EngineeringStudents/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [computerscience](/r/computerscience/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [java](/r/java/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [bigdata](/r/bigdata/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [compsci](/r/compsci/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [learnpython](/r/learnpython/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [programming](/r/programming/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10% [learnprogramming](/r/learnprogramming/search?q=author%3A%27raushanraj88%27&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|10%
Does it count if the library catches exceptions for you? How about this (Java 8). Suppose you have a method that returns something or possibly might throw an exception: String returnOrThrow() { long ctm = System.currentTimeMillis(); if ((ctm &amp; 1) == 0) { return String.format("current time is %d", ctm); } else { throw new RuntimeException("threw an exception"); } } You can "handle" it using stuff from `java.util.concurrent`: void handleExceptionWithoutCatch() { CompletableFuture.supplyAsync(this::returnOrThrow) .handle((result, ex) -&gt; { if (ex == null) { System.out.printf("normal return: %s%n", result); } else { System.out.printf("exceptional return: %s%n", ex); } return null; }) .join(); } 
I'm using and loving it. The biggest advantage in my opinion is the very useful staging view, which allows for commiting individual parts of a diff in individual commits very easily. That's much harder to do on the command line. Also, I prefer cherry picking over formal merging or rebasing, so going through the commit history and cherry picking individual commits is also much easier.
Some of the cloud providers do offer a free tier, but they usually have pretty limited resources. The Amazon free tier these days I think offers 1GB of memory and 1 CPU. You can use up to 750 hours for free on the free tier before you need to pay. You can run as many instances as you want, but keep in mind that you will consume your hours much more quickly the more you boot up. You should also be able to find an OS image that comes with any container you need, like Tomcat, Jboss, etc. I think Red Hat OpenShift may also offer a free tier, but I am not as familiar with them. I think any of these providers will require that you give them a debit or credit card number so they can bill you automatically. I am almost positive you can't run anything on AWS before giving them a number, but it has been a while since I used them, so things could be different now. You can look here for more info on AWS: https://aws.amazon.com/free/
You're absolutely right. Uh, Just a bit of advice: Your organization might want to hire a proofreader to go over the Codename One website. Misspelled and improperly pluralized words are fine on reddit, but on your front page, that can quickly turn people away.
Interesting. Thanks!
I guess I don't understand the conclusion: is the author suggesting we disable that check? That seems to contradict the "Don't Do This" caveat for case-by-case warning suppression.
Thanks. Can you point me at something specific? 
[removed]
Has anyone here actually used Quasar? I'm curious if it's worth looking into more.
I'm guessing that if you really didn't like Java you would have posted to /r/programming and not /r/java I do agree that Java on the desktop is in a horrible situation: https://www.codenameone.com/blog/should-oracle-spring-clean-javafx.html And unfortunately the JavaFX community is still somewhat in denial about that: https://www.reddit.com/r/java/comments/3uzh5k/javafx_is_here_to_stay/ There are interesting solutions that we use at Codename One such as http://teavm.org/ which allows you to run Java on the browser e.g. this demo we released yesterday: https://www.codenameone.com/demos-Restaurant.html
Ok
&gt; Switched to Gmail editing /paste, slowing me down on subject, but it is what it is. What? &gt; I have watched in performance as Java has incrementally been used to clickbait, there is no other form of clickbait this profitable at the moment. What? &gt; dam you can knock down google spell,, java check...Paying the price of manual spelling fix. What? I wonder what the reason is that you don't (or can't) communicate what actually caused your frustration.
**OH COME ON! DID YOU REALLY CONFUSE JAVA AND JAVASCRIPT ALL THIS TIME!?** Man, I need to screenshot this post. (Who makes these people?)
Interesting article on Open Source licenses....
Who the Fuck cares when it displaces life to nonsense, do I need to back up every post against admin edit? Whole different view of back up You really going after me on terminology? Java has been hijacked for ad servers, and this does not bother you?
What just happened here? I bring math, And algorithms took it all sideways? If I can not speak my mind and spell things out in real time, without 8 admin edits, what is the point of me wasting my time on Reddit? This is a waste of math.
AutoModerator removed it (9h ago :P, feel free to resubmit if you want to get to the top of the queue, but please delete this one then) because of spam suspicion, but I don't see that at all.
&gt; I'm personally ambivalent about the benefits of dependency injection. On the one hand, I recognize its usefulness in certain container environments such as Java EE. (For the record, I was the author of the CDI 1.0 specification, with my JCP Expert Group.) On the other hand, given the nature of what I've been working on for the last few years, I don't really have a use for it in my own programs. When I read statements like this, I realize there's no common understanding about what "dependency injection" is at all. To me this reads like this: &gt; I'm personally ambivalent about the benefits of passing objects into objects. I recognize its usefulness in certain container environments, but I don't really have a use for it in my own programs. ... which is nonsense. 
Ads haven't used Java since the 90's or early 2000. 