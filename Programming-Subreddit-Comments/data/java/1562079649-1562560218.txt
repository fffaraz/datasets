\&gt; IMO it's the amount of fields that's the issue. I agree with you. At some point, we have to refactor. it's case by case. But a method/constructor with a large number of fields seems somewhat common. I guess it never starts that way, and then the code grows. Then, nobody thinks about refactoring it.
Yes, the risk of making this mistake is pretty low. But when it happens, it's difficult to spot it. That's why I think a solution like Lilit (that requires no code change and no additional effort) is a decent risk mitigation of this problem :) IntelliJ is great, but it doesn't help much when reviewing a pull request.
Unfortunately you really have to pick for yourself. if you become a Java developer that pretty much means that you would work server-side only writing web services. a front-end programmer is pretty much just using JavaScript. I don't know if this is true for most companies but for the company I work in devops has become a word for guys who just spin up virtual machines. Rarely do they code. If I were to recommend what you would do, it would be to learn how to program on one of the cloud platforms lake azure or Amazon web services.
Ok this makes sense. I'm curious though, with Oracle's paid support model for the LTS versions, when the patch came out for JDK8 back in April, was that patch actually pushed to the OpenJDK repos or was it recreated by the OpenJDK maintainers? I know it was only a couple of days between Oracle's release and it showing up in the OpenJDK repos, but curious how that happens. Is Oracle actually providing security patches for their paid LTS options back to the community or is the community having to develop their own? I'm assuming the latter, the community has to reconstruct the patch themselves, otherwise the only value in using the paid support is getting the patch sooner.
Devops is more ‚Äúconfiguration management‚Äù than ‚Äúprogramming‚Äù. It‚Äôs basically ‚Äúsysadmin with more scripting than before‚Äù. If you *really* want to be a developer and you must choose between these two, I would say go for the Java one, it‚Äôs more likely to help you figure out how things work in a development environment. Once you know your way around the field, devops will be just one of the things you can do with programming skills. This said, i know nothing about the specific courses , so it‚Äôs all generic advice. There are certainly terrible Java courses and well-rounded Devops courses.
Thanks so much for clearing it up a bit. I was leaning a tiny bit towards Java and now the gap gets bigger and bigger.
Hmm, i'll definetly look into the cloud platforms. Thanks for the advice!
List&lt;Example&gt; examplesToSort = ... ; examplesToSort .sort(Comparator.comparing(Example::getI)); (Or similar with Collections.sort())
When I googled "java sort list" I found tons of pages that give code examples. Did you try any of them? Quite a few including this one give the exact answer you are asking for: &amp;#x200B; [https://dzone.com/articles/java-8-comparator-how-to-sort-a-list](https://dzone.com/articles/java-8-comparator-how-to-sort-a-list) &amp;#x200B; I don't understand why googling is a last resort lately.
And if you want it in the opposite order: examplesToSort .sort(Comparator.comparing(Example::getI), Comparator.reverseOrder());
As someone running production code I'm more apt to buy support from Redhat, Azul, etc than Oracle since Oracle is operating as a silo. That isn't ideal as I understand how much time and money Oracle devotes to Java's development and maintenance. Hopefully they revisit this soon and just start contributing their patches to OpenJDK for LTS rather than the same (hopefully) code being written twice.
I try my best to google this stuff. I tried stack overflow and google but I couldn‚Äôt find what I was looking for. I looked up ‚Äúhow to sort a list by key Java‚Äù, I looked up ‚Äújava equivalent of python key=‚Äú, and I looked up a few more. It‚Äôs not my last resort, I spent 45 minutes looking around. Guys like you made me feel bad for asking questions when I started programming. I try to avoid asking questions on this subreddit because of my experiences on here and Stack Overflow when I was learning. Sometimes people don‚Äôt know what to look up and they need help. There‚Äôs no need to be a dick about it.
Thanks for helping me, but now I have another question: Is there a way to do list.contains() by just one value from the Example class?
Congrats on your project. Maybe have a look at the "where to start developing" card on your website because when we press the link we get a " Server Error in '/' Application" . https://imgur.com/v6mg1Ko Good luck!!
When I search "how to sort a list by key java" the answer is in THE first link. It gives you exactly what you are asking. &amp;#x200B; I don't understand why google almost always gives me great answers but people can search for 45 minutes on google with the exact same query and not come up with anything. Are you from a country where google is censored?
I am from the US, I guess I‚Äôm just unlucky then. My google search was filled with a bunch of unrelated articles like ‚ÄúHow to check Amazon prices using python‚Äù or ‚ÄúHandwritten Equation solver in Python‚Äù which are both interesting, but they aren‚Äôt answers to what I needed.
If you prefer not using a for loop you could do examples .stream() .map(Example::getValue) .anyMatch(value -&gt; value.equals(valueYouAreLookingFor))
That works! Thank you!
It was the other way round for me. The NPEs I used to have are now gone üòÅ
Looks like a job for [`ArrayDeque`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayDeque.html)
Aagh, good reminder. I should report to Oracle :)
I see, and I didn‚Äôt know that. Thanks! I‚Äôm mainly happy I no longer have to use jGRASP like we were instructed to use back in the good old days of my university. IntelliJ IDEA is worth paying for, especially if subsidized by an employer.
Oracle does contribute everything to OpenJDK. We just don't backport it. The reason we don't is twofold: first, we want to encourage people to use the recommended approach, which we also believe is the cheapest and easiest, of using the current JDK releases. If you do that you'll never have another major upgrade again, and your overall upgrade effort is reduced. LTS is recommended for large, rich companies that prefer big upgrades that are planned well in advance but are more costly. This also helps us focus on Java's present and future rather than its past. Second, I guess the business people came to the conclusion that keeping the (more costly, more specialized, less recommended) LTS versions closed would generate more income. As Oracle bears almost all of the expenses for developing OpenJDK, it also needs to make the most money to justify such a large investment.
My issue comes with how the code base splits once we get past the current release. I completely understand and appreciate Oracles need to monetize their effort they put into Java, but for me Oracle handling the backports in isolation from the rest of the community makes me less likely to buy support from them. That is just my opinion. As far as keeping up with the most current release I'm still waiting to see how that is going to play out. I'm still on Java 8 despite making an effort every month or so to bump up to Java 11. Once I'm on 11 I'll evaluate how easy it will be to make production jumps every 6 months in both IDE and linux distro support.
I don't understand how google would come up with python results when you search "how to sort a list by key java". Good luck.
It might happen because whenever I google code stuff it‚Äôs typically python related, but I doubt that so IDK
Thank you for being honest about that. Most people would say, "This would never pass a code review." The two statements are equivalent, but the more common one is an attempt to hide confusion. Before I begin, I'm going to point out that what I'm doing is explicitly (and described as such in the original post) an abuse of Python's functional programming utilities and list comprehension tools. It's not really *meant* to be understood, so much as it is meant to be a compact, easily memorized answer to a stupid question. (FizzBuzz has some rather severe problems as a wet paper bag test, notably that its follow up questions are limited in scope and do not lead to any algorithmic questions that might be relevant.) So what the hell is this thing doing? Let's start with the function. The signature and first two lines should be self-explanatory. The only gripe I'll make here is KEYS.sort(), which returns None rather than the sorted list, thus making list sorting a bit nasty when you want to use Python's functional tools. The magic starts here: replacement = ''.join([FIZZBUZZ[i] if not number % i else '' for i in KEYS]) Let's break it down a bit, working from the inside out. if not number % i This conditional is at the heart of everything. We're abusing something about Python's false value: if you put an integer in a place where a boolean is expected, 0 is false and any other number is true. (I presume you're familiar with the modulus operator: if n % i is 0, then i evenly divides n, or put another way, n is a multiple of i.) [FIZZBUZZ[i] if not number % i else '' for i in KEYS] This list comprehension goes through the sorted keys of Fizzbuzz and will generate a list of replacement strings for each character. Let's inspect some sample inputs here. &gt;&gt;&gt; number = 1 &gt;&gt;&gt; [FIZZBUZZ[i] if not number % i else '' for i in KEYS] ['', ''] &gt;&gt;&gt; number = 3 &gt;&gt;&gt; [FIZZBUZZ[i] if not number % i else '' for i in KEYS] ['Fizz', ''] &gt;&gt;&gt; [FIZZBUZZ[i] if not number % i else '' for i in KEYS] ['', 'Buzz'] &gt;&gt;&gt; [FIZZBUZZ[i] if not number % i else '' for i in KEYS] ['Fizz', 'Buzz'] So as you can see, what it does is it will always return a two element list. If the number is a multiple of 3, the first element is Fizz. If the number is a multiple of 5, the second element is Buzz. If the number is not a multiple of the respective number, the element is an empty string. Let's move out now: ''.join([some list of strings]) The list of strings doesn't really matter, but for our purposes the first element is either an empty string or Fizz, and the second element is either an empty string or Buzz--and there are no other elements. But this works on any list of strings. What this does is it goes through and appends each element of the list to a string, with the contents of the string that the `.join()` method being called on as the delimiter between each element of the list. Because that string is empty, this will produce a string with no delimiters: if the list is ["Fizz", "Buzz"], this returns "FizzBuzz". We'll call this result `replacement`. Next line: return replacement if replacement else str(number) This is Python's version of the ternary operator. It abuses a particular principle of Python: the empty string evaluates to false. Thus, if the replacement string is not empty, (that is, it says either "Fizz", "Buzz", or "FizzBuzz"), we return that replacement string. If it *is* empty, we'll return the string representation of the number we passed in to the function. Last, in our main statement, we have this line: print('\n'.join(list(map(fizzbuzz, range(1,101))))) Again, let's move inside out. I presume familiarity with the range() function, which returns an iterable starting at the first argument and ending at the last argument minus 1. map(fizzbuzz, range(101)) Python's `map` function is a tool that says, "Call this function on each element of the list, and return that as an iterator." It's the equivalent of: def map(function, iterable): yield function(iterable.next()) I then convert it to a list (an unnecessary operation here), then use the same String.join() method passing the newline character as the delimiter. Thus, we get all 100 numbers, with multiples of 3 replaced with Fizz, multiples of 5 replaced with Buzz, and multiples of 15 replaced with FizzBuzz, and each element on its own line.
I don't think you can find a good recruiter. Just direct apply where you want.
Just to be clear: the rate of updating your JDK can be the same regardless of whether you're on an old updates release or on the current version. If you always want to ensure you have the latest security fixes, then you have to update your JDK every couple of months anyway, and if you're OK falling behind and skipping some updates -- say, you only update once a year -- you can do that with either model, too. People have upgraded from 8 to 8u40 in the past (skipping 8u20), so they can upgrade from 11 to 13, as well. Now, the chance of a patch breaking your code (to the degree you have to actually change it) is not significantly smaller (if at all) than the chance of a feature release breaking your code. The effort of a feature update may be bigger than that of a patch update, but not by much, and overall the effort should be significantly lower.
I'll grant that it's a contentious discussion right now, especially among junior devs who came out of school where they were given assignments that were particularly well-suited to the use of static methods--or worse, were taught using C++ and are trying to inflict idiomatic C++ ideas on Java because nobody ever told them that C++ does a lot of things differently. Occasionally, you'll get a senior guy who has always done it this way, is set in his ways, and is absolutely convinced he's right. He's the most annoying of the lot.
The issue is more going to come down to the difference in having my linux distribution package manager apply updated patched versions of the current JDK vs using the package manager to install a new JDK version. Either way the plan is to test on the production version and the most current version in CI so that future bumps in production will be smooth.
I'm not really sure this is on topic. I'm also not really sure what you're talking about. That said, if you want to develop, go Java. If you want to write cool little scripts, go devops.
It's not a university but a higher vocational education. Don't know how common it is outside of Sweden but it combindes theoretical and practical studies in often a pretty narrow subject such as Java or devops. I'm not 100% sure however since I have very little experience. I posted the same post in other subreddits aswell and all have the same theme which is great! I'm pretty sure I'm going for the Java one. Seems to fit me alot better!
&gt; The issue is more going to come down to the difference in having my linux distribution package manager apply updated patched versions of the current JDK vs using the package manager to install a new JDK version. Yeah, it should take some time for the Linux distributions to understand that Java LTS is not necessarily the same as LTS in other software. &gt; Either way the plan is to test on the production version and the most current version in CI so that future bumps in production will be smooth. Right, that's very important. But using the current JDK has the advantage of enjoying better performance (there have been some important performance improvements in 11 through 13). &gt; By the way I really do appreciate you dropping by here and clearing up misconceptions regarding Oracle and Java. It is very helpful to the community as a whole. You're welcome! I'm glad it helps.
Ah, non-American. That makes it not quite as confusing. How old are you, if you don't mind me asking?
&gt; that's at the expense of performance There's no such tradeoff, or, rather there is no fundamental tradeoff. It is true that it's *easier* for stackless coroutines to get good performance while it's harder for us, but there is no fundamental reason why delimited continuations can't be just as fast; it's just a matter of prioritizing effort. So far we've done some small and medium-sized performance optimizations, and have plans for bigger-ticket items, but how soon we do them depends on cost/benefit and users' requirements. It's also possible that we'll release fibers with acceptable performance, and improve it further down the line. That's a common pattern for JDK features.
20, born in 99.
Okay, so you're talking about a program between high school and university, I take it.
No it's more of an alternative to university. It's full time for 2 years with i think 10 weeks practical work.
They are only patching the latest release in openjdk most likely and others have to backport it. It's probably fairly trivial in most cases.
Shit I didn't even know 5 came out. Here I am still using 4...
Programming skills are much more difficult to acquire. You can always do DevOps after that. Just embrace the idea, that there is much more after programming like soft skills, domain logic etc.
One word: Oracle. Big Back End Company corporate culture. Everything must be cryptic and useless.
To be fair, Golang has a nice website and docs and it is made by Google, which is bigger than Oracle, and Microsoft has a very good site for .NET
Still better than cpp site.
I have worked with plenty of teams using java devs to create a front end.. By comparison [java.com](https://java.com) is hip and cool.
[This is the actual Oracle Java website](https://www.oracle.com/technetwork/java/index.html), which looks like basically every other Oracle-branded product page. Java.com was mainly the end user help site for the Java browser plugin, which is now rarely used.
That is a matter of taste.
Because Oracle can't charge you when you browse it.
Its not only the size, its the corporate culture. Oracle is old school back end company culture. Microsoft and Google have been front end, public facing companies since their start. Different mentalities.
Microsoft frontend? That's a good one.
Oh no... The [die.net](https://linux.die.net/man/2/fork) university flashbacks.
I would argue that compared to Go the Java page is significantly older and larger. But that could obviously be changed by such a big corporation like Oracle. So yeah it's definitely a mix of both; Google being a corporation that does kind of care about how a product is presented to a potential user versus Oracle which doesn't seem to care about that that much and the sizes and age of the pages and the languages.
Yes, they have always been about making end user, consumer products. Oracle's existence has been about making massive databases for massive orgs where teams of highly trained professionals run things. Completely different mentality. Looks, style, ease of use matter near zero in that culture.
This is a (now legacy) download site for Applet and .jar double-clicker users. For example, [troubleshooting tips](https://www.java.com/en/download/help/troubleshoot_java.xml) mention Windows XP.
The page was [created by Sun](https://web.archive.org/web/20090703004043/http://www.java.com/en/)
ok so as long as theyre in the same package you just type "import classname" at the top. &amp;#x200B; If it's in a different package then indicate the package which it's in so you would put "import package.classname"
Find a basic tutorial, you need to know the syntax, as it differs from c++. No header files, just .java which compiles to .class. pretty sure there are guides for C developers.
thx! You obviously know Python very well. When you do use it?
What the others have said - [collections should generally be preferred to arrays](https://stackoverflow.com/a/6105705/1273080). That said, if you actually need to concatenate two arrays, and sometimes you do, look at your favourite commons library. E.g. Google Guava: [`ObjectArrays`](https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ObjectArrays.html), or [helpers for primitives](https://guava.dev/releases/snapshot/api/docs/com/google/common/primitives/package-frame.html), e.g. [`Ints`](https://guava.dev/releases/snapshot/api/docs/com/google/common/primitives/Ints.html).
Well, maybe you can use an existing CMS for it?
First example code: @Timeout(3) // Sets timeout limit for each test in class to five seconds wat.
Because Oracle.
You should see the PL/I website...
That and God forbid Oracle creates anything user friendly ever. I swear sometimes it seems like they are actively discouraging people.
Not as bad as Oracle, but their site was lame too. Another backend company.
There may be some truth in that. They make money off of offering classes, training, and certification. They don't want people figuring out their stuff for themselves. They want them to hire their students, so they can keep on making money training pros.
You can't blame Sun for it's state in 2019.
I'm going to go the exact opposite. We need a JEP to remove java string concatenation with the + operator. Barring that, adding string interpolation would be nice.
Java 12 and stay away from EE !
Tada? `IntStream` `.concat(Arrays.stream(new int[]{1,2,3}), Arrays.stream(new int[]{4,5,6}))` `.toArray();`
If that's a suggestion for a function in the library to concatenate arrays, you very much missed the point.
Because it‚Äôs old and battle tested it doesn‚Äôt need a flashy website to get people to use it
Ahh, we're shooting from the hip today? Microsoft's core business is and always has been selling operating systems (desktop and server) along with business software like Office, Outlook, Exchange, Messenger and support contracts to large businesses and governments. Their consumer software they give away to OEMs or deeply discounted to consumers. They are the oldest of the old school. Now, I will grant you they entered into the consumer products world with the XBox so that plays a bit to your argument. But how do you explain ibm.com, redhat.com, sap.com, cisco.com, even oracle.com who all have state of the art web sites. Now, some would say (including me) that the only reason Oracle bought Sun was to kill MySQL and use Java to sue Google. And the reason that Java's web site sucks is because they don't really give a shit about the language. Not enough to want to promote it anyways. The only use they gave for the language is potential leverage over their competitors.
It looks like in your [submission](https://www.reddit.com/r/java/comments/c8ft3d/the_dog_who_caught_the_school_bus/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Downvoted because this isn't even close to right. import statements always include the full package. You don't have to import things in the same package.
If two classes belong to the same package, unless they are declared private, they can see each other without the need of any import statement.
&gt; Ahh, we're shooting from the hip today? Lighten up. &gt;selling operating systems (desktop and server) along with business software like Office, Outlook, Exchange, Messenger End user friendly OS, and mostly end user apps. Front end culture, easy and attractive interfaces.
Nah, that is just the closest I think you can get to array concatenation in java without allocating additional array space/copying things twice. Alternatively, you could do it all in a for loop, but this at least (AFAIK) avoids zeroing out the array. I agree with your point. It would be a bad addition to the language.
&gt;End user friendly OS, and mostly end user apps. Front end culture, easy and attractive interfaces. Over 90% if their software is sold to corporations and governments with huge contracts. Most of it due to software like NT and Exchange which have no frontend. You're thinking of Apple.
You're really making three requests: 1) There should be a JEP; 2) that enhances the `+` operator; 2) to perform array concatenation. It's not clear to me that there should be a JEP, because there needs to be a deeper exploration of what problems need to be solved and what the potential solutions are. Changing the `+` operator implies a change to the programming langauge, which might or might not be warranted, but there's certainly a very high bar for justifying changes to the language. It does seem like it would be nice to have some help with concatenating arrays. This can be done in a couple lines using `Arrays.copyOf` and `System.arraycopy` but the latter, with five arguments, is confusing and I **always** have look them up. Now, better support for array concatenation would be helpful, but how about other operations such as truncation, slicing, insertion, etc.? Anyway, the point is that there is a problem space that needs to be explored. What are the cases that are causing difficulty, and what are those difficulties? Once those are answered, then it might be possible to move forward with developing a solution. Along the way, a language change might be warranted, or not, and a JEP might be filed, or not.
Yeah, those are pretty bad. But https://go.java
You can easily allocate a single result array then do a System.arraycopy in to. Dealing with primitive vs object types, and avoiding punting to Object are issues for doing it in a generalized way. If it was a highly desirable feature, you'd want a System method to do it that would do a realloc on the C level if possible. Long before an operator should be considered, there would need to be enough demand to have a library function (even a slow one just for convenience). It's just not an operation that people do that much.
Oracle cares more about extracting money from developers using java than java itself. The state of the ecosystem shows it. It will not be long before the thing is basically gone from the inter webs completely, ala cobol, borland products and similar stuff.
It still looks pretty bad to me.
Oracle cares about one thing and one thing only, monetizing Java... Everything else for them is just pointless.
Well yeah, but it‚Äôs differently bad
They certainly dont care about responsive design
IBM ?
Think that‚Äôs bad look at SAP... can‚Äôt even read the documentation without a login
Better than Oracle, but only by a razor margin.
The size being referred to above was company size (ie: Google vs Oracle) not language or website size. "...Google, which is bigger than Oracle..."
There's also [openjdk.java.net](http://openjdk.java.net/) and [jdk.java.net](http://jdk.java.net/).
Without any hint as to use case, I'll say 11.
&gt; ...of using the current JDK releases. If you do that you'll never have another major upgrade again... The track record since the release of 9 hasn't been too impressive on that regard so far, as the release of 11 (while basically only having minor changes) broke all Java EE application servers, and the vendors have taken a long time to bring that support. (Oracle Weblogic still only supports JDK 1.8 anyway... :) ) I do understand that there has been (and still probably is) stuff that shouldn't be part of Java SE, but the deprecation-to-removal period has become way too short with the current model. It would be manageable if it was only our code that needed to be fixed to run on the latest JDK, but bringing support for the whole tool-chain, libraries, and dependent software across vendors takes time!
A lot when working with byte arrays.
Presumably because it is adequate for the job of doing what it needs to. I'd also surmise that Oracle's target audience is enterprise business not trendy hipster programmers. Tangentially too many sites are either bloated and over the top or try to present one site to desktop and mobile and end up managing to mangle it for both.
They may or may not also care about databases.
kotlinlang: 2.5MB, 1.1MB transferred scala-lang: 1.7MB, 1021KB transferred java: 440KB, 221KB transferred I prefer the "ugly" one personally. I wish more pages were as lightweight.
They don't care about *databases*. They care about database *licenses*.
There are two separate things here. Module removal requires changing the command line/POM, not your code. It doesn't break your application in the same way that, say, a security fix in 11.0.2/8u202 did, moreover it's something that's easy to prepare for well in advance. I think that the breakage you're referring to has to do with an update to ASM; libraries will need to get used to updating ASM. The way Java shops manage updates *will need to change*, and change is inconvenient, but that doesn't mean that the result isn't easier and cheaper than the old model (while ignoring non-LTS is harder and costlier than the old model). And sure, this change will take time but it will happen.
Yes you can: [https://help.sap.com](https://help.sap.com) E.g: [https://help.sap.com/viewer/product/SAP\_S4HANA\_ON-PREMISE/1809.002/en-US](https://help.sap.com/viewer/product/SAP_S4HANA_ON-PREMISE/1809.002/en-US)
Who cares what the website looks like? I mean really.
I hate Oracle so much, classic greed run wild.
[ORA-28365 wallet is not open](https://www.oraclenext.com/2017/01/ora-28365-wallet-is-not-open.html)
&gt;monetizing Java... And every other piece of software they have bought in the last decade or two.
I‚Äôve always attributed it to the cockyness of Oracle. They don‚Äôt even bother to brand Java yet its the mostly used language.
Link at the top links back to java.com...
[removed]
[removed]
I don't understand your comment. I think CDI moving to Eclipse Foundation is the consequence of JEE moving to Eclipse. Red Hat is largely involved in the foundation (strategic member).
Have you seen aspx? Those sites look like a simple xss would take them down.
Why do it need to be pretty? Who is their audiences? Us. And also, they don't need to. We need to use it anyway, beautiful sites or not.
What exactly do you want from the website? It's got a download link and some links to other java resources. All I see from the other sites is a crap ton of unneeded bloat.
Always latest :) so 12 &amp;#x200B; in two month 13 hits GA
I usually use it in processing plaintext into something a bit more usable, whether that takes the form of JSON, some kind of XML, or even straight-up Java (it does make the creation of dummy data for unit tests easier). In fact, the whole reason the `map()` function has been on my mind is because I've been processing an absurdly long flat file into JSON for an application to consume. Each line in the flat file was its own data set entry, and with that knowledge, I knew I needed to map the function that transformed a data set entry (that is, a line in the file) into a JSON object. Java is *actually* my job. But I write more Python and bash than I do Java on some days.
I don't see how that contradicts then though? Google is also a front-end company; they publish user-facing products all day long. Of course theirs is good.
Have a look at this blog to know about different [Java frameworks](https://www.finoit.com/blog/7-popular-java-frameworks-2019/). All of the frameworks are equally functional to develop enterprise-level application having outstanding features. 
They're not mutually exclusive though. You can make a lightweight website that doesn't look like shit. It's just that many people then also add unnecessary bells and whistles in the form of a shitton of JS interactions and the page becomes much heavier for little utility. Oh and don't forget all the trackers and ads and whatnot.
Just like Java
Its not bad, its retro.
Honestly, I think it's subjective. Of the four you list I'd say Kotlin and .Net are the ugliest, Scala is the nicest and Java a distant second. Still ugly, just not the ugliest. The thing about the Java site, is there are some hints that they actually have a design team (or just one person maybe) working on it. Someone has to pick the photography they use for instance. Which is kind of weird how ugly it actually is then.
All the websites you have listed have the "OH MY GOD ITS HTML5" style and I would argue this doesn't look good at all. Also java.com is not for language, but for runtime - and this model is of delivery is pretty outdated.
It's been out several years and is a ground up rewrite which fixes several issues, like being able to have multiple runners on the same test class, and improves things like having decent parameterized tests. You can run junit 4 tests on the junit5 framework, but you get the most benefit by migrating your tests to the new annotations, which you can do on a class by class basis. Your IDE might be able to do it for you.
And how is this different from most mega corporations?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I like Java
Because java is ugly
Languages don't need fancy pages that try to sell themselves to you. Change my mind.
It's a full language reference: https://en.cppreference.com/w/ What more do you need?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;Oracle cares more about extracting money from ~~developers~~ enterprises using java than java itself
Yes, need to make sure you save a few extra mb... Much preferred over having a website that doesn't look and feel like it was made 30 years ago. Also, Oracle jumped right on top of licensing. They're doing stuff, just for themselves
This is such an amazing comment.
Because this is not Java programming language web site and it's for downloading JRE I guess.
why browse the sub if you don't like the language?
"Here's our website. Here's a big picture of nothing and here are 7 BILLION LINKS TO STUFF YOU NEVER NEW EXISTED!?!"
OMG . [https://web.archive.org/web/20080517225336/http://www.java.com/en/](https://web.archive.org/web/20080517225336/http://www.java.com/en/) vs [https://www.java.com](https://www.java.com/) 11 years and nothing has changed. i feel bad if a feature take more than a month.
Microsoft &amp; Google are the opposite when it comes to open source. Also, I wouldn't care if they developed Java in house but they bought an open language from Sun for it's large adoption and instead of being it's Shepard it have done nothing but help slowly destroy it.
Can't care or not care if they don't even know what it is.
From one point of view this is right, but no different from any other publicly traded American company which has one mandate only: increase its value. But from a more useful perspective, this is utterly ridiculous, and completely divorced from reality. Oracle invests more resources into developing OpenJDK than any other company invests in any language and/or runtime. More than Microsoft invests in .NET or TypeScript, more than Google invests in Android or JavaScript (and at least an order of magnitude more than Google invests in Go), and more than Apple invests in Swift/Cocoa. Those companies "care about one thing, and one thing only -- monetizing their platforms" no less than Oracle, *and* they spend less money on them. As someone working on OpenJDK at Oracle I personally agree that some portion of the resources should be diverted to marketing, even at the expense of development, but that's a question of prioritization.
And a simple utility class wouldn't work for you?
To be fair, as a backend guy, I had to look it up to understand your and the other guy's comments.
All those other dead corp languages tried to do the same. Lookie where they are now...
All those other dead corp languages tried to do the same. Lookie where they are now...
&gt; Microsoft &amp; Google are the opposite when it comes to open source. Really? At this point, OpenJDK is more open than .NET, Android and Chrome. &gt; I wouldn't care if they developed Java in house Oracle has been developing Java for the past decade, and have contributed some of the biggest advances to the platform ever. The people working on Java at Oracle are largely the same people who had worked on it at Sun. &gt; have done nothing but help slowly destroy it. Really? In the past five years Java has seen its greatest growth since its early years. In addition, it continues to break ground technologically in compilation, runtime serviceability and GC.
&gt; Oracle invests more resources into developing OpenJDK than any other company invests in any language/language runtime. More than Microsoft invests in .NET or TypeScript, more than Google invests in Android or JavaScript (and at least an order of magnitude more than Google invests in Go), and more than Apple invests in Swift/Cocoa. Those companies "care about one thing, and one thing only -- monetizing their platforms" no less than Oracle, and they spend less money on them. Proof? Also, if they actually are spending more money its a piss poor job. Have you tried to google any problem that points back to oracle? Its behind a frickign pay wall. I see Oracle bleeding out a slow death and most of the people I work will be more than happy to see them go. There has been a huge move to other open languages like python and node partly because of the shitty practices of Oracle. When I started out of college back in 2010 I worked as a c# developer (we were using .net 3.5) and heard about all the cool Java language features and how c# was behind. I few years in I worked on a Java 7 project and remember thinking wow... has Java fallen behind, where were comparable features like LINQ, lambda, proper async events. I could tell Java was old, outdate, and frustrating to work with and had fallen behind by leaps and bounds. It has taken so many years for them to get to par with some of those features. Java usage has gone from 26% back in 2002 to around 15% now: https://www.tiobe.com/tiobe-index/ and its on a downwards trend. Thank god we have something like Kotlin: https://kotlinlang.org/
[wellacktually.jpg] JUnit 5's second anniversary isn't until September. üôÇ everything else you said though is definitely correct. It is easy to run JUnit 4 within a JUnit 5 context. It is also, like you said, a definite good idea to migrate JUnit 4 tests to JUnit 5 because there are a lot of advantages to using JUnit 5.
What the hell are you talking about? Have you tried to install JDK recently? Oracle supports OpenJDK version for 6 months, thats laughable...
&gt; Also, if they actually are spending more money its a piss poor job. I really wish that anyone who thinks that would switch to other platforms just to experience their poor relative quality. &gt; Java was old, outdated I'm amazed at how behind .NET is. It's more than a decade behind Java in compilation, GC and runtime monitoring. Java is at the very forefront of technological innovation in these areas, and there is virtually no one else that comes close. Sure, the different platforms invest in different areas, but Java's success, and the fact that four out of the five FAANG companies base all/most/much of their infrastructure on Java shows that Java's priorities are the right ones. &gt; Java usage has gone from 26% back in 2002 to around 15% now The early '00s were truly an anomaly. When Java started, people used all sorts of other languages for smaller, less serious stuff (they used to be called RAD; VB is perhaps the best-known example). That for a very short while Java took over their market share was the exception, not the rule. Ever since HTML took over the client, Java focuses on "serious" software, and its tremendous success can't be disputed. &gt; Thank god we have something like Kotlin Kotlin is also a part of Java. I'll need to count carefully, but a Kotlin program uses ~95% of the Java codebase.
&gt; Oracle supports OpenJDK version for 6 months, thats laughable... We've changed the versioning scheme, and done away with major releases. JDK 11 is not a major version, and 8u20 was also "supported" for only 6 months. That has always been the case. People are freaking out about the change in the version names, but once they learn what they mean they'll relax.
Had all those a gpl'd reference compiler and runtime?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Some really useful changes indeed: 1. The lack of `@Timeout` was something that made transitioning from JUnit 4 annoying: Every test case body had to be wrapped into an `assertTimeoutPreemptively` to get comparable behavior. And the lack of `TestRule`-s didn't help much to try to reimplement such behavior either. 2. Default test discovery implementations were also very much needed. I tried to recently implement my own `TestEngine` and having to reimplement (or flat out copy from jupiter) the actual discovery pretty much defeated the point of having standard discovery selectors if they were just data holders without any semantics.
I removed Lombok mostly just because I was tired if it breaking every time it or my IDE updated. Otherwise I thought it was great, and tbh the cost/benefit ratio was in favor of keeping it.
I won't let Lombok near any of my projects no matter how much the jr. devs clamor for it, glad to see others are coming around... I get why it's appealing, but I'll use another language (Kotlin, Scala, (J)Ruby, etc) before I add that hack in my project.
After using Lombok for the past 3 years, I can't imagine writing java without Lombok again. I am also aware of Project Amber which is bringing in a lot of cool syntactical features to Java, but Lombok is a great addition to any Java project, especially love `@NonNull`, `@Builder` in combination with `(toBuilder=true)`, `@Value` &amp; `@Slf4j`.
Google's [AutoValue](https://github.com/google/auto/tree/master/value) could be a neat alternative to Lombok with less compiler magic, if you like immutable data objects.
Given the Python 2 vs 3 debacle, and the chaotic madness of JS frameworks, it's clear that the folks running Java have found a better blend of compatibility and change.
Yea adding `@Timeout` was a really good addition. I also really appreciate the JUnit team's way of implementing features. They provided configuration properties to set global timeout limits and both at that level and when using `@Timeout`, more local values override more broad levels. Have worked with other libraries where this behavior wasn't so consistently implemented.
Very cool. What are the advantages of using delimited coroutines as opposed to stackless (which I think is what .NET uses)?
Lombok is not the answer. Lombok is the question. No is the answer.
[http://boringtechnology.club/](http://boringtechnology.club/), presents a similar idea. The short-term benefit of "shiny" technologies often do not outweigh the long-term costs of complexity and impacts on builds, docs, and interactions with other technologies.
Just a reminder, [records](https://openjdk.java.net/jeps/8222777) are being very actively worked on.
Interesting why we don't see similar attitudes for other much more toxic uses of annotations, like in Spring and Hibernation.
I love Lombok and I do value my time. It's an odd article that - to me, more than not reads as why you WOULD want Lombok in a project. I do acknowledge some of the negatives, like cognitive load. Spring is like that too. Until you know Spring well, it's mysterious and potentially frustrating. I think it also can lead to throwing on unneeded annotations without being mindful.. because why not? But I would argue that these tools also greatly reduce cognitive load, once you understand them. Less custom code -&gt; less cognitive load. You know exactly how Spring &amp; Lombok will behave instead of dealing with hundreds of lines of possibly quirky versions of what is standardized via the library. And mostly, I trust Lombok way more than a junior developer to write a correct hashcode/equality boilerplate. The latent bug might raise its ugly head at a very inconvenient time.
\&gt; "much more toxic uses of annotations" those don't use an annotation processor to generate bytecode so they aren't in the same class as lombok.
The main advantage is that it requires no new language features and no changes to API. You can run arbitrary code either on fibers (based on delimited continuations) or on kernel thread.
Why should I use Lombok's `@NonNull` over JavaEE's `@NotNull` ?
They do generate bytecodes (optionally, depends what you do/use), but that isn't what's bad about them, rather it's what they do to your architecture.
So the argument is basically that we should use editor tools to generate code statically instead of a compiler plugin that generates the code at build time? I love using lombok for things beyond getters and setters too. The builder annotation has saved me hundreds of lines of code just in the last few weeks. var and val are very useful, if hacky, since we're still stuck on java 8. Yes, you have to tell your editor about lombok, but that's usually a one time thing. A little bit of one time configuration will also set up jacoco and other tools to ignore the generated code when building their reports. Yes, you have to trust the generated code, but I've more than once accidentally written recursive getters (e.g. `int getInt() { return this.getInt(); }`) because I wasn't paying attention. I personally hate writing getters, setters, and constructors. They're pure boilerplate code. Why shouldn't I automate that? Lombok works with most every editor. Not every editor uses the same methods for generating this boilerplate, or even can. Standardizing with a tool that is editor agnostic is much better IMO.
I'm not a Lombok fan, because I share a lot of the author's concerns over the deep compiler magic woven by the library, but I don't think it's fair to lump Kotlin's data classes into the same bucket. &gt; In several cases, we used data classes out of convenience. With the removal of Lombok, we found that we implicitly used a lot of features we got for free*, such as equality checks. With the removal of generated code, lots of tests started to fail because these features weren‚Äôt available any longer. The missing features raised the question: Is this feature required? You should almost always override `equals`, `hashcode`, and `toString`. The unit tests failed when those were removed because the default implementations are usually useless, and often simply wrong. It isn't a lot of work to add these inside the IDE, but it's even less work when you use a Kotlin data class. One of the things I really like about Kotlin is that it makes following best practices easy, and often the default. Similarly, I love the idea of Lombock's `@Wither`, which you also get in a data class (via the `copy` method), again without compiler witchcraft.
the world has fundamentally changed and he is still living in the world of monolithic performance.
Any drawbacks Lombok usage has wont outweigh my burning hatred for the amount of boilerplate code one needs to have a basic POJO with setters,getters, some constructors and a nice toString. But I agree its a hack and the ideal solution is to move to a better JVM based language that tackles some of the boilerplate.
&gt; You get more bang for the buck ‚Äì literally. I don't get it.
I see all of them through cost/gain lense. Both Spring and Hibernate generates a lot of value, thus I dont mind putting extra effort into learning them. Lombok is mostly just sugar. And god help you when you use Lombok with entities. Anyway, records will change most of the pain points, while entities I think should adhere to common Java Beans conventions.
Or https://immutables.github.io/
Exactly. It's only "magic" if you don't understand it. Lombok has saved me countless hours in the last few years, and even if it does break every once in a while or cause quirky behaviours, a quick RTFM usually resolves it.
I believe, and somebody correct me if I'm wrong, Lombok will generate null checks in the method as if you've wrote them yourself: if (object == null) throw NPE. While for javax validation you need to use javax validator. Either through Proxy or explicitly in method validator.validate(Object.class, object).
Glad he mentioned what I'd argue is the most important consideration before removing Lombok: the increased possibility of bugs where now IDE-generated boilerplate functions like `equals()` get outdated because they aren't being auto-generated correctly by Lombok anymore
They generate bytecode the way the compiler is intending to support it: by generating a java source code file and then compiling it without touching the source file/class the annotation came from. Lombok goes into the parse tree (via non-public APIs) and mutates the AST in place.
Hmm I see. I actually wonder... why does Lombok do that? Does it *have* to do that?
&gt; So the argument is basically that we should use editor tools to generate code statically instead of a compiler plugin that generates the code at build time? That's the minor point of the article. The major point is that Lombok exists as long as there is a critical mass of users enough to support continued development of it as the JDK changes. As the JDK adopts more Lombok functionality, those people supporting lombok (including at the IDE level) might be changing their minds as to how much they'd like to spend making it work for everyone else. Eventually, development will stop, those using it will not be able to find a chair when the music stops and will be forced to leave their code frozen in time or rewrite it in order to use future JDK releases.
+100 lombok is a cancer. If you want data classes for now, use a tool that gives you _only_ that (write them in Kotlin, use one of the many preprocessors out there). Remember, we are getting real, JDK supported data classes in the next year or so. lombok has _so_ many annotations and your team will start using them all: `@Data`, `@Value`, `@Builder` and on and on. Each of those annotations may have 3-5 optional attributes as well. Now combine this with the plethora of annotations from other common libraries (I'm looking at you Spring) and you end with classes like this (actual class taken from our code base): ``` @Repository @Slf4j @RequiredArgsConstructor @FieldDefaults(level = PRIVATE, makeFinal = true) public class AssignedBlockByCourierV2Dao { @NonNull Casserole casserole; @NonNull Environment env; ... etc. ``` - Which of those is lombok and which is Spring? - Is `casserole` private final or is it mutable? I forget - need to look up at FieldDefaults for that. Is it really that much better than writing `private final` on each field? I think not - How many constructors does this class actually have? - What the hell does "repository" mean (I realize that's Spring but it's the same problem). STOP THE INSANITY! Can we please get back to writing real, JDK-supported Java again? Sun is really to blame here. They let Java lie fallow for years and people stepped into the vacuum. However, Oracle has been doing a fantastic job at improving Java and by the this time next year we really won't need all this shims/hacks.
&gt; So the argument is basically that we should use editor tools to generate code statically instead of a compiler plugin that generates the code at build time? That's the minor point of the article. The major point is that Lombok exists as long as there is a critical mass of users enough to support continued development of it as the JDK changes. As the JDK adopts more Lombok functionality, those people supporting lombok (including at the IDE level) might be changing their minds as to how much they'd like to spend making it work for everyone else. Eventually, development will stop, those using it will not be able to find a chair when the music stops and will be forced to leave their code frozen in time or rewrite it in order to use future JDK releases.
&gt; So the argument is basically that we should use editor tools to generate code statically instead of a compiler plugin that generates the code at build time? That's the minor point of the article. The major point is that Lombok exists as long as there is a critical mass of users enough to support continued development of it as the JDK changes. As the JDK adopts more Lombok functionality, those people supporting lombok (including at the IDE level) might be changing their minds as to how much they'd like to spend making it work for everyone else. Eventually, development will stop, those using it will not be able to find a chair when the music stops and will be forced to leave their code frozen in time or rewrite it in order to use future JDK releases.
&gt;@NotNull by itself doesn't do anything, it's just documentation for the client saying don't pass in nulls here. You have to still manually verify the value. @NonNull wraps the variable around a null check which throws a NullPointerException if the variable is null.
Lombok create a if test. I prefer to use spring version of @NotNull, @Nullable. No overhead, just linting in intellij and static analysis in spotbugs and pmd.
I recently was introduced to Lombok. My first question was why is my IDE bitching that this code is incomplete. Oh I need a plugin for that (IntelliJ). It takes three key presses to generate the default getter setter, hash and equals methods. Then your required to think about what makes those objects actually equal, maybe ID isn‚Äôt good enough. Also, run a Coverity scan, if your heavy on OOO and Lombok your in for a real treat. Lombok is great for prototyping and fast code output but in the end has only cause me rework. I respect the use of it, but don‚Äôt like to promote it to my younger team members.
Have you extended a class annotated with Lombok, then in the child class added that annotation in again? Have you run a Coverity scan? If no, just wait.
My current company has been using Lombok nearly everywhere for a little over 5 years. 100+ engineers, somewhere between 300 and 400 microservices, maybe 5 to 10 million lines of code. **Never once encountered any issue serious enough to cause a moment's regret.** The worst "problem" is occasionally needing to disable or override Lombok's `equals()/hashCode()` implementations, and that's a once-in-a-blue-moon thing. Honestly, most of this blog post, and these Reddit/HN threads, boil down to "*it's trendy at the moment to rail against 'magic'*". That's fine, downvote away. But the opposite was trendy 5-10 years ago, and I'd bet you my life savings that the opposite will be trendy again 5-10 years from now. Because ultimately, this whole industry is little more than endless waves of newbies. Each new wave trying to make its mark by embracing new fads, and rebelling against the previous wave's fads. The technological equivalent of high school students and pop music, each wave of incoming freshmen needing to distinguish themselves from what the graduating senior had been listening to. After you've been around long enough to witness multiple waves, you grow unimpressed with the whole process. All I know is that Lombok, and tooling like Lombok, has been extremely beneficial in my personal professional experience, and has not shown drawbacks significant enough to offset that. If that's not a trendy thing to write in a blog this year, then I'll just go back to work and wait until it becomes trendy again.
It takes 3 key presses for each class. Compound that, and that's a lot of key presses. From what you've wrote, it seems like you think Lombok is a silver bullet to faster development output. It's not. It's basically just a library that generates your getter/setter, constructors and builders. There's no magic to it. If you need things a different way, you override it. If you need everything a different way, you drop it. It didn't lead to you having to "rework" code. You just never understood what you were using in the first place.
Here we go again ;) Lombok pros and cons are a long topic in Java community. In our project we've introduced Lombok few months ago. One drawback was that the compilation speed was decreased a lot. However, code started to be more user-friendly. All getters/setter were deleted, people more often used @Value for DTOs and temporary objects. Model classes became much shorter and focused on the information they transfer, so the core business logic, business value. I understand concerns that Lombok does it's job in hacky way, but we are aware that this is a temporary hack and Java Community is working on Data Classes. In my humble opinion we should focus on what code should do instead of writing not-relevant code "just to not use some hacky library"
I disagree, I think they generate negative value. I have no words for how much I hate teaching fresh graduates how to maintain and work in a spring + hibernate project. Throw in some lombok and jaxrs and it takes \_months\_ for them to have any clue what makes the project run.
&gt;All getters/setter were deleted why were they there to begin with? habit?
With an attitude like yours, I wouldn't let any junior developers near you.
I knew what it was from the start, hence my hesitation to allow for the use of it. Implicitly it does promote annotation laziness (not implying you are lazy). But devs quickly toss on Anno‚Äô s and then when inheritance comes into play, forget that you will need to override those methods or use new annotations to help support the current ones. I know Lombok has a place in the community, no denying it. I don‚Äôt like that younger devs are using it so often that they forget design principles and fundamentals of OOO.
What exactly is "monolithic performance" supposed to be?
If java supported compile time macros, then it could be reimplemented as such. Since java doesn‚Äôt have macros, they invented their own based on internals of OpenJDK.
The way author presents his argument I am not sure if he is against the *idea of value/record/data class* or the *implementation*. I get it that Lombok is basically hacked into the Java, and *that* might cause friction, but everything else? Records are things that you shouldn't spend time thinking which if the features you need and which you don't: you have certainty that they represent the idea of mathematical record so equality check is a must (`equals`/`hashcode`), `toString` is nice to have, and accessors should be matching the values inside. And out of the box it should be as dumb as possible with an option to override the behavior if needed. So... I find kind of reasonable why one wouldn't want Lombok, but not really why one would like to remove the idea completely if some alternative was available (the author mentioned Kotlin and `data`). If that's what he wanted to say I couldn't infer that from the article. And complete removal of records I find just absurd after working with them for so long.
Every shop (and developer) is different. I follow the "boring software" school of thought (thanks /u/IanRae for that link) for the most part. You are free to use Lombok as much as you want and I'll gladly let my Jr. Devs talk to you. I'm confident that I can present a strong and compelling case for why it doesn't belong in enterprise software that not only needs to be written today, but maintained for decades. I'm not scared of competing ideas. I've also been known to change my mind on many occasions. I've just been in this specific boat a few times and it's come out on the "ditch Lombok" end more than once.
It's actually pretty easy to create your own 'automations'. You don't need to do everything, just those parts that your project needs. I work on a software, which I started to write in the end of 2001. First real world usage was early 2005 and slowly and steadily the userbase has grown. I'm extremely careful when choosing tools and libraries since our 'project' has greater longevity than most of those, so it's usually better to write your own so you don't have to periodically rewrite those parts that rely on some external tool no longer updated or available.
I use Immutables for every project I work on
+1 for immutables, we've started using it recently instead of Lombok. The 'fromInstance' has been useful, and bring able to create a builder from a parent instance has also been very useful.
You're missing one of the main reasons why its useful. Its not to save time when writing the class originally but rater to save time and reduce errors when later reading or refactoring the code. When quickly glancing at lombock annotated class you know exactly how it will behave. If you have manually defined getters, setters, hashcode, equals, etc that code could have been written or modified to behave in a non standard way, so you have to review the code each time and confirm. I have not used lombok in a while but see how beneficial this pattern is every day when using Kotin data classes.
JodaBeans is worth a look: uses code generation from a maven plugin, which means real code you can read and process as normal.
Help me understand as I am trying to learn. Why would I want my equals method, for example, to be auto generated? I‚Äôm thinking of inheritance between subclasses, their parent and a lot of possibilities where that is valid. Agreed? Ok. If you don‚Äôt agree this next part is irrelevant, however, fresh intern or dev comes on board (very green), how often do they take annotations for granted? My point is not that Lombok is invalid or should not be used, but I‚Äôve seen it used improperly more often than not. Now, that could just be me, but I‚Äôll refrain until I hear more. That being said here is the example Parent Class Automobile Child Truck Child Sedan How would you annotate those?
This. I love to learn. What I have learned is Lombok can (key word is can) quickly be abused and caused my teams rework with security scans. Seem my above comments on OOO / inheritance and you can imagine why. It has a place, just not mature enough yet. Kotlin is competing, any other automated code generator is competing and I‚Äôve found if you can see it, you can review it, you can catch mistakes or at least have a chance to review what was generated. Blindfolding devs is dangerous.
Hibernate requires them for lazy loading.
Did you try [AutoValue](https://github.com/google/auto/tree/master/value)?
Anyone who despises Lombok either doesn‚Äôt understand what is going on, or is simply contrarian by nature. Sure, it has bytecode enhancers. THAT‚ÄôS THE POINT. So does Spring. So does Hibernate. So do many other well-known libraries and frameworks. I have been working in Java for over 20 years now. The language didn‚Äôt move fast enough to add data classes and other features, so libraries (and other languages) filled the void. Thus is the nature of abstraction and software languages. It‚Äôs tiresome to continually see this FUD being thrown around. Don‚Äôt like it, don‚Äôt use it. But it is not a moral dilemma to be solved nor something that demands eradication. When data classes and other boiler-plate saving features finally arrive in Java, then we will use it. Until then, we will use what we wish which solves the same problem.
To be fair, I really love to view manpages in this site
Either way, you have to eat the one-time cost of migrating existing code, and you'll have higher maintenance costs afterwards due to manually editing stuff that Lombok currently auto-generates. What's the argument for volunteering to pay the one-time cost, and starting to pay the ongoing cost, until we actually start to see the community lose interest? It seems unlikely that community interest will abruptly end all at once; more likely it'll be a gradual thing and we'll be able to see the writing on the wall well ahead of time.
One of the best libraries to include on your project
What's the current state of having custom equals()/hashCode()? Last time I checked, this wasn't possible. IMO this rules them out for many use cases unfortunately.
I don't know, but they are *designed* to be ruled out for many use cases, and that is both intentional and fortunate. They are meant to be used in a very special, but very common case. If all fields are public (at least exposed with public readers) and immutable, custom equals and hashCode are not usually wise, and may not interact well with pattern matching.
&gt; Any of the members that are implicitly derived from the state description can also be declared explicitly. (However, carelessly implementing accessors or equals/hashCode risks undermining the semantic invariants of records) I think you're confusing records with Project Valhalla. The latter have no identity. Records are classes.
Hi, check out /r/javahelp for beginner questions.
&gt; and work in a spring + hibernate project The latter part is usually the problem.
Yep, I've seen way more problems with faulty (or missing) equals/hashcode/tostring than issues due to Lombok. It does add complexity for newcomers and may cause issues in the future if/when Lombok development slows down, but the time saved writing and reading code will almost certainly dwarf any time spent on those issues.
I would prohibit the use of Lombok in libraries because it makes looking at the source code difficult.
then use groovy
I had an architect who didn't like Lombok. In his project ~33% (!!!) of the codebase were POJO definitions... And I'm talking about ~800k Line of Code project. Adding another language (especially something like Scala) is MUCH more disruptive than Lombok.
&gt; @Getter/@Setter &gt; Never write public int getFoo() {return foo;} again. I am not a java expert. Why couldn't foo just be a public property?
The time spent reading and writing the same arguments for and against java boilerplate code outweighs and time saved by lombox or wasted on boilerplate code by a factor of 10.
#AskingRealQuestions
It looks like in your [submission](https://www.reddit.com/r/java/comments/c8svd2/need_advice_on_how_to_sell_a_product/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Kotlin
... and Microsoft just broke .NET... again. The best cure for people bitching over Java is to spend time with other platforms.
What else keeps single copy of JavaDoc instead of same stuff on field, getter and setter? &amp;#x200B; There is shitty thing in Lombok (hello \`@Builder\` and inheritance and always alpha stage of feature that we are using in PROD for 5 years). Just use less shitty parts ))
This is a lot of lingo haha I've never had experience connecting a DropWizard project to a database before. You mind if I link you a repo and you poke around and point me in some right directions?
&gt;I get why it's appealing, but I'll use another language \[...\] before I add that hack in my project. Does that mean you're letting people use other languages on the projects where you forbid Lombok?
This is a lot of lingo haha I've never had experience connecting a DropWizard project to a database before. You mind if I link you a repo and you poke around and point me in some right directions?
https://immutables.github.io/ Done
Wait... Lombok can generate builders for you too!?!?
Oh yeah
This is one if it's best features IMO. A lot of the rest of what Lombok does can be auto generated with most IDE's. But, builders are wonderful.
The point of IDE is interesting, I was working in project that we was using loobok, and many people of the team was using eclipse, and others intelij, the people that was using eclipse had several configuration difficulties to make eclipse works good, until they surrendered and migrated to intellij
Because java has no language constructs for properties and foo is just a field. Public fields should veeery rarely be used in java, there are reasons you can find in google :) some of the more important ones: can't be part of interfaces, can't be virtual, can't be refactored/guarded with an api.
The problem is that once you do all that great autogeneration on day one, and someone adds a new property and forgets to update hashcode/toString, now you've got a defective class.
I enjoy using the AllArgsConstructor in my spring objects to not have to worry about autoinjecting. Just add the component as a class variable and it‚Äôs there.
A lot of it has to do with the legacy of Java. The Java Bean was a very important thing, and to be a Bean you had to have a getFoo and setFoo. Public foo was not good enough. Also the "best practice" at the time (before IDEs were so powerful with refactoring) was to always have getFoo and setFoo so that downthe road, if you needed any custom logic there, you would not have to move existing references to myClass.foo -&gt; myClass.getFoo. It's a big reason why people deride legacy Java for being so wordy and full of ceremony. Languages that have transparent getters/setters ('private foo; public get foo; public set foo') make this custom irrelevant because you can always just add the accessors when/if they are needed.
&gt; Help me understand as I am trying to learn. Why would I want my equals method, for example, to be auto generated? When you add one or various variables to a class you may forget to add it to the equals() and toString() methods. Lombok does that automatically.
The benefit is often in the setter. If foo shouldn't be negative, the setter can throw an exception when someone tries to make it so. If it's a public property, anyone can do anything they like to it and you don't have any control.
After reading the article I still can't get why would one remove Lombok from their projects. Why? I also use Lombok in combination with Java 12, no issues so far. Could you elaborate a bit in which way Lombok stops you from updating to new Java versions?
I too removed Lombok from my project. My reasons: - The compatibility of Lombok with new JDK versions is uncertain - You need an IDE plugin to use Lombok. You can't update IntelliJ before the Lombok plugin has been updated - Refactoring of Lombok annotated classes is dangerous. For example, the re-ordering of members of the same type assigns the wrong values to the members in a constructor when you use @AllArgsConstructor -Lombok Builders on classes with final members do not require these members to be set in the builder. This causes potential issues when you forget to update a builder call - You cannot use ‚Äòfind usages‚Äô on hidden generated code
How many developers still use JDK8? 50%? That's one of the reasons to use Lombok: getting var without the new jdk version. And even if JDK development and early adoption outpaces Lombok you most likely stay on a perfectly fine language version and don't rewrite everything so you can have more syntactic sugar in it
There was a time where using an interface was required. Nowadays people just do it for interface's sake like `UserRepository` and `UserRepositoryImpl`. I guess there is hope, that this abstraction is required somewhen somewhere. Though sometimes it could be useful. But in the context of JavaEE and Spring, I assume 95% of all interfaces are superfluous.
I think so
What about the cost of writing getters setters equals etc
I don't see why lomboks equals is not a win win. it gives you an equivalent equals to the one you generate, except when the generated one isn't enough and you need to change it. *Should* Sedans equals actually call super? If someone wrote/generated an equals everybody else have to actually read it to know whether it has been fiddled with just so they can *read it again more carefully* to know whether it's the source of the bug. In this scenario lombok is just great. I frankly don't see the point you alluded to. You need to think about what your equals method does anyway, why not write your solution down in a more succinct fashion? Worst case scenario you implement the critical ones yourself and the readability is still better than without using lombok
You shouldn‚Äôt test Lombok generated code since those tests are almost always useless. Doing something beyond Lombok for equals or hash code almost always means your code = complete and utter garbage (for dumb data classes). I will not stop using Lombok until the Java community finally accepts that demanding getters and setters for every field is absolutely ridiculous. While generated code does have overhead, it‚Äôs overhead is far less than actual code in your code base.
In a lot of shops, introducing a new library, even a big one like Lombok, is an order of magnitude easier than a new language.
If a library creates additional cognitive load for the author, then how the hell is he using any libraries and frameworks at all?
That code gets in the way of READING which is far more important than the writing of code. I don‚Äôt care a lot how much time it takes to auto-generate, but I do care how it introduces unnecessary cognitive load when trying to understand a project.
You could also generate getters/setters/equals etc using your IDE. As long as they're at the end of your class, after non boilerplate code, there isn't much difference to using Lombok. Granted, it takes a few seconds more to generate them than to write 1 Lombok annotation, and you have to remember to generate them for new fields, delete them when you remove a field, but the extra effort is marginal. If someone is writing getters and setters by hand today, that's a different kind of problem.
Inheritance is 99.9999999999% of the time a very, very bad idea. There is a good reason why many new languages are leaving it off entirely. Honestly, breaking inheritance is an upside in my view.
I find these crutches to address Java verbosity adds unnecessary complexity. In the case of lombok it is even worse since it modifies the AST using private undocumented APIs that may or may not be supported in future versions. I know you'll counter me by saying it has stood the test of time, but honestly that itself requires work. Plus Java used to move at snail pace but not anymore. With the new six month release cadence we have several new and upcoming improvements to the language and the last thing I want to learn is that I cannot adopt it due to some private unsupported calls used by lombok in my code. And on that note there are improvements like Records that are going to make much of the reasons to use lombok obsolete. Same applies for reactive frameworks when Loom comes into full force but that's another day another topic. TL;DR - Just write the damn code.
when you're modifying a POJO (adding/removing members) you cannot say with a straight face that looking over equals and hashCode can be an oversight. Especially if you're adding fields that can affect equals and hashCode (not all of the POJO fields affect equals/hashCode right? i mean, it can happen, but it's rare. usually there are a few significant fields that determine equality).
Said nobody ever.
Sure, happy to help, although you may do yourself more service if you follow the user guide and try it yourself.
What‚Äôs the .00000000001% where it‚Äôs a good idea? No problem changing my views but I need education before I can do so.
https://projectlombok.org/features/EqualsAndHashCode
performance in the traditional monolithic setup - where how fast a language performs matters more than in a distributed setup
If your getters are that trivial, why not just make the fields public final?
It does pass security scans, check Coverity. That‚Äôs a major downside, for starters.
https://projectlombok.org/features/EqualsAndHashCode It‚Äôs in their documentation. This is the third reply so have at it.
For everyone reading this. Please be advised, Lombok has flaws and does not pass Coverity or other security scans. https://projectlombok.org/features/EqualsAndHashCode Read the documentation and think about inheritance. If you are not using inheritance, well... enjoy.
I've been using lombok for years - it's not that new and shiny. Also it does not impact the architecture and can be removed automatically if desired (https://projectlombok.org/features/delombok). Your argument does not apply here.
Couldn‚Äôt agree more. This post seems ideology driven and hardly pragmatic. Of course Lombok enables a different kind of coding error... by eliminating a much larger class. I‚Äôd like anyone who rails against ‚Äúmagic‚Äù too explain to me in detail how Streams are implemented. Or a java.util.concurrent.Flow implementation like Reactor. And yet I doubt anyone would suggest we ditch streams for being too magic. Really good abstractions all seem like magic and you will eventually get bitten by them if you don‚Äôt take the time to understand what is going on (and probably will even then.) I‚Äôd be surprised if the 900 lines of code they added removing Lombok costs less than the occasional Lombok bug, so at the end of the day, they‚Äôre making work for themselves. Not a fan.
Except that Java is the underlying implementation behind the most widely used distributed framework in the world...
Bit annoying but for the builder problem if I have some required fields I override the static ‚Äúbuilder‚Äù method that Lombok generates with my own that specifies the required arguments (then all the option/defaultable fields the regular builder methods generated by Lombok can be used). Lombok detects you already created a method named builder and doesn‚Äôt auto generate it. For the find usages problem it‚Äôs not obvious but in IntelliJ or Eclipse you should see the auto generated methods in the structure view of the class (separate panel) and the click on that and do find usages. Not as obvious though as directly having it in the source.
Very occasionally it can be useful for avoiding duplicating a bunch of fields shared between various classes and composition doesn‚Äôt really make sense. Also, for really weird cases that I‚Äôm sure exist but I can‚Äôt say don‚Äôt exist. When it is used, inheritance trees should be kept as small and limited as possible to avoid complexity.
That is my personal preference, but some people in the Java/enterprise community insist they be present regardless of circumstances.
&gt; Never once encountered any issue - support for new JVM versions is lagging - last I checked errorprone didn't want to work with lombok, but there were some fixes for that - refactoring sometimes fails if it related to "lomboked" code - there are no getters in the code so the normal way to "find method references" or "show call tree" by clicking on the method does not work - sometimes it's hard to understand how the class is created. E.g. I can add a single constructor to make sure that this is how the it's created, but surprise! @Data implies @RequiredArgsConstructor which smuggles in another constructor. - sometimes it's hard to understand what the hell is going on - I'm looking at you @Delegate - when importing the project into IDE you need to know how to enable lombok support (and need the plugin). It should be possible to e.g. use gradle to generate idea projects with this option enabled but I never really wanted to spend time on investigating this. But despite the above I still prefer to use is versus creating getters and writing "private static Logger log = Logger.getLogger(...)" in every class. I like it, but I prefer to stick to the basic annotations: - @Slf4j - everywhere - @Value - whenever possible and the type is really a value - @ToString, @Getter, @Setter, @EqualsAndHashCode - Sometimes @Data, rarely @Builder. But when I need a builder I usually also want some custom code so the annotation does not work anyway. It's better to just write it by hand. The rest are problematic in various ways and I found that it's better to avoid them.
Avoiding code duplication / redundancy is not OOO java but good in Lombok. Giant inheritance trees are great use cases for your examples. Those are avoided anyway. If you are using java, building enterprise software NOT using inheritance and running security scans then I feel for you. No problem but nothing I‚Äôve heard is helping your point, in fact, I think your last statement and Their documentation supports my beliefs.
Lombok is anything but new and shiny. It's a fix to the Old Problems of Java back when beans and objects were the new and shiny and people loved writing mindless code for the sake of it.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You'll pay me double to write the useless code and triple to look at it. Generated code that's out of my face allows me to focus on the meat of the issue at hand.
If your code coverage includes generated code of any kind, it's bad to start with. You only want to test the code a human member of your team has written. Do you test coverage the libraries you import too?
...until something weird happens and you spend hours trying to figure out happened. Also, are there still jobs out there that pay you based on LOC? That can't be a good thing.
This is the best comment I‚Äôve ever read. Thank you. Yes you test all third party libraries on top of code you write in house for security vulnerabilities. I am always civil in my responses but you sir take the cake. You can safely delete your comment for the sake of everyone on here who may not know.
I just wanna say, all you morons hating Lombok are writing tomorrow's nightmare Java. Use it right and spend time on writing code that actually does stuff rather than fullfilling idiot coding conventions from 20 years ago.
Security scanning, sure. But unit test coverage of generated code, really? It's like generating code for the purpose of having more code to write. Might as well write a test generator to test the generated code... Or you know, test the generator itself, and its templates (if you wrote it) _once_ and be done with it. I didnt want to be rude, but really, its obvious to me that generated code should be out of scope for test coverage targets. Otherwise, what's the point of automating the code generation in the first place if not to reduce defect count at the source?
[removed]
I think this is quite pretty and also works nicely on mobile: https://docs.oracle.com/en/java/javase/11/
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Seems like they are designed to solve for needing a quickly declared type. An alternative to adding tuples. They aren‚Äôt really a full solution to getting rid of all our boilerplate in bean classes though.
Stop typing. You know nothing of what you are talking about and sound like a fool. Quite literally, your not reading my comments or comprehending them. Either way it doesn‚Äôt matter. Read this: https://projectlombok.org/features/EqualsAndHashCode Google: Coverity. Learn. After that come back and give me concrete examples of why this library helps an organization that is larger then 20 devs, having to produce software to the general public larger than 1k people or who release software to a government agency. When you still have no idea, think harder. Or.... if you made it this far, read the number one comment. Checkmate.
Most of those points I have never run into whilst using IntelliJ, ever. However, @Builder and Jackson is a miriad of getting the right constructor annotations and then not really working because you have some kind of inheritance, by which time I'm ditching @Builder. Still would rather that than creating a whole load of boiler plate each time.
Read the top comment on here. Devs have opinions, we tote them. Facts change my opinion; in drastic format. Prove something is more efficient with mathematics. Big O. If you don‚Äôt know Big O, stop. My attitude is a response to the overwhelming bad excusing people are making for a proven security flawed third party library that is quoted as this in their documentation. Here have a read: https://projectlombok.org/features/EqualsAndHashCode
Is because Java is not afraid of being ugly.
Username checks out.
I don't get what the benefit of this is exactly. You still have to deal with the NPE and most of the time, based on my personal experience, there are better ways to go about it than try-catching an NPE.
Adding lines of code to reduce one bug in a software project with a budget, scale and expertise is something you haven‚Äôt experienced. But, you know this already; that one bug is costly. Bugs and vulnerabilities equate to dollars and cents. Those dollar and cents don‚Äôt pay for conversations like ‚Äúwell it saves lines of code,‚Äù when the Chief is standing in your office. Keep that in mind with any library you introduce. It has to pass Vericode, it has to have a license, and it has to work. Ps - the magic you speak of above is open source and performant. Read up on Big O, then read up on Streams. Do you think it was developed by someone who is a hack? Preach all you want, your opinion is yours, but don‚Äôt state garbage like facts without research.
Magic has always been something to avoid AFAIK? I do agree it comes and goes in fads, but never saw much value out of Lombok, you save auto-generating with the IDE a bunch of code in exchange for an extra dependency and an extra compile step? I'll personally pass on it ü§∑
I‚Äôve been having mixed feelings about it but tbh lombok doesn‚Äôt really do much magic for you. I‚Äôd say its okay to use with discretion. The equals and hashcode generation easily have the best ratio in terms of long term benefits to costs.
It doesn‚Äôt pass security scans if used improperly. You may be a good dev, but is your entire team like you? Does holding up a release because someone broke code in a security scan due to known facts sound like mistakes you want to pay ($$) for? Google your Lombok question, read a bit. Then go read some more. Finally, come back and tell me why you wouldn‚Äôt. Lombok states on their site, in plain English, why it doesn‚Äôt work ‚Äúall the time.‚Äù If you just thought, well I don‚Äôt need ‚Äúall the time‚Äù... then you‚Äôve made it.
As it happens, I don't really use getters and setters myself, but I belong to a very small minority. I've adopted a code style where naked public fields are fine, especially when making a record class which usually has no methods other than the default no-arguments constructor anyway. These record classes are used to transfer data between boundaries, e.g. between database and application server, or application server and to some foreign endpoint in wire protocol such as JSON. They are annotated to provide sufficient metadata for correct conversion across the boundary. In general I find that I don't usually need to propagate object's state from one object to another except over some language or network boundary, so even if I did define these methods they wouldn't be called by anything because they represent functionality I don't need. I mostly just supply what classes need in order to operate in the constructor, and they go straight into private final fields, and there is no need to expose them externally. My objects generally expose behavior, not data. I also basically never need to write equals or hashCode methods. Instead of bothering with equals and hashCode to make something for use in a Map, it's often simpler to just write a routine that returns the key for that object which works in context of that specific generic collection, for instance maybe you only need a subset of the fields for deriving the proper key. These methods I write are generally of form `private static String toKey(T t)`. I prefer this over writing, say, an adapter that honors the hash key API because I'd rather call a simple toKey method and get some opaque String value over doing some `new Key(t)`, because such class will have heaps more code and will be far more difficult to read. A lot of the time the toKey method is very simple, something like `return t.x + ";" + t.y`. Finally, I tend to use JSON serialization for my toString(), e.g. when writing some object into log, something like that, or JAXB, tends to work fine. Still, JSON may need to look into private fields which implementations like Jackson doesn't do by default, and some data is not serializable in any meaningful way, so this kind of stuff isn't a complete silver bullet solution. Still, I find it enormously helpful to have a fixed format like JSON for my data rather than some random "\[" + getClass().getSimpleName() + " x=" + this.s + " y=" + this.y + "\]" kind of serialization, or whatever.
That's explicitly a non-goal for records.
You sir... thankfully don‚Äôt work at a large organization lol.
The benefit is to fail fast. Also, please don't try-catch NPEs
Exactly. And so...?
Scala. Scala 3 will be _really_ nice.
[removed]
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Imagine, that you have a setter for the field and you don't want to set null. Without throwing NPE at the stage of setting, the NPE will be thrown when you call method on it, but then all you know is that someone somewhere set null. If you throw NPE in setter, you know exactly what happened.
Mate, I'll have some of what you're smoking.
Reasoning, kind sir? Rather make statements in attempt to belittle someone than point out facts? Enlighten us, please.
Have you read what you wrote? You made absolutely no sense.
Let me rephrase: Lombok hacks crap into the compiled class files. More efficient solutions to whatever problem you want to solve with boilerplate code exists. Big O is a way for folks to decipher how well their code performs during runtime OR compile time. Read some other comments... or actually go figure out why that may be pertinent information. Or don‚Äôt, continue on.
I think we all know what Lombok does, and how it goes about it. Big O has absolutely no relevance here because we're not discussing about algorithms. You're making absolutely no sense.
I'm torn between Kotlin and Scala. To push it past my colleagues at work Kotlin wins because its faster to learn for Java programmers tho lately I'm liking functional programming more and more so Scala has an edge there for me.
I think you're the one who should be deleting your comments. You clearly belong in /r/learnprogramming
Because sometimes all you want to express is the labels and enums are an old, well understood concept regardless of implementation. On that note why bother with classes when it's nothing more than a pointer to a struct holding function pointers to do your dynamic dispatch? Why bother with functions when it's all just a fancy way to basically do a goto?
An instance of enum is hardwired by the JVM to be a singleton, and comes fully loaded with useful methods. Ordinal, valueof etc.
Because you can use the type of the enum as the type of a parameter, instead of String or int, making it impossible to mix it up with another String or int.
Before enums were introduced, the Java API used to rely on static final int constants to express enumerated types, which is not nice when some method parameter should be in the range on some existing values, and do not accept anything else. So, the parameter type would be int, what means that you can put any int on it. With enums you can input only the values defined in the enum, so it is a type-safe way (and it is as fast as int constants). Enums also are objects and can have a proper type, implement interfaces, etc, so, it is win-win.
I've been trying to get all of our lombok days classes converted to Kotlin. None of the service tier or dao classes, just the things that carry data around.
TLDR; Wanna change Java? Here's a shitton of bureaucracy thrown your way! But kidding aside, I like that Java doesn't "change" a lot. With every simple change that seems like a good thing on its own, you add to the language complexity and if you keep going at a healthy pace you soon have a monster that everyone hates. Maybe one way is to think about BC differently, and remove features just as aggressively as they're added. But developers don't like that either.
&gt; widely used distributed framework &amp;#x200B; which one?
And all programming languages are just syntactic sugar for flipping bits based on some rule or another.
Why any of us exists? Enums existed before oop and way before java. Back when they invented datatypes I guess? Like 1973 or something like that. In your example you should use enum instead of static class because it's faster.
1976
Data classes are "cool" if you use them for Value Object pattern. Other than that it's garbage that resemble more of java beans, which are OOP anti-pattern. And comparing lombok to Kotlin data classes just because they are doing the same thing (at surface level).
What you want is Python.
Everything can be considered harmful if you use it wrong. I've seen tons of senior contractor developers that's been using @AllArgsConstructor (with dozens of properties) just because they can :)
I like the fact that enum types have been added despite the hassle they seem to have created and despite the fact that ADTs solve the problem much better than enums, and now we get ADT-ish types with Amber, soon...
It looks like in your [submission](https://www.reddit.com/r/java/comments/c91ks2/java_lock_lock_in_method_a_and_unlock_in_method_b/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Because enum was there before classes. Why removing a feature from a language? I still use enum in C.. very useful
Type safety basically. You define your type safe range of something.
Correction: TLDR; Java is a complex beast with a lot interdependent pieces, and you can't break any of them.
Yes, I think the OP's characterisation of enums is deficient. It's not simply that there is a set of constants, but those constants have an order. The common solution is using integer constants - see, for example, C# - but if you'd like type safety things become rather more complex. It is possible to create enums using classes - after all, the JVM knows nothing about enums - however, like the upcoming records / data classes this keyword saves an awful lot of typing.
Bureaucracy is that, basically. A complex system with lots of interdependent roles and laws, you can't break any of them, often driving you to dead-ends and Catch 22 situations. This is not something to admire, and Java has taken significant steps since that article was written to modularize itself and decouple certain components from other.
I don't understand why posts like yours are getting downvoted, these are real issues that for some reason just get ignored by some...
&gt;Why bother with functions when it's all just a fancy way to basically do a goto? I get your point, but functions are much more than fancy ways to do goto i.e. there are arguments and a return value, not to mention possibility of recursion.
Science checks out, I'm throwing my MBP in the trash and getting a spatula. Time to flip some bits like a real programmer.
It sort of reminds me of how Scala got really popular for a few years and then Java8 came out and the popularity died. I think you're right, next year we'll all be happy enough with the Java improvements around data classes and other things and Lombok won't be as much desired. Which is the point I like to make. I'm all for making software that will last (be supported/refactored/updated) for decades (at least that's what I get paid for). Adding Lombok adds unnecessary complexity at the cost of saving me a few minutes up front.
Use a `try` with resources: try (CallableStatement stmt = conn.prepareCall("...")) { // ... }
Actually Java had classes way before Enum.
&gt;ADTs solve the problem much better than enums, ADTs solve \_some problems\_ much better than enums.
I've tasted Kotlin (and use it for my hobby projects) and Lombok is the only thing that keeps a Java developer that has used Kotlin sane and happy. Lombok is just an almost necessary workaround while we wait for things like project Amber/Valhalla to deliver more features.
Java didnt invented enum
Someone posted this a few days ago: [Java Futures, Early 2019 Edition - Brian Goetz](https://www.youtube.com/watch?v=BL6ba2dtprw) \-&gt; interesting first part: Brian Goetz talks about compatibility (Code written 20 years ago still works today), and how they carefully have to pick and implement language features (e.g. Generics, Lambdas).
This is what happening to C# these days, it has become a beast with millions of small features rivalling C++.
And something that may fall out of favor and not be as popular in the future. It really reminds me of the AOP/aspectJ movement a few years ago. Yes, it decreases boilerplate and injects common functionality using generated code/bytecode, but at the cost of more complexity and reliance on another tool, and makes debugging source code harder.
These are distributed stuffs that either written in Java or JVM languages : Hadoop, Kafka, Hazelcast, Apache Storm, Camel, Elastic search and its ecosystem like kibana, zookeeper, cassandra, Netflix cloud infrastructure, Amazon Dynamodb.
This is just so you understand why we close connection and not actual advise to do so: No you don't have to ... with regards to jdbc resources you're doing that for two reasons ... a) a typical db will keep the connection alive for a certain amount of time and if you're application keeps opening connections well you're going to run out .. or someone else is going to start having issues. b) You're using up resources on your side which need to be dealt with until the next GC runs. Now, let's say you're using an embedded database. You can set the database to auto-close connections (so that you don't run out of connections) immediately. You'll still be using up a bunch of open resources on the java side until garbage collector cleans them. All that said, ALWAYS close your resources, no matter what. a) It's clean code, b) it's enforces writing good code, and c) there is no reason NOT to in fact you have to go out of your way not to. As u/notfancy shows it's easy to wrap auto-closables in a try block.
Pornhub.com is monolithic application that serve millions of people worldwide fapping every second, and it's written in php. Monolithic doesn't means bad, it's all depends on the need of your requirements. Don't get fooled by buzzword.
All of which is implementable using goto. It's just going to take a lot of manual house keeping.
My advice would be for you to learn a web framework like Spring or Play and try to make a small simple project using it. Just something to give you a goal so that you can stick to it and why not, it would be an item in your portofolio. Also, I understand the frustration, there's so many details and the more you learn it feels like the more questions show up. To avoid quitting, try to focus on the task at hand. Always think about what needs to be done to advance in your current state. Sometimes a big detour might be unavoidable but most times you can find a quick solution. You don't need to understand the quick solution immediately, accept that it works and wait until you know more to question it.
This is the Java subreddit. OP is quite clearly and specifically talking about enums in Java, that is java.lang.Enum.
There are a few benefits to `enums` that you get for free. E.g. "sealed-ness", generated methods and being able to use it in switch. Actually I find `enums` one of the best features in Java.
It looks like in your [submission](https://www.reddit.com/r/java/comments/c92uws/500_000_bug_bounty_campaign_prize_pool/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; The same can be implemented using static on class and invoking it's variables No. It's only poorly emulates enum, without safety and convenience (especially when int used)
Will do!! Thank you !
I usually want immutable objects for data classes, which means I want getters but no setters, plus a constructor so I can contruct with a single expression instead of a series of statements assigning to fields. Fields wouldn't allow me to construct with a single expression nor protect against whoever I hand the data to mutating my objects, requiring defensive copies etc.
Questions that evoke some sort of discussion (opinion) are okay-ish to me personally. Plain programming questions (like "how do I use variables in Java?") are better off at SO or /r/learnjava
The entire Hadoop stack.
fine, but if you have both getters and setters, then why bother? C# and others handle this more gracefully with far less verbosity. I don't see why Java can't follow suit.
The community should make a separate subreddit specifically for programming questions, that way they can be properly managed, seen, and answered without getting lost in other non-related posts
I agree with you. I think discussions are a decent enough fit for the subreddit, especially because it doesn‚Äôt have too many posts.
/r/learnjava and /r/javahelp already exist :\^)
Learn by doing. Nothing teaches you more than a simple side projects. Start siple and gradually go deeper. Always pick what you intent to learn from your side project. Examples: - Textual hangman game: You will learn how to put together an executable application as well as basic java constructs - Calculator: possibly with GUI. An application with more advanced flow of controll. - Todo List: possibly as a REST service. You will learn basics of HTTP, pick a framework. I woud suggest Spring as it is quite dominant and easy to use. You could also implement it to save todos into a database. There is a lot to learn, so do not get discouraged. Visit stackoverflow early and often. You will need to grasp a lot of tools. Such as: Git: (Github, gitlab, etc) just use it. You will need it. IDE: your best friend. Main ones are Intellij IDEA (there is paid and free version), Eclipse(free) Build tools: Gradle or Maven. Pick one. In time you will learn both. Static analysis: SonarQube, SpotBugs, Checkstyle and others. Take this one slow. They will help you but you first need to know what you are doing CI/CD: Travis, Circleci, jenkins... take a look after you get through static analysis. Those were just tools. Take your time. Look into them one by one. For the programming itself. That is a rabbit hole of its own. Once you are familiar with the basics take a look at following: SOLID: This acronim stands fro five basic principles of object oriented programming. Learn them, follow them. Your code will improve greatly. There are other principles you will envounter (grasp, dry, kiss, cqrs, ...) Object oriented design patterns: when you follow SOLID principles, patterns will start to emerge throughout your codebase. These patterns have names. Do not force them into your code just because you think they will fit. Refactoring: A catalogue of actions to improve structure of your code without changing its behavior Test Driven Design: In short it is a technique that helps you design your programs by writing tests first. Do read books. Every topic mebtioned above has at leas one book explaining it in great detail: - Clean Code/Coder by uncle Bob: Start with these - Refactoring by M.Fowler - Design patterns by gang of four - TDD by Example by Kent Beck
Not true. De-structuring and pattern matching are also coming to Java and that style of programming is fantastic. It's the only thing I really miss from Scala.
Such questions should be asked in /r/javahelp.
Oh nice
The rule was and still is there, and is still enforced. It just takes mods a while to get around to it (*see below), but I notice that such posts are most often removed within a day. &gt; Have the mods become more inactive? Or is there not enough capacity? The only mod I know &amp; see active around here is /u/desrtfx. Of all the others I haven't noticed _anything_ at all for **years** (sorry mod team, but it's the (horrible, pun intended) truth).
The rule is still there and I am trying to enforce it whenever I can. As it stands I seem to be the only active moderator and my time is rather limited as I have a 10+ hours/day quite demanding job. On the other hand, the community quite often directly jumps on programming help questions and starts to help the OP instead of rigorously pointing them to the appropriate subreddits. By the time I could chime in, there is an active discussion going and quite often, some valuable content already there. At this stage, it feels plain wrong to remove the post and send OP over to the appropriate subreddits. We hardly get any reports - another problem from the community side. Reports are what triggers us moderators since we can't keep monitoring the subreddit 24/7 and check every single post. Behind the scenes we get a lot of flak from posters who clearly violate the rules (lately especially the "NO JVM languages" one) who insist that their (Kotlin, Scala, etc.) library is suitable for here once we remove the post and point out the relevant rules. I have, some time ago, also updated the sidebar for both, old and new reddit views so there shouldn't be *any excuses* to violate the rules and yet it happens more frequently than ever. I have to **ask the community** to use the proper means: + *don't help programming/learning questions* - point to the appropriate subreddits - /r/javahelp and /r/learnjava respectively + *report* such posts + downvote off-topic/rule violating posts Mainly, the community needs to help keeping the subreddit clean.
What is the policy for certification / salary questions?
Too complicated them, i would go with javalin, less configuration bullcrap, specially if you have been quitting this in the past, try to go sime
Take applications for new mods?
**Sidebar**: + **NO learning Java related questions** **Removed** Generally, if you already state "This annoying question must have been asked a hundred times" you shouldn't post it but use the **search** function of reddit to find similar posts.
**Sidebar** + **NO programming help** **Removed**
I kind of hate the no questions rule for that reason. I think "no homework/simple questions" with both being defined would be a better rule imo. &amp;#x200B; General questions can produce some crazy discussion.
I disliked this article. I could see what the author was getting at, but it felt click-baity. That being said, it's worth a read through. &amp;#x200B; I think if it had been called "Annotation processing doesn't come for free" then I might have liked it more. In a language like kotlin or scala, using data classes is a perfectly idiomatic way to operate. The issue with Lombok is not the notion of a data class, but that it's something bolted on to an existing language.
Problem is that I'm far from the head mod and thus I don't have the main say in taking in new mods, or in even recommending applications. Also, the problem will remain the same unless the community changes their approach to such posts. In another subreddit I moderate with over a million subscribers we are exactly two active mods, but there *reporting* and *downvoting* works as opposed to here. It all depends on the community.
I disliked this article. I could see what the author was getting at, but it felt click-baity. That being said, it's worth a read through. I think if it had been called "Annotation processing doesn't come for free" then I might have liked it more. In a language like kotlin or scala, using data classes is a perfectly idiomatic way to operate. The issue with Lombok is not the notion of a data class, but that it's something bolted on to an existing language.
[removed]
We don't have an actual policy on them, but in my personal opinion, such posts should be directed to the appropriate /r/cscareerquestions subreddit.
Already discussed \[here\]([https://www.reddit.com/r/java/comments/c8oqkq/why\_we\_removed\_lombok\_in\_one\_of\_our\_projects/](https://www.reddit.com/r/java/comments/c8oqkq/why_we_removed_lombok_in_one_of_our_projects/)).
Twitter has been using Graal in production for a couple of years. Chris Thalinger speaks regularly at various conferences about their experience. Here's a fairly recent version of one of his [Graal talk](https://www.youtube.com/watch?v=jsw2aNUspgI)s
Also /r/CSCareerQuestionsEu
I don't think they use native images for production loads though.
Correct me if I'm wrong but it seems [Spring doesn't really support native image yet](https://github.com/spring-projects/spring-framework/issues/22968). There are microservices frameworks that are probably more suitable. Oracle itself does some experimenting and benchmarking with their own [Helidon](https://helidon.io) framework. Things like Vert.x or Javalin also spring to mind.
There is no rule against discussion questions.
I always thought there needs to be some overlap what constitutes a "technical discussion" based on a programming example and discussions on language features, new or existing. &amp;#x200B; I have had my questions blocked too many times just because they referenced a code sample, even when I was clearly not seeking help. That was frustrating. The mods should show some wisdom when it comes to categorizing a post.
Agreed. I've posted once or twice about a new language feature and including even a bit of code seemed to trigger an autobot to remove it.
Please, ask such questions in the *appropriate subreddit* as is *clearly stated* in the *sidebar*. /r/javahelp or /r/techsupport are appropriate where I'd tend to the latter. **Removed**
Please, ask such questions in the *appropriate subreddit* as is *clearly stated* in the *sidebar*. /r/javahelp is the appropriate subreddit. **Removed**
Switching frameworks only for this is probably out of the question for OP, but just for completeness, [Micronaut](https://micronaut.io/) and [Quarkus](https://quarkus.io/) explicitly mention support for AOT. Looking at the contribution graph and developers involved, I'd probably go with Quarkus, but that's a matter of taste.
I tried using Payara. But they used these weird shaded and patched versions of libs so that debugging their code was basically impossible and the sources extremely hard to find. I don't remember exactly what I was doing, but I wanted to know if something was possible that wasn't covered in the documentation so I tried looking at source. Impossible.
Assignment expressions
&gt; We're not dealing with high traffic so the JIT functionality of the JVM likely isn't that significant in our systems which makes AOT compilation with Graal pretty appealing. why is that? since you'e not dealing with high traffic, the overhead of JIT are minor to you. AOT wouldn't help you much if at all. Your energy and time would be better spend in other places.
Try them both; see which you prefer. If you've only just started learning Java don't pay for IntelliJ Ultimate.
Having experience in both is useful because companies tend to use one or the other. But if its your own project? Use whichever one works best for you. Every time someone posts this shit, it turns into a pissing match.
I don‚Äôt really understand why anyone would use lombok when you could instead use immutables, which achieves pretty much all the same goals but gives you nice, clear, readable generated code instead of bytecode-fiddling.
Intersection types. Fugly, but nice when you need them.
I only use @Builder on constructors. It cuts out a lot of that headache. Also I make judicious use of @Singular and @Builder.Default. I find that helps me think more about what valid states my classes can have vs how to instantiate and instance of my class.
You can just replace all of your lombok classes with data classes. It's like a gateway drug.
All of what you said makes sense, but lombok is a horrible solution. Use immutables, then you can trivially review the generated code without having to worry about bytecode manipulation through undocumented APIs that might break with the next compiler release.
Boolean foo = true; if(foo == true) return false; else return true;
 &gt;After reading the article I still can't get why would one remove Lombok from their projects. Why? In my case, it was to use something better, like immutables.
Which problems are solved better by enums?
in my experience Intellij has always been much more polished, stable, etc.
Twitter is
I don't like Lombok. I never use it. I once tried to run a lombok project from github in IntelliJ, i lost 2 hours trying to make the plugin work. Its the IDE job to generate boilter plate code. Anything I don't see.. I don't like.
both have strong points. i am using both depending on the job. If you can find some plug ins, Eclipse has similar comfort with postfix completion, auto complete etc. Autocompletoin is better as in more relevant in IntelliJ. Refactoring suggestions are also nice touch in IntellIJ. for android. use Android Studio for framework development i can't imagine working without Eclipse. Specifically for these reasons -the workspace setup with split second incremental compilation and problems views with perspectives over a multi screen workstation. For teaching noobs on simple projects, IntelliJ is better and smoother.
Anonymous arrays: doSomething(new int[]{1, 2, 3, 4});
As long as it can be desugared to Java code it's not so bad. In this sense what Spring and Hibernate does is way more magical. Even the very idea of a compiler is pretty magical to many programmers.
Full ACK. At least most of the stuff Lombok generates can be desugared to plain Java code.
Where you need static values like InvoiceStatus, DayOfWeek, etc with limited options and can have associations and work in switch statements.
In Eclipse you can right-click on the method's entry in the "Outline" view. From there, you get the usual context menu.
The only reason I would recommend eclipse over IntelliJ is because eclipse is the basis for IBM rational application developer,aka, RAD. if you end up getting a job working anywhere where they use websphere as the application server, you're going to have to use RAD.
AFAIK, streams and reactive libraries aren't using code generation, but are just (quite complex) libraries.
Sneaky throwing exceptions. It's a hack, ugly, shouldn't be used, but it can be useful when using lambdas. (E.g. `Map.computeIfAbsent` and others) Delaying instantiation of a static object until it is actually accessed: void userOfObject() { //the referenced object is only instantiated when the Holder class is actually loaded //it is loaded only if a piece of code references it, like the next line: Holder.MY_OBJECT.doSomething(); } //inner class holding the object private static class Holder { static final MyType MY_OBJECT = new MyType(); } See: The `java.util.UUID` class and the `Holder` inner class in it. /* * The random number generator used by this class to create random * based UUIDs. In a holder class to defer initialization until needed. */ private static class Holder { static final SecureRandom numberGenerator = new SecureRandom(); } The others aren't really tricks, but I really like them nonetheless: Byte code generation. Runtime code generation can be awesome when used correctly. (ObjectWeb ASM is cool) Also, interface proxies. [Java instrumentation.](https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html) Annotation processing. I love generating code at compile time. It's just always in the back of my mind that a generated code is faster than hacking around with reflection. Also provides compile-time validation. JNI. As a fan of native stuff, I cannot not like it.
If you're a student, go for IntelliJ. Why? You might get it for free for as long as you're enrolled. After you're done, think again carefully which one you prefer. It might not be IntelliJ. It seems you didn't get much out of it for that price.
The benefit is that the value space is *closed*. That means whatever you do\*, there will only ever be those instances of that class. You have no chance of ensuring that using static variables. \*: yes, you might or might not be able to use reflection and code generation tricks to get more, but that's not the point here.
Aren't those awful because GC can't find them? Or am I mixing that up with something else?
Being able to be used in `switch` statements is the real killer feature of Enums. There is no equal to this before Java gets full records and pattern matching facilities.
Indeed, wasn't aware that these are two distinct efforts. Thanks!
The benefit is that the value space is *closed*. That means whatever you do, there will only ever be those instances of that class. And you get it with a lot less boilerplate than manually making a private constructor and initializing the static variables by hand. Also, such a hand-written implementation would not be eligible for being used in `switch` statements, which is the real killer feature for Enums.
Repost from 1 week ago.
No, possibly you're thinking of something like: `new ArrayList&lt;String&gt;(){{add("a");add("b");}}` it's not so much the GC, it's more just.. awful in general.
Those aren't called 'anonymous arrays'. Just array initializers.
Yep, and they're complementary too. You can have a record value type.
Syntax nobody knows about, maybe? // this is so exotic, javac's parser tree can't even track properly you've done this post-declaration array bracket thing. public int iReturnAnIntArrayReallyIDo() [] { return new int[0];} or: public class Foo { // exercise for the reader: Try to think of WHY this really is legal: public void iTakeNoArgumentsReallyIDont(Foo this) {} } or perhaps: public void foo() { System.out.println("Hello"); hmm: { System.out.println("Goodbye"); if (Boolean.TRUE) break hmm; System.out.println("What is going on?"); } System.out.println("huh?");
AOT certainly has its place, but the stock JDK can go a long way, so make sure you actually need AOT. If you care about image size, use jlink (e.g. [1](https://medium.com/azulsystems/using-jlink-to-build-java-runtimes-for-non-modular-applications-9568c5e70ef4), [2](https://blog.gilliard.lol/2018/05/26/Multi-Stage-Docker-Build-with-jlink.html), [3](https://www.baeldung.com/jlink), [4](https://qiita.com/h-r-k-matsumoto/items/1725fc587ce127671560)) If you care about startup time, use [Application Class Data Sharing (AppCDS)](https://blog.codefx.org/java/application-class-data-sharing/); it's been getting a lot of attention lately, in JDK [12](https://openjdk.java.net/jeps/341), and [13](https://openjdk.java.net/jeps/350).
Better look for or implement an equivalent of `StringBuilder`. If you concatenate arrays a lot, it can get expensive.
Thank you for pointing out. I will definitely check it out.
i don't understand the hate against Eclipse. It's fast, stable and is an industry standard. Oh, and it's free, including for JavaEE
Using `enum` to implement the strategy pattern. Especially for fallback strategies as the definition order sets the order in `values()`.
 try { return true; } finally { return false; }
int[] a = {1,2,3,4}; // this is an array initializer Not the same thing.
Eclipse performance on Mac and Linux is not good, so IDEA is much better but for Windows ... meh I would stay with Eclipse
InteliJ is thousands times more stable, have many productivity improvements
And RTC, if you happen to work for/with a company that employs it for change mgmt.
As someone who browses the subreddit by new and reports everything in violation of the rules, this attitude is very frustrating, especially considering you say you‚Äôre the only active mod. Fire the ones who aren‚Äôt doing their job, and hire ones who are willing to help. There‚Äôs no point in me putting in effort to flag content that doesn‚Äôt match the goals of the community if nothing will be done.
And much easier to use when using `var`.
If we're doing valid syntax then: var $var = var;
Gemini is a framework I'm developing to generate REST APIs given a model.The goal is to allow developers to quickly setup a Backend with zero or little code. With Gemini you can: ‚úì Autogenerate REST Entities by using a very simple and clean DSL (that handle relations between them) ‚úì Autogenerate REST routes handling persistence out of the box with no code (postgresql supported) ‚úì Autogenerate the Swagger OpenAPI documentation to consume and test generated APIs &amp;#x200B; The framework is in early stage development, you can find it on [github](https://github.com/h4t0n/gemini), put a star if you find it interesting. &amp;#x200B; What do you think about? Any suggestion? Please send me your opinion.
If you're trying to assign something to an intersection type, ```var``` is the only way, literally. ```List&lt;SomeDTO &amp; Closable&gt; myList = ....``` is a nope for the compiler.
I use the Holder for enum lookups all the time. Sooper useful.
Yeah I only intend to use the community edition. That's what I've been using as of right now, but I've also been using Eclipse side-by-side to see which one I prefer
I'm actually using either Eclipse or IntelliJ for learning for the AP Computer Science exam (I am a rising sophomore, and have experience with other programming languages, and I really don't want to take the course cuz I am really good at programming in general) I do plan to use it in the future tho, thanks for the response!
I've never mentioned Scala nor article did. I was just referring to points made in post which were based on wrong premise in my opinion. If you use something wrong, then it will look like anti-pattern. That's all.
I am currently a student at a high school (a rising sophomore) so does IntelliJ give licenses to highschoolers like me?
I use NetBeans, it has smarter auto complete than both.
There is a free Community Edition of intellij for you to use, but you could try getting an education license if your school has E-mail addresses for it's schoolers
Using `if(true) return;` to temporarily shut the compiler up about unreachable code public static void main(String[] args0) { for (int i = 0; i &lt; 32; i++) { System.out.println(1 &lt;&lt; i); } if(true)return; for (int j = 0; j &lt; 300; j++) { for (int i = 0; i &lt; j; i++) { System.out.print('*'); } System.out.println(); } }
I don't disagree, Java has room for improvement in this area for sure.
Functional interfaces are so much fun in Java. The code sample is a bit questionable, but Functional Interfaces with Exceptions can do a great deal to clean up your exception handling. It could be abused a hell lot too, but what can't? ``` public interface FunctionEx&lt;T, R, X extends Exception&gt; { R apply(T input) throws X; default R tryApply(T input) { try { return apply(input); } catch (Exception x) { throw new RuntimeException(x); } } static &lt;T, R, X extends RuntimeException &gt; FunctionEx&lt;T, R, X&gt; noException(Function&lt;T, R&gt; function) { return function::apply; } } ``` Java is the only language that turned lambdas into an object oriented concept. I don't get it why no other language has adopted this concept. It might not have the "pureness" of function types, but I take pragmatism over that.
What, in your definition, are immutables? Because unless you‚Äôre talking about some library called ‚Äúimmutables‚Äù, the concept of immutability does nothing to reduce boiler-plate code. Some of us deal in Hibernate/JPA POJOs which Lombok handles quite nicely. In any case, as I said, don‚Äôt like Lombok...don‚Äôt use it.
https://immutables.github.io
but why
&gt; is an industry standard [citation needed] See Item 5: https://www.baeldung.com/java-in-2018
On top of this all, we should be aware that dependencies may have security vulnerabilities. Not updating because it just works may be tricky. Ask the equifax people for instance. Staying on top of your dependencies might be a solution but better is to actively test / scan and update when needed.
Using package private (default) methods for stuff, that i want to write UnitTest about, but also would like to keep it private. As Test Package is the same, alltough different folder, tests have access to the method, that elsewhere is not accessable.
Intellij is the best one, go for eclipse if you're just learning to code.
He is not the top mod. He can't just replace all the mods.
The attitude I was referring to was the acceptance of posts that are off topic for the subreddit but have good discussion within. If they‚Äôre going to let it slide, just change the rules and the theme of the subreddit.
I personally prefer IntelliJ, but there is nothing you can do with one that can't be done with the other. Intellij feels more modern-ish but you have to pay for full features and support (unless you have a student email account). In the other hand eclipse is fully free, so in the overall it's a tie and depends on personal preference.
it depends &amp;#x200B; or.. you could search the other billion of reddit posts regarding that question.
I hope you are not paid to write this kind of code in production :P
Are you saying Lombok has security problems? Which ones?
This is correct. &gt; An array initializer may be specified in a field declaration or local variable declaration, or as part of an array creation expression, to create an array and provide some initial values. # &gt; An array initializer is written as a comma-separated list of expressions, enclosed by braces { and }. https://docs.oracle.com/javase/specs/jls/se11/html/jls-10.html#jls-10.6
Ok this is epic
NetBeans and Eclipse do have built-in project templates, while IntelliJ IDEA (Community Edition) doesn't. So I'd suggest you to give the former ones a try.
When I‚Äôm back in the office I‚Äôll grab the office Coverity scan and post the results. Remind yourself Monday.
That's a lazy-mans enum tho. It should be a class with a private constructor and several static public value like instances of itself. Ints are just very convenient historically (being the machine word and all).
I have noticed that ALL my young associates use IntelliJ and ALL the old associates (like me) use eclipse. Could be that it is just the company that i currently work for, but i company-jump fairly frequently and have found this to be true at both startups and large companies that i have been employed at.
How is the third var not a reserved word?
Please explain`iGotNoArgumentsReallyIDont`
Interesting .. i use eclipse on Mac and Linux .. i had never considered performance as factor, only features .. what kind of performance are you referencing? You mean stuff like startup/shutdown times? Finding all code that calls your method?
Thank you for doing this, I really appreciate your work. I try to keep this things in mind for the future.
Interesting, first I've heard of it. Will definitely take a look, thank you.
TL;DR: You can use lambdas instead of the trivial usage of the Strategy pattern. Who would have guessed? It's like a "Hello World" example for lambdas, but doesn't grasp the whole field of application for the Strategy pattern. On the one side, you probably shouldn't name your Strategy _...strategy_ and instead use more descriptive names like Comparator (which, in essence, is really just a strategy pattern). On the other side, a more valid and visible use of the strategy pattern is when you have more than just one methods. I once made this for a private/hobby small-scale graph library: public interface GraphSearchStrategy&lt;T&gt; { /** * Enqueues the aggregate node into the given collection. * @param nodeCollection The collection of nodes * @param node that is to be added to the LinkedList. */ void enqueue(Deque&lt;T&gt; nodeCollection, T node); /** * Dequeues the aggregate node of the given list * @param nodeCollection The list that serves as the provider for the aggregate node * @return Next node of the list */ T dequeue(Deque&lt;T&gt; nodeCollection); }
Kotlin! In Kotlin, lambda syntax is super clean, and instead of using weird Function&lt;in A, in B, out R&gt; notation, it's just `(A,B)-&gt;Unit`. Works with functional interfaces as well.
When compiled, all methods have a `this` argument of the parent type. That method can implicitly access members of `this`
those names DAO and DTO seem really similar...
Enums are mostly syntactic sugar. So you can add parameters to the constructors and make them self-documenting with additional properties accessible with getters at runtime: enum HHOA { String verse; HHOA(String verse) { this.verse = verse; } String getVerse() { return verse; } CORRECT("Three shall be the number thou shall count"), TOO_LONG("Four shall thou not count"), TOO_SHORT("Neither count thou two, excepting that Thou then proceed to three"); }
`var` is a reserved type name in Java. If it were a reserved word, existing code would break.
If you're curious, The Java Language Specification talks about receiver parameters (which is what the feature is called) [here](https://docs.oracle.com/javase/specs/jls/se12/html/jls-8.html#jls-8.4). As stated, one use is to allow the type to be annotated.
The constants need to be declared above the members, otherwise the code will not compile.
[removed]
Each have their own quirks. I've found over the last 12 years that once the project starts getting larger and more complicated that Eclipse starts to fall down where Intellij handles things fine. I miss certain validations and the more real-time problem updating in Eclipse when refactoring, but I don't miss the intermittent unresponsiveness of Eclipse.
[removed]
[removed]
It's probably also worth looking at switching to IBM's OpenJ9 JVM as it's optimized more around startup time and low memory footprint.
That's true if you're building a CRUD web application where you taking client input, applying business logic, and putting it in a persistence layer. And vice versa, of course, where you take stuff from your persistence layer, transform it, and spit it out to the client. Basic stuff like does not require containers at all. But that no longer works if your project starts to depend on external dependencies. Take the simple case of working with JNI. Managing these dependencies manually is tedious without a solution like container. Of course, there are other alternatives. You could use Chef, Puppet, Ansible, etc to provision all of your servers (including local dev env). Which is better is up for debate, but to claim that Java itself is all that's necessary for isolation is incorrect.
See https://old.reddit.com/r/java/comments/bkjnoi/docker_and_spring_boot_done_properly/esvpfo8/
Yep, introducing `var` still had the potential to break code, but only if you created a class/interface/enum/etc called `var`, but you'd have to ignore the Java style guide to do that and most people manage to follow the "CamelCase for types/camelCase for variables" rule. It was a fairly clever way to introduce the feature without breaking too many code bases.
Of those two I prefer intellij and use it at work. However, at home I prefer NetBeans
Yep!
The issue is that this creates an anonymous inner class that inherits from `ArrayList`. The more you use it the more classes you create and the harder the class loader has to work. It causes GC issues because it's not a static inner class and therefore contains a reference to the outer class for as long as the inner class exists. That is, if the collection is returned from any method, the lifetime of the outer class depends on the collection, resulting in a possible hidden memory leak. Remember to create your inner classes as static where possible.
While ```var``` would certainly be more concise, it seems like you can also put that line in a method which is itself parameterized with the combination type: public &lt;T extends DTO &amp; Closeable&gt; void example() { List&lt;T&gt; list = getList(); } public abstract &lt;E&gt; List&lt;E&gt; getList(); public interface DTO { }
"if (true) return;" still gives me an IDE warning for subsequent unused code, but "if (1&gt;0) return;" does not.
One problem (to which you might be alluding) of that last example is that it creates an otherwise-unnecessary anonymous inner class. Given the "noclassgc" execution option, sometimes class objects are retained for a long time or forever. That would evade the GC. Just trying to connect potential dots between what the two of you were saying.
Do you throw a @VisibleForTesting annotation onto those? (or equivalent)
Except for the "adding loads of function to enums", I try to stay away from too many tricks. It makes the code hard to maintain for anyone but the most die-hard Java programmer.
But have a well known meaning.
Bear in mind that I haven't used Eclipse in 10 years due to switching to IntelliJ Ultimate and never looking back, but back in those days, the biggest issue was trying to get several plugins working together. The standard distribution would not include either git nor maven support, so the first thing you'd have to do was install those. And you had to hope that the plugins didn't conflict. The more plugins you had to use the more chance that they'd conflict.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
yes, ussualy explizit /** ** Package open for tests /* So that nobody makes it private and then it does not compile :)
i have, but mainly because I use scala and the graalvm JITC is better suited to optimizing it
yes and 10 years ago IntelliJ had issues with Maven as well. Things have changed Eclipse is stable and faster than IntelliJ.
Take the @Deprecated annotation. How would you express something like @Retention(RetentionPolicy.***RUNTIME***) @Target(value={***CONSTRUCTOR***, ***FIELD***, ***LOCAL\_VARIABLE***, ***METHOD***, ***PACKAGE***, ***MODULE***, ***PARAMETER***, ***TYPE***}) any better?
This should all be possible in a much more general way using sealed data classes, in the future: [https://cr.openjdk.java.net/\~briangoetz/amber/datum.html](https://cr.openjdk.java.net/~briangoetz/amber/datum.html)
yeah i noticed this too. what i can say is, many organizations have you forced on using Eclipse, i have never had a customer who said you have to use intellij, most of the time intellij is allowed and that's what most of the programmers use, but again, in some industries eclipse is enforced, not intellij.
I haven't done the exercise, but it could be possible with sealed data classes, no? Of course, a specialised solution like enums can lead to optimised usages such as in annotations, but there's a high price to pay for every specialised solution.
IntelliJ came with support for Git and Maven built in. I didn't have to waste half a day every time the was a new Eclipse version. I don't regret switching.
Why wouldnt you have a class utilizing both those for the type parameter?
Ternary chaining works in most C-based languages except for PHP. var result = cond1? val1: cond2? val2: cond3? val3: valDefault;
They don't.
You can even introduce more symmetry by making the constructor private and introducing a static named constructor. However, architecturally, I think a DAO implementation should return domain objects (or even DTOs) from its data access methods. So I am not sure why you want to convert an infrastructural service object to an object merely containing data for crossing boundaries.
So you want to exchange `enum DayOfWeek {MON, TUE, WED, THU, FRI, SAT, SUN}` with some like this `sealed interface DayOfWeek {}` `record MON() implements DayOfWeek,` `record TUE() implements DayOfWeek,` `record WED() implements DayOfWeek,` .... You now have 8 classes instead of 1 and a lot more boilerplate code. &amp;#x200B; Maybe I'm misunderstanding something?
My favorite "trick" is actually proper OOP, especially separating abstraction from implementation using interfaces. This allows for constrained, yet flexible ways of evolving architecture.
Does giving everyone who reads your code eye cancer count as a trick?
Enums are really good when you do not have associated values. If you have associated values algabraric data types are a better choice. In my opinion they are two completely different tools. &amp;#x200B; And I don't understand the point about the high price? Even the article you linked in another comment ([https://cr.openjdk.java.net/\~briangoetz/amber/datum.html](https://cr.openjdk.java.net/~briangoetz/amber/datum.html)) mention enums as a success.
&gt; static named constructor I believe the correct term for that is a "factory method". Not to be confused with a factory class
Thanks. I am familiar with design pattern lingo, but I wanted to prevent that exact confusion by using a more specific name. It is not that uncommon.
Double brace initialization is a cool trick. &amp;#x200B; You can create an array with elements in shorthand. &amp;#x200B; new ArrayList&lt;whateve&gt;() {{ add("bacon"); add("chicken"); add("tofu"); }} &amp;#x200B; But before you get excited and use it in prod code it has downsides. Like competitor issues and memory leaks. Still kinda neat though
Returning subtypes in overridden methods: interface A { Object get(); } interface B extends A { @Override String get(); }
I approve. safety first
Not running in production, but have some input regardless. Spring is getting some support for native images from 2.2.0, and I know Pivotal is working on this, however it will depend a lot on how you are building, and what you are including in your apps. "Core" Spring Boot with WebFlux and DSL based configuration will probably work with some fiddling, are you using JPA/Hibernate/Spring Cloud you will probably never succeed. My impression from doing a bit of research in this area, is that support is getting better, but it is not quite ready for production, unless you have developers who like the challenge of tracking down compiler errors.
That's the same as every other functional language. (Same as anonymous lambdas in Java). `Function&lt;X,Y,...&gt;` is great because its an object. Even if it looks unwieldy, it is rather powerful. Well I think Scala and C# can do it similarly.
Well, they already knew it works. Lombok does it the same way, been doing it for years..
`Arrays.asList(..)` from JDK and since Java 9 you have collection factory methods such as `List.of(..)`
Adding Lombok is optional and on a per-project choice. Adding it to the language affects everyone.
I think /u/Mee42_1 was talking about the risk of making a simple typo there and they get mixed up and that may result in a bug that is not as clear as if you used less similar names and make a little typo.
Oh God please no
still prefer ```ImmutableList```!
I think IDE warning is a good thing, this way you won't forget to remove this code before committing.
You might want to look at the ByteBuffer class for your use case.
I was just saying that var allows for a bunch of cool inference tricks that you normally can't do
Ah fair. I didn't even know you could to that tbh. I'd look at that line of code funny af if I saw it.
Varargs + Enum To make attribute pattern
I wouldn't mind the \`enum\` syntax sugar if the backing implementation is more generally useful instead of this supremely specialised quirk. &amp;#x200B; You can have 8 enum classes as well, if you override any methods, which make enums even more quirky. E.g. think about what you get when you call \`DayOfWeek.MON.getClass().isEnum()\`. This isn't necessarily true, depending on how the enum constant is defined.
&gt; Enums are really good when you do not have associated values. If you have associated values records will be a better choice. By that logic, the "associated value" of an enum constant is `null` or `void` or `nothing`, or whatever you want to call it. &gt; And I don't understand the point about the high price? I meant the additional complexity this feature imposes on language maintenance. Every feature has this cost, and in the presence of more general solutions, the specialised ones could be removed, in principle. &gt; mention enums as a success Might be because the original authors are still team members. :) They were a success considering the *relatively* low effort of adding *relatively* much value. My point is that records and sealed classes will add *much* more value with *much* more effort, but they could (probably) implement 80% of what enums are offering, which increases the price of supporting enums.
Damn, I thought it is basic knowledge of enums. Other enum tricks: * Enums can implement interfaces. This way, you can either implement it for whole enum class, or make every type implement it itself. * Similarly, you can declare abstract method in enum and every type can implement it.
Your point? I'm just saying they had a working solution, a POC done as a part of Lombok, the 'brilliant idea' of implementing it came from there. Adding to language is a welcome move.
Gosh, we need to upgrade our JDK level (still sticking to 8). Can a primitive type be part of an intersection?
For enum lookups? Not following, can you elaborate? Thank you :)
My point is that implementing `var` in Lombok is nothing like implying it in the language because the language has to not break anyone's code. Lombok can do what ever it likes.
Using reflection to do all kinds of neat stuff! As an example you can create a dynamic user interface for interacting with a settings type class that follows predefined set of rules. Boolean members get a checkbox, List members get a selection box, etc... and you can use method naming rules or inner classes for automatic layout stuff, etc...
 enum MyEnum { VALUE1("something1"), VALUE2("something2"), VALUE3("something3"), VALUE4("something4"); private final String someString; MyEnum(String someString) { this.someString = someString; Holder.NAME_LOOKUP.put(this.someString.toLowerCase(), this); } private static class Holder { private static Map&lt;String, MyEnum&gt; NAME_LOOKUP = new HashMap&lt;&gt;(); } public static MyEnum from(String s) { return Holder.NAME_LOOKUP.get(s.toLowerCase()); } }
using varargs * public int sumNumber(int ... args){ * System.out.println("argument length: " + args.length); * int sum = 0; * for(int x: args){ * sum += x; * } * return sum; * }
So you just downvote what you don't agree with, even if it's relevant? Lombok did what it liked, did it well. Java liked it too and standardized it by importing into language. That "fairly clever way" you talk about was Lombok's idea, is all I'm saying.
Lombok lets you create a copy of the builder as well: @Builder(toBuilder=true) Then the `toBuilder` method will be available that creates a new builder with all current values set. This lets you create copies.
Sorry for replying to a month old comment but I'm curious about what you (sort of) like in groovy but not kotlin
[removed]
Yeah we used that for a while, it did get abused slightly by some I.e account = account.toBuilder().name("Barry").build(); Immutables also allows us to do things like ImmutableDog dog= ImmutableDog.fromInstance(animal).bark("yappyyapyap").build() This has saved us repeating lines of code for each subclass.
One reason is this: You can interface A and B. Class Foo implements A and B. Interface C extends A and B. In this case, class Foo is not an instance of interface C, meaning you can't treat class Foo like C.
You don‚Äôt need setters for every field. Generally you want to try to avoid setters.
I guess, but I'd sure hate the dev that didn't have Foo implement C.
Sometimes that C interface doesn't exist. And sometimes, depending on the context, I'm not about to create an interface with no methods in it just so I can reference an object implementing its super interfaces more easily. I think there are valid times to have that C interface and valid times to not have that C interface at all. That's one of the things I dislike about situations like these, developers have the option of not implementing C, if it exists of course.
I guess I'm a different style engineer because I'll totally create C with no methods. I might need to reference the intersrect in other ways. It's a fair point though I'm a huge stickler about my abstraction models though
I avoid subscription software as much as I can. Sorry this happened to you.
While I believe that IntelliJ is worth every penny, and I was a very happy paying customer, hard economic times have made me look into free alternatives, such as Community Edition, Eclipse, and Visual Studio Code. I never thought I would, but I became a VSCode convert rather quickly. (though I might become a subscriber again when the clouds dissipate)
I always upvote people mentioning Eclipse and other Open source alternatives to IDEA in here. Some people are just blind sheep when they talk about IntelliJ as a superior IDE. IntelliJ IDEA is worth its price in full, but if they do this now next time it will be something even worse. So now I post it here so more people can be informed about it. Thanks
That's easy to say but IntelliJ has become the industry standard for Java development.
Not in my parts, every Java shop I got the standard is free (as in beer) Eclipse. Any place I ever worked that involved subscription software the company paid for it.
I keep on hearing more and more Java devs moving to VSCode. I really need to take the time to check it out.
I have no problems about paying a high price for a good product is worth it, but I only want to buy a product once. Even outside of tech I avoid services when I can, opting for alternatives where I only pay a price once.
Totally with you that employer pays for it, but haven't used Eclipse at a job since like 2014. I have it installed on my personal computer but I barely use it. &amp;#x200B; If I was doing freelance stuff I'd just consider an IntelliJ the cost of doing business. You don't even really need to keep paying the subscription as you can just stay on whatever the latest version was when your subscription expired.
I have yet to be in a Java shop that didn't use Eclipse. I do the same thing you do with Visual Slick Edit. I use the 2011 version I bought.
Is there an equivalent for Map?
&gt; but I only want to buy a product once. You do. You get a perpetual fallback license for the version you were on when you subscribed (including future bugfixes) if you purchase a one year subscription. https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-perpetual-fallback-license-
&gt; I switched to Jetbrains all product pack last year there's the problem
My main complaint with VSCode is debugging is hit and miss. Sometimes it catches the breakpoint, sometimes it doesn't. Really annoying.
I don't see why you would feel entitled to a discount for IDEA just because you have a discount on another subscription. Imagine getting a discount on your phone bill, then wanting to downgrade and asking for the same discount.
IntelliJ products are cheap for professional developers, for me 1 year subscription to all products cost 3 days of work
If my employer wouldn't pay for IDEA, I would probably look for a different employer. The cost for a license is peanuts compared to the productivity gain. Sure there could be compatibility problems with plugins or the like, but if there are you probably have bigger problems. See also [Item #9 on the Joel Test](https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/) &gt; **Top notch development teams don‚Äôt torture their programmers.** &gt; Even minor frustrations caused by using underpowered tools add up, making programmers grumpy and unhappy. And a grumpy programmer is an unproductive programmer. I very much subscribe to that idea.
&gt; blind sheep I used Eclipse for years and it always was a worse and more buggy/clunky development experience than IDEA. For some people it‚Äôs about getting shit done in the most user-friendly and efficient way possible and IDEA is far superior in my experience, so it‚Äôs well worth the price. Also, you can always ‚Äúpay once‚Äù (the annual fee) and get the fallback license permanently - you don‚Äôt have keep paying to use IDEA (albeit without upgrades).
You have the option to ‚Äúpay once‚Äù (the annual fee) and get the fallback license permanently - you don‚Äôt have keep paying to use IDEA (albeit without upgrades).
In my mind jetbrains is priceless. You could not quantity what it's worth. Working with IDEs was a PITH until jetbrains.
That's still a pretty hefty cost imo
It's not entirely about if I can pay it or not. I can, but I was expecting to be given the discount which is advertised on their website. I'm also currently underpaid and working in one of the worst european countries for [developers](https://preview.redd.it/f56fcklgnp731.png?width=1024&amp;auto=webp&amp;s=1d62fdbcc478db992d1ebb0409fb1f1c042abe4a) (Greece)
Same here. Eclipse has been the defacto standard in every company I have worked for in the last 20 years (6 companies.) Only a handful of people paying out of pocket for IDEA.
My former employer had us all switch from Eclipse to IDEA but didn't want to pay for it, so we ended up with 15 pirated versions of the IDE, which made me very uncomfortable (devs pirating dev software is blasphemous) and showed me how cheap a bad employer can be.
You are technically correct. I just don't like it. I bought a license when I was an intern (and making about 400 euro / month) so I can benefit from that discount in the future. I guess it was a mistake to even try their All products pack.
Eclipse is a better IDE anyway...
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You must work for IBM.
I feel sorry for the OP getting shafted with the fat bill. However, I have to chuckle ( not at him ) as intelliJ fans promote it here with a fanboy style that is almost obnoxious. Enjoy the bills fellas!
I hope you know that in the above case, there is no reason to use the Holder class. The Holder class will be loaded exactly when one of your enums is instantiated, that is when your MyEnum class is accessed. That is because you access the Holder.NAME\_LOOKUP map in the constructor of the enum. Another thing to note is that you really should make the NAME\_LOOKUP final. To avoid the above error, I recommend the following instead: private static class Holder { private static final Map&lt;String, MyEnum&gt; NAME_LOOKUP = new HashMap&lt;&gt;(); static { for (MyEnum e : MyEnum.values()){ MyEnum prev = NAME_LOOKUP.put(e.toLowerCase(), e); if(prev != null){ throw new AssertionError("duplicate enum lowercase names for: " + e + " - " + prev); } } } } public static MyEnum from(String s) { return Holder.NAME_LOOKUP.get(s.toLowerCase()); } In this case, your Map is properly lazily instantiated, the first time from(String) is called. Also I recommend the AssertionError to be thrown so you're notified during testing if your enum declarations are accidentally collide.
[Yes](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#of(K,V,K,V)). Map.of()
If he was an IBMer he‚Äôd be advocating Rational Team Concert. üòÇ
Yes. `Map.of`. Since JDK9.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
have you tried contacting them? i bet they give you discount if you ask nice
OK, but this diagram is not showing which year is... BTW I'm from Hungary
How so? The productivity gain is well worth three days of work. And depending on where you are, 3 days might even be a lot for 249‚Ç¨.
You save having to remember to regenerate all this code each time a field is added or removed. You save having to figure out if the code for this particular class does anything different and shouldn't be regenerated.
*cries in still using IBM Notes at work*
That's a problem with your Coverity setup, not with Lombok: &gt; [As of 2018.01 Lombok annotations are supported by using the following options.](https://community.synopsys.com/s/article/Coverity-Support-for-Lombok) &gt; cov-build --enable-java-annotation-framework-support Automatically detects usage of Lombok and passes the --lombok-jar argument to cov-emit-java, to support capture of builds using Lombok.
Yep that was some trivial code off the top of my head done on mobile, and should in no way be used in a production environment.
Most people also dont have to pay for their IDE. And then it becomes more about whats better qol than price
Just to make it clear, the Web site states quite explicitly that a continuity discount is specific to a subscription: https://sales.jetbrains.com/hc/en-gb/articles/206386064-What-is-a-continuity-discount-
The [Spark framework](http://sparkjava.com/) also compiles with native-image. But I haven't been able to get a real project off the ground yet because a bunch of stuff I rely on doesn't work yet. So far Jedis and Gson work. But JOOQ, Undertow, Flyway and the MySQL JDBC driver don't. The Postgresql JDBC driver can function with some work.
What do you do if you care about RAM usage?
Don't want to make a counterpoint, but latest Eclipse version is quite good, and has a bit improved performance. Please ignore this comment and continue use what you comfortable with.
Using the default package private scope so that in my unit tests I can easily call methods without dependency injection.
I really wish people would do the smallest courtesy of reading a community's rules before posting there. It's incredibly rude to just waltz into a community and break their rules. And not knowing the rules is not an excuse when they're right there in the sidebar. That said, I get the feeling most people simply don't care how rude it is.
This shouldn't be the case and it should be respecting your continuity discount. Can you please send me an email (hadi at jetbrains dot com) and we'll get it sorted for you and try and figure out why this has happened. &amp;#x200B; Thanks.
The enormous amount of productivity gains! I would have to look for work elsewhere if they wouldn't pay for a license! It's so absurd. Your productivity is so much related to what you are used to. Muscle memory and keybindings and familiarity with the GUI. I had a co-worker who was a Java development Guru. Just such a genius developing the software that was the backbone of our company's flagship product and he used Netbeans. And and older version at that. I asked him once why he used that IDE instead of Eclipse that all the rest of us used and he said, "it's what I'm used to." His productivity came from his familiarity with his toolset. Not the toolset itself. It's the same thing with Linus and the obscure version of Emacs he uses that he has to maintain himself. Muscle memory.
This is terrible for readability.
Configure the VM for lower RAM usage.
Just to pinpoint where exactly the problem lies: how much smaller does the delay become if you remove "Build" from the "Before launch" settings of the run configuration you're using to start your "hello world"?
Maybe this PR will help you? https://github.com/payara/Payara/pull/3987
I have been using *IntelliJ IDEA Community Edition* for about 3 years for Java and Scala development without any problem. It is free and also open-source and faster than the *Ultimate* one. I hate *Eclipse* but as an alternative, I think *Visual Studio Code* can have a good future.
Sorry, but this is /r/programming and not /r/java material. **Removed**
I understand. Early on in college I saw the advantage of learning fewer tools, but learning them *well*. I used nothing else but EMACS for years until a boss sold me on Visual Slick Edit which I used for eons until I learned Eclipse for the jobs I've had since then. OTOH, muscle memory can be relearned and every decent IDE has custom keybinds for the key strokes you would rather not relearn.
Instead of posting here, reach out to their support team. I was in a similar boat a year ago and they adjusted the price to match the grandfathered renewal rate. I don't use the other products much so it was only worth it at the "3 year" price to me. Win-win for them and me.
The All Products Pack is $249 USD first year price and goes down to $149 USD for the 3rd year onwards. Let's assume you pay full price every year and only work 4 hours a day. That's 12 hours in 3 days. $249 / 12 = $20.75 per hour. That's ridiculously low for a professional developer.
What does ultimate edition have over community edition that's worth 249‚Ç¨?
A counter-point though is that any professional developer should provide their own tools that make them productive. That is part of being a professional.
Just had a quick glance at the [edition comparison table.](https://www.jetbrains.com/idea/features/editions_comparison_matrix.html) What I use off that list is at least support for JavaScript, Databases, **Spring**, Struts, Tomcat, Kubernetes, also Settings Synchronization, Duplicate Detection, the REST Client and the Dependency Structure Matrix.
&gt; tl;dr: should a method include a logical operator in it's name outside Spring Data JPA? No, usually not. A method should do one thing, get the past offers, the present offers, all offers, offers based on some filter criterium, whatever. I've never seen methods with "And" or "Or" in the name in good code (except with expression trees or something, when you're implementing binary operations).
Part of the philosophy is you don't give someone more functionality than they need. You give them exactly what they need, so that unforeseen circumstances don't erupt. you can also create severe performance degradation if someone uses a powerful method in an incorrect way. Long method names can be obtuse and annoying. However the discipline in most agile environments is to provide only what is necessary at that time. In my experience, "we might need this later" sometimes turns into a time suck.
If it makes it more explicit, I have no problem with 'and' or 'or' in method names. In your example, getPromos would definitely be preferable
Not unless you're a freelancer. What you suggest is like working at Starbucks and being required to bring your own coffee machine into work.
Thanks hadi, I will send you an email in case you want to check the issue but I now feel bad that my title is misleading and I posted some wrong numbers, all that just for 60 euro difference. I think I will keep my all products pack mostly to punish myself for talking before thinking.
thank you, helpful!
nope the code area is scrolling very slow on mac and even slower on 5k, 4k or 8k. I think this is the most slow component ever on all other IDEs even Netbeans the scrolling is the same as in textedit ;) it is fun that this days even electron apps like vs code have a faster scrolling and redrawing
Other *exceptions* are the ``doAndGet`` or ``checkAndSet`` methods from the atomic data types. In general in the context of multithreading there are lots of problems with atomicity, so the best description simply requires an *and*.
Nah, the 3rd party library pollutes interfaces forcing everyone to include guava and use it everywhere. The JDK should have made the distinction but it doesn't look like we will ever get true immutable datastructures (e.g. VAVR, guava ImmutableList is not a true immutable datastructure implementation) as the JDK team is cementing the even more horrible Unmodifiable collections. :( That said I hardly need immutable collections. The content is mostly dynamic and then I don't see the point of immutable collections in Java. So I'm rather unhappy with the choice they made with `List.of`. It forces the unmodifiable implementation despite `List` being the interface. There should have been `ArrayList.of`, `UnmodifiableList.of`, `LinkedList.of`, ... (same for other collections)
Of course but most senior devs I know have not found the pain point yet to relearn these nor any enormous benefits to not only relearn them but to pay a proprietary company a subscription as well. Most of their productivity is the sheer amount of knowledge they have in their head about the language that they rarely use code assists etc. They just type code.
GetPastAndPresentOffersThenValidateAndOfferPromosOrSignupDiscountAndSaveToLocalDBInCaseOfNetworkOutageThenAnimatePurchaseDetailsOrPresentThanksAnywayScreen()
They did provide a small discount in response but then I felt bad about the whole thing and decided to keep the All products pack. Honestly I thought about deleting the whole thread but it might be helpful for other people.
I pay for Ultimate and I upvote Eclipse and other IDE talk when I see it. Competition is good. I‚Äôm not a big fan of the subscription model but there is a free alternative even within the Jetbrains product line. I could probably get by with either community edition or EAP if I wanted to but I like to support their product.
That is a big part of the issue. I learned to program when an IDE was little more than a text editor that let you compile code without having to leave it. I don't upgrade software, let alone pay for it, unless there is at least one feature that would rock my world.
It might, yes!
&gt; As someone who browses the subreddit by new and reports everything in violation of the rules, this attitude is very frustrating There's about a hundred ways you could have said this in a nicer way. /u/desrtfx is volunteering his valuable time to help keep this sub clean. No matter what; you don't get to be frustrated with him. The Reddit system of modding sucks, but that's something you should take up with the owners.
The fanboy post hijacks are annoying. I‚Äôm a fan and pay but that stuff is embarrassing.
No worries. We'll get it sorted.
&gt; I think "no homework/simple questions" with both being defined would be a better rule imo. That would just lead to tons of beginner questions because to them nothing is 'simple'.
If you use Maven (or Gradle,etc) to build, I don‚Äôt see why you can‚Äôt use notepad and the explorer to develop.
Some professional jobs require exactly that. Salon workers provide their own tools, carpenters provide their own tools. There are many fields where the worker is expected to provide the tools they need to do their job.
Thank you. I'm not being sarcastic. I had my fanboy days too. alt.emacs.religion back in the day. Now I am just a quiet fan of whatever I use.
Side note: Linus doesn‚Äôt use Emacs. He uses uemacs [0], his own fork of MicroEmacs. Neither is based on GNU Emacs. [0] - https://github.com/torvalds/uemacs
JavaEE / Spring / Application Server Deployments are the minimum I have to have for my job, lots of other features are just nice to haves.
It's from this [thread](https://www.reddit.com/r/europe/comments/c7vh8r/average_gross_salaries_of_software_engineers_in/) where it's common to have statistics without actual sources. I'm not sure if it's accurate for Hungary but I think it's pretty close for Greece. In my case I have a bit of experience now after about 5+ years in multiple languages / roles, so it's just a matter of preference and convenience to keep staying here.
Have the upvote - I laughed for longer than I should have at this .... but if a roundabout way, you answered the question still!
TIL. Thank you.
The only person I know who uses eclipse is my friend in IBM for obvious reasons. He has industrial strength eclipse it's nothing like the peasants version.
With method names like that, who need comments! Totally self documenting.
what about making JAVA IDE in c++ ?
what does this have to do with anything? it won't fix his problem. there is an IDE though written in C++, i used it about 20 years ago. no idea if it's still maintained , the last update was in 2015: http://www.jcreator.com/
I find the community edition is lacking important features for a professional (webdev at least). And it's for a reason, to support their product, and we need to be fine with that (I guess). How do you deploy your application, and more importantly, how do you hot-deploy with the community edition? I think only eclipse can do that in the free version. If you still work with JSP files, how do you see if methods / constants / etc are being used? it has no support for JSP files. (p.s I don't work with JSP files now, yey)
InjelliJ has unquestionably vastly superior completion and project indexing. So vastly superior that eclipse looks like a toy project by comparison. That‚Äôs not even counting everything else it does better. Every time I use eclipse, I am constantly fighting with the code completer till I eventually just disable it entirely. InjelliJ, on the other hand, has amazing completion that almost always just works, and never substitutes my correct typing with its own ideas of what should go there. Same goes for Netbeans. I‚Äôd be shocked to find people more comfortable with eclipse after giving IntelliJ a trial for a couple months.
And/or in the method name is usually a good indicator the method is breaking the single responsibility principle.
Yes, that's also true. I also wouldn't consider these methods beautiful or good style or something, they're more a necessity for performance and atomicity reasons.
Snappy start-up times are nice, but honestly, how often are you restarting your IDE? I've had the same project open for like a month on my work laptop, and the last time I shut it down was because of an OS update.
heh... well you talk about boot time and slowness if the IDE im using jetbrain and eclipse they both shit and slow . eclipse version 2 was fast
But this ain‚Äôt one of them.
Just don‚Äôt do any of that from an IDE GUI? I wouldn‚Äôt trust that anyways. You should have other tools set up for continuous deployments.
Agreed but I wouldn't want to work for a place that wouldn't shell out for an IntelliJ licensed if I asked for it. It's a good indicator that the company doesn't want to invest in their employees.
Ah yes. Notes. Where you search for a word and even though in the next tab you‚Äôre literally looking at a result that should pop up, notes find a way to show nothing
Not everyone works in the US.
I'd pay the money for the database features alone.
The startup and smaller docker image size are what I would gain. &amp;#x200B; JIT can offer performance advantages over AOT compilation in that there's more data available to the compiler, so re-compilation of hotspots at runtime becomes possible. That's what I was referring to - sorry for the confusion.
jlink looks like it's exactly what I'm after. Thanks for the links - they literally solve my problem for me!
I mean for development purposes on your own PC. You can setup [hotswapagent](http://hotswapagent.org/), basically change your classes, and redeploy on a Tomcat in a few seconds. Works **most** of the times if you know what to expect. If you work with microservices it gets more tricky, since you need to setup different ports for each one, but it's still possible to do everything from the UI. (If you have enough RAM to do so) For staging / prod there are a lot of ways to do it. For my personal projects because I'm pretty lazy I recreate docker images and use docker-compose / rancher / portainer on a custom isolated docker network. I've also setup a project with Jenkins that builds, verifies, and deploys the new application on the cloud, but I wouldn't trust myself for a production server. That's a sysadmin / devops issue and I'm ok to stay away from it :D
Have you tried Jetbrains JDK? For me it's somewhat faster. I switched using [JB SDK Downloader](https://plugins.jetbrains.com/plugin/9195-jb-sdk-bintray-downloader).
It should be.
No way. It‚Äôs a tool that they employee needs to provide, and is also a tax write off for them.
&gt; reports everything in violation of the rules, this attitude is very frustrating, especially considering you say you‚Äôre the only active mod Not meaning to be an asshole here, but there are a couple things you should consider: Just because *you* report something does not mean the whole community agrees with that. If the post has upvotes and/or an active discussion going by the time I see the report (which can be some time as I have a real life) I will not remove the post. You have absolutely zero rights to be frustrated because it is one opinion of several and the majority wins.
I think you've done what I initially did. They're not talking about starting the IDE, but launching your code either in run or debug mode.
This might be a partial cause; eclipse has a background compile process that IntelliJ doesn't.
I am in the same position as OP. Upgraded to "All Products" in that promotion last year, and was planning to drop back to IntelliJ only (for which I've had a license since 2015) as the term ends. I just went under my account profile and clicked the "Downgrade" link, and it does indeed quote full price for IntelliJ ($149 US) with no understanding of continuity (should be $89 US). I clicked the "Request a Quote" option, and typed up a quick note to that affect. I'm sure (or at least hopeful!) that the sales people will sort it out and send over a corrected quote. Glad to see someone from Jetbrains in this thread, confirming that this isn't intentional. However, can confirm that it is the current state of the automated billing system.
I have a coworker who likes to write what I call triangular code. There is an entry point somewhere and in that function he writes a few lines of code. Perhaps some input filtering. Then at the bottom of the function he calls another function that does the rest. This function would usually do some processing or calculation and then call yet another function at the bottom. This third function would do something else like talking to a database. He is not very good at naming so the function names end up meaningless anyway but if they were given decent names you end up with stuff like calculateSomethingAndStoreInDB(). He frequently complains about the difficulty of writing tests and mocking databases.
&gt; I clicked the "Request a Quote" option, and typed up a quick note to that effect. I'm sure (or at least hopeful!) that the sales people will sort it out and send over a corrected quote. I have received this invoice since May but I was also hoping it would be sorted from support. I only made this thread after contacting sales and their response was: &gt; When you downgrade a license, the new product doesn't get the continuity discount from the previous license. From a first look it seems like a way to trick people into paying more for stuff they won't use, that's why I made the thread. I will update the post with what hadi will reply in any case. As for me, my peace of mind and time is worth more than 68 euro and I've already lost too much of it today.
If you do not need to separate them, and do not have a better name, then use and/or, or whatever you want, no harm is done.
my daily rate considered good enough in Hungary, especially with 2 years of experience
This trick comes up occasionally. Imagine that you want to have a Map&lt;Key&lt;T&gt;, T&gt;. Where T is defined by the key type (think, something like an enum map, but each enum key has a type). First up, to define the key you write something like this class Key&lt;T&gt; { private Key(){} private static final Key&lt;Integer&gt; INTEGER = Key&lt;&gt;(); } Then your map can look something like this private class KeyMap extends AbstractMap&lt;Key, Object&gt; { private final Map&lt;Key, Object&gt; innerMap = new HashMap&lt;&gt;(); @Override public Set&lt;Entry&lt;Key, Object&gt;&gt; entrySet() { return innerMap.entrySet(); } public &lt;T&gt; T putSafe(Key&lt;T&gt; key, T value) { return (T)put(key, value); } public &lt;T&gt; T getSafe(Key&lt;T&gt; key) { return (T)get(key); } } Now you have a map with a semi-flexible set of keys and types fixed. Why is this useful? Depends on the application, but often it is useful for cases where you are dealing with situations where reflection would be used instead. It allows for you to avoid the reflection. This gives you some of the type safety that you'd want and allows you to talk about your fields in terms of keys with type information bound (for example, you can have a Set&lt;Key&lt;Integer&gt;&gt;). Now, to be fair, a lot of this can now be easily achieved using lambdas/method references. But when I started doing this stuff was back when I was stuck on Java 7. I have no idea if this monstrosity has a proper name.
Without explanation this chart is useless. &amp;#x200B; required at least the year, level of experience and what average means.
I rarely run small code snippets but I do have the same issue when running junit tests. The build before just takes to damn long but as yole pointed out removing the build process from the run config does help quite a lot.
4.13? Why do they still use two numbering systems?
Is your organization on the latest version of java? Does your organization have deep depedency trees? &amp;#x200B; That is where I've seen my biggest regrets about lombok. It delayed our rollout of Java 7, 8, and 11. Why? Because in each of those rollouts an old version of lombok in some sub-sub-sub-sub dependency would invariably break. That would cause massive efforts in our org to get that sub-sub-sub-sub dependency released with the fix and everything up the tree fixed as well. To me, those terseness benefits just aren't worth the potential breaks in the future. Instead, projects like AutoValue and Immutables provide the terseness using a supported Java feature (the annotation processor) without getting involved in to compiler internals. I see no reason not either of those two libs over Lombok.
There was a time like 3 years ago where I worked with all 3 (IDEA, Eclipse, Netbeans) usually at the same day. Eclipse for its bi-directional Java Swing Editor (that nobody else has I think), Netbeans (I don't remember why, I think for a project build with http://wiki.netbeans.org/SAFSupport ), and IDEA for my main project. They are all OK if you feel comfortable using them. Netbeans had bad git support though, so I kinda avoided it. Eclipse had good git support, so I trusted it. But I've learned to use all 3 without issues, even at the same day. If the open source projects like Eclipse made an effort to catch up to IDEA by requesting money I would support them, because open source wins every time. They just need a payment model that will keep people invested.
Or Immutables. But yeah.
Usually this is good advice. getFullName() is better than getFirstAndLastNames(). But I have written validateAndSave()
Why don't you just delete your post then
obv upvoted lol
I try to use java for everything (which means not using JNI). Of course there might be cases where docker is useful. But for running pure java-code i don't think you need it.
Oh! In that case I've never seen the behavior OP is describing. IntelliJ is much faster to start my server than Netbeans.
While I know the "reasons" I honestly don't think they apply in 90% of the cases. More often than not, when you are making a data class, you are NEVER going to turn around and add an interface on it (When was the last time you made a getter interface?). Changing the implementation is equally unlikely. In fact, I'd call it a code smell if a method named "getFoo" didn't return the "foo" field but instead calculated foo somehow. An "abstractDataClass" is equally horrifying in every code base that I've stumbled on it. That code is almost always a big ball of spaghetti. Data classes in a clean code base will pretty much never extend anything and very rarely even implement any sort of interface. After all, is it a data class or is it something else? Often, if it is a data class then the whole point of it is to shuttle around a bunch of fields. The refactoring and guarding is one that does matter, but it also depends on where this dataclass lives. Is it in a library? Ok, makes sense not to expose internals. Is it at the application level? Probably doesn't matter because you know all of the users of those fields. Is it an inner private or package protected class? Same thing, you know all the users so no reason to be overly concerned with someone outside breaking because you add or remove a field. All this is to say that it isn't nearly cut and dry on whether or not to make a field public. I find the argument for a bunch of getter/setter methods to be week generally as it often never serves any purpose other than "that's what we are supposed to do!"
Settings -&gt; Compiler -&gt; Build project automatically
Not the IDE. We are talking about programs. Like a [HelloWorld.java](https://HelloWorld.java) or HelloWorld.kt &amp;#x200B; Eclipse is just faster. Also much faster then Visual Studio Code.
I don't think if you realize my post. I'm not a native English speaker so maybe i can't express myself like I want to. The reason my post is still up is because I still believe it is possibly a trick from Jetbrains to convert more people to the more expensive plan. The reason I feel bad is that I called them out for losing 3 months last year where in reality they just made sure I don't lose any money from it. I also feel bad because my title looks like I'm being forced to pay 250 euro for the All product pack when I'm getting the continuity for THAT product. I just lost the one I already had 1 year ago. I don't give a fuck for that 68 euro diff, so that's why I won't ask anyone to revert my license, but if my post helps someone form a better opinion about purchasing a license, or push Jetbrains to be more transparent about it to other people, it's still a win for everybody.
Yes. I tried all options. Also "Before launch". A fast dev flow is probably the most important feature for me. Also compared to Visual Studio code Eclipse is much better. Even for Kotlin.
Thanks for this! If this works I‚Äôll let you know.
Spring and Hibernate don't tie into the javac and rely on compiler internals to do their magic. Both libraries are generating bytecode, but not manipulating the compiler itself. That's a pretty big key difference. I don't care if you use lombok in you app. It is pretty easy to update it and they are fairly on the ball about fixing things. But, for the love of god, don't use lombok in a library. Lombok breaks constantly with minor incremental versions of java. Because it is so closely tied into changing the compiler itself, you can end up with a lombok dependency breaking everything just because some random library you brought in decided "I can't live without lombok!" &amp;#x200B; Use an alternative that doesn't mutate the compiler. AutoValue and Immutables are awesome and will work with any version of java.
I have tried different JDKs over the years...but never JB's. But I doubt it will make a difference.
Maybe people could post their launch times of a small HelloWorld program (e.g. 10 launches) for both Eclipse and IDEA. &amp;#x200B; A bigger example then HelloWorld would also be appreciated.
I think it depends on what sorts of projects you've developed and maintained. I don't think the average app developer will ever run into situations where lombok is horrible. But, if you are like me and you maintain huge awful legacy code bases with mountains of internal dependencies, then a project like lombok is a nail on the board. It has more than once ground our org to a halt on our java update prospects because of our (admittedly awful) dependency tree.
This still won‚Äôt fix this issue, however: https://www.oipapio.com/question-971567
The entire list of "Java" sites maintained by Oracle: 1. https://oracle.com/java 2. https://java.oracle.com 3. https://java.com 4. https://go.java 5. https://jdk.java.net 6. https://openjdk.java.net 7. https://docs.oracle.com/java And according to Oracle, each site serves a different purpose. Yes, including sites [1] and [2] are different. Until to this day, there is no official one-stop-shop front-door for Java. I've raised this issue several times, most recently here: https://twitter.com/brunoborges/status/1087914698836602880
Well, I wasn't really talking about snippets. But if it is slow for snippets it is even slower for real world applications.
You don't have to subscribe to it, you can buy a specific version (the latest, when you buy it) and keep it forever, without updates. Read up in this comment thread, it was mentioned somewhere. Regardless, competition is good! I'm glad there's more then one good IDE and that I have a choice.
Well it's probably tuned for JB programs, wouldn't hurt to try, let me knorw if it helped in any way I am curious now.
That, my friend, is a question nobody really knows. I've got a feeling even the good people currently at Eclipse don't know. But I'll give it a guess: the one version scheme, like 4.13 has always been in place. The second one, use to be a name. Having both a version number and a name is quite common, Ubuntu and OS X/macOS do the same thing. E.g. OS X/macOS 10.14 vs Mojava. It's designed to somewhat confuse people, as nobody can ever remember which corresponds to which, and with the name, which is newer. Was Tiger newer than Puma or Lion? Was Tiger 10.4 and Lion 10.5? What was the name for 10.8 again? Did they change to places after 10.10, or exactly at 10.10? Your guess is as good as mine. But then Eclipse changed to a faster cadence, and it probably became too difficult and time consuming to invent a super cool codename every 3 months, so they changed the name part of the version to something that can be automatic; just the date. If they consistently use them together, like 4.13:2019-09 it might actually be somewhat clever, as you can easily see from which year which version number is. Of course, as dual naming was designed to confuse people, that wouldn't be really confusing anymore. So in order to keep confusing people, they just use them arbitrarily. Sometimes it's 4.13, sometimes it's 2019-09, and occasionally, but only occasionally it's both. Just my 2 cents, no idea if my guess is correct.
&gt; Looking at the contribution graph and developers involved, I'd probably go with Quarkus, but that's a matter of taste. Can you explain this a bit more? I know Quarkus is backed by Redhat but I don't think they even try to reach the same goals. For example Micronaut is trying for a spring [compatible API](https://micronaut-projects.github.io/micronaut-spring/latest/guide/index.html). Plus it's already working on live environments so I guess it's not at an experimental state (example)[http://www.jbcnconf.com/2019/)
 - I‚Äôd be shocked to find people more comfortable with eclipse after giving IntelliJ a trial for a couple months. Nice to meet you. I tried IntelliJ for few months, like 5 or 6 years ago, and don't feel any superiority. So... what do you use IntelliJ for? Android, Java web, in-build processors? And when was last time, when you tried Eclipse for few months?
They should just use the date of release backwards: 2019.07.04 or shorter: 19.07 next year it's: 20.05 Pretty easy to understand.
Doesn't feel like that much of a win. If you type out the whole class you'll spend a couple minutes on boilerplate code. If you go with Lombok, you'll have to maintain a dependency over time which turns into a much more expensive operation in my opinion ü§∑
The problem in general is defining the correct term because when I read getFullName I also think the middle name should be included, if any (and this is not counting different names conventions depending on the country).
Eclipse used to be like android I'm sure, with an arbitrary word in alphabetical sequence ( Neon, Oxygen, Photon...)
jshell?
[SOLID](https://en.wikipedia.org/wiki/SOLID) and particularly the [**S**ingle responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) The approach `GetPastAndPresentOffers` is inherently wrong according to the **S**.
The problem is, the same issue is strictly _worse_ when not using Lombok. When you implement `equals` manually, you can simply not think whether to call superclass' method or not; Lombok warns you and tells you to make a decision. When you do make this decision, you can configure it for all classes (and opt out if it's desirable sometimes, and those classes will be immediately visible). While for manual code, if you want consistency in this respect, you need to enforce it via code reviews. Which will take non-trivial time and effort from reviewers and isn't guaranteed to actually work. Or you can write code to parse Java and check it automatically, which will also take effort, need to be maintained...
Writing an enterprise application without using Hibernate.
Or better: can't even login without reading the documentation
&gt; If you type out the whole class you'll spend a couple minutes on boilerplate code. No, and that's the whole point of my previous reply. You'll spend a couple of minutes every time the class is changed. Or worse, you'll forget to spend this couple of minutes and have a very fun time debugging it when trying to store two keys which _should_ be different. &gt; you'll have to maintain a dependency over time which turns into a much more expensive operation in my opinion Maintaining the dependency: 1 minute for every Java version upgrade (to increment the version in Maven or Gradle build). If you forget and Lombok doesn't happen to support the new version, the failure is likely immediate and highly visible. Not maintaining the dependency: a couple of minutes per added/removed field for many classes. If you forget, the failure may be visible in tests or it may not. Somehow, I think adding or removing fields happens more often than Java version upgrades. Of course, my personal answer is: don't use Lombok, use Kotlin or Scala.
\`AtomicInteger#compareAndSet\` - what would you call this instead?
There have been many attempts at a general JVM 'startup accelerator' - look up Nail Gun and Drip. They generally all turned out to have several major drawbacks, and people seemed to stop using them. Some of those drawbacks could be mitigated by making the design specific to a single program, which is what I guess Groovy is doing. If you want to start general Java applications fast, check out GraalVM's Native Image tool.
I'm not sure I agree in this specific case. Let's say there are three columns: Past, Current and Future. Is getting the offers in the first two columns one action or two? What if I phrase it as "give me the offers which are not in the third column"? There's no 'AND' anymore. But this is clearly one action, and yet it's the exact same.
In this particular case I would enthusiastically advise finding a better method name rather than calling GetPromos() from multiple places and passing in those two strings. That way if there is ever a third value that should be included, or if you have to filter out canceled promos using another field, or add any other additional logic, it's much more likely that you'll only have to change one place. Also finding usages of that method makes it easy to see all the places where this particular list of promos is accessed. It is often worthwhile to encapsulate even trivial logic if it defines a logical use case.
But then you don't have an idea of how big a release really is. It could be major within 3 months or minor within 1 year.
What's that about broken .NET compatibility? Got a link?
If you understand the syntax, it scans exactly like a series of if-else statements. The big difference is that it's an expression instead of a statement so it's able to return a value. It's a trick since there is a trade-off when first encountering it but after that it's a compact tabular format for conditional expressions.
Neat. Projection types on inline classes is going to be interesting to say the least. I have to wonder how they will work out (if at all) with classes that were previously slated to be value types. For example, Optional.
Agree to disagree here. This is on my top 5 things to look for in a code review and especially so when I see inheritance being used. I don‚Äôt disagree Lombok doesn‚Äôt have a place, it‚Äôs just not there yet for me.
Eh, in a lot of cases, there are most likely sensible defaults or better yet falling back to a Null Object (especially in your setter example) or an Optional. I personally find it sloppy to throw NPE when any of the arguments are null.
Yep. Intersection types have been around for a minute. I'm still stuck on 8 too at work :(
Wouldn‚Äôt that generalize to all methods that invoke other methods?
 enum MyEnum implement Function &lt;SomeType, SomeOtherType&gt; { THING_ONE( st -&gt; doSomethingWithSt(st) ), // ...other enum values private final Function&lt;SomeType, SomeOtherType&gt; delegate; .... @Override SomeOtherType apply(SomeType arg) { return this.delgate.apply(arg); } }
/u/desrtfx sorry to summon you but why is this thread hidden from the subreddit?
Pivotal is proud to announce Spring Business Logic.
Yes, their main use will be classes that need to reference themselves and generics. Value-based classes like `Optional` will likely be made `null-default` inline classes.
This is why you comment your code. And for this function make sure you create the javadoc and in there explain what it returns.
Obviously, the thread received too many reports and thus was automatically removed. I can actually see the reason for the reports as this is not directly Java related. Yes, I know that IntelliJ is *the* Java IDE, but still, complaining about Jetbrains is not related to Java. For now, I've approved the thread again, but should it go down again, I won't restore it.
It's now visible again and not showing as DELETED any more. What's going on?? Why would someone delete the thread. This situation will only make Jetbrains and /u/hhariri look bad.
&gt; I can actually see the reason for the reports as this is not directly Java related. Yes, I know that IntelliJ is the Java IDE, but still, complaining about Jetbrains is not related to Java. &gt; For now, I've approved the thread again, but should it go down again, I won't restore it. I don't see what's so obvious about it. It's one of the most important tools of Java and it's very important to most Java developers. It is also the top post of the day. The automatically deleted threads give no notification to the Authors? I don't know what to say, I'm kinda speechless right now. I want to believe all is in good faith but a lot of stuff going on today.
&gt; The automatically deleted threads give no notification to the Authors? Normally they do, but AutoMod (as well as reddit modmail) has been acting up lately.
Hey there - I'm a 54 year old Java programmer too and I've been working remotely for over 5 years. So, I guess I'm doing what you want to do. Feel free to reach out with a direct message if you have specific questions. Here are some thoughts on: * Unfortunately, Struts and JSPs are not really used anymore though you might find a company that does that. * Make sure you're comfortable with modern functional programming and the new libraries and language changes in Java 8. * Learn one of the widely used frameworks: Spring is used everywhere (unfortunately in my view but there it is). * Understand distributed computing. Java jobs today will almost all be distributed micro-services. * Maybe get involved in an Open Source project to get your skills back up. * An option for remote work if you're willing to work for a lot less money is to try UpWork (or a similar system) for a short period to help refresh your skill set. But, beware, you'll be competing with highly motivated 20 somethings from Eastern Europe and will have trouble making US-level money. * Maybe pick an area of interest and try to become an expert in it. E.g. learn everything you can about Kafka (everyone uses it or something like it). Write an OSS-something that uses it then try to leverage that into a new job.
What's wrong with major minor numbering?
Intelij is great, but fuck their licensing is a ballache.
I last used eclipse 2 months ago for a few weeks as I tried to get rid of my IntelliJ subscription. I do basic SE development, spring development and vertx development. Eclipse is utterly unbearable. In a matter of 10 minutes, eclipse will autocomplete your correct code with incorrect code so many times that you‚Äôll turn off completion all together. Not only is eclipse inferior, but eclipse **actively inhibited my development time**. So I quickly wiped all trace of it from my system and reluctantly kicked the subscription back off. Doing vertx development uses lambdas pretty heavily, and every single fucking time I typed ‚Äúresult -‚Äú, eclipse would replace it with some off the wall, utterly irrelevant CLASS and auto import the class. I‚Äôd rather bang my head against a wall of rusty nails than use eclipse with its horrifying completion ever again.
clearly op haven't used spring-data
Thank you for detailed response
Hidden from the subredit? It appeared in my feed.
I don't know if I'd call it good. The menu's are jacked up and have no relationship to human thought processes.
In contrast to.. intelliJ?
I haven't looked at either project in depth yet, just enough to know that they solve a similar problem, so please take my "evaluation" with a huge grain of salt. Looking at the [contributors of Quarkus](https://github.com/quarkusio/quarkus/graphs/contributors) I see that RedHat put a good amount of manpower behind it, including people like Stuart Douglas (developer of Undertow) and Martin Kouba (developer of Trimou). I used both of those projects in the past and can attest to their quality, as I have read a good part of their source code. I don't know [the developers of Micronaut](https://github.com/micronaut-projects/micronaut-core/graphs/contributors) enough to make such a judgement, they come from the Grails ecosystem which I'm not familiar with. But competition is good for the ecosystem, so I'm glad it's not a monoculture. Hope that helped.
It was automatically deleted because of [reports](https://www.reddit.com/r/java/comments/c9fp4v/i_switched_to_jetbrains_all_product_pack_last/eszgu0n/)
I'd say the worst part of jetbrains stuff is the menus, but at least they don't have multiple locations where you set the same things that all do different things like eclipse.
I agree. In the end, more simple - is better. So if getValueOrGetDefault is more simple, then lets use it. If it simple, then we can easly change it later if necessary.
&gt; Hope that helped. Thanks, that's great info. I will probably give both a try at some point. Offtopic: I'm not very experienced Java dev, but I feel Spring boot is bloated, and most libraries / configurations need spring boot (spring cloud for example), so you are forced in this environment where everything works until it doesn't, and you have no idea what's wrong.
https://betanews.com/2019/05/07/future-of-dotnet/
I would take a look at the nee functional stuff from java 8 and have a look at spring or another popukar framework.
Solve a lot of leetcode problems and write some Java apps using Spring and maybe one more popular framework like spark java.
Apps in the cloud: Docker basically a slim Virtual Machine you use to run your Java apps. Kubernetes, they host your docker containers in the cloud. Springboot seems to be standard. Kotlin is on the rise and runs on the jvm. I'd read spring in action, it's a fantastic book. Spock is becoming a standard testing framework. Build tools are Gradle and maven...ant is legacy.
See [Application Class Data Sharing (App CDS)](https://blog.codefx.org/java/application-class-data-sharing/); it's been getting a lot of attention lately, in JDK [12](https://openjdk.java.net/jeps/341), and [13](https://openjdk.java.net/jeps/350).
But people still seem to like it quite a bit though.
I was looking more in the direction of increasing dev flow. If launching your code feels twice as snappy (because we don't have a JVM cold start) this can only be a win.
&gt;this can only be a win Unfortunately it's not only a win - it introduces all kind of subtle problems of state polluting from one instance to another.
LOL. jshell is the definition of slow. They should use GraalVM to compile it to native ;) &amp;#x200B; I wasn't talking about launching little Snippets in JShell but rather developing a huge app in your favorite IDE and launching it after each edit in a "hot" JVM.
I still find it fascinating how quickly things come into being nowadays. To have someone mention that Spock is becoming a standard and for me to have never heard of it simultaneously scares me and makes me happy. It looks pretty neat.
"There are only two hard things in Computer Science: cache invalidation and naming things." - Phil Karlton
Don't feed the trolls...
Hadoop is old, the buzzword back end skills now are Spark, Kafka, Spring if you're doing full stack web apps, and the basics of AWS--EC2, IAM roles, security groups. There's a ton of full remote work, off the top of my head I know Elastic and Datastax have 100% remote jobs but there are tons of smaller companies that offer it. Honestly, yes Struts and JSP are old, but no skills in this field are future proof. Many companies will give you idiotic programming tests about stuff you've probably forgotten or never cared about; there are basically two flavors, one is really basic stuff to see if you know how to code at all (like reverse a string by hand, figure out if something is a palindrome) and the other flavor is stupid shit that nobody knows how to do unless they study it (like grid searches and variations of Dijkstra's algorithm). A lot of places that ask the latter kind are actually testing whether you communicate when you're trying to solve something. Just do a bunch of leetcode medium questions.
I see people knocking Spring but I wouldn't dismiss it. It's used everywhere, especially in Enterprise. Personally, I love Spring. Spring makes me money. If you want to win projects with larger companies, learn Spring Boot, Spring Security, and Spring Rest. Outside of that, I would strongly recommend learning mobile development. There is a lack of developers with your level of experience. Source: developer for over 35 years, been using Java for 25 of them, and I employ developers.
Right. It's really cool. You were your tests in groovy...or Java, and the tests can live along side existing unit tests. I'm going to add it to this project that is using junit currently....got to update that repo!
You know UML? I think that is important, too... Btw: I already thought about starting a company just for oldies. I think there are a lot of very experienced devs out there, who don't get hired because of age. Maybe a network would be a good start.
groovy is painfully slow to start. java is reasonably quick to start, on the order of 50ms on my system, and as a result startup times aren't generally a problem (spring is another matter entirely). the only two use-cases that i can think of in which faster startup time would help are: &amp;#x200B; * programs that are meant to be used in a way similar to \`grep\` in the shell that might be started over and over again in a loop * in serverless, where you also have a VPS that can host the daemon &amp;#x200B; neither seems like a big win, and you'd have the extra complexity of maintaining the daemon. if you have a particular application that has slow startup, eg spring, then maybe it makes sense, but that's application specific
Learn to use AWS.
&gt; and JSPs are not really used anymore &amp;#x200B; Really? What do people use to write templates for the view? &amp;#x200B; I'm in a similar situation in that I started coding in Java back when applets where supposed to be the future. And ever since I discovered servlets, I was doing backend development servlets/jsp. These days, I only code for my own projects/business (mainly because I don't trust anybody, so I code my own stuff). I'm not looking for a job, but I'm curious, don't people use JSP anymore?
People mostly just use dedicated UI frameworks like React or Vue, and just leave Java to do purely the backend work, in my experience.
Spring is all over the place, but specifically its the Spring Boot style. I would very strongly recommend you read the book Clean Code, as more and more interviewers are going to ask you questions straight outta that book. Be familiar with the concepts surrounding containers. Honestly, I would recommend reading Clean Code first, building a Spring Boot API second, putting that API in a container third, and then building a React webapp to consume that API lastly.
Would have liked to see, how long did the migration take and gotchas or stuff which is missing from reactive framework compared to traditional features.
Using the EA writing an Optional implementation as an inline class was very easy. I thought I'd experiment with scale and tried to put them in an array and that fails at runtime with... Exception in thread "main" java.lang.ClassFormatError: Illegal class name "QFoo" in class file unknown ...while Unsafe is doing some lambda-metafactory spinning. I'll need to look at discussions on the dev-list and some of the example code to see what _should_ work and what might be work in progress.
Put as many examples of your work - old or new - that you can in Github to show prospective employers what you can do.
That‚Äôs odd... I was able to put objects of a `Point` class in an array using the LW1 builds.
JSPs are mostly treated as legacy in the companies that I work with. For Spring Boot server-side generated HTML, Thymeleaf is the de facto standard, because they‚Äôre ‚Äúnatural‚Äù templates (can easily be previewed directly in a browser, because the templates _are_ HTML). For SPA (single-page app) front-ends such as React or Vue, then you‚Äôd just have the back-end implementing appropriate APIs.
As others have said, Spring Boot (Spring framework + easy configuration and more) is going to get you the widest range of options. If you can (and want to) pick up some front-end (React or Vue), you‚Äôll definitely be in demand. Knowing how to write good Java unit tests will put you ahead of 80% of the folks out there.
Better to use a proper smelly method name, than a less descriptive clean one with a javadoc.
S is a bullshit anyway. https://sklivvz.com/posts/i-dont-love-the-single-responsibility-principle
Good news is that it was a left-over line involving Streaming the array that caused the error. The bad news is that it looks like a trivial filter step in the stream processing tripped it up. Example... Using this inline class inline class Int { public int value; public Int(final int value) { this.value = value; } public int get() { return value; } } This compiles and runs... long s = 0; for (int i = 0; i &lt; a.length; i++) s += a[i].get(); Whereas this compiles but explodes at runtime... long s = Stream.of(a).mapToInt(Int::get).sum(); I expect it's a known limitation in the EA at the moment since it looks like trying to spin a lambda involving an inline type always fails.
 people in HN and reddit like it. Not so true in my workplace.
Does it still explode if you use the projection?
\&gt;&gt;Hey there - I'm a 54 year old Java programmer too and I've been working remotely for over 5 years. So, I guess I'm doing what you want to do. Feel free to reach out with a direct message if you have specific questions. Thank you! Are you me in future :-) Are you doing this in a freelance capacity or in a full time role with an employer who offers benefits like Health insurance, vacation etc. How's the difference in salary/compensation compared to on-site/traditional setup? \&gt;&gt;Unfortunately, Struts and JSPs are not really used anymore though you might find a company that does that. Yes, there‚Äôre probably some slow moving enterprise places that still sue it but no more major developments are being done using those directly any more. If looking for remote at this point, pretty hard to see those in job requirements unless again if the job is for an established company that‚Äôs legacy code that needs maintenance or new features. \&gt;&gt;‚Å†Make sure you're comfortable with modern functional programming and the new libraries and language changes in Java 8. Yes, good advice! I know functional is another paradigm but is it being asked as a skill in the Java world on its own? It‚Äôs good to know functional techniques to blend in regular java code I suppose based on the problem at hand. \&gt;&gt;Learn one of the widely used frameworks: Spring is used everywhere (unfortunately in my view but there it is). Yes, I see it everywhere in job reqs.I may start with Spring Boot but I‚Äôm looking for an all in one type course that can help me go from end to end and prepare enough so I can speak confidently in an interview. \&gt;&gt;Understand distributed computing. Java jobs today will almost all be distributed micro-services. Right again, micro services are all the rage. I‚Äôm thinking doing AWS Solution Architect cert will also give me a broad overview and may give me little help in getting into roles that require or help move up from pure dev roles into little high level design roles. \&gt;&gt;Maybe get involved in an Open Source project to get your skills back up. I hear you but realistically speaking, don‚Äôt fine time due to family obligations etc, easier done at younger age when there‚Äôre less demands on time.your point we‚Äôll taken though! \&gt;&gt;‚Å†An option for remote work if you're willing to work for a lot less money is to try UpWork (or a similar system) for a short period to help refresh your skill set. But, beware, you'll be competing with highly motivated 20 somethings from Eastern Europe and will have trouble making US-level money. This will be tricky as US expenses with need for health insurance etc would preclude this option. Good idea on getting experience by working projects though if money is not an issue. \&gt;&gt;‚Å†Maybe pick an area of interest and try to become an expert in it. E.g. learn everything you can about Kafka (everyone uses it or something like it). Write an OSS-something that uses it then try to leverage that into a new job. Yeah, it will take some deeper thinking to see what to pick as an area. I consider myself enterprise backend developer who can find his way around in front end (classic Javascript - does that even exist anymore? :-)), have no specific domain expertise (like finance, AI etc), have done consulting roles in the past, whatever project came by, it's all software at the end of the day so was able to do it across various domains).
Thanks, functional is interesting, didn't use it in the past and didn't see it anywhere in the codebase. Spring it is, any particular resource you may recommend or path to go through to learn Spring? I'm thinking maybe code up a mini project and put it on Github and learn the ropes that way.
Where would I use a projection? I used a projection for the field in my Optional implementation (so it could be an optional over another inline type) but you can't use `int?` and I can't see that it would be meaningful (or possible) to express the method reference or array creation as a projection.
Amen to that! whatever pays the bills at this point :-) I think that Spring might be the new darling framework that's everywhere in the enterprise now. Like Struts was some time ago. Or Servlets/JSPs back in the day. So it would be a critical skills to get paid in the current market for sure! &amp;#x200B; \&gt;&gt;Outside of that, I would strongly recommend learning mobile development. There is a lack of developers with your level of experience. &amp;#x200B; I've personal interest in iOS and Swift but it would be tricky to get a role specifically for mobile dev. given I've no experience but I would love to if I'm given an opportunity to learn/contribute on the job in addition to the normal job duties! In fact I posted another thread over r/ExperiencedDevs at [https://www.reddit.com/r/ExperiencedDevs/comments/c99l6a/iosmobile\_app\_careers\_for\_java\_engineers\_whats/](https://www.reddit.com/r/ExperiencedDevs/comments/c99l6a/iosmobile_app_careers_for_java_engineers_whats/) Maybe I should've posted it here. &amp;#x200B; \&gt;&gt;Source: developer for over 35 years, been using Java for 25 of them, and I employ developers. Are you looking for one at the moment? I'd love to connect.
\&gt;&gt;Hadoop is old, the buzzword back end skills now are Spark, Kafka, Spring if you're doing full stack web apps, and the basics of AWS--EC2, IAM roles, security groups. Well I just used Hadoop as the thing that I read about Big Data. Will look at others you mentioned. I'm seriously considering AWS, as it covers lot of ground at high level and could put my experience to good use. I would be fine interacting with clients and advising them on the architecture, scalability etc, the kids of issues AWS is best at solving! \&gt;&gt;There's a ton of full remote work, off the top of my head I know Elastic and Datastax have 100% remote jobs but there are tons of smaller companies that offer it. I'll look at those and I think StackOverFlow has good section on jobs and those seem to be real meaning actual employers who need to fill positions and they understand enough to post them on stackoverflow vs. ones posting on Monster. \&gt;&gt;Honestly, yes Struts and JSP are old, but no skills in this field are future proof. Got it! You will be pleasantly surprised though that there's places that still use them and continue to do so after so many years and one could have those jobs but when you no longer have that job, you are out looking and find that it was old tech!
I‚Äôm referring to `Int?[]` vs `Int[]`. It is likely a bug that you can file.
Tell me more about this. I come from Weblogic/Websphere world and cloud is new to me. I would love to have all this stuff work in the cloud. I guess I would still need to compile the code locally .. on second thought one could do so on a borrowed computing power in the cloud like AWS EC2 (based on my limited knowledge). &amp;#x200B; In other words, what might a setup look like for developing Java based apps in cloud? I'm thinking sort of like VPNing into a PC that's more powerful that your personal machine and do everything there, faster. And deploy on the App Server equivalent in the cloud using DB in the cloud.. I'm cloud 9 thinking about it :-)
Ive seen it with increasing frequency, particularly the Stream API stuff. As for spring making a small app aounds like a good idea unfortunatly i had to learn it by being assigned to a broken project and told to fix it in X days. The REST stuff in spring is pretty good maybe yju could make a cd catalog app?
I just earned my OCSMP certification last week, for SysML, and my company sees the skill as a viable investment by providing on-demand video training, which was very effective, personally. I'm hoping to transition to UML soon.
I see. Thanks.
I see. Thanks.
Interesting so it‚Äôs not to be dismissed, will look more into it and learn more. The thing with Spring is that it seems it‚Äôs kinda like Java looked in the beginning.. java for mail. Java for xml, java for this and java for that. Spring has all kinds of sub systems, but one has to start somewhere! Spring Boot seems like a good start and maybe I will call some web services that are publicly available and consume them to source data and learn about how to call web services using Spring in the process.
It is amazing to me that in a thread of professional developers the idea that you pay for software is looked down on, even the idea that subscription services are bad. I hate that subscriptions have taken over so much. But I also like that developers get paid for their work.
Thank you for the reply! Find the book recommendation interesting for interview purpose, maybe I‚Äôm looking at Leetcode obsessed reddit forums but it‚Äôs all about cracking the coding interview book over there. I welcome the suggestion. I understand the parts except ‚Äúputting it in container‚Äù. Like the suggestion to tie react in there, to take it one step further, if time allows, one could develop an iOS app to consume the same API!
Not trendy enough.
UML? üòÖ of course! Come on now, we find people calling us oldies old offensive ü§£.. nah .. only kidding!!
Where i am they decided to go with FreeMarker for most stuff, and React for a few screens that fo real time updates. It's basically just a cleaner more compact jsp replacement. I don't like thymeleaf and haven't seen it used more than 1 place, and that poor guy had no idea what he had gotten himself into.
It is easy, you just need to know when was the last release. The same way you need to know what was the last version number, to determine if the current one is major or minor one.
That's why JetBrains does it right: year.major.minor (2019.1.2)
You mean as away to transition out into Architect type roles?
This I‚Äôve mixed feelings about. The kind of employers I have interviewed, none of them asked about any projects on github maybe it depends on the type of role or company culture?
Yeah that‚Äôs what I‚Äôm thinking too! But you know who writes test cases? That‚Äôs a developer‚Äôs job.. üòÑ kidding aside, agreed!
Leetcode is one thing I have never worked with in the past and find most annoying but you gotta do what you gotta do! No idea about Spark, will take a look! Thanks for your reply!
No, there is a lot of cloud stuff kicking about these days so experience with azure/aws is a plus on your CV.
Yes, cloud is the future and will be in demand for quite some time. It‚Äôs not for everyone in that it has a cost associated with it and not every employer/business is going to need it but bigger companies that have to operate on humongous scale like Netflix, whatsapp etc and one could find work in those places!
Cracking the code interview will certainly help you with algorithms and data structures, however it doesn‚Äôt help for how people expect modern code to look. For example, in Clean Code, they make the case for removing as many comments as you can, and instead using more descriptive variable names and methods. One of they points stressed, is that comments are not code, and therefore they can lie (unintentionally) about what the code is actually doing. In interviews, people will test your knowledge of Clean Code by asking you a question like ‚Äúhow do you feel about comments?‚Äù If you say that you prefer more descriptive code over comments because comments can lie, you are immediately signaling to me that you are familiar with Clean Code which is a huge upside. Not every place does this though, but a lot do.
In general, having an And or Or is deserving of a closer look. It‚Äôs not always wrong, and in this case it might be fine because this is a ‚Äúquery‚Äù method (vs. a ‚Äúcommand‚Äù method, which would change the state of the object). Compound query methods aren‚Äôt great, but are not nearly as bad as a compound command method (e.g., depositAndCreditInterest). A query + command compound are also not bad, and as others have mentioned, are found in specialized places like Atomic variables that manage concurrency. There‚Äôs a deeper problem with ‚ÄúGetPastAndPresentOffers‚Äù that is less about the ‚ÄúAnd‚Äù and more about how hard that method might be to test. What does ‚Äúpast‚Äù and ‚Äúpresent‚Äù mean? Round by day? Hour? If this query is coming from the front-end, I‚Äôd be concerned about changes needed to the back-end if someone wants only ‚ÄúPast‚Äù or ‚ÄúToday‚Äôs‚Äù or ‚ÄúLast 7 days‚Äù, so I‚Äôd be expecting a more Specification pattern-based approach, e.g., findOffers(Range range).
like you handle..restlessapi!! Can I call you :-) &amp;#x200B; Tell me which places ask those types of questions..I would love to interview there all day every day! I usually dismiss those types of books as something you learn and pick up as part of your natural progression but I wouldn't have thought of comments in that light..you have made me curious to read that book. &amp;#x200B; I thought places that ask those kinds of questions are few and far between! Everybody seems to be crazy about big O and what not.. &amp;#x200B; I come from Engineering background and not CS so I'm not up and up on all those. I do know data structures but not well enough to answer the tricky questions using trees and graphs.. Even without using any of the complex algo/techniques, been able to manage developing decent enterprise software used by public and works well. Anyway, it's not something one can change, if an interviewer is going to ask those types of quizzes/school type assignments, not much you can do. Keep looking for places that may take a holistic view of the technical interview.
Yes of course, that is the best practice and is recommended. A name such as "givesYouTheFirstNameAndLastName()" would be preferred.
Why do you think it's crap?
Unit tests are the exception, but yes. If "and" or "or" is in a method name, it's probably doing too many things (meaning more than one).
&gt; Really? What do people use to write templates for the view? Mustache / handlebars.js Mustache can do templates on the backend but handlebars for SPA is better.
that's not possible with most huge apps lol
JSF if you want something close to JSP and what Struts tried to be but never came, Mustache and Freemaker are also popular templating frameworks...
State, the necessary bane of software development.
Why use menus if you have shift shift :\^)
Reading TeamBlind forum, they're always boasting their salaries from FAANG companies and the like.. what're the salaries like in Java world for experienced folks? Is there even a comparison..or does it depend on the employer and not so much on the platform being used? &amp;#x200B; Asked another way, what else could Java experienced folks add to their skill set or resume to command higher salaries?
I don't know anything about OCSMP and how it fits into the overall picture. My comment about UML was tongue in cheek.. I thought UML was not big any more and is not used much..especially with the advent of Agile and user stories and what not!
&gt;a freelance capacity or in a full time role with an employer who offers benefits I work as a quasi-employee but under a contractual relationship as I live in the country of Panama. I provide my own benefits. However, there are many companies that provide benefits and regular employment to remotes (e.g. Elasticsearch - I worked there for 2 years). &amp;#x200B; &gt;How's the difference in salary/compensation compared to on-site/traditional setup? It's highly variable. US-based companies pay competitive US rates for remotes. The companies I work for don't differentiate between remote and onsite. But, that's not always the norm. &amp;#x200B; &gt;classic Javascript - does that even exist anymore? No, not really. The Javascript of today bears little resemblance to the Javascript of yesterday. On top of that is a plethora of tools and frameworks you're expected to know. It's its own world. But, there's really good money there and lots of work. Considering moving into that arena if you can.
&gt;AtomicInteger#compareAndSet &amp;#x200B; `setIfCurrentIsEqualExpected` basically just copied the javadoc. &amp;#x200B; &gt; Atomically sets the value to the given updated value if the current value == the expected value.
We're investigating it. As I mentioned previously, it shouldn't be happening. Sorry for the troubles.
Could you please forward that response to me? Same address.
Point of fact: Spring's not new. It's been out for over 17 years :) It's a standard framework. It's a collection of libraries and services. Its MVC library serves the same purpose as Struts. However, where Struts stalled in its evolution, Spring continued to be developed. JSPs still have some relevance but it's pretty minor and scriptlets are outright discouraged. Swift is fine and, if you can make the transition, there's plenty of opportunity there. Same with Java on Android. There are plenty of mobile frameworks that depend on a knowledge of both, Xamarin being a popular one. It's core language is C#, tho. Mobile development is expensive. There's plenty of opportunity for someone to provide a reasonably priced solution. Sounds like your best bet, however, might be to get up to speed with Spring Boot and Rest, and find work leveraging those toolkits. If remote work is an absolute requirement, then mobile is probably the better path.
Maven and Spring together are basically the cookie cutter Java enterprise stack. I would recommend learning Springboot as your priority as centralized application servers seem to be a thing of the past.
thats my combo too
Nothing is replacing it. It is still the best technology for IoT partial deployment. It is still the best technology for complex integrated systems with lots of plugins. The fact that *you* don‚Äôt understand it or cannot use it properly does not make it shitty.
Is that a good combo, FreeMarker and is it used at big companies? I will look into FreeMarker then. Velocity templates anyone? Only kidding. I know, I've known some old stuff!! &amp;#x200B; Have no experience with Thymeleaf so can't say but any template system would be good ... sometimes it's already chosen by the team one may be joining so there's no question about what to choose.
Mustache for enterprise world or it more for Javascript front ends and Mustache for the backend in smaller applications? Reason for asking is whether it's something that's used at enterprise level.
Which is *such* a huge shame and completely ruins Optional imo, though I understand why it'd be a migration issue to do otherwise. Would have been so nice if it were completely flat and empty-default.
&gt;However, there are many companies that provide benefits and regular employment to remotes (e.g. Elasticsearch - I worked there for 2 years). Is ElasticSearch a Java shop or what kinds of roles do they offer for remotes? &gt;No, not really. The Javascript of today bears little resemblance to the Javascript of yesterday. On top of that is a plethora of tools and frameworks you're expected to know. It's its own world. But, there's really good money there and lots of work. Consider moving into that arena if you can. JS frameworks are so many out there. I do see those jobs and they pay well. It's more of a front end dev role which 180 degrees from my background. I'm all for learning React to add one mature framework/popular/pays more money, to my roster to make a good profile and become more attractive to employers. Instead of just saying backend end developer. Plus I see React in addition to Spring in the job reqs all the time. To be honest, I don't they are looking for someone with design sense on those projects .. maybe they do..I don't know..is a full stack developer expected to be as good on the front end as a dedicated front end person?
OSGi is great at what it does. The capability/requirement model is invaluable and there's nothing like it elsewhere. Declarative services are pretty bloody useful too. The module layer is the largest and most complex part of OSGi, and the part that is incompatible with the JPMS model and AoT, but they're looking at making it optional in future releases to keep OSGi relevant. https://github.com/osgi/design/blob/master/rfps/rfp-0196-OSGiConnect.pdf
&gt;Point of fact: Spring's not new. It's been out for over 17 years :) It's a standard framework. It's a collection of libraries and services. Its MVC library serves the same purpose as Struts. However, where Struts stalled in its evolution, Spring continued to be developed. JSPs still have some relevance but it's pretty minor and scriptlets are outright discouraged. As they say in car sales, new to me! Well! it's good news in that it had a long time for it to be accepted as the go to framework for lot of employers so learning it would be beneficial! &amp;#x200B; Yeah! even I know scriplets were bad! :-)
Thymeleaf is the default for Spring Boot, and it honestly isn‚Äôt great. Most templating is just done via the front end frameworks, as it makes less and less sense to continue server side rendering.
New to you, yes, but its history and standard adoption means there is no shortage of tutorials and reference materials. Happy learning!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Spring itself is old, nearly 20 years. Don‚Äôt learn that. Spring Boot is a refresh that does away with all the nasty xml that Spring relies on, and is a modern framework.
It looks like in your [submission](https://www.reddit.com/r/java/comments/c9qy7s/what_do_you_use_for_background_jobs_in_java/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Or Angular, unfortunately.
After some comparisons we definitely hated Thymeleaf syntax and chose FTL for our new templating needs; matter of taste really. Until now we were using JET and in-house tools. But those are for desktop/server-side, file generation level stuff. On the frontend, we definitely use Angular or similar frameworks now, interacting with java REST services (SpringBoot here, but could certainly be raw servlets or whatever else floats your boat). As of JSP, the cardinal sin of this tech is that is makes it too easy to weave arbitrary Java code in your templates, muddling up separation of concerns completely. I maintained (inherited!) pseudo MVC apps where some JSPs had a controller role, and other, presentation-level ones directly queried the database to fill data lists... Of course any tech can be abused, but JSP made it all too easy if teams did not apply strict guidelines. Hence the shift to "lower computation power" in new templating tools.
Solid choices!
Don't bother with manually handpicked frontend libs, leave that to people with too much free time. Pick one of Angular/React/VueJS and study some tutorials/read a book about it. Perhaps develop a small app with a REST SpringBoot background (the ubiquitous TODO list perhaps?) and you're good to go!
Then someone will come with the rule "code smell: 'If' in method name"
I have never, in my over 15 year career, seen JSF being used. Do companies just have a bunch of legacy apps or is this still being used for new projects?
I would recommend Docker too, as a way to manage devops deployment. At least, how to build a container (docker file) and understand basic concepts of swarm architecture
I wouldn't call it a modern framework (personally biased because I hate annotation driven development) but it's certainly a huge leap forward from OG Spring.
Yeah Spring is pretty ubiquitous at this point. The REST API portion is used pretty much universally by anyone providing a REST endpoint in Java so I'd start there. Also knowing Maven or Groovy would be useful for dependancy management and perhapd a dependancy injection framework like Dagger or the CDI if your using enterprise Java.
The cloud is just an ecosystem to deploy code into in this context. You'd compile and build your JAR locally as part of a Dockerfile (or on a CI server if you're running pipelines as part of what you're doing), push that up to a docker registry, then use some kind of orchestration tool to run it in the cloud which will pull it from the docker registry you pushed your image to, like AWS ECS/EKS.
You forgot "off-by-one errors" :)
&gt;I feel Spring boot is bloated Same here, it's unlikely for an app to use all the features of the framework, but everyone has to deal with the complexity of all these layers of indirection that enable them. After a couple debugging sessions through the framework you get a feel for it, but it's still hard to keep in your head.
I'll have to try it. It certainly doesn't accept the projection type as a constructor reference.
Spring is everywhere, (although ironically I don‚Äôt use it at my current workplace) I interviewed for a Java role a few years back and read Spring In Action cover to cover as preparation for the interview, it really helped. If you are looking to go down the big data route then Designing Data Intensive Applications is a good read too, not as Java focused, but useful. Clean Code, is a good refresher, although ‚ÄúUncle Bob‚Äù is a little opinionated and I don‚Äôt agree with everything he says. I also read Hrad First Design Patterns cover to cover its pretty good, although I‚Äôm guessing you know everything in there. Banks hire older developers, a lot of Silicon Valley startups may not, ageism sucks, and it illegal in most jurisdictions but it exists.
Is that Oracle JET with angular? I thought it needed jQuery/knockout?
You might consider pivoting to a devops or sre role. Basically, learn how to automate cloud deployments and the glue and admin of running software. I think your experience can help you here assuming you have been involved with the running of production software over your career. Meaning, if you understand how to make good choices in architecture, then you can help here because enterprises often hire people to specialize in devops and help various Dev teams. I think being a battle tested sort of person can help here.
Uh, no, I conflated two subjects. We use(d) JET for files/code generation, not for serving HTML. Sorry for any confusion.
Yes, only a wrapper that just delegates a call doesn't break SRP. But it must not return a result, because then it could be named "delegateAndReturnResult" therefore breaking SRP.
It looks like in your [submission](https://www.reddit.com/r/java/comments/c9s1ss/attributes_in_serverwebexchange/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Oh, Eclipse JET.
&gt; Spring is used everywhere (unfortunately in my view but there it is). Care to elaborate why?
Spring boot is built on top of the spring framework, don't you think it's important to know how the underlying framework is working? Or at least be familiar with the concepts behind it?
Spring Boot does not have anything to do with xml being deprecated, that was a part of Spring 4. Spring Boot is a platform that allows to run standalone applications in a simplified manner, packing web servers if they are needed.
thanks for bringing the thread back
*149‚Ç¨ for the first year
Guy said All Products, which is 249‚Ç¨ in the first year. Sure, it gets cheaper afterwards.
Right, others confused me with: "What does ultimate edition have over community edition that's worth 249‚Ç¨?"
Care to elaborate why Thymeleaf isn't great? I'm learning Spring Boot now and I'm using it (albeit for learning projects), so I still don't know much about it. Is it because there are better alternatives for frontend?
Please read the messages again, I think you tunneled on some other case and you're arguing about it, when I'm trying to explain another thing.
Complexity and magic.
No I think I understood what your thing was exactly, which is why I mentioned Null Object. This is why I personally avoid mutators/setters as much as possible especially in vanilla Java (even with the option for Lombok tricks). Since we're going deep in this discussion, I'd say there's actually more to your setter example. Think about the time of construction. If you want this object to be a POJO, then you must provide a default constructor. What then do you set as an initial value to this field for which the setter won't accept null as argument?
Isn't \`if\` in a method name subject to the same issues as \`and\` and \`or\`.
Just for the record, I never said that I'm a fan of those rules :D &amp;#x200B; What's more important is to stick to certain conventions of a platform, so that projects can be uniform/standard within this platform. Bean convention is one of the fundamentals of Java, be it for legacy or whatever reasons. But we can have the same discussion to sonar rules, style conventions and so on. You have some valid points there, I can understand most of them. From my point of view a properties construct should have been the default ever since - in other languages, like kotlin for example, I use properties on interfaces very often, because then you can implement a lot of default logic in the interface itself.
its *
Mind some questions from a younger programmer? &gt; Make sure you're comfortable with modern functional programming and the new libraries and language changes in Java 8. I've been looking for decent tutorials on this, specially on method references and the weirder uses for lambda classes, but all I have found was just "Look, you can use it on this example" instead of "look, this works this way on this circumstances." &gt; Learn one of the widely used frameworks: Spring is used everywhere (unfortunately in my view but there it is). Where could I start learning this? The Spring ecosystem is huge (at least from my point of view of having done a bit here and a bit there). Spring boot? Spring security? Spring MVC? What are their relationship?
Migration took me about half a day, I already knew Spring Webflux quite well but I had never used the new CosmosDB SDK before (and in fact, aside from the CosmosDB developers, I think nobody ever has, as it's brand new and unreleased). Now I would just need 30-60 minutes to do the same.
&gt;Is ElasticSearch a Java shop Elasticsearch itself is written in Java. The company uses many languages. In the Cloud group (where I was) it's mostly Scala, some Python and some Go. &gt;what kinds of roles do they offer for remotes It's a completely remote company - other than some non-tech roles everyone works remotely around the world from home.
I feel like Spring is a McFramework - there's nothing inventive about it. It's bloated, run-of-the-mill, cumbersome, big and full of non-standard behaviors and magic. Spring Boot seems to come from their concern about being sidestepped by Dropwizard. They want to be a one stop shop for libraries and frameworks and I don't think any of their offerings are particularly good. It mystifies my why it's so popular. Dropwizard is much better than Spring Boot (and I've used both extensively). I believe smaller is better and that specific, targeted libraries are always better than large general purpose libraries. Anyway, that's my .02 but I'm clearly in the minority.
Btw atlassian is recruiting remote workers heavily
It's worse when you have a simple method name which does several things. I had that one this week. Broke it into 3 methods.
The real news here is that: &amp;#x200B; &gt;Although this behavior is correct since we cannot know if the auto-commit flag was set or not, we could hint Hibernate to skip this check since we already know that all JDBC Connection s run in manual commit mode. &gt; &gt;For instance, all enterprise applications already use a [connection pooling solution](https://vladmihalcea.com/the-anatomy-of-connection-pooling/) which can disable the auto-commit mode when the database connection is firsts established. &gt; &gt; &gt; &gt;HikariConfig hikariConfig = super.hikariConfig( dataSource ); &gt; &gt;hikariConfig.setAutoCommit(false); &gt; &gt; &gt; &gt;For this reason, in Hibernate 5.2.10, we introduced the hibernate.connection.provider\_disables\_autocommit configuration property which tells Hibernate that the underlying JDBC Connections already disabled the auto-commit mode. &amp;#x200B; ..it took 18 years to get this particular performance bottleneck removed. So glad I've never even considered using an ORM library to handle my database reads and writes. Data access layer is far too valuable performancewise to ignore and writing and optimizing good JDBC SQL layer takes less time than it takes to learn and cope with the inefficiencies of an ORM.
Yup exactly this. Or you have a build environment line drone or Jenkins do the build on a server or in the cloud as well.
I don‚Äôt like Spring either, but from what I understand its popularity is due to the huge ecosystem. A bit like with Wordpress in php-land, there is now a plugin or library to do pretty much anything in Spring; so once you‚Äôre comfortable with the basics, you can crank out project after project just by gluing this and that lib. Spring Boot smoothed the learning curve enough that, by the time one realises the complexity, he‚Äôs already too invested in the plugin ecosystem to consider moving away.
You could use: - AWS Lambda (1 Million free requests per month) - RDS for mysql/postgres (free db.t2.micro with 20GB storage) - Amazon Simple Email Service ($0 for the first 62,000)
It's still running because there's no technology capable of replacing it (don't even mention JPMS).
Mustache and handlebars? That's a dated answer right there
So everything I'm going to say now has one big caveat, namely that there are companies out there with legacy stacks that aren't upgrading. If you're looking for info on the "modern" world, heres a quick summary of topics to study. 1) HTTP. maybe you already know this protocol, which would be great, but I've seen devs more used to older stacks and SOAP APIs or JSPs not be that familiar with it. HTTP is one of the main communication protocols for the web. It's really important to know this because... 2) REST. This is an API architectural style based on HTTP. If you know HTTP, REST is incredible simple to pick up, which is why it is so popular these days. Most Java apps today are backed apps that simply expose API endpoints. For API design, SOAP is on the way out, and GraphQL (the new hotness) is too new and hasn't been adopted widely enough yet. REST should be a focus of yours, because... 3) Java server applications. These are the apps I just mentioned. They tend to connect to a database, do any kind of data processing that is necessary, and expose API endpoints to invoke various actions. Java isn't used for front end developer anymore in modern apps, it is more just a system for handling data, security, etc that is invoked by a front end app. They are built with ... 4) Spring. While opinions can be mixed Spring is the de facto standard Enterprise framework for building Java apps. As someone who has built apps with and without spring, there are tradeoffs. On the one hand, spring abstracts away a LOT of boilerplate code and let's you develop your app faster. On the other a lot of what it does is black magic, so when something goes wrong you need to have an understanding of the framework, not just the Java language, to solve it. Fortunately spring is widespread enough that there are enough docs and stack overflow posts to help here. Also, it helps to... 5) Use Spring Boot. Spring Boot is designed to make spring faster and easier to use. It adds another layer of magic on top of the already magical spring, but it works very, very well. If you use spring, use Spring Boot. Period. And once you've done all this... 6) micro-services. Micro services aren't special, they're just a bunch of tiny, focused java apps that expose their own APIs. Once you understand the modern java apps I was talking about before, it's pretty easy to understand how to design for micro-services. And lastly... 7) JavaScript UI. If you've been working in java all your life this should be at the end of your list. But JS is the standard for front end development now. If you want to do front end work that's what you need to know. Hope this helps.
In: `r.method(a, b)`, assuming `method` is not static, that `r` is called the receiver and it is used for 3 separate things: 1. javac will use the compile-time type of the expression `r` to look up what type that is about, and will then use the compile-time types of all parameters passed, plus the name chosen, to look up a precise method signature. For example: `int foo(String, Object)`. 2. javac will then encode this signature into the class file and calls it a day. However, at runtime, java (the runtime) will use the ACTUAL type of `r` (which can be a subtype of what javac thought it was) to figure out the actual implementation of `int foo(String, object)` to invoke for it. Making implementations of methods from your parent types is called 'overriding'. The fact that the VM will always go for the most specific implementation is called 'dynamic dispatch'. 3. Finally, that method is invoked and at that point `r` is no different than `a` and `b`: It's a parameter; a thing that the implementation of the method has access to. It's that #3 rule where this comes up: You can annotate a parameter. For example to indicate 'it should be a non-empty string', or possibly for some documentation purposes. But given that the receiver is kinda also a parameter, how do I document properties on IT? What if I want to annotate a method on j.l.String to say: Some linter tool should probably throw out a warning if the linter tool can ascertain that the receiver is necessarily the empty string? That's where this exotic syntax comes in. You could do: `public int parseAsInt(@NonEmpty String this)` to indicate such a thing. The [checker framework](https://checkerframework.org/) is the only tool I know of that uses this feature heavily.
that's all nice in theory but it doesn't make for a good argument because someone might easily counter that almost all frameworks violate solid in one way or another and people are using them more, not less. and while he single responsibility principle is great in theory and I personally would stick very close to it if I was maintaining the code base alone, the fact is that 99% of the codebase is violating it. my initial question is what good arguments I can bring forward to get team mates to see it's wrong or is it simply that it's a _java thing_ and carry on and have to get used to it?
not sure I follow? how would you go about to encapsulate that logic?
that's my point, right. you can do both just by looking at the signature. I see `GetPromos` accepts a list of status ids and I know what's going on. my point was that this method name will have to get changed if we want something else than these 2 exact strings.
&gt; Unfortunately, Struts and JSPs are not really used anymore though you might find a company that does that. I would qualify that in being that nobody is really starting any new projects using jsp/struts. But in the DC area, there are a lot of ongoing projects and rewrites that **are** stilling using that tech. Hell, I just finished a project that started JS**F** from scratch, if you can believe. The government can be up to 20 years behind the current curve...
Not true at all. First off, the return value is in the method signature already, so that should never be in the method name. Secondly, SRP doesn‚Äôt mean you can‚Äôt have complex logic, just that the logic gets broken into many smaller methods. Also, it‚Äôs a principle, not a rule, so that there is wiggle room and it‚Äôs just a good indicator that you could break a method up if it has and/or in the name.
I usually do an enum with lambda to define its behavior instead of multiple subclasses
what about `conditionalSet` but I just assume that the latest APIs are much more mature in their naming schemes than the ones from Java 1.5 like `Map#computeIfPresent`. In the end, it is your choice to flag it as false positive
It all depends. If the method is used on multiple places with the same context, then returning another status would require a change in all callers and making sure they are all in sync, therefore a method name change would be the lesser evil. If it is not a business method, but rather just a DAO method, then sure, extract the parameter. Do not worry about code smell dogmas so much, remember that "Perfection is the enemy of good".
Unless you really do two different things like registerUserOrConfirmOrder, then it's all about the level of abstraction, the same thing could be wrong and right at the same time, and a method name does not change a thing about that, nor it is a good indicator. SRP is a just bad, arbitrary and subjective principle that people take as a dogma.
The problem with that is that it's not open for extension, though.
Oh I‚Äôm just saying that I like the fact that there‚Äôs a method, it‚Äôs just that as you point out the name is not good because it describes the method‚Äôs implementation rather than its purpose. Not sure what a good name would be since I don‚Äôt know the codebase, but maybe something like GetLaunchedPromos(), GetAdminPromos(), or GetUsedPromos().
Mind if I chip in? Spring is a bit of beast, and there‚Äôs a lot of ‚Äúspring magic‚Äù that goes on, but fundamentally, it‚Äôs actually really productive. If your new start with spring boot, how spring boot came about is MVC was such a pain in the ass that, they created an opinionated framework that‚Äôs much easier to work with. Spring boot will give you most of what you need to achieve most web based tasks. Spring security provides a tonne of interfaces to simplify/standardise doing security. Spring Data is kinda useful and plugged into any java project, though it works best with spring ecosystem. Personally it‚Äôs too slow for most of the work I do. My personal favourite is spring cloud, as I write a lot of streaming producers/consumer architectures, and I can bootstrap I spring cloud Microservice in about 30 minutes now. Spring batch is a bit of nightmare to get your head around at first, because beans and spring automagic, but super useful.
This is one of the best andwers I‚Äôve read in a while. Leetcode medium questions? What do you mean?
Jlink/modules is another area to look for startup performance improvements. Cutting out a bunch of unused classes has some pretty nice startup benefits.
&amp;#x200B; becoming familiar with Spring would definitely be helpful. Look into javascript frameworks for front end work and how to hook them into backend services, things like Angular and React or the new kid on the block, Vue. Take a look at using docker containers as well and become familiar with writing restful web services. Microservices have taken off, another subject to look into. I am a 64 year old software consultant, engineer and Architect and though I don't work from home all that much (I travel a great deal to various clients) I certainly can and do from time to time. Good luck!
Or thymeleaf as a more comparable replacement for JSP if I‚Äôm not mistaken.
Still not a great example. There's not need for the Function3 interface at all, just put the apply method directly in the main class. That makes much more sense for the purposes of the demo. Also, it's probably better to reintroduce the Strategy class as a functional interface rather than using BiFunction. The philosophy of the Java approach to lambdas is that names are important, and personally I'd rather see that being embraced than see a bunch of ugly generic types with a million parameters thrown around everywhere.
There are better, more modern template languages, like [Closure](https://github.com/google/closure-templates) which aren't limited to strictly java. But even those are now legacy and react is now a solid contender for both client and server rendering.
Not everything needs to be open for extension. Or should be.
Exactly. Keep the Java interface for the strategy, implement it as Lamba.
Microservices with Spring Boot and Cloud stuff like Docker and Kubernetes are the bread and butter of today's enterprise Java world. In fact we're hiring some people and have interviewed someone with a similar profile as yours without any modern framework experience. We did not hire him. You really need that current industry standard package. And if you don't have any experience with it, go learn it. Get certificates, do hobby projects or open source, it's a must to keep up.
&gt; In computer programming, the strategy pattern (also known as the policy pattern) is a behavioral software design pattern **that enables selecting an algorithm at runtime**. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use. -- [Strategy pattern on Wikipedia](https://en.wikipedia.org/wiki/Strategy_pattern)
It looks like in your [submission](https://www.reddit.com/r/java/comments/c9vt9d/efficient_data_aggregation_library_for_springboot/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
In this case it would clearly be against the pattern. The whole point of this pattern is a strategy interface. You can still provide predefined implementations, even an enum if you want that.
This is not exactly violated by having the implemention in an enum.
Hello everyone. All what you have posted here is so valuable for me, although I'm 32 at the moment, but I'm looking forward to nail a remote job opportunity in JAVA ecosystem. Currently I have 10 years of experience working in JAVA Enterprise applications and 4 years freelancing as a FE Developer with ReactJS, but I'm lacking knowledge in some of the areas you mentioned (like AWS, devops and Kafka), so I will put hands on to update my knowledge base. Living in El Salvador (central Am√©rica), do you think is possible to get a remote job paying $60K annually? That is my goal to start saving money and bring food to the table :)
An enum has a fixed number of constants. You cannot just load a JAR with another enum constant.
If you go to leetcode.com their programming/algorithm questions are separated by difficulty. The medium ones are the one to focus on, hard ones generally can't be solved in under 45 mins I guess
I already commented that on Medium, but you could actually use BinaryOperator&lt;Integer&gt; to make that BiFunction mess cleaner. Though when applying this in my code, I would probably make an own interface that uses the primitive type anyway.
Hadoop is three things--HDFS, YARN and MapReduce. The first two are used heavily, MapReduce not so much. HDFS is pretty simple (the secret is you need to format a namenode if you want to recreate a cluster, that one was a nightmare to figure out). YARN is the scheduler and it gets used by Spark under some circumstances and also a lot of Cloudera tools like Hue, Oozie, Hive, HBase etc. as does HDFS. At this point most of working on that stack means working on the web interface of whatever flavor of abstraction someone really wants. I remember at a previous job interviewing someone who stayed at a place with bad tech too long and all he could do was VB and Coldfusion. It's unfortunate that there's such a huge disconnect between recruiting and engineering that they just do keyword searches on your LinkedIn, but at least there are tons of jobs finally. The big thing with spring is dependency injection, if you know that phrase you'll get hired probably. AWS is extremely useful and it doesn't take a lot to become familiar with it. EC2 are VMs, Security Groups tell you which nodes can talk to each other, IAM roles serve the function of SSH keys along with read/write privileges for users.
the enum implements the interface, any can.
I live in Panam√°. That‚Äôs a very reasonable number depending on your experience. Try http://remoteok.io and Stack Overflow as well as upwork and toptal.
Being able to select an algorithm at runtime does not imply that the mechanism is arbitrarily extensible. Having a fixed set of implementations to choose between is a perfectly valid approach.
With that you would still have an interface making it open for extension.
You are treading a narrow path as your *self promotion* ratio and frequency are too high. Nobody here wants self-promotional spammers. **Removed** and one and only warning. Next such post will be your final exit from here.
Government projects and internal applications are still being made using jsf (and libs like prime faces). It's more and more SPA's + JEE/spring backend, but it does still happen where I live.
Use reactive streams like Flux &amp; Mono in Spring reactor, and the parallel implementation becomes trivial. Additional benefits: * Customizable error handling * Retries and timeouts are one-liners * local and global parallelism limits to ensure no operation saturates thread pools and DDoSes downstream dependencies * Cancellation propagates both forwards and backwards. * Rich composition operators * Backpressure support.
They include a lot of their own libraries in their starter packages, but if you're just looking for a dependency injection framework, you can just do that. Not quite sure which offerings can be categorized as "not particularly good" either. Their resttemplate, for example is great (though I do prefer using okhttp where it makes sense), so is spring data (IMHO, although it's probably the lib with the most magic in it. I also prefer jdbc over data/hibernate for anything that's not simple CRUD). Spring integration, and of course their dependency injection are all great IMHO. I can see that things like spring security can be rather clunky, and they indeed also include what is essentially their own (and in fact lesser) version of apache commons lang3 and part of guava for some reason, but most of it is very nice to use, well documented, and it has a large community, making it easy to troubleshoot when you run into issues. It's also true that it's fairly bulky by default (50MB jar for a Web- starter with little to no functionality), but many of their starter packages contain a ridiculous number of features. if you're building a rest api, you can do that with the Web- starter, but that does include thymeleaf, mvc and more things you won't need. You can obviously build a slimmer spring app by adding only what you need. The biggest gripe I have with it is how bad it is for microservices (same for jee and most other java frameworks). An app using 200+MB of ram, and taking upwards of 10s to start isn't very good as a microservice, especially not when working in tandem with a container orchestration engine (doing DR tests was a joy - starting ~20 spring boot apps on 3 servers is not something I recommend trying). Something like Redhat's Quarkus works a lot better in that regard or, y'know, something written in golang that uses 20MB of memory and starts in less than 100ms.
It's not a "trick" but I like using map-reduce a lot. For example: `BigDecimal itemsTotal = sale.getItems().map(SaleItem::getTotal).reduce(BigDecimal.ZERO, BigDecimal::add);`
Using \`Class#getGenericSuperClass()\` as a hack to represent generic types in metaprogramming. Example implementation: [https://github.com/google/guice/blob/master/core/src/com/google/inject/TypeLiteral.java](https://github.com/google/guice/blob/master/core/src/com/google/inject/TypeLiteral.java) \`new TypeLiteral&lt;List&lt;String&gt;&gt;() {}\`
We use it, never seen it anywhere else. It‚Äôs alright i guess
To be honest, you could have killed the Strategy Pattern even without lambda.
JSF is way better than JSP. Used JSP (with a lot of Java code inlined!!) in a previous gig. JSF is incomparably better, it's a component based framework, you'll need to know a bit about JS &amp; CSS to make functional websites but I think it's fine.
Thanks you for your reply! Is Kubernets and Docker something one can practice on their own in AWS or let say local machine. I understand in an enterprise setting usually you have the build server but if I'm at home, an all in cloud way would be optimal.
Thanks you for your reply and help, much appreciated! I think one solid framework like Spring, React on the FE is a must. Spot on with Docker and restful/micro web services. Great to know that you are able to do great in those roles!
Thanks you for your reply, I will take a look.
Thanks you for your reply! I appreciate your thoughts. DevOPS looks little too much fighting fires type role and to be honest, I don't think I've the aptitude for it. Trying to stay either on the architecture. client facing, dev remote work which is not always tied to real time stuff meaning I get some piece of work assigned, I do it and be done. With DevOPs, someone asks you to do something and they are literally waiting on you to do builds, deploy stuff etc. I get your point though for sure, could be great transition for someone who may be interested.
Thanks you for your reply! Thank you for book recommendations, I've heard of those come up frequently in these discussions. I'm not strictly following Uncle Bob, will pick up what I like from his style and leave the rest. &amp;#x200B; Head First series is a good for and have come across them in discussions but haven't read any of them, will take a look. &amp;#x200B; Yeah, Silicon Valley is all about young blood, no kids, no mortgage payment and people who can pull all nighters..I'm sure not all of Valley is the same but more established (read boring )companies offer great work life balance some times .. and I'm looking for remote only to boot anyway!
Thanks you for your reply! I've used Maven and have familiarity with Spring (read about it, watched tutorials)..it looks great and certainly a must have these days!
Yeah, that's good! Plenty of resources and jobs! Age helps sometimes :-)
Good tips. Thanks.
I think this is a misuse üòâ and not extensible.
&gt; a strategy interface. The strategy interface contains one method. The interface of that enum can also contain one such method. I fail to see how it is against the pattern.
Has anyone tried using Strategy Pattern with spring autowired ?
And in a class/method name usually implies multiple responsibilities, the opposite of what you want.
If you were starting a small to medium sized project - nothing too fancy, mostly crud and it isn't a consumer app, just internal business - would you say that JSF is better and faster than using the full SPA style with Node and React and all that crap?
It looks like in your [submission](https://www.reddit.com/r/java/comments/ca0jtw/question_about_java_se_8_programmer_certification/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
How about: ~~~ interface Strategy { int eval(int a, int b); } final enum BuiltinStrategyEnum implements Strategy { ADD, SUBTRACT, MULTIPLY; final int eval(int a, int b) { return switch (this) { case ADD -&gt; a + b; case SUBTRACT -&gt; a - b; case MULTIPLY -&gt; a * b; }; } } ~~~
Much better
&gt; Part of me really likes the idea of just dragging and dropping a bunch of form components Well the way we use JSF is not really like that. It's primefaces and you are programming to their API. Everything is hand written, no GUI build tools involved. I like it because your java programmers can knock out web apps quite handily (if they know a bit of JS &amp; CSS as noted above) . If you are from Big Co,. then you probably have a distinction between front end &amp; back end programmers so using React etc. would make more sense in that case because that would be their specialty (front end guys that is)
"Manipulating the compiler" sounds like FUD. Lombok uses JSR 269 annotation processing which maps over Java AST. This plugin framework to the compiler was specifically designed for such use cases, and this is conceptually not significantly different than languages that allow manipulation of AST through macros, etc, just invoked as a phase in the compiler.
Yep, we're in the middle of going down this route, building out a backend-for-frontend type service which pulls all the related data from different upstream services for the client apps into single endpoints. Reactor is making it a dream (though I'm more used to RxJava)
And these developers are making 100 to 200k a year and they baulk at the idea of 200 dollars to jetbrains for a product that is possibly 80% of their day. And most of the time your employer is paying it. It's like a carpenter getting annoyed that a bosch power drill is not free.
100% agree.
After using Eclipse since 2011 or so, I tried the Intellij CE for Java and couldnt get It, frankly. Not to mention I thought my poor laptop was going to explode Just opening a project. I prefer the way eclipse works in almost every way. The only things Intellij got it far better than Eclipse was the dark theme, the rest didnt seem really worth my time. Nowadays I Just use it if I'm doing Android development with Android Studio.
Well, it isn't. Maybe before calling fud you'll do the five seconds of research it would have taken to verify what I'm saying. https://github.com/rzwitserloot/lombok/tree/master/src/core/lombok/javac Lombok uses a significant amount of compiler internals above and beyond the annotation processor. That's because it is doing much more than just generating source or bytecode.
No Android support is sad too
What does it have to do with SRP?
Good idea ü§î
You can extend function types in kotlin as well ``` interface FunctionEx&lt;T, R, X: Exception&gt;: (T) -&gt; R { companion object { fun &lt;T, R, X: RuntimeException&gt; noException(function: (T) -&gt; R) = function::apply } override operator fun invoke(input: T): R fun tryInvoke(input: T): R = try { apply(input) } catch (x: Exception) { throw new RuntimeException(x) } } ``` unless i understood your orignial comment wrong
~~~ enum BuiltinStrategy implements Strategy { ADD((a, b) -&gt; a + b), SUBTRACT((a, b) -&gt; a - b), MULTIPLY((a, b) -&gt; a * b); private final Strategy strategy; BuiltinStrategy(Strategy strategy) { this.strategy = strategy; } @Override public int eval(int a, int b) { return strategy.eval(a, b); } } ~~~
kotlin is quite easy to grasp if you already know programming and the java eco. and its interop with java makes it a great language for anyone looking to mix the 2 languages in a project in any capacity. ``` data class ClassWithData(val id: Int, val name: String) { var state: Int } ``` vs ``` @EqualsAndHashCode class ClassWithData { @Get int id; @Get String name; @EqualsAndHashCode.Exclude @Get @Set int State; } ``` lombok is neat, but personally i will take the easier to read kotlin
My enum can implement the interface and implement the method by delegating to the lambda.
In that case I misunderstood you. I thought you didn't provide an interface at all.
If you like annotation route and you are already using Spring then you could just use [@Async](https://spring.io/guides/gs/async-method/).
This example doesn't show how you pass / access the strategies (in Java). You'd need to either wrap the `Function` in a class as a field, keep it as a static variable somewhere or register it in a singleton accessor. I prefer the first. But then the `Function` is not really needed anymore. Full circle back to the original pattern.
Nothing wrong with using JSF, is there?
As soon as you're autowiring an interface you're using the strategy pattern.
Sure, so I essentially use the ‚Äòstandard‚Äô strategy pattern with auto wired. I am wondering if there are any benefits using autowired with java 8 functionals. Any thoughts ?
Yes i agree with you. This sample try to show the concept and can be better.
You'd have to put the Function inside a class (field or method). This defeats the purpose, as then you might aswell use the standard pattern without indirection. So no benefit in this as long as the language doesn't support free floating functions
It's just a little dated. The processing of the UI is done on the server, where most modern front-end work realized that it'd save processing power making the client do most of the rendering work, so it's easier to scale with non-JSF tech than it is with JSF. But if you know the needs are few (internal, limited market), JSF in and of itself is still viable.
I know people here really love to help others, but this should honestly be in r/javahelp I think a major problem is there is no intermediate subreddit for questions like these and r/java has just become a dumping ground for all questions.
Eh, he asked specifically for backend templating. Thymeleaf and freemarker are good too for more logic full templates. But sure, the not dated answer is do your templating on the front end with jsx/angular/js flavor of the month.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The first letter in method name should be lower case to match Java naming convention
And it's missing a parenthesis. But other than that, it's perfect!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I tried following DropWizard's guide but there's not really any relevant information on how to configure your project to connect to an external DB Here's the project https://github.com/SixteenDollars/help
Lets add Freemarker / FTL. I think both Freemarker and Thymeleaf allow rendering templates by an arbitrary service at any time, independently from requests, allowing to dynamically glue websites together from server-rendered parts. From my experience this is a hassle to do with JSP.
I use VSCode for JS/TS (frontend) in addition to Eclipse for Java (backend). Eclipse is not good for Javascript, while VSCode definitly is. Imo VSCode especially shines when there are a multiple small amounts of various languages involved in a single project due to it embracing the language server approach with tons of PROPERLY WORKING plugins. Big IDE for Java, VSCode for that single python file or templating languages, SASS etc..
How can there be a war? Different frameworks are created for different purposes even if they achieve the overall same results. Look at all the web frameworks for java, they all allow you to build web services, but some offer full fledge ee support while others are meant to be more light weight. So I think saying one framework is better than the over all is like saying apples are a better fruit than oranges.
It looks like in your [submission](https://www.reddit.com/r/java/comments/cacly1/can_you_help_me_please_due_tonight/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I've been getting some good results with Vert.x lately. It seems very easy to learn although I think some of the framework could do with some refactoring to bring it in closer with some of the newer Java programming paradigms.
&gt; Or there are other players there? [RxJava](https://github.com/ReactiveX/RxJavaReactiveStreams)
Play Framework (uses akka)
If anything, RxJava is the biggest library on Java.
Well you have the base Reactive Streams interface that a lot of frameworks implement. The common interface allows for interoperability. The primary choices IMO are Spring 5/Project Reactor, RxJava, Akka, Ratpack and Vert.x.
can anyone think of a good example that would allow for an apples to apples comparison of several different reactive frameworks ? is there an accepted canonical problem ? &amp;#x200B; ideally you'd be able to test implementations to characterize performance
[Armeria](https://github.com/line/armeria) also support both its own stream implementation and [RxJava](https://github.com/line/armeria/tree/master/rxjava) integrations.
&gt;..namely that there are companies out there with legacy stacks that aren't upgrading. Yup! there are just like Mainframe lives on .. &gt;...Spring is the de facto standard Enterprise framework for building Java apps This is a good thing in that if one can master it, it's good enough for few years at a minimum (certainly longer but even in worst case) and will get people jobs. Even longer term, once companies have invested in their applications developed using Spring, there'll be need for maintaining them so it's a safe bet .. need to get on it! I may already be little late to the party ..but I can pick up based fairly quickly. One of the challenge is to look for straight to the point resources/books/tutorials that are designed to take you from fairly new to decent enough level.. would appreciate any recommendations in that regard. &gt;Use Spring Boot. My understanding of the Spring Boot is that it's a result of some painful experiences with Spring (classic?) and is designed to get you up to speed quickly and address the "lessons learned" from the "normal/regular" Spring. &amp;#x200B; So if starting with Spring Boot, would it help to understand the overall Spring eco system or is it more scaled down version and lacks some of the features that you may get with Spring? Not sure if I'm wording the question correctly. &amp;#x200B; &gt;JavaScript UI. This is interesting to watch. JavaScript's reputation back in the say was a second class citizen in the web application world..relegated to client side validations and maybe navigation and menu helpers etc..JQuery added some spice to it..now it's a very different world. Full fledged UI frameworks like React, Angular and Vue are all the rage. I would love to at least master React..it's really completes the loop on backend to front end dev cycle.
You're very welcome. To address a few of your additional points. You don't need to learn "regular" Spring separately before learning Spring Boot. What Spring Boot brings to the table is just a rapid way of getting your Spring application up and running. It eliminates virtually all of the initial setup configuration, of which there can be a LOT, and let's you get straight to coding. When you're actually coding, you're using "regular" Spring. Repositories, dependency injection, config injection, transaction management, AOP, MVC, etc, etc, etc, it's all "regular" Spring. So I would not say you need to specifically avoid Spring Boot in order to learn it. Any lessons on how to use Spring Boot will also be teaching you all the important "regular" Spring stuff you still need for it. As for how to learn it, Udemy tends to be my favorite site for coding courses these days. I took a good one about Spring Boot before I started my latest job, because I was coming from a shop that had an excessive anti-framework culture (and I feel we suffered greatly from it, IMO), and I wanted to give myself a refresher as I hadn't touched Spring in several years. As for JavaScript, it's come a LONG way in recent years. On some levels it still has its standard defects (== is still broken due to type coercion, dynamic typing still sucks IMO, you only have prototypical OOP, etc). However, starting with the release of ES2015, JavaScript has been heavily overhauled. If all you're familiar with is the old JQuery-using JavaScript, I would recommend studying ES6/ES2015 (they're the same thing), because a lot of the old pain points of the language have been resolved. Add to that all the new frameworks and libraries, plus node/npm/webpack, and you have a development experience that is much, much more robust than ever before. I'm actually quite fond of it, and I used to be a big JavaScript hater. As a Java dev, I would recommend focusing on the Spring side of things to start with, but once that's done (and you've taken the time to learn ES6/ES2015 JavaScript), learn React. Yes, any JS framework recommendation risks opening up a massive flame war, but I would recommend it for two reasons: 1) It's really good. I've actually taken the time to write apps in Angular, React, and Vue. They each have their own strengths and weaknesses, but I would generally choose either React or Vue if I had total control over a tech stack for a project. 2) More job opportunities. Angular is doing better in adoption numbers than some of the forum chatter might suggest, but it's nowhere near where React is at. Vue is wonderful, but it hasn't gained a lot of market penetration in the USA (Asia is another story, however). Anyway, hope this helped. If you have any other questions, feel free to poke me.
I just finished learning basic java and there are many free java tutorials out there that might not get you a degree or a certificate but teach you what you need to know. look around on the web. lots of stuff
go with vert.x
Vert.x would be my go to as well. Lighter and faster than anything else out there, and easier to understand/test IMHO.
Using the [Manifold framework](https://github.com/manifold-systems/manifold).
Assuming you know the basic stuff about java (statically typed, fully object oriented), do some research into java web frameworks. The most populer one is the Spring framework. To quickly get started in doing java web backbends, look at Spring boot. That's pretty much the industry standard for java backend.
Possibly JHipster. It's a project generator that will produce both a Spring Boot backend and a Angular or React front end. You can use it to see how various things are implemented and explore a complete stack.
Not tried Vert.x, but Rx has very similar syntax to reactor. I originally was using Rx but Switched to reactor because for some reason I couldn't get the thread hooks to work in Rx for things like MDC storage etc, that and spring data / webflux natively supports reactor.