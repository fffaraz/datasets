Of course. If the programmer knows how to do it, they can mask `0x80` onto Java generic types, [as has been proven](https://redd.it/4l5e3u)
This pretty much explains why turing complete types are a bad feature.
&gt; BTW - Do not paste that into Eclipse [You can paste worse](http://cseweb.ucsd.edu/~atl017/papers/pldi11.pdf) TL;DR: Paste this: interface I&lt;T&gt; {} class C&lt;P&gt; implements I&lt;I&lt;? super C&lt;C&lt;P&gt;&gt;&gt;&gt; { I&lt;? super C&lt;Byte&gt;&gt; whoops = new C&lt;Byte&gt;(); }
But that would almost be sensible...
I think he was saying that the same code is generating the garbage, not collecting it.
Hmm, can't be too bad. Let's see, open class, paste... An error. Ok, let's just close tha... crap.. now there's two! Ok, we'll just ... fudge. There's like 8 of them now. Ok, so now I'll .. One second.. why are my feet wet? Is that a tentacle?! Oh God NO! WHATEVER HAVE I DONE!!! The horror! My eyes! Vision.. dimming... ^(;,;)^ ᴵ ᵃᵐ ᶜᵗʰᵘᶫᵘ, ᶫᵒʳᵈ ᵒᶠ ᵗʰᵉ ᵈᵉᵉᵖ 
Ok... that is officially not funny. I love how type parameters are almost always one letter long; as if everybody has permission to get fully stupid just because it's a type parameter instead of a value parameter. Am I the only one that hates that?
&lt;T, K, A, D, M extends ConcurrentMap&lt;K,D&gt;&gt; makes perfect sense.
It's really nice to read good news for a change
Not wishing to be a complete debbie downer but.. the first trial in the case which lead to this one, regarding whether apis are copyrightable, ruled they were not - oracle then successfully appealed, which meant they could launch this case. Oracle is far from out of money; s'not over yet
&gt; Oracle is far from out of money; s'not over yet Yes, it's still good news nonetheless. I just hope it won't go on forever like SCO vs. IBM.
Well, it's logically consistent, and maybe even provable. But to what degree does it represent any degree of readability? I know... words. So bothersome! Should have just stuck with machine code amirite?
Congrats Google. 
I never fully understood Oracle's argument. I can see a trademark infringement or even a patent infringement, but simply making your own version of an API which requires copying the declarations didn't seem like nothing more than fair use. Unfortunately I'm sure this will be appealed.
That's true, but more of a problem of the justice system itself - you can do the same thing even more effectively with patents against smaller companies. With Oracle vs. Google it would probably end in a big patent war, in which both would lose lots of money (that is my game-theory inspired guess as to why that hasn't happened yet).
Not all overflows are an error. Sometimes we want rollover. Here's a possible use case where we need to return a 16-bit value that rolls over: short seq; ... seq++; return Short.toUnsignedInt(seq); Before Java 8 you used: short seq; ... seq++; return seq &amp; 0x0FFFF 
Probably helps Java's freedom - beyond Android.
To be honest, Oracle/Sun have done reasonably good job as the custodian of the Java specification.
They just need to buy the jury or the judge to win. So Oracle will keep trying until Oracle or Google get tired enough.
woke up...made my day
As a new software dev I have no idea what the rulings of this case mean to me writing software in Java and Android. Law was never my strong suit
/r/fuckoracle 
I did a small pet project recently and found that whenever you need to do something that's not a really basic CRUD operation it's simply more convenient to use spring's JDBC template than it is to use JPA. jdbctemplates / other spring data stuff take away some of the annoyances of plain JDBC (so many SQLExceptions!) while still letting you use good 'ol SQL.
Does it has to be so complicated? private &lt;T extends Thing&lt;? extends ListingData&gt;&gt; List&lt;Thingy&gt; getInfo(List&lt;String&gt; idList, Class&lt;T&gt; typeC){ If you have everything typed and wrapped in class, this alone does not mean you have object oriented code. After seeing your Java 8 lambda code, I think I will stay at Java 7, no offence. Thanks for reddit API samples thought. Very useful. 
Aside from scaring everyone away from it. This lawsuit has been a PR disaster.
What gets me here is copyright is supposed to protect non functional pieces such as artwork (as I understand it). How fucking stupid do you have to be to be convinced that computer science can be considered an art. WE MEANT THAT FIGURATIVELY GODDAMIT
There's an implementation available. See https://github.com/eclipse/eclipselink.runtime/tree/master/jsonb
"Entry level position, minimum wage, requires 30 years experience writing cpu microcode, pls apply within!"
I think the problem is generics can get so verbose as it is that people want to keep it short. I don't find it difficult to read *most of the time*, for example with a Map it's rather easy to understand what K and V are. In more complex cases it can get very unwieldy and I agree some descriptive names can help.
You're on your own there bud. Sorry.
Oracle's argument is very simple : they think that INSERTNAMEHER's money should be theirs.
Thanks! Doing our best.
It is a bit silly the way they hold the word "engineer" in such a high regard. On the other hand it's amusing seeing people in the U.S basically use it for every job you can think of. 
[removed]
[removed]
Do you know the [Axon Framework](http://www.axonframework.org)? &gt;The axon framework is focussed on making life easier for developers that want to create a java application based on the CQRS principles.
Superb thank you!
Does Arun's blog still qualify? Lately he blogs only about Couchbase (his new gig). 
There are more blogs that may interest you. See them at: http://www.topjavablogs.com
https://antoniogoncalves.org/ had two postings since October...not exactly kept up-to-date
Pretty much every blog here is related to Spring, Java EE, SQL, and similar technologies.
I think the issue is that java apps require the jvm to run. Native apps only require your OS. So as average Joe user I'm going to prefer the simpler native executable that I'm used to. Average Joe developer knows this, so when they go to make a new app they have to decide between "write once, run nowhere" and "write twice, and maybe someone will actually use it (or just target windows and everyone else is out of luck)" All of that is referring to desktop apps though. I think you'll find that in the enterprise world java is more common because it's not about appealing to the everyman user, it's more about stability and keeping costs down. Combine that with the fact that writing software for multiple platforms really isn't that hard these days with .NET / Mono. It's really almost as simple as just compiling the same code base twice (as long as you're not doing a bunch of OS specific stuff).
There are a few decent Java desktop applications, most prominently IDEs and other development tools. And there are quite a lot specialized Java applications that were developed for in-house use or for niche markets. I guess the main reason why Java is rarely used for general purpose desktop applications is the lack of user acceptance. Java applications don't blend in well with the native applications of the operating system. Their look tends to be perceived as dated or even ugly and it's not easy to integrate them well into the infrastructure of the host operating systems without a considerable amount of native code that needs to be different for each platform. Also requiring all users to download and update a Java VM that comes with a ad-ware installer is not exactly beneficial in gaining acceptance among potential users especially of smaller tools for which Java would otherwise seem ideal. Although Java 9 could bring some improvements in this area. For mobile apps you would need something that makes it possible to provide a common environment API for all platforms and to be able to execute Java code on all of them. Microsoft already made some efforts in that direction: http://juniversal.org/ but it's unclear whether this will ever be solid enough.
Just now, reading your comment, I have active two Java desktop applications (IntelliJ IDEA and Free Rapid Downloader). So it's not like there aren't Java applications or they aren't used. On a side note, both are distributed with their own JVM, so the other comment about "disadvantages" of Java apps requiring JVM installed by user doesn't really hold. Or are native apps "disadvantaged" in a way, that user is required to install OS? Sounds funny. PS: I think there were some crazy stuff going on with GUI things in Java (long not solved issues, lack of support, walking away) and .NET land GUI-wise was (is?) more reliable, coherent, nicer to write in* and nicer looking without any effort. *: Tried writing simple GUI app in Scala Swing - ended with patchwork containing a lot of accessing lower layers b/c Swing (or Scala Swing?) didn't support basic features like tray icon. I was quite disappointed because in .NET/C# I was able to mash app together in a fraction of time, better looking and with same functionality.
Azureus, a few other peer-to-peer clients, IDEs, SQL Developer, to name a few. Pretty sure that there was a brief burst where people finally stopped trying to make those cancerous Applets, went full-bore Swing and it turned out OK, and then Python GUI apps went mainstream. Now if you're going to write GUI and it doesn't need to be performance-driven, then you might as well do Python.
It gets interesting in part 3, when the author finally starts to show how to use Xtext.
As someone using Java against his will, I'd like to quietly point out that C# can be used on Windows, Linux, Mac, Android, and iOS with very little porting thanks to Xamarin, which is now free. C# rules cross-platform, currently. Please don't kill me.
The average non IT person will probably never see a Java app outside of Android. Java is used mostly in businesses that have a need to build custom software to serve their needs. Because the Java eco-system is heavily supported by open source, it is very cheap to build a system with it. Building on Microsoft technology tends to be a more pricey due to licensing and expensive migrations.
Since no one has pointed this out yet: Java was designed to be multi platform 20 years ago, when there were dozens of platforms. You can count on one hand the number of platforms a user is likely to be using these days, so the "run everywhere" benefit is less obvious, but back in the days before smartphones there were dozens of mobile device manufacturers that all wanted to run apps. These days Java isn't really big in terms of user apps outside of Android. It's still huge in enterprise; aside from the monstrous market share of Web servers (Tomcat and every derivative), there are a lot of internal corporate desktop apps built in Java that you'll never know about outside their respective companies. 
What about all of those mods people made? Are they going to still package a JVM just to run them?
There are no plans of abandoning the Java PC version atm.
Again. This cannot happen if you download Java from the official Oracle sources. I did the same on countless computers (as administrator of a company) and never encountered a similar problem. Java - downloaded from the original sources - and best using the offline installer **will not do this**. BTW: Your unnecessary and unfair rant is just obnoxious. /r/Java is **not for dealing with Java technical issues**, it is for **News, Technical discussions, research papers and assorted things of interest related to the Java programming language** as is stated in the sidebar. Ranting about something without even bothering to post in the correct subreddit is really not OK. Therefore you receive a permaban from /r/Java.
Java wasn't so much designed for mobiles, as it was hardly a thing back then, but for settop boxes. Ironically, most settop boxes today are Android based, so in a way "Java" (note the quotes) succeeded in its original mission. Then a little later Java was retargeted not to unite the many consumer operating systems (there really was only Windows) but as an attempt to break the Windows monopoly. Back then Windows had the (unfair?) advantage that all apps were Windows. OS/2, Amiga OS, TOS, Irix and a coupe of others had already given up on the desktop. Mac OS was around but shrinking to below 1% market share in the US and virtually unheard of with consumers in Europe. Double irony that with Windows Mobile the situation is now reversed. All apps are for Android and iOS (write twice, run almost everywhere) and Windows Mobile keeps failing since it has no apps. Failing to capture the desktop and applet market, Java was delegated to the place were operating systems and CPUs that fail at the desktop inevitably end up; the server. And it does really great there! And the write once run everywhere actually plays out pretty well. People develop on a mix of OS X, Windows and Linux and deploy to Linux, BSD, and various other systems.
Thats definitely windows 10 is usually 64 unless it's a tablet or something.
&gt; package Models; The defacto Java standard for naming packages is to keep them all lowercase and use the reverse domain name of your own domain name. &gt; `enum Models.Direction` and `Models.Duck::move()` Instead of having a giant switch for each direction in `move`, you should instead store the offset directions in the `Direction` `enum` (using either `-1`, `0`, or `1` for both X and Y coordinate). Then accordingly use say for example `getXOffset()` and `getYOffset()`, then in move you just perform: `setX(x + (direction.getXOffset() * speed)); setY(y + (direction.getYOffset() * speed));.
It would be easier to read than what is currently there. As for performance, modern JVMs can easily perform the kind of required optimizations to make it fast. 
What about [FreeMind](http://freemind.sourceforge.net/wiki/index.php/Main_Page)? It's a very nice app written in Java that I find way too few people use. Also, I have seen MANY occasions where Java applications run on both Windows and Linux servers in businesses. I don't think this is what you meant, but it's an important niche.
&gt; has anyone used it? Yes. It is essentially the java version of [lex and yacc](http://dinosaur.compilertools.net/), making compiler generation simpler.
If you don't understand OOD, then OOP is pointless. That's the tldr of this blog entry. Accessor methods should never return references to mutable fields.
I haven't used JavaFX for anything too extreme (a simple calendar and media player) but it's FAR better than Swing could have dreamed of being. It's kind of upsetting though, because it doesn't seem to be gaining the traction I personally think it deserves. I think most people just think that Java GUI on the desktop is dead. It's basically WPF/XAML (used to use C# before moving to Java because I switched my primary OS to Linux) for the Java world. I'd personally recommend it. But, then again, I like C/C++ style languages, and while python is close it's just not my cup of tea &gt;.&lt;
That 0.0.3 looks really small though, [semantic versioning](http://semver.org) suggests using the third number as a patch version, so maybe 0.3 may be a better fit. But I don't want you to change versioning, it's a formal thing after all. It's just that it may confuse viewers of your library.
I really enjoyed Qt as well. It's a very polished API, their Qt Creator is the best C++ IDE I've ever used (other than Visual Studio, excellent piece of software, but I personally can't stand Windows) and its still under active development. Anyone getting comfortable using C++ and is wanting to move away from command line apps seriously needs to check it out! 
Very few people (there is a whole community of them), but the point was that Java is more cross-platform because it has implementations for many other systems no matter how old. As far as I know, there are no .NET VMs available for Palm OS or Mac OS 9.
&gt; a .NET VM That's not how it works. Mono works on Mac the same as Linux, and the Microsoft .NET Core now supports Mac too. It's a runtime, not a VM. &gt;Java rules cross-platform and it will for awhile So where's Java for iOS, Blackberry, Xbox, Playstation, and Wii?
How about www.buggybread.com. It seems like a nice Java site. 
&gt; Mono works on Mac the same as Linux Mac OS 9 != Mac OS X, completely different kernel and completely different software. &gt; So where's Java for iOS, Blackberry, Xbox, Playstation, and Wii? Blackberry: &lt;http://www.oracle.com/technetwork/systems/index-139239.html&gt; and &lt;http://developer.blackberry.com/bbos/java/documentation/introducing_sdk_1968206_11.html&gt;. XBox, Playstation, Wii: Homebrew by using JamVM with GNU Classpath. iOS: There is RoboVM, although Microsoft killed it older versions would still work. 
&gt; Mac OS 9 != Mac OS X, completely different kernel and completely different software. Ah. Okay. Didn't realize you needed to support legacy systems. &gt;XBox, Playstation, Wii: Homebrew by using JamVM with GNU Classpath. Homebrew? AHAHAHAHAHAHAHAHAA. Good luck pushing a product with it.
Depends on the company's desires. JamVM and GNU Classpath are both under the GPL, so they cannot be used in proprietary software. There are however other JVMs and libraries which they can pay a license for if they are not under a permissive license. But virtually all developers for game consoles would be using C/C++ from the official SDKs for the most part because they have their own engines written in those languages. Having a reliance on C# would be a risky move, because unlike C/C++ it is very recent and it could gets it support pulled. Sticking with C/C++ in game development is a far safer choice for a company to make. As for myself, I take a route which is not a dive straight into greed where you would kill your own users for a few dollars. Many companies today are just gambling in a quickly expanding bubble, if all their assets are in that bubble and it bursts then they go down with it. 
It's stored in `getRemoteAddr()` and `getRemotePort()`
&gt; Having a reliance on C# would be a risky move, because unlike C/C++ it is very recent and it could gets it support pulled. Tell that to everyone using Cryengine, Unreal, Unity, or most of the major cross-platform engines.
Firstly, what makes you think its dying? What does your application do? A lot of people say a lot, depending on the context. But here is my experience. I have worked on Java EE, Spring and Play. Play stands out and is in no comparison with these. First its good that you discovered play and its sad that you did not understand the edge with Play. Play is one of the awesome, best evolving Frameworks in my opinion.
My application is a combination of a data mining / web scraper, a reddit bot and a communication layer between a phone app and my computer. All of those with web interfaces (which is the main reason I decided to use a framework). I understand why Play can be really good in certain instances but having migrated the whole project to Spring Boot, it feels really nice to have Java as the main language instead of being pushed into learning Scala when i don't really to learn it. I really liked learning Play but now that I've been on Spring for the last month, I don't think I would switch back soon but I'll still keep an eye out for it. 
For every request, a thread is created and all the info about the user is present in the ThreadLocal object. A ThreadLocal keeps all the objects per thread.
I used it in making a small interpreted [language](https://github.com/nishtahir/ALang) a while ago. It's quite easy to use and reasonably well documented.
I have been looking forward to the configuration enhancements in 2.6. Thanks for the update.
Care to give a source? Because those are completely different versions. The PC version is still being active developed in Java. 
I was referring to game consoles. Also, if those engines are used then C++ would likely be chosen and not C#.
seems it was lwjgl I was using see http://bedroomcoders.co.uk/lwjgl-streaming-sound-with-openal/ (libgdx uses lwjgl as one of its backends) 
I am trying to put one out every day at around 19 CET(Central European Time)
I wonder why ~~these guys~~Oracle see the need to reinvent promises. There is an existing ~~language~~API for promises. Making up your own should not be done unless absolutely necessary. Edit: Removed stuff Edit 2: http://markmail.org/message/ia2ck3nzsakwre7a. After glancing through the messages in the link, it seems that the answer is largely organizational, rather than technical. Anyway, it's not terrible so congrats on getting the functionality into the language.
Well if you look at the first episode, "[Why Scala?](https://youtu.be/8rGCOejhZ7U?list=PLXcr3tdUCbQb6zjN6kw4s20joId2jygUe)", you'll see some reasons. At the time I made the change, I was taking a course on design patterns and Scala has some nice features for design patterns. For example, the [object adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern) is simulated via a feature called [implicit conversion](https://youtu.be/RZjaTqu4CMs?list=PLXcr3tdUCbQb6zjN6kw4s20joId2jygUe). You don't have to be "best in java" to use Scala. The two languages are method call compatible. 
I meant why create a new ~~language~~API for futures, not why do it in Java lol. What's wrong with the bluebird promise API, for example?
Cryengine and Unreal are pretty widely used across the major consoles for many big-name games.
Thanks. And does that file handler has a special name in the Java world?
If you're interested in this type of programming, check out rx java too. I've used promises or composeable futures in many languages and the rx libraries always end up being my favorite. They're very well thought out and part of a very comprehensive library. And yes, rx java does stream-like programming too. 
Third year student here. Scala looks nice but I'm afraid that the time spent learning it would be somewhat wasted since the jobs are scarce here for Scala compared Java. There may be one or two small startups that are a little more savvy with new languages, but the vast majority prefer Java, .NET, JavaScript, etc.. Not the best reason I admit. 
No, because you don't care or even know about it in the Java world. In practice it's hidden inside the socket. If you care to learn more, I'd suggest reading a C Unix socket programming tutorial, since that's really what's going on here. Back in the day, there was "beej's network programming guide" that I remember finding very useful 
I think they would have much better luck using Spring + Kotlin instead of Scala. https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin
Yes, by no means am I saying that a 0.0.3 is production ready. RE SemVer, I'm following item #4 http://semver.org/#spec-item-4
I can't seem to find any reason there, could you point it out? I'm here, but I don't see it: http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
Then why did you use Swing?
&amp;nbsp; Yeah. All the Scala jobs are in big data. Hadoop, Spark, Twitter stuff. &amp;nbsp; Scala has all the functionality to replace Java, but it's newer and people tend to stick to old stuff. If you just want to get a job, the easiest thing is usually to [learn whatever is in demand](https://youtu.be/ZZUY37RQS-k?t=1m49s). If Angular is in demand, learn Angular. If Java is in demand, learn Java. etc. &amp;nbsp; Looking back to when I was a student, if I wanted a job, the best thing to do would have been to get a letter that says I work really well with other programmers, to memorize common algorithms and be ready for algorithm questions, to get a really high GPA and a professional looking resume, to learn two or three really common languages (like Java and Javascript), to make interviewers like me, to apply EVERYWHERE, and to accept internships with the companies with the best reputation because their internships will look good on my resume. &amp;nbsp; Instead I have this: [https://dl.dropboxusercontent.com/u/214507961/JohnsResume.pdf](https://dl.dropboxusercontent.com/u/214507961/JohnsResume.pdf) 
Swing. Should have mentioned it in the original post.
Because it is very great server by Apache!
intellij is ready to update.
Is it? How does it compare to Payara that have supported Java EE 7 since the very beginning (for obvious reasons of course) and has a proven record on production? Why would I want to use it in my company?
The best way to describe it I think is a lightweight Java EE compliant implementation using Tomcat and other tried and tested Apache projects. Before TomEE, there wasn't really an attempt to bring this projects together other than Geronimo, which never really went anywhere.
I wish the `CompletableFuture` type had an SPI to inject the default `Executor`. Sending everything to the `ForkJoinPool` by default doesn't seem to be the ideal choice for all setups.
&gt; We rewrote our Scala because it was hard to maintain. &amp;nbsp; Really? &gt; and makes it ridiculously hard to be able to read other people's code. &amp;nbsp; I really have to rely on my IDE for everything from pulling up types (Ctr-Q), finding implicit parameters (Ctr-Shift-P), identifying implicit conversions (look for the gray underline and press Alt+Enter). I also have to occasionally bring up the [syntactic de-sugarer](http://stackoverflow.com/questions/9891407/getting-the-desugared-part-of-a-scala-for-comprehension-expression/19676506) for things like for-yield, thunks, etc. I think your problem isn't reading, it's understanding. &gt; There are many ways to do the same thing, which is bad. &amp;nbsp; Just because there is more than one way to do something doesn't mean that both ways are equal. I was just watching [Scala With Style](https://youtu.be/kkTFx3-duc8?t=23m6s) where the slide shows two different ways to write the same thing and the imperative way [bottom] is actually better than the functional way [top]. In Java you don't get to choose - you have to do it the imperative way because even though Java has lambas, it does not have folds (I think that folds are also called reduce in the context of Map Reduce). Scala trades "only one way to write something" for expressive power and conciseness. For more seasoned users, more expressive power is awesome but for beginners it is a pain in the @$$. &gt; Scala has a lot of stuff in it, so much so that it looks like a mess. &amp;nbsp; If you really know Scala, the code looks better than Java code. In Java you get used to writing things like "public static final" and you get used to it. Maybe you have a trick to implement adapter pattern with less boilerplate using reflection. But these things don't make Java code look better. In fact if you take a step back it looks worse, you just stop noticing it because you're used to it. Personally, I find my browsing speed (I have like two ways of reading code - one is more browsing to see the author's intent and the other is like executing all the code in my head like a debugger - here I'm talking about skimming) to be faster with Scala code than Java. This is assuming you actually know all the language constructs and are just reading. &amp;nbsp; Given my experiences learning the language and given the complaints I am getting, these issues like reading difficulties remind me of issues I had because I didn't really learn the language. Scala is not an easy language to learn. It's not like Python where if you know whatever OOP language you can learn it in a week. Scala is a very hard language to learn and I would recommend starting with Java and then Haskell and then finally Scala. I wouldn't expect anyone who is not proficient in Haskell, F#, Erlang, or OCaml to pick it up in less than two months. If they did that would be good. That being said, the learning curve is a very valid criticism and I would urge anyone who plans on learning this language not to take it lightly. &gt; Java's core philosophy is that it tries to make it easy to pick up and maintain code. &amp;nbsp; In Java it's a lot easier to pick up and maintain code without relying on an IDE for everything from handling implicits to pulling up types. If you really wanted to you could include the type for every value explicitly (just press Ctr-Q and copy-paste the type) instead of relying on compiler inference and then it would be just like Java from a maintenance perspective (I think). I'm actually really interested in the maintenance issue - whether the problem was actually something to do with the language itself or if the issue was (I don't want to sound belittling) that the people who did code maintenance just didn't fully learn the language. &gt; Things like Java8, Lombok, Immutables, Google Autovalue, Functional Java (the library) make Java have the core Scala non-functionals. Just missing the builtins and the syntax sugar. &amp;nbsp; I've never actually done functional programming in Java, but [Functional Java](http://www.functionaljava.org/features.html) looks nice. 
Long time Java developer, agree completely. Scala, Kotlin look interesting. As is Swift, I've been playing with Elixir too, pretty sweet for distributed systems.
It's an interesting perspective. Their unique value proposition was that they were the only one totally free from commercial influences. If that's not your thing, then it may be the server for you. Some people are hardcore anti-money (or, mostly, one-sided against money, if they have to get paid they are suddenly not against money). TomEE was also really small (not the fastest to startup, but still fast enough) and as another value proposition fully Tomcat based. Some other servers have been using Tomcat internally (or parts of it, like Payara does), but TomEE is the only server that IS Tomcat, "just" preloaded with the Java EE libraries. For tooling etc that may be important too. 
Interesting project. I think in the end having a JVM that run on top of WebAssembly will be more successful, since it is going to be a common target with a large amount of support. But this is interesting none the less.
Applets rise from the ashes to reclaim their rightful spot in the browser. 
The coolest thing I've read in ages - thanks for posting!
Quick, who can spot the sentence with *neither* the word **Cacheonix** or **Cache** in it?
Additional Resources?
Downvote
A lot of Scala teams seem to be fine hiring Java developers and retrain them in Scala, as the pool of Scala developers isn't big enough yet.
I am interested by the language, but the Scala compiler has some issues and is considerably slower than plain Java. The Scala ecosystem is getting richer and that benefits Java so it's a win/win imo. Personally i think Scala will continue to grow in the Data Science communities, but i don't see many people relying on it for much else.
I think that Scala is a mess and I think it won't be growing much because simpler and nicer languages are coming (Kotlin and Ceylon). Scala has operator overloading madness (Scala is the best argument against operator overloading imo), a slow compiler, slow tooling, bad/overly verbose errors and last time I tried to use it with Play and Slick I ran into several issues regarding its type system and reflection (I can't quite remember what it was exactly, but I remember wasting a lot of time on trying to find an elegant solution when there were none). I just can't see it taking off because it has so many downsides along with a steep learning curve and hard-to-navigate documentation.
Oh joy - maybe Flash will make a comeback too!
This was an interesting read. Will definitely check this out. 
&gt; Case classes limit you to 23 data members. I remember when this restriction was lifted. I just started learning Scala and I checked the site and on the front cover it said [a fix was made](https://issues.scala-lang.org/browse/SI-7296). &gt; We had rules like "when you use implicit LHS typing, the RHS must have the type information". For anyone reading the comments, there is a difference between this: val string1: String = makeString() // Left Hand Side (LHS) Type and this... val string2 = makeString(): String // Right Hand Side (RHS) Type The former makes explicit that "string1" is a reference of type String. The latter actually sets the type of whatever is on the right side and then after the right hand type is set type inference kicks in. val string2: String = (makeString(): String); // Equivalent code after type inference But yeah, if your team isn't ready for it you run into problems.
You can define a subclass of `CompletableFuture`, or a decorator class that implements `CompletionStage`, and override the `*Async` methods that don't take an `Executor` to call the `*Async` methods that take one with some executor provided in e.g. the constructor. Also, you may want to wrap around all the returned `CompletableFuture`s/`CompletionStage`s so you override the continuations as well.
I like Scala. I like Java. Scala is really nice I think, I like FP and OOP, mixing them is nice. 
I think most people are using Spark with either the Python or Java bindings (which are officially supported). I know I'd never learn Scala just for Spark...
Scala is The C++ of the JVM: * Feature rich and powerful * Takes longer time to master * Each developer has his/her own style * Slow compilation. 
C++ slow to compile ?...
&gt; it won't be growing much because simpler and nicer languages are coming (Kotlin and Ceylon). I'm glad I haven't begun to learn it then.
Scala, the language, does not need to 'get any better'. Most Scala users are happy with it. Scala has every feature you can think in a program language. That's the way they like it. I like my language to be less powerful, and simpler to read. But that's me. Scala offers some programmers several things they want, and Java can't give them. Not every language should target me! Now, the tooling in Scala should probably get better. The compiler should be faster, errors should be better reported, IDE's should be smarter. That would make Scala users happy.
Horrid.
Seems fair to me. C++ is known for fast executions, not compilations.
While [this prezi on reasons Scala is nicer to use](https://prezi.com/07yqjyfcotn6/top-10-reasons-java-programs-envy-scala/) is a little old, it does highlight reasons I like Scala. I would say Scala is hands down better than Java. Now, would I say Scala is the best language? I don't know, but it is the best language I've used. Do I use Scala for every task? No; I like Python a lot for scripting. Sure it compiles (a little) slow, but that's hardly gotten in my way. Removing all the boiler plate code more than makes up for it. Take for example [case classes](http://docs.scala-lang.org/tutorials/tour/case-classes.html) which implement equals, hashCode, and toString. All in one one line. I can only see Scala getting better. First is with advances in the JVM, as Java tries to catch up with Scala (now they've got functional programming in 8, and I hear rumors of [type inference for 9](http://openjdk.java.net/jeps/286)), it can only push the JVM forward. Also, Scala doesn't have to maintain backwards compatibility, allowing it to cut loose any mistakes in its past holding it back. While this produces a greater technical debt when it comes time to go to the next version, it hasn't really been a huge pain (I've been using it since 2.9). 
Personally for myself, I stick with plain old Java. It is a language I am used to and one I already know quite well.
I think is just trojan horse from Jetbrains to sell more IntelliJ licenses, I see little value in it despite all the overwhelming marketing like the "next big thing".
&gt;I thought Kotlin is free and open source Makes no difference.
o, i c !
Kotlin hasn't been out long. I'm writing a distributed DES and switched from Scala to Elixir. I'm new to elixir, but already just as productive for this class of application.
Kotlin has an [Eclipse plugin](https://github.com/JetBrains/kotlin-eclipse).
I almost switched to Kotlin for its [data classes](https://kotlinlang.org/docs/reference/data-classes.html), but Google's [autovalue](https://github.com/google/auto/tree/master/value) project met my needs. I'm looking forward to using it in Gradle build scripts, but I doubt I'll be making libraries in it anytime soon.
I couldn't tell you why, but it did get a small amount of penetration. But like I said, for the vast majority of researchers, I don't ever see a day that Scala replaces Python and R in academia. It's not even on the map. This is just my observation. There may be someone that knows better than I. On the other hand, I know programmers that love to use the newest languages (Scala) and frameworks (Play!) "just because" and they claim to love Scala...but only as a secondary language. TL;DR: Programmers love Scala more than academics, academics will make you pull R and Python out of their cold dead hands. It's not my observation after 15 years in the Ivory Tower that Scala will get much more penetration. 
[removed]
I used to think this about DSL's like [ScalaTest](http://www.scalatest.org/) until I realized that the whole point of DSL's is not to reason about and conceptualize it. The point of a DSL is to read it like English and to copy-paste it. "A Stack" should "pop values in last-in-first-out order" in { val stack = new Stack[Int] stack.push(1) stack.push(2) stack.pop() should be (2) } ^ When you look at this, you should think of it as if it were a specification written on a piece of paper. If you look at it and think "I wonder what the type signature of the word "should" is in this DSL", you are over-thinking it.
Apart from high entry barrier, the language IMHO is much better and safer
Under a minute
Wich doesn't compare to the IntelliJ plugging.
No, Scala can get better. For example, Scala “[Don Giovanni](http://www.scala-lang.org/news/roadmap-next/)” plans on making the language a little more consistent. It's already pretty consistent as far as features go (at least compared to what I heard about C#), but it can still improve. Everything else I agree with completely.
I chugged the Scala "kool aid" pretty hard around 5 years ago... and am still very greatful for it opening my eyes to functional programming concepts. However, over the past couple of years I've stopped fighting the uphill battle to lobby for it in the workplace, because: 1. Java 8 streams are "close enough", and don't require any major political battles for me to use them. 2. I got really burned out on breaking changes between Scala versions. When a language is extremely new (e.g. Rust), that's somewhat understandable. But Scala has been around long enough now that this really has become inexcusable. There's no reason why people should have to download separate versions of libraries, depending on which Scala version they're using.
My point is, will Java 10 happen and if yes who will care by then for greenfield projects? Specially with Oracle loosing on court and most non-JEE based development being on Android and Google is also not known for doing interesting programming language research. IBM is now strongly backing up Swift and has made J9 a modular language runtime instead of a plain JVM. The Scala guys are now researching a native compiler, based on LLVM.
converting between a java and scala Long for instance. or having to deal with null objects brought in from java.
I switched to Kotlin, try it. Ps: I don't like Scala very much.
Just learning Scala but so far it seems like the most natural successor to java. It's already binary compatible, eases you into functional style when it makes sense, and is such a pleasure compared to java. The main 'problem' is the learning curve, and even that isn't so bad if you don't try to jump into all the details right away. If you're curious about Scala, give it a shot, Activator makes it super easy to kick the tires.
I only mean to say that, for a language besides Java, Eclipse has great support for Kotlin. I'm sure IntelliJ puts more work into their IntelliJ plugin than their Eclipse plugin, but I think you'd have a hard time finding a language with better Eclipse support than Kotlin (besides Java, of course). I love Eclipse, I don't like IntelliJ, and I love being a benefactor of Jetbrains' trojan horse :)
&gt; and I love being a benefactor of Jetbrains' trojan horse Good for you. 
What used to turn me away is the frequent changes in the language because I did not have the time to follow up closely enough. Did that change? Can I consider Scala as a language now more stable now?
 Lombok will make your compilation time at least 5x worse(tried to migrate an 500KLoC java project). And java8+lombok's features are ridiculous compared to the ones in Scala.
 Stack&lt;Integer&gt; stackResult = new Stack&lt;Integer&gt;(); stackResult.push(2); UnitTestRunnerFactory.getDefaultUnitTestRunnerFactory.createUnitTestRunner ( AssertionFactory.getDefaultAssertion.assertFalse ( "A Stack pop values in last-in-first-out order", new UnitTester&lt;Stack&lt;Integer&gt;&gt;() { override public runTest() { Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(1); stack.push(2); stack.pop(); return stack; } }, stackResult ) ); Better?
&gt; div(sqrt(minus(square(b), multiply(4, multiply(a, c)))), multiply(2, a)) - better? Is it more javaish? &gt; I never said that operator overloading is bad. Yet Scala certainly makes it seem bad, with its collections API and shit like SBT. &gt;Have you heard about incremental compilation? Yes, I have, and I use it all the time. Scala's incremental compilation is much slower than Eclipse's Java incremental compilation. How slower, you may ask? About 20 times slower. I don't really notice compilation with Java, but even in the simplest of projects, Scala's compilation is very noticeable. &gt;Its type system is strict and the reflection api is almost the same. Possibly, you've spent months(or years) learning java but you was unable to comprehend a little type theory. But that's irrelevant to play and slick. You just mention random crap so far. Once again, I had no trouble with type theory. The problems encountered were purely technical and had to do with composability of Scala's features (unfortunately, I don't remember what they were exactly). Copying shit from academic languages left and right isn't bad *if* you take the time to actually integrate them. Scala is the problem, not the theory behind it. &gt;Scala is more popular/powerful/supported than ever and the only folks hating it are the ones having problem with learning operators and a typesystem which doesn't suck - the same guys spamming Object and RandomTrashProxyFactoryBeanConfigurator. I don't want to learn 60 different "operators" which have no logic behind them. Sure, you want a union operator? Then use the proper mathematical symbol. I don't want to be confused by your shitty 20-character string of pluses, minuses, equals, slashes, colons and percent signs. If it means addAll, or foldLeft, or foldRight, just say it!
 Then you've used Scala... and moved to legacy because of the java8 hype.
Collections for one.
Absolutely love it. Spring boot + Kotlin makes web services really enjoyable. Don't like a Java API? Just add some extensions to make it the way you want! 
I like scala as a language. I enjoy using it immensely. It feels powerful, like going from a simple handgun to a rocket launcher. But like the rocket launcher it unfortunately can do a lot more damage too. Just because you can do something all on one line doesn't mean you should and it's easy to make writing shorter code some kind of obsession. A lot of the Scala code out in the wild is hardly readable for people with Scala experience let alone for someone who's new at it. 
I tried to pick up Scala, actually without knowing Java too. Spent 6 months with it and got fairly far with it I think really, but the further I got, the more I felt like it was harder to write "good" code with it. There were always so many ways to do the same thing, and when you asked which way would be considered idiomatic, you got several answers. I was tasked with looking into languages to consider for some new micro-services at work, and I considered Scala for some of them, but in the end realised it wouldn't be possible to use it in a maintainable way in a team. You'd have to ban parts of the language, spend ages training people up, and maybe be less productive even then. I will say, it was an invaluable learning experience. I do feel like I learnt an absolute ton, and it certainly helped introduce me to Java a lot easier afterwards.
Typescript was clearly invented by Microsoft to sell more Visual Studio licenses.
I think Scala *will* improve - rationalisation of syntax / language constructs, improvements in compiler speed and tooling. See [dotty](https://github.com/lampepfl/dotty) for work in progress on this. For the Java developer who just wants a better Java, Kotlin is a really attractive alternative. My view is that Scala is not a good language for the kind of type-level programming its more "advanced" users tend to favour, and if that's what you really want to be doing you should be using Haskell or Idris - or, if you have to be on the JVM, maybe Frege. There isn't really a mainstream JVM-equivalent to F# (an FP .Net language closer to OCaml than Haskell), and I think there should be; Scala won't be it.
I was aiming for "Automatic gzip compression of responses", I guess these two half-sentences make one whole one? :)
Scala looks like someone took a handful of punctuation marks and spilled them across the monitor.
re's no reason why people should have to download separate versions of libraries, depending on which Scala version they're using." That is a big stinking issue. I wanted to introduce scala to my team...but failed to win over the cold souls on this very issue. I truly can't justify these complexities given that java works great (albeit with lots of extra lines of code compared to scala). 
Looks nice but since there is no Netbeans support yet I didn't try it...
Just wrote a new blog post about the current state of Machine Code Snippets (and a little bit of Vector API: SIMD, AVX2) in Project Panama. JMH, benchmarks and the wild nature of assembly code are included.
This article is stolen from [this website](http://www.htmlgoodies.com/beyond/article.php/3893911/Web-based-Mobile-Apps-of-the-Future-Using-HTML-5-CSS-and-JavaScript.htm). /u/gaurav3222 - Gaurav Gupta - please direct people to the original article. Copying and pasting an article onto your own website under the guise of it being a 'content aggregator' is copyright infringement. You must seek permission from the author before duplicating an article, which you repeatedly fail to do.
To call Typescript a weakly-typed language ? I don't get that.
It looks like PHP isset shenanigans.
Java != Javascript. Also, once WebAssembly comes out JavaScript will be like programming in VB6 compared to other superior and safer languages.
Well, directly injecting machine code into a Java program via internal interfaces is going to be a security and portability nightmare. 
1. This article is copied from a different site as /u/Jazzalenko pointed out and thus is a **violation of copyright** - which is forbidden here 2. This article is not related to Java - it is about JavaScript both of which are completely different and unrelated languages. Seriously, what you are doing - copying an article from somewhere else and claiming it as your own (which is clearly visible on your site) is **stealing** and thus **illegal**. You could face huge copyright charges and be sued and forced to take down your site and pay huge fines and fees. If you want to work as a *content aggregator* as you pointed out in a different comment, you **need to keep the link to the original article** and also **keep the original author** - everything else is **illegal** because it is **theft of intellectual property** and **copyright violation**. Should you try to post such content again you will be banned and reported for the above reasons. **Post removed: illegal content (copyright violation) and not Java related**
....? Where do I mention type safety?
Yes, AssertionFailedExceptions are much more descriptive...
Thank you. I noticed this guy the other day and /u/jeffjose and I have been tweeting some of the original authors. Copying articles is one thing, but spamming them all over reddit as your own work is really just asking for trouble. 
I love it to death, despite its shortcomings (too many goddamn features). That said, I program Java (7, to add insult to injury) in my day job, and I hate it with every bone in my body. Why do I have to write 100 lines of code for what Scala gives me in just one? Why do I have to work so hard for such simple things? The things I can do in 2 seconds in Scala take can take me literally 100 times longer to code in Java. Scala could get better if its syntax would be a little more "strict", and if they get replace the if (...) syntax with if ... then syntax (I hate parens). Maybe easier Macros would be nice too, although, like the rest of Scala's features, this would get abused to death. All in all, Scala is an awesome language, my favorite, but I wouldn't recommend large teams work with it. Too much of everything to be readable by anyone other than the guy who wrote it. I've been using it for 3 years and I can barely understand some of the more out-there libraries. And by which I mean, I can barely understand their *syntax*.
Here's one for you: http://www.theregister.co.uk/2013/10/10/nhs_drops_oracle_for_riak/ And it worked on release (just don't confuse Spine 2 with Spine!)
Yep
Picoservices for the win! Etc.
Serious production system? You mean the code they write to get enough data for their paper and then abandon as soon as the grant runs out? 
I like Kotlin. It is essentially an improved Java. Data classes, type inference, unified types, named parameters, null safety and much more makes you more productive and the code more pleasant to read and to write. 
This statement is sadly typical for Java developers, although completely valid. Have you ever thought that another language could make you more productive, help to avoid bugs and bringing you more joy? Especially the upgrade to Kotlin is an easy one for Java devs. 
&gt; It is very common, especially in open source projects, for a developer to declare a class as final, but not give any indication as to why this decision was made. Likewise, it is very common, especially in open source projects, for a developer to not declare a class as final, but not give any indication as to why this decision was made (i.e. what are the expected scenarios in which overriding is fine).
I programmed for a long time in Java, and back in 2009 I switched to Scala (that was around the time it went to version 2.8 if I remember correctly). I think it's fair to say it took me probably a year to write Scala code in a "proper" way, i.e. having unlearned the Java style, embraced immutability and new concurrency abstractions, less reliance on inheritance. Nevertheless, I felt immediately liberated from day one, and there are still projects I haven't fundamentally refactored although they were written when I was a Scala novice. When I look back at my old Java code (and I still have a few things running in Java because I hadn't had time to rewrite or transition them to Scala) I shudder. Of course it's difficult to compare the two, because I am also more experienced now that I was when I wrote those Java programs. I still appreciate about Java that it's usually straight forward to read other people's code, because there aren't that many different ways to do things compared to Scala which has a much larger palette at your avail. Still, all that boilerplate... Sometimes I just have to experiment very fast with some ideas, this is too brilliant in Scala, you can get going in zero time. I admit though that I never really programmed Java 8, so I guess things got a bit better now with more functional abstractions available. A last thing to note is Scala.js, that's just a fantastic addition if you need to write stuff that runs in the browser and you hate JavaScript (like me). Your last question - 'Do you think Scala will get any better?": Definitely! It already got better and better from Scala 2.8 and 2.9. to 2.10 to 2.11 and the upcoming 2.12. I am following closely the discussions around Dotty and new initiatives like the Scala Center for open source support and Scala Native for LLVM back-end. With Scala, there are constantly exciting projects popping up. Java also advances, but I think it's more like a large ship, its changes are much slower.
There aren't any more radical changes since long time. The frequency of additions has slowed down, especially in terms of the language itself, while the standard library is being modularized. If you do normal stuff, you can easily compile your project from 2.10 through upcoming 2.12 without any changes, that's like what? a three? year period. At worst you get deprecation warnings. I have projects that were written back in Scala 2.9 times, and whenever a new version comes out, I can compile them virtually without changes.
AutoValue just creates value classes - all fields final with a good hashCide and equals implementation. Incidentally, that's what kotlin's data classes do to. Lombok can do that, if you give it the right annotations, but it can also do a bunch of other stuff which I have no idea why you would want to do. Is a synchronized annotation really easier than a synchronized block? I prefer focused libraries to jack-of-all-trades.
Thanks for the tip!
&gt; Honestly the community needs to get better, not Scala. THIS. scala is full of SICK NASTY PEOPLE. They need help. Mental help before they hurt themselves and everyone around them.
I'd say the exact opposite - final is a sane default for any class. If you make a class non-final you have a larger api to worry about keeping stable, and often that is unnecessary. There are good reasons languages like kotlin make classes final unless explicitly told not to. Non-final methods I can understand, it's unnecessary if the class is already final.
I didn't say it isn't growing, I am saying that it won't be growing. Kotlin is still very new and Ceylon still needs at least 5 years of development time, so my predictions are for the future, not the next 5 years.
&gt; if they get replace the if (...) syntax with if ... then syntax Oh I'd love that. I remember Odersky mentioned it a few times, but at the moment it doesn't look like it's a top priority. &gt; easier Macros would be nice too I think that's what's coming with Scala Meta eventually.
What do you mean? A Scala `Long` _is_ a Java `long`, and it's even a `java.lang.Long` (auto-boxing) if required.
Null is kind of a pain. In Scala the Option monadic wrapper, when applied to null, returns None. I guess for using Java methods that return null you either have to make a wrapper method in Scala that returns Option instead or you just have to suck it up and do null checks (boo).
Corporatively speaking, I've made some missteps in my career trying to push cool things down into production line (for a variety of reasons, including: developer inertia when it comes to learning new stuff, management issues allocating available professionals to do a job, etc). Personally speaking, I like to try out new things whenever possible, including alternative JVM languages.
I'm currently watching it, I like how you show the desugared code. A cool plugin for eclipse / IntelliJ would be the ability to show the desugared code side by side.
You are right, it can get better. The point I was trying to make was that, for a lot of people in the Java world, a better Scala means 'a more java-like Scala'. While for a lot of people in the Scala world, a better Scala mean 'a less java-like Scala'. Scala pays a price for being sort-of-a-better-java. 
You are incredibly stupid. This isn't people getting bored. This is a design decision made by the creator of the most popular library in the language to improve the readability of unit tests for people who do this all day long. Who do you think you are, king of the testing engineers?
Being a C programmer for about 15 years, I moved generally from C to Java. I am already very productive with Java, I generally do not write buggy code and if I do it is fixed immedietly, and Java brings me the joy that I need. Generally the syntax of Java appeals to me as a C programmer. Kotlin does not share that same appeal. Kotlin reminds me of Pascal and Javascript.
&amp;nbsp; Meh. Right now I want to write an SBT plugin that will insert all the types explicitly so that you can read the code on GitHub or whatever without needing an IDE. Not every single type, just the ones where the type isn't already given on the same line. &amp;nbsp; It would be pretty cool to have an IntelliJ plugin that did that, but it would be totally impractical. Even if I could, in order to keep all the desugared code up to date, whenever the application code is compiled, new desugared code would have to be printed. Compile times would suck really bad and desugared code is more of like a beginner thing or a thing for people who are writing compiler extensions/modifications.
Nah I think it's some form of bot or very very bored troll. Look at the recent posting history.
Right, I see articles like this, and it's like they're just trying to say "Spring is Still Relevant" by associating Spring with a hot topic. Another fun thing people never talk about with microservice articles: security. You have lots of services talking to each other, and now you have a ton more attack vectors. &lt;em class="scarcasm"&gt; But hey, Spring boot solves that too right? Just add spring security with OAuth 2, right?&lt;/em&gt;
If a class is marked final then instances of the class cannot be mocked with the standard mocking libraries. Something like Power Mock must be used. When we were implementing the [paywall at Super Stack](http://superstack.io) we ran into this problem all the time and it was very frustrating. 
 One of the stubborn idiots above disliked the given DSL in a specification-style framework - it should log the good things with green and the bad things with red - like a normal specification-based test library(I know it's alien for ee/spring devs). And I've sarcastically wrote a unittest in an imaginary unittest framework with idiomatic java. The dislike of DSLs from these noobs are astonishing...
So basically never for 99.9% of companies out there
&gt; I think is just trojan horse from Jetbrains to sell more IntelliJ licenses is this a bad thing?
most java developers are just card-punchers; they don't really care about anything. java pays the rent, so they use java. i wouldn't expect much.
Your whole attitude is kind of off-putting. People are having a discussion with differing opinions, and in you come with sarcasm and name-calling.
&gt; finding out that I want to extend a class It is well established that Java type hierarchy depths approach a power law such that few classes have many subtypes, many classes have at most two, and most have zero. Statistically, you are very unlikely to make said discovery. On those grounds, classes should be `final` by default, because that's one less thing for you to worry about (a non-final class with a non-private constructor is not guaranteed immutable).
So don't use a mocking library. This is perhaps the most misguided reason for rejecting `final` classes.
All of which still use %% and have other "strange" operators in there.
This pretty much sums of [FP nerds](https://storify.com/realtalktech/taking-down-haskell). They're all broken in the head. They can't be saved. They will be the downfall of Scala.
My experience is similar, inside of three weeks realized I didn't want to do java again if possible. It's not that java is bad it's that once you know the boilerplate stuff is not required, you'd rather do without. In addition, the functional stuff changes how you think about solving problems. For me it's a no-brainer, switch if you can.
&gt; In addition, the functional stuff changes how you think about solving problems. Exactly. So one should also add that if you nevertheless go back to Java, probably the quality of your Java code will also improve after the Scala experience.
That adds a considerable amount of complexity to a unit test. For instance, what if one has an instance of the final class MyWidget and they want to call getWidgetDetails. The generation of the WidgetDetails object might be complex and not relevant to the unit test at all. Not to mention service calls. Mocking is very nice for unit tests, and people who do mock will hate final classes. 
&gt; Just like your troll account. Troll? How much does Lightbend pay you to shill for them. The truth is scala is going to die because of it's terrible community, and you're part of that.
&gt; &gt; Scala also can't really be used on Android without great difficulty, so it's already out of the game there &gt; Simply wrong. No, it's true: - Scala has a huge runtime (50k+ methods) which brings it very close to the Dex limit, leaving just room for toy applications - It's very hard to use with minification - Lightbend has zero interest in Android so they have no intention to ever optimize or fix these issues - Scala will soon be Java 8 only, Android only supports it partially, so you'll have to stick to an old `scalac` for your Android apps - The countless anonymous classes created by the compiler are terrible for mobile performances It's not impossible to write Scala apps for Android, just like it's not impossible to write them in Python. It's just that nobody bothers doing it because it's simply not worth it. Maybe you'd like to elaborate on your "simply wrong" or maybe point to a sizeable Android application (not a toy one) that you wrote? &gt; &gt; Kotlin is "elegant Scala." &gt; &gt; Absolutely not. You are both arguing about which color is best here. Elegance is a personal thing, not worth debating about. 
&gt; I generally do not write buggy code So what you're saying is "I generally do not write code that does anything more complex than "hello world"", right? Because any code of any value whatsoever will have bugs in it.
There's very little overlap between people who like Kotlin and people who like Scala, in my opinion. The people who like Scala find Kotlin weak and too close to Java. The people who like Kotlin enjoy their sanity (you can tell which side of this debate I fall on, haha), and believe that Scala went way too far.
Java 8 is evidence that Java lang is taking cues from scala now
Incorrect, the programs which I write are vastly more complex than a "hello world". Something is very wrong with you if you value code with bugs in it. A program is not valued by its bugs alone.
Assuming the construction of `WidgetDetails` is interesting (non-trivial) I'd likely have a `WidgetDetailsBuilder` that accepts a `MyWidget` and spits out a `WidgetDetails` object. This decouples `MyWidget` from `WidgetDetails` and its construction. I dislike mocking libraries, as they tend to make it far too easy to couple test code to implementation behavior. That encourages sloppy coding and it makes it more difficult to change the code, as you now have to change the mocks as well. 
Mocks also work with abstract interfaces. 
 You've mental illness or you must be a 10 year old edgy javatard. Congratulations!
Whether or not statistically it makes sense for classes to be final by default, I personally feel it violates the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) &gt; Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification Closing off classes prevents extension in many ways... usually resulting in you resorting to some adapter pattern or some AOP proxy or something. There are plenty of times I've been personally inconvenienced when some third party legacy library finalizes all their public classes, and I just want to add some minor custom behavior on top of their implementations (since they didn't expose the proper interfaces). If you do you due diligence, it can be done responsibly, but also I've never really seen open classes cause any harm. Making a class final does not make it immutable, so it really isn't removing something for you to worry about. Why would you be worried about somebody else extending your code in theirs? You only get true immutability in Java when you have all final fields for your classes. Even if it is extensible, whatever extends your class may not be immutable, but that's their problem. 
 So, both you and /u/haskell_oxford are the resident FP noobs? Or you're the same... Whatever, I hope you'll avoid the industry.
&gt;Then look at the attitude of your comrades. My only response on this thread has been to you. I haven't given my opinion on anything, other than your attitude. Don't just assume my position. Even if I had, your poor attitude is not excused by the perceived poor attitude of others. You're the only person in this comment chain I've seen calling other people names and being dismissive via sarcasm. &gt;These "people" I can only assume your surrounding _people_ in quotes is meant to imply they're not people. Care to extrapolate? &gt;can't support their claims _Can't_ is a hard word. This debate is mostly based off of the opinions of people who have experience in one language, and not both. Those speaking from a position of experience with both are still just giving opinions. &gt;This idiocracy must end This idiocy being what? Thinking Scala a lesser language, or not being able to properly support their claim? You weren't clear. &gt;I'm totally tired to see people creating crappy code because they're too lazy to learn. Shame... I'm, again, not sure if you're implying anyone who writes code in Java is lazy or... I'm not really sure what else you're trying to say. I assure you that blanketing an entire group of people (those who know and write for Java, rather than Scala) with any kind of generalization isn't going to hold up. How about this - As someone who hasn't given their opinion either way, tell me your opinions? Support your own claims? So far I've heard you say that the justifications for "Java being better" are re-hashed and reused, but haven't actually seen you put forth your own justification for Scala being better. 
Unit tests are no easier to write than other tests. Id argue they're actually some of the most difficult. They require careful planning and crafting of your code. I consider them fundamental because they're extremely quick and can effectively test your code in isolation. Good unit tests (minimal mocks) are an indication that you have minimized shared state and side effects of your application, something that is all too often ignored.
I don't value buggy code. I'm saying that you write buggy code, as do I, as do the greatest programmers in the world. Get over yourself. 
I'm a Java dev that spent 8 months working in a Scala team. I strongly agree with this guy: https://www.youtube.com/watch?v=TS1lpKBMkgg . Language is too complex. Reading someone else's Scala code is an order of magnitude harder than writing Scala code. Tools are not mature enough given the fact that the language is 12 years old. 
Simple code is good code.
What an awful attitude towards software development you have. I'd hate to work on a team under someone who pretends all ideas that come out of his mouth are perfection. Of *course* your tent is flawed from the second you design it. Everything is flawed. Software or not, the reason that engineering exists as a discipline is to move closer to perfection, because *nobody has attained that.*
I like writing Scala code, I hate reading other people's Scala code. 
Long *Rant* TL;DR *Java has libraries, just like Ruby, and the author doesn't seem to know that* Wait, Wat? Ok, is the author here suggesting that Java doesn't have any decent libraries that abstract away the tedious, error prone, common patterns? (paragraphs 1-5) Isn't Rails just a gem? Rails isn't anymore "natural" (while it's widely used) than any other Java library is. (See ant/maven/gradle etc for dependency management) Java's main selling point (beyond portability) is it's rich library backing. There's a thousand web frameworks (author's example) for Java. If you want an out-of-the-box, opinionated, read the docs and it'll work the first time, do everything for you framework, take a look at Spring and Spring Boot. A tiny amount of config, use Spring Data/Spring Data Rest to do your CRUD operations, and sprinkle in some Spring Security, then build your entities and deploy that SOB to Heroku. Sit back, drink a beer, and ask yourself what kind of a person drinks at 11am (a productive one, that's who) &gt; If David Hansson could design and develop Rails by himself, why can't a group of programmers just copy the &gt; design to Java? What makes this even more embarrassing is the fact that Java initially marketed itself as the &gt; web programming language, because of its applet technology. This statement makes me question the author's grasp of what the article is about. "Sure, this works in language A, why wouldn't the exact same thing work in language?" Is short sighted, and shows a complete lack of understanding of the semantics and run-time of either language. &gt; To emphasize this point, let me add that there is no good web framework for C either, and it is unlikely that &gt; there ever will be. again, WAT? No, there probably won't be anyone who writes a good web framework for C, because that's not what C was built for. Pick the right tool for the right job. C is about 2 layers of abstraction away from electricity. &gt; If someone would just write Java on Rails their framework would have many times more users than Ruby on &gt; Rails, and it would instantly propel him to internet fame and fortune. Again, do 3 seconds of research before you take up your valuable time to write something on the internet. Fine, I'll do it for you [Some Java Web Frameworks](http://lmgtfy.com/?q=java+web+framework) Twitter dropped Ruby for Java/Scala, so there's got to be some interwebs stuff floating around for the Java. &gt; So, completely unbeknownst to my friend, he is actually making heavy use of all those subtle language &gt; features that he claimed he never cared about. And this is intentional! Ruby on Rails was designed to make it &gt; possible to build websites without understanding type theory, or memory management, or object-oriented &gt; design patterns. So, Ruby and Python developers build these "library" things that abstract away common design patterns and common solutions to common problems? Shoot, Java needs to catch up. The next time I start a project and have to reimplement HashMap, I'm going to shoot myself... &gt; Ruby on Rails provides a concise way for expressing: do this when the button is clicked. The "do this" part is &gt; implemented in Ruby as a first-class function. How would it be implemented in languages like Java which &gt; don't support them? Well, the behaviour of first-class functions can be mocked by defining a new event &gt; handler class with a single perform_action method and then passing an instance of this class to the button &gt; object. So guess what? Using a Java library typically entails declaring a humongous number of handler &gt; classes. Or, you can use a single abstract method interface (see java 8 lambda's, or anonymous inner class, or Command Pattern) Just because you don't know of a better way, doesn't mean that there's not one. &gt; But computing has changed radically since the 70's. Damnit, what do I do with all of these punch cards I have lying around then? &gt; So using a Java library often consists of subclassing a number of magical classes and then overriding a &gt; number of magical methods. This style of library became so pervasive at one point that we even gave them a &gt; new name. They're called frameworks. 1) Google common antu-patterns. 2) You just spent 10 paragraphs writing about what an awesome _*FRAMEWORK*_ F'ing Rails is, O^Muh^GUR^D!!! &gt; I surmise that probably many general purpose programming languages were originally designed because of &gt; the author's inability to write a good library for the language that he was using at the time. "General purpose programming language," you keep using that word. I do not think it means what you think it means. A language is the blocks that you build your libraries out of. A library is a set of tools for solving common problems. Java doesn't have built in semantics for a Map or List data structure, but what it does have is a set of primitives that will allow a _**LIBRARY**_ designer to create that data structure. &gt; Transforming this sequence of steps into a state machine is an incredibly tedious and error-prone process, &gt; and most importantly, feels repetitive. No, tell me more, oh great internet sage, about how tedious it is to implement the solution to a problem that has been solved before. It's a state machine. You don't need a CS degree to figure out what it is or how to implement it. You have Google. Scheme (or my personal favorite lisp flavor, Clojure) have much better tools to destructure data, granted, but that doesn't mean you couldn't build that same (dare I say it?) _**LIBRARY**_ to do that for you in any *general purpose programming language*. Every language is built on something that is built on C. (Even Ruby) &gt; ... the purpose of general-purpose programming languages are to enable the creation of powerful libraries, &gt; this means that different languages can also be characterized by what features they provide that cannot be &gt; written as libraries. Stanza provides an optional type system, garbage collection, and a multimethod based &gt; object system. But if you don't like Stanza's object system, there is no way to write your own. *Oh contraire monfraire*. There's nothing preventing you from extending the type system of *any* typed language with a preprocessor. See Scala. &gt; the purpose of a general-purpose programming language is to enable the creation of powerful and easy-to- &gt; use libraries. Now you're just making my point for me. &gt; The more powerful the language, the easier the libraries are to use. No, the design of the library should abstract away the complexities of having to deal with low level operations. That's the point of writing a library. See Ruby or Java web frameworks. &gt; Code that makes use of a perfectly tuned library should read almost like a set of instructions for a coworker. I can see you're trying to sound poignant, and concise here, but you don't. A *perfectly tuned library* makes no sense. Perfectly tuned to what, for what? *Reads like a set of instructions* should be changed to _**IS WELL DOCUMENTED**_. The 2 hard problems in computer science are *cache evictions*, *naming things*, and *off-by-one errors*. (see what I did there) Just because some function name(s) make sense to the writer of an API, doesn't mean they will make sense to the end user. &gt; So the next time you come across a particularly elegant library, know that many decades of language &gt; research has gone into making that possible. Do I detect a hint of hubris here from the _*language designer*_? &gt; If you're curious about specifically which language features a library makes use of, then you can dig deeper, &gt; explore, and appreciate the thought that went into its implementation. If you're not curious about all this &gt; subtle language stuff, you can safely ignore it all and get on with your work. That's the whole point. Yes, a higher level of abstraction is the point of building libraries. Finally, we agree! I knew we could do it. _**Make Libraries Great Again**_ Final thoughts: I doubt the authors sincerity when he claims to be a "language designer" (unless that language is JavaScript). *RANT DONE* _**MIC DROP**_ * edit: formatting * edit: git commit -m "more damn formatting, it's late" 
I can't understand people making classes/methods final all the time, especially in fresh opensource projects. It's fine if your code has 10 years and is stable, but it's much easier to change that one small thing by subclassing than by forking every goddamn library and setting up own CI for it before pull request gets accepted. 
Don't mock classes. Mock interfaces. If you find that your interfaces get bloated, it's a sign you should either merge the functionality of two classes, or modularise better.
 Which operator - the "+=(adding)"? Or the ":="(assignment)? Is it THAT hard to learn these? Is it easier to learn/write a million xml tags for maven?
Easier? Yes. more convenient? no.
Small remark: This was already posted yesterday on /r/programming: http://lbstanza.org/purpose_of_programming_languages.html 
Interesting article, terrible title. Also, &gt; The design of the programming language directly determines what sort of libraries you can write and how easy they are to use in the end. Truer words have never been spoken. 
 &gt; I can only assume your surrounding people in quotes is meant to imply they're not people. Care to extrapolate? Brainwashed robots(or disoriented people)? &gt; Can't is a hard word. This debate is mostly based off of the opinions of people who have experience in one language, and not both. Those speaking from a position of experience with both are still just giving opinions. If someone don't know about something doesn't it make his/her arguments useless? &gt; I'm, again, not sure if you're implying anyone who writes code in Java is lazy or... ...average popularist|zelaot not knowing anything. &gt; How about this - As someone who hasn't given their opinion either way, tell me your opinions? Support your own claims? So far I've heard you say that the justifications for "Java being better" are re-hashed and reused, but haven't actually seen you put forth your own justification for Scala being better. Don't you know the benefits of Scala over Java? Should I google/write it for you? Of course, what I'm thinking, there are [people, who can't even google an SBT tutorial](https://www.reddit.com/r/java/comments/4lxjfm/java_developers_what_do_you_think_of_scala_do_you/d3s2pvm). Buzzwords incoming: 1. **Typesafety** - it's hard to write typesafe code in java because its typesystem is built on the legacy no-generics way. You'll often end up writing null, Object, instanceOf + type casting and throwing exceptions instead of using a more clear solution for these problems - Option, Either or [the disjunction of scalaz](http://eed3si9n.com/learning-scalaz/Either.html) and pattern matching. Also, to build a DSL in Scala you can use the basic features of Scala + the hygienic blackbox macros(an [example](https://github.com/getquill/quill) for this). 2. **Data+Information oriented code** - if you write java you'll be forced to write obvious informations over and over which makes the code a giant unreadable mess. There are plenty of coding patterns you can't do in Java which creates more workarounds in the langauge - like [lombok](https://projectlombok.org/) which can make your compilation 5x longer for a few Scala features - the developers of Java are lazy... If you write code in Scala you can also avoid obviousity with its local type inference. 3. **REAL functional capabilities with robust concurrent design** - it makes your code [referentially transparent](https://en.wikipedia.org/wiki/Referential_transparency) which is a huge win in *concurrent* design - you can forget that crappy synchronization and work with immutable collections using Scala's [Future](http://docs.scala-lang.org/overviews/core/futures.html), akka's [actors](http://doc.akka.io/docs/akka/current/scala/actors.html) and scalaz's [Task](http://timperrett.com/2014/07/20/scalaz-task-the-missing-documentation/). There is also Scala's [async/await library](https://github.com/scala/async). 4. **High level generalizations** - if you know a little Haskell and such then it's easy - typeclasses are present in Scala too which brings high level, flexible and extensible generalizations. Once you [get it](http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html) you can design scalable hierarchies. There is also [simulacrum](https://github.com/mpilquist/simulacrum) which removes a lot of boilerplate. 5. **Fastly evolving language** - java got its generics by [Martin Odersky](https://en.wikipedia.org/wiki/Martin_Odersky) who invented Scala - if he wouldn't introduce generics you'd all code like golangers. The developers of java have introduced lambdas in 2014... Mostly because cpp did it - it doesn't seem like they've did it because they knew what they're doing - for example the Stream api is a crap, you're working with iterators and building them and the end of the day you'll need to "collect" the results - full of boilerplate. It was easy to implement and "the users can go f*ck themself, we're clever, right"? It won't really change just like java - a lot of idiotic workarounds, tons of boilerplate patterns and ee/spring crap. Scala is almost the opposite and learns from the practice/research - they're already designing Scala3 with [dotty](https://github.com/lampepfl/dotty). 6. **Decent build system with SBT** - SBT is a far better solution to build things - with maven, you'll often end up with *mvn clean install -T 1C* and such because maven can't really manage the compilation and a lot of crap could happen when you don't clean. With sbt, you only type *run or *compile* - you don't need to use clean. Plus learning SBT is really easy thanks for its easy DSL while *learning/practicing maven is a huge pain*. 7. **Powerful features** - I won't mention all but my favorite is implicits - with [implicit parameters+values](http://www.scala-lang.org/old/node/114) you can get a small and simple DI utility. For example the ExecutionContext.Implicits.global is an implicit thread pool what you can import and use with Scala's concurrent utilities without the need to explicitly connect them to it. With [implicit classes](http://docs.scala-lang.org/overviews/core/implicit-classes.html) you can extend types with methods without the need of another WhateverUtil - clearly makes things simpler. With these two implicit capabilities and scala's traits you can also implement typeclasses - you can get a lot with a few features. 8. **The gem of Pattern matching + GADT** - Scala doesn't introduce GADT like Haskell but it [reuses inheritance and case classes to get it](http://lambdalog.seanseefried.com/posts/2011-11-22-gadts-in-scala.html). This "gem" is one of the most useful design patterns - you can create types with (virtually) multiple named constructors - there is no equivalent in java for this.
&gt; Right, because there's only one correct preference. Preference != logical decision. &gt; Do you have any statistics to backup your generalization, or is it just from personal experience (Eg, baseless)? Scroll through this thread. They're making statistics... &gt; You're still being a bit of a jerk. Disturbed is a more accurate state. &gt; How about you post this nicely formatted wall of text as a top-level comment, and field questions/arguments there... As you wish. 
Sidebar says: &gt; Please seek help with Java programming in /r/Javahelp! Also, did you really just upload a video instead of asking your question *in text*? What's the point of that video? Is it a mockup, is it an already completed application? Or are you just trying to get some views?
Benefits of Scala: 1. **Typesafety** - it's hard to write typesafe code in java because its typesystem is built on the legacy no-generics way. You'll often end up writing null, Object, instanceOf + type casting and throwing exceptions instead of using a more clear solution for these problems - Option, Either or [the disjunction of scalaz](http://eed3si9n.com/learning-scalaz/Either.html) and pattern matching. Also, to build a DSL in Scala you can use the basic features of Scala + the hygienic blackbox macros(an [example](https://github.com/getquill/quill) for this). 2. **Data&amp;Information oriented code** - if you write java you'll be forced to write obvious informations over and over which makes the code a giant unreadable mess. There are plenty of coding patterns you can't do in Java which creates more workarounds in the langauge - like [lombok](https://projectlombok.org/) which can make your compilation 5x longer for a few Scala features - the developers of Java are lazy... If you write code in Scala you can also avoid obviousity with its local type inference. 3. **REAL functional capabilities with robust concurrent design** - it makes your code [referentially transparent](https://en.wikipedia.org/wiki/Referential_transparency) which is a huge win in *concurrent* design - you can forget that crappy synchronization and work with immutable collections using Scala's [Future](http://docs.scala-lang.org/overviews/core/futures.html), akka's [actors](http://doc.akka.io/docs/akka/current/scala/actors.html) and scalaz's [Task](http://timperrett.com/2014/07/20/scalaz-task-the-missing-documentation/). There is also Scala's [async/await library](https://github.com/scala/async). 4. **High level generalizations** - if you know a little Haskell and such then it's easy - typeclasses are present in Scala too which brings high level, flexible and extensible generalizations. Once you [get it](http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html) you can design scalable hierarchies. There is also [simulacrum](https://github.com/mpilquist/simulacrum) which removes a lot of boilerplate. 5. **Fastly evolving language** - java got its generics by [Martin Odersky](https://en.wikipedia.org/wiki/Martin_Odersky) who invented Scala - if he wouldn't introduce generics you'd all code like golangers. The developers of java have introduced lambdas in 2014... Mostly because cpp did it - it doesn't seem like they've did it because they knew what they're doing - for example the Stream api is a crap, you're working with iterators and building them and the end of the day you'll need to "collect" the results - full of boilerplate. It was easy to implement and "the users can go f*ck themself, we're clever, right"? It won't really change just like java - a lot of idiotic workarounds, tons of boilerplate patterns and ee/spring crap. Scala is almost the opposite and learns from the practice/research - they're already designing Scala3 with [dotty](https://github.com/lampepfl/dotty). 6. **Decent build system with SBT** - SBT is a far better solution to build things - with maven, you'll often end up with *mvn clean install -T 1C* and such because maven can't really manage the compilation and a lot of crap could happen when you don't clean. With sbt, you only type *run or *compile* - you don't need to use clean. Plus learning SBT is really easy thanks for its easy DSL while *learning/practicing maven is a huge pain*. 7. **Powerful features** - I won't mention all but my favorite is implicits - with [implicit parameters+values](http://www.scala-lang.org/old/node/114) you can get a small and simple DI utility. For example the ExecutionContext.Implicits.global is an implicit thread pool what you can import and use with Scala's concurrent utilities without the need to explicitly connect them to it. With [implicit classes](http://docs.scala-lang.org/overviews/core/implicit-classes.html) you can extend types with methods without the need of another WhateverUtil - clearly makes things simpler. With these two implicit capabilities and scala's traits you can also implement typeclasses - you can get a lot with a few features. 8. **The gem of Pattern matching + GADT** - Scala doesn't introduce GADT like Haskell but it [reuses inheritance and case classes to get it](http://lambdalog.seanseefried.com/posts/2011-11-22-gadts-in-scala.html). This "gem" is one of the most useful design patterns - you can create types with (virtually) multiple named constructors - there is no equivalent in java for this.
Hey, there's a dedicated subreddit for this: https://www.reddit.com/r/javahelp
What are the other languages "coming soon" ? Are you going to do it for the hard ones like JS too ?
&gt; Um... Nope. You could theoretically write a web app in C, it would be hard, but you could do it Obviously someone [has done that](https://kore.io/) allready. &gt; We're just talking about manipulating bits at the end of the day But you are totally missing the point! The author does not neglect the fact, that you could of course write a library for any topic in any language, *but* that the level of accessibility will differ quite a lot, *because of* the capabilities of the chosen language. Different topics require different levels of abstraction - and not every language offers enough features (meta programming and introspection come into my mind for things like ORM, Testing frameworks) to reach a pleasent usability. So we (the author and at minimum myself) are *not* just talking about bits, but about accassebility, comfort, and things like that. Obviously not every language is equally present in every IT area. One of the reasons is for sure based upon the features of the language. &gt; The whole point of a library is to abstract away the complexities of the language and leave the end user which something that is less error prone and easier to reason about. After all you got it - but you have to draw the right conclusion out of it 😉 (Perhaps the term *can write* should be replaced in the original article by *should write* in order to make the intention clearer!)
Unfortunately, that's just how Medium works. We (Sourcegraph) can't change that, without switching to a different blogging platform that would have its own set of downsides. For anyone else reading this, you can follow us at https://twitter.com/srcgraph.
Sourcegraph CEO. The rough order is at https://github.com/sourcegraph/sourcegraph#supported-languages under "Coming soon." And yep, we will support JavaScript and other dynamic languages (like Python, Ruby, etc.).
How do you store the index of the source code? Does it upload the code base somewhere to your servers? Or is it using the local storage or is an on-premise index server installation is possible?
&gt; especially in fresh opensource projects ... but it's much easier to change that one small thing by subclassing `final` will be your least worry, trust me.
Do people still do anything via inheritance, rather than composition?
Language features have next to no impact to adaption. What really matters is marketing and image. Then after adaption comes disillusionment and plateau (where RoR is now too). Perfect Gartner Hype Cycle.
&gt; The whole point of a library is to abstract away the complexities of the language and leave the end user which something that is less error prone and easier to reason about. This is not the point that the author makes. The author's claim is that it's the language's responsibility to provide facilities to easily create an arbitrary library for arbitrary functionality. Now, in a general sense this is true. If your language provided nothing to build upon, then it wouldn't be very useful. But, contrary to the author's claim, it's the library writers responsibility to provide an API that abstracts away the language details and presents a solution that is more about "solving the problem" and less about "working with the language".
Hmmm.... I've been going through a 2 month long interview process, and I think it might be worth it... That said, I do wish it have been shorter.
If I'm not mistaken, you need someone who can carry a project on his/her own? Then you don't need someone who can juggle with algoritms, but someone who has build/configuration knowledge. (maven/gradle, spring, jenkins, db connections, ..). I'd always chose a developer who can build a fully functional project basic project over one that can program his own self-balancing tree implementation and needs help to create a full project. That being said, it's hard to assess someone if you lack the knowledge yourself.. (once you hire the first team member, he can help you with assessing the rest of the applicants..) So maybe it's not a bad idea to involve someone you trust in the process. 
This is a really important question, I cant use this if the repo is is not using local storage. 
How about the mistakes you DON'T notice while writing? You should write for NASA, so they can save on writing tests. Everyone in this profession should care about their code, but to say you don't mistakes is highly arrogant.
Pretty much was going to say what @oljoner said regarding your admitted lack of experience with Java and ability to assess code. Find someone who can help you. A coding challenge is meaningless if you can't determine quality from it yourself. That said, if you have been writing code on any platform, it can be pretty easy to find what smells. Idioms, design patterns and standards cross language barriers in a lot of cases. But at the end of the day, it sounds like you need someone to help you in the process.
I take pride in my work, and a coder's competence can not be judged just from the language he's hired to work in. Except maybe Javascript.
I went through a month-long interview recently --about one per week for four weeks. On the fifth week, I emailed to ask how it was going, and they decided to "go with another candidate." Well, thanks for blowing about six hours of my time over a month, all of which could have been done in two days. 
"Generally" does not mean "all". Also, the lifetimes of mistakes are short due to lots of testing and making sure the current code that is written works correctly. When the end result is reached and a release is ready then there should not be any mistakes in the code. On the long term side of the code, generally there are no mistakes after they have been corrected during development.
I've used pitest on a project at work and I would definitely recommend it. It is a great complement to code written using TDD.
Except when classes make sense... now you have an interface for every class even when you have only a single implementation. That adds nothing but clutter to the code. Interfaces should be used for polymorphism and explicit definition of your API via a contract. In many cases, there is no use for an interface. Having to make a bunch of them solely for mocking is a pain and just plain ugly.
&gt; But, contrary to the author's claim, it's the library writers responsibility to provide an API that abstracts away the language details and presents a solution that is more about "solving the problem" and less about "working with the language". How is that against the authors opinion? &gt; If you're curious about specifically which language features a library makes use of, then you can dig deeper, explore, and appreciate the thought that went into its implementation. If you're not curious about all this subtle language stuff, you can safely ignore it all and get on with your work. That's the whole point. The author only stated, that the features of a language determines, how libraries *could* be designed. This is just natural, but has nothing to do with *exposing* some bare language features to the end user.
Scala shares the exact same primitive types plus auto-boxing as Java. There is really no difference. val j = new java.util.ArrayList[java.lang.Long] (1L to 10L).foreach(j.add(_)) import collection.JavaConverters._ val s = j.asScala val x: Long = s.head 
The **statement** represents your database query... and cleaning up those objects are really easy: try (Connection conn = Database.getInstance().getConnection(); CallableStatement cs = conn.prepareCall("{call storeprocedure(?,?)}")) { int i = 1; cs.setString(i++, param1); cs.setString(i++, param2); if (cs.execute()) { ResultSet rs = cs.getResultSet(); while (rs.next()) { RowObject data = load(rs); list.add(data); } } return list; } catch (SQLException ex) { LOGGER.log(Level.SEVERE, ex.getMessage(), ex); } 
All of those GC issues are directly controllable by the developer. You should be exploiting the use of GC to shorten your development time, and then circumventing as needed when you are in the optimization phase of your development. GC is a huge asset to the Java language.
In my 6 years as a software engineer I can count the number of times I have had to write my own custom data structures for performance on one hand. Most performance problems come from people not using the correct existing data structures or not knowing how to correctly configure / use some libraries they have chosen. Building a solid base for a project including dependency management, testing, builds, deploys, logging, error handling, metrics and validation are far more important. A good base framework can drastically reduce the time it takes to build / debug a project. You can always improve performance later if you designed the code well. 
You don't need to know how to _code_ advanced data structures, you need to know how to _differentiate_ and _employ_ them. This statement is valid even for algorithms challenges (you can use whatever libraries fit you best in Code Jam, for instance). Discovering after 5 months or even years of production that your code is not up to the job is a nightmare. Good design and a decent unit/performance test suite can help a lot, of course, but algorithms and computational complexity skills is a real life saver.
It relies on code being mirrored on Sourcegraph.com. It does not send code to Sourcegraph; it pulls code from Sourcegraph. So, your private code will not be sent or uploaded by the extension; you need to explicitly auth on Sourcegraph.com to be able to use the Chrome extension with your private repositories.
Yes, we are! More to come soon. Email me at sqs@sourcegraph.com if you want to get early access to beta test this.
I don't know if it's appropriate to comment here but at work we replaced log4j in a project to use the log4j2 bridge since we were having deadlocks occur due to some heavy multi-threading. Since then we're still seeing some blocking occur on threads when it comes to using logger. Anyone else run into these issues and how did you fix it? I'm thinking about just ripping out the bridge and doing it the correct way to see if that helps. 
I already use and love [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc). It looks like this will give me the extra features I've been missing to make browsing code more pleasant
Unfortunately your code leaks. You're not closing the ResultSet or the Statement. I wrote [an article about how to do JDBC properly](http://lpar.ath0.com/2008/09/05/java-jdbc-and-memory-leaks/) including all the necessary object closing, because all the examples I could find were wrong. There's [an update covering Java 7 try-with-resource](http://lpar.ath0.com/2013/03/07/jdbc-example-code-revisited/); basically, JDBC code should look like this, with three nested try statements: try (Connection connection = DriverManager.getConnection(JDBC_URL)) { try (PreparedStatement statement = connection.prepareStatement("SELECT FIRST,LAST FROM PEOPLE WHERE LAST = ?")) { statement.setString(1, "Smith"); statement.execute(); try (ResultSet results = statement.getResultSet()) {; while (results.next()) { String first = results.getString(1); String last = results.getString(2); logger.info(first + " " + last); } } } } But to go back to the original question: The reason for Statements is performance. To do a query, the database engine has to run your SQL statement through a parser, compile it, come up with an execution strategy, then run the resulting query and assemble the results. If it had to do that for every single lookup, performance would be terrible. By having a Statement, it's possible to have a variant called PreparedStatement which allows you to do all the parsing, compiling and execution strategy stuff once, keep a handle on the result, and then repeatedly substitute in parameters and run the query. The reason why you still have _non-prepared_ statements is that if you're _not_ doing repeated iterations of the same query, a PreparedStatement requires an additional round-trip to the database server. So in that case, a simple Statement will be faster. You can think of a prepared statement as being like a limited form of anonymous stored procedure, with the advantage of being more portable between different databases.
On reddit use /u/username ;)
At least Borland never sued their users.
Yes, but that's for religious reasons, because it was bought by Microsoft.
They also had their own issues. I remember one of the first Borland C++ releases for Windows had a very polemic EULA that forbid its buyers to use Borland C++ to produce development tools that could compete against Borland. Surely some old timers might remember that release. I read about it on PC Techinque's back in the day.
With just two try with resources: try (Connection connection = DriverManager.getConnection(JDBC_URL); PreparedStatement statement = connection.prepareStatement("SELECT FIRST,LAST FROM PEOPLE WHERE LAST = ?")) { statement.setString(1, "Smith"); statement.execute(); try (ResultSet results = statement.getResultSet()) {; while (results.next()) { String first = results.getString(1); String last = results.getString(2); logger.info(first + " " + last); } } }
Let's consider some technology that was current when all this stuff was invented: the steam engine. The instructions for how to operate the steam engine are covered by copyright. Someone can't just copy your instruction manual verbatim. However, they can write their own manual for how to operate your steam engine, using their words. So copyright covers specific expressions of ideas, but doesn't cover the facts about how your steam engine works. You can't stop them from describing how to refill the boiler by claiming you have a copyright on the word "boiler", for example, but if they copied the "refilling the boiler" page from your instructions, you could claim infringement for their copying your specific expressions. The details of how the steam engine works are covered by a patent. Someone can't make a steam engine that works exactly the same way. However, they could make a steam engine that was a drop-in replacement for your steam engine, using different mechanisms internally. So patents cover the specifics of how something is done, but don't cover how it might be described in the manual. You can't stop someone from describing how the insides of your steam engine work just by saying it's patented. The brand name and product name under which you sell your steam engine are covered by trademarks. So your competitors can make their own steam engines using their own (possibly patented) mechanisms, but they can't decorate them to look like your steam engines or pretend that they are from your company when selling them. They can, however, use your trademark to refer to you and your product -- even when it's to tell people how much better theirs is. So trademarks cover identity, and protect consumers -- or at least, that's the theory. This all started to get really messy when software was invented. The header files of some C code are like the casing of the steam engine, the C code implementing the APIs in the header files are like the mechanism inside the steam engine. (And what you call the software is covered by trademark, as before.) However, explaining this distinction to people who aren't programmers can be tricky. Oracle couldn't go after Google using patents for a variety of reasons -- firstly because Google used their own techniques for the implementation, secondly because a patent war between two large corporations tends to be a last resort, and thirdly because a lot of the techniques are obvious or have a load of prior art. Oracle successfully went after Microsoft using trademarks. Microsoft had called their VM "Java", even though it didn't meet the Java compatibility standards. Microsoft renamed their language to "J++" and hurriedly scrubbed all reference to Java, but that wrecked their chances of getting Java developers to "accidentally" write code which would only work on Microsoft OSs -- so they dropped J++ soon after and built C# instead. Google had wisely never claimed that Android ran Java, only that you could use the Java language to write Android applications, so Oracle couldn't go after them on trademark grounds. So that left copyright. Oracle figured they could pull the wool over people's eyes and confuse APIs and implementations of APIs enough to get a judgement, or be lucky enough to get judges who didn't understand the importance of allowing independent implementations of APIs.
The short answer to why anyone would care is that it means your compile times are unbounded. I think most programmers would like their code to be guaranteed to compile in finite time.
&gt;Below is a discussion of the major changes. &gt;Java 8 baseline 5.2 moves to Java 8 as its baseline, both for JDK and JRE. This means: &gt;The hibernate-java8 module has been removed; that functionality has been consolidated into hibernate-core. &gt;Native support for Java 8 date/time types as Query parameters. &gt;Support for streaming (java.util.stream.Stream) query results. &gt;Support for java.util.Optional as return from methods that may return null. &gt;Leveraging Java 8 "default methods" when introducing new methods to extension points. &gt;Consolidating JPA support into hibernate-core. That effectively means that the hibernate-entitymanager module no longer exists. Its functionality has been consolidated into hibernate-core. &gt;JCache support Support for using any JCache-compliant cache impl as a second-level caching provider. See HHH-10770. &gt;Session-level batch size support Support has been added for specifying a batch size for write operations per Session. See HHH-10431.
Possibly because some of their target CPUs don't support integer overflow traps, so they would have had to code around that for every single integer operation, leading to a performance hit.
Use [`ProcessBuilder`](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html) instead of calling `Runtime.exec` directly. Also you discard the processes stderr. Don't do that, at least log it somewhere.
Starting from scratch I would use log4j2 but otherwise staying with logback is fine if you don't need the features. Log4j2 rolling files are (were?) hard to configure correctly. If you log A LOT in production, I'd say log4j2 is a requirement, with (async) circular input buffer enabled. 
**No it doesn't leak.** These are multiple autoclosable resources in a single try block, which is valid I would think. They are all going to be auto closed. As for closing the resultset, this is not necessary since the underlying statement will be autoclosed.
Java I think is helpful for new programmers. As a Sr. developer, I may want to pick how to do certain things that Scala bakes in.
That would be interesting.
Well, any Java ORM you use is going to use JDBC, so it's not like it's deprecated or anything.
Yes, _eventually_ all the resources will get freed up. In that sense, Java never leaks. :-) However, it's generally desirable to close resources as soon as they are no longer needed, particularly if they might be large. But you're right that in the single query case, it doesn't really matter that you're not structuring the code to explicitly close resources as soon as possible, and running your code exactly as written won't leak anything. I was focusing on the general question of how to structure JDBC operations. In the general case you want to be able to extend what the code does without having to restructure it. With connections, statements and resultsets in their own try blocks, the lifetime of each is clear, and it's trivial to add a second statement, call a method which creates a statement and does some work and returns, do multiple lookups, or hit an exception and catch it, all without the risk of failing to close resources properly or closing resources that were never opened. Explicitly giving each resource its own block also gives you the chance to catch exceptions involving resultsets and statements and recover without killing the connection. For instance, retrying after a delay to avoid crashes if someone else has an exclusive lock.
that would be better in a static util class
Made the transition today. It's like night and day. I ripped out the old log4j dependencies and replaced them with the api bridge. It improved console logging a good bit for us. what took the cake was feeding the logs to an async file appender. Even with trace on the performance hit rests around 1-5%. In order to judge apples to apples I set up several runs with a synch file logger (with and without garbage) and an async one (with and without garbage) and t it really did improve runtime by around 50% for both cases just going garbage-free.
You would be wise to heed this advice. And remember, you'll be able to rule people out by their code but there is a large group of people who won't fit your needs that you CAN'T rule out by just looking at their code. Can they deploy to the cloud, do they understand how to implement or use CI/CD...I mean...simple stuff, can they ssh into a server and tail a /var/log file (do they even know what tail is?) If you're starting s project from scratch these things will be significantly more valuable than the "best code."
The overwhelming majority of code that people are writing to solve business problems will never become a performance issue, even when poorly implemented. I'm not saying you don't need to be mindful, but prioritizing hiring for it over design, composition, testability, maintainability, would need to be a very industry (or implementation ) specific decision.
Make *sure* they know the answer to: "What happens when you declare the main method of an application as private?" Answer: the program will compile, but will cause a "No Main method found" error. You'll see this question (and many other equally useful questions) on the Java Interview questions websites. It's super important, and is definitely not useless trivia. Nope. Not useless trivia. Developers make this mistake all the time. :) 
Great work. I am really looking forward to the day the JVM finally understands value types for complex data structures.
[removed]
They might make this mistake, but seems like you'd learn quickly not to do it again, which would mean you wouldn't keep the exact error memorized for very long.
I couldn't make it work. Is there something to do in order to be able to use it on your own public repositories on GitHub, apart installing the extension ? 
The comments are dated 2014, yet the article is dated 2016.
Given that, in TDD, you write a failing test case first and then write the code so the test passes, and that mutation testing is testing for a disconnect between the test and the code. Wouldn't TDD eliminate the need for mutation testing rather than compliment it?
I was being sarcastic. :) No one ever makes this mistake and so the question is useless trivia. 
Basically any modern (i.e. async, non-blocking, stateless, not servlet based) JVM web framework will work for most peoples need. If you have an idea of your performance requirements and you know how you're going to scale, then you should be able to come back with some numbers. Most important is setting your goals: https://plumbr.eu/blog/performance-blog/performance-tuning-for-legacy-applications#goal More generally, it's hard to answer how "fast" a framework is, because "fast" can mean different things in different contexts. There's latency, which is how long it takes for a single request to be served (this request took 100ms to be served). There's throughput, which is how many requests can be served at once in a given time frame (100K requests were served inside of 100ms). Many of the benchmarking performance tests (*cough*techempower*cough*) talk about latency but not throughput. And they'll talk about latency without discussing the latency profile, and the knock on impact of microservices that have large upper bounds on latency. Regarding upper bounds: the math around latency and microservices is non-intuitive, and you can have performance problems that have no clear root cause because the performance issues are smeared over several systems. If you have a microservice that depends on 16 backend resources behinds the scenes, and 99% of the time each of those services returns a response less than two seconds, then your odds of returning a response that takes more than 2 seconds are (IIRC) 15%. http://bravenewgeek.com/everything-you-know-about-latency-is-wrong/ So, the bigger question to me is why you're looking at "fast" first -- microservices have a bunch of tricksy issues like this, so there's more to it than being able to return an HTTP response.
Doesn't SLF4J already do this through parameterized messages? e.g. Object obj = new SomeObject(); logger.debug("The new entry is {}.", entry) Here `entry.toString()` isn't called unless `logger.debugEnabled() == true`. Am I wrong?
I think it's synchronous as I didn't make significant changes to our logger configuration when I migrated. We use the loggers to write to files yes. Thanks for tips everyone! 
It used to be a lot until we started removing logger calls in favor of our homegrown logging system that doesn't write to files. We moved some to debug as well that couldn't be written to our homegrown logging system. 
You may be interested in [Async Loggers](http://logging.apache.org/log4j/2.x/manual/async.html). The easiest way to configure involves setting one system property. Should give a nice [performance boost](http://logging.apache.org/log4j/2.x/manual/async.html#Performance).
Rapidoid has a nicer less verbose API but lacks some essential features like WebSocket and HTTPS
Yes, `toString` isn't called unless debug is enabled, but what if you want to log `logger.debug("Some expensive stats {}", entry.getStats())`? The call `entry.getStats()` is going to execute before `log.debug` so sl4j can't help at all because you have already made an expensive call before getting into the logger. This new addition to log4j2 solves that.
Runs tomee and postgress.... I do have a small personal project I am building for it, each server runs a microservice..except the one which runs postgresql. It works really quick!
Please try again. We released an update and there may have been a temporary blip. Sorry!
You should check Akka if you want to squeeze those cores 
I'll have a look at that.... currently just using REST to pass json between them. 
JOOQ is a lot simpler than hibernate and forces you to think about the underlying SQL queries a lot more (that's a good thing). Hibernate hides a lot of complexity which works fine in the simple case but in the pathological case can result in suboptimal queries. My last gig was a hibernate shop and hibernate was widely recognized as one of the biggest contributors to long-term technical debt in our products. We use JOOQ at my current job and the whole team is a big fan of it. 
Love it!
http://www.mybatis.org/mybatis-3/
If you have a complex, behavior-rich object model where you need large chunks of it at a time for processing, Hibernate (or EclipseLink or other ORM library) can be your friend. If your app is a simple suck-n-puke database front-end and what you really need are lots of reports, ORM is not of much use. (I would argue an object model, in general, is not much use either; but that's different spirited discussion....)
I suspect that escaping the _method_ is actually more common than shared access from multiple threads: for example, before 2.6, a new LogEvent was created for each logging call that passed the isXxxEnabled checks. This event contains timestamp, level, message, logger name, etc. The event _has_ to "escape" the method, because it needs to be passed to the downstream components like the Appenders. When the event passes through a Layout, it often gets turned into text, and finally into a byte array. Again these objects are often passed to other components for further processing. I suspect opportunities for stack allocation are more rare than you think. 
If you need a new Object, simply allocating one is blazingly fast, often as fast or faster than obtaining a reusable one from a pool. Object pools may harm performance when they are shared between multiple threads and cause lock contention. What Log4j 2.6 does is reuse objects in ThreadLocal fields to avoid this lock contention. (In addition some redesign was done to allow the reuse of StringBuilders and ByteBuffers.) These Objects are all short-lived (before Log4j 2.6): they would only be used for the duration of the logging call and could be garbage collected when that call completed. So logging contributed to the young generation filling up sooner, resulting in more frequent _minor_ collections. Minor collections are fast (often 2, 3 milliseconds on a 1GB heap on my test box) but they are _stop the world_ collections (unless you are using a pauseless collector like Zing). So the benefit of Log4j not creating temporary objects is less pressure on the garbage collector, less frequent stop the world minor GC pauses, and has the nice side effect that your application's objects won't be promoted to the old generation as fast. Bear in mind that the objects created during logging, especially the Strings, char arrays and byte arrays are often fairly big objects (so they tend to help fill up the young gen fast). Making Log4j garbage-free wasn't easy, and it's not something I'd recommend doing in an application unless you have very strict non-functional requirements, but for things like a library, being garbage free or low garbage is very appropriate. 
&gt; hibernate was widely recognized as one of the biggest contributors to long-term technical debt in our products Do you mind expanding on that, as in what made your team come to that conclusion?
Still doesn't work. Many unhandled promise rejections and some 404 on `srclib-data-version` URLs.
When it comes to straightforward retrievals/joins, any DB access layer will work. Comparing them at this level is bikeshedding. But when retrievals are complex, SQL turns out to be a *really* good way to express them. ORMs (except for JOOQ) just get in the way of doing it in SQL, and if they have their own query language for it, then it's just a reinvented wheel without the benefits SQL has from being a long-lived standard.
They escaped the method they were created in and were not eligible for stack-based allocation. (See my other more detailed comment.)
Damn. A great post that has convinced me to give this a go on my own... but what got me to actually upvote was the "ZX81 for scale" picture.
What I am missing the most is the "peek definition" of visual studio 
Build a cloud, get investors, profit!
just another good alternative
Does it work for you on this URL? https://github.com/JodaOrg/joda-time/blob/master/src/main/java/org/joda/time/Days.java#L42 Our HTTP API returns 404s when Sourcegraph hasn't built that version of the code. That logs a nasty-looking error to the console, but it just means our servers are still building that version. You can increase the priority of that by going to https://sourcegraph.com/github.com/USER/REPO, which will trigger a build. We are working on streamlining this process, as you can imagine!
This would make a kickass kodi box. 
&gt;The overwhelming majority of code that people are writing to solve business problems will never become a performance issue, even when poorly implemented. Absolutely true. However, all it takes is one line of poorly implemented SQL/Java/whatever in the wrong place to bring performance crashing to its knees... Though performance monitoring is as important to solving that as knowledge of performant design.
OpenElec (Kodi for arm) works well on even just a single Orange PI.... The $15 model has a built in IR sensor, and works well driven from my TV remote, and even hardware h264 decoding. ..... this is the other pet project! Things are so amazingly cheap today.... 
There's an up and coming project to make Haskell run on the JVM you might be interested in. Literally compiling Haskell to JVM bytecode, not a Frege-style new language.
&gt;The only people who have really been using Scala seriously, from what I can see, are those in academia. I'd add fintech and security, not to mention big data type stuff.
thanks! sadly this sub is a little hostile towards newbs
They prefer to keep topics related to the Java language; stuff like help topics falls outside this 
If you can use `jessie`'s packages then install `openjdk-8` from `jessie-backports`.
This sub is not hostile towards newbs. This sub is not for programming help - that's all. All programming help (which includes installing programming environments) should go to **/r/javahelp** as is indicated in several places here.
Thanks for the great article! One question pop up in mind, is it possible to pass in the JSON entity class type instead of hardcoding it in the UserType's `returnedClass`method? 
Kotlin is rising very fast and I'm not surprised. It's the best language I've ever used. It's fantastic. 
Kotlin does this extremely well. I didn't find lambdas useful in Java,given they have big limitations.
&gt; *[perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away...](https://en.wikiquote.org/wiki/Antoine_de_Saint_Exup%C3%A9ry)* Is there somewhere we can vote for features to be removed from Intellij? The new feature already has [bug reports](https://youtrack.jetbrains.com/issue/IDEA-157093), which presumably means even more of our subscription money will be wasted fixing them.
Java never can. That's the problem when you make a language,you have to preserve compatibility. Kotlin will suffer from it,just like every other language has. Java suffers from it, it'll never get null safety built in. C# will never get null safety unless they choose to break old code. They sort of have it but it isn't truly fundamental to the language,so it's tacked on,just like using not null annotations for java
It's fine if you want to make something like checkers I wouldn't use it for anything that is graphically intense 
It really depends on which kind of games you want to write.
I was surprised to see it so close to groovy.
Glad to see clojure doing well!
For pixel platform games with keyboard and mouse, javaFX is good?
With JavaFX can i reach the level of indie game on steam? 
This could be something I could contribute to is it not on github?
Thanks a lot for sharing! Well, egh. I'd say, let the JDK developers make one more attempt at getting it right in a future (pun intended) API :)
If everything you are doing is within a single framebuffer then you really would not be able to use all the advantages of JavaFX.
You should reconsider, I'm sure a lot of people would love to lend their time on such a unique project. I know I would at least like to give the source code a look.
If you are serious about game development then LibGDX is the answer. If you just want a 2d game for fun / learning purposes JavaFX is a perfectly good alternative. There are a few things to point out: JavaFX support for mobile and web platforms is rather limited, so if you target those platforms LibGDX is better. Performance-wise, both of them support GPU accelerated graphics, but LibGDX gives you better access to it, while using data structures and services made specifically for games, thus gaining performance and efficiency. JavaFX, on the other hand, is a UI toolkit and, as has been mentioned, is easier to use. However, you will need to add some code on top of it to make it more suitable for games. As for Steam, there are some Java games on it, since JavaFX is just a library it wouldn't be any different to those applications. I'm currently maintaining one of the few JavaFX game libraries, if you wanted to give it a go, http://almasb.github.io/FXGL/ would be a good place to start.
There's still too much churn in the code in addition to some IP issues that have to be resolved before the public release.
What sup Ray, Wase here!! looks cool man! 
Agreed. I have used it for ETL job processing on corporate LANs multiple times and love it. My favorite design: send serialized java objects from one app to another that implement runnable and run them on the receiver. No xsd/json/XML, just pojo to pojo. Would usually have one master and tons of slaves located on different database servers or what not, running jobs locally instead of from cron jobs or whatever. Very fast, very easy
Tricky from a security standpoint. With neither a contract nor source, the people running the code have no assurance as to the nature of the code (barring decompilation and other such nasty options). Put bluntly, how do I know this game won't root my box?
:)
Thanks for your interest in Rapidoid. I encourage you to try Rapidoid + Scala, and if you write a blog post about that, please share the link. :)
Yeah, the only correct answer to that question is: I don't know. I've never been that dumb. There are a lot of those silly, really obscure, never seen issue type questions, when really who cares because it's just not something that happens.
He has a youtube channel with gameplay: https://www.youtube.com/c/rayfowler And a development blog: https://remnantsoftheprecursors.com
You don't. I mean, I use my actual name on my reddit account and it's sprinkled everywhere. The blog indicates I've been working on this for a solid year. The /r/rotp subreddit is filled with comments from people using it. But you can't REALLY be sure, can you? Of course, you can't really be sure about any software that you acquire, amirite? I work in an email security firm so I really do understand your concerns. You can certainly wait for the code to be open-sourced late next year. Then examine it and compile it yourself before playing. I'll understand and won't lose any sleep over it.
This tranthamp fellow is one of my accomplices. He supplied the Raspberry Pi 3 so that I could get the memory consumption down enough to run on it.
The servers are written in Java, with libraries that are written in Java, with application code written in Java. Google JavaEE. It's the "Enterprise" version of Java used in systems like this, sometimes (it's common and perfectly acceptable to use standard Java for servers, but maybe you'll get a clearer idea by searching for JavaEE anyway).
https://en.wikipedia.org/wiki/Java_servlet to start with... 
Run [Kubernetes](http://blog.kubernetes.io/2015/11/creating-a-Raspberry-Pi-cluster-running-Kubernetes-the-shopping-list-Part-1.html) on it and deploy stuff in containers to it. Cloud in a box :)
I work at a large Dutch bank and our mobile back-end uses plain old SQL in the back end (with a bit of a custom framework similar to Spring's JDBC template). Although I would prefer something like JOOQ I think this approach is excellent. Hibernate is nice for simple CRUD updates where there's no relations to take into account but whenever joins are involved it's in my opinion easier and more readable to do it in SQL directly. It's the lingua franca when it comes to data mutations and it's something where our Ops guys can actually grep the Java code to see where the queries are coming from. 
The most prominent streams of server side development are Java EE and Spring. But there are tons of framworks. You may want to look at the [Java EE 7 Tutorial](https://docs.oracle.com/javaee/7/tutorial/). But don't try to learn everything. Another good starting point is the [Spring Documentation](https://spring.io/docs). 
Other game reimplementation have used the approach where they reuse the original games assets (art, music, story) but reimplement the engine. That way you still need to buy the original game, but the new engine makes it possible to play it on modern systems, http://openmw.org/ is one example where people have reimplemented the morrowind engine. It seems that you haven't taken that approach, is that the reason for not open sourcing it?
If you're not going to post sources, demonstrate using some technology or otherwise relate this in some way to Java programming, I don't see how this post belongs in this subreddit, the mods should seriously consider removing this post.
In Kotlin your closures can be inlined, no penalty.
I run OSMC on my Pi2 actually and it works flawlessly in 720p encoding/decoding, though I use h265. Really does make it amazingly cheap to set up your home-brew services.
Um, do you know how HTTP servers work? And how web-browsers work? And how dynamic web-servers &amp; web-content works? Very very simplified version: Static version: Web browser makes an HTTP request to the web server "get /index.html", web server reads index.html file from disk, sends it to web browser. Web browser shows you the page that is in index.html. Dynamic version: Web browser makes an HTTP request to the web server "get /index.app", web server RUNS A PIECE OF SOFTWARE THAT GENERATES HTML CONTENT ON THE FLY. Then server sends the output of the app to web browser. Web browser shows you the contents. Java is used a LOT to write the apps that run on the web-server and produce HTML output. Well, mostly these days they produce JSON output that is rendered using Javascript (javascript is not java, it runs on the browser), but that's another story. Besides, java is used a lot on backends to do high volume (multiple terabytes to petabytes) data storage and analysis with things like Hadoop, Spark, Cassandra etc. etc. etc. EDIT: Sorry for the first line, I'm not trying to be insulting or condescending, I'm just trying to figure out your level of knowledge in this area so that I can give appropriate level of explanation. If things are still unclear or you need more info, ask away and I'll do my best to explain.
Thanks ! Got it.
Amazon.de says the kindle edition is only for US customers, otherwise it costs 11EUR, could you send it to me please?
under the kindle edition button does it have 0.00 to buy?
yes
ok, so I assume that if I go back and look through every post in /r/java that does not "facilitate discussion about Java as a programming language", I'll find a request from you requesting the mods delete it. Right? I mean, a quick scan on the /r/java front page shows there's a post with 100+ upvotes which has almost nothing to do with Java and not a peep from the forum police. I mentioned that this entire game is written completely in Java, with no OpenGL or Unity. This is directly in response to several posts I've seen in /r/java in the past week or so asking about if it were possible to write games in Java. I also specifically mentioned 3 different parts of it that I chose to use 3rd-party code rather than write it myself. Perhaps that doesn't meet your nebulous standard for "discussion about Java", but it's not about me peddling "my wares". If you're not interested in the topic and I'm not spamming, then just chill. Reddit posts drop off the front page in a week, anyway. 
Right now I'm working with a graph algorithm that touches all edges and nodes just as numbers, where accessing an attached human-readable name is a performance penalty but vital for understanding what the hell it's doing.
[ObjectLayout](http://www.objectlayout.org) proposes a way to get better memory layout without java code changes, although it still needs JVM changes. Azul is doing [some interesting work](http://nighthacking.com/simon-ritter-on-struct-like-performance-in-java/) in this area. If you have a chance, take a look at [Javolution](http://javolution.org/) which has structs and unions for interacting with native apps. I haven't actually used this myself, would be interested to hear from anyone who has.
I won't likely have a chance to double-check right now, but I recall a type being used in the original description that would not have been inlined. If I misremembered that, then I'm fine with taking one on the chin for it. Confirmed: The original submission link covers Java 8 and Kotlin, using the Supplier type. If you do as the original submission described for Java 8, you'll likely generate piles of garbage. 
That's very kind of you, I hope it helps! (Check out the sweet page numbers when you get it)
Thanks! Seems like it can be valuable to both interviewer and interviewee alike. I feel like there's value to programming texts we can consume without having to be at an IDE while we read. You should make an audio book! 
Haha I don't know I'd probably put people to sleep. Don't we have robots to do that for us? I'm just a lazy programmer!
Haha you just have to find the right audiobook narrator to read it. "Java Interview Guide, read by Kate Reading" - SOLD. 
It is very great, but i understand, for a good games it is not good
I suppose thats one way of looking at it. The other (rational) way is to treat books as tools that help people learn. You'll find no bullshitting in this book, just practical advice about what to expect and how to prepare for an interview. Of course you are entitled to your own opinion, but I (and clearly many others) disagree that an interview guide is pointless. In fact, I wrote this originally to help me prepare for interviews, not only because software development is a complicated subject, but because programmers tend to naturally drift in and out of familiarity with certain topics depending on the type and direction of their projects. And to those people, it is extremely valuable to have a summary of all the topics you might expect to see so you can brush up and make the best (and most profitable) impression you can on potential employers.
At this moment, there are about 83 people who disagree with you.
Java 8 is evidence that Java lang is taking cues from ~~scala~~ ~~haskell~~ ~~ocaml~~ ~~ml~~ ~~lisp~~ lambda calculus now. FTFY! Sure Java 8 took some cues alright: from C#, Scala, Haskell, and probably others. They all do that. [These aren't exactly new ideas though.](https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf)
Yes it is safe.
Are you implying an upvote is a a discussion about programming? Because only 5 people have had anything to say, none of the comments are about an experience with programming in Java.
Java has a bit of a PR problem in that the best examples hide the fact it's Java from the end user. The deployment model for desktop applications continues to be problematic and it means the majority of quality applications tend to be server-side, embedded (like TV UI etc) or hidden behind an OS specific wrapper.
Thank you for this. I have interviews with several companies coming up and this is ideal. I have been looking everywhere for free stuffs and this answered my prayers. I will review it once I read it. Thank you once again kind stranger. :)
One thing I found out in this project is how slow the official Math.arcsin() function is. It was necessary in the inner loop for my planet rotation code. Replacing the Java function with the ApacheMath FastMath.arcsin() resulted in a 75% drop in over processing time for that process. Crazy.
Hey, nice game. I *love* MOO1 &amp; 2. If you ever open-source, ping me, and I'll see if I can contribute anything. I'm pressed for time these days but I expect to have some more free time in a couple of months. I got this exception running on Debian/SID. Maybe because my machine has 2 soundcards, and the first one is the HDMI output on my videocard which is useless and has few controls. Anyway, you might want to fix this. It runs fine with sound turned off. java.lang.IllegalArgumentException: Master Gain not supported at org.classpath.icedtea.pulseaudio.PulseAudioLine.getControl(PulseAudioLine.java:89) at org.classpath.icedtea.pulseaudio.PulseAudioSourceDataLine.getControl(PulseAudioSourceDataLine.java:51) at moo.util.OggClip.setGain(OggClip.java:108) at moo.util.OggClip.initJavaSound(OggClip.java:346) at moo.util.OggClip.getOutputLine(OggClip.java:363) at moo.util.OggClip.playStream(OggClip.java:491) at moo.util.OggClip.access$0(OggClip.java:393) at moo.util.OggClip$2.run(OggClip.java:276) java.lang.IllegalArgumentException: Master Gain not supported at org.classpath.icedtea.pulseaudio.PulseAudioLine.getControl(PulseAudioLine.java:89) at org.classpath.icedtea.pulseaudio.PulseAudioSourceDataLine.getControl(PulseAudioSourceDataLine.java:51) at moo.util.OggClip.setGain(OggClip.java:108) at moo.util.OggClip.initJavaSound(OggClip.java:346) at moo.util.OggClip.getOutputLine(OggClip.java:363) at moo.util.OggClip.playStream(OggClip.java:491) at moo.util.OggClip.access$0(OggClip.java:393) at moo.util.OggClip$1.run(OggClip.java:243) 
I would buy that shit so hard. I'm starved looking for good interview stuff in any kind of audio book format and frankly that's the best format for me to consume given my commute. If you have any recommendations for interview prep audiobook stuff I'd love to hear it. Also I realize technical material isn't perfectly suited for audiobook format but it sure would be awesome. 
Yes, I have a friend who tested the game on a Raspberry Pi to test low-memory and against Linux. There seem to be some incompatibilities between Linux and the 3rd-party audio code I use to play Ogg files. I'm not going to be able to fix this until I get my Linux laptop and am able to debug first hand.
I'd love to see what you're creating and sharing to help others.
Exception entering intelligence screen: showing panel: Races spy panel display java.lang.NullPointerException at moo.ui.races.RaceTechUI$SpyButtonsPanel.paintComponent(RaceTechUI.java:602) at javax.swing.JComponent.paint(JComponent.java:1056) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintChildren(JComponent.java:889) at javax.swing.JComponent.paint(JComponent.java:1065) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintChildren(JComponent.java:889) at javax.swing.JComponent.paint(JComponent.java:1065) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintChildren(JComponent.java:889) at javax.swing.JComponent.paint(JComponent.java:1065) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintChildren(JComponent.java:889) at javax.swing.JComponent.paint(JComponent.java:1065) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintChildren(JComponent.java:889) at javax.swing.JComponent.paint(JComponent.java:1065) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintChildren(JComponent.java:889) at javax.swing.JComponent.paint(JComponent.java:1065) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintChildren(JComponent.java:889) at javax.swing.JComponent.paint(JComponent.java:1065) at moo.ui.BasePanel.paint(BasePanel.java:96) at javax.swing.JComponent.paintToOffscreen(JComponent.java:5210) at javax.swing.RepaintManager$PaintManager.paintDoubleBuffered(RepaintManager.java:1579) at javax.swing.RepaintManager$PaintManager.paint(RepaintManager.java:1502) at javax.swing.BufferStrategyPaintManager.paint(BufferStrategyPaintManager.java:306) at javax.swing.RepaintManager.paint(RepaintManager.java:1272) at javax.swing.JComponent._paintImmediately(JComponent.java:5158) at javax.swing.JComponent.paintImmediately(JComponent.java:4969) at javax.swing.RepaintManager$4.run(RepaintManager.java:831) at javax.swing.RepaintManager$4.run(RepaintManager.java:814) at java.security.AccessController.doPrivileged(Native Method) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:76) at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:814) at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:789) at javax.swing.RepaintManager.prePaintDirtyRegions(RepaintManager.java:738) at javax.swing.RepaintManager.access$1200(RepaintManager.java:64) at javax.swing.RepaintManager$ProcessingRunnable.run(RepaintManager.java:1732) at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:311) at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:756) at java.awt.EventQueue.access$500(EventQueue.java:97) at java.awt.EventQueue$3.run(EventQueue.java:709) at java.awt.EventQueue$3.run(EventQueue.java:703) at java.security.AccessController.doPrivileged(Native Method) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:76) at java.awt.EventQueue.dispatchEvent(EventQueue.java:726) at org.GNOME.Accessibility.AtkWrapper$5.dispatchEvent(AtkWrapper.java:697) at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201) at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116) at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105) at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101) at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93) at java.awt.EventDispatchThread.run(EventDispatchThread.java:82) 
Why not return the hash code of the primary key?
Because then you will not find the entity after you persist it. The hash code changes because you stored it when the identifier was null, then you try to find it with another hash code relative to a non null identifier.
You are wonderful.
A couple of months ago I discovered that the classic Java RTS game Tribal Trouble had been opensourced by the original authors. I was excited because it had been a mainstay casual game for me for years and I had been disappointed when it stopped working on MacOS X. The company had disappeared and it seemed unlikely it would ever be fixed. Then I found it in a github repo under GPL license and I got to work! In the past couple of months I have been getting the game working again, removing vestiges of the registration system, modernizing it to Java 8 and hopefully modern LWJGL. I would also like to redo the multiplayer matchmaker so that people can play without requiring a central sever. It is still a work in progress and is a long way from where I would consider the work complete. When it includes a full installer requiring nothing more than clicking on an icon to start it I will consider it minimally "done". In the meantime it still needs additional LWJGL work for the occasional crashing bug, multiplayer needs lots of work, the Ant build process needs to be replaced with Maven, the packager/installer needs to be created, etc.
I can see this coming in really useful as a complete refresher. Many thanks for this. Awesome work.
email is great. When you enter combat right now, you are essentially relinquishing control to the AI since tactical combat is not in the game yet. Most likely the AI is seeing that the colony ship is armed and is retreating.
It is only in epub? Or the Kindle format includes other extensions? 
I'm not entirely sure what can be done, I'm by no means a Maven or compiler expert. So take everything I say with a grain of salt. If the ordering thing can't go away. The big thing that would be helpful would be any sort of "You did it wrong" type error in the plugin. So if there is anyway for the plugin to know that it was used wrong, and to single the user that stuff is bad that would be useful. I haven't tried kotlin recently, so I don't know if it does this already. Other than that, I'm not sure what more can be done. As I said in the post, my critique was somewhat unfair as kotlin does things better than pretty much any other jvm language I've run across :). It was more of a nitpick.
We have a huge finance reporting infrastructure that is mostly based on java from beginning to end. Literally over 1 million lines of code in current and active development.
No, only that your views are in the minority.
Agreed
This is why I prefer to use a UUID as the primary key, it can be generated at the time of the object and will remain unique forever. It also makes it trivial to implement hashcode and equals based on it. The only downside is looking up an object by id is clunkier with a giant string (even though it can be reduced to about 22 characters with base 64 compression). For this problem (particularly regarding web urls) I just add an incremented id as well. It may seem strange to have two ids, but then you get the best of both worlds, a simple and trustworthy unique id that doesn't break HashMaps because its a real hashCode value, and a handy lookup number for urls or queries. For most applications, the extra space is hardly a factor for the convenience.
I wasn't aware of that.
For SWT there's SWTBot.
With Lists you have no issues. Sets are the ones where you need to provide an implementation for equals and hashCode.
If you're using Postgresql, it's better to store the Java UUID in the [PostgreSQL UUID type](https://www.postgresql.org/docs/9.1/static/datatype-uuid.html), which takes less space than a character varying type.
I'm currently learning java and i'm not quite at the stage to apply for junior jobs but this book im sure will be handy when i've learned more! ill be sure to leave a review when i've read through. Thanks!
There is no "versus". When you use Spring Boot for for example a web application you're using Spring MVC. Spring Boot is just a 'bootstrapping' (hence the name) library that gets you started faster. 
Can you expand on what you mean by "the deploy model for desktop applications continues to be problematic"? I am interested in any potential pitfalls so that I can avoid them.
Can you test yours against boon json? Thank you in advance :)
I was benchmarking boon also, but it was slow on not cached data and so I removed it from results, I will include it again
Pretty cool :D 
hm, this one looks interesting, I will definitely test it, thanks
You should tell those people who created Spring Boot that their project is not needed then. It is widely accepted that setting up a Spring project is a major pain. That is why Spring Boot was created. Of course if you spend several months studying Spring you can set up a project in a day. It's that big learning curve that takes time.
Spring-Boot saves you from having to write boilerplate code, because it comes with common auto-configurations. In most cases, you will still have to override one configuration or another - or at least set all the necessary properties.
Great book and nice gesture !!, thanks. I have also shared [133 Core Java Interview Questions from last 5 years!](http://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html), you guys may find it useful while preparing for Java technical interview. Cheers 
[Alibaba fastjson](https://github.com/alibaba/fastjson)
Maybe off topic, but on your benchmark are lower numbers better?
My question to you would be, *What are you trying to do?* Spring MVC is an opinionated solution to the MVC paradigm and Spring Boot is an even more opinionated Web App solution. 
Oh, I definitely agree. I'm in the process of moving a Spring project to Spring Boot.
Tl;dr: I understand that my comment was needlessly flippant and truthfully I am judging a book by it's title (not even it's cover!) I imagine the process of creating the book is what made it easier for you to interview better. The rub for me is, if I'm interviewing someone or I'm being interviewed, the best thing for both the company and employee is honesty. If I'm honest about not knowing something, but I can successfully explain how I managed to learn a new technique/skill/methodology in the past, I see that as more valuable than being able to explain interesting corner cases of a Java framework from memory that I could easily Google any way. Targeting an interview help book at a particular language instantly makes me assume it's full of fizz-buzz-esque exercises that someone could memorise. Needless to say, I doubt I fall into the target audience in terms of interviewee, but as interviewer, I see this as potentially harmful, but again, mostly in the sense of time wasting. Getting passed phone interviews given by none technical people by using keywords like polymorphism and garbage collection won't benefit anyone if they can't back it up with drive to learn or experience. 
Thank you :) 
Is it really bad for games, isn't android programmed in Java?
Didn't realise... sorry :)
CORBA is still a thing? Wow, I did not know that.
A quite good guide that can inspire you: https://www.gitbook.com/book/ncrcoe/java-for-small-teams/details Also code generators that make Java a lot less verbose without resorting to unsafe reflection magic: http://immutables.github.io/ https://github.com/google/auto https://github.com/derive4j/derive4j
The Android devkit does use Java. It's just that it's capable of also using other "native" languages if desired, such as C/C++. The core application will still be written in Java: you just call into code written in other languages. See this: [Android NDK](https://developer.android.com/ndk/index.html)
- default methods in interfaces - using method references ([example](http://minborgsjavapot.blogspot.ch/2016/03/put-your-java-8-method-references-to.html)) - lazy, suppliers / consumers ([example](http://minborgsjavapot.blogspot.ch/2016/01/be-lazy-with-java-8.html))
You should probably add a benchmark that tests startup performance (i.e. create a new parse instance and parse some JSON, lather rinse repeat). For some applications, startup time is a significant concern.
This is nice: http://blog.paralleluniverse.co/2014/05/01/modern-java/ (pick things which you think are relevant) you should definetely mention: - lambdas - spring boot / other "light" (lighter) frameworks. blow their minds by showing that java is faster than C++ with Rapidoid (https://www.techempower.com/benchmarks/#section=data-r12&amp;hw=peak&amp;test=plaintext) - json apis (jax-ws), swagger - spock - gradle - lombok - some stuff from netflix (at least hystrix, show them hystrix dashboard) - monitoring (e.g. dropwizard metrics. maybe takipi ? I don't use it, but it definetely looks cool) - persistence stuff (jdbi? jooq?), concurrency stuff (rxjava? quasar?), ... It really depends what you want to show them. If this is a kind of lecture where you want to teach them new libraries and "syntax", or just show them various cool aspects of the ecosystem. I'd personally prefer the second option :)
Bold move
At school for my distributed systems course I did a project with CORBA/Java simulating a bank server (Derby as backend account DB) and a Java terminal program as a "Teller" client for making transactions. Was really fun and I thought it was pretty neat with the IDL. But I could never see myself creating a new IRL system with CORBA. 
What are the extra few bytes used for? You're saying there is *some* cost of a method during object instantiation?
Very surprised "empty block" wasn't in first place.
I'm a fan of Spring Boot, Spring Cloud, Cloud Foundry, etc. I'm also a fan of Java EE since EE 6, EE 7, and the much needed specs coming out in EE 8. It's cool to see that there's a Java EE competitor, to at least one of the tools of the Spring cloud tool box, that is up and coming. I tried it. It was just like Spring Boot (except there's no Spring Initializr website), and it worked. So, I thought I'd share it. Enjoy!
It's a bit of both. I'm working on a project at work and was trying to decide how to organize my code. I have a class which is instantiated very frequently. That class contains a relatively large number of methods and only one class variable which is passed into the constructor. I was considering factoring out the methods into a static class and passing the variable to the method so that I'm not reinstantiating a (potentially?) expensive class. 
As often as I feel like dealing with the legal person about open source usage and licensing, unfortunately.
Diffing the lock file could help you create a helpful commit. Or you could just go with "upgrade dependencies" Also worth looking at is commitLock task https://github.com/nebula-plugins/gradle-dependency-lock-plugin/wiki/Usage I am not using this yet but this is definitely on my list of things to do.
System Requirements say JDK 1.3, 1.4, 1.5. Is it safe to say Java 8 is not supported? In Netbeans while on a Breakpoint, I can click on a previous method in the Call Stack and 'Pop to here'. Is that a similar feature or is ODB something different?
Modules will make it much easier to get rid of legacy stuff in Java and lock the code down.
That's not what this sub is for. 
[You could use the search function](https://www.reddit.com/r/java/search?q=play+spring&amp;restrict_sr=on&amp;sort=relevance&amp;t=all)
So never then? At one point the legal department in my old company announced that they intend to get us to start reducing the amount of third party libraries we used going forward until we weren't using any and instead had everything in house. That idea went over really well with all the devs, we said we'd love to write or own in house frameworks, it'd be an interesting project for the next couple of years... That idea was dropped soon after :(
It's similar to headers in C/C++, it seems. The method body isn't necessarily directly linked to method definition.
We use the dependency check tool from owasp to detect if there has been any published security problems with any of our dependencies: https://www.owasp.org/index.php/OWASP_Dependency_Check If it's not a security problem or functionality that we need, we often don't upgrade.
I make a desktop product, coded in Java. I ship an embedded JRE with the product. That embedded JRE includes many things never used by my product. I'm looking forward to being able to exclude some of these things when Java 9 is released. That will make my download smaller, my installed product smaller, and start-up quicker. For me, having CORBA included in the JRE has become a symbol of these problems with embedding a JRE that will be solved, hopefully, by Java 9. I really, really hope the Java team at Oracle successfully pull this off.
Please, see the sidebar: This sub is for: #News, Technical discussions, research papers and assorted things of interest related to the Java programming language Your contribution has nothing to do with any of the above and so it is misplaced. Also, the wrapper classes should only be used in very special cases and not as a general replacement for the primitives. **Post removed**
Technically, this falls under **Java Programming help** and thus should be posted in **/r/Javahelp** as the sidebar and various other hints suggest.
You can easily deploy Spring-Boot in a Tomcat/Jetty server, JSP isn't actually an issue at all. When we first switched to Boot, we only did so for the auto-configuration and version management, not for Thymeleaf or any other feature. An embedded Tomcat would've made this slightly harder, but I can honestly say I didn't have much of an issue with that either, when I set it up for web integration tests. JSF wasn't that hard either, although significantly moreso. I would argue that's mostly because the two are very different technologies and JSF isn't really meant for an action based MVC Framework like Spring MVC. As for servlets, using `@WebServlet` will work fairly well, if your Configuration class is annotated with `@ServletComponentScan`. On the other hand, injecting into a servlet, which is managed by the container and not the Spring context, isn't as easy. But Spring is fairly forward in terms of registering filters going through Spring's Servlet, which works as a Frontcontroller. Essentially, any Controller you can register to it will work as servlet. Can you give a specific case in which you would need to register a servlet with a Spring-managed Bean injected to it that can't be handled in a controller?
I will add it in the evening. And also I will need to add another benchmark to show that boon is cheating
Add [mapstruct](http://mapstruct.org/) to that list!
Have a look at Spring Boot (http://projects.spring.io/spring-boot/). 
Nooo, don't! I still need that in 1-2 projects.
There was RoboVM before Xamarin aquired it, closed it down and finally killed it. There is a fork called [BugVM](https://bugvm.com/) but at the moment the OSX support does not seem to be in a good shape...
The Codename One [ParparVM](https://github.com/codenameone/CodenameOne/tree/master/vm) was designed for iOS but should probably be pretty portable for OS X and pretty small/simple. The main drawback is that it lacks the API binding for OS X as Codename One uses JavaFX packager when targeting Mac Desktops.
The purpose of reviving it is to bring it up to date with Java 8 and 9. Its not supported yet, but that is coming. As for process, its not like a breakpoint debugger in that you begin debugging after your application is done. You look at every variable through every state and every method call all recorded and static. You then can walk back and forwards and backwards again through the same section of code. Imagine being able to ask, "what was the state of this variable a few moments ago and who changed it?"
As the article wrote, you can still use it if you supply a command-line argument or use the new module system.
Honestly, I don't think I've ever done more than either Logging+stacktrace or just flat out empty blocks. This is something I really hope gets changed about the language in an upcoming release.
If my work is anything to go by it's still used in quite a few legacy enterprise systems.
Hi, We plan to go into a freemium model. 
On the license it will be core based licensing (if SaaS) or OEM based in case if on premise installation.
Just use Java and then use Java native packaging to bundle up a Mac application. https://docs.oracle.com/javafx/2/deployment/self-contained-packaging.htm
&gt; A lot of Scala teams seem to be fine hiring Java developers That's suicidal. It could take as long as a year before they know exactly what they're doing. I mean they can get a basic understanding in two months sort of like a Ruby on Rails developer could get a basic understanding of C++ in two months, but they won't be able to write really, really good C++ code for a while. They would be much much much better off hiring someone who knows F# because at least F# and Scala are close. Scala's resemblance to Java is just for transitional purposes - to provide a fallback and backwards compatibility. Good Scala code doesn't even resemble Java code. For example, Scala doesn't even have real for loops. It's for statements is actually 1.to(10).foreach( ... ) and although it has while loops, they look kind of ugly and I usually find myself wanting to use tail recursion optimized into a goto/while because it looks cleaner. // factorial of n def factorial(n: Int): Int = { var nn = n var nf = 1 while(nn &gt; 1) { nf = nf * nn nn = nn - 1 } nf } // tail recursion optimized into a while loop def recursiveFact(n: Int, nf: Int = 1): Int = { if(n &gt; 1) recursiveFact(n - 1, nf * n) else nf } def main(args: Array[String]) { println( recursiveFact(3) ) // 6 println( factorial(3) ) // 6 } ^ See how much cleaner the recursive version is? I mean as crazy as this sounds, but in Java you cannot write an application without writing any loops. In Scala you can replace all the for loops with Range.foreach( ... ) and all the while loops with tail recursion and it would be not bad. &gt; the pool of Scala developers isn't big enough I graduated from college and I program in Scala as my main language and let me tell you the pool of people hiring Scala developers isn't big enough. I mean maybe if you are a big data person with experience building real time systems in other languages but just like a person who is like "I know Scala I want to program in Scala" - not that easy to find a job compared to something more common like "I know Java EE and Node.js"
What if I told you there are more punctuation options than a period?
How? where ? what ?
Hint #1: Use SQL, not JPA ^ok, ^^seeing ^^myself ^^^out
What's wrong with Java? Package it up in an osx app file and run it Java natively.
Check out Play -- the Java API is specifically built not to use Servlet and the request per thread model, and to use CompletableStage, Optional, and functional programming concepts in general: https://www.playframework.com/documentation/2.5.x/JavaHome Details of Play 2.5's Java 1.8 support: https://www.playframework.com/documentation/2.5.x/JavaMigration25
Looks like pooling is the main feature now, and I don't know but has DeltaSpike a CDI based @Asynchronous? OmniServices is created by the people behind OmniFaces (obviously), Mojarra and the Java EE security spec. DeltaSpike is really great too as are the people behind it (Romain is one of my heroes ;)), and though they seem to have some overlap at first this looks to be more aimed at direct EJB replacements, while DeltaSpike has more unique things of its own. DeltaSpike does have as major selling point (see documentation overview) that it's Java EE 7 without Java EE 7. Now that EE 7 is largely ubiquitous, this is not such a big sell anymore. DeltaSpike also has JSF enhancements where they kinda overlap with OmniFaces (with OmniFaces having much more features being created by BalusC and the Mojarra devs). Since it's all EE extensions I think it should mostly work together it needed, and some (friendly) competition is always good, kinda like we had RichFaces, IceFaces and PrimeFaces before. 
Will do!
Came here to say this. I think many 'developers' would avoid Hibernate.
Genuine question: why? Especially in case of simple queries. 
This is why you never use unaudited remote repositories where anyone can upload anything and to verify your inputs before they are used. However, this article only serves as a warning for ___Java___ because it was not performed using the most common Java package managers.
Sorry. This seemed to be more technical discussion than programming help.
That plugin is coming out! I contacted IntelliJ and this what they had to say... 1. You can press [Alt + Enter](https://www.jetbrains.com/help/idea/2016.1/working-with-scala-show-type-info-action.html#invoke_show_type) on a variable to toggle explicit types and [Alt + =] on a highlighted expression to get the type of the expression. 2. You can set the [IDE Settings](http://s33.postimg.org/7cc73shdb/type_Annotation_Settings1.png) to control what types are explicit and you can [enforce it](http://s33.postimg.org/sq54b8ulr/type_Annotation2.png) like [this](http://s33.postimg.org/cg0pjqyun/enforced.png). 3. In addition to [features for implicits](https://www.jetbrains.com/help/idea/2016.1/working-with-scala-implicit-conversions.html#invoke_implicit_conv), they are working on a code [transformation / desugaring](https://youtrack.jetbrains.com/issue/SCL-10327) feature.
" standard approach for deploying Java EE applications is packing all components into a single EAR/WAR archive and deploying the archive on the application server. This leads to monolithic architectures which make applications difficult to maintain and scale in cloud (PaaS) environments." This is such what fucks young developers minds and forces them on to the microservices bandwagon. If you have an ear file it can still be highly modularised and not a monolithic architecture. You don't have to have TCP/IP between everything. Maintaining a distributed monolith is the worst possible scenario and the performance sucks. I hate that people don't grasp that just because you don't have microservices doesn't mean that it's a monolith. Claiming that monolithic architectures have bad maintainability is also wrong. A well structured monolithic architecture is more likely easier to maintain than a distributed one since you don't have to deal with complexities of components not being available or not answering in a timely fashion because of network issues. Testing a monolith is also easier because a distributed architecture has to set up complex testing environments. Microservices should be used when needed. The default should be to think modularised and structured and then see if there really is a good reason to deploy one or more modules as microservices. 
No I have not. The performance of the application is not a problem. I'm not concerned about the project that prompted the thought, but it sparked my curiosity and I wanted to get some more insight into the topic. I definitely need more experience in design, however the methods are all aimed at accomplishing one single goal. They're largely all private helper methods for one externally facing method. In this case I couldn't see any value for separating them.
Why?
What is the C# library? The reason I ask is that there is very possibly an equivalent in java. 
I'd say it is simpler to use straight SQL for simple queries, why involve the overhead of a whole ORM for something simple?
The latest release of Hibernate is 5.2.0, Hibernate 4 is 3-4 years old.
As often as possible. If it's for Java SE, then I typically only worry if it's supported by the JDK/JRE. If it's for Java web, then I only worry if it's supported by my JDK and stack (i.e. - will it work a particular version of Java EE, Spring, etc.).
who knows... readme.md didn't really give me much of a clue... I wish when people were dumping release announcements, they'd at least give a sentence that would give the uninitiated some idea what it actually is that they are announcing a new version of..... 
I am looking for a way to build native, compiled, 86-x64 apps.
I know a lot about Spring, and a lot about Angular. I also read all the release notes, and I still have NO idea what it does.
my read is that it's like https://jhipster.github.io/ but not sexy
People always give advice like this and blame the victims but it seems just absurd to me. Are you telling me that every single piece of software you ever get goes through rigorous checks to make sure it's legit? You do checksum verification on everything? You never just do pip install whatever and assume it'll be fine? Even if you do, you're in the extreme minority. Systems should have reasonable expectations of their users, and when you have 17K people falling for an exploit, it's not user error, it's system error.
I tend not to upgrade my dependencies until I can tell whether they cause any problems from what I see/read from third parties. If the new features have value and there are no significant issues reported in the first 90-180 days that they're out, then I'm inclined to test them in a build. In other words, not updating all the time, but not avoiding updates either.
Genson
[Packr](https://github.com/libgdx/packr) does that well Use [NSMenuFX](https://github.com/codecentric/NSMenuFX) to get that native OS X menu bar with JavaFX.
It's base project that show you how to combine spring boot microservices and oauth2 authentication with angular2. Building webpack angular2 application is part of maven lifecycle. I will add more description to readme
It's very hard to defend against people putting malicious code in jars. It might be worth having some sort of automatic code building service to have a little more trust that the binary jars match the source code. One thing that maven currently lacks is automatic verification of signatures. As far as I can tell, Maven just checks the sha1 of the jar, but the sha1 comes from the same host as the jar. While there are pgp signatures, there's no chain of trust. Those signatures are not signed by a central maven key. You have no guarantee that jars you're downloading have not been modified. The signatures are from who ever uploaded them. I don't believe there's any requirement for uploaders to be in the PGP web of trust. It would be very easy for an attacker to upload a rogue jar and a valid signature. Compare this with the Debian archive, where the checksums are signed by an archive key. (They actually have multiple hashes which are all signed.) A first step would be for Maven (and Gradle/ivy/etc) to automatically download and verify the pgp signatures it does have.
Yes, packages are uploaded and signed by keys that are signed by at least two other developers, which means they've met and verified their identity. (If you look at the PGP web of trust, Debian Developers feature very highly in the list of most connected keys. At one point I was in the top 500 keys) Debian trusts that the packages were uploaded by a valid Debian Developer. Debian also signs the package signatures so you can be sure that you're downloading a valid package, even if you're downloading from a mirror outside of Debian's control. The same guarantees can not be made of Maven. (I don't think that many other systems have signatures. NPM appears to just have hashes, not signatures. CPAN doesn't appear to have any obligatory hash or signature. I've not checked others.)
Because OP asked for an alternative to what your suggesting. 
I frequently run a [SQL masterclass](http://www.jooq.org/training). Participants are often so excited about the SQL language after the class and about what they can do with it, they start embracing it in their projects and suddenly don't really need ORMs anymore. They usually don't look back to using ORMs, which mostly hide the SQL language from them. This is true also for projects that use only simple queries. This is not true for applications that do a lot of writing of complex data, though, where ORMs shine.
Good choice: restful backend and ajax frontend. In the past we used JSPs, but these require whole page reloads. By end of the first decade of the new millenium, browsers invorporated the possibility of rendering/refreshing only parts of a page. So devs began to make small request and only render the pieces of the page that needed to be refreshed. They called this ajax. This led to the success of REST architectures, which allowed backends to serve this highly granular requests. Other benefits of this approach are that you code your backend once and you can serve different purpose and different technology clients. I wouldn't spend much on server side rendering but for special cases and for cultural knowledge.
Both single page applications and html server side rendered applications are valid options for modern applications. Every option has its strengths and weaknesses, none of them is better than the other. Few years ago there was the huge SPA hype where everyone did it, many failed because they took SPA's as the only solution to problems. For example [Twitter](https://blog.twitter.com/2012/improving-performance-on-twittercom) changed from a SPA to server side rendering to boost overall performance of their application. What I'm trying to tell you is, don't ignore one option just because you think it's old or outdated. Let the specs decide your stack.
A lot of bigger companies are backtracking and using sever side rendering where possible. It's faster and more reliable. Picking the right technology for the job is crucial, and often that can mean mixing server side and client side rendering. A common practise I've seen is rendering above-the-fold content exclusively on the server for a variety of devices and have AJAX lazy-load anything else. It's faster and most efficient (imho). In my experience, AJAX definitely has its place, but not everything needs to be a single page application and not every application needs to render everything server-side. Personally, I love working with Thymeleaf fragments and render "entire" HTML elements that just need to be replaced in the DOM with very simple AJAX calls. I've found this to be a useful for any search functionality especially.
Please use this fork instead of BugVM: https://github.com/MobiDevelop/robovm Much cleaner, better build system, etc. 
I didn't know that there was another fork. Thank you for pointing that out.
Sure, the copy/paste thing is a perfect argument in favour of "natural" SQL as opposed to "jOOQ" SQL. I like most of my own SQL statements inside of views and PL/SQL stored procedures, where the database can precompile it for me. MyBatis has chosen an interesting approach, although you can do pretty much everything you do with MyBatis also with jOOQ (which also has a small templating language)
It happens :) Well, "don't know SQL"... They usually think they do, and leave the course thinking they don't (yet). Which is great. It's a big, exciting world of wonky syntax to learn.
There are a lot of good thoughts in this thread. The basic idea is you need to understand your problem and understand what it is you're doing, I'd recommend reading design patterns at some point. Do you need a lot of per-user customization ? Is there a lot of output without a lot of input? how quickly do you need to develop your application ? what sort of development pool do you have? what's your maintenance story look like ? etc etc etc. JSP is useful SPA is useful in general if there are multiple ways of doing something then there are good reasons for doing it each way. It's easy to get side tracked into thinking there is a single end all be all solution. 
If you do everything right, and you designed properly - what does that mean? how do you enforce that. what about non osgied dependencies? in theory maybe in practice I would strongly advised to have a test to validate that it is the case. not even talking about the deployment process where you need to rely on timeout to know if it all fails or not, or the fact that it's hard to get the dynamic service part right. 
I'm doing a dependency update sweep at the moment on a project that's had very little work done on it in nearly a year. It's incredibly painful. Apparently I can't update JUnit from 4.11 to 4.12 because doing so breaks Cucumber. I can't update Cucumber from 1.1.8 to 1.2.4 because doing so doesn't work with Spring 3. I can't update Spring from 3.2.10 to 4.2.6 because we've still got some legacy code that depends on Spring 2 features that have been removed in Spring 4. And so on and so forth.
&gt; If you do everything right, and you designed properly - what does that mean? how do you enforce that. What I meant by that is the difficulty of interacting with third party bundles which don't properly specify their capabilities and package imports and exports in their manifest and stuff, and when they do things like split packages... Doing this stuff properly yourself is simple because the right tooling automates it and enforces that you've done it right. Generally no need for specific tests for things like that. The class visibility issues you mention can be enforced at compile time easily, unless other bundles have incorrect manifests. As for non-OSGi jar dependencies, you can wrap those yourself easily enough as part of your build process, including automating their package imports and exports (or taking fine control if necessary). As for the more general questions of what "doing everything right" and "designing properly" mean in the context of OSGi, I would strongly recommend looking to the practices pushed by the enRoute project for guidance. &gt; not even talking about the deployment process where you need to rely on timeout to know if it all fails or not, I assume the scenario you're referring to is that you're waiting for a service to become available, but there is no bundle which provides that service deployed into the framework? This too can be verified at build time. Each bundle specifies the service capabilities they provide and require, and a set of bundles which satisfy these requirements can be resolved at build time. If you're using declarative service annotations (which most people probably should be) it's even easier, as these capabilities are added to the manifest automatically. I realise there are some edge cases, but for the vast majority of use-cases this is true, and in the other cases there are good tools for inspecting bundle wiring issues in a running framework. This can also be a pain when you're working with other bundles which don't properly specify this stuff, granted. In any case, so long as you have correctly selected which bundles to deploy, if something still isn't starting at this point then you shouldn't need a timeout as something will have thrown an exception or at least logged a warning somewhere. &gt; or the fact that it's hard to get the dynamic service part right. If your service doesn't need to be dynamic, you don't really have to worry about or design for this. The default reference policy is static, for example. If your service *does* need to be dynamic, then OSGi is going to be the easiest way to do it. If it's still difficult, that's because dynamic software is difficult, not because OSGi is difficult.
SQL has a pretty big learning curve too. It just that you already have that knowledge. If you have never used Hibernate and are building a small project SQL is probably better. If you have a large project the upfront time to set it up is a big time saver.
Yea that's unfortunately true! As they say on the site, they are focusing on the single toolchain for the moment. But that doesn't mean alternatives don't exist. Most of the enRoute stuff is still applicable to development with IntelliJ and Osmorc, for example, which also is built on top of Bnd with similar design philosophies. The same project structures should be supported and importable directly. ... I've done a little research just now and it seems like there has been a fair bit of recent development on the IntelliJ end. There is an [issue here](https://youtrack.jetbrains.com/issue/IDEA-100812#tab=Linked%20Issues) which looks to track related features to bringing rough parity with Bndtools. I don't know whether it yet works with all the different project structures supported by Bndtools (Gradle/Maven/ant...) In any case, you're probably right that the OSGi/enRoute folk are not doing a great job of "selling" it to most developers. Which is a shame, I think, but at least I'm getting some use out of it so I don't mind too much ;)
So, can we now migrate from MongoDB back to Oracle?
It was just a joke
Robovm is nice and can use with any jvm language. https://github.com/sureshg/RobovmKotlinApp - Here is a sample iOS app written in kotlin using the mobidevelop RoboVM fork.
From my understanding it has to do with portability. Restful services allow you to write a back end that's decoupled from the presentation layer. This would allow you to write one back end, and serve it to both Web/Mobile front ends. This is where I'm coming from, as my primary development platform is Android. I want to write a back end that will serve my mobile users well, while having opportunity to expand to the web in the future. 
And really all I want is data persistence. 
/r/Javahelp
Thanks! This looks like it! :)
Definitely agree on that. They're all tools in our toolbox. 
&gt; I wouldn't spend much on server side rendering but for special cases and for cultural knowledge. Why did Twitter went back from client side html generation to server side then?
What do you *really* want? You're specifying the solution without specifying the problem. Is it performance? Use of native Cocoa widgets? Smaller downloads?
When I first started Web app coding with Tomcat, I assumed you should build your app using many separate war files, all in different contexts. By default, this is 'microservices' based, with each context not able to access the other unless by using TCP/IP.... and this was before microservice's became popular. But, every job I've held seems to think you should just package the entire app into a single war, and deploy this in its own server. Which is a monolithic architecture. 
[removed]
I have exactly opposite experience :-)
I recommend exploring one thing at a time. Trying many new things at once can cause a bit of confusion, churn, and time wasted troubleshooting stuff that isn't well understood. Pick out the one thing you thing would help the most, and try that out until you understand its benefits and drawbacks. Then move on to the next thing. 
Can't we just choose a sane db that is proven and doesn't come from a company with more lawyers than engineers?
Kotlin and Groovy both aim to reduce the verbosity of Java. If you're coming from Python Groovy may be more familiar with its dynamic typing but I encourage you to take a look at Kotlin as well. It's null safety is a great feature and the language in general is very polished. Kotlin's developers (Jetbrains) are also working on supporting Javascript as a compilation target so you don't have to deal with Javascript (which I consider a plus).
If you're using Spring, it's probably best to start with Spring Boot. I'd start from scratch and just slowly add your old logic back into the project. The use of Groovy or other languages is debatable - I'd probably start using Java 8 though. All other languages kind of lie in this "long tail" of usage, so, I'm sure different companies might also use Groovy or Scala, etc., but it's used far less than plain ol' Java. Java 8's seen a lot of adoption though, so I'd get used to working with lambdas, and in particular, the fun things you can do with Collectors. It's also debatable to use the more "microframework" techniques of Dropwizard, Spark (the web framework), etc. While yes, they're nice and lightweight, lots of server-oriented jobs use a DI (Dependency Injection) system like Spring. For example, I've actually used Java 8 and Spark, and used default methods on interfaces as a "trait-like" system as an alternative to static dependency injection. It's fun for small projects, but I doubt many jobs would be interested in seeing this sort of thing happen. 
Dynamic languages are bad when you are building large scale, long life applications. Kotlin is syntatic sugar on Java done better compared to Groovy. It's not very hard to learn. The verbosity in Java is pretty overblown to me as I make heavy use of things like Lombok, previously Guava and now native Java 8, other libraries and my IDE.
Where has NSMenuFX been this whole time? That is fantastic.
http://algs4.cs.princeton.edu/home/
if you want to write more terse Java I highly recommend Scala
Well, i would say twitter is a special case. Architecting ANY software for millions of concurrent users is a waste. I usually prefer flexibility over performance, because in the scenarios I face, the main problem supporting product pivoting rather than mega loads of users.
Is there a better title I could've given it? Thanks!
Design patterns has little to do with data structures and algorithms...
you mean in general or java specific ? because there are those "awesome" lists on github which have some good resources in it one good example is the algowiki.in which is based on the algowiki on github
Primitive type overflow and underflow is very common. When there is a count, potential overflow should be checked because otherwise objects may break after a certain value is reached. One thing which can get confusing are `Collection`s which contain more than `Integer.MAX_VALUE` entries, in these cases that value is always returned. So if there is code which relies on the size of a list then it needs to check if such overflow occurs.
All the time :) One time a primary key on a DB table exceeded 2^31. The service owning the DB and all other services handling that datatype stopped working because they used Integer in their API clients ;) lesson learned - setup alerts to fire when your primary keys are close to magic values (2^31, 2^32, 10^10, ...).
The most unexpected Java limitation I've hit so far is: methods have a size limit. I was trying to create a Map with 7776 items, and initialized it inline in code. My code wouldn't compile, and gave an error "Code too large". It took me a while to find http://stackoverflow.com/questions/2407912/code-too-large-compilation-error-in-java
That is... kind of insane to be honest.
[Rapidoid](http://www.rapidoid.org/) is really fast, quick to develop in and elegant.
This is help with **Java programming** and thus should go in **/r/javahelp** as our Automoderator has already explained and as the many hints on the subreddit indicate. Please, read the [**Posting Guides**](https://redd.it/48eykt) there before submitting your question there.
Interesting discussion this! &gt;https://deltaspike.apache.org/documentation/core.html#AsynchronousOperations This one was added very recently, so no big surprise not everyone knows about it yet: https://issues.apache.org/jira/browse/DELTASPIKE-1094 The development of it seems a bit more subtle than DeltaSpike already has it, now OmniFaces as well. Look at this: there has been discussion going on publicly and behind the scenes between the DeltaSpike and OmniFaces and others (Stephan Knitelius): https://groups.google.com/forum/#!topic/j3e-concurrency/Qyujp62B5E4 I remember a blog from post a while ago about @Locked for CDI, which was a few months before DeltaSpike 1.6.0. Can't find it now. 
I suppose, if you increase the heap size, you can overcome the String length limit (number 2).
+1 for avoid groovy, Clojure for fun tho imo :)
Why Ivy?
That's an unfair comparison with C++, btw. Try Seastar: http://www.seastar-project.org/
I assumed Maven was still the standard.
english can be ambiguous. i suspect they mean constraints encountered in ridiculous situations, not that the constraints are ridiculous for existing.
I gave up asking people standard interview questions like: what's the difference between an abstract class and an interface because I realize I just don't care. But that doesn't mean you won't get those.. Or others like: What's immutable? What is an example of an immutable class? What is the StringBuffer class used for (somewhat obsolete in java8) What is polymorphism and give an example. Difference between method overloading and overriding. Personally I realized that if someone can or can't answer those doesn't really matter to me. I suggest: Know your datastructures, particularly common java libraries Like: What's a List, an ArrayList, an Array, A tree. One implementation of Tree. A Map, A Hash. What is a hashmap? What's the runnable interface for? What's the (main) difference between a checked and unchecked exception in java and/or Exception vs RuntimeException. For Spring: Most people only care about dependency injection and MVC So I guess I'd ask what annotation you use for: setting up a controller class, setting up a method to handle a request, maybe write me an example controller on the whiteboard. probably not stuff i'd ask a junior but they might. I'd just read up on what Spring's dependency injection is. It should be a chapter or so but I wouldn't say it's something easily quizzed on. Also do you know git or svn? Basic commands are fine, only an asshole's going to ask you something like: "whats the command to revert a merge that's already been pushed?" vs. "what does git push do". Last thing: you should know how to write a for loop. If I give you an array of ints and want you to write me a function returning the sum, that should be easy. You'd be surprised how much of a weedout question this is. OH. One last thing. If you have something on your resume be prepared to be asked about it. If you say you know javascript and I say "looks like you know some Javascript too?" and you say "well i took a course 3 years ago and im pretty rusty" then I know you're fudging it, and if you fudged one thing how many more did you fudge? That's not a rejection it's just something any interviewer has dealt with and we all know what "well im pretty rusty, or whatever" means. 
Try [r/cscareerquestions](https://www.reddit.com/r/cscareerquestions)
&gt; ~~to Oracle~~ to Postgres! edit: (no special intermediary library required!) 
GA? seriously I have no clue what the post means because of an acronym...
Bit of a let down
Ah, my bad
All the questions I was asked on my job interview (within the past few weeks), first Java job. First phone interview: **Interviewer**: Do you know what a platform is? **Me**: Platform? In what context? I'm sorry, I know what the word platform means, but in what context ... **Interviewer**: As in, you know that there are hardware platforms and software platforms and that Java is a software platform. **Me**: (A bit stunned.) Yes, I know that Java is a software platform and not hardware. **I**: What is the difference between the JVM and the JRE? **M**: The JVM is the Java Virtual Machine, it converts the code we write to bytecode the computer can run and the JRE is the ... well, the JRE is the Java Runtime Environment and it... Hmmm. I can't quite remember what the JRE does specifically. Let me think. There's the JDK, the JRE, the JVM. The JDK has the ... **I**: That's fine. Don't worry. That's fine. Do you know what the classloader is and what it does? **M**: No. We used classes in school. We used interfaces, classes, and inheritance in the parent classes to child classes configuration, but I'm not sure what the classloader does. I can look that up for you and get back ... **I**: No, no. That's fine. Someone will call you tomorrow. They'll ask you some more basic questions. **Me**: Great. Thanks. Second phone call. **Interviewer**: Is Java pass-by-reference or pass-by-value? **Me**: Java is pass-by-value. If you send a primitive into a method and change that primitive inside that method it will not change outside that method unless you return it. **Interviewer**: Is that the same for objects? **Me**: That's not the same for objects. This is where it gets a little tricky. If you send in, say, an ArrayList into a method and add an entry into that ArrayList it will be added to that object outside the method. An object such as an ArrayList has a structure of items in it ... **Interviewer**: That's fine. That's fine. What if I have an ArrayList A. And I make a second ArrayList --let's say ArrayList B. Now I assign ArrayList B as ArrayList A like "ArrayList B = ArrayList A". What happens if I change ArrayList B? **Me**: ArrayList A will also change. Because when you assign ArrayList B with an "=" sign it's really just pointing to that object (ArrayList A) on the heap. They're the same thing. **Interviewer**: All right. Come in Monday for an interview. In-person interview. **Interviewer**: On the whiteboard can you map out some inherited classes, let's say, using animals. Start with animal and work down to ... dogs. **Me**: I just drew some boxes marked "Animals," "Mammals," "Canines," and "Dogs". I was super awkward and nervous and didn't really know what he wanted. **Interviewer**: Okay, where would ... say wolves be in here? **Me**: I just drew a line over from "Canines" and made another box marked "Wolves." **Interviewer**: Okay, now do wolves and dogs have the same attributes and actions? **Me**: They can. Yes. Or you can override the functions of each so that they're different. **Interviewer**: Okay, would "Animals" be a class or an interface in this instance? **Me**: I don't rightly know. I guess that's an architecture decision. I'm going to go out on a limb here and say it's a class. **Interviewer**: No, it's an interface. (We all laugh.) **Me**: All right. I blew that one. **Interviewer**: No, you're right, this is too abstract an example to say whether it's definitively one way or another. I mean, these are just boxes of animals on a whiteboard. But, we use interfaces here a lot. Our motto is "If it's not an interface, make it an interface. If you can't make it an interface, stop and get someone else to look at it. Then make it an interface." **Me**: Well, I'm a very junior developer. This will be my very first job. I'll rely on the team for much of the design aspect. **Interviewer**: All right. Thanks for coming in. Because I had gotten so many things wrong, I kinda thought I blew the interview. But they called a couple days later and said that I did really well and that they'd send me an offer by the end of the week. Anyway, these are all the job interview questions I got on my first Java job interview which was just a few weeks ago. Good luck. 
For junior positions be ready to defend every single thing you wrote in the CV, since they will want to test if you lied somewhere. That is especially important with projects and technologies you write there. As for something not mentioned before - a common thing in my area at least is to sit someone in front of a laptop, ask him to write a piece of code and then test it, that usually includes unit tests, maybe integration tests with some trivial mocks. They might also try to gauge your knowledge of the 'newer' versions of Java, so don't be surprised if someone wants you to write an equivalent of some simple loop using streams.
Thanks!
Aswell some comments on [InfoQ](https://www.infoq.com/news/2016/06/Gluon-VM-Full-Mobile-Java-9) 
I once was asked why the build failed on one of my coworker computer. I went over and puzzled with the compiler error. After looking at the error for 5 minutes and couldn't get a sense of it, I asked him to show me the code. Then, I stood there in shock looking at a string concatenation with the content of the entire file (I remember it was a license text or something related to legal).
Very cool. Thanks.
Sorry for the noob question but how does this work? It say's they use JavaFX does that mean you build your app with JavaFX components or can you still use native components? Are they going to have wrappers for other native functionality (like notifications)? 
Thanks and congratulations. In a few words, if you do your homework, you should not have any problem passing an interview.
I think it's more that the interviewers are weird. Many times I've encountered interviewers who want to show off their obscure knowledge about X by asking arcane questions. In those cases ask yourself if that is somebody YOU want to be working with
Honestly the best advice is don't specialize in just java. Learn some python, js, ruby or Haskell too. It doesn't hurt.
I wish I'd seen people do it wrong less when still using JEE and/or Spring.
For my case, normally we share only the business logic in C++ while the ui is in native API. We tried xamarin in an attempt to unify our code base before but it cause us more headache so were back to C++ + java/swift
That article doesn't say anything about 4.1.1? And I checked the Maven and doesn't seem like 4.1.1 is up.
How does this work with swift? I thought swift doesn't have automatic bindings to c++ code, only objc-c. Do you expose an obj-c (or just c) API to the c++ code?
Some people say Google is planing to use Swift for Android in the future, that would make sense, one language for both OS, it could profit for both OS, i'm not sure Java could be a thing for mobile anymore.. http://thenextweb.com/dd/2016/04/07/google-facebook-uber-swift/
When it comes to C++, it would be the STL.
That article was written by a Swift zealot. Swift makes less sense than a lot of alternatives Google has at hand. Especially from a business point of view. Also Apple would never allow it / make things extremely difficult. Anyway switching language would be the deathsentence of Android, they would have to add support gradually and mainly SDK access, Kotlin style.
Junior developer, I deal with spring and such, but mostly Eclipse RCP for the almost 2 years of my professional experience. Is RCP useful for a CV or "career" or should I GTFO asap?
&gt; Also Apple would never allow it / make things extremely difficult. https://github.com/apple/swift/blob/master/docs/Android.md
I have shared a lot of interview questions on my blog, you may like to see them for your preparation: * [Core Java Questions of last 5 Years] (http://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html), * [Java Phone Interview Questions]( http://java67.blogspot.com/2015/03/top-40-core-java-interview-questions-answers-telephonic-round.html), and * [Spring Framework Questions for Java Programmers](http://javarevisited.blogspot.com/2011/09/spring-interview-questions-answers-j2ee.html) There are plenty more on different topics like collections, thread, design patterns and basics. Cheers!!
Go away.
because you don't like hearing things with which you don't agree? no. you grow up. i've worked in COBOL and Java. i support a Java EE, Spring based application with 5 levels of indirection and think the COBOL analogy is pretty accurate if YOU don't like hearing it, too bad.
Caveat; I'm not familiar with the gory details of Oracle's process. But this reads to me like "we're going to fix the date and fix the features that will be done by that date", and that is a recipe for cutting quality. Please tell me why I'm wrong.... 
These news about Java EE scare the crap out of me as a junior JavaEE + Spring developer...
Except a ton of new development is still being done with Java.
Yes. And much of it is way too big
Ok sure, but this thread is about Java and JavaFX. I was asking about a pure c++ cross platform solution for gui too. I'll just do objective-c or swift for mac but I'd like to target Win and linux.
Tell me about the problems you solved in your current project. If the interviewer starts asking you trivia questions tell him to go fuck himself
&gt; Oracle has all but abandoned the language Java EE is not the language! What a bunch of FUD. Unlike .Net, Java has tons of well-tested and production ready alternative to Java EE. The death of EE is just a blip in the Java universe. Oracle would be better spending money on improving core Java rather than Java EE.
Nope, It has become fairly clear that Oracle doesn't give a hoot about Java anymore and it needs to cede ownership to IBM or RedHat. Oracle was never a good steward but has gone from bad to actively harmful.
Yes, you should be able to just upgrade a Spring Boot 1.3 application to Spring 4.3 by setting the spring.version property in your POM or Gradle build file. Boot 1.4 M3 is on Spring 4.3 RC1 already, the soon expected 1.4 RC1 will have upgraded to 4.3 GA.
JavaEE is part of the Java standard and requires development from the java team.
Except that Oracle controls the reference platform and the standards that Java EE needs to meet. They are in control of it. There is a difference between a JVM Engineer, Java Compiler Engineer, and Java Standards Engineer however they all need to work together to reach the core goals. Java will succeed or fail based on the general quality of the reference implementation. Just because OpenJDK exists doesn't mean Oracle can ignore their implementation of the JDK or Compiler.
I took it to mean the author feels Oracle has stopped investing in Java (SE) as well... Java 9 is behind on schedule too, isn't it? 
Java release is always behind schedule. I would prefer them to be late rather than rushing. JVM is no toys like nodejs, enterprise demand stability.
JavaEE is a set or over set of specification, reference implementation and API. Most of them have FLOSS implementation (Spring in primis) or better, less bloated alternatives that lives and go further even without JavaEE.
Yeah but that's like saying "Cars have become the new horse drawn carriages!". It doesn't mean that they have the same issues or that they are equally bad. It just means that because their use case is similar, so they have some similar attributes. The worst things I've seen in Java are from the same kind of misguided business decisions that created them in COBOL. They are not a given in Java.
With the module feature of Java 9, you likely will not be needing a full Java EE implementation. If you need REST then you include the REST module, if you need CORBA you include the CORBA module. Instead of having a giant monolithic organization that controls Java EE, the extra modules could be ran by different organizations with their own ruleset. 
Hopefully they'll sell it off now that they realize that they can't get billions of dollars from Google
Looks nice, but what about connecting to a running java process (web server, for example)? How would the results look like and how do I get them?
Oracle doesn't give shit about EE doesn't mean they ignore Java. 
Do you know any mature Java replacement?
The people who run Nodejs are hip start ups, that if their stuff messes up they lose some users. There are lot of businesses that have very large java stacks, and when things mess up there are actual issues. People die. People lose their investment portfolios. People lose their retirement fund. Or their bank account is off. 
&gt;JavaEE is a set or over set of specification Do you mean super-set?
&gt; It's carefully repairing it's verbosity problems, instead of reveling in them like COBOL did. if you're talking about Spring and annotations - yeah, they're an improvement but something was fundamentally screwed up because they were needed 
do you run Android or regular Java builds ? Java 8 ?
Yes that's true. However if it's a jr position it may be more about getting through it to get the experience.
Yep, a comparison should be using `--rerun-tasks` (and possibly a lot of other things like empty caches of downloaded libs etc.).
&gt;it tried to be all things to all people And it's probably best on this way for now.
Java 9 is, from what I hear, behind schedule and still far from as complete as it should be at this point in the new schedule. Jigsaw is a mess
Java 8 with Ant.
Don't worry, you'll constantly need to pick up new skills throughout your career. You'll never be finished! The worst software developers are the ones that just learn a handful of skills and just stop. Eventually, if you do it right, you'll have covered so many different languages, libraries, frameworks, etc., that you'll find it easier to pick up new ones. 
Re-run. Still, mac is faster by 50% http://imgur.com/IHiKANS
That settles it then boys!
The only thing I've heard about jigsaw so far is how much of a mess it is... 
I think the word he was looking for was 'rails'.
I've found it's much more useful to find an area of programming you like - web dev, desktop, mobile, whatever - and focus on learning that rather than a language. I'm a backend web dev. Rather than spending all of my time becoming the best Java dev ever, it's been super helpful to become pretty decent at Java, and also know how to deploy and debug Java web apps - the Unix command line, logging, security, configuration management, a scripting language (I went with Ruby but Python may have been a better choice), and the like. Figure out what you want to _do_ with Java and the rest will come from there.
There is a 4 1/2 second difference between them and you only ran the most basic of builds once. There are a thousand things that could account for this difference. If you really want to compare the speed run a full build in profile mode (`./gradlew build --rerun-tasks --profile`) multiple times on each system and compare the results. 80-90% of time will probably be spent running tests anyway. You should also check that you are using the same version of gradle on both systems (although I would be surprised if it made much difference). Ideally you should use the packaged version of gradle that comes with the project, I think IntelliJ should default to this.
I wouldn't call Walmart or PayPal hip start ups. If their stuff messes up, they lose a lot of money. Node can't really be called a toy anymore and I gladly migrated our stack off of a GlassFish server / Jersey stack onto NodeJS and never looked back. Node isn't for everything, and Java is still critical in the industry (hell, I still teach Java at university) but it's not right to insinuate Node isn't production or large-scale ready.
The hardware is physically different (e.g. the read speeds on my MBP SSD are about 3 times faster than my desktop SSD), System resources could be getting used by something else, power management, cache invalidation. All of these things could account for a couple of seconds difference. It's a couple of seconds difference at most, not worth worrying about.
Oracle's purchase of Sun was also great for lawyers! 
NASA's Director of Software Engineering confirms that NASA uses NodeJS in Space Suits. https://twitter.com/CollinEstes/status/738767017843515393 
Use the excellent EqualsVerifier library to test your implementation: https://github.com/jqno/equalsverifier
The correct ways to implement equals are lombok or your ides code generation ;P
[removed]
When all you can do is rely on a change.org petition, you know that shit has truely hit the fan.
That's pretty much the exact opposite of what the email said, did you not read it?
It wouldn't necessarily mean that indeed, as it are largely two different things. Not entirely different mind you, as sometimes things move from EE to SE (JDBC, Common Annotations, etc). Unfortunately, be it coincidence or otherwise, but my gut feeling says JDK9 shows less activity then JDK8 did back then. Project Jigsaw seems active, but most other things? Not so much. Remember that Java EE 8 wasn't completely abandoned in one day either. Activity slowly dropped, but you had to have eagle eyes to notice it at first. Then it became more obvious if you paid attention, but most people still didn't notice. Then really all activity dropped and nobody couldn't help but notice it. If, on the Oracle abandon scale, Java EE is five to twelve now, Java SE is at quarter passed two. 
&gt;If superclass reflects to IS A relationship and interface to CAN DO relationship This isn't a hard-and-fast rule. Some people use interfaces in a different manner. 
I hope they don't use left-pad when they coded it.
verbosity only matters to you poor hipsters.
yes, i value small code. i recognize i am in the minority. if it makes me ignorant because i'd prefer to do the work of 6 source files in 1 and remove the necessity of managing/tracking those other 5, ok then i'm ignorant companies dropping money on software aren't interested in anything other than reducing that amount of money by any means necessary
here's an unexpected limit that you're very likely to encounter eventually. if a call site is monomorphic the JIT can inline the method. if there are many implementations, then it uses indirection to call the method, which can be 10 times slower. in general, 2 or fewer implementations can be inlined, but some JITs may be different so you can have a critical path in a deployed system that performs well. and then you (or your users) make a small change in a totally unrelated area of the code that adds another implementation of a hot call site. and your app gets 10x slower 
I know what I'll be using in my next batch process!
This depends on if you want to develop software that runs on the card or uses the card. Also, /r/javahelp is the sub-reddit to get help from, so you may get your question deleted and/or downvoted.
They are already fairly involved over Hadoop. If you mean libraries that provide functionality in this area, most is actually already there, atleast in Java or Scala (and therefor also Kotlin). So when your goal is to conquer the disciplins where Python reigns you need to address that community. That will be rather difficult: - Python is easy to learn and academia people are quickly productive, thats certainly not the case with Scala and Kotlin is not a scripting language either. - Python in this disciplin is more of a wrapper around C libraries. - The bad PR the JVM is getting recently. **So the best option would be building something unignorably awesome and make it public.**
@Sqirril - Even though the examples use lambda expressions, Failsafe is actually compatible with Java 6+ so you can use it now with anonymous classes: CheckedRunnable connect = new CheckedRunnable() { public void run() { connect(); } }; Failsafe.with(retryPolicy).run(connect); It's more verbose than Java 8, but it's about as good as we can do. edit: Runnable -&gt; CheckedRunnable (failsafe supports rethrowing checked exceptions)
The word of mouth sharing helps a lot. Thanks!
Oh neat! I'll have to try it now then. Thank you.
I read it, and I think it's fine. Of course, most of the topics in the book have been hammered into my head through school; however, reading some less talked about topics gave a nice refresher. In any case, I'd hope the interviewer would recognize more confidence in my answers during that portion of the interview. (I didn't have an interview, just bought it for the read and to support OP)
If you want some well-designed code that applies principles from Effective Java, you should read the [Google Guava](https://github.com/google/guava) source.
This library? https://github.com/rholder/guava-retrying The basic retry functionality is similar, but they differ in numerous other ways. Compared to guava-retrying, Failsafe: - Doesn't require Guava (which is nice for people/projects that don't use Guava) - Supports async retries - Integrates nicely with Java 8 and CompletableFutures - Integrates with 3rd party asynchronous APIs (like Vertx, RxJava, etc.) - Supports standalone retry/execution tracking - Supports event listeners - Provides a pretty nice circuit breaker implementation ...and wraps it all in a fairly tidy API.
I was aware of AsyncRetry, and the retry capabilities are similar, but one of the main motivations for Failsafe was support for Java 6+ (AsyncRetry is only Java 8, or Java 7 with Guava) and no external dependencies while still providing really good Java 8 integration. Another primary motivation was to create something with as clean/concise of an API as possible (which I hope was achieved). A few other differences and motivation: - Event listeners - Asynchronous API integration and support for 3rd party schedulers - Standalone retry/execution tracking - Circuit breakers Overall, Failsafe is intended to provide different strategies for dealing with failures. Retries and circuit breakers are supported initially, but there may be more to come in future releases.
I work in a team of over 30 in a Fortune 50. Python is for experimentation and answering one offs, we code production in Java. Not having type safety, a compiler, a robust library system, and platform independence means Python is more of a hack and slash scripting language for programs &lt;200 lines, and we use Java to do the serious cleaning, and robust data processing. That said, people who are just learning how to program, might be okay with Kotlin, but there is far less to think about in Python.
One book i would recommend is Data Structures and Algorithm in Java by Robert Lafore.
Seems like the github page wont load for me. Can you give me the TL;DR?
Sure, adapted from the README on github: Failsafe is a library for handling failures with a concise API and a flexible feature set. Failure handling strategies include configurable synchronous and asynchronous retries, circuit breakers, and various other features to help integrate into any type of failure handling use case.
Nonsense
Keep going your service will be very helpful, by the way, how deep you show dependencies? All dependencies or just first level? Another question is it possible to do without storing all data in database at all? Parse it on demand? 
Always the same: Slow, Garbage Collected and Java verbosity. Surface whenever you discuss with people developing in language outside the JVM. There's also a constant stream of negativity from newssites like infoworld, zdnet or voxxed.
Please, please stop using JSP for new projects/tutorial/how to or whatever. Use thymeleaf instead.
I had a lot of similar questions. Like the difference between primitives and objects, sorting algorithms, some SQL questions regarding other languages I used, weaknesses, strengths, the usual. But they did emphasise that hiring me as a junior was primarily done on the basis of wanting to make sure I was willing to and able to learn new things and quickly so. 
Yeah, they should consider a different name. How about ReliefValve. Ok, never mind.
Thanks ! I did not pay attention )
Scala is already used in Data Science, just take a look at Apache Spark for examples. Also look at Weka, a set of machine learning libraries and tools written in Java. Needless to say, you can use these with Kotlin as well. For non java developers though, using Python is just so much simpler since it does not require compilation, and can be easily used interactively. Additionally, the science packages with C library bindings make python very competitive when it comes to performance. Personally I would not want to write a large persistent application in python, but for data analysis, it is pretty dang good.
Apache Camel throttler
Some parts of Java EE will live on, for example JAX-RS, JAX-WS, JPA and JMS are likely to continue strong. The problem is the vast majority of developers have moved away from bundling so many libraries into their application servers. There just isn't as much popularity for JBoss/Glassfish/TomEE as there is for smaller Jetty/Tomcat servers. Not to mention the popularity of Micro Services and being able to quickly bootstrap projects like Spring Boot/Dropwizard only makes using Jetty/Tomcat more desirable. It's not really a Java trend, just the direction server side has moved towards.
We are in 2016 and Java EE is already dead. In banks and other places they still websphere experts and weblogic gurus and applications running on app servers but those are the exceptions. they are java running zombies. 
Java is like C++ but easier. You should learn Java too. But don't let it spoil your love of C++. C++ is a damn fine skill, personally I find it to be too much of a pain in the butt allocating and deallocating memory and chasing pointers and memory leaks, but that's just me.
Possibly, though technology name recognition tends to be contextual - Failsafe and Maven Failsafe are very different technologies. We usually say "Maven Failsafe Plugin" or "Maven Failsafe", so hopefully when someone just says "Failsafe" we'll know they don't mean the Maven plugin thing. Failsafe is really a perfect name for this library, so we felt it was worth using even despite the possibility for occasional confusion.
&gt; The problem is the vast majority of developers have moved away from bundling so many libraries into their application servers Quite the opposite in practice... people claim they're lean to be based on Tomcat, but then take a look at their average pom.xml. It not rarely drags in more than twice the size of the average EE server. Also, most servers won't activate what's not needed. So it's just some 35mb~100mb of jars sitting there, which for most installs is rarely a problem. Should you be that much space constrained and also minifying your JDK, then Liberty may be an option, which lets you very easily minify your server to just contain what you use. Of course, going for Tomcat + bunch of (EE) libs in WEB-INF/lib is also an option, but for many just going with the defaults is the easiest thing. You have a fairly rich environment to start with, without having to worry which dependencies in which versions you need to add to a pom.xml. &gt; Not to mention the popularity of Micro Services and being able to quickly bootstrap projects like Spring Boot/Dropwizard only makes using Jetty/Tomcat more desirable. Not saying Tomcat is a wrong choice, it's a great server and I love it, but something like JBoss spins up just as quickly. Install == unzip, and starting it is 1 second. 
I do like JPA (ORMs in general) for manipulating data, but I won't miss it when querying for data. I'm recently finding myself using different layers for query and command, and enjoying it (CQRS).
I'm learning Java EE now. Should I continue or start something new? I figure Java EE will at least give me a good foundation for enterprise apps
WebSphere is an ancient beast that IBM replaced by Liberty. WebLogic is a bit less of a beast than WebSphere is but still represent the old generation. Many startups use TomEE, JBoss, Payara or Liberty and are very happy with it. We do consultancy and many of our clients are young people in startups that use one of the above.
&gt; Quite the opposite in practice... people claim they're lean to be based on Tomcat, but then take a look at their average pom.xml. It not rarely drags in more than twice the size of the average EE server. I agree that large war/jar files are often the result. At work we have a project that yields a 180mb war file (Spring with all it's insane libraries), that could easily be 20-30mb if done with simple Servlets/Hibernate. However, in practice it really doesn't matter that the war file is bloated, any laptop with a decent SSD/CPU won't have trouble and with continues deployment, proper DevOps and hot deploying no one really notices any thing. &gt;Of course, going for Tomcat + bunch of (EE) libs in WEB-INF/lib is also an option, but for many just going with the defaults is the easiest thing. You have a fairly rich environment to start with, without having to worry which dependencies in which versions you need to add to a pom.xml. The thing is, what if you need to update some dependencies? We have 50+ servers. Developer's should be able to simply update the version in the pom.xml and push their code. Then Jenkins/Hudson picks it up and deploys it. In the real world developers may not have complete control over application servers, so a library update may take much longer because DevOps has to get involved. Not to mention the vast majority of companies these days have at least some components of their infrastructure on the cloud (AWS/App Engine/Azure) which means instances could be spun up and shut down several thousand times a day automatically. Having a lightweight app server allows for instances to become inService much faster which helps with auto scaling and general instance management.
I can understand the mistake. Just added comments to the pom mentioning they're just test/examples dependencies so it stands out a bit more.
Ah, thanks, I'll ask it over there and include a little more detail about what I'm trying to do. 
 *facepalm* I tried to do something similiiar a while back.. I forgot the fsking "superseeds" for some fudged reason. (Even though it's in the 2010 blog post by Geertjan...) THANK YOU for posting this! :-)
I am glad to hear that you found the post useful! :-D
in Java
Yes. JavaScript or Haskell zealots don't care
I work at a decent sized IT company (1200 employees), mostly focused on Java development and lots of projects around here use JPA. Like any technology it has pros and cons. Sometimes it's great and other times it's incredibly frustrating to debug. tl;dr it's definitely feasible in the 'real world'. 
I use it just about every day. EE 6, EE 7 in GF 3.1.2, 4.1. Eclipselink implementation.
Why not both?
I've used Hibernate (~= JPA) for 4 years, and despite it seems easy, it is very hard to use because it does too many stuff behind your back. Perfomance fine tuning is a PITA ; entities get lazy fetched or lazy loaded behing your back. Working in a team with people without great Hibernate experience implied a very carefull core review. On a different project I'm using now QueryDSL for SQL and it's much better. You got so much more control over how the database is queried and updated, without the pain of plain old SQL. 
The opinion I have come to from my experience, and the experience of many others who's opinion I hold in high regard, is very different. It's an overly opinionated and brittle framework. I merged together front end and backend in a single large deployable in an era where services and the UI clients that use them are increasingly being separated.
It's closed source? I have to upload my code? How do I introspect the raw historical debugging data with custom queries? I need a halik login? Yeah... no. Nice idea though.
Legacy and sunk cost I'm afraid.
For legacy projects yes it's relevant. For newish greenfield projects, it's all SPA (single page applications) now.
Which vast majority? Almost every survey and ranking indicates Java EE is used about as much as Spring. Personally I see Java EE everywhere and Spring only occasionally.
You're right, JSF is obsolete on delivery instead of waiting for a few months to achieve that status.
Pretty much, yeah.
you can very quickly mock something up in Java as well. There is such a wide variety of frameworks and libraries that you can quickly get something built and going. Professionally i develop in both Ada and C which is what makes up the majority of the code base on our Air Track Control system but i have written countless tools and simulators on swing and java and it would probably take me 3 to 4 times longer to build something similar in Ada or C. 
Also, while JSF *may* be the second most popular web framework, it's **leagues** behind angular. ~30k questions reference JSF, ~180K questions reference angular.
Same reason they use Spring. because its what they are used to, even though the fact is there are far more lightweight and easier to use frameworks out there. 
SPA applications have their place but are not for everything. I know it was the new hot thing but a lot of people are already moving away from it.
There is not much to discuss if you think one of the most popular Java frameworks is obsolete. It is not like it is just from legacy stuff either. It is much more popular today than it was a few years ago.
Just two years ago I had a two months gig on a new project using WebSphere 6.1. It is still used a lot in the enterprise.
I appreciate it :)
Why are people moving away from SPA? 
Than you are really out of touch with the Java eco system. No one is going to like every framework but you should really at least be familiar with the two most popular Java frameworks if you are going to work with Java.
Partial mocks are usually a code smell from my experience. Consider why you have to use one and think about how you could refactor. This usually results in more focused "single responsibility" dependencies.
The only time I use mocks in my code is when simulating hardware. As in I'm literally simulating a robot in a warehouse. The rest of the time I refactor my code so that I can write real unit tests for as much as possible, then use a combination of functional and integration tests for what's left. Databases and web services are more than fast enough for most TDD scenarios, and when they aren't then you're usually better off fixing performance bugs than refactoring to allow for the use of mocks.
Halik creator here - let me clarify. Your debugging sessions are stored locally. You only need to upload the code if you want to share your session with others. You sign in with GitHub - no need to sign up and create a separate login. Custom queries are on the roadmap. I will gladly answer concerns with closed source, you need to give me more details though.
I find Java to be more fun than C++ - no header files, good debugging, the ability to easily modify code while you are debugging and continue execution, simpler compiler. I'd give it a whirl if you get the chance. 
Go easy please ... It was my 5 year old's first published work.
That's called a confirmation bias. You're surrounded by differing opinions, and the fact that new versions of JSF are still in development after a decade of use, and you refuse to give them any credence beyond "developers I respect dislike JSF".
But apparently not as much as you assumed, eh?
Maybe, JS is evil. Sadly it seems increasingly the future of web development because of its extremely low buy-in and lax standards (lots of young developers are cutting their teeth on JS).
some are, not everyone. one reason is that SEO never quite caught up. going "isomorphic" with react or angular2 universal looks like it will address this. if you're not building something SEO-sensitive (or where only a limited amount is such), spa is probably fine.
The difference is that... can't leave me in suspense here. 
http://search.maven.org/#artifactdetails%7Cnet.jodah%7Cfailsafe%7C0.8.0%7C Here you go! It was a button "Maven Central 0.8.0" in the beginning. Maybe it should be more spelled out, but the button allows it to auto update the version without him having to.
unfortunately it is widely used. it is very effective at what it does. it also allows incredibly sloppy handling of database interactions. in fact most places i've worked, people using it have never even read the user guide.
Google gave me: https://github.com/sudohippie/throttle, looks rather nice, but obviously it's someone's side project for fun. http://stackoverflow.com/questions/1407113/throttling-method-calls-to-m-requests-in-n-seconds gives a handful of ideas, I like the one with `DelayQueue`: If you want to limit to N requests per second, you put N entries into the queue with a delay of 1000 ms, then `take()`, do the action, put pack, loop forever. What's missing in Guava's `RateLimiter`, anyway?
Just one example out of thousands, but the very site you're using now, is it SPA?
JSF is "offical" server side gui framework of Java EE 6 and 7, other option is plain servlet+jsp. 
For those thinking of abandoning tests using mocks (partial or otherwise) in favor of coarser-grained tests, see: http://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam On the specific topic of PARTIAL mocks (a.k.a. "spies"), it's not bad for code you can't change, but if your code is well-designed with SOLID in mind you probably don't need them.
Applets can be baked into a pie, applications need bigger pies? I'm not sure, I got confused somewhere around "they're different because one is bigger than the other"
You're using reddit on a browser, and it's written in ReactJS SPA style.
Yup. Spring/Java for greenfield projects are relegated to just JSON in / JSON out.
Applets are [officially deprecated](http://hg.openjdk.java.net/jdk9/client/jdk/rev/de7a9b3f70a7)
Congratulations to Codename One for their effort keeping Java alive on the mobile platforms besides Android. Apparently with the current mobile and desktop situation, Oracle is leaving to third parties the job of keeping Java alive outside the server space.
Rather watch this serie about test-induced design damage http://martinfowler.com/articles/is-tdd-dead/ And related articles: http://david.heinemeierhansson.com/2014/test-induced-design-damage.html http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html
Thanks for the link. I seldom do any Java besides Android and maintenance projects nowadays. The way Oracle is going with Java, sadly reminds me of Borland when Delphi started to fade. Curious to see what Java ONE 2016 talks, besides yet more Jigsaw and features scheduled for Java 10 and beyond (aka not before 2020), will be.
I feel for you, but a new project and WebSphere 6.1 is incredibly, utterly rare IMHO. Even IBM strongly, strongly discourages you from going there.
Sorry, I have no desire to create a DZone account to look at an article.
Yes the link broke, it worked fine but suddenly the article entered moderation. There is a mirror in the codenameone site.
Is this the article: &lt;https://www.codenameone.com/blog/java-developers-can-finally-target-windows-uwp.html&gt;?
Interesting because with JSF you can write rich applications without having to write JavaScript. I used to work in environments like yours. We needed twice as many people to get the job done. Now I don't have front end developers because we mostly use components that are already written. I guess from your perspective where the front end is someone else's problem JSF does not offer as much. 
Tried kill -3 on several pid, can't get anything. Any tips ?
Was going to post this exact same article. When integration tests fail, they are extremely difficult to debug since they test an entire workflow. I would aim for 80%+ test coverage with 95%+ of your tests being unit tests.
Years of experience with hibernate. I started to use mybatis and spring-jdbc-template and never look back; even in large projects SQL is much more maintainable and easy to tune. 
Try{whatever}catch(Throwable){//shhh}
What about type-safety and renaming columns? Do you keep a reference class for column names somewhere? The only place I've used JdbcTemplate were large, join-heavy select statements, usually to create reports and/or similar. For any (simple) CRUD operation JPA has served me well.
Or not using either JSP or JSF and going with a JS framework like Angular?
Or not using a JS framework like Angular and going with Ruby on Rails.
An invalid ssl certificate :( how hard can it be to configure the lets encrypt client.
I partially agree there but both Microsoft and Apple are moving towards more mobile/desktop convergence so this makes sense in that regard. With convertible devices like the surface the touch UI is really cool...
Is your application redirecting stdout or stderr to a file?
Again that returns to the problem of combining both your frontend and backend into a single deployable unit.
Because I can write sophisticated apps without having to code Javascript as well lean too heavily on a HTML/CSS design person. Also very good tooling in IntelliJ (though this may be true for other technologies as well) allowing me to update managed bean names and have those changes propagated in the JSF pages, jump to class beans referenced in the JSF pages, and auto-complete bean and method names in the page as well. So to me the tight integration, with a controller bean layer, between front-end and back end is actually beneficial. 
So? What problem is that exactly? Split them if and when it really becomes a problem, not because ZorroX on HN says you should do that. For many UIs it's not at all a problem and even much better for performance to have (stateless copies) of your business beans in the deployable unit. In practice it's a fairy tale told by hipsters that you by default need to split them in order to scale.
Maybe just a case of different needs for different projects. I work on internal business applications. They have to look nice but are not like marketing websites. You can use standard HTML tags with JSF and have a designer pretty them up the same as any other HTML app. The only thing the front end knows about the backend is the tag with the data in it. I am not sure why you see it as a big deal to deploy an application. It takes me a matter of minutes.
Yes they are cool at first. We got one too, then after a while it is only used as a (lackluster) laptop replacement.
As a Mac user I totally get that. But I think that's a chicken and egg problem... These devices allow you to use them either as a laptop or as a tablet. So now you use them as a laptop because of the lack of proper touch apps. Once those start coming around the potential/value will change. We saw this with the iPad that became far more powerful only when developers truly embraced it's form factor.
I love Kotlin, would like to use it in production. 
Project Lombok really just covers Kotlin's data classes feature, but Kotlin provides much more than that. From https://kotlinlang.org/docs/reference/comparison-to-java.html: What Java has that Kotlin does not - Checked exceptions - Primitive types that are not classes - Static members - Non-private fields - Wildcard-types What Kotlin has that Java does not - Lambda expressions + Inline functions = performant custom control structures - Extension functions - Null-safety - Smart casts - String templates - Properties - Primary constructors - First-class delegation - Type inference for variable and property types - Singletons - Declaration-site variance &amp; Type projections - Range expressions - Operator overloading - Companion objects - Data classes - Separate interfaces for read-only and mutable collections So, if you want to stick with Java syntax and just cover the data classes type of boilerplate reduction with some other annotation-based voodoo, then go with Java + Lombok; else Kotlin. If you want big data, use neither and go straight to Spark + Scala. Kotlin 1.x stable is out now and supported in IntelliJ, Eclipse, and as an independent SDK.
Then how do you deal with boilerplate?
&gt; It's not an issue with internal applications. Front facing large scale applications it's a bigger deal. At least one known public application that runs JSF and has embedded services is http://zeef.com. Adam Bien had an article about it some time ago: http://adam-bien.com/roller/abien/entry/a_java_ee_startup_filtering It runs on a single server for the UI (read the "What is the zeef.com architecture?" part). 
That covers use cases where SPA is appropriate. There are still use cases for server side web frameworks and JSF seems a safe choice for someone familiar with it. 
If the data is wrong, you can just look where it is set, and go through callers hiearchy (in IntelliJ), or place some breakpoints, look into debug logs... Chances are if the data is wrong, and it is hard to find, then unit test would not cover it anyway, because it is an integration/multi component problem, and you are lucky that it is even covered by some test. And I am telling that as someone who worked on EJB 2.1 legacy system with ~20 layers, traslating shit to shit many times and logic all over the place.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/titlegore] [The open source APM tool inspectIT released new version showing for the first time the new UI-based agent instrumentation configuration](https://np.reddit.com/r/titlegore/comments/4o2kg6/the_open_source_apm_tool_inspectit_released_new/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
What code are you talking about?
Also useful: http://stackoverflow.com/questions/14076296/nullable-annotation-usage
Objects can never be null, they either exist/were created or not. *References* can be null. &gt; Never assume something will never be null. A agree, don't assume that. But there are certain execution paths that might *never ever* produce a null reference. private Object foo() { return new Object(); } public void bar() { String baz= foo(); // baz is never null System.out.println(baz.toString()); } Assuming you're not running out of memory, `baz.toString()` can be called safely. In this case checking `if baz != null` is not needed. Static type-checking tools can help to discover these things, and help to avoid clutter code with superfluous null-checks.
Kotlin fixes this http://kotlinlang.org/docs/reference/null-safety.html and more ;) http://kotlinlang.org/docs/reference/comparison-to-java.html
JSF has close to half of the MVC web framework market. Spring MVC is about the same and everything else is far behind. If you want a clean modern application that uses components for the front end than go with JSF. Look at the demo on PrimeFaces.org. If you like those components than there is nothing easier. They also have an angular library that is very nice. If you have a front end team that has lots of time to work with CSS and JavaScript than Angular might be a good choice. Use caution though, Angular has already gone through one major rewrite and has not yet stood the test of time.
Your question is a little confusing since Angular and JSF are not really direct replacements. Angular is just a javascript library and JSF is a full MVC framework. There is a project called AngularFaces that uses both for example. JSF 1.1 was not very good in my opinion but JSF 2.0+ is much better. JSF has close to half of the MVC web framework market. Hipsters do not like it so it will not show up as much on blogs and forums. Spring MVC is about the same and everything else is far behind. If you want a clean modern application that uses components for the front end than go with JSF. Look at the demo on PrimeFaces.org. If you like those components than there is nothing easier. They also have an angular library that is very nice. If you have a front end team that has lots of time to work with CSS and JavaScript than Angular might be a good choice. Use caution though, Angular has already gone through one major rewrite and has not yet stood the test of time.
Cool work! Yes, I created flame graphs. So they are still in development as we're figuring out new uses for them. Some things have been done before, and many haven't. Summarizing: - Apart from CPUs, some basic other resources have been analyzed: different types of memory events, network events, disk events, and scheduler events (especially off-CPU or blocking events). Examples are in the 2nd half of http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/99 . I think there's more events we can target here. - Width is significant: it's proportional to the number of samples (for a CPU sample graph), or the metric you're profiling (eg, bytes, for a memory flame graph, or total time, for an off-CPU flame graph). - Color usually isn't significant, but we've tried a few things. One type of differential flame graphs use a red/blue scale to indicate growing and shrinking code paths. Other palettes use color hue to indicate types of software (Java, C++, kernel, user). - Root graphs: been supported by flamegraph.pl for a while, via --inverted. Can also top-merge using --reverse. I believe, using the correct nomenclature, a flame graph is really an adjacency diagram with an inverted icicle layout (a layout which has existed for decades). I mentioned that in http://queue.acm.org/detail.cfm?id=2927301 Things that aren't done yet or are more in-progress: - Middle-out approach merging (http://techblog.netflix.com/2016/04/saving-13-million-computational-minutes.html), where the merge point is a function(s) in the middle of the stack. - Differential flame graphs: lots of prototypes, but we need to get it into production and refine it.
I should add, when it comes to Java, we (at Netflix) have been using Linux perf_events and the new -XX:+PreserveFramePointer option to make flame graphs. Background: http://www.slideshare.net/brendangregg/javaone-2015-java-mixedmode-flame-graphs
[JSF is still quite popular.](https://blogs.oracle.com/theaquarium/entry/survey_confirms_jsf_remains_leading) If you only know JSF 1.x, have a look at JSF 2, it's just not the same anymore, as in much much better. I would say choosing between the two depends on your use case. I would prefer Angular for single page applications and the like. JSF for internal enterprise systems, where you need a framework which exists more than 2 years without breaking changes. Edit: I would really appreciate some feedback. So as downvotes should indicate, that I'm wrong, I would be glad to know more about that. Also I know, that the survey isn't showing a direct difference between JSF and Angular, it was just to show, that it's still a valid topic.
When integration tests fail in a way that proves difficult to debug, write a unit test. Maybe even use a mocking tool. Premature unit testing is the root of much evil.
Because there isn't a /r/jvm. Well, there is, but no one uses it.
Ruby/Rails is in long term decline in github usage stats. https://github.com/blog/2047-language-trends-on-github 
I want to use Java SE
I would be interested to see what the breakdown is when discussing greenfield projects, and would want to add the dimension of "we only use the back-end to serve RESTful endpoints; our front-end stack is React/Angular/whatever".
* SPA frameworks - more work is done by the client CPU. * JSF - more work is done by the server CPU. If you have 10,000 clients, that's a lot of CPU workload that the server doesn't have to do. Plus, since client does more of the work, remote network requests are much reduced.
I think the touch area is completly covered with tablets. I rarely ever need both laptop and touch capability at the same time or interchangebly. If I do my tablet or laptop are close anyway.
Only if it wasn't a long term job. I think learning any platform can be as fun as learning any other if you drop any attitudes you might have. Given that, since all else is equal, I would rather invest my time in something that makes me employable. I did have a job interview once at a small company with a ubergeek evangelist. He believed in and the company did everything in Groovy and a nosql database. It sounded interesting and they were very willing to let Java programmers learn on the job, realizing that few people knew Groovy. I got a guaranteed offer from another organization first, delayed as long as I could, it was around the holidays, so I let it go. Probably just as well. Some of the other "progressive" ideas were no desks for the programmers. Everyone sat together in a big room, next to each other on long tables. I think that would have irritated the fuck out of me after a while, not having my own desk, and a comfortable cube. 
One of the nice features of Grails is that it is just Spring and Hibernate underneath, so you can bring out the big guns if you outgrow Grails. GSP is a nice templating framework though. I can't comment on company culture though.
I'm a fan of Grails mainly because the jvm finally got a powerful and sane view layer. Also prior to Java 8 you got some nice functional stuff. With Spring boot and Java 8 it's kind of a toss up. Be careful with Scala and Play. It's a very opinionated toward reactive programming. If you don't need that avoid it at all costs. Why wrap everything in a Future[T] and "for comprehension" yourself to death when you get nothing out of it? Also, as you said, Play's docs really suck. There is no good table of contents. You have to continue to click down and down to find wtf the framework does. It may sound petty but it's just not good. Lastly I'm not a fan of Scala's type system. As Rich Hickey said every bug that ever made it to production has two things in common: it passed the type system and passed the tests. A fascist type system only gets you so far. So in the end it depends on what you need. It goes back to the old adage of using the right tool for the right job. If you're going quick and dirty then Grails will get you there. I wouldn't look at Scala/Play unless you need to scale ASAP, but even then your mileage may vary. All that being said if you're looking for JVM alternatives for the sake of JVM alternatives and have not looked into Spring Boot you are doing yourself a disservice.
Yeah, play is very opinionated. If i want to use it, i would try with java8 or kotlin 
I really like Grails, but I don't have much frame of reference. I used to be a Coldfusion and PHP developer before I zigged into several years of scientific programming (agent-based simulation). Now I'm on a Grails team, and I have to say, the learning curve is pretty forgiving. 
The demo browser is probably not configured to connect through a proxy server, and so you can connect directly to the internet.
I haven't looked at the code in question, but I suspect it's using the JavaFX webview. This is an entire webkit browser baked into the JVM. My guess is that the web-filter runs locally on your computer via plugins. Obviously, these plugins wouldn't impact webkit.
Are there any good reasons to choose Tomcat as a Java webserver today when Undertow, Netty and Rapidoid exist? Edit: apparently not
"Facebook" and "Reddit"... right...
Totally agree with the Play documentation. Like Scala type system though. 
Can you explain the tone in your comment? a.k.a. The Quotes.
Why choose ReactJs over AngularJs 1? What are the benefits for an large web app that will manipulate a lot of data? Doesn't consider Angular2 because its still not bug free
Nice post, took all of 3 seconds to integrate in a couple of our dropwizard services using gradle, and another 5 seconds to get circleci copying the html as build artifacts
Groovy lost Pivotal sponsorship and its future is unclear. 
[removed]
nice one!
They will migrate to different platforms within the next year according to the preferences of the maintainers of those projects...
This seems like a sensible decision for all the same reasons the Google Code shutdown was. There are a significant number of better alternatives now. &gt; The problem is that Java EE JSRs and GlassFish itself is heavily reliant on java.net. Reliant how? If there are specific concerns that alternatives will fall short of requirements then this needs to be addressed of course... But is this really the case? &gt; Oracle so far has not announced a transition plan and is basically asking everyone with java.net projects to do any migration on their own. [Yup, this seems pretty reasonable to me.](https://community.oracle.com/community/java/javanet-forge-sunset) I don't see why the project teams would need (or want) their hands held more than that through the migration process. &gt; A very troubling possibility is that it is being done because Oracle is backing away from an open standards based collaborative development approach and instead pursuing a highly proprietary, unilateral path. I can somewhat understand those fears in general, though it seems pretty speculative, and I don't see how this news in particular provides any evidence for it. (Interesting to see Reza Rahman's name pop up yet again where FUD is being spread...)
Nice article, but there is a copy paste error in the Diagram. "What is the main focus of your use cases?" is mentioned twice, another one should probably be something about stored procedures.
&gt; Reliant how? Mailing lists and JIRA issues mostly. Project pages too. &gt;I don't see why the project teams would need (or want) their hands held more than that through the migration process. Because many of the projects that are most reliant on java.net are Oracle projects. So it's Oracle that should transition its own projects, but it has not announced any plan for that. Where are all the existing JIRA issues going to be migrated to? Will they even be migrated? Will all the existing users who created the orginal issues and provided comments still be linked to the right users after migration (if that happens at all). What happens to the mailing lists? Will all current subscribers be migrated to whatever new platform, or does everyone has to subscribe again? What will happen to the large archive of mails? Will that be migrated? Will links be preserved? Will java.net stay up with redirects in place? A lot of source code and existing discussion refers to JIRA issues. E.g. "This was fixed because of JAVASERVERFACES_SPEC_PUBLIC-320". Or even using the full URL: "See https://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-320 for details" It would be kinda bad if all that crucial information would just vanish. 
&gt; SPA frameworks - more work is done by the client CPU. &gt; JSF - more work is done by the server CPU. And what do you think users will prefer? (hint; think batteries, hot devices and fans spinning up) 
Good catch :) Fixed. Thanks a lot!
Are you talking about the Linux kernel?
It doesn't matter whether it is Java or not, as long as it uses different log levels. Does it?
Try sparkframework. It's small and minimalistic and you'll have your web app up and running in hours. I love it. Guice can give you all the DI you need. However, then you need security, and you miss Spring security. And programmatic transaction management is a pain the ass, so you miss declarative transaction management. And some batch jobs should run at 6am, so you expect an @Scheduled to work. And you want to cache some expensive service calls and @cached is not present. And... you end up thinking why the heck you didn't started with Spring Boot. To be honest, everything you need can be done in spark+ guice + ... . Spring boot just makes every integration easy. No, I'm wrong. Each integration is harder with Spring, but the whole work of integrating with every external library is easy. Start with spark+ guice, and keep your business code well separated from your framework code, and if the time comes in a couple of days you can migrate to the Spring world
You wrote an application which is used by users. If the application crashes they can provide you the log to see what actions the user took to recreate the bug. If you are writing in Java the StackTrace is not everything, because the users could only use an older version because of various reasons and since then the code base changed. Logging will tell you more detailed information what the current state is (provided you coded it that way) Log Levels are an additional useful feature. Somethings while you are developing the application you need more information, but they are useless and just spammy for the user. You also have the option to merge logs or scan logs for specific things, if you print them in a specific pattern. It is rarely fun to scan through multiple GB or TB of data manually if you are searching for a specific thing.
You may not have installed 'word for windows' but I'm sure you've installed native applications on your PC and on your phone. SPA webapps are Rich Internet Applications similar to native apps where every click doesn't necessarily create a server request to get the next HTML page from the server.
Something with log levels would e.g. be the xorg logs.
You can even combine them in single queries: http://www.jooq.org/doc/latest/manual/sql-execution/alternative-execution-models/using-jooq-with-jpa/using-jooq-with-jpa-entityresult
What do you use when querydsl is not enough?
&gt; Because many of the projects that are most reliant on java.net are Oracle projects. So it's Oracle that should transition its own projects, but it has not announced any plan for that. Sounds to me like they're just leaving it up to the individual project managers, like they said. I see no reason to suspect internal projects will be forced into some secret malicious/poorly-thought-out migration path. As for general migration issues... Good point about links and stuff not working, I doubt they'll do much in the way of setting up redirects. Still though, whilst migration is certainly a pain in the arse and will leave a few dangling threads, I don't think it's all that disastrous. I do know (or am pretty sure at least) that JIRA can be imported into a new host whilst migrating users properly. But yeah, there could be loose ends migrating to other tracking systems, depending on how comprehensive any available import procedures are... Email archives can probably be imported to e.g. Google Groups via their migration API. Again, I'm sure other solutions exist for this, too. Importing subscribers isn't exactly the most complicated thing in the world. It's pretty much just a list of emails...
&gt; Sounds to me like they're just leaving it up to the individual project managers, like they said. Unfortunately I don't think it's that easy. The individual project managers are the spec leads, who have been re-assigned by Oracle (see the ton of postings about this lately). I've spoken to individual spec leads in the past. They can't really on their own migrate. It's an Oracle infrastructure team or something like that, that normally takes care of this. &gt;Still though, whilst migration is certainly a pain in the arse and will leave a few dangling threads, I don't think it's all that disastrous. I think it's pretty bad by itself, if it happens at all. But the lack of any communication regarding any migration, specifically given the fact that all spec leads have been re-assigned and Oracle silently pulled back from Java EE, is a little disconcerting. There are certainly options if Oracle (and its spec leads) are willing and given the opportunity and resources to do so, but are they?
Just for the record, I did not downvote you. 
It's not that simple you have to remember that doing requests also costs battery. I have never heard of a single study on which kind of app uses more battery, SPA style or JSF style.
When working with data pipelines there's a lot of metadata logging along with application heartbeats and general quarantine information. 
&gt; What are open-source applications with effective usage of logging? Come on, put in some effort yourself would you? Pretty much any Java application / framework uses some kind of logging. 
No problem!
http://openjdk.java.net/projects/code-tools/jmh/
This is the path we've taken and it's a good one IMO. If you need more frameworks, migrate toward Spring. If you need less (like we did) abandon Spark and roll your own. Great to get going quick and iterate as you discover what works best for your requirements. 
Im not crazy? Sure theres a lot of tedious boilerplate in java but a good ide can take care of a lot of it or make it quick. On the ither hand i can look at a piece of java code and very very quickly understand whats going on, what types variables are, whats being called, etc. In these newer languages they've gone so overboard with removing "boilerplate" code that its damn near unreadable. Id much rather take a few extra seconds to write the code than to take an extra couple minutes teying to decipher what its doing. Ive been trying to learn gradle and kept wanting to tear my hair out trying to figure out what was going on in the groovy sections. I was taking a look at Kotlin the other day and it does do some really cool things and i do plan to learn it, but parts of the syntax (or lack there of) it already have me hesitant to embrace it. Hopefully deciphering the code is one of those things that comes easier with use.
The fact the it still gets new releases after all these years is a good reason, if you're thinking long term. You may also get better community support because it's the common ground. Depends on the project, really.
To be fair to Ceylon, it's hard for it to die when it never actually came alive in the first place. There is nothing fundamentally flawed with it, it's just a matter of conjecture. If it finds its niche, it could pick up steam. It took more than seven years for Scala to emerge as a viable option. Ruby came out in 1995 and wasn't used that much until Rails came ten years later. Python waited 9 years before version 2.0 made it popular. Language popularity isn't an overnight thing.
I'm not really clear what this is from the landing page. I had to go into 'core' library to understand. It seems similar to http://www.dropwizard.io/0.7.1/dropwizard-core/apidocs/io/dropwizard/Application.html
Can someone define what a complex query is? Edit: so far answers range from a query with a join to a query that is 400 lines long. Kind of makes it hard to navigate the diagram when people interpret "complex query" so differently.
Very true. The same could still be said for Kotlin which, while there is still a lot more to hear about it out there, it still sees precious little use. And the same is true of Clojure I guess, despite my own bias.
I do not understand what kind of applications? Desktop, web, mobile, 3D?
Yeah, good support and stability might be a good reason. Still, I think the Java community has a problem with moving on to better things. Java may just be the next COBOL if we don't modernize or adopt newer innovations.
A simple definition might be anything with a join.
There really are many Java communities, ranging from government to valley startups. And there never was an Internet-enabled community for COBOL like the one we have now. Our future is bright. :)
Is this an advertisement for JOOQ? JOOQ is not free. Better stick to QueryDSL or JDBI.
From what I can [see](https://github.com/jpkrause/jx), this was made around 2001. Not bad.
It bothers me that the four nodes (the question and three answers) that come after "standard CRUD" are exactly the same as the four that come after "a little bit of both". It seems like there should be a way to simplify the diagram by not repeating those.
I'm alergic to ORMs , instead I have an utility the generates the JDB clases reading the structure from the database or a class, it can generate the code in Java, C# and Ruby, it takes me a minute to generate it and my Entities are annotation free.
It costs money though - seems that for most use cases (like the blog post indicated), queryDSL is more than sufficient (and free). 
what about Looking Glass OS https://www.youtube.com/watch?v=JXv8VlpoK_g that was java based and made from sun
No, it's not an advertisement for jOOQ. I'm the author of the initial post on which ykushch based his diagram http://www.thoughts-on-java.org/use-jpa-next-project and I prefer JPA for the most common use cases :-D QueryDSL is of course also an option and I added it to the post.
But I am looking for "effective usage", where programmers have learned what is the most effective information to log.
Kind of reminds me of the Component framework/architecture in Clojure (if you're familiar with it). 
Looks like that was fixed. Another thing: when I click `@CheckForNull` in that [same class](https://github.com/Tillerino/Tillerinobot/blob/master/tillerinobot/src/main/java/tillerino/tillerinobot/BotBackend.java), it takes me to a [404 page](https://sourcegraph.com/code.google.com/p/findbugs/-/def/JavaArtifact/com.google.code.findbugs/annotations/-/javax/annotation/CheckForNull:type).
But to be fair, us devs do drink a fair amount of coffee :P
True ;) Most serious error a programmer can encounter: **Out of coffee error** (I need to get another cup...)
 http://www.jnode.org/ 
You might find real user reviews for JMeter and all of the other major load testing tools on IT Central Station to be helpful: https://www.itcentralstation.com/categories/load-testing-tools. Users interested in JMeter also read reviews for Neotys Neoload. This IS QA Manager looked at JMeter but ultimately chose Neoload because "it's provided a faster turnaround on load-testing creation and the ability to use the team servers so multiple people can use this at once, which we couldn't do before." You can read the rest of his review here: https://www.itcentralstation.com/product_reviews/neotys-neoload-review-35800-by-isqamgr347. Good luck with your search.
Thanks for the tip, I'll check out Ceylon!
I had such high hopes for Looking Glass. Those early demos were slick.
I would be great that methods in a controller return Single instead of Observable. (but keep it for SSE or Webstocket stream for example)
Thanks :)
mvn [dependency:resolve](http://maven.apache.org/plugins/maven-dependency-plugin/resolve-mojo.html) -Dsort=true
&gt; mvn dependency:resolve -Dsort=true thanks for the tip. I ran it, but it doesn't quite meet my requirements (granted, I wasn't super clear about those requirements in my post). The site plugin includes additional information about the dependencies, most important to me is the license information if available. This generates a nice list GAVs (with no duplicates I might add, which is amazing), but I need a bit more information than that. Perhaps it's possible to use maven to ask for all available metadata on an artifact? With the list generates by the dependency plugin I could whip up a simple script to get all the metadata I need per artifact... 
The [license-maven-plugin](http://www.mojohaus.org/license-maven-plugin/) might be of some use.
That's something we can consider. In a lot of our controller methods for example, we will end up making a DB query (using our DatabaseClient), which returns a Observable of Rows and we then apply transforming operators to that stream to transform to some model entity, and finally into a response. So we do end up having a bunch more controller methods where returning Observable instead of the Response directly makes sense. Note that in our HTTP API, the Response is different to the body of that response. So when the Observable from a controller emits a Response, we can send the HTTP headers for the response immediately. But for streamed responses, there is a separate Entity that the Response can return that returns an Observable stream of data making up the response body. We stream those as chunks. Not sure if that is clear from the API. We're working on some examples, and more documentation.
How bulkhead work without a separate thread pool? I know hytrix has it thought out very well. Nice code though!
mvn dependency:tree -Dverbose will list all a project's primary and transitive dependencies. It's not exactly flat, but you could parse the output to strip away the branches I guess. Edit: spelling
I'm not familiar with it, but I'll check it out. Thanks!
This is what we use.
As much as I enjoy reading these posts, and find that they're informative and very useful, it always bugs me that they are also very strongly just advertising the product at the same time.
IBM products.
java is the new COBOL because its so damn wordy
Lets talk about intellij, before helping me with my homework question.
I'm the author of this book. If you have any question about it, just let me know.
Intellij or eclipse?
java is typed. 
When do expect to complete the book? At 400+ pages I can only imagine the amount of time that you have put into the book thus far!
It's 90% done. The last part is going to be an overview of jOOQ, so I hope I can finish it all in two months.
Spring Boot sucks
Code throwing unchecked Exceptions sucks.
Java is dead.
Java sucks, this sub is pathetic, and you should all be less upset about the fact that people are choosing newer, leaner alternatives
You should try Scala
Google rewrite Android API in Swift.
By the end of the summer, it should be ready.
JSF yadda yadda yadda Spring MVC blah blah.
&gt; I prefer JPA for the most common use cases :-D I will convert you to s/JPA/SQL, just you wait :)
You can get a virtual private server from a company like Digital Ocean for $5/month, it's their smallest server but it will work fine for your purposes. There's many VPS providers that do the same thing... Anyway you get one of those and setup Linux on it, I'd suggest Ubuntu, Debian, or CentOS. With VPS providers you just click which Linux distribution you want and it'll automatically set it up for you. From there, you can SSH in and setup your website. Digital Ocean has a ton of tutorials on setting up servers, so I'd suggest checking those out. They'll be helpful for setting up Java based web apps. 
Now hiring, Java (better known as JavaScript) developer for fast-paced starting company with plans to dominate search market share.
Java is a crappy language because it keeps crashing my browser.
Java is ded.
True..it's a good advertising showing us how the tool works against famous frameworks. 
AbstractFactoryBeanFactoryImpl lol
I just don't understand why anyone would use interfaces over inheritance.
Netbeans or JBuilder?
What are some equivalents to analyze Java source code?
Discontinuation of Visual J++ was the beginning of the end.
Consider AWS [Elastic Beanstalk](https://aws.amazon.com/elasticbeanstalk/). It will manager the server for you. You just upload your WAR file.
https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#Java
eApps' Jelastic service. Supports Tomcat, TomEE, WildFly, GlassFish, and also Docker, which allows you to deploy anything.
Java is the island
Funcitonal programming is the only right way to program.
With those two choices only, I'd go with Groovy/Grails for sure. I dislike Scala's syntax. Play looked interesting but then went heavy into Scala it seemed.
Oracle made Java great again.
&gt;Abstract...Impl God damn it.
But shouldn't you be using the interfaces (List and Map) in your exported API so you can switch them if it should become necessary?
string
Fight me IRL.
I don't mind it!
Java 6 build 21 is the best.
Vector isn't deprecated. But it's not recommended. https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html The issue with Vector is that it's synchronised, where as ArrayList (and the other new collections) are not. You can replicate Vector with List&lt;String&gt; list = Collections.synchronisedList(new ArrayList&lt;String&gt;); The main advantage of that is that you can use the right backing list for your situation. 
I'm using Java to validate the forms on my webpage
import *;
Bucky Roberts at thenewboston? It may be getting old... but it should do well for you. Then research separately through google for whatever project you plan on working towards.
What you use Java? Haven't you read on the news: Its not secure!!
Checked exceptions are fine. Not integrating them properly with generics and lambdas is the mistake. For example, imagine if you could have a `Function&lt;File, String throws IOException&gt;`. That's a function that, when called, accepts a file and either returns a string or throws an IO exception. Then you could pass it to `Stream` methods or whatnot, and have the checked exception pass through correctly and still be checked.
Why did not you move to Scala yet? Are you working on 20 years old enterprise?
You are just not good enough to learn emacs.
I have a business idea but I can't code
Most of the learning subreddits would recommend NOT thenewboston. 
Hey if it's what drives someone to learn programming.
what I ended up doing was hosting my project as a free app on heroku, might work for you
lucaseder
ShitSphere
Bangalore it
Debugging JSP syntax errors in raw servlet code.
There is one on udacity hosted by a very hot chic
this! Vector isn't deprecated, you just have this locking (probably unnecessary) in place.
MochaHost tomcat host is good
This made me want to attack you so bad till I remembered the title of this thread.
J2EE.
I had an interview recently where the ad said Java experience and the interviewer opened with c++ questions. Somehow a disconnect took place they didn't actually want Java. 
Well, the desire to make a Minecraft mod is what made me learn Java, how to use Photoshop, and a whole bunch of other things. I've since then moved to Android development, but damn me, it's hard.
#FXForLife
I was just told about heroku today by another student. I don't know what it is but I don't totally trust it. why is it totally free? guess my paranoia and lack of knowledge is keeping me from diving in head first on it. It just seems too good to be true.
i can fake linux to some degree, wouldn't say I know it though. I assume VM is virtual machine?
This is good IMO.
Fuck you you fucking [insert racial slur here], your mom is a slut whore prostitute and your dad loves to get fisted by gorillas.
It's appears totally. Free because it is *not* totally free. From my understanding (I am not a heroku employee, or a professional, just a student who just finished high school), heroku is more of a market place that allows you to link together various containerized services, or host other Web Apps. On the free service you get a bunch of limitations (only able to run for 300 hours a month before confirming a credit card), weaker hosting platform, not fully featured, but for what you are looking for, heroku seems like the best option. 
Java's standard graphics libraries are very capable and easy to use.
Nobody uses servlets anymore. \- or - Nobody uses JDBC anymore.
Have you heard of my lord and savior gradle?
Intellij Master Race
Wanted: Java applet coder. 
Java is ugly
Microsoft Works
How do I fix null pointer exception?
J2ME
You just made me legit sad.
I am getting a ClassNotFoundException. Can you help me? Ps- what is a jar file?
Java is pass by reference for mutable objects but pass by value for primitive data types and immutable objects. 
lol, umm no. Java passes references to objects around. everything is pass by value in java. 
Everything IS pass by value but Java *copies* **pointers** to objects. 
Chennai that shit dog
 try { //lots of spaghetti here } catch (Exception e) { LOGGER.error("somthing went wrung with system") }
&gt; Have you heard of my lord and savior gradle? I remember interviewing at this one place and there were like "You've *used* that *filth* they call Maven?" 
 catch (Throwable t) { // should anything go wrong... } 
I think a lot of it is people talking past each other, to be honest. I'm not sure if this is what you're looking for, but in my experience people use Java for the JVM and/or the ecosystem, and not necessarily for the Java language. (Everyone loves the JVM; Scala, Groovy, Clojure, JRuby, Jython; Java has some killer libraries; and the build toolchain is second-to-none.) So when you hear this debate, I think it's important to separate the ecosystem/tooling versus the actual language. As the language goes, C# evolves faster and has some neat language features that Java hasn't caught up with (events, async/await keywords, properties, extension methods, and my personal favorite that's new in C# 6, the null-conditional/null-propagation operator). Until Java 8, for a long time, lambdas were on this list, and the data processing facility that we now get from Streams. Most of the stuff you'll need to write an app is baked into the .NET framework, whereas Java isn't really complete without guava, apache (especially commons-lang), and depending on your app, arguably Spring. So when I/we talk about Java we usually implicitly mean "Java as augmented by what have come to be standard libraries." From an ease-of-use (language-plus-library) perspective, Java 8 versus C# 5 was nearly an even match (as someone who's used both extensively and professionally) but C# 6 inched ahead again. But you still have to put that up against the fact that in Java land we've had sensible dependency resolution capabilities that the .NET ecosystem has only recently come close to with NuGet. And NuGet still isn't there. From an enterprise perspective I think Java edges out C# on the strength of the build toolchain, cross-platform support, and (arguably) performance (not least because iirc the JVM JIT has more layers of code cache than the CLR does). So tl;dr that was not brief and did not describe everyone's stances, but I did try to point out the pros and cons. Correct me if I'm wrong.
Since so many Java devs have no experience with true pass by reference and constantly make this mistake, THIS is what pass by reference looks like: Person bob = new Person("Bob"); Person jeff = bob; jeff = new Person("Jeff"); bob.getName(); // "Jeff" Java is always pass by value, but for objects the variable is always a pointer that is automatically dereferenced. Does "NullPointerException" sound familiar? You're passing around the value of a pointer, not a reference to an object.
I'm guessing its the exception that is thrown
One thing that always gets me with intelliJ fanboys is that they're so feverishly proselytizing. I mean yes, I get that it's good, but it's a fricken IDE, not a religion.
What about him?
JEE
You're all shadow banned. Nah, just kidding. But it sure would be annoying...
 catch (NullPointerException e) { // oh well ... }
What happened with that build?
Nothing that I know of. I was just suggesting that one particular outdated build is the one you should use, because I'm too lazy to re-write my app to support anything modern.
I double clicked the jar file, but it is just a zip file.
My MBA manager, who is directly overseeing a project with a Java backend and Javascript front end, does not know the difference between the two.
Java still stands out with fairly seamless cross OS development and huge external libraries. It is the reason I am developing my etl process right now in Java. I get to use Lucene and run on windows and rhel.
This is about docker right?
I stopped using Heroku's free tier about a year ago when they changed their TOS and had mandatory 6 hour downtime every day. I see they changed it now, but who knows what will happen in the future? Also when I was using it, they also restarted my server every day for no reason and so every day I had an outage for several minutes. I moved to OpenShift's free tier, but discovered that sooner or later they will brutally force you to paid plan: https://www.topjavablogs.com/news/free-openshift-tier-it-was-a-nice-dream-but-that-s-all So at the end I moved everything to VPS (provider very similar to DigitalOcean) and since then I'm very happy and I think it's the best solution.
Pass by reference of the value
Aladdin 
java allows you to upload files in browsers.
Scheduled thread pool tasks? 
I actually had to override finalize() once, when trying to use Java and opengl. That's the only time I find a legit use of it
Ahah, I'm not even mad
Why didn't they write this Java app in Python?
Knock knock. Who's there? ... ... ... ... ... Java.
Please, don't recommend thenewboston. They are a [discouraged resource](https://www.reddit.com/r/learnprogramming/wiki/index#wiki_discouraged_resources) as they teach questionable practice. They don't adhere to commonly accepted standards, such as the [Java Code Conventions](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html), use horrible variable naming ("bucky" is under no circumstances a proper variable name), and in general don't teach proper practices, plus their "just do it now, I'll explain why later" approach is really bad. [Derek Banas](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) covers about the same ground, but in much better quality.
Optional is great. For example compare User user = userDao.findById(1) .orElseThrow(NotFoundException::new); and User user = userDAO.findById(1); if (user == null) { throw new NotFoundException(); }
Was the same for me, I learned modding and java at the same time, but I was already doing OOP for a few years before that. But if you have never written or even seen code before, you should first learn the basics of the language and then start with your project. And I think it's great that people want to start learning java because of Minecraft but before jumping into modding they need to learn to code. I once tried to start writing android apps, before writing even a few lines of code I needed to read through the Android API Reference for at least five minutes.
I see this *so* often with our entry level hires. What are colleges teaching people about error handling?
Tell me about it…
But muh destructors!
I'm just done with a school assignment that for some ungodly reason involved Swing, and I'm triggered beyond any belief right now. Finally lost my shit at public class JSlider extends JComponent implements SwingConstants Please kill it with fire.
FROM THE NOTHING IT'S BECOME.
Any good recommendations?
&gt; Sedgewick and Wayne for a beginner...but it and many of the others on this list are not free nor freely available through this link? Sorry for the confusion. I probably need to do a better job of laying out the page. The table of content links are meant to be a quick scan of the books which you can click to jump to that particular book on the list. Once you are in the main body of the post, clicking the book title will take you to where that book actually lives.
import java.lang.*; Yep, I've seen that in production code. 
TL;DR: More bikeshedding NULL
Can you pseudo code your thought? From this it sounds like you're just looking to use `super.method()` somewhere in your child function.