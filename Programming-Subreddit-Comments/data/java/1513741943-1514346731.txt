Spring Boot. Also JavaConfig took a lot of the sting out of Spring when they introduced that.
Probably Spring
Docker and k8s can be used with Spring/JavaEE... 
Our shop uses JSF with PrimFaces for itâ€™s widgets. EJB for persistence. Granted we are quite experienced with it, but I think itâ€™s pretty easy to learn although perhaps not always flexible. A new comer in our office is Vaadin, which Is something of a an anomaly but it looks great and you can do everything in Java without having to mess with xhtml, although you can if you want. It is a refreshing change but I am still wrapping my head around it. Those are the two choices I would go with. Spring can suck it. Just kidding, I donâ€™t really care. I tend to lean towards frameworks that have very few configuration files embedded in XML. I mean there will always be some, but long XML files sicken me.
NumberFormatException is unchecked.
I agree with everything said here, but my experience is if you're choosing between the two Spring has a $$ advantage where there are more opportunities to choose from. That's not a thing that matters though if you are familiar with one you're familiar enough with both. I haven't used EE since... well, a REALLY long time ago, but if I had to pick it up I would probably need a week to get up to speed for 90% of the work.
for my R0.02 Know both stacks, however my preference leans heavily towards spring. Some organizations who have invested in JEE will not move away from that investment so if you want to marketable I'd know both. Also invest time in build automation (gradle/maven), CI(Jenkins, bitbucket, travis-ci), Continuous Delivery(CD), 
I am, as we speak, writing a greenfield app with Jooby. It's quite good! We also use Jooby at work, although we aren't using its unique features very heavily - more as a thin layer between business logic and HTTP/websockets. 
My point was that it's actually a pretty common occurrence that parsing a number will fail. As such this is not a "blow up and stop the world" situation meriting an exception, but use of an Exception as an alternate return value. A more sane API would have been to return Optional or null. But instead we have an exception. This is just bad API design via exceptions. and in reference to "Heck, even the standard library (atleast the older methods) is guilty of this" 
In my example, both of `handleCommand`'s `catch (IOException e)` blocks include the filename (`args[0]`) in the message printed. For server applications, checked `IOException` for filesystem access does get annoying. I end up doing this an awful lot: try { ... } catch (IOException e) { throw new RuntimeException(e); } (I wish there were a more concise way to do that, though I'm not sure what a good syntax would look like.) But even in a server application, there are times when you need to communicate with systems out of your control. When I open an `HttpURLConnection` to some third-party web server, there's always a chance it could fail and throw `IOException`, which should be handled specifically rather than treated as a bug. And, if I was lazy and wrote the surrounding code in a way that would leave things in an inconsistent state if the request fails - then it's a very good thing that a checked exception forces me to be aware of that possibility. No system is perfect for all use cases, but better to err on the side of safety.
I do acknowledge there there are cases where you get overloaded uses of `Optional`, but I do think there are also many cases which fit it pretty well. One I've seen a lot are auxiliary address fields like "line 2" or "city" that can be either present or missing. Maybe this is just a case of functional vs object oriented design? I'm looking at data classes as algebraic data types (simulated with something like Immutables) that are open to decomposition and inspection, and where the type system enforces constraints like cardinality of fields. You seem to be considering them more like stateful OO objects, that hide their internal workings and which implement behaviour on their client's behalf. Part of that might come from working with microservices - I feel that the ADT approach is a much more natural fit for JSON-mapped data. Funny thing is, Java's planned pattern matching, data class, and sum type support means that the language is moving towards supporting proper ADTs. Just like Optional has supported a move towards functional programming by encouraging monadic sequencing and the resulting deferred "interpretation" of the empty case, so it seems like there will soon be a lot more language support for ADT-esque approaches than traditional OO ones.
Spring Boot then move to spring boot 2 with spring 5
http://dropwizard.io Unlike Spring, Dropwizard applies a lot less magic. It is not a platform built from scratch but instead a collection of popular Java tools/libraries and a little bit of glue to make them work together nicely. That way you get the best that the Java ecosystem had to offer without getting tied in with a specific vendor.
Having used Spring and DropWizard, I much prefer DropWizard. DropWizard seems to me a more neutral collections of some of the best tools for each job, and it's both simple and easy to use. Spring is just Spring, Spring and more Spring, and while it's easy, it's not simple- there's a LOT of magic going on.
I agree but to employers it seems to be one or the other. I prefer EE but it seems like everyone just wants a spring/hibernate app. 5 years in each. Fml. 
Spring Boot.
Thanks for the info! I would also like to be able to implement my own framework but i dont know yet how that could look like programmatically. Especially the anotation features like @webservlet , jpa etc. Maybe ill take a look at how spring does it.Btw do you consider javaEE a framework? I though its just the languange side for the enterprise features. As for resumes for the first enterprise job , what kind of project would you think is needed on github to have a good chance? Should it be something large that uses every javaEE api and spring feature? Or smaller samples with various topics? . 
Grails ftw! 
What level of knowledge do you think is necessary to be marketable as a junior? Should i just know how to use the major features of both with an IDE? Or should i know how the low level works and how usually automated components would be used without maven automation? Should i contribute to the open source code of either to prove my knowledge on github? 
&gt; I want my code to fail fast and fail hard This nothing exclusive to a *checked* exception ðŸ˜‰
from what I know, spring dominates the market but you should worry about these kind of things if you have really no worries about acing the interviews. interviews focus about algorithm, cs concepts. + you write code so master a language so that you can syntactically correct code on paper. once you join a company, you will be guided on the frameworks technologies they use. 
I think im ok with general programming and CS concepts. I may not remember how to implement an AVL with c + pointers but its not really something i care about a lot , it's pointless these days to go such low level. I would like my future job to be more about the architecture of applications and the abstractions than the actual algorithms , since i also have semi business + IT Systems knowledge.
I think the Open Source thing is a great way of proving your credentials. Pick a project - I suggest an Apache one that interests you, because a) there are loads of them and b) they have a very well written, easy to understand, standards around contributing. In addition blogging on things you discover or find interesting on your development journey can be helpful to promote yourself and your abilities as they grow. It doesnâ€™t have to be on anything new (anything you write on Spring or JEE has probably already been written as nauseum) but itâ€™s more about your take on it and the process of discovery. As a consultant in the enterprise space, I find that whilst there is still a huge portion of the market out there for Java, itâ€™s not necessarily quite as black and white as â€˜Spring or JEEâ€™. As with all things, there are nuances. For example, in addition to tools like Spring Boot or Tomcat / Wildfly, Eclipse Microprofile is starting to gain traction - which is effectively just enough JEE to be useful. Vert.x and reactive frameworks in general are becoming more prevelant in the Microservice space. Serverless architectures - Lambda and OpenWhisk in particular - are of interest to enterprises looking to reduce compute costs. Itâ€™s a very interesting time to get into Java, IMHO. 
What about vertx?
The only thing im worried about contributing to Open source is that it requires extreme knowledge on a very specific software and usually another language (c etc for some java tools) to be able to contribute , and im not sure if such a time waste is worth it for the moment. In order for example to contribute to apache tomcat i will have to be studying about tomcat for the next 5 months because atm all i know is how to set up and run some servlets. After that you have to find issues etc , and actually write working code following standards you may not know to get your commits pulled.
Just look at what's most in demand in your area. If you have a lot of experience in Spring, Java EE is easy to pick up and vice versa. For me it completely depends on what the client is already using / already decided upon. 
If it were completely up to me; Spring Boot 2 with Kotlin. And if it's simple non-MVC stuff a serverless framework like AWS lambda where you can just focus on implementing logic. 
&gt; The moment something is off, bail out. You can do the same with unchecked exceptions? The only difference is that you're forced to declare them on your interface. 
Trust me you would not do that. My area consists of 500-600 euro salaries and making shit wordpress websites with paid themes. Im going to immigrate for this job
I never said not to take pay and stack into account did I?
Wicket (https://wicket.apache.org/) in my opinion is the best framework. Take a look.
do have a look around at what kind of questions get asked in interviews , they aren't always fair...
Jetty+vaadin with gson, guice, and hibernate under the hood
Haha ok i believe you.It's a bit sad cause i have learnt a shitload of subjects about CS , and wouldnt want to be "reduced" to pure low level coding and be compared with guys who have no CS degrees and just know how to write code without the entire environment part. Especially if im not going for a pure code job. Im doing a bit of hackerrank and its not so bad tbh. Solved a couple of easy / medium ones but i had to take small peeks at solutions for the others. Give me a break im not einstein Hackerrank!
I am always thinking about why other constructs like Scala's Try monad is not used more instead.
Do you have any documents, tutorials, examples or quick guides how to play with it? For ... let's say for someone who didn't read all the mailing lists and stuff :) Maybe a bullet point list what you cloned, how you built, what you tried? Would be nice, thanks in advance.
I would probably say Spring.
Spring Boot.
If you are applying to a junior position it doesn't matter if it's spring or jee. They just want to know if you understand the basic concepts like dependency injection, immutability, DAOs etc. Your first few months or even first year will not be about writing an application from scratch, or anyway you won't be the one making design decisions.
Kinda ironic that dropwizard applies less magic 
you're dropping the wizard
There are no silver bullets. So, it depends.
Take a look at [Play Framework](https://www.playframework.com/) too. Since you are familiar with rails, you will get up and running really fast.
Robert C. Martin detests checked exceptions yet is a big advocate of TDD.
Probably Java EE
For a project at work, we are actually planning to use Vert.x AND Spring Boot 2. Using Spring for the DI and configuration stuff, probably some scheduling as well, but Vert.x for the main app logic. 
The JEP Dashboard lists all JDK Enhancement Proposals (JEPs) for this release which change the Platform Specification. They have a Scope of "SE". JEPs in the first three filters (blue title bars) corresponding to Status of "propose to target", "targeted", "integrated", "complete", or "closed/delivered" are expected in this release. https://bugs.openjdk.java.net/secure/Dashboard.jspa?selectPageId=17511 Currently, Local-Variable Type Inference (var keyword), Time-Based Versioning (the 18.3 name), and Additional Unicode Language-Tag Extensions (some standard for date/time formats) are included, with many more in "candidate" status.
Consultant here. We recommend and use Java 8 for all our clients. Some clients are still unsure about how to use streams and Optionals, but once you show them how it's done, they usually jump all over it. I would probably refuse to work at a location that uses 6/7 still, and would certainly not start a new project on these. Java 9 is not yet really ready for most projects, as there still are a lot of dependencies that prevents upgrading. Probably start using it next year for real. 
Public Service Announcement: Spring Boot isn't an web application framework, it is an application framework build on top of the Spring Framework. Spring MVC is a web application framework. You can use it with Spring Boot or the ordinary Spring Framework, especially if you find Spring Boot too "magical".
This right here.
&gt; Spring can suck it. Just kidding, I donâ€™t really care. &gt; I tend to lean towards frameworks that have very few configuration files embedded in XML. I mean there will always be some, but long XML files sicken me. In case you didn't know Spring recently added Java based configurations. [Over 10 years ago](http://spring.io/blog/2006/11/28/a-java-configuration-option-for-spring/). https://i.imgur.com/IW8simF.gif
you wouldn't get compared to people without cs degrees. Companies are usually very strict about the degree requirements when hiring bachelors. After 5 years though, everybody is on the same level playing field.
&gt; Need a routing layer? Implement it from the core servlet API up. Why spend your complexity budget on useful stuff if you can reinvent the wheel badly?
That's awesome!
People should not ignore the IDE's role in language design. The IDE is the user-friendly co-compiler to the language, and should be prominent in thinking about possibly burdensome safety features enabled by static analysis. It offers a middle ground. It is imperative that all exceptions that could be thrown by a method are documented, and the IDE should propagate them up and warn when the documentation and the code do not match. At the same time, these can be treated as warnings that can be fixed if time and code structure allows, not something to beat the programmer over the head with. Regardless, there are three dimensions to exceptions: - Can they be prevented? Non-preventable exceptions usually relate to concurrency. File system errors fall into this category, because a file can go missing immediately after checking that it exists. Preventable exceptions should not be checked exceptions. Eg, string.getBytes("UTF-8") is supremely annoying. It will never throw UnsupportedEncodingException. - How often will they occur (as a percent of calls)? The more likely an exception is, the more important it is to deal with it. OutOfMemoryError can occur anywhere, but almost never does. - How likely is the caller to recover from it? Most callers cannot recover from OutOfMemoryError, except close to the top of the call chain. The same is true for many programming errors (eg IllegalArgumentExceptions). The non-preventable, frequent, and recoverable errors are the ones that benefit most from being checked Exceptions, but it is pretty rare for all three qualities to align. Rare, unrecoverable exceptions should be Errors. Preventable exceptions should be prevented, and not dealt with at all. The interesting insight is that these qualities depend on the *use* of a method more often than on the declaration of it. Therefore, an ideal situation is really one in which a method declares all the things that can go wrong, but the caller (or static analyzer) filters and qualifies them. Try, catch, and re-throw can be used for just that. But the block nesting it forces is decidedly ugly. I can imagine comments or some IDE UI for documenting on a call-by-call basis the problems that the invocation will have, and feeding that into a declaration of the problems the method might run into. More practically, I stick to declaring all preventable errors as unchecked exceptions (and documenting them), frequent unpreventable ones as checked exceptions, and programming errors (which, by their nature, are unrecoverable) as assertion errors. What to do with infrequent unpreventable errors is less clear.
+1 for Vert.x. A lot of functionality in an awesomely documented, lightweight framework. Also doesnâ€™t download the entire internet when building. 
Another vote for Vert.x here. If thatâ€™s a bit too leftfield, a reasonable alternative is the Eclipse Microprofile stuff - otherwise known as just enough JEE to be useful. Itâ€™s still standards based, so very portable, and doesnâ€™t introduce vendor lock in. Itâ€™s backed by a bunch of enterprise vendors, because there are non-Spring shops out there that want a similar experience to Spring Boot, whilst maintaining alignment with JEE. Wildfly Swarm is one (of several) implementations of Microprofile. Iâ€™ve used it a few times. Plays well with Docker / Kubernetes as well. 
Spring Boot
Surprised not to see Java EE mentioned. https://www.youtube.com/watch?v=LwimkQQDhio https://community.oracle.com/docs/DOC-1008823 
&gt; I mention it because itâ€™s the only other way I know to validate that code that doesnâ€™t check for, letâ€™s say FileNotFoundException, InterruptedException, or IOException Never heard of the Either&lt;L,R&gt; type, then? The biggest problem with FileNotFoundException is that itâ€™s an exception at all, not whether itâ€™s checked or unchecked. 
I love Play, but I like it better in Scala - its awesome either way and you get to learn akka!
Haha, valid point!
Anything specific you don't like in Java APIs?
Depends on the market area. For example, our enterprise projects have always been mostly JEE, with some occasional Spring ones. Another consulting companies have other kind of customers.
I specifically do not like the Java API for Akka - not Play! itself. I think it is because I learned Akka in Scala
How are they similar to arrays? I'm curious.
ninjaframework Really well-designed api, especially the router and controller parts.
Thanks for the idea and the starting point :)
Awesome I'll check it out. 
Too many programmers would rather brutalize the control flow of the application than use a type designed to handle exceptional cases. You don't need language-level support for exceptions, you just need generics.
I really like the concept too! I do not know an other one similar to it.
Too much magic that just winds up causing problems, especially in the maintenance part of the application's lifecycle.
I can agree, there is a lot of magic - however I rarely have encountered a problem that I was not able to find searching google/stackoverflow. What do you suggest?
This just in, water is wet and app-server to db-server round trips are slow. 
What should be common sense unfortunately doesn't seem to be. The "works on my machine" effect of developers not feeling the pain of these round trips while developing (and without having the theoretical background for whatever reason) leads to tons of pain and suffering in real world applications.
&gt; Too much magic that just winds up causing problems Translation: I don't understand it so let me take a dump on it.
like everyone else in this thread, Dropwizard.
Wicket has a small community though. If you care about something being actively maintained nad being able to find answers / support when there are problems I wouldn't use Wicket.
This can be done for any out of machine process like a webservice. Lol
The pain of eventloop programming is severe and you'll rarely need the benefits it promises. (You spin up tons of worker threads anyways)
If you can pull in kotlin check out https://www.http4k.org/ I love the functional programming idioms it uses following that of the finagle paper by Twitter. 
To be fair, using monadic types like `Try` is a huge pain without a good functional syntax. I'd say lambdas (which we have now) are a minimal requirement, with pattern matching an extremely nice to have bonus. I also think that language-level support for exceptions is useful even with a `Try` or `Result` or whatever type. First, it provides a universally accepted failure type that encodes a stacktrace when it's constructed, which makes debugging way easier. Second, it's nice to support throwing unchecked exceptions as a panic operation. If you run out of memory (or even have an unrecoverable application fault) I think having a way to say "blow up the stack" is pretty useful. I don't find a ton of value in threading a `Try` all the way up your method signatures for a problem you can't recover from or otherwise meaningfully handle. But yes, there are way too many people scared of monads. On this we can agree. ;)
Thanks. Would you be comfortable with sharing some area/market details and what you're using JEE for in general? I love it from a tech perspective but i have no idea what im supposed to do out there in another country with it.
LOL The correct translation is: It's not worth the trouble so I moved on to something better. But whatever, you can't debate an army of fanboys, so whatever.
fuck docker and kubernetes. Stupid hipster shit.
I really positively hate spring - Its the framework that has damaged Java's reputation more than anything else...the idiology of it has created huge spaghetti code bases, difficult to debug. BUT. This means there is loads of money in it, with employers constantly on the spring treadmill trying to get yet more employees to sort out the shite left by the previous employees. Spring is the better option if you want more money and job security. 
This. Nowdays hipster developers doesn't have the common sense nor the theoretical background to consider network roundtrips and other dozens facets of real world distributed systems. 
Time for [Nonchalantly.java!](https://gist.github.com/poetix/357df0e8ed9535f69d3b)
I want to write a medium post or something if I can find the time and post it here. I actually took notes on what I was able to find out about the implementation details and where to look (combination of source code and also JShell commands). It will take a lot more work to condense, though, since I just saved my REPL history + outputs; I would need to cross-reference JDK source code/documentation with the results. Just to start: the tricky thing is that the bytecode doesn't change at all from what I can tell and have read in the documentation, so you need to inspect actual runtime information (which is something JShell is perfect for). [Here is a link to the MVT command line options. ](https://www.reddit.com/r/java/comments/7l2rre/minimal_value_types_commandline_options_valhalla/)
Checked exceptions are a nuisance when the vast majority of exceptions are going to bubble up towards an exception handler of last resort (like a Servlet handler which will figure out what HTTP response to send based on what kind of failure it was) and nothing along the way is ever going to do anything to trap or recover from them. That said, it's sometimes helpful to translate the `JPAException` from the persistence layer (say) into a `UserNotFoundException` in the service layer, so that the failure is classified and contextualised in useful ways. It comes down to what kind of signalling you need between parts of the system; in a chain of callers A-&gt;B-&gt;C, unchecked exceptions are the only way to send an exception signal from C back to A without B having to declare an interest.
Or not... geez
Hahaha thanks for the honest answer. I really like JavaEE and the cleanless you can achieve by separation of components vs Spring monolithic apps , but my top priority right now is $cash$. So that seems like great advice
And this in turn infects the whole ecosystem. That's when sysadmins get asked to turn off firewalls and grant everyone full control on directories/files. UUghghgghgh.
I have a strict rule to never return null, and also to never pass null. All members are declared final, all constructor arguments are annotated @NotNull. So when an object has been constructed successfully, all its methods will work, NPE free and I don't have to worry about nulls inside the methods, because there's no way you could instantiate the class with nulls to begin with.
I was a big fan of Wicket years ago but it seems like it hasn't caught on. 
Wow. I tried it when I started my company three years back. In the end, I switched to Ruby on Rails. Do people still use it?
1. Like someone said here, why spend your effort reinventing the wheel, literally, in some places? Understand what the wheel does, sure, but there's no need to rewrite a routing framework, for example, unless what's there doesn't do what you need. It does, and if it doesn't you certainly wouldn't be asking us about it, you'd know. 2. JPA is a Java EE standard, and Hibernate is an implementation of it. Whatever you've learned there should translate. 2.5. It's not necessary to know all the parts of Java EE at once. The ones you need to learn have a way of smacking you in the face, often with a few pages of stack traces. See, especially, "no-I-don't-need-that-to-run-transactionally." :P 3. Frontend is frontend, and there are tons of ways of interfacing with backend, so ... Java EE supports them all. SOAP with JAX-WS, RESTful stuff with JAX-RS, direct websocket connections, AJAX to call the other stuff using JSF (some people hate JSF, but I think that they're still stuck in early JSF-land, when you should hate it), and even tons of ways to mix in things like Bootstrap with BootFaces, etc. In a really big environment, you're likely to see good separation of frontend and backend. 3. Spring Boot is mostly a way of trying to get rid of the hassle and complexity of configuring an application server. Something I read recently was about how a very few, small number of programmers get to write new stuff using the newest tech, and lots end up doing (at least some) maintenance. If you do maintenance, you WILL end up dealing with application servers, and I don't see that as bad. Some are better than others. Look at Wildfly/JBoss EAP/Tomee for Java EE "Full Profile" (and maybe IBM's new Liberty WAS), and Wildfly/JBoss EAP for "Web Profile." If you just need a servlet container, without several of the server-managed-and-mediated things, Tomcat/Undertow/Jetty would be options. It's probably more important to get the big picture here - IMO - rather than the deep-down bits of each and every one of these. You can do that when/if you USE one of them for something; until then, you're learning things that will likely be obsolete/changed by the time you need them. The "**big picture**" on the other hand moves slowly, and you'll start to be able to see the changes and directions it's flowing. 4. Down to your criteria, demand is a fickle whore. Interviews are about selling you and some combination of what-you-already-know and what-you-can-do-or-could-know-if-you-needed-to, which is a good part of why soft skills matter so much. Re: "climbing the ladder," make sure you know where you want the ladder to end. If you don't want to be managing people eventually, for example, you'll probably go a bit different direction in keeping up with tech than if you were planning that move to management. The big picture is still important, both ways, though - the people who make really stupid mistakes make them because they don't know that the mistake was stupid, often from not knowing where their "thing" they're working on fits into the whole. As for money, they'll pay you what you convince them you're worth, so know that number and don't undervalue yourself. Aaaanddddd keep your head on, and don't overvalue yourself.
Isn't being both a structure to represent an optional value and conveying nullability the whole point of "Optional" concept?
Yep. Started coding like this about 2 years ago and never looked back. 
StudentUniverse uses it. GivingTools uses it. I don't know about anybody else in particular, but it's mostly a positive experience for me. The GORM stuff is really nice too.
I would recommend reading Goetz's valhalla proposal &amp; watching Jon Rose's talks; I wouldn't be able to explain as well as them.
A very valuable job skill is knowing how to deSpringify a hairball application. I have seen multiple internal projects be started with Spring seemingly making things easier but the complexity and opacity and difficulty in debugging hurt so much the Spring framework was later removed, and the cost of hand writing the small parts of Spring functionality actually necessary for the task was less than keeping the dependency. It feels more like a cult, you need to do everything in light of Spring and it manages opaque executions and side effects on its own, instead of just being a damn library that sits there passively until we call on it. Cognitive confusion is a huge overhead cost in any codebase. 
Thanks for sharing! I learned so much : )
I think server-generated HTML's days are numbered I'd use Spring for a REST service and React as the front-end
good stuff. what's the reaction from your team/colleagues?
Note the last sentence, this is about learning the core problems those abstractions actually solve. It clearly says not to do this for real applications in production. 
I think you're right. This is definitely where I'm leaning right now.
Checkout undertow.io non blocking with an event loop but can easily dispatch to worker threads. All HttpHandlers follow the same interface whether its blocking or non-blocking
Just remember when doing async processing you need good logging / error handling. Otherwise you could just lose messages and not really know. What should happen if there is an exception in the second service and the first service never gets notified? You need a way to pass that to the user or at least log it somewhere so you know it happened.
That is a very good example. Probably the most common piece of user input validation in all of java, and it's an unchecked exception. 
https://stackoverflow.com/questions/20380792/eclipse-error-the-selection-cannot-be-launched-and-there-are-no-recent-launch
This is a good case where the message sent needs meta data: an ID, a time stamp and a type and the server then sends a response later to notify the sender that the message was completed. Should the sender not receive a response in a certain period of time, then the sender can resend the message. That is a simplified way to guarantee the handling of a message.
The class simply refuses to exist in Java Application on the left side within Run Configuration. So i can not click it and do run button. It is really annoying and I don't know why.2
Interesting conclusions but I would actually disagree with them (slightly). 1. Overhead of JDBC can't be understated. There is a huge cost to establishing new connections and sending/receiving data over those connections. That being said, you need to temper that reality with the fact that the bigger the requests, the more you decrease general DB concurrency. DBs are often shared resources, as such, you don't want to put too much work or logic in them. 2. Http requests should NOT be batched together (like, at all). For a few reasons. 1. Batches are harder to cache. The smaller the data chunk the more effective Http caching 2. Batches end up putting a lot of pressure on one server. Not great if you are trying to load balance. 3. You can always do requests concurrently. Http 1.1 allows for OK concurrency of requests, Http 2 is frankly awesome for them. In http 2, the actual overhead for your requests are peanuts compared to the performance gains available to you for parallel processing on the server. 4. You can and should batch up like requests to the DB to get higher and manageable throughput. If you have a "User" endpoint that returns one user, wait for a couple milliseconds for requests to come in for "User" and then send those requests to the DB in one batch. You may slightly slow down an individual request but you will massively speed up everything else on an aggregate. 3. Logic belongs outside of the database. I can't overstate this. The DB is a shared resource and you'll regret putting a ton of logic there. It is almost always harder to expand DBs than it is to expand applications. The company I'm working at now is paying the price for putting too much in the database and it isn't a fun one. The first approach was one that tried to minimize the number of requests to the database (multiple select statements in one query, dynamically built of monster queries, etc). But ultimately, those things make it harder to evolve the application. Further, the mega queries have a tendency to lock up a bunch of resources which prevents other parts of the app from making progress. So, this isn't to say don't batch things. Definitely do that. But rather that you need to think of things in terms of multiple DB actors. The more tables you join, the more rows you update, the longer the query runs, the more you will end up blocking other processes from doing their job.
&gt; you can't debate an army of fanboys. No different than us being able to stop some fuckin' troll from coming in here and shitting on something for some fucking reason, which seems to happen a lot in this sub. Why don't you go play with yourself on the freeway?
I'd say that you can see the opposite problem as well when you don't think about lock contention. You might, on your machine, benchmark query or a group of queries and come to the conclusion "Hey, I want to make this faster". One way that could make it faster is if you just do all those queries in one request. Further, you could make it go faster by doing an exclusive table lock so your app doesn't have to do any pesky work locking multiple rows! The problem, of course, is that while that will make your individual usecase go faster, you've just killed performance in production because now all the other things hitting the DB at the same time have to wait for your super query to finish every time it is called. Optimization requires that you take all of this into consideration.
I remember my first C# / .Net 2.0 app in about 2004, my second year on the job. There was a new caching feature for data that was supposed to speed up web applications. I didn't know how it worked under the hood and didn't have time to try and figure that out. I just had a Wrox book about all the cool new .Net 2.0 features. So I turned on the caching in the properties file and saw a speed-up in my load time on my local box. A little while later in production everything was crawling. Turns out that the thing I turned on cached the data retrieved in previous requests into all subsequent HTTP requests and responses. With production data and use cases, HTML bodies with the cached data inside were up to 20 MB. So people in New York were literally just clicking sort on a GridView or whatever and then having a round-trip across the country to where the servers were in Dallas, sending 20 MB each way. True story.
Wow thats a greatly detailed answer. Thank you very much. I like the suggestion about the big picture , and i admit i havent read into that a lot , since i was focused with the tools themselves. The problem is that there are no enteprises here (poor place) only small shops mashing wordpress plugins together so i plan on immigrating for work with the above knowledge. As a result, i dont really know what the workflow is at a large company or what product we will really be building. Obviously an enterprise application wont just be a controller and a db query , but since such applications are private i dont know where to look to learn what the **big picture** really is like. Is there any source you would suggest?
ViewState!
I would say that Spring in general is a very transparent framework. Would you elaborate on magic parts? Like which parts do you find hidden away enough to cause confusion?
Maybe just use connection pooling?
Just curious, but why would the nuances of particular languages not be useful for a CS major? Wouldnâ€™t they be writing programs?
Yes! That's what it was called! Luckily I moved on to working in Java shortly after and haven't thought about it since
[FUN FACT](https://www.alphabot.com/security/blog/2017/java/Misconfigured-JSF-ViewStates-can-lead-to-severe-RCE-vulnerabilities.html)
That solves the problem of connection establishment time, it does not solve the problem of roundtrip time.
This. Imagine trying to decouple business logic of a system when you decide to move away from Oracle and it's all triggers and plsql for 650+ tables.
I'm living it :). Sql Server, but same problem. Layers upon layers upon layers of logic built into the database. Migrating away from sql server simply isn't an option at this time. But worse, even migrating tables to new database servers is challenging because we have to parse through the 9000 stored procs, views, functions, etc to make sure none of them reference data in the tables we want to move. Pushing logic into the database is a good way to make a giant monster monolith database. Which is 10x worse than slightly slower app performance because it needs to make multiple requests.
Of course they will be writing programs but a large majority of the concepts in computer science exist independently of any implementation details. They will certainly be taught any language they are required to use.
Confusion? No. Today's spring boot has plenty of documentation and examples. You can blindly follow examples w/o reading the docs and get pretty far. You can take some time and read the docs and get pretty far. You can spend a lot of time reading through code and figure out what's going on. I've used spring framework and now boot quite a bit and don't find it confusing, nor should any other competent developer. The "too much magic" comment comes from when you need to leave the beaten path and do something a little custom. Spring boot does not make this easy. Especially when things go wrong and you're presented w/ a monster stack trace. Getting to the underlying thing that needs a small tweak isn't always easy either. If you're doing a basic restful webapp where you submit a form or json to an endpoint running on Spring Boot the magic is great. It's the well traveled path. If you have to implement a custom auth scheme because, while your dev shop is cutting edge, you have to integrate w/ some out of date custom server from a service your boss found at half the price of the other guys (read: business as usual) you're going to have a bad time. I've also run into unexpected side effects from adding dependencies that were autowired in unexpected or weird ways. My app that worked great a moment ago is now failing to start because I added one maven dep. Better cancel my evening plans because I have to dig through this stacktrace just to find the issue. There are plenty of examples on stackoverflow of both of those scenarios. They are also the ones the come up more often after the app is past the MVP stage and being maintained and slowly iterated on. That's my two cents. It's why I don't use Spring today. If that's not the case for you then you should use Spring if you like it. 
Ha! My last exposure to spring was implementing camel so I may have been angry at spring simply by association. Man, I just realized Iâ€™m a grudge holder. I will remember you djnattyp. 
The important issue is that optionality and nullability has a large overlap, but has some important distinctions. `null` is one approach to represent to represent optional values, while `Maybe`/`Option` is another. They are not an approach to handle `nulls`. If you have some `Nullable&lt;T&gt;`, you can't have `null` as a "value", because that's pretty much what `Nullable` is trying to prevent. But with `Option[T]`, `null` is a perfectly fine value for `T` if `T` is nullable itself. `Option` cannot rule out `null` as a valid value, as that would lead to methods being implemented incorrectly. If you don't want to have an `Option[T]` with a valid value of `null`, make `T` non-nullable. 
Are we... co-workers?
I have no dog in this fight. I just wanted to stop by and point out that you got so heated over a debate about Java frameworks that you suggested (even in jest) that someone attempt suicide. Might I suggest some time outdoors or meditation?
Kotlin is the answer for anyone wanting to love their work. Works well with Spring Boot or Dropwizard, and Ktor looks very promising.
The amount of database roundtrips matters and in some cases moving logic to the database helps reducing them. But donâ€™t forget that (at least with Oracle) you can tune fetch/array sizes. This also reduces the amount of roundtrips, without the downsides of moving logic to the database. These are tools, use the right one for the job.
Fetch in bulk and tune array sizes. Fetching one-by-one is slow indeed.
I think we could be coworkers...
I disagree with your batch hate. Http especially is a very very expensive protocol. Even with http 2.0 our rest webservice would take exponentially more time with single requests vs batch. We would process anything from 5 to 10000 reports in the same request. Keep in mind these were internal requests from the application server to the documentation system. When the rtt is around 50ms you do the math. Average scenario was 30s, we had processes take half an hour during tests. If we batched it'd be anywhere from 2 to 20s tops. Either way, we still cached. We were just smarter about it. Being able to manage the cache made it easier to invalidate anyways. I'm on mobile so can't really give you a detailed explanation, but we did test batch vs no batch and batch wins every time.
[extract](http://commons.apache.org/proper/commons-pool/) "The Apache Commons Pool open source software library provides an object-pooling API and a number of object pool implementations. Version 2 of Apache Commons Pool contains a completely re-written pooling implementation compared to the 1.x series. In addition to performance and scalability improvements, version 2 includes robust instance tracking and pool monitoring. Version 2 requires JDK level 1.6 or above."
Sure, that fetches the roundtrips on a TCP/IP level, but not on an application logic level. If you have thousands of statements (as in the blog post), then fetch sizes won't help you. I've found that much more can be gained from average applications by reducing the amount of statements, rather than by tuning the fetch size.
Sure, that should be an additional consideration. It's not applicable in the example of the blog post, though. Also, I don't think it's the same category of "optimisation", because once you re-arrange your locking strategies, your logic changes fundamentally. That's not "just" moving a loop from the client to the server.
&gt; the bigger the requests, the more you decrease general DB concurrency Valid criticism. I'll add this to the blog post. One example are huge transactions changing millions of rows that put pressure on the UNDO/REDO log and on all other sessions reading the same data (e.g. in an MVCC environment). &gt; Http requests should NOT be batched together (like, at all) The idea here was the same as the one for databases. You should often not iterate a list of 1000 IDs in the HTTP client to fetch them individually. It is often better to send the ID list to the server and loop there. The paradigm is always fetching similar things in several requests is bad. Depending on the environment, you might also overestimate the effect of caching (but it's a valid concern in general, which I'll also add to the article). For instance, if the resources you're accessing need authorisation, then caching might simply not make any sense, because it would be against security policies and turn out to result in wrong behaviour, once authorisation is removed or once the session is terminated. &gt; Logic belongs outside of the database Here, you didn't disagree slightly, but massively, and you're wrong to claim this *in general* :) Heck, every SQL query is "logic", SQL being a declarative / logic programming language - where do you even draw the line? &gt; The company I'm working at now is paying the price for putting too much in the database and it isn't a fun one So, there's your context. You've drawn a conclusion from your context, and your conclusion was (erroneously) absolute. Add some figures to describe your system (# concurrent users, # concurrent requests / queries, # rows in your tables, # tables, and of course the database version and vendor). That will put this criticism into perspective.
No one said (in the article) that it should be *all* triggers and plsql.
The complexity you're describing would have been quite similar if it had been implemented in any other language or platform. If you wrote all that stuff in Java, then migrating away from Java wouldn't be an option.
That is essentially one of the approaches discussed in the article ("validated" null-intolerance); I think it's the correct one in most cases. What do you do about Hibernate? Just not use it?
JavaEE running on Apache TomEE. Without a doubt. Currently using it to host a JavaEE game on facebook. not regrets at all. There is something to say about deployment of software that takes a few seconds - my users don't even know I have a new version of the game up and running! It just works
While I agree that it is challenging, moving from a language/platform is way easier than migrating from a database.
I am fortunate enough to not have to use hibernate. The applications I work on store data through other API's and if it does have to keep data locally, it's through an sqlite database which I interface with directly. I do admit having an ORM would be nice in some cases, but for the scope I'm working on, I don't need it.
We haven't really discussed it (we're all kind of siloed, everybody works their own projects), but I've not heard any complaints either.
Thank you very much, I'm really looking forward to reading what you have to tell, so make a lot of noise if you're done :) For me (and I guess for many others): I watched all the talks about valhalla, I read some things about prototypes and command line flags, but I don't get the big picture of what the current state is and the future state will be, so I feel kind of unable to gather the information for myself, so that I'm able to test something locally. So, I just wait until you write how you did it for us :)
I can run two applications that do the same thing side by side. One written in java another written in Go. What I can't do is run the database side by side (not easily at least). It is WAY easier to migrate an app than it is to migrate a database. If for no other reason than the fact that it is easy to A/B test apps.
&gt; When the rtt is around 50ms you do the math. Average scenario was 30s, we had processes take half an hour during tests. If we batched it'd be anywhere from 2 to 20s tops. Do things concurrently. The big downside to http 1.1 is that to do things in concurrently you have to have multiple connections for the amount of concurrency you are after. With http 2, it is only one connection. 10,000 items, 50ms request times, 32 http 1.0 connections and you could do it in 15 seconds (10,000/32 * 50ms). Not great but potentially livable. With Http 2, you can send all 10000 request at the same time, and then wait to get them back. In the best case, having only a 50ms time total. &gt; Either way, we still cached. We were just smarter about it. Being able to manage the cache made it easier to invalidate anyways. I'd never knock caching, but I was mostly referring to http caching. non-batched requests are much more likely to generate a cache hit for the client.
You're now mixing two things here: - The database (i.e. the data) - The database (i.e. the logic alongside the data) You can run your T-SQL logic alongside with your logic in Java and the one in Go. I don't see why rewriting everything from Java to Go is easier / faster than rewriting everything from T-SQL to XYZ.
[See my answer here](https://www.reddit.com/r/java/comments/7l1eks/the_cost_of_jdbc_server_roundtrips/drkf8rp/)
&gt; The idea here was the same as the one for databases. You should often not iterate a list of 1000 IDs in the HTTP client to fetch them individually. It is often better to send the ID list to the server and loop there. &gt; The paradigm is always fetching similar things in several requests is bad. Fetching things one by one is bad. However, fetching 10000 things concurrently isn't as bad as you might think. Particularly with Http 2 which has just a slightly higher overhead to do that over doing 1 giant request with 10000 items. The difference is that by doing things one by one, you allow the load balancer to split the request to multiple app boxes. If you are doing things in a giant batch, then you are at the mercy of the client not to overwhelm your boxes. And this doesn't even mean that you can't batch to the DB, on the server side you simply have to wait for a reasonable amount of time, collect the requests, and then you choose how big you want your batches to be going to the DB. &gt; Depending on the environment, you might also overestimate the effect of caching (but it's a valid concern in general, which I'll also add to the article). For instance, if the resources you're accessing need authorisation, then caching might simply not make any sense, because it would be against security policies and turn out to result in wrong behaviour, once authorisation is removed or once the session is terminated. It is going to depend on a case by case basis, certainly. However, batching basically completely removes the ability to use http caching. You'll simply never make the same "Get me 1,5,8,5" request again. &gt; Here, you didn't disagree slightly, but massively, and you're wrong to claim this in general :) Heck, every SQL query is "logic", SQL being a declarative / logic programming language - where do you even draw the line? I have a few heuristics that I go by. But generally, if it is more about interpreting the data and less about fetching the data, then it doesn't belong in the database. For example, a "Is item valid" check that spans multiple tables belongs in the application layer. If the object loading is so complex that it requires multiple select statements, those should be done in the application layer. And finally, and this is more gut feeling than anything, if the query being written has too many joins, cross applys, CTEs, etc. Then I become suspicious that it is doing too much and should be broken up. Similar to how a method with 1000 loc makes me feel suspicious that the method needs breaking up. &gt; So, there's your context. You've drawn a conclusion from your context, and your conclusion was (erroneously) absolute. Add some figures to describe your system (# concurrent users, # concurrent requests / queries, # rows in your tables, # tables, and of course the database version and vendor). That will put this criticism into perspective. Exact numbers will be hard for me to give. Primarily because the system is complex. It is a data processing system which involves multiple applications at multiple stages crunching data until it gets to the final end user. It used to be a couple of giant monoliths. But over the years we've been slowly breaking it apart into microservices, different engines, etc. The thing, though, that has really hampered us from doing this is the fact that early on, all the data was stored in one giant database. And because of that, there were more than on stored procedures which would pull data from all the monolith's stages in one go. We've had to work on breaking things up because we've reached the limit on throwing hardware at the problem. We can't just buy a more expensive database server.
My point was that it is easy to optimize for the case of one. Much more difficult to optimize for many. I used locks because those are often what ends up changing when you push things into the DB (though not always as explicitly). At least in SQL server, locks will auto-promote to try and improve performance for a transaction. So it might start at row, then page, and could finally end up doing a table lock if it detects you are doing enough locks. This is transparent to you the query writer. Until you run into that fateful day when for some weird reason you get deadlocks while upserting single rows in a transaction into a table.
This guy talks about spherical business logic in vacuum, but that's never the case in the real word. 1. Business logic can be complex and I would like to have all the power of universal language like Java plus its frameworks and libraries to implement it. Inheritance, composition, components, IoC, design patterns, configurability, testability, etc. Sorry, but even if PL/SQL has some potential to do that, it is just not there yet. 2. Business logic can depend on external stuff. How will database handle thousands of calls to remote API-s and loading tons of JSON-s to extract necessary data? Isn't it wasting license money if your database server CPU is busy waiting for a HTTP response instead of doing work? If you suggest to handle remote calls in the application and extract core logic to stored procedures, then this is possible only as part of the hybrid approach. You might be able to implement domain rules like that, but not the entire flow of use-cases. 3. Tooling and lifecycle management for PL/SQL code sucks compared to Java word and this _is_ an issue and this _will_ cost you money if your developers are not productive. So, if RDBMs would offer us a proper language, standard library and tooling, I would look at it from another angle. But today we are where we are. Finally, I wan't to say that these problems with data affinity have also been addressed in an opposite way by IMDG-s like Apache Ignite or Hazelcast.
The problem is that the data and the logic alongside the data have a funny tendency to mix with each other. If I push in concerns like "Calculate pdq" into the DB, I'm almost certainly going to end up with a query that is "Load User, calculate pdq, eat data". What gets worse is if you end up with multiple applications doing the same thing but calling the shared "calc pdq" function. Because then they all have to move before you can be rid of "calc pdq". This gets more complex if "calc pdq" ends up joining a bunch of tables in the database. Now, what if you want to move one of those tables to a new database server? Well, you have to then migrate every app using the "calc pdq" function first before you can even think about moving to the new DB. On the other hand, if "calc pdq" lived entirely in application logic, the the process of upgrading it could be done gradually over time per application.
I don't see the difference. You could rewrite your pdq function to connect to some other system from within the database and then proceed with those upstream refactorings just the same. In Oracle, I've done this kind of work dozens of times using AQ or db links etc. Worked effortlessly. Of course, if you want to completely replace the vendor of a large part of a large system, well you're in for tons of work anyway. A client of mine has been trying to migrate a large, complex, legacy system written in Delphi many times, including migrating it to Java and to PL/SQL. So I really do not think that the specific vendor of any part of the system matters that much...
https://github.com/brettwooldridge/HikariCP/
&gt; And this doesn't even mean that you can't batch to the DB, on the server side you simply have to wait for a reasonable amount of time, collect the requests, and then you choose how big you want your batches to be going to the DB. 1. Beware of the junior dev who doesn't implement this and unleashes the 10000 queries from those many boxes on the DB 2. Waiting and collecting sounds like much more work than batching in the first place. &gt; It is going to depend on a case by case basis, certainly. However, batching basically completely removes the ability to use http caching. You'll simply never make the same "Get me 1,5,8,5" request again. In the systems I work with, you hardly every make the same get me 18374187348713878934 request again, and even if they did, it would be a post and the resource would probably have changed in the meantime. &gt; And finally, and this is more gut feeling than anything, if the query being written has too many joins, cross applys, CTEs, etc. Then I become suspicious that it is doing too much and should be broken up. Similar to how a method with 1000 loc makes me feel suspicious that the method needs breaking up. I don't disagree. But 5 queries are still better than 500 &gt; We can't just buy a more expensive database server. I understand. I mean sure, there are those systems. I've never seen one though, and the largest ones I've worked with have billions of rows in their tables, 100k+ sessions on average days with ~1000 queries per session, some of which have thousands of lines of SQL. Still only using 4 CPUs on average in their Oracle database. It's hard to find the single most responsible problem in a system. But usually it's not "just" because of stored procedures. That's all I was trying to say.
I agree with that. In addition to that, each layer capturing the exception and rethrowing it with their own can add some state info to it, e.g. the current value of some variables. It would have helped massively though it Java could, in debug mode, keep track and capture the method arguments of each method call in the stack trace.
As ever, it depends on the situation at hand. They are not mutually exclusive either. ;) I just mentioned it because the article didnâ€™t.
As ever, it depends on the situation at hand. They are not mutually exclusive either. ;) I just mentioned it because the article didnâ€™t.
I think you are misunderstanding the point of the ThickDB model. It is not to capture *all* business logic in the DB. But rather to encapsulate the relational model behind a PL/SQL API, effectively turning the database into an application server. The idea is that instead of requiring a Java application manage the sequence of relational operations (SELECT, UPDATE, INSERT, DELETE - which are inconvenient and lead people to using ORMs), you provide a high-level PL/SQL API. This decouples the application from the specific table structures of the database, while at the same time providing performance enhancement opportunities by eliminating database round trips and allowing use of PL/SQL features like bulk binds.
I think Apache Commons Pool is a general-purpose object pool, not limited to a JDBC connection pool.
&gt; just mentioned it because the article didnâ€™t. It says: *"Again the full benchmark can be seen here (which also benchmarks the effect of **JDBC fetchSize**, which is none, in this case)"* &gt; In my opinion there are no hard/fast rules regarding â€œall logic should be in the applicationâ€ vs â€œall logic should be in the databaseâ€. Of course not. Completely agree.
Imagine all the hours that have been wasted discussing nulls would have been spent on actually creating useful stuff.
Regardless which one you choose, you will need to learn SQL as well. Go for SQL, directly ;-)
It's easier to isolate the application and replace it than it is to do the same in the database. Data and logic can be mixed pretty easily (in db) and there's no static typing to help you isolate the logic. And if your source code is (in) migration scripts on multiple versions...
plsql is just too bad for complext business logic. poor testability, poor OO, no proper IDE for refactoring.
Or imagine all the hours building better code that result from discussing things like null safety and null tolerance. I get it, you might not see a reason to talk about these things, you might not even care about null, but just because the language was designed with null doesn't mean there aren't better ways to do things =/
I would recommend Grails. It uses Spring Boot under the covers so you have that at your finger tips if you need it (otherwise you don't have to worry about it. There is also a REST only profile you can use when you create the app that leaves out all the view stuff if you just want a REST API you will be hitting with React.
There is a big list of logos at the bottom of this page of companies that use it: https://grails.org Just because something isn't the current buzzword doesn't mean it isn't used anymore. It just means the hipsters have found a new shiny toy to move on to. 
Of course i already know sql. You cant do a single thing without it. Granted , only at a basic level with some complex selects, aggregates and updates , triggers, a bit of PL/SQL and that's pretty much it. Anything more you would suggest that you think is crucial?
Let's talk ad nauseum about Optional instead!
My personal rules. * Prefer, above all else, never returning or taking a null value. * Annotate parameters as being Nonnull * Use Optional if something is optional (return or parameter) * You should never return null for collections. Just use Collections.emptyThing. * If you must accept or return a null, annotate and document it! I can understand not using optional for performance concerns or maybe for signaling (Caches, for example, null == never seen. Optional.empty == seen and doesn't exist, Optional.value == seen and here is the result). But there is no excuse not to yell and use every builtin tool at your disposal to let others know what is going on.
Dropwizard is great, but honestly I've instead used it as a jumping off point for "what libraries should I use". I simply don't use frameworks anymore. Setting up a Jersey + Jetty + Dagger + whatever app just isn't that hard to do and is really easy to understand when you don't have to fall back into someone else's wiring.
&gt; yet he is a big advocate of TDD. That's an understatement. In "Clean Architecture" he even included an intentionally misleading graph with the benefits of TDD.
Very good point. All that matters to me is that it is still well supported with a solid base of users. I don't want to trail blaze.
Which magic?
Tipperoni: @ParametersAreNonnullByDefault on the class or package-info
kinda random, but a nice little addition :D
Why random?
from what I understand its just a cosmetic addition, putting var there doesnâ€™t actually do anything, but I guess â€œrandomâ€ was probably the wrong word.
Yeah. Itâ€™s nice that they thought about this corner case, though, in order to maintain continuity.
http://i0.kym-cdn.com/entries/icons/original/000/007/762/337.gif
definitely, it would have been better if they introduced var along with lambdas and required its use, but you can only plan so far ahead.
Yeah. Iâ€™m glad weâ€™re getting it as soon as we are, though!
This JEP accomplishes nothing, it only allows you to use (var x, var y) -&gt; x+y when you can already leave out the type: (x, y) -&gt; x+y. The var keyword doesn't add anything in this context. It makes sense from a completion point of view, but looks silly in this context.
[edit: curse this formatting, can't it just have headers like HTML?] In terms of a good technology overview with samples, I like O'Reilly's "Java EE 7 Essentials," but a lot of that will still require you to tease out big-picture details from either imagination about how the different pieces fit together or actually building something. With that said, I'm going to assume that you know "enough" about the concept of "domain"/entity objects (not to be confused with entity beans, which are deprecated) and having a database service layer of some kind (JPA or otherwise), and splitting up the presentation of things from the business logic to kinda cover how things can be laid out at a pretty high level: * Layered horizontally, with packages for domain objects, business logic/objects, and presentation. This is more the "older" (but not necessarily "wrong") way of doing things. Classes that map to entities that you'll be doing stuff with, along with the database service objects, go in separate grouping (probably more than one package). The different components that enforce/calculate/DO your business stuff, like control the whole flow through the process of say, placing an order or moving an item through a manufacturing process go in another layer. Whether you include routing for the presentation layer in here or not is subjective up to a point. The top/presentation layer then renders business logic into whatever - text on a dumb terminal, web pages, desktop GUI (not seen so often in any new development), or whatever. Originally, a decent but perhaps over-engineered goal of J2EE was to enable a complete division between the business/data layers and the presentation, up to splitting which machine (and hence JVM instance) those all ran on. The official standard for cross-JVM communication was IIOP, but as of the current Java EE spec it's become optional to implement. Large Full-Profile solutions will still include it for now. Disadvantages of IIOP were dealing with local-versus-remote interfaces, having to declare interfaces for EJBs, and dealing with all the security; the lighter way to do this now is to annotate EJBs with @LocalBean, which says "just... use the thing itself as an 'interface,' and go away, okay?' :D * Alternatively, stacked vertically. This is becoming lots more popular. Take all three layers, from external presentation to business to database, along with associated cross-cutting concerns like logging, security, data transfer, etc. and package them together, for individual business components or operations. This means that something that say, handles... updating the registration/license/plates for a vehicle would have all the stuff to present outcomes of what happened, decide whether rules were followed when the vehicle registration was renewed, and save it to some persistence storage all within its own little cluster of packages, and be separate from say, the part of the application that lets people register themselves with the government so that they can apply for and renew driving licenses, vehicle registrations, and commercial transport licenses - each of those would be its own little vertical stack of things from DB up to presentation as well. What you might see in terms of where I'm going is the trend, now, for those vertical stacks of stuff to be shrunk as small as possible and turned into "microservices," where "presentation" is JSON/XML/YAML or whatever the flavor of the day is, and by being SO self-contained dealing with shifting load becomes easier. Do 75% of your drivers buy new cars around the winter holidays? Cool, come November, start up 100% more instances of the "register a vehicle" module/service so that there aren't delays. **Closing (and this was too long; clearly I need a blog)** So... I realize that I just answered a lot of your questions by example, rather than your question of "is there a good source?" * I really don't like Oracle's Java EE tutorial, because it just showcases all the tech REALLY fast, and in a way where if you haven't used it then it'll feel very, very over-complicated for the scenario they present. * While I personally do well with thick books that are theory heavy on the front side, then detailed technical application of the theory spread out through the book, those are too much for lots of people; if these work for you, they tend to be pretty comprehensive. * There's no substitute for a **general** idea of the things that you're interacting with to make your application work - databases, networks and TCP/IP, storage, and so on. This does NOT mean that you need to be able to configure a big cluster of databases, but you should know about transaction-processing vs analytical-processing DBs, in-memory and column-store options, and when you might want them. Deep details not needed. Similar for networks and storage - lots of previous assumptions from even five years ago go by the wayside now with smarter hybrid solid-state-with-enterprise-spinny-disks and tons of memory available. Don't waste memory/storage casually, or a [leather-winged demon of the night](http://www.mindworkshop.com/alchemy6.html) may visit you. If this is web stuff like it most likely is, then for the love of all that is holy, please take the time to learn HTTP from its origins (stateless) to how problems were fixed (cookies, headers with session IDs, compression, security) and so on to how we got to HTTP/2 with encryption everywhere today.
I was certain 8 was a typo and you meant to write 9. I would hope very few are still on Java 7 or lower this many years in. I certainly wouldn't want to work with it.
Just a reminder that @NotNull is a non-standard annotation (all of the null-enforcement ones are) and that if you use a different tool chain it might/might not be enforced. I really wish the Java team would just endorse one syntax for this and we could then all move forward with assurance that the code will be checked the same way in all tools. 
It reduces the "wtf why" - moments of the language. Consistency is very important for the language to be easy to learn and use.
I disagree, you can't do this: BiFunction&lt;Integer, Long, Long&gt; func = (Integer x, y)-&gt; x+y; In that example the Parameters are obvious, but it is an all or nothing approach. Either they all have a type or none have a type.
Ah, interesting insight. Yes, I'm mostly coming at things from a classic OO viewpoint, since most of the code I look at is OO, and most of the misuses of Optional I see are in code that is (or that purports to be) OO. I hadn't really considered this from the standpoint of an algebraic data type or a plain data carrier. (Interestingly, even though you said "algebraic data type" first, I kept reading ADT as "abstract data type"!) I guess I'm a bit skeptical about whether Optional works for the kind of cases (heh) you're talking about it, but if it does, more power to you. I'm not categorically (heh) opposed to using Optional for fields. The reason I'm still a bit skeptical, though, is that currently there's no language support for Optional. Maybe some libraries help with this, but it seems like in many cases one is forced to deal with it explicitly. For example, if there's a field of type Optional, its language-imposed default value is null, not an empty Optional, because (today) Optional is an ordinary Java object of reference type. But the pattern matching and data class stuff in the works could be a game-changer! It'll be interesting to see how it turns out. We may end up changing our tune on fields of Optional type. Incidentally, this topic never ends. On /r/java a link was posted to an article [Some notes on null-intolerant Java](https://www.reddit.com/r/java/comments/7l1pvq/some_notes_on_nullintolerant_java/). In that article, the author writes &gt; I have seen inexperienced teams promptly convert every field and parameter to an Optional, and replace null checks with Optional.isPresent(), which if anything makes things worse. This is mainly what I'm concerned about with using Optional in fields, and why I say to avoid using fields of Optional type. But if one considers the issues well, and the resulting code is preferable to the alternatives, then it's probably OK. 
Perhaps I'm misunderstanding you. But you won't be able to do: (Integer x, var y) -&gt; ... The JEP says: &gt;An implicitly typed lambda expression must use var for all its formal parameters or for none of them."
I only read the motivation :/
You can also do @ReturnValuesAreNonnullByDefault !
[This was the article](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying) that led to my aha moment and understanding of what all this hype about streams and distributed logs was. [The Log: What every software engineer should know about real-time data's unifying abstraction](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)
Wow i didnt expect so much information. Thank you so much. Googling something specific is one thing , but if someone doesnt mention it to you , you wont even know what is there to google. So from your post i got loads of new potential knowledge which i appreciate . I do know deep details in some things mentioned there but overall i will study more about architecture and the choice of the right technology as you mentioned. Didnt even know about http2, i saw it in the javaEE tutorial but was like "eh will take years before its used in a job".But i want to work abroad since Greece is suicide for software developers so im gonna learn that too.It has taken me 3 months to learn java and what i know about javaEE/spring from scratch (was php , c , js junior dev ) , so i hope in a year of study and practice to master some parts and also master algorithms for interviews, i MAY be eligible to apply for junior javaEE software engineer. Thanks again , i only have one last question. Would you mind telling me your position and a 1 sentence description of your daily tasks with enterprise java? I have no idea what i would actually do with it if hired.
I'm really more a database admin/SQL person, at the moment. We have a Java EE application, but it's not exactly what you'd call well-engineered, or deployed "at scale." WHEN stuff happens to it, it's more maintenance, and it's so old that it's not even Java EE 7 so there's not a lot interesting to say about it, other than "contractors" and "grant" apparently permit lots of poor decisions to be made while spending lots of money. This all happened before I was around, but seriously... who starts a project with a framework that was EOL'ed 3 or 4 years earlier? (again, all in the past; not naming names or frameworks) If anything, I'd say that my current focus when it comes to the application - which I swear to god is mostly a glorified frontend - is moving the underlying architecture that it all runs on into something that's been standard for a while, like "Maven" and not "ant," so that we can actually get around to improving it. Someday. Larger shops will not suffer these problems, and you'll likely have groups of people who develop feature(s) together, with a business systems analyst who knows some of the Java EE system and DB and helps translate business user's desires and "needs" into thing that you can code, with care and attention to detail. TL;DR: What I do now isn't important here. I've read lots about architecture and best practices in a lot of areas, and we don't do them. I've heard lots about the failings and successes at other places, and they seem to line up with the respective good and stupid of the best practices that I'm familiar with.
Perhaps a use would be if you had some sort of tool which converted some java code to lambdas. Before var you could map type to type and it would work. Now the tool would still work with var, without needing to be updated for the special case. Though here it would still fail if only one of the variables were var, so I'm not sure if you really gain much.
The problem with checked exceptions is that that were included within the Java API itself. If checked exceptions were left to to domain level, no one would have had anything to say about them. That would have been the correct way you would usually use them. Consider something like an SQL exception. There are many reasons you could have this exception. It's a catch-all where most of the time is unrecoverable. Invalid Operation (like forward only resultset and moving backward) or Query syntax error. Hindsight is 20/20 but really JDBC should have made SQL Exceptions mostly runtime and made them unchecked except for a business rule violation in the DB. So: SQLConnectionException - runtime SQLOperationException - runtime SQLQueryException - runtime SQLViolationException - checked Maybe at some point someone will do a JDBC2 interface? 
So you use Optional when Querying for a specific row in a DB? 
SOOO much better than structs in C#. Thanks!
Bring logic back to data! Oi!
&gt; Which magic? Most people don't understand 'opinionated defaults' in Spring and how @ConditionalOn* annotations work, so they call it 'magic'.
spring boot 2 reactive
I think is Java EE!
JSF! And OmniFaces and PrimeFaces. Super combo and is veru productieve!
JSF? Is very close to Wicket, no?
Is Grails bit nice, but I think is slowest of all Java frameworks? Is not build for performance!
Cool. I'll check it out, thanks.
Probably lots of reflection use which annotations usually use
It's the hipster JS culture. Once they land a job in an Enterprise co. They realize how deep in mud they are...
Sounds good to me! Iâ€™m building side projects with spring while in school just to differentiate myself from the boot campers and flavoroftheweek.js folks. Spring + React to hedge my bets.
you can still return a null Optional....... doesn't mean you should... but you can.
In school? Do you mean uni? Cause in high school i didnt even know what a program is in general lol, spring would be sci fi.Still, even in uni its no small feat.Especially if the teachers dont ever mention it like it mine , they prob didnt even know it exists, so i had to read everything from books
Agree. Does nothing. Makes two ways to do the same thing, adding the more verbose way. Actually makes the meaning of `var` *less* clear because var only works in local variable context when an assignment is made, and in a lambda context, there's no assignment being made. There's also no type inference in method parameters for JEP 286, so this actually adds an inconsistency.
I'm writing an app with Spring Boot Rest, Kotlin and React. Mostly just to learn, but also because I can.
I'd much rather be able to write var addOne = (x) -&gt; x + 1; 
I'm not sure I've ever noticed any shortage of people that understand any of that? Are your local schools surveying to figure out what local businesses need out of graduates?
I liked java/spring while at uni, was definitely not in the cool crowd. But hey, I got a job now and still liking it.
I do not get the issue with null. 
My picks are a little non-standard, but highly productive with high quality. My favorite choice for a stack is Vaadin + Spring Boot + Lombok + Hibernate + Postrgres. Heavy use of lambdas, streams, final, Optional, and @NotNull annotations. MVP pattern. For quality: Infinitest, Mockito, PageObjects, Cucumber, SonarCube, Checkstyle, Findbugs, Checker Framework Tools: Linux (or cygwin), Intellij + ideavim, git, docker Build and Deployment: Gradle, Jenkins, Docker, AWS.
java spring is as heavy as it comes. itâ€™s ugly and old. most people i know have used spring for a number of years are moved away from it by choice. nowadays there are lots more elegant better performing options for people who want to learn. thatâ€™s just my opinion from everything iâ€™ve heard. iâ€™ve never actually used it.
What was the population of the study like? Was it other students of the same university?
Depends but querying for a specific row and it's not there I'll throw an exception (how are you able to describe a record that's not there to begin with?). Queries like "get me the last row" return an Optional.
&gt; thatâ€™s just my opinion from everything iâ€™ve heard. iâ€™ve never actually used it Well at least you're honest. You should try it yourself and look at all the neat things people are building with spring-boot. 
Spring was actually a LIGHTWEIGHT reaction to this monstrosity called J2EE. Early versions of J2EE were sort of insane. I know, hard to believe.
First this should probably be in /r/javahelp. Second, the line % java Date 12 31 1999 is how you run the code from the command line, the reason you are getting an array out of bounds error is because your program is trying to access the element at position 0 of the array args[] and if you didn't pass anything through the command line then there is nothing populating the arguments array.
Enough to get you the Presidency, sadly. Wonder if improvements to the english language is critical to fix this. Using latin as identifiers for fallacies seems to be an area of improvement.
so i should put the %line inside args[]?
&gt; A more sane API would have been to return Optional or null. +1 to apache commons for having this
No, that line does not go in your code anywhere. You need to compile your code and when you run it from the command line your three arguments are "12", "31", and "1999". When your main method starts they will be put into the args[] array. The code you have is perfectly fine, the problem is that you're not passing those arguments in anywhere. Try looking into how to run java programs from the command line.
I've seen an article mentioning of an error-handling spectrum. On one end, you have command-line quick scripting, this is where you don't really care about error-handling, any error should just thrown in your face. On the other end, you have critical-mission software like an Airplane software. Error handling is priority. You'd wanna use a robust exception-handling mechanism. Make sure you're forced to handle all the exceptional cases. The [complaint](https://www.reddit.com/r/java/comments/7ksxza/the_exceptions_debate_by_brian_goetz/driaw4y/) about NumberFormatException probably isn't for mission-critical software. 
I don't know about others, but with all the other required courses, there simply isn't time to learn enterprise-level platforms. Between learning base coding, networking, databases, design patterns, data structures, etc, you should feel lucky if a fresh graduate is a competent developer.
Because businesses that use it refuse to hire less than senior level. 
So many stuff here I honestly don't know, yet important when stuff happens in Production. Is there any book that focuses on all these topics?
I think you may be mixing up JEE with Enterprise Java Beans ( which was the inspiration for frameworks like Spring )
u can do neat things with brainfuck im sure. thatâ€™s besides the point
I've seen a whole crapload of requests for Spring in my job search. I never see anyone wanting Java EE. 
You have strong opinions on something you have never used?
i donâ€™t need to date a girl to know whether i would wanna marry her. i donâ€™t need to drive a car to know whether i like it or not. liking or not liking something is a question of taste and everyoneâ€™s taste is different. my strong distaste of spring should not bother u. it is just my opinion.
Couldn't the tool leave off the type for all of them anyway?
I'm 23, and I'd much prefer to make something with Java/Spring than with some js lib-of-the-week
How exactly does this contribute to consistency? It introduces a 3rd (redundant) way of declaring lambda parameters, that seems to make the language more confusing IMO.
This is the only thing that would be actually useful, and it is disallowed!! :(
No, it expands lambda definitions to allow the pseudo-type where you explicitly define types. If you can use var in almost all places it makes sense to allow it in all locations, even if you would rarely do so.
Well without a specific example in a lot of cases you know statically what the type is, due to static typing... Otherwise there is the `getClass` method or `instanceof` keyword.
100% this, most of the jobs I see that want JEE developers want senior ones, I was targeting JEE as my primary platform to develop on but didn't have a degree, 100% of the positions I saw wanted a degree AND several years of Java EE Experience in a production environment, so basically if you aren't a college grad that jumped into JEE, you're shit out of luck.
School doesn't have time to teach frameworks really so it depends on a) what they do professionally, b) what (if any) do they use in their free time, and c) what they use on the job. Also there seems to be a much higher supply of front end developers than back end, at least on the East Coast, and that probably contributes as well
Younger guys skew node.js. They do so because they perceive Java as old and complicated and view node has fun, productive and hip. Us older java guys know java is productive and useful and definitely easier to manage than the typeless shitstorm that is js. 
All I got was Struts from mine. Spring Boot was a godsend in comparison
Universities shouldn't be teaching frameworks
JavaEE has a steep learning curve. Furthermore, without an adequate guide, advancing from simple Java hello worlds to a relatively easy web app can be seen as an impossible task. Personally, I had to spend over a thousand dollars for courses on JavaEE, Spring, hibernate and Oracle PL/SQL, and even those paid courses felt inadequate when I had to work on a live system. From my viewpoint, learning Java EE on your own is a titanic task. I graduated around 2000, and in my ignorance I thought that learning PHP and MySQL was enough for industry needs. I only learned JavaEE until my mid thirties. Then, after you learn, you're at the mercy of project pacing. You can get stagnated for years, depending on your boss or the projects that the company is accepting. In my early 40s, I'm still learning. TL;DR: Java (and I include the huge collection of specs) not an easy language to learn.
Java scales really well and performs. That's why enterprises use it. And spring is not exceptionally heavy. Spring MVC is very similar to Asp.net and Express.js or whatever MVC framework you want to point to. And Spring Boot is simple and delightful to work with.
Since you only mentioned python as your example here and didn't say the magic word "generics" or "erasure", it sounds like you're just not familiar with statically typed languages. The point is that all types are known in advance. Your code doesn't check the type of a thing, the compiler does.
When you say "hard to find", are you recruiting people, or what exactly? I work in a building full of people who know EE and Spring. Maybe all the people you want are already working for boring corporations.
I am under 30 and am familiar with spring and a lot of jee. For college kids there is no point to learn jee. You should be learning that stuff on the job or in internships. You should be making things, but learning frameworks isn't the goal. It's learning how to make projects from start to finish and in a team that is important. Second I would say jee has a lot of bad parts. Javaee has grown too much and standard spring too complex. It's reached a complexity that is necessary due to mismanagement at the standard Enterprise architecture level. If you are using good architecture the more complicated parts of spring and javaee are not necessary. Spring boot is a step in the right direction in my opinion. If you need more complexity than spring boot, I think in most cases it's your architecture that needs to change (with exceptions). Get out of the monolithic hell and it's much easier.
Well those of senior level must have somehow started in order to be senior level right?
Well those of senior level must have somehow started in order to be senior level right?
Wow thats a high investment from you. I hope the job now is justifying the effort. 
Node js is a joke. Using it for an enterprise scale application ...how would that even work? The though alone is a nightmare 
&gt;Wow thats a high investment from you. I hope the job now is justifying the effort. It is. My latest course actually landed me the job, because my interviewer saw I was being proactive. It took me a full year to recover the investment and pay that loan... but it was hard. To think a $200 course in college would have made this much easier... I'll always regret not having taken it. See, there's this other barrier to entry. You can't learn Java because you don't get Java jobs, and you don't get Java jobs because you don't know Java. If the industry wants more qualified personnel, they have to invest in educating future prospects.
Unless the economy goes south and wipes out most of the start-ups, there are enough of a job market for JS folks that most don't need to look outside of their flavor of the month Node framework. WebAssembly might change that in the long run though. 
I started coding in primary school. By high school I had a job. Everyone is different, lol.
I perceive ecosystem where switching build systems quarterly to be able to keep up with bare minimums is the norm a ... bit too adventurous.
the fuck. I guess it also depends on your education etc.I didnt even have a pc until high school
Well those of senior level must have somehow started in order to be senior level right?
That may be the problem. We always recruit new devs regardless of there knowledge in specific frameworks and put them into teams with senior devs. For me this is the only way to go. We also had some kind of bootcamps where they get a lot of beginner knowledge, but imho working the real projects from the beginning is far better.
&gt; base coding, networking, databases, design patterns, data structures In my experience, that stuff was enough to get me a foot in the door at my first job. *That* was when I learned to develop properly. Of course, if a dev shop is hiring graddies and expecting them to be anything but notionally useful in the first 6 months, then theyâ€™re living a pipe dream. 
Smaller shops that want a quick time to market tend to go Spring in my experience. You tend to find a lot of traditional verticals (pubsec, FSI) still roll with JEE because of the wealth of knowledge they *already have in-house* in that space. Someone else in the comments mentioned not being able to find anything less than a Senior JEE role. I think that is symptomatic of the above. 
I certainly agree that JEE used to be a total PITA. Now that EJB2.x has been burned with fire, and JEE annotations are a thing, I think itâ€™s a lot easier for a newcomer to get to grips with. Iâ€™m just pissed because none of that stuff existed when I was learning. 
Come to Europe, lots of Java EE projects going around.
20 something checking in. We are an ee/spring shop. Id say 80/20. My co-workers are all 35+. The other 20 something that came into my office are JS devs. Its just the trend right now... But us java guys will always be there.
Personally I dread implementing command line parsing and configuration part of an app. Not because it is hard, but because it is boring. That and lifecycle management are the two reasons that I like using Dropwizard instead of doing it myself.
Hi, I know JavaEE/Spring. :)
Don't you think it kinda makes sense that people still in universities have no experience with enterprise development? Teaching people very ecosystem specific frameworks is a total waste of time in uni; there's more important stuff you should be learning there.
Work for a small Dutch firm specialised in enterprise Java. 90% of our projects are Spring. Mobile Back-end of the biggest Dutch bank is Spring for example.
I think the hurdle for getting started in JS is wayyyyyy lower than Java. Java brings a significant overhead with it. If I compare how to establish a databse connection in java and js and proably have an easier time with JS. This does not mean Java is bad. Java is over engineered in many ways (my opinion). It just takes more time getting started. Spring Boot took away a lot of this and replaced it with magic. JavaEE on the over hand will get their too, but slower as "businessy". Another reason I would say is eco system. The JS ecosystem is build on top of a lot of open source projects. Java never had that. It was for many many years very enterprise driven and that shows. If you look at Spring. Spring is this huge eco system of tools and libraries built on top of dependency injection. It would take months if not years to understand it all quite well. There is just nothing like that in JS compared to Spring. JS these days is quite hype driven (my opinion again) and this results in always the latest libraries being released and people jump on it. Java was always more for standards and standards take time and stay a while. I started as a Java dev and still work in the finance industry as one, but I have passion for JS because it is so lovely weird and yes, because you can throw together a little project pretty quick. But would I built a large enterprise software I h ave to maintain for years. I am not suicidal ... anymore.
Congrats on your determination to learn the harder technology, while the JS guys probably read 10 pages of js tutorials and that was it. When i was 20yo i just learnt what a database is.Poor country typical scenario.
&gt; java spring is as heavy as it comes. What does "heavy" even mean in this context? I mean, aside from you forming an opinion on stuff you haven't even used.
You know Netflix uses Node in production, right? Along with LinkedIn, and eBay... I agree with the sentiment that Java EE is a more mature platform, but to be honest, in a microservice architecture a lot of that maturity is just overkill. Java EE is really about the app server - something rapidly going out of style. Deploying containers is the new paradigm.
But they absolutely should make you aware of it, if it's a near guarantee to be immediately relevant in the job market. Teaching you how to make GUI programs in java is not guiding you in the right direction.
&gt; Anything more you would suggest that you think is crucial? Well, since you're asking, you could start reading my blog: https://blog.jooq.org/sql
Next thing you'll recommend switching languages because other languages got this right.
&gt; Data and logic can be mixed pretty easily (in db) I keep hearing people complaining about what *can* be done wrong, and certainly, they've seen ill-designed systems. I've seen ill-designed Java systems too. That doesn't mean we *should* be doing these things badly, no? &gt; and there's no static typing to help you isolate the logic What do you mean by that? SQL, views, stored procedures are all statically typed... &gt; And if your source code is (in) migration scripts on multiple versions... Well, that's crazy of course, but why would you approach it this way? The standard is to version control .vw files for views .pks and .pkb files for PL/SQL packages (or whatever the layout is) and install them as a whole. Yes, the tooling is a bit more hand-made than e.g. in Java. You could compare it to ant-style deployment, but I don't see a problem in doing this right.
I'm happy to see that the language is kept "regular". I wish they had done the same thing with a variety of other keywords and features to make the language more regular. For instance, I'd like to write static local classes, and for completeness' sake, why not allow the static keyword on top level types as well?
Why can you declare interfaces to be abstract? Because it makes sense. That doesn't mean people do it. But forbidding it would raise more questions than allowing it.
Wha, only Mac and Linux builds? Where's the Windows build, you hipsters?
Yes, 10 years ago when things were different. I'm proud to say that the company I work for hires a lot of juniors to train them. But most companies expect even "juniors" to have experience with Spring. In fact, even we are always looking for people who have gathered experience in Spring/JEE at uni (and surprisingly, most good universities here teach at least some form of JEE).
I learned JEE in uni and I absolutely loved it. Now I work with an in house AOP framework that resembles JEE/Spring but has its own pros and cons. When youâ€™re working with the framework itâ€™s easy to think that it works by magic but once you start maintaining it itâ€™s obvious that there is no magic - only logic.
I have worked for several German multinational companies doing DAX consulting. All our web projects are based in either Java EE or ASP.NET. In 10 years of doing such projects, I have only touched Spring MVC during one month. So I could also provide several examples of Java EE deployments, many of which running on top of WebSphere, if it weren't for NDAs. Not to say that there aren't many Spring projects going around, there are. However, Java EE projects aren't 0 as the OP was stating, and Spring uses many of the Java EE JSRs anyway.
Funny how different parts of the EU can be so different. It's almost as if they're different countries ;)
oh god I hated all the swing shit we had to do. Literally the biggest f#$@ waste of time.
A unique and novel angle on this old chestnut
I agree that `public static class Foo` to me makes more sense than having to create a private unused constructor in your class.
Yep. 21 years of experience. 7 I can stretch to include as JEE. Very interested in writing heavily in that or Spring. I can't get a call back. Probably going to get stuck going through a .NET migration after which I'll be a .Net dev with a couple of years experience, which will likely bump me down from Sr. level possibly to Jr. Level depending on where I wind up. Will also probably destroy my salary. Hopefully I'll catch a break in the next year or two, but I'm concerned where I'm going to be in 5 years.
Because everyone wants to jump on the lastest JS framework. All the Spring/JavaEE programmers who write enterprise grade apps that scale are snatched up. You have to poach those ppl from other companies unfortunately. 
That doesn't really mean anything. Amazon uses .NET Core... (on one tiny application that only matters to a handful of users in one department).
I would leverage your java experience as counting for some .net experience since java and c# are very similar. Same thing the other way - keep up personally on the java frameworks etc and you can leverage that experience. 
My company hired me and I picked it up. I never heard of it coming out of college.
Im 20 and used Spring for one of my university projects. Its a godsend. But yeah I only know of one guy my age that knows Spring. 
We used it for running stubs for load testing enterprise API's because it was capable of handling high tops with minimal cpu
How hard is this?? DriverManager.getConnection(url, user, password)
I also noticed that a lot of business will expect experience in EE/Spring even in entry level positions.
Spring is also kind of a hard framework to learn. Unless you have a bootstrapped project and someone willing to explain how and why it works, it might seems pretty daunting task to create a Hello World from scratch. Now trying to figure out what are the best practices on your own is even harder. No-one outside of enterprisey environment seems to know how to do _real_ world work with Spring. I learned Spring 10 years ago in a project. I already had 10 years of experience in other development including Java desktop and data processing work. It took be about year to really wrap my head around how everything works.
We won't know if other languages got it right unless we talk about it and compare. Discussion is the start of understanding. Maybe Kotlin/Swift/Rust etc are better with their optionally nullable (Int? etc) types, maybe F#/Haskell etc are better with their Option/Maybe type, maybe C/C++/C#/Java etc got it right with null reference, or maybe everyone is wrong and JS reigns supreme with null AND undefined. The point is that talking about and exploring the options around handling null isn't a short discussion, but it's one worth having because there are tons of examples of languages (modern and classic) that handle null through secondary systems rather than direct null references. And maybe (juuuuust maybe) those are worth learning from.
What does you static analysis configuration look like?
I knew this would happen, when I mention this :) well. maybe a bad example but I remember in the beginning I struggled a lot with JDBC, Hibernate and ORM in general. Finding a working config that worked in my case, because the one of the docs didn't fit my setup. It was cumbersome, with SpringBoot things are definitely easier. But I give you this one :)
First thing that it came to my mind is that market and university around you pushes different stacks. It came to my attention not so long ago, when I was teaching fellow at my university I saw that a lot of teaching material and courses are pushed by the local IT corps in order to satisfy their needs. Universities want their people to get jobs and corporations want to grab people with good base knowledge. Also, I am 24 years old, and I do know and actually worked with this stack. To be fair, I also have more then 3 years of working experience.
&gt; I keep hearing people complaining about what can be done wrong, and certainly, they've seen ill-designed systems. I've seen ill-designed Java systems too. That doesn't mean we should be doing these things badly, no? The thing is that Java is one of more restrictive languages and in an enterprise environment where you have over 200 engineers collaborating that is a very, very good thing. I'm not so sure about SQL. &gt; What do you mean by that? SQL, views, stored procedures are all statically typed... What I actually meant is, I want compile time errors and feedback, not runtime failures by the time someone walks into an edge case on a weekend. &gt; Well, that's crazy of course, but why would you approach it this way? The standard is to version control .vw files for views .pks and .pkb files for PL/SQL packages (or whatever the layout is) and install them as a whole. Yes, the tooling is a bit more hand-made than e.g. in Java. You could compare it to ant-style deployment, but I don't see a problem in doing this right. I want real VCS, real artifact repositories (like Maven - Artifactory) where unit of work is isolated and stateless.
I don't agree. Old j2ee with all the xmls was quite complicated, but modern servlets and jee? Maybe php is little simplier, until you run into its 'features' and also I started to hate various limitations of hostings.. I wasted so much time trying to overcome those. And if we look at the js, one just can't keep up and it's definitelly not simple and the dynamic nature makes you so free..to shot yourself into leg. And the modern frontend js with all of its tools and testing frameworks is nothing you can learn in one day.. And they also want seniors on the angular type positions, because for some reason they use it mainly in financial institutions. So it's not very different.
This guy knows how to develop properly. Beware!
I always sell myself as Java, .NET and C++ full stack dev, because we do projects across all these environments, and I happen to work in different roles across them.
Being aware isn't going to make you relevant in the job market. Honestly, CS students should spend a significant time outside class coding and learning. It's not the universities job to teach you the high level abstractions and frameworks are easy if you have the skills to write a framework which is what they should be preparing you for. One of the biggest problem with CS students I've noticed is they do the bare minimum coding to pass their classes and then manage to graduate not knowing a whole lot. Granted I went to a middle of the road state school but I got a lot out of it. 
Maybe it's just your impression, because company you work for has people experienced in Spring, so it's doing only such projects?
What were the stacks you saw being promoted by local companies?
&gt; started in JS is wayyyyyy lower than Java JS, do you mean Javascript?
by JS do you mean JavaScript or Java Standard Edition?
I think a lot of people in this thread are confusing JEE with other things. I never found it to be hard, complicated etc. I would say the same about Spring, but despite the hype, the educational materials for it and community support are pis poor.
That is true about everything in programming. Everyone wants experience, nobody is willing to give it. That is why internships are so important.
Please , there is a way to do everything web related with any languange. But ignoring that the languange itself is a horrible toy , you need 2000 files of node modules just for a minify.There are a million reasons i could list. 
&gt; The thing is that Java is one of more restrictive languages and in an enterprise environment where you have over 200 engineers collaborating that is a very, very good thing. I'm not so sure about SQL. That is just your personal, very subjective taste which you (and many of your peers) have been elevating to something like "a law" over these discussions. What can I say here? You won't believe me or hear me anyway even if my arguments are in plain sight and easily verifiable :) &gt; What I actually meant is, I want compile time errors and feedback, not runtime failures by the time someone walks into an edge case on a weekend. And what *I* actually meant is, PL/SQL, T-SQL, pgplsql and (ghasp) SQL are compiled by Oracle, SQL Server, PostgreSQL, etc. if you store them in the database. What are you even talking about? Open up SQL Developer (or SQL Workbench, or SQL Server Management Studio, or what not) and run CREATE VIEW xyz AS SELECT 1 FORM foo; It will not compile because of the syntax error and you get that feedback right away. SQL is a statically typed language. You just seem to completely dislike SQL to an extent where you don't even try to use it the way it is intended to be used. &gt; I want real VCS, real artifact repositories (like Maven - Artifactory) where unit of work is isolated and stateless. Sure. In Oracle, you can use http://www.gitora.com. I don't know the tool chains of other databases, but surely, SQL Server has a TFS integration, which is again integrated with git.
All I'm saying is that most of those languages (and many more) explore many more interesting concepts than this boring and silly idea of having 0..1 arity encoded in a special value. This really cannot be a language's most defining trait.
That's not the same thing. `public static class Foo` simply means that a class has no enclosing instance (i.e. is not an inner or local class). It would be redundant but not confusing on a top level type: // Top level type public /* static */ class Foo { // Nested (but not inner) class public static class Bar {} } It certainly should not mean that it cannot have any instances (what you're probably intending with that private unused constructor). Of course, this example shows one of Java's problems. The over-re-use of keywords for different concepts. I wonder if we should introduce `transient` and `volatile` classes.
&gt; Vert.x Did check out Vert.x since i haven't heard about it before. Looks awesome and i feel an urgent need to try it out.
I'm a Junior in a BS in CS program but I'm learning all the spring, spring boot, and react stuff on my own. The only useful classes I've taken have been an html+css class and an Android class. The rest were just a basic computer science java sequence + data structures.
Well, the static for nested classes is strange, I meant to use it for top classes indicating there is just one default instance (the one the JVM creates) and it can not be instantiated through other means. The only way to do this currently is to use an enum, ugh.
No one said it was a languages most defining trait. And of course there are more interesting things about other languages than their null handling. I, for one, would love to see coroutines (Kotlin) and pattern matching (Scala) ported to Java. But a lot of those defining language features are things that would need to be implemented at the JVM level, something simply have no control over. But "null" is a definable issue that people CAN talk about and provide solutions for. If we all thought it was fine the way it was we wouldn't still be talking about it, either we'd have agreed on some standard null replacement or we'd have said "fuck it" and things wouldn't have changed.
Some smaller API changes (grep for "@since 10") in build 36: # List/Map/Set.copyOf and Collectors.toUnmodifiableXX List&lt;String&gt; listBuilder = new ArrayList&lt;&gt;(); listBuilder.add("foo"); listBuilder.add("bar"); List&lt;String&gt; immutableResult = List.of(listBuilder.toArray(new String[0])); // Java 9; good luck with generics List&lt;String&gt; immutableResult = List.copyOf(listBuilder); // Java 10 List&lt;String&gt; immutableResult = listBuilder.stream() // Java 10 (stream) //.someOp .collect(Collectors.toUnmodifiableList()); # Reader.transferTo Similar to java.io.InputStream.transferTo introduced in Java 9. # FU UnsupportedEncodingException More constructors and methods take Charset encoding parameter, so you don't have to catch that useless (e.g. in case of UTF-8) exception. // Java 9 try { String result = URLEncoder.encode("foo", "UTF-8"); } catch (UnsupportedEncodingException exception) { throw new AssertionError("WTF? No UTF-8 charset, but JAVA spec. promised it's guaranteed to be here?!1111"); } // Java 10 String result = URLEncoder.encode("foo", StandardCharsets.UTF_8);
You donâ€™t have to be shit out of luck, as you could always do Java EE projects in your own time when in uni, or if possible try to do practical work using Java EE for your uni.
It makes you very aware of bounded contexts by design. My advice for Vert.x is to make sure that your Verticles only do one thing, and do it well - and make good use of the Event Bus. The [documentation](http://vertx.io/docs/vertx-core/java/) is awesome, and [Clement Escoffierâ€™s tutorials and blogs](http://escoffier.me/vertx-hol/) are really useful. Have fun!
&gt;Javaee has grown too much and standard spring too complex. Can you please give an example for both of these statements?
We have quite a number of EE customers in the Netherlands. Itâ€™s probably not for nothing that BalusC and Geert-Jan and a bunch of other well known EE folk is from there.
It probably doesnâ€™t mean anything. People have learned that â€œSpringâ€ == â€œheavyâ€, with both terms being black boxes. They could have learned just as well that â€œboobooâ€ == â€œslapokoâ€. Thatâ€™s at about the same semantic level.
College wasn't practical for me, I have java experience, moreso than PHP, which is what I currently write for a living, bit everyone who wants java is a large company that just ignored anyone without a degree ðŸ™ƒ
I'm a big Spring fan, but his comment is not inaccurate. However, with complexity you get flexibility, backwards compatibility, and standardization. So, there's that...
For fuck's sake. I absolutely hate the var keyword, and now I'll get to deal with it at work too, joy. Some complex types are already annoying enough when they're not hidden, so let's allow people to hide complex generic types so now you can go looking for the definition first to know what you're dealing with. I know there's some legitimate uses for var, but there are legitimate uses for goto too, and yet that was never included because it would cause people to misuse it. This will not lead to more readable code, ever. /rant
I probably "learned" spring after I used it in 3 distinctly differently set up projects over 3 different versions of Spring (2ish, 2.5 and 3.1) over 7-8 years of professional dev. I would never expect a dev with &lt; 5 years of experience to "know" Spring.
What are some legitimate uses for var in a statically typed language? I feel like all the resources I've found that discusses the var keyword in C# gloss over the keyword's appearance by saying "var has uses" but never dive into it. Outside of reducing the amount of typing you have to do (which I don't feel at all warrants 'var') I always draw a blank at what makes var useful?
I was never a big Spring fan but JavaConfig and Spring Boot started changing my mind; that and everyone asks for it. I'm not dyed in the wool DI, I use what works and is clear.
I'm doing more with .Net lately, that and Spring Boot. I can't stand Microsoft because of their past but they have come a long way with their tools. I get the impression that .Net Core is/was not really something that have/had their hearts in. Hopefully they will get new leadership that does something great like kill the Windows product line and start making Microsoft Linux.
Java we includes things like jsf and jsp and just tons and tons of specs for different technologies. Spring standard requires setting things up in xml. Spring boot removing that part of it is amazing.
Exactly. In my opinion it detracts from the overall readability more often than it helps. The potential of misuse weighs far heavier than the potential advantage it brings in very specific scenarios. (how often do you instantiate a [HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor](https://github.com/eclipse/org.aspectj/blob/master/org.aspectj.matcher/src/org/aspectj/weaver/patterns/HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor.java)? And even then the advantage is minimal. I'd rather they spent their time thinking of better ways to improve the language, rather than adding it "because every language has it and it's thus no longer a controversial feature". Worst argument I've read in ages. 
Do we know anything about the new httpclient?
I was wondering about the reason for the OP too.
will definitely follow this blog , very well written and easy to understand the steps , i already wanted to learn sql better.Thanks again for all the information
I like vs code. Seems to be going places.
experience since 21? Werent you still in college? How did you manage both studying and working , that had to exclude all free time.
Hibernate sucks in general. I much prefer something simple like jooq 
The former
Why do they never seem to talk about this stuff? I follow OpenJDK changes but never heard about these.
They're so obviously useful they don't need any discussion and someone just commits it? :O
&gt;Java we includes things like jsf and jsp and just tons and tons of specs for different technologies. That's not really an example, just moving the accusation a little. What is actually complex? Can you be more explicit?
Two projects ago was a Java EE project. So I know it's being used; there's just a lot more that use Spring.
We don't only do Spring. We're a firm specialised in enterprise java consultants. There's just a lot more projects that use Spring than Java EE. I used both on projects and both are in my skill matrix. 
Sure that would make sense. Except that var is only allowed for local variable declarations. It doesn't make sense for method parameters and isn't allowed for fields. I would say lambda parameters are most like method parameters. In addition the JEP states that it doesn't support mixing var with non-var parameters which sounds most confusing!
Fucking this. JS is even being used on the backend these days. JS is ruining programming.
They are technically countries, but not as isolated as they once were. Otherwise something like Brexit wouldn't really be a thing, would it? And as a Dutch person myself I can tell you that the border between The Netherlands and Belgium is largely invisible. Thanks to the lack of border controls and the Euro there's barely a difference between doing business in The Netherlands and in Germany. And as for banks, the Tridos bank in Zeist is mainly Java EE based for instance. It's perhaps not the biggest bank, but there you go. ING uses quite a bit of Java EE as well, and they're certainly not the smallest one, are they? And the SNS bank (Volksbank now) use quite a bit of Java EE as well. With the biggest bank and your username I guess you're referring to the Rabo. Yes, they are a Spring shop, but being a Spring shop even they use some Java EE. I'm pretty sure they had JPA, EJB, and JAX-B in production, at least a few years ago. And not a bank, but what about KLM? They're a well established Java EE shop, with very large parts if not almost everything in their backend being Java EE. And what do you think one of our biggest national pride in tech (ASLM) is using? You guessed it, Java EE ;) 
Yup
They do. You just have to pay attention to Java ONE, Devoxx and NDC talks.
Avoid RSI. I surely don't enjoy doing MyVeryLongClassname localVar = new MyVeryLongClassname(); And this is only the basic example, it is even more "fun" when generics with mutiple type parameters come into play, even with help of the diamond operator.
&gt; ING uses quite a bit of Java EE as well, and they're certainly not the smallest one, are they? Sure, but the entire mobile app back-end for example uses Spring. &gt; With the biggest bank and your username I guess you're referring to the Rabo. Nope, ING. We also work for the Rabo but ING is the biggest bank in Holland. 
Doesn't your IDE show what its actual type is? If not, that's what you should be ranting about, not `var`. If so, what exactly is the annoyance?
Yep stuff like that where it's super obvious what you are getting back. var foo = new Foo() or var foo = getFoo() I think it's generally pretty good. Most of the time where it sucks is when languages start inferring return types. At that point figuring out what getFoo() gives you can get complicated.
I do watch some of those, but I havenâ€™t heard about *these* changes.
just seems weird, since Java SE is a standard too, youâ€™d think this stuff would have to be announced.
"Summary of changes" link on http://jdk.java.net/10/ is a good detailed changelog for every new JDK build
Might be confusing for you, but it's moving towards consistency. For pure consitency it's still missing being able to omit var and the type like with lambda parameters now and for right-side inferred Generics (thankfully)
how would that be useful?
&gt; edit: using the new "var" syntax! aweful to read the example code as expected. &gt; `Collectors.toUnmodifiableList()` The same way they should have created `List.of` etc. factory methods for mutable lists and `UnmodifiableList.of` for the unmodifiable ones.
I have it installed in Ubuntu in a VirtualBox but it fails to open correctly, leaves black rectangles open and is basically corrupted. I've never really used it.
The IDE is not always at hand, say at reviews. Java is already too dependant on good IDE support. You don't see the type at first glance. Hovering takes navigation and waiting for popup. It's natural to look on the righthand side to figure out the type, if it's not clear from the left side. You loose more time because of unnecessary readflow interruption.
I can't use my IDE at all points during development. PR reviews, for example, come to mind.
The specification as a whole is complex. In my opinion anything that has configuration outside of the code itself, has a certain level of complexity. Javaee and spring both rely on that a lot. They are both massive frameworks, asking for specific examples within the ecosystem is futile I think. Do you want me to say how the war overlays work, or how war, jar, ear etc all fit together in it, or how xml servlets override each other in sub projects? Since apparently jsf isnt enough, do you need something specific to say ah ha no it's not? Any specification or framework should be able to fit into a single programmers mind, or it is trying to do to much and is too complex in my opinion. That is my litmus test. Having jsp, jep, rest, soap, beans, transactions, hibernate, xml object representation, etc. All in one specification is my argument it is too complex. In practice it gets worse I think as projects get larger and end up using them all.
&gt; But "null" is a definable issue that people CAN talk about That's exactly what I'm saying... Bikeshedding ;-) &gt; and provide solutions for Bikeshedding &gt; If we all thought it was fine the way it was we wouldn't still be talking about it Bikeshedding &gt; either we'd have agreed on some standard null replacement or we'd have said "fuck it" and things wouldn't have changed Bikeshedding Cheers. ;-)
Sure it's strange but it's been there since Java 1.0
Meanwhile everyone else is making the comment that "Your IDE will show you what type it is, what's the big deal?". If we take an IDE into account, this isn't a problem. Most, if not all IDE's will autocomplete just about anything. Even Notepad++'s autocomplete would do well in this situation. [This](https://i.imgur.com/RYlkNjU.gifv) is what it looks like in IntelliJ. I made sure to import the lib (aspectjweaver) into an existing project. I typed a total of maybe 10 letters. Even in notepad++ or sublime, you'd only have to type it in once, after which it becomes an autocomplete suggestion. Besides, just because I like being annoying, RSI is not caused by just typing more, it's caused by bad form while typing. If you have RSI, use a wrist rest or some form of ergonomic keyboard. Less typing is not a solution to RSI, because in the end, your hands will still be in the same position for about the same time.
If you mean exactly these ones in particular no, because the focus has been on Java 9 this year. Yet all these kind of minor improvements, outside modules, have been discussed. Some examples of what I mean, [Immutable Collections](https://www.youtube.com/watch?v=E1RXMCQ7k9g) [Collections Refueled](https://www.youtube.com/watch?v=ogRVWXuuAU4) [JDK 9 Hidden Gems](https://www.youtube.com/watch?v=G7pfr2XyLfI) [Collections Framework Enhancements in JDK 9](https://www.youtube.com/watch?v=nem4QUXepTc)
Ongoing, http://openjdk.java.net/jeps/321
Thanks.
I totally agree with this. I had a decent amount of Java experience in college, but had never touched Spring, Hibernate, or many of the other tools I use every day now. My mind was blown for a few weeks/months, but then I learned. Hiring managers just need to realize that colleges or coding courses are good at providing the basics and good algorithm concepts, but their company needs to teach "real-world" libraries etc to new hires.
Shameless plug: I'm working on a tool which creates an API change report between two given JDK versions: https://github.com/gunnarmorling/jdkapidiff, making it very easy to find about the new (and removed) APIs in new JDK versions. I'm also publishing some rendered reports (with a few package exclusions that made sense to me) and just updated the published JDK 9/10 comparison based on b36. The README.md has the link to that report, showing the new unmodiable collector methods etc. The tool is still work-in-progress, currently working on only taking exported packages into account and excluding package-private classes/methods. Feedback welcome :)
Yeah, I'm very familiar with the Java 9 stuff, but these new methods kidna snuck into JDK 10 :P
That's awesome! I wonder why there doesn't seem to be an official list of Java SE changes for each version, it seems like it must be very inconvenient for non-OpenJDK VMs to update without one (not that any actually exist :D).
Thanks, I didn't even realize that page existed for JDK 10 yet! It still doesn't seem to explicitly list these new methods, and they aren't listed at all in the JDK 10 "features".
&gt; Cheers. ;-) First off, don't be an ass. If you don't want to have a discussion then don't respond. If you think I'm wrong then talk it through like an adult, don't rely on childish replies. Second, "bikeshedding" doesn't really apply in this situation. We're not talking about a minor issue that has no effect on larger structures and architectures. Null safety, regardless of what either of us thinks, has been shown to cause issues. It's too easy to miss, especially in edge cases, and can lead to major problems. It's not called the "Billion dollar mistake" because it's a minor inconvenience. Let's talk about an example. Collections, by convention, are returned as empty rather than null, right? It's rare that someone is going to null check a list before running stream() on it. But what if it IS null? What if whoever implemented the method added a case where null is returned? What if that case is non-obvious? You end up with an NPE that can, potentially, cost a significant amount of time to debug. At the end of the day though, I know I'm just another faceless name on a message board, and if you're not willing to discuss this nothing I say will change that. Just consider that maybe in the future rather than looking to start a fight because you don't think the discussion is worth your time you could instead just downvote and move on.
Isn't anybody excited about [Optional.orElseThrow()](http://download.java.net/java/jdk10/docs/api/java/util/Optional.html#orElseThrow(\))?
So what does someone who wants to work as jEE developer do if there were no java internships? Got to start somewhere right.Probably need to be some kind of genius
What uni was this? Unless it's a computer engineering course your typical university computer science will not teach any frameworks in any language, let alone Java.
Example: Give me customer id 123 - another user deleted customer 123.
Can you also waste memory if you have a ref in a local variable that is no longer used, and the enclosing method runs for a long time? Also, if you have a long-lived object with a field that is no longer needed, setting it to null would help I think.
Here's one more subtle leak: File.deleteOnExit(). I just ran accross that recently when I build an application which would create an endless amount of temporary files and delete them. I added File.deleteOnExit() just in case something fails in between. Little did I know that this is adds a String to an ever increasing list. How to prevent it? Don't use File.deleteOnExit().
&gt; That is just your personal, very subjective taste which you (and many of your peers) have been elevating to something like "a law" over these discussions. What can I say here? You won't believe me or hear me anyway even if my arguments are in plain sight and easily verifiable :) I haven't seen those arguments that try to disprove what I said. &gt; And what I actually meant is, PL/SQL, T-SQL, pgplsql and (ghasp) SQL are compiled by Oracle, SQL Server, PostgreSQL, etc. if you store them in the database. What are you even talking about? Open up SQL Developer (or SQL Workbench, or SQL Server Management Studio, or what not) and run &gt; CREATE VIEW xyz AS SELECT 1 FORM foo; &gt; It will not compile because of the syntax error and you get that feedback right away. SQL is a statically typed language. You just seem to completely dislike SQL to an extent where you don't even try to use it the way it is intended to be used. I have never said I don't like SQL or don't like writing it, I merely said that I believe that Java is more maintainable language than SQL is and I acknowledge the fact that performance can be gained if you stick your logic close to your data. &gt; Sure. In Oracle, you can use http://www.gitora.com. I don't know the tool chains of other databases, but surely, SQL Server has a TFS integration, which is again integrated with git. Can you easily write unit/integration tests for within your project, along side your production code easily in SQL? You can deploy one instance of your application alongside other instances and easily knock it out if you detect something wrong. Can you do the same with DB? Is it as easy to setup? Are the risks the same? 
There are some books with practical real life examples of enterprise apps, but even that is lacking, as technologies change. But it's better than nothing, I guess.
There are more than one UI frameworks in Java. Which one will you be using? Start from there. 
JavaFX scene builder 
What alternative would you suggest?
I ended up with explicitly deleting in a finally block
Awesome read. Two questions from a new SWE: 1. How is detecting memory leaks in production code typically handled, is profiling common? 2. How do memory leaks that aren't significant enough to cause an OutOfMem exception affect program runtime?
Thanks. I was looking at the google drive desktop app and trying to find out which programming language was used but to no avail. Let's say google drive is made in Java which UI framework was used?
Thanks..I'll look into it.
That is wasting memory, but not a leak.
I'm 25 and I use Spring on most systems that I own. A couple Guice and non-Java systems mixed in if the system is newer but for the most part its Spring.
Where are you? I know that college students will invariably have never heard of JavaEE, and if they have, they think of the color gray. Additionally, the kinds of companies that use JavaEE aren't the kinds of companies that younger developers even *think* have programmers. I mean, I'm now in the finance industry, and my company has a small army of programmers. If I go to the local university, however, they wouldn't even *think* that we had that many programmers doing that many things. Honestly, I'd look for raw Java knowledge from those that are under 25, and between 25 and 30, I'd look at resumes from large consulting firms, which are more likely to use JavaEE regularly.
Thankfully this problem has been around long enough that most of the analyzers will recognize a bunch of annotations and/or make the list configurable and/or recognize them regardless of the package information. But I agree, it's really getting to be ridiculous that this (or some other sort of non-null marker) isn't part of the JDK. A lingering problem with the various existing annotations is that *some* of them were designed prior to Java 8 and can't be used as type annotations -- unfortunately including the JSR305 ones which are as close to a standard as this has gotten. This can cause issues in the analyzers because code that has identical annotation placement can produce a different AST depending on whether the annotations are defined as type annotations or not.
JS on the backend is really great for simple websites that have lots of forms because you can use the same validation file for front and back end and not need to deal with duplicating business logic.
I dont think this is relevant for daily coding... Java is enough old and stable, the garbage collector works definitely well. 
I suppose so, unless the reference happens to be a collection.
I'd argue that if you have names that become too long, it means that class is doing too much. Divide and conquer. Another argument is the 3 seconds you save on typing that name (which you're probably auto-completing anyways) will not make up the 15+ seconds a code review will take the reviewer to decipher that type. This is an instance in which more verbosity is actually better than less.
Profiling is the way to assess and handle memory leak issues. What I will say is that one of the many reasons I am a fan of implementing many small microservices across containers and this is but one reason why. Certainly there is added complexity in managing the overall state of these services in a stable way, but there are many positive and negative tradeoffs to be argued between large monoliths vs scattered, small microservices. At the end of the day, a memory leak inside of a massive monolith application is going to be that much more difficult to solve whereas it is a bit more manageable with smaller chunks/components services. All the same, regardless of your infrastructure/architecture choices - the important thing is to stay on top of profiling early and consistently; if you wait until an application is in production and massive in scope before you worry about the memory leak problem is likely is already too late. By that point you may have major symptoms of a memory leak which are really the result of many separate leaks stacked on top of each other throughout the codebase. Finding all of these will be difficult to pin down and will stagnant development for quite some time. You don't want to over-engineer or hyper-optimize to the point that you can't move forward at a reasonable pace, but sprinting ahead without taking time to analyze these things and balance "technical debt" will quickly come back to haunt any development team later. 
I've been programming in Java post-grad for ~8 years and it wasn't until about a year ago that I started working with Spring Boot, after a brief period of trying to learn Spring Core. I also worked with Struts at my first job, but since then the vast majority of my work was in legacy migration activities, writing code that lived mostly outside of a particular framework/ORM. It's a complicated question. 
The project I work on just recently removed this very call. It was useful though: an external team tends to screw up xml and blame us, but since there were a bunch of temp files from the service they use we could search through the files to show itâ€™s their mistake.
While people have said, "learn topics, not frameworks", it might be useful to know *what* topics you need to learn: * Dependency injection: this is the big selling point of Spring and JavaEE. In fact, it's a big part of why they exist: companies wanted the ability to plug in small, company-specific modules into large, commercial, off-the-shelf products that did most of the heavy lifting. We've taken it a few steps further since then. * Object-relational mapping: Java's database interface tools are shit. Most Java guys hate databases for that reason. Both Spring and JavaEE provide object-relational mappers to try to alleviate some of the pain of interfacing with databases. * Batch jobs: This is somewhat newer in JavaEE, but Spring has a batch architecture. Batch jobs are everywhere in large businesses. There are just things you really want run at night, because you want to, for example, send out a hundred thousand letters a day, each to separate people containing tailored content. Or maybe you're getting a daily feed of items being scanned into or out of a warehouse. Or maybe you're getting HR feeds involving payroll data. I've done *all of this stuff personally*. * Web service design: Focus on RESTful web design at first. It's in higher demand simply because of its reduced conceptual overhead (also, the fact that Javascript doesn't balk at it in any way). * Build automation. Pick one: Maven or Gradle. Pick one: Jenkins, Gitlab, Bitbucket. * The basic architecture of a Java server product: what are WARs and EARs, what do they contain, and why do you care? There are also things you probably shouldn't sweat: * Message driven architecture: This is an advanced concept, and in my opinion, JavaEE just does it better. This isn't to say that JMS is necessarily *good*, but it's just not something you should care about at first. * JSP. Honestly, it's a bit old hat at this point, and most apps are moving to a single dummy JSP that serves up a Javascript-driven frontend. As much as I hate Javascript, I can't say that this idea is *wrong*. * Anything that involves direct use of servlets. If you're not implementing JavaEE, you shouldn't care about servlets directly. Now, cards on the table: I'm a JavaEE guy. I think it's amazing stuff. This is not intended to disparage Spring. Spring has a Spring Way of doing things, and as a result presents a very consistent set of APIs. JavaEE is more about standardizing the APIs of popular--even best-in-class where possible, and sometimes even meaning copying Spring wholesale--libraries and frameworks, then letting individual implementers have their way with it. In theory, changing JavaEE vendors shouldn't be too hard. In practice, it depends on how much implementation-specific behavior you're using.
Surprisingly coherent article. I guess I'm old and cynical and have seen too much "memory leak in java, your pointers are wrong" shitposts. Anyway - this is a good article. If you are not comfortable with java gc and memory leaks and cannot name 3 different profilers when woken up in the middle of the night by naked group of swedish supermodel teens jumping in your bed this will help.
Did anyone else read 2.1 and yell out "DUH!" ? 2.1 isn't a leak, it's the programmer specifically telling Java to create an object the first time an instance of that class is accessed and not get rid of until the JVM (and/or ClassLoader?) is shut down.
I feel like it's exactly the opposite and the long class names in Java -- they are long because they are incredibly specific. When you start stacking design patterns on top of eachother, something like `RedisHttpSessionUserResouceAccessStrategy` doesn't sound like a class that does too much, but probably something that does too little.
The problem with .NET Core is that while some parts of .NET Framework carried over to it, some did not. There's also the weird case of Entity Framework Core (the .NET approximation of JPA, more or less) missing features that Entity Framework 6 had.
I've been doing more .NET stuff in my free time, but I'd still rather use Java/Spring or C#/ASP.NET MVC over the js lib-of-the-week.
Java has a lot of terrible developers though. HotSpot is objectively a better runtime than V8, but Java developers tend to work at a very high level of abstraction that covers over the low-level primitives that make Java a compelling language in the first place. You don't need Spring to read from one socket and write to another. Java is great at this kind of micro-service work, but many Java developers are not and really struggle with writing more procedural code.
&gt; In my opinion anything that has configuration outside of the code itself, has a certain level of complexity. Configuration outside of the code? &gt;war overlays War what? &gt;xml servlets override each other in sub projects? Wait, what??? &gt; how war, jar, ear etc all fit together in it Most modern projects only use the war. If you want it, you can add some level of layering by going with an ear, but it's not at all mandated for anything. &gt;do you need something specific yes &gt;to say ah ha no it's not? The overwhelming majority of people just parrot "Java EE and Spring are heavy", without even knowing them. &gt;Any specification or framework should be able to fit into a single programmers mind You mean like programming for the Unix system? Or even for OS X? Or Android? Or .NET? Or for the JavaScript ecosystem? All of that fits in a programmer's mind? &gt; jsp, jep, rest, soap, beans, transactions, hibernate, xml object representation, jep? xml object representation? Also Hibernate is not in either Java EE or Spring. Spring does uses it through, and some (but not all) Java EE implementations use it. How is that different from a gazillion other frameworks and ecosystems that use a gazillion other options for persisting data and/or talking to the database? But your terminology and "examples" have given me enough evidence so suspect you barely know what you're talking about and are just another parrot who at most has done some quick Googling to find reasons why Java EE and Spring are supposedly heavy. 
&gt;&gt;ING uses quite a bit of Java EE as well, and they're certainly not the smallest one, are they? &gt;Sure So there you go, even you basically admit here that OP's statement that "I never see anyone wanting Java EE. Literally 0" is nonsense. I also don't think Spring/Java EE usage at ING is at 90%/10% tbh. I know you didn't say this, but still. &gt;We also work for the Rabo but ING is the biggest bank in Holland. Okay true, ING is indeed bigger. Still holds that Java EE *is* used quite a bit in The Netherlands as per my other examples, and that the biggest bank does indeed use a fair share of Java EE as well ;)
1. Profiling once in a while gives you a good impression about your application, but you could effectively add a leak with every commit. Enable gclog and then use the http://gceasy.io/ API to monitor your health. 2. I have problems to imagine a non significant leak. I can only imagine a scenario where the application is intended to run for a defined time. Then if you don't get a OOM, the leak still decreases the amount of available heap, which directly increases the pressure on the GC, which can degrade the performance of your application (too many, too long Stop the world collections). But profiling would tell you when this happens.
&gt; So there you go, even you basically admit here that OP's statement that "I never see anyone wanting Java EE. Literally 0" is nonsense. I also don't think Spring/Java EE usage at ING is at 90%/10% tbh. What is there to admit? I didn't know there was even a discussion? I'm just saying that my experience with enterprise Java in the projects that we do in our company is roughly 90% Spring, the rest EE. &gt; I know you didn't say this, but still. So you're basically attacking a strawman twice. I never said that and I never said that the usage in the netherlands is 90/10%. I said that in **my experience in the projects we do** the difference is roughly 90/10. We do a relative large amount of greenfield projects so that might very well account for the discrepancy between your experiences and mine. &gt; Still holds that Java EE is used quite a bit in The Netherlands as per my other examples, and that the biggest bank does indeed use a fair share of Java EE as well ;) I really don't get why you get so incredibly aggravated whenever someone mentions that in their experience Spring is used more than Java EE. Who cares? It's just a bunch of tools; use whatever you want.
Wow , thank you , your post has been tremendous help. I never had a problem with sitting my ass down and studying , in fact i love it and i spend a lot of free time for that. But since i dont know a single java developer (no large companies in a 800km radius..) its very hard to understand the ecosystem and how javaEE/ Spring are actually used in real life.So knowing what to study and why to ignore other topic helps a lot , appreciate that. Since i couldnt find a java internship i also dont have the experience almost everyone requires , hence im not sure if i cam ever find a job so ill try my best to learn as much as possible. I have a few other topics which i dont know whether they are relevant to a java engineer position so if you could tell me whether i should study them would be great.Job titles are confusing you know lol * Docker.Only been shortly briefed about it.Will a java junior job use it , and would knowing it make me a more attractive candidate? * Microservices * Advanced sql. Are complex queries enough or do i need to know the DB architecture / optimizer etc? * Servlet async. Its a bit hard to grasp.Is this used a lot? And speaking of servlets , you suggested ignoring them , but i was under the impression that i would be tested to setup a servlet as a basoc check in an interview? And doesnt every web request start with a servlet anyway? Thought it was the most important topic actually wow. * JSF? Ignore or learn? If you dont have the time a single.yes/no would suffice but thank you in advance anyway for the help.
If another user already deleted customer 123, how did the first user even get the option to request information for customer 123?
You can still get memory leaks if you hold on to references, if the garbage collector can't get rid of the root, there's not much it can do to help you. 
I believe this very helpful https://www.reddit.com/r/java/comments/7ega84/what_we_can_do_with_java_10/
It's not really a leak, is it? It has to know what to delete when the application exits.
I'd be nervous about giving my Enterprise logs into a free source. 
You can create a subtle leak if you use File.deleteOnExit() "just in case" for an infinit amount of files: while(true) { File tmp = File.createTempFile(â€¦); tmp.deleteOnExit(); // Just in case something fails before the explicit delete â€¦ tmp.delete(); } Now you have a memory leak with the ever growing list DeleteOnExitHook.files, as tmp.delete() doesn't afffect that list. For me personally it's subtle as I'm not aware of the implementation details of File and the documentation of File.createTempFile() encourages the usage of deleteOnExit(): &gt; This method provides only part of a temporary-file facility. To arrange for a file created by this method to be deleted automatically, use the deleteOnExit method.
It's the GC logs. What is in those logs which makes you nervous? Edit: They have also an Enterprise version, which runs wherever you want. Plus they plan to open source that. So if you want there's no need to use their SaaS. Edit2: It sounds like I'm selling that to you. I'm not affiliated with them, just a happy user.
This is really interesting, thanks for sharing.
I think it's still something good to know about.
Uh dunno. I'm everbeeing skeptical with free services since Facebook. I thought they can't make big bucks with a free service. And boy was I wrong. And I was the product! So I really can't say which informations would be interesting from GC logs, but fo' sure there must be something, if it's free!
I try to delete and if the delete fail I call deleteOnExit. Best of both world.
FOSS? Are you a product when you use FOSS applications? Some things are genuinely free. 
Then what's the point of the degree? That's like requiring someone to get a degree in electric engineering before teaching them how to be an electrician on the job. 
So, Show me the source then, if it's FOSS? And why do I need an Enterprise version (which DOES cost money) when I want to deploy that on my own servers, where I can be sure nothing is done with my logs? Why can't I do that with the free version? Questions over questions
I'd consider that too specific. Since there are many individual descriptors in that name, you could make 'redis' and 'httpsession' packages. And abbreviate strategy to 'strat'. Could even do 'URAStrat'. Although technically I see your point, I don't think its a realistic scenario or one that wouldn't be solved by better class design given how you said yourself - that class probably does too little. I think that the problem of overly descriptive names can and should be solved by the developer and not the syntax.
How do you port it? I'm working on a big Jsp application myself. 
From a semantics perspective or how they work under the hood? I mean, arrays are reference types themselves. 
How do they differ? Or, how are they better than C# structs? 
They are immutable.
ELI20 please?
I'm not talking about this particular product, in general just because it's free doesn't mean you're the product. 
I think the information about String.intern() is incorrect for later releases of Java. At least according to this article the strings in the string pool are eligible for garbage collection when they get unreachable: http://java-performance.info/string-intern-in-java-6-7-8/
&gt; The IDE is not always at hand, say at reviews My experience doesn't chime with yours, which is why it didn't occur to me. &gt; Java is already too dependant on good IDE support. I don't disagree, but I don't think the language will get out of that foxhole any time soon. &gt; You don't see the type at first glance. The same delayed insight applies to inherited methods, interfaces or design patterns. &gt; It's natural to look on the righthand side to figure out the type, if it's not clear from the left side. You loose more time because of unnecessary readflow interruption. Then you're not really against using `var`, just against lines without type indications *at all*. Just because you *can* use `var` doesn't mean you always *should*, or that using it will always be the most legible approach. I suppose it depends on your collaborators or personal style whether it's acceptable to use it only when calling constructors and foreach loops, or perhaps also for well-known built-ins and simple types with long names. Legibility and code style can be very personal things. I personally don't like unnecessary clutter in code, and `var` scratches one such itch.
I do not think it is smart to be this strongly opposed to var. It has been a long time trend for languages to adopt var (or more generally inferred typing). One of he reasons for this is just what you say you hate about var; it hides complex generic types. This is good because it allows more complex generic types to be used. This is good because the types enable the compiler to do more compile time checks og types, which prevents more runtime errors. For example: the option type has basically eliminated null pointer exceptions where used. But it is a bigger hassle to write Optional&lt;int&gt; a than var a, which may deter some people from using it. Now optional is a simple case. But what about java streams? They have huge signatures to enable seemingly trivial more Â«functionalÂ» operations like map. However it is not worth having all the boilerplate for such a seemingly small gain. With type inferrence however, more people would learn to appreciate the power of a more functional and pure approach rather than keep writing writing error prone for loops. I used to have the same arguments against var as many of the people here. But after actually spending some time doing it i cannot imagine how reading twice as much is more readable. I feel that in practice it is easier to read the code because the logic is apparent even without the types written plainly (with or without ide). I suggest people to show some good faith and try to use inferred types for a while (a month?), to get used to it at least, or more likely, learn to enjoy it. 
&gt; I didn't know there was even a discussion? OP said: "I never see anyone wanting Java EE. Literally 0" to which pjmplp replied: "Come to Europe, lots of Java EE projects going around" to which you replied: "Work for a small Dutch firm specialised in enterprise Java. 90% of our projects are Spring [..] biggest Dutch bank is Spring" Which, especially given the context in which you replied, strongly implies that "lots of Java EE projects going around" is questionable at best. Since largest bank, 90% spring... To which pjlmp replied: "I have worked for several German multinational companies doing DAX consulting. All our web projects are based in either Java EE or ASP.NET" To which you replied: &gt;Funny how different parts of the EU can be so different. So with "different", what can that mean? pjlmp says a lot of Java EE in his projects in germany, you say 90% of your projects are Spring in holland. Hence, you imply that with different countries in the EU being different that the Java EE usage is different between germany and holland. So then I reply: "Tridos bank in Zeist is mainly Java EE based [...] ING uses quite a bit of Java EE as well [...] KLM? They're a well established Java EE shop [...] (ASLM) is using? You guessed it, Java EE" So then finally we get to you replying "sure" to "ING uses quite a bit of Java EE as well". The entire discussion is thus, that relative to Spring: * Is Java EE used much at all? * Is Java EE used much in the EU * Is Java EE used much in The Netherlands And since you're kinda known as a Spring fan here (like I'm known as a Java EE fan, no insult there), I think it speaks volumes that "even you" (meant in a positive way), "admit" that the largest bank in The Netherlands uses "quite a bit of Java EE". &gt;I really don't get why you get so incredibly aggravated whenever someone mentions that in their experience Spring is used more than Java EE. Who cares? It's just a bunch of tools; use whatever you want. I agree with the latter, but there are strong implications here, which are that in fact those tools aren't being used. When spreading FUD (perhaps not on purpose even) that tools aren't being used, other people read it and also don't use these tools. You get into a race to the bottom, based on nothing. I get aggravated because this has been going on for a long time. It dates back all the way to the heated discussions on TSS and it has been the strategy for a long time to blacken Java EE based on unsupported claims "it's heavyweight", "it costs millions of dollars", "it's closed source", "it's designed by committee". People read that over and over again and start to shun Java EE themselves. Back in 2001~2003 Java EE was one of the many tools I used and I had zero involvement or connection with anyone in Java EE, and it already annoyed me greatly. Back then there WAS a pile of junk in EE, but even then the FUD was greatly exaggerated. While Java EE has improved massively, the FUD has always been going on. Hence my response.
Google drive is web based so it's possible no Java ui framework was used. It might be using a Javascript framework instead. If it was using Java it might be using something like GWT. 
I've never said that. My gosh. Good job iron maiden. Text comprehension level over 9000.
Docker: itâ€™s a part of automation stacks. Learn itâ€”and how it fits into the artifact deployment world. Microservices: itâ€™s a buzzword to sell simple, single-purpose services, then using them separately. Learn why, but study RESTful design and implementation. Advanced SQL: thereâ€™s a point where you need to say, â€œIâ€™m no DBA, Iâ€™ll let them handle it.â€ Do know when itâ€™s time to denornalize data, when itâ€™s time to use a caching solution, and when you should stick to proper normalization. Servlets are underlying architecture. If youâ€™re worried about them at this point, youâ€™re not in junior territory anymore. I would not expect anyone with less than 5 years of JavaEE experience to know much about worrying about servlets. JSF: learn, unless you really want to point yourself in the direction of being a services architect. A part of me regrets not doing much work on the front end. 
I don't disagree that it is easier at the time of writing, I certainly agree there. I even agree that it may lower the barrier to lambda's, which is, again, a good thing. I still do not think it's a good idea, nor do I think it's a good learning tool. It teaches you nothing about typing, and while that will result into less errors, it will also inevitably lead to overuse/misuse. That's my biggest concern. You assume I've never used type inference, but I've done C#/C++ for far longer than a month combined, and I've used both var and auto in each, even though I didn't really see the point in it back then (Both CLion and ReSharper suggest using it, which is why I did at first). I still don't like it. Not in my code, and ESPECIALLY not in code I have to review. Might be just me, but I find it very unclear. &gt;This is good because it allows more complex generic types to be used. How? Just because you don't have to immediately deal with it? You're making your code harder to understand by _not explicitly stating the type of your variable_. Even though it is complex, you still need to know. If I see a complex type, at least I know what to do with it, or what direction to look. How is ```var a = funcThatReturnsComplexType();``` clear? How does that help me? I'll still have to know what the type is anyway, so I now need to go look for it somewhere else. Is that a bad use of ```var``` then? How are we stopping people from using ```var``` for _everything_? Might as well start assigning everything to ```Object```, while we're at it. Then even the compiler won't know what's happening. I'm not "afraid" of the **existence** of ```var```, but more about the **potential to be misused**. It reminds me a lot of ```goto```. There'd be a lot of opposition to introducing ```goto``` into java. Not because it has no legitimate uses, but because we're actually fine without it, and misuse would lead to harder-to-maintain code.
&gt; I merely said that I believe that Java is more maintainable &gt; language than SQL Having written a lot of PL/SQL, I disagree. In fact I prefer SQL in PL/SQL to SQL in Java, because SQL is statically typed in PL/SQL, while it is an opaque string in Java. On the other hand, PL/SQL is annoyingly verbose. So I prefer to write Java. &gt; Can you easily write unit/integration tests for within your project Yes, you can. You can write unit tests in PL/SQL. You can even easily mock database objects using synonyms. &gt; You can deploy one instance of your application alongside other &gt; instances and easily knock it out if you detect something wrong. If your application is PL/SQL, you can do the same thing. Take a savepoint, deploy your packages, if things go wrong, roll back. Just think of the DB as an application server, like any of the JavaEE app servers. If you don't like that, containerize the database. &gt; Is it as easy to setup? If you understand the database, it is very easy to set up. Problem is many Java devs don't seem to understand databases and prefer to think of them as magical black boxes that they write queries for. &gt; Are the risks the same? The risks are different, since DBs are a different tech stack, but they are of no different scope and magnitude. You just have to understand how DB tech works. 
Not sure what it means for Java itself due to this is jvm level. It introduces a new class attribute that allows you to build a nest of classes. That seems to allow for a class in the nest to access the private members of a another class in the nest. It is stricter than package protected but looser than private. Warning: I read it half asleep so may have missed something important Edit: here is the actual jep http://openjdk.java.net/jeps/181 and it lists the ramifications 
&gt; In Oracle, you can use... Why? You can use ordinary git for packages and views, be CREATE OR REPLACE. Tables are problematic because you can't replace a table without dropping it, but for tables, we isolate ALTER TABLE into migration scripts, which we version control in git. I don't know why people keep saying that the tooling for DBs has to be so different. I know tools like RedGate exist to do migrations, but I've never found the need for them. 
The point of the degree (which was actually in computer engineering) is that I understand how my instructions are being executed down to the silicon level. I have experience dealing directly with multiple languages, sensor inputs, networking protocols, as well as technical writing, economics (I have an econ minor), working in groups, managing people, etc. Many colleges do a worse job than they should, but on the other hand it is effectively impossible for them to prepare students for every work environment in every programming language. I could just as easily be in a non-Spring Java EE-only environment, so if they would have taught me Spring, would that be useful? This is why internships are vitally important for software/engineering students (my internships were actually in Systems Engineering for the record).
He seems very attached to his girlfriend
From my understanding, itâ€™s going to be used in the implementation of value types.
Indeed. Though I suspect there is a subtle and far more prevalent version of this in production software: Collections in effectively-singleton beans with application-cycle lifetime. 2.5 is not a leak either.
My company has a training program for out of college IT hires where you learn Java EE/Spring. Seems to be a good decision; learning spring is a pain 
Step 0: Add headers and footers, templates, etc. so you can include them easily from other JSPs. You probably do this already, but I had to include this. PHASE I: CREATE THE FRAMEWORK Step 1. Add Spring config XML. both for context and for spring-web. Configure views folder (prefix) under WEB-INF/views, and set suffix to .jsp Step 2. Create hello world controller and add dummy jsp view. For security, Spring security might be too hard to config for now, so we'll put the security in the controller for now, as follows. Step 3: Here comes the fun part: Create an interface for a controller (why an intergace I'll get to that later) with security methods: add public methods get the session, user roles, checking if the user's logged in, etc. Call this "MySecureController", or something. Step 4: Create an abstract controller class that implements those security methods. Call it "BaseController" or something. I assume you do your security on the start of all the JSPs. Copy that code to the base controller. Step 4B: As convenience, you can get the ServletRequest and Se4vletResponse and request attributes statically (courtesy of stackoverflow): public static HttpServletRequest getCurrentHttpRequest() { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); if (requestAttributes instanceof ServletRequestAttributes) { HttpServletRequest request = ((ServletRequestAttributes)requestAttributes).getRequest(); return request; } logger.debug("Not called in the context of an HTTP request"); return null; } Add methods to get the request, response and session to the base controller. Step 4C: Create exceptions for timed out session and access denied. Add @ExceptionHandler annotated methods to your base controller to handle these exceptions, and redirect to error pages or the login page, etc. Modify your security methods to throw these exceptions. Step 5 (optional): If you know AOP, you can add aspects for detecting security annotated methods in your controllers (that's why we needed the secure controller interface). But if you can't do this or configure spring security, you'll have to add security checks in all your controller methods. In any case, we've centralized our security to our base controller by now. PHASE II: CONVERT YOUR MODULES. Step 6: Replace variable evaluating scriptlets &lt;%= varname %&gt; in your JSPs with ${varname} annotations, and add the jsp core tag library for for loops and conditionals. This may take a while. For each module of yor app: Step 7: add a controller by inheriting your base controller. 7B: copy the jsp files to their corresponding view folder. 7C: Add the @Controller annotations to each. Then add a method with its @RequestMapping for each of your "main" jsps, returning the path (relative to the views folder) of your desired view (without the .jsp extension) Step 8: Start moving the hardcoded scriptlets to your controller methods. Also, in each method, add the variables to your ModelMap, otherwise the evaluations won't work. Step 9: Test that your controllers work fine by entering their urls directly in the browser and testing each action. Step 10: Now that the controller for your revamped module works fine, replace the old urls with the new one. EDIT: Step 11: Move your servlet codes to new methods in the corresponding controllers. This should be done last, now that you got all your JSPs MVC-fied. Rinse and repeat. In a small app, consisting of 5 modules and around 15 jsps, the process can take around two weeks.
&gt; Then you're not really against using `var`, just against lines without type indications at all. Exactly. That's why I'm against using var at method returns only. To me I think thats going to lead to more misuse than benefit and shouldn't have been made possible. So far, nearly every new feature or std lib. extension that came into Java was horribly misused (e.g. Annotations, Optional, Stream). There's always a rush to use these everywhere whenever they are released without much thinking. Compared to Microsoft for C#, Oracle doesn't even release guidelines to hint at the problem of method returns (see [here](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables)). As me and my team don't develop in a vacuum, we are bound to stumble on these misuse-cases, be it in libraries, tutorials or examples. 
&gt; To me that's clear misuse of the language and shouldn't have been made possible. Fair enough. &gt; So far, nearly every new feature or std lib. extension that came into Java was horribly misused (e.g. Annotations, Optional, Stream). There's always a rush to use these everywhere whenever they are released without much thinking. I haven't used Java professionally enough yet to be able to tell, but it doesn't surprise me. &gt; Compared to Microsoft for C#, Oracle doesn't even release guidelines to hint at the problem of method returns (see here). I think Oracle's documentation in general is horrible and overly academic, as compared to for instance Microsoft's. &gt; As me and my team don't develop in a vacuum, we are bound to stumble on these misuse-cases, be it in libraries, tutorials or examples. I hope you guys at least agree within your own bubble.
Makes sense. Have the generic be the host and all the specialized versions be in the same nest. Also sealed classes one day. Also the jep talks about fixing some of the synthetic methods generated today.
Adds to the learning curve... A lot...
I use whatever the client decided upon. I have a small preference for Spring. That's not "being a Spring fan". I am not "spreading FUD", I just countered someone who said that in their experience Java EE is used more in the EU, my experience is the opposite. You're reading way too much into it as usual. I strongly prefer both EE and Spring staying viable candidates; competition is good. 
Having used Spring, Dropwizard, Java EE, roll-my-own-Dropwizard, the whole shebang: Spring Boot. It's simple. It's friendly. It's **documented**, and most importantly, it **just works**. There's no more magic in there than Dropwizard. 
All these examples of Optional and nested Maps or Functions hint towads design issues and lazyness rather than increased maintainability, composition and readabilty. One thing that Scala thaught me is that simplicity and as much explicit design as possible is a huge deal for productivity (Scala tends towards implicit magic and complex YAGNI implementions which are pita to deal with).
&gt; custom auth scheme Done, done and done. Java EE doesn't even have a sane authentication standard. I've used Apache Shiro in the past for this. Spring's security architecture is pretty similar and extensible, and I have no issue implementing custom schemes here. 
To be fair you can do that with Spring on Tomcat as well. But wouldn't you much rather have blue-green deployment so you have zero downtime, not a few seconds?
The thing is, the "magic" does add to the learning curve but if you have any members of your team who are decent with spring they are more than capable of helping beginners get over that learning curve. 
Consider the source code for a nested class: class Foo { private int val; class Bar { void x() { val++; } } } Since `Bar` is inside `Foo` it has access to other things that are declared within `Foo`. However, when this is compiled, the nested structure is "flattened" into separate classes: Foo.class Foo$Bar.class As far as the JVM is concerned, `Foo` and `Foo$Bar` are independent classes. So how can `Foo$Bar` get access to private fields of `Foo`? This has historically been a problem. Earlier, `javac` would silently relax the access level of private fields to have package access. (You should find this disturbing.) More recently, `javac` will create "bridge" (synthetic) methods to mediate access to private members. This is better, but among other issues, it converts what should be a simple field access into a method call. JEP 181 proposes to introduce nesting as a first-class construct known to the JVM, so that `Foo$Bar` is known to the JVM to be nested within `Foo` and not an independent class with a funny name. This in turn allows the JVM to permit `Foo$Bar` access to private members of `Foo`, without the need for `javac` to create bridge methods and such.
Oops, I meant my [post](https://www.reddit.com/r/java/comments/7ll5kh/jep_181_specification_introduce_nests_as_an/dro57o4/) to be a reply to this one.
Actually services achitect is pretty much what i would like to go for.I have also been studying azure and soon AWS. Still i will learn JSF why not. Im still confused about the servlet part.The first thing i learnt was install/set up tomcat and use a servlet to write various responses , read headers etc. What are the alternatives apart from jsf anyway? Thanks again for you help, its great to know what you actually need to study. Finding these things are harder than studying itself. I think im gonna go for docker next since it seems easy and its quite marketable , compared to just more details on the 2 frameworks
How is Websphere Liberty? I can't think of anything as painful as getting back into bed with IBM as being on WAS 7/8, but there appears to be some good stuff going on. 
It's alright. Startup times are more comparable to Tomcat and config is almost as easy. The issue, at least up to a few months ago, is that IBM did not recommend it for production. So on my projects, developers were running the streamlined version and higher environments got stuck with the crazy bloat of full Websphere.
Null is the ultimate bike shed 
Itâ€™s not so much that you need alternatives for servlets, so much as it is the fact that almost everything does the work of setting up servlets for you. 
No i mean what other ways are there to display a message etc like a simple response? 
You could, say, wrap it in a JAX-RS endpoint. 
It allows for more complex types to be used because it hides the additional hassle of writing and reading signatures for example for streams and optionals as was my point. But i think it also depends much more on the style of the code. Writing procedural style and oo style code i think promotes declaring much more variables and getting data then performing logic (ok maybe not oo but more like in tell vs ask ). Funny someone else mentioned scala (which suffers under that it is a younger language which lacks strong conventions like java has), because i wanted to use akka streams as a example of readability on var vs explicit types. See the scala examples vs. Java examples: https://doc.akka.io/docs/akka/2.5.4/scala/stream/stream-flows-and-basics.html#defining-and-running-streams The funny thing here is that there is a lot of explicit typing in the scala example to illustrate the return types, but this is not done when writing it in production code (which shows there is a middle ground here). I am using akka streams as a example because i think it is a very good library which removes a lot of concerns (optional removes null pointer exceptions, streams makes it much harder to get out of memory). It cannot compare to goto because goto changes the order of execution and makes the logic more complex, just like exceptions adds a second flow of logic, goto added infinite extra flows of logic. Var just hides the type signature.
I actually like scala a lot, but I also hate the implicit typing. I will stay away from a scala discussion in the Java subreddit however ;)
Ok... But Netflix runs their entire data access layer on Node in containers... They recently moved off EE/app server... https://www.linux.com/news/event/nodejs/2017/3/slaying-monoliths-netflix-nodejs
So why does Netflix run their entire data access layer on Node microservices? What do you know that they don't? https://www.linux.com/news/event/nodejs/2017/3/slaying-monoliths-netflix-nodejs
That's far more convincing. Edit: I take that back. Nothing in that article tells me that Node is a better technology. It just tells me that they weren't using Java correctly and created a deployment nightmare for themselves. 
Have you worked with containers? They make everything else feel like a deployment nightmare in comparison. No app server is capable of doing what Kubernetes does. Ya, that article didn't have much substance, but the point was to address the fact that Netflix uses node for significant workloads (you implied they might be using it in "one department") I'm sure you can Google around for the reason they switched. Anyway... I'm pretty sure the entire Netflix engineering crew knows more than a random redditor. I have nothing to prove to you, I'm just trying to help you out.
it's all an illusion !?
ASP has had XCopy deployment for 20 years. You literally just drop the binaries and lose files into the correct location and... we'll that's it. You literally don't need to do anything else. Don't even bother restarting the web server, it will detect the new files and safely switch over. Java has had an equivalent for well over a decade. If your deployment process is more complicated than that for a development environment, chances are you are doing something seriously wrong and making things far more complicated than necessary. *** As for Netflix engineering crew, be careful about idolizing companies that have the money to buy their way out of problems by throwing more people and hardware at it. I've worked as a consultant for many large companies whose actual engineering is mind-bogglingly bad. For example, a few years ago I did some work for McKesson, the 5th most successful company in the US. If I recall correctly, something like 40% of US medical prescriptions go through their software. Software that was mostly cobbled together using PowerBASIC. Now I'm working for a major online retailer (I can't say the name, but yes, that one) helping them fix their tax software. The department I'm in hasn't figured out how to do branching and merging so all the work is done in master. I have far more respect for companies such as Reddit and StackOverflow. Why? Because they are running on shoestring budgets and manage to make things work in spite of it. 
great explanation. thanks!
P.S. What the fuck does Kubernetes have to do with your argument? In their introduction Kubernetes explicitly says that "Does not limit the types of applications supported. It does not dictate application frameworks (e.g., Wildfly), restrict the set of supported language runtimes (for example, Java, Python, Ruby)". 
Ughh... Java EE is about the app server. It's literally a spec that's married to it's deployment mechanism and massive runtime. If you're not using an EE app server, why are you using EE? The inverse is true... If you move to Kuernetes, why stick with EE? This isn't too say you can't use Java with containers, but you're much more likely to use something like Vert.x, not full EE. Hint: one of the reasons Vert.x is popular is it's not-blocking asynchronous behavior... Something that node also has out of the box.
Ya man, geez I guess all those engineers working on Kubernetes and docker swarm didn't RTFM on Java EE. Total waste of time, that. Node too. Basically anything you're not familiar with is trash, lol. Lol... "X-copy deployment" ? Do you think that's what containerization gets you? How does that even fit into this conversation. Please do some reading. Start with containers, and then Kubernetes.
I'm going to help you out here, I'll make it easier for you: - Containers are almost like VMs - they allow you to bundle your system-level dependencies (JDK, .NET, whatever) into your container, and keep them isolated from the host and other containers. - Combine this with a Container orchestration platform, like Docker Swarm or Kubernetes and you now have the power to dynamically spin up containers to accommodate for sudden load: Kubernetes detects one service is overloaded, so it spins up 10 more containers (they may or may not be on the same physical machine or VM) to deal with the demand. - The containers/microservices do not communicate with each other in any way other than their exposed APIs. They do not exist on the same app server. They do not pool resources. - If a container misbehaves, it is terminated, and another is deployed in it's place. This is containers 101. This has nothing to do with "x-copy" deployment (lol). It's about stateless, self-contained deployment artefacts NOT being associated with a monolithic web server. And again, if you're not using an EE app server, why would you use Java EE? 
I glad this eventually got some upvotes. It's kind of neat!
You are so obsessed with Kubernetes that you don't actually know what we're talking about. It's rather sad actually.
Tell us how you liked it if you try it out! :)
Yeah the JavaFX UI library (framework?) is what you need. For Scene Builder, make sure you use the one from Gluon (http://gluonhq.com/products/scene-builder/) and not the one from Oracle. If you prefer to hand code your UI, you can either do it with Java (using JavaFX objects) or FXML (probably similar to the XML you use for Android, no idea) 
[removed]
Yeah agreed
Annotation driven programming is the worst form of meta-programming available in a modern language. `Optional` probably shouldn't be retrofitted into existing code-bases where there's a mixture of nullability and `Optional`. Streams, however, are an unambiguously good addition to the language. I don't go ripping out existing code that works to replace with streams, but it is a very, very rare case that a more declarative stream isn't vastly more readable than a bunch of for-each loops -- or worse -- raw indexed iteration.
They already implemented Stream debugging in their latest release, 2017.3
There no reason to introduce `goto` in Java though, we have checked exceptions, try with resources, and complex forms of iteration. Every code feature has the potential to be misused. Also, comparing type inference to `goto` is weird. Type inference is a property of languages with more advanced type systems, not 1970s style programming. There's a reason type inference is used not only in Rust and Haskell but also in C++/C#. All code style is aesthetic, and you're certainly entitled to your preferences, but the tide is very clearly against you.
I feel like if you "really" need to be sure that the file gets deleted, you should rely on VM shutdown magic but just write better error handling / cleanup. It's as if implementing your own shutdown hooks with better logging / validation is particularly hard. 
Here's the poster child for `var`: try (InputStream is = urlConnection.getInputStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr)) { ... } versus try (var is = urlConnection.getInputStream(); var isr = new InputStreamReader(is); var br = new BufferedReader(isr)) { ... } 
Yes, but it looses a lot of the benefit when you have to wire into Spring's infrastructure rather than just handling it yourself. If this is the only "custom" part of your application, the productivity benefits from Spring are worth the increased friction by doing one thing non-standard, but as the surface area of integration points with Spring grows, the benefit to using it shrinks. Spring benefits from doing things "the Spring way" for sure.
&gt; The big downside to http 1.1 is that to do things in concurrently you have to have multiple connections for the amount of concurrency you are after. HTTP/1.1 pipelining anyone? Ok, I admit it, I didn't read the article and are probably missing an important piece of context why said statement might be true.
You can easily deploy a container with Java EE, in appserver form, jar form, library form or whatever. Thatâ€™s pretty much the entire point of a (Docker) container, you can put whatever you like in it.
&gt; And again, if you're not using an EE app server, why would you use Java EE? Because it has a lot of powerful and useful APIs to get stuff done? 
Now lets see some reactive streams debugging support :-D
I'm not comparing type inference to goto functionally.it's my example of another language feature that has huge potential to be misused. I can see the tide is against me, unfortunately. Because more than anything I'm sad that time was spent on this rather than anything else. I was talking to friend about this yesterday, and ultimately the conversation ended with a wishlist of what we'd have preferred to see over var. In my opinion, there are other things that would improve the language more than var does, such as the Elvis operator(which obviously has some disadvantages as well), or advanced switch statements like C# has. Everyone is entitled to their opinion for sure,but it makes me sad that I'll get to deal with what I feel will be unreadable code because people are lazy and overuse var.
&gt;I'm sad [Here's a picture/gif of a cat,](http://78.media.tumblr.com/tumblr_l7iy5lsiWO1qcn249o1_250.gif) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
Wasn't comparing goto and var functionally, it was just an example of another keyword with big potential for misuse. Misusing goto will however not only be detrimental to code readability obviously. I feel like younger languages often are better candidates for var. I actually like the way that kotlin uses var and val, with val being final and var being variable and inferred with optional syntax to clarify the type. But in this case the language was built with var and val in mind, so it has that additional functionality. In java, var does very little and it feels like an afterthought. Looking at the jdk docs, their reasoning is "because everyone else has it". Well, java is not everyone else, which is why I prefer it. It's no-nonsense, tells me what everything is and, though verbose, is one of the easiest languages to read when formatted well. 
**Sidebar** -&gt; **NO programming help, NO learning Java related questions!** **/r/learnjava** is for such questions and there the **sidebar** contains plenty learning resources.
&gt; It's literally a spec that's married to it's deployment mechanism Actually, itâ€™s not. &gt;and massive runtime You mean the 35 odd megabytes it takes to implement? 
Netflix is one of these unique companies who have special requirements that do not apply to 99.99999% of all other web sites/services out there. Youâ€™re also falling for the fallacy of idiolising a big company. Because Netflix is successful as a business you assume they have the brightest, most talented and completely rational engineering team, right? For all we know there may have been a single Node zealot who started a rewrite of the aging Netflix code without any consent, then presented it as the better solution and used the age old â€œitâ€™s already thereâ€ argument, combined with some political influence and nerd rage to get it into production. This honestly wouldnâ€™t be the first time I saw exactly that happening in â€œwell respected big companiesâ€. 
Totally, but what is JNDI, for instance, getting you in that context?
But a lot of those APIs aren't useful in an immutable container context.
You mean bean validation for validating incoming data is not useful? Or expression language for binding properties is not useful? Or CDI for managing your classes and allowing you to easily decorate or intercept your code is not useful? Or JAX-RS for processing and responding to HTTP requests is not useful? Or Java EE Security for securing your endpoints (eg using JWT) is not useful? Or JSON-B/P for parsing and generating JSON is not useful? It might be me, but those are imho exactly the tasks one does in a â€œimmutable container contextâ€. 
Look, this is a Java sub. I have nothing against you, or Java. I was trying to explain why some big companies used Node, I was here to help, not argue. If you'd rather just take the stance "lol Node sucks, Netflix and LinkedIn are full of idiots" that's fine, I'm not here to convince you.
Scroll up to my original post and you'll see exactly what trap you fell into. &gt; if you're not willing to discuss this nothing I say will change that That's the very thing I said at first: *"Imagine all the hours that have been wasted discussing nulls would have been spent on actually creating useful stuff."* Yet you tried to change my mind. The writing was there, on the wall. What were you trying to achieve? ;-) Sorry. I'll now downvote and move on.
In modern Java EE youâ€™d use CDI injection or programmatic lookup for most things you need. And what it gets you is that code can obtain the services and resources it needs.
Liberty is a totally different thing. IBM build it from the ground up and its essentially everything that WebSphere is not; * Install is download, unzip, run * Runs on every JDK (so also on a Mac) * Small, fast * Highly modular; you can remove or add whatever you donâ€™t need/need and minify the result * Open source Itâ€™s a myracial this is from the same company. 
I donâ€™t think I said here that Node sucks or that Netflix are idiots. I said that for all we know... meaning we donâ€™t know what the exact process was that led to Node being adopted. Thereâ€™s a lot of irrational stuff going on everywhere, and being successful as a business doesnâ€™t mean their tech decisions are by definition the best. And I know that Servlet is more general, but even so JAX-RS does respond to http requests and technically can even do so without relying on Servlet. But sure, letâ€™s make the list even longer ;) Or Servlet, for responding to http requests in general. The point being, thereâ€™s a lot (most even) in the Java EE APIs that has nothing to do with any deployment model and are by themselves highly useable APIs for application and services development.
Uhuh, so in a containerized (in the "docker" sense) microservice model, you can't use a full featured Java EE web server, because by definition, the container has to hold your whole runtime. I guess you could put all of Websphere in a container, but that seems nuts, the overhead for every container would be crazy. So that leaves you with a partially compliant servlet container, like Jetty, fine, but again, look how much of Java EE you just lost access to. This is the only point I'm trying to make. Containers shift favor slightly away from EE, because they aren't compatible with full app servers.
I'm a fan of Streams. I use them when I find it approriate and that's often, like transforming, filtering or aggregating data. But imo they should be kept "local" and not be passed around across class or even method boundaries. Getting a half-done Java 8 Stream from somewhere is intransparant and error prone. Also debugging them takes effort (I wish I could use IntelliJ at work).
In Java you can also use labelled break and continue, which come the closest to goto. Thanksfully I've never seen it used.
Here's an article by James Stratchan (inventor of Groovy and Apache contributor) discussing my point: https://blog.fabric8.io/the-decline-of-java-application-servers-when-using-docker-containers-edbe032e1f30
Who the hell are you to answer me like this!!!ðŸ–•ðŸ¾
&gt; competition is good. Amen! ;)
&gt;you can't use a full featured Java EE web server, because by definition, the container has to hold your whole runtime. Nonsense, you can easily do this. Whatâ€™s stopping you? &gt; I guess you could put all of Websphere in a container WebSphere??? The old beast that even IBM have phased out? Urhh, no, I would be putting a lightweight Liberty, Payara, WildFly or TomEE there. &gt;but that seems nuts, the overhead for every container would be crazy. What overhead? You mean the 1~2 second startup and the 30~40mb of memory usage? &gt;tons of app server features are now useless to you. But the entire Java EE API is available to you, which is what we were discussing, werenâ€™t we? &gt;If you can't understand this, you're either being intentionally obtuse, or you just don't have experience with containers/ microservices Sorry, but I think itâ€™s exactly the other way around. Youâ€™re dreaming up that Java EE can only function with an installed AS that is supposedly gigabytes in size, takes minutes to boot and can only be used as a target to deploy wars to, and demands that multiple totally independent apps have to run it? Thatâ€™s the picture youâ€™re trying to paint arenâ€™t you? And then assuming that all of that is totally a fact youâ€™re pulling out the â€œcanâ€™t you see that this is incompatible with microservices and containersâ€. But your error is in the assumption that all of those attributes you dream of are cast in stone. News flash; they arenâ€™t, and couldnâ€™t be further away from the truth. Full Java EE can perfectly well be used as a small runtime, starting in a second, having 30mb of RAM overhead, works with 1 app only and packaged together as a single bundle. Your view of Java EE is, at best, severely outdated. 
Feel free to read the article I linked. Merry Christmas.
The good news is we're getting pattern matching / data classes... eventually! I would much prefer these features as well. I have no problem with `var` and will use it extensively, but it ultimately isn't the kind of thing that makes a language good / useful, especially given that Java's type system is so under-powered anyway. `var` is certainly more useful in a language generic programming, but in Java I find myself having to translate generic types into raw types anyway to make sure weirdness with erasure doesn't happen that the compiler won't catch.
Yes, I think like many of these great new Java features we're going to get in the coming years, they're very well engineered, but still feel a little more "bolted on" than in other languages.
You may have missed that they have their own subreddit too?
Did you read the article yourself? I already read it when it was published. It doesnâ€™t invalidate anything I said, and in fact it says â€œJava Application Servers are mutating into becoming more like frameworksâ€, and indeed over the last ~2 years relative to the article they have done so even more. And it clearly says as well that you still need the Servlet engine, dependency injection, transactions, messaging etc. Which was exactly what I said. So the entire point is that in production running multiple apps, deploying a war, monitoring a deployment folder are not needed anymore or not as much, but the Java EE APIs still are. If anything, that article supports my point. Merry Christmas to you too.
Never used javaee but been using spring mostly spring boot for a while what do you mean by it being cleaber and not monolithic?
And I never said you *can't* containerize Java EE. But when you lose hot deployment in favor of stateless containers, it gives you reason to consider other frameworks, since as you admit, that's all it reduces EE to; a framework. Maybe you want a framework that is event driven and non-blocking... In that case you'd choose Node ;)
The nature of all bachelor's degrees is that it's not efficient, from a pedagogical perspective, to spend a great deal of time on particular implementations of the skills in question. Partially because the fundamentals must comprise most of the curriculum, partially because not enough time is left to cover ever possible implementation, and thus there's no guarantee (indeed, it's arguably a *bad* thing) to assume that students will go on to work with one particular implementation as opposed to others. (This applies to all non-CS degrees, too - specialization is almost always deferred to postgraduate degrees.) For example, most college grads we interview at my current job worked with Android SDK for their senior projects. But we can still consider these graduates, because they weren't educated as Android developers but as *Java* developers who happened to do a project or two in Android. Their ability to learn that framework gives us confidence that they'll be able to learn others. Obviously it's nice if we find grads who have worked with Spring, but given the constraints of bachelor's degrees, it's not a reasonable expectation to have.
Cringe: System.gc(); Thread.sleep(10000); // to allow GC do its job 
Check out /r/Java on Reddit. It's pretty okay 
Listen to this guy. /r/java is ok, but it pails in comparison to /r/Java - it's a real shame we're so fragmented 
You can always consider other frameworks, but Java EE is a great one, very complete, high performance, backed by several companies and open source organisations, and it works perfectly well with containers. Iâ€™m a long time Java EE user and actually have never really used the deployment options you think are such a USP for Java EE. We basically did container deployments and micro services before the masses discovered them ;)
Link plz?
I miss Java Posse.
adam bien does a monthly video covering all things java. https://www.youtube.com/channel/UCksTNgiRyQGwi2ODBie8HdA 
vJUG
https://dzone.com/java
For me the answer is just one thing, XML. XML configuration is cancer. It's slow for computers to parse and extremely hard for humans to write correctly. It's slow and painful to learn and error prone and unreadable. It's baroque and excessively verbose. It's not a programming language, it's magic that you have to read (possibly out of date) documentation to understand. It basically combines the worst of binary formats (unreadable by humans) and text formats (slow for computers to parse) and has drawbacks that are the sum of the drawbacks of the formats it replaces. Its stupid is even greater than the sum of the stupids of the things it replaces. Somehow most enterprise Java stuff got tied in with XML, which is a shame because Java's a pretty good language. Spring boot is on the right track by eliminating XML based configuration and going (mostly) pure Java configuration. A new grad out of school might know Java but she won't know how to handle all that XML configuration without lots of training. 
You have two options, you can use Swing or JavaFX. JavaFX is the replacement for Swing so you should probably use JavaFX for a new project. For JavaFX you can use SceneBuilder which generates FXML. You donâ€™t have to use FXML but it is the recommended approach. SceneBuilder is part of OpenJDK but Oracle doesnâ€™t release binaries for it. Gluon provides binaries for it which someone already provided you a link to.
&gt; extremely hard for humans to write correctly. What? This statement is utterly bizarre. Which part of XML is hard to write? XML is many times easier to write than JSON, especially once you go beyond one level of nesting. This is all moot though because Java EE 6+ doesnâ€™t require XML configuration. 
&gt; Which part of XML is hard to write? My experience has been very strongly that human generated XML is a consistent source of errors. If you've had a better experience than that more power to you.
Nah
Race conditions arenâ€™t that rare.
Generic type erasure is a bit irritating.... 
Slightly :)
Oracle
Generic types for primitives.
All objects are heap allocated. C# has structs which can be stack allocated, which is nice for performance critical code and game development.
value types are coming my friend..somewhat similar to structs.. but yeah i agree.
primitives, especially null, are not objects.
Just use the boxed type? 
return new T(); // nope
Actually no. JIT does escape analysis, and stuff is often automatically allocated on the stack if appropriate.
Coming soon!
That might be changing with the introduction of value types.
Multi-return / out params.
Thatâ€™s pretty neat. I still wish it could be explicit, instead of hoping the JVM will optimize.
generics don't provide a nice way to say that a method returns whatever the object is. you can do it with an addition type param, but then that has to cascade down to all subclasses. there should also be a way to specify `this` as the return type (and to chain `void` methods) also, the inlining problem 
The heart 
I hate it when I get there. What I usually do is force the T to implement a newInstance() method. T extends YourInterface can then be used to create new classes. Usually looks slightly awkward but does a good job getting rid of a ton of boilerplate.
What makes allocating in the stack better? 
You can do that with interface Foo&lt;T extends Foo&lt;T&gt;&gt; { T copy(); // T is the self-type } It's a pain in the ass, but it works
So you have to pass in an instance of T in order to create new instances of it? I suppose that's a bit like `Collection#toArray(T[])` called with a zero-sized array.
Even better than that, when possible objects aren't even allocated on the stack - their fields are sort of turned into local variables which can exist just as registers.
Cache locality, and avoiding indirection. If you access several objects on the heap, the CPU has to load all of them individually. If you access several objects on the stack, they are all adjacent, so the CPU can load them all together. This is also the case for arrays. In Java, an array of objects is always an array of pointers. In C# or any lower level language, you can have a contiguous array of structs.
It's not a language you can just pick up easily and be using productively in a few hours.
What? When? 
[JEP 218](http://openjdk.java.net/jeps/218) 
Thanks for the link. This is great, but there's still a lot that needs to happen for this to make it in. Would be wonderful though!
Verbosity, when writing Java, it takes you a lot of code lines to do a simple thing (like C++). Maybe itâ€™s just personal but itâ€™s one of my problems with Java.
/r/IntelliJIDEA/
There's no easy way to create a fully initialized immutable object; the only way is to have a giant constructor.
Using `new T()` in a generic class or method would make it gratuitously inflexible. What if T's constructor requires parameters? You're forced to make an awkward subclass and use that in place of T. What if T is an abstract class or interface, and the implementation you want comes from a factory function? Now you're just screwed. The properly generic way to do what you want is to inject a `Supplier&lt;T&gt;`.
* You can't import the 2 classes with the same name from different packages. Not a big deal for a lot of people, but I've had to provide the fully classified class path to both the classes and that's not pretty. * No concept of "var", which can lead to reduction of a lot of unnecessary verbosity in code. (I know its coming in Java10, but I had hoped that it'd come sooner. I use Java8 at work)
you could use the builder pattern instead of the giant constructor.
&gt; but then that has to cascade down to all subclasses 
The developer usually. 
Concurrency
But now you have null problems.
Thankfully it's getting better with time. Lambdas especially reduced a lot of boilerplate. I do look forward to the day that we get properties. 10 brings local type inference.
You only need to use the full qualified name on one class; you can import the other.
It's legacy (the initial bad design decisions) which it cannot get rid of due to backwards compatibility reasons. 
The broken type hierarchy
Use optionals for the boxed type. Not annoying at all. 
Well, first choice is obviously no bad design. But now that we have some bad design, I would prefer keeping it rather than losing parts of the ecosystem that may depend of it.
You haven't removed nulls, you've just moved them.
Thanks...I'll check it out.
Ok mate.
All I really want for Christmas is to ask null if it is null
Is there more to it than just Oracle being terrible? Iâ€™m not too familiar with all the hate for them.
Just imagine Redhat bought Sun. 
Optional.ofNullable(thing) Is always your friend. Can I add lack of language support for coercion of null optional to empty optional to me gripes?
But it will take mush less time reading the code. 
How about Google, that was more realistic.
What? 
Personally, I find it really hard to read it because there is a lot of code and it's hard to find what matters. But it's not only about how the language is made, it's also how people use it. I feel like people get used to use long names for variables and functions, use lot of steps to do something (just look how many objects you need to call to write a simple file), etc... And I think we can never change it in Java, or only partially. It's how the language and it's ecosystem is, but it's also why alternatives such as Kotlin emerge (which is always a good thing).
Google do give fuck about java but not other Sun projects and not sure it will treated as first citizen, but Redhat will. The only problem that Redhat didn't has the money. 
_Its_ legacy. I was really confused first
Yes but that has its own problems such as duplicating every field and inheritance.
The barrier to entry for just playing with JavaEE/Spring is much higher - you need to fuss around with an application server (many of which are proprietary) and cumbersome configurations (Maven/Gradle etc.). Compare this to downloading a ZIP file, writing a simple JS+HTML page and opening it in a browser - that's something any person with minimal tech skills can do in a few minutes. Don't get me wrong - the ecosystem and infrastructure is great (indispensable, even) for enterprise settings, but they are simply a hurdle when you just want to play around with something in between uni courses... 
What are your thoughts on the recent move to open source java and the desire to keep parity with the open JVM(seems like they're copying .NET? Also what about the decision to have a 6 month release cycle without hard deadlines for features? 
Just give me native tuples
Canâ€™t believe Iâ€™m commenting on Christmas about this but literally most of the comments on this thread are solved problems in Kotlin. It has 100% interop... or you can continue to justify NPEs in production Â¯\_(ãƒ„)_/Â¯ 
Lack of tuples and pattern matching on tuples. Lack of tail call optimization. Lack of list comprehension.
That's not a result of type erasure, that's because you aren't guaranteed that T has a no-arg public constructor. Constructors are a little weird in that you can't specify that they'll exist using an interface (though you could simulate it with an interface with a build method.)
I do that but it's annoying
Huh? I don't know what you mean by that - there's no cascading here. class Bar implements Foo { Bar copy() { return this; } } 
Lack of properties (auto getter/setter(?)). Lombok has useful annotations for that but it feels a bit hacky and doesn't always interacts good with other tools. 
Lack of tail recursion. I'd also love immutability by default.
You haven't even moved them. The optional itself can be null.
That was the point I was trying to make. Admittedly, badly.
A relic of when people thought everything *is* a type hierarchy.
You can often get the same result as comprehensions rather easily using streams.
Immutability by default. Non-null by default.
Only if you have good JIT. And you have to pray it will do it.
The problem with streams is the difference between IntStream, LongStream and Stream and you have to convert back and forth. For example, in Haskell, you write: Prelude&gt; [3,6..30] [3,6,9,12,15,18,21,24,27,30] While in Scala you write scala&gt; (3 to 30 by 3).toList res3: List[Int] = List(3, 6, 9, 12, 15, 18, 21, 24, 27, 30) I believe that in Java you have to use [vavr.io](http://www.vavr.io/) to get something similar.
Type erasure. I would like a switch in my JVM to disable it. Or better, a switch to enable it for legacy applications that insist on doing shitty things.
Java is explicit about typing. I'm not sure how it would look if it was less explicit about numeric types. I can't imagine it. Anyway, IntStream.iterate(3, n -&gt; n+3).takeWhile(n -&gt; n &lt;= 30) isn't so bad, although it requires Java 9 for `takeWhile` (otherwise you can use `limit`, or `map` a `range`).
I would like operator overloading. Have you ever written substantial code with `BigInteger`? Dreadful.
yupp, i agree with you !!
Most things that Scala fixes: * Everything is an expression, not a statement * Type Inference * Pattern Matching * Case classes * Value Classes * Unified type hierarchy * Tuples * Interpolated and multi-line strings * Good support for functional programming * Less verbosity * Easily implement immutable data structures * Some support for tail-call optimization * Implicit Parameters (Controversial, but I think if used correctly, they can help a lot) * ^ This gives you extension function * ^ Also type classes (A really great alternative to making everything an OOP hierarchy) * ^ Also the ability to do type-level programming * And last but not least, semicolons are not necessary
Actually, i think kotlin provides better fixes, Kotlin = java - ( bad things about java) - (oracle) + (google) And plus kotlin has a good syntax style, more like C++ !!
I agree that kotlin is a great language. What things do you think Kotlin does better than Scala?
Honestly speaking, i am not deep into scala, and plus i haven't heard about it much, maybe as i am new to this field, but the thing that kotlin is made by google makes it my first choice, sorry if my comment lacks research, but it's my personal opinion.
Kotlin is made by Google? &gt; Its primary development is from a team of JetBrains programmers based in Saint Petersburg, Russia.[2] https://en.wikipedia.org/wiki/Kotlin_(programming_language)
**Kotlin (programming language)** Kotlin is a statically-typed programming language that runs on the Java virtual machine and also can be compiled to JavaScript source code or use the LLVM compiler infrastructure. Its primary development is from a team of JetBrains programmers based in Saint Petersburg, Russia. While the syntax is not compatible with Java, Kotlin is designed to interoperate with Java code and is reliant on Java code from the existing Java Class Library, such as the collections framework. As of Android Studio 3.0 (Beta version) Kotlin is a fully supported programming language on Android and lets the user choose between targeting Java 6- or Java 8-compatible bytecode. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Kotlin doesn't require you to type out lambda arguments, if you leave lambda paramas unassigned, then you can just refer to the parameter with ```it``` keyword. AFAIK scala does not allow that. But on the other hand Scala has full-blown pattern matching, while you can only do simple matching with ```when``` statement in Kotlin.
if you read the post, i did mention it lacks research ðŸ˜…ðŸ˜‚
Agreed. My IDE auto-completes and validates XML on the fly. Meanwhile, I've spent hours staring at js and json files hunting for some missing comma or invalid quote mark. XML got a bad name because of Soap and similar web services which were never really meant to be read by humans, but instead used to send messages between systems without having to use opaque binary protocols. Too many developers used the tools correctly to generate these files, but then got lazy and started modifying them by hand. Eventually they had a mix of generated XML and human XML which worked poorly for both the devs and the systems.
Scala does allow this actually. You simply use the underscore character instead of 'it'
Yes, I think writing Java is not a huge problem, because and IDE can type all that boilerplate for you. But reading the code and pick out what actually matters is often slow and frustrating. So easy to miss something and misunderstand what something is actually doing. Part of it is cultural, with the VeryLongNamesOnMostThings and splitting up logic over many tiny methods and hidden behind layers of (YAGNI) abstractions. I am optimistic and think it might not have to always be like that though.
It can be a huge speed improvement. Instead of finding some free space on the heap to store something dynamically you essentially add an integer to the stack pointer, then subtract it again when the method returns (and that pointer is being added and subtracted to anyway, so allocating space for that variable is free). And no risk of making the life more complicated for the garbage collector.
I entered the job market at Java 7/8, we mostly wrote Java 8(I have just a few years of experience). When I complained about boilerplate in Java, all the senior devs went quiet and stared me down. Now I don't complain no' mo'
Kid, you don't know how good you got it. But, yeah, there's more work to be done.
I'm fluent in Kotlin. I can write a Java class and hit the "convert to kotlin" shortcut in IntelliJ
A very poor article if you write about immutability, but fail allready with the first example ðŸ˜‰ (Hint: a getter that exposes a *mutable* object breaks the immutability!) I would suggest you to read the classic book "java concurrency in action" - it explains the concept better and in detail, what pitfalls awaits you. 
Kotlin arrived late to the party. We already had Groovy, Clojure and Scala.
Chaining void methods imo breaks an otherwise clean and precise contract. To return this from a generic method and still have access to your subclass, you can do: public &lt;T extends...&gt; T build(p) { /*...*/ return (T) this; } Are there true benefits to inlining that can't be otherwise achieved?
If custom arithmetic classes aren't your thing and seem to niche, think about comparison operators. Having to read and write equals and compareTo is much less intuitive than the common comparisons. 
It was almost that when I first started using it in version 1.1. Give it a few long evenings and you could know all of the language and standard library and have time over to read up on the most important parts of how the virtual machine was designed. So much simpler than something like C++. This is not so true now, no.
You can use Clojure on top of the JVM (and together with classes written in Java with pretty seamless interop) for some immutable goodness. 
That "supplier" is going to have exactly the same problems. Indirection is not abstraction. Moreover, the main reason we want new T is to build DTO handling libraries such as ORMs and serializers. Stuff that naturally expects a parameterless constructor.
Sure you can. In C# you can specify a type constraint that demands a constructor. But that alone can't work so long as there is type erasure.
Could be worse. F# Option&lt;T&gt; allows you to have None (a.k.a. null) and Some(null). 
They have already put a huge amount of work into it and it's come on a long way. Look up project Valhalla for more info.
Doesn't have to be that way.
That's not guaranteed. Lots of stuff can break it and there isn't a good way to determine whether or not something is going to be stack allocated.
What would that look like?
There is a proposal (I think by Dan Smith if you want to google) to add declaration site variance for type parameters, and if we had that then some sort of automagical "This" type which is covariant for subtypes could slot into the type system with no modification or special treatment, so maybe they'll explore it then.
Spring! (runs away quick before the flames start!)
&gt; Part of it is cultural, with the VeryLongNamesOnMostThings and splitting up logic over many tiny methods and hidden behind layers of (YAGNI) abstractions. So much this. Very long names are typically not helpful, and combined with all those endless layers of pointless abstraction it can make code very hard to disentangle. But this is a cultural problem, and not something to do with Java itself.
[Data classes](http://cr.openjdk.java.net/~briangoetz/amber/datum.html) might interest you.
All those issues that you mention would theoretically get caught by the compiler, no? At this point, though, you'd be heading into C++-style templates anyway.
True, but Iâ€™m not qualified enough to talk about them.
1. How about a proper Option and Return type, so we can finally stop the nonsense of checked exceptions? 2. Immutable classes and persistent immutable collections 3. Final as default. 
ONLY if it's a static set of math operators on classes extending Number. Arbitrary use of operator overloading is a terrible idea. I would just like Java to do what they did with String and +.
I've got Null Pointer Exception problems, but null ain't one.
&gt; For me the answer is just one thing, XML. http://arjan-tijms.omnifaces.org/2011/08/minimal-3-tier-java-ee-app-without-any.html Enough said...
[:)](https://media.giphy.com/media/Y03IFRFRSjjQQ/giphy.gif)
Of course, it's just a pain in the ass especially when converting between different data structures.
I know, I'm stoked.
Scala does it by having a constructor where parameters are declared as `val`. They then become immutable fields on the class. So a class carrying three attributes is: ``` class Whatever(val foo: String, val bar: Int, val baz: Something) ``` That's the complete declaration. Create with `new Whatever("hey", 22, reference)`.
Yes, but you get so much annoying garbage and weirdness with those fixes. I've been writing Scala for two years now, and it's still a relief to come back to Java. Yes, I have to type more, but at least the code always says exactly what it does without there possibly being all kinds of weird invisible magic underneath.
Same here. I bought David Flanagan's book in '96, read through it in an evening or two, then started writing programs. There wasn't really much to it.
Agreed. `equals` needs to be an operator. Parenthesizing is also pretty visually cumbersome for equality.
Google already owns too many things. If it also owned the companies behind the main programming languages, that would be even more dangerous for us.
Eh. Ya it used to be worse, but itâ€™s still worse than Ruby or Python. I generally think the advantages of Java still outweigh the boilerplate but thereâ€™s definitely more than some other languages. 
How about making Kotlin Java 2.0? ðŸ˜‰
Google would have been a million times better than Oracle and I have no idea what you mean with dangerous compared to the shitshow we have had with oracle
JEP 218 is bad, they're trying to wreck Java by taking one of pillars undergirding Java's dominance and strength and transforming it into python's duck-typing glacially-slow scheme. Java is some 3 orders of magnitude faster than Python because of these schemes, and the fuckers want to destroy that gap by making java loops as glacial (8000% overhead) as Python. If you want totally unconstrained variables and glacially slow processing times, just use R or Python. JEP 218 is refuctoring damage to Java. These fools need to go apply their fuckup fixes to a different language, like Chef or R. If you want to smash things and wreck things, fine, just do it in the landfill.
Verbosity and entreprisy golberg machines.
While single-firm monopolies are rare, except for those subject to public regulation, it is useful to examine the monopolistâ€™s market conduct and performance to establish a standard at the pole opposite that of perfect competition. As the sole supplier of a distinctive product, the monopolistic company can set any selling price, provided it accepts the sales that correspond to that price. Market demand is generally inversely related to price, and the monopolist presumably will set a price that produces the greatest profits, given the relationship of production costs to output. By restricting output, the firm can raise its selling price significantlyâ€”an option not open to sellers in atomistic industries. The monopolist will generally charge prices well in excess of production costs and reap profits well above a normal interest return on investment. His output will be substantially smaller, and his price higher, than if he had to meet established market prices as in perfect competition. The monopolist may or may not produce at minimal average cost, depending on his cost-output relationship; if he does not, there are no market pressures to force him to do so. If the monopolist is subject to no threat of entry by a competitor, he will presumably set a selling price that maximizes profits for the industry he monopolizes. If he faces only impeded entry, he may elect to charge a price sufficiently low to discourage entry but above a competitive priceâ€”if this will maximize his long-run profits. https://www.britannica.com/topic/monopoly-economics#ref34158
Getting you to waste your time and fill your head with a dead end was the goal, it worked. We got dummies insisting on new languages left and right. It's the tower of babel up in here. The front cost of learning a new language is measured in years, we're not talking about a newbie level casual familiarity. I'm talking enough mastery to be able to make world class useful products with them. After 5 years of work, the civilization is just now getting to basic proficiency in Python, and now they want to change it up to coffeescript, chef, R, Erlang, Javascript, and tens of others. Suggesting a new language needs to be looked on as defection. You might as well be running into a damn middle school and yelling out that everyone needs to be speaking Mandarin now. Then after a few months yell out that people need to be speaking in french. It grinds productivity to a fucking halt, and what's worse is that the people responsible for managing the system haven't a clue about the effort required to get to a productive place in a language. Before I can finish making my point, we've got more people yelling out about how we need MongoDB, Flask, RShiny, Perl, NoSQL AJAX SASS, Delphi and Pascal. And before I've finished my sentence we've got people who want to change out everything to VB.NET, adobe flash, AIR, Lua and Ruby. The people doing this on purpose need to be punched. 
I'm not sure what you mean. Why can't you use tail recursion in Java?
Tail recursion is not optimized, so you can incur into stack overflow of you go deep enough and there is a lot unnecessarily parameters passing (AFAIK)
This fails if you do not understand the difference between an entity and a value object. Creating a new cat with the same name is not the same cat (if you change the owner); this is the same for objects. Also the example with the builder is totally wrong. If you require a field, you need to construct them in the constructor of the builder. Whats the point of late validation if you have a compiler.
Tail recursion doesn't exist because the compiler tech/theory didn't exist at the time for a jit vm with tail recursion. I am not sure if it's doable now though.
What about vectors, matrices, complex numbers, quaternions, Clifford numbers, etc., all of which have more than one component/can't implement number, and all of which are (mathematically/conventionally speaking) more justified in using + than string?
Should have written more than two there, the comment was more related to the code being shabby because of all the fully classified paths around in there and if you needed to instantiate that class, then you'd have it twice, and that itself would take atleast 4 rows. We were using a library for a third party integration and each of their response classes were named the same but under different packages. (and each one of the classes was 6-7 levels deep) Had to write a wrapper over that so that we don't pollute our code with all those full class names.. there I really missed the feature that we have in C#.
Of course Java supports tail recursion, it just doesnâ€™t optimise it.
Tbh ive started looking into go and it seems like the best of all worlds if you use it right
I will never miss an opportunity to share this: https://youtu.be/-zRN7XLCRhc Edit: Whoops it doesn't copy the starting time on mobile. It starts around 33:20
That doesnâ€™t sound right. Can you elaborate?
Fuck I hate dzone.com. Now it requires me to login and I can't bypass that. What a shitty website. 
Off heap podcast. Infoq podcast www.infoq.com https://www.codewars.com/
I assume you have benchmarks and experiments to back this up and are not just making shit up as you go...?
&gt;&gt; All those issues that you mention would theoretically get caught by the compiler, no? I think he was addressing that it makes the code harder to understand and maintain. C++ templates, I recall working on code with the STL in the early 2000's, I bet it's even more complicated now. 
In addition to what /u/Drisku11 said about complex numbers etc, I think the clarity concerns with operator abuse are greatly exaggerated. As much as people complain about stream operators in C++ or the pipe operator being used in some C# or C++ libs to denote a kind of method chaining, I think these uses are totally legitimate. I don't get the calls for "purity" of operators. They don't even mean the same thing in programming as they do in standard mathematical notation half the time, such as assignment with `=`, and even in math, operators are overloaded and invented.
It also makes stack traces a bit more awkward. 
Maybe you are a null.
Google abandoned the excellent Eclipse framework for Android, abandoned GWT for projects targeting JS, started Angular 1 which kind of made sense, worked a lot like jQuery Mobile then abandoned it and rewrote it to be like a knockoff (no pun intended) of ReactJS. For a company full of PHD's and supposedly bright people; they seem to have the attention span of 9 year children. Business likes, needs and deserves far more stability than that. 
If you need native, use [AbstractMap.SimpleEntry](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.SimpleEntry.html), but yea, I'm with you on this one. I'd like an option for native tuples without doing weird stuff. Conceptually though, I think the original idea was for you to make your own JavaBean that had everything you needed in it. Hence, you don't need 2 return values! */em grumbles*
You have no idea what you're talking about. Do you even know what duck-typing is? It's unrelated to value types. Value types are just stack-allocatable types with pass-by-value semantics that can be flattened into inline memory for fields and arrays. In other words they can be used like structs. They *improve* performance by improving memory locality and reducing pointer indirection.
It would be great to see Tuple introduced formally. Python and even C# has Tuple. It would be super great to see something like C#'s await formally in the Java language. And I really hope they stay away from C#'s Linq concept, can't stand that.
Oracle understands business. Microsoft understands business but would have killed off Java I'm sure. I'm not sure what Google understands, they are the best search engine for sure and they have remained stable at that. Chrome is a great browser too so that's two good things they do. Everything else seems to be science projects, they get bored and cancel them or completely replace them with something not even compatible.
Not saying itâ€™s worse or better, but unless you just use value (think itâ€™s called a record type in .NET land) types you canâ€™t get around that without disallowing null throughout the language. 
*mumbles something about webscale*
Four different ways to model date/time!
Took more than a few hours to figure out how to run from Java from the command line, let alone do something useful. Every time I take up Java again it take a while to relearn how to deal with jars/classes again. Don't know how many hours I've wasted fighting class path issues. Had to do some Oracle DB Administration work, needed to write some oracle scripts to change tablespace permissions, had never written scripts in Oracle before; whole process from first introduction to language to running custom script in production and completing the task, about an hour....
This is return covariance. You're also able to return Bar from Baz.copy and you're forced to continue re-implenting "return this"
I'm interested in situations where it's a benefit to avoid allocation. Usually something like robovm etc. In this case the JVM is good enough that you don't care about the allocation, but off the JVM the language feature is more relevant.
Yeah, many languages have import aliases. Thankfully in my experience clashes have been rare. That library sounds awful to work with. You have my sympathy.
You still have no fucking idea what you're talking about. There will be no overhead for primitives. You're pulling all of this out of your arse. And you've still not explained how the fuck you think duck-typing is involved lol. What you find infuriating is entirely in your own head. It sure as shit isn't going to break legacy code.
Oracle won't do it, community has to. 
But you're not actually using the self-type there, right? You're just implementing the raw interface type and covariantly refining the erased return type of `copy()`. That will get you an unchecked warning if you try to pass a `Bar` to a method that expects a `T extends Foo&lt;T&gt;`. class Qux implements Foo { @Override public Foo copy() { return this; } }
Lombok or Intellij builder generator is your friend in this case. Overall default parameter values coupled with named parameters would solve this problem.
1\. The redundancy of having to generate getters and setters over and over again. You should just have annotation - @prop, @propgetonly, @propsetonly, something like that. 2\. People making a fairly simple language into a frankenstein monster by adding trendy b.s. in. "immutable by default" is a monstrosity the moment your data extends past just one class. Running into streams in code is like reading a book in english and suddenly parts are in german. 3\. Enterprisy b.s. churn. Every few years someone invents a new framework that does the same things we do now just in a different way with different syntax. A relational db is still king, despite attempt after attempt to create new ways to store data. Spring brings with it a lot of monsterous "we're doing the same thing as before just in a new monsterous way" kind of stuff. 
&gt;Sure you can. In C# you can specify a type constraint that demands a constructor. We are talking about Java here, not C#. You can't specify constructors in a Java interface. &gt; &gt;But that alone can't work so long as there is type erasure. What does type erasure have to do with it.
This doesnâ€™t sound right. In fact, generics over primitives will let you use primitives in more places, which (by your own admission) will make Java faster. Imagine an `ArrayList&lt;Integer&gt;`. That would store its values in an `Integer[]`, right? And thatâ€™s really an array of pointers. So, if we want to loop over the elements and sum them up, weâ€™d have to dereference every `Integer` pointer (each of which may incur a cache miss, forcing us to wait while the value is retrieved from main memory) and call a method to extract the primitive value. If we could write `ArrayList&lt;int&gt;` instead, then weâ€™d have an `int[]` under the hood. Now we donâ€™t have to dereference or call a method. Weâ€™re also more likely to find our values in the cpu cache. Those are all performance wins. You should really read the JEP and/or listen to some talks on on the subject. Brian Goetz has given a few of them and theyâ€™re really interesting. I bet theyâ€™ll change your mind. 
&gt;1\. Take a look at [data classes](http://cr.openjdk.java.net/~briangoetz/amber/datum.html).
Goetz talked about introducing tuples, but thought they would be generally less useful than value types.
Goetz said they might look into operator overloading after implementing value types. It would likely be restricted to arithmetic types, though, if they decided to pursue it.
C# shows how the syntax could be done. As for type erasure, how can you call a constructor if you don't know which one to call?
Lombok [https://projectlombok.org/features/all] generates getters and setters for you. Cuts down on a lot of the boilerplate code.
Record is F# only (immutable data structure); hasn't quite made it to the other languages yet. Value Type or struct is what you're thinking of. They're trying to shove in non-nullable reference types as compiler warnings. If it works, Java could go the same route. But that's a big if. 
Everything. It's dying 
You could make the argument that more classes in Java could use the math operators, but allowing operator overloading anywhere could turn into an anti-pattern real quick. I'd call it the same situation as GOTO: a good idea in *some* places, but generally discouraged because it has the ability to cause so much unreadable code to be written.
Thats a feature of the platform, not the language.
Can't mix primitives and generics.
Any reason you don't just use `Supplier&lt;T&gt;`?
But, how to live without generics?
Neato, til.
 &gt;As for type erasure, how can you call a constructor if you don't know which one to call? This isn't because of generic type erasure. Java didn't have constructors in interfaces before generics were introduced in 5.0, either. The reason there aren't constructors in interfaces is that you always need to specify which concrete class you are constructing in order to know which constructor to call, so interface constructors is a nonsense concept - which has nothing to do with erasure.
I really don't care that they are "copying .NET". I am just glad it is happening.
Reliability and scalability. There is a saying that goes something like once a shop grows up it becomes a java shop. I believe Twitter is one company that switch to java becuase of scalability issues. 
Have you tried kotlin?
I highly recommend the helsinki university java and ooc mooc: http://mooc.fi/courses/2013/programming-part-1/
&gt; Supplier Ha. I'm embarrassed to admit this is the first I hear of it. That's what happens when you've been using a language since 1998, you get stuck in your old patterns and way of doing things. Nice to learn about that. Thanks!
&gt; Java didn't have constructors in interfaces Java still doesn't have constructors in interfaces. That wouldn't even make any sense other than as a generic type constraint in a non-erasure scenario. 
&gt; but would have killed off Java I'm sure And probably allowed C# to suffocate. Without competition, Microsoft allows their products to turn into crap.
That's been my long-held belief and why I mostly switched to .NET. Sadly, .NET is going the same direction.
I would rather see VB's syntax for chaining methods. In Java it would look like... with (foo) { .doX(); .setY(y); z = .getZ(); } 
I only want to see tail recursion if it's explicit. Maybe `tail return foo(x)`. Without a compiler check, it is easy to break tail recursion without realizing it. Especially if it isn't clear from the source code that its necessary for the function to work. 
That last bit bothers me. Yes, numeric classes should be able to override the addition operator. But its a mistake to allow the addition operator to be used for concatenation. I've seen countless minor bugs caused by evil type coercion. VB almost does this right by using + for op_add and &amp; for op_concat. Sadly, they also allow + for op_concat for legacy reasons.
[JEP 218](http://openjdk.java.net/jeps/218)
It's not any one specific feature; it's the entire thing, taken as a whole. Great IDE's, free cost, absolutely massive community and third party libraries, and yes, it DOES run everywhere on every platform, without modification. Java is still king when it comes to that specific feature, sorry. It is well supported by very large and powerful corporations. As a business, I can be assured the code I write won't be disappearing due to lack of support any time soon. (Can't say the same for rust, go, etc) It has a very large and capable base library which you can use for pretty much anything. Networking, GUI's (swing), database (jdbc) etc, there is a ton of well written and pretty much bug free code. Though I would say they could have done a better job of offering a simpler API in many cases. It's possible to do complex things (say, in swing), but they could have tried harder to make the normal things a little easier. I also happen to like the language itself as well. I don't mind the wordiness, the IDE takes care of that, and then for developers READing the code, it's all very clear with no surprises. The compiler handles whole classes of issues that show up in other languages (scripting languages). I have yet, to ever write a single junit test. I know it's out there, and I know what it's there for, but I've never used it and I've been programming professionally since, well, almost 2 decades. To me that's a great strength. I can come back to code I wrote 10, 15 years ago, and immediately read it and understand it, with no surprises. I can maintain this code. Be surprised how many languages fail this very simple test. When you make it easy/possible to do complicated and tricky code (c/c++), don't be surprised when new developers come on board and don't have a clue what the heck is going on. The "wordiness" of java is a benefit, in my opinion.
No multi line strings
Plot twist! 
Especially with streams, tuples are often needed for only one statement, creating a class it's really overkill
High memory consumption on docker. 500 Mb of ram for a simple Spring Boot app with a web server. Crazy.
Official doc is pretty good imo. I always end up going back to it when I get stuck with a new concept/type.
This is the big reason TCO isn't supported in Python. Given application maintenance lives and dies by stack traces, it's not a terrible argument. 
&gt;&gt; Java didn't have constructors in interfaces &gt; &gt;Java still doesn't have constructors in interfaces. Did I ever say it has constructors in interfaces now? You cut off the rest of my sentence when quoting there (most notably that key "either" word), nice one. My point is that the restriction didn't come about because of generic type erasure, the restriction existed before generic type erasure.
The language is mostly surprise free and the right mix of complexity and simplicity. It favors readability, backwards compatability and explicitly expressing something rather than implicit "black magic" running in the background.
The Cloneable interface is just dreadful. The Date class is so broken it's not even funny. Finalizers are also pretty much broken. Autoboxing was probably a mistake. I'd love a JavaX release where you have to optin to enable the broken parts of Java.
The way she goes. Never mind them. I've been a Java head for the longest time and people come at you with all kinds of crap. I mean, I've worked with a ton of languages. The phps and nodes of the world. Then when I say I'm sticking to JAVA no matter what, they tell me I only love it because I learned it at the university. That's true but I spent so much time during that semester learning it that I just decided to take it with me. Comparing it to shit like php just disgusts me. I'm not enjoying any language with dollar sign syntax. Comparing Java to the 8 odd languages I've been able to work with to date (still fairly young), it's by Ã€ HUGE MARGIN the best one. 
And the ecosystem is unbeatable - there are libraries and tools for basically everything you could need.
Lombok is pretty great, I include it in most projects these days. That being said the library still exists partially to make up for shortcomings in the language itself.
OK how about "implements MathOperators" instead? Create the JEP.
Exactly. The problem with arbitrary operators is that it would make code unreadable. See SmallTalk.
So am I but I am a fairly recent grad that doesn't keep up with everything. I went to java one and heard this news about java and I thought it was a really cool innovative idea. However a few days ago I saw a post about .NET which mentioned that they open sourced the platform about 3 years ago and since then something like 60% of work being done to the platform is from the open source community. I wanted to mention this relationship becuase it shows how the competing technologies are pushing eachother. I'm not the best languager. 
The lack of the main compiler (Oracle's) being able to make native binaries.
&gt; After 5 years of work, the civilization is just now getting to basic proficiency in Python, Uh, Python is older than Java. Sure, it's only in the last ten or so years come into its own a respected language, but people have been building applications with it longer than that. Now, the 2/3 divide, that's only recently been settled (I'd say about the five years you mentioned) though there are py2 of holdouts (and not simply because they're in the boat that upgrading to 3 won't be sponsored by the corp, folks that say that 3 is the worst thing to ever happen to Python). 
I just use Scala, which allows symbols for method names among other things. But "implements MathOperators" still runs into problems; it doesn't stop people from using operators in inappropriate ways, and it would prevent you from implementing operators that work on mixed types. e.g. you cannot add a position to a position (position is an affine vector, not a vector), but you can add a position to a displacement (displacement is a vector, and you can add vectors to affine vectors).
That dude hates Oracle. 
I just went through the Udemy basic Java course. This was after taking CS202 last semester so it went fast for me as I used it as sort of a refresher before 303 this semester. However John (the dude that does this lesson) explains things way better than my professor ever did. In fact it made me sad now that I know my university courses and professor didn't do nearly as good a job as that series of videos. It's the only one I've done so far but I'm moving onto the next one asap. 
Definitely, I can't imagine writing builders myself.
As to LINQ, is this a matter of taste or do you have reasons for it?
You can then call the method with Thing::new. Which ultimately has very little overhead.
&gt; The compiler handles whole classes of issues that show up in other languages (scripting languages). I have yet, to ever write a single junit test. I know it's out there, and I know what it's there for, but I've never used it and I've been programming professionally since, well, almost 2 decades. To me that's a great strength. While rest of the stuff you wrote was pretty much on the spot, I must admit that quote bit above strikes me as a particularly dumb statement. While Iâ€™ve done my fair share of untestable coding over my past two decades of professional software development, being assured that complex bit of logic I wrote last year still works as intended after my last refactoring, is valuable. Iâ€™d say, looking back at my younger cowboy me who rarely if ever wrote unit tests, I can not call that guy a professional even if he did get paid for writing code. 
\*What are **the** weakest points of Java**?**
Are we allowed to say the JVM? Itâ€™s not really part of the â€˜languageâ€™ but itâ€™s what I like most about Java. 
Just to clear any confusion, please elaborate on your testing strategy
okay these are some fair points but the intellij isn't that bad, is it? :-) i just don't like oracle at all and really hoped that google would have done a better job
To me, its the whole Java ecosystem, its so mature as compared to other languages. I havent had trouble finding resouces for anything that I required at my job.. I've used Java at my job for uploading files, image manipulation, rest service calls, soap service calls, xml parsing, sql db connections, multithreading, queuing systems, cron jobs, auth callbacks, serving UI assets, interacting with AWS S3 and I havent faced any problems implementing them, there is always something out there that I can use after customising it a bit for my use case. And all this without taking a performance or scalability hit, if you write the code correctly, it just works. Ive had one of rest services serving 2500 calls per minute and they run flawlessly. Plus the whole dependency management system (maven is what Ive used so far) is great, it just works. My productivity is very high when I work with Java as compared to when I majorly coded in C# earlier. I have an industry experience of 2 n a half years and Ive been coding in Java for the last one n a half years, given this, in my opinion Java is almost unbeatable when it comes to backend.
IntelliJ isn't all that bad, I've used it for a few fun side projects. I use and prefer Eclipse for 99% of what I work on for fun or professionally when doing Java, web, console, thick client UI, etc. Also, I'm not anti-Google, just wish they could stick to a few more projects.
It seems odd at times, maybe I haven't used it enough.
I guess by saying unit test he means the tests that you write in dynamically typed languages just to ensure that you did not put a typo somewhere in your code.
Well, that could be said of a lot of companies though. If anything, that's one thing they do pretty good at for their own products. It's the other things, the buy, extend, extinguish that has always bothered me about them, the stranglehold they had over vendors, the guy in I think it was Brazil or Panama who had to take them to court for taking his Excel idea and not paying him for it, all the stories I know that are similar.
It would also depend on the needs of the consuming application. Maybe app one will handle a response code differently than app two. I would probably create a shared package that would expose a pretty object with enough information for the different consuming apps to do what they want based on the different status codes and response body. This will also help you test the consuming apps by mocking service a.
for chaining voids, i was thinking of something likedouble-dot instead of single dot. it's syntactic sugar, but at times expressing the initial type is tedious, especially when there are complex generics involved. eg `genericFactory(obj,arg1,arg2).method1()..method2()`. for a concrete (if trivial) example of this problem, look at ByteBuffer the inlining problem is separate. here's cliff click talking about it: https://archive.fo/R72e (the original azul blog appears to be down). i haven't verified that it's still a problem with java 9, but i haven't seen any suggestion that it's been "fixed". in many cases inlining gives an order of magnitude increase in performance. if the JIT doesn't inline the methods that you want (typically because they've become megamorphic) and you need that performance, your only option is to duplicate the java code the simple fix is to allow the code to specify implementations that are "always" inlined, though the java people seem to favor yet another layer of magic. and the hard fix is to allow some form of meta-programming fwiw, unsafe + inlining results in code that's competitive with c 
Do people still use swing? Javafx is so much better but it feels like no one knows it exists.
You have two options. Option 1. Distribute the client in a package and use it as a dependency. This can be done by packaging your client classes into separate module and distributing a compiled JAR via Artifactory or other means. This is even simpler if you have a monorepo. Anyways, the client should be maintained by the same team that produces the API. One way of creating a client is just to handcraft it with love and care and somehow make sure that it is in sync with the API. Another way is tie it to your API somehow. For example, if you use [Spring Cloud Feign](https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html), you can declare your API as an interface with Spring MVC annotations. You then implement it in a controller class (that will be your service) and also use it to produce a Feign client by extending the interface and adding @FeignClient annotation to it. The distributed part is the API interface. Option 2. Similarly to WSDL, you describe your API with something like Swagger, RAML or OpenAPI (either automatically or manually) and then *generate* the client code (e.g. using swagger-codegen) for each consuming service. If the API changes, just regenerate it. The benefit of this approach is that you are now truly cross-language and cross-platform. The downside is that the tech is not quite there yet and the generated client might not be... the most elegant one.
**Sidebar** in **/r/learnjava**
Can you expand on the scalability point. As I understand it Java doesn't scale nicely in a lot of aspects (JVM is a heavy weight), but it compensates scaling in large projects due to types and such, that basically help quite a lot with projects larger than 200k LoC. 
As someone who is still very much in the early stages of learning, it seems to me like the most mature while still being relevant in modern implementations. It has decades of information and community support, which has made it an ideal language to learn programming with. If I have a question or get stuck, chances are almost 100% that there is an answer somewhere online. It also runs on EVERYTHING. I can deploy and test my apps on whatever platform I want. This also adds to accelerate learning since I can immediately encounter the subtle differences in platform and learn to work within them. I can also easily write automated tests for my web apps (and native mobile apps) by simply adding a framework or two. Nothing specialized needed, just more java code. I don't know if other languages are like this as well but it's super convenient. Another point is the absolute sea of libraries and frameworks that you can add in seconds to expand your capabilities almost infinitely. Other languages also have this but not to the degree of java, I don't think. Overall it's just the wealth of knowledge and flexibility that comes with the language. You can do everything with it and if you don't know how, the information exists to show you how.
If I were starting a new Java project I'd use spring boot with annotation configuration and no XML. That doesn't change the fact that a ton of pre-existing enterprise code out there is tightly coupled with XML. If you ever have to deal with JavaEE projects started before 2011 (most of them) then you'll have to deal with it too.
Ease of learning (for me anyway). I've tried to learn Scala and got no where but picked up Kotlin without any problem. 
I think people know JavaFX exists but continue to use swing. JavaFX had a bit of an abortive start, coming out kind of half baked/finished and missing some of swing's features. then there was the scenebuilder stuff: released in a rough state, then in limbo, now maintained by a third party(gluon). now it might be ready/decent but I would hesitate to use it due to its volatile history. continued support and stability is very important to many Java devs, as /u/888808888 said: &gt; As a business, I can be assured the code I write won't be disappearing due to lack of support any time soon.
Two things: * the number of high quality and well documented open source libraries; * the number and quality of material found on Internet about Java technologies. For example, Haskell has many high quality libraries, but they often aren't well documented, and you can't find common Haskell exceptions on StackOverflow. On Spark (the Scala/Hadoop one) you can have bugs that have no answer on StackOverflow, so you have to find the solution by yourself. That slows down development a lot.
Yeah, exactly. I don't "have to" write tests for my javascript code either. Often times, I don't. But I wouldn't consider that to be a strength of my coding ability or my code but rather laziness/bad habit on my part. Sure, things like strong typing helps catch some simple mistakes and errors, but there is still lots of value to writing tests. To brag about never having written a test comes off as ignorant.
Malware packaged with the JRE. I forget if its bonzi buddy, ask toolbar or some virus software, but it is very unprofessional. 
Can you give me an example of the annoying garbage? Genuinely asking
i try to avoid both.... java is nice, for everything but making desktop applications. I think most people just write a "web page" if they need a front end. Having said that, JavaFX is nice, but most people already know Swing so will just throw something together in that if they just need something quick and dirty.
I like how libraries are handled. You get a single .jar and drop it in and just works. You don't have to muck around with .h and .o files or build a "package" like python/perl. Having said that, java's weakness is also libraries. You can get into some messy builds with maven and gradle. It once took me 45 minutes to build a "simple light weight" logging library. (it's really easy to write an effective and crappy gradle/maven setup, lots of people just say "let's just build the entire world") 
Yeah I work with guys with that mindset and have to politely decline their PRs when the converter fucks up 
Without unit tests, how do you ensure your application still works in the face of your colleagues' incompetent code?
&gt; free "stand apart" Hmmm
I had the same issue with mutiple versions of JAXB (one is inside the JVM) and other XML libraries that are conflicting with JAXB.
I agree, but I think he was referring to Java, as in it's a strength of the language to not need to write tests (however bad of a practice it is, of course)
Copying .NET? oO OpenJDK is available since 2006 and only enterprise features and proprietary components were missing. I would say it is the other way around. The biggest problem with .NET was always that it only ran on Windows but it is always good to have competition ;-)
I'm 22 and I have like 5. Still in the uni and have been working professionally since before I was 18.
JavaFx tables vs tables in Swing. When 80 percent ui is tables , using swing is pain. 
Mouse events are platform reliant and file paths. And line breaks in some cases.
The simplicity of bytecode combined with great most-bug-free libraries, in my field, certainly puts java at the top for me.
A Spring Boot application is still a Spring application. All Spring Boot does is provide opinionated, "sane" configuration and defaults for many common applications for frameworks. Many of the auto-configuration just provide a number of pre-configured beans to be used with various other frameworks (Spring JDBC, ORM, AMQP, Web, etc), all of which you can override and configure yourself either using your own beans or configuration properties. I would just suggest first getting a good handle on what Spring Core is and the frameworks it provides. Your understanding of Spring Core needs to be sufficient enough to understand or appreciate what Spring Boot is providing. If not, it will make it difficult to take over control of the configuration if you need to. 
There are certainly areas of Java that could be improved, as others have pointed out, but most of these amount to nothing but annoyances. In my opinion, the premise of the question, that something must make Java weak, is false. It's a very strong language that you can use to accomplish nearly anything.
Thank you for the info! So, very generally, Spring basically has a bunch of different modules and Spring Boot just selects some of them for you and configures them? I've seen the Spring in Action book mentioned so I guess I'll give that a read and hopefully it'll clear things up a bit more :)
Spring Core consists of many different models. There are a large number of other Spring Projects that Spring Boot supports auto configuration for. Spring Boot configuration is applied based on what YOU choose. This is generally done using "starters" which will add the required dependencies to work with a specific framework. For example, "spring-boot-starter-web" will include all the dependencies required to use Spring MVC on top of an embedded Tomcat server. The Spring Boot configuration will detect these modules on the class path, make an "assumption" that you intend to build a web app, and configure everything for you. Add in "spring-boot-starter-security" and you you will get a web app with basic authentication via Spring Security for free. It may seem like magic, but it's all in the documentation and sources code. It's a really fantastic project which greatly simplifies configuration and lets you get down to writing your business logic quickly. 
&gt; (JVM is a heavy weight) can you expand on what you mean by this?
Unsigned bytes. Why have signed bytes?!?! Why?!?!?
As to readability, I want to make a point about the structure of Java. I think it's frustrating that the type comes before the variable name. For example, in Kotlin, the variable is in a consistent position to the far-left. Regardless of the access modifier (val/var) and the type (or if the type is inferred), your eyes can always scan the same position: var foo = "type String is inferred" val bar: List&lt;String&gt; = listOf("Even if we declare the type, the varname is in a consistent spot.", "which makes it easier to read a program") Here's the same thing in Java. Notice how the position of the variable name, arguably the most important part of the declaration, is all over the place: public String foo = ... public final List&lt;String&gt; bar = ... It might sound silly, but ever since I starting doing more kotlin, Java's declaration grammar has frustrated me
The type system is fundamentally flawed. Any type &lt;T&gt; is *actually* of type &lt;T&gt; or null. Even if your function declares a return type, it can still return null. Watch: public Coffee getCoffee(long orderId) { return null; } It's possible for any function, regardless of signature, to return null. Even if your function says it returns Optional&lt;T&gt;, it can still return null. This means that you don't actually know for **absolute sure** if a function is returning the type it says it returns, or if it'll return null. The compiler doesn't enforce it. Kotlin solves this with the nullable operator, ?. If you have a type String?, it means "this could be a String OR null, so you need to handle the null case"
/u/squashsoup2014 did a great job of pointing out the differences. To try and answer your question more directly.... The code that you will write (as in the non-spring config code)... all your managed beans, controllers, DAO classes, models, etc etc... are going to be (or at least certainly *can* be) identical. So for the most part, you spring knowledge will translate easily between the two packages. If your final deployment architecture is going to be cloud or container based, I would probably suggest using boot, since the embedded server saves you like 64 seconds when setting up your container images. :D
I find myself missing 'const' from C++ sometimes (const methods, const parameters). And the verbosity can be get annoying.
You can mark method parameters as `final`.
The level of abstraction is not free
For me, it is deployment and initial provisioning of hosts that can get super hairy.
I work in the defense industry and they love their desktop guis. We write a lot of javafx guis , but I guess I understand why a lot of people avoid it. It's a shame it's a pretty good framework and pretty easy to use.
Its unnecessarily bloated runtime and rapidly declining user base 
Twitter switched to Scala, still a JVM language but not Java specifically. 
Personally I prefer types before variable names. My only beef with declarations is having to pile all the keywords in front and move the varname and type further and further out.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_groomy4u] [When should you use Spring Boot vs Spring?](https://www.reddit.com/r/u_Groomy4u/comments/7m58ni/when_should_you_use_spring_boot_vs_spring/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Not sure why you're getting downvoted. Your opinion is totally valid. 
my favorite features as well
Stay in you hole.
No they're not. Just remember to use the popup trigger "isContextMenu" or whatever it's called, and there is no issue. Line breaks are handled natively by the underlying reader/writer. In short, if you're noticing those types of problems, you're most definitely doing it wrong.
My colleagues aren't incompetent, and I didn't say I didn't test my code, I do test it. But I rely heavily on code reuse, well designed apis etc. 
It can strike you anyway you want, doesn't matter to me. The proof is in the results, and I've done this long enough to know what I'm talking about. How do you think software was written before junit came along? We're all just cowboys, huh? I didn't say I don't test my code, of course I do. But I don't see the need for unit tests.
so kotlin ?
Writing a web page instead of a proper UI is the most cringe-worthy thing I've read all day. Swing is incredible and very powerful (if a little quirky in some spots), you just need to put some effort into learning it. I've made my share of desktop apps, and swing is always a pleasure to use. JavaFX is very immature yet. You can't even turn off font anti-aliasing, and there is no designer yet that can compete with Swing's JFormDesigner. Either of those 2 are pretty much deal breakers right there, at least for me and many others.
What's wrong with swing tables? They are very powerful and flexible.
They're pretty helpful if done right.
Iâ€™d prefer Ceylon, but thatâ€™s just me (almost literally). It looks more similar to Java and has a better type system than Kotlin. Kotlin is a step in the right direction, but I wish they had kept Java-like syntax. 
Really? Java looks more like C++ than Kotlin does to me. In fact, my main issue with Kotlin is that they made a lot of seemingly-arbitrary syntax changes. Like, why do types come after the variable name now? Ceylon managed to keep the `&lt;type&gt; &lt;var name&gt;` syntax while improving on Java. I know Ceylon has already lost the war, but there are a lot of good ideas in that language. 
I would add "expression trees" from C# 
Isn't the purpose of Spring Boot simplicity? Why go through Spring and not directly to boot? I could never stand Spring because I always felt it added additional complexity on top of the already complex app server/Java EE environments. But I LOVE Spring Boot... It "just works" for almost everything and removes the Java EE complexity. I specifically understand how it works but I don't see why other people should? Most Spring Boot questions can be answered with a quick google search when something doesn't work and IMHO it would actually be simpler if you don't try to "over think it".
I agree, but I also like being able to simply check what type a variable is so you can't really win. I often find it's a little frustrating in Rust, Haskell, Kotlin, Go etc. that you don't know types just by reading the code unless you're familiar with return types and such. Not sure if anyone knows of an alternate middle ground out there?
**tl;dr** You should *really* check out this link: [https://start.spring.io](https://start.spring.io) Spring Core is the entire framework. To use a flawed cooking analogy, imagine we're baking a cake (an app). Think of Spring Core as eggs, flour, milk, etc. It's the "ingredients" of everything we're using. But instead of cooking (configuring) a cake (err, an app) from scratch, why don't we just start with a reasonable "base" cake, and we can build off of it as we see fit? That's what Spring Boot offers: it's a Spring app which comes with good opinionated defaults &amp; configuration, and let's you start building applications quickly. It's like a pre-configured base cake... I mean, you know, *sort of*. It's just an analogy. If you read about the Spring Core framework, you'll probably learn more about the philosophy of why Spring is helpful. If you want to get your hands dirty &amp; start actually using Spring, you need to check out Spring Boot. 
Never tried it, but I'm going to seriously consider it for my next Java project. 
Does that include a JVM or just the class library?
&gt; Java didn't have constructors in interfaces before generics were introduced in 5.0, either. I'm going to assume English isn't your first language and give you a quick lesson in syntax. If you say, "X didn't have Y before Z" in English, that implies that X has Y after Z. Adding "either" doesn't change the meaning because "either" is ambiguous in this context.
That would be a huge undertaking, but probably worth it in the long run.
Could you elaborate? Never heard of 'expression trees'
I disagree. Javaâ€™s type system is much stricter than JavaScriptâ€™s, but it is not strong enough to act as a proof of the correctness of your program. Sure you donâ€™t have to write certain kinds of unit tests - Those that verify what your program does if it receives invalid input (as in getting String instead of Boolean). But it can not verify what happens if you get â€˜nullâ€™ instead of an object for example. And it can not verify at all that your complex interest calculation logic really calculates correct amounts given some complex input. 
It's highly productive due to the JVM and its ecosystem with stable mature libraries and frameworks.
what do you link so much about the JVM ?
Yeah. I am saying we are just cowboys. Until we act as true professional engineers we are all just hacks. Some are better and have more experience than others and can get better more consistent results than others. That does not make us professionals though. Claiming that Javaâ€™s strength as a language is that you donâ€™t need to write unit tests is like claiming that beefâ€™s strength as meat is that you donâ€™t have to wash your hands when preparing your meal. 
I've been using Java for over 10 years and I still cannot find anything better, regardless of the poor respect Java has amongst the hipsters and younger devs. I used mostly C++ in college, so when I began using Java, the productivity gains were enormous - no allocating and leaking memory, no pointers to pointers to pointers, built-in String class and no crazy things like operator overloading. Python and Ruby were set to eat Java's lunch, and they do have a lot of users and good libs, but it never happened. I still am baffled why companies build their large apps in a dynamic language when a single misspelling of a method name will crash your program at runtime. The smaller code size doesn't make a difference in 6 months when you go to refactor and realize you need to deeply inspect each file for issues, where in Java the compiler catches it immediately. For smaller one-off scripts and hacks, neither Java nor Python nor Ruby are good solutions. Perl or just AWK and Sed are far more powerful if you take the time to learn them. I won't even consider JavaScript - it's just a bad language with an even worse ecosystem. Supposedly Rust or Go are the next in line to dethrone Java, but I'll wait skeptically. But what I've seen, the few benefits of these languages don't compare to the massive amount of frameworks, tools, and ease of reading Java. And many of Java's warts are fixed in 8, if you must use functional patterns. Yeah pojos with getters and setters are verbose, but IDEs do these for me automatically. People dislike all the factoryFactoryBuilders and other patterns common to Java, but if you actually become familiar with something like Spring, you begin to understand why they're used. C / C++ still have their niches in OS Dev, games, and other apps where speed and low level mem access is important, but this is a fraction of jobs these days. Some of the functional languages like Haskell or even Scala are fine for academia and individual projects, but are simply too difficult for business use and lack tooling and libs. Honestly, C# is probably a better language than Java, but until it is completely untied from MS and .net, it won't gain more popularity. 
I got into the whole TDD craze earlier in my career, but unless the code is really complex, there is no need for the majority of unit tests in Java. This is different compared to Python or Ruby where you just don't know what will break when you change a method signature or name. I think that's the point the original commenter was referring to. Anyway, whenever we get bug reports I tend to see if more unit testing would have helped, and often the answer is NO. It's either an integration problem that would have not shown up, or a logic error we wouldn't have expected anyway. I now cringe when I see devs spending half the day writing big test with a dozen mocked classes. Almost all of them are a waste of time and energy. 
Swing never caught on much except for internal businesses who needed custom apps. At the time, most desktop apps were far easier to write in VB or other languages, and Swing was pretty bad on Windows compared to these, and few buainesses ran Unix / Mac desktops so there was no need for it. Nowadays, internal apps that were formerly written in VB are just served up as websites on corporate networks. They're a lot easier to maintain, distribute, and secure. Swing is probably never going to really catch on because the days of apps for the desktop have moved on. It's either mobile apps or web. Even big consumer apps like TurboTax or Atom are starting to become hybrid web apps.
I agree for big apps with complex UIs that need speed. For example, Photoshop or even a media player are better as native apps than the *online* versions. But most corporate / business apps are just crud forms, and it's far cheaper to just serve these up on the corporate intranet than deal with IT going around and installing and patching apps all week. Especially with remote workers over VPN.
I still disagree. Java as a language does not offer enough guarantees to go without some kind of executable verification. Merely being able to compile your program is not enough. The distinction between a professional and a cowboy is that professional developer will do his due diligence to ensure that the software quality is up to some acceptable standards while the cowboy will come in, guns blazing and shoot up some code that seems to work, run it once and then move on. I was not objecting so much to the claim that some tests are not necessary in Java. I was objecting to the claim that a professional developer does not need to write a single line of test for the code written in Java. That is simply NOT professional!
Scala has variable type inference, and once I learned how to make the IDE show the type by hovering over the var and clicking the key combo, this problem went away. 
The memory model allowing to implement portable multi threaded software. The jit was also a game changer by providing close to bare metal performance. GC that also makes it easier to manage resources, some multi threading algo would be very hard without it. Offheap access for when the heap is not suitable. JNI for when native libs are better - even though jni is a complicated piece. The ecosystem that integrates with pretty much anything.
&gt; The important bit about Random is that it doesnâ€™t provide true randomness [snip] &gt; On the opposite, SecureRandom offers true randomness: CSPRNG like SecureRandom do not provide true randomness. Being cryptographically secure is a different property from being a true source of randomness. 
Why not just try a modern and fast framework like Guice instead?
* Write once, run anywhere, on a lot of platforms. It's completely normal for people to write and test Java code on Windows and MacOS that is deployed productively on Linux, and hardly ever run into any problems with incompatibilies or different behaviour. * Downward and upward compatibility. You can take byte code compiled in 1996 on a Java 1.0 JDK and in nearly all cases it will run without problems on a Java 9 JVM. The source code from 1996 will also still compile, though you may have to use a compiler switch. And you could just as easily write and compile code on the Java 9 JDK and run it on a Java 1.0 JVM, if you take care to avoid language features and standard API classes not available back then (which would admittedly be a pretty bad experience). * The practice of having APIs for new features specified through a community process and then have competing implementations leads to a lot less fragmentation of the platform. These are all things that are enormously helpful for longterm maintainability of software, which is something large organizations tend to be *really* keen on. And for individual developers, it means their knowledge and experience does not become outdated as quickly as e.g. in Javascript web devlopment.
I wrote a blog post you might find useful. http://rabbitstack.github.io/spring/spring-boot-or-not-to-spring-boot/
Oh, yes. Abstraction is the most powerful tool you have as a programmer, but bad/misapplied abstractions do more harm than good. And they're distressingly common.
That it's a VM that has been programmed for most major platforms and therefore we can code once and run anywhere (for the most part).
But I do like Java as a language too.
Me neither actually! but I've read a good part of the overview doc! Looks really interesting. Tbh, it looks like a whole new language. Not sure why it's associated so much with Java... I guess maybe because of the JVM and the fact you can code in both languages in the same project 
Well how do you make sure that your APIs work as expected. You'd write tests that call them, right? Otherwise I couldn't work with you. 
it's not always possible... as boxed type consume more memory, and are a lot slower https://blog.gotofinal.com/java/benchmark/performance/2017/07/09/performance-of-java-1.html Sometimes that performance can be important, if collection is really large or this part of application must be fast
It's multi-language thing and Graal will make it even better.
They are powerful even a bit more than those in JavaFx. The problem I had was that they contents were edited multi thread ( UI , Timers , network commands ) and tables would from time to time screw up either just a white slate would show up or everything but one button element would be replaced and clicking the button would call the wrong object.
I was listening to * mousePressed * mouseReleased * mouseClicked
Question should be the other way around. ðŸ˜
I prefer type first because I can type List&lt;Account&gt; and IDE can generate `accountList` variable name, which is 90% of time good name.
If I'm developing a library (not an app, but a library that will be used by an app), should I use Spring or Spring Boot for my library project? You see I'd prefer my library to not be bloated with unnecessary jars. With vanilla Spring framework, I feel I could cherry pick the exact jars to be included in my project. Am I correct? 
How did you get fluent with basic type theory stuff like covariance? I've read articles but I can't seem to understand and retain knowledge for more than a short period.
Guice is a great dependency injection framework but DI is just a small fraction of what spring offers
Afaik there's no true randomness in the universe, just random enough.
"I didn't eat a donut yesterday, I didn't eat a donut today, either." Hope this has been educational for you, you pompous ass.
Professionals who are using Spring are those who haven't switched to Spring Boot yet. I switched a few years ago. Before that, I had been using Spring since 2005. Now, all new projects are in Spring Boot. No reason not to. Like others have said, Spring Boot is still Spring. I still visit the Spring docs.
None of those are platform dependent in any way. They are very commonly used.
To be honest that description sounds a bit squirrelly; can't blame java if the button is calling the wrong object, that means there is a bug in your code. The rest sounds like it might be a multi-threading issue; make sure you're not running any gui code in the non-swing thread. If you update the table model, then that update method call must occur in something like "SwingUtilities.invokeLater()"
I can't really explain it better than it is in official C# docs, but I found this feature while reading documentation of Entity Framework. They allow to write DB queries like: using (var db = new BloggingContext()) { var blogs = db.Blogs .Where(b =&gt; b.Rating &gt; 3) .OrderBy(b =&gt; b.Url) .ToList(); } and that's because expressions in Where and OrderBy can be parsed. In JPA/Criteria Query above query would have to look like this (more or less): cq.select(b) .where(cb.gt(b.get("rating"), 3)) .orderBy(cb.asc(b.get("url")));
yes , but the sequence is dependant on OS , developed on linux and user was on windows. There was a problem
API's don't exist in a vacuum. They are used by clients. You can write tests any manner of different ways, I specifically don't use junit, that's all. And as an older software dev, I've written software long before junit existed. I'm not sure "you couldn't work with me" would bother me in the slightest; I hire those people who I want to work with, not the other way around.
Kotlin also gets a lot of love in the Android community. Mostly because we're still stuck with Java 7 and parts of 8. Might be a reason why Kotlin gets associated with Java so much.
Speak for yourself dude. Any language that _requires_ heavy testing by a framework like junit is just a crappy language. You're writing tests that are covered by a sane compiler like Javac, and probably doing a worse job on top of it all. There are many ways to test your code, junit is just not something I want to use, and have never needed it to date.
Personally I would use Spring Boot for new projects, and Spring for existing Spring projects, as refactoring them into Spring Boot projects can be time consuming. The one instance where I would not use Spring Boot is when application load time is critical. On average, I find that Spring Boot applications take about 1-2 minutes to complete loading, which may be unacceptable in a few scenarios.
Ease of updates is one benefit of a webpage; but a java jar is easily updateable, just spin off a thread and look for a version on a server, download it, and force a restart. That's what, 20 lines of code max? Dump it in a re-usable library and suddenly its like a few lines of code to add auto-updating to each and every one of your projects. I'd rather deal with updating my apps in place, instead of the unholy javascript/css/html trio. Apps look and feel native to the platform, and you get a ton of re-usable libraries that you can use in your code as well. 
The free version is a showcase for what they can do. With an upload limit. The enterprise version has more hints and more sections and preserves your logs. The free one does not, so if you want to view an old analysis you need to have their service recalculate it. The enterprise version saves the analyzed results and can do a trend over your logs. If youâ€™re skeptical about what they can pull from the gc logs, just open one up in notepad++. Itâ€™s mostly numbers, thereâ€™s no object information (if youâ€™re worried about PI or passwords or anything like that). 
What sequence? "pressed" comes before "released" on every OS. Not sure if "clicked" comes before "released" or the other way around, but it's never mattered. "there was a problem" doesn't really say much. I'm sure there was, doesn't mean you weren't doing something wrong. I'm not saying you _can't_ write java code that doesn't work properly on all platforms; I'm saying you _can_ write java code that works 100% properly on all platforms. I do it all the time, and everytime I see somebody claiming the opposite, when you dig into it, turns out the dev was doing something wrong and just blaming it on java.
 try { new Application().run(); } catch (OutOfMemoryException e) { System.gc(); }
It was about 5 years ago or more. The button was part of that object. It would not update if the button had focus as far as I remmber. Yes , that was my bad first of all calling anything attached to swing element outside of dedicated swing thread is a no no. In JavaFX it is much easier and harder to screw up. 
I am not saying that java is bad , but there is some platform dependant code.
I don't see how it's any easier in JavaFX; the same rules apply there regarding swing dispatch thread. The rest of your comments are very hard to understand as to what you were trying to do, so who knows...
No, there isn't. You'd have to point it out to me, because I've never come across it before other than in sun's proprietary apis which are clearly marked, or via JNI (which of course is a totally different story).
Maybe because type-after-var vs type-before-var is a completely pointless distraction (vim &gt; emacs, obvsly), and there's been a lot of kotlin spam in /r/java lately. 
Good post! &gt; If you are new to Spring and want to learn how the dependency injection, AOP programming, and proxies work, starting with Spring Boot is not a good choice. Spring Boot hides the most of these details from you. I haven't use DI or AspectJ so far, so this kind of makes me just use plain old Jersey &amp; Servlets for my next project, at least until I get a good grasp of Boot. In your experience is it hard to upgrade a Spring Boot project to a higher version; e.g., upgrade an existing project from SB 1.5 to 2.0? 
bootsfaces!
Swing is still the better option, by far. Newer != better, and it has a long ways to go yet. Specifically; ability to turn off font anti-aliasing, a real form designer (something as powerful as JFormDesigner), the ability to make the app look native (Windows/OSX/GTKLookAndFeel) etc etc.
I'm not sure really, just a persistent interest I guess. And I've had to get pretty intimate with the java type inference spec for a project which helped with a lot of stuff. Sorry I can't give you a more useful answer! Tbh I still get covariance and contravariance mixed up haha
Google is where science goes to die. Google is primarily a marketing company. They would *like* to be something more but usually Google's science consists in hiring off some leading researcher from a university or from a not-for-profit research organization. Then, because perhaps because of being over-paid, these people intellectually retire at Google. 
Sure, there are many ways to test your code but some are more efficient and reliable than others. You can always test your code manually each time you write a piece. But that is terribly inefficient use of your time and the time of a testing team (I hope you have at least a testing team). And if you work in a team, unit testing becomes even more important as a safety net making sure nobody breaks your code without getting notified about it by a broken test. No language _requires_ you to write unit tests. Writing tests is a choice you make (or donâ€™t make). Java allows to skip _some_ form of testing, as those checks are part of type checking. But Javaâ€™s type system is not all that formidable in the big scheme of things. It can only catch very small subgroup of bugs and even those not very reliably. For example, it does not help you to avoid NullPointerExceptions (not without additional tooling). There are better languages with more capable type systems than Javaâ€™s around. Some are even available on JVM. None of them obviate usefulness of automated testing. Type systems can not validate that your business logic is implemented according to the specification. It can not verify that a customer can not access certain functions unless they are in the certain age group. It can not verify that you can not withdraw from your bank account more than your balance. At least not Javaâ€™s type system. 
It's similar to a front end developer trying to use some common JS framework that abstracts a whole lot of things away, but not learning the fundamentals of JavaScript first. Knowing how to use a framework well enough to hack out a result is one thing. Being able to maintain and debug it when things go wrong is another. So many issues that are a "Google search away" are very simple problems that an understanding of core Spring (and even sometimes Java IMO) would solve.
Thanks! Honestly as soon as people use the terms I think they are a wizard. I'll look for more resources on demystifying it! These concepts are a foundation for so many things in programming but I would guess that 99% of programmers never think about them.
The former seems totally possible with Java, what am I missing?
Nobody is saying we shouldn't test our code. I'm referring specifically to language features that java has, which python/javascript/etc do not have (remember the context of this discussion, the thread title). When you refactor (say, rename a method or modify the signature) in java, the compiler will guarantee that your code runs (still) or doesn't. You don't have to manually grep through your code base updating client references etc. You don't have to worry about type errors etc etc. With many scripting languages, you _have_ to write such tests, and you will fail to do a better job than a sane compiler like javac which does it all for you. I don't disagree with the rest of your comment, but A) that was never my argument, and B) those types of issues have been around since Assembly and C took off, many years before the invention of java and junit. You don't need a junit framework to validate your code. It starts with writing correct code, small code that is resuable, testing often and early, having clear goals, small commits and updates etc etc.
Do you ever write actual business logic instead of just hooking up framework endpoints? There's a big difference in trusting the framework and not testing that and not testing code that actually does the thing. No compiler will tell you if your method is broken and returning false instead of true under certain inputs.
No, actually I just sit on reddit and look busy.
If you are writing a library, you should definitely target Spring and not Spring Boot. In particular, you shouldn't make your library configuration dependent on Spring Boot autoconfig. Otherwise, people not using Spring Boot would not be able to use your library. This is actually a point against Spring Boot. It makes configuration so easy, that there are libraries that use Spring Boot's autoconfig as a crutch, which makes the library unusable to ordinary Spring projects.
The Spring Boot Starter POM's generally bring in the dependencies that you need to use that specific framework or feature. Bloat appears (in my opinion) when people get careless managing their dependencies. It also depends on your definition of bloat I suppose. 
That's if you favor variable names over type information. I favor type information.
&gt; I find that Spring Boot applications take about 1-2 minutes to &gt; complete loading That is likely due to default autoconfig, which is scanning for every possible configuration most of which may have nothing to do with your app. Using the `--debug` option, you can see which autoconfig options are being applied, and you can disable the useless ones, significantly decreasing startup time.
Yeah I went to boot directly. Then over time I began to appreciate it more as I had to override default configs for things. But using boot your ramp up time can be really small and get you directly into the weeds. 
Yeah it was when clicked occured on one OS it was after pressed on other after released. Sometimes I had to make really weird UI and that was a case with really weird drag and drop.
* Any of the many web- / application framework will do. Incomplete list: [Spring](https://projects.spring.io/spring-boot/), [Vaadin](https://vaadin.com/), [Jooby](http://jooby.org/), [Spark](http://sparkjava.com/), [Ninja](http://www.ninjaframework.org/), ... * Recommending native Android app * Here some hints for the ELO system: [link1](https://moultano.wordpress.com/2014/08/04/a-skill-ranking-system-for-natural-selection-2/), [link2](https://moultano.wordpress.com/2015/12/22/ranking-servers-for-natural-selection-2/)
Yes. I remember the beginning of this discussion and my argument was against a claim that a **professional** developer does not need automated testing harness (in Java). It does not matter if you call this harness JUnit or TestNG or JBehave or Fitnesse or Cucumber or whatever floats your boat. You can write your own if thatâ€™s your thing. But you need a reliable automated harness to make sure you or your colleagues have not broken anything that they are not supposed to without being notified by the tool _**before**_ it goes to production. It is part of being responsible, _professional_ developer. Professional developer does not rely on his experience and gut feeling alone. He **makes sure** that everything works as it is supposed to.
Spring boot is mostly used as an micro services which has inbuilt tomcat server.
Having zero unit tests is a bit extreme in your case. I do, however, think unit testing should not be covering everything either. I have seen junior SDEs writing all sort of unit tests cases for all possible branches of the code. I always told them unit tests are good but we get paid to solve a problem not to write unit tests.
How is that humanly possible.You dont even know what an algorithm is before you get to uni.Hell i didnt even know how a PC works 1 year before uni cause i didnt have one.
I'm not sure mate. Emigrated to Germany from Cameroon and just went ham from day one. Was pretty comfy in Cameroon, got to Germany, spent my first few months at the Haribo production line: put the fear of God in me. Just devoured everything. Wouldn't say I had mastered complicated algorithms back then but shit like linked lists, yeah. 
Thanks, what would you recommend to use as a database?
22 years (and counting) of *relevance* is a pretty good track record for a modern language. In part, it's because of the continual (if slow by design) evolution of the language itself: annotations, lambdas, modules It's openness has led to a community hijacking at times (I mean this in the most positive sense) when the "powers that be" weren't getting it. (So, Spring &amp; Hibernate bringing a better Java EE than Java EE). While this isn't strictly a language feature, I would say the community and proliferation of frameworks is a contributing factor in its sustained popularity. Side note: As I've been working with Java since its release in 1995, I am always tickled by the (seemingly annual) "Is Java Dead?" click-bait posts that pop up. Short answer: No. Saved you a click. 
I disagree that discussing other JVM languages in a thread about Java's strengths (right after a popular thread about its weaknesses) is spam.
Spring boot means you configure SpringMVC by adding @EnableWebMVC to your application, caching with @EnableCaching etc, and adding the dependencies in your maven or Gradle file. You get sensible defaults for configuration. It also comes with an embedded Tomcat servlet container. The only time you wouldnâ€™t want to use Spring Boot is if youâ€™re making something very non-standard, or youâ€™re using some other framework and want to use only a small part of spring. 
I don't think that's a valid analogy. You need to understand Java well enough to work with Spring Boot. Even to get basics going you need to learn some Spring along the way... But spring is a HUGE project with a HUGE amount of legacy. Going into all of that stuff is redundant.
It includes the JVM as well as the class library and other tools. Please read this page if you are interested in additional information: https://javapapers.com/java/oracle-jdk-vs-openjdk-and-java-jdk-development-process/
I think you need to reread my comments. I'm not arguing against what you think I am. Though you're definitely wrong about the automated part of testing. If it works for you, knock yourself out. It's not a requirement.
Ah. Yes. Your users are your testers.
Yup. Because if you don't use an automated test framework like junit, that means that developers don't test there code. Perfect logic right there, folks.
Sure. Because who else finds those regressions. 
You seem to be lost here. Go back to my very first comment. Java has language features/designs which other languages (python/ruby/javascript etc) do not have. Whole classes of errors go away when you use a language like java, because the compiler catches these mistakes for you at compile time. So. Whether you use an automated framework like junit, or whether you use some other mechanism for testing, is beside the point; the point is you have to test LESS for java than you do for python. Python is easier to code initially, but much much harder to maintain. Get it now?
I have to admit being more intrigued by this than I should be. Here is a test class. If you're on windows, can you run this and provide the output? import javax.swing.*; import java.awt.event.*; public class tester { public static void main(String... args){ JFrame frame = new JFrame("tester"); frame.getContentPane().addMouseListener(new MouseAdapter(){ public void mousePressed(MouseEvent e){ System.out.println("mousePressed"); }//mousePressed public void mouseReleased(MouseEvent e){ System.out.println("mouseReleased"); }//mouseReleased public void mouseClicked(MouseEvent e){ System.out.println("mouseClicked\n"); }//mouseClicked });//mouseAdapter frame.setSize(640, 480); frame.setLocation(200, 200); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); }//main }//tester
mousePressed mouseReleased mouseClicked
So you are going to rely on humans to determine if the escape could occur ? 
Open JDK does do it. So yeah perhaps there is some other not as good JIT.
I'm hard pressed to understand why explicit is better. Unless you actually want to manage all your memory manually as well. But then you ought to be using C++
So um, then it's better to have humans doing it make making those mistakes too ?
Same here (linux); without seeing your code it's hard to argue one way or another, but if I were a betting man I'd bet that something was off in your code somewhere. I've done both server and desktop java for too long now to think otherwise. The only platform issue I remember in the area of mouse listeners, is the context menu popup trigger. Linux and windows do it differently, on one platform the trigger occurs on mouse down, the other it occurs on mouse up, and so Swing provides a utility method "isPopupTrigger" which can be used to determine whether the event is a popup trigger for the platform it is running on.
if allocated on the stack, then it's not on the heap, so that means you don't have to do GC when the thread leaves that method/function. No GC is a win in many ways.
You're right, a jar is easy to upgrade on your own machine. The problem in corporate environments is that most desktops are locked down with Active Directory and installing apps is not something that can be done by users. So devs have an easier time making updates to a webapp and then updating the server once and all clients get the new app automatically. This is just how it works in huge corporate environments, gov, academia, etc. Those self installing applets / Java web that came out a long time are still better than many HTML 5 capabilities, but unfortunately corporations started blocking those too as there were a lot of security problems. 
Those annotations are in plain Spring MVC.
At work I use the commercial RDBMS Oracle and MSSQL. But for your project you might consider a free DB such as MariaDB, MySQL or PostgreSQL.
You could just use JavaFX properties, no? 
I'm listening...
I still don't see the problem. If it's a "corporate app", then "corporate" will be in charge of AD or whatever other mechanism you have for updating. You talk to them about your needs. No different than updating a web app on a server somewhere, I'm sure devs don't just have wide open permissions to access the server either. Actually there are many ways to update your apps. On linux, you can put it in a local repository so then updates are handled by the package manager automatically, just like a native linux app. Or, you can setup an rsync script via crontab to pull down latest files etc. But even beyond that, users always have access to their own home directory. You don't need to "install" (using an MSI) anything, really. My installer for windows is basically an exe which contains a zip payload at the end of the exe. When the exe runs, the C code (exe) finds the java executable path from the registry, unzips the payload, then launches the unzipped stuff (which is usually a jar) and then executes the jar to complete the installation; which is nothing more than unzipping further files into a sub directory you have access to. It even puts an icon on the desktop and the start menu. So honestly, I don't really see the issue :)
This is about specifying memory _layout_, not manually managing allocation. I want a contiguous array of structs. Letâ€™s say I have a class `Point` with two member floats `x` and `y`. In my hot path, I loop through a huge list of points and modify each one. This array might be allocated by some other function, so the JVM canâ€™t optimize it as local. Assuming 64-bit architecture with 64-byte L1 cache lines: With C#, 8 `struct Point` elements fill in a cache line; everything is great. With Java, 8 `class Point` _pointers_ fill a cacheline. The data they reference _might_ fill _another_ cacheline, only if I was careful to allocate the Points sequentially, and the JVM hasnâ€™t moved them around. For performance, Iâ€™m better off allocating a `List&lt;Float&gt;` and manually using `x = list.get(i * 2); y = list.get(i * 2 + 1);` Working directly with primitive components is clunky and error prone. I want to specify that each pair of floats represent a 2D Point; thatâ€™s what `struct` is for.
Atomic decay?
Cosmic background radiation?
So contiguous allocation is an important performance issue. But it has pretty much has nothing to do with if something is allocated heap or stack. In Java, If you wanted fast performance you would NOT allocate ArrayList&lt;Float&gt; but rather float[]. I realize that the lack of struct makes the code more error prone. I'm not here to have a java vs C# pissing match. 
How do you know it's random? Just because we aren't aware how it works doesn't mean it's actually undeterministic. Everything is random for us until we understand how the mechanism behind it works. Are you saying there's somekind of proof that atomic decay is random or there's at least a leading theory supporting it?
And that's my frustration with Scala and type inference in general: it makes the IDE essential for reading code. When looking at code outside the IDE, not having the type slows me down, and I don't think the few seconds I saved not declaring the type make up for it.
Yeah, I could have been more clear in my original comment. The crux is not stack vs heap, but inplace vs heap reference. Whatâ€™s wrong with `ArrayList&lt;Float&gt;`? Itâ€™s the easier choice if the size changes dynamically. AFAIK the overhead from `ArrayList` and autoboxing `Float` are practically negligible here. I am not a C# fanboy. I use it as an example because it is the nearest language to Java which has manual memory layout specification. Some of the other commenters have pointed out Java 10 is on track to support value types, Iâ€™m happy with that.
If you are referring to C# value types, the math is all different. There is no concept of escape, but you do have to worry about making copies expensive by making the object too large.
 And you are apparently not reading what I am writing. Just let me quote the relevant part here: &gt; I have yet, to ever write a single junit test. I know it's out there, and I know what it's there for, but I've never used it and I've been programming professionally since, well, almost 2 decades. To me that's a great strength. I said that not writing unit tests is _not professional_. As a professional, one should do more than just write code. It involves documentation and finding out what exactly is needed and deciding how to achieve that and also measuring ones progress so that one can say with confidence that no regressions have been introduced along the way. And yes it involves writing tests. Sure, in Java you donâ€™t get type errors (well, some of them you donâ€™t) and you almost never get typos. But that does not mean that Java the language makes unit testing obsolete. And your way of putting it made it look like youâ€™ve not written a single line of unit tests. As though unit tests are only useful for catching typos and type mismatches. They are not. â€” Let me just bring in an anecdotal story - I used to be much like you. I think I was pretty darn good developer. Never wrote a single line of tests. Did my own testing and caught most of the obvious problems right then and there. But it took time and wasted effort. I had to run the application many times a day to verify that my changes worked. Sometimes many times an hour. Most of my development time went to manually testing all changes. And yet, when the testing team got their hands on the app they consistently found edge cases that I would have not thought to test (either because of the creator bias or because it was just too much effort) After I started writing unit tests, something changed. Because I was forced to think about how to formally test the code I spent some initial time on writing the tests and enjoyed fast feedback loop either confirming that my code works or getting notified immediately if I broke something I should have not. Last project I developed for a client, lasted for about 8 months. Because of the way the client manages their release process, the first time any of the code we wrote was tested 4 months after we started our work. Second time the testing team got to test our code was 2 months later and last round was 2 months after that. We touched more than million lines of code. We refactored significant portions of old and funky code in ways that automatic refactoring tools can not help with. Over all of those months we got back 4 bug reports, that were basically refinements of poorly defined business requirements. We were actively writing unit and integration tests for all our business relevant code and adding code review to the process. I would not have imagined delivering this level of quality if Iâ€™d worked the old way. The old way was always hit and miss. The new way is being certain that I deliver solid product. 
"b =&gt; b.Rating &gt; 3" is the problem. Java compiles it to byte code, but you want to compile it into an expression tree (the result of the second sample).
I really don't know C# at all but I hear people say lambdas are poor man's *extension methods*. The one in the example is a library called **LINQ**. You might look it up if you are interested.
Fuck, no! I don't want people abusing the shit out of operators. Even + on String is questionable.
What do you use instead of junit? As a junior dev, it's very much preached to use only junit where I work
Mostly FE technologies (JavaScript, Angular, React, etc.), php and C#. C, C++ and Java were not in "hotspot" at the time. I am not sure about it now, since I am not in that city for little more than a year. Of course, on university you had algorithms, data structures, C, Assembly a bit, Java, or C#, AI classes, etc., but a lot of classes in later years started focusing on FE technologies which I didn't like. I was teaching fellow on course Advanced Java Programming class, where people were introduced deeper into Java, Java EE and Spring. To be honest, I had only around 30 people attending course. Others were focusing on PHP and FE. The reasons I heard is that it is easier for them to learn it and find the job as FE engineer or as PHP engineer since the needs on the market was mostly focused on this stuff at the time.
Any discussion of truly random will lead you to quantum mechanics, which is obviously not a useful level for most Java programmers to be thinking about. What everyone practically means by truly random is that it is based on some input beyond a seed. You're just being pedantic for the sake of it trying to make a distinction beyond that at this level.
This is a well known problem and they are actively working on it. See project Valhalla.
I don't think you need to be proficient in the entire Spring Core project, perhaps that's a bit much to ask, but knowing the basics (Java Config, beans declarations and scopes). I guess my feeling is, why not learn as much about Spring Core as you can? To be a successful developer (especially in the enterprise world), too much knowledge is never a bad thing! 
Simplicity is a badly overloaded term. &gt;Isn't the purpose of Spring Boot simplicity? Spring is made to be a simple (cohesive) framework with simple (low fan-out) dependencies. Spring Boot has a simple (easy to use) configuration with simple (opinionated common use-case) defaults. 
FE ?
If someone says â€˜thereâ€™s no randomness in the universeâ€™ I donâ€™t think itâ€™s pedantry to point out that there is. It would have been more constructive to have answered with an explanation, rather than a two word prompt for them to look at themselves, but meh
Well I started getting interest in programming when I was 15-16 years old. So I got some books, started reading and trying things out. Most of the time, it was really frustrating and hard, but suddenly I realized that I became hocked with solving problems. So I created few apps, and finished high school and went to university. So once I went there, I guess I did went into crazy mode, and reading and creating apps like crazy. Soon I realized that I really like Java, and started reading books about it. So at some point, I wanted to get some experience, since I had "knowledge" from the books, but not a real practice in profession and that is what I wanted. That was next step. Also, my parents went on some financial problems and I decided to step up. So one thing let to another, one summer school which local company organized, than internship for 2 months and finally the job. I was 21 years old when I got the first job. The university went ok, but at the end it took me 1 year longer, and I was ok with it, since I couldn't handle it all. Later at the last year of the university, I got 1 job as a contractor, to do some web app for the university for not so much money, but hey, it was perfect opportunity and great way to boost my portfolio since I was software architect there, choosing the stack and people I will be working with. After that project, I finished university and after 3 years of working in that company, I decided it is time for a change. So one year ago, I moved to capital city, and started working for some great startup. Also I added 1 more contract job which I did for around 2 months. So at the end, I had 2 contract jobs, 2 full time jobs and 1 job as teaching fellow on university for 1 semester. Now, I have 24 years, and I have 3 years of experience, but keep in mind that for that 3 years I did also PT jobs as contractor and teaching fellow. At the end, when I sum it up, it was a great ride, it was hard and painful, but most important it gave me enough experience and knowledge to position myself on right path and to enable myself normal and stable life, with great opportunities ahead. So I would say it was worth it all this years of struggle and hard work, because now I see all the good that it gave me.
 * Null and * something to replace builder pattern, like named parameters Are the most irritating problemes to be solved for everyday programming. Something more distant: * Case-classes/closed-hierarchies with something analogues to pattern-matching with exhoustiveness checking * Value-types+generics on primitives/value-types would be nice * Declaration-site variance * Something like type-classes/optional interface implementation * Higher-order generics
Sure. But I don't think anyone would contest that Spring Boot is simpler than Spring which is the exact point. You might need to dig into the underlying complexities of Spring but why start with the complexities unless you need them. 
That just means we need named operators and new symbols. Although, the problems with existing overloading are way overstated. Why do you treat the basic operators as so fundamental? Plus means different things with ints and floats. The only fundamental ones that probably should not be overloaded in any language are referencial equality and reference assignment.
I know LINQ but the first example seems basically possible in Java.
You need to know basic configurations to get started with Spring Boot so it's unlikely you will skip that. The idea of "too much knowledge" is problematic. Where do you stop? Learning too many things at once can lead to confusion. The nice thing about Spring Boot is that you can just get up and run almost right away. Once you have something running your learning experience is transformed by the practice and becomes goal oriented. I think it's easier and you can always dig deeper from that point to understand the underpinnings. 
Say "simple" again. I dare you. I double dare you.
&gt; a real form designer What is your complaints against SceneBuilder? You should never use a form builder for Swing because there isn't a standard output format for a gui builder, and code generated by a form builder is hard to maintain (like all generated code) which means other developers would have lock-in to the tool used by the original developer. JavaFX fixed that by having FXML. &gt; the ability to make the app look native (Windows/OSX/GTKLookAndFeel) etc etc. I have never understood why this is important. Web apps don't look native and people tend to prefer web apps these days. Electron most certainly doesn't look native. I think the "native" argument is just FUD against Java on the desktop. 
Ah sorry, as a Front-End technologies.
The goal of these examples is to build SQL query. In Java you can't build WHERE blog.rating &gt; 3 from .where(b -&gt; b.rating &gt; 3) without parsing expression/lambda
OK point taken ;-)
I see, thanks. Couldn't you do the same or similar if you used some kind of light ORM? Obviously not practical for many situations, but when it can be used, you would have correct typing, compile-time errors for incorrect DB fields, etc. So if I am understading right, C# allows a meta-programming that generates ASTs, and they are used for SQL queries? Would the C# statement you listed catch field name errors? How would it, unless the database is some kind of ORM?
I suggest you try JFormDesigner. It generates clean, readable swing code, the same code you would write yourself. I mean, technically, it's lock in, sure, but so is writing certain postgresql/mssql queries (for example). It's a cheap buy, and the license is perpetual. At a certain point, a business (like mine) buys tools to make their life easier. Some buy visual studio, others buy adobe photoshop, I buy JFormDesigner. I guess you need to try JFormDesigner to discover differences b/n the two designers. I can't sum it up in a short post, but there is no comparison. No, people DON'T prefer webapps. They are foisted on us, but they are truly awful. Everybody writes their own design, none of the controls match the native window system etc. I don't use Electron apps if I can help it; they are slow and take up tons of resources. 
&gt; I said that not writing unit tests is not professional. and I said you're full of shit. 
Things like this, dozens of similar libs to do one thing yet none of them solid and maintained, operator overloading, and the complete inability to even decipher some code due to implicits and traits is why I gave up on Scala. Hoping Kotlin is what Scala should have been. 
I get where you're coming from, in a way. It's a much more relational way of approaching code.
Data classes, pattern matching, and value classes are all in the pipeline.
&gt; I see, thanks. Couldn't you do the same or similar if you used some kind of light ORM? Obviously not practical for many situations, but when it can be used, you would have correct typing, compile-time errors for incorrect DB fields, etc. umm... same or similar... no. I focused here on particular problem- parsing lambdas and translating them into SQL query strings. "correct typing, compile-time errors for incorrect DB fields, etc." yes, but that's different thing. &gt; So if I am understading right, C# allows a meta-programming that generates ASTs, and they are used for SQL queries? Exactly, or at least something like that ;-) &gt; Would the C# statement you listed catch field name errors? How would it, unless the database is some kind of ORM (in which case, Java could do just as well with annotations it seems like)? Entity Framework is ORM. It should be enough to check during early runtime if classes are mapped onto tables correctly. If so, statements should be also fine. 
Thanks for helping me understand. In order to truly replicate the queries in Java would require implementing something like syntax tree generation.
Null-as-valid-none-type and null-as-error are different concerns. The second is fine since you just get a NPE, the first is the problem that Optional solves.
the community is really fractured between technical java and enterprise java, and android prolly mucks things up further. reddit is about the best that we have, but with that fracture, lots of good content gets downvoted stackoverflow is probably has the most vibrant discussions 
There's one on https://javachannel.org/ - it had a bit of a layover due to scheduling/life/holidays but it's cranking back up. 
The new Graal compiler, which Java 9 offers as an experimental alternative to Hotspot, does more advanced escape analysis. 
&gt; No compiler will tell you if your method is broken and returning false instead of true under certain inputs. Err,`javac` might not, but "compilers" certainly are capable of doing so. The reason we aren't writing all our business logic in Idris or Coq is because there are other trade-offs besides correctness, e.g. development speed and run-time performance. The fact that Java's type system is garbage doesn't mean that it isn't possible to encode business logic in types. 
I like real desktop apps and wish that there were more of them, but I really don't understand why people like you show up in these threads. Like, web-apps clearly won this battle. That doesn't mean they're superior in all respects, but the ways in which they are superior is clearly important to like 99% of the market.
The problem is operators mean different things for different types. Then they accidently get mixed with different language properties and subtle bugs get into the system. Example char + int. This is also possible with method overloading which is almost the same thing. But with methods at least I can control+click on an IDE and see what it is supposed to do easily. Also I really hate to check what an operator is supposed to do, symbols mean different things for people. For example, what is | to you? Pipeline, bit-OR, ... It is just another cognitive burden while studying a code base. With a clearly named method at least I have an idea what is going on. Example: cin &gt;&gt;, cout &lt;&lt; in C++ (By the way, fuck C style naming of variables and methods). The only place it makes sense to me is [] for dictionaries, even then val = dict[key] looks ugly.