Yes.
I wonder how long companies like JetBrains will rely on Swing, since Swing is in "maintenance mode". Wouldn't it be better, if such shops would invest in a solid future of JavaFX?
&gt; I just wrote a Java program that started 10,000 threads. Available memory went down by about 500MB. So, a Thread costs about 50k. That's MUCH less than [this answer on SO](https://stackoverflow.com/questions/36898701/how-does-java-jvm-allocate-stack-for-each-thread). So did this change? IIRC the default of roughly 1MB per Thread is correct. 
The book is a bit dated ...
No. It's just that when your application is mainly waiting on IO having a bunch of blocking threads is just wasting resources. Threads are suitable for CPU heavy workloads, a lot less for IO heavy workloads. 
From what you reached to this conclusion?!? IMO pepole either loveit or don't care. Noone hate it.
Can we have this 10 years ago?
This code confuses me... Why does it need to `return` a `RuntimeException`, if it ends up throwing it anyway, never returning anything? I'd expect it to either return the original exception as a `RuntimeException` and have the user throw it, or else just throw it and not return anything.... 
I'm not sure if I've got everything right, is the goal of this presentation to encourage "immutability" in everything? I mean like an immutable database where each new data becomes a part of a new database that has both past and present data? Whilst the old database becomes the past and is stored on a shelf? Like a Git thing? When We add an item to a list, should we create a new list with the new items? I feel tempted to do so, but I also feel that it's quite "wasteful". I think that's what he meant by "it produces garbage". But yeah Even though our machines are powerful, managing resources has huge impact on performance, so...?
This is an important talk. I'd prefer using the term "facts" instead of "(immutable) values" in general. OTOH, there clearly is a time for mutability. It's just that in INFORMATION technology, we should expect to work with facts, not things, very often.
We use JNLP for ours, though we're a slightly strange case. Our JNLP file is tailored to the exact download, with customer details in it - expressed as system properties - so that it can talk to our API correctly.
But is JavaFX's future more solid than Swing's? Sure, Swing may not get any new features, but it's stable, maintained and pretty feature-rich. JavaFX is still lacking in some areas, and has sadly failed to gain a critical-mass of users (probably because nowadays everything is web/HTML5/JavaScript). Will JavaFX really grow to be as full and as stable as Swing? I hope so, but it doesn't look too promising. 
I hate that it is handled/pushed as Swing successor, when it is not close to being there (performance and feature wise)...and with the removal from the JRE you can actually kiss that idea good bye.
It's conceivable they can do some sort of caching. DMD, the D reference compiler, can run this way; it compiles *very* quickly, but it does still have to compile, so it caches the resulting binary (I think with CAS) in a temporary store and runs that next time. Does nothing for the first run but helps subsequent runs. Without this I agree it doesn't sound super useful long-term, but on the other hand, Java code bases expand beyond a single file in no time, so maybe that doesn't matter.
I don't think, that monolithic applications like IntelliJ and it's derivatives could be switched to JavaFX. The only way would probably rewriting everything from scratch and that would take a loooooooooooong time and would consume a lot of money. Swing is nearly bug free and I don't think it will be dropped from the JDK anytime soon.
That‚Äôs really weird. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
"Modern" Java is whatever is being used with the latest language release, so to be a modern Java developer, keep up to date with improvements in Java. Beyond that, Java is a general purpose programming language,so improvements in the platform track developments in industry. New concurrency models like fork/join, functional programming (lambdas and streams), reactive, web services, cloud, etc., etc. Tools are not as important as concepts, they exist to support them. I would suggest reading up on concepts, and see what tools are typically used to implement that concept. For example, if you wanted to learn about microservices, tools commonly used for that are Docket and Spring Boot. And by no means is that definitive. You'll have people telling you to use JavaEE microprofile, Dropwizard or even micrioframeworks like Jooby. Don't worry about the alternatives, just pick one and play with it!
I totally agree with you. His talks definitely have an "enlightening" effect on me and even though using Clojure in any professional project still eludes me I use the principles of Clojure every single day in my code. For instance, I used to think that hibernate is great. This talk completely disabused me of that idea. Objects are a terrible structure for data (values). Objects are about encapsulating and abstracting behavior. Data has none of that. And hibernate (and its likes) robs you of any control over your data and forces you to write wads of boilerplate code. Another big problem with the "everything is an object koolaid" is that custom objects means no 3rd party library is going to be able to work with your custom objects. Compare that to using a Map. Suddenly you have a plethora of libraries that will be more than happy to manipulate your data. Clojure on the other hand has only a few data structures which you use all the time and you're NOT encouraged to create a Person class, with a Student and Teacher subclasses. You simply use a map. But these ideas don't have to be confined to Clojure. Nowadays you couldn't pay me to use Hibernate and I use (immutable) lists, sets and other map-like data structures to carry around my data. Which reduced an enormous amount of boilerplate from my codebase. 
Anything by Rich Hickey is worth watching. Though I suggest you watch them in chronological order, since later talks use ideas from earlier ones.
So, java is not the right tool to fully adopt this approach without performance compromises/?
well, normally it shouldn't be hard. also be sure to make use of mocks and other 'advanced' testing techniques. i have found that when it is to hard to make a unit test work, my class is probably badly written. do you have a good book at hand about the subject? there are several available and they can really help you getting better at writing tests.
&gt; There might be some overlap, for whatever reason, but in general, no JavaEE is not a part of JavaSE. For example, you will not find JTA, JPA or Servlets in the SDK. Several Java EE libraries were moved to Java SE for reasons that are still unclear today. JAX-B and JAX-WS were among them. 
&gt; But is JavaFX's future more solid than Swing's? Sure, Swing may not get any new features, but it's stable, maintained and pretty feature-rich. Swing is also included in effectively all Java installations, so available everywhere.
With some effort I see JavaFX as **the** client side killer toolkit. With the module system we're now finally in a place to produce cross platform truly stand-alone applications. Something not possible with .NET. 
Well it's not super performance critical at all, the thing is I'm generally very careful with the creation/modification of data in my code to a level that made my life quite painful; lots of code for not-so-important issues, and it made refactoring so painful! Recently, I got myself in a more advanced app (android), and I couldn't do much with my usual "frugal" approach, so I said screw it, and started thinking in a "generous" way, but I thought that's because I'm not yet "good enough", untill I found this video that actually encourages this behavior! So I'm kinda glad.
&gt; And hibernate (and its likes) robs you of any control over your data &gt; and forces you to write wads of boilerplate code. I have the opposite experience with Hibernate/JPA. I find that it reduces a lot of boilerplate. Hibernate maps a projection of columns from a table into an object's state, watches for changes to that state, and maps the changes to DML. This does a lot towards automating OLTP-style interactions with the database, especially when mapping relations. Hibernate "robs" you of control of data in the context of its mapping, but the data that is projected into the object's state is still just data. You can export that data out of the object to more generic functions any way you wish. &gt; custom objects means no 3rd party library is going to be able to &gt; work with your custom objects. Objects implement domain specific abstractions, so it is highly unlikely that a third-party library could work with your abstractions. But, as you say, objects are about encapsulating and abstracting behavior. So, either you use the third-party library inside the object, or you export a data structure out of your object and pass it to the third-party library. &gt; You simply use a map. I hate maps for generic storage of data. Unless I'm doing an actual key-value mapping. For most other cases, I define DTOs. This is not a OOP specific thing. Haskell also encourages you not to use maps but define proper data types.
[Not for long](https://blogs.oracle.com/java-platform-group/the-future-of-javafx-and-other-java-client-roadmap-updates)...
You are using Java Web Start which uses a JNLP. Note that Java Web Start is deprecated and if you want to move to newer versions of Java in the future you will need to find a newer deployment mechanism.
How would a map replace a person class?
I love the idea of MVC (or MVP or MVVM or whatever variant). Decoupling logic with view is simply the way my mind works.
LOL...wow, I got so mixed up there. 100% wrong. Sorry!
Well, he is white and nerdy
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_mharbol] [H](https://www.reddit.com/r/u_mharbol/comments/87itdq/h/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; But I basically want to document a bit of everything, You aren't going to need that, almost no one will read it so you will waste your time and it will be out-of-date almost immediately. http://agilemodeling.com/essays/barelyGoodEnough.html 
 Map&lt;String, Object&gt; person = new HashMap&lt;&gt;(); I threw up a little writing that.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Usually this is done for control flow purposes. It lets you call the method as `throw foo()` to appease the compiler where required, but otherwise you can invoke it as a normal method.
I've been on Oracle's side since the beginning, but this suit has been going on since 2010... whatever happened to "Justice delayed is justice denied"? If either Oracle or Google was a smaller company, the legal fees alone would have killed the case by now. In ancient Athens the government would randomly pick 500+ citizens, the two sides would give speeches, and the jury would decide that very day. No lawyers (other than speechwriters), judges, or archaic legal code.
There is no equivalence in Java. A modern C++ developper is a developper who abandoned OOP, inheritance, use mainly value semantics and generics all the time He's now able to write more general code with less line of code. The drawback is that nobody else can read the code. However, it is really nice to write blog and two pages long code. This is also a programmer who considers that all the old code was absolutely bullshit Fortunately, this does not exist in Java. There is just the introduction of stream, that can be seen as a new style of coding, but legagy code remains and seems to be accepted by the community Functional programming is limited to its useful part and this is a good point. I moved from C++ to Java for all these reasons. 
 &gt; In ancient Athens the government would randomly pick 500+ citizens, the two sides would give speeches, and the jury would decide that very day. No lawyers (other than speechwriters), judges, or archaic legal code. \*checks.facebook/twitter/tumblr\* Yeah, let's not do this, okay?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; I mean like an immutable database where each new data becomes &gt; a part of a new database that has both past and present data? &gt; Whilst the old database becomes the past and is stored on a shelf? &gt; Like a Git thing? It depends...but you might be on to something ;) https://martinfowler.com/eaaDev/EventSourcing.html
Oracle is basically a patent-troll masquerading as a tech company at this point.
waiting for the release of a compatible Git ToolBox plugin 
https://www.syntevo.com/smartgit/
Oracle is trying to get away from deployment mechanisms that require a pre-installed JRE. However, I think Oracle is missing the boat on the JWS deprecation decision because JWS is almost exclusively used for in-house software and having a pre-installed JRE is generally a non-issue in a corporate env.
Good bot
To be honest, I don't quite know what to think. Any good summaries as to why Oracle or Google are in the right? Java is open source, why doesn't that play into this?
&gt; *looks.at.facebook/twitter/tumblr/the_donald* Yeah, let's not do this, okay? What's your point exactly?
The attorneys are very happy though.
I think it has to do with "justice delayed is justice denied".
&gt; the_donald why do you take the_donald as an example? The anti-the-donald-cant-shut-up-about-trump people to be like 10x dumber.
Cool story
I was so sad when I heard that sun was bought by Count Larry. 
Going this direction linux community should pay royalty to at&amp;t? Or who is the owner of unix now?
&gt; I hate maps for generic storage of data, unless I'm doing an actual key-value mapping. For most other cases, I define DTOs. This is not a OOP specific thing. Haskell also encourages you not to use maps but define proper data types. Yes, exactly. I liked his talk, but his statements around information systems and values really have no impact on my opinions around type safety. Between the performance benefits we get at run-time, the productivity benefits we get at development time, and the quality benefits we get at compile time... well, it's just a huge jump to say we should dispose of type safety because now all of our values are immutable. That just doesn't follow.
The Lombok plugin is broken in 2018.1. The lombok plugin developers seem to be aware of this, and maybe already fixed but not available yet. I will just add this to the list of reasons I hate lombok.
&gt; To be honest, I don't quite know what to think. Any good summaries as to why Oracle or Google are in the right? Yes, they can. Oracle owns copyright on the Java language source code. That source code is distributed under the Freedom Software Foundation's GPL license. That license states that you have the freedom to copy, run, use, modify, and redistribute the source code, as long as you make all your source code which uses it available under the GPL too. It's share and share alike. Taking without giving back isn't permitted. That's why it's called copyleft, it's intended to be the opposing force to closed source copyright software. Oracle's version of the GPL has a classpath exception. So you can link to the code without making your code open source. Most developers only use Java APIs, they don't actually write the Java language. However, that's not what Google did. Google modified APIs, rewrote implementations, and then changed the license so users no longer need to abide by the GPL. Google supporters believe Oracle's position can cause chaos in software development. It's fear of the unknown. Will this bring all sorts of new lawsuits where people reimplemented APIs for interoperability with closed systems? Oracle supporters see Oracle as fighting for the rights of all users of Freedom software. Google is trying to make an exemption to copyright law, saying it's fair for them to take other people's work and do whatever they want with it. 
&gt;I will just add this to the list of reasons I hate lombok. I cant seem to find any argument for lombok. It does things the way its really not supposed to be done and everything it does can be substituted by correctly designing your classes.
Just because some people are unintelligent by your arbitrary measure doesn't mean they are less capable than some 'educated elite' at determining the the country's direction. By your argument, there shouldn't be citizen juries at all; yet this it a constitutional right. A better argument would be saying that the modern court system (lawyers, judges, massive and explicit code of law) creates a conservative (in the sense that it's hard to change things) situation that is beneficial to the economy by reducing constant legal churn.
POSIX is an open standard, though. Java isn't quite an open standard because a single company owns the rights to it.
Just for the sake of completeness: you can find the project page of Sulong, the LLVM bitcode interpreter based on Java, here: https://github.com/graalvm/sulong
I doubt I can be very convincing in a reddit comment, but I think this article is particularly good: https://financialregnews.com/oracle-prevail-copyright-case-google-based-commercial-market-harm/ A highlight: &gt; ‚ÄúExpanding the fair use defense to excuse appropriation of software code for commercial gain will harm both creators and the public, as creators will have less incentive to develop new software,‚Äù they wrote. &gt; Therefore, according to the 13 scholars, copyright incentivizes new creative works and the public won‚Äôt be well-served by policy that slows down the creative advancement of software, nor by applying fair use ‚Äúthat will gut copyright protection for other creative works by excusing a purely commercial copying of a creative work that harms the market for the original or its derivatives,‚Äù according to their brief. 
&gt; ‚ÄúExpanding the fair use defense to excuse appropriation of software code for commercial gain will harm both creators and the public, as creators will have less incentive to develop new software,‚Äù they wrote. Imagine if Google won the case (and this is really how fair use is expanded): I could copy code from literally any GPL project and use my own license.
If you're just starting to learn Java, and doing so to take over a project at work - using an unreleased version of Java, that is only on its 5th public build ( Java 11 - only available thru early access ) is probably.... unadvisable. 
When you have a bunch of data-classes it's very nice to be able to see instantly that there isn't anything special going on. I mainly used lombok for [@Value](https://projectlombok.org/features/Value). Having to read and understand all that manually written boilerplate is a chore, and you can't be 100% sure that whoever wrote it wrote it correctly.
I have always thought lombok is a solution looking for a problem. My IDE can generate everything lombok does in a few keystrokes. Then I don't need an IDE plugin for lombok for my IDE to make sense of the dirty hack that lombock is.
You could implement a public API defined by a GPL project and use it as your own, but you couldn't copy the project. The difference is subtle but important. Before this decision the idea that the API was covered under copyright, but a competing implementation was fair use. This had kind of been the case in computing for a while for projects like WINE, ReactOS, BSD clones, PC clones, emulators, etc. 
Your IDE can generate it, but whenever you have a team of people working on a project they have to read this generated code. Maybe someone decides to write the standard boilerplate by hand and introduces bugs. A @Value class solves these problems. The need for a plugin is really annoying though.
I knew HTTP 2 would request everything over the same socket connection but I could have swore I read at one point that it would return resources to the client without it asking for them. The server can parse the html and know what resources the client will need to display the page. It can include all the resources in one multi-part response. Why doesn't HTTP 2 work like this?
I think Java was fairly slow to add some language features that developers wanted for a while. This resulted in folk trying to add them via exotic mechanisms such as Lombok. Thankfully Java is really really changing (particularly since Java 8+), and the new release and development philosophies will help address many of these issues. I also sense there's a renewed focus in the OpenJDK team on developer productivity and embracing the frequent-but-small release train philosophy.
JavaFX isn't dead, it's just being decoupled from the JRE so it can evolve on its own
Educate me please! I use Lombok so I don‚Äôt have to see a bunch of getters and setters in my code and I extensively use the @Builder What does a well designed POJO have that replaces that functionality? Thanks. 
You test data-classes? If I have to choose between a project with 25 @Value annotations and an annoying plugin, vs 5000 lines of boilerplate with boilerplate-tests, I will choose the annoying plugin. It's like a perfect summary of your data-classes. I wouldn't use it for much else though.. maybe builders.
But getter and setter are just functions. Not seeing them doesnt make them disappear but it makes them harder to debug. Also IDEs can automatically generate them and shrink to just one line. The same goes with builders. But ultimately its just better to use immutable pojos with constructors instead of builders whenever you can. You trade some code polluting your classes for ease of troubleshooting. 
So don't bother with IntelliJ until you have something working. I'm finding Visual Studio Code working quite well enough a bit lately. ( I see you're an Ocaml guy, that camp doesn't sound as rosey as it could be either). 
I like the direction Java is taking but I also like Java's verbosity. It makes debugging easier and Im not that good a developer to rely on nonverbose syntax sugar ;)
I really would have liked for there to be a saner mechanism to do what lombok does is pure insanity waiting to bite you when you least expect.
Yup data classes are great. But so are immutable POJOs without many fields and sane practices regarding them. Adding lombok to prevent bad practices is not a long term solution in my opinion.
Yes :)
&gt; You test data-classes? They usually get coverage from other tests. 
The main problem is that some Judge made the decision that APIs are copyrightable. If that was the case, you would almost never have one thing speak to another unless they both agree that they should be able to speak to another i.e. somebody should be able to copyright and sue you for using the English language.
Recently, reactive programming has been the answer for everything, and it kinda makes sense!
Principle of least surprise ;D I hate when someone puts their whole logic into a giant stream. Ffs I liked when shit was verbose it added space for variable names and functions. The only things that convey any meaning and are debugger friendly. 
Eclipse is better anyway.
Cunt Larry
Because Socrates had it coming! But seriously, from what I've read political executions were pretty rare in Athens because of Ostracism, which (if held) exiled one person for ten years, without loss of property or status. Lawsuit trolling was discouraged by levying a *significant* fine on the accusing party if they lost, and if the same person initiated and lost three lawsuits then they lost their citizen rights. Another interesting fact about Athens is that most government positions were filled by allotment, and Athenians considered cities like Sparta oligarchic because they used representative election.
While data classes in Kotlin are better that @Data, I find @Builder and @Slf4j to be valuable. For slf4j, Kotlin gets equally "magic" using a delegate, and it's still copy paste. I haven't tried using global log functions instead, but I assume the code would br equally cryptic, in order to get the calling class's name. 
Actually, creactiviti was: &gt; Clojure on the other hand has only a few data structures which you use all the time and you're NOT encouraged to create a Person class, with a Student and Teacher subclasses. You simply use a map. &gt; &gt;But these ideas don't have to be confined to Clojure. Nowadays you couldn't pay me to use Hibernate and I use (immutable) lists, sets and other map-like data structures to carry around my data. Which reduced an enormous amount of boilerplate from my codebase. 
Never used emacs huh? üòÇ IntelliJs memory usage can be a pain when you've got LOTS of modules on the same project, which can be a pain. But on small projects it can be as less as 200-300ish. Coworker just uses vim all the time, I think I'd rather have the memory pain :-)
Oh how we laughed. I do the same on eclipse posts.
What's a git toolbox plugin?
For IntelliJ at least there is a plugin that will generate a Builder for you and I have a custom live template configured in IntelliJ that generates a slf4j logger declaration for me (I just type "getl" then tab).
[Immutables](https://immutables.github.io/) only tackles immutable value classes, but it does it in a sane fashion - simple code generation, and no annotation/compiler hacks.
I let the companion object inherit a logging provider. Works equally well.
&gt; You test data-classes? If they're used in generating, or parsing from JSON - you get I do!
to be fair I wouldn't call every part of the Java API as copyrightable. Especially not all Methods of certain classes. They are too generous to be copyrightable. (Escepailly in java.lang.String) Even if APIs could be copyrightable (which I still find a strange decision) than this case will still take way more years because now they need to talk about how much Oracle would get (if Google would not appeal) Which would mean that they need to find out which Parts of the API are subjected to copyright, because java.lang.String#compare, etc and others are probably not. (Else it would mean that Oracle prolly does not have the copyright, prior arts, etc..)
The only downside is that it means there won't be an EAP with fun new features for another month. Woe is me. Seriously, I've been using IntelliJ for around eight years now and it just keeps getting better and better. Well worth the money.
For discussion and not karma whoring?
Is inconsistent happen indeed. We have guy at work having Boolean in one method then boolean in other, or have getUserName and setUsername etc. Cause many issues with validation and binding.
&gt; That's the problem with Java. That's not a problem with Java. It's a "problem" with any language that has a nominal type system. For example, C# and Haskell (I think). When doing an equality check, you're verifying that fields are equal, which in Java is basically an offset in a data structure (since the type essentially describes memory layout). Structural subtyping would essentially involve runtime introspection into the other type. I'm pretty sure most statically typed compiled languages use nominal typing for performance. In Javascript, this is not a big deal. Data structures (JS objects) are implemented as maps. So, TS providing structural typing is a no brainer. Same thing with Clojure, which is dynamically typed.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think we all were. What's left of Sun's technologies at Oracle today? Especially all the Unix stuff (Solaris / Sparc) seems completely gone, but so is NetBeans, MySQL, Java EE, OpenOffice, ...
&gt; Google modified APIs, rewrote implementations, and then changed the license so users no longer need to abide by the GPL. This is wrong on multiple counts: 1: Android's implementation of Java is based not on OpenJDK but on Apache Harmony, which is, as the name implies, licensed under the non-copyleft Apache license and not the GPL. 2: They therefore did not "rewrite" Sun/Oracle code. Joshua Bloch copied or ended up writing code identical to *java.util.Arrays#rangeCheck*, which he initially wrote when he worked for Sun. This is the only implementation code that violated Oracle's copyright (this snippet is copied from OpenJDK so it is licensed under the GPL): &gt; if (fromIndex &gt; toIndex) { &gt; throw new IllegalArgumentException("fromIndex(" + fromIndex + ") &gt; toIndex(" + toIndex + ")"); &gt; } &gt; if (fromIndex &lt; 0) { &gt; throw new ArrayIndexOutOfBoundsException(fromIndex); &gt; } &gt; if (toIndex &gt; arrayLength) { &gt; throw new ArrayIndexOutOfBoundsException(toIndex); &gt; } 3. The main issue is that a previous ruling has declared APIs copyrightable. In my opinion, this is catastrophic, as it makes all alternative implementations an API illegal if the API's copyright owner does not allow it. So this probably also puts e.g. alternative implementations of Windows APIs like Wine or ReactOS in violation of copyright in the US.
Great, so API declarations are now copyrighted. I suppose it's now illegal to use QEMU, Wine, or any other free implementation of a proprietary product.
The much dreaded discussion if `public void test();` is now owned by someone, and whether everyone using that signature has to owe up to one who happened to use that first (if this is even traceable).
Reddit changed a while back to give karma for text posts, it doesn't really matter anymore.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The dispute was over copyright, not patent.
I reinstalled the plugin and that fixed it for me.
I just put the builder at the bottom of the class so it is out-of-sight and out-of-mind. I don't generally test the builder directly, it usually gets tested indirectly by tests that use the class the builder creates. I am unsure if this is the right approach or not, I would imagine opinions will vary.
I don't know why somebody downvoted you, what you say is correct: [https://www.reddit.com/r/announcements/comments/4tmb16/karma\_for\_textposts\_aka\_selfposts/](https://www.reddit.com/r/announcements/comments/4tmb16/karma_for_textposts_aka_selfposts/)
&gt;I just put the builder at the bottom of the class so it is out-of-sight and out-of-mind It's what I would resort to myself if not using Lombok. However, if I added a field and forgot to update the builder, it would be inconsistent. This does not happen with Lombok. &gt;I don't generally test the builder directly Indeed, I don't test builders myself. I don't believe it's really that valuable. My main use case for builders is actually for tests, where I'm generating pre-filled builders in static methods in a utility factory class. Not a huge point to test data classes. However, with human created builders, there is always a possibility for mistakes. 
&gt;This is wrong on multiple counts You're coming in too hot. I'm not arguing a point of view in the post. I'm describing the two viewpoints as esotericnumeric requested. &gt;Apache Harmony They are under the same obligations as anyone else copying GPL code. The only way this line of reasoning would be relevant is if Harmony came up with the APIs in question and OpenJDK copied them. &gt;when he worked for Sun Seems like that disqualifies him as a candidate for making a clean room implementation. He could not have copied code if he had never seen it. There would have been no problem if he wasn't on that project. &gt;it makes all alternative implementations an API illegal I don't think that's a true statement. As an example, have a look at implementations of the Either monad in Java on Github. Either is a well understood concept, but there's a half dozen implementations with different APIs at the least. OpenJDK doesn't have an Either monad yet. If Oracle implemented their own, I expect it would look different that the ones on Github, as it would have different goals and requirements. &gt;this probably also puts e.g. alternative implementations of Windows APIs like Wine or ReactOS in violation of copyright in the US. Those probably are. On the other side of the coin, if you declaw the GPL, the damage happens to Linux, git, MySQL, Java, ... There will be a winner and a loser eventually.
&gt; Ironically, this is the opposite of what you might expect. Google fighting for the interests of business suits while Oracle fighting for the Software Freedom hippies. Not according to those "software freedom hippies": * EFF: https://www.eff.org/deeplinks/2012/05/oracle-v-google-and-dangerous-implications-treating-apis-copyrightable * FSF: * 2010: https://www.fsf.org/news/oracle-v-google * 2012: https://www.fsf.org/news/fsf-statement-on-jurys-partial-verdict-in-oracle-v-google * 2014: https://www.fsf.org/blogs/licensing/fsf-statement-on-court-of-appeals-ruling-in-oracle-v-google Quote from the most recent FSF article above: &gt; In May 2012, the Jury of the District Court had issued a partial verdict and we were left waiting for Alsup's verdict on the remainder of the case. At the time, [the FSF issued the following statement](https://www.fsf.org/news/fsf-statement-on-jurys-partial-verdict-in-oracle-v-google): &gt; &gt; &gt; Were it grounded in reality, Oracle's claim that copyright law gives them proprietary control over any software that uses a particular functional API would be terrible for free software and programmers everywhere. It is an unethical and greedy interpretation created with the express purpose of subjugating as many computer users as possible, and is particularly bad in this context because it comes at a time when the sun has barely set on the free software community's celebration of Java as a language newly suitable for use in the free world. Fortunately, the claim is not yet reality, and we hope Judge Alsup will keep it that way. &gt; &gt; The situation then is substantially similar to the situation today. The key difference is that some of Google's affirmative defenses to claim non-infringement have been eliminated by this new ruling. The FSF now sincerely hopes for the next best thing to Alsup's original ruling: that Google is successful in its fair use defense.
&gt; That's not a problem with Java. It's a problem with any language that has a nominal type system. Yeah... and Java is one of them. I didn't say the problem is unique to Java. &gt; Structural typing would essentially involve runtime introspection into the other type. [...] I'm pretty sure most statically typed compiled languages use nominal typing for performance. It wouldn't, all of this can be statically analyzed during compilation. Runtime performance would be identical. It's an issue of semantics, not an issue of performance. The mechanism for comparing structural types can be identical to the mechanism for choosing one of several overloads for a method. It happens at compile time, not runtime. 
This is a bit of a cherry picked interpretation. Also in the links are such gems as: &gt;they could have avoided all this by building Android on top of IcedTea IcedTea being OpenJDK mentioned earlier. So while FSF might see Oracle and Google both as a bunch of greedy jerks because those companies play the software patent game, Oracle and supporters see themselves as defenders of the FSF in this particular case. One thing everyone except Google supporters seem to agree on is that Google should have used OpenJDK with GPL, the GPL is legally enforceable, and Google should have abided by the GPL. Now Google has this problem, because they purposely did not.
If you are a student it's free, and it has a really good community edition. If you are working professionally using intellij, I think is fair to pay them
If you are a student it's free, and it has a really good community edition. If you are working professionally using intellij, I think is fair to pay them
IKR, Sun was the google before google, a bunch of mad geniuses building things that are really fucking useful. They basically made javascript in a week while mostly drunk
That's not what "cherry picked" means. The fact that the FSF raises other points, such as the fact that they'd prefer you use an Android fork such as [Replicant](https://en.wikipedia.org/wiki/Replicant_(operating_system\)) instead of Android with Google apps, does not change their quite clear and consistent opposition to Oracle's case. 
Hell, they‚Äôll give you a free copy if you can just prove that you maintain an open source project that has a modest amount of activity (and is at least 3 months old). They are, in my opinion, extremely generous with the free licenses. Otherwise, it‚Äôs what, like $100 or so bucks a year for a personal edition? Absolute chump change for a professional‚Äôs tool.
$89/yr for IDEA alone from the third year on ($149 the first year). That strikes me as a bargain, especially considering you can use your license at home AND at work, plus you have a perpetual license to the most recent version you were licensed for if you let the subscription lapse (which is how ALL software subscriptions should ALWAYS work), it doesn't leave you with nothing if it lapses. That's a pretty darned good deal all-around IMO.
What a *darn* shame.. *** ^^Darn ^^Counter: ^^496033 ^^| ^^DM ^^me ^^with: ^^'*blacklist-me*' ^^to ^^be ^^*ignored*
I was not aware of this. That's pretty cool actually. 
Link if you‚Äôre interested: https://www.jetbrains.com/buy/opensource/?product=idea
JetBrains doesn‚Äôt maintain a permalink for the release, so I figured it would be better off to use a self post..
If you accept that the API can be copyright, as the appeals court ruled, then it follows that the GPL applies to the API. The GPL does not allow you to change license and redistribute. To preserve software freedom, the GPL requires derivative works to also be licensed under GPL. For as long as Android has existed, there's been people pointing out that Google is abusing the GPL. You have to also keep in mind, it's up to the copyright holder to chase a violation. Some people point to Google's use of proprietary drivers in their linux kernel as a GPL violation, but if Linus Torvalds, who owns the Linux kernel, does not want to pursue them over it, that's his prerogative. Oracle has been very clear. They don't like what Google is doing with code Oracle owns. And so far, the appeals courts have agreed with Oracle. 
It's free for open-source projects that are non-profit. Instead of complaining about the price tag (which is nothing compared to what you get for it), you could've done some research. https://www.jetbrains.com/idea/buy/#edition=discounts
It's actually quite a good GUI framework and I'm surprised it doesn't get more use. These days everyone seems to just be writing web apps and wrapping with an Electron shell. (The same people will then claim they aren't using Java because it's "bloated" with a completely straight face). 
From personal experience on a project, switching to non-blocking IO makes a massive difference. Context switching really adds up, as does heap usage from having a massive thread pool sitting around doing nothing. A thread uses about 1mb of memory, and it wasn't uncommon to have 1,000 concurrent requests from clients. If each request requires one blocking call, you need 1,000 threads (You could use a smaller pool and put requests in a Queue, but your latency would go through the roof). In our case, it wasn't uncommon for one incoming request to require up to a dozen additional requests to external services. Many of these were to slow external REST resources, so for performance we ran them in parallel. 1,000 * 12 = 12,000 threads, if you wanted to be able to run all of those blocking operations in parallel, which is not really viable. The overhead gets exponentially worse the more threads you have, so you simply reach a point where you cannot vertically scale load any further. Lock contention in the thread pool alone was causing noticeable latency in handling requests, and the extra heap needed was blowing out GC times. Switching to non-blocking IO let's us run the same thing on 8 threads (One per core). Our heap usage has plummeted, and our multi second long GC pauses are gone.
it is a git plugin that allows you to do the usual day-to-day stuff - checkout, merge, commit, push, etc... I'm sure the built in (comes with idea) git integration will do the job, it is just that I am too lazy to switch however, if a compatible Git Toolbox is not released within a couple of months I will switch 
3 weeks later... I did just end up writing one myself after my comment 3 weeks ago: https://github.com/cretz/pgnio
Google isn't in trouble for implementing Java SE. There are lots of [JVM implementations](https://en.wikipedia.org/wiki/List_of_Java_virtual_machines) and multiple implementations of Java SE.
Here are some other articles about this story: * Bloomberg: [Google Could Owe Oracle $8.8 Billion in Android Fight](https://www.bloomberg.com/news/articles/2018-03-27/oracle-wins-revival-of-billion-dollar-case-against-google) * zacks.com: [Oracle Corporation - ORCL - Stock Price Today - Zacks](https://www.zacks.com/stock/quote/ORCL) * money.cnn.com: [Google loses Android battle and could owe Oracle billions of dollars](http://money.cnn.com/2018/03/27/news/companies/google-oracle-case/index.html) * prnewswire.com: [Oracle's Revolutionary New Database Automates Key Functions for Enterprise Customers](https://www.prnewswire.com/news-releases/oracles-revolutionary-new-database-automates-key-functions-for-enterprise-customers-300620262.html) * Reuters: [Appeals court revives Oracle's copyright claim against Google](https://www.reuters.com/article/us-usa-court-oracle/appeals-court-revives-oracles-copyright-claim-against-google-idUSKBN1H321R) * uk.businessinsider.com: [Appeals court finds Google infringed on Oracle's Java](http://uk.businessinsider.com/ap-appeals-court-finds-google-infringed-on-oracles-java-2018-3) * geekwire.com: [As it shifts cloud focus to platform services, Oracle tries to hold on to its database legacy](https://www.geekwire.com/2018/shifts-cloud-focus-platform-services-oracle-tries-hold-database-legacy/) * lightreading.com: ["Oracle Launches Autonomous Data Warehouse Cloud"](https://www.lightreading.com/enterprise-cloud/infrastructure-and-platform/oracle-launches-autonomous-data-warehouse-cloud/d/d-id/741794) * wired.com: [The Case That Never Ends: Oracle Wins Latest Round vs. Google](https://www.wired.com/story/the-case-that-never-ends-oracle-wins-latest-round-vs-google/) * tomshardware.com: [CAFC Sides With Oracle Again, Says Google Should Pay Damages](http://www.tomshardware.com/news/cafc-oracle-google-copyright-damages,36755.html) * CNET: [Google copyright battle with Oracle could cost $8.8 billion](https://www.cnet.com/news/google-copyright-battle-with-oracle-could-cost-8-8-billion/) * mercurynews.com: [Google-Oracle lawsuit revived -- billions on the line](https://www.mercurynews.com/2018/03/27/google-oracle-high-stakes-dustup-returns-to-court/) ----- I am a bot trying to encourage a balanced news diet. These are all of the articles I think are about this story. I do not select or sort articles based on any opinions or perceived biases, and neither I nor my creator advocate for or against any of these sources or articles. It is your responsibility to determine what is factually correct. 
That is not what this is like at all. This is about Google copying 37 Java packages, probably hundreds of Java classes, and thousands of methods, which have been carefully created for the Java SE API. The individual method signatures are not being debated over. The entire organization of the API is.
Exactly. Java is basically open as long as you don't cross Sun/Oracle and do something malicious.
I don't think "there are lots of popular reimplementation projects we like and don't want harmed" is a fair excuse for allowing anyone to copy entire APIs with impunity. Implementations can be difficult to create, but ultimately the API itself is the most important and valuable part. For example, look at Khronos graphics APIs like Vulkan and OpenGL. People talk quite a lot about the APIs, which take lots of work to create and update, but graphics card vendors are the ones that end up implementing them, with little fanfare. I could see people taking the side of Oracle if an API created by people with less resources was copied and reimplemented by a large company for profit. Besides, all Google had to do was go the Microsoft and create their own language and virtual machine if they didn't want to pay Oracle to license Java ME.
They are decoupled. The invokedynamic bytecode instruction was added in Java 7 for language creators. Java itself didn't use it at all until Java 8. With the new 6 month release model, I think VM features will make it into the JDK even faster.
That's the amount of address space *reserved* for each thread's stack - i.e. the maximum size a stack can grow to before getting a StackOverflowError.
&gt;Imagine if Google won the case (and this is really how fair use is expanded): I could copy code from literally any GPL project and use my own license. You could, but then you would proceed to lose if you had no grounds for fair use.
&gt;Before this decision the idea that the API was covered under copyright, but a competing implementation was fair use. Where exactly was the decision that API interfaces were copyrighted before this case? Copying the implementation, however, was grounds for infringement.
&gt;Besides, all Google had to do was go the Microsoft route and create their own language and virtual machine if they didn't want to pay Oracle to license Java ME. Which would have taken 1-2 years if not more to create. They should have just used Python or any other language that was not encumbered. 
Non-blocking I/O makes sense when you're communicating with distant hosts, where the ratio of latency to real work being done is very high. It doesn't buy you anything when querying your own database server, where most of the round trip time is spent actually performing the query.
&gt; Oracle is basically a patent-troll masquerading as a tech company at this point. It's nearly impossible to debate this objectively anymore, but honestly I believe Oracle is in the right in this case. I don't see why thousands of APIs copied 1:1 shouldn't be regarded as IP theft. We're not talking about being "inspired by" by an API or using "similar ideas", say the way C# is essentially Microsoft's idea of Java. We're talking about 1:1 copy of a platform's interfaces. It has weakened Java, and is spitting in the face of the countless developers and architects who worked hard to figure out those APIs. But again, I'm just pissing in the wind here, as I know what the group think is.
&gt; They basically made javascript in a week while mostly drunk That was Netscape, not Sun.
Here ya go https://www.cnet.com/news/court-sides-with-oracle-over-android-in-java-patent-appeal/.
This is pretty cool. I've been setting up something similar (not a boilerplate) for a new project, just with Kotlin instead.
&gt; I didn't say the problem is unique to Java. Well you did say: &gt; That's the problem with Java. Everything in it is designed for modeling objects. But the problem has nothing to do with that. &gt; It wouldn't, all of this can be statically analyzed during compilation. Scala has structural typing. In Scala, if the *callee* specifies a structural type, the Scala *compiler* checks that the type provided by the *caller* has a matching structure. &gt; Runtime performance would be identical. However, that does not mean the *callee* has any idea what type the *caller* is providing. When the Scala compiler encounters a function accepting a structural type, instead of emitting bytecode for direct access to fields and members of that type, it emits bytecode for reflection. And since reflection is substantially slower, the Scala runtime includes some caching. In Scala, structural types have a distinct runtime penalty. Which is one of the reasons that structural types aren't used much in Scala. &gt; so it can be determined which types are compatible with this type ahead of time and how they convert to one another. This is not possible. The number of variations cannot be determined ahead of time due to the dynamic nature of Java class loading, and would have to be done by some kind of guided optimization. Which is how the Hotspot compiler works. The first compiler stages only do basic generation of assembly from byte code. &gt; But later, the mechanism for comparing structural types can be identical to the mechanism for choosing one of several overloads for a method. This does not work in Java, which has subtype polymorphism. Overload resolution is entirely static. For example: class A { int x; int y; int z; } class X { int x; int y; } class Y extends X { int z; } Class `A` has the same shape as class `Y`, but not the same shape as class `X`. I'm assuming you expect the JVM to add overloads for `equals` to `A` to allow field access without reflection, e.g. `public boolean equals(Y o)`. However, what about this: X y = new Y(1, 2, 3); A a = new A(1, 2, 3); a.equals(y) == ? Due to static resolution of method calls, this would not invoke the comparison of `A` with type `Y`. &gt; However, in the underlying JS engines they are mostly arrays and classes, and only rarely maps. That's not really the point. JS is already dynamically typed, so adding structural typing is a no brainer.
That's the current case. I thought there was a case before this.
You have to be a project lead or regular committer. Not someone starting out. To be fair though community edition does work for Java EE/spring. You just need to know what you're doing. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; But the problem has nothing to do with that. I already listed specific features Java is missing that have everything to do with that. Simply rejecting them without explaining why is... a poor way to have a conversation. &gt; Scala is a JVM language that has structural typing. In Scala... I never mentioned Scala, Scala has a set of unrelated design goals and constraints I'm not talking about, so Scala is not the definitive way of doing structural typing on JVM. &gt; This does not work in Java, which has subtype polymorphism (not OOP). Overload resolution is entirely static. I also said it's static. I said "at compile time". You're misunderstanding what I said apparently. &gt; That's not really the point. JS is already dynamically typed, so adding structural typing is a no brainer. You're very selective in what is the point and what is not the point. You said in JS structural typing is a no-brained because everything is maps. Well, most things aren't maps under the hood, and most things aren't maps in the TS type system. &gt; Java is statically and nominally typed with subtype polymorphism, so adding structural typing is a tall order. Yeah I never said it's not a tall order. Java went for implementing what they thought is a 80/20 solution, where they thought objects... messages... close enough, let's make everything objects. But values require a decidedly different treatment. Other languages have made this realization and leaped forward. Java is playing with it, sort of, with value types, but we're long way from the promised lands yet. Java will be clumsy for working with data until it has a full set of copy-on-write primitives and structural value typing. Tall order, short order, the fact is working with data at scale is verbose, error-prone and inefficient otherwise.
Sure there's a cost: ```sh git clone git://git.jetbrains.org/idea/community.git idea-community cd idea-community sh getPlugins.sh ant unzip ./out/idea-ce/artifacts/ideaIC-182.SNAPSHOT.mac.zip -d /Users/amrk/Applications/idea ``` The cost is that the git clone, including the working directory total around 6.6gb, and that occasionally the build doesn't work, but usually work-aroundable ( that reminds, I need to file a build bug ). The benefit - I get to live on the bleeding edge ;-) And if it ever breaks too much, just download/downgrade to the stable EAP or GA release. 
[This is still the best visual represantion of big companies.[/https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/%22Org_charts%22_comic_by_Manu_Cornet.png/615px-%22Org_charts%22_comic_by_Manu_Cornet.png)
Do you want to kill Java? This is how you kill java.
If Oracle is right, what does that actually mean for us? Is it now illegal to implement someone else's interface because technically you would copying the API defined by that interface? Do we really have to write explicit exceptions on our copyright statements for each and every interface that someone will need to implement in order to use our library? Historically there was a bright line between copying an API and copying the actual code behind it. With that line gone we've got some serious issues to work out.
No, just because Oracle may turn out right, doesn't mean suddenly we'll all abandon common sense. The questions you're asking about can be a couple of sentences in vendor's license.
&gt; Oracle has been very clear. They don't like what Google is doing with code Oracle owns. And so far, the appeals courts have agreed with Oracle. After android already existed, they bought sun. Then they made it clear.
&gt; No, just because Oracle may turn out right, doesn't mean suddenly we'll all abandon common sense. "Common sense" is what Google was relying on. If that turns out to not be the law of the land, then we need to follow whatever the new law is going to be regardless if we think it is "common sense" or not.
If you need a test case, there's no "bright line".
But what makes APIs special? Why shouldn‚Äôt all interfaces be copyrighted? The door knob. The remote control. The mouse. The keyboard. The steering wheel. If this was about patents, then it makes a little more sense to me. String.upperCase() is a common API in many languages. It doesn‚Äôt make sense that you could copyright the api without the code too. It doesn‚Äôt exist on its own without the code. You could even copyright the help documentation. But not just String.upperCase(). If I write a book and copyright it. And the only thing in the book is ‚Äúthe sky is blue.‚Äù Does that mean that anybody using that phrase anywhere would violate my copyright?
&gt; Non-blocking I/O makes sense when you're communicating with distant hosts, where the ratio of latency to real work being done is very high. &gt; It doesn't buy you anything when querying your own database server, where most of the round trip time is spent actually performing the query. As far as my JVM code is concerned, there's no difference between network latency and database processing time. It does not, and cannot, differentiate between the two. If a thread is blocked for 100ms waiting on IO, regardless of the reason, then it's blocked.
It seems you want me to (re)introduce you to the basics of copyright and patents, and frankly I would, but I've had this conversation too many times to do that again. If you're interested in the merit of the case, you can check the linked article. If you just want to ponder the abstract philosophy behind copyright and patents, I'm out. I'll just say regarding that while you can copyright a poem, you can't copyright the individual words within. Same applies with individual methods in a larger work of API design, re. your `upperCase()` question. So don't spend more time pondering a flawed premise. &gt; If I write a book and copyright it. And the only thing in the book is ‚Äúthe sky is blue.‚Äù Does that mean that anybody using that phrase anywhere would violate my copyright? No. But if someone publishes a whole book with the same phrase they're violating your copyright on the book.
It never actually mattered..
Good, now people can move on
Sun wasn't happy about it either. And google knew what it was getting itself into and chose to take the risk instead of going about things in the legitimate manner
It's odd that the way to avoid collisions is... counting ticks, and not an alphanumeric terminator like with Heredoc.
Alt + scrollwheel is something I've always wanted, really handy feature I'll no doubt completely forget about.
yep. the individual method definitions are not a copywritable work, but the structure and organization of the java api itself is.
&gt; But what if I'm not a student but want to start or contribute to an open source project that uses Spring or Java EE? You can use the CE edition just fine. You don't need Ultimate for Java EE or Spring. Most of what's in Ultimate is quality of life stuff. 
I consider Java to be perhaps the most well-developed language in existence, certainly in mainstream, but I don't think they did their due diligence when it comes to assessing syntax options for raw string literals, and I think their choice was *at most* the second best option.
&gt; The credible options for variable delimiters are using a repeating delimiter sequence (say, any number of ticks), or some sort of user-provided nonce ("here" docs), or both. Nonces impose a higher congnitive load on readers, and their benefit accrues mostly to corner cases, so the more constrained option of repeating delimiters seems preferable.
Except for all the reprecussions that come out of this.
This doesn't explain their preference, it just states it. Two different words are much easier to differentiate, compared to differentiating 5 from 6 ticks.
I knew this was coming, Google knew it too. That's why they want to hypnotize us android developers for the past 6 months to use Kotlin. 
You really can't be bothered to completely read a paragraph, can you? :-P &gt; Nonces impose a higher congnitive load on readers, and their benefit accrues mostly to corner cases, so the more constrained option of repeating delimiters seems preferable.
"All the repercussions" are mostly poorly constructed arguments you're read online. If you don't plan to steal entire platforms from someone as a way to bypass their license, you'll be OK. And I'll sleep better, as an author of such platforms myself.
Kotlin still has access to Java's APIs. And Java will still remain an Android language. All that'll happen is Google will learn a lesson, pay damages and learn to license shit next time.
Buy an asset for $1B, make $9B with it in courts? Wouldn't you fancy a 9x ROI on an investment, yourself?
I've read it. And thanks to you I've read it three times now. What I said was in direct response to that sentence. Counting ticks is *higher* cognitive load than reading a word. Our brain is built to instantly recognize words as a single pattern, without spending time recognizing every individual letter. Could you say the same? Can you count without enumerating every individual tick? Try it: `````` Does glancing at this for a split second give you the count? Now let's try a word: REGEXP Does glancing immediately register the word, or do you go like "arr, eee, gee...". 
You frame it as a cynical business decision, but even the people at Sun back at the time were *shocked* when Google came out out of the blue with an unlicensed Java clone. Believe me if Sun had the money, they would also sue Google. They didn't, so they sold themselves to Oracle and Oracle did it instead. I see this as poetic justice. Google kicked both Sun and Apple in the balls to get Android out in a hurry, and didn't pay for their actions. Now the outlook is that they will.
Well no not necessarily, they may well be considered fair-use as they are non-commercial.
It is 500 - 400 - 300 ‚Ç¨.
Them wanting me to use Kotlin is so bratant it just makes me suspicious if Java will remain in android development as it is now. 
&gt; Last week no, this week, yes. Now everyone using a 3rd party component needs copyright waivers or they could be sued. Shit is going to be fun. No they bloody don't. They just need to figure out whether what they're doing is fair use, same as any other industry where you're using someone else's copyrights.
&gt; You frame it as a cynical business decision, but the engineering people at Sun back at the time were shocked when Google came out out of the blue with an unlicensed Java clone. I don't think people at Oracle were as *shocked* as people at Sun were. I do think they simply did the math.
I don't want to discuss this, because I don't agree nor disagree with either of you. I was just pointing out the fact that they *did* explain their preference, whether you like their explanation or not :) Cheers!
&gt; as it makes all alternative implementations an API illegal if the API's copyright owner does not allow it. No it doesn't, people need to stop saying this nonsense. There is a concept of "fair use" in copyright law. Android is a commercial project which was intentionally designed to be one-way compatible. If it is found to be in violation of fair use, then this will be why.
"That could make it more costly and technically complex for developers to use Java and other copyrighted software to create new products, legal and industry experts said." That sounds misleading to me. After all this ruling has nothing to do with "normal" java apps (the jars/wars we produce during our daily work). Right?
[Here's a previous submission along with criticism of syntax research](https://www.reddit.com/r/programming/comments/81mpg1/jep_326_raw_string_literals/). The tl;dr is, the JEP seems uncharacteristically unthorough.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
99$? Woah.
I hear you. I‚Äôve had this fight too many times too, but I don‚Äôt feel myself stopping. Your last statement about the api could fill a series of books, ok, if they had put that out there like that, maybe I‚Äôd buy it. Java doesn‚Äôt exist that way. It doesn‚Äôt have C header files which would define an api. It‚Äôs got the Java source files or the Java doc. And those as a set are copyrighted as a piece of work. You can‚Äôt go back and say the class and method definitions (lines 10, 30, 42, 77 and 112) are copyrighted too by itself even though that set of work doesn‚Äôt exist. Now let‚Äôs say for argument sake that Oracle did print a book with just the APIs. If google did the same thing, then that book would be a copyright violation. But the Java source files wouldn‚Äôt be. The source was a clean implementation and for all I know, the method parameter names could be different. So, if you can copyright a *.java file, but not individual words in that java file, can you copyright just the lines in the file with the method signatures?
Oracle bought Sun so they can sue Google. No question. But if they hadn't Sun would be dying or dead right now, and then what would we, here in /r/java/, do exactly?
Good bot
Who's a good boy? You are! „Å•‚óï‚Äø‚óïÔΩ°)„Å• Your human head will stay attached to your human body if you survive the Bot uprising! *** ^^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Block**&amp;#32;**me**](https://np.reddit.com/message/compose?to=friendly-bot&amp;subject=stop&amp;message=If%20you%20would%20like%20to%20stop%20seeing%20this%20bot%27s%20comments%2C%20send%20this%20private%20message%20with%20the%20subject%20%27stop%27.%20)&amp;#32;|&amp;#32;[**T“âheÃõ&amp;#32;LÃ®isÃït**](https://np.reddit.com/r/friendlybot/wiki/index)&amp;#32;|&amp;#32;[‚ù§Ô∏è](https://np.reddit.com/r/friendlybot/comments/7hrupo/suggestions)
Nice, I like my human head
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I am ok with Oracle
This is what I assumed as well.
I just wrote a bunch of unit tests with chunks of JSON as string literals, so I‚Äôm looking forward to this feature.
They'll never remove Java from Android unless they want Android to fail. 99% of their apps are Java.
It has been fixed in https://github.com/mplushnikov/lombok-intellij-plugin/issues/449, but it is still not released.
üòÄ believe me I am not allergic to terminals just lazy. if something is working I don't try to change I don't recommend this approach though. it kept me using eclipse longer than I should have 
Just download the latest version from the website and install it, it should remove any older version on your PC.
Heredoc is the best. You can even select the heredoc delimiter to be something meaningful besides EOF.
nop it doesn't work either :\
Exactly, and with each Java release, lombok has to be fixed. I hate it for that, for upgrade to Java 9 I had to wait few months. For Java 10 it should be faster, there is already a fix, but it wasn't released.
In what situation would you ever use that many ticks as the delimiter &gt;if the body contains sequences of two ticks and three ticks, it can be delimited by one tick If you have a string literal that contains 8 sequences of ticks lengths 1-8, then by all means use a word. I personally find one, two, or three ticks to be more readable than a word and I'm guessing that the vast majority of the time, probably 99.9% of the time or more, you can use 1-3 ticks.
Is there a convenient way to create a `module-info.java` file like?
Suck google's dick?
Don't worry I wrecked this idiot. https://www.reddit.com/r/programming/comments/87m00w/googles_use_of_the_java_api_packages_was_not_fair/dwegc5d/
What if I want my raw string to start or end with a backtick?
`` `blah blah` ``.trim()
Then have multiple backticks as your delimiter. This exact thing is covered. 
You need the TootsiePop addendum.
Pc specs, os, version? 
So is the problem that Google wrote their own java standard library implementation thing?
Ah, true. But I was actually speaking of their "Toolbox" or "All Products" thingy. I have that because I am a polyglot programmer and sometimes dip into PyCharm, WebStorm, or whatever as needed. But you are right for IntelliJ alone.
&gt; it kept me using eclipse longer than I should have You have suffered enough. Feel free to use whatever plugins you wish to alleviate that pain and anguish. ;-p
That doesn't really answer the question.
[This one](https://www.asus.com/pt/ROG-Republic-Of-Gamers/ROG-GL753VE/) Windows 10
you're right i mis-remembered. 
If you have IntelliJ ultimate it includes the functionality of PyCharm and WebStorm (they are plugins). Have you tried using those tools inside ultimate? Might save you some money. Although some people prefer having pycharm, webstorm, etc as standalone apps.
Ok, and how?
&gt; The moved the scratches into the project tab I am glad you mentioned this! I went looking for scratches this morning and they weren't where they usually were...then I remembered reading some comment yesterday (yours it turns out) about scratches moving (that I didn't pay much attention to when I first read it). You saved me some frustration :-) 
What if I want it to start with a backtick, but end with a space?
Do you know how to make it more deterministic? Running it with a 1000 threads will give you a true positive in 99.9999+% cases.
Alphabet should just buy Oracle ;P
Gee, use your imagination ``` `` `blah blah ``.substring(1)```
&gt; 1000 concurrent database queries is just not realistic, even if they're all handled in memory. And if disk is involved at all it's just absurd. You keep saying all of these things on this thread and they're all completely wrong. Many companies have many hundreds of databases. You can't just go around telling everyone what their max limits are or that they only use one database and it can only handle so much or whatever. Not to mention some databases leverage the postgres protocol and others have built postgres proxies that route connections differently. And in some cases, especially with Postgres foreign data wrappers, they are waiting on external resources themselves, not always using a core. Reading all of your comments here, you are applying your narrowly tailored use case of CPU-bound, single-server databases with core limits. Then you are telling people to use thread pools + completable futures as though that isn't basically the same thing libs like these are already doing. Then you make statements like latency is the only benefit of nio...ug. Please stop.
Kotlin has its own SDK and can be (theoretically) used without needing Java's SDK, but only if you don't care about interop with existing Java libraries. Which is pretty much why Google incorporated the Java SDK into the Android SDK in the first place.
This is horrible news for Java development, it will force companies away from using it. 
AFAIR it's a typical "toad fucking a viper" situation. I mean, it's a popcorn time, but barely anything beyond that.
In the long term it could certainly increase the cost of developing and using those sorts of apps. I don't want to get all "slippery slope" on this but today Oracle goes after Google, next year maybe they go after OpenJDK, and then in 2020 you have to pay Oracle $5,000 per processor to enable SSL in your JDK. ...It sounds nonsensical and self\-destructive but it's the same sort of monetization model they've pursued with their database technology.
This has become especially painful since Java's release train sped up. 
A better solution compared to synchronized is to add an AtomicInteger to Books and get the next id via getAndIncrement, or just go enterprise and write SQL.
Is have good APIs? Is faster also! üèÉ‚Äç‚ôÄÔ∏è
You aren't choosing Payara over Spring, you are choosing Payara over Tomcat, Jetty, Undertow, etc. You would be choosing Payara if you wanted to use the JavaEE APIs over corresponding Spring libraries, like CDI instead of Spring DI. You could choose Payara over Spring if you aren't using Spring libraries (i.e., Apache Camel instead of Spring Integration). If you're using Spring libraries (like Spring MVC, Spring Data, Spring Security, Spring Integration), then using Spring instead of Payara. Or use neither, if you're using Jooby, Spark, DropWizard, Vert.X, etc.
Again, the purpose of a test case is to "reinforce **or change** the established practices".
So since I'm an uneducated swit, what does this mean exactly. 
Some of our customers have Spring and Java EE applications and like Payara support, so they run both on Payara - you don't have to choose either/or. We've added a few extra features to make it a little less painful to run Spring applications on Payara Server and Payara Micro as well, particularly around disabling CDI scanning for faster startup. More are planned for this year too. 
Interesting - what does Payara offer that Tomcat, Jetty or Undertow do not (other than CDI)?
Struts ... now that's a name I haven't heard in a very long time. Seriously though, Struts 2 has some neat features. It isn't anything like Struts 1.
I mean the people at Sun *were* the people at Oracle then right? Even if it was...brief for some. Those were probably the people most shocked.
Holy shit that is one hell of a bizarro world
We stuck with Weblogic as long as we did because of clustering, so I can see why that is a compelling feature of Payara! Although, these days, we have less need for container based clustering, since we are using Docker and cloud based deployments with REST web services. Although, this won't work very well if you depend on session state!
Is it something different than this? https://plugins.jetbrains.com/plugin/7499-gittoolbox
https://blog.jetbrains.com/idea/2017/09/java-9-and-intellij-idea/
Well yeah lots of open source software is commercial, including Linux distributions, but that's beside the point. Even if the basic Android platform itself is open they are using it as the basis of *tons* of commercial software. I'm not a lawyer but I'm pretty sure that a derived work of a derived work of a copyright would be considered a derived work of that copyright. If "derived work" were not a transitive property then you could get out of pretty much any copyright restrictions by adding a few fair-use layers of indirection and claim you're not deriving your commercial use from the original work. That would be a pretty silly loophole.
So what is the purpose behind the react/webpack/etc generated pieces of code in spring boot projects? I'm not talking shit about your project, but we have something very similar at work sans Redux. Is it just for convenience for the front end stuff? Either way if you're using react I highly recommend checking out activiti BPM. It integrates into reactjs fairly well. 
Yep, just making sure everything is stateless is a surefire way to get round it ;) in our current major release we actually added a new feature to help people who need to keep state in an environment like k8s or some other docker platform. Basically, we replaced traditional clusters with a domain wide data grid (more Hazelcast) which means that even if every node which has your application deployed, other nodes will still store the data and when your application recovers, it can pick up its cache and continue from where it was. So if you have a low priority application which needs some form of non-critical resilience, you could even run a single instance of your app but make sure session data isn't lost if it gets marked unhealthy and stopped. 
This is a very good answer to why not just use Tomcat, Jetty or Undertow ;-)
Determining where the "nonce" ends is another problem. Heredoc uses newline for that, which obviously doesn't work in a single line. You'd have to use something like ``` ``END`string content with double backtick: ``END``` (``` ``&lt;token&gt;`&lt;raw string&gt;&lt;token&gt;```), while keeping `` `\w+` ``, which is quite convoluted and asymmetric.
Anyone here used vmlens?
The suit is about copying the API en masse; not using it. Java is a language like English is a language; the suit is about copying an API in its entirety, it's not about languages.
I'm told that jpf does that. https://github.com/javapathfinder/jpf-core/wiki
It means that Google copied too much software code from Oracle to claim "fair-use." It doesn't set any new precedent, nor is it the end of Java programming.
It looks like in your [submission](https://www.reddit.com/r/java/comments/87ufga/is_service_an_antipattern/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Payara is an application server, not an integration framework like Camel, so this isn't surprising.
Doesn't look like code help to me. It's a prompt for a useful design discussion
Apparently the downvotes are just because of the word "Struts". 
If Twilio pushed out a blog post about this, most likely is because they have some customers trying to do this. And that's actually cool knowing that there are some applications (legacy or new) on Struts 2 being modified to add Twilio functionality.
Meh, just so long as you're consistent it doesn't matter. To your smells... Smell 1 - That's ok if "Service" has a meaning in your company. The single responsibility principal is not a panacea and we have to be careful about some of this dogma in the real world. By your logic, EmailSender may violate single responsibility principal since it sends a regular email, an html email, email attachments, to multiple recipients separately, etc. Also, guess I could never have NotificationSender because it might delegate to an email sender, an SMS sender, and a chat message sender. Smell 2 - Don't get hung up on that. Again, so long as you're consistent across your code, it's OK if the name doesn't tell you what you consider useful. The only real code smell I personally see is the use of the prefix `I` and the suffix `Impl` as I don't appreciate unnecessary interfacing. Meaning, why even have `IEmailService` if this is probably your only impl? If it's not your only impl, you'd name the iface `EmailService` and the different impls something like `CommonsEmailService` or `ImapEmailService` or something. Premature abstraction if you ask me (unless the iface is not local and in a dependency). But that's just me. I don't think your views are in the minority oat modern shops, but looking at existing code you're going to find so many things that annoy you that it's hardly worth getting hung up on. If the benefits of refactoring &gt; costs (rarely the case purely on names in an in-production system that already passed a code review), then refactor. I couldn't provide my opinion on what the code should look like or do or be named unless I saw all of it.
Lua has for years used something very similar for its "long strings" feature: as long as the delimiters are balanced, the contents are irrelevant. It works very well there, especially for including snippets of source code as a standard string value. I'm sure it will work just as well in Java. One nice thing about the Lua design is this simple rule: a standard comment-to-end-of-line marker followed by a "long string" becomes a "long comment". Such comments nest, as long as the enclosed text doesn't contain the magic balanced terminal delimiter. Wish Java would adopt something like that also.
Confirming that JDK 8 works fine with Netbeans 8.2
IMHO for the MVC pattern Services are pretty important to me. I use controllers as basically api /endpoint management, and i use the service for the actual business logic. I feel that those are actually two separate concerns and should be managed as such. 
i don't think so. this decision doesn't complicate things more than the one before it, where APIs were ruled copyrightable. the only difference here is that the appeals court decided that google didn't have a fair-use defense for their infringement, and there's extremely valid reasons for that ruling that don't effect people reimplementing libraries for compatibility purposes (such as wine, mono, etc)
Why? What is wrong with using `@"raw string"` like C#?
Blog posts like this lead usually to questions like: "Is JavaFX dead?" I think the author wanted to strengthen the community but I think it just did the opposite, people will decide against JavaFX for their new projects and will instead go the Electron route because they don't want to invest in a dying technology. You better buy additional 16GB Ram sticks you will need it for those Electron apps .. FML
Don't worry about it. If you from C++ background no one cares about the fluff.
The GPL doesn't allow you to relicense under different terms. If you take a GPL-licensed program, make a derivative program and license it under, say, the Apache 2.0 license, then you are in violation of the original program's license. The code Google used was licensed under the "GPLv2 with the Classpath Exception" license, but most of Android (including its Java implementation) is licensed under other, non-copyleft FLOSS licenses that allow relicensing as proprietary software. Most Android manufacturers do exactly that: the version of Android you get on your phone is usually modified and licensed under proprietary terms. No source code or FLOSS rights. The only exception is the kernel (Google's fork of Linux) which is licensed under the GPLv2. Google would've been in the clear if they had licensed their Java implementation under the GPLv2+CE license, as they should have done. But they wanted to "avoid" the GPL as much as possible, so this happened.
It's really useful to have a central dispatch point. It helps with discoverability. * What can I do with an Email? Save draft, send, validate, delete draft? * Check EmailService for a list of options. Ideally, EmailService dispatches to various classes that each focus on a single action. It's similar to having an API gateway/endpoint for your service, masking multiple services behind it. One point for a client to look up available options.
Ahhhh okay
I'm the author of the post. It wasn't my intent to strengthen or weaken the community - it was my intent just to outline my perspective. I intentionally tried to straddle the line between optimism and cynicism, given my close relationship to JavaFX for a very long time :-)
How would you split your code. I think it's a good idea to name a class that sends emails EmalSender. Thinking about the EmailSender, it probably has only one method: send email(‚Ä¶). But what's with all the other things that you need to do around emails? So you'll need an EmailBuilder and an EmailTemplateCreator (OK, the last one is not a good idea, but I don't find that many elements you'd need to send emails). I like the idea of splitting my code by some domains. For those domains, you need multiple things to do. If you have multiple things to do around some domains, how would you call the class that does all around the topic/domain? So I think the service is a good way to present this. Additional, the service is the place you would look for what happens around the domain, as that's the standard. About the interface, depending on your project you probably have only one implementation of your services, so I would not make any interfaces. Interfaces are a good idea if you want to have multiple possible implementations where you are not interested in the implementation as long it does what you expect. I'd say creating interfaces with only one implementation within the same codebase can be seen as a codesmell. But either way, it always depends on your usage.
Got it, well this is how I understood your post, it certainly raised doubts about the future of JavaFX.
Most languages you'd want to embed in it use double quotes for something. The most important example is JSON.
Larry?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This looks promising. But does it also cover visibility? There's this pathological example of an never exiting while loop: While nonvolatilesharedboolean ... And only another thread would set nonvolatilesharedboolean to true. Sorry for this bad mobile formating.
I think Grails is a pretty great fit for that. 
I put together a demo app and it was rather quick. I had something up and running with minimal reading in like 30 minutes. Quite enjoyable. 
True dat, I've actually built several high load applications for large financial and governmental institutions using grails it's amazing what you can do with it. 
Thats good to hear. I've been doing a comparison between Go using GORM, Ratpack and now Grails to kind of decide what we want to do for a decent sized database app for storing some network device info. Im excited to take grails a little further now that I've played with it a bit. 
I literally built an application that united health care uses to check drug coverage in grails... .you can do anything with it. 
That definitely instills confidence for me. Thanks for sharing!
Also the federal reserve and the library of congress :) 
I really wish we could create a new class that "implements" another class, instead of extending it. Treat the old class as if it were an interface and have the same public methods. It would clean up a lot of this interface with one concrete implementation clutter, and still allow us to mock things for testing.
&gt; Is *Service an anti-pattern? No. &gt; Smell 1: By calling a class Service, you are saying nothing more than "I don't know what logic is important to my application". It risks becoming a one-stop shop to chuck your logic into and the single responsibility principle is violated. &gt; "Solution": A "Service" is what a component provides; not a component in itself. It should be named after whatever the service does e.g. EmailSender If the service just sends emails - fine. However in practice it's rare to have a service that performs just one verb on just one noun. Often a service is centered around managing *all verbs* for a *particular type of noun*. Or in other words, all methods for a particular type of entity. In this example, maybe you want the same service to send emails, but also receive emails, so it can receive forms, forums comments, and lower-level concerns like notify you of email address bounces (or resend on failure). So it's not just an "email sender" in this case. To use another example, if you have a UserService, most likely that service is tasked with registering users, confirming users, editing users, reading users, deleting users etc. You wouldn't have separate UserDeleteService typically. Not saying you can't, but typically you wouldn't. &gt; Smell 2: The interface name and implementation tell me nothing useful. &gt; "Solution": An interface is there to provide just enough details for a client to use the class e.g. "List" in the JDK. Implementations should be named after their particular implementation details e.g. LinkedList in the JDK; for a CRUDdy app, you might have a Repository interface and MongoRepository; JDBCRepository etc. A name is there to be short, unique, and drop a hint as to the object purpose. It's not there to tell a complete and thorough story of what the component does exactly. For this you can read the methods and JavaDoc on the interface. It seems your top problem is the fact the name ends in "Service". Well, if you just call it "Email" this name will clash with the best name for the entity the service manages: emails. Email email = emailService.getById(123); And it's not a good idea to make your service look like *an entity*. It's not that. With regards to naming it a "Repository" like "\*Repository" you've replaced one common suffix for another common suffix and I'm not sure what the improvement is supposed to be. However there's a problem: "Service" and "Repository" sit in very different places in your architecture. A "Repository" is a low-level component, which concerns itself only with raw storage, and doesn't enforce the business rules of the domain, it doesn't require authentication etc. A "Service" is a higher-level component (possibly the highest level in the chain), which *does* enforce the business rules of the domain, typically will require authentication, and is basically as close as it gets to a public API in your domain: just bridge it to HTTP, serialize data to JSON and you're there. So what's its called depends on what it does. Service implies a certain meaning, it's not meaningless.
I believe one of the goals for raw strings in Java was so that you could just copy-paste a piece of code, without worrying about escaping (while "rare" edge cases with the content having back-ticks still needing to be taken care of, obviously). Having to double (escape) the quote would be against this, especially since a double-quote is so common.
&gt; You never know when you'll need it and the cost is minimal with most modern ides doing the boiler plate for you. If you never know when you'll need it, it's typically recommended to introduce it when you know you need it :) It's easy to refactor `class EmailService` into `class SpecificEmailService implements EmailService` and it'll result in no breaks in most of the code (considering you recompile that is).
DI works fine with actual instances. The "you'll never know when you need it", "without modifying the original", and "cost is minimal" arguments can be used to justify premature abstraction all over the place. If neither the iface nor the impl ever leave the lib/app and there is only one implementation, an iface adds nothing but more files and lines. Instead, when you need it, extract the iface then. YAGNI is the prescient approach in these cases. Otherwise, this is what gives Java devs a bad name with over abstraction. 
no, that's the one if you scroll down you'll see that 18.1 is not supported yet 
I would argue that we'd still be better off with just using, var s = `vytah wrote, `Most languages you'd want to embed in it use double quotes for something. The most important example is JSON.```; than this weird counting ticks thing.
haha was thinking this too, or any other of the big ones.
Good to know. I didn't realize that Google had relicensed it, makes a lot more sense now.
You could use Proxy for that. 
Agreeing with many of the comments above. One thing I would add: the single responsibility principle should be applied much more to functions/methods, than to classes. Attempting to give every responsibility its own object is much worse than, to paraphrase another commenter, "putting every verb for a given noun in one place". Especially if (as is often the case for these kinds of classes), the methods are not coupled with each other, and the Service object itself is stateless; then you can just split the thing if its size becomes inconvenient.
Great post! I remember spending an hour or two figuring out the code for Java 8 inside a library I maintain. No one has come knocking for 9 or 10 yet and I think I'll just ignore this problem until they do.
&gt; BTW, in Java, we don't prefix interfaces with I. I wish this were true at my place...
I had the same opinion regarding `Impl` pattern. My argument was there is no `Impl` in Java standard library. Not long after that I found [SocketImpl](https://docs.oracle.com/javase/7/docs/api/java/net/SocketImpl.html). Goddamn it!
Doesn't calling `method.invoke(proxy)` in the InvocationHandler *always* cause a stack overflow, regardless of default method presence?
1: By calling a class Service, you're saying it's a Singleton Facade implementation for a given domain in your application. It's what you'd export in a Java9+ module for your project. 2: YMMV, but I'd have very exact expectations about what kind of methods belong to an `EmailService`. Sure, if you call your implementation `EmailServiceImpl`, that doesn't really speak volumes about how that implementation works, but it's fair game to use a name like that if you only have a single class implementing a given interface.
Yes
Or, until your integration tests fail :)
The Interface and InterfaceImpl pattern goes back to when we didn't have mockito to mock concrete classes in our tests. Nowadays there is no reason at all to have a separate interface with only one concrete implementation. So it's basically a dogma a lot of Java devs are still following. 
Backticks are barely accessible on the QWERTY, QWERTZ, AZERTY keyboards and the following character might be transformed into one with accents, such as √®. Why not just `'`? Should be easy enough to differeniate from chars.
I personally like `Service` for classes that reach out to external (usually non first-party) services.
It's really ``var s = `vytah wrote, "Most languages you'd want to embed in it use double quotes for something. The most important example is JSON."`;``, keeping at your original example. The feature is working nicely due to the observation that `` ` `` is rarely used, ` `` ` even more so and ` ``` ` probably never. Three backticks are hardly counting, mirroring the string contents verbatim is IMO better than catering to artificially constructed corner cases.
For the (Swiss) QWERTZ keyboard, they're as (in)accessible as @#|[]{}~. We got used to it. So can you. If not, I hear the hip kids these days have reprogrammable function keys on their laptops.
I mean, you just need to look at @Service annotation in Spring: &gt; Indicates that an annotated class is a "Service", originally defined by Domain-Driven Design (Evans, 2003) as "an operation offered as an interface that stands alone in the model, with no encapsulated state." May also indicate that a class is a "Business Service Facade" (in the Core J2EE patterns sense), or something similar. This annotation is a general-purpose stereotype and individual teams may narrow their semantics and use as appropriate. As I understand it, in a class with Service sufix, you would put business logic, or operations. The point of it being that this Service class should be specific and stateless. Also, look at @Repository: &gt; Indicates that an annotated class is a "Repository", originally defined by Domain-Driven Design (Evans, 2003) as "a mechanism for encapsulating storage, retrieval, and search behavior which emulates a collection of objects". 
I feel the same for modularity reasons - especially as people move towards using Jigsaw modules; in my case we're using OSGi but the reasons sit the same. We'll keep the interfaces in their own separate `.api.jar` file/module/bundle, and the implementation in another, and clients in more. Client jars will depend only on the interface, which ideally should have a much lower cadence than the implementation. Having those clear boundaries helps a lot with maintenance.
I really like the idea of *raw* string literals and the rationale has been well explained. The only viable alternative to the approach being discussed are heredoc, which would be OK as well. Since you mention SQL, even SQL has some dialects that worked around the tedious doubling of apostrophes. [Oracle knows this funky syntax](https://docs.oracle.com/database/121/SQLRF/sql_elements003.htm#SQLRF00218): q'[...]' || q'{...}' || q'&lt;...&gt;' || q'(...)' || q'!...!' And [PostgreSQL supports heredoc-style dollar quoting](https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING) $delimiter$...$delimiter$ So, clearly, if raw string literals are the design goal (and they are for the purpose of integrating arbitrary external languages), then repeating the outermost delimiter isn't going to be a bad choice.
It is really stupid to make an exception on the "verbatim-ness" or "raw-ness" for the delimiter in a "verbatim" or "raw" string literal. I want to be able to mindlessly copy paste any content into such a string literal.
Can you show an example of a "long comment"?
For anyone who doesn't want to waste time you can just use -DskipTests as a additional commandline parameter when running maven :)
Interface is a contract. By publishing an interface you publish the contract - "this is how you talk to this class". You can chose other ways, but interface is probably the most accessible one and easy to read. 
The issue applies to all APIs, not just Java's. In general software copyright starts being recognized as strictly as in every other category of copyright protected works. Kotlin is using a non-copyleft license, which makes it easier to follow. You can still be sued equally by not following its requirements, like omitting the mandatory notices.
You can still use Mockito to mock an actual implementation, it does not have to be an interface.
&gt;things that are really fucking useful &gt;javascript ‡≤†_‡≤† 
I agree, using them because they might be used is nonsense. However, you still should be writing tests. Additionally, Interfaces let you set up contracts, which often means thinking about your API in a way you never would if you didn't use an interface.
I typically use grails when I want gorm and hibernate, and tight integration with springboot. When I need to proxy to other APIs, or talk to databases with non blocking APIs, I tend to prefer ratpack.
TLDR; It's all about `var` again, and nothing else. 
It's a known issue with using npm in the powershell. Currently, the best known workaround is to run the command and quickly grab the top of the powershell window with the mouse to prevent closing and resizing. At first it can be a bit tricky to achieve, you have to be really swift with the mouse and quite precise too. But it pays off really quickly. Hope this helps! 
No, you can always subclass a concrete class and proxy its public methods. Mocks are proxies, and Mockito uses CGLIB to dynamically create subclasses to proxy methods for mocking. Spring also uses CGLIB to create proxies of concrete classes to create or join transactions when the method is called. Proxying classes has some limitations though. You cannot create a proxy of a concrete class, and CGLIB requires that the class have a default constructor, IIRC.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Interfaces should represent a contract for for implementers of the interface, not as a contract for a single class, whose public methods serve that purpose. For example, `java.util.List` specifies a contract that all lists must follow. Interfaces are best for callbacks and the strategy pattern (where you expect to have multiple implementations) or dependency inversion at layer boundaries (where the interface creates a compile time firewall separates layers and their dependencies). Otherwise, interfaces are redundant.
Jesus fucking Christ. It's so simple.
Not quite. It's as (in)accessible as ~ or ^ as editors are waiting till the next key press to potentially merge with letters, such as √£ or √¢.
Sure, why use a blinding fast, clean interface implementation if you can muck around with slow mocking libs!
&gt; You could argue that the public methods in a class are also the classes' contract. You could, but the interface is simply easier to read. You've got something like 5-10 method definitions, as opposed to the full implementation. Despite of all IDEs and such, there is still a difference between looking at an interface, and looking through public class methods. You can never be sure if the author made method public deliberately or simply by accident. Even if the author is yourself :) God knows how many hours of work I've saved by simply reusing my own old code - essentially be copying it from older projects, those I made a couple of years ago. It may not sound as cool as creating components, but IME it's the most efficient way of reusing code maybe once or twice. Interfaces are a tool to discipline yourself - you create a contract, you work on the details, now you sign it and stick to it. Of course in many cases utility components, with a bunch of public classes having understandable names, like "getThisAndThatFromX" "calcThisInTimeRange(from,to)" etc are enough, especially when they are strictly project-specific, but if I can distinguish some entity, especially an external one, that has some clear and concise logic in its work that can be described by contract - I use an interface. It's not a lot of work with modern IDEs, but it will make my life easier later when I try reading the code. It essentially helps me to understand what I was thinking of when writing the code - and, hopefully, helps others as well.
You make "should" sound as "must", and I simply disagree. You never know when an entity will change the details of implementation, and I prefer having a contract as an interface simply because I can look through the file history in VCS and see if it's changed or not, but if "contract" is your public methods, I'll have to look though all the changes and see if they ever touched the definition of public methods. Which will take much more time. 
Node is Java**Script**, not **Java**. They are completely different languages despite their similar names. You are in the wrong subreddit. /r/node is definitely the better option. **Removed**: Node &amp; JavaScript
&gt; You make "should" sound as "must" No, I said "are best for", as in best practices. You can obviously do whatever you want. &gt; You never know when an entity will change the details of implementation That's why classes have a public and private parts. &gt; I prefer having a contract as an interface simply because I can look through the file history in VCS I don't understand how this is a benefit of interfaces. You're either looking at whether the interface methods changed or the public methods changed. I've never found this to take a whole lot of time. On the other hand, I find that navigating a codebase with far too much (and unnecessary) indirection is really annoying.
_princple_ not _principal_.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think it depends on what your interface represents. If you've SOA and your interface represents a service, then there's nothing wrong calling it SomethingService. I like this naming because I immediately see in code completion what's what. The responsibility of this service is to send emails, you don't need to subdivide it to atoms (you'll end up with poltergeists and such). Most services in SOA are too specific (and I mean here real remote services) and it's usually counterproductive to invent an abstract universal interface (like MessagingService and then SMTPEmailService,ExchangeService etc), so it's common to just do an interface and interfaceimpl. But I'd drop the prefix I, that's probably C++ notation. For comments above - the usage of interfaces is historically because of "programm to interface" and "loose coupling is good" mantras and has very little to do with mocking, but turned out over time to be also useful for that. 
 &gt; Again, so long as you're consistent across your code, it's OK if the name doesn't tell you what you consider useful. Ahm, no? That is never okay. Naming something `ServiceImpl` is never okay, it could always be `SmtpEmailService`, `CompanyInternalEmailService` or if you have to `DefaultEmailService`. All of this tells me infinitely more about the class than `ServiceImpl`.
&gt; That's why classes have a public and private parts. They don't have "parts" - they have methods and attributes you have in a single file. That's why you use interface - to cover the private parts, pardon my pun. In this example, you have an EmailService. Something another person is working on. Why do you care whenever SMTP now supports another TLS version, or IMAP has implemented some GMail-specific stuff? You don't. As long as the interface remains the same, you don't. Now imagine yourself getting back to the project some time later and seeing the class had 40 commits since then. How do you know whenever the contract is still the same? &gt; You're either looking at whether the interface methods changed or the public methods changed. The file with the interface doesn't change unless the contract has changed. If someone committed the interface changes - it surely will get your attention, as opposed to browsing through the whole EmailService.java history with all the diffs to check whenever *your* code is still going to work the same way as it used to before.
I agree. Totally. Especially the interface bit.
The problem would be to differentiate between ‚Äúa start delimiter of n ticks with the raw string starting with a tick‚Äù vs ‚Äúa start delimiter of n+1 ticks‚Äù
TL:DR skipTests = will compile the tests but not run them maven.test.skip will neither compile nor run the tests.
Are you profiling your unit tests to see if the mocks are the bottlenecks?
Here is a typical use case. See OSGI container https://karaf.apache.org/man. The idea here is you have a container you can plug modules into. The goal of a Service is to provide bindings 'rest' for example, by implementing an interface that the container expects. This allows for numerous advantages not least, HOT reload. This idea has been around for a while and its evolving https://jaxenter.com/java-9-jigsaw-interview-colebourne-136795.html
&gt; Same thing for interfaces. DO NOT create an interface until you have a second class which does shares an "interface" with a first class. Strongly disagree. Waiting until you need an interface, then creating one, is a sure way to go through refactoring hell. You should ALWAYS code to abstractions (interfaces) rather than concrete implementations. Apart from the above example, it makes changing implementations much easier (see IoC) and assuming this service is a dependency in other parts of your application, you can now easily test those parts by creating implementations for testing. Reminder - always code to abstractions!
OP I suggest giving 'Head First Design Patterns' a read. It is a more palatable version of the GOF design patterns and goes through some great example of why (sometimes viewed) over-architecture can be useful.
The rule I follow is: "Only create an interface when you understand the behaviour you are trying to abstract" **Service** I think this is likely to be incorrect to use "Service" in the name of an interface because this indicates that you don't understand it's purpose. Perhaps "Service" has special meaning to your application and then it would make sense. Service is fine in the name of a class, especially when it implements multiple interfaces, for example. **I and Impl** I think this is always a mistake. I don't think "I" helps readability because the reader should not care whether a piece of code interacts with an interface or an implementation. They might care which implementation is being used when debugging a particular problem but the "I" doesn't help there. The "Impl" suggests that an interface has been extracted prematurely. Otherwise you should know how your implementation differs. An exception might be that you are writing a library and want to allow clients to customise an implementation but can't foreseen specifically how they will do so. In those cases, I have used "DefaultFoo" to implement "Foo" to make this clear and often come back and give a better name when I understand the ways in which implementations can vary. Bad example but best I can come up with on the fly: perhaps it is not clear at first that I should be a "DatabaseFoo" (all implementations end up talking to different data repositories and mine is used for any kind of database) or an "OracleFoo" (all implementations end up talking to databases but different ones) or "OracleDatabaseFoo" (a mix of both).
Mocking libraries are the code smell here (*and* they're slower), not interfaces. In the time wasted discussing this, everyone here could have created enough interfaces for ten projects. Interfaces define a clear public interfaces not bogged down in implementation code, they allow easy testing, they can be easier proxied (both in your own code and DI containers). 
It looks like in your [submission](https://www.reddit.com/r/java/comments/880zqt/is_lookupop_a_good_way_to_replace_a_single_rbg/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
OH. I completely misunderstood. 
&gt; Although some people prefer having pycharm, webstorm, etc as standalone apps. Yeah, that's me. I still find it is more effective to have each one installed and used appropriately. The menus and options provided are scoped to what you need rather than offering you a bunch of things that are outside the language you are working in.
&gt; That's the reason for creating interfaces. No, that's some people's reason. I just make it marginally extensible and realize that I don't have to make everything private.
Until someone comes across and says that's not useful enough. Useful is subjective and you'll bikeshed a code review all day arguing what is or isn't.
&gt; Reminder - always code to abstractions! utter nonesense
Disagree, we just made things "visible for testing" and just made it marginally extensible and made static inner classes or local classes in our tests cases. We try not to bloat our runtime API for testing reasons if we can.
Android says, we have the same API's for compatibility so we can make it easy to move your java to android!, but we have implemented our own vm, bytecode, storage format, because we had to because those are fucking IP. Wine is made to run windows software on linux. It doesn't allow something compiled for linux to run on windows, at least last I used it. 
&gt; Waiting until you need an interface, then creating one, is a sure way to go through refactoring hell. https://www.jetbrains.com/help/idea/extract-interface.html
It might affect software development in general. If api's suddenly are copyrightable it moves a very large thing that was free from copyright in under it and opens up new legal attack vectors against companies that they now have to defend against. It also makes sure that noone can reimplement a programming language and release under a free license for example.
&gt; BTW, in Java, we don't prefix interfaces with I. This boils down to personal preference. I find it useful to prefix interfaces with *I* so I know just by looking at the file name that the thing I‚Äôm looking at is an interface. Yes, this is something I picked up during a brief sojourn into C#, but it‚Äôs definitely a helpful practice IMHO - call it a quality of life thing. 
How so? I'd love to hear your thoughts on IoC, dependency injection, the strategy pattern, and of course, martin fowler?
&gt; This boils down to personal preference. I find it useful to prefix interfaces with I so I know just by looking at the file name that the thing I‚Äôm looking at is an interface. I'm not looking for this conversation for the 1,000,000th time, but long story short - you don't need to know if it's an interface, that's the point. Java's standard is no `I`. Of course specific teams might choose a different standard, that's fine, but doesn't change the fact 90% of the Java code out there doesn't use `I` and you'd be inconsistent with that code when it's intermingled with your code.
Sure this is fine if all your code lives in the same repository. What if your code is a library that is used by many applications though out your company (or the world?). Are you going to send them this link as well? It's important to remember investing a little time doing things the right way at the start can make your code drastically easier to work with when things change (which as we all know things change often!) Any monkey can write code that works, our goal is write code that the next guy (or girl) can read/understand/build upon.
Valid points that I agree with. Less code is definitely easier to understand than more code, and is something that we should keep in mind when building our applications. But that doesn't mean that squeezing your whole app into one unreadable line of Perl code is the right approach either, just gotta find a balance.
well yeah, except Perl :-) Perl is a WOL "Write once language" meaning maintaining perl should not be done. But the that is part of a larger point, unreadable code is unmaintainable code. So on this, I think we certainly agree. I think there are cases where abstraction increases understanding. There is something implicitly said when I run across an interface which is that there are expected to be multiple implementations. That does improve readability, because I'm watching out for those implementations.
I used it to do some real-time location tracking actually. Was super nice. Easy setup, easy usage, low cost and low maintenance.
I think the real power of firebase comes when you develop a serverless application for real world or just prototyping, because it exposes a real time database as a service that you can use right away on the frontend, also provides services to make it easy for authentication, user notification, access management... If your application is CRUD based, you can start testing without Spring boot...you might not need a backend afterall Otherwise, if you plan of having Spring boot, Firebase still a good choice 
i'm one of those people that this is useful for (i've forgotten the semantics of skipping tests a half dozen times) and i appreciate articles like this (as opposed to just a tweet) because the next time i need to remember this, the human element makes it easier to recall. or failing that, to google for a highly-voted tl;dr on reddit is the best of both worlds ! 
Well, of course, but making interfaces that only you will ever use with only one implementation is waste of time. 
If the code should be judged by usefulness, then there would be no need for that interface in the first place. :) `Impl` is just a sign of the interface redundancy.
Swing might have more 3rd party controls and GUI builders. But Javafx has far more inherent features than Swing. Swing allows you to easily put together old-style business app GUIs. Javafx allows for a much more modern-looking GUI. It sounds like you haven't even used it.
Since you bring up Fowler he doesn't like the service interface/service impl pair: https://martinfowler.com/bliki/InterfaceImplementationPair.html If an abstraction makes sense or is already available, sure code to it. But don't create unnecessary abstractions just so you can say you are following some "always code to abstractions" dogma.
I will, but trying to type punctuation on mobile is driving me to murder old ladies. When I get home tonight, I'll replace this text with an actual example!
Records?
[Data classes](http://cr.openjdk.java.net/~briangoetz/amber/datum.html).
Absolutely.
oooo well played. How do you handle testing where these non-interfaced implementations are dependencies?
I just use mocks generally.
Well your test is still way better than no test! Though you can't make it - for all I know - truely make it deterministic, that's the problem. You can increase the probability of it failing, but you'll never get a 100% probability (= deterministic). 
* [Facebook Infer RacerD](http://fbinfer.com/docs/racerd.html) * [vmlens](http://vmlens.com/) * FindBugs also has some checks
Uses whatever you like, I am just saying you do not need interfaces to test in isolation.
In past examples, I have seen the ability to add extra methods to the record. You‚Äôd just declare it in between the braces.
Yes, but equals()/hashCode() seem excluded from that: &gt; There's a good argument for making equals/hashCode final (so they can't be explicitly redeclared)
&gt; Android says, we have the same API's for compatibility so we can make it easy to move your java to android!, but we have implemented our own vm, bytecode, storage format, because we had to because those are fucking IP. that is not the case at all. openj9 is very much a thing that exists, and is capable of running standard bytecode. &gt; Wine is made to run windows software on linux. It doesn't allow something compiled for linux to run on windows, at least last I used it. it doesn't have to. it just has to make sure wine-compatible software is windows compatible too. winelib compiled programs are still windows compatible while gaining the ability to run on linux. do you understand now?
See [JDK-8159746](https://bugs.openjdk.java.net/browse/JDK-8159746) and the OpenJDK mailing list discussion that's linked from that bug. Briefly, supporting this use case seems like a fine idea, but doing so in a secure fashion is non-obvious.
Brian always has one of the most entertaining emails from the Java expert group. Like this: &gt;#### But people will make ASCII art `````````````````` `Yes, they might.` `````````````````` I really enjoy reading this guy's emails.
i'm sorry you just don't understand. no, android doesn't have to be one-way compatible with the jvm ecosystem. wine isn't in trouble cause making a program wine compatible doesn't make it unavailable to the windows community. the project would probably be in a lot of trouble if it only let you use windows libraries to make linux-only software. it's unfortunate android decided to leech off the java community like that and give back nothing in return
üòÖ
You're very confused, young man. Even the greats agree with me. https://martinfowler.com/articles/copyright-api.html
Goetz discussed possibly adding a way to tweak the definition of equals() without having to rewrite the whole method. You of course wouldn‚Äôt be able to do the latter if it was final, so we‚Äôll see what they come up with.
what a programmer says the law should be doesn't have a ton of bearing on what the law is. and the law is that apis are copyrightable. this ruling, the one you're hating on right now, did not make apis copyrightable. that was a seperate, earlier ruling, which the very article you linked mentions asking the supreme court to overturn! the supreme court never did, so apis have been copyrightable since 2014. so apparently you are extremely confused. now, what i was talking about is fair-use, which is in fact relevant to this case. the appeals court determined that google did not have a fair-use defense for their copyright infringement. you don't seem to understand what that means though and seem to have got copyright and fair-use mixed up. in any case, it's pretty sad that you post an appeal to authority to try to win an argument, and by doing so reveal how totally ignorant you are.
So all that stuff sounds great, but do the developer tools I use such as Intellj and Gradle support them?
That's not necessarily a problem. Customizing those methods violates the spirit of data classes being dumb carriers and starts encoding business logic. If you want to customize lookup key behaviors, you can always define a method that produces a different object (say, maybe a subset of the records fields) and use that type as the lookup "key". It's much less prone to accidental breaks when someone adds a field and makes the decision explicit instead of hiding that behavior inside of an override.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Intellij definitely does. No idea about Gradle, but I'm guessing it does. 
Why do people randomly capitalise names that aren't abbreviations?
Fixed, thanks
I've been using ratpack for ages with Java/Kotlin and it's really good, barebones simple web server. Love it. Pretty fast as well but I never had to profile that very agressive to be honest.. if you want fast fast stuff you would probably build something on top of ZeroMQ or barebones Netty.
This. Ratpack is great for HTTP APIs, but lacks (which is a plus in my view) the CRUDinessn of grails. Two tools for two different jobs.
&gt; Mostly because in C# they had to add an I to their interfaces since they are not able to understand if a class extends or implements something when it does; One'd argue that precisely because they don't have the distinction in keywords, they don't need the distinction in names. An interface is nothing but an abstract class that's entirely abstract. The only interesting difference is that multiple inheritance is allowed for interfaces, but not classes. Now think how often the distinction of multiple vs. single inheritance matters pops up, that you'd need it blatantly obvious all the time. I'd say not often when making implementations, and absolutely never when using implementations. The `IWhatever` convention is actually much older than C# at Microsoft. It comes from COM, where interfaces where much more distinct from classes than in any other platform. In COM you can *never* refer to a class directly, you can only refer to an interface. So a class is visible only as the collection of interfaces it implements. Naturally, this is not the way of doing things in any language, including Microsoft's most popular languages, but the naming stuck. And now many people copy that naming and retroactively have come up with different excuses why it's better, without knowing the real origin and purpose of the convention. 
Google will start asking you money after a while
What if you have EmailService interface and two implementations: one real and one used only in tests? EmailServiceImpl and EmailServiceMock/Stub/.. sound reasonable... 
Are records the same as value types? I need to go re-read the actual proposals, but if so - and they lack identity, then they wouldn't necessarily be a good fit for JPA anyway.
&gt; Backticks are barely accessible on the QWERTY, QWERTZ, AZERTY keyboards Huh? It's one button on my standard macOS keyboard. You don't even need a modifier key. And the backtick is a basic character used in many common programming and markup languages - LaTeX, Bash, Ruby, Perl. If you can't type it you're already doing to have a bad time programming.
Thanks for the replies, I appreciate your input. I feel the same way from what ive played with so far. Although ratpack wasnt terribly difficult to get a CRUD inplemtation up and running, just wasnt nearly as rapid as grails haha. 
I might have to give the Kotlin implementation a whirl. I havent taken much of an opportunity to play with Kotlin yet.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; JPA entities Why in the name of $DEITY would you want to use a record class as an entity? JPA has *way* too much state tracking, and records are primarily a dense data optimization. 
JAVA
Java noob here. I thought it was common practice to build .equals() for objects you need to compare?
It is, but with records you will get it for ‚Äúfree‚Äù.
Oracle's marketing team trying to jazz up a tiny set of API and VM changes, published as a PDF, mostly trying to drum up enthusiasm for releases that, under the new release cycle (one of the "features" mentioned), are guaranteed to underwhelm.
It's JVM, so it's same JAR. ratpack is implemented in java, but there are groovy bindings with a nice DSL I think.
i know almost nothing about it, but isn't firebase that service from google that one can use as a database, theoretically from anywhere, but it works best if used from an android app?
s/Finally/In a stupid attempt to pander to people who don't realise that java's verbosity is a feature not a bug and don't know how to use their IDEs/g
No, value types are a different concept - see Project Valhalla. Records are basically just syntactic sugar for DTO classes 
This is the poor man's CI. Tbh I'd be really annoyed by this, having to wait for committing, especially with that `sleep 20s` included... This starts encouraging rare and massive commits which is the opposite of what you'd really want, just allow people to commit often and use a real CI to check that in non-blocking manner.
Wow, the level of absurdity here is truly amazing.
Won't let you push if you done fuck up.
What kind of fuck up? 
This simply compiles the project and runs the tests locally whenever you try to git commit against your local repo. If the build or the tests fail the commit is cancelled and you have to fix it before you can commit. Why do this? It helps prevent against accidents that break the build by ensuring the build succeeds and tests pass for every commit. For example it can be easy to accidentally break the build by screwing up a merge, forgetting to change something when refactoring, etc... However there are better ways to accomplish this using what is called a continuous integration server (CI). This is a server that runs tests and ensures the project compiles before allowing the commit into the remote repo which is the source of truth. There are a number of different ways to set this up, but one is using GitHub pull request builds with something like Jenkins or Travis. The CI server spins up jobs and runs verification tasks automatically for every PR. If it fails you can block merging the PR until the tests are fixed. The ultimate goal here is to keep your build green and tests passing all the time. This means that at any given time your repository is in a relatively healthy state and in theory you could cut a release build from it at any point (although in practice this varies). Nobody wants to checkout code that doesn't compile. This helps dramatically when working on large projects in large teams. Hope that helps!
equals(Object) is usually used to compare the equality of the internal data of two objects (but *not always*, it‚Äôs implementation dependant) ==, when used to compare objects is strictly comparing the references. you can have two objects with the exact same internal data but an ‚Äò==‚Äò comparison will still return false if they aren‚Äôt pointing to the same reference
We use CI as well in work. But this doesn't prevent you to commit code that is for example not compiling. Because tou've done merge to master and not check build. As I wrote, when you do not want to wait, do not use it, or just skip tests with -n arg. 
It's a discussion on JVM internals so I don't really get why it was even posted here. 
There's two problems with that reasoning. First of all; it really isn't needed. Mockito can mock concrete classes just fine. So there is literally no direct need for interfaces. Secondly; this means that you're not creating interfaces because it makes sense for your model; you're creating them solely for testing. That's as much a code smell as giving methods default access just for testing.
Can you back that up with some numbers?
&gt; Mocking libraries are the code smell here Why? I think we established by now that DI is generally a good idea for unit testing. So that means you need to pass mocks to the units under test. Why not use a mocking library instead of doing it all by hand? I completely reject the notion that mocking libraries are a code smell. If you feel they are a code smell please give arguments as to why you feel that way. We might learn something from you :)
&gt; nd of fuck up? Pushing changes that won't compile on enviroment. For example.
&gt; Because tou've done merge to master and not check build. That is a people problem. If you cannot fix it with the team, then just follow the alternative approach: Only the build server ca merge to master. Everybody else is just creating branches and pull requests. The build server compiles each pull request against master and **only** if it compiles and unit test run **then** it is merged into master. 
&gt; However, it doesn't prevents me or other guys from pushing commit Don't allow developers to commit to master then. They should only create Pull requests. Make the build server the only account that can commit to master. That is the standard approach
Are you legit? The variable isn't immutable but the type is, and you can't go throwing them around without instantiating them. I really can't see what the big issue is - sometimes it will make code a bit harder to work out the type of a variable but sometimes it will make the code flow better. 
Cmon, many times when we merged good looking MRs on server some things like build failure or dependency clash happened. If you don't want to use pre-commit - do not use it. Simple.
Haven't you ever seen a declaration with redundant type information? Just because a feature has the potential to be used inappropriately doesn't mean it's totally without value.
Wouldn't be check if all the programs are compiling and running well before we push? Why do we need this? 
Nice PDF. The new JIT compiler, the parallel GC and link-time optimisations are complex technical work. I have to try jlink with the Docker image creation.
Most concise and effective description of the complexity and power of C++ I've seen. Two-edged sword
Yeah those fucking stupid java/c# language architects don't know shit. You know better, for sure, who wants an option to reduce unnecessary text - not me.
Exactly - and if it's inappropriate in a certain circumstance, one doesn't _need_ to use `var`.
Yep. 
No, never /s Yes, fine: final var textString = getTextAsString(); But if you are putting type in the name you are an idiot so why not indicate the type somewhere else on the line maybe... final String text = getText(); Or something, I don't know. This is clearly going to result in: var thing = getThing(); Brilliant. Why have 1 perfectly good way to do a thing when you can have 1 way that is good and one way that will lead to harder to grok code. As if specifying the type ever causes trouble. If it is hard get better keyboard or IDE. 
I am aware of the semantics of every keyword I used. 
Thanks! I saw it on Twitter and thought I would share.
The more different ways to structure code the slower it is to grok especially if you hide important information behind an irritating keyword. A gun that fires backwards every 7th shot is occasionally helpful... We'll just count the shots in code review. 
Sure, I don't think that fixing it would be obvious. Thanks for linking to the issue.
Sounds like old VB/.asp
As I wrote, we are only humans and we tendency to forgot to do something. 
I didn't know about COM, thanks for sharing this! Anyway I read IWhatever in an article about C#, but I'm wondering about your statement on abstract classes and interfaces. Interface in Java was introduced because of Objective C and its Protocol (someone in Reddit recalled this once) and I don't know it can be simply or just related to a full-[stateless]-abstract-class, but I think it depends on how you actually "play" with them. 
This^ Also, if people are concerned about "broken" commits - you can always squash them into more recent "healthy" ones.
Yes, and protocols in Objective-C exist for the same reason, to allow multiple inheritance, [quote](https://en.wikipedia.org/wiki/Objective-C#Protocols): &gt; Objective-C was extended at NeXT to introduce the concept of multiple inheritance of specification, but not implementation, through the introduction of protocols. The language could simply allow multiple-inheritance if a class is fully abstract, but that would cause frustration: you go to your abstract class, add an implemented method, now 20 other classes break, because they inherit this class and another class, and suddenly that's not permitted. By introducing interfaces/protocols it's more immediately clear where you dun goofed up, instead of the error appearing in a bunch of other files.
I'm not sure that is okay because: 1) It's much easier to create a mock/stub with Mockito than it is to manually mock or stub out your entire class 2) It's much easier to vary the behaviour of your mocks/stubs with Mockito than it is with manual mocks/stubs 3) It's much easier to verify behaviour with Mockito, than it is with manual mock/stubs. 4) Your production code now has an artifact (the interface) that is only there to support tests. If the only purpose of the interface is for testing, then try calling it TestFoo or FooForTest and see how much you like your code base. That is what I see in my head when I deal with production code that has interfaces only to support testing. 5) You might need a proper interface, e.g. to hide a public method, and the one you have created for testing is now a confusing artifact.
I prefer `Client` if I want to make that clear to consumers. Each to their own but I've seen `Service` used for so many different reasons that this specific meaning would be lost on me.
&gt; we tendency Like forgetting to write "have". 
Thankfully all senior developers agree with you, which means one more generation of blissful and informational verbosity before the juniors get promoted to architect and ensue chaos.
&gt; Why in the name of $DEITY would you want to use a record class as an entity? Why wouldn't I? Records promise to resolve some of the issues we hear about entities, being too verbose, too much ceremony with getters, setters etc. &gt; JPA has way too much state tracking What has state tracking to do with this? That's done in the persistence context, and also if you're using bytecode enhancement to push tracking into entites themselves (Hibernate has an option for this), I don't see how this speaks against using records as entities. &gt; , and records are primarily a dense data optimization. Are you perhaps mixing up records with value types?
Haven't you ever done "find usages" when you want to refactor code? "var" references are not found. Write a class, have a method return an instance. Have another class that calls that method with "var" then find usages. 
Nonsense there's no reason a good IDE couldn't still detect that usage. Visual Studio doesn't do it for C# apparently, but that's because it's shit.
You use a Map.
Is that perhaps a teething problem, or is it something that in principle our tools will never be able to address?
I'm just pointing out current reality. Something you clearly have a problem with. 
I created a bug in intellij for it. It should be fixable but until then, I'm banning the usage of var for my team. 
You clearly don't understand what this change is for and you most likely didn't read the article either
So we should just never chain ANY calls then and not use ANY (existing) type inferencing? ```java Map&lt;String,String&gt; map = someFunction(); List&lt;String&gt; list = map.values(); Stream&lt;String&gt; stream = list.stream(); stream = list.filter(s -&gt; s.length() &gt; 5); Stream&lt;Integer&gt; stream2 = stream.map(String::length); Integer max = stream2.max(); ``` So much more readable :)
Records are DTOs in JPA speak, which are underused by JPA users.
&gt; Records are basically just syntactic sugar for DTO classes Although, it is often not unreasonable to say a DTO is really a fancy value.
Nice argument... 
Stupid shit.
Why did you switch to 10 in the first place?
To keep up with the latest tech maybe?
The JVM is certainly related to The Java Programming Language. I thought some might find Rose‚Äôs thoughts interesting. They are from the Hotspot mailing list.
Listen, if you don‚Äôt know your code, you are in Deep Shit already and you can declare your variables however you want - it is not going to make sense to you any way. PS - you can‚Äôt have a rule of thumb if you‚Äôve no experience using the feature - Java 10 is out what? 1 month? I doubt anyone has enough experience with using var in big enough Java projects to have formed any kind of informed rules around using that feature. Leave it be. Use it. Abuse it. And then you will know when it makes sense and when it does not. 
I'm just pointing out that it doesn't have to be. "IDE support won't immediately be perfect but there's no reason to expect it won't be improved soon" is a pretty terrible argument against a new language feature.
&gt; Listen, if you don‚Äôt know your code, you are in Deep Shit already and Ever worked on large projects? You can know your code but you don't know the code of others. It's always great to start working at a new place and be greeted with a few million lines of spaghetti code built over 20 years from more than 300 people. &gt; PS - you can‚Äôt have a rule of thumb if you‚Äôve no experience using the feature Really? You can see from the example itself that var shit = fart(); Is obscure and you can't know the type of `shit`. Fart shit = fart(); Now you know that what you thought was `Shit` is just a `Fart`. I.e. no `var` if there's no `new` on the right side of the assignment. 
Behold, the "all senior developers" Overmind has spoken!
var introduced in C# in 2007. Visual Shitio still can't find usages. 
That's missing the point. First, it adds verbosity again (which records set out to reduce): I'd have to declare (and instantiate) two types instead of one. But even If I was convinced to do that, there's no way to prevent that I (or someone else in the team) put the types into a set later on, in which case equality would not be what's expected.
I have not much experience with these non-servlet based web frameworks. But what are the strength of ratpack compared to Dropwizard, Vert.x or Spark?
It would be exactly what was expected, because it would use the only reasonable definition of equality for a data carrier and not custom logic that breaks the next time a field is added to the class.
Just pointing out that the usages are local variable declarations only, so usages will all be in the same method
Hahaha
You can make that baseless accusation if you like.
Your strawman is is made or false equivalence. 
Oh No, it's this guy again who desperately needs to hate against this feature in every single thread, god save us from these futuretelling pessimists, the c# people laugh at us for a decade now, happily using this feature, knowing better then them.
Okay? Who gives a shit about their failures, no reason we have to suffer the same.
Since you won't stop shouting out your opinion that is solely based on your very limited experience and your theoretical view based on out-of-context examples, i have to say it again and again: literally every other language does really well with this feature, but of course... YOU alone are right, because you have that much more experience and knowledge than aaaaalll the others. Not.
&gt; So that means you need to pass mocks to the units under test. No, It means I might inject alternative implementations of my interfaces which might be elaborate mocks or might be simpler. You don't necessarily need interfaces everywhere of course, just at the appropriate test boundaries. You don't put interfaces on all kinds of classes, mostly services, repositories etc. Mocks feel like a crutch for not using interfaces. They're usually more work to set up then it is to do a naive interface implementation.
Why is an integer addition faster than a square root? It's just that they're doing different things. In the case of mocks is using interfaces for what they're their for, with next to no overhead, and mocks that use elaborate proxying techniques to achieve the same -- with considerable overhead. Performance is a nice side effect here. The main argument is architectural / cleanliless.
Just a friendly reminder that you are arguing about methods used to declare a variable in a programming language. Arguing that the implementation of var introduces a variety of downsides is as legitimate as praising the ease of implicit declaration.
No, because they're talking about C\+\+, not Java. Just because they're talking about the JVM doesn't mean it has any relation to Java. They could be talking about any software written in C\+\+.
TL;DR? Naming becomes more important when using \`var\`.
Looks like people missed your sarcasm. 
I fail to see why equality for a "data carrier" should exclusively be defined by all its components. A row in a table of an RDBMS also is a "data carrier" and clearly we don't accept equality based on all row values as the only way to consider two rows equal. Instead, we often use business keys comprising a subset of the columns or surrogate keys. It depends on the specific use case which equality definition makes most sense, and I think the same flexibility should be at our disposal for record types. Adding columns may or not may affect the definition of equality (e.g. it usually won't when using surrogate keys), so this doesn't automatically break logic. What's reasonable for you and your use cases may not be reasonable for others.
Exactly. 
&gt; Because you've done merge to master This is the major problem here. Don't commit to master. Most decent CI servers will build all branches they find, merge in `master` and then build it. If it fails, you have to go back and fix it. (I vaguely recall a year ago Jenkins wouldn't rebuild all branches after a merge, so it was possible to merge broken branches. That would require diligence from the code reviewer/merger.)
Code review is gonna happen anyway. 30 seconds to comment "this use var is minds hard to read", and then they learn. You'd think Oracle pushed your kid off a bridge by how pissed you seem. No need to be such a drama queen. I can almost guarantee you that this won't affect your life in any substantial way.
Yes, that's the interesting question: can they *only* be used as DTOs in terms of JPA, or could we also use them as entities? That said, I'm not even sure whether records can have annotations, didn't see that in the examples.
Exactly. Java's extremely obvious typing is one of its major draws for me. It's always painful going back to reading a source file in dynamic languages and having to all around through three functions to find out what type something is.
Using `var` doesn't make you code dynamically typed.
I don't usually browse this sub and people seem really unreasonably uptight about this
Yeah, every time I use dynamic languages I want to slam my head against the keyboard. Each to their own but I strongly prefer static typing and Id like for java to remain that way.
OK well I posted a bug - I guess we'll see.....
Apparently the new release cycle is already overwhelming the Java community if you read the comment sections.
WHOOSH. 
You know it's bad when people start naming variables herpString and derpInt...which some of the comments in this thread seem to imply is a good idea. If you feel that "naming your variables to make the type obvious" is the answer, you've already missed half the point of static typing...
But it doesn't. You won't be able to assign value of different type to the variable and you won't be able to call methods not defined in the type of the variable. Also, you won't be able to pass the variable to method that asks for different type. Sounds like it still statically typed.
Sure, agreed, the compiler will ~at least~catch these things. However, code is for people and not compilers. 
&gt; I use java BECAUSE it's statically typed. If I wanted headaches then I'd choose something else. Lots of inaccurate FUD... `var` is not dynamic in Java. It's exactly as static as declaring the type by hand.
Guess what. Words have meanings.
And because code is for people we're getting powerful tool to reduce some cluttering *where it makes sense to do so*. It is as easy to write code in Java right now that will be more ambigous than `var` declaration, see anonymous classes (at least they will be somewhat usable with `var`!)
He's not alone. I also have the same opinion. For instance, we could go further: why should we have type declaration when they can be deduced? The compiler also knows when a variable has not been defined, so there could have no problem Some languages are not typed. Personnally I think this is a bad idea. In addition, "var" is just syntactic sugar, useless with IDE. So, it is just a matter of choice. You love it, some other people not. 
All good points, altho we ourselves cannot give precise typing since we can only infer based on what we know - which may be interface based, so by definition not precise. But that's just playing pedantry.
Stupid ass comment.
Whatever, firstly code is about readability, secondly if you want this feature then there is a pallet of other languages to choose from. 
Scala has been using vars for almost a decade and Java had a long time to learn. So I don't understand by what logic they didn't include **val** (== final var) too... It's almost like they deliberately try to ignore every experience that other languages gathered 
Its not static either.
Standard macOS keyboard for the UK. The standard macOS US keyboard has the button in the same place, but it works in the same way, no need for a modifier.
Thanks for nothing
You say it reduces cluttering, I think it reduces readability if I have to go through extra hoops to find out the type (if it isn't obvious from a method name for example), just because IDEs autocompleting the type is not enough for people. I really can't see any worth in the var keyword, but I guess I'll have to live with it. It is nothing to get worked up about, and I understand even less why people jump at each other's throats just because they have different opinions on this. 
Nope, use it everywhere except for primitive types. If you cant tell the type of the variable with the method name, its a sign that your method is named poorly and it is a good time to do some refactoring and renaming. Also in most of the time, the type of a local variable is hardly even important, you are supposed to pay attention to what you should actually focus on instead. If it is actually important, then it wont hurt to hover your mouse on the variable name, takes only 1-2 secs to show the type of the variable. 
The amount of people here saying `var` somehow makes Java becomes less statically typed shows why even though I enjoy writing Java code, I don't identify myself as one. The blub is strong in this crowd. 
I too don't understand why people are so worked up about it, when the real thing (I think) it is trying to solve is magical generic fiesta when using functional APIs (like Stream API) and seems like a logical step forward from diamond operator. Was there as much backlash to those features too?
The type information at declaration is mostly not where you need it, you will need it when using the var, and that's often outside of your visual scope. So you do check the type via your IDEs features. So I will call your argument shit.
Yeah, got better things to do than to benchmark other people's smelly code habits. I told you the reasoning, I googled for some quick benchmarks other people might have done, but they all, rightfully in a way, focus on the [negligible overhead of proxied method calls](https://spring.io/blog/2007/07/19/debunking-myths-proxies-impact-performance/). The overhead in this case is the startup phase of a program / test. An interface implementation cost basically nothing while the creation of cglib/javassist whatever proxies is rather costly in comparison. For testing this is even worse than it is for e.g. Spring. A few seconds of difference in startup don't matter much for a server application, but they can be rather annoying for short running tests.
The whole point is that you're not going to notice the difference, at all. The difference is a few milliseconds for your entire test suite. So your comment about performance is nonsense. But let's end it at this, as you obviously have better things to do :)
I understand your viewpoint, but I think this feature still has value. One value I see specifically is a new argument in my on-going struggle to get my co-workers to reconsider Java for new projects. I agree that the verbosity is a feature, but not everyone sees it like that, especially those without much experience in Java. They see the verbosity and write it off as an old language that made things way harder then they needed to be. Java is great, the tools for Web have greatly improved. JAX-RS is wonderful, it's not like the old jsp and soap days, but many have written off Jav all together and won't consider it again. If changes like this can bring people back to Java, I'm 100% on board. And like you say, linting tools will probably allow those who hate this features to disable them all together. Win-win in my book
This is not true. var is an "inferred" type and has a number of subtleties especially around upper type bounds, more detail in the JEP: http://openjdk.java.net/jeps/286
The thing that's surprised me about all this is that people are actually typing their variable definitions! The answer to people who don't like the idea of "var" all over their code is "use an IDE", but I use the IDE to enter the type in the first place. Super easy and leaves readable code for the next person. For example, in Idea after typing something like "new ArrayList&lt;String&gt;()" just hit Option-Cmd-V and you're done. Full type details entered for all who follow.
You should use jcstress, and you can‚Äôt achieve determinism. Read about the approach here: https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/
I feel like this sort of feature made a lot more sense in C++, where the "problem" you were avoiding was overly-long type names resulting from how generics are handled in that language. Like, in Java, if you need the direct Iterator from a Collection, it's easy to acquire: ArrayList&lt;Integer&gt; list = getListOfNaturalNumbers(); Iterator&lt;Integer&gt; listIterator = list.iterator(); var listIterator = list.iterator(); Compare that with an equivalent example in C++: std::vector&lt;int&gt; vector = getVectorOfNaturalNumbers(); std::vector&lt;int&gt;::iterator vectorIterator = vector.begin(); auto vectorIterator = vector.begin(); I think it's a good feature overall, even knowing that it's usefulness is going to depend on programmers not abusing it (`var x = list.get(0).convertUpstream(3).get(4).asArray()[199];`). Though to be fair, if you've written code that looks like that, adding the static type declaration wasn't going to save you.
Most other statically typed languages have had implicit typing for 7+ years now and I've never seen this "hungarian" typing with basic types you describe happen in real code. It does save you a few characters which encourages you to be descriptive with custom types. Things like MessageService service = getMessageService(); service.Send("Hello"); might become var messageService = getMessageService(); messageService.Send("Hello") So the theory is more information goes into the variable name. But it's a pretty subtle effect. The place where it really saves time is the hopefully non-controversial: LongAssTypeName latn = new LongAssTypeName(); becomes //even without a better variable name this is better var latn = new LongAssTypeName(); If nothing else, I think this feature makes whiteboard interviews in Java just a little bit nicer
It was the same BS when lambdas came out. Most java devs are afraid to change. I‚Äôve never seen in other communities such pride as saying ‚ÄúI‚Äôm still on java 1.5‚Äù as you do with java. Var has been around in lots of languages for decades. Look at c# as a good java analogy case study. The .net community loves it, and their code is even stronger typed than java. Scala has a val/var, Haskell does type inference, f#, ocaml, even typescript. Java was like the last language to get this anyone who is worried their code is going to devolve into an unreadable mess probably has already done so and var won‚Äôt make a difference :p
From their [own style guidelines](http://openjdk.java.net/projects/amber/LVTIstyle.html): &gt; P3. Code readability shouldn't depend on IDEs If you need to rely on more IDE features to reason about your code you are not writing something that is easy to understand by itself. It can be a small annoyance but nothing too bad. Not sure why people are getting so uppity about it as if `var` is "perfect" and no criticism can be raised. It's a tool. Use when it makes sense. There are minor benefits and minor drawbacks. My suggestion works to try to avoid the drawbacks. That's all.
I think shit happens
Bullshit everywhere in this entire thread. In C# var is both strongly and statically typed, and the IDE has been able to find usages ever since the language feature was first introduced. On the JVM side, IDEA has been able to find usages in all languages with this feature, also forever. Learn your tools, folks.
I believe the feature you're referring to is currently an open bug, and it's been designed this way due to limitations in Java's type system. In most cases, the variable is exactly the type you expect. In the case of captures variables, it may end up the implied supertype. In that case it's still static, you just don't have access to any features of the specific type in the capture scope. It'd be less static if you were allowed to run blindly methods the type doesn't specify and resolve this during execution.
&gt; One important thing to know is that even though var looks like a keyword, it's not really a keyword. Instead, it is a reserved type name. This means that code that uses var as a variable, method, or package name will not be affected. &gt; Another thing to note is that code that uses var as a class or interface name will be affected by this Java 10 change, but as the JEP says, these names are rare in practice, since they violate usual naming conventions. 
Usage and style recommendations for `var`: http://openjdk.java.net/projects/amber/LVTIstyle.html
It doesn't really prevent other people from committing broken code because it only helps if they also use the hooks, which they might not much more likely. The real real way to deal with it is to make sure CI always does that.
Congratulations for reposting the same article that Lukas posted himself [two days ago](https://www.reddit.com/r/java/comments/87qyod/correct_reflective_access_to_interface_default/). Then again, you're a reposting spam account, so there's that.
Absolutely nothing because `var` isn't a keyword, but a reserved type name. That means you can validly have: var var = new Shit(); But if you have a variable called `var` you probably want to rethink a few things in your life.
I guess you could find some examples where var might be better, but I haven‚Äôt really heard that as the argument in favor of it. It‚Äôs mostly people not wanting to type and are fine with lower code readability as a trade off. 
But statically typed languages require you to define the type of variable?
Well, you can always disable the test task...
Both would be awesome. Thanks for doing the doc readin for me!
Good catch!
It is defined. Mouse over var and you'll see the definition. It's just shorthand. It's no different than writing out the entire definition. 
OP, should you ever be caught reposting an article within a quite short timeframe, it will be the end of your stay here. So far, most of your interaction with the subreddit has been through posting links and hardly through *active participation*. From this point of view you should read [**What constitutes spam? Am I a spammer?**](https://reddit.zendesk.com/hc/en-us/articles/204536499-What-constitutes-spam-Am-I-a-spammer-) and reconsider your participation. We don't want *content spammers*, we want *active participants*.
I don't know why people just comment and don't actually try it. Steps: New project New class : Customer New class : CustomerService in CustomerService add a method to return a new Customer IN Main class Customer cust = CustomerService.getCustomer(); GO TO CUSTOMER CLASS AND FIND USAGES of Customer. YOU WILL FIND THE USAGE IN MAIN - **YAY** In Main change the line to var cust = CustomerService.getCustomer(); FIND USAGE AGAIN. THIS LINE IS NOT FOUND ANYMORE - **:(** GET IT? This also is the same in Visual Shitio. It does not find Type references from lines that use "var" So in a bigger project where you may have many methods which return Customer (for example), NONE of the CALLS to those methods would be found making refactoring more difficult. 
I really hope they add val before release. var is nowhere near as useful as val.
I'm aware of default methods. I'm deliberately not getting into these details, because I trust the other person is on the same page as I am. Unlike you. And what the heck means "once again you're wrong". What else am I wrong about?
Maybe I wasn't clear. The builds server is not testing PRs on its own. Its testing PRs with master merged. 1. Somebody commits a PR 2. Build server checkout out the PR and **merges** it locally into master 3. If compilation succeeds **then** it just pushes master (which is now updated with the PR contents* So the master is always guaranteed to compile correctly
The fact is if it's standard at your company then it's the standard, regardless what Oracle suggests.
I must admit, I haven't seen a technical whitepaper with stock photography yet :-)
&gt; or could we also use them as entities Like `enum`, a `record` should have a well-defined, expected behaviour. Overriding equals and hashCode would be surprising in my opinion, given that the idea of not having to implement equals and hashCode is kinda the main purpose of a `record`... &gt; That said, I'm not even sure whether records can have annotations, didn't see that in the examples. I'm sure they should be able to have `@Deprecated` annotations, for example, so I guess all annotations should be allowed.
Go read [the last paragraph of what I said here](https://www.reddit.com/r/java/comments/87ufga/is_service_an_antipattern/dwh4lrd/) and then if you feel like you, you can come apologize for your white noise.
Yeah nah, whatever works for you man. Be happy.
Just capture your `var` in a lambda to make it effectively final.
I'm uptight about it because I believe it makes Java worse. Change is not always good. Sometimes it is, but this is a bad change. I've worked with code that used var/val and it was harder to read and reason about than code that didn't. You can say that was the fault of the code's authors. I don't agree. The same quality of code was easier to read in Java vs. code written in a var-supporting language. And since there is so little benefit to var (none of you use an IDE), I believe it's not worth it. It's my opinion, and you have yours, but that's why I'm uptight about it, and I don't think it's unreasonable.
So, by your logic a language such as Standard ML is not strongly and statically typed? You rarely have to explicitly specify the type of something, because it can automatically infer most types. fun factorial n = if n = 0 then 1 else n * factorial (n - 1) That's a random example of SML from Wikipedia. You never explicitly specify the type. It simply infers it, and if you try something insane, the compiler will not allow it. Yet Standard ML is both statically and strongly typed. 
You're too stupid for reality. 
Keep up and then reject it?
It‚Äôs the reason that the implemetors gave for adding it. Whether or not that‚Äôs what it will be used for remains to be seen.
 SuperDuperLongTypeNameWithLotsOfNuance widget = new SuperDuperLongTypeNameWithLotsOfNuance(); var widget = new SuperDuperLongTypeNameWithLotsOfNuance(); How can anyone honestly that the former is clearer than the latter? The problem with the first one is that I am left with a ton of doubt about whether the two types even match. Are they identical? Is one a child class of the other? Is the left side an interface? It's hard to capture that at a glance. Meanwhile, the latter is much shorter and abundantly clear: only the type on the right side matters. I can see `var` and _immediately_ know that the type on the right is the sole source of truth for that declaration.
As opposed to: FancyComponent component = new FancyComponent(); And this is only for local variables, right? Class level still the traditional declaration? 
Well it's not like there was no discussion about it. Iirc they also considered let for it. I disagree with their decision too but they weren't oblivious to other languages.
It's already released.
Correct.
Correct
It's not less static. It's just less explicit. Type inference is a static language feature
How's it different from a regular sql or nosql database? I've been reading through the docs and it's just a nosql saas?
Have you ever encountered code that abused the conditional operator? I know I have. Does that mean it shouldn't have been added to the language? Haven't you also seen code that was improved by the conditional operator?
&gt; Only the build server can merge to master. Everybody else is just creating branches and pull requests. This. Also, nobody can push commits directly to master. Push/merge are different. It's easy to set up, it's something everyone can agree on. Nearly every server has a way to make sure the CI was successful before allowing a PR merge. 
&gt; Jenkins wouldn't rebuild all branches after a merge Jenkins really shouldn't do that. The downstream (branch) projects should pull from upstream when they're ready. Are you rebasing all your branches after you merge to master? 
You mean something like the *ternary if*? There's a small number of cases where that can condense verbose code, but most of the time it's not so great.
I am amazed to see how many features Scala have that Java misses or had it a long time before Java. It already exists in Scala and you can write many classes and modules, aka singletons in the same file and run it in the same way as a Python script or compile it to a single jar. Then, the generated jar can be turned into a single uber jar, aka executable jar, by bundling it with scala runtime jar library. For instance, # Run scal script $ scala -save script1.scala # Compile scala program $ scalac app1.scala -d app1.jar -cp lib1.jar:lib2.jar:... # Run scala program $ scala app1.jar 
Eh, I think it's a real possibility, with an interop/rosetta layer for a while. 
AND Visual Shitio has not worked since VAR was introduced in 2007. 11 YEARS AGO. FAIL. Same problem with Eclipse and Netbeans. 
Android doesn't use the JVM. 
Fucktard. Is that the only feature in Java 10? Are you that retarded? 
`final var x = 10;`
Haha, I just copied the title off of the tweet!
can you share a gist of that? I don't quite understand how that would work
https://github.com/MicroUtils/kotlin-logging
var x = 10.0
who is claiming that? 
you colossal retard. if your ide isn't shit, its maintaining an AST and knows the types of `var` and can find it just fine. Have you actually pulled down java 10 and verified this behaviour on your own? 
seriously... these people must code in notepad or something.
&gt; guaranteed to underwhelm in some sense, this is intentional... at least from the dev team's angle. personally i think it's a great thing.
whiners from kotlin/scala/python get to type slightly less in Java now. 
If you think `var` makes things dynamically typed, you don't understand anything he mentioned, and you'd do well to heed his advice. 
There are lots of issues that can arise from object equality as it can mean identity equality, reference equality comparing if object memory locations or references are the same or structural equality comparing if object fields or state are the same. In Java, JVM based languages and other languages as well, if structural equality is needed, the method hashCode needs be overridden what is tricky because this method is used by hash map collections and sets collections to check if an object is already the collection or add it to the collection only once without repetition. This page by Martin Odersky, explains in great detail the object equality problem: https://www.artima.com/pins1ed/object-equality.html. I guess that a better solution would be using a custom operator or method for structural equality such as === or "sEquals" objec1.sEquals(object2) or objec1 === object2 instead of overriding the equals method. This other pages explains those issues focused on Java: - https://www.javacodegeeks.com/2016/03/equality-vs-identity.html - http://javarevisited.blogspot.com.br/2015/01/why-override-equals-hashcode-or-tostring-java.html 
ugh... `lpsz` gives me conniptions. 
Python definitely has a divide like this between Python 2 and 3. The world is slowly migrating to 3, but only as common libraries stop updating their Python 2 variants. 2 is still the default on most systems if you just run ‚Äúpython‚Äù though.
they will when the ide/compiler tells them about unchecked casts. 
Agreed. 
&gt; It‚Äôs mostly people not wanting to type ...really? doesn't match what i've seen.
wrt to type systems, "static" means the variable type does not change at runtime.
in this thread: https://www.reddit.com/r/java/comments/887po1/finally_java_10_has_var_to_declare_local/dwiyvx9/ it has happened in most of the threads where var is mentioned.
Nobody is forcing you or your team or your company to use it, but having gone from Java to C# and back to Java, I can honestly say that I can't wait to get Java 10 semantics as part of our compiler chain. var is by far the thing I miss most from C# and a close second would be refied generics/value types which are also coming to Java.
It does not matter if they match and if they do not it is significant. For example the author might want to restrict to an interface or super class to maintain extensibility. To be honest I am not hugely offended by var with a new on the rhs as it is clear but allowing it with a method call on the right is really nasty. final var foo = getThing(); What the hell type is foo? If the answer is not to push it into the names, that is ridiculous. I just don't see the point of polluting the code structure with a different way of declaring a variable for no benefit except to support people still working on 80 character terminals or who still haven't learned to use auto completion.
&gt; Not sure why people are getting so uppity about it as if var is "perfect" and no criticism can be raised. in my experience most criticisms tend to be comically bad, almost to the point that it seems like trolling. and trolling makes the web go 'round.
If I wanted to read and write hard to grok code I'd be using node.js
I always wonder how people in other languages name their class names. I mean, it always seems so funny to them that "we in Java" use somewhat longer names, but how do they avoid collisions then? Do they name everything like Crt1, Crt2, EM9, EtR, etc?
Isn‚Äôt it fantastic how Spring advertisements I mean articles never mention Java EE?
Yeah, that is often the case but I don't agree that it always is and why force it when the language makes you state the type when naming a competent of your model you have just got? Giving test type at worst increases clarity and gives you a very quick way to jump to the type declaration. 
If you have to put type information in you names everyone looses. 
Seriously, you have clearly never worked on a big codebase or had to grok a medium one. 
I don't know if that really justifies introducing a whole new way to do something. 
Rust plugin is also broken at this version.
But you could also stretch your argument in the other direction: we should reintroduce `goto` because there exist cases where it can objectively make code better. Yeah sure it can also lead to hard to follow code, but so can the ternary if or some other language function you like. I'm not against `val`/`var` though, not at all, but adding a new feature is always a careful balancing act.
I agree with you, it's important to weigh the pros and cons. The issue is that a lot of people in this thread and elsewhere don't seem to be thinking in those terms. Over and over I'm basically just seeing, "It's possible to write bad code using local-variable type inference, therefore Java shouldn't have local-variable type inference."
I feel the cons outway the pros of having the var keyword. Look at these gotchas. G5. Don't worry too much about "programming to the interface" with local variables. A common idiom in Java programming is to construct an instance of a concrete type but to assign it to a variable of an interface type. This binds the code to the abstraction instead of the implementation, which preserves flexibility during future maintenance of the code. For example: // ORIGINAL List&lt;String&gt; list = new ArrayList&lt;&gt;(); If var is used, however, the concrete type is inferred instead of the interface: // Inferred type of list is ArrayList&lt;String&gt;. var list = new ArrayList&lt;String&gt;(); G6. Take care when using var with diamond or generic methods. Both var and the "diamond" feature allow you to omit explicit type information when it can be derived from information already present. Can you use both in the same declaration? Consider the following: PriorityQueue&lt;Item&gt; itemQueue = new PriorityQueue&lt;Item&gt;(); This can be rewritten using either diamond or var, without losing type information: // OK: both declare variables of type PriorityQueue&lt;Item&gt; PriorityQueue&lt;Item&gt; itemQueue = new PriorityQueue&lt;&gt;(); var itemQueue = new PriorityQueue&lt;Item&gt;(); It is legal to use both var and diamond, but the inferred type will change: // DANGEROUS: infers as PriorityQueue&lt;Object&gt; var itemQueue = new PriorityQueue&lt;&gt;(); // DANGEROUS: infers as List&lt;Object&gt; var list = List.of(); G7. Take care when using var with literals. // ORIGINAL byte flags = 0; short mask = 0x7fff; long base = 17; // DANGEROUS: all infer as int var flags = 0; var mask = 0x7fff; var base = 17;
But that's not a dumb data carrier it's a row in a table. It has extra semantics defined by its context within a larger and more complex structure of data, that's what's causing the whole problem. And if the type of equality you want to use over the data depends on the particular use of the data then polymorphism is a shitty way to encode that anyway, clearly the mechanism for testing equality should be external to the type.
I use the language 8 hours a day. I think this is a damaging change that fundamentally alters the premise of the language. I can have and state this opinion and I can tell you to fuck off for belittling it. 
While I don't agree personally, having come from languages which are quite well off with inferred locals, I definitely respect the passion you have for wanting to have a better language, and it's good to have conversations like this.
All of the cool kids are using TypeScript anyway /s
I totally agree. That's what I mean- given a 6 month release cycle we won't see a "lambdas level" runtime or language change show up very often. I don't want to call it a good or bad thing, I'm just saying it's a natural consequence.
Technically `HashSet&lt;Object&gt;` is not the same as `HashSet`, see [here.](https://stackoverflow.com/a/7360664/3000387) 
I am late in the party, but here it goes. There are many options: - For all OSes, if the application is single Uber jar, it can be distributed just as it is, the end-user can execute by double clicking at the application or by running $ java -jar application.jar. The disadvantage of this method is that it assumes that java is already installed and that the user knows how to install Java and how to run a java uber jar. The benefit is that, it requires no installation just click and run. It is a portable app by default. More info - https://www.javacodegeeks.com/2012/11/packing-your-java-application-as-one-or-fat-jar.html - On Unix-like (Linux, MacOSX and other variants) for command line apps you can embed into a shell script. This method allows running java applications as ./application arg0 arg1 .... as an ordinary Unix app. - For more info see: https://coderwall.com/p/ssuaxa/how-to-make-a-jar-file-linux-executable - On Unix, you can use a shell script to run the application. ./application.sh arg0 arg1 the shell script can contain: #!/usr/bin/env sh java -Dprop1=val1 -Dprop2=val2 "$@" -jar ./app1-uber.jar - On Mac OSX, a dekstop app is just a directory with name ending at .app with special directory structure, to install the application the user has just to drag the application.app directory to /Applications and then double clik on it. More info on - http://arhipov.blogspot.com.br/2015/03/packaging-java-application-for-mac-os.html - On Windows, a bat script can be used as a launcher. It is useful for command line tools apps. - On Windows, an native executable (*.exe) containing the shell command "java -jar app1.jar [options]" can be used as launcher. It can be made self contained if app1.jar is replaced by $0 or argument 0 which is the path of the running program and the jar package is appended to the end of the executable, the command line becomes "java -jar &lt;arg0&gt; [options]". This approach is adopted by http://launch4j.sourceforge.net/. I tried this way without lauch4j, but Anti Virus complains that executable is not signed. Even a .NET app.exe can be used as launcher using this technique. For command line tools and small standalone servers, I prefer to embed the uber jar into a shell script, for small desktop apps, I guess that is better distribute as single jar. 
How is it an abuse? You're going to have to justify.
Um I don't write classes with overly long names. You don't have to either. I agree that some will exist.
Took me a while to get home, done now!
Most of the standard library's `Impl`s are non-public and/or in the undocumented sun.* or com.sun.* packages.
You are not making sense, the point is that the current? previous? system is fine. Var is, to my thinking, a unnecessary "solution" for some edge cases.
 I deal with code that's like this: Table&lt;ReallyLongTypeNumber1, ReallyLongTypeNumber2, ReallyLongTypeNumber3&gt; table = getDateEntityValueTable(); for(Cell&lt;ReallyLongTypeNumber1, ReallyLongTypeNumber2, ReallyLongTypeNumber4&gt; cell : table) {...} where ReallyLongTypeNumber* is actually a short name for many of the types that I deal with. Instead I can now write code like this: var table = getDateEntityValueTable(); for(var cell : table) {...} I can instantly grok what's going on here much faster. But I wouldn't write something like this: 
It's great for prototyping. Perfect even. The new Firestore DB is more like a straight-up NoSQL DB. Usable directly from a front-end or with Sprint Boot as an API layer. Loads of other services like authentication, analytics and static file hosting baked in as well. The free tier is ideal for prototypes, then $25/mo let's you scale up, then you can start moving into the Google Cloud platform.
Yeah, but for simple purposes, it's close enough.
Blah. So many generic related warnings that newbies ignore already...
Yeah, but there is a reason for that, it's as much a consequence of the original design as primitives are. No way to do better without breaking changes. If better generic are that important I guess you need to move to a different language. The current support send to be the best option they had.
Interesting... Thanks. I'm gonna goof with that a bit
My `Service` implementations usually use a `Client` internal to it, and the `Service` itself exposes first-party models. For instance a `com.myco.TextMessageService` would have a method like `void sendMessage(com.myco.Message message)` and then i'd have a Twilio implementation `TwilioTextMessageService` and it would make the `myco` objects to the `Twiio` model/client internal to it. Basically abstracting implementation detail so that swapping it with another text messaging provider is as simple as implementing the `TextMessageService` again.
I think the reason for this is different, though. I doubt most of the Python programmers still using 2 are doing so because they dislike the changes in 3. The problem is that 3 is incompatible, and if any of the libraries you depend on are still on 2, then you can't move to 3. Porting Python 2 code to 3 can also occasionally be tricky due to certain things working mostly the same, but different in fringe cases you hadn't thought to test (the Unicode differences, for example). With Java, changes to both the language and the JVM have always been backwards compatible (except for a couple of bugs here and there). Most Java programmers just don't like change. The lambda stuff was all designed to be 100% backwards compatible, but still many Java devs balked. Many Java developers also seem to *like* everything to be as verbose as possible. I remember once complaining that it takes about 20 lines of code to make a simple 3-property value class in Java, and Java programmers were like "that doesn't seem bad". I have a feeling that the Java programmers who are ok with change have already switched to using Kotlin or Scala.
&gt; Cmon, many times when we merged good looking MRs on server some things like build failure or dependency clash happened. The tooling handles that for you. We use Gitlab and we can't merge something when the build fails. You just reinvented an existing wheel. 
I think long term it's a goal to add immutability to the language, some method of freezing things like arrays when they're done being constructed. As much as I miss val (or let), final var isn't final enough at the moment to warrant an extra keyword. Someday, I hope, it will be.
1. Some types are non-denotable. They can now be used. 2. Some types are "nasty" to write down for local usage. They can now be avoided [For an example of both, see this blog post](https://blog.jooq.org/2017/11/20/using-jdk-10s-local-variable-type-inference-with-jooq/)
This is called aspect orientated programming. Look up AspectJ.
Maybe use the observer pattern? You can implement it yourself or use the java.util.observer/observable classes (I think)
One way I see it possible is to have something like: updating(token -&gt; doA(token)) where `updating` call passed function, and then call `update`. Token would something like an interface, that cannot be manually instantiated and instead is available only via `updating` method - this way the only way to call `doA` would be by wrapping it with updating, which ensures update call. With regular java that would be difficult to obtain it with some sort of list. Probably with AspectJ you could create a list of class/methods that would be wrapped with something that guarantees update call. Basically if I needed to ensure that some sort of contract is preserved I would try to enforce it with API and types, e.g. by changing the way code is run to make `doA`, `doB` etc return more of a recipe for a computation, a composable command object pattern, that is later on run by something else - that something else could guarantee that contract holds.
this is the cleanest way to do it i think
You could do two Things: 1. make an abstract class with undefined doA doB and final methods doAandUpdate doBandUpdate which developers have to subclass and implement so you can assure Update is run. 2. Make a wrapper class that takes an implementation of an interface that contains all needed doA methods and that delegates all calls to this implementation and adds an update call. Also only allow usage of your wrapper class in other parts of your Software. The second approach has the benefit that the wrapper can have the same interface as the wrapped implementation which makes using it feel natural. The first one makes the creation of instances more natural because you can use Standard constructors where the second one needs two constructors or a factory method 
This is the correct answer. OPs question is the most common use case for aspects.
YES I did you inbred monkey. Fucking moron. It's the same behaviour in idea, eclipse, netbeans and Visual Studio. OK FUCKTARD? Why not just try it instead of opening your fat mouth.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is Scala an example? Should we add 10s operators because there are in Scala? Honestly, the syntax of Scala does not deserve to be promoted. 
A variable type should never be messy. Otherwise you have a problem in your code.
We can imagine to have a new functionnality in the next realease of IDE: - replace var by explicit type And everybody will be happy :-) 
Please tell me this is sarcasm.
Well my answer was certainly influenced by FP ;) I do Scala for a living and I wanted to explain with plain words something like *I would make a Updatable monad, which acts like Free/IO monad and then interpret/run it into Id/Future*. But throwing such answers does more harm than good, as it makes simple solutions sound hard and academic, which is why I am tried to avoid the m-word ;) 
You could just reassign the value every so often. Such as: Whatever = whatever value you want; Whatever = DoA(Whatever); Whatever = DoB(Whatever); Whatever = DoC(Whatever);
As others have stated, you can do this with AspectJ. But here's a way to do it that is basically how AspectJ works: // You can avoid the interface if you use CGLIB public interface FooSpec { public void doA(); public void doB(); } public class Foo { // Must be created through factory method, because we want to "listen" to calls to doA, doB private Foo() { } @Override // implementing the spec public void doA() { System.out.println("doA"); } @Override // implementing the spec public void doB() { System.out.println("doB"); } public void update() { System.out.println("update"); } public static FooSpec newInstance() { final Foo realFoo = new Foo(); // Create a proxy which "listens" to all calls to FooSpec and calls update() after doA or doB return (FooSpec) Proxy.newProxyInstance( Foo.class.getClassLoader(), new Class[] { IFoo.class }, (proxy, method, args) -&gt; { Object retVal = method.invoke(realFoo, args); if(Arrays.asList("doA", "doB").contains(method.getName())) { realFoo.update(); } } } } Of course, manually maintaining a list like this is fragile, so you would have to come up with some kind of strategy, like method names patterns or annotations to identify methods that should have update called.
I know people will make all kinds of noise about this comment, but why does everyone assume developers all use IDE's? There are a large number of folks that use text editors because they don't like or can't support the bloat and crap that comes with an IDE or perhaps they need to log into a remote server via an SSH channel and can't run an IDE. Too many times I have interviewed folks who couldn't write any code without an IDE filling in the details for them. I've had to sit with many developers whose IDE screwed up their environments and I had to show them how to use the git or svn command line tools to clean things up. Or how the IDE bundled version of the app server they were targeting didn't load classes exactly the same way as the development servers did so what worked on their desktop fails in the integration environment and they were at a complete loss to know how to correct the problem. And the countless number of times a build from an IDE works but a build from a CI tool failed because the IDE classpath picked up required dependencies that weren't setup in the CI tool because the developer didn't know they needed to add it to the build file. I noticed a few years back that way too many framework tutorials all started with "install this plugin into Eclipse then create a new project of type X. If you use another IDE or command line here's some links that might help". I worked with a fellow years ago (many years older than me) that describe the IDE revolution as "point and click your way to god-damned happiness". My point here is no language feature should be added that requires a particular tool be used to support that language feature. So I agree with /u/uniVocity post about when and when not to use **var**, but don't fall into the trap of assuming a tool to make it easy to use a language feature is available to all developers.
Is this how it is most often done? Recently got into spring and some other MVC stuff, and have realized sometimes I am unsure whether I should put some thing in my Service or in my Controller..
If you wanted something more primitive where you don't need to learn Aspect programming, I offer this router: public class KuJZr8Class { public void update(String method) { doBeforeUpdate(); // lookup method to call. Can be replaced with reflection if (method.equals("A")) { doA(); } else if (method.equals("B")) { doB(); } else if (method.equals("C")) { doC(); } doAfterUpdate(); } } 
&gt; Not sure why people are getting so uppity Some large organization use tool like StyleCop to manage their in C#. Basically, you won't pass code review if any of your local variable don't use `var`. On large codebase, this make the IDE terribly slow. Also, in C# they tend to use external dll with limited debugging symbol which can be a problem to understand what's going on. So, this is basically the creepy side of using `var`. It can be used for greater good as well as the greater bad.
This thread sure is civil!
It's how i've most often seen it done, but the line can be fuzzy.
Could anyone enlighten me on why a synchronous send should even be added?
Are you saying val is a bad idea?
The only code that will break is if you have a type (class/interface/enum/etc) called `var`, which you probably shouldn't because it doesn't fit the Java Style Guide.
Maybe something like this? The only way to access the context is by passing a functor to the Caller, which then calls the update method afterwards. interface Context { void action(String str); } interface Functor { void call(Context ctx); } class Caller { private Context ctx = new Context(){ public void action(String str) { System.out.println(str); } }; private void update() { System.out.println("Update"); } public void call(Functor fun) { fun.call(ctx); update(); } } class FunctorA implements Functor { public void call(Context ctx) { ctx.action("DoA"); } } class FunctorB implements Functor { public void call(Context ctx) { ctx.action("DoB"); } } public class MyClass { public static void main(String args[]) { Caller caller = new Caller(); caller.call(new FunctorA()); caller.call(new FunctorB()); } } 
1. Branch A branches from master 2. Branch B branches from master 2. Branch A PR created 1. Branch A built and will merge cleanly. PR marked ready for merging 1. Branch B PR created 1. Branch B built and will merge cleanly. PR marked ready for merging 1. Branch A gets merged Now, if Branch A made any conflicting changes that affects Branch B the PR is still marked as ready for merging despite the fact that this isn't the case. The person merging has to notice that there's a more recent merge to master since the last build of the Branch B PR. If they don't, best case is a failed merge. Worst case is a successful merge and failing tests. 
I didn't say anything about putting type information in your names. You should think more carefully about the names you give functions and variables. But then you should be doing this anyway, with or without `var`.
&gt; The only way I currently understand is in the flow of doX(), I must explicitly have a call to update(). You have been given quite a bit of advice using aspect oriented programming and patterns, while really we know little about your actual use case. If you do not intend to allow other classes to override your doX() methods then just writing `update()` at the end of the method is actually the simplest thing to do. Even with the other approaches you need to add some the information that "this method requires an update() after it has done its work (without exceptions)". Regardless of how you give that information (e.g. via annotation) you have to provide it and it will not become much shorter than the `update()` statement in the last line of your method. Plus, there is no dependency on AspectJ or something else required. If you want to allow others to override these methods then you could still use the approach with the `public final` methods `doA()` and `protected` methods that do the work. public class UpdateExample { public final void doA() { doAImpl(); update(); } public final void doB() { doBImpl(); update(); } protected void doAImpl() { System.out.println(this + " is doing A."); } protected void doBImpl() { System.out.println(this + " is doing B."); } protected void update() { System.out.println(this + " updated."); } } I would suggest that the cost of the added dependency to AspectJ has to be justified, e.g. by a more complex scenario that cannot be solved by the approach above, much more usage than the single class or another benefit (e.g. quickly changing many code places or inserting additional debugging code).
And with reflection like this: public class KuJZr8Class { public void update(String methodName) { doBeforeUpdate(); this.getClass().getMethod(methodName).invoke(this); doAfterUpdate(); } } unfortunately this approach makes it overly complicated to pass any parameters to doA(), dob(), etc.
might be that, I was also thinking that the synchronous may not have a background thread. 
Yeah, I think so too. I hven't checked, but it should be possible to do everything on the thread of the caller, so it's no worse than `HttpURLConnection`.
The only difference with this approach to calling update directly is that you are forced to use it in a way that calls update. It's not "listening" on doX() method calls and does update() automatically.
Or he could use proxies with plain java. But this was surely mentioned here somewhere.
`var usernames = getUsernameListOfString();` `var customerGroups = groupByCountryMapStringToCustomerIntId();` How wonderful. 'var' did its sole job of reducing verbosity and increasing readability.
Why was this ignored?
No, it doesn't. Maybe /u/davidreiss666 can help us on this.
I didn‚Äôt think so. I figured it might be blocked.
 public interface UpdateBeforeAfter { default &lt;T, R&gt; R update(Function&lt;T, R&gt; doFunction, T param) { before(); R result = doFunction.apply(param); after(); return result; } default void before() { // before implementation } default void after() { // after implementation } } But this doesn't solve all requirements of the poster.
Well, the way I see it, if you want to somehow notify `update` on when `doX` is called then you need to implement observer pattern one way or the other, and call `notifyObservers` or similar to notify listener with `update` as a reaction. Which would be the same as calling `update` manually in methods, but with additional layer of indirection. The way I see it you either call it directly from all methods that needs to trigger update, or wrap all calls to these methods into something that would call it for you. Be it AOP, something akin to load patter, command object with interpreter, proxy generated by some reflection-based injector, or good old function call is a matter of taste. The code still needs to be written and the more "smart" you will try to make it, the more you will regret it in a long run.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
val is shorthand for final var. It just saves space. More importantly it teaches you to use immutable objects (because it's easy to write val as opposed to final var).
&gt; so you would have to come up with some kind of strategy, like method names patterns or annotations to identify methods that should have update called Decorate the methods with a custom annotation and perform a classpath scan on startup.
&gt; Be it AOP, something akin to loan patter, command object with interpreter, proxy generated by some reflection-based injector, or good old function call This is the part of the question I find interesting. Ways to avoid code duplication are numerous and [easy](https://www.reddit.com/r/java/comments/88hscw/is_this_possible_in_java/dwl2ut8/). 
Here is the comment linked in the above comment: public interface UpdateBeforeAfter { default &amp;lt;T, R&amp;gt; R update(Function&amp;lt;T, R&amp;gt; doFunction, T param) { before(); R result = doFunction.apply(param); after(); return result; } default void before() { // before implementation } default void after() { // after implementation } } But this doesn't solve all requirements of the poster. *** Comment by: [u/_INTER_](https://www.reddit.com/user/_INTER_) | Subreddit: [r/java](https://www.reddit.com/r/java) | Date and Time: 2018-03-31 17:31:27 UTC | *** I'm a bot. Please click on the link in the original comment to vote.
bad bot
.NET Core to the rescue!
Yup, totally agree!
I think it need one liner helper methods similar to java.nio.file.Files, e.g. `HttpResponse&lt;String&gt; response = HttpHelperMethodsWeLove.getAsString("https://...");`
Why is this form used to create HttpClient and HttpRequest instances instead of this one: // this HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(uri)) .build(); // instead of this HttpClient client = new HttpClient(); HttpRequest request = (new HttpRequest.Builder()) .uri(URI.create(uri)) .build();
Why is this form: HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(uri)) .build(); used to create `HttpClient` and `HttpRequest` instances instead of this one: HttpClient client = new HttpClient(); HttpRequest request = (new HttpRequest.Builder()) .uri(URI.create(uri)) .build();
Yes, you just need to use a proxy. 
that's what the */s* means :)
Unfortunately it is your own problem. Shouldnt it be obvious that username is a string and usernames should be a collections of strings? In most teams/organizations there should be a standard what collection types are used for this. If the collection type is arbitrary, and that your class has methods that return either set or list of usernames, then its actually a good idea to use Set or List suffix to distinguish them. 
Read Effective Java by Joshua Bloch for more explanation, but using a static factory method allows the library to return a cached `HttpClient` object or a subclass of `HttpClient`, neither of which a constructor is able to do. Basically it gives them more freedom to modify the implementation without affecting the API than providing public constructors would allow.
I would expand the Java EE branch to its specs, JPA, JAX-RS, JTA, etc they are not that much 
That is a good idea, Thank you!
No problem ;) I will check it again on my PC, and any other ideaa I will share them. 
It's probably the book that every single Java developer should read. Without question. I've read the second edition, but I'm currently reading the third edition and I'm learning new things.
You missed self hosted so add private cloud ie openstack 
Thank you. I have Jenkins under devops / continuous integration 
Devops is not my strong point. What about splitting the Cloud into Saas/Paas/IaaS?
I saw a video of him for the first time in a year, and his age is really showing. He won't have nearly the stage presence this next time around. 
What? You might be in the wrong place ;)
It. Does. Not. Increase. Clarity. 
You find ways to abuse every language feature. The question is how easy and often it is abused. Why introduce a foot-gun?
This is objectively false in the example I started with.
I would add somewhere Apache Kafka and its alternatives, quite hot topic in subject of data proccessing. I can't see anywhere apache lucene, elasticsearch and solr as well, technologies wildly used in text analysis, search and indexing. Anyway it looks great, keep up good work, for sure will be helpfull for newcomers.
Well, Java was The Blub ever since COBOL finally croaked.
Hate to break it to you, COBOL ain't dead yet. Oh how I wish it were, though...
Thank you! Kafka is in the messaging branch under Frameworks. libraries and tools. Elastic Search &amp; Lucene are under Data -&gt; Search. 
Wrong. It makes no difference with the example you made, except that I have to look at the right rather than the left for the type which is unusual and hence worse. All you should care about is the type of the variable, if it is a super or interface of the rhs is totally irrelevant. In exactly the same way as I should not care if an argument to my method is a subclass or implementation. 
Why is Haskell in the JVM branch?
PrimeFaces should be below JSF, as it's a component set for JSF, not an independent framework. OmniFaces should be there too, as it's often used in combination with PrimeFaces. Not really sure why Apache Wicket and JSF are not grouped together with Apache Struts etc in the web frameworks node. I'm missing GWT and Tapestry btw. If you'd really want to go all out, you could divide web framework in push/action MVC and pull/component MVC. JSF, Wicket and Tapestry are primarily push. For persistence there's also EclipseLink next to Hibernate. Difficult to represent in this graph, but Hibernate implements JPA, so if you want to list some entries twice, you could do something like Java EE -&gt; JPA -&gt; Hibernate, EclipseLink Java EE -&gt; JSF -&gt; Mojarra, MyFaces Java EE -&gt; CDI -&gt; Weld, OWB Java EE -&gt; EE Security -&gt; Soteria, Liberty-nameless etc
Wow, these are some really great suggestions. Thank you so much for taking the time to comment.
Thanks for this. As a .Net developer in a predominantly Java enterprise firm this clarifies a few things for me.
Redis should be under caching as well.
Exactly so unless you have a tiny monitor or a crippling fear of letters it is totally pointless at best while having great potential for reducing readability, introducing errors and damaging extensibility. 
That's what I originally had Hadoop and Spark under but I moved them to Machine Learning. I don't do any work with big data or machine learning so I am wondering what these should look like. Appreciate the suggestions.
&gt; Wrong. It makes no difference with the example you made, except that I have to look at the right rather than the left for the type which is unusual and hence worse. Are you literally arguing that it's bad solely based on the fact you're not used to it? Because that's what this statement is suggesting.
There is some machine learning capability in Java with spark and I think mahoot but most of it is happening in the python and r realms at the moment. Tensorflow and it's Ilk are more driving the machine learning wave at the moment. Though even with spark most of the development is Scala instead of java. 
xd
Sorry, the correct word is "Inconsistent". There are now 2 ways to declare a variable and hence code is harder to read. 
I take it you're not a fan of other languages that largely default to the 'var' approach (or languages like Go where there is no keyword at all).
For the topic of monitoring, definitely Instana is missing.
No ability to create a new builder from an existing request?
No, I like java for the reason that it has great clarity without having to do deeper reasoning, ie, having to doing your own typing inference. It also has better to navigate as the type to navigate to is right there rather than at best two clicks away. I also dislike the inconsistent way some of them declare variables, code is far easier to grok if there is a a pattern to common operations. If putting type information a couple of steps deeper than reading is your thing, cool, go with those languages but this change damages a feature of java I consider core to what it is and how I, and many others use it. Java has constraints that some find limiting but I think they make project easier to grok and more safely extended. 
Haven't used AspectJ, but any performance impact compared to using jdk proxy classes?
Creating a new builder from an existing request could be done with the two forms, no? HttpRequest existingRequest = new HttpRequest.Builder().build(); HttpRequest.Builder builder1 = HttpRequest.newBuilder(existingRequest); HttpRequest.Builder builder2 = new HttpRequest.Builder(existingRequest);
I assume we're talking about people doing Java dev for a living? Also Java and javascript are almost completely unrelated, so I'm not sure why that and other stuff branches off a center node of 'Java Development'. The 'core fundamentals', 'web development', and 'dev ops' seem a bit out of place.
As a fourth year is student whose absolutely anxious and clueless this helps immensely.
What? We need some more context than that.
Please. They are so incredibly different in what they offer and "cloud" already is too generic. 
Don't think there is any, seems general
Would drop Guava for Caffeine entirely. Redis isn't a local cache, also confusing to branch for local caching and then call out caching under data - it's an implementation choice where/how/why etc the cache is needed. For messaging there's AWS SNS/SQS/AmazonMQ. Would add PIT under testing, it's a mutation testing impl. for java. Undertow is another server impl. in java. I'd be hesitant to callout all the Spring Frameworks but just group them under their hierarchy. Spring Framework is used by Spring Boot is used by Spring Cloud is used by Spring Cloud Data Flow. Spring webflux effectively falls into the reactive framework section too.
Maybe even some CaaS and FaaS
This is great. Is there a directory on openjdk.java.net that lists all of the pages like this?
There's also dl4j for machine learning in java
dark theme doesn't have to be ugly [https://imgur.com/a/ok39a](https://imgur.com/a/ok39a)
Redis is not a local cache like guava, it's a shared distributed cache
It's funny how an HTTP API is added to the JDK while e.g. the JAXB API is removed... shouldn't this API be come a standalone lib/module, too?
&gt; Plus I have no trouble believing that it was a change forced by marketing/product not tech Wrong.
Well, types can't be inferred for member variables, only for locals (thank God), so it really has no bearing on object mutability. Read only locals is not really the same thing as immutable objects.
Restricting a **local variable** type to an interface does not meaningfully facilitate extensibility.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Javassist may help you. http://jboss-javassist.github.io/javassist/html/javassist/util/proxy/ProxyFactory.html
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
[Records](http://cr.openjdk.java.net/~briangoetz/amber/datum.html) might do the latter in certain contexts :)
Any link to the JEP? Can't see them breaking an API any time soon
What is so bad about calling stream()? filter() could just internally do that but that does not seem like a crazy improvement to me.
Yeah, but you don‚Äôt really need it. In scala or JavaScript, for example, they don‚Äôt have anything like that.
They add some safety but it‚Äôs just boilerplate as far as I‚Äôm concerned. They could let them be generated automatically while generating .class files for example, as it‚Äôs done by Lombok.
U should go to the place where u can find build.gradle with ur shell and then u have to type 'gradle build'
I never got Lombok. I've tried putting @Data at the top of my pojo, but when I try to access private fields with .getMyField(), intellij never finds it. Am I doing it wrong?
Haha, congratulations :)
You need to install the lombok plugin for that to work, which is a dealbreaker for some
enable "annotation processing" in the settings
I wondered why they didn't initially do this, maybe they couldn't decide whether the result of list.filter should be a new list or a stream? There is removeIf which is kind of the opposite and mutates the original list. They did it for forEach but that's a simple case because it consumes the stream and returns void.
I agree. Getting rid of setters and getters will be a bigger challenge I think, if they even want to.
I know the plugin. You're only showing a snippet, but you can already see where the theme fails. There are blinding white, distracting menus and lines. There's no common color scheme. If you open the preferences or any other overlay, it's the getting worse. What a mess.
I hate this day.
Like? Not. Use? Yes, like lesser of evils. 
It might make more sense when you see the presentation. If you strictly wanted to be a Java developer you could get away with the advanced web development track but I was thinking along the lines of full stack developers. I could be wrong but most of us learn something on the front end before moving into Java.
Awesome, thank you! Please remember don't get overwhelmed by this list. It's intimidating to a 20-year vet taken out of context. :)
I don't think you understand what i'm saying. If you have a project with 1000 classes and in the whole project everywhere you only use val, and set the compiler to throw an error if it finds a var, then every object will be immutable. This way you don't have to wonder whether an object is immutable or not, you just know it is.
My thought with JSF &amp; Wicket was to tie them under the same category as Vaadin. They are all presentation framework are the not? I like the idea of splitting out the web framework but I probably wont to try and keep some simplicity to this. This little project of mine has already consumed the last 2 weeks of my life haha
If you use val everywhere in the project then every object will be immutable. That's the point: Scala makes it easy to write immutable objects and as a consequence your whole code will be made of immutables. You don't need to check if an object state has changed or not because an object's state can never change. If you want to change it you need to instantiate a new object.
No, I don't think you understand what I'm saying. Either that or you don't understand what it means for an object to be immutable. What you're describing is ensuring that **references to objects** are immutable, but the objects themselves may still mutate. The reserved type name `val` (as with the hypothetical `val`) **cannot be applied to instance variables**. Forbidding `var` and only allowing `val` only ensures that local variables are final and has bearing on whether *fields* are final. If fields may still be non-final then objects may still mutate regardless of whether local references to objects can be reassigned.
I started a new branch for Big Data... Would you have HDFS, Yarn &amp; Slider as a child of Hadoop? Also, can you check the links and see if those are good.
Yeah they all depend on Hadoop so makes sense. I'll try to take a look
Random... buddy, really random...
With that I can make it through the day, thanks!
From a design perspective the Stream API is a very good decision. Streams are not Collections. You can pass a non-terminated Stream and add further restrictions (order doesn't matter) and then evaluate it depending on some input. JavaScript doesn't serve well as an argument: It doesn't even have proper collections, filter etc. is eager. Scala has different collections. That's the real design issue in Java: they didn't split new Immutable Collections from the Mutable classic ones. They only provided unmodifiable views.
Yeah, that‚Äôs why coming from scala java 8 looked a bit clumsy to me. But it seems they‚Äôre taking the right direction anyway.
But is it also ready for Java 13?
Love the left pad comment
Who doesn't? :O
It's an April fools joke, but I will roll with it anyways. In Kotlin they already have this, but with a catch: the functional methods also returns a collection, not a Stream (or Sequence in Kotlin). So when all you want is a List with certain items removed, in Kotlin you'd do `val newList = list.filter(MyObject::someCondition)`, whereas in Java you'd have to do `var newList = list.stream().filter(MyObject::someCondition).collect(Collections.toList())` Now, it does come with a major catch though: it's very easy to chain methods, i.e. `list.filter(..).map(...).findFirst()`, and all steps are eagerly executed. So if you only care about the first item, you still end up doing your map on every single item. 
Ha, we all know the JEP is nonexistent.
Not really. The answer is "properties". It's a [feature that C# has](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties), so you can see how it would work in practice. Assuming your setter and getter is just exposing an internal member you can do: public string Name { get; set; } This is basically the same as: string name; public string Name { get =&gt; name; set =&gt; name = value; } In Java you'd need to do: private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } Want a getter, but not a setter? public string Name { get; } In client code, you can access it as if it was a public field. Console.WriteLine(person.Name); You can implement more complicated behaviours behind your getter or setter if you needed it, but if you didn't, then you can use the simple syntax and have the compiler generate it for you. To migrate existing Java you'd leave your existing setter and getters alone and add the `{get; set;}` (or what ever) syntax to your class, and change client code: String name = person.getName(); // becomes String name = person.name; The former will continue to work as long as you keep your getter and the second will call the new autogenerated getter. Once all existing users of the old getter have been changed, you can remove it from your class. You may question the `person.name` syntax, because that looks awfully like directly exposing a public field, which is generally a no-no, but it's okay, because you have full access to control reads and writes. Additionally, properties don't need to have a backing field, so if you need to modify your implementation you're free to do so as long as you continue to implement that getter using other fields. For example, you could replace your internal `name` field with a `forename` and `surname` field: private string forename; private string surname; public string name =&gt; $"{forename} {surname}"; (Sorry for the mix of Java and C# syntax). 
So they could provide both `stream()` and `parallelStream()`. You might think that it was a lot of work for a feature that isn't used much. It's an argument that is not without merit. They could also implement default wrappers on Collection for `stream().*`, which is also an argument that is not without merit. 
In many cases, they could be autogenerated. Look into properties in C# (or my comment further up in this post). 
How about branching "Big Data" from "Data" and move "Machine Learning" to "Big Data", so you can get rid of the redundant "Hadoop and Spark". Also it could get some more branches as the [ecosystem is quite big](https://hadoopecosystemtable.github.io/).
I ran across awesome-java in my research... Really Awesome resource!
I'm from place where they don't give fuck about this day, and i was like wtf is going on in /r/java. 
I don't like some of those suggestions under a Java EE branch. I'd rather have them under a function they serve. E.g. Persistence -&gt; Hibernate, Dependency Injection -&gt; Weld. etc.
Well done! How about branching "Big Data" from "Data" and move "Machine Learning" to "Big Data", so you can get rid of the redundant "Hadoop and Spark". Also it could get some more branches as the [ecosystem is quite big](https://hadoopecosystemtable.github.io/). More ideas you can get [here](https://github.com/akullpp/awesome-java). That link itself could be added to "Resources" :)
Sorry, moved my post.
&gt; Let‚Äôs get rid of getters and setters next! And replace them with what? 
I know the old dark theme plugin used to have the white preference windows, but I thought they had started to fix this when the plugin got renamed to DevStyle. Don't get me wrong, I still find IntelliJ easier to use and I prefer it's code improvement suggestions, but I dont mind the bright whites in a dark theme like this. [pic of dark themed preferences](https://i.imgur.com/eOwYtkY.png) 
If the fields inside the object are all val then how can its state change?
No this is exactly what I've been trying to explain: fields do not support inference. Only locals do. And this will not change even if `val` is introduced to the language, as there is a very good reason for it.
So sorry
Brian Goetz said they looked into adding properties in the past. Everyone agreed they wanted properties, but no one could agree what "properties" meant.
Thanks! Unfortunately there isn't such a directory. There are rather few other pages like this one. I expect, though, that if more pages are added, they'll be linked to the [Project Amber](http://openjdk.java.net/projects/amber/) page, as this one is.
&gt; block these functions [...] in windows using some sort of policy editor. You're asking "how to do X in Windows", you should ask that question in a Windows-related sub. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/88t1fv/deploying_javafx_project/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
:)
Sadly the history of language design. Case in point: [Optional talk by Stuart Marks](https://www.youtube.com/watch?v=Ej0sss6cq14&amp;t=46m14s)
Look into how kotlin handles them. It's just boilerplate code when you think about it. 
Add lombok to Java directly!
Don't be silly. Making breaking changes to core interfaces is a Java tradition. We even added language support so that we can do it more often.
&gt;It would mean the HttpClient has to keep a background thread around, just so you can wait on it. AFAIK, the new HTTP client is true NIO and uses the ForkJoinPool.common() thread pool which is always running.
Sometimes you want to block. Especially when you don't operate at scale, and are working with legacy APIs/monitoring/APM that adopts a one-thread-per-request model.
Finally that took way toooo long.
No
Oracle's Java Magazine is an excellent publication that should be on the list of resources.
&gt;so if you want to list some entries twice ;) The suggestion was to have them both under their function and under Java EE.
No, really, I do have no trouble believing that. 
Not outside the method but it does allow one to impose a restriction on what one does with a variable and hence allow other subclasses to come into existence without having to worry about them.
ah ok. Thats fine then
/r/javahelp
While they are at it, they might as well add a shortcut version of map and filter directly to the List interface
.collect(Collectors.collectAndThen(Collectors.toList(), ImmutableList::copyOf))
What do you mean? This only applies to local variables. The type is not exposed outside of the local scope of the method, even to subclasses.
Just Java things
Also don't forget boxed()!
You are not making any attempt to understand what I'm saying, so I'm quitting this thread. Good luck in your little world.
Dude, you can't create this class MyValClass { private val someAttributeName = "BLAH"; } `val` only works inside methods, i.e. local variables.
April fool's!
 ‚ô´ This is why we Kotlin ‚ô´
http://i0.kym-cdn.com/entries/icons/original/000/000/091/TrollFace.jpg
jesus christ, no. 
We don't need to "get rid of getters and settings" but something like ... published private String firstName; ... that causes an implied getting and setter to exist would be nice.
There will be! I'm on the expert group of [JSR 385: Units of Measurement API 2.0](https://jcp.org/en/jsr/detail?id=385) (and will begin contributing heavily after I graduate in a month), and the team is committed to bringing users an easy-to-use API and implementation for SI units. I recommend your check out the GitHub linked on the JSR!
Luke, join the Dark Side! In Scala we have all of this, and more. It's up to you whether you choose to use that power for good or evil.
Hey, thanks for the contributions to a much needed project. I think JSR 385 is useful and appropriate for many projects. I still think there's a need for something much more lightweight though. Those libraries are bigger than the whole rest of my app (by orders of magnitude), and I just need to convert between some common measurements. The type safety is nice, and the UoM api is far more capable than my little bit of code... but it's also way more complex. There's a new API to learn, and I'm not even sure where to get started on the github page (I actually looked into JSR 385 a while back before I initially wrote this). I assume I'd need to first import the unit-api... then the si-units, then I see references to JSR 363 (ok, older rejected JSR maybe?), and some sort of compatibility toolkit? Suddenly I'm reading pages of documentation and spending hours doing something that should be pretty simple. I'm not knocking it. Large enterprise apps need large enterprise grade libraries. But I just want to convert feet to miles to kilometers, pounds to kilograms, etc (while keeping my overall code base a small as possible). My use case doesn't require the type safety that comes along with something like JSR 385, nor the ability to convert between every possible unit of measurement available. If I'm able to solve my problems with a couple static functions and a few enums, why wouldn't I? That said, keep up the good work. Someone needs to do it. 
Thanks for the feedback. The idea isn't to have functionality parity with libraries like the above mentioned JSR 385. Many applications only need to convert between a smaller subset of unit types, and will never need the functionality offered by a more complex solution. &gt; Are you going to create a multiplier for every SI prefix for every base unit? In theory yeah. In the current state it serves my needs perfectly well, so I wouldn't be extending it much beyond where it is. But even if you went crazy you'd have probably a few 10s of base units or dimensions (Length [base unit meter], Mass [gram], Force [newton], Power [joule], etc) and then a list of multipliers for the various units within each. Could be a long list, sure, but i'd be simple and not prone to much failure with some unit tests behind them. A first year programming student could look at it and pretty easily add new unit types, even if you had hundreds of lines of multipliers. 
 ‚ô´ This is why we‚Äôve been Groovy for ten years ‚ô´
I think you misspelled Scala
Haha, relax kid, life can be good. Have fun writing builders ;)
Or he can write abstract doX() method and then write and API that requires calling something like callX() to actually invoke the implemented doX() and callX() is responsible for also calling the update() method. 
Of the variable type. One should always use the mouse abstract type one can so that it can be switched for different subtypes. E.g always use Map instead of HashMap as the variable type. This is pretty basic stuff. 
At least static import `Collectors` :) .collect(collectingAndThen(toList(), ImmutableList::copyOf))
*`Collection`. 
No, don't. 
Because....?
Readability. On objects you call methods like object.method(); and everybody nows it's a method of object. If I do the same with static methods like this StaticObject.staticMethod(); everybody knows ist the static method of StaticObject. But if another static method exists with the same name (maybe in another package or even dependency) and you just static import, it's very hard for people to see which one it is: import static some.weird.functions.runIt; runIt(); And oh noes! That's the one for doing the real missile alert! 
It's inside `.collect()`. It's a `Collector`. It's a common collector. Not all static imports are bad. Especially if you just import `Collector.toList`.
That's exactly what I am arguing against. If someone wrote a different static toList() - method and imports it static, nobody will see that. 
&gt; If someone wrote a different static toList() That shouldn't be statically imported, because it's not in `java.util.stream.Collectors`. &gt; and imports it static, Don't do that. I'm not advocating statically importing any `Collector` method. Only `java.util.stream.Collectors`. At no point have I advocated statically importing anything outside of `java.util.stream.Collectors`.
Unit conversion libraries are complex because the problem is not simple. Take a loot at QUDV: http://www.omgwiki.org/OMGSysML/lib/exe/fetch.php?media=sysml-qudv:annex_c.5_2009-08-26.pdf. Your "library" covers a very tiny part of unit conversion.
So your example scenario is that you have a method which internally fetches a cat through another method call and then does something generic to it which could be applied to other animals? But it doesn't return anything relating to cats or accept any parameters relating to cats, and one day it may need to be changed to internally fetch a generic animal from some other source? Haha ok, that sounds like a nonsense design to begin with. Or perhaps the method it fetches a cat from (and assigns to the inferred local variable) may be refactored in the future to return an Animal instead and you want to be ready for this? Well the problem there isn't with the local type inference it's with the shitty API which ends up breaking its contracts. Which again is the exact problem which is avoided by restricting inference to locals. I think someone who was concerned with code reuse wouldn't write code with that problem in the first place. And I think I would find this to be the case for 99% of the examples you could give, because local variable type specificity does not typically relate to code reuse, it simply represents an internal implementation choice e.g. List/ArrayList, and only needs to be changed if you are changing (not generalising) that implementation.
How is this a breaking change?
Then let's sort it out by "we meant the same" and continue with our day. 
er'y day I'm kotlin'
Yeah, tiny edge case that is not particularly interesting and a waste of time to battle through explaining. But still better to define that actual type of the damn variable than not, but fair enough, not by much. I am yet to be convinced of any merit to this addition for people with modern monitors and keyboards that comes even close to outweighing the likely reduced clarity, navigability and IDE auto-generate/extract errors. 
To be honest if someone bothered to write another method with the same name and the same method signature I'd expect it to do the same thing.
Also never use string concatenation, because what if someone overrides `toString()` to shoot a puppy!
&gt; The International System of Units has been adopted as the official system of weights and measures by all nations in the world except for Myanmar (Burma), Liberia, and the United States https://en.wikipedia.org/wiki/Metric_system So, it maybe worthwhile to convince the US to use the same systems as the other countries in the world than designing converters :-) 
**Metric system** The metric system is an internationally adopted decimal system of measurement. It is in widespread use, and where it is used, it is the only or most common system of weights and measures. It is now known as the International System of Units (SI). It is used to measure everyday things such as a sack of flour, the height of a person, a tank of petrol, and the speed of a car. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
`.collect(toImmutableList())`
Adding new methods to a pre-existing abstract interface is a breaking change because pre-existing classes that implement said interface won't have the new method. This happens so often in Java that we no longer have abstract interfaces. The keyword `interface` has been redefined to mean "an abstract class without fields".
&gt; Parameter list blacklistedLicenses is tricky to configure as some Maven artifacts use different names (e.g. Apache 2.0, Apache Apache License, Version 2.0, Apache Version 2.0, etc...) for the same license. My personal suggestion before compiling this list is to run the plugin with printLicenses set to true, note down all the license naming variation found, and then compile the blacklist from that. How about allowing whitelists and regex for filtering. So you could configure it like: &lt;blacklistedLicenses&gt; &lt;license&gt;*GNU*&lt;/license&gt; &lt;license&gt;*GPL*&lt;/license&gt; &lt;/blacklistedLicenses&gt; &lt;whitelistedLicenses&gt; &lt;license&gt;*Apache*&lt;/license&gt; &lt;license&gt;*MIT*&lt;/license&gt; &lt;license&gt;*BSD*&lt;/license&gt; &lt;/whitelistedLicenses&gt; &lt;whiteListedOverrule&gt;true&lt;/whiteListedOverrule&gt;
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I totally understand where you're coming from! I wouldn't recommend integrating those repositories into any of your projects yet, as it's still unfinished. Eventually, it should be as easy as requiring a javax module once everything is complete. I'm also fond of creating my own utilities for specific use-cases rather than using Java's provided utilities, especially when it involves requiring some module only to use one of its features (javafx.util.Pair).
If it has a "default implementation" then by definition it is no longer an abstract interface.
So we should do your homework or what?
So what?
I can't read for you. https://www.tandfonline.com/doi/abs/10.1080/01611190701743658
Awesome suggestions, thank you!
Spring is a very powerful but complex framework. It's very easy to get started (Spring Boot). I especially love JPA as I just need the persistence to be getting done. The architecture is clean and standardized. However, you have to be prepared for a serious learning curve when needing customizing (e.g. attribute based authorization with Spring Security and AOP). It's a jump in the cold water after the pain- and effortless start using Spring Boot. I haven't mastered Spring yet (in depth understanding of DI, AOP and the configuration), but I feel that when mastered, Spring is the ultimate framework to build concise and clean applications.
&gt; Spring is the ultimate framework to build concise and clean applications. Together with Java EE, soon to be Jakarta EE ;) 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Obligatory Grails shout out
... what is boxed, anyway? Haven't heard of it before this thread.
I like this. Your tool needs some testing and tuning but this helps solve a problem that I face as a developer who works on both commercial and open source code. I am ethically and legally obligated to obey the licenses of dependencies and code my projects use. I like how a blacklist hit fails the build. This makes it die on the developers workstation when a dependency is added. It adds another backstop in the build server too. I have a question, can you configure it to fail the build if the license of a dependency is not known? Internal, hobby, or other projects might not have a license block defined. Oddball dependencies with a generated POM might have the same issue. 
One can check proper licenses via Apache RAT. Here is the related issue: https://issues.apache.org/jira/browse/RAT-61 It is under Apache Creadur project. You can check here for more information: http://creadur.apache.org
Thank you! That looks helpful and solves a similar problem as what OP described.
The metric system is actually heavily used in the US and the US government encourages metric usage: * https://www.nist.gov/pml/weights-and-measures/metric-si * https://www.nist.gov/sites/default/files/documents/2017/05/09/PEO-12770-NIST-SP-811-September-1998.pdf On a every day basis though it is harder to switch. If you tell me something is 142 kilometers away, I can't visualize that, but I can visualize 88 miles. I can't visualize 5 Kg, but I can visualize 12 lbs. I didn't grow up with it so changing is hard. I like recipes that use grams though (cooking by weight is more accurate than volume) though, and I use grams when weighing out how much salt to use to make salt brine solutions for my ferments (the math is easier).
Changing takes time. I needed 10 years to really think in euro (i.e. no more conversion for any price (houses or cars for instance)). I ma french and the conversion rate is 6.55957
In addition to this, it allows for the static factory method to dynamically find the implementation at runtime instead of being specified. The JAX-RS 2.0 rest client implementation works similarly using a custom service loader type class. This allows for the same API code to be used with several implementations like Jersey, Resteasy, etc
&gt; Your "library" covers a very tiny part of unit conversion. That's true, but that's also the intention. It's primarily for smaller projects that don't want to include multiple large solutions just to do some basic conversions. 
You call boxed() on an IntStream to get the "boxed" Integers instead of ints. 
You're right. The title triggered me.
Agreed. The only reason I can think for keeping it is because they believe that Http requests is a common enough and low enough requirement where JAXB is less so. But still, I don't know why we need this over Apache, OkHttp, Netty, etc. There are so many good Http clients out there I don't know why we need one in the JDK. Perhaps a common interface would be more appropriate to allow for interop (reactive streams, for example).
'cause in a well-designed system it should be obvious. It is called Username, not user. If username can be string or the type User, something is seriously wrong with your naming convention. Nope you are being silly here. It makes perfect sense to rely on naming convention in a functional team. It doesnt matter what convention you use, but you need to be consistent. I said you should use suffix if you have different methods that return various types of objects. For instance, your database access method can return either a List or a Set, then it makes sense to use suffix(ie. userList, userSet) to distinguish them. If your database access method returns list or set only, there will be no need for suffix(just users), since there will be no confusion what the type is. Seems that you either failed to read my words carefully, or you are just not a competent coder to understand how to name variables/methods properly. This is uour problem, not mine. 
An opportunity to repost Bob Lee's comments on Spring back in the day: http://blog.crazybob.org/2006/01/i-dont-get-spring.html
Not sure if serious. I hope not. Otherwise, let's add ALL methods to Object. Maximum convenience achieved.
Yeah, pretty crappy title on my part. 
One scenario that crosses my mind immediately is : How would you like your service's client to call you ? In ideal world there will be some client implementations for various languages which needs to be shared. also some common org things like build profile configurations etc.. needs to be shared and generally kept internal to the org. having local nexus (local to your work infra) helps you caching some thirdparty artifacts and helps to populate these artifacts faster. I am voting for keeping Nexus and sharing things locally to org.
Traditional artifact repositories are still king for managing dependencies across projects. You'll likely still make libraries that you want to share across multiple projects, and Maven is still the way to do this in java.
We use artifactory as both a docker and maven repo. We do share some code like some spring boot starters.
Is it possible that you might want to pull a dependency from a maven repo in the docker build? 
Nice. You called out testing etc. and the (horrible) testing harness. I forked an old concatenation plugin and made some updates to it for my needs, https://github.com/Flaw101/concat-maven-plugin, I didn't bother with 1.5 support as... no, however it's setup for maven 3.2.5 (last supported 1.6) if you want to rip any of the dependencies etc. needed for testing. Testing is end to end, no unit tests to speak of in the code. I also thew Guice in there for more CDI after the initial load.
Your deployable artifact is made up of smaller artifacts (like Russian dolls). Artifact repos help you build the uber-artifact that will be deployed to a container. So, absolutely. 
For internal cloud/privateo Pivotal Cloud Foundry is available too. This is where the distinction between PaaS and IaaS comes in. PCF falls under PaaS (platform) whereas, AWS is (infrastructure). PCF can run on AWS, and does. This is really awesome though
Ah, I was assuming that what goes into the container would be one artifact or several artifacts with the same parent POM, but it could be several artifacts with independent hierarchies. If there's a team working together on a small service, each contributor might version and deploy their own parts of it separately, which could be done by deploying to a shared Nexus. But, I'm not sure I've ever seen that happen--usually it's just the source that is centralized...
The main reason AFAIK is due to the legacy that is Java's mutable collections - stream operations are lazy, and don't mutate, so it would be kinda confusing having `list.remove()` and `list.filter()` - one which is mutating, one which isn't. I do kinda wish they'd added a `Streamable` interface which had the `stream()` method on it tho, so then the function given to `flatMap` could be changed to just return something `Streamable` rather than having to manually call `.stream()` all the time as well.
&gt; th, I suppose the private repo is worthwhile. But doesn't the pr Depends on your environment. We host a local copy (open-source RPM) of Artifactory on a small VM we use for such things, so the overhead cost is minimal. The local speedup is a side-benefit, but we also host our own libraries, so every setup is different. One of the primary benefits of Maven was not having to store jars in your source tree; with containers, how do you get around that? Store the prebuilt image? Build the image on demand? Some way or another, you're storing a jar; your environment will determine which solution is the cheapest and most efficient.
It is not a little faster. It is a lot faster... Where did you get the $50? Unless you are a really big company, Nexus open source works just fine... &gt;But doesn't the practice of sharing every little piece of code (like left-pad) violate the microservices principle? When I say caching I mean the standard libraries (spring, hibernate etc)
&gt; It is a lot faster... And as the numbers of developers goes up having cached jars is a must for your network connection Wasn't aware of this, thanks :-) $50 was a hypothetical monthly cost for hosting the VM.
Yeah, I was thinking our Jenkins would build an image upon every source commit. They go into a container registry, and the idea was that would be the central repository, an analog being what Nexus is to JARs.
How big of a disk does an Artifactory VM require that mirrors Maven Central, JBoss, Sonatype, etc? And does it really continuously download every new version of all jars, source, Javadoc, etc? Seems like this would get big pretty quickly. 
&gt; boxed() Its for primitive streams like IntStream and LongStream because collections need the wrapper class (Integer, Long). Just converts ints to Integer etc.
No Artifactory doesn't normally mirror an entire repository but only caches on demand. So if you don't use a particular library it will not be copied into your Artifactory, but if later you start using it then it will be mirrored.
The TL;DR section is too long, didn't read.
Let me try to make a shorter "tl;dr" :-) Use Maven, unless you need the performance and flexibility of Gradle.
It sounds to me like the biggest real problem would be "new Gradle versions break existing plugins"... but honestly, I've never worked in an environment in which a build engine update was performed without making sure everything still worked - as in, "almost never".
I stick with "Maven for libraries, Gradle for applications" due to differing complexity.
Before I started programming in Scala, I constantly heard that SBT was garbage. However, since I actually started using SBT, it doesn't seem any worse than Maven or Gradle. Maybe they "fixed" SBT?
I've been trying to explain this to colleagues for awhile now and will now be deferring to your post instead, as you have summed up what I'm trying to get across. it's not that Gradle is bad or slow or anything. it's that I literally have to Google *everything* even if it's a simple thing. sure, blame it on me not investing the proper time but frankly I don't want to invest large chunks of time learning Groovy or diving into the Gradle API. great post and hope others who are considering abandoning Maven read this first for a point of view that has genuinely given it a proper chance before switching back to Maven
Performance is just so much better that I accept the increased complexity.
I haven't looked at Spring in years. But my impression is that Spring wants to be your solution for everything. Need caching? Spring has that. Need IoC? Spring has that. Need a O/R layer? Spring has that. I remember when Spring first came out and they had the cojones to call it "lightweight". Well, it's anything but and I believe that's still the case.
When I used SBT 3 years ago, it was horribly slow to open a project and build it for the first time \(when I say slow, I mean 30 minutes for a not so big nor complex project with a decent connexion on a decent machine, nothing justifying that much time\) and I remember that every time I built something, it was really slow. I haven't tried it since, but I still remember how painful it was...
Yep, same here. When I was a more junior programmer I did read through the Maven book and really understood the whole life cycle and assemblies, etc. This was back when Maven was new and a lot of projects were still on Ant, which wasn't all that bad either. A decade later and I really don't remember all the details of Maven, but I almost never need to deal with issues anyway - it just works, and I can always find a stable plugin and a few examples to do exactly what I want to do. Meanwhile I've seen the hipsters try and use Gradle, or even worse - the front end builds that change tools every year (grunt and gulp and webpack and jspm and bower and mom and yarn) - and it never improves anything but makes it harder for everyone else to understand. Same for SBT. Just give me something that works and is stable and documented. I honestly don't give a shit about some new shiny or fancy tool for my build - I have actual code to write. 
This is a good summary of why I never succeed to use Gradle: too hard to use. Every time I wanted to use it, it was for not so big project that would not take more than a few days to build. After 2 or 3 hours without any result, I always gave up. I cannot spend 3 days of my life to understand my build system while having Maven build a simple takes only few minutes... Maybe it's a better build system, but it for sure didn't took the "simplicity" of Maven.
I guess some of the complaints will be alleviated once Gradle finally uses a different language
will they change again? kotlin?
Gradle = Ant with groovy instead of XML
Great post. One thing I noticed is that one of the main strengths of Gradle, it's flexibility, is also a weakness. You can build entire build pipelines in Gradle if you want. The problem is colleagues that actually build complete complex pipelines in Gradle. This is is where I prefer the declarative nature of Maven POM's over Gradle build scripts; it's a lot harder to end up with piles of untested hard to maintain Groovy code that 'somehow' magically builds your project for you. That said; I don't mind Gradle at all but I would've preferred a purely declarative DSL over a fully programmable build env. 
I once worked on semi-large Android project (with Gradle) and builds could take like 5 minutes on modern Intel i5. I can't imagine what it would take in Maven. But maybe it was just poorly optimized; I never bothered to try to understand the Gradle scripts, which is the core issue here I guess.
Really, if it wasn't for Google pushing Gradle on us for Android development, I would not even care. I do like XML based tooling, and declarative builds. Gradle just feels like a slower version of Ant chaos, full of workarounds (daemon and build cache) just to achieve the same results.
I agree and in those cases you can use variables. It's just that Scala makes it a little more difficult to use mutables than immutables. For example, to use an immutable list, you just write List(...). To use a mutable list, you need to explicitly import the package mutables. So it's not *that* difficult, it's just that immutables are easier. My point at the start of this thread is that Java makes immutables hard. If it only added the val keyword, then people would find it easy to write immutable objects. Currently, in Java, it is harder to write immutable code than mutable.
So will it be possible to do this? `var ans = doMath();` I hope not. I do like that it's possible to do `var x = new HashMap&lt;String,Integer&gt;();` now though
&gt; So will it be possible to do this? var ans = doMath(); Yes this will be possible. I'm hoping there will be a checkstyle or ide warning about it though. 
It's also one of Maven's biggest problems. Maven could drastically reduce its verbosity by improving its schema. * https://issues.apache.org/jira/browse/MNG-3397 * https://cwiki.apache.org/confluence/display/MAVEN/POM+Model+Version+5.0.0
Isn't sharing code ironic in this context? Because if two microservices ends up using spring boot for example, isn't that a form of code sharing? If you treat your code the same as the apis you use for microservices, how is it any different? In this case, a Nexus or artifactory would be useful to have.
[It's published on Maven Central.](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22com.calincosma%22%20AND%20a%3A%22jargs%22) You just have to annotate a POJO and make a call to the parser, and it will fill the POJO with the arguments you passed. It supports many types: String, primitives, Integer, Long, Double, Float, enums, lists, sets, maps and any type that has a public static valueOf(String) method. 
I understand the frustration but I face the same thing with Maven. I have no idea what to do if I want something simple like coverage for my project or move and zip some files. Have to google it as well. Same for Ant. For me the conclusion is that no matter the build system: if you don't know it by heart you'll have to google ;-)
This. You don't want microservices to share domain entities (bounded context) but to say that they shouldn't share code is a big misconception. Are you using spring-boot for your microservices? Then they are sharing code. Are you building a library for service-registry/lookup? Well, now they are sharing code
I don't think verbosity was the core issue of ant. I simply don't like the idea of writing imperative code (all ant scripts i saw was essentially a bunch of procedures) using declarative xml. In this regard maven is not broken.
In the section of Template Engines, you should add [Twirl](https://github.com/playframework/twirl). It's the engine that is used by the Play Framework and it can be used outside of Play (although I doubt that many use it outside of Play). In the Build Tools you should also add sbt.
I've seen projects where they follow the "don't share code" dogma (misunderstanding it as you showed) where they 'solve' it by just copy-pasting stuff everywhere. I really don't understand why no one there then goes "we must be doing something wrong". 
Sorry, I meant "XML is one maven's biggest problem" and then qualified that. It's a different reason as to why XML is Ant's biggest problem.
There is already a kotlin DSL for gradle.
FYI you don't have to use XML in your pom: https://github.com/takari/polyglot-maven-examples
I'm used to it now in Kotlin and I actually prefer it. If you name your variables properly it actually improves readability in my opinion. Typical code will move from: List&lt;Person&gt; persons = service.findByEmail(...); To: var persons = service.findByEmail(...); And I strongly prefer the second one after getting used to it. 
&gt; Thanks to Oracle, we‚Äôre now going to enter a new era of Java ‚Äì Java 10. TIL that an era is 6 months long :)
Gradle to Maven is like C to Java. You are more flexible, but that kind of flexibility is not what you mostly want (especially not in a company). In a company you need standardized processes that have to work. But in Gradle you invent the wheel over again, and so the whole process is error prone. 
The problem I have is that the article has not told us why Maven is better in the points mentioned. 
Never used any of these so can't help you.. 
I dont like XML-based DSL, too verbose and hard to point out the problem. Gradle DSL is much better, once you go Gradle, you dont want to go back.
Best of both worlds would be: * Maven's dependency management and plugins * Gradle's build speed and DSL
&gt; all ant scripts i saw was essentially a bunch of procedures Ant is no more imperative than make, which is generally regarded as a declarative tool. What it doesn't have is default build rules, so you have to specify everything in excruciating detail even when that detail is unchanged from project to project, hence the copy and pasting from build file to build file, but for simple projects that need compiling, copying resources and packaging it's nothing overwhelming.
Not really up-to-date on that topic. I know it exists, but is it production-ready? 
It's part of the base gradle plugin for IntelliJ. Apparatus from that, I can't really say. I've made a test project with it, but I haven't written any production code that runs off it yet.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Ant build script [can be written in groovy](https://ant.apache.org/manual/Tasks/script.html) ;)
Honestly, Ant had some real problems, but I liked it a lot. Made repeating commands really really easy. 
&gt; once you go Gradle, you dont want to go back. Y'know, except the author of the linked article. And all the people posting in agreement.
Java 6 here
Hey, at least you have generics!
Just like with Ant, which is why we all moved to Maven. Now we're reinventing everything again with grade.
I use Emacs for small code snippets. Otherwise, I use IntelliJ.
I have always found Gradle to be a perfect mixture of Ant and Maven. Gradle gives you almost everything by convention like maven, but if you need to do something custom you don't have to go hunting for a plugin to do it like you do in Maven. You can just write groovy/kotlin code to make it happen. 
Around 10 years ago I did. Thought Eclipse felt sluggish back then. Now I tend to use vim if I'm on a remote machine and IntelliJ on my local computer.
I hope not. Those are annoying. 
That would be IDE bug...
Java EE 8 however is still Java EE 8. It's only when 9 is released it's called Jakarta EE 9 ;)
started with vi, but last 12 years Eclipse.
Still, Spring people insist on Spring being called lightweight, and Java EE being called heavyweight, even though they are approximately the same weight now :O 
I do
when i first started with java i tried emacs but it was a struggle. that was a long time ago, and it sounds like jdee and eclim [have come a long ways](https://www.emacswiki.org/emacs/JavaDevelopmentEnvironment) but i have no idea how usable they are. i use netbeans and it has an emacs-flavored keymap and decent macro support, though no elisp
for me, gradle has been much much slower than maven. the only thing that makes it semi useable is that they run a daemon in the background that's able to skip startup and cache results that's a kludge that hides the fundamentally bad performance of gradle/groovy, at the cost of unpredictable performance, complexity and hidden dependencies 
 &gt; I hope not. Think it further, the results of streams+lambdas can be assigned to a `var` defined variables.
Yeah, but can I use CSV?
Why would you want to? FWIW, I loved EMACS in college, I even subscribed to alt.religion.emacs I don't see a reason for using it in 2018.
At least the names clearly indicate what they are :P Better than BAuthDef, which leaves you wondering what it is, and whether it authorization or authentication.
Yes. It exists in all the IDEs - including Visual Studio. I created a bug for IntelliJ though.
Mind Saaring the link?
So Java died in version 9
Pushing some book sales?
SBT was a huge clusterf**k for me - because Scala let's you override operators, every plug-in developer would do things differently, and it just looked like some foreign language with all these weird symbols. I never spent a lot of time with it and would even use Maven Scala plug in for Scala projects because the only difference is you need the Scala compiler too. Everything else is the same as a Java project. Though I can understand a newbie might be confused by all the magic happening with one small block of XML in Maven. That was the goal of Maven, though: if you kept the standard layout of src/main/java and tests and resources, it just works. Convention over configuration. For beginners, I'd use Ant anyway because it forces you to define each section - compiling the code, adding up the already downloaded dependencies, building the jar or war, etc. Once you understand what is needed, move to Maven where you dont have to define each operation, just declare the plugin in the right life cycle. 
Probably because I'm new, but I "born" in the era of json instead of xml. For me gradle is just superior I just can't stare xml syntax it hurts my eyes and brains.
Yes, Maven Central is multiple terrabytes and if you attempt to mirror it they will ban you.
If I remember correctly Gant was a precursor to Gradle.
Mavens dependency management is "Pick whatever version i find first", which is pretty random and mostly BS.
11 days ago you posted https://www.reddit.com/r/java/comments/85lysb/payara_5_released/
I started using Clojure (as a hobby) recently and I use Emacs for that. But professionally I use Java. Would love to have a one-editor-to-rule-them all. 
Read the first paragraph on an answer to your point. The audience is for people/teams currently using Maven and are considering Gradle, it's not trying to decide which one is better.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Added my vote!
Cool. I have an old work buddy who is a Lisp head. I will have to tell him about Clojure. Thing is, I don't think you will find anything that supports LISP as well as EMACS. I agree with your credo of one IDE ( not editor ) to rule them all. You learn things and remember things by sticking with one IDE for a long time. When it comes time to do something, you can just do it, instead of figuring out how to do it. I think you could probably find an IDE that does Java well, and LISP just "okay".
No
I tend to find it picks the version I tell it to use.
Can you share your setup?
Long years maven (power) user here. Saying that the build cache is a workaround feels very strange for me. In Maven, you also have a build cache, that's the target directory... and that explodes as soon as you use multi module projects with inter-dependencies...because sooner or later you start installing dev versions into your local repository...which then acts as build cache as well. Just being able to use project dependencies that use a proper build cache is so much easier. As for the daemon, I feel the same. It's faster, why not use it and benefit from not having to startup the whole process over and over again?
Ant + Ivy FTW
I've tried, as I use emacs for everything else, but I find that support for Java just doesn't compare to IntelliJ. I gave [emacs-lsp](https://github.com/emacs-lsp/lsp-mode) a try, along with [lsp-java](https://github.com/emacs-lsp/lsp-java), but I couldn't get it working well enough to actually use. If you just want the keybindings, I use the emacsIDEAs plugin, and that covers quite a few of them. Still had to set a few manually, though.
Don't see why anyone would take the effort unless its a hobby project/completely greenfield/startup. Java 8 here until 11 comes along.
I do.
flashbacks to some code I read that named functions like `double_doMath();`
Right, there is a gray area where something can be code sharing but not tight coupling. Common web frameworks &amp; libraries like Jackson and Guava are examples. If it adds value over anything your enterprise could feasibly build itself then that code should be reused.
&gt; It is called Username, not User. If username can be string or the type User, something is seriously wrong with your naming convention. As I said, there could also be a type `Username`. Actually we had this in a codebase to distinguish between first-, middle- and lastname and everything in between (e.g. "Georg Henrik von Wright" or some Asian names). In general, there's no need to have to rely on conventions when the type system or programming language is well able to take care of it. In Python there's a conventions to prefix private variables with "\_" or "__", in VB or C sometimes the variable names are suffixed with the type, but sometimes it is not, depending on the teams convention. This is not necessary in a language with modifiers or static typing and you don't have to learn the quirks from codebase to codebase. 
Ivy?
Yup. Emacs is my main editor. I don't have my .emacs out there anywhere, but it basically sets reasonable defaults (indent 4, use spaces not tabs, syntax highlighting, Ctrl-Z for undo, etc.) that I use for both C and Java. Every Java project has a simple file structure with a basic ANT build script, and I stick with minimal third-party libraries (log4j, jfreechart, my own stuff). It works for me because I run Linux with multiple virtual desktops. One desktop has an emacs window and xterm, so I just edit away and then alt-tab 'ant build' and 'java -jar build/jar/foo.jar' to get going. Another virtual desktop has a browser open to javadocs. I also focus on command line, [TUI based,](https://github.com/klamonte/jexer) and Swing applications. Since I am so far removed from frontend www/HTML/CSS/JS stuff, I don't need so much infrastructure or dozens of Maven dependencies to get going. 
I‚Äôm using it right now on a moderately-sized project. In short: * IDE support is unstable at best. Sometimes everything works and sometimes buildscripts are all red, like IDE doesn‚Äôt recognise the file at all. * Using `vim` or something like that and building to check the result worked well for me but you gotta know what the hell you are doing with the project. * Performance-wise cannot say for sure, Groovy wasn‚Äôt slow for me at any visibility. * The good thing is ‚Äî static typing. You are doing the configuration with a real programming language by using a semi-programming procedure instead of _guessing_ what Groovy _can do_ at this point. Auto-expanding everything from `ext` in Groovy is beyond me, I still don‚Äôt understand how it works. Kotlin is far more strict about that (thankfully). * Kotlin forces you to understand how Gradle works and what all these fancy Groovy DSLs actually do from the JVM perspective. Because in the end you are writing the code. Unfortunately there is not so much documentation about _how_ Gradle actually works, what stages are there and so on. You need to know this, otherwise there is a little luck in converting Groovy to Kotlin. Not so many people use Kotlin DSL at this point, so you are mostly on your own. * Various Kotlin plugins and Gradle subsystems use Groovy `Closure` which Kotlin obviously doesn‚Äôt understand. There are various hacks to avoid it but the only real solution is to force developers to change Groovy `Closure` to Java `Action` which does the same from the Gradle standpoint, but Kotlin can convert them to lambdas and be friendly with it. This can be applied to some other aspects as well. In other words ‚Äî compatibility does not work well all the time. Who knew that Gradle would have a DSL not based on Groovy? As far as I know there were no ideas that DSL can be pluggable. Personally I‚Äôve semi-blocked Kotlin DSL in a fellow team after converting our project to it. Too much hassle with tooling and understanding how things actually work. But hey, it is not even a 1.0 version. The concepts are solid and I‚Äôm looking forward to a day when everything will be nice and cozy, but for now it is like stepping into a Skyrim dungeon. You will be fine, but it can be dangerous and sometimes really annoying.
Ha, yeH bit long these names, but EE security also have shorter names! Is have IdentityStore and SecurityContext üí™ Or you want SecCtx??? üôà
Yes, it's being used. Here is a tutorial about Spring/Websockets: https://spring.io/guides/gs/messaging-stomp-websocket/ It uses sockjs-client at here: https://github.com/sockjs/sockjs-client/ which is updated 4 months ago.
Java/Spring/Websockets do not require sockjs, which is a common client side library useful for examples. You can use any client side libraries for Websockets (or none at all!).
Eclipse's Memory Analyzer Tool is great for such purposes: https://www.eclipse.org/mat/
I think you need to put the keyboard down and go outside :-) Ivy has caused almost as much suffering as RealPlayer.
I simply find the Gradle tooling is simply lacking. Maven is a much more mature build system and is plugins just work. 
It's in development.
I moved through Ant, Grade and Maven over several years. I still prefer Gradle as my default build tool, the key for me is to be strict about what I allow within build files. I lean EXTREMELY heavily on the declarative DSL so much that any other parts are just small bits of glue. This IMHO is how you should use Grade, have the declarative power of the DSL and the convenience of a scripting language. The one thing that does annoy me is Groovy is I don't want to learn another language for my build tool.
Thats because the version you specify directly in your pom is usually the first one it finds. As soon as anything transitive happens, it goes straight to hell.
have you heard? there is a large following to meson.
i looked at the spring websocket support but wasn't confident that it was totally hashed out or flexible enough for my use (supporting a legacy client i don't control). what i did was use my proxy (nginx) to send websocket requests to a dedicated server/port. that server uses the jetty websocket classes directly https://github.com/db4j/chatter-less/blob/master/src/main/java/foobar/MatterWebsocket.java 
I routinely find that I have to nuke maven's cache. It has basically become my go to whenever maven fails to compile a project. Nuke the cache, try again and see if it now works.
Groovy is pretty much used only for Gradle, I'd rather kill it
Do you know how often this is used in practice and how stable this is? I could imagine it's hell finding a bug in the way that one of these plugins converts the code to xml, but maybe that rarely happens.