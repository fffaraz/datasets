Stolen off of the programming subreddit to see if I can't get people posting all the Smalltalk stories here.
Of course, according to http://isqueak.org/AdHocVM &gt; If you have an Apple iPhone SDK kit that you purchased from Apple you should be able to check out the current Squeak VM SVN then compile and install the VM on your iPod Touch or iPhone by following the instructions from Apple to build an application for personal installation on your device. &gt; &gt; If you do not have an Apple SDK, then you must (at this time) talk to someone who owns an Apple iPhone SDK kit. That person can build an AdHoc application that will run for ONE YEAR on upto 100 devices. So, yeah, you can get Squeak on an iPhone, which is great, but it's not like it's available without someone, somewhere, tithing to Apple for the permission to install it...
Discussed here: http://wolfram.kriesing.de/blog/index.php/2008/forward-thinking-ftplets
Why are .Net implementations called Iron something? 
Blame Jim Huginin (the JPython/IronPython creator), who originally christened his CLR-hosted Python project "IronPython." All subsequent ferrous names seem to be extensions of the IronPython brand. "It Runs On .NET" is the standard explanation.
See also: http://www.seaside.st/about/history
In my programs I create a binary method of string and object called %. It accepts one other object, stringifies that variable and self, then returns the two strings appended together. So you can write something like: string := customer name % ' has ' % numberOfOrders.
via: http://news.squeak.org/2008/10/25/squeak-and-seaside-bofs-at-oopsla-08/
D'oh!!!! I just bought that book! (It's not very good for a decent programmer. It doesn't get past subroutines/methods.)
I never thought I was going to live enough to see that.
Not as exciting as the title suggested.
via: http://blog.fitzell.ca/2009/04/seaside-tutorials-from-gemstone.html
What's with Gemstone and their love of PDF files? All their tutorials and documentation comes in PDF format.
&gt; I'm delighted that Smalltalk is still thriving. :/
via: http://gilesbowkett.blogspot.com/2009/05/ultra-miniapp-hello-world-on-seaside.html
Does anyone have any info on deploying a VW application on server (i.e. somewhere you can't use the neat GUI) with multiple instances running? 
I do just that on our server, where there are 4 Smalltalk servers running to handle various parts of the website. All you need to do is use the -headless command line argument to start a VW image up with no GUI.
What're you using as your frontend server for sticky-sessions? Apache?
GST noob here -- I have the gnu-smalltalk package installed on Ubuntu 9.04, but when I run gst-package, I get this error: `gst-package: invalid tag start` My guess is Debian/Ubuntu have older versions of gst-package; is that true, and if so, is there a way to get around that short of compiling the svn? Or am I wrong and the problem is completely different?
Debian Experimental (not sid) has packaged gst-3.1, which is the lastest released version. However, it refuses to run at all for me, complaining of undefined symbols. &gt;gst: symbol lookup error: gst: undefined symbol: gst\_set\_executable_path Might work for you, maybe?
Truth... smalltalk was too advanced for its epoch.
trippy - one wonders if some (hopefully small) bit of work could be done to unify it with cappuccino to take advantage of their widget set
Amazing!
Holy shit, that is so bad ass, it does look amazing. `self` is the perfect username for a submission like this ;)
Ahem. Clamato is just as popular south of the border as it is up there.
preface from the author: &gt; I had an idea back one or two years ago about writing an "absolute beginner to &gt; programming" book which uses GNU Smalltalk as the tool to teach programming. And &gt; I have done a lot of work on it but after my lessons got a little harder at &gt; university now I cannot find time to finish it. Instead of leaving it decay on &gt; one of my folders I decided to post about it and maybe find other volunteers to &gt; complete the book.
Wow, the world's most beautiful smalltalk meets the world's most beautiful web framework.
have new promotion on November.
very cool IDE; even includes a nice GUI builder and all for FREE. The packagebuilder is great: I was able to create a windows executable for a hello-world GUI application in a few minutes without even knowing about the system.
Nice try, smartarse :)
:)
If you don't like the weather, wait a minute. It'll change.
shitty troll is shitty.
The new window theme looks awesome!
agreement. question about the weather in your area.
Squeak 4.1 looks great, I can't wait to see what they'll add to the next version.
Oracle might hurt Java, but, unfortunately it is too late for Smalltalk comeback, at least in its current incarnation. Maybe Newspeak can give a new energy to Smalltalk, in the same way Clojure did it for lisp, but I doubt it can be mainstream again in any way.
Those are great questions. Not sure why I found this in the /r/smalltalk sub-reddit tho. 
Probably just trying to make smalltalk.
I done b&amp; it. it was not on topic.
Not ^y to hear that - lightweight blogspam - got a blue arrow from me. But it was kind of in the spirit of smalltalk. Not just a programming environment but an ethos of openness and curiosity.
Feel free to repost it in philosophy :)
It looks that Objective C did definitely profit from this FUD... http://snap.sonydeveloper.com/
Blogspam. Here's the direct link: http://www.fast.org.ar/
Whoa. So glad I waited to take it until next semester...oh...wait...
It is kinda sad that GT is dropping SmallTalk. I thought it was especially important for two reasons: providing "real" object-oriented programming to students early in their curriculum, and learning a new programming syntax wildly different than Java/Python (the previous courses). With most of GT CS courses being in C or Java, I loved my brief exposure to SmallTalk. Wonder what they're replacing it with...
&gt; Smalltalk, like Xen, was created on a bet. Does anyone know what the bet was for Xen? [Wikipedia](http://en.wikipedia.org/wiki/Xen) and [Google](http://www.google.com/search?q=Xen+%2B+bet) offer no information. Does the author mean [Cω né Xen](http://en.wikipedia.org/wiki/Cω)? Even if so, I still can't find anything about it.
It's too bad they didn't pick up Pharo. It's also too bad that comp sci students can't be expected to learn many languages, and that CS departments now choose languages based on popularity or industry pressures, and not for elegant language design. As someone who knew a bit about programming before going into some CS courses, I found Java to be horribly frustrating because the class had to spend lots of time hearing "don't worry about what (class|public|private|void|import|.*) means right now."
First, stop what you're doing and go get: http://pharobyexample.org/ Monticello is what you want for version control of your code. It's a Smalltalk-focused distributed version control system and it comes with Pharo (and Squeak, and...). You can set up repos on your filesystem or on remote servers (like SqueakSource, sort of like a poor-man's Github for Monticello) or anywhere in between. Monitcello is pretty robust for what it is designed to do. I am sure you could integrate Git as a Monticello repo type somehow. As for projects and products... sorry, I can't speak to that. I'm kind of in the same boat you are. There are examples of some Pharo apps out there (like Moose, or the Seaside one-click image). The Pharo project also has a Jenkins/Hudson server that might illustrate some of the methods they use to build, test, and package the system. Also, always try the Pharo mailing list. It is *very* active and where all of the most knowledgeable people are.
Thanks for the reply. That book is the one I downloaded to study with Pharo. Glad to hear I made a good choice. I'll read up on Monticello and will join the mailing list.
I'm writing a full length article about the same subject, and have interviewed (via email) Alan Kay. Look for it to appear on my [blog](http://dorophone.blogspot.com/2011/06/cross-post-also-on-new-yorker-about.html) sometime soon, if I can't find a publisher elsewhere. 
Very cool. This looks a lot like Clamato. Is there any relation? I see Clamato's BitBucket has not had any commits for a year.
A tip of the Carolina blue hat to you. The thought of how many people will read that on an iPad makes it all the richer.
Thanks. Now if I only had some reason to learn SmallTalk.
&gt; reason to learn SmallTalk. Seriously. It's one of those things I've looked at so many times and thought "historic" and "looks cool" but never actually gotten around to learning. I'm ashamed to say that beyond time and motivation the whole imaged based thing has been the largest obstacle for me. The idea that I don't open a text editor and type has been a major stumbling. 
I actually philosophically feel the other way - files are an artifact of striated storage devices, just a contrivance that reflects the fact that it was hard to build fast, persistent storage, so you had to split storage between slow, persistent storage and fast, ephemeral storage. Hence files. In many ways, its more natural to have just a structured universe of data, which is what a Smalltalk image is. I think we just aren't used to that idiom, because we've spent our lives working with inferior metaphors and technology. The more I read about Smalltalk systems and Lisp Machines the more I think they represent a sane future direction.
Totally agree with you on both fronts. Mine wasn't a commentary on merit only on familiarity (and thus the embarrassment). 
I did professional Smalltalk development for about 7 years, and I've never, to this day, been as productive as I was using the image-based approach. Having everything live all the time enables experiments at a tremendous pace. The biggest hassle is deployment. That always was a pain. 
Can you elaborate somewhat? I'm curious about this aspect of the system.
Have you tried Dolphin Smalltalk? It has pretty easy deployment into an exe file. 
Sorry for the delay. I was out of town for a bit. The image based environment is great because it allows rapid experimentation on live objects. You can rapidly switch back and forth between coding and executing to kind of get a feel for things. You can also use code to operate quickly on live objects (much like you might operate on data in a database) based on object metadata. For example, maybe you want to switch from a Dictionary-based storage mechanism to one based on instance variables. You can write a script to effect this change in no time flat by operating on the objects at the meta-level. The immediacy and responsiveness of the environment are something that you really need to get a feel for before you can completely appreciate it. If I was still coding, had my choice, and all else being equal, I'd certainly dive in with Smalltalk before any other system I've ever used.
I haven't done much coding in the last ten or so years, so I haven't had a chance to try many of these systems. It might be fun to give it a whirl, though. Thanks for the tip :)
Sounds a lot like SLIME with CL. How come you don't do Smalltalk anymore?
&gt; Programming languages started with the imperative paradigm but they rapidly bifurcated into two mutually contradictory paradigms - functional and OO. Once the bifurcation was complete, the imperative paradigm ceased to have any importance. Beyond being a tool of mentally incompetent brainwashed morons and those desperately maintaining obsolete code of course. &gt; The functional paradigm rejects all notion of modifiable state and orders everything around verbs so that all sentences are verb-object-object. The functional paradigm rejects state and objects so violently that it denies subjects exist. As a direct consequence it is blatantly unnatural to the human brain, contrary to physical reality, and contrary to human consciousness. Only math lovers find the functional paradigm attractive or useful which makes it useless to the rest of humanity. Okay, I've read enough to see that this guy is full of nonsense. Nothing to see here; move along... P.S.: Edited to fix a typo.
Decided to do a PhD in operations research, so mostly using math, stats, and simulation software these last ten or so years. I was doing Java for a while in late 90s and early 00s because that's what everyone wanted, but I spent more time configuring everything than I did actually producing code. Eventually, I got tired of fighting the systems all the time. 
I pretty much came to the same conclusion at the same point. However, I read on to watch the train wreck unfold. Basically, he calls a lot of people stupid. In some cases he gives reasons, but in others the reader is simply left to surmise that people are stupid solely if they disagree with the author's way of doing things. It's pretty clear he likes lisp, but he only gives scant attention to the question of "if lisp is so great, why isn't everyone using it now?" Personally, I like lisp. But I also like python, and C, and Objective-C and Smalltalk. I'm not such a big fan of java (I'll use it when forced), like C# even less (again, will use it when forced) and loathe C++ (will simply quit if someone attempts to force it upon me). However, I don't call C++ programmers stupid simply because they share a different point of view to me. 
Operations research sounds like a lot of fun. My PhD is in computational neuroscience, but it sounds like the methods overlap a lot. Awesome. Too bad about Smalltalk, though.
Very cool. I don't know much about neuroscience but the concepts behind biological computation are fascinating. I read a book called "the quantum brain" that talked about the possibility that the brain can amplify quantum phenomena, including computation. Almost made me want to go back to school. I hope you enjoy the field ;-)
The gst command takes files as arguments. I'd try a "main.st" that just handles command-line args and runs your "main" code.
Git anyone?
Ah, it's hidden across Number and ReadStream. s := 'ff'. x := Number readFrom: (ReadStream on: s) radix: 16. Thus x is 255.
Try [this](http://c2.com/cgi/wiki?SmalltalkCaseStatement).
That page greatly confuses me. It appears to be a description of hypothetical syntax that doesn't actually exist in Smalltalk, so I don't know which snippets are real. Please give an example of real Smalltalk code that emulates C-style or ML-style switch-case expressions.
Why do you say it's hypothetical? If you scroll down, you'll see the `Case` object being defined, and the `switch` method added to the `Object` class.
Aye, fully functional code is there. It just took a while to weed through extra crap. Fully 50% of the page was either nonfunctional Smalltalk code or code from other programming languages. The last 30% is backtalk: &gt; I would contend that in normal OOP there is no real need for a switch statement. Oy!
I don't think you should've deleted all that. It was copied off a wiki that no longer exists. All that exposition was necessary to explain why the final code looks the way it does. 
Here's a compromise: Start with functional code, then describe why it looks that way. Use headers to indicate which parts are fantasy, which parts are from other languages, and which parts are real, working Smalltalk code.
You deserve up votes for linking to that... This is part of the beauty of Smalltalk - adding one simple object adds basically a whole new construct to the language. 
I had not. It looks interesting for more team based development, and obviously you have to use GIT (which I prefer but some don't). My focus right now is more towards people who just want a code snippet reviewed and don't really have everything in a repository. Though I do plan on adding review creation from a repository down the road. Thanks for the link though looks like a solid project.
Gah! Juan's lazer eyes are still looking at me!
LAZERS! :U
Squeak.org has a good selection of [Squeak and Smalltalk books and documentation](http://www.squeak.org/Documentation/).
http://stephane.ducasse.free.fr/FreeBooks.html
I've have reading 10 pages and I'm still reading ;) thx
Since my initial dive into Smalltalk used the Pharo environment, I highly recommend their free book [Pharo by Example](http://pharobyexample.org/).
The webpage is light on details, but it mentions that they have some things working with the next features being Object structure and Message sending. I'm a bit of a Smalltalk noob, but what parts of Smalltalk could they have without Objects or Message sends? [edit formatting]
I'm a bit confused: Pharo is based on Squeak, and all Squeak VMs have been written in Smalltalk, not C. Specifically, in a dialect called Slang, which has a 1:1 correspondence to ANSI C. The advantage of this is that you can then debug the Squeak and Pharo VM kernels using the Squeak debugger rather than needing to use some C-based one. I fail to see the advantage of using an intermediate language that doesn't have the features of the Squeak debugger. Speed can be gained via the Cog JIT VM, or by using NativeBoost (at least on Pharo) which allows you to write methods containing snippets of x86 machine code with Smalltalk and compile them at runtime, that can bypass the VM completely and call external libs or other SMalltalk methods that are themselves written in NativeBoost x86 assembler.
Awesome. Thank you for the information. I remember homoiconicity from my computation theory class in college now. I was looking more into dumping source code for specific objects (like classes) in ruby or python, rather than the state of the world. I definitely need to refine my question a bit.
You could make a case for saving an image file to be considered a form of serialization but it would require some unhelpful pedantry. “Serialization” usually means writing a graph of objects out in some form that could be saved to a file or more often streamed over a connection and then read in (either at a later time, or in a different address space, or both) to create new, and different, but equivalent (or nearly so) objects. Smalltalk can do that, of course, but saving an image is not the same thing. It may be helpful to consider that when Smalltalk was first developed it's [target platform](http://en.wikipedia.org/wiki/Xerox_Star) was single-user machines which might not have much of an operating system underneath the Smalltalk (or whatever) runtime.
This has been the bible wherever I've been: [IBM Smalltalk, the Language](http://www.amazon.com/IBM-Smalltalk-Language-Addison-Wesley-Technology/dp/080530908X/ref=sr_1_25?s=books&amp;ie=UTF8&amp;qid=1353354627&amp;sr=1-25&amp;keywords=smalltalk)
&gt; I mean, what is wrong with dictionary at: key put: value. ? Nothing, but the problem is that some methods don't follow a structure that would allow such naming, instead you have for example NSCalendarDate with: dateWithYear: month: day: hour: minute: second: timeZone: Where the first parameter gets mushed into the method name and breaks the symmetry with month, day, etc. It looks extremely awkward. But I think I somewhat get the point, I shouldn't think about those things as named parameter, but instead as more of a way to break up the method name into something that reads like a English sentence. Looking a bit more through the OpenStep documentation, for most part the naming reads like natural language, only sometimes they get abused as named parameter like in the `dateWithYear` example and things look awkward.
I have always been bothered by the method-name-as-first-param-name issue. That aspect of it right there kills named parameter order independence, which is a lovely thing to have.
&gt; That aspect of it right there kills named parameter order independence, which is a lovely thing to have. Not necessarily, sometimes the order doesn't matter to things making sense, other times they do. Consider: history at: num ifAbsent: [ "thing" ] does it really make sense to accept history ifAbsent: [ "thing" ] at: num ? I'd submit that no, it does not, this code reads like shit. If order-independence makes sense, it's easy enough to add messages with the relevant orders, you could even automate that, but it should not be assumed that parameters can be swapped around nilly willy because they usually can't (for readability purposes, technically you can of course put them in whatever order you wish to). Furthermore, strict ordering of parameters — and making the formal parameter name and its "tag" independent — allows for sequences such as BlockClosure's `on: e1 do: b1 on: e2 do: b2 on: e3 do: b3` (which allows handling three different signals). In fact, this demonstrates the importances of both non-swappability (what would the message `on: on: on: do: do: do:` mean?) and the ability to duplicate "tags".
&gt;That aspect of it right there kills named parameter order independence, which is a lovely thing to have. Why? I see no value in that property. What, exactly, does this allow you to do of any significance? I'm quite certain it makes things harder to remember.
You might note that dateWithYear:.....is a method that creates a new date. Nice to know what you're getting back, eh?
Along with the other good comments here, it is extremely important to note that the method dispatch is **dynamic**, in the general case based on something like hashing the concatenation of the parameter names. This doesn't say much, but I thought I should link *something*: http://en.wikipedia.org/wiki/Dynamic_dispatch#Smalltalk_Implementation As already argued, there are good reasons not to provide order independence, which would be very costly to provide (sorting the parameters into a standard order before performing the hash and then dispatch). Dynamic dispatch is very expensive to start with (speaking as a compiler guy), which is why everyone goes to the trouble to cache it to make it an expense we can live with. Also, as said above, the English-like syntax is considered very important by the Smalltalk community, and masklinn's ifAbsent example illustrates that English does not generally have order-independent clauses, and it is considered far more useful than not for Smalltalk to do the same. Along those lines, choosing good method parameter names in Smalltalk is a high art, and can lead to far more readable programs than carelessly chosen ones. So no, not just a historic artifact; this is part of the heart and soul of Smalltalk. Similar comments apply to the OO subset of Objective-C, and to its implementation.
Smalltalk syntax is entirely reflective. The language is defined in terms of itself. You can make Smalltalk code do the most amazing things, (including interpreting EBNF expressions of a different problem space.) This means that you can create objects and oriented code for those and other classes to define new/novel "statements" in Smalltalk itself. I didn't like the fact that Smalltalk didn't have a case stament, so I wrote one. (Actually I wrote methods for Object and other classes and a few other classes and methods to handle "case:" and "cases:") In Smalltalk/V with its caching interpreter-compiler it was efficient after the first invocation of the code and it didn't need to be re-interpreted or even re-compiled if you saved the image.
A very sad day for Squeak Smalltalk
Fuck. That was unexpected. RIP Andreas.
wow. This is a huge loss for the Squeak community. RIP Andreas.
Well, if someone were to create a smalltalk dialect that does this it would be curried. When you call array at: 5 it would return you a closure that takes a put: so something like [ put: value | ... ] so this would implement currying and partial function application into smalltalk
Yes, I suppose you could do that, but if your point in saying this is that it would make parameter order independence cheaper in Smalltalk, I'm afraid I don't see how it could. Each parameter curry would have a dynamic cost in itself, even if the final method dispatch becomes cheaper. Currying and partial function application might be good ideas in Smalltalk, I just don't see how they fit in to the topic of this thread.
you will have less methods overall and less method calls right now (something first: a) will call (something first: a second: default) which might call another method etc. maybe it's possible to implement (something func first: a) so that it uses the same stack frame as a safe optimization [ first: a | ^ first: a second: default. ; first: a second: b | ... ] in this case it's not currying, it will override it and jump into the other part with a default value you might have to end the argument list with something though maybe the syntax now changes to something func first: a : to actually execute the curried method since something func first: a would return [ : | ^ first: a second default. ; second: b | ... ] and you have to execute that closure by passing an empty argument ... I haven't really thought this through
Not sure why as of yet, but I can not open it on OSX 10.8.3. Many other people on OSX 10.8.3 do not have this issue. On my mac; the application has the dreaded circle slash; and the operating system says it is damaged or incomplete. Squeek 4.4, earlier Phoro's and seaside all work. It seem to effect only the Pharo2.0 all in one. If you know how I may fix this - I would love to know...
&gt; compile-time We were talking about *dynamic* dispatch; by definition, that is not resolvable at compile-time. &gt; If the arity of the callee is fixed and all that changes is the order of parameters at the call site If it is dynamic, and if it has a bunch of parameters, not just a tiny number, then it seems like the dynamic renaming would be the standard cost of sorting, O(n log n) for n parameters. Even if you figure out a way to do radix sort, the cost of that sort would appear to overwhelm the overhead of the dynamic dispatch itself, which is already considered somewhat painfully expensive. If we were talking about statically-resolved dispatch, then sure, I personally really like order independence; it's just a matter of being practical. Also, as someone who has implemented such mechanisms in my professional work, I just wanted to get the issues across -- I don't otherwise have an iron in the fire. In particular, if you have some bright ideas for a new approach in a new language, I would certainly encourage you to go for it -- but to be aware of the costs of any proposed features, that's all.
*We were talking about dynamic dispatch; by definition, that is not resolvable at compile-time.* Yes, but in Smalltalk semantics, you're dispatching the message send according to the selector; this is an orthogonal issue—it seems that you've missed my point and that you're talking about something completely different than I am. So I'll try to make it clearer: The receiver's method is *not* resolvable at the compile time of the call site, but if the only thing you're attempting to do is to get parameter order independence, you can catch the unimplemented method, generate a reordering wrapper on the fly that will re-send the parameters to a method you actually found in the receiver (in the proper order), proceed, and let the inlining logic deal with it. This doesn't need to be performed more than once per (receiverClass x selector) combination. The actual methods providing the functionality in diffferent receiver classes don't even need to have compatible selectors; this approach deals with it nicely—the wrapper is always installed into the receiver's class so different wrappers can delegate the send to methods with different selectors. This also simplifies inlining, because the wrapper-to-actual send is a self-send (which can be resolved statically by the VM, of course), and if both the wrapper and actual method get both inlined (this is likely, because the wrapper is trivial - a single re-send), the whole thing becomes a simple exercise in copy-propagation in the data flow graph so the wrapper overhead goes away. This only covers static call sites, i.e. hand-written Smalltalk message sends. An (APPLY ...)-style facility would have to figure stuff at run time, that much is obvious.
&gt; catch the unimplemented method, generate a reordering wrapper on the fly that will re-send the parameters to a method you actually found in the receiver (in the proper order) I was talking about the cost of doing *that*. The reordering isn't free.
Really? I'd argue that it's no more costly than the meta-object protocol in Common Lisp implementations: it simply expects the externally-provided resolvers to exhibit certain stable behavior (for example, they ought to return the same applicable method orderings for the same combination of a generic function and a vector of arguments types), and their results get aggressively cached, at least until new code is added and the caches are invalidated due to the change in the global runtime state. Then, the system converges to a new performance optimum after the lookup resolution dependencies propagate throught the system again. The amortized cost of the lookups should be negligible...unless you're writing a short-running command line utility, that is. That reminds me, you'd need an invalidation mechanism if the hand-written receivers change selectors. But that shouldn't be all that difficult, there is already a generic mechanism for observing changes on any objects in core Smalltalk.
I am uncomfortable with the notion that caching *always* solves all woes of dynamic costs, but perhaps you are right -- it would be nice if the overhead was in fact reasonably small in real world code.
For those who never heard of it, the Dynabook is sorta the spiritual grandfather of the personal computer, GUIs, PDAs, smart phones, laptops and tablet computers. [Source material and other related links](http://thinkubator.ccsp.sfu.ca/Dynabook/)
[Functional programming went mainstream years ago](http://prog21.dadgum.com/31.html)
The OpenCroquet branch of Squeak received a custom VM called Cog back in 2009. I'm pretty sure it's being used now by Pharo. Squeak 4.4 also includes it now. One of the features it includes is tail recursion elimination. [Here's a nice write-up](http://www.mirandabanda.org/cogblog/2009/01/14/under-cover-contexts-and-the-big-frame-up/) of what it does by the author.
I don't doubt the authenticity of the book or signatures. They all worked together, the note inside makes sense, and I don't think there is much value in forging the signatures of these people despite them being significant innovators. If you really wanted to make sure you could try emailing Adele Goldberg at Neometron.com. Who knows she might get a kick at seeing the pics.
there is no semantic differences
FWIW, Erlang and Rust also use statement separators, but a statement separator as terminator is an error in Erlang, and in Rust it may change the semantics of the compound (e.g. `3` has type int but `3;` has type unit)
* [Details](http://article.gmane.org/gmane.comp.lang.smalltalk.squeak.general/174905). * [Release Notes](http://wiki.squeak.org/squeak/6193).
so I got it to work with initialize I did: (self isMemberOf: Employee) ifTrue: [ ^ self error: 'Employee is an abstract class. Make a concrete subclass.']. 
That's how its done with Squeak abstract classes, IIRC. Since Squeak was the brainchild of the original Smalltalk team, meant as a direct successor to Smalltalk-80, its good to go back and see how Squeak does things, I think, in order to get a feel for "the Smalltalk Way."
There is a demo online now: http://pharo.pharocloud.com/rickshaw
[Funeral information and memorial book here](http://sollevinson.com/notice.php?id=25422&amp;p=bottom).
It a good place to start, thanks :)
Depending on how experienced you are with squeak, there's always my video series, [Squeak from the very start](https://www.youtube.com/watch?v=Es7RyllOS-M&amp;list=PL6601A198DF14788D) which is meant partly as a birds-eye view of what you find in _Squeak by example_. For many people, especially those who have never heard of Smalltalk before, it is easier to see what is going on than it is to read about it.
so doing a forked solved that but it does not capture key strokes until I do: At + . as in a user interrupt. any ideas?
I made a web application in Smalltalk. That was just awesome to see. Makes me wish there were more jobs out there where I could do some Smalltalk.
No audio on this video?
Is there a recording, transcript or summary available of the talk these slides were for? I'm not very good at understanding things by looking at slides alone.
&gt; Just take a look at the code city of Pharo (built with Pharo for Pharo). Every building is a class, and the red bricks represent the modified methods in Pharo 3.0. That looks pretty cool.
This is mostly useful to someone already familiar with Pharo, I think. For someone who has never used Pharo, like myself, they have some stuff at http://pharo.org/documentation. Those seem to be for older versions, I don't know how much of it applies and how much is outdated. It was very recently that Pharo 3.0 was released -- I suppose with time they'll update these other docs where necessary.
From the page: &gt;I started to be fed up to see all the books I like to be out of print, so I started to contact authors and collect their old books.
[**@mikefilonov**](https://twitter.com/mikefilonov): &gt;[2014-05-03 10:40:20 UTC](https://twitter.com/mikefilonov/status/462542163952541697) &gt;Mozilla Persona bindings for Seaside: &gt;[*smalltalkhub.com*](http://smalltalkhub.com/#!/~mikefilonov/MozillaPersonaSeaside) . Demo here: [*testimagestore.pharocloud.com*](http://testimagestore.pharocloud.com/) [#seaside](https://twitter.com/search?q=%23seaside) [#pharo](https://twitter.com/search?q=%23pharo) [#smalltalk](https://twitter.com/search?q=%23smalltalk) [#persona](https://twitter.com/search?q=%23persona) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/25p33w%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Cool. I've heard about scratch but never used it. I think it's interesting though.
I've been so confused for 10 minutes... Trying to find some pre-announcement about changing ObjC syntax to be more in line with the Smalltalk roots, and then I reread the title.
&gt; What: Program or enhance the game of 2048 using ... If I add pictures of dinosaurs to the game, is that a valid submission? That would enhance the game for me. This description is ambiguous. 
I actually fantasized about exactly that for years.
I guess you can ask their bounding box (which is a rectangle) by sending the bounds message, and check whether those are intersected or not. Maybe there is a more convenient method which I'm not aware of.
go Pharo go :) Pharo 3 already brought us a ton of new features and bug fixes. Can't imagine how cool Pharo 4 would be :) 
this a great video presentation one of my favourites , you should add this to the new website it clearly shows what Pharo is all about. 
I think that's quite elegant. If you're looking for a better solution, what don't you like about your current solution?
I mostly pleased with it, but haven't used too much so far. If the chain is not so long, the +1 unary chain message seems to be an overhead, like in the last example.
I added it to http://pharo.org/documentation
I'm aware of the demeter law and its consequences. I don't think that the first example is a violation. Using auxiliary variables is an option, and many times I would go to that direction, but not always.
It would be nice to include the Gofer installation details for the getting the Playground workspace installed. As someone who is learning to work with Pharo, having clear instructions on how I can follow along is critical. GToolKit is not included in Metacello, and is definitely not part of the core of Pharo 3.0, so there's a bit of a barrier to entry before you can enjoy the shininess demonstrated in this video. 
It's down for me here in Brazil =(
&gt;The purpose of the Smalltalk project is to provide computer support for the creative spirit in everyone. Reminds me of a video I saw about Smalltalk. It was from the 70's or 80's, I think. They were talking about how easy it was for children to start programming in Smalltalk. Anyone know which one I'm talking about?
It's running in low-res mode, looks like shit.
A good way to start is to follow the book: http://www.pharobyexample.org It uses an old Pharo version, but the basics are there, and you can jump to a newer version (and prettier) right after. 
I haven't got any concrete suggestions for you, but I think I can offer some ideas of what to look for and cautions. I came to Smalltalk from a similar background, being mostly a C programmer who had dabbled a bit in the basics of C++. My first Smalltalk programming job was at a company staffed by people with similar backgrounds. I learned the language while there, but not much more. Of course, I didn't really realize this at the time. At my second Smalltalk job I worked with people who had much more experience with Smalltalk and other dynamic languages. I learned much more there, because I got to do some pair-programming with people who understood the strengths of the environment. I really don't see how I could have learned some of the best lessons I learned there any other way than sitting next to someone, discussing the problem, and seeing how they approached it. It was just a foreign way of thinking. The strengths of the language that I learned only at the second place were things like: 1. Being able to open inspectors on any data structure while the program halted at a breakpoint, to make changes to them, then resume program execution. 2. Using drop-to-frame to get to take multiple runs through a problematic piece of code after invoking it only once. This was particularly useful for debugging intermittent problems: once you had a live occurrence of it, you could keep it alive as long as you wanted just by dropping the current frame back to one prior to the part of interest. 3. Being able to compose and execute test code that runs on the same data structures as the program being executed, while in the debugger. I've debugged problems where I could not understand how the program was behaving the way it just did when halted at a breakpoint, composed a quick ten-line query that walked all the data structures available to it at that point, doing a consistency check, and found that the problem was due to the way the context it was provided was set up (so the bug was in code that had already finished executing). 4. [Programming in the debugger](http://lambda-the-ultimate.org/node/12) was a technique I used occasionally, but probably not enough. If you haven't got a Smalltalk veteran handy you might be able to learn some things by watching a live-coding video. I don't actually know whether such things exist, I'm afraid, but I know that there are similar things for Lisp, and I've learned a few things from them.
You can watch my videos. They're meant to complement the _Squeak by Example_/_Pharo by Example_ books by giving a brief overview of how to work with Squeak (or Pharo to a certain extent): [Squeak From the Very Start](https://www.youtube.com/watch?v=Es7RyllOS-M&amp;list=PL6601A198DF14788D) I modeled them on the original Khan Academy videos. 
You could pass this link on to any friend that wants to learn Smalltalk: [Squeak From the Very Start](https://www.youtube.com/watch?v=Es7RyllOS-M&amp;list=PL6601A198DF14788D)
First thing I thought was Craig Latta.
http://amber-lang.net Transcript show: 1 + 1 "PrintIt" =&gt; Transcript show: 1 + 1 =&gt; Transcript
More background info here: http://www.computerhistory.org/_static/atchm/xerox-alto-source-code/ https://news.ycombinator.com/item?id=8490156
This is most valuable because of its historical significance and as an example of ST running in much slower hardware and minimal memory requirements. Nowadays there are many implementations that trounce these in modern hardware, Squeak included.
Pharo is probably the most stable free release. You should probably start by spelling Smalltalk properly (no capitalized ’t’). :) http://pharo.org
Have a look at Laser Game by Steve Wessels. Link: http://squeak.preeminent.org/tut2007/html/
Does it have SDL bindings?
That's good material, thanks! :D
&gt; SDL Yes. The OSWindow stuff in Pharo4 uses libSDL2 as a possible backend. For OSWindow/SDL in combination with OpenGL and OpenCL, have a look at: https://www.youtube.com/watch?v=1Nze9tnwYxY
This is a matter of man power... we just did not yet have the time to fix it. (yes, everyone is as annoyed about it as you, but it will only be fixed when it will be fixed... the sad reality of reality ;-)
+1 for linux mint.
This would be nice on rPI.
Let us know how it goes.
Additionally to what others offered you there is Athens that uses cairo as backend. Wooden is a new game engine it the works but is a 3d game engine using opengl. I am also in the process of porting BGE, Blender Game Engine to Pharo, though I make no promised when I will be ready to release it since I do this just for the fun of it. 
lol epic reply, I think I broke the thumb up button ;) By the way I have a 27'' retina iMac and pharo looks very smooth , maybe this is fixed but I never noticed such a problem a year now that I own this iMac. 
Thank you! I tried to but couldn't find much literature on smalltalk! You just saved my paper good sir!
I bought this when it came out. I used it for Squeak routines I was writing. Is Besset a student of Ducasse?
&gt; by windows-based, whether it's a GUI that has windows (then I would say that maybe every GUI is windows-based) I meant exactly this, maybe it was not the right wording, just wanted to specify that I didn't want a web framework. I'll take a peek at Spec and let you know where I can get, thanks!
Very kool. If only Squeak or Pharo were a programming option in a game engine like Unity...
How about you guys fix the UI/font rendering mess on high resolution screens. Unacceptable in this day and age. I show ppl pharo and the first thing they do is complain about terrible blurry interface.
So I can't have an opinion without working on it (as if it's that simple)? You foolish muppet.
If you're not willing to contribute to the open source project to resolve your complaint, then no. No you don't. Also, name calling. Keep it classy.
great work guys, I have been beta testing Pharo 4 a year now and it has been getting better and better :)
The easiest way to open a browser for a class in Pharo is to select it, and use the hotkey ALT+m (on Windows/Linux). You can also select the **class/keyword** and right-click -&gt; choose *Code search...*, and then the *implementors of it* choice. Here is the different hot-keys that can be of help: [KeyboardShortcuts!](http://pharo.gemtalksystems.com/book/Tidbits/KeyboardShortcuts)
Ok, I know you're not supposed to feed the trolls, specially the kind of spoiled trolls who like to troll on free software and not only expect but demand the world works for free for them, but your post is cleary among the top stupidest posts I've ever read. Not only you show an absolute lack of knowledge and interest in Smalltalk, but in ANY computer language and computer history in general. I'm really happy you didn't understand the first thing about Smalltalk so we don't have to put up with you further than this 13 year oldish rant. To me, this is clearly a sign our UI choices do actually work, at least they work at keeping terrible programmers like you away, which is more than enough to me. Please stick to your mainstream language of choice and go troll your modern 21st century proprietary, multi-million-company-owned text language lovers.
Of course I have "an absolute lack of knowledge and interest in Smalltalk". I tried Pharo to see if Smalltalk would be a language for me. If I would have knowledge about Smalltalk I wouldn't need the tutorial and would know about the VM .... Also, I program in my spare time, not for a job, so of course I lack computer history (and I don't care about computer history by the way) and computer languages because I it's a hobby, nothing I'm forced to do to pay my bills. And I'm near 30, just in case you dig out that "OMG KIDDO" argument again. Also, I orientate my expectations around the things other languages / IDEs / tutorials offer me. Compared to Java/C#/Ruby/Rust I find Pharo to be lacking everywhere. It may be great for people using it everyday and being fluent in the workflow &amp; language, but for a total new beginner it's pure coder hell, sorry.
Yeah, sure, I just code in a total unknown language to improve my IDE up to a modern standard .... How about no? Other than that, thank you very much for your detailed answer. I don't feel very comfortable to be pushed into a complete trapped environment that looks/behave/works total different than the systems I'm used too for no good reason. And saying that "it's just the Smalltalk way" is okay as long as there is a reason behind that - legacy reasons have no value for me like the left click menu. Btw, right clicking is Windows/Linux/OSX convention, so 99,9999% of the OS out there. &gt; It's a tutorial, not a course. A tutorial is a lightweight course.
Shameless plug time: once you get past the download video (#1) of my youtube tutorials, [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D), you'll get a decent (I hope) demo of the very basic features of Squeak and Pharo (if there are Pharo-specific things that don't work right, please let me know and I'll redo those videos with Pharo in mind). Smalltalk isn't like your average modern language. It's a lot of fun to play with once you get past the first stage, but some people find it hard to get past that first stage. Hopefully my videos can help.
&gt; There's a few ways to do this. Filing out / Filing in is one way. There's also package managers, etc. Let's say I have a friend who starts the tutorial at the exact same time as I do. How can I send him some code I just wrote without leaving the Pharo VM? For example, can I join some IRC channel? Send him an e-mail? Or maybe some specific tool which comes with the VM? Can we easily synchronize the states of our VMs?
Hey, thank you for those videos. Is there any way I can watch them inside the Pharo VM?..
I'd say the most intuitive, supported, and "best" way to do this would be to use the package managers. Both Squeak and Pharo come with the Monticello Browser, which is actually a distributed revision control system (it probably doesn't live up to git, but it serves the Smalltalk communities well) and by setting up a private repository for you and your friend (through something like squeaksource, or a "local repository" sync'd via dropbox might work -- dunno), it'd be real easy to share code between the two of you.
It's a real pitty because there is tremendous potential behind Smalltalk (and Pharo itself). I mean at the end of the day they're a bunch of volunteers and academia types, so resources are scarce. I don't think people ought to be angry at them. Whatever scarce resources exist though, should *definitely* be used to fix the UI issues (HiDPI, performance, icons/themes, keyboard shortcuts, threading) rather than wasted on esoteric frameworks or work that's not **immediately** visible to newcomers. Once these UI issues are fixed, more people will come and **stay** and resources will increase. You need new blood and with the competition and innovation that's been going on in the programming arena these days, you really can't afford to have people jump through hoops or force them to use an atrocious environment (in terms of looks/perceived performance and user experience). They made some real progress with the Squeak -&gt; Pharo move (Squeak was rotting in obscurity for years but Pharo looked "fresh" and immediately picked up some new blood), but it's not enough any more. They need to do a lot more. I have a top of the line 15 inch retina macbookpro. Pharo looks and feels like total crap on this machine. Unacceptable.
I completely agree with you. I think Pharo has a lot of potential and smalltalk IS really nice to work with once you get over that initial hump. It's just the general attitude from many of the folks who respond to any criticisms that makes me angry. I think Pharo would be better with more people using it, when someone new is frustrated and confused by it well, I just don't think they should be insulted and called an asshole which unfortunately seems far too common.
Note, I only called him an asshole because he did act like an asshole. :) He could've framed it in a, "I don't understand" or "It's different and I don't know if I like different" way, but instead, when he didn't understand, he blamed Pharo, and when it was different, he rudely implied deficiencies.
Forgot this one: for quick sharing of code there is a kind of integrated paste bin thing. Shared workspace is the name I think. Now, one can use gists on GH for that. That's more my taste. And Pharo supports Git in full. I use that all the time with branches merges and all on my Pharo code. 
A long time Smalltalk philosophy was to do *everything* in Smalltalk. There was /some/ validity to this since with live coding, Smalltalk had one of the greatest debugging environments around. However it developed a reputation for not playing well with others with a slow FFI and external source code control. Pharo sees these as important areas and is why it introduced NativeBoost as a fast FFI, works with git through Monticello, and is working at integrating libgit. 
First of all hello and welcome to the Pharo universe. "why use it at all?" Pharo is not your usual programming language that follows more or less a similar path and has some extra features here and there. Pharo is a rethinking of the concept of programming. There are of course languages out there that do this like Lisp and Haskell. However with Pharo its even more extreme because we are not talking here about a weird language, actually the language is pretty simple but completly diffirent enviroment. Now as you can imagine I was not exaggerating when I said "Pharo universe". As you can also imagine this come with the cost of learning something that is very unfamiliar. To answer your question of what is the selling point of Pharo. For me at least is live coding. That is the ability to code an application while it runs. Its not the only feature but , again for me, is the biggest one. Live coding is not something that Pharo invented , it took it from Squeak that took it from Smalltalk that took it from Lisp. However Pharo takes live coding much furhter than other solutions out there. Because Pharo is so hardcore when it comes to live coding that means that many libraries that in other language will tie to C libraries , in case of Pharo they are remade in Pharo. This includes the GUI. That means losing speed , because Pharo is not as fast as C but also losing native look. What you gain ? you gueesed it , live coding. That means even though the GUI can be slow at times and not up to your standard its also far more flexible than whatever you tried before because you can hack it while it runs and change it a fundemental level. Basically Pharo is a paradise for people who love to experiment on the fly, make fast changes and modify anything . If the code was just an interface to C code that would put a significant barrier to how far your hacking can go without leaving the comfort of Pharo live coding enviroment. So in the end Pharo is not better, is just diffirent. Whether you need that diffirence only you can answer that after giving Pharo a serious try and equipment with the patient and the expectations of an unfamiliar / unconventional enviroment. To conclude if you need help we are with open hands to anyone who wants to learn Pharo . We are here to help you have the most fun you can have with coding. There is an irc channel in freenode where you can pop in to chat with us called #pharo , the mailing list is ultra friendly to begineers and I have made a series of video tutorials about Pharo including why one would want to use Pharo when there are programming languages out there far more popular. You can watch the playlist here and should be enough to help you make Pharo apps even if you have zero experience with coding. https://www.youtube.com/watch?v=Ol5ivaEATLQ&amp;list=PLqbtQ7OkSta0ULYAd7Qdxof851ybh-_m_ and here is the pharo website http://pharo.org/ which comes with a documentation section 
&gt; That means even though the GUI can be slow at times and not up to your standard its also far more flexible than whatever you tried before because you can hack it while it runs and change it a fundemental level. Uhh ... but I don't care about hacking my GUI, I want a fast reacting, well designed GUI from someone who knows UI design. 
then you dont care about pharo. You will be far better with languages like C/C++ , objC etc that will offer you native support. 
I've been involved with Pharo for about two years and generally found it a very welcoming community. &gt; you'll find that any complaint about smalltalk/Pharo, and often times even asking a question with the slightest hint of frustration, result in replies that basically amount to "if you don't know, then FUCK YOU". This is an exaggeration. It is true that unconstructive non-actionable grizzling gets jumped on hard, but constructive criticism is always (mostly) welcome. I think some of the old-timers get oversensitive to complaints about how Smalltalk is different from the norm, when its actually those differences that we value. It certainly depends on how the criticism is phrased. Also there are two mail lists: pharo-users for newcomers and pharo-dev for those contributing to pharo. The pharo-users mail list is gentler and gets quick responses to "why isn't my code working" or "how do I do Y". Some of the UI criticisms are valid but once I "got it" they were insignificant versus the gains.
&gt; smalltalk was the first then it must be the best You are right, this is not a good argument. &gt; It's not outdated, it's CONVENTION it's the smalltalk way The thing with conventions is that whatever they are, you get used to them, and also its hurts to change when you are used to them. This is the same whether its old-timers needing to align with the rest of the world, or newcomers needing to align with the Smalltalk-way. However the people developing Pharo are developing it for themselves to facilitate development of their applications. They see other priorities for development than expending effort to change conventions that are working well for them. &gt; essentially tell you that you're smalltalk is the "most productive language I have ever worked with" I see this attitude more from newcomers (once they get over the initial hump) than old-timers, particularly newcomers with extensive experience in other languages. So I feel there is something special here. We just need to close the gaps.
Some work being done on icon set... http://forum.world.st/ANN-Idea-icon-pack-now-in-Configuration-Browser-td4823136.html
great work guys. I migrate all my projects from Pharo 4 to Pharo 5 with zero issues so far. Keep pushing forward!
&gt;Left clicking anywhere on the screen opens the menu? How about ... I don't &gt;know, the right click since Windows 95? Left clicking the desktop on the main Pharo window opens the World menu. This is a Pharo convention. You can learn more about it in the “Pharo by Example book” downloadable from the www.pharobyexample.org website. The book describes a specific version of Pharo - Pharo 1.1, downloadable from the same web site but don't let that stop you. It simply makes the screenshots look the same on your screen and in the book. You can use Pharo 4.0 with the book if you like but expect that some things no longer apply. If you follow the book, you will learn Pharo conventions. 
&gt;Tutorial WTF 2: Open the so called "Browser", to close it I can click "OK" &gt;at the bottom. Everywhere else (yet) I have to click the "X" at the top &gt;...... someone should take some lessons in GUI design. Pharo GUI is very consistent in the sense that you have the same icons on every window to “Close”, “Minimize” and “Maximize” at the top right. This however does not apply to modal dialog boxes. And, most likely you have just encountered one. I assume you have modified a method in the browser for the first time. When that happens an “Author identification” dialog box pops up asking you to provide your name. This is the name that will be used to identify changes to the system performed by you yourself. You should have chosen a name like the example FirstnameLastname provided substituting your first name and last name as appropriate. A name like that would help you and everyone else you share your code with identify the changes you have performed yourself. The problem with this dialog box is that it has two buttons – one named “OK” and the other “Cancel”. And you cannot make it go away by clicking “Cancel”. So you have probably just clicked “OK” without reading the dialog box text. Thus you have identified yourself as “FirstnameLastname”. A more appropriate name for the “OK” button in this particular dialog box would be “Use this name”. This might make you pause and consider what it is the dialog box wants from you. Or it might not. But in any case, it would make it easier for tech support to identify what you were doing. You would have to say you clicked the “Use this name” button. There are few dialog boxes in the system with a “Use this name” button. So it would be easy to figure out what you were doing. There are many dialog boxes in the system that have an “OK” button. So clicking an “OK” button does not tell anyone anything about what it is you were doing. 
&gt;Okay I'm on page 13 and have yet not seen any real code I could try out. &gt;Not even a simple "Hello World!". The only thing the tutorial does is &gt;showing me the syntax - that's NO DAMN tutorial. All those expressions you have been selecting and then right-clicking the selection and then selecting “do it”, “print it” or “inspect it” from the local menu are real code. The “Hello World” example is at page 17. 
&gt;Okay I try to make a new project - but the menu doesn't offer me nothing &gt;for that case? I do know that Smalltalk is different from Java/C#/Rust/Ruby &gt;I have used but THEN the TUTORIAL has the TASK to show me how it is done &gt;the Smalltalk way. The thing you call "Tutorial" is the worst piece of text &gt;I've seen in my whole life. The purpose of the tutorial is to whet your appetite by teaching you a few basics and pointing you to the “Pharo by example” book, a $32.90 value that you can download for free from the www.pharobyexample.org website if you prefer. You can learn the Pharo way in the book. Buying the book is a good way of supporting the Pharo project.
I know this post is old but I wanted to mention that there is Dolphin Smalltalk. It's basically a windows-focused smalltalk. I enjoy using it a lot more than pharo mainly because it looks nicer and is faster. It's also very easy to make native gui's with, it has a view composer similar to how you composed gui's with visual basic. The only downside is you can't build an exe with just the community edition of Dolphin. If that isn't a dealbreaker I'd say give dolphin a try.
1. Get Pharo. 2. Work through the small tutorial that is in the introduction when you open Pharo. 3. Get the book, Pharo by Example (its free online). 4. Build something with Seaside (very easy, tutorials and documentation exist, and web development is all the rage these days). Smalltalk is also about the environment much more than most languages. The entire environment is live, customisable, and is a big part of development. You may miss it when you move to other languages :-)
So your complaints are what, that Pharo is different? You can't create a new project because you mould the existing environment into whatever you want it to be. You create a new window, new classes and methods. And that's your app. And when you want to deploy it, then Pharo gives you options for packaging it. As for the GUI, it can be whatever you want it to be. Pharo gives you tools and options. And yes some of the default options are unintuitive, or very different from what you're used to, but the magic is the fact that everything is customisable and can be changed at runtime. From the sounds of your rant though, you're not interested in Pharo. Sounds like you should just stick to Visual Studio, C#, and whatever GUI system MS is pushing these days...
I'm actually taking a web development program in college right now, so this would be perfect for me! I've read a little bit about Seaside, and I've seen their list of example pages. Have you built anything with Seaside, or do you have any links to projects that aren't shown on Seaside's homepage?
&gt; Hey, thank you for those videos. Is there any way I can watch them inside the Pharo VM?.. Not that I am aware of, sorry. 
With respect to Morphic, check out [Lively Kernel](http://lively-kernel.org), which is Morphic implemented in Javascript for the web. 
Well any explicit 'how-to' should defer to Tim Rowledge's work, which I didn't want to copy/mess up (I actually email-talked with him first) - from MagPi: WARNING! AS BEFORE THIS IS A DEVELOPER RELEASE, AND NOT FOR BEGINNERS! Eben Upton 11th Feb 2014 Also, there's a separate subreddit for Squeak I just wanted to give a flavour of ST's philosophy to those who play with Raspberry Pi. One of Alan Kay's quotes that gets ignored in very many descriptions of ST is: "People who are really serious about software should make their own hardware." Alan Kay Which goes a long way towards explaining why ST failed on pristine PCs sitting beside flowers in vases and maybe should be looked at anew by makers.
Ephemeric cloud Quick Start Video: https://www.youtube.com/watch?v=a1GfuT9M4qo 
Pharo project is moving fast, so it can be a bit confusing. I'm not sure what you're trying to do. 'System Browser' from the World menu should be all that you need. To search for methods you want 'Finder' which is in the World menu under Tools.
yes pharo has massively improved. Take a look at my GTSpotter tutorial --&gt; https://www.youtube.com/watch?v=mNh6VtPy8m4
congratulations to Squeak team , I am very glad they keep moving forward :) 
&gt;Why Aren’t People Using Smalltalk? The crickets over on [Exhibit A](https://www.reddit.com/r/smalltalk/comments/3gpkwt/pharo_14_macbook_i_cant_get_the_halo_to_appear_on/) aren't an encouraging sign.
I love Pharo, and I'm predicting it will have a very healthy future. However, I think [this talk](https://www.youtube.com/watch?v=YX3iRjKj7C0) makes some good points. In my mind the biggest question is 'is the average programmer too dumb to use sharp knives?'. I hope that the answer is 'no', but I'm not sure.
As sharp knives go, C++ is far more dangerous. As Bjarne Stroustrup said: "C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do, it blows your whole leg off." I might add that any complex programming language can get a developer into trouble. C++, Scala, D, Vala, etc. There is no substitute for syntactically simple languages like Python, Go, and Smalltalk when it comes to ease of programming. For the record, I'm a pretty average programmer with over 20 years experience writing device drivers, financial/database applications, etc., using C/C++, Tandem TAL, Fortran, and C#, and Smalltalk is not in the least bit dangerous for me.
Yes.(?)
I agree with Ward Cunningham about Smalltalk being more dangerous. He said; "What killed Smalltalk was it was just too easy to make a mess. In C++ you got punished for making a mess, while in Smalltalk you could build mess upon mess".
Yeah, if I go by the response here, I would say there isn't much a community to even comment on. 
Well, we use the stack frames reification all the time, because that is what makes the debugger work easily. The debugger is nothing else that a powerful inspector of those objects. Also, return form closures to the point where they were defined, continuations, exception handling, are all features based on that. That said, performance is a real, hard, ever present issue on this. The general advice is "do not reify them unless strictly necessary". Lots of optimizations are required.
Another thing I'm a little worried about is monkey-patching. If stack frames are reified as objects, people can implement functions that walk the stack and break abstractions in horrible ways... Changing the value of your local variables when you call them, in a manner that's invisible. Seems like the more dynamic a language is, in a sense, the more people can write really very bad code. Continuations, do you guys use something like call/cc?
Thank you for the answer. Is it possible to run Pharo interpreter from the terminal in the same way that you can do with GNU Smalltalk? I cannot even start an image from Pharo. So Pharo is more or less like Ubuntu in the Linux world?
Yeah, Pharo is more or less like Ubuntu. To my knowledge (I haven't use Pharo), it doesn't have a command line utility. What do you mean you can't start an image from Pharo? The Pharo environment is a GUI app. If you have a supported GUI, then you can start it.
&gt; people can implement functions that walk the stack and break abstractions in horrible ways Sometimes that is useful. &gt;Seems like the more dynamic a language is, in a sense, the more people can write really very bad code. Perhaps, but people can also write really clever code if they need to. I'm not sure where the extreme distrust of programmers came from (C++ culture maybe) but I dislike being treated like that by my tools. Real power carries real responsibility. Which is fine with me - gimme the power.
&gt; I found mailing list posts from almost a decade ago with people proposing to remove the allegedly rotting Etoys and Nebraska and perhaps other packages, but it didn't happen due to political reasons. And almost a decade later, they're still in there. So the main reason why people is not using Smalltalk is that they are too conservative?
Congratulations! Is it possible to run the Squeak interpreter without the programming environment? Also, why in Ubuntu the Squeak version is 3.9?
&gt; Is it possible to run Pharo interpreter from the terminal in the same way that you can do with GNU Smalltalk? You can evalute expressions from the command line. pharo -vm-display-null pharo.image eval "1+2" People usually use the command line to load packages and deploy applications on a *nix server. pharo -vm-display-null config http://smalltalkhub.com/mc/MyUser/MyProject/main ConfigurationOfMyProject --install=stable You can also use zero conf scripts from here http://get.pharo.org/ to install the image and the vm and automate the full deployment process. 
It does sound very odd. You should go to the Pharo forum and ask them about this. They're usually very helpful. (I don't use Pharo myself.)
I agree with @cyancinic: if you are producing a programming language, it should be to empower programmers, not to baby-sit them. As for continuations, we don't actually use them. It is just that after Seaside succeded and uses them, many people got excited about continuations. We tried and implemented them in our Smalltalk, did many tests in order to understand how they work... and forgot all the thing after. But it could be done, because activation frames were there for us to play with.
Squeak specifically comes across as very conservative to me. (Another example is that there is no syntax highlighting in workspaces.) And Squeak remains the de facto example of Smalltalk with the highest profile out there. So who knows? I won't pretend to know why people don't use Smalltalk though. I'm just a newbie.
Have you tried the old tutorials and found them broken, because of their age? [Smalltalk 80 - The Language](http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf) isn't exactly a spring chicken, but I don't think it will lead you too far astray (maybe an actual Smalltalker can comment?).
Wow "Version of 2015-08-14"! Thank you! If anyone else knows of up to date guides to Smalltalk (Pharo or others) do keep posting!
My videos are a few years old, but almost everything should still be relevant except the version number: . [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D): Starting with squeak programming with as few assumptions as possible . Just about everything in the first few (20 or 40 or so) videos should apply to Pharo as well, except the link for the download.
It worked! Thank you so much. I'll use Pharo 5.
Looks pretty dense, yeah does it still apply well to current implementations?
Very cool! Glad there are video tutorials. Thank you.
I spent four years programming professionally in Smalltalk in the '90s. Here's my take on learning it: The language itself is fairly simple compared to most. While perhaps some of the details of interfacing with the display and operating system are different with modern implementations over the description found in *Smalltalk-80 the language*, I think the essence must still be there (note though that I have not used any of the systems that are current). However, I think the important lessons of Smalltalk are not to be found in books. I don't know how to recommend that you learn them, as I had to learn them from other people. My time with Smalltalk was divided between two companies. At the first, everyone I worked with had self-taught, and they were coming from a procedural (C etc) background. I learned the syntax and how to program well enough there, but I didn't really get it until I went to the second company, where there were a bunch of people who came from a Lisp background, and had some people who'd been doing Smalltalk for a long time. *There* I learned a lot just from reading the codebase and sitting beside more experienced Smalltalkers as they debugged some complicated problems, or just examined new systems we were integrating by watching them do their thing in the debugger. I think learning the power of the debugger was as much work as learning the language, and as valuable - and that was not described in any books I had seen, nor any I have seen since. Here are a few things I learned: 1. The power of dropToFrame. There were a few complicated, infrequently occurring bugs in a framework I was integrating into our system for which this was invaluable. I spent whole days with a live system in my debugger in which the bug was manifest, and I could just drop-to-frame to reset and take another run through it, rather than let it finish and have to wait until the bug reappeared. 2. Being able to execute arbitrary code in the scope of one of the stack frames in the debugger, which would then have access to all the local and inherited variables visible to the method of the stack frame. Writing 5-6 line snippets that would run consistency checks I had just dreamed up was relatively common. 3. Being able to [program in the debugger](http://c2.com/cgi/wiki?ProgrammingInTheDebugger). Using this in conjunction with drop-to-frame is a worthwhile experience. 4. Being able to rely on a fine-grained version control system, like [ENVY](http://c2.com/cgi/wiki?EnvyDeveloper), let me fearlessly make changes to my local copy. I'd use that to version control debugging sessions. 5. I should also mention that the Smalltalk debuggers (at least the ones I used) all showed one's current location in a piece of code by highlighting *only* the fragment being actually executed, which was almost always a finer distinction than the *line* that fragment occupied. So, for instance, one could have something like this: x &lt; 10 ifTrue: [foo for: x] ifFalse: [foo finish]. And one would, at various points in stepping, see **x &lt; 10** highlighted, *then* see **foo for: x** highlighted, and finally see **foo finish** highlighted. Pretty much every other language's debuggers I've worked with would just highlight the whole line, leaving you to figure out which bit is to actually occur next. For the record, my experiences were first with Digitalk Smalltalk, then with IBM Smalltalk + ENVY. Book-wise, the three Smalltalk-80 books are the only ones I kept from my Smalltalk days. I have the Blue Book (Smalltalk-80 The language *and it's implementation*) rather than the Purple Book (Smalltalk-80 The Language), and have found value in the implementation section, which specifies the language in terms of itself. Edit: I forgot to mention a couple of other things: 1. It's pretty easy to write custom inspectors, and to use the source code of the system-supplied inspectors as a base. If you have your own complicated data structures, it can be pretty handy to write your own subclass of one of them, tuned to work with your own code. For instance, I occasionally took the code for the system-supplied *Dictionary* inspector, and made my own inspector that would go through the tedium of walking through linked objects for me and present just the essential information from the chain. 2. **become:** can be a powerful tool in debugging. I've used it to morph live objects in a debugging session into instances of a special subclass of their class with extra debugging hooks. You wouldn't want to do this often, but sometimes it is really useful.
Thank you for your detailed reply!! I'll keep your experience in mind as I search for and go through beginners' tutorials...
I just remembered, you can find the *and its implementation* part of the blue book, which is the part missing from the purple book [here](http://wiki.squeak.org/squeak/64). As an exercise, I think you could do pretty well by using the debugger to step through the standard collection classes (whose source code should be included in the system) as you execute various manipulations (adding, removing, copying, transforming) of them. Also look at the higher order functions **collect:**, **select:**, **reject:**, and there are a few others I am forgetting, I think.
A pre-build image is available here: https://drive.google.com/file/d/0B-bMBVDOi3oTdll3dGJValVIenc/view?usp=drive_web
I don't recommend any alternatives, I like Smalltalk and want it to become more popular. The alternatives I was referring to are the languages that are somewhat popular and **more specifically** the languages that kids are using these days: ruby, python, go, node/javascript, maybe even clojure. They all have robust environments that look great and work even better, package managers that grok HTTPS/crypto/checksums and don't get you OWNED by every punk that can man-in-the-middle HTTP and finally, are not completely ALIEN to newcomers. They are nowhere near as powerful when it comes to interactive development, but honestly, it's irrelevant unless you get the kids using your product. Nobody will give 2 shits about how great Pharo is with live objects if they don't last 10 minutes using it. Pharo doesn't even do retina resolutions right and the environment looks like a bad Eclipse copy made by someone who huffs glue (it's 2015 people, get your act together), has no hardware accelleration, doesn't take advantage of multiple cores, feels extremely slow, has no proper editor inside the environment (emacs/vim keybindings), has an alien package/source management system that is stuck in the 90s and is a major security risk. These are things that rub you the wrong way **the moment you start using Pharo**. They are a lot more important than libraries because as a new user, you view them as serious shortcomings that you'll have to learn to live with. One can always write more libraries but why should one HANDICAP himself for no obvious, immediate benefit when the siren call of the alternatives I mentioned is so strong and powerful? In my view, this is why you don't see fresh blood in the Smalltalk ecosystem. The Smalltalk environment is supposed to be one of the major strengths of the language, yet in Squeak/Pharo case it's been left to rot and is now decades behind the times. You know things are bad when my Emacs can render fonts at retina resolutions perfectly fine, has pixel-based smooth scrolling (backed by OpenGL and hardware accelerated at the OS level), has built-in high performance asynchronous IO and can even do multicore via subprocesses, has an amazing package manager built-in and possibly the best interfaces to every version control system out there. They're even adding an FFI as we speak. This is Emacs that we're talking about not some fucking hipster glittery project, tho there's plenty of them too. Look at the FFI mess in Pharo. It's 2015 and people in the Pharo community are still excited by FFIs in the same way that people in the Python community are excited by asynchronous event loops. Sad really. Nativeboost (haha) can't even do x86_64. How hard is that for someone to write? It's a 4 week project or less and yet, it hasn't been done. Retina rendering? Hasn't been done. I see 10 macbooks for every non-macbook at every ESUG video yet nobody is stepping up to fix this atrocity. Think about what message that sends out and what one can expect from the language. It sends a **crystal clear** message that Pharo is a toy project, not to be used for anything serious. It may not reflect the truth but this is what most newcomers believe. Maybe you will ask then, why don't you do it? Be the change you want to see and all of that. I refuse to invest my precious little free time in a project that I see as pretty much completely dead and with no future potential. If people were flocking to Pharo, if the community had a clear vision about where it's going, if I could only **believe** that things would change, I would be willing to do that. But that's not currently the case. 
&gt; the environment looks like a bad Eclipse copy made by someone who huffs glue (it's 2015 people, get your act together) &gt; It sends a crystal clear message that Pharo is a toy project, not to be used for anything serious. 10/10 rant. As a newbie myself, I came to the same conclusion as you just from the design aspect alone.
You may be right but new users don't even know what Morphic is. They launch Pharo and they see a low resolution environment with terrible font rendering, bad icons, widgets that feel slow/laggy when you drag/move/scroll them and so on. If they get past this initial shock (and that's a big if), grit their teeth and persevere (smalltalk is an awesome language after all) they will discover the rest of the shortcomings I mentioned. It's all downhill from there and it gets harder and harder to justify spending more time with Pharo to one's self .
Try this link: http://amber-lang.net/ specifically: http://amber-lang.net/learn.html
That works, thank you!
Great, I wish you success and I hope this happens. Hopefully it'll look good in retina resolutions too, cause currently it doesn't. 
Yes, the retina issue is a problem...for the demo/development image, what we do is to render using Cairo but then copying everything into the standard BitBlt display, this means we have the same problem as the normal Pharo download. (In addition, there is some issue with font rendering that we need to fix) The final version will work differently: We have rewritten the whole window-logic to not be hard coded in the VM but instead written in Smalltalk. One new backend for this is using libSDL2. This works very nicely, much faster, and will allow for high resolution. We are pushing all this forward, and all of it will hopefully converge in Pharo6. 
There are other articles there as well on Pharo. They are pretty nice as well.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [What system should I use to quickly prototype a new type of document that can be edited by multiple users simultaneously? Squeak? Pharo? : smalltalk](https://np.reddit.com/r/programming/comments/3mk20t/what_system_should_i_use_to_quickly_prototype_a/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Have you looked at the original [Kansas project](https://web.archive.org/web/20010217143325/http://www.sun.com/research/ics/kansas.html) written in Self? 
&gt; They're even adding an FFI as we speak. that was a good laugh :D Maybe you should ask emacs users how they feel about elisp. They hate it. Now go ask Pharo devs how they feel about their own language . They love it. There is your gap &gt;Nativeboost (haha) can't even do x86_64 It can do however Assembly code using Smalltalk syntax and keep the liveness of the enviroment. Try that with your most popular language out there. Oh and the fact that it cant do x86_64 is not the fault of Nativeboost, its the fault of the VM. The VM is on its way to be ported to 64bit. Why it takes so long, easy to explain, people working on the VM are a lot less than people working on the Pharo image. One of the costs of having a small community. &gt; It may not reflect the truth but this is what most newcomers believe. If that is what newcomers may think, personally I would say to them, "off you go, Pharo is not for you". In the end Pharo is made for people super excited about live coding enviroment and sincerly , Pharo is light years ahead. If you dont care about live coding, or its a low priority for you, then Pharo is not for you, period. Pharo for me is a toy, and that is what makes it special. Every time I use it I feel like a kid inside a candy store. It feels a breath of fresh air to escape the stupidity of "modern" coding for a chance and feel like a kid having fun kicking adult asses with your coding skills because you use an environment thinking outside the box. I hope Pharo does not get very popular, I prefer it to remain my secret weapon ;) Oh and by the way none of the things you described as problems are problems in my book and they are not that big either in our community. Which explains why it takes so long to fix them. &gt; I refuse to invest my precious little free time in a project that I see as pretty much completely dead and with no future potential. Actually its quite the opposite , Pharo is steadly growing in popularity. We had all discussion in one mailing list called pharo-dev and another pharo-user where very few people posted. This year alone we had to divert most of the people to pharo-user because we got so many new posts each day and the community is still growing. I dont think Pharo will get as popular as Python any time soon, but it will get more popular. Why ? Because as you said its a toy. Its the materialization of coding fun and once you get used to it , its so hard to give it up. More and more people are joining us and if you look how much they produce you will be amazed because pharo makes them so productive. Personally I am 2 years now with Pharo and I am super excited about its future. PS: A small secret. Eclipse was a smalltalk IDE that was ported to Java and it went downhill from there. 
Not only for "real world" things, people have been using Pharo professionally for quite some time , as you can see from the success stories here http://pharo.org/success I am using Pharo to script Blender the open source 3d application (https://www.blender.org), for the generation of 3d art. I call my project Ephestos and you can watch a small demo here https://www.youtube.com/watch?v=XPGDQc5LUvE So basically I am using Pharo to control Blender There is no limit for what scenario you can use Pharo ;)
That's very cool! I didn't realise Pharo can interact with things outside the virtual machine like this, sounds very useful indeed! Thanks!
So they are using Squeak Smalltalk instead?
The intent is to use a VM that is compatible with any of the major existing Smalltalks including Squeak and Pharo. The main libraries will be Squeak at first, but we hope to [help] complete the VPRI work of rewriting the core of Squeak in only 20,000 lines of code, and use that as the basis for further development towards a post-Self hardware system (that can run still Squeak, Pharo &amp; other Smalltalks as well as Self (?) using the same VM). http://www.vpri.org/pdf/rn2006002_nsfprop.pdf http://www.vpri.org/pdf/tr2011004_steps11.pdf It's all about messaging between processors looking (to the applications programmer at least) just like messaging between objects so that, regardless of where the object lives physically, the programming model is the same. Many existing OOP interpreted languages could use the same processor ISA with little or no modification, if we do it right. Craig Latta's [Context](http://thiscontext.com/tag/smalltalk/) project or something similar will be integral to the the more mature system.
More information about your intended target is needed. Do you want this to run on the web? If so, you can use either squeak or pharo with the Zinc Websockets package to communicate with the webpage clients. The webpage can be programmed in whatever, javascript, amber smalltalk, etc. If you want this to be a downloadable desktop app, you can deploy in either squeak or pharo, use WebSockets to communicate or regular networking (regular sockets or what not, not really sure as I just use the WebSocket package for pharo&gt;&lt;browser or pharo&gt;&lt;pharo). I would recommend that you use pharo. It has more development going on and just looks more professional. That being said there's nothing wrong with choosing squeak if you want. They are not that different, really. 
It should run on users' computers, so that I don't have to pay for time on a server. Server side computation should also run on users' computers (though only when users give it permission to do so). I would prefer to have the server side data stored redundantly on the users' computers, updates being spread peer-to-peer; however, if neither squeak nor pharo support this, then a server to hold the data might be a necessary evil.
Why would they start by implementing hardware squeak? Is it easy to extend squeak to implement self?
&gt; Why would they start by implementing hardware squeak? Is it easy to extend squeak to implement self? Eh, the hardware instruction set, the "machien code," can be made versatile enough to handle the needs of both languages, and there's far more programmers and libraries for Squeak then there are for Self. And Self isn't likely to be the best language of that type that can be created so why limit the project to a language almost no-one has heard of, letalone uses? Besides "SiliconSqueak" is a far cooler name than "SiliconSelf." ;-) By the way, Self was written in Smalltalk originally and in fact, Squeak was created as an open source tool so that better languages beyond Smalltalk could be created, so "SiliconSqueak" has another implication besides just being a hardware VM.
It certainly can. It can use any C library , that alone gives you access to thousands of libraries. I use sockets to communicate with python , JNIport is for communicating with java, C++ libraries can be wraped as C libraries to be used by pharo, there was a library that communicated with R programming language. Natiboost which is included with pharo can also use C and ObjC libraries and dynamically compile Assembly code. PharoJS compiles pharo to javascript. Sky is the limit ;)
I think self could do it.
I believe there are versions of the Squeak/Pharo VM that journal events. Certainly, you could modify Object to log all events, for some definition of "event" and the VM could journal any message send. You might be able to modify Object to journal message sends as well. You'd probably want to make sure that the journaling mechanism didn't journal itself though. Edit: that is exactly why Object is subclassed from ProtoObject (or whatever it is called). You do your journaling in things based on the protobject class, but not IN the protoobject class itself. There's at least one feature for that in Smalltalk already that I adopted to animate message handling in arrays, for example, for my Squeak video tutorial series. https://www.youtube.com/watch?v=O8mimAy5_es&amp;list=PL7FA6D04E58A406E9&amp;index=1 Edit: Reviewing my videos, this shows a bit how I ended up doing it: https://www.youtube.com/watch?v=QAA0mGRAQwY&amp;index=2&amp;list=PL7FA6D04E58A406E9 The MCReciever class actually deals with the proto object class and allows you to intercept any message send to any specific class of objects. In this case, I created animations for specific messages such as #at and #at:put: for array instances that I wanted to animate while ignoring the rest of the messages. That's pretty much the functionality you want, but you want to do it for everything (which is why I suspect you'll want a VM-level solution to keep things fast. 
&gt;How good are the numerical computing libraries in Squeak and Pharo? they're based on the original Smalltalk-80 libs, which were ground-breaking 35 years ago, but kinda old-hat now. They don't directly support input using decimals past normal 32 bit floats, but do support storing numbers as arbitrarily large numerator and denominator, for which you can do simple arithmetic and retain full accuracy in the result. For example: i := 123/131. i inspect reveals that i is a Fraction: (123/131) j := 2352365347635235625/123464567356788345632456. j inspect reveals that j is a Fraction: (2352365347635235625/123464567356788345632456) k := i * j. k inspect reveals that k is a Fraction: (289340937759133981875/16173858323739273277851736) However, transcendental functions apparently convert to BoxedFloat64 (optimized 64-bit floating point object). k sqrt inspect reveals: 0.004229588582670601 so generally, only the 32 bit value is accessible without some finagling which I don't recall how to do. It's relatively straightforward to add external libs to Squeak, and I believe tehre's been work to add Numpy capabilities via the standard extended libraries like BigNum or MPFR (I experimented with MPFR a few years back, but don't know if anyone implemented the interface to the whole thing or not). A little search shows this: http://comments.gmane.org/gmane.comp.lang.smalltalk.squeak.general/177227 Contributions were live as of a couple of weeks ago so it might do what you want. Apparently they are concentrating on Pharo only, but I'm not aware of specific issues that would prevent squeak from working with it.
gnu small talk is rather cool, and it can work together with other stuff. A language that is looking rather interesting for me is [ni](https://github.com/gokr/ni) it's very new, but also looks very interesting, I will have to try it out I think.
&gt; walled off from everything else. That is, of course, the original and traditional Smalltalk philosophy, and in my not so humble opinion, part of the reason that Smalltalk, a superior language in many ways, failed to catch on. I don't know the answer to your question, but I've long thought that such things were important.
&gt; Great, I don't ubderstand all the details, but it looks like Pharo is the better place to be. If you have a specific task you need to do, and the Pharo direction supports that specific task, then yes. Pharo was meant to be a reboot of Squeak without all the excess baggage like e-toys and so on. The problem is that many interesting things depend on e-toys and so on, so you win some and lose some if you choose Pharo OR Squeak. I try to stay current with both. 
You realize that squeak already IS a virtual OS, right?
OK, wasn't sure. The VPRI folk were talking for a long time about rewriting the OS fundamentals of squeak in only 20,000 lines of code. that might be a good place to look to see what they identified as "fundamentals" to be targeted for a complete OS. https://news.ycombinator.com/item?id=1114410
This one is super easy. You can just send a request to the Yahoo weather API. In Pharo, which is shiped with a lightweight HTTP client, for the weather in Greenland : ZnClient new get: 'https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20in%20(select%20woeid%20from%20geo.places(1)%20where%20text%3D%22greenland%22)&amp;format=json&amp;env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys'
You left out some way to display the result, however. Preferably in a nicely formatted way. Edit: this works in squeak: Transcript show:( HTTPClient httpGet: 'http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20in%20(select%20woeid%20from%20geo.places(1)%20where%20text%3D%22greenland%22)&amp;format=json&amp;env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys%27' ) contents. However, silly bug in HTTPClient will cause an actual *crash* of squeak if you use the original URL string from your post. "https" isn't handled correctly.
If you really want Smalltalk, I think you'd be best off writing a Smalltalk VM in elisp and using Emacs. You might be able to port Squeak that way. The problem of course would be that you'd only be able to write your own custom stuff in Smalltalk, the bulk of the macros and such would still be in elisp. Still, take heart from examples like [Ejacs](https://code.google.com/p/ejacs/). In fact, perhaps there's something to that. I think there are Smalltalk to JavaScript bridges, perhaps you could meld the two. In any case, I've not heard of a Smalltalk editor that has any features beyond the standard handful of text editing features that you see in any Smalltalk IDE, and I think these days even those (cut, copy, paste, search &amp; replace) may well be delegated to the host operating system. An alternative would be to grow such a thing yourself, by making a simple framework providing hooks to augment the standard text-editing stuff, and add features as needed. That could be fun, but there'd be the temptation to spend 90% of your time developing an editor in the course of whatever natural language writing you intended to write.
Thanks. Does this have anything do do with Cuis?
&gt;If you really want Smalltalk, I think you'd be best off writing a Smalltalk VM in elisp and using Emacs. That would be a ton of work. Anyways, assuming such a VM is implemented: then what? How would this allow me to customize the fundamentals of my editor using Smalltalk? Emacs doesn't allow customization of the GUI, and uses Elisp only as a tool for programming within the constraints of its existing, extremely limited GUI. It sounds like what you're describing is a way of bringing additional programmability to Emacs using Smalltalk in addition to Elisp, while remaining within the constraints of what can be reprogrammed already using Elisp. This wouldn't allow me to write mindmapping software within Emacs, to flip text upside-down, or to take tablet input to make new characters on the fly. I'm disappointed to hear that nobody appears to have made a powerful natural language editor in Smalltalk. I guess I'll just make my own in Pharo, from the ground up. It will be a lot of work, but this appears to be the only way to obtain what I need.
&gt; Thanks. Does this have anything do do with Cuis? Don't think so. They have their own graphics libs, I believe. Athens, maybe? [Gezira](http://vpri.org/fonc_wiki/index.php?title=Gezira) A glossary of VPRI terms and projects: http://vpri.org/fonc_wiki/index.php?title=Glossary 
I've found this via friend yesterday. It is for some company in banking industry. Sweet thing is that it is for juniors, so it looks like you can learn smalltalk and get paid for it.
&gt; Emacs is *almost* what I want. I'm pretty sure this is not the case, because your conception of *document* is fundamentally different from Emacs' and pretty much every other text editor in the same class, and your apparent vision of an interaction model is also different from that of Emacs. I think you need to go the other way: you want Visio or the like, something with a more suitable representation of what you think of as a document, but with as much customization via a programming language for manipulating *its* underlying data structures. You might look at the apparently defunct [Minara](http://minara.sourceforge.net) as a starting point. It aimed to be the Emacs of vector graphics. You still have some misconceptions about Emacs' abilities, and again you seem perfectly happy to have jumped to them. If you'd looked at [the link I included in my previous comment](http://ergoemacs.org/emacs/emacs_as_word_processor.html), you'd have seen a screenshot of Emacs showing bold, italic, and underlined text directly: no markup visible. It can be done. I don't use org-mode myself, so I don't know why they didn't avail themselves of [enriched text](https://www.gnu.org/software/emacs/manual/html_node/emacs/Enriched-Text.html) when they wrote it, but *that* link should show you of what kinds of markup Emacs is perfectly capable of, which you persist in asserting it is not. ----- &gt; Your questions ... about how newly drawn characters are represented are just details Since your fundamental objection to Emacs seems to be that it is limited in its representation of the document being manipulated, I'd have thought you'd be more concerned with respect to such extensions to the representation. Anyway, I don't see the point in carrying on with this discussion. You clearly want something other than Emacs, despite continuing to use it as the reference point for describing your desires. My only concern here was to refute incorrect assertions about what Emacs can and cannot do, and I think I've at least provided such, whether or not you believe them.
I'm not sure what pace you need but check [here](http://files.pharo.org/books/), especially the Enterprise Pharo ! Also with Smalltalk, once you are a bit familiarized with the system, you find how to do things by exploring the code, which often contains examples or example methods. For instance, say you want to setup an http server. You can use the finder (World menu/Tools/Finder), search for 'http' and find that there seems to be a ZnClient class that does http stuff. Opening a browser on ZnClient, you will find that there is also a ZnServer in the package. The class comments will tell you that the following code start a server: ZnServer startDefaultOn: 1701. If you keep on browsing, you will find that the request of this default server are handled by the class ZnDefaultServerDelegate, which offer the welcome screen. Finally, if there is something you can't find, know that the mailing list is quite active. Good luck !
There is a really top notch 'learn by doing' tutorial that is written for squeak. I suggest you try it. Pharo is just a fork of squeak and everything you learn in this tutorial will carry over. http://squeak.preeminent.org/tut2007/html/ 
Pharo actually has c/c++ interop, as well as java. So does dolphin smalltalk which is great for windows development.
First step is to use the latest documentation for Pharo that can be found here https://ci.inria.fr/pharo-contribution/view/Books/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/UpdatedPharoByExample.pdf Next step is joining a mailing list , I advise pharo-users and the seaside mailing list , and bombarding with question leaving none alive. We Smalltalkers love question bombardment :) 
Sound this could be done in Pharo using the Announcements framework which is already used by Pharo for many different kind of events. 
awesome 
not really and actually both cant do it for the same or more like similar reasons, they have a GIL. Pharo obviously does not name it GIL but its a very similar concept. Both of them have green thread which are not real OS threads hence why they cant use multi cores out of the box. Python has multiprocessing model which as the name implies it uses the process approach I just described about pharo the diffirence is that it has also a sophisticated api for communicating between these processes similar to its green threads. In any case the discussion is really uneccessary you wont find a more optimised language for performance than C and C++, its what python uses to speed up its code, its what pharo uses, its what every language out there uses. 
As I said Pharo has green threads meaning that you can have concurrent code that does not block. For example loading my ChronosManager project via metacello is quite heavy because it download a quite large (for Pharo standards) zip file from github and has to extract and compile the st files, as you can imagine thats a lot of heavy IO that will block your image by doing Metacello new baseline: 'ChronosManager' ; repository: 'github://kilon/ChronosManager:master';load. If you dont want it block and keep using your image while it is doing all those things then just put the code inside a block and use the fork message for example [ Metacello new baseline: 'ChronosManager' ; repository: 'github://kilon/ChronosManager:master';load. ] fork. The only issue with green threads is that they are not OS threads so they are only assigned single CPU , but still you get concurency (not real of course) and non blocking code. 
You could have a look at [TxText](https://vimeo.com/67752734) There hasn't been a strong need for rich text editing in Pharo until now, but I'm sure it's a useful endeavor. Even the basic code editor widget leaves a lot to be desired, and improving its UX would be a great first step. Then mixing in graphics-based interactions for syntax errors, contextual info, etc could be really really cool.
Have a look at [this book](https://github.com/SquareBracketAssociates/NumericalMethods). It describes the implementation of a NumPy/SciPy-like set of classes in Smalltalk. The source code that was associated with the original book is now maintained for Pharo
Hey bud, this is actually a subreddit for a programming language named "Smalltalk". I think you were looking for a subreddit more along the lines of /r/CasualConversation. If you have any interest in object oriented programming, then you should keep poking around this sub! Hope that clears up why your post is stuck at 0 points :)
Thanks for feedback! I'm relatively new to Reddit so this really helps.
Is there way I could change the subreddit?
Hey, that's great! It's been a long time since I've used Windows, but back when I did, I used to love Dolphin Smalltalk. I'm glad that it's still alive.
Caution: This link redirects to **SPAM** (instadatehookups.com). [**yidbvyuvsy.com**](https://www.reddit.com/domain/yidbvyuvsy.com) (aka The Idiot Spammer^^TM ) is a known spam website. --- [**^^Basic ^^Automod ^^Instructions ^^to ^^fight ^^spam**](https://www.reddit.com/r/FightSpam/wiki/basicautomodsetup) 
You might be refering to his [TED talk](https://www.ted.com/talks/alan_kay_shares_a_powerful_idea_about_ideas) ?
Yes, that's it! Thank you :)
Even more than Lisp, you'll find that working in Smalltalk is *different* from what you are used to. 1. No more than there is in Java, C#, Ruby or Python. But, why would you want that? You can wrap up a stripped image and VM into a thing that looks enough like an executable that you won't care that it isn't one, just as you can with Java, C#… 2. Each implementation has its own default image that ships with the VM, there is no one “baseline” Smalltalk image (well, not any more). As far as I know Pharo, via Squeak, is the closest living relative to straight up Xerox Smalltalk-80, but that's not really meritorious by itself. 3. [https://github.com/JumpIntoSqueak/metacello-git](https://github.com/JumpIntoSqueak/metacello-git) But note, and see below, programming Smalltalk isn't about text. 4. To a greater or lesser extent, depending on what they do. Especially if they use GUI components or tricky VM interactions, yes. 5. No, and you'll find that you don't want to. Working with Smalltalk is not about manipulating a textual representation of a program that you think will turn out to do what you want when you get round to running it, it's about interacting with live objects, all the time. Since your Smalltalk “program” isn't a complex body of text in files you don't need a powerful text editor to work with it. Every other crappy IDE that you've ever seen—except the commercial Lisp environments—and that you prefer Vim to, is a pale imitation of the Smalltalk experience. 6. This I don't know. Maybe? Some of the commercial Smalltalks use native widgets but tend to be a behind the curve as native toolsets change. Smalltalk assumes that you never work outside of Smalltalk. 7. This I don't know. Yes, keyword messages are one of those simple seeming things that turn out to have a huge impact on how you write and structure code. You're going to have a really interesting time. Good luck! 
&gt; Smalltalk assumes that you never work outside of Smalltalk. I somehow agree with the statement, but it sounds like Smalltalk can't interface with the outside world, which is not true. For example, wrapping a native Library with NativeBoost in Pharo is super easy and integrate really well with the object model. I think the feeling that Smalltalk doesn't integrate well with the outside world, mainly comes from the fact that : * you can find almost all you need inside, * and when you have to go outside, it often means you go back to the more "classic" way of programming. Which make you wich everything would be done in Smalltalk.
Might I suggest you spend a bit of time watching the [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D) youtube videos? They give you a feel for the Squeak interface, at least from a beginner's POV. You can't even begin to imagine what a truly gifted Smalltalk programmer can do until you've watched oe work closeup (not a truly gifted Smalltalk programmer, unfortunately). I'm hoping to make a few vidoes of a friend working, and then provide a running commentary of how his workflow is proceeding. It isn't at all obvious what is going on until you realize that he's managed to make Unit-Testing part of his coding so seamlessly that you don't realize he's done so until he's finished a coding session and notes that all tests have passed. 
3. Monticello has LOTS of problems. It's still better integrated in the workflow, but the way it handles branching is just… *facepalm* *sobs* At least in the Pharo ecosystem, more and more projects are moving to Filetree and Git. 5. I guess a nice compromise would be to make the Smalltalk text editor work more like vim or emacs (like Emacs does with evil to emulate vim-like modal editing). About full support in an external editor, I don't think anyone wants to have to jump back and forth between the image and an external editor, and while it is technically feasible, I doubt it will ever gain enough traction to be worth the huge development effort needed to duplicate a whole Smalltalk toolset in vimscript or elisp. 6. There was Mars, a binding to Cocoa. Doing that properly is a huge development effort with little traction (from people that have interest, time, and skills to push it forward, that is). Dolphin Smalltalk is now opensource and should look pretty nice, but it's limited to Windows 7. Have a look at [Teapot](http://smalltalkhub.com/#!/~zeroflag/Teapot), it's pretty similar to Sinatra
I'd expect just the basic muscle-memory movement and text editing commands to work…
It would have to be modal, though? That doesn't seem very Smalltalk-y somehow. People do get very attached to their editors, I know, although I've moved from EMACS to vi(m) and back and forth. Shrug.
Sure. But then you could also imagine that the whole browser would respond to keystrokes when the editor is in command/normal mode. Interaction could be very vim-like and the experience could be very nice for someone used to vim. But that would require rebinding most shorcuts across all tools… ain't nobody got time fo' dat
&gt; Ah, I might have phrased this point poorly. What I mean is, if I start editing methods and such in my image, can I "diff" what I have done with what the particular image (e.g. the Pharo image I originally opened) originally looked like? Yes. All Smalltalk classes and methods know their history—in some cases, very far back. If you look inside your Pharo install you'll see the VM, an image and a changes file. However, if you want to see changes across a whole image in one place you'll need to use something like Montechello to manage changesets. That's another thing that's different about Smalltalk. If I wanted to share with you dome code that I've written I wouldn't send you a text file containing my code—it's difficult, but not impossible, to do that—I'd send you a changeset that summarised how I had changed my image, and then you would apply those changes to yours. A good practice with Snalltalk us to save your changes at the end of a programming session and then play them back into a fresh image at the start of the next. 
&gt; No, and you'll find that you don't want to. Working with Smalltalk is not about manipulating a textual representation of a program that you think will turn out to do what you want when you get round to running it, it's about interacting with live objects, all the time. Since your Smalltalk “program” isn't a complex body of text in files you don't need a powerful text editor to work with it. Every other crappy IDE that you've ever seen—except the commercial Lisp environments—and that you prefer Vim to, is a pale imitation of the Smalltalk experience. &gt; This is normal for smalltalkers to say, but frankly it's been one of the hardest things for me to deal with over the years. I'm an Emacs person, not a VIM-head, but nevertheless I miss it when I *am* editing text. Face it, the image is a lot more than text, but writing methods, etc., is still text, and only people who are happy with Notepad will consider the Smalltalk text editing capability to be any sort of upgrade. Is there any way to get more powerful key-bindings when entering text? 
&gt; I'm hoping to make a few vidoes of a friend working, and then provide a running commentary of how his workflow is proceeding. yes please!
Well, what libraries did you use in Java?
Nothing for the website parsing, he wanted it done manually.
So you need something that handles URLs, and something that handles regular expressions, and then just the usual array classes and so on. So your strategy is to find a class that can accept a URL and return the html content of a webpage, and find a class that accepts raw text and parses it using regular expressions. Each modern smalltalk will have different classes that do these things, but you can probably find out which is which by searching the class libraries of a given Smalltalk implementation using words like HTML or "regular expression," right? Then its just a matter of using what you learned by doing it in Java and applying it to the specific syntax and methods of the equivalent smalltalk classes.
Would you happen to know a good place to see smalltalk syntax (we kinda have to learn it as we make this), maybe like a tutorial that shows the uses of arrays and storing data since i doubt there would be one specifically for webcrawlers.
&gt; Would you happen to know a good place to see smalltalk syntax (we kinda have to learn it as we make this), maybe like a tutorial that shows the uses of arrays and storing data since i doubt there would be one specifically for webcrawlers. AH, the best resource (IMHO) for totally beginning smalltalkers with some programming experience is my [_Squeak from the very start_ ](https://www.youtube.com/playlist?list=PL6601A198DF14788D) video series, which is meant to teach what the name suggests (for someone who at least has some understanding of loops and such).
Alright thank you, I will check it out 
After you've gone through my vidoes, the book [_Squeak By Example_](http://www.squeakbyexample.org/) goes more in-depth than I do. The equivalent for Pharo Smalltalk is, of course, [_Pharo By Example_](http://pharobyexample.org/). Other than the source of the application, and the name (Squeak vs Pharo), my videos should almost all apply equally to both. Pharo is a fork of Squeak [found here](http://pharo.org/). Each has its strengths and weaknesses. Squeak is the original open source research tool from Alan Kay and the others from the original Smalltalk-80 team. Pharo was forked by part of the Squeak community that felt that there were just too many directions that Squeak was going in simultaneously to allow for a smooth and coherent revision path that would allow for using it for commercial purposes such as webservers, so they started over with a minimal version of the Squeak libraries and went in a different, presumably more-easy-to-maintain direction, than Squeak itself. The Smalltalk webserver, [Seaside](http://www.seaside.st/) is developed on Pharo and than ported to Squeak and other versions of Smalltalk and of course there is an introductory Seaside book, [Dynamic Web Development with Seaside](http://book.seaside.st/book). That book was actually written in collaborative form online using the collaborative-book-engine/server bundled with Seaside. The online version is shown in the above link and there is an option in the bundled book-engine/server to print-to-pdf. The standard distribution of Seaside is a simple "one-click" application that allows you to evoke a localhost webserver with one button-press. The book-engine is one of several options available for serving webpages, again accessed with a single button-press, so, 10 seconds after downloading and starting up Seaside, you can be publishing a wikie, or a blog or a book online using your own webserver on your own computer. Once you get your Smalltalk version of your webcrawler done, you can trivially convert it to a seaside component and make it available on your Seaside webserver. For extra points, furnish a link to your sandboxed Seaside server to your teacher and let him crawl the web using his webbrowser and your code. It's trivial to do using Mac OS X or Linux, and shouldn't be that hard to do with Windows, depending on how strict your ISP is about homebrew webpages. The same code will work on each major OS that Seaside is implemented on. . Smalltalk is far more innovative than people realize.
&gt; nning, so all the Squeak "forks" have impeccable pedigree. Yes, I never meant to imply otherwise. However, the Pharo community believed that Squeak had gotten to cluttered with stuff that was not maintainable, and/or was using obsolete or unsophisticated classes, and trying to keep backwards compatibility with all the typical Squeak stuff such as etoys meant they couldn't nimbly revise classes as needed to support [basically] Seaside. So, as is typical with forks, Pharo is becoming less and less Squeak-like with each new geenration. If you want to use the minimalist Pharo image + all the new Pharo stuff developed for Seaside and latter projects, you use Pharo. If you want to have access to all the neat original Squeak projects such as etoys and so on, you use Squeak. And of course, people port the latest version of Seaside back to Squeak, so you can at least use the main Seaside application in some recent version of Squeak and still use etoys and such.
I'd like to suggest you check out Dolphin Smalltalk, which has a very easy deploy to executable method, as well as a native windows (for windows OS). It recently became free and open source so I'm expecting more great stuff from this smalltalk implementation.
That looks very cool! BTW, I wish Squeak and/or Pharo were available as iPad apps, but Apple doesn't seem to allow that. Perhaps if hosted via Javascript?
Yeah, I had a series of method calls in my Workspace that sort of mimicked the message call chain "conversation" I wanted to implement and I was about to refactor the whole thing into the appropriate object classes in my System Browser when I looked outside and thought, huh, nice day out. I ultimately messed up the choice of classes and had to restore to a backup Smalltalk image. No worries! I just read in some fileouts I had done earlier and was able to recover most of the useful work and start altering more appropriate classes.
Check out /r/CasualConversation if you want to make small talk instead of Smalltalk
lame 
Yay! Now if only I could get Garage/OpenDBX working with Oracle.
/u/EstebanLM : thank you for all the great work that you and the Pharo team are doing !
Yeah, I don't really get why they're trying to distance themselves so much from Squeak...
They are moving farther and farther away from Squeak. They forked it in 2008. I don't blame them for trying to stand on their own.
If someone is taking this, how is it?
Yes. I just checked and the installation of the OpenGL libs described in the help files on extending squeak still work with Squeak 5.0 Installer new merge: #openGL With the all-in-one Squeak 5.0 the installation process was over before I could finish typing this sentence. Test that it installed correctly by entering: OpenGL example and "doing it." Shameless plug: my [Squeak from the very start](https://www.youtube.com/watch?v=Es7RyllOS-M&amp;list=PL6601A198DF14788D) videos have several examples of using OpenGL and I have a few examples of programming remote OpenCobalt virtual worlds as well in other videos on my youtube channel.
[removed]
[removed]
[removed]
Thank you so much for the detailed answer! This is really fascinating. &gt; Too bad. Those of us who use it think it ranks up there with LISP and FORTH for production use. I want to clarify what I wrote: what I meant was my interests are in the history of Smalltalk, but that has nothing to do with Smalltalk as a productive programming language (I believe it is!). Given the name of your friend, I suspect he is from Brazil. Incidentally I'm from South America too! Would be possible to contact him about the history of the adoption of Smalltalk in Brazil?
&gt; Given the name of your friend, I suspect he is from Brazil. Incidentally I'm from South America too! Would be possible to contact him about the history of the adoption of Smalltalk in Brazil? He's pretty easy to find online. and he's about as knowledgeable on the subject as anyone, I think.
I don't think there's a standard for this, it's one of the things that is different for each Smalltalk distribution. Are you talking about an application that you'd ideally like to launch like any other application on your operating system? What Smalltalk are you using? Edit: I think *packaging* is the standard term for packaging up a Smalltalk application as a standalone binary. At least, that's what IBM Smalltalk called it, and Pharo Smalltalk appears to call it the same thing. The documentation I examined confirms my suspicion that those two implementations at least differ in the details of how it is done.
Unfortunately I never finished it, I really hated using Pharo and the Language.
Eh, it does take a while to get used to it, but the Smalltalk IDE (can't speak for Pharo's new implementation) makes for some really easy debugging and experimentation... once you get used to it.
Thanks for responding at all. I gather you've got things under control now.
I'm glad like Edward you seem to have things sorted. Coming from another language to ST of any flavour can be a handicap at first because how you do things in ST is fairly alien to the mindset of a C programmer for instance. Those who stick around tend to find they love it in the end, but the lack of structure baffles many at first. If you don't come with preconceived ideas of how to do things, ST tends to come more naturally. It's the easiest language I've encountered (and note I've got more than a couple I know from usage) to teach people, though explaining it is challenging when dealing with people that demand structure.
Hi guys, Seems like some of the newer stuff in Pharo is using Spec for describing UIs. Might be worth a look over the docs, seem pretty good. http://spec.st/docs/home/
My Lua script (rough early version: http://sprunge.us/DfZU?lua http://sprunge.us/FfPB?c) does a similar thing and handles selection for image types 6502(Squeak), 6504(Stack), 6505(Cog), 6521(Spur), and 68021(64 bit Spur). I could easily add a link for 6519 images, but I'm unsure the current Spur version (3732) supports them. The problem lies in that the Pharo images require special support in the VM, but they don't distinguish themselves based on image type. To my mind, this is wrong; I should be able to distinguish a Pharo image fron a non-Pharo image based on a simple file test. Ideally, there would be no difference in the VMs, but since there is since Pharo 2.0, the image type should be distinct. Grepping the image file for PharoVM seems possible though rather expensive for what should be identified in a fixed offset cookie.
Completely agree, the versioning story isn't exactly satisfying. But there's work on bootstrapping images so image contents/versions should become a bit more manageable. VM development is also moving towarts a merge between the Pharo &amp; E.Miranda branches. Have you raised the issue on the lists?
Not yet. I got off those a couple of years back as they were somewhat chatty. I suppose I need to do so. In the meanwhile, I guess I'll add a test for PharoVM to my Lua code. Maybe figure a way of caching my greps to cheapen subsequent starts of the same image as I try to refactor this into something I'm not embarrassed to show.
If Craig Latta has his way, it won't matter which image you are using. *Context* will make the idea of incompatible image formats obsolete. And of course, once SiliconSqueak hits the market, everyone will be too busy playing with hardware to worry anyway.
Spoon is now called Context: http://www.netjam.org/spoon/ [SiliconSqueak](http://www.siliconsqueak.org) See also: https://prezi.com/yhw-a3i0rnri/adaptive-compilation-for-an-object-oriented-and-reconfigurab/
&gt; Interesting - although the hot VM seems to be spur rather than COG. Will this ship in a format like an Arduino or Raspberry PI then? Context will run on SqueakJS (Craig is testing a distribution website written in Squeak running on SqueakJS) as well as any other VM that he can manage to make it compatible with (which should, in theory, be all of them, including all commercial Smalltalks). The SiliconSqueak ISA is meant to be compatible with at least Squeak and Pharo 32-bit VMs (no point in wasting 2x the transistor count just for the extra addressing, though I suspect that for some applications (like video editing/manipulation), a 64-bit interface to RAM and specialized imaging processing cores will be useful with at least SOME processors). 
In all of the Smalltalks I am familiar with, any browser that lets you look at or edit instance methods will do the same for class methods via toggle buttons on the browser itself. So you should see two buttons, one labeled *instance*, one *class*. I am not familiar with Pharo in particular, but the images of browsers in it [on this page](http://pharo.gforge.inria.fr/PBE1/PBE1ch3.html) would indicate Pharo is the same in this regard.
I wound up writing a simple stanza of Smalltalk which embeds a line of Lua code returning the VM options with an easily grepped prefix into the system dictionary. The Pharo images I wanted to detect have a message, *Smalltalk vm isPharoVM*, which I can detect with *respondsTo:*. If present, I add a little extra code to the embedded Lua. It's a pretty evil hack, but trying to get that stanza to work across all Squeakish dialects was going to be anyhow.
I went through your Lua code but got confused as to what it's doing exactly (and how)… Could you show examples of your use-case(s)? In fact I'm thinking of writing a project launcher, something that could take care of building and running a clean image after a git clone of any project, a bit like Ruby's bundler or Rust's cargo. I probably wouldn't need to detect which exact flavor of image, since that would be specified in a project config file, but that could help to make the tool a bit clever.
I understand. FFI is one area where the community really lacks skilled developers with enough free time, and everything is a bit at the prototype stage. NB was cool, but it was too much work to port to new architectures. UFFI and Lowcode look promising though. I had never heard of Smalltalk Agents… which dialect was that from ?
Ok, pretty similar to what I was thinking about, then. For VMs I started writing Homebrew formulas, so that the different VMs install just like normal unix packages, just with different, explicit names. Then I'd have a `pharo` wrapper that redirects to the correct VM.
I'm not sure. There were a couple guys - the main dev was David Simmons. They were focusing on building a really nice Smalltalk for the Mac that integrated well with the native libraries and code (pre-OSX). Here's an old press release I found: http://www.mactech.com/content/md1smalltalkagents-21-0 The company was known as QKS - Quasar Knowledge Systems. STA was perhaps the most beautiful Smalltalk ever released in terms of UI design. Really nice but the audience wasn't big enough and it was still hard to get real apps done with it. They kept missing deadlines for improvements and kind of lost their audience. Eventually Simmons joined Microsoft and began developing a thing called S#. Their VM tech was called the Agents Object System (AOS) and I think Microsoft ended up owning it. http://www.bitwisemag.com/2/S-Smalltalk-The-Next-Generation.html According to Simmons linkedin page - He is still at Microsoft and was an architect on the Windows phone. Poor guy. Brilliant with a string of failures in his wake.
I'm not talking anything mac-specific here (besides homebrew, but that's exactly the same as APT or RPM or your favorite distro's package manager). The wrapper would basically be Peter's I mentioned before and explicitly run the correct `/usr/local/bin/pharo-vm-{cog,spur}{32,64}`. No filetype mapping here.
Because I'm trying to give you a single release, not the dev history. I do speak git, I just don't always want to take down my trousers (share my git repo) in front of other people. See Emily Dickinson's "I'm Nobody! Who are you?" for an inkling of my mind here.
You can use git and github with pharo too. I recommend asking this question on the more active [pharo forum](http://forum.world.st/Pharo-Smalltalk-Users-f1310670.html).
Thanks for the advice, will do.
Diego and Stephan talk about his use of Pharo... I do not think is anything new to smalltalkers, but is a very nice article :)
Coders rarely choose best, they choose what they like most or what they feel most comfortable with. Git and Github is an option so is Git and Bitbucket, recently I started using Git with Gitlab and of course you can use other VCS like mecurial etc
Thank you for your reply and the links you provided. I've read about Context of Craig Latta and I definitely like his visions and what he did, especially the remote debugging and development. I hope these things are picked up by other languages and platforms, not just SmallTalk. What you do looks quite interesting so I hope you would share the results of your work in this subreddit.
Nice UI and interesting topic. Not that I know any of it. Downloads fine and ran out of the box. Is there any way to jump into the class browser, say, "cleanly"?
There are better solutions for namespacing in Smalltalk. Still broken, but better than what Pharo currently offers and certainly better than Context too. &gt; When someone runs a Context-aware VM and image, they can pull in classes by UUID and use them. What if you have multiple classes with the same name within your image? Will the IDE force you to specify which class you want to reference with a UUID? So if you had four different User classes in your image, you'd have to specify which one you want each time you reference User? &gt; If a class has dependencies, those classes (identified by UUIC) are pulled in as well. How will it know which version of the class is required? &gt; Journaling of classes and objects will be to a separate image that lives only for that purpose, and rolling back to a previous state will involve not just the source code, but the entire associated sea of interacting objects being rolled back to the appropriate save points as well. So, an image repository. Which Pharo sortof provides with snapshots, except that snapshots are stored within the image. So if your image gets borked, there's no easy way to rollback. This happened to me before and it was infuriating. But I would think the better solution is to just have snapshots be stored external to the image so they could easily be imported and exported wherever you need them. What exactly will this image for journaling be? An image gutted for that express purpose? Will it have any sort of interface for seeing change logs or dependency trees? &gt; the entire associated sea of interacting objects I have an empire of objects, not a sea, so I'd much rather them be treated as such. What's really needed is a better persistence solution, one that will automatically organize your objects by class, even if just into a file system, and will automatically restore objects after an image crash. And I want to be able to revert to older states of subsets of objects rather than always being forced to revert the whole damn thing. Seas, oceans, and any other swirling undifferentiated volume are the wrong metaphors. I'm a programmer, not a fucking pirate.
Because Smalltalk is awesome, I need Seaside, and Seaside hasn't been fully implemented in Dolphin. Otherwise, I'd be using Dolphin.
well, 'twas my own metaphor, not Craig's. And context should, in principle, work with nearly any library of classes, as long as there aren't dependencies on the level of external calls to the system that vary by OS. By the way, since each class or subclass has its own UUID, why did you think that things could only be changed on a per-image basis? You can already rollback using the Changes file on a per class basis. Why would you think that Context wouldn't allow at least as good a facility?
&gt; well, 'twas my own metaphor, not Craig's. Given his affinity for jam and noise music, it probably resonates with him too. &gt; By the way, since each class or subclass has its own UUID, why did you think that things could only be changed on a per-image basis? You can already rollback using the Changes file on a per class basis. Why would you think that Context wouldn't allow at least as good a facility? Because the existing facility is rather clunky. I know you can browse different versions of a method, but I don't know of any way to browse different versions of a class, unless there's some hidden tool that I'm not aware of. Are you simply referring to the change sorter allowing you to select the changes you want to file in? I never liked that method because it presents everything as an unstructured list, with no way to filter for whatever package, class, or method you're looking for. Having a global repository of class definitions by UUID is probably a good idea, but there still needs to be a concept of namespacing within an image. Forcing programmers to have to tell the IDE which definition they want to use when it can be inferred by the context of the method they're modifying is just lazy.
Why not use the *context* of the class reference to choose the class definition? Context isn't about context, it's about ignoring context in favor of a universally unique id, which is contextLESS. There is no context in Context. And the irony is not amusing.
Check https://github.com/PolyMathOrg/PolyMath Not sure it has what you need already but it should be a good starting point for connections to people and other libraries.
The World Menu was left intact, just click outside the container "icon buttons" and you will access the standard menu with the System Browser item.
Thank you PolyMath contains packages that implement different optimization and statistical analysis algorithms that are used in machine learning (like linear regression, least squares, hill climbing and so on). There is even an implementation of a genetic algorithm. But I didn't find anything related to neural networks
it is fixed now
they changed the behaviour of certain API for adding path-chunks, consequently breaking all cog dependent VMs (not just Pharo flavour)... but this was quickly fixed. Btw... Pharo was not the only one suffering from API changes in Sierra... my command line sourceTree for example does not work anymore.
I just tried it, and although now the application does not crash, you get a warning about file permissions along the path /private/var/folders Manually giving my user account write permission still did not get me a stable system where I could save changes. CORRECTION: I just tried the download link and had these problems. When I used curl get.pharo.org | bash then I get a working system. Thanks!
Just realized I didn't click far enough into it haha. Looking good!
Look as SquakJS https://squeak.js.org/ 
Also, look at Craig Latta's work: https://thiscontext.com/2016/
Yeah I think the biggest problem, for now, is that there is no way to go graphics in WASM. That's because the Web API has not yet been integrated into the forthcoming MVP, though the team *is* planning on it apparently. Similarly, instead of normal communications protocols (sockets/tcp-ip) we would be limited to what is available in the web platform (websockets/ajax calls). So I guess it's like building a VM for a machine that only has web capabilities, which yes is very different. The binary format is not a problem for web browsers using wasm, because all wasm files are bytecode that gets delivered as a file in the first place.
&gt; Before the Strongtalk system could be released, the company was acquired by Sun Microsystems, Inc. to work on the Java® virtual machine. Development of Strongtalk was halted at that point, so very few people have ever had a chance to see the Strongtalk system in action. So, it was squelched by Sun / Java. Like so many good other good things in software. God how I hate them. 
I've most familiar with VisualWorks Smalltalk, so I had to do some investigating. It sounds to me like a mcz is a sort of library of code. I've never used Pharo; is it a live environment like VisualWorks? If the .st file is the equivalent of a .im file in VisualWorks, my only guess is that git is simply saving the changes from your live system. And it is saving as .mcz. From what I read online, it sounds like all you need to do is place the .mcz in the package- cache directory and you should be able to load it. Like I said, not very familiar with Pharo so hopefully someone who is will come and answer your question. Hope I haven't wasted your time with all this text :)
Thanks!
Yes, Pharo is a live environment like any Smalltalk. The Pharo community considers it an evolution from Smalltalk, which in practice means that you have all that you find in Smalltalk, and many things more (Traits, tools, slots as first-class objects, Opal compiler and lots more)
mcz files are, as another reply said, compressed versions of package files. A package is, basically, an assembly of classes and extensions. It adds some metadata -like dependencies and versions. I read that you are using FileTree now, it has another granularity. If I remember it well, any method is a separate file for the CVS, which is much finer a grain.
What kind of Smalltalk are you running?
I see, thanks for the info :) I'll try out Amber, is there any common design pattern for it? MVC? MV*? MVVM? Any library integration? Or is it just do what you want? 
It appears that the Amber ecosystem is still pretty young. Your best bet would be first to work through the tutorials, and then make your plans from there. I do find, as a rule, that design patterns aren't supposed to be prescriptive, rather they are for describing what you're doing. 
Don't do "#cr" until the end of each row. You're adding a #cr with every single #show, so every single character is going to be on a separate line. Also, since there is no back-positioning possible with Transcript, you'll need to provide for a call to drawing your pieces (or whatever they are called) in the middle of your board drawing method.). You might want to look at drawing directly into a Bitmap instead. That way you can draw the board, then draw the pieces in a second pass. If you want to do it YOUR way, you'll have to dredge up some old BASIC algorithm for some ancient mainframe and see how they did it using ASCII. VERY cumbersome, I suspect.. 
&gt; Oh yes it took me a while but I realized cr was creating new lines. Would using timesRepeat work for creating bars based on the number of columns? If you already know the number of columns, then that would be setup before the loop started, so I don't see why not. &gt; Hmm I didn't know about Bitmap... I believe our prof said not to use a GUI board so I believe we are supposed to print it out. I will double check with him to see if Bitmap may be allowed. Thanks! Eh BitMap kinda *defined* the original GUI that Jobs and later Gates saw, so its probably not an option.
&gt; Thank you. You're welcome. Thanks to my ADD, I added bunches of stuff after my first save, so you probably missed some important "one more thing" that I added after you replied.
I'm happy to see how those efforts are not lost. Hopefully there will be people wanting to work on it in the future :)
PDF loads fine for me. (Safari on iOS.)
This is for Smalltalk the programming language.
Well, I can help you. Working everyday in Smalltalk, with a development team, since more than 10 years. My philosophical bend is sometimes overrun by practical thinking, but I used to have long discussions with friends about design, principles, etc. so I feel fit for that too. English is not my mother tongue, however. I live in Argentina and speak Spanish, but think my English is acceptable. 
Your written English is great, don't worry about it. Smalltalk seems to live on strongly in South America, it's interesting to me (CA person here).
I PM'd you!
Thank you. And yes, Smalltalk has a large community in Argentina, with movement, students, universities and an annual conference. At least, "large" for a Smalltalk community... CA is for California, Canada or where?
Have you checked in `Workspace`'s superclass(es) ? My guess is Squeak's `Workspace` inherits `#open` from its superclass and doesn't define its own specific implementation; I had a look in a Pharo image I have at hand and the `&gt;&gt;` method does not recursively lookup methods up the inheritance chain. Pharo's `Workspace` does have an `#open` method, but not `#shouldStyle`, so it's very probable that it has been refactored or reimplemented and its class hierarchy is now different from Squeak's.
you can use #lookUpSelector:, it searches the class hierarchy: Workspace class lookupSelector: #open will return the compiled method.
I see you posting content on here all the time. Glad someone is keeping the sub alive. This language looks pretty neat, I will save the post for a later date!
Eh, that's easy to do: just use native-looking widgets. I believe that both Pharo and Squeak offer that option in the preferences, in varying degrees. Using GTK would be a bit of a chore, although perfectly doable. The only real advantage would be speed. Morphic is quite crufty as it is implemented currently. Compare the [1.3 image speed](https://squeak.js.org/run/#image=/Squeak1.13u.image) with the [5.0 image speed](https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&amp;zip=\[Squeak5.0-15113.zip,SqueakV50.sources.zip]) in the SqueakJS demos. Warning, the above links download the Squeak =&gt; Javascript compiler &amp; VM then download the full unmodififed Squeak image to run in it, so you have to wait a bit for the image to download. WIth 1.3, its a tiny image. 5.0 is perhaps 500x as big and about 10x as slow once it is running because of the convoluted nature of modern Morphic.
Morphic is a mess. eToys kind of polluted it. Pharo has done a lot of cleaning up of Morphic but I've got a project that is kind of graphics intensive and I'm about to give Cuis a shot. 
&gt; It's deliberate, I think, to maintain awareness of code activity. I filter those mails and never ever look at them… &gt; Pharo also has a discord channel, if you want to come and chat; link at http://pharo.org/community Thanks. I'm author of [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D) so I'm familiar with both communities on at least a superficial level. I'd like to make more videos, but last I looked, neither platform is currently supporting OpenGL very well, which was where I wanted to go. Eliot Miranda is working on reviving Balloon3D, but not sure if that will do what I want or when/if it will be available on both platforms. The refusal of anyone to support Slang or even C as part of the FFI implementation is also frustrating. Igor went with x86 assembler syntax, which was very difficult to work with and hardly in keeping with the Squeak tradition nd this still appears to be where things are headed, as far as I can tell.
&gt; Did you check out cuis? Juan's graphics work seems very impressive. I'm considering trying it for a project pretty soon. Cuis is neat, but it has nothing to do with OpenGL or FFI as far as I know. 
The Spoon fork! Has anything major changed since 2005?
I used to be a part of that project. HOwever, unless John Dougan is still working on it, it's currently inactive. There's a Croquet-derived GPLed project still ongoing. The old name was [OpenQwaq](https://en.wikipedia.org/wiki/OpenQwaq), but not sure what the new name is... [Immersive Terf](http://www.3dicc.com/about/) but it apparently is no longer open source.
Why OpenCobalt was stopped?
&gt; Why OpenCobalt was stopped? Julian Lumbardi's grant money ran out and he had no interest in restarting it. We in the [Silicon Squeak](http://www.siliconsqueak.org) project want to start it back up, but that will depend on product sales to fund new development. We have a router design based on SiSq that could run OpenCobalt out of the box so every internet user could host their own Cobalt room or rooms for virtual visitors. With the 10^9 processors possible for a single system, things could scale pretty nicely for some uses.
I had fun with Croquet and OpenCobalt several years ago, a really nice idea and implementation, but now I don't believe that the project is active. 
It was Croquet that first brought my attention to the whole Smalltalk/Squeak world. It's disappointing more didn't come of it.
Morphic is not a mess. Squeak version of Morphic is a mess perhaps because of eToys and other stuff as you mention. Cuis version of Morphic is very simple.
It is a fork? Can you comment why the fork? 
Yes, it is a fork. It is explained in the page. It adds features and fixes bugs. I was able to run this forked branch while I was not able to run official branch on Linux for instance.
How actively developed is Dolphin Smalltalk right now? On the [Github page](https://github.com/dolphinsmalltalk/Dolphin) there is a bit going on but not too much... 
I would think that some wealthy customer of Dolphin Smalltalk pays for the core developer's salaries. The Pharo folk pay for core developers of Pharo. The Squeak community chips in for the VM work as well or so I understand.
That makes sense. I guess if your company actually ships commercial products in Pharo, it makes sense to pay to have someone to care or it for several reasons.
I've only just started using it having gone through the code browser, playgrounds, and the tools for finding classes and methods. I'm curious, what do you find so bad?
&gt; I've only just started using it having gone through the code browser, playgrounds, and the tools for finding classes and methods. I'm curious, what do you find so bad? Eh, the overall feel is rather geeky compared to the much more (IMHO) elegant Squeak IDE. While there are many important features that PHaro adds, it adds them in the least elegant way possible. One glaring example is the "spotter" (I think it is called) which kitchen-sinks in almost every conceivable search option in a window that covers your work area. There's other stuff too, but I don't remember it off the top of my head. There's many useful new features that Squeak lacks, but they're just thrown in all-at-once. squeak had a professional GUI expert working on it (may still have one). I don't think that Pharo does, and it shows. Certainly, the original Squeak team had an impeccable background with respect to UI design and implementation as they literally invented it.
DId you take advantage of Pharo-only features, or did you just decide to use Pharo instead of Squeak, just because?
I think that Object Arts is NOT making any money now. It seems a hobby for the main developers, they are very knowledgeable and answering anyway. As for pros &amp; cons, Dolphin is exclusive for Windows development, using heavily OS functions and native controls. Pharo is multi-platform and has a more active community (which is actually a two-edge sword, because there are lots of different packages and active projects for almost anything, in different ways)
Is there any work still being done on that?
Just one look at a pharo vs squeak screenshot comparison is enough reason for the average person to choose Pharo. Nothing against squeak but pharo just looks and feels much more professional.
I would say it is not too active. However it is a great product for windows development and is my preferred smalltalk. Activity in the newsgroup has really slowed down as well.
&gt; Just one look at a pharo vs squeak screenshot comparison is enough reason for the average person to choose Pharo. Nothing against squeak but pharo just looks and feels much more professional. I might argue that programmers are generally pretty bad at judging aesthetics and while beauty does not guarantee utility, simplicity often does go along with ease-of-use. User Interface design is generally the hardest part of computer science as it demands both technical knowledge and artistic sense. Fitts' Law is not the end-all and be-all of user interface design, but it IS a start.
Ok. I'm just pointing out that most people that try squeak get the impression that it looks like a kids toy. Even the latest verions. I've seen numerous anecdotal reports of people's experiences with pharo and squeak. I'm sure if you posted pictures of both in a poll, people would choose pharo. Your comment mostly went over my head, so I'm not sure if you were agreeing or disagreeing with me :)
I know the difference between squeak and etoys. I used squeak before pharo existed. Older versions of squeak definitely have problems in the looks department, even without etoys. Another issue was squeak would jam everything and the kitchen sink into the world menu. So I can't really say it's always been better designed visually than pharo. 
&gt; Another issue was squeak would jam everything and the kitchen sink into the world menu. So I can't really say it's always been better designed visually than pharo. That's certainly still an issue. Both need UI revamping. Craig Latta's starting to work on that as part of his Context (aka Spoon) project. If you have suggestions for a "best of both worlds" UI, he'd be happy to hear from you. https://thiscontext.com
Yea probably etoys to a degree, but even looking at the Squeak pictures on their website it is really cutesy like the Perl6.org website which looks like it stole Squeak's color scheme. It is not as bad now, but some of the older Squeak versions looked really cutesy. I'm not saying that means it isn't a professional product for adults, but there is a somewhat adolescent look to it. I mean no offense by this by the way, just my opinion. Do you use Squeak professionally?
Unfortunately Dolphin Smalltalk doesn't have too many resources when it comes to game engines. There is some stuff, however. I am using an old package by jeffrey massung called "Unstdio". It's a 2d game engine based on opengl, and it has directx input support. It's not really as feature rich as you'd typically find in a 2d engine, but for the game I am making I think it is definitely suitable, and since I love smalltalk so much it's what I like to use if I can. SMalltalk is actually really great for developing games, because you have such rich debugging facilities in smalltalk so you can step through your code when there is an error, change things, and resume the game on the fly. There are also a couple 3d engine things in dolphin, one is an old Horde3d wrapping that Federico Omoto wrote, which uses a really old version of Horde3d and can be quite a pain to track down the right horde3d dll's to use with. Another is an activex/com interface with the engine Truevision 3d, and a game engine on top of it created by Andy Bower. In all honesty though, the 2d game engine is the only one I think that can actually be useful for professional game development. That's why when I want to make virtual reality/3d games I usually go with Unity. I am investigating using .net game engines with dolphin though, since there is a .net package Federico Omoto made a while back that might work with them. The .net package has some flaws however. Another thing I'm looking into is lesser software's system which looks pretty awesome, and can actually run dolphin's system on top of it's vm, however I'm not sure what the pricing actually is yet and I have a bad feeling about it. If you're interested in any of the software I mentioned just let me know. Unstdio is not really available anymore on the net, but you might be able to find it somehow. I can give it to you if you want as well. I have been thinking about making a youtube series where I create a game in unstdio to show what programming in dolphin is like. 
Once again, lots of great info here. I've heard both good and bad about Smalltalk, but will be taking the journey anyway to find out for myself. There's a bit of a push (at least by Richard Eng) to market Smalltalk as it is in a weird spot being a historical language which only relatively recently got several open source/free versions. I think YouTube videos would be a great way to teach what it is like to code a small/focused project. I've seen the popular bouncing balls demo, so I know you can do some pretty cool interactive stuff by changing code on the fly (I've also seen this in Common Lisp &amp; Forth) and it is always magical. Agreed that practically the only non-toy 3D engine will be Unreal and maaaybe Unity, but I'd rather use a system I can understand over a something like Unreal which is really big. I'd be glad to see what you do and perhaps leverage that in my job. I'm an engineer and wouldn't mind using a good 2D engine for some physical systems simulations, but need a jumpstart.
Exactly! I'm not asking for 10 TB of videos, but a few would be helpful. There is a pharo MOOC course, but I don't speak French. Edit: Just found the ObjectArts YouTube channel and they post some good videos.
I see this pop up every now and then. I thought it was dead, but it looks like it has some recent papers or talks as of 2016.
Yes. Gilad Bracha, its main author, got an important prize last year. He's always working on Newspeak and makes a strong campaign for it.
The Pharo MOOC has very good subtitles, so not speaking French is not a problem. I found it an excellent way to get started, along with Pharo By Example. Along with the other free books available, I've actually fond the documentation for Pharo quite good for an open-source project. 
This subreddit is about a programming language called Smalltalk. Not sure what that has to do with the weather ;)
I wonder where is the source code of Lumiere and Gaucho
I'm not sure. Pharo has been working on two things called Spec and Bloc, which are intended to be the new UI and UI builder. I didn't try them, so it's just repeating things that I've heard. Anyway, I hear also that UI for desktop applications is dead, because everything is drawn on web browsers nowadays ;-)
Thanks. Looks good. It may finally be time for me to try Pharo.
Smalltalk has traditionally used a simple recursive descent parser with one token of lookahead. With no fixed leading context, the parser can't know it's reading variable names until it sees the closing vertical bar an arbitrary number of tokens later; omitting the colon leaves a more complex grammar which requires a more complex parser. Google ll(1) grammars and parsers for enlightenment. ll(1) grammars are easy to hand code parsers for, and the Smalltalk-80 image had its lexer and parser in the image. If you wanted to change the language within the constraints of the grammar, you could. (e.g. Squeak's {} computed arrays.)
Thanks for the explanation! Figured it was something along those lines, but didn't know what.
For the hobbyist, I think you'd prefer Pharo. VW is indeed huge and is basically Smalltalk in a pinstripe suit. It is designed to build business systems. It attempts to emulate the native platform UI but as this changes fairly often it is frequently out of date. The new iceberg/github integration is looking pretty cool. Pharo has been aggressively refactoring Morphic and has removed a lot of the cruft grafted onto it by eToys. You might also check out Cuis which is another variant with a re-imagined Morphic but I don't have any direct experience with it. Fwiw, I know Stéphane Ducasse and he isn't going anywhere. 
Though OP is looking at just personal use for now, I was too some time back, and I looked into licensing models for the possible eventuality that I built something I could sell. Has Cincom's licensing model changed? That was a big put off for me when I was looking into it some time ago. They wanted a percentage of all commercial sales, for ever I think.
I'm getting the most valuable info from a book about Cincom's VisualWorks. I don't get enough description of how to actually do things from the Squeak side.
No, it is not on Coursera, but on a French site, called FUN. It uses pretty much the same mechanics than Coursera, SantfordOnline and many other sites for MOOCs. The course is on French but has subtitles in English. All tasks and exercises are in both languages too.
I am new to Smalltalk and I've been pretty happy with the Pharo book. For the first couple chapters it really helps to have Pharo open so that you can click through with the text.
&gt; Is the Pharo MOOC pretty highly regarded? Anybody here work through it? I liked it, I'm half way through it. I didn't like the web interface for the video too much, so I downloaded the videos &amp; english subtitles. For VLC to use the subtitles the subtitle files had to be renamed to match the video filename. The exercises were engaging.
True, but the surrounding text is also interesting.
I suggest you check out Dolphin Smalltalk, which imo has the best interface of any smalltalk I have ever used (I've used pretty much all the main ones, including pharo/visualworks/smalltalk-x/etc. It also runs on mac, according to this post by Andy Bower: http://www.object-arts.com/blog/files/dolphin-under-wine.html So the upsides are that you get what is imo the easiest to use and most user friendly smalltalk version available, and also the best gui building system that I've seen which is kind of like constructing gui's in visual basic. The downside is the user activity has really dropped off lately, so you will not be able to get as much support (although there is a newsgroup with low activity that still gets you some). Another downside is you might not find community packages for the latest stuff, although Dolphin still has a pretty big library of packages you can use, just takes a little searching.
Delayed thanks for the very helpful answer (I've been out of country). Good to have another possibility on the table.
Very nice. As a fellow newbie, I appreciate the time and care that you put into this. It should help people get over that first barrier of unfamiliarity. Thank you. 
I like the watch analogy. It does make you wonder about why software development is the way it is today when you consider the alternative they propose. https://www.jwz.org/doc/worse-is-better.html
Eh, there IS a practicality to such things. I have a hard time programming in LISP. I have an easier time programming in functional languages. I have an even easier time programming in Smalltalk (never tried Self). So there's a pragmatic issue about tradeoffs of perfection vs ease of programming that *insisting* on perfection loses. The IDE that smalltalk uses is superior to all the IDEs I've seen, which shouldn't be THAT controversial as the very concept of an IDE evolved along-side the Smalltalk language and programming environment. Some swear by the IDEs that developed for LISP (but see above about me not being able to use LISP very easily), but anyone who has ever used the Smalltalk IDE and then gone back to the crude copies used for procedural languages realizes immediately that crude copies aren't the same as the original.
Thank you for this excellent tutorial, one of the most accessible and understandable I've seen! Really hope there will be more in the series!
I am very pleased with Clément Béra's work. Béra's blog post on object kernels was very interesting! https://clementbera.wordpress.com/2016/02/17/mind-twister-toying-with-object-kernels/
NOt that I am aware of. What do these tools offer that raw Smalltalk + OpenGL don't and why can't you implement what you need just by programming the required Smalltalk yourself?
Wow. Jeff Massung here. Been such a long time since I thought much about Smalltalk. The 2d game engine I put together was just to learn Smalltalk and dolphin (which it's still great if you use Windows). But life and work tore me away from it. If you have a copy of unstdio, could you PM me so I can get a copy? I'd like to try and update it and add some features. Memory lane... :)
So, it's been a long time since I used Smalltalk, but here's my impressions from 10 years ago and some updated ones for today... Hot changing code (and having it propagate to existing objects) is huge. That said, there are limitations to it that you run into in production. For example, add a new instance variable to a class and its value is nil across the board. Any method using it will have issues. Presumably modern Smalltalk implementations handle this? The debugger - as with lisp - is built on context frames. This is (imo) the greatest feature of Smalltalk. Hitting a bug, and then being able to restart the frame or even back up a few calls and fix the bug at its source and then restart is the stuff dreams are made of. Smalltalk fails epically when it comes to teams and code sharing. I'll probably get down voted for that comment, but to a newcomer, it's non obvious how to use perforce, git, etc. And (maybe different today) some implementations locked you into using source control that was built into the image. Sigh. Smalltalk object orientation is beautiful. That said, OO has human related problems the same way Haskell does with FP. Too many programmers spend way too much time architecting something beautiful and pure instead of solving the problem before they even completely understand the problem! This causes problems later when the class hierarchy or API doesn't make sense any more or it becomes unbelievably difficult to pick up and grok (looking at you, morphic). While all programmers make that mistake in all languages, some languages magnify this problem; Smalltalk is one. That said, I miss my time with Smalltalk. Every once in a while I look at Pharo and look forward to doing something in it.
There is http://agilevisualization.com with Roassal. E.g see https://www.youtube.com/watch?v=iXUZiFtnxK8 or https://www.youtube.com/watch?v=CuimMwuZiGA
thanks, will check it out.
Quick question: Are the tutorials/books/MOOC linked to on the Pharo website up to date to work with Pharo 6.1? I've been meaning to read the books/tutorials for a while but don't know if they "match" the latest release?
No, sadly updating all the material for every release is impossible (just re-doing all the videos would take months). The mood is based on Pharo5, but 1) there are not that many user-level differences 2) everything you learn is still relevant for the newer version.
This happens when the browser cannot find the source code and instead decompiles from bytecode. Bytecode only knows temps by index, so names like `tmp1` etc are generated. Check that the `.sources` or `.changes` files corresponding to your image are here.
Started playing with it today, and it's been much easier to understand than Pharo for a beginner like me. Simplicity really pays off.
Thank you! It makes sense now.
Not a regular Smalltalker either (yet?;), but tried Cuis-Smalltalk this weekend and it really delivers on the promise of being "appropriable", at least compared to Pharo and Squeak, and certainly so even when compared to stuff I use everyday like Python. I still prefer the idea of direct manipulation from Self Language, instead of the focus on tools that Smalltalk-80 shares with modern IDEs, but the Morphic interface has a more hands-on experience, probably because it was ported from Self.
Yeah it's a classic… but if the browser indicated explicitly that it's showing decompiled code, it would be nice…
Reminds me of [Pinocchio](http://scg.unibe.ch/archive/projects/Flue11a.pdf) which is also on [github](https://github.com/pinocchio).
Great project
Are there any comparisons of some "famous" code written in Slang side by side against Lowtalk?
I hope Pharo is in a good mood.
:-) MOOC... but it is in a good mood, too. There was the yearly ESUG conference (general Smalltalk industry/research conference) last week and it was great... 
I’ve used it to do some basic text munging. I have a large BibLaTeX file that I needed to do some repetitive processing on every record of. Could have done it with a shell script or Python, but found Pharo a particularly elegant solution to code and totally performant. 
I've been working through Rosalind bio-informatics themed problems (http://rosalind.info), building up a suite as I go, refactoring etc. It's a good way to learn any language really. Edit: re-read the initial post, it's not really something useful. You can also look into Seaside to make a personal site / web app, or Roassal to create visualisations, or Spec to create a GUI app (within the smalltalk world, mind) It's a general purpose programming environment, so you can do whatever you'd do in other languages really.
thanks, it doesn't have to be useful, I edit the question to be just, what you do with your install. Making visualization is actualy something I've been wanting to test
&gt; Spec to create a GUI app Where can I find more about it and/or is it the most up-to-date way to build GUI apps with Pharo?
Sorry for the late reply! Here are links to a booklet and the project home, respectively. http://files.pharo.org/books/spec-tutorial/ https://benjamin.vanryseghem.com/projects/spec/ Yes spec is the framework of choice for pharo currently. 
Huh. Ralph Johnson emailed me a while back to say that when one of his students wants to learn Smalltalk, he refers them to my intro Squeak series, [Squeak from the very start.](https://www.youtube.com/playlist?list=PL6601A198DF14788D) And most newbie (and advanced) questions about opensource Smalltalk are answered on the Squeak and Pharo mailing lists. It is true that the communities are terribly tiny, but in South America, for some reason, Smalltalk is far more popular than in the USA. Likewise, there's a lot of Euopean activity that USAns never are aware of unless they are part of the Squeak/Pharo community. That's a marketing thing and few companies using Smalltalk are into pushing Smalltalk. 
&gt; Thanks. Unfortunately, I do not like trying to learn from videos; I much prefer readable texts. That is why I have never even tried Pharo's materials. Most Smalltalk video suck. Mine suck slightly less, IMHO. 
I like books, too. There are some Pharo books you can print yourself, and some are available to order: http://files.pharo.org/books/ 
You can find it on GooglePlay and TuneIn as well
&gt; A reddit for smalltalk-related discussion, including Squeak, Seaside, GNU smalltalk, and other topics Not about making small talk with other people...
To be absolutely clear, Smalltalk is a programming language. 
To be absolutely clear, Smalltalk is a programming language. 
Lol, damn alright my bed didn't read enough, deleting now
There is a pharo mooc starting soon
Thanks very much. I will take a look.
Hah. If you want to see how hard it is to learn something without documentation, ty [Self](http://www.selflanguage.org). It is a smalltalk-ish language and you may like it. But compared to Self, Smalltalk really has plenty of documentation :]
I can recommend them. https://imgur.com/a/IpgSh
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/6rrA0Nh.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dod167j) 
I have one of the Goldberg books, and it recently helped me get over a major hump that none of my other materials seemed to even mention.
hell no - it my be relegted to the historic section but IMO it's starting to get more popular due to the likes of squeak nd pharo. 
The Pharo books are pretty good IMO. Guides on GUI and web programming, scraping HTML pages with xpath, drawing, visualisations etc.
&gt; I went to a large bookstore last night that has several shelves of books in the Programming section, but nothing on Smalltalk Haha. Only several shelves? It's typically a few large rows where I'm at. Programming might not be popular in your demographic area (the stores will stock books/topics that sell in the area). I've worked a lot in mainstream C++/C# languages/libraries and was very frustrated with their limitations (.NET even in new versions had many limitations). Many libraries fell short of their advertisements and I had to spend a great deal of unexpected time filling in the gaps or having to wastefully do things in computationally expensive ways. In learning Smalltalk I learned those limitations never existed and I learned solutions I craved had existed in Smalltalk for decades. Debugging in Smalltalk is unrivaled. If this isn't your cup of tea, then move on to what is your cup of tea. Everyone has different flavors they like. The only thing I don't like in Pharo is that at present parallel processing has to be done explicitly in the application domain. Intuitively it can be done implicitly on the VM level, but there are greater priorities at present.
Hey Marcus, do you like Smalltalk? Are you more productive with it?
What is a mooc?
What video format? I got "Video format or MIME type not supported" when I checked out the page.
It's fun. TO get a feel for what it is like, watch my introductory series [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D). VIdeo #3 is the first one where coding appears. Smalltalk is where IDEs first appeared. The language and libraries evolved along with the concept of an IDE, and everyone else borrowed concepts and capabilities along the way. Only LISP and Self managed to actually genuinely do their own thing, IMHO, rather than merely copy things in a crude manner. 
"A massive open online course (MOOC /muːk/) is an online course aimed at unlimited participation and open access via the web." https://en.wikipedia.org/wiki/Massive_open_online_course
see http://files.pharo.org/mooc/
yes and yes. (sorry for not wanting to discuss that in depth here, sadly I do not have the time right now).
when you do, i'd love to know what kind of thing you do to make money with it. (consulting? your own startup? job?) thanks :)
The other thing to mention is that working in Smalltalk is basically editing an application while it's running. And afaik, it's the only language that works this way (Common Lisp *could* do it but they have chosen to work more like the "cult of the dead" languages). It may sound trivial but it allows a completely different way of working. Back when I did a lot of Smalltalk it was common for me to *truly* write TDD: I'd write a test, let it fail in the debugger, make fixes, back up and step the debugger again, see another issue, fix that, continue on. It was pretty magical, highly productive and I'd advise anyone to experience it even if you don't end up making a living in the language.
Do it. It is magical. It will also make you dissatisfied with every other programming environment. And a little frustrated when you want to integrate with many foreign code libraries but this is improving.
Self does this too, and even better than Smalltalk, from what I have heard. I'm part of a startup working on a Squeak processor. The chief engineer is a Self fan, but Self has even less of a user base and fewer libraries than Squeak does. The processor was originally meant to be a drop-in replacement for the tools bundled with the One Laptop Per Child project, but Smalltalk's messaging is perfect for ultra-massively multicore processing (UMCP) and so the design allows for up to 2^30 processors to work in a single "address space," where in a single unit, or LAN or distributed over the internet (or some combination thereof). One existing design is for a 4-way home internet router to allow cheap [really cheap] fiberoptics-based grid broadband internet.. We've also got a design to be used when regulating solar power grids ala what is needed to re-power Puerto Rico. Combine those last two and let your imagination run free.
Thanks. Do you use it as a hobby or for production solutions?
When do you get to the FPGA stage? Will you have something that boots?
[removed]
Enjoying it so far. Recommended :)
Lately hobby but I have built and run production systems in it before. I'm kind of gearing up to do another cool thing I want. You need to keep in mind that the original vision for Smalltalk was similar to the vision for the unix shell. Its your workbench that you use to manipulate information and build tools. If you've ever worked with one of those guys who lives in emacs (gets his mail in it, reads net news in it, browses the file system in it...), Smalltalk is for that kind of thing. You put things on the screen. You make them behave. You simulate, manipulate, construct, tinker... Think of how a data scientist uses something like Matlab or R these days to explore machine learning solutions. Smalltalk is like that. You use tools, you run little scripts (any text at all, select it and control d and it executes). You compute. I probably wouldn't build Facebook in Smalltalk. I would build anything I personally needed to solve a problem with it. There are some people doing very serious data analysis and visualization with it. http://agilevisualization.com/ It is a great tool for building enterprise applications - both web and desktop - where you don't need insane scalability. It is a nice tool for building Raspberry Pi solutions complete with UI. 
Self is basically Smalltalk evolved to be a prototype rather than class based language. Otherwise they are very closely related. As a recovering Hypercard stackhead from way back, I definitely see the attraction of prototype based programming in certain circumstances.
Very interesting, thanks. &gt; It is a great tool for building enterprise applications - both web and desktop - where you don't need insane scalability. Wasn't JWARS built with it? http://www.dtic.mil/jwars/ "3) Smalltalk was used in a massive military project. In the 2000s, the U.S. joint military wrote a million-line battle simulation program in Smalltalk called JWARS. It actually outperformed a similar simulation called STORM written in C++ by the U.S. Air Force!" found on: https://techbeacon.com/how-learning-smalltalk-can-make-you-better-developer
Thanks, wouldn't Pharo be "better" at this point given the greater community?
&gt; Thanks, wouldn't Pharo be "better" at this point given the larger community? NOt convinced it is larger. Etoys and Scratch and many other children-oriented things were dropped by the Pharo people and those are still important to the Squeak community. Not to mention that the GUI of Pharo sucks, IMHO. 
Yes it is very powerful and people have built very large systems in it. They can be fragile because of the permissive dynamic nature. Unit testing was invented in a Smalltalk environment to compensate for this. Automatic refactoring was pioneered in Smalltalk. The whole agile thing came from Smalltalk. It is an incredibly influential language.
Wow this is great!
I'm fairly in-experienced with Smalltalk, I'm Curious, what are those downsides? I use normally either Cuis or Pharo, Squeak is too laggy (due to network requests, not CPU speed) and crashes from time to time so I don't it much. And I don't think either of them is perfect* I can't see much different between their 'IDE's. *: I'd prefer if the method list in the Browser could be filtered, Ctrl+Tab to switch Windows, maybe Alt-n to switch 'workspaces' and more keyboard shortcuts in general. But I'm still learning the ropes of how the environment works to be able to configure it.
Well, one obvious downside for me is the Spotter for consolidated searching. It drops down and obscures the pane y ou are on, so that if you were hoping to copy some word, you have to dismiss it, copy the word, then call the spotter again then search. Very disruptive.
I think what they want to see is how easy it is to learn something with lots of documentation like, say, Python...
Hello, my main job is to do research at a public research institute (https://www.inria.fr). A lot of that research happens to be with Pharo. Part of that job is making sure that some of the research (where it makes sense) is actually integrated back into Pharo. (So that the next iteration of our research can build on top of it). In addition, I do some Pharo Consulting for http://zweidenker.de, a company I co-founded some years ago.
Thanks for the info ! If I learn smalltalk and love it, I may try to do some consulting too. cheers :)
It looks like Seaside is maintained on Github since earlier this year. STHub version is kept for those who still use it.
Hi, I have used Pharo to create Grafoscopio[1], a system for reproducible research and literate computing (the mix of prose, data, code, visuals &amp; data). The motivation behind such project was my PhD research and the question on how we can change the digital tools that change us. Literate computing (or data storytelling, as some call it) became a path for exploring such reciprocal modification between digital tools and communities, and after trying with Python related technologies to mix ideas from Leo Editor and IPython/Jupyter (see [2]), I went back to my initial intuition of using the Smalltalk meta system, to explore/prototype my PhD question, with a lot of better results in less time and with less incidental complexity (see [3]). Now I have a good prototype and a nascent community around Grafoscopio, with interesting prototypes, like: Panama Papers as reproducible research [4], Specific domain visualization for medicine information [5], and a whole book on Data Journalism [6] made open with Grafoscopio. We have also a recurrent workshops+hackathon called Data Weeks[7] and more agile meetings called Data Rodas, where we explore &amp; learn together data activism and digital citizenship. So, in Pharo you can prototype research questions, build agile prototypes with practical uses, create communities around them and empower people with a critical approach around data and technology. Here are some extra links to expand. There you can find other projects (like the Twitter Data Selfies): [1] http://mutabit.com/grafoscopio/index.en.html [2] http://mutabit.com/offray/static/blog/output/posts/on-deepness-and-complexity-of-ipython-documents.html [3] http://mutabit.com/offray/static/blog/output/posts/grafoscopio-idea-and-initial-progress.html [4] http://mutabit.com/offray/blog/en/entry/panama-papers-1 [5] http://mutabit.com/offray/blog/en/entry/sdv-infomed [6] http://mutabit.com/repos.fossil/mapeda/ [7] http://mutabit.com/dataweek/
tl;dr: "We've been fucking around with shit nobody needs, but we still don't have a deployment solution, namespaces or multithreading.".
Lol. I do think having a better deployment solution and multithreading are two very important spaces for me as well, but it seems like Stefan realizes this and wants it fixed as well. They have quite a few things they're trying to work on and only so many people contributing. Does anyone know what he means by IOT usage? I know it involves remotely logging into linux plug computers (basically a tiny desktop you can plugin to a power outlet and it has wireless) and modifying Pharo on that computer, but I'm not sure why anyone would care unless that computer was actually a microcontroller or something like a Raspberry Pi that had peripherals and sensors. I saw this somewhere in the Pharo roadmap.
To me, IoT implies things such as TV's, refrigerators, thermostats, etc. For example, my lawn sprinkler system is an IoT device; it is connected to my LAN and I manage it with a phone app.
There are many: Settings tool (second icon on the launcher), click on the "editor" settings, you will see a menu of themes, many dark. You can also create a custom theme.
Interesting. I was looking at modifying Pollen*, a Racket library for doing some data related web sites, but I'll give Pharo and related tools a try. Your examples are quite nice! *http://docs.racket-lang.org/pollen/ Much of the data I'm interested in analyzing is US demographic and banking data, but also some related technical data. 
What's the issue with Slang?
By the sounds of it though there are very promising things on the way regarding this issue.
Well, back in the day, you just used morphic, but Real Programmers Don't Use Morphic™
It sounds like there isn't a GUI builder for an application's UI. Is there a good, up-to-date article that covers the best way to get started building a GUI for a Pharo app?
http://files.pharo.org/books/ Pharo by Example 
http://files.pharo.org/books/ Pharo by Example 
I don't understand what your post means. Can you explain this to me please?
&gt; I don't understand what your post means. Can you explain this to me please? Morphic is a GUI library that allows one to drag and drop live GUI objects on top of each other. For some reason the interactive nature of Morphs has been removed in Pharo or at least I've never seen it used or any discussion of how to use it. This video shows morphic working in squeak in the traditional way: https://www.youtube.com/watch?v=qQxuMtgdkGc&amp;list=PL8573D7FF480E256C
I just tried it in Pharo and everything he does in that video I've just done myself: https://imgur.com/a/pgwTM 
&gt; Thanks for showing this to me! It seems to work, or are you referring to something else? No, did you have to change some settings? cant get anything to become "live." Certainly I can't find a way to activate the halos, which programmers say look cartoonish and unprofessional and a reason not to use squeak just because of that.
It's alt-shift + left click to bring up the Morphic halo. 
&gt; It's alt-shift + left click to bring up the Morphic halo. So yeah it works fine. OK, thanks. A Pharo user told me that halos were ttheh most amateur hour of all Squeak interface elements and since I'd never gotten them to work, I just assumed that he meant that they didn't work in Pharo.
yes just use pharo. 
Thanks for your words about the examples. Pollen has interesting ideas and I like its author approach to Racket and embedding expert domain via DSL (in his case, about writing). In [Grafoscopio's Manual][manual], you will find some notes on Pollen and other writing, interactive notebooks and data visualization tools and how Grafoscopio compares with them and its place in the documentation, data storytelling and visualization ecosystem. [manual]: http://mutabit.com/repos.fossil/grafoscopio/doc/tip/Docs/En/Books/Manual/manual.pdf 
I've played with Smalltalk in the past, major problem I had was getting images in unmaintainable states and not being able to do a clean upgrade. Also I'm more of a functional than a OO programmer. 
Wrong sub: r/smalltalk is about the smalltalk programming language/family of programming languages.
Some times my images get slow, but is pretty easy to return to a state similar to the one I had, just by reinstalling the software on a clean images. I keep the previous images or delete them as needed. But, of course, Pharo favored OO programmers instead of functional ones.
Github is the place to go. Version 3.2.4 was released in July - https://github.com/SeasideSt/Seaside/wiki/Seaside324Changelog And here's the stub for (next?) version 3.3.0 - https://github.com/SeasideSt/Seaside/wiki/Seaside330Changelog
I'm going to just link to a comment I made here a few years ago, [my take on learning Smalltalk](https://www.reddit.com/r/smalltalk/comments/3hw5fo/an_up_to_date_smalltalk_beginners_guide/cubtxj9/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=smalltalk). The essence of this is that I think it is more the fact that the language is simple enough to enable certain styles of interactive programming and tools that are powerful enough to handle it than the language itself which makes Smalltalk good. I think the best reading you can do is code reading. I learned a lot from looking at the visible parts of the Smalltalk environment itself, which for me was first Digitalk Smalltalk/V the IBM Smalltalk. I particularly remember just looking at the various browsers: class browsers, method browsers, package browsers. Watching the code for those things execute in the debugger was also pretty informative. I've never even looked at the book, but I understand that the Smalltalk companion to the GoF patterns book is quite good.
Smalltalk was always intended to evolve. When Smalltalk 80 was published, evolution of the language nearly stopped- although libraries continued to evolve. Pharo Smalltalk is a fork from Squeak with a couple goals - reignite language innovations (it has traits and some other newer features) and stabilize the platform enough so real commercial apps are possible. I suggest you join the pharo users list at pharo.org. They maintain a sizeable collection of free ebooks about pharo and Smalltalk in general
I had not realized that Pharo had traits, so this might be enough impetus to make me finally look at it.
since you seem to have come to it from a design patterns perspective, I'd recommend [the Design Patterns Smalltalk Companion](https://www.amazon.com/Design-Patterns-Smalltalk-Companion/dp/0201184621)
'2' is a string literal, so == compares the *values*. '2' and '2' have the same value. 2 asString is an *object*, so == compares the *identities*. Each time you type '2 asString' it makes a new String object. a := 2 asString. b := 2 asString. c := a. Here, a == c but c does not == b, because a and c are the *same* object. The thing about symbols is not that there is only one symbol, but that there is only one *instance* of each symbol. So: a := #SomeSymbol. b := 'SomeSymbol' asSymbol. c := a. In this case, because there is only one symbol object that looks like #SomeSymbol, a == b and b == c and c == a, because they are all pointing to the same actual object with the same identity. But #SomeSymbol is a different symbol from #ProfStef. Sorry, I know this is confusing. I hope that helped a little.
what you describe (the pool) is called "string interning" - it's a fairly common way of handling strings, although i don't know anything about smalltalk implementations.
&gt; Two separately constructred ByteString instances that have the same characters are not identical. Yes: you can use `=` if you want to check for equality instead of identity. Also you can use *symbols* if you want strings guaranteed to be unique in memory. `('hel', 'lo') asSymbol == #hello `
&gt; what you describe (the pool) is called "string interning" - it's a fairly common way of handling strings, although i don't know anything about smalltalk implementations. It's possibly more restricted than general-purpose interning: maybe not for smalltalk but it can be useful to store *literals* in a static segment of the program's memory, as literals are pretty likely to be seen repeatedly. This way whenever you're supposed to create a value from a literal you can just refer to the static one (if immutable) or do a simple copy of it (if mutable). "Native" languages obviously do it ("bss" and "data" segments of a binary) but e.g. Erlang also does it, and will in fact keep literal values shared, off-heap and not garbage-collected (as of a recent release when passing them between processes anyway).
One of the the best books (if not the best) I ever read is "A Mentoring Course on Smalltalk".
/u/estelendur already gave a thourough answer of what's happening but I think it would also be a good idea to point out what you generally need these for. A Symbol in Smalltalk is basically the way you do what other languages use enums for (it's used for other things as well, but if you're programming in Smalltalk you will probably only need to think about the enum case). For example, in C you basically just have numbers and ways to interpret them so if you want to program, say, a state machine and have people be able to read it you need to make a bunch of macro definitions which textually describe the states but change into numbers at compile time so they can be used. With Smalltalk you can use the words themselves and let the system make sure it's efficient. I would point out one thing about `==` and literals though. While `==` is overloaded to do value compare on certain types I believe in the case of literals that the compiler will substitute literals at compile time so if you use a string literal like '2' it will create an object for that and replace every instance of that literal with the same object so if you look at their identity they would be the same. This may be implementation dependant but something like this is generally how most languages deal with literals.
You could also download Squeak rather than Pharo, arguably closer to the original Smalltalk-80 philosophy. &gt;How are special operators and symbols (for example, the object instantation operator, ||, string start end end character, "", etc) constructed in Smalltalk? AFAIK, they're not part of the syntax, but part of the standard library. Some people have told me that Objects can modify the syntax and change the parse tree, so is that possible, and is it done? If it is done, how? The various kinds of text panes used in Smalltalk are instances of classes written in Smalltalk and so can do their own parsing. Specifically, the original "workspace" text window has a special array which contains "predefined" variables, such as "Smalltalk." There happens to be a single instance of a Class named "Smalltalk" which is an array that contains all "global variable" names and so, when a workspace window is started, it runs a routine that checks with that known single instance of the Smalltalk class, and puts a reference to the class ID for Smalltalk in the predefined array with the index "Smalltalk." The language parser that is associated with that workspace window (it is automatically evoked when you use the keyboard shortcut for the menu "Do It") happens to be one that recognises the Smalltalk language. That same class (or a subclass) is also used in the text-editor portion of the System Browser, where other special instance variables are predefined as well. &gt;How can Object subclasses be created if creating them involves sending the message subclass to Object, which takes a symbol as an argument? Aren't symbols Objects too, so how were they created? There's a lot more of this type of question in Smalltalk that has been confusing me recently :( It's very recursive and self-referential. There is also a class called "ProtoObject" which is the super class of Object. Some things are defined in ProtoObject and then used by Object. &gt;Why is the syntax for keyword message so strange? AFAIK, the syntax for keyword messages is &lt;reciever&gt; &lt;messagename&gt;: &lt;arg1&gt; &lt;arg2Name&gt;: &lt;arg2&gt;? Is it similar to currying, where &lt;reciever&gt; &lt;messagename&gt;: &lt;arg1&gt; returns a partially evaluated Object, and &lt;arg2Name&gt; is a different message? Some people have said that it's pascal calling conventions, but that still doesn't make it less weird. It simplifies the parser (remember: this is a time when memory was measured in Kilobytes, not megabytes or gigabytes and so the simpler the program, the less memory it used). Smalltalk has a special kind of variable called "Symbol" which is a text string preceded by a '#'. There can be only one instance of any given Symbol in the entire system and there is a dictionary subclass which is highly optimised to handle Symbol objects and the VM is also optimised to handle them. When you type something like _myArray put: 'name' at: 'saijanai'_ in the workspace or a System Browser editor pane, the parser associated with that class of text pane would deal with 'myArray' as an instance variable name (assuming the syntax is correct) and then assume that there is a Symbol called '#put:at:' associated with the class that 'myArray' is an instance of. A method call means to push the object associated with the name 'myArray' on the stack, followed by the Symbol objectID associated with '#put:at:' on the stack, followed by the Object IDs that each variable references. Then the call means that the 'myArray' object's Method Dictionary is searched for '#put:at:' and the actual code associated with that Symbol is executed. If no '#put:at:' dictionary index is found, the dictionary of the superclass is searched the same way, all the way up to Object's dictionary, which is where message "#MessageNotUnderstood:" is sent to Object with the Symbol '#put:at:', which then evokes the debugger to display the debugger window. I've probably screwed up some details, but this is roughly sorta what goes on. &gt;How much syntax does Smalltalk actually have? 6 pseudo "reserved words" that are predefined in the workspace/browser editor parser: true , false , nil , self , super , and thisContext . &gt;How do some Objects, like the array Object, take any number of arguments (the with message can be repeated an arbitrary number of times)? It's not actually an arbitrary number of times. #with, #with:with, #with:with:with: and so on are actually all Symbols defined for the Object method dictionary. If you use too many, the #MessageNotUnderstood will automatically be evoked, if I recall correctly. More than 6 (?) variables in a single method is considered ludicrous and so they simply say "pass by array of variables" instead.
Thanks for the explanation (sorry for the late reply). Ok, I get the concept behind objects being separate entities so they aren't the same. As well as the string comparing the values so they are equal. But why isn't '2' equal to 2 asString? As in, why doesn't 2 asString turn the 2 into a string literal? 2 is the object, but isn't the message telling the object to become a string literal? So shouldn't we be working with the string literal threfore it would 2 asString would be == '2'. I'm assuming that the program prioritizes turning the 2 into a string before checking if it's equal to '2'. 
&gt; Why doesn't 2 asString turn the 2 into a string literal? 2 is the object, but isn't the message telling the object to become a string literal? So shouldn't we be working with the string literal therefore it would 2 asString would be == '2'. Why is 2 asString still considered an object? 
Thanks! For number 1, I was asking about how it was done, not how many there are. As for number 3, why is it not collection.set(key: key, value: value)? It's equally readable. As for number 5, lol - a cheap, but working way to do it. Thanks!
Thanks a lot! This cleared up how it internally works!
&gt; Thanks a lot! This cleared up how it internally works! You're welcome. Like I said, I'm sure I have some things wrong, but this blurry overview should give you at least a "feel" for what is going on, and for me, that's better than a 100% accurate explanation that takes hours or days to wade through and grok. Just don't blame me if you get a question wrong on a test, however.
They aren't the same 2, I guess. I don't remember, or maybe never knew, exactly how Smalltalk does object identity, but identity is definitely a property that objects have and objects are almost never the same object.
1. In Smalltalk all computation is done (or at least is made to look like it) by sending messages to objects, which causes them to run methods. There is no "object instantiation operator", there is only the messages like `new` which you send to a class (which is an object). Booleans are also objects, and understand messages such as `and:`, `not`, `ifTrue:ifFalse:` and so on. On Boolean, for example, there are messages called`|` and `&amp;` and `==&gt;` but they are just messages, nothing special about them except that the parser understands that they appear infix with exactly one argument to the right, and it knows this because their selector (their name, essentially) does not start with a letter. Literals, such as `'this string'` or `#aLiteral` or for that matter an integer like `12345` are created by parsing text in the usual way—reading the text, creating an abstract syntax tree and so on. At some point a `new:` message gets sent to, say, the `ByteString` class. What you might not be used to is that Smalltalk is running all the time, so the compiler is being invoked on little snippets of code here and there all the time. You don't edit a file of text and then compile it. 2. Symbols are objects, yes, and are created on the fly, as above by reading, parsing, and acting on their literal representation. 3. as others have explained, message syntax allows for code to read like natural language. Smalltalk was originally going to be part of a system aimed at technology-naïve users, including children. There is no currying, nor partial evaluation (which, BTW are very different things). 4. Almost none. Special symbols are the delimiters or markers for literals (ie `'`, `"`, `#`, `@`) the keyword argument indicator `:` and the delimiters for blocks (`[`,`]`) and for local variables `|` within methods and blocks. That's it. Oh, one more thing—by convention, a variable name beginning with a capital letter has global scope, which is why class names begin that way. 5. They can't. Some objects have a bunch of methods with various numbers of keyword arguments.
Thanks 
Thanks for the shorter and easier to read answer! The only part I didn't really get (which the other answers didn't mention too much, either) was how the AST was interpreted for those "special" elements. I get that the code is parsed into the AST, but how does the compiler "know" that the || characters are for local variable creation, that " is for comments, ' is for strings, # is for symbols, [ and ] are for blocks, etc? Are they part of the syntax, or is the way the AST is interpreted modified? If it's modified, how?
BTW, wouldn't it make more sense if, let's say, the with message to Array returned an array with that element appended? That way, any arbitrary number of with:s could be specified without an error, or is that too inefficient, or too Haskell - like?
That's not necessary, because of the concept of cascading message sends. I forgot [facepalm!] to mention that in my reply about syntax. A `;` between messages means "send the message on the right to the receiver of the message on the left". So you can do this sort of thing: |a| a := Array with: 'a'. a atLast: 1 put: 'b' ; atLast: 1 put: 'c' ; atLast: 1 put: 'd'. which will leave the array `a` containing only the string `d` (because `atLast:put:` is a destructive update. As it happens, the method `atLast:put` answers the object added, but Smalltalk methods _by default_ do answer their receiver, which in this case would have been `a`.
The code you write must be converted to a computer can understand. Usually the way compilers deal with literals is they group all the same ones together. So, for example, if you had a string `"my string"` in C, spread around the file, the compiler will recognize that that same string is used, allocate one string for it and put it in the statically allocation section of the object code. In Smalltalk, I *believe* what will happen is when the compiler encounters `'2'` it will allocation an object and replace that location with the newly allocated object, and when it sees the next one it will use the same object again. *If that is true* than `'2' = '2'` (value compare) and `'2' == '2'` (identity compare). I have to amend something we said before. In Smalltalk `=` is value compare and `==` is *always* identity compare. It's just for certain types there is only ever one instance. Examples of these are symbols and all numbers. That is, there are not multiple `235` numbers, there is only one so you can use `=` or `==` to compare them, it will do the same thing.
&gt; (I'm using this info to create a programming language based off of Smalltalk. Kind of like Strongtalk, but more Haskell-like) &lt;curious&gt; How will it be more Haskell-like?
Thanks! 
Thanks, I'll go walk through some compilation examples. Just as one last question - if the syntax is held in classes Scanner and Parser, how do classes add synthatic elements? Is adding synthatic elements done at compile - time, or at runtime (probably compile - time, but AFAIK, Smalltalk has no way to execute code at compile - time)?
Well, strong, static typing, laziness, and immutability. I MIGHT add monads, but that might make it unnecessarily complex.
Basically, how does the class Symbol bind the # to symbol, strings bind ", characters bind $, etc? Are they part of the syntax (core syntax or in the classes Scanner and Parser), or are they added dynamically by another class?
&gt; Are they part of the syntax (core syntax or in the classes Scanner and Parser), or are they added dynamically by another class? So, the answer to that question is "yes". In fact, you can make a symbol from almost any object that knows how to represent itself as a `String`, including—but not limited to—a sequence of characters that you pulled out of an editor window. In pharo there is: String&gt;&gt;asSymbol ^Symbol intern: self and class Symbol&gt;&gt;intern aStringOrSymbol ^(self lookup: aStringOrSymbol) ifNil:[ | aClass aSymbol | aStringOrSymbol isSymbol ifTrue:[ aSymbol := aStringOrSymbol. ] ifFalse:[ aClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[WideSymbol]. aSymbol := aClass basicNew: aStringOrSymbol size. aSymbol string: aStringOrSymbol. ]. NewSymbols add: aSymbol. aSymbol]. which lazily creates a `ByteSymbol` or `WideSymbol` as required by sending a message, `basicNew:` to the relevant class which it looked up, and then sends `add:` to `NewSymbols` which is just a `WeakSet` of symbols. That's the only "binding" that happens. Method `basicNew:` is Smalltalk's "malloc" and lives on class `Behavior` which is the parent class of `ClassDescription` which is the parent class of classes `Class` and `Metaclass` Really, you need to play around with Smalltalk to rally get how it works. A lot of the ideas you seem to have about how a language "must" work just don't apply. Objects send messages to one another, that's all. 
&gt; how do classes add synthatic elements? What do you mean? I don't understand what a "synthetic element" is, but remember that in Smalltalk there only objects sending messages each other (except a few cases that are handled by the VM directly for efficiency). The answer to any question about Smalltalk is almost always: an object send messages to some other objects. Classes (and meta-classes, and methods and blocks) are just objects, they have no special powers in the runtime—and also no restrictions. &gt; Smalltalk has no way to execute code at compile - time Huh? Smalltalk is all run-time, all the time. "Compile time" is just when the classes `Scanner`, `Parser`, `Compiler` and their close collaborators happen to be doing some work. That can be at any time. Compile time is run-time and the compiler classes are regular Smalltalk objects which send messages to each other and run methods which are regular methods.
OK, thanks! A synthatic element is a syntax element - something that's part of the syntax. For example, message passing is a synthatic element. Based on the fact that certain classes are "bound" to certain characters (single quotes for strings, hash for symbol, etc), how do those classes "bind" those characters? Based on the fact that Smalltalk has no distinct compile and runtime phases, is it bound during runtime?
Is it still going to be object-oriented? And if so, how are you going to integrate immutability with state?
Where did you get this word "synthatic" from? Plain Google and Google Scholar seem only to understand it as a typo (or maybe OCR error) for "synthetic".
&gt; the fact that certain classes are "bound" to certain characters (single quotes for strings, hash for symbol, etc) That is not a fact. &gt; how do those classes "bind" those characters? They don't. The scanner, parser and compiler objects interpret those characters and execute code to create, say, a string object. Or, they write code to represent a block or method. 
What makes you think that Smalltalk is the right starting place for this language, since Smalltalk is dynamically typed (and dynamically everything else, as it happens), eager and works by mutation? 
Well, it'll still be Object Oriented. For integrating immutability and state, I'll do the same approach as Haskell took.
IMO, the problem with smalltalk as a 'pick up language' which gets a lot of people interested in it is that by it's own design it doesn't follow any standard paradigms that most people are used to and tends to feel like a dead end when it comes to the unnecessary step everyone feels IS necessary: "How do I get what I made to simply run on my grandma's computer just by her double clicking something?" This is not what smalltalk was designed for and never was and primarily why I think everyone kind of looks at it like it's an ugly computer mutation or something. Apple had a hard time trying to figure what to 'do' with Hypercard, which is largely the same concept: It's not a program or a language but both...the most tragic aspect of it isn't that no one is out there to help, it's that in a world not dictated by hackers funded by rich morons, the web browser and OS paradigms could have just been THE smalltalk environment. It already does everything that an OS can do, and everything that the internet *claims* to do (but far better). It's a language for both high and low level coders, for beginners and experts yet I think this very idea of sharing a space is what keeps it from becoming more popular. Just look at programmers in general who like to brag about 'elegant code' rather than actually make something useful. It's a shame, but that's my outsider perspective on it. There's too much cultural differences between the existing groups and their mentalities that don't mesh with the all-inclusiveness Smalltalk has tried to maintain. Personally, I get it...a guy going to get a beer at a bar doesn't want to hear a screaming child in the corner; a bar isn't for children. But again, we're talking about a programming environment (language? Maybe not so much, it's really a large hunk of clay to be molded by whomever is running it), but that's the general feel I get from many communities regarding it. If you can't make something with it that will make you money or fame, it's worthless in most people's eyes. It's a shame really...if people would get off their high horse and stop trying to showboat pointless accomplishments (look how many shaders I was able to get running! all done in assembler!) we could figure exactly what Smalltalk can do for general computing other than being an oddity.
I wasn't saying smalltalk doesn't make *any* money, but strictly speaking from pop culture point of view, even non programmers have actually heard of Java, Lua, C++, etc. so immediately at face value, it's got more potential than this other thing that sounds like what they do at an airport before takeoff. :p
I understand. Another point is that good, corporate Smalltalk programmers are highly valued and highly paid.
Having the goddamm deployment tools is what is taking me aside from really coding in this plataform. 
Decided. Stupid phone.
FYI this is a sub for the Smalltalk programming language. 😊
Thank you, that explains things.
This is a programming subreddit for Smalltalk-80
Smalltalk-based AIs work in all sorts of ways...
I think the videos are subtitled, yes.
You should probably be even more afraid of ze terribel french accent :D
I'm not sure if there is a published comparison or not, but I used dolphin for work for a while so I can give a slightly biased and incomplete comparison. The biggest, most important difference is that Dolphin only runs on Windows. Only only Windows. And if Microsoft takes away support for 32 bit applications anyone using Dolphin to produce software that they sell is likely kinda screwed. I don't know if Pharo has or will have a 64-bit version, but they have more active developers so it seems more possible. Aside from that... they have different keybindings, meh. They have a different GUI and I think Dolphin's is nicer. You can probably make nicer GUI applications more easily with Dolphin because it lets you build with native Windows graphics objects. Pharo has a larger active community. And that's about what I know.
Oh yes, I forgot, it does run under wine! This was not a possible use case for my former employer, as it apparently looked much worse and cosmetics were important to the users. The win32 thing is a fear that my old employers have, and I assume they have some evidence that this may happen in a few years, especially if Microsoft moves toward the walled garden app distribution model (which it may or may not). Requiring customers to jump through a bunch of hoops to get the program running would not be good for their business, I am sure; most of their customers are highly non-technical and need to be reassured that the software they're buying is slick and up to date. But if you are not planning to sell to non-technical people there is much less of an issue, or if you are braver than my old employers.
Pharo does indeed now have a 64bit virtual machine!
Smalltalk runs on self-contained virtual machines, so actual code is mostly non-portable. Cincom is proprietary and is certainly non-compatible with most other Smalltalks. Pharo seems to be derived from Squeak, so there may be some level of compatibility, but I wouldn't depend on it. And Dolphin is Windows only, so I doubt it is compatible with anything else.
What kind of code? I mean, is there lots of platform independent stuff? That should be portable, especially if it is cleanly separated from platform and implementation specifics. I've worked on porting code from Digitalk Smalltalk/V to IBM Smalltalk. Stuff that involved operating system calls, graphics, IO and the like needed changing, as I recall, but most of the application I was working on was platform independent: dealt with the generic collections; the kind of stuff that ANSI Smalltalk wound up standardizing on, I think (this was before that standard was ratified).
Ok, but as you say, changes probably have to be made to port code from one "dialect" to another. That is probably not what OP meant by "portable". And I said "mostly non-portable", meaning you can't write code for this dialect and just expect it to run on another one. I'm not sure we are even saying different things here, we just have different slants on the question.
Craig Latta was working on a universal library system called "spoon" (now called Niad) but seems to have become more interested in web-based programming. Other universal library systems are also in the works. Our SiliconSqueak project needs such a system, for example.
&gt; But once you reach any GUI, every dialect has completely different approaches to that and there is no compatibility. It's easier to rewrite all the GUI in the target Smalltalk Interesting. I figured most systems were using a GUI framework (Morphic, Brick/Bloc, etc.), and you'd just need to port the framework's smallish number of primitives, a la wxWidgets. 
Is http://seaside.st the official homepage of Seaside? The "news" section has items displayed from 2006 through 2014. If it isn't dead, someone should think about updating that page.
I don't know the details of UI libs but that seems like you'd end up porting/reimplementing the whole framework. For something like Bloc, you'd have to port the FFI bindings to Moz2D or Cairo, but then Bloc apps become easy to port. Alternatively, I'd consider splitting the app as a portable backend defining the model classes (as in MVC) with dialect-specific frontends.
As said by [ceferro](https://www.reddit.com/r/smalltalk/comments/7zojfl/portability_between_smalltalks/dupt2gd/), code that only relies on basic stuff is portable. The way your answer was formulated suggested that one should just abandon all hope… However it's certainly safe to say that all Smalltalks have `Boolean&gt;&gt;ifTrue:ifFalse:` and `Collection&gt;&gt;do:`, so the question is, at which point do dialects start to differ in a really annoying way? I gave the VW namespace example because it has an impact on syntax. I think Pharo/Squeak's dynamic arrays are not universal either (the curly braces). Also, do you include library availability in your definition of "portability"? People say that C is portable. Now, show me a "portable C application" which doesn't contain a bunch of compile-time conditionals generating different code on each platform ;-)
&gt;but that seems like you'd end up porting/reimplementing the whole framework. Yes. Probably not enough bang for the buck with the limited resources smalltalk in general has. But if your framework is going to be BSD/MIT licensed anyway, then I could see the case for making it so that other smalltalk might want to take it up as well (free or commercial).
I'm pretty sure the question meant *source* code, not *compiled* code. With respect to source, the nature of the VMs becomes irrelevant, it all is a question of what non-standard APIs does the source make reference to.
&gt; at which point do dialects start to differ in a really annoying way? Do most smalltalks implement at least the ANSI standard? Or stated another way are Phare, Squeak, etc. supersets of ANSI Smalltalk? It is better to say that methods and objects are portable if they only use what is in ANSI Smalltalk? &gt;show me a "portable C application" which doesn't contain a bunch of compile-time conditionals generating different code on each platform ;-) Yes, the same with Common Lisp, with its conditional reader macros. It is fair to say that ANSI Smalltalk doesn't come with features to facilitate portability across implementations? Thanks.
&gt; As Seaside proves, code that works across several Smalltalks is possible. Here are the [Seaside coding conventions](https://github.com/SeasideSt/Seaside/wiki/Coding-Conventions) for those that are interested.
did you mean this video series for [squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D)? seems a link got mixed up in your post.
&gt; did you mean this video series for squeak from the very start? seems a link got mixed up in your post. Oh yes, thanks. Corrected.
This is awesome!! Been wanting this for so long
It’s too bad none of the bigger Smalltalk vendors have produced something like this
More hype is the biggest difference. Speaking as someone who believes in PR, this is an important issue, not merely a snide comment.
Thanks, nice demo! Useful code for using Azure APIs and handling images.
^
I am in complete agreement with you but for me languages I feel comfortable with are Forth and Prolog. 
I think the problem is that some of the free Smalltalk distributions are mostly used by people that programmed them. The interfaces are usually based on old principles. The help lacking. If you want to learn C++ or javascript, you have special websites to learn it. In all smalltalk versions there is a lot of communication in the mailing lists. If you have problems with the code, report the problem on the mailing lists. They will help you and it shows them what problems a beginner encounters. [Pharo](http://www.pharo.org) is really a research environment, where new things are tested. It is interesting, if you know what it all means. In pharo you have right-clicks and left-clicks to do anything. [Dolphin](http://object-arts.com/downloads.html) has a windows 95 style interface. A bit easier to work with, but also has some strange quirks. At least it has a page with examples. [Squeak Smalltalk](http://squeak.org/) It was my workspace for some time, but I do not know the current state. Almost all Smalltalks have become bloated. That is because there are classes for almost anything in the libraries. Smalltalk usually has a module/library system. It is like having all possible libraries of Javascript in your system. You do not need to subclass anything if you want to define Money. In Smalltalk your class can behave as anything as long it has the methods (duck-typing). You start with defining the class, and the methods that you need. (Just use empty methods first) Then you fill in the code for the methods. Maybe you want an MoneyExchange class too. Dictionaries are defined runtime. MoneyExchange exchange at:'yen' put:3.02. You can do that initialization in the MoneyExchange class, but it needs to be run once. Run-time errors can be a pain if you do not know what to look for. The debugger shows the whole 20 level deep call stack, but only your own code is relevant. The advantage of smalltalk is the word-like programming and the very easy grammar. And it is pure object oriented. That means you can treat anything like an object. The programming itself becomes very simple. But the interface is sadly not so simple. I think the simplicity of it becomes clear if you look at examples in books. Ruby and Scala also have these OO-capabilities. I think you will prefer Scala. It is a bit like Pascal. 
I think you should post the code you tried with the Money class. It could help to get some feedback on your code and figure out why it didn't work. I noticed you said there were 'uncommented messages' in pharo. I think you mean 'uncommented methods'. 
http://books.pharo.org 
Here's a sneak peek of /r/unseen_programming using the [top posts](https://np.reddit.com/r/unseen_programming/top/?sort=top&amp;t=year) of the year! \#1: [The power of visual unseen](https://np.reddit.com/r/unseen_programming/comments/6u64kz/the_power_of_visual_unseen/) \#2: [P: A programming language designed for asynchrony, fault-tolerance and uncertainty - Microsoft Research](https://www.microsoft.com/en-us/research/blog/p-programming-language-asynchrony/) | [2 comments](https://np.reddit.com/r/unseen_programming/comments/6c7yoj/p_a_programming_language_designed_for_asynchrony/) \#3: [Status of (Visual) Unseen](https://np.reddit.com/r/unseen_programming/comments/6u5e5u/status_of_visual_unseen/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Thanks! I will be watching them!
There is already a Smalltalk VM shipped with Raspbian - its Scratch - which is written in Smalltalk and runs on the OpenVM (all the free smalltalks use the same VM which also hosts NewSpeak and Scratch). I think you might prefer [Cuis](https://github.com/Cuis-Smalltalk/Cuis-Smalltalk) which is a clean minimal Smalltalk (forked from Squeak) by Juan Vuletich that is intended to be used with a clean core that loads packages on demand - thus eliminating a lot of clutter and making things more reproducible. 
Not really, they have clean bootstrap from sources, improved headless story, modular (development) tools, remote development / debugging &amp; shitloads of other stuff. Pharo is getting a lot better, I only wish S. Ducasse wasn't so pigheaded when it comes to type annotations (they are great as documentation and help for tooling; any semantics are to be left completely pluggable, just give us a syntax and see what different peole will use them for)
Is there a mailing list or other "community" for Cuis?
Well, I guess I'm only famous in my own mind, but "Squeak from the very start" is an introductory series of video on how to download and install squeak, as well as several hours of an over-the-shoulder look at the most basic features done in a Salman Khan-Style presentation. And I hadn't been doing squeak for very long when I started doing the video series. IN fact, with many of the features, I learned the features and on the same day that I learned them, I rehearsed presenting them and then made the video presenting them, all on the same day. To me, that is elegant simplicity.
Ah, haven't heard of your videos, and assumed entirely diferent kind of authorship ;-) Sorry. I'll check them out, to see whether they'll scream (or at least whisper) "Squeak is so much simpler than Pharo" to me.
Simpler doesn't mean better, of course but for a beginner like me, they were easy enough to figure out. Like I said, my friend and I had a lot more difficult time figuring out Pharo. Lots of features looked interesting but they were put together non-intuitively and one important feature seemed to have been modified beyond repair.
I took a look, and it seems to me the videos are: Either about pretty simple things: loops &amp; other basic constructs / datastructures; dragging morphs around / halos; file handling (which Pharo streamlined a lot, I remember hopping around the image like an amphetamine bunny, trying to find basic things like read a file, give me a parent directory, join two paths ...). Or more about libraries / frameworks than Smalltalk itself: seaside, pier, opengl, connectors (which have Pharo port), and exploring those (or similar) libs would have been at least as "simple" in Pharo. But hey, two Smalltalks are better than none, at least we can pick our poison ;-)
From my days of delving into Forth, I always remember this quote from Moore: "There’s a definite sense of rightness when you’ve done it right. It may be that feeling that distinguishes Forth from other languages, where you never feel you’ve really done well. In Forth, it’s the “Aha!” reaction. You want to run off and tell somebody." (Brodie, *Thinking Forth* p. 133) Perhaps that *definite sense of rightness* is more attainable in languages that narrow down the possibilities, languages that some would accuse of being *rigid*. I've heard that particular adjective thrown at Forth and Pascal, too. Smalltalk, on the other hand, feels so messy and open-ended. Even more so than Lisps, there you got tinkering for the ages. That is why I use the new-agey verb *To Grok* for talking about mastering Smalltalk: it is more about getting a feeling of it, an intuitive and easy-going relationship to it. It's a sort of enlightenment (in the Buddhist sense) to be able to say *I don't care* about how it works, and just flow with it. 
I would have thought that Pharo would be just as easy as Squeak as well, until my friend called and we "pair-programmed" via Skype trying to figure out a very simple feature and it took us a very long time to figure out that it just didn't work in the same way it used to on Squeak. It is possible that the users of Pharo have different needs or that for the users of Pharo, the old way was of no value but for the two of us, the old squeak way was of value and we couldn't (after an hour of trying) figure out how to get the default behavior (which seemed the most logical behavior) to work. Senders of... Where's the list of every method/code block if else: block, etc? You have to read through the code and click on the specific line where a method is found rather than get a default list of methods that you can select from. That is, in both our opinions, a seriously weird thing to omit from the Pharo version.
For the linking error, [it seems pretty common](https://duckduckgo.com/?q=mingw+wsafdisset&amp;ia=web) with [this blog post](https://sharewithraymond.blogspot.com/2012/03/undefined-reference-to-wsafdisset8.html?m=1) appearing to offer a solution
Have they [Squeak from the very start] been of any help?
There's a free MOOC course on Pharo here: https://www.fun-mooc.fr/courses/course-v1:inria+41010+session02/about Spoken language is French, but the movies are also dubbed in English or you can download and use EN subtitles.
"Senders of used to give you a complete list" - i do get a full list of senders. Are you trying to say that you preferred that list i a pop-up menu ? "requiring your to find the message in the method source text." You keep repeating this, but WTF it is supossed to mean ? I sure as hell didn't need to even look at a message source.
GNU Smalltalk might suit you. http://smalltalk.gnu.org/
&gt; The Smalltalk for those who can type LOL. Excellent start.
Beggars/choosers, but do you know if gst supports the live-coding that makes smalltalk so appealing? 
Okay, I'll keep trying to figure that out. Thanks. It just doesn't seem to have a built-in debugger, etc. Thanks again.
You're not familiar with how Smalltalk works, but you are creating a language that is based off of it? I cannot even. 
I don't understand the relation with Smalltalk, it is not visible in the first glance to the webpage
http://fizzygum.org/docs/fizzygum-for-lispers-and-smalltalkers/ and http://fizzygum.org/docs/technical-intro/ and the object/class inspector example here: http://fizzygum.org/docs/hacking-fizzygum/
Thanks! I didn't pass from the home page.
&gt; Here's an idea: how about developing a bare-bones Smalltalk implementation that new programmers should build themselves? I mean: give us just the virtual machine so that we must bootstrap the whole Class library from Object upwards. Layer by layer, we will be adding functionalities and features, instead of being handed a full-fledged system with no manual: 'There. Go figure'. You may want to check out [Little Smalltalk](https://github.com/crcx/littlesmalltalk).
Too bad it does not come close to being a Smalltalk
If it is a Smalltalk that is easy to learn, then its a bad implementation. Smalltalk is the most difficult programming language I have learned. Assembly is a bit harder, but not much. People are misled by the simplicity of the syntax, the sophisticate IDE , the fact that is dynamic language and the pure OOP design. Smaltalk is a very hard to learn programming language. Mainly because the "language part" makes aroynd 0.001% of what Smalltalk really is. Forget about Pascal Forget about Scheme Smalltalk is a beast and unless you are willing to put the time and effort you will never discover what the fuss is all about and why pretty much every modern software technology comes from Smalltalk and not from Lisp or Pascal (even thoug Lisp has been a big inspiration for Smalltalk on language level)
1) Git friendly workflow 2) Completely redesigned IDE 3) New FFI 4) Tons of new Libraries focusing on professional coding 5) Actively developed , moving forward very fast ---More Reasons--- 6) Far better documentation 7) Modern and not emotionaly attached to the legacy of Smalltalk , willing to go beyond that 8) Far bigger community , far better support 9) More focused on web dev (I dont even like web dev) 10) By far the most important Smalltalk implementation and pretty much the last hope for Smalltalk survival because let's face it things are not very good for Smalltalk popularity wise Pharo owes a lot to Squeak because it started as a Squeak fork and to this day much of the code is squeak code. On the other hand I joined Pharo in 2011 and left in 2017 (mainly because I realised I could bring many of the features I liked back to Python) , Pharo promised to provide an open source project focusing on modernising Smalltalk, community based and focused on professional coders and it delivered all its promises to full. Pharo has diverted from smalltalk so much that there is just a vast amount of diffirences between the two projects. The only thing the two projects actively share is the VM. Everything else is just diffirent.
For toy applications, any of them are useful. I did a series of tutorials on Squeak that should be applicable to any Smalltalk at that level (except Squeak-specific stuff like etoys): [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D)
Pharo is in a bit of disarray right now as they are upgrading a lot of subsystems. It would be like trying to prepare a big meal in a kitchen undergoing renovation. You might give Cuis a look. Its a Squeak fork that was brutally simplified by one very smart guy. I like his minimalist philosophy. https://github.com/Cuis-Smalltalk/Cuis-Smalltalk
Don't forget my videos, [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D) which give a kind of "pair programming" tutorial of much of the beginning material found in [Squeak by example](https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?referer=http://wiki.squeak.org/squeak/6546&amp;httpsredir=1&amp;article=1112&amp;context=compsci_fac) and [Pharo by example.](http://books.pharo.org/updated-pharo-by-example/)
I am using Pharo right now and going through their MOOC \(online course\). I am a beginner as well, but I like that Pharo has a Discord group, so when I have questions I can go on the group chat and people are usually very responsive. My problems usually arise when I put the image on an infinite loop and then it crashes. It isn't hard to recover as long as you have your change files. 
First, I'd like to push my ultra-introductory videos, [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D). Second... "live programming" doesn't have disadvantages, but a Smalltalk implementation may have compromises such as possibly strange implementations of floating point and lack of an easy-to-program switch statement. Name space issues has been an issue in Squeak for a long time as well. Also, unlike C or C++, there's no official standard any more so each implementation is becoming less and less compatible with rival implementations.
Cool, I will take a look at your videos :) Thanks for giving some critisims. What do you mean "live programming" has speed as a disadvantage? Is it slower to code or do you mean the code runs slower?
Code runs slower.
Mmm, that link and any other I could Google does not work \(The one from the Squeak Wiki does not open in my PDF reader\). Is this a free book?
I updated the link for you, and we may trust it is a free resource, since it is listed on the [free books](http://sdmeta.gforge.inria.fr/FreeBooks/) at Mr. Ducasse's site.
Thanks for making these. I've been looking for something like that.
Pharo has several external options last I checked. THe very best was Alien/SPock which allowed you to program in x86 assembler and chain external function calls within the body of hte method (which was all either x86 assembler or glue to the VM). THe first time a method was run, it would actually evoke the gcc compiler, compile the code and inject it into memory. Sort of a pre-compiled JIT. Unfortunately that was cancelled before it was finished. I personally would have preferred C or even Slang to be the source code, but the programmer was a real bit-hacker and wanted assembler specifically. . There are also libraries that let you interface with native scripting languages, so you can write OS scripts in Smalltalk. Both Squeak and Pharo have thousands of libraries that may do more than you expect, but as you say, they are ill-documented. In fact, Smalltalk's philosophy is: "the source code is the documentation" and since many/most of the libraries are written by doctoral students and professors, they assume a lot of background on the part of an end-user. A bit irony for a language that was invented to help Alan Kay's team make programming available to kids.
i don't see a download for a linux version on the website even though it says it is supported?
Thanks for pointing that out. There will be a maintenance release out over the weekend. I will make sure that the Linux build is uploaded to the site. 
Does it support web-gl? websockets? I think those are pretty important for gaming on the web :p
There will be websocket or equivalent support in about a week. For graphics, there will be paper.js or web-gl. The first games will be simple board games. Once that is working properly, I will be adding animation and socket support. -- Peter 
Nice. This project is pretty impressive. I think it's designed to make SPAs (Single Page Applications) right? Or is it the server side aswell?
Thank you for the comment. Yes, the interpreter can run in the client (browser or mobile device) and uses a widget set to build the page and manage user interactions. In this mode, it would be more of a browser application than a SPA. This configuration would be the most useful for games and teaching programming to students. The interpreter can also run on the Ruby-on-Rails server. In this case, the client widgets would be proxied and controlled from the server. The use case for this would be any data-centric applications such as database administration, project management, inventory management, etc. So, it can run in either the browser or on the server. Or, in both, something like Ruby Meteor.
This is a better question for StackOverflow. I still don't understand well what are you trying to do, but "People := People new" seems to point that People is a class (since you are sending new to it) but you are assigning it as a variable, that will destroy the class (or more correctly, render it not-accessible using its name).
People is a class, and each of the names like Adam, John are are objects. the point is having the names of the people in an Array or Collection to be able to refer to later or have the number of them (using size peopleGroup). 
If a group of people hold no behaviour except for being a collection of people, then you could directly use an OrderedCollection. people := OrderedCollection new. people add: Person named: John; add: Person named: Adam; add: Person named: Josh. self assert: people size = 3 If you need specific behaviour, create a People class that hold an instance of a collection and delegate to it. Beware of what most likely look like syntax mistake: People := People new # Here, like ceferro said, you just lost the name reference of the class People. Person Josh # You are sending the message #Josh to the class Person. What you want is something like this Person named: Josh. You could make it work though but that is advanced concepts and bad design. People peopleGroup size # You are sending the message #size to whatever is returned by the class method #peopleGroup of the class People. This look like a singleton pattern and probably not what you want. What you want is send the message #size to an instance of People.
My personal preference (for hobby projects) is to start from clean image. Create my own package and use Iceberg to manage the changes. I don't know though how one would manage dependencies in this case.
I see you have the question on SO now, I think it is better to follow there. 
I always save the original, clean image. Then I clone it for each new project.
VisualWorks Smalltalk is a good place to start. It runs from one image file. Of course you can read and write other files into the system like photos or text documents, etc. But yes you are correct, you can begin an entire project in one file and learn a ton without having to worry about anything outside of that image file. Be sure to read the documentation that is provided by VisualWorks (or whichever version you pick). One of the most important aspects of programming that people often overlook is reading documentation. It is not as fun as writing code but it makes it much easier.
Is VisualWorks a type of IDE?
ehhh...kinda. Smalltalk is a unique beast. There is an "image" file which is basically a snapshot of an entire live running system. I cannot stress this enough - Smalltalk is a fully self contained LIVE RUNNING SYSTEM. Inside the live running system are a number of objects and classes (which are also objects - don't get too hung up on that yet). At a somewhat higher level, these are arranged into a set of tools such as a code browser/editor, a compiler, search features, inspector (a generic user interface editor for an object). VisualWorks is a Smalltalk which means it has in it an IDE. There is a huge paradigm shift to make here. Conventional programming keeps code in files, where it is dead and inert. Smalltalk code is objects and you write bits of code that transform the objects in the system.
Well I can’t even get it installed. Seems as if theresno hope for me and computers. Thanks for your time.
what went wrong? are you on windows or what?
Linux
I know this is a Smalltalk sub but I'm inclined to recommend you try Go instead. One of the reasons being "A Tour of Go" which walks you through the main features of the language and even has you build some semi\-complex programs at the end. And the best thing is that it allows you to write and execute your code within your browser. And regardless of the Tour, I think Go would make a great first language. [https://tour.golang.org/welcome/1](https://tour.golang.org/welcome/1)
K
I recommend Squeak or its variant Pharo. Both are actively maintained, free, and available for nearly all platforms. There is a free tutorial book "Squeak by Example" (also Pharo, nearly identical) that will get you started. Smalltalk is quite different from most other languages and programming environments. There are probably not too many people nowadays who learn Smalltalk as one of their first languages, but it might be beneficial!
I had problems with Squeak installing, so ended up with Pharo. I’m not a complete beginner. I have some working knowledge of Python and have been trying to learn C. I don’t know if it’s a good idea or not but I’m thinking when I have an episode with C, I could switch over to Smalltalk for a bit till I cool off. The difference between the two seem so stark that I’m hoping I wont have any issues mixing the two up.
What? No. Don’t follow this advice. Smalltalk and Go aren’t even remotely related. Argh. I write Go in my day job, but if you want to learn some very unique, give Smalltalk a shot. It’s a lot of fun. 
Smalltalk has a unique history among programming languages in that the development environment was integrated from the beginning. Researchers at Palo Alto Research Center (PARC) in the 1970's weren't just trying to create a new language, they were trying to invent a new way for users to interact with computers. They basically invented the PC environment that we are all familiar with today \- multiple windows, mouse input, graphical icons, customized fonts, etc. It was a visit to PARC in 1979 that inspired Steve Jobs to create the a line of computers that would become the Macintosh in 1984. And, Bill Gates, seeing what Steve was doing began the Windows project circa 1985. I have been using Smalltalk since 1987, and it remains the most productive programming environment that I have ever used. And, I have used a lot of environments from mainframes to micros since I started my career in 1977. Both Squeak and Pharo are excellent to get started \- I wouldn't recommend VisualWorks or VisualAge unless you were doing a large database\-oriented project. If you are interested, I write a blog called "[Smalltalk Express](https://smalltalkexpress.quora.com/)" on Quora which details my development of a Smalltalk environment for creating Web applications. You should certainly try Smalltalk \- I will be glad to give you some advice if you run into problems.
Interesting, I ‘ll have a look at your blog. I’m in the middle of the tutorial that comes with Pharo and it’s definitely foreign to me. I consider that a good thing because it will allow me to think and learn in a different way.
Thanks, that makes sense.
Any reason why you prefer Iceberg over Monticello?
I was able to find english versions of the videos here: [http://rmod\-pharo\-mooc.lille.inria.fr/MOOC/Videos\-EN/](http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos-EN/)
I just know and understand git better.
This looks nice, do you have plans to opensource the Smalltalk implementation? Everyone I know who would be interested in this won't touch it unless it's opensource.
I am still working that out. There are several parts to the project. I would consider releasing an open source Smalltalk version if I knew that there were people willing to work to improve it. Code that I am willing to open source includes: -- most of the JavaScript GUI (Opal/Ruby wrapping Qooxdoo widgets) -- Ruby tools for managing Squeak image files -- a Smallltalk compiler written Opal/Ruby Note: Opal/Ruby compiles Ruby code to JavaScript. If someone were willing to convert parts of the SqueakJS VM to Typescript, I would be interested in providing the GUI and other tools. It would give a version of Squeak with an HTML5 user interface and that could run on the desktop, in browsers, and mobile devices. 
Know of any 3d model games written in small talk?
Yes, there are a few. https://www.slideshare.net/esug/woden-2-developing-a-modern-3d-graphics-engine-in-smalltalk https://www.reddit.com/r/programming/comments/4pnnrn/glimmerings_of_a_fully_functional_3d_ide_in/ 
Oh fantastic! I've always wanted to learn more about this
Just to complicate your life, GitHub is where everything is moving. The tool for interacting with it is called iceberg. 
Haha, great! Thanks for the tip.
where do smalltalkers hangout? like discord or freecodecamp
The Pharo group on Discord is here: http://discord.gg/Sj2rhxn 
So how are you doing? What's the weather like in you part of the world? Do you like object-oriented programming? 
"Pharo or Squeak?" is a great ice breaker.
Tried that at a party. Ended up in an Egyptian-themed S&amp;M orgy.
Has anyone brought interfaces?! 😉
Oh yes I see posts like that often
Cuis, actually
No. But it irritates me when I do searches for smalltalk and I find the majority of results are about talking socially. AFAIC, that should be "small talk".
Nice to hear that someone invests into the best programming language ever. Remember that there was a 16bit Windows Implementation of Smalltalk, called Smalltalk Express too. See for instance http://www.andreadrian.de/smalltalk/index.htm . Do they have anything in common?
So you made the method count that returns the value of count. That's called an accessor. count "return the value of the ivar count" ^count A mutator looks like this count: c "update the value of the ivar" count := c. Methods don't have identity in the editor - what does that mean? If you browse the count accessor, you can just modify it to look like the mutator and do 'accept' (or save - cmd-s) and the system will notice that you are trying to save a method named count: and since there isn't one, it will create it and you will have a new method. This confused me a lot at first. 
Thanks a lot! This is close to what I tried so I feel a bit relieved. Is it mandatory to use 'c' or can I use any letter I like?
You can use any letter you like. It is quite common to imply the type of the argument in the name. For instance: count: anInteger count := anInteger 
Very helpful, thanks again :)
No problem - have fun!
&gt; http://www.andreadrian.de/smalltalk/index.htm No, they are not related at all. I started using Digitalk Smalltalk/V in 1987 and I think that "Smalltalk Express" was related to a version of Digitalk. My "Smalltalk Express" is built with current Web technologies and is very different from the Smalltalks for PC's. 
Yes this old Smalltalk Express was basically Smalltalk/V with WindowBuilder and a free license. Back to your implementation: Looks nice in the browser! Which type of applications could be built with yours? 
Thanks. The GUI is built in JavaScript using the excellent Qooxdoo library. And the JavaScript for both the GUI and the compiler/interpreter is translated from Ruby using the Opal/Ruby compiler. So, the runtime can be deployed to browsers, desktops (using Electron/NodeJS) and mobile devices (with Qooxdoo mobile widgets). Currently, I am using the same Smalltalk/VM to support the "Python Village" (pythonvillage.com) learning environment that I am building for teaching programming to children. 
Forth rigid? That's a bizarre claim against the simplest language of them all - the simplicity demands that it be open ended to the same degree and it is. Is there any other language that has NO reserved words AND allows you to redefine even integers? Pharo is too far from the parent tree now for me; it's become a playground for its own developers and each new release breaks some assumption or adds some new unwanted detail to the language. Just as you know when something is right, so too you know when it's wrong.
Smalltalk Definetly uses files or else it would not work at all. The image is a binary dump of the memory , it allows to retain live state and execution. Sources is a text file containing the source code , cause the image only contains the bytecode , and changes file which contains in text format changes to the code. What you describe is part of learning how to code , learning the tools at hand is a must do for any language including Smalltalk. Smalltalk is probably the most powerful language but that also makes it very hard to learn because it’s so massive in term of features. But it’s well worth the effort and can teach probably the best way to code and do OOP. So yes expect to learn a lot. 
Nope. I’m looking for places to talk to people when lonely and this was the one small talk reddit that actually has subscribers. What the heck is this place?
Be sure to check out the Pharo community Discord chat. It's a great place to get help when you're stuck. You can get an invite at the link [here](http://pharo.org/community).
Sweet, Self really needs some approachable material. It’s such a cool system, looking forward to seeing more of these. 
Eh, Self really needs the libraries to take off. Interestingly enough, the engineer in the startup I belong to is a real Self fan, but there s a vastly larger userbase and available library for Smalltalk than for Self (and Smalltalk's is incredibly tiny), so our hardware system is called SiliconSqueak, not SiliconSelf. Of course, being a Self fan he made sure that the same hardware can run the Self VM as well as the OpenSmalltalk VM that Squeak and Pharo use (actually in can run an arbitrary number of VMs, but that's a topic for another thread).
I’ve heard of the hardware, didn’t know it runs Self too! You’re right about libraries, what would be the no1 priority there in your opinion?
Well, the original goal was to make it a drop-in replacement for the OneLaptopPerCHild program, so Etoys and Scratch were important. Lots of other stuff, also. 
What is the status of SiliconSqueak? I have not seen any updates posted online in a few years. Also, I see from activity online at Github (and from asking people) that the Pharo/SqueakNOS work is kicking up again, this time as [CogNOS](https://github.com/nopsys/CogNOS). Are these related to your project in any way?
&gt;What is the status of SiliconSqueak? I have not seen any updates posted online in a few years. It's constantly evolving. CogNOS is of interest to us, but not quite the same thing.
I should add that the SiSq model allows up to 10^9 processors to work in parallel. CogNOS has many useful ideas, but isn't designed specifically for parallel work. The most interesting work we're doing is to easily and transparently (at least to the application programmer) support those ludicrous numbers of processors. Ideally, that will be useable with many/most libraries at some level, preferably with as little rewriting as possible, so that existing squeak libraries can be dropped in and "just work" in parallel even when distributed over some arbitrarily huge number processors. The "pure" OOPness of Smalltalk allows that as a standalone object can be seen as an application running on its own processor and at the other end, each processor or collections of processors (including black-box specialized units for dedicated work like floating point) can be dealt with as "just another object that accepts messages." Ideally, the physical location of processors should only matter in terms of latency, not the programming model, at least on the application level.
This is precisely the kind of thing that I daydream about a lot these days. On the one hand, I really desire a personal computer that is entirely a Smalltalk like environment (hence my attraction to something like CogNOS). But it only goes so far unless there is an entire hardware/software ecosystem that treats pure objects with the seriousness and pervasiveness they deserve. I'd be interested in any more up to date writing/literature you have on the project if available.
https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C3&amp;q=siliconsqueak&amp;btnG= And the phd thesis about SiliconSqueak (pay no attention to the security error message): https://metamorphresearch.org/images/siliconsqueakv4.pdf
Well, the question I was pondering was whether the behaviour is wise, not whether it works as expected and I thought that is wider than GST. Certainly in GST a subclass: message does not result in initialized being called on the resulting class. The example in DLD.st is just manually sending the message while loading the file. The question of initializing new instances clearly must have come up in the early days; does anyone know why automatic sending of the message was not added then? What's the philosophical reason (if any)?
**Note:** The slides are in English, but the talk is in Danish. Click through to get to the video, then register to download the slides in PDF. Toit is Lars Bak and Kasper Lund's brand new programming language and software platform for small IoT devices. There's very little else I can find about it online; it was publicly unveiled in [this session](https://di.ku.dk/english/event-calendar-2018/dsfd-talk-lars-bak/) (can't find an online recording). Other links I've found: * [toit like a tiger](https://www.toitware.com/) (check out that font!) * news article: [original danish](https://www.version2.dk/artikel/aarhus-eksperter-chromes-javascript-motor-skaber-iot-sprog-virtuel-maskine-1085544), [translated to english](https://translate.google.com/translate?sl=auto&amp;tl=en&amp;js=y&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;u=https%3A%2F%2Fwww.version2.dk%2Fartikel%2Faarhus-eksperter-chromes-javascript-motor-skaber-iot-sprog-virtuel-maskine-1085544&amp;edit-text=&amp;act=url) * [github organization](https://github.com/toitware), no repos or public accounts * [twitter account](https://twitter.com/toitware), no tweets Toit's features: * object-oriented * indentation-based syntax * looks a bit like self/smalltalk (not surprising) * virtual machine * garbage-collected * project started in February 2018 Example, seen in the news article and in the slides: class TreeNode: left := null right := null TreeNode TreeNode left right size result := 1 if left: result += left.size if right: result += right.size ^result build_tree depth if depth == 0: ^TreeNode ^TreeNode build_tree depth - 1 build_tree depth - 1 main tree := build_tree 5 assert tree.size == 63 `TreeNode` and `TreeNode left right` appear to be constructors.
Don't ask for advice here, we threat women like objects :D
This is a subreddit for the programming language Smalltalk. Try /r/casualconversation
Have I been in a situation like that? Absolutely, happens to lots of people. Don’t let that be the reason you don’t go for it and ask her out though.
We could do with a bot that detects a % computing related language and redirects accordingly
We could just filter out any posts that mention "girl" lol
*Classy* objects, though. (Self-centered minority excluded.)
Are you suggesting a smalltalk-detecting Smalltalk program?
No, because that would be ridiculous (and ungrammatical).
[removed]
It's fine from where I am.
Working fine for me too.
That sounds like a great project to me
Just making sure he'll find this if he looks for his profile page.
What are you going on about? This sub is about the programming language smalltalk.
This sub is not about small talk. It is "A reddit for smalltalk-related discussion, including Squeak, Seaside, GNU smalltalk, and other topics".
Aren't you the little conversation killer. ;-)
"The class of Class is Class class which is a MetaClass." how not to get a date using Smalltalk 
Don't give up. If you want to start with Squeak (one of many good choices in the Smalltalk world) go here: [https://squeak.org/community/](https://squeak.org/community/) and click on the link for 'Squeak Mailing Lists'. There is a sub-category called 'Squeak - Beginners' where you can ask any question - ask about your problem getting it installed and someone will help you out for sure. There is an All-in-One download for Squeak that works on Win/Mac/Linux. Unzip the downloaded file (Windows and Mac will do this automatically for you if you double-click on the downloaded .zip file) and then click the appropriate file to start Squeak (Squeak.exe on Windows for example). Again, if you're not sure which file to click to start Squeak, ask on the mailing list. Don't be shy, everyone starts out as a new user. The Squeak wiki is another good source of information. You can find a link to it from the main Squeak site ([www.squeak.org](https://www.squeak.org)) . It might look old, but a lot of people contribute to it on a regular basis, even to this day. It's actually a goldmine of Smalltalk information. Just start browsing through it and you'll certainly find information on how to get started. Try this tutorial as well: [http://squeak.preeminent.org/tut2007/html/](http://squeak.preeminent.org/tut2007/html/). It uses an older version of Squeak (3.9) but you can still learn a lot from it. There are many freely available Smalltalk books on the Internet as well (one advantage of Smalltalk being around for such a long time). See the Documentation section of the main Squeak site for a link to a bunch of these books to get you started. As others have mentioned, Squeak by Example or the newer Pharo by Example are free to download and both will guide you on installing Squeak and Pharo respectively. [https://github.com/Cuis-Smalltalk/Cuis-Smalltalk-Dev](https://github.com/Cuis-Smalltalk/Cuis-Smalltalk-Dev) is the page for Cuis Smalltalk, which is a stripped down version of Squeak. There is also a link on the page for how to install it. Starting with either Squeak, Pharo, or Cuis is a good choice in my opinion. Once you get one of them running, look for the 'Terse Guide' - they all have one in the main menu, and start reading it. Good Luck! &amp;#x200B;
Have you checked if that code can be adapted to `RBScanner` and `RBParser` ?
+/u/User_Simulator Rickyfalcon
Going into the playoffs was before I moved away from the OP for whatever reason so this week has been a life changing week, digestion wise, and I'm still feeling it. ~ steelsoldier77 ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
+/u/User_Simulator hadoc27 
They will have to stop soon. ~ hadoc27 ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
+/u/User_Simulator hadoc27 
If F1 has to have to stop soon. ~ hadoc27 ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
Before the drivers give autographs and photos etc.. that is said about them. ~ hadoc27 ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
+/u/User_Simulator hadoc27 
Finnish Christmas i think I never said Clarkson is not a road That Renault in the future. ~ hadoc27 ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
Don't think so. The code is just a couple of methods that modify the Scanner and the Parser classes. After I file them in, when I try to use the ':&gt;' pipe message, the compiler prints out 'End of statement list encountered -&gt;' Not a clue on how to fix that.
Seems like either the change is not used (wrong compiler ?) or it just does not work. I don't remember in which release the old compiler was replaced by Opal… Either way I'd try to first understand how the code works and then check how to make the same feature in Pharo. In a Pharo 7 image I have running neither `Scanner` nor `Parser` are there anymore, so I doubt the code can be meaningfully loaded without rewriting it.
Is Roassal Pharo-only or does it work on straight Smalltalks too?
OK. I didn't know that. Thanks.
I think you posted in the wrong /r xD
+/u/User_Simulator wean_irdeh
DragonflyBSD has lightweight kernel thread, application checkpoint, and a kernel which can be loaded by a bootloader, I wonder this one BTRFS project right now. ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
I think the kernel can be loaded by a bootloader, I wonder this one BTRFS project right now. ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
Thank you for the direction! ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
+/u/User_Simulator wean_irdeh
I don't want that happen again It turns out I have to pay the patent royalty nevertheless. ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
Oh my I hope that doesn't happen to me
I'm not sure what you mean with respect to *self*. You definitely can reference it from within a block, and assigning to it wouldn't make any sense - it is the system's way of telling you what object received the message being processed, that should not be something you could change. Perhaps you could give concrete examples of what you have tried with respect to this? There is no shorthand for += or anything like that that I know of. However, if you give an example of the larger context you would like to use such a thing in, we might find that there is an alternative way of expressing what you want without such a need. I'm thinking here of say the enumeration methods inherited from Collection, for instance.
You can add new symbols to the parser methods, though I've never done it.
My ST career is some decades ago. As far as I remember I would look for a method in the Number class and if that does not exist I would add one. 
In Pharo, one could use `Dictionary&gt;&gt;associationAt:`: ```smalltalk |assoc| assoc := test associationAt: #this. assoc value: assoc value + 1. ``` This avoids going twice through the lookup cost, which might make a nice difference in execution time, but I'll admit the code is not much nicer to read. As suggested by EdwardCoffin, maybe you actually want a Bag; alternatively, I would ponder whether this integer you're incrementing is actually a part of a more complex object. Your code would then be a tiny example of micro-managing a dumb representation instead of having an object and telling it what's happened that it has to react to; the response to that is of course to introduce that object proper, so that you can write `(test at: #this) countOneMore` (or increment or tally or whatever verb reveals what you're actually counting).
Numbers are immutable, so this won’t work.
What I am trying to do is to assign to the referenced Dictionary item *without* having to reference it all over again on the **put:** message. Sometimes this situation has led me to some grossly convoluted code that I'm not very proud off. /r/programminghorror... 
Should I use Singletons for these kind of self-referenced assignment, instead of stark naked numbers and their immutable disposition? How would the overhead look like, if so? 
Even `(test at: #this) countOneMore` is probably still operating at a too low a level of abstraction. For example if you want to increase a tally on certain objects it would be much more idiomatic to create a `Tally` class (which might encapsulate a dictionary) which has a `addOneFor: #anObject` message, which under the covers does the dictionary gymnastics. Then the complicated `+1` gymnastics reduce to: ``` tally := Tally new. tally addOneFor: #this. ``` 
I don't see how a singleton would fit in this picture or help at all here… can you explain your thinking?
Sorry (can you tell that I haven't read any Gang of Four material, yet?), I meant to create a Box class: a container for numbers with a set of methods that delegate to its instance variable. That way, I can access it directly by referencing its key on the Dictionary, whereas a naked number must be referenced again in order to be accessed. 
A Singleton is basically a global variable, therefore the eyebrow-raising ;-) But otherwise yes, your box thing is what I was hinting at with `countOneMore`
I believe that Pharo writers stopped caring about the Smalltalk Everywhere thing using Slang some time ago, but I may be wrong. http://wiki.squeak.org/squeak/slang
I'm not sure i fully understand what you mean by this. Is it a good thing, or a bad thing for my current need ?
WEll, I was responding to your question about slang, rather than your question about C. Squeak has some ability to interact with foreign libraries. Pharo has taken that several steps further. This should give you a feel for what they can do (or want to do): https://files.pharo.org/books-pdfs/booklet-uFFI/UFFIDRAFT.pdf The webpage is a year old. The pdf file is 3 years old. I believe it has been superceded by something else but I haven't found it yet. Looking...
I must be missing the point of the other conversations here, but can't you just implement a method in Dictionary like at:incrementBy: and then the code can be test at: #this incrementBy: 1 It's very easy to add your own methods to any class in smalltalk
Okay, i managed to make the clock call example work, finally. 
Great. There are more complicated things that you can do. For example, at one point I was talking to the author about creating a c library that would render a mandelbrot set into a region furnished by Smalltalk. Basically the pointer to the base of a Bitmap object, which could be locked down in the RAM of the computer hosting the VM so that the library would render asynchronously into the Bitmap. You could then use Smalltalk to adjust the parameters of the renderer and it would draw as fast as possible without any interference from the VM. It wouldn't be in-synch with the VM-based graphics but it would be as fast as any C application with respect to drawing. Similar strategies could be used for the WebKit libraries to make a Smalltalk-based webbrowser.
Is there anyplace that i can look, to get an idea of what the VM has, as far as built in are concerned ? Are there some cpu friendly stuff that i should be aware of, if i want to smalltalk-prototype the mandlebrot renderer, before externalizing it to some shared library latter, but still want it to run as fast as possible ? 
well, you can write a mandelbrot thing completely in Squeak or in Slang, though I still haven't tracked down examples of Slang. For Pharao-specific stuff, you'll need to ask on the Pharo discussion groups. I used to be far more active in Squeak and even did [a popular introduction](https://www.youtube.com/playlist?list=PL6601A198DF14788D) (which the Pharo people never mention in [favor of their own Pharo-specific, computer sciencey intros instead](http://mooc.pharo.org))
The engineer at the startup working on SiliconSqueak (a processor that uses Smalltalk bytecode as the machine code) suggested this article: https://marianopeck.wordpress.com/2011/07/06/named-primitives/
Both links seem to be dead?
This project is on hold for now. I am working on a similar project for Python. https://vistapython.com 
thats pretty sad 
Well, this IS a slow sub, but the topic is for the computer language not "small talk." Do you have a Smalltalk related question or are you just bored?
Ummmmmm.....
Thank you for the help though.. ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
I think the kernel or the ARM chips? ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
+/u/User_Simulator wean_irdeh
For paranoid users: PCIe passthrough of USB hub to Tails VM running Chrome might be arise when writing program in assembly? ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
I think the kernel or the ARM chips? ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
Doing well, thanks. Ample coffee has kept my shadow civil 😄
I think the kernel or the ARM chips? ~ wean\_irdeh ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
you reply: "i wanna die".
Wrong subreddit.
There is a discord channel for Pharo. Go to https://pharo.org/community to get the link. And if you’re wondering why pharo uses Discord and not Slack, it is simply because Discord is more adequate for open source project. 
Awesome, thanks! Looks like I’m getting a discord account
Saijanai is indeed wrong &amp;#x200B; Pharo and Squeak share the same VM. Slang is a tool used by the VM , the problem is that as a tool is made specifically to accommodate the needs and demands of the VM developers and is not for general usage. Alsos note here that the VM is not fully implemented in Slang because it still make heavy usage of C code for some performance critical parts. &amp;#x200B; According to one of those devs &amp;#x200B; " You have to know that the Slang to C generation is, in my opinion, the worst code of the whole VM packages. " You can find the answer to my question containing the above quote here [http://forum.world.st/Understanding-Slang-for-building-a-compiler-to-C-td4882523.html](http://forum.world.st/Understanding-Slang-for-building-a-compiler-to-C-td4882523.html) &amp;#x200B; In theory you could take this code and make your own C generator. Generating C code is relatively easy. Generating optimised C is less easy. Generating readable C is even less easy. &amp;#x200B; Additionally you can look at RPython , which is the equivelant of Slang for PyPy a JIT VM for Python. RPython is documented and more actively developed because its used not only to implement Python but also several other languages including Smalltalk. The devs of PyPy are very much inspired by smalltalk and python is a language suprisingly close to smalltalk , not as syntax but definetly at implementation level and features. &amp;#x200B; I am actually developing a language that will be largely inspired by Smalltalk and will compile in readable optimized C code. However in order to make this possible and easy I will have to bring the syntax and feature set much closer to C. It wont be OO like Smalltalk though cause I like to try some of my own crazy ideas so the similarities with Smalltalk will be mainly on syntax level and not implementation (no VM , no dynamic types, no GC etc). 
 Argument expected -&gt; Don't you want single quotes?
Both Squeak and Pharo have lots of ways of accessing foreign libraries and acting as a scripting system... Shameless plug time... While I don't go into any of the above, you might want to watch my [now-ancient — I've been sick] introduction to Squeak videos: [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D) You can skip the first two if you already know how to install squeak (about 3 minutes saved, there).
Thanks, these videos look like they will be very helpful at some point. Do you have any links to documentation or tutorials? FWIW I'm not sure if I'll go with Squeak or Pharo at this point...
I think that Squeak, because it is less oriented towards modern programmers' expectations, is a bit less complicated and easier for a beginner to use. The PHaro people chose utility over simplicity and while there are a huge number of neat tools thrown in, they are thrown in by computer scientists rather than the original Smalltalk team (which created Squeak as the opensource successor to Smalltalk-80). Alan Kay was a professional jazz guitarist at one point and his origianl team all are multi-talented people with a strong feel for aesthetics and a desire to advance education. People who were attracted to using Squeak shared that quality. Pharo was founded by hardcore computer scientists who wanted a pragmatic tool to program with, and to hell with anything not necessary for that purpose. . Squeak is very crufty because it is older, but it is still more intuitive for a beginner, IMHO. 
Interesting, thanks for the background info. Do you have any pointers to something I could read that would help me dive into the task I've set out for myself? Thanks!
For FFI in squeak (which isn't as powerful as in Pharo, but that's a matter of tweaking libraries for compatability as they use the same VM under the hood): https://stackoverflow.com/questions/33197626/what-is-the-syntax-for-the-squeak-ffi-in-the-new-squeak-5-0 FOr FFI in Pharo: https://files.pharo.org/books-pdfs/booklet-uFFI/UFFIDRAFT.pdf For external scripting: http://wiki.squeak.org/squeak/1914 For anything beyond that, the discussio groups for squeak developers and pharo developers: http://forum.world.st/Squeak-f45487.html http://forum.world.st/Pharo-f1294836.html 
I think you may have misunderstood -- I'm looking to replace some of my daily emacs usage with a simple text editor written in smalltalk. This will give me an opportunity to write (and use!) smalltalk that I won't have otherwise. The bullet points are the components I am guessing I will need in order to implement an MVP I could actually start using :) 
Stuff for an old programming language called Smalltalk
Thanks! Cuis looks very cool. Happily hacking away in Pharo 7 now...
*fixed*
This is Reddit; argument is always expected
/me groans.
You could start by downloading pharo
anyone knows who are the admins for r/smalltalk ? it might help if there was a description mentioning programming languages…
Squeak is a much better intro than pharo. Pharo is meant for computer scientists and is NOT as easy to use out-of-the-box. Speaking as someone who made a series of intro videos on Smalltalk.
I didnt know there were options! this is awesome
I didnt know there were options! this is awesome, I'll scope out both just out of curiosity probably 
Check out [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D). . The details of interface vary between Squeak and Pharo, but the basics shown almost always apply to both.
Looks like the sole moderator has deleted their account.
We're orphans. DOes reddit have a process for handling this, I wonder... (it would have been nice if he/she had asked someone to take over before they did that).
this sub is for the programming language called "smalltalk." as for your example, why did you say something snide when they said they watched tv? part of making small talk work is being friendly, not a dick.
lol my bad I'm a noob on reddit. and you're right it was far to snide, maybe I dont have good small talk skills so I dont know how to respond idk
I just submitted a request to moderate /r/smalltalk from the site admins. I mod a few other subreddits, and can clean things up a bit. If I am granted moderator status, I will request another SmallTalker to co-moderate too.
Don’t think of it in terms of skills, think of it in terms of attitude. Even if you have bad skills, flub something and say something silly or mean, if your interlocutor can tell you’re interested and bear them good-will, they’re more likely to forgive you than if you can give impromptu 45-minute encomia in proper cadence but are mean-spirited at heart. Once you’ve done that, then you can work on your skills at Squeak or VW or what-have-you.
hahaha I didnt know those concepts had words. I'll totally try that. what do you read to learn words like that
Eh, just read widely in whatever interests you. It helps if you have wide interests.
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/redditrequest: --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)
Could you share why squeak is much better intro? Also what do you mean by "Pharo is meant for computer scientists"? Thanks!
You might want to check out /r/CasualConversation sir.
Is there something we can do to support your request? I don't know how Reddit manages this.
I made the request, bust since there is a current moderator (albeit he seems to be shadowbanned), the process can take a while. I've started playing around with some idea on the look of the new-reddit /r/SmallTalk here -&gt; https://www.reddit.com/r/Just_A_Test_SubReddit/ 
Sorry for the nit-pickiness, but it is *Smalltalk* with a lowercase T, not *SmallTalk*. The preview looks ok otherwise.
Ug, you're right! Force of habit...
Yes, I hope they give it to you! Let's design a cool header for the sub, too!
I'm not a graphic designer, but I was envisioning a sky with clouds background with the Smalltalk rainbow balloon, and the logos of the different distributions (Squeak, Pharo, etc..) lined up across the banner.
Well, implementations come and go, but the language is forever. How about an inspiring quote by one of the gurus, like Alan Kay? Or a praising slogan?
I'm open to ideas and suggestions.
Let me know when they grant you mod status. I'll do the design! 
Will do!
I support this :)
In case you haven’t sussed out why everyone is downvoting… this subreddit is dedicated to the programming language and environment known as Smalltalk and its various implementations.
Have you heard from the admins yet?
No, but the process can take some time. If there is no moderator for the subreddit, a bot automatically assigns the requester a moderator status. Unfortunately since there is still a mod, who appears to be shadow banned, it requires a manual intervention which is done "at the site admins leisure". At least /r/Smalltalk is not being bombarded with spam and junk, so it can run without a mod for a while. But I would like to clean it up, make it evident that it is a programming subreddit, and promote it more too.
I’ve reported Leila Lowdes spam a couple of times in the last couple of days. Good luck!
Those requests sit in a moderator queue until the moderator decides to do something. Hopefully something happens soon. These posts about making small talk are driving me nuts.
They're both pretty close to Smalltalk-80. In my opinion pharo is better - more visual polish, larger amount of developers/packages made for pharo, etc. However there are people who disagree so I guess it depends on your use case. If you weren't aware Dolphin Smalltalk is also open-source. It's windows specific but has greater interoperability with the windows environment. I think it blows the pants off of pharo/squeak in terms of just look and feel of the interface, not to mention building gui's and stuff is much easier. If anyone is interested in getting Dolphin you can get a release installer from the github pages, the main webpage has been down for some reason. https://github.com/dolphinsmalltalk/Dolphin/releases v7.0.57.2 is basically the 'stable' branch, and v7.1.3 has a new look and feel and other improvements but is more 'beta'.
Pharo is officially "not really Smalltalk", but there is no reason to care about that. Squeak contains many "remnants" of very old stuff that are no longer fully maintained. Pharo si more "leaner" and up to date in this regard.
Great! At least, we have gained one active moderator.
I didn't realize that [object-arts.com/](http://www.object-arts.com/) is down, I'll update the sidebar and menu links to point to the github location.
Eh, Squeak was meant to be teh official successor to Smalltalk-80, created by the original Smalltalk-80 team while they were working at Apple. Pharo broke away for many reasons, some valid on a technical level, and some based on personality, I think. Squeak has a lot of legacy libraries that clutter up the code (e.g. eToys adds hundreds of methods to Object, which computer scientists find offensive. Pharo was designed BY computer scientists with no real regard for thigs like ease-of-use, IMHO. THere are popup windows that cover teh work area you are interested in so you can't refer back to that area while performing operations on that area. A minor annoyance if you have a good memory, but for someone like me (on disability for cognitive issues like a 0.5 sec memory visual memory buffer), it is impossible to use... ...literally impossible to use. Not joking here. Impossible to use. . Ahem. . So, it's not merely a matter of taste for someone like me to avoid using Pharo. User interface design has consequences. THere are other issues. Some features were changed so radically that professional programmers have to spend days recovering those features when they make the transition from Squeak to Pharo: even though they want the new features, they can't live without the old ones, and so have to port them over themselves.
Agreed. I'm a long time Squeak advocate. I still prefer it over Pharo. I can't put my finger on it but Pharo feels less familiar as a Smalltalk than Squeak does to me. Glad to see them both active however. Also, Dolphin Smalltalk is neat -- I really liked the work they did early on with Lego Mindstorms. However, I'm a Mac fan and user so I'm not inclined much to use it.
i like the squeak debugger and system browser far far more than pharo. 
When did you last try Pharo? I've had pop-up problems with both Squeak and Pharo throughout the years, mostly caused by cascading debugger issues.
Haven't used it lately (nor squeak, actually — I've had an illness that put me on permanent disability for health and cognitive issues (imflamation-induced dementia for the win, hoorah)).
Allow me to suggest Cuis, which was started from Squeak, and is much smaller and simpler. Juan Vuletich worked very hard to simplify it and remove lots of clutter from Squeak. It's worth a look: www.cuis-smalltalk.org
I'm still hoping that CUis eventually becomes the basis of squeak.
Added.
Thanks, was about to do it myself.
As of Cuis 5.0-3584 (the latest as I'm posting this) it's up to a whopping 487 classes. We need to get on Juan about this... it's growing out of control ;-)
I hadn't heard of Cuis - this sounds absolutely brilliant. Thanks for bringing it to my attention!
 Here are the key highlights of this release: &amp;#x200B; * Pharo is now provided in 64-bit version in Linux and OSX and brings even better performance and stability. The 64-bit version is now recommended for Linux and Mac, and is provided as technical preview for Windows. * Pharo comes with a new version of the PharoLauncher (https://pharo.org/download): THE tool to manage your distributions (access to regular versions, jenkins builds, and older versions). * Pharo build has a fully new build process that supports its full bootstrap from sources. This will enable the production to specific (micro) images. * Iceberg, the git client for Pharo has been significantly improved, and is the default CMS. * Calypso, the angular stone of PharoThings, is the new system Pharo browser. It replaces Nautilus and brings better remote working and more advanced browsing capabilities. * IoT is now an important part of Pharo. Installing PharoThings (https://github.com/pharo-iot/PharoThings) provides an impressive amount of tools to develop applications in small devices. * The unified foreign function interface (UnifiedFFI) for interfacing with the outside world is significantly improved to work properly on Windows 64-bit.
I was thinking that v7 was supposed to get a gui update to Brick/Bloc to replace Morphic. Does anyone know the status of that? Is it still planned for a future Pharo release?
&gt; Pharo is now provided in 64-bit version in Linux and OSX and brings even better performance and stability. The 64-bit version is now recommended for Linux and Mac, and is provided as technical preview for Windows. Although i'm a Lisper at core, I want to say congrats to the Pharo team, and let's hope the 64-bit version is here as soon as possible. 
I really like that metaphor—Smalltalk as sculpting software. It’s so apt that one would think that I would have heard it elsewhere before.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/datascience] [Looking for ideas for using reflection\/introspection for statistical programming \[X-post r\/smalltalk\]](https://www.reddit.com/r/datascience/comments/ajt5yj/looking_for_ideas_for_using/) - [/r/programming] [Looking for ideas for using reflection\/introspection for statistical programming \[X-post r\/smalltalk\]](https://www.reddit.com/r/programming/comments/ajszg8/looking_for_ideas_for_using/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I think I heard similar statements long ago referring to lisp machines. 
It makes sense because I think Ingalls implemented Smalltalk-72 in Lisp and the method browser was lifted from… Interlisp? I want to say.
I know Alan Kay has been previously exposed to Lisp at SAIL. According to http://samizdat.co/shelf/documents/2004/08.02-historyOfSmalltalk/historyOfSmalltalk.pdf the first ST-72 was implemented in BASIC(!) as a realization of the one-pager meta-circular interpreter. Later on the VM was a combination of microcode and assembler on the Alto. The browsers he credits to Larry Tesler for ST-76, no clue if he invented them or copied. Given the timelines, it could be either way. His CV reads as if it was new to him. http://www.nomodes.com/Larry_Tesler_Consulting/1962-1980.html
Huh. I was sure I read a paper by Ingalls on the topic of implementing Smalltalk that mentioned Lisp. I must have been confused. Cheers
Statistical programming / analysis of what? Are you thinking about ways to analyze Smalltalk code, external data or something else entirely?
I mean general statistical programming. With whatever data. I am an epidemiologist, so medical data for example. It's just that I felt that that sort of code introspection could be put to good use to navigate my programs more easily and get insights in a clearer and faster manner.
They are all dialects of Smalltalk, so most of the syntax is identical and the core libraries (Kernel, Collections, SUnit, maybe ported libraries like Seaside…) are quite similar. Most importantly, the basic principles of the language are the same, and many differences you can overcome by reading docs or going through the code. There are [lots](http://mooc.pharo.org/) of [ressources](http://books.pharo.org/) on the Pharo side that you should find useful, including on the basics mentioned above, and some general OO programming and design advice sprinkled throughout. However, the biggest differences are in the environment and tooling. Both Pharo and Squeak take a much more integrated approach, all the tools are in the image, in the same vein as most other Smalltalks, whereas GNU Smalltalk takes an approach more similar to most languages where you can edit code in Vim but lose most of the I and E of IDE (disclaimer if it's not obvious, I'm a Pharoer ;-). I do like how GST can treat the image more like a snapshot or a deployment artifact, and I think they have gained some nicer GUI tools since I last checked.
Pharo and Squeak are great but if you are starting from scratch, in order not to get overwhelmed by those large environments, you may want to look at Cuis Smalltalk (see sidebar link). Exact same components but packaged in a more minimalist way. That way you can focus on the task at hand (learn Smalltalk) w/out getting overwhelmed by what is around
So if i learned Pharo in this case, would I be able to understand GNU Smalltalk? Are they that similar in syntax? (Sorry if this is a dumb question)
While you can learn the basic syntax and concepts using any dialect, I will differ from the other advice you're getting here. Squeak dialects (Squeak/Pharo/Cuis) have diverged quite a bit over the years but at least once you know one a lot of the knowledge is fairly transferable to another since they are all very closely related including essentially using the same VM. (yeah, Pharo's is a bit different but it's still built from largely the same sources and the core of the VM is the same) GST is very different from Squeak dialects since it's not even derived from the same code base so once you start getting into it a lot of knowledge won't transfer. If you want to 'learn the ropes' using one of the Squeak dialects using one of the many tutorials out there, you'll be fine as the core language is syntactically identical. Frankly, it shouldn't take more than an afternoon or two tops. But then I'd highly recommend switching to GST as soon as you can for your class. That way you won't start going down blind alleys doing things in one environment only to discover all the subtle, and not so subtle, differences in the other. As far as specific recommendations, depending on what you're looking for there's everything from the bite-sized [Smalltalk For You](https://www.youtube.com/watch?v=9Moyp5Lm9OA&amp;list=PL61A023880D3529DB) to entire [books](http://books.pharo.org/) put out by the Pharo developers and others. If I were in your position, I'd probably start with the [GST documentation](https://www.gnu.org/software/smalltalk/manual/html_node/Tutorial.html) and see how far that gets you.
Hi! You can start from here: [https://mooc.pharo.org](https://mooc.pharo.org) Also I recommend you to try Cuis Smalltalk, it's a fork from Squeak, like pharo, but with more stable and simple, [https://github.com/Cuis-Smalltalk/Cuis-Smalltalk-Dev](https://github.com/Cuis-Smalltalk/Cuis-Smalltalk-Dev)
You might find Ctalk useful. It generates C99/C11 code for GCC. It also as allows you to mix C and Ctalk statements within methods and functions. It's at sf.net/projects/Ctalk/. Enjoy!
should be noted I am not using latest VisualWorks, but rather Visualworks 7.4 (circa 2005), yeah I know I'm a "little" behind, but it's what I've got for work
Well, here's a few videos about playing with Croquet AKA Cobalt, a Squeak-based 3D virtual world: https://www.youtube.com/watch?v=JPRm8IWAIBo https://www.youtube.com/watch?v=eU9r1rf5EjE There are problems with Squeak and possibly other Smalltalks with respect to realtime processing due to the automated nature of garbage collection, but for some games, even 3D ones, this isn't really a big issue. 
You may want to have a look at Woden, a 3D graphic engine for Pharo: https://github.com/ronsaldo/woden
[This](https://medium.com/@richardeng/mobile-smalltalk-c6f0cc712909) popped up about a year ago, but I haven't heard anything since. The code isn't available, but maybe it'll give you some ideas on how to get started.
you dont listen, Im not using Pharo, I'm using visual works
But I’m definitely going to look into this. Thanks!
If you have an image, you should be able to find a few places on the Web to print some stickers for you. Example: [CafePress custom stickers](https://www.cafepress.com/make/custom-stickers)
Thanks for the tip! Sadly I have no prepped image. Creating a GOOD one would require an artist, so I was hoping someone else had already done the hard work. :-(
Er, um... Smalltalk is a computer programming language...
Richard Eng, a Smalltalk evangelist, uses lots of strong images in his articles. You can take from one from the articles, here is an index https://hackernoon.com/@richardeng 
Excellent pointer! Thank you!
Amazing - thanks so much for sharing. Have you seen what Kay is up to on Quora recently? https://www.quora.com/profile/Alan-Kay-11?ch=10&amp;share=7985ca8f&amp;srid=3IS 
See [proggit discussion](https://old.reddit.com/r/programming/comments/b29qav/dr_alan_kay_on_the_meaning_of_objectoriented/?st=jtep4wy0&amp;sh=1131aa07).
The free book "The Spec UI framework" [http://books.pharo.org/spec-tutorial/](http://books.pharo.org/spec-tutorial/) , might help.
Ctalk has a tutorial that you might find useful. It isn't smalltalk, but it should acquaint you with the language and class library principles. http://sf.net/projects/Ctalk 
Well, my tutorial series is also outdated, but most of it applies to both Squeak and Pharo: [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D) Squeak's feature set may not be as "evolved" as Pharo's, but in turn, the interface is less "de-volved" as well. None of the Pharo crew seem to put ease-of-use at the top of the priorities, while Squeak was created by the original Smalltalk-80 team while they were at Apple, and the twin-influences of XEROX-PARC + Apple's own obsession with ease-of-use during that time-frame, show.
Wow this looks like exactly what I'm looking for! Thank you so much!
Is there a single smalltalk thread in which you do not bash pharo? :)
How did I bash Pharo? There are tradeoffs in choosing which fork to go with. If there weren't, there would be zero people participating in the Squeak forums: they'd all using Pharo instead. In fact, there would have been no need for a fork in the first place as they people who split off would have simply convinced all Squeakers to go with their ideas and there would simply be a more advanced Squeak that retained the ability to appeal to everyone who has a reason to use Squeak rather than Pharo.
Wrong sub my friend.
I got it lol. thx!
I am not sure what you are trying exactly to do. First, I would suggest this is a question better placed in StackOverflow, on the tag #smalltalk. I will try to answer, but I am not sure. Note that #[ ] is the syntax for ByteArray, a particular class of Array where every element is an integer of 1-byte size (that is, between 0 and 255). So, #[122] is an array of size 1, with a 122 on its first position. You cannot write #[var] if that is what you have tried, because the #[] syntax is for literals only. You should do char := ByteArray new: 1. char at: 1 put: var. char utf8Decoded
That's exactly what I was looking for! thank you so much! You are right I should start using Stack Overflow for my questions, reddit has been my go to place for answering any questions I have about anything recently but from now on I'll ask my questions there, thanks for the help!
At least, there we can format the code in the answers :-)
Signed up!
this is a programming subreddit. i think you might be in the wrong place?
compiler or IDE?
Are you familiar with f-script?
The compiler first. After that, you can begin porting the Smalltalk classes and tools you like most and build your ideal IDE on the desktop, tablets, etc. Yes, I remember f-script.
Have you seen the Squeak-JS project? Seems to me that if you do what Squeak-JS does, you need not port anything.
I have, but Squeak-JS is a full Squeak VM. That means it compiles Smalltalk source code to a virtual machine bytecode, then interprets that. Swift++ compiles to machine code. In addition, Squeak-JS requires a JavaScript implementation to run. Either within a browser or nodejs. That makes the compiled Smalltalk code twice removed from bare metal, while Swift++ compiles to native machine code. (Actually, to LLVM IR, which is then compiled to machine code or whatever the backend targets, but the user doesn't normally see that.)
Well, the eventual goal is to get the Squeak VM compiled to webasm, which is sort what you describe with Swift++ and LLVM IR.
Yes. In fact, the WebAssembly working group is creating a WebAssembly backend to LLVM, which will then let us add a WebAssembly target to Swift++
Well, the point is that if you simply did what Squeak-JS does, then there would be no porting of libraries, as all standard squeak plugins and primitives are written in slang, which directly translates to C, so all of Squeak could directly be put into Swift if you wanted. No porting of libraries required. I'm assuming of course that a translator class could be modified to work with the target platform. I'm just starting to learn how to do that (trying to port unum to squeak as a plugin so that multi-precision unum will be a first class number system in the Squeak environment).
Well, the point is that if you simply did what Squeak-JS does, then there would be no porting of libraries, as all standard squeak plugins and primitives are written in slang, which directly translates to C, so all of Squeak could directly be put into Swift if you wanted. No porting of libraries required. I'm assuming of course that a translator class could be modified to work with the target platform. I'm just starting to learn how to do that (trying to port unum to squeak as a plugin so that multi-precision unum will be a first class number system in the Squeak environment).
Well, my point is simply that if you port the squeak VM then you don't need to port any library. You may need to create a code translator for slang so it will work as you want, but no libraries will need to be ported. Various primitives and plugins would need to be, but that's another issue.
Well, my point is simply that if you port the squeak VM then you don't need to port any library. You may need to create a code translator for slang so it will work as you want, but no libraries will need to be ported. Various primitives and plugins would need to be, but that's another issue.
Well, my point is simply that if you port the squeak VM then you don't need to port any library. You may need to create a code translator for slang so it will work as you want, but no libraries will need to be ported. Various primitives and plugins would need to be, but that's another issue.
GNU Smalltalk looks abandoned, or?
Kind of, but who can blame them? They've been steadily working on it for the last decades and yet nobody uses it. Such a shame 😔
&gt; The whole ideal of what we're trying to do here is... comes back to this question I asked in the beginning, and that is, what would a computer be if it were like a pencil. Can it be used by children? Well, yes, it can. Can it be used by adults? Yes, it can. How *low* can we go to childhood? Can we go into... much much lower than grade school? Here's an answer to that question. It's a tape I got from the woman who's my accountant. This is her daughter, aged 22 months, two months shy of her second birthday, and she's never lived in a world that wasn't densely populated by Macintoshes, because both her mother and father worked at home, and both her mother and father had their own Mac. And in fact when I found out that the little girl was interested in computers, I gave her an Apple II, which she rejected. She wanted a Macintosh just like her folks, and she literally learned to use it by sitting on her mother's lap while her mother was working. So for this child, the Macintosh is not a piece of technology, but simply more material in the environment to [manipulate](https://youtu.be/p2LZLYcu_JY?t=4891).
Yes, those are your best options. Discord server is very active and the community is very supportive. Probably the best place to ask questions. I would give this book a look too: [http://files.pharo.org/books-pdfs/learning-oop/2018-04-01-LearningOOP.pdf](http://files.pharo.org/books-pdfs/learning-oop/2018-04-01-LearningOOP.pdf)
That book is 1.3 years younger, so more updated, which is very good. Also has the same author Stephane Ducasse that wrote also "Pharo by example updated", the book I'm reading, with other authors. How would you compare the 2 books? Is one more basic? I don't know which one to read now. I'll ask my next questions on discord. This task is much more daunting. I expected Smalltalk to be learned in days, it seems more like many weeks now. Even if I study 6 hours per day. It will still take a long time. Thank you very much
there is a mooc going on right now that just started.
The Squeak newbies group is good. I assume there is a pharo equivalent but there might not be since pharo is kinda geared to professionals. Just checked. Subscribe to the various Smalltalk discussion groups here: http://forum.world.st I'd advise to subscribe to: Squeak Beginner, Squeak Dev, Pharo By Example, Pharo Smalltalk User. Might I suggest you review my [Squeak from the very start](https://www.youtube.com/playlist?list=PL6601A198DF14788D) video series? There are a few minor differences in the interface, but as far as I know, etoys stuff aside, you can do everything I show with almost no modification, in squeak AND pharo.
Review my videos. People sometimes call it a pair-tutorial series (as in pair programming for total beginners).
I don't know whether I should be impressed or frightened by how many subreddits you've asked this question. Is there something that you're planning to accomplish?
Yes trying to make a list of resources for all the languages.
Try the books from http://books.pharo.org, in particular _Learning OOP_ where many of the chapters are written around little programming projects.
here’s the mooc. http://mooc.pharo.org
&gt; pharo is kinda geared to professionals This scares me. Does this mean if I use squeak, as a not just Smalltalk noob, noob programmer in general, Pharo is harder than squeak? Because then I'll jump into Squeak. This book Pharo by example at least starts following closely, only replacing names of things, the book squeak by example. I could watch your video series also. I'll probably will however only if I do squeak, It's already hard.
Thank you.
Eh, Squeak was created from Smalltalk-80 by the original team that created Smalltalk-80. THey updated it, but they were working at Apple, where teh obsession at that time at least was "ease of use." Pharo is done by computer scientists who want to research tool that isn't crufty and carefully designed from scratch to be "simple under the hood." They succeeded in extending the technical abilities to make it more useful to professionals, but arguably lost sight of the human element while they were at it, at least in my opinion.
First I'd check if you're running Pharo Launcher, or running VM &amp; image "by hand". Maybe you'll have better luck with [the zeroconf scripts](https://get.pharo.org) with cygwin or whatever the thing is to run Bash on windows is nowadays; e.g. try `curl https://get.pharo.org/50+vm | bash` But IMHO you'd probably be better off following the book with Pharo 7 and either ignoring or working out the discrepancies. Docs will never be perfect in any programming environment, but in Pharo you do have the possibility of exploring all the code. Most of the general principles in the book should still apply, and you'll progress further by exploring and figuring outdated docs or unknown code by yourself. There is always the [Discord channel](http://pharo.org/community) if you need help on a particular detail.
I agree, the original poster should use the latest version if Pharo. Almost all of the material in the book should be compatible, as far as the programming examples go. UI might be different.
I'm 100% running Pharo launcher. I tried to say this in my post like this: &gt;Pharo Launcher downloaded yesterday from [https://pharo.org/download](https://pharo.org/download) the big blue link captioned "Windows 10" I already subscribed to the Discord channel. I had the exact same problem in Ubuntu, I say this if it helps. I'm just going to use pharo 6 and pharo 7 for now, specially 7, and if things go impossible i'll come back
I'm also a first time user. Pharo 5.0 wouldn't not work for me either on Windows 7 and for the same reason. I just copied `pharo.version` from `C:\Users\bri\Documents\Pharo\images\Pharo 7.0\` to `C:\Users\bri\Documents\Pharo\images\Pharo 5.0\` and edited it to contain `50`. It then launched ok. I hope that's clear :)
I'm a noob so I'll make you these basic questions: &gt;wouldn't not work Did you mean Wouldn't work? There is a double negative there. I'm doing your "hack". You must be a pretty good hacker to realize this strategy. I never mess with things like this, to me I have way more danger to break the system than fix it. I'll do your hack anyway because it can't break anything that's working, it only messes the 5.0 which doesn't work anyway, slightly and very easy to back up if it goes bad
EDIT: IT WORKS!!! 100%! EXACTLY HOW YOU FIXED IT! NOTHING to add. It just freaking works. Thank you!
&gt;wouldn't ~~not~~ work Sorry about that
As a past Smalltalk developer, I have for years lamented that Smalltalk did not remain on the minds of most programmers and the fact that when we hit the fork in the road, the powers-that-be opted for Java instead of self. It's great to see this post and learn about what could have been and maybe what we're finally ready for now.
Does this have a project web page? Source code? A quick search brings mostly dead or bullsh*t links… apparently there's a VistaSmalltalk that was a .NET implementation?
There was a .Net implementation of VistaSmalltalk in 2004. This version is based on Java. Here is the blog post: https://smalltalkexpress.quora.com/Vista-Smalltalk-on-the-JVM-with-JavaFx-GUI The website is under construction here: https://vistasmalltalk.com/ There will be preview releases for evaluation starting July 15 or before. The project is not open-source, so there is no source code available at this time.
ASCII values are bytes. UTF8 values are multi-byte.
Try using Pharo?
If you mean "try the image with the Pharo VM" - well, I admit I hadn't, but I'd be surprised if that worked. (OK, just tried it, and it doesn't) If you mean "try using Pharo instead of Smalltalk-80", don't worry, I love Pharo :) I'm just interested in Smalltalk-80 for historical reasons.
I think Dan Ingals demoed a copy of ST-80 running in Squeak. &amp;#x200B; Might be able to track it down on squeak.org..
The package for squeak/pharo that emulates smalltalk 80 is called Hobbes
Squeak prior to 3.10 was pretty much the original Smalltalk-80 VM, or such is my understanding.
Very interesting, I'll add Vista Smalltalk to the Smalltalk implementations list here.
Thanks.