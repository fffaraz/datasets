this is awesome. i wish it was getting more love!
Yeah, I'm a little bit nervous about that, I just thought it would be a good idea to have a few methods from ActiveSupport and others.
Was it not possible to define dig in such a way that it works with any container type that also defines dig?
Well, I guess you're right, if the container type implements reduce it's possible.
Recursion is pretty cool ... https://carc.in/#/r/sxz
Thanks for the suggestion, sometimes you want to release something pretty bad and don't think about other possibilities. Now it depends on #[]? instead. https://github.com/werner/crystal_on_steroids/blob/master/src/crystal_on_steroids/dig.cr#L16
I think I'd rename this "permissive" dig method to `#dig?` and only define `#dig` on container types (according to the emerging convention for ?-methods). The reason is that permissive-dig defeats the type system, but crystal users likely want to use types to catch problems at compile time. A symptom of this is that the return type for permissive-dig is complicated: https://carc.in/#/r/szv (Edit: fixed the args: https://carc.in/#/r/t00) An upside to permissive-dig is that it might be possible to define it in such a way that it works with arbitrary enumerables instead of just tuples.
Updated with ZigZag and VLQ, next up delta encodig
Thank you! You can consider these as tries what we can do with Crystal. Probably noone will need these kind of syntax in Crystal. (I built but I won't use I think :D) Thanks for your comment! BTW, I changed the name from ufcs to lambda to make it more "hipster", and I put a warning on top of README it's not recommended. :) https://github.com/f/lambda.cr/blob/master/README.md
 crystal init lib venus-fluorite This made me chuckle a bit.
Almost, I'm waiting on this: https://github.com/Homebrew/homebrew/pull/50304 Maybe using the official homebrew instead of a tap wasn't a good idea...
That's great news! Proves that the interest is surely going up and more big compaines are willing to use Crystal as soon as it is possible :)
I'm guessing the anonymous donations are from Matz? Wondering why he doesn't become a contributor to the language design, that would sure kick things up a bit. 
Pretty cool. Playing with it now.
he's probably already stretched working on mruby and streem 
It looks like you're missing the *event* library (libevent, I think.) You will need to install that library to get rid of the error. How you'd go about doing that is dependent on your OS. Hopefully that gets you pointed in the right direction.
Matz is a super cool guy. Great to hear he's supporting Crystal in some way or another.
&gt; I'm guessing the anonymous donations are from Matz? No, his name is explicitly there a bit past halfway down the page: http://s5.postimg.org/qpu8v64uf/Screenshot_20160329_151439.png So far, he's donated $500.
If their claims are true :)
And if we do what kind of code would it generate?
Thank you, this was probably the issue that created the most usages of not_nil! for me. 
So instead of `s = ""; s += "..."` you can do `io = MemoryIO.new; s &lt;&lt; "..."; s = io.to_s` and then `io.clear` if you need to clear the buffer (though I think in this case it doesn't matter much before subtitles lines are just a few).
# **우리동네 예체능-151회-다시보기 E151 160412 151화 torrent 720p 우리동네 예체능-151회-다시보기 E151 160412 151화 다시보기** 1080p MKV 다시보기 우리동네 예체능 151회 다시보기 E151 160412 151화 토렌.트 토렌 Torrent Comprehensive 720p HD 파일명 | 파일받기 | :--------:|:--------:| **[우리동네 예체능 151회 다시보기 E151 160412 151화](http://15.ylla.hya.bin.nulwew.com/18/5cy)** | **[파일받기 (클릭)](http://15.ylla.hya.bin.nulwew.com/18/5cy)** | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 다시보기 우리동네 예체능 151회 다시보기 E151 160412 151화 토렌.트 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 우리동네 예체능 151회 다시보기 E151 160412 151화 토렌.트 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 우리동네 예체능 151회 다시보기 E151 160412 151화 토렌.트 토렌 토렌.트
# **피리부는 사나이 12화 다시보기 E12 160412 12회 다시보기** 1080p MKV 다시보기 피리부는 사나이 12화 다시보기 E12 160412 12회 토렌.트 토렌 Torrent Comprehensive 720p HD 파일명 | 파일받기 | :--------:|:--------:| **[피리부는 사나이 12화 다시보기 E12 160412 12회](http://15.ylla.hya.bin.nulwew.com/18/5d2)** | **[파일받기 (클릭)](http://15.ylla.hya.bin.nulwew.com/18/5d2)** | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 다시보기 피리부는 사나이 12화 다시보기 E12 160412 12회 토렌.트 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 피리부는 사나이 12화 다시보기 E12 160412 12회 토렌.트 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 피리부는 사나이 12화 다시보기 E12 160412 12회 토렌.트 토렌 토렌.트
# **수요미식회 61화 다시보기 E61 160413 61회 TORRENT 다시보기** 1080p MKV 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 Torrent Comprehensive 720p HD 파일명 | 파일받기 | :--------:|:--------:| **[수요미식회 61화 다시보기 E61 160413 61회](http://15.ylla.hya.bin.nulwew.com/18/5d8)** | **[파일받기 (클릭)](http://15.ylla.hya.bin.nulwew.com/18/5d8)** | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 토렌.트
# **수요미식회 61화 다시보기 E61 160413 61회 다시보기 고화질** 1080p MKV 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 Torrent Comprehensive 720p HD 파일명 | 파일받기 | :--------:|:--------:| **[수요미식회 61화 다시보기 E61 160413 61회](http://15.ylla.hya.bin.nulwew.com/18/5d8)** | **[파일받기 (클릭)](http://15.ylla.hya.bin.nulwew.com/18/5d8)** | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 수요미식회 61화 다시보기 E61 160413 61회 토렌.트 토렌 토렌.트
# **헌집줄게 새집다오-18회-다시보기 160414 18화 다시보기** 1080p MKV 다시보기 헌집줄게 새집다오 18회 다시보기 160414 18화 토렌.트 토렌 Torrent Comprehensive 720p HD 파일명 | 파일받기 | :--------:|:--------:| **[헌집줄게 새집다오 18회 다시보기 160414 18화](http://145.yl3la.hha.in.lidaru.com/19/5dh)** | **[파일받기 (클릭)](http://145.yl3la.hha.in.lidaru.com/19/5dh)** | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 다시보기 헌집줄게 새집다오 18회 다시보기 160414 18화 토렌.트 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 헌집줄게 새집다오 18회 다시보기 160414 18화 토렌.트 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 헌집줄게 새집다오 18회 다시보기 160414 18화 토렌.트 토렌 토렌.트
# **(한글자막) 빅뱅이론 시즌9 24화 다시보기 즐감 torrent 파일 다시보기** 1080p MKV 다시보기 (한글자막) 빅뱅이론 시즌9 24화 다시보기 즐감 토렌.트 토렌 Torrent Comprehensive 720p HD 파일명 | 파일받기 | :--------:|:--------:| **[(한글자막) 빅뱅이론 시즌9 24화 다시보기 즐감](http://145.yl3la.hha.in.lidaru.com/19/5e4)** | **[파일받기 (클릭)](http://145.yl3la.hha.in.lidaru.com/19/5e4)** | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 다시보기 (한글자막) 빅뱅이론 시즌9 24화 다시보기 즐감 토렌.트 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 (한글자막) 빅뱅이론 시즌9 24화 다시보기 즐감 토렌.트 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 (한글자막) 빅뱅이론 시즌9 24화 다시보기 즐감 토렌.트 토렌 토렌.트
# **정글의법칙 in 통가 209화 다시보기 E209 160415 209회 다시보기** 1080p MKV 다시보기 정글의법칙 in 통가 209화 다시보기 E209 160415 209회 토렌.트 토렌 Torrent Comprehensive 720p HD 파일명 | 파일받기 | :--------:|:--------:| **[정글의법칙 in 통가 209화 다시보기 E209 160415 209회](http://145.yl3la.hha.in.lidaru.com/19/5f9)** | **[파일받기 (클릭)](http://145.yl3la.hha.in.lidaru.com/19/5f9)** | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 다시보기 정글의법칙 in 통가 209화 다시보기 E209 160415 209회 토렌.트 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 정글의법칙 in 통가 209화 다시보기 E209 160415 209회 토렌.트 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 정글의법칙 in 통가 209화 다시보기 E209 160415 209회 토렌.트 토렌 토렌.트
Hi, Right now Crystal is single-threaded, like nodejs. In the (hopefully near) future we plan to add multiple-thread support, though it's something really hard to accomplish (it has to interact well with the GC, Channel and Fiber need to be aware of this, etc.). So probably right now it's not a good idea to switch, specially because Crystal is not yet 1.0. But stay tuned! :-)
Aww I see. I will definitely install it and give it a go though after looking at those benchmarks. I appreciate your honesty as well, that shows where your integrity level is at with crystal. Thanks for the fast response
You should take a look at Elixir instead. Crystal is amazing, but it's still very young and still in development, and there aren't many libraries available for it -- it's something to play with and keep an eye on right now. Elixir's a language built on a very mature platform that was specifically designed to handle massive numbers of parallel connections. It has a ton of features to simplify and streamline these kinds of problems, scales across CPU cores by default without you having to do anything, scales across multiple machines simply by pointing them at each other (a single application instance can be running on 50 machines). It's used for Call of Duty servers and IM/chat networks, those kinds of things are its whole specialty, and in benchmarks a single machine can maintain 2 million plus websocket connections.
As you are coming from NodeJS, my vaguely informed opinion is that you should not try Crystal for now, except for simple use cases. You see, Crystal is a very interesting language. I have been using it for my side projects for the last couple months and while I love the syntax, it has proven equally delightful and maddening. My main two annoyances with Crystal are also its strengths. Namely: - Breaking changes: Asterite et al will not hesitate to introduce breaking changes to better the language design. While this is to be expected (only a fool would expect full stability from &lt; v1.0), it can also lead to spending hours trying to fix my own code, when in conjunction with annoyance #2, which is: - Its type system. Of course, as a compiled language, it needs to resolve clearly the type of your structures at build time. This offers a tremendous advantage: if your code compiles, it is this much closer to running correctly. The main issue with this design is that is offers new challenges that were not available in boring old languages like C (unless you were trying to be too clever by half) or modern interpreted languages like Ruby. I know that I end up spending an ungodly amount of time trying to figure out why the compiler doesn't like a given variable as an argument to a function. Let's just say that browsing the compiler source code itself can be a great help. I think some things could be improved but, as usual, it is likely that Asterite will be able to explain in a couple sentences why I am misunderstanding the theory. A couple items: - I really, really wish `typeof()` would return the resolved type of a variable as opposed to its potential types (Crystal allows you to specify a union of types for a variable, and that is glorious) because when perusing YAML or a library such as ssh2.cr either I need to treat the library like a white box, which should not be necessary, or I need to build a castle of `case variable.. when type1.. when type2..` to debug it - I wish I had a better understanding of how to move from a type to another. For instance the 'duktape' library offers bindings to run a Javascript interpreter (did I mention that C bindings are awesome?) -- when the interpreter returns a structure to Crystal, it is of an aliased type Duktape::JSPrimitive. These can be found, for instance, in a hash table. Now, a fun game: -&gt; How do you create another hash table (String =&gt; String) and copy your (String =&gt; JSPrimitive) table's content to that one easily? In conclusion, this is why I am thinking that, coming from Javascript, you would trade the well documented uncertainty of Javascript's type inference for a different, quite sadistic mistress ;)
&gt; And Erlang is not "one of the fastest languages", - it is rather slow. But it is certainly one of the best languages for conurrency. Oops my bad. Would using one 1 Elixir compared to several node instances (that have to use Redis Pub/Sub for communication between processes) be faster though? I wouldn't need to spin up multiple Elixir instances, right? It handles that multi-core issue for me?
Nope, crystal is not mature at all, in fact they just changed the syntax for default arguments. Crystal is fast just like any llvm language tends to be (c, c++, rust, swift, etc), but in the grand scheme of things node is pretty fast too. Stick with node for production. If you really want to sip some new, faster kool-aid try clojure or elixir/erlang. Both are great for parallel execution. I prefer clojure generally but I think elixir has better support for loads of connected websocket clients if that's what your app revolves around.
&gt; Would using one 1 Elixir compared to several node instances (that have to use Redis Pub/Sub for communication between processes) be faster though? They will communicate faster, than node instances through Redis &gt; It handles that multi-core issue for me? Yes When I tell "it is rather slow" I mean raw language features, not the runtime. ie if your algorithm/bussiness rules needs to run a lot of plain code, it will run slower than same code in Go, Java, mature Lisp implemenations or V8/nodejs. But runtime is very fast, so if your code mostly communicates with small amount of logic/computations, then Erlang/Elixir will brightly shine.
I wouldn't say Erlang/Elixir are *slow*; they're pretty decent. Obviously not Go or C++ speed, but still pretty nice. Also, if you're looking at a web project, check out [Phoenix](http://www.phoenixframework.org/).
I am really excited to see what the Crystal team comes up with.
Rust doesn't have a GC so you can write extensions as easy as in C. Crystal requires a GC and many other things for runtime, so even though crystal_ruby is a nice idea, I don't think it's going to be very useful.
I was thinking of doing those bindings. Good job. It looks like the code does not adhere to the usual format though. Camel case is not used normally with crystal.
Good point, Jerome. For now, I opted to use *some* camel case so that the bindings wouldn't stray too far from the original's documentation. 
I built it from source. In fact, I built the example and it pulled the library along: EXAMPLE=controlgallery make example I suspect what you are lamenting is the lack of pre built libraries as I don't imagine building would be a big challenge for you :)
Oh, I'm able to compile the library, I don't know how to install it. When I run the crystal example I get `ld: library not found for -lui`. I tried `make install` and `sudo make install` in libui but I get: ``` cp out/libui.A.dylib /usr/lib/libui.0.dylib cp: /usr/lib/libui.0.dylib: Operation not permitted ``` I'm actually very bad using makefile and understanding all those C tools.
Sure :) I'm just happy there are bindings! I think people expect Crystal libraries to adhere to the code style of crystal. For the bindings it's not so important indeed, but a library on top of them, abstracting them into a DSL for building UIs would be nice with crystal conventions-adhering code.
Yay! I was able to run it. I didn't see that I had to pass the link flags to compile it, and then I had to specify LD_LIBRARY_PATH too when running it.
very, very cool
Hi, Should some test cases be failing? For instance: Failures: 1) Sidekiq::Job serialization deserializes a simple job RedisError: ERR DUMP payload version or checksum are wrong [4531577650] *CallStack::unwind:Array(Pointer(Void)) +82 [4531577553] *CallStack#initialize&lt;CallStack&gt;:Array(Pointer(Void)) +17 [4531577512] *CallStack::new:CallStack +40 [4531905145] *Exception@Exception#initialize&lt;Redis::Error, String&gt;:CallStack +41 [4531905076] *Redis::Error#initialize&lt;Redis::Error, String&gt;:CallStack +68 [4531904980] *Redis::Error::new&lt;String&gt;:Redis::Error +100 [4531875300] *Redis::Connection#receive&lt;Redis::Connection&gt;:(Array(Redis::RedisValue) | Int64 | String | Nil) +116 [4531899954] *Redis::Strategy::SingleStatement#command&lt;Redis::Strategy::SingleStatement, Array(String)&gt;:(Array(Redis::RedisValue) | Int64 | String | Nil) +50 [4531868311] *Redis#command&lt;Redis, Array(String)&gt;:(Array(Redis::RedisValue) | Int64 | String | Nil) +135 [4531868117] *Redis@Redis::CommandExecution::ValueOriented#string_command&lt;Redis, Array(String)&gt;:String +37 [4531869035] *Redis@Redis::Commands#restore&lt;Redis, String, Int32, String, Bool&gt;:String +267 [4531518704] ~proc(Redis -&gt; Redis::RedisValue)@./spec/job_spec.cr:7 +80 [4531852369] *Sidekiq::Pool#redis&lt;Sidekiq::Pool, &amp;(Redis -&gt; Redis::RedisValue)&gt;:alias.Redis::RedisValue +257 [4531518461] ~proc( -&gt; Void)@./spec/job_spec.cr:5 +61 [4531511764] *it&lt;String, String, Int32, &amp;( -&gt; Void)&gt;:(Array(Spec::Result) | Bool | Nil) +420 [4531518314] ~proc( -&gt; Void)@./spec/job_spec.cr:4 +74 [4531749830] *Spec::RootContext::describe&lt;String, String, Int32, &amp;( -&gt; Void)&gt;:Spec::Context+ +310 [4531511129] *describe&lt;String, String, Int32, &amp;( -&gt; Void)&gt;:Spec::Context+ +9 [4531518220] ~proc( -&gt; Void)@./spec/job_spec.cr:3 +108 [4531749830] *Spec::RootContext::describe&lt;String, String, Int32, &amp;( -&gt; Void)&gt;:Spec::Context+ +310 [4531518099] *describe&lt;Sidekiq::Job:Class, String, Int32, &amp;( -&gt; Void)&gt;:Spec::Context+ +51 [4531448832] __crystal_main +3408 [4531496024] main +40
Excellent. BTW, good news: I sync'd and rebuilt the most recent library and the crash on exit on OS X is now gone.
I'm guessing you are using Redis 3.2? It works on 2.8 and 3.0 but I think it needs some work on 3.2.
It's really awesome to see this language continue to grow and come with such awesome write ups for new language releases!
1.step(10, 2) { |i| } (1...10).step(2) { |i| }
instead exchange method, you can use array.swap(i, j), which is faster.
Now working for me.
Author here, thanks for posting! It's still a work in progress, but it's pretty far along. I've gotten a [Crystal version of ActiveSupport::Inflector](https://github.com/phoffer/inflector.cr) working (provides singularize, pluralize, camelize, etc, methods for Rails), and using those methods via extension tend to be between 3 and 5 times faster than their original Rails versions. The plan is to have it cleaned up quite a bit, and allow people to easily create a Ruby native extension. It's still a bit of a mess, but it's not at a truly usable point yet anyways. It will (and currently does) allow for any Crystal code to be used, not just code specifically written for an extension. If anyone is interested in future uses/contributing, I'd be happy to talk more about it and answer questions. I just created a [Gitter channel](https://gitter.im/phoffer/crystalized_ruby) to make it easier for people to ask questions and get more info.
Thanks for the answer, helped me understand more, but unfortunately, I'm still figuring this out. What I am doing is to implement a c library to crystal, In C, the header, the variable was declared as: char *varx; in Crystal, its declared as varx: NewType and is an alias that's declared as: alias NewType = UInt8* However, the value varx is actually a String, or char array, eg "ABC" So far, I have only managed to get the Int value of the first char in varx in crystal: val = varx_instance.value val is probably the A's ASCII value which is 65. I would like to retrieve "ABC" instead of "A" 
Thanks for reading the project! I am very happy you did this. If I understood you, it is a bad thing to have a view that returns and Object.to_json right?
Sure! But don't worry, really, performance can always be later improved, and here it doesn't matter much because it's just a small sample program. One small way to improve things is to use `{uid: todo._id, ...}`, that is named tuples ( http://crystal-lang.org/api/NamedTuple.html ) instead of a Hash (`{"uid" =&gt; ...}`). In this way you avoid creating many small hashes in heap memory (named tuples are allocated on the stack).
This is kind of a given. Structs are allocated on the stack, but classes are allocated on the heap. In addition, although classes are passed by value, structs are passed by reference. The docs say: &gt; The rule of thumb is that if no instance variable is ever reassigned, i.e. your type is immutable, you could use a struct, otherwise use a class. IMO I usually prefer using `record`.
I can recommend reading http://www.mikeperham.com/2014/09/22/dont-daemonize-your-daemons/ Personally I use systemd when available, daemontools else.
I'd prefer something like Webmachine instead 
Any experience with supervisord?
Good blog post, that guy's smart! Yep, use upstart or systemd. It's what the OS uses to run daemons: you won't get anything more reliable.
Why `compile` is deprecated?)
i have seen 'eye' before but havent used it yet. it seems a bit compilicated (at least for starters i think)
hmmm, can you suggest where race conditions? i tried to make it safe and atomic as i can.
The problem with eye is that it's ruby-based, which means it is complex (therefore easy to break) and uses a lot of memory. You don't want your monitoring tools to be complex. I wrote a process monitor designed to be a next generation monit called Inspeqtor. It is a single binary, with no dependencies at all. * https://github.com/mperham/inspeqtor/wiki * https://www.youtube.com/watch?v=Ad4L2z497wY
It would maybe be good to have this interface in the standard library. As a side note, there's no need for the base "class" to be a class, it can just be a module with abstract methods. Having it as a class forces implementors to be classes too. The key-value stores backed by a Hash could then be a struct, so it avoids an extra allocation and it's basically like a Hash without overhead.
Can you elaborate a bit on why it could be useful to have this interface in the standard library? I think this project may be useful for someone who has to replace their data store at some point, or somebody who has differents requirements in development and testing, and prefers to have a single interface. But on the other hand, an adapter is conceptually harder to maintain (because it has to keep track of the changes in all the adapted libraries), and to some extent it prevents the replacement of adapted libraries (for example, if I want to use a version of an adapted library that is no longer supported, or maybe I want to use a newer version and I'm forced to modify this library). Edit: just to make it completely clear, I understand some people can find this library useful, but I think the use case is very narrow in nature. That's why I'd like to learn more about it.
My main "issue" is writing the adapters. For example we have crystal-db ( https://github.com/crystal-lang/crystal-db ) which provides a unified API for databases. Libraries simply register protocols with implementation, and then you do `DB.open("postgres://...")`. The same could be done with the key-value store: provide the interface, let users implement it and register implementations, and access it via a URI or something like that. Then swapping implementation is just swapping an URI and the underlying library, no need to change all occurrences of FileStore with RedisStore. But having a shard which basically contains adapters for each and every implementation is backwards and is less flexible in my opinion. It's a really good idea, but it should be done in another way. And yeah, it probably doesn't belong in the standard library, but it could be a sort of "standard".
[**@RemoteMeetup**](https://twitter.com/RemoteMeetup): &gt;[2016-07-14 18:35:41 UTC](https://twitter.com/RemoteMeetup/status/753659247402086400) &gt;The first [@CrystalLanguage](https://twitter.com/CrystalLanguage) Remote Meetup is tomorrow! Get your spot today! With [@asterite](https://twitter.com/asterite) [@sdogruyol](https://twitter.com/sdogruyol) [@ysbaddaden](https://twitter.com/ysbaddaden) \- [*bigmarker.com*](https://www.bigmarker.com/remote-meetup/0-Crystal-Remote-Meetup?utm_content=buffer5d734&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4sv1cv%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
Nice presentation Sdogruyol!
thank you!
This is a feature I am introducing in addition to the library bindings. It allows devs to specify a UI without hard coding it and maintain it using fragments described in simple .yml files. Some davantages: No need to recompile your code to test a UI change Team collaboration now easier Descriptive UI Separation of concerns Obvious drawback: No compile-time checks Note that inflating fragments and pure coding can be mixed.
&gt; (well, forget about Windows for now, this is Crystal) +1 Made me laugh.
For now you need to create wrappers of these types. For example you would create a CUI::Menu class/struct that wraps a LibUI::Menu type. When you do CUI::Menu.new you invoke LibUI.new_menu and store the rerturned value in this type. Invoking a method on CUI::Menu would pass this value to the API, and so on. Right now it's a bit tedious, but eventually it'll be simpler, without needing to write so many wrappers.
Yes that's actually what I've started doing at the bottom of cui.cr. Looks like Menu is a popular class! 
What does your development cycle look like? Does it have code reading? Does it have the equivalent of rails console or pry? Do you still have to use node stuff for front end? Does it support database connection pools? 
This is an Array of Array(String). First you should cast the result and actually it should be results results = conn.query(query).as(Array(Array(String))) results.each do |result| if result puts "Result" else puts "nil" end end
Thanks for the reply. If I try with ".as(Array(Array(String)))" I get Error in ./src/file_update.cr:10: can't cast (Array(Array(Bool | Float64 | Int32 | Int64 | MySQL::Types::Date | Slice(UInt8) | String | Time | Nil)) | Nil) to Array(Array(String)) And if I omit the "as..." part but leave results.each I get in ./src/file_update.cr:11: undefined method 'each' for Nil (compile-time type is (Array(Array(Bool | Float64 | Int32 | Int64 | MySQL::Types::Date | Slice(UInt8) | String | Time | Nil)) | Nil)) The entire script is: 1 require "./file_update/*" 2 require "mysql" 3 4 module FileUpdate 5 conn = MySQL.connect("localhost", "dbuser", "dbpass", "db", 3306_u16, nil) 6 7 dir = Dir.new("/mnt/sdb/files/") 8 dir.each do |file| 9 query = %[SELECT `id` FROM `file_data` where `file` = "#{file}"] 10 results = conn.query(query).as(Array(Array(String))) 11 results.each do |result| 12 puts "test" 13 end 14 end 15 end
A more defensive approach would be rows = conn.query(query) if rows rows.each do |row| id = row[0].as(Int32) puts "#{file} has id #{id}" end else puts "No results" end If you don't need the else case rows.try &amp;.each do |row| Is another possibility.
Yes, the compiler can't know whether or not the result will be empty or not, it doesn't even have a connection to the database after all. It just sees that `nil` is a potential value here and forces you to handle that case. `.not_nil!` raises if it's in fact `nil` at runtime, so afterwards the compiler knows it can't be `nil`. This is nothing special about `nil` btw, it works for every combination of types.
I strongly encourage you to use https://github.com/crystal-lang/crystal-mysql Not because it's under the official language organization, but because it doesn't use `libmysql`, it implements the binary protocol itself so non-blocking IO can work transparently. It also provides a uniform DB API so dealing with these nested arrays is easier, and usually never a problem. Also check: https://github.com/crystal-lang/crystal-db
I'll switch over. Thanks!
*VoidCSFML* is not a proper separate library, it's generated together with *CrSFML*. I didn't have to even give it a name, but it happens to be kinda usable by itself. [Why not CSFML?](https://github.com/BlaXpirit/crsfml/tree/master/voidcsfml#why-not-csfml)
Updated on 08/13/16. No meta objects yet.
&gt; It can compile to native code, or run interpreted on the command line I believe it's always compiled. The REPL simulates interpretation by compiling and running the entire history again. Crystal is so fast that most folks don't realize what it's doing. I imagine that things like network i/o will give it away. Someone please let me know if I'm mistaken. 
Here it is, it's a validation library: https://github.com/soveran/scrivener I only mention them because the author seems to be porting a lot of his work to crystal, so they might become available some day.
How it performance compare to redis memcache?
I have to improve some concurrency and memory stuff before we do this, but it is a interesting thing to do!
Yes that was very tongue in cheek. And a bit embarrassed as well :)
NOTE: I ended up renaming the project so now this link points to a 404(!) Correct link: https://hub.docker.com/r/cyansmoker/crystalvault/ 
Merhaba. Brilliant video
Merhaba
Teşekkürler :)
Update. Instead of u = User.find(1) u.email = "a" u.save I think this would be better/faster User.update(1, {"email" =&gt; "a"}) I welcome any comments and criticizm. I know I should check already existing tools like Ecto in Phoenix.
It would be faster. It would not be object-oriented, which is the ethos behind Ruby and Crystal. Even simpler: Table.update_row(:users, 1, {email: "a"})
That doesn't really seem much of an abstraction and really provides no advantage over just typing "update users set email = 'a' where id = 1" 
Take a look at repository pattern
Yesterday I have managed to finish to some point `crystal_api`. This is a short tutorial https://github.com/akwiatkowski/crystal_api/blob/master/payment_api_explained.md 
User(1).update {"email" =&gt; "a"} this is more in line with User.where().update() 
I am not smart enough to mess with PG connection code. What do you think is missing now, features or better performance?
Because for some time now IO is nonblocking by default.
If you can deal with breaking changes, why not? Excitement is fun. But you *will* need to keep that in mind. If something breaks, and now you have to rewrite half your program and change all the `X`'s to `Z`'s, do *not* go complaining somewhere of how the language in unstable. TL;DR: Go ahead, but **make sure you fully understand what the worlds "alpha stage" mean**.
Crystal isn't going to go viral. It's already viral!
Why'd you link to hacker news that links to the article? ..
Thanks :) 
Just started using today :) Definitely the best HTTP client currently implemented in crystal, nice work!
Hi! If you can tell us what API you want to hit it'll be simple for me to explain because I can use a concrete service. But the basic thing is to create an OAuth::Consumer, create an HTTP::Client and then invoke `consumer.authenticate(client, token)` with your access token. Then token can be obtained with `get_access_token`
Thanks for the reply! What I have now is somewhat similar. I'm using the [Tumblr API](https://www.tumblr.com/docs/en/api/v2), by the way. For now, I'm not worried about going through OAuth flow, I just have the access tokens right off the bat. My initialize looks something like this - def initialize( consumer_key : String, consumer_secret : String, oauth_token : String, oauth_token_secret : String) # create some nifty oauth stuff consumer = OAuth::Consumer.new(Host, consumer_key, consumer_secret) token = OAuth::AccessToken.new(oauth_token, oauth_token_secret) @http_client = HTTP::Client.new(Host) consumer.authenticate(@http_client, token) end I'm a little confused at the `consumer.authenticate` part - is it modifying the `@http_client` passed in as the parameter? Apologies for the newbie questions, I'm still getting used to how Crystal does stuff. What would an example of getting the resource `"/user/info"` look like? Right now I have `@http_client.get("/user/info")` and it's giving me `getaddrinfo: Name or service not known (Socket::Error)` By the way, I'm really digging how OAuth is built right into the stdlibs. Dealing with OAuth can be a mess sometimes, and I think this can help make things more consistent :) **Edit: just figured it out** I was using HTTP::Client.new("api.tumblr.com/v2"). Since it actually takes the host and not a URL, I just had to drop the `v2` part and add it when I do `get` requests. Works amazingly! OAuth can be difficult but this was one of the best experiences I've had in any language :)
I'm glad to hear that! In any case I'll try to document it soon, because it's a very useful API. The way the `consumer.authenticate` call works is that it sets a `before_request` callback on the http client to set the Authorization header with the access token data. Similarly, when you invoke `client.basic_auth(username, password)` it sets a `before_request` callback to set an Authorization header. This is possible because this callback exists on HTTP::Client :-)
Wow, this is great! I've actually been thinking about writing a command-line tool in Crystal that would require OAuth, so this article's timing works out really well. :D
&gt; Added Indexable module that Array, Slice, Tuple and StaticArray include Nice! I wrote that for Ruby once, Matz was not impressed :-( 
Also worth reading: https://crystal-lang.org/docs/syntax_and_semantics/c_bindings/index.html (yes, ruby ffi is built-in in crystal)
Also, try BlaXpirit's SFML bindings if you're not too set on SDL, they're pretty good
One thing I really miss in Swift after writing a little Crystal is macros.
Interesting idea. If I'm correct `Tren` will create Crystal code which generate SQL queries generating methods. It probably should be as a macro, but macros have less power than regular crystal code. At this moment there are some libs http://awesome-crystal.com/#awesome-crystal-ormodm-extensions aiming to be "better rails' active-record": Two of them are intended to be *big*: * https://github.com/waterlink/active_record.cr * https://github.com/drujensen/kemalyst-model There is yours generating SQL methods: * https://github.com/sdogruyol/tren - yours And there is one mine: * https://github.com/akwiatkowski/crystal_api - macros oriented I should say "let the best win" but I think every creator will use its own until one of the alternatives blast the rest.
How do you namespace the methods?
Hi guys! I have been meaning to finish writing this for a while. I think Crystal has a fantastic start, but it's website is far from good-looking. Here I present some design flaws with the current website, and then preview my ideas at the bottom. I was thinking about opening an issue on the github website page, but I'm unsure if it would be welcome there / if the core team is interested in a redesign / if it is on the radar at all. Thanks.
Can't agree more, pure awesome
You're totally right. I was playing with the browser size (which isn't responsive). On mobile it isn't cut off. Didn't notice that.
I'd suggest something like https://atom.io/themes/base16-ocean-dark-spacegray -- it's still fairly muted so it won't steal the focus like the old one, but it's distinct.
I like it but it's seriously lacking colors/images. But of course this is only an early mockup :)
I tried to use guardian but didn't see a way to: (1) kill my currently running process, (2) recompile the app, (3) start app. So I wrote Sentry. In order to kill a running process it would need to keep the app's PID in memory which I didn't see a way to do. It just watches files and runs tasks that you specify. Gaurdian was based off of the Ruby lib of the same name. I based sentry off of Nodemon from Node.js. Similar use cases but different execution.
Thanks! Do you know why Crystal doesn't use [this style](https://crystal-lang.org/docs/) for the API doc? It looks really nice - can't figure out why it isn't utilized in the API.
I said I was gonna do it, so i did it: https://github.com/crystal-lang/crystal/pull/3456
All of these adapters use an existing supported language (java/python/javascript) to launch out an external app. Go is easy because it's designed to compile to one executable file without the need for external libraries. Crystal can probably do pretty well, too. Heck, Ruby can be run by fatpacking. In short, it shouldn't be too difficult, just a bit tedious to write the wrapper. 
Tweet taken down already?
Most of the time a company with dozens (hundreds?) of developers does not use only one language. Different teams will elect to use different languages and infrastructure based on their IT policies. Likely they have bits using Go, Java, Ruby, Node, etc.
That's still pretty big news IMHO.
It's rather straight forward. Use the Go Lang and serverless framework approach. Crystals app needs to be staticly compiled and called from node js. Heads up: keep your binaries small and warm up takes time. API gateway will be an issue if you want a low latency service.
I guess I'll stick to javascript or python for quick tasks and look to crystal for something that requires heavy lifting. 
Another question: I guess this could be used to generate any kind of strings not just SQL right? Kind of like a generic templating engine or something.
Why not use ECR as a templating engine?
I was just thinking it would be nice to be pass in an array for a IN or NOT IN clause or other similar tricks.
Is select from crystal or this library?
select is from Crystal std
 $ time crystal build --release bin/download.cr crystal build --release bin/download.cr 10,16s user 0,08s system 100% cpu 10,200 total $ time crystal build bin/download.cr crystal build bin/download.cr 2,17s user 1,57s system 216% cpu 1,727 total $ crystal version Crystal 0.19.4+101 [e5d2bc6] (2016-11-02)
Wow, amazing work!
Nice! Bigint next!
Nice!! Just curious if you configured 2 tsung machines both handling 64k connections, how come the graph show the amount of users caps at 64k connections?
I found this near the end of the article. Sorry for the formatting; I'm on mobile: After some googling i found out that the default port ranges on Ubuntu was the limit. sysctl -w net.ipv4.ip_local_port_range="1024 64000" did the trick. 
It's not working as intended
Why can't windows developers use the ubuntu layer? 
Maybe, but that makes sense since the language is relatively new. With time and effort, we'll probably get there :)
ARM support and LLVM support? Holy crap, that is incredible! Are there any guides or tutorials or command line gists that show how to compile for ARM and have to compile Crystal using LLVM?
Thanks, Appreciated! crystal-api-backend has some really good concepts that frameworks like Rails is missing. I definitely borrowed some of your ideas (and code *[cough](https://github.com/fridgerator/crecto/blob/master/src/crecto/schema/build_from_sql.cr)*)
Thanks! I am using postgres adapter for now, but it seems there is a push from Crystal core team to use [crystal-db](https://github.com/crystal-lang/crystal-db) more for a common interface to sql. So I may wait a bit to see where that goes before making another adapter so I don't have to do something twice. But it would be nice to also support also mysql and sqlite. Thanks for letting me know about the typo, i'll fix it asap.
&gt;[**RubyConf 2016 - Opening Keynote by Yukihiro 'Matz' Matsumoto [49:04]**](http://youtu.be/1l3U1X3z0CE) &gt; [*^Confreaks*](https://www.youtube.com/channel/UCWnPjmqvljcafA0z2U1fwKQ) ^in ^Science ^&amp; ^Technology &gt;*^1,310 ^views ^since ^Nov ^2016* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
crystal_api creator here. Need put more work to my pet project and check another DB engine. Have you used crystal_api? What should I improve?
It'd be nice if the proposed merge into /r/crystal went ahead. I'm getting RSI typing /r/crystal_programming!
Looks great! It would be cool if it (and Crystal libs in general) adopted the [null object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern) rather than returning nil (ie: in the finders) For example: # Examples of finders that don't find a record # # all # users = Crecto::Repo.all(User, query) users.size # 0 # # get by primary key # user = Crecto::Repo.get(User, 1) user.name # nil # # get by fields # user = Crecto::Repo.get_by(User, name: "new name", id: 1121) user.name # nil 
I consider that absolutely horrible. Why delay the `nil`? should `user.name` return `""`, a "null string object"? Where is the boundary? Why waste performance over something so unneeded, when you can just `user.try &amp;.name` if you want to replicate the behavior or actually check for the error?
That's a terrible name. `jsonapi.cr` maybe? `crystal_json_api`?
I'm looking forward to any suggestion or critic, but I thought the first one would be more technical :) At this moment it is JSON PostgreSQL API framework, but I know it doesn't must be only PostgreSQL, nor JSON. I'm not thinking about messagepack now, but I'm ok with adding it laters/soon. I wanted to make it work ASAP not to construct big framework where most of feature is missing and it is not usable. If you find something dirty*, buggy, not usable I'd be more than a happy to hear and fix it :) \* some dirty parts would need more time to be fixed
Why did you ignore what I said? It's still a bad name. Maybe think of a less "standard" name? `crapi`? Definitely more wacky than `crystal_api`, at least :P
I tried doing this and got an error to do with XML. Syntax error in src/phone_server.cr:13: unexpected token: 1.0 "&lt;?xml version="1.0" encoding="UTF-8"?&gt; ^
If someone tells me "not ready for production applications" I tell that person that my scripts/tools works better and more stable after I have rewrote them on Crystal. "Solve problems you have with Crystal instead of Ruby" already doing it, but could solve other people problems. I think my problems are very limited and niche.
&gt; more stable after I have rewrote them on Crystal. I get that. But it can still have frequent breaking changes. That's why it's not ready for production yet. It needs to be stable for longer periods of time for production. &gt; could solve other people problems. I would advise checking things like /r/webdev or similar boards for problems other people have to get inspiration. The best ideas are in moments of frustration. It's harder to think of problems in hindsight.
If it's not about language or tooling, but rather you not being able to rewrite your particular code base -- then you can replace Crystal with any language other than Ruby and have the same conversation. There is no automatic conversion, and I don't think people would advise using such a thing on a large code base if it did. Perhaps you should revisit your architecture so you can change smaller pieces at a time.
Build a wall around it. jk, but in all seriousness, I would say Crystal isn't stable yet; since the language occasionally goes through breaking changes, I probably wouldn't use it to build something that my job would depend on...
Using it in production, finding bugs or pain points, and submitting merge requests is the best way of getting it production ready. I'm build an app on it right now and have made a few MRs to Crystal and Kemal and also developed a useful lib myself. 
I'm wondering if it's a mistake targetting Web Development as the primary focus? I feel like Rails folks aren't likely to move due to a mixture of already having a mountain of Ruby code, and Ruby being "good enough" in terms of speed. The JS folks aren't likely to move because they like JS, or they like having JS everywhere. Crystal does seem awesome for writing command line applications, system applications etc. I feel like we need a killer app that isn't necessarily web based, a games engine, or something like Electron? I might also be completely wrong.
Another important and related question I think is to ask is: where does Crystal stand if Ruby reaches it's goal of 3x speed improvement in the next couple of years? Ruby will still be slower than Crystal but at what point does one no longer care? If I could statically compile a Ruby program I doubt I'd care if it is still 5x slower than Crystal, at least for the majority of use cases. 
Personally if Crystal wants to be great I think the development team needs to stop thinking in terms of C all the time. Not everything under the sun needs to be pure static and run at supersonic speeds. Sometimes making life easier for the programmer, at the expense of speed, is worth it -- and they can make those things optional, so it's not like one has to use it. I also think they should work toward making the syntax more uniform, even if it means pseudo-methods, e.g. I would really like to see `.to(Foo)`, `.of(Foo)` and `.as(Foo)`. Also, Crystal should stop using meta-attributes syntax (`@[...]`), that is so hackish -- IMO there is something really wrong if it has to resort to that. 
It was just a thought ☺️ I for one would love to write a game engine in it. 
I doubt if Ruby will achieve this goal without big sacrifices like becoming something between Ruby and Crystal. Imagine rewrite gems to have types. Think about RAM also.
I'd more than happy if Crystal will allow you to achieve your goal :)
Crystal doesn't actually target web dev as a language. Keep in mind that the largest application written in crystal so far is a compiler, not a web framework. Crystal itself is very much application agnostic. However the community does consist of a lot of web devs who have come from ruby, and their first project in crystal is usually something web-related. 
Personally, I don't use crystal for its speed, I use it for its type safety, awesome community, and the feeling of being a "cleaned up" ruby without the warts. I would still use crystal if ruby was faster. However speed is an easy way to get ruby developers engaged, so it's ended up as crystal's headline feature.
The reason why you're struggling against the type system is because YAML is dynamically typed. YAML is read in at run time and neither the structure or types can be verified by the compiler. However, this problem has been already solved by JSON: use a pull parser. The pull parser allows essentially dynamic structures to be read in a type safe - albeit verbose - manner based on treating the JSON as a stream of tokens. If you spend any time using crystal's JSON pull parser you will find that it works very well for parsing dynamic JSON payloads. Because the pull parser is a low-level construct, everything else can be built from it: `JSON.mapping`, `JSON::Any` etc. (`JSON.parse`/`JSON.parse_raw` doesn't use it, but that's just an optimisation). I suggest you look at how JSON solves these problems, and attempt to emulate that, instead of attempting to create a YAML AST out of crystal objects. The hacky "making a sequence look like a mapping" stuff is then confined to `YAML::Any`, and you have `YAML.mapping` for creating nice type-safe object trees.
You seem to want crystal to be a very minimalistic lisp-like language with simple syntax, but that's not what crystal aims to be. Crystal aims to feel at home to ruby developers, and I feel it sticks to the spirit of ruby's syntax extremely well. Many of your suggestions do not align particularly well with the core developers' vision of the language, so often the only applicable answer is "no". Hopefully if you stick with the language a bit longer, you'll get a hang of how crystal is designed. However, obviously that PR shouldn't have been ignored, but sometimes PRs do fall through the cracks and get forgotten about. Just bump them and they'll usually get reviewed.
&gt;The reason why you're struggling against the type system is because YAML is dynamically typed. YAML is read in at run time and neither the structure or types can be verified by the compiler. However, this problem has been already solved by JSON: use a pull parser. This is not a good answer though. Saying "Don't use this and use json instead" doesn't solve any problem for the developer. 
No, I'm saying solve the problem by using the same solution JSON uses. The pull parser solution can easily be applied to YAML. 
Trans is writing and designing his own yaml parser. 
We've explained to you time after time why crystal works in the way it does in regards to union types. If you are unable to accept it as correct you might as well go and use a dynamic language. Creating a recursive, dynamic structure in any statically typed language will always end up with either creating a common interface over (scalar, sequence, mapping), or loads of casting.
What? Thats exactly my point as to why the way you're trying to do it doesn't work.
Just out of curiosity. Is this really a limitation of compiled statically typed languages or just the crystal typing system? For example could this be done with go or rust? 
I'd love to see this same benchmark with Rust and Elixir added.
Small note for anyone interested in doing this: the situation in Rust will be very, very different in the very near future; the async stuff is gearing up for an initial release, which changes the equation drastically for web stuff.
Yes? Just because it was reviewed doesn't mean it would be accepted. 
I can make full-of-buzzwords sales pitches too! Crystal is a niche language with a small community. It has fast, slick and extremely readable syntax. Static typing with type inference saves you from bugs and at the same time you don't have to write types everywhere. Try Crystal Now!™
are you legitimately retarded
If you are offended to this degree by someone calling someone else retarded as a joke, you are a child.
Small note for anyone interested in doing this: steveklabnik is a Rust shill.
Nice work
What would you recommend for creating a 2d array of string array's? Edit: I'm an idiot, so I tried: `@data = [] of Array(String)` last time and it didn't work, works now? Ah well :) 
this one's neat, but it has unexpected behavior. It works, but the default value is `[[]]` which isn't what I want since the first result is always an empty string array. Turned my results into: `[[], ["this", "data is", "lit"], ["yo", "its", "dat boi", "oh", "shit", "waddup?"]]` which means I'd have to `@data.pop` in the initialize def for it to have the expected results
this is not create a type restriction for an array, it just create an array with values into its. Ex: you can create an ` arr = [[] of String, [] of String, 5] # result: [[], [], 5] `
&gt; Btw, if you pre-fill your array I'm loading data from a file
dup creates a new array which contains the same objects as the original. clone creates a new array with new objects obtained from calling clone on each object of the original array. ary1 = [[true]] ary2 = ary1.dup ary2[0][0] = false p ary1 # =&gt; [[false]] ary1 = [[true]] ary2 = ary1.clone ary2[0][0] = false p ary1 # =&gt; [[true]] 
Alright, what's the point of using `#dup` when you can just assign the variable directly to another variable if it has an identical, if not the same, effect? Now I'm more curious about the actual use-case of `#dup` now that I understand what's really going on. ary1 = [[true]] ary2 = ary1 ary2[0][0] = false puts ary1 # [[false]] Edit: Or is the assignment/copy of another array just doing that in the background for me, similar to type inference (no idea what the technical term this would be)
Thanks for the response :)
Imagine a shoes-style gui system for Crystal :) The problem is that so many people are already comfortable writing GUIs in html/css/js.... That model is so familiar to everyone at this point.
fyi the link you shared has utm params for twitter. might mess up analytics haha. 
Windows support would be huge. Crystals great for server stuff (I'm not 100% sure it always matters though as server stuff tends to be i/o sensitive rather than language sensitive, so the case for moving to crystal from django or rails isn't super clear to me although being able to transfer rails skills to writing slick hot non web server apps is great. But having a window port with something like QT would be spectacular for those of us who would rather chew our own arms off than write another damn javascript faux-native x-platform desktop app ever again. 
Maybe we need to crowd fund some paid full time developers to give us the good stuff, and find some evangilists to go and get us the institutional backing to crack the big time. Crystals a great language it just needs the eyeballs and perhaps a "killer app" (Like rails for ruby, scipy/numpy and django for python, and "demented monster scale telephony apps" for erlang.
If type safety is getting in the way, your doing it all wrong. Type safety *saves* time by stopping you from doing stupid shit before it becomes an intractible "deep" problem by ensuring that your types are sane and domain appropriate to the problem.
Great article! Just a quick note. You can use kemalcr organization in your shard.yml dependencies: kemal: github: kemalcr/kemal branch: master
The effect of dup vs just assigning is not the same. ary1 = [[true]] ary2 = ary1 ary2[0] = 'hey' puts ary1 # ['hey'] vs ary1 = [[true]] ary2 = ary1.dup ary2[0] = 'hey' puts ary1 # [[true]] In the context of nested arrays, it's harder to understand the point of one vs the other, but if you have an array of objects that you don't want to copy, then you want to use dup. 
I actually caught myself today accidently trying to use ObjectSpace to search for floating file handles. Whoops wrong language. But that is as much a plus as a negative. Its ruby enough for a rubyist to pick it up *straight away* but it breaks away where it counts to ensure its primary focus, fast and furious C++ like speed by giving the coder AND the compiler the ability to reason in advance about type and type safety. Yeah it won't run rails any time soon. But, so what, web serving is 90+ percent waiting on IO. Crystal wont improve that. But crystal WILL improve things like writing native utilities, node.js style custom weirdo servers, game rendering without the overwhelming at times peculiarities of full blown c++, and so on.
I'd love to see it break top 10 soon. Could it pass Scala in the next couple of months?
Just curious (for the sake of making improvements) did you think the [docs](https://crystal-lang.org/docs/) or the [API docs](https://crystal-lang.org/api/master/) needed improvement? or both? And what area(s) need improvement? :) 
website docs, the api docs are pretty good. though is it normal that some things aren't documented eg.: `reset` for [Response](https://crystal-lang.org/api/0.20.3/HTTP/Server/Response.html) although `respond_with_error` does what I need, curious if that's purposly not listed?
Is it equivalent to C/C++ pre-processing instructions ? Like #ifdef/#ifndef #endif ?
Because crystal is a compiled language, it's already pretty strict about what code compiles. If you typo a variable, most of the time you will get a compile error, either telling you that variable hasn't been declared, or is the wrong type. The rest of the time you get a logic bug, which can be hard to chase down, but there are lots of other ways to introduce logic bugs too (including typoing literals, which you can't protect against). Another reason why it's not a significant problem in crystal is because typos are limited at function boundaries. Instance variables and class variables have to be explicitly typed, so typoing them is an immediate error. Typoing function argument names is another instant error. This means that likelihood of an error due to variable name typos is proportional to your method size, not whole program length. And if your method is over 20 lines long it's probably due a refactor in most cases. This is also reflected in my experience, I've been programming in crystal for over a year and I haven't found this type of error to be too common. Hope that helps!
I have never talked about *type declarations*, I talk about *variable declarations*. Perl doesn't have types (besides scalar/array/hashes). Much less than Crystal. It is more dynamic, and it is not compiled into C and machine code. But it *allows* to enforce variable declarations, and there is no type declaration. I have tried Crystal. And I got bitten by the same problems I had with Lua and Python that make me avoid these languages if I can. The same problems that pushed Perl people to introduce `use strict "vars";`. The same problems that appeared in other languages and pushed them to introduce the *possibility* for the writer to enforce more strictness (as much as the language internals allow it). Because it is a problem with all languages which started without variable declaration. People have been asking for (and sometimes given) the *option* to have more control in all those languages: * BASIC: http://stackoverflow.com/questions/2454552/what-do-option-strict-and-option-explicit-do * Crystal: https://github.com/crystal-lang/crystal/issues/900 * Fortran: http://cs1313.ou.edu/CS1313_2000Spring/Q+A/implicitnone.html * Javascript: http://stackoverflow.com/questions/8651415/what-is-strict-mode-and-how-is-it-used/8651441#8651441 https://news.ycombinator.com/item?id=3179505 * Julia: http://julia-programming-language.2336112.n4.nabble.com/using-strict-was-getindex-for-a-real-number-td32504.html and a few others * Lua: https://love2d.org/forums/viewtopic.php?t=2902 https://forums.civfanatics.com/threads/strict-lua-for-lua-modders-with-big-thumbs.532099/ http://lua-users.org/lists/lua-l/2006-10/msg00053.html http://stackoverflow.com/questions/1014757/declaring-variables-and-scope-question-for-lua and many others * PHP: http://stackoverflow.com/questions/3193072/strict-mode-in-php http://stackoverflow.com/questions/91699/php-equivalent-of-perls-use-strict-to-require-variables-to-be-initialzied-be * Python: https://mail.python.org/pipermail/python-list/2001-January/090680.html http://stackoverflow.com/questions/613364/is-there-a-need-for-a-use-strict-python-compiler/615306#615306 http://stackoverflow.com/questions/13425715/does-python-have-a-use-strict-and-use-warnings-like-in-perl/34071474#34071474 http://wiki.c2.com/?VariableDeclarationPreventsTypos and many others * R: http://stackoverflow.com/questions/24798663/variable-declaration-option-explicit-in-r * Ruby: http://stackoverflow.com/questions/13972345/does-ruby-offer-an-equivalent-of-perls-use-strict https://www.thecodingforums.com/threads/why-no-perl-style-use-strict-in-ruby.842315/ https://translate.google.com/translate?hl=en&amp;sl=auto&amp;tl=en&amp;u=https%3A%2F%2Flinuxfr.org%2Fnews%2Farticle-sur-ruby * Tcl: http://computer-programming-forum.com/57-tcl/7c63bfc979f55f3b.htm 
There was only *one* thing that stood out to me: You can simplify [this](https://github.com/exts/Crim/blob/master/src/Crim/Http/Router/route_parser.cr#L43) code by using string interpolation: route = route.sub(":#{mv}", "(?&lt;#{mv}&gt;#{rex})") Same thing for the code [here](https://github.com/exts/Crim/blob/master/src/Crim/Http/Router/route.cr#L34): raise InvalidRouteMethodException.new("Method (#{@method}) isn't in the valid methods list: #{METHODS.join(", ")}") and [here](https://github.com/exts/Crim/blob/master/src/Crim/Http/Router/route.cr#L30): raise EmptyRouteException.new("Route #{@route} was left empty") Oh, and you can leave off parentheses on function calls in most cases, though whether or not to do so is mostly just personal style. Crystal also comes with [a source code formatter](https://crystal-lang.org/2015/10/16/crystal-0.9.0-released.html) that you might want to try.
My non-technical blog created using [Jekyll](http://jekyllrb.com/) blog engine took to much time to render (about 30 seconds). I had to do some wicked hacks to create features I've needed. I've started my new blog engine as an experiment. It's still apha/early beta and not documented but I've managed to move my blog to it https://github.com/akwiatkowski/akwiatkowski.github.com Keep in mind content is in Polish and images (not sure if they are needed) won't be in repo and that can make it crash. If you want to create small blog/static site easily and fast Jekyll will be much better. If you have a lot of pages, if you need to add custom features and if you love Crystal maybe it will be solution for you. When I finish some minor stuff, add incremental rendering features, validations, FTP upload after rendering I'll create simple blog (now in English) because IMHO sample is the best documentation. And then I'll repost this here.
So this works with HTML then, right? It doesn't say anything about that in the README (It should, if at least for SEO).
AWESOME. So interesting to read. Thanks for posting this.
This is probably overkill for this but I already had the code around so there you go: require "big_int" lib LibGMP fun sizeinbase = __gmpz_sizeinbase(op : MPZ*, base : Int32) : Int32 fun export = __gmpz_export(rop : Void*, countp : Int32*, order : Int32, size : Int32, endian : Int32, nails : Int32, op : MPZ*) : UInt8* end struct BigInt def size LibGMP.sizeinbase(self, 256) end def bytes(format : IO::ByteFormat = IO::ByteFormat::SystemEndian) : Slice(UInt8) e = format == IO::ByteFormat::BigEndian ? 1 : -1 Slice(UInt8).new(size).tap { |s| LibGMP.export s, nil, e, 1, 1, 0, self } end end p BigInt.new("1F877C", 16).bytes(IO::ByteFormat::BigEndian) # =&gt; Bytes[31, 135, 124] 
Oh, OK! That's helpful to know. Thanks for your response.
As a testament to Crystal's terseness, while a long method, it remains extremely easy to read.
See ndjson.org
I had problems with tags in `korganizer` and existing command line organizers were hard to me. Next idea - write own organizer. It's very early, some things are dirty, but I'd like to check if I could move more into console than desktop or webapps for that kind of tools. I know that everything is in `emacs` but I'm not yet ready. Existing alternatives: * [taskwarrior](https://taskwarrior.org/) - looks promising * [calcurse](http://calcurse.org/files/manual.html) * https://github.com/pimutils/khal * https://www.reddit.com/r/linux/comments/56fn8b/command_line_calendar_and_organizer_calcurse/ In case after second research I find best tool for the job in existings I'll create shard for human friendly time processing.
I really like [RubyMoney](https://github.com/RubyMoney/money) so I wrote a library for Crystal based on it. This is my first real Crystal project.
Congrats on your first Crystal shard! How was your experience?
What exactly was lacking compared to rspec? 
- You can use `.should be &lt;= 5`. We know, the [documentation is shit](https://github.com/crystal-lang/crystal/issues/3909). - There's a shard for mocks: https://github.com/waterlink/mocks.cr - [`Spec.before_each`](https://crystal-lang.org/api/0.20.5/Spec.html#before_each%28%26block%29-class-method) exists. - let doesn't exist, but you can define private helper methods in the file, which help a lot. I think the main problem is the lack of documentation and guidance of how to use the spec module.
Yeah I saw that pattern on some CLI's but I was wondering if there was any way to do it w/o involving ruby or a different language
It's not really possible to do that for anything except what is packaged with the OS. Homebrew is the de facto way of distributing tools for Mac, so that's probably the most effective way to do it. Honestly, while it uses Ruby, you don't really need to know Ruby to get it working. It's mostly changing values for your own package. Brew has [instructions on creating a formula](http://docs.brew.sh/Formula-Cookbook.html)
So, here it is. Some (hopefully) fully persistent data structures in Crystal. Unlike some other libraries, my goal is to limit these structures' functionality to exactly what I would use them for in Scala, for instance. Hence, Lists and Stacks are pretty dumb. You can push, pop and uncons() to your heart's content but I have not implemented concat() yet. Similarly, the Map structure can add, delete, update, and be queried, which is 99% of my needs. Under the hood I am using linked lists for the queue-like structures (no fat nodes) and an AVL tree for maps. I know, I could improve performance by using other tree types but this was a good trade off for me, in terms of how quickly I could implement that kind of tree (after all, it's a week-end project ;)) When I move to implementing Vectors, I will use a tree or possibly a combination of trees and lists. As previously noted, I will keep Vector's implementation distinct from List and Stack so, while some functionality may be considered "lost" these simple structures can be updated in the same O(1) time as in Scala, as opposed to O(Log n) when using a tree. If anyone wishes to suggest a good backbone for Vectors, I would be interested. So far I have considered R-B Trees, Relaxed Radix Trees and a few others.
We were having issues with the original camo proxy in production, so I wrote my own version in crystal. I think the result is much more readable and maintainable than the original nodejs version. The main reason this is better than the original is the request tracing. Every useful detail about the request, any HTTP requests to fetch the image data, including redirects, are documented and displayed as a single object. This makes debugging production issues an absolute breeze. 
Great job! I didn't know about camo and it seems to be a really useful project.
It's been really useful reducing error rates in production so I'm happy with it!
Nope, but IMO SFML is just awesome and covers everything, even if it's just bindings: https://github.com/oprypin/crsfml
I've been craving a good IDE in Crystal. Tooling is half of the benefit of using a compiled language.
You're not going to get anywhere with OpenGL and anything other then C/asm without bindings.
Not entirely true. You still need the GL headers, but native implementations are perfectly possible. https://github.com/tomaka/glutin https://github.com/tomaka/glium
The first one is a **glfw** reimplementation, and the second one literally has "OpenGL wrapper" in the description.
http://i.imgur.com/pbkQCSM.png
And then you proceed to link two repositories that are not "native" implementations of OpenGL
You do understand that OpenGL is not an implementation, right? When you include the headers, those are just the headers from the spec. You're not including a library. I've proceeded to link a pure native implementation of windowing abstraction, inspired by GLFW. 
Take it easy, the issue is definitely in the radar; actually we were planning on going through it and a few others first time next week.
&gt; Take it easy I'm confused, did this come off as aggressive? I'm just asking the community their thoughts on this issue. What they think about it, etc... you'd want as many opinions on such a language breaking change as possible no? Since the thread's closed, not many people know this issue exists.
I'm very interested in writing a DX12, Vulkan, and potentially Metal renderer once we have working Windows support. It's in my list of projects.
You should use make doc in the crystal repo to generate docs. There's more info about how to develop in crystal's repo in CONTRIBUTING.md
Seems like shards for the AWS and Google clouds would be quite useful.
[removed]
Good stuff! Is this gonna be native in Crystal, or was this just for shitzengiggles?
Sweet! I don't really know a whole lot about that sort of stuff. If I have a VPS server with 4 CPUs, does the multi core mean I can use all 4 at the same time without having to spin up multiple processes like how Puma or Unicorn work?
Yeah you can use all of the cores without any effort
This is fantastic news! I am looking forward to its official release.
I've used [micrate](https://github.com/juanedi/micrate) before successfully.
pardon ama bu nedir? mariadb gibi birsey mi?
What's the use case?
I am sure there are others uses, but for me it is the ability to parse external data into different classes. For example, say a text file might contain a number or it might contain a text message. When you read it in and check it against a regexp, e.g. `/\A\d+\Z/` then you want to convert it to an `Integer`, otherwise a `String`. You can't exactly do this with Crystal because return types become tangled. The best you can do is a union type `(Integer | String)`, but that can lead to problems with supported methods that one type has and other doesn't (compile error). So the Dynamic type would fix this by wrapping the union and dispatching at runtime based on the actual runtime-determined type. P.S. Of course Dynamic should be avoided whenever reasonably possible b/c code will run faster and provide better type-checking. But, there are times when the elegance of the API is more important, and in those cases a Dynamic type can be a godsend. 
I think golang gets around this with their use of `interface{}`. I wonder if the not-yet-fully-baked meta object system would suit your use case.
Well, to some extent you can, but it isn't very elegant or convenient. You are basically talking about creating something like a unified `IntegerString` class, for my prior example. That requires one to cover all the methods of both classes. It can get pretty involved with lots of behavior to ensure. That's basically what I tried to do with my YAML parser. And though it worked to an extent (despite how ugly it kind of was), there are still some places where it become an insurmountable problem, such as parametric behavior of `#each` for a Hash vs an Array -- such a class can't be Enumerable. Really having something like Dynamic is a very simple idea that would allow for very powerful APIs. But I fear the core team are static purists, so I doubt it will ever happen. 
Do you have VT-x and AMD-V enabled in Virtual Box settings? It's under System then Acceleration I think that has to be on for 64 bit to work I've never had any problems though, I'm running 64 bit Debian
fucking awesome, thanks!
Why don't you install 64 bit windows?
I have 64 bit windows. Virtual Box only allows for 32 bit linux images for some reason...
Something doesn't seem right. Maybe you have the wrong version of virtualbox installed?
Hi! Check https://crystal-lang.org/api/0.21.1/HTTP/Params/Builder.html so you don't need to https://github.com/sb89/crystal-darksky/blob/master/src/darksky/client.cr#L15 In JSON.mapping, you can use `field: Float32?` instead of `field: {type: Float32, nilable: true}`
Thanks! I'll take a look at this.
&gt; So let’s say I have some CLI I want to exist, why can I just live and die in /usr/local/bin like "normal" unix-y utilities do? This post walks through porting a contrived CLI program (written in Ruby) to Crystal and then covers how to release it as a binary in homebrew. For me, the goal and finality of this was to see it as a binary with `file` and have it in my `PATH` from the `brew install`. It was fun getting all these things actually working after thinking that it might be possible.
Super awesome! Really well written and organized. It's an excellent article for those seeking to distribute CLIs via homebrew.
Just a note, you should probably stick `spec2` and `stdio` shards under `development_dependencies` in the `shard.yml`. This hardly matters when you're not devloping a library, but it's a good habit to get into.
Didn't know that it had groups like bundler. Thanks! Will do!
Probably should open an issue on github if you haven't.
Thanks, I'm new to Crystal.
There was a discussion on this subject on GitHub: [https://github.com/crystal-lang/crystal/issues/3941](https://github.com/crystal-lang/crystal/issues/3941) I've forked the repository I linked in the first comment and made a few changes to have it working with current Crystal syntax. The tests that the repo creator originally made now pass but I can make no more guarantees because I use a very small part of it and I know next to nothing about encryption. The repo is [here](https://github.com/Exilor/openssl.cr) Example: key = OpenSSL::PKey::RSA.generate(1024) data = "this is a test string" encrypted = key.private_encrypt data decrypted = key.public_decrypt encrypted String.new(decrypted) == data # =&gt; true There are more examples in /spec. 
The current fiber code is really quite short and simple, so in addition to what u/bcardiff said, I'm wondering what the benefits of using llvm's solution are. The page on it didn't seem to go into detail on the benefits, but I assume platform independence is one. I'm sure we'll find out more about the feature as it evolves! 
Visual Studio Code has a pretty nifty plugin, not sure if there's a linter, i'll have to check. Edit: no linter
The ST package is very good.
What? The sublime text 3 package automatically runs `crystal tool format` on save, and while the syntax color file is based off of a ruby one, it's heavily modified (for example, `attr_reader` is not highlighted while `getter` is).
https://github.com/veelenga/awesome-crystal#editor-plugins
Does the VS code integration run the formatter on save?
*visits link* ERROR: invalid input syntax for integer: "-moving-from-ruby-&amp;-rails-to-crystal-&amp;-kemalyst-" (PQ::PQError) 0x4f59f0: ??? at /var/www/andrewzah.com/lib/db/src/db/statement.cr 103:7 0x55e27e: ??? at /var/www/andrewzah.com/src/controllers/post_controller.cr 49:10 0x58a73b: ??? at /var/www/andrewzah.com/lib/kemalyst/src/kemalyst/handler/router.cr 166:26 0x58f475: ??? at /var/www/andrewzah.com/lib/kemalyst/src/kemalyst/handler/router.cr 128:7 0x5981b7: ??? at /opt/crystal/src/http/server/handler.cr 24:7 0x57d0f8: ??? at /opt/crystal/src/http/server/handler.cr 24:7 0x57c194: ??? at /opt/crystal/src/http/server/handler.cr 24:7 0x57b18f: ??? at /var/www/andrewzah.com/lib/kemalyst/src/kemalyst/handler/static.cr 48:9 0x599395: ??? at /opt/crystal/src/http/server/handler.cr 24:7 0x596adb: ??? at /opt/crystal/src/http/server/handler.cr 24:7 0x4d08e3: ??? at /opt/crystal/src/http/server/request_processor.cr 39:11 0x4207a8: ??? at /opt/crystal/src/fiber.cr 114:3 0x0: ??? at ?? Oh, the irony... (FWIW, the correct link is `https://andrewzah.com/posts/moving-from-ruby-&amp;-rails-to-crystal-&amp;-kemalyst`.)
Is there an actual talk or just this slideshow?
I wrote this! I haven't blogged in over a year really, so hopefully it makes sense. Thanks for posting it here!
You try [libui](https://github.com/andlabs/libui)? Would be a nice port if you can get that working. Edit: Someone already [did it](https://github.com/Fusion/libui.cr)
Do you know if libui can render bitmaps and capture keystrokes? The documentation is pretty-much non-existant.
not sure really, haven't tried it yet. I plan on using it soon for a desktop podcast player thing so hopefully it has some functionality regarding that.
I am also interested in this but, unfortunately, libui development seems stalled.
Thought it was feature complete last I checked for what it was supposed to accomplish?
 adt IntList, Empty, Cons(Int32, IntList), would look a bit nicer IMO
Wow, I had no idea about that, and I thought I knew most of the undocumented features.
https://crystal-lang.org/docs/syntax_and_semantics/macros/hooks.html does not mention the `finished` hook: class Abc macro finished def self.hi puts "Hello" end end end Abc.hi [The above will print `Hello`](https://carc.in/#/r/1rj5). You could use this to for example implement proper JSON mappings (with functioning subclassing and all).
Done. Thanks
Do you have an example of that?
[I do!](https://github.com/MiningPotatoes/geode/blob/master/src/geode/angle.cr#L88)
Hello, Crystal people. I wrote this tool that lets you point and click directly on module names/paths on GitHub. I don't code in Crystal, but tried to support it. Please let me know if it works correctly, for both local, external and standard library modules, and if there's something that could be better.
Good job!
Hey, I am new to Crystal. What is the "=&gt; Float64" part for?
&gt;Regarding the pipe operator, I think that asterite's reply here does a good job of explaining why we haven't added it. I don't think so. The basic excuse is that it would pollute the syntax which is silly. It hasn't polluted the syntax of other languages and it's very useful. Ask any elixir programmer what they like most about the language and pattern matching and the pipe are always in the top five. &gt;We already have some basic pattern matching with case and destructuring assignment. no we don't have basic pattern matching. &gt;At the end of the day, there has to be a strong motivating usecase when adding featured to crystal or you'd end up with a mushy bag of features (I think everyone agrees that design by committee is awful). First of all Crystal is already a mushy bag of features due to it's ruby heritage and glomming on a type system on top of that. There is a huge mishmash of dynamic and static programming features in there as well as additions to the standard library. Some of the features they added (like slices) are just barely enough to get their work done working on the language instead of being a robust and useful type. Just put there to get some work done. secondly Pattern matching is present many languages and the pipe is present in a few. Adding two features which many of the very small crystal community is asking for isn't really that big of a burden. The fact that somebody is writing a library to try and make some version of pattern matching is evidence right there that people want and need this. I think at this point the team is just being stubborn. Having decided "no" at an earlier point they are now dug in and changing their mind is embarrassing to them. I bet the guy who wrote this library is smart and capable of enough to submit a pull request to put these into the language itself but hasn't done so because he knows the core team is opposed to adding these features into the language. &gt;If you come up with a strong enough example for either of your two suggestions I'm sure they'll get added. People have submitted strong examples and frankly we don't even need to. As I said pattern matching has been around a long time and is implemented in many languages. They already have function signature overloading which is a dumbed down version of pattern matching. TLDR: "keeping the syntax simple" when the syntax is complicated and adding it would make it simpler is not a good enough reason to reject it.
See: https://github.com/fiatjaf/module-linker/issues/8
great!, but why not contribute kemal for better optimization instead creating "yet another framework"?
very excited, I am signing up to go!
If anybody has any tips/ points to improve feel free to share!
Hi! I've written some software that used FSMs for various purposes, so I'll offer some input. What's the usecase for this project? My use was to basically implement state machine that represented independent agents in a system that moved through various states and had different behaviours accordingly (think, for example, video game enemies). In this case, what you want is a way to model states and transitions that associates the states with blocks of code instead of with an opaque text file. I don't know if that's what the problem you're trying to solve is, so maybe this is what's right for your needs, but it's pretty far from what I'd adopt if I were looking for an FSM library in a new language. At any rate, thanks for writing something and sharing it. Keep it up!
I'm following a course about automata in uni. I wanted to make a Turing machine ( which has a finite state function backbone in this particular course at least) simulator in some language I don't really know to get to know two things at once, so I could use the T.M.to check my exercises. I'm typing this on mobile, so in depth questions are rather annoying to type up, but do you mind if I ask you some questions another time? Thanks for the feedback anyway, really appreciate it!
Still can't believe I got that name!
- Structs can't inherit non-abstract structs though? - I know that `sprintf` could be replaced, but the convention in Ruby is to use it over `%`, so I used it here. - About `Angle::NAMES`, it wouldn't let me have the variable only for compilation without `macro finished`. 
First use `crystal tool format` before commiting. Next write working spec :) In a meantime add some comments.
libui just wraps platform native libraries; on linux this is gtk, which can do your tasks.
there are bindings for gtk and sfml: https://github.com/jhass/crystal-gobject https://github.com/oprypin/crsfml you can try writing your own c bindings to something like nuklear: https://github.com/vurtun/nuklear
Hi my friend! you can use this logic; *You must have a run_action method to call your actions. (Look my file core/controller.cr) *Your class must have a hash(String, Proc(Nil)) *unfortunately crystal's self keyword is not a instance, therefore you must create a helper or router class etc. (i think you want to do this) pls. contribute my project. Thanks!
Crystal should add support for something like this on an instance level, unnecessary boilerplate 🙁
Is that on the roadmap?
I was using it for a big project but got burned a few times from breaking changes to language and to dependencies. I would actually advise against using it in production until later this year, which is hard for me to admit because I love crystal.
In my company we use crystal as an API backend to a lot of our services. It's a beautiful and surprisingly stable language. It does however as others have mentioned have breaking changes regularly so you need to be mindful of that in your dev cycles
I rewrite in our company quite big backend api from ruby(event-machine) to crystal (21 shards, 300Kb source size, compiled size 21Mb), it much more stable and faster than ruby app, and half of year in production. And rewriting was quite fun, because i copy most of code, and it works almost without changes.
Cool. Looking forward to that. Any word on ARM support?
Really as it stands though, you can distribute your applications to your application server and not have to have crystal on it. As long as it links the same shared libs &amp; versions from the system (e.g. libcrypto) it will be fine.
Any instructions anywhere. I'd love to get it running on the pi.
It's in the new version of crz https://github.com/dhruvrajvanshi/crz/blob/master/src/crz/chain.cr
It's really impressive that Crystal is supported now. They've just recently added Go, so this suggests Crystal is being considered on that level - not as a massively popular language but one that isn't all that obscure either. 
This is cool, CodeWars is such a fun site.
Is it me or has the community been unusually silent lately.
The team and some of the community members are probably busy preparing for the Crystal Code Camp conference.
If you want an ORM (like DataMapper), there are some available: http://awesome-crystal.com/#awesome-crystal-ormodm-extensions
I'd recommend Jennifer over Kemalyst-model right now, it's the most advanced ORM right now (Crecto is right there too but I stuck with a more OO recommendation).
The bindings in the hoop project really showed me how flexible it is. I didn't expect objective c cocoa wrappers to be so simple.
I think I've seen this before. It works by interacting with Ruby's C bindings right? Do you know if that is any different than how Helix works? I haven't looked into Helixs code yet. 
From what I can see they work in similar ways.
I think it depends on your goals for learning. If it's to benefit your career, Crystal won't pay off for awhile. If it's for learning programming concepts, then it depends on what your background is, your understanding of OO, etc. If it's for fun, then it really doesn't matter, although the ecosystem is more mature in Ruby. My career is Ruby development, but I've been working with Crystal for awhile too. They're both fun, and once some parts of the Crystal ecosystem catch up to their Ruby counterparts, it's going to be amazing.
Bottom of the [roadmap wiki](https://github.com/crystal-lang/crystal/wiki/Roadmap), literally just `DSL for writing Ruby extensions`. The target for crystalized is to generate scaffolding for a native gem (and handle other conveniences). I've got it working as a gem but never got the installation part quite right. 
Yes its worth it to keep learning Ruby IMO. Ruby is a fantastic language. A lot of the things you learn in Ruby will directly transfer to Crystal.
that's the only way at the moment. 
https://github.com/oprypin/crsfml goes C++ -&gt; C -&gt; Crystal
I mean... that's exciting, but where's the code?
Negatives: - lack of Windows support (for now) - lack of ARM support (for now?) - lack of destructuring in pattern matching - lack of persistent data structures in base library As you can see, these are only negatives as far as I wish the language also covered these, so that it could be perfect (for me!) And an additional one: - numerous breaking changes ensuring that your code will stop working within a couple releases, tops ;)
The biggest lacks in the language are pattern matching and pipes. Other issues are. Inherited some idioms and cruft from ruby, small community, documentation can be improved and better organized, lack of useful shards (due to small community). Aside from that the fact that you have stronger typing means a lot of stuff you are used to in Ruby are extremely difficult if not impossible in Crystal and you may end up wishing for them.
The main thing I find lacking in Crystal is not having parallelism support. (I haven't followed Crystal in about 4 months, so this might have changed)
I would say if you want to learn it, learn it ! And do some side projects with it. But you'll certainly not have a lot of job offers in Crystal giving the age of the language and its alpha status. But it's how all languages starts : in the beginning, only few early adopters use it but the bigger the community is, the more job offers you'll have ! However, giving the fact that Ruby and Crystal are really close, I would recommend you to start with Ruby, you'll find more job offers. Then, it'll be really simple to move to Crystal.
I love crystal, but it lacks somethings I like in web focused languages such as class reflection for one. Makes factory boilerplate very annoying when dealing with large applications. 
Isn't ARM support already in?
ARM support has been in master for quite a while, and there's a apt repository for raspbian maintained by one of the core devs. Could you elaborate on the lack of persistent data structures? I'm not quite sure what you mean. 
Look at perl6 as an example of pipes AND method chaining. It is indeed needlessly complex. I think Dart gets it right in the way that it allows all regular methods to also be chained by implicitly passing the object to the next method.
With Microsoft releasing entire linux distributions in the Windows App Store, it sounds like they want most developers to just go this route.
not the |&gt; pipe which took the result as the first argument, but ~&gt; pipe that took the object being called before to be used again would be pretty useful. e.g: a = ["a", "b", "c"] a.pop # return "c" but I just want to use a a.pop~&gt;map{#something} would be nice 
Yes! That is a very useful operator, however that's already pretty easy to do in crystal using `a.tap(&amp;.pop).map { # code }`. So I don't that that one will be added to the language either, but for a slightly different reason. 
I'm sorry I don't understand. 
It being available as a macro doesn't affect its inclusion to the language unless it's widely used, which it is not. And maybe it isn't a lot of code. Even if you wrote that code and maintained that code the code wouldn't be merged because adding it *decreases* the quality of crystal by creating 2 competing but incompatible ways of doing exactly the same thing. If it got merged, either one would dominate over the other (in which case why add the other) or both would be used, creating needless incompatibilities. 
[They're working on it](https://github.com/crystal-lang/crystal/tree/thread-support) :) It *does* work too from what I've heard. Just not finished quite yet.
Does anyone know of any Crystal benchmark tests that analyze basic things like hash vs arrays, simple loops vs mapping, etc? Edit: Nevermind, found some stuff! 
I would say the community. Crystal is run by a handful of individuals who do not like outside participation, even though they'll surely deny this. Go read some of the github issue threads and you will get a feel for the protective and often hostile atmosphere in these discussions. It is the main reason I left the language. Contrast this with Ruby or Elixir where people are much more friendly and open and you understand why Crystal is moving so much more slowly and will probably never grow out of its niche. 
Isn't it undisputed that crystal is 'fast', shouldn't we be focusing on what we can actually do with crystal now? If crystal wants to grow, we need interesting things made with crystal.
Thank you for your quick reply! So perhaps I should find the source for the specific version and build it myself?
&gt; undefined reference to `__cpu_model' Ugh this sucks, again nothing really related to CrSFML. So I guess you're on Ubuntu 16.04. https://bugs.launchpad.net/ubuntu/+source/gcc-5/+bug/1568899 [See](https://github.com/rroohhh/MoNS/commits/dfe5f90e) a [workaround](https://github.com/rroohhh/SFML/compare/d8277a58bd5da9976eac32fa691a569244966325...9ed6bffbb6895fa048dac6cf636c1f9b424d0b2b) - then rebuild SFML.
Alternatively, to make your life easier, clean up all of this mess before it's too late and install SFML from repos. Again, I assume this is Ubuntu 16.04, in that case SFML 2.3.2 [should be available](http://packages.ubuntu.com/search?keywords=libsfml-dev). Then install CrSFML with the [recommended approach](https://github.com/oprypin/crsfml#approach-1) (you also won't need VoidCSFML to be installed globally)
This worked! Thank you sir! Now a strange thing is that I forgot to run the export commands in this last attempt and then I got the error above ("error while loading shared libraries"). So I suppose if I had ran these export commands with "approach 2" it would also work...
There doesn't appear to be one
If you decide to write one, you can use [their api](http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/Welcome.html) as a reference. Seem's like a simple http request/response api.
Nice to see it listed here https://github.com/showcases/web-application-frameworks
There are many, but this is just one I ran across the other day: https://github.com/crystal-lang/crystal/issues/2396 There's is just an attitude about the main contributors.
You can bind web servers to the same address though, which for me is a reasonable work around (multi process, basically...)
Two days, no comments. What's happening here?
Obvious question is: what is the state of development of Crystal regarding to parallel use of fibers and Windows development. Related to that: possible concrete news as to timing on the roadmap to v1.0 This might not be apparent, but for company coders this is all-important And also obvious: please record for posterity and sleeping coders :P
Contributor Covenant is a cancer.
Hey it's definitely a start! I'll check it out, thanks.
Post what you found!
https://github.com/icyleaf/fast-crystal That said, after review, it's not terribly helpful. A lot of the benchmarks have questionable results. It's a good starting point, but I ultimately opted to benchmark things as I go, so that's what I'm doing now, and what I suggest everyone do for performance critical code. In short, I question all the built-ins and rewrite as necessary if I find a bottleneck. That said, my rewrites are *not* generally applicable, so it's not worthy of a pull request. (e.g. split a string on an exact byte where the length is always known. I can get 10x the performance of a regular String.split, but it's only applicable to my use case.) I recommend checking out the linked source only as a *general* guide, and benchmark your critical code paths on a case by case basis.
They looked very patient to me : https://github.com/crystal-lang/crystal/issues/1967 , anyway this guy is tiresome and very annoying ^^
Hi, see: https://github.com/ysbaddaden/android.cr https://github.com/ysbaddaden/java.cr
I hope this book would be ship with Crystal 1.0 ;-)
Now this is some good benchmarking. Crystal gets the expected / correct results. Kemal is also doing pretty good, pretty close to Phoenix https://www.techempower.com/benchmarks/previews/round15/#section=data-r15&amp;hw=ph&amp;test=json&amp;l=zb2by7 also doing pretty good against Ruby frameworks https://www.techempower.com/benchmarks/previews/round15/#section=data-r15&amp;hw=ph&amp;test=db&amp;l=zdk54v&amp;w=0-1ekg&amp;f=0-0-0-47pc-0-6bk-27xgcg-0
crystal need 0.7s to compile a single `puts "Hello world"` line in my machine, so I think it not just you. Rust is faster, and Nim is even more faster. Go compiles almost instantly. 
Crystal performs full-program type inference. As awesome of a feature as that this, that's where a good chunk of the compile time goes towards. That being said, 8s does seem a bit longer for such a small program... where's your code?
Yes, Crystal resonates with brainwave isochronic singular frequencies and leads to wellness and happiness. But you don't need to pay quacks for it, just download it for free!
Yes, it's for website, like Node.js or php. They are languages though, but i think you know it. Amenisthe - perhaps is [amethyst](http://codcore.github.io/amethyst/). There is also [Amber](http://www.ambercr.io). 
Thanks
I guess full multicore/parallelism support and web-framework like Ruby on Rails would be two most important killer features.
*Trawl*...?
crystal already provides concurrency through channels. true parallelism is still in the works afaik. 
RoR is good enough for folks who need RoR. I'd vote more for performant statistical libraries that could become the basis of something like numpy/pandas for crystal. 
awesome job, thanks very much!
Hi, what is this for? Afair there is no windows support for crystal, yet. Or do people use VS on linux?
Actually that's for Visual Studio Code, it's a "Sublime Text"-ish cross platform text editor that runs on Electron.
looks nice, i also write similar project for json and msgpack, https://github.com/kostya/auto_json, https://github.com/kostya/auto_msgpack, i have problem with inheritance of classes, fields not extending properly, do you solve this problem?
What do you mean fields not extending properly?
If you're wondering, yes, this thing is specifically why I wrote [magicjson](https://www.reddit.com/r/crystal_programming/comments/6k2op2/magicjson_a_better_json_parser_generator_an/).
"lol, Golang does this so much better"
Why did you fork?
Because it changes discordcr heavily (no more Cache, just Client and CachedClient; no longer using JSON.mapping but [magicjson](https://gitlab.com/zatherz/magicjson) instead, heavy usage of "extra fields" to pass the client to the payloads, etc). I assumed that meew wants discordcr to stay minimal.
i mean this: https://gist.github.com/kostya/553212dde839fb4924e8b4aefd77e773, and this is works as expected, i wonder how you solve this.
When you include MagicJSON, four constants are created: * `MAGICJSON_OBJECT` (just `true`, used for detecting if this is a MagicJSON payload) * `MAGICJSON_FIELDS` (default value `{} of Nil =&gt; Nil`) * `MAGICJSON_DEFAULTS` (default value `{} of Nil =&gt; Nil`) * `MAGICJSON_API_CONFIG` (default value `{} of Nil =&gt; Nil`) When you run the `field a : Int32` macro, `MAGICJSON_FIELDS` becomes something along the lines of: {"a":{type: Int32, key: "a", ivar_name: "a", has_default: false}} When you `include MagicJSON` (or extend/include something that includes it), the class gets populated with macro hooks (`macro inherited`, `macro included`). These macros forward the `MAGICJSON_` constants into the including/inheriting class (so if you inherit `A`, its `inherited` macro is ran which at this point sets `MAGICJSON_FIELDS` in whatever class inherited it to `{"a":{type: Int32, key: "a", ivar_name: "a", has_default: false}}`). Note that the `macro included` of `MagicJSON` itself and a type that includes it are different - `MagicJSON`'s sets the constants to empty tuples, while the on in a type that includes it sets the constants to the value of the constants in this type. Does this make sense?
this is based on stars on the language repo. maybe not the best sign of much. 
Official blog post http://kemalcr.com/blog/2017/07/01/kemal-0.20.0-released/
Keep up the great work! This is still one of the greatest web frameworks out there - and that's across all languages. I'm currently building my side project in serverless with node but I'm miserable - considering porting it to Kemal for developer happiness. 
Wow, thank you :)
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](https://i.redd.it/wv477e19fn6z.jpg)
Awesome! Thanks for the great work! 
Hey, could you provide benchmarks compating Kemal to raw http implementation?
It's hard to compare the built-in raw Crystal http server with Kemal. Kemal is built upon it but provides much more features (routing, parsing, sessions e.g)
I follow this project. The name of the project is so cool. Probably , I will write my first web application with this framework. Greetings from Turkey.
thank you :)
So, no compiler on Win32 yet, but you can still code Crystal on Windows with this extension, because it support syntax highlight, symbols navigation and basic completion without Crystal installed. :-)
The list: https://github.com/showcases/programming-languages
It's not hard to compare at all. Kemal performance is atrocious in the grand scheme, and not very good at all compared to Crystal's default HTTP handler: https://www.techempower.com/benchmarks/
that's not true at all, round 14 results are actually broken because of misconfiguration please check round 15 preview for more correct results https://www.techempower.com/benchmarks/previews/round15/#section=data-r15&amp;hw=ph&amp;test=fortune&amp;b=2&amp;s=1&amp;l=zb1vy7&amp;w=0-1ekg&amp;d=h&amp;f=0-0-0-47pc-0-1kw0-27xgcg-0 
Unfortunately, there's no IDE for Crystal for now
I've found vim-crystal and Crystal for vscode to be very awesome.
Welcome! I'd give VSCode a try. The code runner addon for crystal works pretty well. It also has syntax highlighting as well, but VSCode needs a bit of config to work better (2 space tabs, no trialing whitespace etc etc). Also try Atom, I've seen a lot of Crystal programmers who really love it. There is no "official" or "complete" IDE like Visual Studio for .NET. There is no debugger either other than GDB. I'd jump on our [gitter.im](https://gitter.im/crystal-lang/crystal) and hit up @RX14, he's the one using GDB the most right now and can probably give you some good recommendations. 
I use Sublime Text with Crystal plugin and AFAIK at least some core developers, too. The plugin for VS Code seems really great, so I'll check that out soon: https://marketplace.visualstudio.com/items?itemName=faustinoaq.crystal-lang
Whoa, what?? What happened? What changed? The old benchmarks reflected my own tests relative to Go-based frameworks... And now they're significantly better...
Kemal and Crystal were not using all the 32 cores that's why it's really slow also there were some misconfigurations.
Atom (https://atom.io) has the Crystal package that turns it into a full Crystal IDE: https://atom.io/packages/crystal
Here are links to discussion: https://github.com/crystal-lang/crystal/issues/4366 and to PR: https://github.com/TechEmpower/FrameworkBenchmarks/pull/2758
Awesome! Thanks! That makes the results a lot more clear!
Hey, would it be possible to make crystalshards.xyz index GitLab too? Especially considering that `shards` has first class support for it too (`gitlab: a/b`)
That'd be a great improvement. I just let the developers know about this idea :P
On https://crystalshards.org too ;-)
I will be adding support for gitlab, bit bucket, and allow for manual submissions via https://crystalshards.org later this month.
Fantastic.
Probably a little early in Crystal's development to ask for something like this... Glad it is at least a bit on their radar. I'd love to see this personally, I love RubyMine. 
without asking and raising the level of the discussion I don't think we will get anything done there. they seem very open to the possibility. it could really help to get more people voting for the issue.
very cool. I need to look inside and learn about the storage, trade-offs, etc. I've been thinking about building a REST interface to RabbitMQ in crystal for some time so this might help me move to actually doing it.
Hows it compare to the competitors?
That's great. Definitely going to look into using this. BTW, you have a minor copy/paste error: ensures(test_method(val), return_value &gt; 0) Also, checking @val != nil is a bit of a contrived example since the type system already allows enforcing this. This being said, I understand how it makes for an easy to digest example.
Thanks! Also yeah I know, though I didn't know how to make another good example since what I am used to in C++ this is the most common invariant you write :P
DUDE THANK YOU FOR THIS! I would really really love some basic docs on how to use CrSFML. Do you have any?
There are [a ton of docs](https://github.com/oprypin/crsfml#documentation). Let me know how they can be displayed more prominently, because I thought they were impossible to miss.
I'm oblivious so your probably right.
How much overhead does this add to the runtime? The nice thing about tests are that they don't burden your classes with these types of checks. It might be a nice feature to only enable if the environment is not production so they run on development, test and CI envs but not in production.
The implementation leaves zero imprint on your system besides what needed to not cause compile errors if you turn on the release flag, this means it should have no overhead at all in production. You can also manually set that internal CrystalClear::IS_ENABLED constant to false to force it to not be included at compile-time if you don't want it to be in debug either. Otherwise the overhead is only the overhead of the actual tests (i.e if you query a super heavy method then that is the overhead in the test). We use something similar in C++ in live production at my workplace and the overhead while having it on in debug is negligible. And like I said in release it will be non-existent since the code is simply not added. The main advantage of this compared to Specs is that this will usually capture any misdoings that you didn't think of when writing the specs, like let's say a Junior programmer coming in and using a construct in a way it was not designed to be used.
You can take the compiled binary, wrap it in a tarball and build with `rpmbuild`. [Here is a StackOverflow answer](https://stackoverflow.com/questions/880227/what-is-the-minimum-i-have-to-do-to-create-an-rpm-file#1165200).
Do Crystal binaries need supporting libs?
Only if you do dynamic linking, which I believe is the default, but don't quote me on that. Waj has written an excellent answer on [Stackoverflow](https://stackoverflow.com/questions/35166392/how-can-i-produce-a-crystal-executable-with-no-dependencies#35167198) for static linking with Crystal as well.
wut ?
Spam bot.
It would be really nice to have a standalone statically linked binaries for crystal apps. 
This was very very helpful. This was the most relevant code that made it click for me https://gitlab.com/Zatherz/magicjson/blob/master/src/magicjson/infect.cr#L3-29 Hopefully helpful to others as well. Nice work @Zatherz
An unstable language/compiler used in production, what could go wrong?
Could you please tell us in which areas you find it unstable?
Don't get me wrong, I love Crystal and have a bunch of projects in it, it's just that using a language which is at 0.23 for something as important as that seems weird.
Best spam ever.
`raise Vibrations`
Spam? I beg to differ...
Uh... check out description of this sub in the sidebar --&gt;
Sorry if the name seems misleading, but this subreddit is actually about a [programming language.](https://crystal-lang.org)
I wouldn't really call it unstable, rather untested.
I guess.
Looks like we have a good theme for the next April Fools, though.
Reprogramming cells with crystals. `require "homeopathy"`
Sorry, I can't read. That --&gt; is too complicated for me. But thanks.
Sorry, I forgot that some people own the universal truth.
Sorry, don't understand your language. I think that I've to reprogram myself... Let me get my crystal out.
Sorry, let us explain in terms you might get. Our chakras resonate in gigahertz frequencies. Our favourite mineral, silicon. We call our mantras "specs". We heal things by imposing our hands on a keyboard. In other words, we're software developers and this subreddit is about a programming language.
Hahaha are you talking about computer language? Why did you let me in? And why on Earth did you (crazy people) called this group crystal programming? Okay, no need to kick me out... I am leaving. Wrong place, my bad. My Apologies... still, you need crystals to make your computers work :P Bye and thank you for explaining to me in a language that I understand. 
It's called "Crystal Programming" because there's a programming language called Crystal, and hey, it looks like a honest mistake, so I don't think you have to apologize. Cheers!
Here is my crystal language. Now I promise I am leaving. Sorry, I left the door open before leaving so I could show you my crystal language. http://i.imgur.com/UvAJWwb.jpg
It was funny but now it just got weird.
Hehehe you are not alone. I was also here by mistake, then I saw the light!
Then bring your crystals and let's talk our language somewhere else. This place is full of weirdos! They don't actually talk crystal language but they use our babies on their computers! 
Hahaha you made my day! 
Exactly?
what the fuck is this garbage
Mind your language! If you are so smart and are in a group that is supposed to be for nerds why don't you read the comments before vomiting your rudeness? No one gave you an education? It was a mistake! Garbage is your language.
\&gt;implying
Quick question, are there any libraries that anyone uses for creating shell scripts with Crystal? 
The built-in [OptionParser](https://crystal-lang.org/api/0.23.0/OptionParser.html) is pretty useful. I’ve had luck with [at-grandpa/slim](https://github.com/at-grandpa/clim) too. 
&gt; A modern command line job processor written in Crystal that can execute jobs concurrently. **:rocket:** This doesn't seem right...
Founder of Red Panthers(https://redpanthers.co) Here. We have written crystal production code for our clients. The main category we use crystal is for a Local POS/API service for devices at the client location to talk to before going to the cloud. It improves the latency of our devices and not having an internet connection is not a deal breaker. What our application does: * Talk to local POS devices * Helps user records the sale * Keep a local record of the sale and item catalog * Sync with cloud when it has internet We are able to build an executable and package it to our client, making it easier to install for non-developers as well. We are able to put the full package (bootstrap theme, Javascript, etc) into a single executable. Hence our clients love it. And the response time is in the range of 10 - 15 Micro Seconds. Which meets our SLA requirement for talking with devices. Crystal right now is our go to tool when it comes to building an executable application or system programming (managing printers, readers, process-monitors, etc), or when our clients ask for API service with micro second SLA. Being a Ruby on Rails dev shop, also helped us to work in Crystal. I can ask anyone in my team to have a go at a crystal program and they love it. 
You should write an article or something about how you package up your crystal app. I would love to see that.
In the pipeline will do. 
Thanks.
My first blog. Glad to hear any feedback :)
I love it! I like when you wrote: begin..rescue expression which is almost identical to eg. C#'s or Javas try..catch. For non-rubyist is very useful.
I guess is well fixed now, just waiting round 15 Preview 3
Hello /u/IvoB I am the creator of [Crecto](https://github.com/Crecto/crecto) and core team member / contributor to [Amber](http://www.ambercr.io/) web framework. I work at [LI-COR Biosciences](https://www.licor.com/), a company that designs and manufactures biological and environmental research equipment. I have been using Crystal at LI-COR for about a year now. It has been used so far for various tasks: internal services, account servers, websockets communication between instruments and servers, etc. I'm not sure what type of information you are looking for but would be pretty awesome to be a part of this project!
Hello Nick, Thanks for your reaction and cooperation. You have Crystal already used on very different tasks, so that is particularly interesting. I am preparing some questions I like to ask you and I will be sending them shortly.
Done! I'm excited to see everyone's answers :)
Done as well!
me too
I made this a couple of months ago as a first experiment with Crystal. I already had an FNV library in Ruby and I decided to find out how portable the code was between the two - I have to say that I had to make minimal changes to achieve that. The only sticking point is that keyword args from Ruby aren't supported in Crystal syntax. I think Crystal has a lot of scope and can be a terrific language! A lot of good decisions were made early - choosing Ruby-like syntax, targeting LLVM for example. I would love to see the language grow in popularity and maybe I'd get to use it for work someday!
The site is unreadable on mobile. The text is off the sides and I have no scrollbars.
This list is clearly pretty inaccurate, judging by how crystal is position 32 and rust isn't even in the top 50. Even if crystal was actually higher than rust, which I highly doubt, it can't be by that much.
I like Crystal, but I think the same, currently Tiobe is very inaccurate. Languages like Elixir, Rust have had a big impact in latest months and not even in the list. Also the list shows Julia(backed by MIT) and Kotlin(backed by Jetbrains) at position 46 &amp; 41 respectively. Crystal at position 32 is just rare. I found IEEE list more accurate # =&gt; http://spectrum.ieee.org/static/interactive-the-top-programming-languages-2017
Well, TIOBE measures search engines. Maybe they are right and Crystal community searches "crystal programming" more than other languages. # =&gt; http://spectrum.ieee.org/ns/IEEE_TPL_2017/methods.html
~~Ah shoot, I forgot to include that for 1.0 I would really hope that static compilation would work so I can use this in embedded environments. And since this is built on LLVM, having a guide on how to cross compile to ARM from an X86 system would be awesome, but not necessary I feel for a 1.0.~~ Just saw the last question in the survey, whoops!
Well even if its wrong its good for marketing haha.
Isn't Kotlin more backed by Jetbrains?
Haha, this ranking method is highly inaccurate. They are basically just throwing the query +"&lt;language&gt; programming" at search engines and measure how many total hits are reported. But this initial value is just a wild guess, the search engine does not actually match all results and return an accurate count; it only retrieves the most significant results. The estimated total results are basically calculated from the combined base frequencies of "&lt;language&gt;" and "programming", meaning this is the upper limit of how many results might possibly match both terms. "+crystal programming" reports 250.000 results, "+rust programming" reports only 73.200. This relation is very similar to the one between the reported hits for "crystal" (1.160.000.000) and "rust" (240.000.000) individually. If you want accurate countings of search results, you need to force google to actually retrieve all results by clicking through the result pages (at least I don't know of any other way). Don't worry, you don't need to go through thousands of pages! It comes to an end very earl: "+crystal programming" yields about 200 results, "+rust programming" about 140 (the exact numbers can vary a little). This is at least somewhat accurate but still doesn't mean anything! The crystal results for example contain quite a few entries about esoteric applications with no relation to computer lanugages. Btw: "+java programming" has about 310 real results.
o.0 didn't test that. Fixed it. Thanks for the feed back :)
Just a few things: 1. file naming convention is `guessing_game.cr` would contain the module `GuessingGame`. `crystal init app guessing_game` will do the right thing and use the correct type name. 2. Typo: "GussingGame.cr" 3. By convention we use `# =&gt;` to document the return value (or output, in the case of puts) of a statement, not `#&gt;`. 4. You should add one to `rand(100)` to use 1-100. You note that the range is 0-99, but you should really fix that as you say 1-100 earlier. 5. It's good to introduce `begin` and `rescue` but you should mention that the optimal way to do it is to use `to_i?` to return nil if the string isn't a number. This could be done after you add the loop: just use `next unless guessed_number = guess.to_i?`. You could also use `unless` with `gets` to avoid the extra indentation. 6. I would use a more user friendly `"#{guess} is not a number!"` error message. And print it even after you add the loop: unless guessed_number = guess.to_i? puts "#{guess} is not a number!" next end Perhaps I made it a bit too complicated though. I think though that introducing the simple way and cleaning it up at the end could work.
Yes, It's. I changed my comment +1
I agree with your general point, but by the same token, note that Kotlin isn't even on the IEEE list. The truth is somewhere in between. I also think things like Elixr, Crystal, Kotlin, and Nim, have been getting a lot of attention, but as you say, a lot of it is just recently. So how you look at that is kind of debatable one way or another. 
Updated the article. I made a new section 'Refactoring' based on your feedback. I hope I fixed everything you mentioned. Thanks again for your awesome feedback :)
`rand(100)` is range 0-99 not 1-100. I was suggesting using `rand(100) + 1` and discussing that the +1 was needed to make the range 1-100. Also, the section on `to_i?` doesn't make it clear that the question mark is simply part of the name of the method, and not an operator or similar. A minor nitpick is that `gets` will only return `nil` if the input IO was closed, which necessarily means that all future calls will return `nil` too. Using `next` instead of `break` in the `gets` guard statement will cause you to enter an infinite loop if you use Ctrl-D (which closes the input file descriptor in the terminal). Apart from that, the new section's good! It's a good article.
It's a chicken and egg problem. Tools have to be used in production to have it be tested. I agree with your caution but also think stuff like this should be supported. 
I quoted you on the last nitpicking part, if that's alright with you. Thanks again for all the feedback :)
Sigh...spam 
Visual studio code is good
I just realize you wrote a lot about Julia, amazing +1https://julialang.org/learning/ Thanks you for be part of Crystal community.
There is already the quite frequently used: https://github.com/johnjansen/crystal-libraries-needed
True, but my suggestion would be to transfer that to the crystal-community org and continue with the great work. My idea is to create a decent set of shards maintained by the community, that's why I already added my shards to the crystal-community org and will continue maintaining them there.
The crystal-libraries-needed is now part of the crystal-community :-)
Thanks!
Please read https://crystal-lang.org/media/ and contact to https://github.com/matiasgarciaisaia 
I think the best way to sustain income is to make a product with crystal to generate money. Crystal is stable enough to produce software, maintaining it with newer updates might not be as bad either, but trying to sustain off donations is unrealistic and unpredictable. One minute you could be getting a lot of money and next minute people might lose interest in crystal because of the lack of community/libraries or simply features that they wanted added that won't be coming.
This sounds pretty interesting. Will have to give it a try.
One of the big issues with this is who gets the money. Do you divide it up by all the contributors? Do you weight it by lines of code? Do you somehow decide which contributions are more important than others. Maybe a bounty system would work better.
For the "permission" thing, I think we're probably OK with that, but shoot an email to crystal@manas.tech telling a bit about the project to be sure :) But I'd love to read that story :)
Perhaps you're missing some background. Manastech is receiving this money to pay for time for it's employees to work on crystal. All the contributors outside manas are working in the traditional open source way: for free because they want to.
The [guides](https://calebuharrison.gitbooks.io/crystglfw-guide/content/) are impressive. But... for things like text rendering, loading images, playing sounds, one still have to use other libraries (and make wrappers for them and add dependencies to a program). So IMHO it is easier to stick to CrSFML for now or create own "engine" that will use CrystGLFW as building block, hiding it's api under the hood.
I don't mean to rain on your parade, but it looks like the Crystal team is already working on [something similar](https://github.com/crystal-lang/crystal_lib).
You don't ! :-) In fact, libgen [is based](https://github.com/olbat/libgen/blob/master/README.md) on this tool, it just aims to make it more convenient to use in your projects.
And if you look at the latest commit, you'll see it was committed by OP.
Ah, got it. Looking forward to using this tool!
I don't disagree! I do think there's room for wrapping some of these narrower libraries, though. GLFW is attractive because it's so relatively lightweight. The more we can work as a community to separate concerns and encourage modular framework designs, the better. For this particular domain, Crystal is really hurting for a robust and idiomatic approach to OpenGL. That's my next project ;) For now I think you're absolutely right, though - CrSFML is fantastic, and definitely worth a look!
Technically, there *can* be garbage in our langf�Gf�GfHf=��wPf��f��F
The documentation is pretty terse but it's complete. I do think some tutorials would be nice. Can you give some examples of where you got stuck?
UPDATE: I got a proposal to move the projects to https://github.com/crystal-community, so I did. Invitations for Crystalium are no longer valid.
I don't have a Ruby background. Before Crystal I used to write code in C and Java. When I discovered Crystal a year ago, I found a lot of help in Ruby documentation. I think the low level parts (those that Ruby doesn't have) are the most undocumented. Embedded assembler, &lt;loc:&gt; and @[Type] instructions are some examples. Crystal is growing fast, next time we could see video tutorials, guides and more. Also a book is ongoing.
Related to a Crystal book see: https://www.reddit.com/r/crystal_programming/comments/6q5ryd/information_about_realworld_crystal_usage/
However the crystal-community was created with the same goal, so if anyone wants to add their repo, just make an issue in https://github.com/crystal-community/community and we will add you
Useful for VSCode extension https://files.gitter.im/crystal-lang/crystal/adcO/kemal.png
Using https://github.com/Papierkorb/bindgen for most of the work.
A historic event!
This is literally the most beautiful thing I've seen all day... THANK YOU SO MUCH!! I would seriously tip you Bitcoin right now if I had any.
dooooooope
Amazing!
I certainly hope that Manastech CFO level is not seeing Crystal as a net negative, but rather as an investment. Knowing how the CFO level typically thinks, I'm a bit skeptical, though. I know my company will start donating money immediately when a piece of Crystal software starts bringing in money -- perhaps even before. And we'll donate effort as much as we can. Hopefully others will too. Please keep working to have the donation side remain completely transparent, because otherwise this is just feeding money to a potential competitor instead of feeding money into a joint operation :)
&gt; The fact is; one copy and paste code from Ruby to Crystal and 90% of the time it will run with no errors. You can even run Crystal programs using the Ruby shell command and vice versa since the syntax is valid for both languages! Crystal has been distancing itself from Ruby for while now. That paragraph could have been a passable hyperbole a few years ago but not these days.
Thanks you! &lt;3
I think the next version of crystal will have ARM releases see: https://github.com/crystal-lang/crystal/issues/4719#issuecomment-322937863
Hmmmm, I can only hope!
It's a shame too. If the crystal team had maintained backwards compatibility or built some add ons to either translate ruby code or mimic ruby code crystal could be so much further ahead. I know it wouldn't work 100% and I know that some modifications are actually better than ruby (symbol to proc for example) but crystal gives up a lot by not being able to run ruby code out the gate. Imagine being able to port a ruby gem in an hour or two instead of weeks and weeks of eventually futile effort.
Maybe isn't too late for that, see: https://github.com/crystal-lang/crystal/issues/4864#issuecomment-325079394
Also, See http://public.portalier.com/raspbian Portalier is a core developer of Crystal.
I don't see anything in that thread that's relevant.
Yeah I've seen this &gt;Packages are available for the armhf architecture. I need it for Armv8 though :/ plus I might not be using debian and stuff, this is a pretty specific build for a specific "distro"
Yeah, my bad. I read somewhere about translate ruby code to crystal. But I can't remember where.
https://github.com/Papierkorb/bindgen A C++ binding generator for Crystal
Looks cool! Just as a friendly note: you say that when a program compiles it will definitely work, and that you only write tests for sql queries. I think I know what you mean to say, but just to be absolutely on the safe side, compiled code does not mean your program does what you might want it to do. For example a = ["Hello"] puts a[1] Compiles, but does not work.
Try this: On compilation device: crystal build --release something.cr -o something --cross-compile --target arm-unknown-linux-gnueabihf This will print a `cc` command and will create the file `something.o`. Copy this `something.o` file to target. On target, `git clone https://github.com/crystal-lang/crystal`, then `cd crystal` and run `make deps`. This will build the native library dependencies for Crystal. Afterwards, run this on target to link the object file: cc 'something.o' -o 'something' -rdynamic -lpcre -lgc -lpthread PATH_TO_CRYSTAL/src/ext/libcrystal.a -levent -lrt -ldl -L/usr/lib -L/usr/local/lib Replace `PATH_TO_CRYSTAL` with the path to the cloned `crystal` repository. This should create a `something` executable on the target. 
1remindme 4 hours
A great introductory series produced by the Crystal Team :) Awesome!
Also I'd point out def add_one(i) 2 + i end Compiles and works but is wrong :)
I see and agree. However, Tele is battle-tested, so it should work as expected :)
Sweet, I use this for Ruby sometimes so having Crystal support is sweet too
I think you mean to use a "!", not a "1", right?
Thanks for this contribution! A much needed contribution for the Crystal ecosystem. 
What's 'crystal-raw'?
Crystal's raw stdlib with no framework
Still slower than I would expect. Something seems wrong.
Yeah, we had a discussion about that here https://gitter.im/crystal-lang/crystal?at=59ae2088614889d475bfb5bb
Great release! What is the url for that techempower screenshot?
https://www.techempower.com/benchmarks/previews/round15/#section=data-r15&amp;hw=ph&amp;test=fortune&amp;l=i2ej5t&amp;c=4
I think it's a good thing to have a distinct syntax because the semantics are also very different from Ruby. It makes no sense to look like Ruby but do something entirely different. I'd compare this to JavaScript as a prototype-based language mimicking Java's class-based syntax for object instantiation. This makes it hard to get a proper understanding of JavaScript's object model of JavaScript - and most JS developers probably don't get it.
Hooray for a new release! Sad to see that the moving out of global namespace pull [request](https://github.com/kemalcr/kemal/pull/378) stalled though, that was what I was most looking forward to.
Crystal supports concurrency but not parallelism (yet). 
Nice, you are running out of full stack environments above you, and you are *right* behind the stackless crystal solution.
&gt;I think it's a good thing to have a distinct syntax because the semantics are also very different from Ruby. That's the problem. The syntax is not distinct. It's exactly like ruby. The semantics aren't really that different either. They are both object oriented languages which means they have similar semantics. I think they can deviate from that if they want but they don't seem to want to push into a more functional approach either so it will remain more or less like ruby. Having said that ruby is flexible enough to make it behave any way you want. You want prototypes? No problem, you want functional? No problem, you want a typing system system? No problem. There is a gem for that. 
https://crystal-lang.org/2016/12/29/crystal-new-year-resolutions-for-2017-1-0.html I think if this holds that you will see parallelism in 1.0 and probably the alpha/beta releases leading up to it. That being said 2017 is ticking by quickly.
Same error as the OP, I can't compile to arm because my LLVM was built without support
Could i use this language to make a game?
Yes, you can make games. See this repo that might give you some inspiration: https://github.com/geppetto-apps/ecs.cr I haven't worked on that repo in some time, but you might see the basic building blocks. I don't know if you're familiar with game programming from other languages, but i would recommend some other resources: - Game programming patterns by Robert Nystrøm http://gameprogrammingpatterns.com/ - Gamkedo on YouTube (especially Snake in 5 minutes) - Entity Component System (https://en.m.wikipedia.org/wiki/Entity–component–system) Those we're really insipirational to me for getting a practical introduction to game development. Edit: fixed title of book, added link 
thank you!
What's the 1.0 outlook and timeframe?
Do you plan any connection with ruby? Any clear roadmap? Can I use it now on production?
Are there any plans for making a binding for any GUI toolkit work with Crystal? Ruby sucks on that field. Even the simplest one ([nuklear?](https://github.com/vurtun/nuklear)) would be a great start.
I need windows support, when it come true?
An awesome QT binding is here: https://github.com/Papierkorb/qt5.cr#sample-code
Windows support is the most loved PR by far: - https://github.com/crystal-lang/crystal/pull/3582 - https://dev.to/crystal-lang/we-created-the-crystal-language-ask-us-anything/comments/lmb 
About Ruby &amp; Crystal see: - https://github.com/crystal-lang/crystal/wiki/Roadmap#shard-ideas - https://es.slideshare.net/AnnaKazakova/how-to-write-ruby-extensions-with-crystal About Crystal on production see: - https://github.com/crystal-lang/crystal/issues/4795 - https://github.com/crystal-lang/crystal/wiki/Used-in-production
Also see: - https://blaxpirit.com/blog/23/how-to-build-video-games-for-windows-using-crystal.html - https://github.com/oprypin/crsfml
See: https://dev.to/crystal-lang/we-created-the-crystal-language-ask-us-anything/comments/lnc
Yup. There's a few better working libraries, but I decided to try and write my own game framework [https://github.com/jwoertink/crono](https://github.com/jwoertink/crono). Feel free to check it out and help contribute for fun!
Any chance of getting official ARM binaries soon?
 Runtimeless anytime soon? Fullstack like Red anytime soon? Will I be able to write very DSLs and self modifying code easily? Can I create sublanguages to write dense code like with APL that use Unicode symbols in a Crystal low level language/thing? 
Nice work! +1
Follow discussion here: https://dev.to/crystal-lang/we-created-the-crystal-language-ask-us-anything/comments/m16
&gt; Runtimeless anytime soon? I think you can compile static binaries using `--static` flag, avoiding run-time requirements but generating bigger binaries. &gt; Fullstack like Red anytime soon? Red is a great work. I think Crystal is still more focused in language core. Some issues in Crystal about type system and parallelism aren't solved yet. So the community is finding use cases for crystal everyday making libraries and bindings. BTW, Red has a C lib, so I think we can bind Red too :) &gt; Will I be able to write very DSLs and self modifying code easily? I think so, It's one of the common use cases for Crystal, see https://dev.to/crystal-lang/we-created-the-crystal-language-ask-us-anything/comments/m1k &gt; Can I create sublanguages to write dense code like with APL that use Unicode symbols in a Crystal low level language/thing? I don't understand your question entirely, but I'm sure you can use inline Assembly in Crystal, also you can use macros and even create a whole language with Crystal, see: https://github.com/charly-lang/charly
Why doesn't type inference work with tap? class Bar def initialize @counter = 0 end def increment @counter += 1 end end class Foo def bar @bar ||= Bar.new.tap do |b| b.increment end end end
The inference rules don't fit all cases, yet. Crystal use these inference rules: 1. `@bar = 1` (or other literals), inferred to the literal's type 2. `@bar = Type.new`, type is inferred to be Type 3. `@bar = Type.method`, where `method` has a return type annotation, type is inferred from it 4. `@bar = arg`, with 'arg' being a method argument with a type restriction 'Type', type is inferred to be Type 5. `@bar = arg`, with 'arg' being a method argument with a default value, type is inferred using rules 1, 2 and 3 from it 6. `@bar = uninitialized Type`, type is inferred to be Type 7. `@bar = LibSome.func`, and `LibSome` is a `lib`, type is inferred from that fun. 8. `LibSome.func(out @bar)`, and `LibSome` is a `lib`, type is inferred from that fun argument. So, if you want you can open a new issue here: https://github.com/crystal-lang/crystal/issues
As workaround you can use: class Foo def bar @bar ||= Bar.new.tap do |b| b.increment end.as(Bar) end end See https://carc.in/#/r/2ohj
Awesome, thank you! I was doing explicit annotation but this is much cleaner. I will still probably open a ticket though.
Yeah, just posted in both to be incase anyone else knows or sees
Lots of questions: 1. The work on the core seems to have slowed down greatly, we used to get pretty regular releases and now nothing for a long time. What's going on? 2. How confident are you that you will be able to get compile times down something approaching Go? 3. Same as above but for memory. 4. What are your plans to enlarge the community. 5. What is the obstacle to having greater reflectivity in objects (being able to list methods, attributes etc). 6. Are we going to get profiling tools? 7. What are your plans for a good debugger? 8. When are we going to get good concurrency. 9. Have you guys talked with the Ruby team to see if you can join forces to produce Ruby 3.0 or 4.0 based on Crystal? I love crystal but currently I am afraid to use it production because I have fears for the long term health of the project. It seems like it needs a bigger set of core devs.
Thanks! It's been a fun learning project. 
Thanks you!
&gt; The work on the core seems to have slowed down greatly, we used to get pretty regular releases and now nothing for a long time. What's going on? I think the core team is reorganizing things to bring 1.0 to us. The community is growing fast and disscussions/issues/PR are getting bigger and harder to handle. &gt; How confident are you that you will be able to get compile times down something approaching Go? I think Crystal can be fast, just need a better review, see: https://github.com/crystal-lang/crystal/issues/4864 &gt; Same as above but for memory. Same as above answer :) &gt; What are your plans to enlarge the community. Community is comming from all parts of programming world, not just Rubyist. I'm not a rubyist and I love Crystal mainly because is a static/compiled language with easy syntax. So, I think Crystal is very friendly and will grow more after 1.0 &gt; What is the obstacle to having greater reflectivity in objects (being able to list methods, attributes etc). Crystal isn't a dynamic languages, so this kind of runtime evaluation doesn't exist. Metaprogramming in Crystal is reached using macros. I think macros are the hardest/useful thing in Crystal. &gt; Are we going to get profiling tools? I think you can use debugger and profilers as GDB/LDB and XCode (instrumments) to debug and profile Crystal binaries. However, Current support/documentation for debbuging/profilling is almost non existent but necessary. &gt; What are your plans for a good debugger? Same as above answer :) &gt; When are we going to get good concurrency. Cocurrency is already here via CSP model, but Parallelism is still work in progress. The core team at Manas is thinking in something similar to Guilds (Ruby 3) to archieve this. &gt; Have you guys talked with the Ruby team to see if you can join forces to produce Ruby 3.0 or 4.0 based on Crystal? I think this would be awesome, other idea is to transpile Crystal to Ruby just like TypeScript to JavaScript. ... However is unrealistic, currently I think is too late to redirect Crystal in that way :( Maybe we can have a good DSL to write Ruby extensions using Crystal. See: https://dev.to/crystal-lang/we-created-the-crystal-language-ask-us-anything/comments/lna &gt; I love crystal but currently I am afraid to use it production because I have fears for the long term health of the project. It seems like it needs a bigger set of core devs. I love Crystal too. Some projects are using it in production: - https://github.com/crystal-lang/crystal/wiki/Used-in-production - https://dev.to/crystal-lang/we-created-the-crystal-language-ask-us-anything/comments/lpa Also if you want professional support you can contact to Manas: - https://github.com/crystal-lang/crystal/issues/4795#issuecomment-320451463 - https://manas.tech/ Don't be afraid :) We are a friendly community always avaliable to help. - https://crystal-lang.org/community/
That didn't answer the question. What's the timeline.
Well, I think Windows support actually depends of community, some PR's about Windows are getting merged and the triple flag for Windows is already in master. So you can compile some basic code generating object file in Linux and linking using Windows Build Tools. So, I think we should have something before 2017 ends :)
There's an official raspbian repo: http://public.portalier.com/raspbian/
This is a limitation only for instance variables. Local variables will work with tap and other methods just fine. We won't be relaxing this requirement though, we need to know the type of all ivars before the rest of compilation.
tried that, was actually talking with snapcase and thought we might ask you later for some help, since we had errors building it and stuff with libcrystal.a and main.o
ask away, preferably in IRC
Well, Crystal's macros can also really alleviate the need for `send`; you can develop some pretty powerful metaprogramming constructs by generating runtime metadata, kind of like Qt.
So, here you are https://gist.github.com/veelenga/91fb751286b35f1b497f1a1c41228c06 It's just a proof of concept but is something :)
Pretty neat, do the macros handle dependencies the way they should for each called def? Because that might get me to write some crystal again after taking a break from it.
&gt; do the macros handle dependencies the way they should for each called def? I'm not expert in crystal macros, but you can ask to veelenga in the gist comments :)
Better way to deal with YAML, JSON, and database results. Right now it's awkward as hell to deal with data that might be messy.
I'm an author of that gist. Thanks for sharing, but I will not suggest to use it anywhere. Added new comments: &gt; it is inefficient and violates Crystal best practices. Does not allow you to pass arguments, does not work with method overloading and could have other limitations. Unfortunately, the compiler does not allow us to make dynamic calls and any custom implementation will be more like a hack than a usable solution. But if it does not, then there might be reasons for that... And maybe this is a kind of situation when better to find a different approach than creating hacky stuff... Crystal is great, and please try digging into it more! Just keep in mind, sometimes you have to do it in a different way than you usually do it in ruby.
Thought of one more thing. a=[String, Int16 ...] b=a.map{|k| k.new()} 
Maintaining the windows version would be a big undertaking right ? I am afraid if / when the Windows support happens it will require a lot of time from you guys to maintain and improve. Don't take me wrong I would love to see Windows port to happen but is this realistic in the long term ?
&gt; I really believe Windows should be a first-class target and that this is fundamental for Crystal's future as a language. The more native the better. I would ditch even glibc if it were possible (at some point it will be). [0] I think Crystal for Windows is a goal [1], so stay tuned :) [0] - https://github.com/crystal-lang/crystal/pull/3582 [1] - https://crystal-lang.org/2016/12/29/crystal-new-year-resolutions-for-2017-1-0.html
block_given? or similar macro would be a nice to have just to cut down on some overloading.
[selenium-webdriver-crystal](https://github.com/ysbaddaden/selenium-webdriver-crystal) may work for you.
One thing that wasn’t explained in the online book was the use of the `property` macro (and friends). I remember it was used in one of the code samples but it was never explained. I eventually managed to figure out what it did after searching for a while and looking at the source code that it was actually a macro inside the `Object` class. Also I got confused about why I should even bother writing a property for every instance variable that I want to expose from a class when instance variables are publicly accessible with `foo.@bar` anyway. I had to dig around in the GitHub issues to figure out that it was actually an internal feature that was not meant to be used.
it's just a convenience macro. A way to save you some typing.
Thank you! I put a link for this arcticle on project's README https://github.com/hugoabonizio/schedule.cr#usage :)
Great post!
I'm really looking forward to eventually using Crystal in production (I'm a subscriber to this sub, after all) but I'd like to raise a few issues with this post: On promise chain/callback hell: `async`/`await`mostly fixes this. It makes code readable again. On dynamic types: a complex app that's 15k lines of code would greatly benefit from TypeScript. It makes writing JS fantastic and pretty much exists for this reason. I have a huge preference for it over Ruby, which I swore by for years, and it would solve their issues and more. On lines of code in the new build (10k) vs the old (15k): I feel like this is a questionable metric, since everyone knows that your second time through a problem will always be more efficient. They'd probably have a similar LOC difference if they had rewritten again in node. On the lack of incremental compilation: this is a BFD if you ask me. An 8s delay after code change is pretty rough if you're used to things being snappy. No disrespect intended to author or anyone else. I don't think anyone needs justification for switching. The fact that it's working for them is encouraging and its hard to argue with its performance. I look forward to the day that I feel confident enough to dive into it in prod.
+1 for this! 
You could add/request it here, get a few more eyes on it https://github.com/crystal-community/crystal-libraries-needed
Looking at your code example, is that how people write user creation code? How are you handling user duplication, invalid json requests, etc... Trying to learn web dev the crystal way, so seeing any code is interesting especially nodejs style devs working with crystal.
You could also discuss it in the gitter channel which is very active https://gitter.im/crystal-lang/crystal
I don't think Crystal has built-in support for actors, so I assume first someone will have to write a time-sharing scheduler to implement actors on top of. Then yeah, it'd be thing. Until then, have you seen Pony Lang? It's probably more in line with your interests.
Thanks for the pointer @lewisinc
You bet! Here's a good talk by a guy who took Pony into production with his company (he's on the Ponylang core team) and his experience doing that. https://www.infoq.com/presentations/pony-wallaroo
Is there any work being done on incremental compilation at all?
Crystal author have discussed some topics here: https://github.com/crystal-lang/crystal/issues/4864
So the answer is no. They are not even talking about incremental compilation there. Actually it looks like they can't really fix it at all which is pretty sad.
Sypervisors provided by OTP, not the Erlang lang. Would be nice to have actor primitives in Crystal, but complex Supervisor-like stuff should be provided by external libs.
The link is not working for me. Anyone else? 
Awesome article, I liked the little nuances that really make Crystal shine :)
And in 2027: Ruby - Crystals main influence that no one remembers ;)
That is not nice. Sure ruby has a lot to improve but it is kinda rude to say things like this
I'd say it's a poor example. Tons of casting `xxx.as(Yyy)`, not good at all. Also, sad that it doesn't support autocasting, otherwise probably 100% of those casts would go avay https://i.imgur.com/zoYYK64.png
I know but I wanted to make it as explicit as possible and as close to Ruby code
Some time ago I meet https://github.com/ethagnawl one of the contributors to tmuxinator . He was kind of interested back then in a port to crystal to avoid some of the maintenance in the ruby project. I recall he mention that many tmuxinator users struggle with the ruby environment setup (since they were not ruby users). I don't know tmuxinator apart from that talk with him but if you want to create a terminal multiplexer you can check how to use the same lib they use https://github.com/tmux/tmux . There are also many wrappers on different languages, that's always helpful to compare how to do things. The .erb support will be a challenge, if want something like that there are other template engines in the crystal ecosystem https://github.com/veelenga/awesome-crystal#template-engine . Or you can support the basic interpolation at least. For exposing a cli you can check https://github.com/veelenga/awesome-crystal#cli-builders or even the built in https://crystal-lang.org/api/0.23.1/OptionParser.html
I didn't mean it like that. I love Ruby! I just think Crystal has a great future ahead 
What is your directory structure? Can we get a bit more information about the project.
Also, you seem to have a circular dependency file. You are requiring 'b.cr', which depends on 'a.cr' but 'a.cr' also depends on the main file 'fooable.cr', how did you see this working? Seems strange.
You are being overly optimistic. There are people working on an LLVM back end for ruby. There are people working on a JIT for ruby, there is the truffle project. The people who are working on those projects are deeply experienced and in the case of truffle probably amongst the best in the world and there is every reason to think ruby will get almost as fast as crystal in the next year. When that happens many people will probably abandon Crystal and go back to ruby to advantage of the ecosystem. If somebody wants a typed language there are dozens to choose from some of which are even faster than Crystal. You never know what's going to happen. 
I think crystal's folder structuring is interesting, when I was working on a framework I ran into a similar problem, but it seems like the crystal way is to require all your necessary libraries in the main module file. For instance: - src/module_name.cr - src/module_name/a.cr - src/module_name/b.cr - src/module_Name/fooable.cr Inside module_name.cr you'd require all the sub module&amp;classes require "./module_name/*" module ModuleName # module stuff here end Then you won't have to worry about the require issue and can just require the module file directly unless you necessarily have to deal with those files elsewhere like in test files, but the same applies. If that's the case then you'd just require each crystal file and you should be able to access the other modules without any issue. random_script.cr require "./module_name/a" require "./module_name/b" require "./module_name/fooable" blah = Fooable::foo or something like that. Someone correct me if I've messed up the explanation, but I believe that's how it should be. I'm a bit rusty. Edit: PS, no need to down-vote, this is a honest question that I had as well as a non-ruby developer had to learn by reading other project sources. Especially with the little C/C++ knowledge I had regarding headers, this is a bit different than that.
I believe that's correct yes, to give yourself less of a headache it would be a lot easier to include from the main, and just focus your class files on the classes themselves. Crystal actually even permits a wildcard ('*') , so you can actually do it just to the main folder and crystal will manage all of the imports for you ``` require "./some_dir/*" ```
This was the solution, yes. I actually found out about it after I decided to see how some other shards worked and saw that Spec2 was requiring everything in the main module. Thanks for the writeup though, I am sure this will help future confused programmers just as much.
Yes there was a circular dependency in the requires but I am not used to requiring files manually like this. The languages I have worked in (OCaml, Clojure) have automatically managed module-level bindings and hence I've not had to worry about requiring stuff explicitly.
 if @parent.is_a? AANode return @parent.parent end nil Also, pretty sure that in the example you linked, if `@parent` is `AANode | Nil`, then the cast in the `else` block *is* unnecessary
It worked for me.
I think it’s better to ask the developer himself in the repo issues!
+1 Nice! We need more ML stuff in Crystal / Ruby.
congrats on releasing this, looks well done. My only suggestion would be to have some test coverage for the project so that people can consume &amp; contribute with confidence.
Yes, crystal compiles to a single binary.
Awesome thanks. One more question - are you aware of any tutorials or github gists/projects that show how to build command line apps? I am looking into replacing some old perl/php scripts to deployable binaries... Thanks
Works for me too..
Couple of links I found just from searching [link 1](https://jclem.net/posts/building-a-command-line-application-with-crystal) [link 2](https://www.youtube.com/watch?v=Tpw1vcxw290) Also this section in awesome-crystal [https://github.com/veelenga/awesome-crystal#cli-builders](https://github.com/veelenga/awesome-crystal#cli-builders) 
Thank you
BTW, there are some RFC issues here: https://github.com/vladfaust/core.cr/issues, you can affect the way Core develops.
Next step i will cover the specs.
Yes and no. Crystal compiles to a single binary that can be easily run on another system with crystal installed. It is possible to compile with the proper links so anyone can run it, but it’s still a bit shaky for the portability. But obviously once crystal gets closer to a 1.0, this problem will go away and make it easier to distribute a single binary to be ran anywhere
Thanks for responding. So as of today, i can build a binary, but i will have to "bundle" the binary with dependencies to make it work on a target machine? Did i understand correctly? 
Yeah, basically. [Here's an thread](https://github.com/crystal-lang/crystal/issues/2003) that talks more about the issue. Depending on the system you're building from, you might get it to work. I wasn't able to on macOS. 
But it needs external libs to run that binary.
Hi, excellent project!, Can you add a GIF of your TPLink Lightbulb working?
&amp;. What this operator means? Is it native from Crystal?
Ah finally ArangoDB for Crystal, yay!
Noob here. Can someone explain why and how I should use this framework over let's say Laravel or Ruby on Rails? What would the benefits be?
It's for crystal. You are asking why you should use one language vs another language. 
I've never used Laravel so I can only speak to Ruby on Rails. Im my experience so far, crystal applications use FAR less resources than a Ruby (Rails) application, so you can get more done with much smaller servers. I've also experienced significant speed increases compared to a similar sized Ruby app.
Using a block will use the buffered IO. File.open("location") do |file| # file.read_char # file.peek # file.read(bytes = Bytes.new(10)) end
Perfect! Thank you!
`File`inherits from `FileDescriptor`which includes `IO::Buffered`. So in Crystal, file IO is buffered out of the box. You just use the API provided by `File`, it doesn't matter if it's with a block or without (though blocks are usually recommended, this way you can't miss closing the file).
Here's a handy chart on whether you should modify scrolling behavior: ***No***
[triggered](https://media.tenor.com/images/d213cc0fadd5b0aa5d088c2b8cd6dc47/tenor.gif)
Seriously though, if you're in charge of that website then please make that go away
We are removing it
Stronger, compile-time type checking without making coding a lot more difficult. Many other languages/frameworks achieve the first, but not the latter.
This is true but not the "right answer". From the IO::Buffered api doc page you can see that IO::FileDescriptor includes this type. This means that all file descriptors - including files, network io, and stdin etc are buffered by default. So just don't think about buffering, its done for you. Whether you open a file with a block or not or whether you're using a file or a network socket, its on by default.
Crystal handles non-blocking for you, just write blocking code in separate fibers and communicate using channels and crystal will use non-blocking code and select() calls behind-the-scenes. Further, you'll need a framework or some of your own code to copy messages received to every listening websocket (are you sure that's what you want?). This is sometimes called publish/subscribe or pub/sub. Does that make sense?
&gt;… &gt; &gt; ws "/" do |socket| &gt; &gt; udp_working = true &gt; &gt; while udp_working &gt; message, client_addr = server.receive &gt; socket.send message &gt; end &gt; &gt; socket.on_close do &gt; puts "Goodbye..." &gt; udp_working = false &gt; end &gt; end You want to run `socket.on_close` first, otherwise the event handler won't get added and therefor won't run until after the loop, but the loop is effectively infinite because of that. Also, there is a small chance that `socket.send message` will error due to a closed socket, if the socket is closed between checking the `udp_working` var and the call to `#send` 
Oh hey, didn't realize you posted this on SO as well. Consider my answer there the canonical one.
Thanks! I wasn't sure whether SO or Reddit was the best place to post the question - but the responses on both sides have been fantastic. I see now that the socket.on_close event should come first otherwise will never get called. I will do more research on Crystal's concurrency paradigm and see if I can improve things. Really appreciate your help.
I don't think you need to enable it, it should already work.
It doesn't seem to.
How is crystal supposed to be "as fast as C" if it doesn't even have TCO \*mumble grumble\*
Try passing `--release`, which should tell LLVM to enable those optimizations.
I have, the code is def test(i) puts i test(i + 1) end test(0) It dies when it reaches 65517, Invalid memory access (signal 11) at address 0x7fff534cbfd8
Unless things have changed, this is not normal behavior. I was able to run millions of recursions in release mode because, indeed, this comes for free with LLVM. In fact, LLVM performs sibling call optimization, of which tail call is a special case. I have to test with a recent version of Crystal and confirm your observation. If, indeed, this was explicitly disabled in LLVM, it deserves its own github issue.
...a bit later... Well, crap. I know that Crystal doesn't guarantee this optimization and leaves it to LLVM (best effort), but indeed, this very simple example fails.I am 99% positive that it used to work.
I have submitted a GitHub issue. 
It has tco, LLVM does tco, its likely just not happening in this test case because it never terminates. I've seen llvm do tco on recursive fib, which is even dual tail recursive.
I'd point to the fact that the loop never terminates as to why it doesn't optimize this.
 server.bind "0.0.0.0", 1234 Will bind to all ipv4 addresses.
 def test(i) puts i if i &gt; 2000000 puts "Exiting" exit end test(i + 1) end test(0) This also returns the same error.
In release mode? Interesting.
Yes, release mode.
is it possible to know which libs it needs when running said binary?
&gt; Also, what is the fastest way in Crystal to find the list of INET and INET6 addresses for the machine the app will run on? What do you mean by this? I don't understand the question.
I wouldn't get my hopes up; Asterite was clear, in the past, that this is not a core priority for the language.
Yup. It was closed. 
What is a core priority anymore? Incremental compilation? Multi threading? Windows support? Foster more efficient compiler? As far as I can see every major goal has been abandoned and the language is dying from neglect. 
I hadn't heard of raylib before! Gosh, a proper game library in crystal? I might start making a bunch of games now.
It's a raw C binding (so not OOP), but it works well (and I'm planning to take it further in a separate library)
&gt; It's a raw C binding (so not OOP) Well fix it already! :P
This is a pretty harsh assessment. While Crystal's blog seems to have slowed down, I checked and there are still daily commits on Github. I think the team may be focusing more on marketing, i.e. new website, etc. This is a good thing because for an open source project to succeed, it needs lots of attention. So, I would not make any assumption.
I think the more attention can be beneficial and if you look at my comment history you'll see that I have been vocally advocating for the language on /r/programming and other subreddits. But as of late I have grown to be more pessimistic about the language. They had some fine goal in the new years resolution but it looks like none of them will be achieved this year. This tells me there is something severely wrong. My guess is that the core team is simply not knowledgeable or skilled enough to pull them off because none of them were really that complicated. There is already some shards for multi threading for example and it's a puzzle as to why they don't try and fold that stuff into the language. Also having these features will actually get more attention than a web site. Why not devote some time to ARM support so people can use it in smaller devices like Raspberry Pi? Why can't we do a static build? Do those two things and you'll be attract some people from the Go crowd especially if you get incremental compilation. Get the multi threading right and you'll see it perform well in the techempower benchmarks which will attract more people. Right now ruby with roda performs about as well as kemal FFS. Sorry to be a downer but it's been a rocky ride with Crystal for me. It's still not that productive compared to Ruby and it's not as efficient or as fast as go. It sits in a weird space. 
&gt;The other day I reviewed some code that had a bug but neither I nor the author saw the bug. We wanted to reformat fax numbers to remove the US country code at the beginning. &gt; def formatted_fax_number &gt; # fax_number is a method generated by ActiveRecord &gt; fax_number.gsub("+1", "") &gt; end &gt;We deployed to production and got our favorite error: Undefined method gsub on Nil…great. &gt;With Lucky this bug would have been caught at compile time: &gt; # Define a model &gt; class Facility &lt; BaseModel &gt; table :facilities do &gt; field fax_number : String? # Adding ? Makes this nilable &gt; end &gt; def formatted_fax_number &gt; fax_number.gsub("+1", "") &gt; end &gt; end I'm utterly confused. Won't the first snippet error at compiletime because Crystal is statically typed?
is there any good resources to learn crystal?
I think they are comparing it to the same program written in ruby.
Thoughtbot are massive in the Rails community and are definitely writing this with an eye on Rails developers. I had never heard of Crystal until yesterday when I saw they posted this, and now I'm super, super interested. I love Ruby but I'm tired of its difficulty in scalability and its lack of type checking. 
We did an intro course with the folks at DailyDrip - that may be a nice starting point https://hackernoon.com/an-introduction-to-the-crystal-programming-language-b9e0222b5b5e
I started with a simple Kemal and MySQL rest api 
Crystal is more making a back end, while JavaScript runs client side and html/CSS design the front end and what the user see's
Looked awesome, minimal dependencies they say, but installation involves compiling library from 180M of sources (and resulting library depends on half the system), so well, it's not easier than CrSFML to distribute. I'll better wait for crystal Windows support.
So i need know front end stuff too to make web app and website?
yeah, pretty much
I ended up creating this as a quick need to help convert some CSV files to JSON so I could parse them into NDJSON with `jq` which then gets fed into `esbulk`. This is my first Crystal program. It's pretty ugly, but was extremely fun to code on. I still need to work on tests and clean up some duplicate code.
I heard these guys stole/"borrowed" a lot of code from Amber Framework. 
 module Csv::To::Json Maybe shorten that to CsvToJson or maybe CSV2JSON?
Well, Amber is based on Kemalyst, Kemalyst was based on Kemal and Kemal is based on Frank :) Amber: https://amberframework.org/ Kemalyst: https://github.com/kemalyst/kemalyst Kemal: http://kemalcr.com/ Frank: https://github.com/manastech/frank 
There's [`IO#read_bytes`](https://crystal-lang.org/api/0.23.1/IO.html#read_bytes%28type%2Cformat%3AIO%3A%3AByteFormat%3DIO%3A%3AByteFormat%3A%3ASystemEndian%29-instance-method) which allows you to specify a type and "byte format" (endian-ness). No idea if it's any faster though.
It looks like the GitHub page of AmberFramework has credited Kemal and a few others. I do not see the same thing on Lucky's GitHub page. I believe the Amber team also has one of the core contributors of Kemal on it. 
Ooh, something I might actually use. Also TIL amoeba is sometimes spelled ameba.
Yes, but ameba is intensional, since it is easier to write/spell. And it [should be also](http://wikidiff.com/ameba/amoeba) an alternative form of amoeba
Neat! Maybe not reading the full file but only enough bytes to have the full header would be a nice performance increase :)
That's a great idea, going to try pulling that off.
Reminds me of the [`file`](https://en.m.wikipedia.org/wiki/File_(command%29) tool.
You should be able to read DateTime columns with `rs.read(Time)`.
Speaking specifically about parallelism and windows support, crystal development seem stagnant at the moment from my point of view.
Crystal needs a "killer app", to be honest. Without that, it'll languish in obscurity. Every contribution, every new project, every new repo ups the possibility that there will be a hit and the language will take off. I can tell you right now that being a "launch language" when web assembly takes off would be a *huge* boon to Crystal, but I don't think that's going to happen, unfortunately.
I think Crystal has a lot of potential to become a really popular language. It has good momentum, but it needs to hit that 1.0 stage before it will see any serious usage. Movement in that direction has stagnated a bit as far as I can tell. Maybe the roadmap for 1.0 is too ambitious? Maybe the core team has burnt out? Maybe things are coming along swimmingly and they just aren’t communicating that? I do think the majority of the current momentum is in libraries being written.
it definitely feels that way. Nevertheless that have not stopped Ruby (for example) to become a widely spread language. Maybe the lack of a clear goal/timeline is a hindrance?
I do think that people is starting to feel comfortable enough with Crystal to start writing more and more libraries / shards. Still, at least I know it was my case, I think lot of potential contributors are waiting for this "more stable version of the language" to actually start working on the next killer app / framework. While this way of thinking might deserve its own discussion, I kind of understand it. I had some projects on hold for quite a long time, waiting for a more stable version of Crystal.... that I'm no longer sure it will arrive, and if it does, I'm not really sure if it will still be relevant. So I have decided to wait no more and see how it goes :)
True, Ruby has always had abysmal Windows support. On the other hand, recent languages that took off (go, rust) have wonderful Windows support, so for a language to establish itself now, it may be more important than it used to be.
Crystal needs parallelism, windows support, a book from the Pragmatic Bookshelf, and time to bake. Given time to bake, a killer app will eventually reveal itself; I suspect that may be when the tide turns against containers, and people are once again interested in distributable binaries.
In the latest 0.3.3 release `rs.read(Time)` will return values from Date columns.
That's a bit of a stretch. Go and Rust have both adequate Windows support but it's not something that's great or even usable for most of people (if you go beyond the "generic" use case). Crystal does not even have the "generic" stuff working.
I doubt that. Distributable binaries are nice to have but not a key to success. Containers are taking over whether we like it or not. Nowdays it does not matter what do you use and everyone and every big company out there has a lot of teams using myriad of technologies and they have to work somehow together.
In my opinion how Crystal should evolve. 1) reach 1.0, stabilize 2) add a reasonable parallelism support 3) focus on biggest painpoints raised by people on github 4) grow ecosystem by making "most wanted" shards. I am sure there's a lot of DB drivers,crypto,math,xml/soap libs that people want or need Postpone things that are too hard even for a multibillion dollar corporations to do right. 1) If there are not people solely working on Windows stuff. Postpone it 2) GUI libs would be nice but a multiplatform gui library is a huge undertaking and does not need to happen. Help community with QT/GTK bindings, electron etc 3) it does not need to be perfect from the beginning 
Problem with crystal is its terrible leadership. Overly elitist, protective and downright hostile at times, they chase away newcomers rather than embrace them. Language won't go anywhere unless they solve that. Look at Elixir on how it's done.
Is that so? I have no idea about Crystal leadership other than in my opinion there is little official communication. Other than that, every time I have asked Crystal community the response was rather welcoming and helpful more than hostile. Can you share any example regarding this hostility ?
&gt; Postpone things that are too hard even for a multibillion dollar corporations to do right. This↑↑↑↑
Same here. I have asked the authors some dumb questions and have found them to be very patient :)
 db.query "select id, name, weight, birthday from users" do |rs| rs.each do id = rs.read(Int64) name = rs.read(String) weight = ra.read(Float64) birthday = rs.read(Time | Nil) # if it is NULL in mysql end end
Someone should develop a killer open source blog like https://ghost.org
Distributable binaries are great for small devices and that's a field Crystal can have impact in.
I think he is referring to their hostility to feature requests and their general silence on almost everything. It's one thing to answer a specific question because the documentation is lacking but it's another to build a welcoming community to noobs. Having said that they really need to grow the core team to have people outside of Manas work on the core language. 
Adapted from http://mattwarren.org/2017/11/08/A-DoS-Attack-against-the-C-Compiler/ and Reddit comments
I use mostly Ruby professionally and Rust as hobby. Crystal seemed like a nice blend of both. I took a look at Crystal for a couple of weeks last month. My conclusion was that the language will not make it. Mostly based on the arguments others have already written, lack of communication, lack of movement forward on key issues. I can compare it with Rust where they made a users survey, they shared the results, core members had an open meeting, shared the notes, and shared the conclusions which became the goals for the language for 2017. Everything that happened this year is around this and the whole community was around this. I do not see that in Crystal, not even close to that and in an environment where multibillion companies are pushing languages (Go, Swift, C#) either you got that kind of focus to drive forward or you will not make it.
Did you file a bug on the bug tracker?
 s = StaticArray(Int32, 1000000).new Also breaks it IIRC
I'm not sure it's a bug, since other languages (e.g. c# and rust) also fail in that type inference, see: https://www.reddit.com/r/programming/comments/7bn21r/a_dos_attack_against_the_c_compiler_performance/dpjgfdg/
Sorry for a bit of necromancy, but what are your issues with Windows and Rust? I use it every day.
By Windows "support" i meant the ecosystem. Libs / pkgs for BizTalk,Servicebus,mssql, integrated security, msmq and a myriad of other things. Both Go and Rust have an adequate support for the win32 and other core things.
Ah, gotcha. Yeah, most of the stuff I write is cross-platform, so I don't miss those libraries, but I can totally see why they're useful. Thanks for taking the time to answer.
Don’t get me wrong, I love containers... but I think a big reason they exist is because we need to deploy things that are a mess of files spread all over the place. Compare deploying, say, a rails app to comparing a java war file... as much as I love rails, the deploy story took a step backwards around 2006-7 and containers are a way to reclaim that. Over 30 years I’ve seen cycles everywhere I look in this industry. In 5-10 years, people will rediscover binary file distribution, give it a new name (self-contained?) invent some Linux-like distribution and file location rules, and act like it’s a bunch of new ideas.
Go had a great support for Windows. 95%+ of the libraries work great, and most that don't would be easily fixable.
What you really mean is someone should beat Wordpress, which is a hard hard game.
You're acting like Rust isn't backed by a multi million dollar company though. Mozilla.
Make a constant, like API_KEY = "123abc" But remember that anyone who gets the compiled version also has the API key.
I would recommend to stick to environment variables, just have your release binary depend on them and set them with your service manager.
I think Mozilla is non-profit. But you are focusing on the wrong part of my comment. To me, Crystal core development does not seem to be able to engage the critical mass needed (and I understand there is a number of people in this very same subreddit, but to my understanding, not enough to move a whole complex language forward) and given the other several new languages targeting probably the same population, I don't think they will be ever able. Also they can not just pay their way out, so ...
This is the obvious answer; I actually thought OP was asking something else. If someone / OP wants to _package secrets_, then one solution is to encrypt the secrets data, and give authorized users a public-but-obscure API endpoint that returns the key or salt needed to decrypt. It's still not safe, as anyone that wants to decompile + shark the traffic will be able to get the secrets. However, its better than nothing. In the end, stick to environment variables.
That's cool actually thank you. Would love to see it added to official crystal environment.
Thanks, I really hope so but the maintainer has recently already closed the issue stating that it would be hard to maintain this feature for not having a proper solution and had lots of suggested complex features as the months goes by.[0] Meanwhile, I just created this program so that I can contribute to the Crystal community just a tiny bit and that my development process will improve by not just having to deal with YAML's. Indeed the task of adding something without to reformat the file is hard and I haven't seen any package manager that uses YAML had done this yet (for me i guess). [0] https://github.com/crystal-lang/shards/issues/144
I guess after reading all the comments on that issue that it would be better to be integrated within the shards command and not as a external tool that need to be installed. I would love to see your sharn add command as shards add. And since you already maintain sharn why not give it a try and submit a PR to shards :)
I wonder if this is a problem with an overly ambitious goal for 1.0 that made it seem like the language is not ready/not progressing. There are people going through issues, writing pull requests and committing things right now. Sometimes things go slower, and sometimes faster, but I think Crystal is already a wonderful improvement over a lot of languages. For me, parallelism and widows support doesn't matter, and I think for a lot of web developers that is true. Most apps are deploy on virtual machines that have 1 or less than 1 core and are instead scaled horizontally, and almost everyone is on Linux/Mac that Lucky is targeting. So I do believe Crystal could do better, and I'd love for it to have a stable API, Crystal is already quite good. I realize not everyone is a web dev, and needs/wants parallelism and Windows support, but my point is that for a lot of people, Crystal is *already* a wonderful language :D I do wish there was more communication and transparency outside of Github issues and PRs though. And I agree with a lot of the thread that it needs a "killer app" or framework. I'm *hoping* that Lucky can be a part of what drives that growth. I'm excited by how many contributions Lucky has gotten so far and I think it will continue to grow. Maybe it's wishful thinking, but I think Crystal has a real shot. I haven't worked with a language I like this much in a very long time. I plan to continue to support Crystal with my backing dollars and with contributions to Lucky and Crystal itself. 
It sounds like they won't take it. They don't like feature in the first place and the crystal yaml parser will reformat the yaml on round trip. The only possible solution is to get away from yaml or have the core developers change their mind about round trip yaml modification. 
True. It would be bad to not see this added to crystal environment though. Thanks again for your contribution I might try and fork it later on.
FYI. Not my code.
Sadly they won't accept it. Once the program is already stable, I might try to write my own package manager (not just a tool) to see if it can solve the problem i had with shards.
Thanks for Lucky by the way! :)
Hahaha yeah (+1)
That would be great. And eventually it will find it's place in the echosystem just like Yarn.
[removed]
Is TDB stored locally in a file then, like sqlite? Do you have any experience with NetCDF files? I'm curious if TDB would be a good candidate for unpacking and storing NetCDF data for easier querying.
:D
This looks pretty slick!
I have not found that to be the case . In fact I find the Elixir community to be VERY elitist. I don't think I have found a community that thinks it is the solution that solves all programming issues more than I have the elixir community. I thinks its completely understandable that their communication etc is not great at the moment. they are a language concentrated on trying to get to 1.0 I share the opinions stated before that they have tried to bite off too much for 1.0. windows should not even be a thought for 1.0
Ha! This is blog post that I wrote a few weeks back. Thanks @fridgamarator for posting it on here. Actually, I have to thank the members of this subreddit for their assistance with this weekend project of mine. I had to ask a couple of questions here with respect to how to accomplish certain things with the Crystal language, and always got really great, helpful answers from the members, so THANK YOU all of you!
Nice interesting blog post. I just saw it on hacker news searching for crystal related things and saw it wasn't posted here. Hope you don't mind me posting.
I don't mind at all, in fact, I am grateful. I debated whether to post it here myself, but thought that it might look like I am self promoting or bragging, so am glad that another community member thought it was good enough to be posted here. :)
Almost got me with that title there...
It's a common troll but the first time I've done it. I really am excited to see Crystal production-ready and am looking for my niche to help it along.
Browsing through the shards, I've been pleasantly surprised by the number of shards that already exist and that are equivalent to the ruby gems I would use.
Many are trivially portable from Ruby but some take advantage of Crystal's environment. Eventually we'll have a boot kernel and init system, undoubtedly.
I think a automatic tool for detect highly portable gems to shards would be very useful :-). A proof of concept would be searching for `send` and other crystal invalid code and evaluate the gem with a score of crystal portability.
Yeah, porting gems to shards isn't too hard :) I did a proof of concept here: https://github.com/faustinoaq/ruby2crystal This could be a tool to check incompatibilities between ruby and crystal code. 
Excellent! Are you going to batch process the whole RubyGems archive?
aha! so that's you in the gitter/irc channel :) Very cool tool
[removed]
seriously have to pay to watch the rest? okay....
I am glad to see thoughtbot playing with crystal. I hope they can contribute to the core team who seem rudderless at this point.
*Now* I remember why I don't subscribe to any Thoughtbot content or blogs; click the link for the teaser page, then click the link for 'Subscribe', and you have to authenticate (by GitHub or email/password) before discovering that it's US$29 *a month*. There are several sites well worth paying a third to a half of that a month for; unless you're on a corporate expense account, you'd have to be really, *really* sure you'd use thoughtbot's stuff *regularly* to make it worthwhile. Thanks but no thanks. I'd rather support people who believe in transparency and respecting the (prospective) customer.
I think is not that hard, would be an interesting project.
v0.2.0 has been releases. support body adapter and history of redirect. https://github.com/icyleaf/halite/releases/tag/v0.2.0
!remindme 10 hours
I will be messaging you on [**2017-12-01 06:19:57 UTC**](http://www.wolframalpha.com/input/?i=2017-12-01 06:19:57 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/crystal_programming/comments/7go56k/lucky_is_getting_bigger_and_better_announcing_v06/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/crystal_programming/comments/7go56k/lucky_is_getting_bigger_and_better_announcing_v06/]%0A%0ARemindMe! 10 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dqkorkv) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Lucky looks really interesting, thanks for creating it! A few questions: 1. Why Lucky over another Crystal effort like [Amber](https://github.com/amberframework/amber)? It seems like there might be similar goals shared accross projects. 2. Crystal-lang itself seems to be stalling in it's trip to 1.0, along with a pretty staggering list of [open issues(14%!)](https://github.com/crystal-lang/crystal/issues). Are there any concerns that this will put your efforts dead in the water? 3. What can community members like myself do to help prop up Lucky as a project, besides simply using it and submitting bug reports? I'd really like to see Lucky and Crystal take off!
Those are great questions! I'll try to address them in order. 1. There are some overlapping goals, but Lucky takes a pretty different approach to view rendering and handling actions/routes. The main reasons I did this is to ensure better type safety. This isn't to say that Amber isn't safe, it's that Lucky puts compile errors over runtime errors *really* high up on the list of priorities. You can see some of that on https://luckyframework.org/why-lucky/ and this unreleased blog post: (will be published soonish) https://gist.github.com/paulcsmith/bae83156448ee1db5b79ddccfcb49409. One thing that isn't prioritized as highly as in Amber is performance. Lucky is still fast, but if an API is nicer but slightly slower, I'll probably choose the nicer looking one even if it means a performance hit. 2. I don't have many concerns about it. Crystal is already better for my use case than any other language I've tried. It's fast, catches tons of bugs, and it is a joy to use. People are still active in the community and are contributing. I wish there were some more feedback from the core team, but I think they've just had to prioritize other paying work right now. Sometimes open source has slow points. I think Crystal is just in one of those ditches right now, but will soon get out. 3. Thanks for offering! There are some issues on the repos marked "help wanted." Some are harder than others, but if you want some help, feel free to hop on https://gitter.im/luckyframework/Lobby and I'd be happy to help. One of the most important things is building apps and blogging about your experience or writing things you've learned. Here's an example: https://blog.edwardloveall.com/a-week-with-lucky. Tweeting about what you like is also helpful :) Thanks for the great questions. I hope this answers them fairly well.
Thanks for the response. The Gist of the upcoming blog post did more for me to understand what Lucky is about than anything else I've read, so thanks for sharing that!
&gt; Why Lucky over another Crystal Honestly I hate this question. I've seen it asked a lot in other communities on similar topics. Unless there's a huge speed difference, the only reason to use a different framework is because they approach similar goals differently than other frameworks. That's the main reason why people write new frameworks, new languages. It's the approach to a problem, not the problems they solve which could be simpler because of syntactic sugar or cleaner because of the way the classes/code is organized. It's all subjective at the end of the day. On top of that, for a language so small variety is a good way to mature a language. Developers solve problems differently and approach code differently which in return helps developers learn from each other to write better code in the end. Variety is good, sharing libraries between frameworks is good.
Hi in the [docs](https://crystal-lang.org/docs/syntax_and_semantics/modules.html) they do it like this module Curses class Window end end Curses::Window.new Is this what you meant?
It depends. There are pros and cons for both. For example, with `module Example::Namespace` you explicitly declare `Example::Namespace` as a module, with `class Example::Namespace::Classname` you don't. It will also work if `Example::Namespace` happend to be a class. If you want to define multiple types in `Example::Namespace`, it probably makes sense to wrap everything in the namespace instead of repeating it every time. It's similar if `Classname` is supposed to inherit from `Example::Namespace::Baseclass`: If you use the long form, you'll have to repeat the namespace because you're not in the scope at that point: `class Example::Namespace::Classname &lt; Example::Namespace::Baseclass` vs `module Example::Namespace; class Classname &lt; Baseclass`.
Interesting, the part regarding repeating the namespace because you're not in scope is interesting. I also didn't know you could wrap a class with namespace using semi colon? instead of using end syntax.
Semicolon doesn't replace `end`, it delimits a statement in the same way as a newline character. The full example with proper formatting would be ``` module Example::Namespace class Classname &lt; Baseclass end end
I’ve always felt “just get something started”. There’s constantly this need to not push stuff up until it’s fully written and all this. I’m glad to see this approach finally getting up there. Get something simple working, then let people hack at it and add to it. 
`Announcement::BaseQuery.new.title("This is the title").first` it feels ugly and bloated compared to RoR. `Announcement.first title: "This is the title"`. Such guide would probably work as a deterrent instead of attracting new crystal users. 
Cool stuff! Hopefully by the end of next year we can have pretty complete support for windows! (And hopefully some official ARM binaries)
ARM and Multi core are much more important to me than windows support. I just don't think windows developers are going to venture outside of the Microsoft ecosystem to use this language.
Um, why is Lucky pegged against Heroku so firmly? I just tried to set up Lucky and it looked like local development has a hard dependency on an external service. I mean... why?
That's a great question, and it is one I want to address in the guides and in Lucky itself, but I haven't had time. Heroku CLI includes node foreman. Lucky uses that to run the Procfile.dev that starts the asset watched and the Lucky server. You actually don't *need* Heroku CLI to do that though. You can use foreman, forego, node foreman and do something like `foreman -f Procfile.dev` and it will work just fine. I chose Heroku first because it is really easy to install and because everyone at thoughtbot (where Lucky was developed) has Heroku already installed. It says in the guide that: "later Lucky will support foreman, and forego as well" That's still in the works, but I've prioritized other stuff. Feel free to use foreman or forego right now, you just won't be able to use `lucky dev`. You'll need to start the server manually `foreman -f Procfile.dev`
Well, kinda. You can’t distribute to Windows just yet. If the person running the binary has crystal installed, it’ll run just fine. If they don’t, you’ll need to do some linking, and there’s some issues on Mac with that. 
Only if they have the proper libs in place. Crystal doesn't do static compilation unfortunately.
We're sorry for the delay, hope you like the results :)
Interesting results - will be good to conduct the survey again next year and compare results. Maybe we will have a greater piece of the pie for production apps. Crystal is a delightful language and hope that it keeps growing in 2018. I'm planning to play around with Lucky over the Christmas break. Thanks for conducting the survey and publishing the results /u/sdogruyol 
Sad to see so few responses.
I discovered crystal *after* the survey closed, but I'll be sure to do it next year!
I've done several projects using Crystal and am subscribed to this sub, but I never saw the survey for some reason.
Other cons: * No multithreading * No windows support * Beta: still has bugs, api may change * Slow compilation, takes lots of memory, can't compile incrementally * Must use the GC (sometimes a con, sometimes not)
Thanks! Could you tell me when to use Crystal, and when not?
If you like the language and don't care about the downsides, go for it!
Windows native support is coming strong and relatively fast now it appears. It also does run on WSL if you want to run it on Windows presently.
You might look at this: https://www.tiobe.com/tiobe-index/ Crystal is growing insanely quickly right now, so as for adoption, it's happening. I've talked with a few folks at various companies and they are excited. One, for example at Nanobox, would love to rewrite their Go stuff in Crystal once Windows native is in place. I just cannot believe how Crystal has blown past Kotlin, Clojure, Hack, Julia, Erlang, Rust, Lua, D, Scala, and on and on in no time flat. It's gone from not even being in the top 50 six months ago to position 24 this month of November. Last month it was at 28 and in September it was at 31. It finally popped out of position 60 in August to 32 with TIOBE saying this: &gt;"Especially Crystal with its jump from position 60 to 32 in one month is doing very well. The Crystal programming language is a statically typed Ruby variant. Since it is compiled it is superfast and has a small memory footprint without losing the feeling of being easy to use. It seems worthwhile to give it a try." 
I don't think crystal ecosystem is ready for full blown production projects, but definitely my go to tool on personal projects. Given your experience with C you might find Rust language very appealing.
If you're writing an interpreter, crystal can certainly do that job and do it fast. And it'll probably be really easy to write. However it won't be absolutely the fastest language for the job. If you're writing a programming language for fun, crystal will be a great fit. If you absolutely need the fastest performance, you probably want rust (or god forbid going back to C++). Presumably since your language is running on a vm, its going to be a garbage collected language. Running a gc'd language on top of a vm in a gc'd language doesn't sound like the absolute best possible performance. For tooling however, I'm sure crystal will be great!
Thanks! How does Crystal compare to Haskell?
What's the logic behind rewriting go stuff in crystal? 
They're very different languages with very different goals and maturities. Crystal is object oriented and imperative, haskell is functional. You can do some vaguely functional programming in crystal, but haskell is truly different. It's hard to compare them to be honest.
In terms of elegance and performance?
I think the main impetus is that they just like Ruby/Crystal better. They feel it's more manageable, etc. I'm seeing that people really prefer Ruby as a language, but want the speed. A lot of folks have gone out and explored other languages, but never really feel "at home" or as productive.
And you might find using C with Crystal to be nice: • https://crystal-lang.org/docs/syntax_and_semantics/c_bindings/ • http://www.crystalforrubyists.com/book/book.html (scroll to bottom section "C Bindings")
&gt; I just cannot believe how Crystal has blown past Kotlin, Clojure, Hack, Julia, Erlang, Rust, Lua, D, Scala, and on and on in no time flat. I'd bet money on Crystal reports tainting the data.
The compilation issues are the ones keeping me from diving in. Do you know if any work is being done there?
Crystal is a fun language but.... Do you need to support windows? Do you need multi core support? do you need a rich ecosystem? if the answer to any of these is yes it's probably not for you. Your project sounds interesting though. Can you tell me more about it?
Dang. My project was mainly created 1. Out of inspiration from Pharo 2. Lack of a good language that fits my needs I did a couple of horrible preliminary implementations in C++, and gave up on all of them.
It's a difficult issue to solve: https://github.com/crystal-lang/crystal/issues/4864
"Crystal has blown past Rust" Now think again if TIOBE is a good source Otherwise, Crystal has a bright future if windows support arrives one day
Exactly this. Crystal being higher than rust simply means the source is wrong. Its impossible. Its simply not true by observation!
Crystal and Haskell are elegant in different ways. Without you trying Haskell I can't say which you would prefer. In terms of performance, crystal will probably end up faster by a bit.
Thanks a lot Serdar hocam :)
No, TIOBE is a bad source because of an obviously naive and weak methodology, there are many articles and discussions about that and most people in language subreddits don't take it very seriously : ) Crystal being higher than rust was simply an example of that. I love that it's becoming more popular, just think there are objective ways to demonstrate it's becoming more and more popular (projects done with it, companies that use it etc, os activity)
Oh yes, I know that the methodology sucks, I was just saying that Crystal being higher than Rust is just so clearly wrong it's easy to see the methodology sucks by inspection.
I am sorry, it just sounded very ironic :D (but I hope you guys go up for real)
Hah, reading it again it kinda does sound that way. I was making fun of how bad it is, not you!
No problem, fun is fun!
I disagree, TIOBE is a good source. I've looked into the other sources and they don't seem to be any more reputable than TIOBE is if you look closely. Rust is ONLY really popular because of the stupid Moz foundation's evangelization efforts. They WANT Rust to be popular. Personally I don't like Rust and I know a lot of other folks with very similar feelings.
A big question is do you REALLY need multi core? A lot of times you don't really need that as Crystal is still blazing fast. Also, Windows support - it's already there if you can use WSL, but if not, it's coming as per [this](https://github.com/crystal-lang/crystal/pull/3582#issuecomment-348035110). Rich ecosystem is rather nebulous and you might have to actually judge that for yourself based on documentation, existing tooling, and the Gitter/IRC communities... Get out there and chat live with some folks before making a decision and play with the language. You might be surprised.
I believe Rust popularity is artificially inflated, especially by moz foundation's proselytizing. Ultimately I've heard some very convincing arguments that TIOBE is a far better resource than any other option currently available.
That's clearly bullshit, rust is past 1.0 and just by looking at the number of github repos and the momentum of their repositories, crystal is more than an order of magnitude less popular. 
LOL, let's not bring a version number into the argument... :D
It's not just a version number it's a commitment to stability, and it means a lot to a lot of companies. If you want to believe crystal is amazing and everything else is bad, so be it. I choose to believe we still have a lot of work to do, which I thhink is a much more realistic opinion.
I think you're very emotional in this statement. If you want to believe that Delphi/Object Pascal is more popular for new projects than Ruby and Go, and that Scratch beats Swift, go ahead. You might hate Rust and their marketing, but you should be objective: Rust is at least a magnitude more popular(I am a Nim guy, I can see the things from your viewpoint) I agree that Rust's hype makes it seem inflated, but be very careful here: it beats C++/Python etc in level of hype, and still nobody argues actually Rust is more used than them. There are objective metrics: contributors, github projects,libraries, blog posts etc. And yes, Mozilla's marketing helps, but it helps to expand its usage, not the illusion of it
I agree with you there. I just think that things otherwise are overinflated re: Rust. 
I don't think emotion is driving my statement. I actually prefer straight Ruby and I have some beefs with Crystal. I just want things to be balanced and I feel very strongly that Rust hype is just that. There's a lot of money behind Rust atm and I don't like where it's going... neither where it's been. Unfortunately all of the other language benchmarks that exist are also either slanted, dated or wrongfully influenced. I'm just saying that I think TIOBE (based on their own outline of source material) is better than the other options we have. I also don't think that the GitHub info is that objective based upon timelines and contributor counts, etc. 
Sure, there's a lot of hype. But the fact and the hype both agree that rust is a much bigger project from a much bigger company with a much bigger community.
I don't know if TIOBE is better, but that doesn't matter, as it often produces wrong results. Even if TIOBE was the best language ranking tool we had, that would just mean we have **no** good language rankings There is a lof of money behind * Java * C# * C++ * Typescript * Go * Swift * Kotlin That doesn't mean a thing. Haskell had/has big hype and seems inflated based on this, and who financed that? The reason there is so much hype for Rust is that it's the most popular alternative of C++. (I am talking manual memory handling, deterministic execution, etc: stuff that a few other modern languages might also optionally have: D, Nim, Pony etc, and not Crystal, Crystal is just targetting different niches). Also it has the borrow checker which while a bit heavy and non-friendly can evolve in PL into something very useful and common 
Really? That's amazing, because so much effort, time and money has been put into Haskell.
A lot of money trying to optimize away their everything is immutable design. When you have to create to mutate, everything in general is a lot more expensive. Its just that we chose a more traditional architecture and can utilise traditional compiler backends to do what we want.
Aah, true. Makes sense!
Multithreading *is* planned right?
Cool. Not everyday I go to a website claiming to support "x" languages and Crystal is one of them!
Tell the Nim folks they're on deck. 
Just attempt a [JSON.parse](https://crystal-lang.org/api/0.23.1/JSON.html) and [rescue](https://crystal-lang.org/docs/syntax_and_semantics/exception_handling.html) any malformed entries.
Yeah. I can do that, But I wanted to validate the above "schema". I guess I can always just walk it in crystal. But representing it as a type is much more interesting.
Heh. I noticed that, too.
Yes, it's been planned for awhile.
A friend of mine told me about it when I was looking for learning exercices for Crystal. It is very great, and in addition, after submitting a solution, you can see other's solutions. It showed me some best practises, and simpler ways to do things (example : using regex when Crystal has a bunch of functions to check strings).
Then try [mapping macro](https://crystal-lang.org/api/0.23.1/JSON.html#mapping%28properties%2Cstrict%3Dfalse%29-macro)
The compiler itself is not extensible. The more related think I can think of is what is done in playground https://github.com/crystal-lang/crystal/blob/5fd965e999bec40ff3ae9af1493d113cc9677419/src/compiler/crystal/tools/playground/server.cr#L16 There are AST transformers and visitors to do manipulation. Then you would need to print the AST and compile it. That works fine in playground because the source is a single file. But for profiling, if you aim to instrument more than one file it might be not that trivial. Another approach I did in the past was to manipulate the AST before using the compiler internal classes https://github.com/bcardiff/afix/blob/master/src/instrument.cr . Here some lost regarding compiler flags occur because I didn't call the full compiler chain. But was enough to lookup for some particular ast pattern (integers assignements) and instrument them with manual built ast. A third option, is to fork the compiler and add the transformation in the compiling process. This would look similar to the previous one regarding AST manipulation. Then you would need to compile this crystal-with-profiler compiler and use it on the target program. Note that some instrumentations require the result of the parser only, some would require expansion of macros, some would require the type inference to be done, etc. Depending on the needs, you should hook to different part of the compilation process. https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/semantic.cr might offer some guidance to the internals of the compiler. For https://crystal-lang.org/2016/02/18/buenos-aires-crystal-meetup.html I made a small sample: https://github.com/bcardiff/crystal-tool-demo (probably outdated Apr 2016). Some technicalities why this is not done in crystal is due to the lack of dynamic library loading, that would be needed to make some sort of plugins.
Nice tip. 
Yes, it's stored locally like SQLite. I'm unfamiliar with NetCDF, but I've considered making Crystal bindings for HDF5, another file based general data store. Any sort of time series data should fit nicely for TrailDB. We use TrailDB at AdRoll mainly to densely store events for posthoc analysis.
Yes, it's stored locally like SQLite. I'm unfamiliar with NetCDF, but I've considered making Crystal bindings for HDF5, another file based general data store. Any sort of time series data should fit nicely for TrailDB. We use TrailDB at AdRoll mainly to densely store events for posthoc analysis.
In my experience (tried to run binary on fresh OS install), no, because they would not have needed libraries installed. I would like this to be possible though...
Besides system libc, I'm not sure what dyn. libraries are required. Depending on what shards you add this list could be bigger. I'm not sure if the compiler has flags to generate totally independent binaries (static linking). You can check the libraries dependencies with a command. On Linux you can check the dynamic link libraries with ldd command. On Mac I think is with "otool -L ".
Is possible but you need to check binary dependencies first. For example on Linux: ``` ldd mybinary linux-vdso.so.1 (0x00007fffde98a000) libpcre.so.1 =&gt; /usr/lib/libpcre.so.1 (0x00007f1defbb4000) libgc.so.1 =&gt; /usr/lib/libgc.so.1 (0x00007f1def94a000) libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007f1def72c000) libevent-2.1.so.6 =&gt; /usr/lib/libevent-2.1.so.6 (0x00007f1def4d6000) librt.so.1 =&gt; /usr/lib/librt.so.1 (0x00007f1def2ce000) libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007f1def0ca000) libgcc_s.so.1 =&gt; /usr/lib/libgcc_s.so.1 (0x00007f1deeeb3000) libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f1deeafb000) /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f1df00d6000) libatomic_ops.so.1 =&gt; /usr/lib/libatomic_ops.so.1 (0x00007f1dee8f9000) libcrypto.so.1.1 =&gt; /usr/lib/libcrypto.so.1.1 (0x00007f1dee47c000) ``` So, I can copy these libs to client machine without installing new dependencies or crystal compiler. A similar method is used to create mini docker containers for running crystal binaries, see: https://manas.tech/blog/2017/04/03/shipping-crystal-apps-in-a-small-docker-image.html
Thanks for checking and I second your feelings.
Most binaries come with a list of dependencies, so don't let that scare you off. That's what package managers are for. In the short term I'd suggest bundling everything you need into a Docker image.
Depends on the llvm version too
I got bored at work: https://gitlab.com/snippets/1689690
And again, those “20xx will be Crystal year!” 🙃 Love your work though. Thank you and a happy new year! 🎉
In case you missed it, this is a response to [recent Hacker News comments about Crystal](https://news.ycombinator.com/item?id=15945262). 
Welcome to the real world :P
Negatory - I swapped mail with a core member over a week ago and they tipped me off this plan and announcement were coming.
Rust can expose a C interface and you can use bindings to that in Crystal.
Thanks, this is exactly what I was looking for! Declaring a rust function #[no_mangle] pub extern "C" fn hello() { println!("Hello world!") } and building a shared library did the trick.
Awesome! Great job to all those that made this happen. Happy Holidays.
👏🏻
good job
Thank you team crystal!
As you probably know Crystal is a statically type checked, compiled programming language. More on the topic on their site https://crystal-lang.org/ It’s still in Beta, last stable version is 0.24.1. We've built two applications, the first one is just API, the second one is redirector, which is incredibly fast — redirect may happen in hundred nanoseconds even with DB connection. Here's the link to the service http://to.click, feel free to comment if you are interested in more details. Also we have two bots: http://clc.to/bot for Telegram and Slack app which is currently unavailable for public, but surely will be later on.
Wow, works amazing!
Literally a blank page when I load the site https://pastebin.com/Mr2TyFEH is the page source for me, not sure if the servers overloaded or what
works for me
working for me too now
Probably deploy issue, sorry for any inconvenience %) 
May I ask what did you use as the web framework?
We would like to make sure that widely used services is fast and reliable enough, so we decided to use Crystal lang. The very first question was what to start with, there’re two popular frameworks named Kemal https://github.com/kemalcr/kemal and Amber https://github.com/amberframework/amber but both of them seemed too heavy for the quite simple task, so the first thing we did was a try to use low level functions to build routes and handle requests, it worked but seemed ugly so we decided to migrate to router.cr https://github.com/tbrand/router.cr as a quite light weight solution that fit our needs. Nevertheless Crystal is not in production stage it's stable enough, we faced several issues with DB but all was solved quite easily. For public frontend we use ReactJS. Private hub is built with Ruby on Rails as we've quite wide experience with it.
We would like to make sure that widely used services is fast and reliable enough, so we decided to use Crystal lang. The very first question was what to start with, there’re two popular frameworks named Kemal (https://github.com/kemalcr/kemal) and Amber (https://github.com/amberframework/amber) but both of them seemed too heavy for the task, so the first thing I did was a try to use low level functions to build routes and handle requests, it worked but seemed ugly so we decided to migrate to router.cr (https://github.com/tbrand/router.cr) as a quite light weight solution that fit our needs. Nevertheless Crystal is not in production stage it's stable enough, we faced several issues with DB but all was solved quite easily. For public frontend we use with ReactJS. Private hub is built with Ruby on Rails as we've quite wide experience with it.
Hey, great that you want to try Crystal. It's really an amazing language and I hope you get to know it well ;) I'll try to answer your questions as far as I know: * I don't think Crystal is explicitly intended for realtime applications, but it surely can be used for this. I'm not too familiar with how the GC behaves exactly, but maybe you might wanna take a look at the implementation in `[src/gc/boehm.cr](https://github.com/crystal-lang/crystal/blob/master/src/gc/boehm.cr)`, which is mostly just bindings to LibGC. Boehm GC is considered to be *good enough* for the current state of Crystal's development but it is clear that it will need to be replaced eventually, probably by a customized native-Crystal. There is an issue currently discussing the use of [immix GC](https://github.com/crystal-lang/crystal/issues/5271) which is used by scala-native on LLVM. You can also disable garbage collection entirely (`-Dgc_none` compile flag) but this obviously won't work with the stdlib (there was some project working on a minimalistic stdlib for embedded use, but I can't remember what it is called). It should even be possible to use a custom GC for specific requirements. So, currently, there is certainly room for improvement, but the maintainers are aware of this and there are ideas how to develop further. * Crystal's macros are very powerful and you can do almost anything with it as long as it generates valid code. The macro interpreter provides a limited set of operations to modify the AST directly. For more complex code you can embed the output of any executable (for example a Crystal program generating code). * Crystal essentially uses the same concepts as Ruby: blocks are essentially anonymous functions, they can be used for higher-order functions. You might wan't to take a look at the [Iterator class](https://crystal-lang.org/api/Iterator.html) (and Enumerable) which provide methods like `map` etc.
Also you can disable the GC for sections of code if you want by wrapping it in `GC.disable` and `GC.enable`
Fantastic. Thank you for your detailed answer.
I'm the author of Kemal :) May I ask why it seemed too heavy? 
The framework they linked has fewer lines of code than your readme. Kemal is not simple enough to bug free, and not complex enough to be a full framework. I guess that's their rationale.
Thanks RX, yeap, that's it, we don't need full fledged web server, we need tiny error prone server that can handle 2 routes and respond back — nginx + router.cr makes this pretty good.
Can not sign up. Error :change was rejected 
FYI, I had to comment out: &gt; (spacemacs|defvar-company-backends crystal-mode) from config.el, otherwise Spacemacs would break. FYI, I'm running Emacs25 with the Spacemacs develop branch.
Just fyi, I don't think you mean "error prone" there.
source?
The image comes from an article[0] while the source data comes from [1]. [0] https://stackify.com/popular-programming-languages-2018/ [1] https://www.indeed.com
Huh, where is rust?
Wondering why scratch is there lol
I created a new develop branch to fix your feedback problem. The master branch and the develop branch of spacemacs are slightly incompatible, causing it to not work properly. Thank you.
From their methodology &gt;We took the 50 most popular languages from the Tiobe Index and searched for “(“Language name”) Developer”. Searching for "Crystal Developer" for me gets loads of results for Crystal Reports, so I think these results are very misleading. Either way, it doesn't pass the sniff test: - it's a metric related to maturity - we're not being beaten by popular languages which are post-1.0 (rust)
A reassuring post to start off 2018. Crystal is "good enough" at the moment. That is to say it's not perfect and there's room for improvement but at the same time, you can build useful stuff with it.
*suite
great
Its actually much more than this now, perhaps 45%. The port's actually going fairly quickly.
I wish i knew how to help with this. maybe one day
Same
It's not even that difficult (at least not all of it). I managed to get the time implementation ported rather quickly. Didn't expect that, especially considering I have 0 experience working with Windows APIs and only little C programming skills at all.
Thanks, that means a lot to me.
I've had this bizarre notion to slave a Ruby instance to Crystal for runtime interpreting. Then I think about using v8 and Opal and I laugh and laugh and find something else to do.
Thanks!
Take a look at this post that explains some benefits of Amber https://medium.com/@eliasjpr/amber-crystal-web-framework-1d76f5abfe2b
Hello, probably you will get a much more helpful reply if you ask those questions on their gitter https://gitter.im/amberframework/amber :)
Hi, amber developer here, amber console was removed because is was very experimental, so we decide it's not suitable for amber projects yet, see: https://github.com/amberframework/amber/issues/352
yeap, thanks, meant error free :)
can you please specify browser and OS? in general it works good, but we see csrf protection error for your requests
Worked now. Thanks. (android Chrome) 
&gt; Any natural way to make nested/nested routes? See scoped routes here: https://amberframework.org/guides/getting-started/routing/routes.md#routes
Sweet. Is it meant to be pronounced like the name "Oscar"?
I am pretty sure `crystal deps` will be removed in the next version of Crystal, fwiw https://github.com/crystal-lang/crystal/pull/5544
&gt; Make sure you have `require "markov"` in your code This was the issue. I had used the command `crystal init app markov_chain` . The line was `require "./markov_chain/*"`so I understand how that came about; I figured it was pulling all in from that directory like a relative import in pythonese?) I changed it to `require "markov"` and it worked. In any event thanks for the pointer and I'll be mindful of similar in the future! 
&gt; In the end, Lucky uses one class per action because ... it helps to stay clean and focused yea, reminds me &gt; I have to kill fast and bullets too slow! Said John Freeman. And started killing Combines with bare hands
Please keep the hype in check: this is very much an experimental project, it may never replace the bdwgc we currently use.
I am very excited for this.
I have been following some people in the data driven movement and I am curious what you think about having a GC optional? I don’t even know what that would look like. 
Starred
Crystal IS production-ready. I have several web products live, and both their uptime and performance are awesome. However, IMO, you have to dive too deep into Crystal to make things work smoothly - I speak about macros, workarounds because of unstable API, lack of shards and questionable level of code quality in some even quite popular libraries. From my half-a-year experience, Crystal is not newbie-friendly yet. The good news is that it needs good high-level shards only to solve this issue (is it an issue? 🤔), and it’s just a matter of time. My opinion after six months? I still think that Crystal is the best programming language ever. Thank you, devs.
I am starting to convert my nodejs game server over to Crystal now, after seeing the kemal websocket benchmarks. About 30% done (10k lines of code left), and it's been a blast. WSL w/ Crystal has been a joy to work with because I can also alt-tab and enjoy gaming, or code. Can't wait to see what the future holds. And the community in general has been EXTREMELY helpful. 
Learning about people using it in live projects was one of the reasons why I wrote this article. I've been playing with Crystal for quite some time already, but when it came to creating a new product I always took the "safe option" (Rails, Node etc). I guess I'm convinced now that it's ready to use in the next project
The biggest problem crystal faces right now is dearth of libraries, and dearth of documentation. The official docs are pretty good, but there is no rubydocs.io or hexdocs.pm equivalent, which I can just point at a github repo and view the autogenerated docs for a project. I've been using it mostly to replace small little CLI scripts I used to write in ruby/bash. Its absolutely wonderful, and when I manage to get statically linked binaries working, its basically perfect
But there are so many languages that don't use semicolons. 
Wow, thorough. I'll definitely pull this down and play with it. Did you mean rails-esque, by the way? :P
I did. Changed it in the readme. Now I feel embarrassed.
Why use a router in crystal when the one Comcast gave me works fine? The monthly fee is what gets me, but I mean.. github has a paid private repo so I guess that's comparable. Still, with that said, not sure I understand this.
... these are not the droids you’re looking for.
Really wish crystal could add NPM support, natively. With electron, if possible.
Don't know why this got downvoted. Your name says it all.
I don't think it will be production ready until a sizeable company adopts it. 
Nope. It lacks stable 1.0, no windows support, no parallelism, very small ecosystem, very small dev team and very few job opportunities out there, *Production ready* C#/.NET/.NET core Java JS Ruby Python *Production ready RC 1* Go *Almost production ready use at your own risk* Nim *Not production ready* Crystal
What exactly do you mean there? That's a lot of different languages/technologies. Where would Crystal fit in?
Nice! I hope crystal gets popular in Korea. For some reason ruby never made it big in Korea. Maybe because it is considered japanese but i know that koreans mainly use python,java,c#, c++ and nowdays rust is getting popular.
How do you know about ruby in Korea?! Are you living in Korea? :) I hope crystal gets popular too. 
Rule number one of crypto club: don’t roll your own!
Thanks! Just rolled this in to production for our user passwords. It works great, and password recovery is fast.
Why might this be better than 3ROT13 (not to be confused with ROT13)? Someone ELI5?
I've never used 3ROT13, so I don't know exactly, but I can say that since this rotates by 26 characters instead of the standard 13 it's also twice as secure
I love you guys. Best programmer memery I've seen in awhile
I will be sure to take this into account. Maybe by allowing you to specify your own character range.
I was scanning saramin for Ruby/Rails keywords some time ago and did not get many hits. Also the Rubymotion developer Laurent mentioned Ruby was never big there.
My understanding is that 3rot13 encrypts with key1, decrypts with key2, then encrypts with key3. Key1 and key2 must not be the same, and weak key checks are also performed. 
That would be great. I literally just ported the code from the Rust library so there are definitely things that could be improved.
Were you thinking something more along the lines of this? ``` String.build do |str| input.chars.each do |c| if 'a' &lt;= c &lt;= 'z' str &lt;&lt; (((c.ord - 'a'.ord + amount) % ROTATE) + 'a'.ord).chr elsif 'A' &lt;= c &lt;= 'Z' str &lt;&lt; (((c.ord - 'A'.ord + amount) % ROTATE) + 'A'.ord).chr else str &lt;&lt; c end end end ```
Honest question: Why is it inefficient? I know nothing about Crystal, but apparently their iterators are also lazy, just like Rust's. Is it because it doesn't pre-allocate?
3ROT13 is slightly more secure than a single ROT26 but also extremely slow. If you still insist on making it more secure, simply chain it together: ROT26.encrypt(ROT26.encrypt("plain-text")) Simply chaining twice is already 75% more secure than 3ROT13!
You should definitely take advantage of Crystal’s [method overloading](https://crystal-lang.org/docs/syntax_and_semantics/overloading.html) for your `on` method. That way, you can be more assured in the arguments you’re getting and catch errors on compilation instead of runtime.
Can you give me an idea of how to do that in this case. `*arg` will almost always be an array containing one Bool followed by a number of Procs, I don't see an obvious way to overload and specify the types here. It's been a long time since overloading was something I even considered. Thank you ahead of time.
When you write `input.chars` that invokes `String#chars` which builds an Array with the chars. Then `map` will create a new Array. Then `join` will finally create the resulting string. So, lots of allocations. To make it more efficient, you can use `each_char` instead of `chars`. That returns an iterator. To make it the most efficient, just use `each_char` with a block, and build the string as you go. The iterator is fine but it does, too, need a memory allocation (it's a class). I was actually going to send a PR for this but... meh :-P
Ah, I see. Classes are on the heap in Crystal?
Theoretically you could have the same performance as rust using `string.each_char.map.join`
&gt; Personally I don't like the name though :P 'Crystal' seems generic to me. I think 'Sapphire' or 'Emerald' would continue the Ruby gemstone tradition and be more expressive. Not being sarcastic ... I just think the name is a bit uninspiring. Despite Crystal syntax &amp; some features being inspired from ruby and a lot of the core dev's being ex ruby devs, I honestly believe they don't want Crystal to follow in the shadows of Ruby, but rather cast its own shadow over Ruby which why I think they named it Crystal. I could be wrong though as a php dev, but that's how it looks from my POV.
You're right; the devs have mentioned in issues that being a "faster Ruby" has never been a goal, and IIRC asterite was once joking that he was drastically going the change the syntax just to make sure no one sees it that way.
Ruby could just as easily have been named [Coral](https://en.wikipedia.org/wiki/Ruby_(programming_language\)#The_name_"Ruby"). What would Crystal have been called if that were the case? Crustacean? 
Crystal is an amazing language, and while I too agree that it draws much inspiration from ruby, it has already evolved far beyond it. I think all rubyists will love crystal, but I am not sure if all crystalites will love ruby. Type safety and compilation are huge velocity gains for developers. Furthermore, not only does it further the ruby community’s paradigm of convention over configuration but it enforces it.
The Boehm GC does not return heap memory back to the OS by default. This means that if you heap size grows, your app will allocate more memory and keep that memory allocated for the crystal process. If you look at the GC free memory from within the process you will see that it freed the memory to be used for new crystal objects. Freeing the memory will stop the heap from growing, but the process will still keep that memory for itself. There is a setting you can use https://github.com/crystal-lang/crystal/issues/3997#issuecomment-283765417 Also read that thread for a more detailed explanation.
The GC is running all the time. Running GC in a fiber in a loop will not change anything.
You're ignoring the answers provided and repeating yourself. (Just an observation, not trying to be rude.) The memory is "free", in that it is available to be used. It is just not reallocated to the OS.
&gt; The memory is "free" But the ram usage still is high. And other applications on my server (for example, my simple php forum w/ mysql, nginx, etc) can't use it since Crystal has that "memory allocated". There must be a way to de-allocate and free it up. It's not fair to my other programs I feel.
He is telling you that there is no way to do that. Crystal does not give any memory back to the operating system once it grabs it. If you need that then you need to use different language.
&gt; You're ignoring the answers provided and repeating yourself Yeah.. I'm just repeating myself, and NOT trying to understand anything at all. Btw, remind me not to ask another question here again. So sorry it takes me a while to try to understand things and also so sorry for not being smart enough.
Just ignore those responses, you are asking a perfectly valid question. I had the same questions. What the OS tells you how much ram a process is using is different from the free memory with the process it self. Every time you create a new object via the GC, the GC looks for free memory. If there is no free memory, the GC requests memory from the OS and adds that to the heap memory. This increases the size of the memory a process uses according to the OS. The GC uses the free heap memory to create your objects and when they are not used anymore, the GC can reclaim the memory used by the object. This happens automatically for you and you don't need to do it yourself. This memory is returned to the free memory in the heap. The memory is not returned to the OS. So the process still uses the same amount of memory. If you are familiar with ruby, you would see that after a few GC runs, the heap size may be reduced. This happens because the ruby GC gives some of the heap memory back to OS if it hasn't been used for a few runs. The crystal GC does not do this, it will only increase the heap, never reduce it, hence the process memory will never be reduced in size unless you restart it.
Sorry. You're frustrated. As I said, I wasn't trying to be rude -- believe it or not, I was actually trying to help get the point across. Lot's of good information in this thread.
&gt; Lot's of good information in this thread. Yeah, and takes me to get shamed in doing so. Pretty fucking pathetic.
woah. dude relax. you are being very sensitive.
There is a new GC being written specifically for Crystal though by ysbadadden. Maybe it will change some of this behaviour, but who knows?
Forks! Im tbrand! We are discussing and developing the blockchain everyday! Joining our slack from github!
One thing I'd like to add, is the community. For an actual real word proof, search "Dillybob1992" on the Crystal's gitter. And look how much help I received for questions (which is what drove me to create that Crystal TCP Server example w/ Godot). They are extremely helpful in there. The lead developers post regularly in there as well, and it's such a promising feeling to know, you will always (99% of the time), get help with your questions.
So much this. /u/RX14 is another member worth mentioning for the level of help he gives in the community, too. They're all great though.
I have been playing around with this language for almost a year now and I love it. I became one of the sponsors because I would really think Crystal can make a difference in the programing languages paradigm, and since I have little time to commit to the project as a coder, I would like, at least, to collaborate as a backer and some sort of Evangelist / spammer (whenever I have the chance I always talk about Crystal.) The only thing I worry about is that it has been labeled as "promising" for a little bit too long now. I think the biggest challenge is to transition from "promising" to a "real amazing" language.
It's u/RX142 actually, RX14 was taken :) Thanks for the kind words!
oh sorry, my bad! I mixed it up w/ your IRC/gitter handle
Yeah I'm RX14 everywhere else so it's definitely confusing.
Possibly relevant username alert
I'm still waiting on an answer haha, but yes I may just eat 'em if I don't get it.
The classic chicken/egg scenario. The next successful stage after "promising" is "proven" (in production, at scale), and I haven't heard anybody telling that story yet. I expect that it'll poke along in "promising" purgatory for another year or two, until some hail-Mary project that's already in deep schist reaches for it in a desperation move, and proceeds to save the company. Then it gets the "overnight success" treatment from the glossy business-IT pubs/sites, gaining enough boardroom credibility to be approved for trial projects in existing companies. When enough of those start succeeding, we're back to Ruby circa 2004 or Java circa 2003. Exciting times; not yet for the faint of heart.
I meant the parent commenter's. :)
Ahh yes. Relevant indeed.
In order to make that transition they need more people on the core team. They need better programmers on the core team. They need people who are more open minded on the core team. They need to embrace the developers they have and listen to their needs and take them seriously. Very serious changes to take place in the language. Static compilation, multi core, better garbage collection, faster compilation, and of course better documentation. Also the marketing has to change. Stop pitching this language to Ruby developers and instead pitch it to go developers. At the same time work to make crystal compile as fast as go and run as fast as go with the same level of quality tooling. 
I use this lib in my TIL cloning project https://github.com/ChangJoo-Park/today-we-learned :) 
&gt;You can name the repo priority_queue.cr and just change the dependency it will work. While this may work from a technical or language point of view I think it would lead to confusion for the consumers of the lib. 
Isn't that a recipe for disaster. It means a long running process will keep ballooning on high peek demands but never release this memory and thus starving the other processes of memory. Silly example: At x time there is a spike in usage, your service spikes to 90% memory usage but runs fine. The GC internally release the memory when thje demand goes down and the process can reuse it ( but it still holds the 90% allocation ). That means that any other process, lets just say the database will need to work with only that 10% left. Sounds like a serious decision flaw to me. By that logic somebody can spam a service to have it reach 100% or higher, forcing the system to put memory into the swap file and starting all other processes ( including the OS ). Nice way to take down a server. Unless you left something out like: The memory is returned to the heap and other processes can use it, only the OS can not properly show the correct memory usage of the process. Now that makes more sense to me. 
&gt; They need better programmers on the core team. There are like 6 people in the core team. One of them recently back, is the guy who wrote Crystal for the last 6 years. Unfortunately just about every developer has a day job, so progress will always be less fast. &gt; They need people who are more open minded on the core team. As in? &gt; They need to embrace the developers they have and listen to their needs and take them seriously. Example of such needs not met? &gt; Static compilation No idea what is going on with that. I am not a developer, just somebody with a passing interest in Crystal. &gt; Multi core You mean multi thread? In experimental: https://github.com/crystal-lang/crystal/wiki/Threads-support Part of the hiccup is that its linked to the GC as i understand. See also: https://crystal-lang.org/2017/12/19/this-is-not-a-new-years-resolution.html Multi-threading Rework the fiber scheduler to handle multiple threads in parallel 680 ~Effort in hours Manas.Tech is supposedly working on it. Not sure if this is active now or not as the company itself the first business is still earning money. &gt; Better garbage collection https://github.com/crystal-lang/crystal/issues/5271 In development ... https://github.com/ysbaddaden/gc Issues: the developer is limited to his own system and needs more work for windows etc ... &gt; At the same time work to make crystal compile as fast as go and run as fast as go with the same level of quality tooling. Go is a custom compiler. Part of the language design for Go was such that it can read and analyse the source code fast. And produce a output. But as a counter result, Go is less optimized as compiler and ends up being slower the for instance Rust or Crystal there LLVM back-end. LLVM as a back-end to a proper language produces faster programs but does such at slower compile time. More time goes into the actual optimization process. Your kind of asking to travel to the moon without understanding the technology behind it. There is only so much one can do to make the compiler faster. Do not forget that Go is developed longer then Crystal by several C/C++ veterans who got paid by Google to work on it non-stop and they have a bigger team / resource pool. The fact that Crystal that relies mostly on volunteer work while using LLVM is beating Go in a whole slop of benchmarks is amazing by itself. We all want features now, fast, now, faster ... Windows support is essential for me but like impossible for me to do so ( totally lacking in knowledge about writing a compiler ). So yes, all we can do is wait or use a alternative.
It's really quite common for `require "foo"` to live in `RX14/foo.cr`. It's not that confusing because you're just adding a constant extension. Require already allows you to require normal files without the `.cr` extension.
It does not give a compile time error because there is an implicit `else nil` branch in the case. There was some discussion regarding what would be a good behavior to let the compiler complain about missing patterns in case expression. But catching them in compile time is not supported yet. https://github.com/crystal-lang/crystal/issues/4749 https://github.com/crystal-lang/crystal/pull/4837 I would feel comfortable with something like this: ``` case a when Int32 pp a, typeof(a) else unrechable # some built in construct that will complain if # reachable during compile time # but requires discarding case/else if all is covered end ``` Currently you can use runtime exception for sure.
Thanks for the link. I came to Crystal because of the power of the union type and trying to get away from Go's interface{} type. An implicit else nil defeats that power. Oh well, I'll come back to Crystal if they implement this. 
&gt;There are like 6 people in the core team. One of them recently back, is the guy who wrote Crystal for the last 6 years. Unfortunately just about every developer has a day job, so progress will always be less fast. So you seem to agree they need more programmers at least. I stand by my assertion that they also need better programmers. People with pretty deep experience in writing compilers, garbage collectors etc. &gt;As in? The current team are not really open to new ideas. The community has asked for things which in my opinion have been quite reasonable like a pipe operator and tagged structs and better ways of dealing with JSON and YAML files and the core team has outright rejected them. There were also requests for rather small items to seek better compatibility with ruby and again rejected. The Immix GC is another example. The team recently said something like "don't hold your breath for that" meaning they are not taking it seriously. There was an issue recently in to_s which recently changed it's output and when people complained the devs said "don't rely on the output of to_s" or something like that. the rest of your post is just excuses as far as I am concerned. Yes garbage collection is hard, yes multi core is hard, yes static compilation is hard, yes fixing the compile time is hard but this is why they need more and better programmers. BTW looks like they hit a wall with the compile times. I don't think they can improve that without changing some things in the language and again they are not open to ideas on that.
That's cool. That means you could use greek symbols etc. Could make some math stuff a lot cleaner looking.
I think it's unfair to dismiss the whole language on such a small point. Quite often you depend on the return type of the case itself, in which case you would get a compile error since you suddenly have a implicit else nil where you shouldn't.
The memory is returned to the heap and other processes can use it, if swap space is as big as the ballooning crystal application. Users log out at night, their RAM memory space no longer gets actively used and gets swapped to swap space on disk as other request for RAM get preference. Modern OSes check RAM activity constantly and optimize.
Wow. What a rational response. 
Tell me what language is open to outsiders coming in and telling the developers what to do. I have been in the Crystal, D and other communities and everywhere you will see the same response. As long as people like us do not pay for the features to implement or our visions do not match with the developers, your barking up the wrong wall. Trust me, i have seen massive issues in several open source programming languages that directly affect there attraction for new users. But most developers who work on the core are unpaid, so they do not take orders from us unless they like the idea. And ... most developers are stubborn, see D for instance where Walter refused markdown in function documentation until he tried it and ... suddenly after years changed his mind. The issue with a lot of languages is, you can not work with pure democracy or else your language ends up a big mess as everybody wants something and not all people understand the technical issues it can create on the compiler / language. You know the beauty of open source code? Do not like the direction a language takes and you have the skills ( and people ), fork a project. &gt; the rest of your post is just excuses as far as I am concerned. And i will be honest, if that is the attitude you present to the developers or other people... It rubbed me the wrong way. They are not excuses but facts ... simple as that. &gt; this is why they need more and better programmers. Like open source developers who want to work for free grow on trees. Its always the chick or egg problem in any language. 1 -&gt; Your language has issue ( language, marketing, ... ) so people avoid it 2 -&gt; Not a lot of people use your language 3 -&gt; Hard to find more professional people who want to volunteer ... Loop back to (1) This is why in general only language who have a sponsor or corporate overlord grow, as they have the money to push and fix issues until the gain momentum. And not even then its a guaranteed success as a lot of languages have failed even with corporate backing. Take my advice unless you are directly involved into a project, the chance people inside a project like this will listen to you are 5% at best. And that is if your idea matches with them. I know its hard to stand on the sideline and yell with good intentions. If i had the time, i will have been glad to fix issues in different languages and push them more. But like most people, i have a family, a life that takes time, just as most people who yell from the sidelines. We have good intentions and see issues but when the developers do not see them or do not have time to fix them... 