&gt; something like `Rc::new(make_huge_struct())` will write the struct **to the heap** ... You meant: **to the stack**, right? &gt; ... allocate memory for the Rc and then copy the struct into the allocation I thought that this was already optimized. The box operator doesn't perform this optimization to arenas like in: let a = Arena::new(); let x : &amp;mut BigStruct = a.alloc(construct_a_big_struct()); // &lt;~~~ the same optimization is needed here ...
It doesn't have to be that big no, rustc doesn't properly remove unused functions etc yet.
`rustc` itself does remove unused function; the problem is the design of the runtime trait (providing IO and scheduling etc.) which is entirely a problem with libstd, i.e. library not language issue. The runtime is stored as a trait object, with a vtable full of function pointers to things like networking functions and thread creation. LLVM (the optimiser) finds it hard to tell that most of these functions are unused, leaving you with a hello-world program that has a pile of functions for TCP/IP handling (i.e. utterly pointless).
Thanks for the explanation, that sounds tricky to solve really.
It's sad this is considered an issue.
Yes, just like a "normally" compiled C program. That is how software is usually distributed on Windows. You dynamically link and bundle all your deps with the application.
C and C++ are low-level enough that often times optimizations of common situations must be held back *just in case*. For example: struct Animal { virtual void eat() = 0; }; struct Cat: Animal { virtual void eat() { std::cout &lt;&lt; "Cat eat\n"; } }; struct Dog: Animal { virtual void eat() { std::cout &lt;&lt; "Dog eat\n"; } }; void replace_cat_by_dog(Animal* animal) { if (Cat* cat = dynamic_cast&lt;Cat*&gt;(animal)) { cat-&gt;~Cat(); new (animal) Dog(); } } // Note: this is not OK in general, it only works on manually allocated objects // and only if (as in this example) sizeof(Dog) &lt;= sizeof(Cat). Thus, when using `replace_cat_by_dog(animal);` you cannot guarantee that the `animal-&gt;__vptr` will be unchanged during the method call and thus cannot optimize the read. I *believe* that the same cannot occur in Rust, and thus more caching of virtual pointers should be available.
Thank you. I have almost no experience with this stuff (only ever used VB many years ago, and now Python). So if I want to distribute a program, I need to either have it statistically linked, or ensure all the necessary dll's are installed?
Mostly correct. Not necessarily installed per se, but rather "available". Usually you'd just have them in the same folder as the executable.
How does the program know where to look for the libraries? 
- error messages can have the ~ annotated. - seen 'hoogle' , where you can write signatures that are character based, and it does an more intelligent search based on the syntax you provided you could search for 'tildre' - names are things to ague over. syntax is easy to compose. You learned "~" "[]" and they did the job of unique_ptr, vector&lt;T&gt;, make_unique, .. it was very elegant the way it was some months ago. Fun concise powerful, logical syntax, instead of annoying, labourious vocabulary (learn different words for the same things.., arbitrary choices for what someone else wants to call it..) 
While waiting for Cargo, the package manager, Rust-Empty relieves you some of the pain of working across multiple repositories. You can now type `make symlink-info` and it will create a `.symlink-info` file with dependency information. It gives you a commit hash and remote branches where the commit is available. Releasing this now to get some feedback on the changes. Anyone experienced problems? Questions? Feedback is appreciated! Also: If you are new to Rust, *please* use Rust-Empty because it makes your library much easier to use.
i wish you could have kept ~ ~[T] @T ... the way they were (perhaps @ simply being used for Rc&lt;T&gt; to avoid the core language introducing dependance on a garbage collector ) ... and then moved on to generalizing these mechanism similar to operator overloading (sigil overloading). When I saw this language a few months back, I was impressed how common patterns from C++ had basically been baked in with convenient sugar, making them look more natural instead of being hacked in with templates. And of course, having the powerful templates for adding custom structures is great too. Not all code we write needs to be optimised to the same extent - a few common data structures can handle the majority of the code thats' written - but then you drill down and optimise key areas. in our use cases, the goal was actually to simplify the runtime right down, allocations could be completely eliminated with precompiled datastrcutures (which is why elsewhere, I'm ranting about the inconvenient casting!), and offline tools preconditioned data.. but in an experimental phase you needed to be able to write code *rapidly* to determine what structures you were going to end up with.. it wasn't worth writing each step fully optimised since you never knew exactly what you'd end up with, and it's a difficult workflow, having to keep tools and runtime in sync, you can't iterate code so fast that way. preprocessor Tools code and runtime code had different requirements - convenience vs performance - but having them in the same language meant you could move data structure declarations across, test bits of the runtime in the tools, or prototype the tools in the runtime ( which saved a lot of friction moving between team members). "condition this data structure, test it's valid.." There's a lot of assertions being made where people seem to think they know every workflow that will ever be used... Something that my 'perfect language' would also do is it would have a subset that could be interpreted. Right now in games people use a mixture of C, C-sharp , and scripting languages like Lua. C/C++'s syntax and semantics don't suit being interpreted .. but the inference rust was capable of (absence of a type means infer it, instead of 'int'..) and the ability to declare a lot of data structure in a few characters with ~[] () etc meant I could actually see this coming to fruition one day, even if it wasn't a goal of the core devs. A lot of my ex-colleagues are moving to Csharp for application and tools work,i don't want to touch that language. The powerful data literal syntax is great for debugging and testing too. (do you think when JS was invented, the designer thought ASM.JS would be developed some day? ..and does asm.js hint that productivity and efficiency needn't be opposites in language design?) I think what i'm seeing with ~ and do before it is "throwing the baby out with the bathwater". special features that really contributed to the language having a fresh feel over C++, occupying a unique space, are being lost :(
&gt; It seems to me that loop is the only one for which a return value makes sense, &gt; ok maybe; I'd agree `while condition {break..} else { ..}` seems convoluted,because the condition is divorced from the evaluation but for..else might be less insane? I hadn't realised python already had this, and I'd suggested it to complete the ability to use for x in option.iter(){} to handle options with less nesting. isn't option kind of baked in by for .. in {} already. (if thats implemented in the compiler as sugar.. maybe that could revert to if {loop{} } else { ..} swell) 
It was the easiest way to demonstrate something that "worked", sorry for confusion. The current design has dummy values (i.e. not using the types) for the "allocator-less" pointers*, so I was actually using `Rc` as such a hypothetical dummy value, e.g. [the one for `std::gc::Gc`: `GC`](http://static.rust-lang.org/doc/master/std/gc/index.html), and [that for `~`: `HEAP`](http://static.rust-lang.org/doc/master/std/owned/index.html). let _: Gc&lt;int&gt; = box (std::gc::GC) 1; let _: ~int = box (std::owned::HEAP) 1; (The current names/casing etc. is not necessarily the final design, it's just what was bestowed on `box` when it was implemented ages ago, and will be properly worked out as `box` gets used more and more.) \*note that most of these aren't actually allocatorless, one might want a `Rc&lt;T, TcMalloc&gt;` or `Rc&lt;T, MySlabAllocator&gt;`, and these *will* require passing true values, say `box (rc_allocator(my_alloc)) 1` (NB. this design is just off the top of my head, and the final design will have significantly more thought put into it).
Typically, it looks in its current directory (at least on Windows).
Thanks :)
&gt; yes , i too am bewildered by this assertion "you don't use trees often". At no point was that assertion made. You keep saying that people tell you "you don't use trees often", even though that has not been said. People have pointed out your strawman repeatedly ([e.g.](https://github.com/rust-lang/rfcs/pull/59#issuecomment-41866141)). &gt; I use trees all the time. You can *use* trees without having to see `Box`: look at [the inferface of `TreeMap`](http://static.rust-lang.org/doc/master/collections/treemap/struct.TreeMap.html). Not one `~` anywhere. (There are some uses of `~` in the implementation, but they (correctly) don't infect the external interface.)
is the plan for 'multi-parameter type classes' to allow functions to be overloaded on 2 arguments ? - it's needed for proper operator overloading (e.g. distinguishing `matrix * matrix` from `matrix*vector`)? I know you can achieve this now with a sort of 'double dispatch' through intermediate traits. maybe some macros could streamline that boilerplate? but would 'multi parameter type classes' only be applied to compile-time polymorphism, or is there any way they could make sense for trait-objects swell (like sugar for double-dispatch..)
not so direct as rolling your own data structure, with all the options at every stage. you have nodes of different types, of different sizes (so an enum currently won't cut it, at some point you need optional owned pointers or an enum of owned pointers to 'content'). why would you want to abstract away and wrap a ~ or a vector of [~Nodes] or whatever you need, and invent yet more vocabulary , when its so convenient to deal with directly as it stands now.
&gt; seen 'hoogle' , where you can write signatures that are character based, and it does an more intelligent search based on the syntax you provided It's actually just normal Haskell type signatures; nothing special. (It does "fill in"/be flexible with the exact signature that it receives, but it's not a special "Hoogle" syntax.)
Anybody think rust can approach the c++ score for [the follow-up]( http://codegolf.stackexchange.com/questions/26371/how-slow-is-python-really-part-ii)?
so I gather box will allow passing an allocator, thats great; has it been considered to also allow allocators to be tied to types as with C++ operator new overloading - perhaps in rust that would look like a trait Alloc that you can impl for the type. Maybe that doesn't work so well for multiple tasks?.. are there reasons you don't want to go that route. 
To me uniformity and simplicity of grammar is highly desirable. MS has experimented with operators (specifically ^) for smart pointers in the past and the results were not great.
From the RFC: &gt; There will be a unique pointer type in the standard library, Box&lt;T,A&gt; where A is an allocator. The ~T type syntax does not allow for custom allocators. Will a new syntax for specifying allocators with ~ solve the problem? May be something like: let b: ~/Rc int = box 5; Or is the real problem eliminating multiple ways of doing the same thing?
On a microcontroller, that has for example only 8kb of flash memory, wasting 2kb on lovecraft *is* an issue...
The quotes aren't actually an issue, they just act as a canary in the coal mine and tell us that something that shouldn't be linked in is being linked in, that more general flaw is of course an issue for embedded.
Actually, this is correct in the version of rustc that the OP is using—unused functions are not removed. However, in the nightlies/master branch, unused functions *are* removed, which cuts down the size of hello world by 3x. What dbaupp says regarding the runtime is correct, however; nightly rustc still isn't good at removing unused functions that are called through trait objects, leaving a lot of code (e.g. networking) around that shouldn't be there.
Apparently the whole binary takes 469320 bytes, almost all of which is rust runtime overhead. It's safe to say removing 2K of fancy error messages isn't going to help fit on a 8kb board. 
But the point is this could be done with significantly more brevity. I don't even work on embedded platforms and a 2KB Hello World binary bothers me.
It seems to me like this is yet another case of the ideological divide between simplicity/newbie-friendliness and expressivity/power user friendliness that has been splitting a lot of FOSS communities lately (think Gnome 3). As someone firmly entrenched in the "expressivity" camp (firmly enough to find Python to be a chore to read and write), I find most arguments I have seen in favour of this to be invalid. &gt; ~ is hard to type under some keyboard layouts ...and significantly easier to type than &lt;&gt; under some others. With my German keyboard, the key for both is right next to the left shift key required to type &gt;. Fundamentally, the special character choices in pretty much all programming languages have been made with the standard US English QWERTY layout in mind anyway; if you really wanted to make life easier for AltGr-family keyboard users, you ought to start by giving curly braces for block scope the axe. &gt; Box is more learnable/searchable Saving newcomers the effort of having to type "rust tilde" into the search engine of their choice once does not seem like a good deal for forcing everyone using the language to match a pair of angle brackets forever. &gt; Box&lt;T&gt; makes the language cleaner by reducing the number of distinct syntactical constructs So does removing everything but parentheses and the S and K combinator. The number of special cases in natural languages makes it evident that "simpler is better" is not an adequate quality metric for symbolic representations as far as the human brain is concerned. Some of the most legible and pleasant to work with code I have encountered was academic Standard ML code which defined additional operators along the lines of |&gt; for chaining functions of type 'a -&gt; 'b -&gt; 'c -&gt; .. -&gt; 'a; understanding its use took a single look at the definition, and the code was far cleaner and more easily understood forever afterwards. &gt; you never encounter ~ Don't generalise from your coding style to that of other people. &gt; Rust is opinionated If everyone starts using that as a pretext to use Rust as a vehicle to enforce their own opinions and aesthetic preferences, the project will come to a grinding halt in no time. &gt; Allocators Could someone enlighten me as to why they are useful with owned pointers? I can see their utility with containers whose implementations sometimes need to create new cells of the contained type without being explicitly ordered to do so by the code that uses them, but when does this happen with ~? Would it be possible to strengthen the macro system or provide sufficiently powerful generic character-sequence operators in the style of Standard ML or Haskell that a user could choose to define ~T as an alias for Box&lt;T&gt; (or @T as an alias for Rc&lt;T&gt;, or §T as an alias for Rc&lt;T&gt;, etc.)? This way, the conflict could at least be pushed out of the language design and instead be carried out along codebase boundaries.
We can get `default! Foo { x: 10, y: 20 }`, can't we?
&gt; My usual keyboard layout doesn't have a ~ symbol Out of curiosity, what layout would that be? It is interesting that some layouts do not have the full (printable) ASCII range available. 
I wonder if there'll be some decent way to transition from rust-empty to cargo...
Capturing is faster, and often clearer, when you can do it. The examples you are referring to probably just didn't want to explain capturing.
How would you check for errors in the `reader.lines()` call? E.g. if reading the next line failed/file got deleted/etc? Or should that be done when matching on `line`?
Rust-Empty is preparing your project to use Cargo. They both use the same project structure. Rust-Empty will integrate with Cargo as good as possible in the future.
&lt;3 &lt;3 &lt;3
Would you consider calling box 'new', it seems to be related to operator new/placement new ... and change the ::new() convention to ::init() or whatever This might save time teaching, and make translating API's too and from C++ easier. (if you are going to move in the direction of greater similarity to C++.. leverage the potential benefit of easier crossover) then you just explain 'new in rust takes advantage of 2way type inference, it knows what type of object you're assigning to, so we didn't need make_unique, make_shared etc.' 
As usual, the disagreement will be much more loud and vehement than the agreement. At first I thought this was a bad idea, but several things made me change my mind. 1. Allocating memory is generally slow, so it makes sense to associate that with typing more than one character, and it also makes people think about allocation carefully instead of using ~ everywhere. 2. It's more consistent. 3. Easier to type. 4. Supports custom allocators. 5. Always possible to add back in. So I say don't be too discouraged by the loud disagreement. Also, if we switch, I don't think we should have ".to_owned()". The fact that we are using "unique", "owned", "boxed", and "~" all over the place for one concept is confusing to newcomers. 
Would it work to have just "box" and not Box&lt;T&gt;, that is, use "box" in types as well? "box" is not much more work to type or read than ~ (since its characters are more common/closer to the fingers), but I can see Box&lt;Foobar&gt; getting annoying very fast. Anyway, I understand the desire to minimize special cases in the syntax, but I think easy, lightweight heap allocation is a worthwhile investment of syntax complexity.
Perhaps worse yet, by someone forgetting to set the "no_eldritch_abomination" cfg option.
So `~str` becomes `Box&lt;str&gt;`, and `~[T]` becomes `Box&lt;[T]&gt;`?
Neat project! I haven't looked at it too closely, but it appears this is a framework for apps to create their own metrics. I have a pet idea for instrumenting the runtime itself that you might be interested in. It boils down to this: most significant runtime events that may result in task scheduling (including all I/O) go through one of two vtables (traits `Runtime` and `IoFactory`). By decorating these two vtables one could extract some rich information about what is happening in the runtime. 
Another point: Servo does this sort of metrics tracking with its own system. If you are enthusiastic about metrics reporting in Rust then collaborating with Servo is a great way to get your Rust project a foothold in the wider ecosystem.
It would be useful to have type "reflection" in macros.
About half of your arguments aren't for the superiority of the tilde, but for the non-superiority of the `box` syntax (e.g., that it is equally hard to type angle brackets on some keyboards or that it is equally easy to search for.) Setting those aside: &gt; Don't generalize from your coding style to that of other people. Not encountering owned pointers isn't just about how the language _is_ used, but about how it _should_ be used. Changes needn't simply mirror the habits of the community—they could also be attempting to shape them. The reasoning is that you _should_ rarely `Box` in the code that you're writing, because you either are overusing heap allocation, or you because haven't abstracted your data structures away enough. If this syntactic change causes the community to change the way they program: _good_. &gt; Rust is opinionated What this means is less that it's a vehicle for the opinions particular people, and more that Rust-the-language does not want to be all things to all people. Rust has a particular set of goals, and decisions are made based on those goals. &gt; Could someone enlighten me as to why [allocators] are useful with owned pointers? At present, owned pointers always use some particular `malloc` implementation to allocate the memory they use. If you've done C programming in particular areas, you know that there are various reasons to prefer one `malloc` implementation over another in particular problem domains, or even to write your own allocator. For example, you might want to abstract away techniques like slab allocation, or to use an allocator optimized for low-memory systems, or use some knowledge about your own access patterns to optimize cache locality. Allowing you to parameterize over allocators will allow you tighter control over the memory your program is using. &gt; Would it be possible to strengthen the macro system... There are major downsides to this idea. It's not hard to find examples of people radically overusing similar systems (e.g. various infamous libraries for Scala and Haskell) and it really fragments the language. One advantage to Python's approach, regardless of how you feel about the particular syntax that they chose, is that effectively everyone who writes Python writes it in a consistent way.
Update: I've talked to wycats (one of the Cargo developers) and was told Cargo will make progress in a short time. Added experimental Cargo support.
Indeed its aimed to be used by other rust apps to expose their metrics. Exposing rust runtime data is something that would be probably easy to add, I will take a look what's there.
Well, aside from `ref` and `ref mut`, and wildcards and placeholders.
&gt; About half of your arguments aren't for the superiority of the tilde Yeah, and I am not claiming that I am categorically against anything that might replace the ~ syntax. In this particular case, though, it is the box syntax that is seemingly on the verge of being made to replace it; arguing that it is inferior to ~ seems valid in the context. &gt; Changes needn't simply mirror the habits of the community—they could also be attempting to shape them. In that case, how we should shape them is the debate we should be having. Are heap allocations really that bad? Is there no way we could make them better, given that for instance, Poly/ML-compiled cons-cell based list-mangling code often outperforms all but the most tuned C doing the same thing in-place with arrays? Instead, I'm seeing a discussion about learnability and whether Rust should be more like Python. &gt; One advantage to Python's approach, regardless of how you feel about the particular syntax that they chose, is that effectively everyone who writes Python writes it in a consistent way. I don't think that perceiving that as an advantage is nearly as universal as you appear to hold it to be. A well-written program in a flexible language (to pick up my |&gt; example from the parent post, imagine code fragments like "the_graph |&gt; remove_edge e1 |&gt; contract_edge e2") can convey a lot of information that is immaterial to its execution but brings across the programmer's mental model for what is going on. Removing that level of expressivity from the language itself will force this sort of information to be relegated to imprecise, distracting screen-sized natural language comment blocks, or perhaps more often to not be recorded at all. &gt; At present (...) So why does the allocator need to become part of the type, instead of simply invoking it when actually creating an instance of it? i.e. int ~a = magical_int_allocator(3);
I somehow expected to find an implementation of the VISA instrumentation API in rust… :)
I think so (could be wrong here). However, we already have `StrBuf` (might become `Str` in the future), and `Vec&lt;T&gt;` instead.
Any special reason about why does the client was built in Python?
Mainly because its easier to distribute it to the system from which you may want to use it, which may different from the one where observed app is running.
`ref`, `ref mut` and `_` aren't destructuring.
&gt; Is it possible to declare a const pointer to mutable data? No &gt; How does this whole "owning pointers" thing work with local variables? Could you explain a bit more what you are asking please? I don't understand your question.
PolyML code can get quite fast—so can appropriately-written OCaml or Haskell—but that's not what Rust-the-language is trying to do. As fast as they can be, I wouldn't use even a heavily optimizing compiler like MLton to write code for writing code on, say, a small microcontroller, where I may want to know literally every instruction that is being generated and where every allocation happens. Rust is making different trade-offs. Perhaps the problem domain you have in mind would be better served by writing OCaml code, and not pushing Rust towards being another OCaml? &gt; A well-written program in a flexible language... One should never assume that programs will be well-written. &gt; ...can convey a lot of information that is immaterial to its execution but brings across the programmer's mental model for what is going on. Entirely possible. In this _particular_ case, I don't think keeping a sigil as an alternative to a slightly-longer keyword will convey much more information. And as for your larger point—I've taught at least half a dozen programming languages over the span of half a decade, including Python, and Haskell. You may not be a bad programmer, but these students, by and large, were. It was remarkable to what degree Python's strict regularity forced their programs into relative readability, to the degree that I could put in front of you a program by a Python newbie and a program by a seasoned Python expert and you might have difficulty distinguishing the two. (To be strictly fair, the same was true of Scheme, but we did not teach them about macros or mutability.) Python doesn't merely stipulate uniformity of style, but also uniformity of _idiom_, which is a very valuable thing, and I think that's where the comparison lies: not that Rust should be a language for beginners, but rather that pushing for uniformity of idiom will produce a uniformly readable codebase. Overloadable operators allow wonderful things, but can also allow horrifically unreadable things (c.f. the infamous 'Scala table of operators', which are the poorly-designed user-defined operators from a library.) All of this isn't to say that there isn't a place for flexibility in languages. Just that it is also a valid design decision to strive for uniformity, and it seems the Rust team has chosen that. &gt; So why does the allocator need to become part of the type... If the allocator used were not part of the type of a pointer, we could have code like { let x: Box&lt;T&gt; = if some_condition { alloc_with_A(); } else { alloc_with_B(); }; // implicit free(x) gets inserted at the end of scope } We don't know statically which `free` to invoke—the one associated with `A` or the one associated with `B`—so either every pointer has to be tagged with the relevant allocator—doubling the size of pointers and increasing the overhead of literally every pointer used—or we have to statically outlaw that situation somehow. Rust is not the kind of language in which one wants overhead on every pointer. Parameterizing pointer types by their allocators allows you to statically determine this and outlaw the above code. 
They are binding elements rather than structural elements of a pattern, yes, which is a reasonable distinction to make. Afaik, "destructuring" usually refers to using a pattern to bind certain structural elements of a value, though, and this is the meaning I based my response on. It does, however, seem likely that /u/isHavvy was using the term to refer specifically the elements of a pattern which allow you to match structural elements of a value, regardless of whether you intend to bind them, in which case my counter examples aren't relevant.
&gt;&gt;Parameterizing pointer types by their allocators allows you to statically determine this and outlaw the above code. C++ achieves this by allowing you to tie the allocator to the type by overloading operator new. So you could have T, Pooled&lt;T&gt; , auto *p = new Pooled&lt;T&gt; ..(or whatever smart pointer ..) that would suggest to me you could have done the same thing with sigils. `trait Alloc` which you could impl for a type, then the sigil allocates that that. so the ability to specify an allocator isn't a reason to remove the sigil, IMO.
"box is googleable" and 'new' is what they'd guess having been exposed to other languages.. I doubt anyone is going to just be learning rust
This function is hilarious: https://github.com/mozilla/rust/blob/1ce0b98c7bad8c01e008ccbc790607f4bb26ec89/src/libgreen/macros.rs#L61
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 34. [**Keyboards**](https://en.wikipedia.org/wiki/Tilde#Keyboards) of article [**Tilde**](https://en.wikipedia.org/wiki/Tilde): [](#sfw) --- &gt; &gt;Where a tilde is on the keyboard depends on the computer's language settings according to the following chart. On many keyboards it is primarily available through a [dead key](https://en.wikipedia.org/wiki/Dead_key) that makes it possible to produce a variety of [precomposed characters](https://en.wikipedia.org/wiki/Precomposed_character) with the diacritic. [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*] In that case, a single tilde can typically be inserted with the dead key followed by the space bar, or alternatively by striking the dead key twice in a row. &gt;To insert a tilde with the dead key, it is often necessary to simultaneously hold down the [Alt Gr](https://en.wikipedia.org/wiki/Alt_Gr) key. On the keyboard layouts that include an *Alt Gr* key, it typically takes the place of the right-hand [Alt key](https://en.wikipedia.org/wiki/Alt_key). With a [Macintosh](https://en.wikipedia.org/wiki/Macintosh) either of the Alt/[Option](https://en.wikipedia.org/wiki/Option_key) keys function similarly. &gt;In the US and European [Windows](https://en.wikipedia.org/wiki/Windows) systems, the [Alt code](https://en.wikipedia.org/wiki/Alt_code) for a single tilde is 126. &gt; --- ^Interesting: [^Tilde ^Fröling](https://en.wikipedia.org/wiki/Tilde_Fr%C3%B6ling) ^| [^Ñ](https://en.wikipedia.org/wiki/%C3%91) ^| [^Tilde ^de ^Paula](https://en.wikipedia.org/wiki/Tilde_de_Paula) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch7asps) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch7asps)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
The current `~str` and `~[T]` are obsolete and have been replaced by `StrBuf` (likely to be renamed) and `Vec&lt;T&gt;`.
Might make things easier to write, but it makes them harder to read. :( Though as a newbie this discussion has definitely helped me understand that the sigil is not "part of the type" in the sense of `*` in C pointers, but rather the expression `let ~x = …` is actually desugared.
&gt; Rust is making different trade-offs. Is there evidence for there actually being a trade-off of the form "we provably can't make programming idiom relying on the throwing around of cons cells perform decently without breaking this other aspect"? Even if there isn't, code volume and reading/writing complexity is not strongly correlated to its contribution to the cycles a program consumes. A lot of code would benefit handsomely from both being able to have tight, C-like inner loops and not particularly fast, heap-happy, mathematically appealing control around them. This proposal seems to reduce the convenience of algebraic data types - a way of organising control flow I considered a primary advantage of Rust over other C-like languages, and have dearly missed in past projects that absolutely could not be implemented in a higher-level language - to a significant degree. &gt; One should never assume that programs will be well-written. I would consider the assumption that badly-written programs can be salvaged by language features to be one of the worst sicknesses of modern software development. Catastrophically bad C programs segfault and terminate early; catastrophically bad Python programs produce the semblance of working, get shipped and wreak havoc down the line. &gt; In this particular case, I don't think keeping a sigil as an alternative to a slightly-longer keyword will convey much more information. The context of the degrees-of-freedom-orthogonal-to-semantics argument was not keeping ~, but introducing arbitrary overloadable sigils to make both camps able to write the code they want. &gt; to the degree that I could put in front of you a program by a Python newbie and a program by a seasoned Python expert and you might have difficulty distinguishing the two. Once again, you are framing this as if it was a self-evidently good thing. I would contend that the uninformative flatness of a newbie's Python code is thoroughly unpleasant (in a way that feels similar to me to how I find writing and reading 6502 or x86 assembly much more pleasant than their (lauded for its regularity) MIPS counterpart). It's easy to understand what the code does, but much harder to understand why it does it - and I would contend that the former is the computer's job, not the reader's. If no amount of expertise allows the programmer to do better than the baseline, that is a pretty sad state of affairs. &gt; and it seems the Rust team has chosen that Declaring it to be a choice that is set in stone does not seem to be in line with how development has been handled so far. I am also not aware of a "Python-like philosophy" being part of the goals... &gt; don't know which free to invoke. Ah, I see. Thanks for the example. I suppose this does make a strong case for having parametrised types that behave like ~ - however, I would consider not encumbering algebraic data types more than they already are on its own to be a sufficiently important objective to make retaining ~ together with a "default" allocator (like C++'s new/delete) while strengthening parametrised types if needed worthwhile, or even to introduce overloadable sigils. A lot of recent proposals and changes seem to be taking Rust closer and closer to being not much more than a sort of C++ with a stricter type system. I'm enough of a PL person to appreciate the value of good type systems for itself, but a new programming language is unlikely to win programmers over unless it makes some tangible task dramatically easier and more pleasant. The safety guarantees of a type system, unfortunately, do not seem to qualify as "tangible" for this purpose. Making heap cell/ADT based programming nearly as effortless as in a functional language while retaining a systems focus would qualify and be a pretty much unique attraction point, and it is very low-hanging fruit because it's *already there and working*; is making the syntax a little bit more uniform to please the Python camp (who will probably keep using Python for everything anyway) really worth throwing it away?
I'm sorry, you're going to have to format your comment better; it's just too hard for me to read without paragraphs.
&gt; sigil is not "part of the type" in the sense of * in C pointers It is certainly part of the type? `let z: ~int = ...;`.
Although I'm obviously biased, being in the disagreeing camp, I don't think it is fair to characterise the disagreement as loud and vehement, as if to imply that one will perceive more of it than deserves the time of the day. Given that the situation pretty much seems to be that this RFC will be adopted by default unless the disagreement is strong and/or well-reasoned enough, it is justified that somebody who thinks this is a very bad idea would feel much more of a sense of urgency (and deserve some amount of priority consideration, even, which wouldn't be the case if the debate was conducted on level ground). &gt; allocating memory is generally slow I still don't get the point behind the "it takes time to run, so it should take time to write" argument. Isn't the point of higher-level languages to abstract over operations and hide their complexity? &gt; It's more consistent. Not sure "consistent" is the right word here. "Inconsistent" seems like it should imply that other syntax leads one to make assumptions about the piece of syntax in question that turn out to be incorrect; is this the case here? &gt; Easier to type. Not on most keyboards. On US-English, the only difference is that Box&lt;T&gt; is significantly longer; &lt;&gt; is a supremely awkward sequence of keys on a German layout (whereas ~ is pretty normal). &gt; Supports custom allocators. Why not just make sure that the parametrised type system is powerful enough that people could write something that behaves just like ~ with a custom allocator, but retain ~ in tandem with a default allocator? &gt; Always possible to add back in. Only after the damage is already done. Language design choices like this also tend to be naturally self-reinforcing, in that implementing them will make some people to whom the consequences are unacceptable leave, while pushing the language into "interesting" territory for some others.
Python is merely an example; AFAIK, there is no move to make Rust "Python-like" or to attempt to attract Python programmers. The stated goal is to make Rust more _regular_ and remove non-orthogonal features, and I used Python as an example of a language which made great effort to avoid non-orthogonal features. None of this, as far as I know, is attempting to specifically "...please the Python camp." And as for the rest—do you really expect me to believe that _two extra characters_ that constitute a minor syntactic change will somehow turn Rust from the bright future of functional programming to a failed experiment?
&gt; remove non-orthogonal features As far as I can tell, the only pertinent aspect that has a semblance of non-orthogonality is the circumstance that ~ does not allow you to choose the allocator. Would user-definable sigils or additional syntax to specify the allocator for a ~ not be a more... orthogonal way to increase orthogonality? &gt; Python camp Sorry for the somewhat polemic shorthand. I meant to use the term to denote people who favour the kind of simplicity this change seems to aim to further; as I stated in the head post of this thread, it seems to me like there is a fundamental divide which results in strong correlation between valuing simplicity and regularity, disliking gratuitous syntax and shorthand and thinking Python has significant redeeming qualities. &gt; two extra characters As far as typenames are concerned, we are talking about 4 extra characters (going from ~T to Box&lt;T&gt;), and a greater increase in cognitive overhead because the angled brackets actually have to be matched. (Honestly, I previously thought that even ~ was excessive and it would be better if instances of ADTs were implicitly on the heap.) I do think that this change passes a certain threshold beyond which the language feels as if its designers were meaning to discourage ADTs. If you discourage heap boxes - deliberately, mind you, judging from the comments so far - which are essential to any nontrivial use of ADTs, I would consider the statement that this is not the same as discouraging ADTs to be disingenuous.
Are there any examples anywhere of this capturing that you speak of?
as in using different (jemalloc/tcmalloc/malloc) allocators for different objects in the same code? I didn't think that was possible. 
would `box("foo")` work?
Capturing is the second code snippet. (And actually the first code snippet too: the `rx` variable is captured.)
`box` is [placement "new"](http://en.wikipedia.org/wiki/Placement_syntax) for Rust. We don't have "implicit" constructors, nor do we allow variables to be left uninitialised in safe code, so any construction needs an initialising expression. That is, those examples would need to be `Heap::new(some_bar_value)`, which requires putting `some_bar_value` on the stack and then moving it into the allocation. (This exact pattern is currently used for library smart pointers like `Rc::new`.)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Placement syntax**](https://en.wikipedia.org/wiki/Placement%20syntax): [](#sfw) --- &gt;In the [C++](https://en.wikipedia.org/wiki/C%2B%2B) [programming language](https://en.wikipedia.org/wiki/Programming_language), __placement [syntax](https://en.wikipedia.org/wiki/Syntax_(programming_languages\))__ allows programmers to explicitly specify the [memory management](https://en.wikipedia.org/wiki/Memory_management) of individual objects — i.e. their "placement" in [memory](https://en.wikipedia.org/wiki/Memory_(computing\)). Normally, when an object is created dynamically, an allocation function is invoked in such a way that it will both allocate memory for the object, and [initialize](https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming\)) the object within the newly allocated memory. The placement syntax allows the programmer to supply additional arguments to the allocation function. A common use is to supply a [pointer](https://en.wikipedia.org/wiki/Pointer_(computer_programming\)) to a suitable region of storage where the object can be initialized, thus separating memory allocation from object construction. [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*] &gt; --- ^Interesting: [^V2 ^word ^order](https://en.wikipedia.org/wiki/V2_word_order) ^| [^New ^\(C++)](https://en.wikipedia.org/wiki/New_\(C%2B%2B\)) ^| [^Allocator ^\(C++)](https://en.wikipedia.org/wiki/Allocator_\(C%2B%2B\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch7fpoa) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch7fpoa)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Can `Heap::new&lt;T&gt;()` not rely on `T` having an implementation of the `Default` trait? (I guess that would be spelled `Heap::new&lt;T:Default&gt;()`.)
AFAIK, ~[T] is supposed to be analogous to a classic C array, which can be longer than the number of elements it holds as it may have nulls instead of actual objects. This is what the Option&lt;T&gt; represents. On the other hand, Vec&lt;T&gt; is analogous to the C++ std::vector, which is a data structure that grows as you add elements, and will always return an element if using a valid index. Therefore a T can always be returned. Hope this clears things up, and anyone correct me if I got something wrong.
&gt; AFAIK, ~[T] is supposed to be analogous to a classic C array, which can be longer than the number of elements it holds as it may have nulls instead of actual objects. This is what the Option&lt;T&gt; represents. Ah, that does help clear up that bit. I wanted to know if there is somewhere that defines and documents methods on ~[T]. I wasn't able to find anything in the API docs for it or any other primitives for that matter (except if a trait is implemented for it). Also, you stated Vec&lt;T&gt; grows, so I assume ~[T] does not grow? What is its default capacity and what happens when you overflow it?
I'm not saying that `Box` should only store `Default` types, just trying to come up with a solution that works in enough cases to avoid the need for a `box` lang item at all.
For what purpose? `box` aka placement new is a general operator that all smart pointers can use. It's a very general &amp; useful concept and seems like a positive addition to the language on its own: individual smart pointers will each "reinvent" such an initialisation routine (that constructs the data directly into place) if it's not provided, e.g. something like `Rc::new(data, |d| construct_thing_using_data(d))` and `Box::new(data, |d| construct_thing(d))`.
Again this may have changed, but both ~[T] and Vec&lt;T&gt; grow, but with ~[T] you can specify a size without giving any values. So creating a ~[T] with size 7 will contain 7 None's, which can later change, and more can be added. On the Vec&lt;T&gt; side of things, you can't create one with size 7, because what would it fill those 7 spots with? Every element is guaranteed to be a valid T, so it will only grow when elements are added. To get None's in a Vec, you'd need a Vec&lt;Option&lt;T&gt;&gt;.
No, that will make `Box&lt;&amp;str&gt;` (`~&amp;str` right now). The `~foo` expression never made a unique pointer.
&gt; AFAIK, ~[T] is supposed to be analogous to a classic C array, which can be longer than the number of elements it holds as it may have nulls instead of actual objects This isn't true: Both `Vec` and `~[]` have unused capacity (i.e. extra space that's not storing actual objects). The reason `(~[]).get` (well, it's actually `(&amp;[]).get` due to coercion) returns `None` is to give a way to index *without* the risk of failure. That is, `v.get(i)` performs exactly the same bounds checking as `v[i]` except `.get` returns `None` instead of failing. For `Vec`, `.get` is just the equivalent to `v[i]` until we get proper indexing overloading, when I imagine `Vec.get` will be changed to return an `Option` after this. &gt; Therefore a T can always be returned No it can't: if the index is larger than the length there's no `T` to return; so `.get` needs to indicate this in some way (e.g. by failure, or by returning an Option). (The reason `Option` is preferred is it is a "softer" error than `fail!()` and is much easier to recover from.)
&gt; both ~[T] and Vec&lt;T&gt; grow Methods like `.push` were recently removed from `~[T]`, so it's no longer resizable at all (although it was still resizable in 0.10). &gt; ~[T] you can specify a size without giving any values You can do the same with `Vec::with_capacity`. &gt; On the Vec&lt;T&gt; side of things, you can't create one with size 7, because what would it fill those 7 spots with You can't create one with *length* 7 without supplying 7 elements, but you can create one where the backing allocation has enough space for 7 Ts (i.e. capacity == 7). The first `length` memory slots of a `Vec&lt;T&gt;` and `~[T]` have to be initialised, but anything after those (i.e. the remaining memory slots in the allocation) can be left uninitialised, because the `Vec`/`[]` functions ensure they can never be accessed.
Methods on `~[]` come from the traits [in `std::slice`](http://static.rust-lang.org/doc/0.10/std/slice/index.html). The various `Owned...` traits apply only to `~[]`. The methods for `&amp;[]` and `&amp;mut []` (defined on the other traits there) can be used on `~[]` directly too, since `~[]` currently coerces to `&amp;[]` automatically. (e.g. [`.get` comes from `ImmutableVector`](http://static.rust-lang.org/doc/0.10/std/slice/trait.ImmutableVector.html#tymethod.get).)
Of what use is `~&amp;str`? It is a unique pointer to a string reference. So, someone else already owns the object, correct?
It's not really a useful type, it's just something you *can* make like `Rc&lt;Rc&lt;Rc&lt;()&gt;&gt;&gt;`.
Not for long. In the very near future `~[T]` Will have the same representation as `&amp;[T]`.
I'm not an expert on this, but wouldn't removing `~` make it less of a special case in the compiler? Or would `box` be a special keyword/case anyway so that it's not really a win? If a user wanted to define something called `new` instead, would `box` offer more features because it's baked into the language or could the user reimplement `box` as a library?
The `box` expression is being added as a generalization of the placement new optimization. It needs to be available in general, not just for unique pointers.
The `box` expression is a generalization of the placement new optimization. At the moment you can only express this for unique pointers, and it will extend it to any user-defined function.
Sure it's possible, but it's not really what's meant by allocator here. The `box` expression will allow an arbitrary function to construct an object *in-place* rather than copying it into an allocation. This is currently only available for unique pointers, so this will be a generalization of the feature.
You're going out of your way to quote people out of context and misrepresenting their statements. A straw man argument isn't going to change the opinion of anyone who has a say in Rust's development. You seem to be ignoring that `box` is being added to support the placement new operation *in general*. It's going to be part of the language regardless of what we use for the syntax for the unique pointer type. The language is *gaining* the ability to express something it couldn't before, and removing the hard-wired special case for unique pointers now that there's going to be a general mechanism makes sense to the language developers.
This isn't the meaning of allocator that's being used here. The `box` feature is analogous to placement new + perfect forwarding in C++. 
Thank you. I think I remember that book. These days most programs use a different approach though, I think. They just play as many random games as possible and see who wins. Then they pick the move with the best probability of winning. Obviously that approach alone is too simple to write a strong AI, but it does get around the problem of writing rules to score a board.
Does this also imply that all methods on &amp;'a mut [T] will work on ~[T] as well? Currently they don't, though I got the impression from the parent post that they should.
This is one of many recent changes that reduces the amount of special syntax, though, so things are going in the direction you prefer.
Each line is actually a IoResult&lt;~str&gt;, which is a Result&lt;~str, IoError&gt;. Result is an enum (such as Option) that contains either the value you expect or an error (see http://static.rust-lang.org/doc/master/std/io/typedef.IoResult.html and http://static.rust-lang.org/doc/master/std/result/enum.Result.html) One way to check for errors is by matching on Ok(value) and Err(value). You can also achieve this by calling result.is_err() and then using result.unwrap_err() (if there is an error) or result.unwrap_ok() (if there is no error.)
But then, shouldn't this work? fn main() { // let mut x = &amp;mut[1,2,3]; // this works let mut x = ~[1,2,3]; // this does not loop { println!("{}", x); if !x.next_permutation() { break; } } } The method is implemented on impl&lt;'a, T: TotalOrd&gt; MutableTotalOrdVector&lt;T&gt; for &amp;'a mut [T] { ... } as shown [in this commit](https://github.com/mozilla/rust/pull/13761/commits). (BTW, the pull request probably needs discussion; not much is happening either for or against merging.) With ~[int], this fails with perm.rs:6:15: 6:33 error: type `~[&lt;generic integer #2&gt;]` does not implement any method in scope named `next_permutation` perm.rs:6 if !x.next_permutation() { break; } ^~~~~~~~~~~~~~~~~~ 
&gt; If you aren't willing to make sacrifices to improve performance and memory consumption, then Rust is probably not going to interest you. If there weren't sacrifices you thought it didn't make sense to make to improve performance and memory consumption, nothing other than bare assembly would interest you. Saying that good systems code is characterised by using the most computationally efficient data structures everywhere and not wasting a single cycle at any point is what one would call cargo-cult optimisation; there is no excuse in any but the most contrived situations for optimisations that cost the totality of the programmers working on the code n seconds of additional thinking time (for any reasons including understanding, sheer typing effort and bug-fixing) but is not going to save n seconds of cumulative runtime across all invocations of the code ever. (for the purposes of this comparison, we can probably convert between "wasted" memory and time by using some reasonable estimate of the expected additional time spent on cache misses/swapping.) At the same time, a quick Valgrind run over your favourite program followed by a back-of-the-envelope calculation will tell you that the vast majority of logically interesting code falls under that category. A good systems programming language is not characterised by forcing you to optimise everything everywhere at any cost; if anything, the "good" part comes from something that is quite closely related to the opposite of that, and the "systems" part comes from still allowing you to write efficient, close-to-the-metal code that you can very nearly cycle-count *when it actually makes sense to do so*.
As someone that's been experimenting/ playing with Rust for a couple of weeks, I have found the syntax to be mostly very manageable and orthogonal.
&gt; Eh, why the hostility...? The &gt;-lines in the post you are responding to were not meant as literal quotes of anyone in particular; I just tried to put headlines on classes of arguments I thought I saw being made that I wanted to counter. If you think I misrepresented/misunderstood any of them, I would much appreciate an explanation. I don't think you actually responded to the arguments made in the issue. You misrepresented them here and anyone not reading the whole discussion will have a warped view of the arguments made by the other side. &gt; Also, there is a good reason I am ignoring that it is "being added to support the placement new operation in general" - unless something about this feature actually prevents ~ from working as it did before, the question whether the syntax should be retained is entirely orthogonal to whether box and everything it entails should be introduced. Every language feature has a complexity cost. The burden is on the people who want the feature to prove that it pulls the weight it adds in terms of complexity. The hours of time I've spent dispelling confusion about `~T`, `~[T]` and `~str` on #rust is enough to convince me that it has a high cost. Nearly anyone learning the language makes a reasonable assumption that this is more special than a library type. This kind of simplification through removal of duplicate language features is a core part of Rust's language design. If you don't agree with it, then you're going to find you don't agree with the language designers overall. Here's a non-exhaustive list of features removed in the past, including purity, structural records, static inner mutability and export lists: https://github.com/mozilla/rust/issues/4707. For example, export lists were removed because it was *another way* of doing privacy. Some people liked being able to declare the whole API in one place, but Rust's design is based on providing only one way to do it. &gt; I hate to make this a "no, you"-type retort, but if anything, isn't twisting my statement into one against the introduction of box rather than one against the abolition of ~ what one would correctly refer to as a strawman argument? I'm not twisting your statements. When you say something like this: &gt; It seems to me like this is yet another case of the ideological divide between simplicity/newbie-friendliness and expressivity/power user friendliness that has been splitting a lot of FOSS communities lately (think Gnome 3). I think pointing out that Rust is *gaining* expressiveness here is fair. Here is that part of my reply: &gt; You seem to be ignoring that box is being added to support the placement new operation in general.
&gt; Saying that good systems code is characterised by using the most computationally efficient data structures everywhere and not wasting a single cycle at any point is what one would call cargo-cult optimisation This is how Rust is designed, so I guess that makes it a language all about cargo-cult optimization in your view. &gt; there is no excuse in any but the most contrived situations for optimisations that cost the totality of the programmers working on the code n seconds of additional thinking time (for any reasons including understanding, sheer typing effort and bug-fixing) but is not going to save n seconds of cumulative runtime across all invocations of the code ever. (for the purposes of this comparison, we can probably convert between "wasted" memory and time by using some reasonable estimate of the expected additional time spent on cache misses/swapping.) It's laughable to claim that a word (`box`) instead of a symbol not used the same way by any other language is somehow causing wasted programmer time. Linked data structures built with owned pointers do not have any of the nice properties they do in functional languages. You don't write the symbol outside of the type definitions anyway because Rust uses type inference. &gt; At the same time, a quick Valgrind run over your favourite program followed by a back-of-the-envelope calculation will tell you that the vast majority of logically interesting code falls under that category. A good systems programming language is not characterised by forcing you to optimise everything everywhere at any cost; if anything, the "good" part comes from something that is quite closely related to the opposite of that, and the "systems" part comes from still allowing you to write efficient, close-to-the-metal code that you can very nearly cycle-count when it actually makes sense to do so. The choice of data structures is one of the most important things you need to get right... and it's not premature optimization. You do need to worry about time complexity, cache misses and TLB misses if you care about performance. Even a tiny dynamic memory allocation is more expensive than dozens of function calls.
As long as the communication protocol is sane and documented enough, implementing another client (in another language) should be easy.
You need to type in the password before it runs the script. If you do not want to do that then *don't give it the password*.
And why would they have to make a whole web site for this? A simple gist or blog entry would have been better.
Ah, I was slightly incorrect: it works when the method takes `self`, but not when it takes `&amp;mut self` (see the definition of the `sort` method just above). The reason it fails for `&amp;mut self` is it would need to be borrowing a `&amp;'a mut ~[T]` to a `&amp;'a mut &amp;mut [T]` where the lifetimes are the same, which is impossible (`~[T]` and `&amp;mut [T]` have different representations, so the process of borrowing would have to create a new value of type `&amp;mut [T]` on the stack, and then borrow it to a `&amp;mut &amp;mut`; but this happens at the point of the call, not the place where the `~[T]` is: i.e. they have different lifetimes).
Hmm, but is this something I could fix? Declaring/defining the functions as fn ...(self) -&gt; bool doesn't change anything; you still need to do "x.as_mut_slice().next_permutation()" for it to work. I must admit, though, that I'm confused over the mutability syntax for methods. Does the "mut" keyword (not &amp;mut) do anything at all when placed before "self"? It seems that we're allowed to mutate the slice either way.
&gt; Declaring/defining the functions as fn ...(self) -&gt; bool doesn't change anything; you still need to do "x.as_mut_slice().next_permutation()" for it to work. Are you sure? The following works for me: trait Foo { fn bar(self); } impl&lt;'a&gt; Foo for &amp;'a mut [int] { fn bar(self) {} } fn main() { let mut x = ~[1i,2,3]; x.bar(); } (and doesn't work with `&amp;mut self`.) &gt; I must admit, though, that I'm confused over the mutability syntax for methods. Does the "mut" keyword (not &amp;mut) do anything at all when placed before "self"? It seems that we're allowed to mutate the slice either way. `fn a(self)` vs `fn b(mut self)` is the same as writing let x = &amp;mut [1, 2, 3]; // vs. let mut y = &amp;mut [1, 2, 3]; `x` is an immutable pointer to mutable values. `y` is a mutable pointer to mutable values. I.e. for the former you can change the values, but not the pointer (can't make it point to a different slice), but for the latter you can reassign it, like `y = &amp;mut [4, 5]`. That is, `mut self` allows to to reassign which slice the `self` variable points at, local to the method you're defining.
You're right, your example indeed works, and it does work in my code as well, now that I actually try to *call the correct method*. *sigh* :-) (Since recompiling the full build takes a while, I renamed the trait and methods to test standalone, in &lt;1 minute. I did not change the method call in main, though!) Thanks!
whats going to happen when its 'Box&lt;T&gt;' instead of ~T, are you going to have to write .borrow() 
i think Rust gets this right already - you can see *locally* what is mutable. if you want something to be immutable, you can create it as such. and with the expression oriented syntax you have ways to avoid needing the mutation at all (re-ordering things compared to C++). I hope they add the idea of loops being able to return expressions.. for{} .. else {} .. break has return value - to remove some more cases where mutable variables are used
is ~[T] even going to be kept; Box&lt;[T]&gt; .. might as well write Slice&lt;T&gt; or whatever. 
As a follow up question. Are there any performance differences?
No, it'll be a lang item.
Then you wouldn't be able to use the smart pointer of your choice.
I thought that `~constructor` allocated a new owned thing, and `&amp;expr` borrowed a pointer to `expr`. Do these things mean something different when applied to a string? I barely know any Rust, so maybe you can help clear this up for me :).
&gt; It's a very general &amp; useful concept and seems like a positive addition to the language on its own If this is true, how does one make the logic of removing `~` consistent with the logic for keeping `*`? Why doesn't `*` become `ptr`?
but they seemed to work brilliantly in the rust I originally discovered. Much more appealing than the smartpointers of C++11. Give me new vocabulary (especially different words for the same things..), its just a pain, labourious to read and write. Trawling through docs,asking someone.. "what do you call it when..." .. But give me new syntax, its a new toy, fun to use, easy to compose, easy to string together a few primitives to do what you want. 
Ok, I am confused. I keep getting told that cargo is just a dependancy manager. Is it now a build system?
Yes. `~str` was not an owned pointer to a string, it was its own type. In other words, `~T` is a type, but `str` isn't a `T`, so `~str` is a distinct type, not "`~T` where `T` is a string."
Right, that's one of the problems. Prefer stack allocation in Rust. It's been a beginner mistake to heap allocate too much, precisely because new syntax is fun, shiny and easy.
Wait, does not `Vec&lt;T&gt;` have both capacity *and* length ?
Reading the "simple" implementation proposed here, it seems that there is no copy/move constructor involved. Is this expected or just a simplistic implementation for benchmarking purposes ? I would tend toward the latter, given the implementation of `Drop`.
Yes, it has both a capacity and length. It's not able to track uninitialized holes other than at the end of the vector though like the parent comment suggested for `~[T]`.
&gt; It's laughable to claim that a word (box) instead of a symbol not used the same way by any other language is somehow causing wasted programmer time. How is this a pertinent response? To spur your memory, your response in the context of the (paraphrased) outline of the exchange up to this point amounts to roughly: * (me) "replacing '~' with 'box' seems pretty much explicitly designed to encumber and discourage the use of ADTs, when I think that if anything, it should be facilitated" * (you) "you probably should look for a different programming language, since encouraging something as wasteful as ADTs runs counter to Rust's philosophy as a systems programming language that everything should be optimised" * (me) "it is incorrect to say that an appropriate philosophy for a systems programming language is that everything should be optimised, because large parts of the code have a ratio of programmer time to machine time spent on them that is so high that any improvement of the latter at the expense of the former is foolish" * (you) "but typing 'box' does not take up much programmer time" Even if the discussion was just about ADTs rather than indiscriminate optimisation at this point, your response would be deceptive and inappropriate, since what is at stake is not the possibility of telling programmers to type more characters but the possibility of telling programmers to not use ADTs. (To respond to the half-hearted remark following the quoted sentence, though, it would be interesting to see why you don't seem to consider their arguable key property, being that algorithms and control flow can be expressed as folds over the data naturally, "nice".) I frankly find it hard to believe that you would misconstrue the context of a conversation that you were involved in to this extent by accident, and further taking your insinuation in [this response](http://www.reddit.com/r/rust/comments/24elup/rfc_remove_in_favor_of_box_and_box/ch7ln7g?context=3) that you are concerned about casual onlookers perceiving my arguments as legitimate, I am inclined to conclude that you are more interested in making my points appear discredited after a very cursory inspection of the thread than in having an honest debate. I do not think it makes sense for me to continue participating in this discussion under such conditions.
&gt; How is this a pertinent response? To spur your memory, your response in the context of the (paraphrased) outline of the exchange up to this point amounts to roughly: So once again you're going to paraphrase the other side of the argument to misrepresent it. &gt; Even if the discussion was just about ADTs rather than indiscriminate optimisation at this point, your response would be deceptive and inappropriate, since what is at stake is not the possibility of telling programmers to type more characters but the possibility of telling programmers to not use ADTs. Linked data structures (one node per element) built with unique pointers aren't efficient. That means *using unique pointers* for this should be discouraged, not the pattern in general. A b-tree is far faster and more space efficient than an rbtree because it doesn't use a node per element. It's still a linked data structure and can be represented via an `enum`. I've never said ADTs should be discouraged, you're just reaching for the trusty straw man again. &gt; I frankly find it hard to believe that you would misconstrue the context of a conversation that you were involved in to this extent by accident, and further taking your insinuation in this response that you are concerned about casual onlookers perceiving my arguments as legitimate, I am inclined to conclude that you are more interested in making my points appear discredited after a very cursory inspection of the thread than in having an honest debate. I do not think it makes sense for me to continue participating in this discussion under such conditions. It's rich that you're trying to accuse me of going down to your level when I've been quoting your comment in-context and responding to the points you've actually tried to make.
Sounds like it could be https://github.com/mozilla/rust/issues/5723
Narrowed this down to a better test-case: fn owned_iterator(slice: &amp;[~str]) -&gt; ~Iterator&lt;~str&gt; { ~slice.iter().map(|s| s.clone()) as ~Iterator&lt;~str&gt; } fn main() { let mut iter = owned_iterator([~"eg"]); //if this is not stored in a variable, the code works for i in iter { println!("{}", i); //segfaults } } The underlying problem seems to be that the cast from ~StructType to ~TraitType is allowing the programmer to ignore the lifetime of references stored within the struct, so the reference surviving beyond its variable's lifetime is being missed by borrowck. A clearer test-case for the same problem: struct Ref&lt;'a, T&gt; { ptr: &amp;'a T } trait Get&lt;T&gt; { fn get(&amp;self) -&gt; T; } impl&lt;'a, T : Clone&gt; Get&lt;T&gt; for Ref&lt;'a, T&gt; { fn get(&amp;self) -&gt; T { (*self.ptr).clone() } } fn make_getter_for_dead_local() -&gt; ~Get&lt;uint&gt; { let local = ~42u; ~Ref::&lt;uint&gt; { ptr: &amp;*local } as ~Get&lt;uint&gt; } fn main() { println!("{}", make_getter_for_dead_local().get()); } Not sure whether this is #5723 or not. The details of borrowck are a bit over my head, to say the least.
This was [just fixed](https://twitter.com/pcwalton/status/461195039180193792)!
&gt; So once again you're going to paraphrase the other side of the argument to misrepresent it. So once again you are saying I am misrepresenting some argument without actually saying what part of the representation is supposedly wrong. There is no way to summarise a conversation without changing the wording, and copying what happened up to that point word for word would have been a waste of database space. &gt; Linked data structures (one node per element) built with unique pointers aren't efficient. So with what should they be built to be efficient? Raw pointers? If you discourage every available way to implement a pattern, that is tantamount to discouraging a pattern. &gt; I've never said ADTs should be discouraged, you're just reaching for the trusty straw man again. ~~And I never said you did, you're just reaching (...)~~ edit: correction, apparently I did in the abridged version. My bad. Anyway, an argument I believe I advanced before in some form is that non-circular algebraic data types are not a viable replacement for full-fledged ones, and that you Rust won't implement them without some kind of heap pointer, all of which have now been discouraged in one form or another; accordingly, discouraging the last previously undiscouraged way of creating/referencing data on the heap without intending to introduce a replacement is equivalent to discouraging ADTs. &gt; It's rich that you're trying to accuse me of going down to your level when I've been quoting your comment in-context and responding to the points you've actually tried to make. Going down to my level? As far as I can tell, you are the only one who has tried to reframe what should have been a discussion about an engineering/design problem into some sort of popularity contest which is all about swaying the mindless anonymous masses towards one's viewpoint. [Accusing someone you disagree with of acting in bad faith](http://www.reddit.com/r/rust/comments/24elup/rfc_remove_in_favor_of_box_and_box/ch7jfxu?context=3) in the very first line of your initial response (and [pretty much showing them the door](http://www.reddit.com/r/rust/comments/24elup/rfc_remove_in_favor_of_box_and_box/ch7jkww?context=3) in another) is not acceptable in a civil discussion; if you thought I misrepresented some class of argument I was meaning to respond to, you ought to have pointed out where you thought was wrong (something you still haven't done, as far as I can tell). I can assure you I intended no misrepresentation, but it is entirely possible that I misunderstood something that was being said; at that point in time, the discussion still seemed sufficiently reasonable that second-guessing every word would not be necessary.
protocol description is 10 lines long and it can't be simpler. https://github.com/Fiedzia/rust-instrumentation/blob/master/src/instrumentation/stream_utils.rs (json response will have result or error, so its simple as well, I just haven't documented that yet). I don't see a need for rust client at the moment, but writing one would be trivial, as it really doesn't do anything fancy.
&gt; Rust isn't intended for people new to programming I hope this doesn't stay the case, and that this attitude doesn't permeate the documentation / language decisions. Why should rust be austere? Lots of people "learn programming" via C++, and I find rust much more approachable. That said, it's arguably not as "pick up and go" as python or javascript.
Any segfault in safe code is certainly a bug.
Rust doesn't have a concept of copy/move constructors. Types that implement `Drop` automatically move when passed around by value, and any copying has to be done by a manually-defined &amp; manually called function (conventionally an implementation of the `Clone` type). Clone is not implemented in that code because, yes, it's just a minimal example. (See the implementation in `std::vec` for a version with all the bells and whistles.)
Couldn't we just roll a dedicated RcVec&lt;T&gt; or RcSlice&lt;T&gt; (immutable/immovable?) if there's any potential efficiency of either layout or interface to be gained over Rc&lt;Vec&lt;T&gt;&gt;; (i'm sure you wouldn't have to repeat everything to do that) (for my own purposes I was interested in making a parameterized vec-alike taking a pointer type to allow using a relative pointer instead)
So then why the highly-visible sigil for the rare thing with fewer semantics, and the lost-in-the-noise keyword for the common thing with more important semantics?
I found this doodle amusing enough to share. macro_rules! hashlit( ( $( $key:expr =&gt; $val:expr ),* ) =&gt; ( { let mut h = HashMap::new(); $( h.insert($key, $val); );* h } ) ) Emboldened, I then set out to write a Haskell-like IoResult&lt;T&gt; combining and unpacking macro, and was dismayed to find that the macro system only supports first/rest splitting for a uniform syntax. Alternatively it may be that I'm not clever enough to write a macro that accepts both `x &lt;- something();` and `let y = non_io_computation();` syntaxes interspersed. So. Is this going to change? Will there be an affordance for making the "rest" bit a slightly wilder card?
Sure, we could, but one of the goals of DST was to reduce the burden on smart pointer implementors by having the compiler automatically do the right thing.
&gt; I don't understand why `box` is lost-in-the-noise: it's far more obvious than `~`. Not to the scanning eye, it isn’t. The eye reads text by shape first, then by semantics. You can recognize `let ~f = foo();` as an assignment to an owned pointer without even engaging the language center of your brain. Not so much for a keyword that has the same general contours as its surrounding text. (I think this is part of the reason I disliked the presence of both `&amp;` and `@` when I first checked out Rust—they both register as “square-filling glyph with internal squiggle.”)
Idiomatic code is rarely handling `Box`/`~` directly, and is especially not allocating new ones. &gt; You can recognize let ~f = foo(); as an assignment to an owned pointer without even engaging the language center of your brain This is not an assignment to an owned pointer: it is pattern-matching `f` out of an owned pointer. i.e. `foo` needs to be returning `~T`, and it's the same as writing `let f = *foo();`.
Thanks for the feedback! Updated Rust-Empty. Removed the piping to `sh` by first storing it to a file and asking the user for confirmation before continuing.
Here is a screenshot for anyone curious about what it looks like: http://imgur.com/ppQEQOg
You're not alone...
Take a look here: https://mail.mozilla.org/pipermail/rust-dev/2014-January/007986.html Out of curiosity, where are you based?
Is there somewhere one can get the sprocket logo on a shirt?
Awesome. This will be helpful. Note that with the compiler options `-O --crate-type staticlib` you'll see nothing but a newline for a simple hello world. Removing the `-O` option let me see all the glory. (Edit: Actually, this appears to be for more than just hello world. It doesn't give me output for anything.) For those of you who were not previously aware of this, it started as [GCC Explorer](http://gcc.godbolt.org), with support for Clang, G++, and a few other compilers. It seems to have changed to Interactive Compiler now, due to its support of additional compilers (and languages). The source is available on GitHub: [mattgodbolt/gcc-explorer](https://github.com/mattgodbolt/gcc-explorer). There is a [D version](http://d.godbolt.org) that doesn't seem to work yet. Be sure to play with the filter settings. I really like the colourise option.
Are you making you're functions public? If you don't have a public function then there is nothing to call so there is no reason to generate any code.
Pretty awesome! I might try and load something up with textures based off of it. Go through [TONC][1] and see if I can find a good example [1]: http://www.coranac.com/tonc/text/toc.htm
I see this discussion as orthogonal to that: C++ is hard for tooling because the grammar is *ambiguous* and context-dependant, with preprocessor hell. Rust's syntax, including ~[T], had always been unambiguous (context-free) to my knowledge, so ~ wasn't a barrier. So long as you've got * and &amp; already, dealing with extra sigil types should be easy. 
Having 'extra syntax' is better than having a more verbose language (like esp. old style c++). If you don't care much about safety, rust would be a hard sell if it didn't have advanced syntax features like pattern matching and unpacking, enums, ...
i really hope someone makes a game, prints it on a cartridge and sells it in stores as a brand new GBA game.
A fair point. I guess I should fully disclose my ideal future, just so you know that you're talking to a madman. First and foremost - I want supplementary views (beyond text) of my systems. There are [lots](http://osqa.bitsquid.se/upfiles/flow-visibility.jpg) of [languages](http://staraban.com/wp-content/uploads/2014/03/unreal-engine-4-blueprint-editor.jpg) that [provide](http://www.csee.umbc.edu/portal/help/VHDL/samples/sqrt8m.jpg) these views, but the views are primitive and the languages are in their infancy. Even the ones that have been around forever have never been spread across domains other than the one they were originally conceived in. I just don't see a lot of value in language features in and of themselves. Far more important is the ability to add meta data to your code, perhaps that meta data should always be stored intrusively with the raw code (because there's definitely value in writing procedural or functional blocks of text). Anyway, I hope that makes some sense. I follow rust because it puts great emphasis on the things that I think need to be expressed by my code (ownership of data, mutability of data). But beyond that I really just want to see rich tooling grow around a minimal language.
What about it do you find too complex? "use before mod" is perfectly sensible to me.
I think it is complex that you need to use up to 3 different keywords to actually import code from other files: `extern crate`, `use` and `mod`. What is the benefit of this compared to one keyword such as Java's `import`?
If you don't mind printing them yourself, here's an SVG version of the black Rust logo: http://www.rust-lang.org/logos/rust-logo-blk.svg (should be appropriate for putting on a shirt as well!). As for the colorized Rust logo (as seen at the top of the page here), I'm not sure where to get an SVG of it. There are some PNG versions of it hosted on Github: https://github.com/graydon/rust-www/tree/gh-pages/logos
`import` is just `use`, isn't it? Is the other stuff just kind of implicit?
also, why crate of all names? 'module' was too easy? or does it mean something different altogether?
Its a different thing. Module refers to logical unit - you can have several, even nested, modules in a crate, crate refers to result of compilation process. Having different words for both allows to differentiate them. 
Modules in various programming languages are useful for namespacing and type abstraction, but they aren't great for specifying the process of compilation, i.e. the boundaries of compilation units, their dependencies, any linkage information, etc. In some languages modules are just given these abilities directly, but this conflation of purposes muddies the waters when modules are used purely within in a single compilation unit and causes some problems when scaling up to larger programs. In other languages (including extensions for Standard ML, Racket, etc.) there is a distinct notion of a compilation unit, which has been called anything from 'unit', 'assembly', 'library', to 'crate' in Rust. I think this is more confusing than it used to be in Rust because crates aren't as much of a first-class thing in the language syntax. A file that is being treated as a crate definition has an anonymous top-level module, and the crate properties are specified via attributes on the module.
Because we support dynamic linking in native code. We want namespacing below the package level (a module) and the concept of a "compilation unit" (like a JAR), which is a crate. Rather than require you to mess around with classpaths, we built the concept of a "JAR" or an "assembly" directly into the language, with the "mod"/"crate" distinction. This is more up-front complexity but it actually makes things simpler overall, because the build logic for Rust can be very simple.
Thanks for the link...but I don't think I'll qualify (not running a meetup). I currently live in Charleston, SC, which isn't exactly a hotbed for tech. I do travel a lot for work though, so I'll see if I can stop by a Rust meetup some time :)
I've always seen Rust's integrated testing system as being for simple tests. I don't really remember much about D's version, but I imagine it's similar. While complex tests aren't really supported, the ability to quickly write tests for basic functionality ("does this sequence of operations produce a valid state?") or regression tests ("make sure that bug doesn't happen again") is very valuable. The Rust compiler uses a different testing system for compiler-level tests, since it needs to ensure that the many parts are all working together correctly. However, the libraries all use the integrated testing system because it's more than adequate for the job. I would like to see the integrated functionality made more configurable. So it could be possible to replace the current system with one that better suits your project's needs.
It's not fixed, it's just improved: hello world in C is ~10kb, and there's no language reason why Rust's hello world can't be that small too.
'library' sounds like a much more accessible name for this concept, at least in my head.
Yes (whether compilation results in dynamically linked .so/.dll or statically linked lib doesn't matter, idea is the same).
From what I understand of pcwaltons reply, `extern crate` and the other namespace related stuff is analogous to the classpath in java, just built into the language.
I've always disliked the keyword `use`. It's rather ambiguous, as you would also "use" an external crate or "use" a local rust module file. I now read `use` declarations as `alias a::b::c`.
I do like the fact it makes files namespaces , avoiding needing a extra namespace entity within the files, or the times you use a class just to group some things together.. (you've already got the files/directories doing that). so, within a file you can just go ahead and write functions without feeling like they're disorganized. I always trip up with the switch from relative to global paths between use and the actual code, but error messages could help (when you get something wrong, it could tell you the actual path(s) to any matching symbol, and what to do to make it visible.)
The problem I have with testing is that there's no easy way to say "this should be a compiler error".
Thankfully it's not part of the language, and is merely a feature of the compiler. Given the power of dynamically loaded syntax extensions, everything the built-in unit testing does can be done outside of the compiler now.
I'm pretty sure Nintendo has a very strict certification process around that.
The compiler test suite uses the `compiletest` program for that kind of thing. I believe that /u/nikomatsakis has some plans to allow compile-fail tests to be defined like normal unit tests, but it requires some very nontrivial changes to the compiler, so I wouldn't expect to see it in the near future.
 &gt; I don't agree with keeping tests together with the code under test This is a fundamental issue that many testing libraries and languages struggle with. However, I think it's fair to say that practically speaking having unit tests inside the code files in rust is extremely effective. Don't know how something works? Open the source file. Don't know how to use it? Open the source file. Need to fix a bug? Add a test to the source file tagged with the bug id. Want to see a history of bug fixes for a code unit? Open the source file. It's very effective. The #cfg option also lets you do some very nifty things like: different tests for different environments, tests that include large code segments (even *entire code directory trees*) which are only included in test builds. There are situations where its not terribly useful; as you say, for example, I guess, some database integration tests or something where you need to have some complex per-test setup and teardown operations. ...but I think it's a bit harsh to say built-in rust testing is categorically harmful. There is absolutely space for 3rd party testing libraries to step in. eg. #[cfg(test)] mod tests { // &lt;--- Notice this is not even compiled for non test builds extern crate Mocker; extern crate rTest; use Mocker::mocksyou; ... whatever } 
While I don't mind the module system, I do find it has some odd parts to it: **1) Mod is odd.** mod x; &lt;-- import file x *as module x* mod x { ... } &lt;--- use ... as module x Not confusing at all right? mod x { fn hi() { println!("Hi"); } } fn main() { x.hi(); } Woops, no, that didn't work. Defining a module doesn't import it. For some reason I keep wanting to put mod foo { .. } inside foo.rs to make it obvious when you have a million files open which module you're looking at; maybe that's just too much C# namespace habit creeping through I suppose. **2) Use has to be first.** mod x { fn hi() { println!("Hi"); } } use x::hi; fn main() { hi(); } What? No? Use has to be first? That doesn't make any sense. You have to use it *before* it's defined? I understand why, but you have to admit, logically that makes no sense. **3) Extern crate n; self::n;** You know what I'm talking about. extern crate n in the root of a crate and you can just use n::blah. ...but if you put it into a submodule you have to use self::n; or you get an obscure error message about 'maybe you need extern crate n'. **4) Obscure super:: importer** Seen code like this? I have. struct Foo; #[cfg(test)] mod test { use super::Foo; #[test] fn test_it() { let _ = Foo; } } Why is that a thing? It's totally hacky; it's like the from .. import blah in python; seems entirely harmful (for all the same reasons as in python). **5) mod.rs** Oh, oh oh mod doesn't do enough things already; mod x can also import a *directory*, but if it does it imports x/mod.rs, which has to have a manually generated list of mod a; mod b; mod c; in it. It's useful (eg. exclude some file) but it's also awkward to use. ... Like I said, I don't mind the module system that much, but you've got to admit, it's got some rough/odd edges.
&gt; Not confusing at all right? You can think of `mod x;` as literally just sugar for `mod x { &lt;contents of x.rs here&gt; }`. &gt; x.hi(); &gt; Woops, no, that didn't work. Defining a module doesn't import it. The reason what you've written doesn't work is because the syntax is actually `x::hi()`. It should work fine if you write that instead of `x.hi()`.
woops; you're totally right on that one. my bad.
Posted: https://github.com/mozilla/rust/issues/13929
Here's the repo: [libgrave](https://github.com/HeroesGrave/grave) It's not documented at all at this stage.
In this example from [Piston](https://github.com/bvssvni/piston/blob/master/src/lib.rs) you see how the power of the module system comes into play: * It lists the external crates which the library depend on * It tells which objects you expect to find at top level with `pub use` * It tells you there is a utility module `pub mod shader_utils` that might be useful, but not essential to use the library * It tells you which source files that comes with the project * All this information is grepable from the command line! In C# you depend on the IDE to for the same information. As somebody who had to re-setup a large code base several times in C# I absolutely prefer the Rust way. It comes at a little additional mental cost but gives you the flexibility you need to maintain larger projects. With Rust's module system you can have a flat file structure while providing a deep module tree for the API. You can have a deep file structure while providing a flat module tree. All this can be done in `lib.rs` without any other sub module caring about where the source is.
&gt; Can you be more specific regarding the deficiencies that you see? Well... I would like more fine-grained control than the general-purpose `assert!()` and `assert_eq!()` (a "test interface"). And setup/teardown logic. And mocking. And (more obvious) encapsulation. And [testdox](http://agiledox.sourceforge.net/). The key is that the tools D and Rust provide are so basic that you can achieve most of these things with a little work, but a dedicated tool can do it better. It becomes difficult to draw the line between what should and should not be within the scope of `#[test]` (most of this probably shouldn't be). For what it's worth, I'm glad it's a compiler feature and not a language feature (I didn't know). I think the concern I have with native support is that a language (or a compiler) can't and shouldn't be expected to have all the features of a dedicated tool. The integration may signal to newcomers that "this is the [language] way of testing" when it's more of a quick'n'dirty alternative to manually building a test program on the sideline, the way you'd have to in another language without depending on a separate tool. I don't know if I'm making all that much sense, and maybe I'm just being overly paranoid.
i know :-( but it would be cool. it wouldn't hurt them to open up their older consoles.
I was trying to articulate my confusion around the crate/mod system last night and failed. This post is exactly what I was trying to articulate. As a beginner, I honestly spend more time trying to satisfy the compiler with just importing code than I do actually coding. It always devolves into randomly mashing `extern crate`, `use` and `mod` until the compiler is happy. And just when I think I've figured out how it works...I realize I don't because the compiler yells at me again.
What's your background, in terms of what language(s)/platforms are you most comfortable coding and writing tests in? I think that's some useful information to have for this conversation. I get the distinct impression that you're bringing some loaded expectations to this discussion that haven't been shared with everyone else. At this point, I can only speculate on your background. I'd consider it a great favor if you'd give some background on your experiences; it'd help me give my own answers your questions and respond to your assertions about Rust's approach to testing, to date. (Regarding my experience: I've written many many tests for the rust standard library and runtime in the course of my contributions using existing tooling. I'm also a mid-career software consultant, writing mostly full-stack C# &amp; JS, who's practiced TDD day-to-day for almost a decade, with all of the tooling/baggage that implies).
Thanks, this one was very useful.
Looks cool! I have a similar (but much jankier) solution in my code. I may adopt yours instead :) I'm curious, would it be better to select!() on the broadcaster rather than blocking on the message receiver? For example, imagine the application registers 1,000,000 channels to "tune in". The current code will queue those million channels until the first message is sent to the broadcaster, then process them sequentially. This basically makes it impossible to know the latency of the broadcast, since you may have to process a huge number of channels first. Could also have non-negligible performance profile (big jump in CPU, etc). If you selected on both channels, then you would process the listening channels as they arrive and amortize the cost over the lifetime of the broadcaster. All that said, I only skimmed the code, so maybe I'm missing a reason for the structure :) BTW, I like your trick to retain only active channels on send, very clever.
Would it be possible to just write `use` and let the compiler infer which mods and crates are needed? I think this would keep the power of the mod system, while making it more simple to use in many cases.
&gt; I get the distinct impression that you're bringing some loaded expectations to this discussion... I definitely am. I haven't deliberately tried to keep this element out of the discussion, but I have tried to avoid devolving into a discussion about what constitutes the optimal degree of Uncle Bob-ness. I doubt any good would come of that. I've been in the industry only for a few years, and additionally my employers haven't officially practised automated testing, so I have had limited exposure to real-world tests. My expectations are also lightly coloured by university, which, for better and worse, rarely matches the industry. The topic of testing interests me, however. I work professionally with PHP and I have most experience with [PHPUnit](http://phpunit.de/getting-started.html). I have passing familiarity with JUnit and NUnit but haven't used either in quite some time. It's my understanding that they all have (had?) the same basic approach to testing and structure of test suites and can be quite configuration-heavy. I've used [VS' .NET test harness](http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx) on a few occasions. Testing of D's and Rust's standard libraries have challenged my views specifically in these ways: * Tests are often not physically separated from code under test. This *can* lead to encapsulation issues in D but I don't know if it does in practice, and I have no idea how Rust compares (I note that tests tend to have separate modules). * Tests seem to be very implicit. For instance, I don't think I've seen a custom assertion message in the (mere handful of) Rust crates I've looked at. This seems to reduce long-term comprehensibility and maintainability of the tests themselves, along with their usefulness as auxiliary documentation beyond syntactical how-to (which does have significant value on its own). * Tests as first-class documentation. D uses this in a few places. I've personally viewed tests as the tool with which to enforce explicit contracts rather than the language of the contracts themselves.
I think mentioning D's `unittest` system in the same sentence as Rust's `#[test]` system is a great disservice to Rust. Even though it's simple, Rust's offering is incredibly more useful than what D has. Consider these 2 equivalent files (first in D, second in Rust): import std.stdio; unittest { writeln("Pass 1"); } unittest { assert(false); } unittest { writeln("Pass 2"); } void main() {} And Rust: #[test] fn test1() { } #[test] fn test2() { assert!(false); } #[test] fn test3() { } As you can see, the second test is meant to fail. Let's run the two test suites. First D: Pass 1 core.exception.AssertError@test(10): unittest failure ---------------- ./test(_d_unittestm+0x47) [0x4580cb] ./test(void test.__unittest_fail(int)+0x1a) [0x45735a] ./test(void test.__unittestL8_2()+0xe) [0x449d9e] ./test(void test.__modtest()+0xe) [0x45732e] ./test(int core.runtime.runModuleUnitTests().__foreachbody3(ref object.ModuleInfo*)+0x30) [0x4620ac] ./test(int rt.minfo.moduleinfos_apply(scope int delegate(ref object.ModuleInfo*)).__foreachbody2(ref rt.sections_linux.DSO)+0x4c) [0x45ae0c] ./test(int rt.sections_linux.DSO.opApply(scope int delegate(ref rt.sections_linux.DSO))+0x42) [0x45ae82] ./test(int rt.minfo.moduleinfos_apply(scope int delegate(ref object.ModuleInfo*))+0x25) [0x45ada5] ./test(runModuleUnitTests+0xae) [0x461f42] ./test(void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()+0x17) [0x459303] ./test(void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate())+0x2a) [0x4592b6] ./test(_d_run_main+0x1a3) [0x459237] ./test(main+0x17) [0x457377] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf5) [0x7f33615e1de5] And now Rust: running 3 tests test test3 ... ok test test1 ... ok test test2 ... FAILED failures: ---- test2 stdout ---- task 'test2' failed at 'assertion failed: false', test.rs:9 failures: test2 test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured task '&lt;main&gt;' failed at 'Some tests failed', /home/.../src/rust2/src/libtest/lib.rs:222 Consider these fundamental differences: * Rust has named tests, runs them in parallel (note how test3 happened to be first), outputs nice statistics, runs the tests separately from the main program. * D doesn't have named tests, *stops the test execution on first failure*, no output at all (I added those `writeln` statements so we could see what happens) and runs alongside your program (that's why I had to add a `main` function...). And there are plenty of differences not shown: * Rust also supports 'expected failure' tests, which I don't think D does. * Rust has benchmarking support. * Rust actually compiles a test harness, which has command line arguments for sharding, and benchmark ratcheting (so you don't regress on speed). *You can also run a specific test*/ I'm sure more things can be added here in the future to make this even more compelling. I don't think you realize just how bad D's system is. I maintain a very large D codebase with lots of built-in unittests and I had to write my own test runner to mimic some of the features that Rust's system gives you by default. The only thing I am currently missing is that there is no way to test for compile failure (I encode many constraints into the type system and it'd make me much more confident in them if I could test them)... I only need borrow checking and type-checking failures, which seems to me to be easier to do than parsing and lexing errors.
There needs to be a way to set the privacy of modules and crates. It's also very useful while reading the source code to have the modules and crates listed out.
It used to be called `extern mod` and I think it was a more sensible name... the term "crate" is only meaningful if you've already learned Rust.
&gt; I don't think you realize just how bad D's system is. It would be more accurate to say that I didn't realise how much more useful Rust's is. I started the discussion precisely because I had been very unimpressed with D's `unittest` and thought Rust might have made the same "mistake".
TL;DR - you're used to working in highly abstracted platforms. Many of the assumptions you bring, coming from that perspective, aren't valid in Rust. This doesn't preclude you being able to grasp our preference, as a community, or make your opinion invalid. But I don't think it's constructive to initiate this conversation, based on the relative knowledge gap between this two scenarios (PHP/webdev and Rust/systems programming). To say anything beyond this would become a personal attack, which I am loathe to deliver. More in-depth: * By saying that I'm a .NET dev, I wasn't expecting you to be able to relate to my situation specifically (e.g. proclaiming your familiarity with NUnit). I wanted to point out that I'm well experienced with testing in highly abstracted platforms (which includes PHP, Java, .NET, Ruby, Python, etc etc etc), which I (rightly) guessed was where you're coming from. You'll find that this piece of context, and everything that falls out of it, is pretty much the crux of my response/critique to your observations. * From what I've gathered, based upon your comments, this isn't a discussion about the "uncle-Bobness" of Rust's approach to testing. This is a discussion about the technical implementation details of Rust's testing infrastructure and how that influences how we test the Rust compiler, runtime and standard library. Rust's approach to testing is born out of the nature of the space in which Rust's operates, much as is the case with what's the state-of-the-art in other platforms. * Re: separating the SUT and test themselves isn't a physical requirement in Rust's testing facility, it's merely a convention that's used (extensively) in the Rust codebase. Part of this a value judgement/opinionated choice of the Rust core team, and the other is that there's no cost for the Rust community to put it there (because all #[cfg(test)] code is stripped out during non-test builds). It isn't a technical limitation, it's a deliberate choice. To further drive this point home, you'll see there are many tests that are explicitly *not* in the actual src codebase, specifically run-pass/run-fail and friends. Also, I dispute your implicit observation that separating the SUT and test code is inherently superior, as a general code compositional heuristic. It's just different from what you're accustomed to. The reason that D and Rust both do this is because the kind of test-runner magic you get with .NET, Java, PHP, etc where it's easy to point a test runner at external resources (whether they're scripts, assemblies, JARs, whatever) is a lot more cumbersome in Rust. You'll find that this approach (co-locating tests w/ code) is more in-common with C++, where tests are often built/ran as a special case executable of the main bin. This also brings up another point I think it's fair to make about an unspoken bias of your perspective: In highly abstracted platforms, you can get away with subordinating the design to the goal of testability because most of those design choices are also a part of well-abstracted systems that are appropriate to that platform (because everything's on the heap and reference types are used 99.9999% of the time, anyways!). Programmers using languages/platforms like Rust, D and C++ will want to avoid subordinating design (and performance) to the goal of testability. In .NET, people are ok with making all service actions be virtual calls because there are lots of other, orthogonal benefits to doing so beyond easing mocking/stubbing at test-time. This is often an unacceptable performance concession for applications in Rust/C++. Even in Servo, the codebase which has driven the much-argued-about, still undecided inclusion of inheritence-driven virtual calls, the use of virtual is carefully measured and weighed against other abstractions (I'd even say it's only been adopted as a last resort because of the historical baggage of the DOM and it's roots in C++-style OO, but others can speak to this better than I). That isn't to say that we won't eventually have IoC containers and mocking frameworks in Rust, but it probably won't happen until we see Rust being used to write enterprise/line-of-business software where business domain trumps technical soundness and performance (and the day *I* can bill hours to write Rust will be a happy one, indeed). * Regarding the nature of tests (being too implicit, lack of comprehensibility, etc). The best I can say is: TDD/BDD and the touchy-feely "let's use tests to drive implementation and ease-information sharing/onboarding for people un-used to the codebase" is an *opinion* that was formed in the context of enterprise/line-of-business software where communicating correctness of the business domain for follow-on maintainers was the primary concern. Much like how the Theory of Relativity and Quantum Mechanics break down under special circumstances (like during the big bang), the idea of tests-as-documentation doesn't really work when the business domain is "let's make IO work on (at least) three mature OS platforms" (as just one example). *If the following paragraph is based on a strawman, I apologize. Please set me straight.* I also get the impression that you're unimpressed with Rust's test infrastructure because it's common to just use assert!() directly, as opposed to a more sophisticated Assert.That(foo, Is.EqualTo(bar)); style APIs prevalent in mature test/spec libraries on other platforms. This is the very definition of gold plating. This is akin to the idea, in my opinion, that the use of vim-keys makes a developer legitimately more productive over their career (disclaimer: I'm a dedicated vim-keys user). Much as is the case vim-keys use, no one has ever *shown* that more robust assertion APIs actually accomplish the goal of making tests more robust, as opposed to making the writer of said test feel test like that's what happening. Again, if this graf is extrapolating from a point that you didn't actually make, please let me know. Now back to our regularly scheduled program. * Rust the language/library, unlike most of the application code in the languages I use as a counterexample, is focused on system interaction and the soundness thereof Practically speaking, this means that most of Rust's automated *unit tests* are actually *integration tests* (and this distinction is really only important to programmers working in particular application classes where there are lots of dispirate, IO-bound resources that're involved in a full-stack test). You don't mock out the filesystem when your tests are verifying that your libraries work correctly with the filesystem API of the host platform. The same applies to most other IO tasks in the stdlib, code generation/LLVM interaction and many other things. This is a problem D, golang, msvc, etc all share and is present in their automated test infrastructure. This is also why there's no flashy answer to your question about whether there're mocking frameworks for Rust. More then likely, if someone wants to mock/stb something in Rust today, they just hide the real implementation behind a trait and then write a test-centric implementation of said trait for satisfying the dependency they want mocked/stubbed during the test. ------ Anyways, I don't have much else to say. If you've made it to the end of this rant, thank you.
I'm getting a failure when running the code. :)
That's very impressive! I remember reading somewhere that NES games were written in ASM directly, does anyone know if the titles for the GBA were too?
This is a very good breakdown. I neglected to frame Rust in the context of its compiler, a systems language, and Servo, not to mention its unstable nature, and that makes a lot more sense. My interest in Rust is limited to the language as a potential future replacement of general-purpose C++ (and D), because I'm tired of dealing with its shortcomings despite liking it as a language, though I know that isn't really a goal.
Could you tell me what runtime failure you're seeing? Edit: all of the spawned tasks to demonstrate receiving from the broadcaster will fail once the task holding the broadcaster completes, so that should be expected.
That is a very good point about the broadcast latency. In general I haven't even been thinking yet of what happens when dealing with large numbers of consumers; my use case for this now is as a way to distribute an incoming Open Sound Control stream to a handful of tasks, so adding or removing new consumers is a rare operation. I wasn't aware of select!(), or a mechanism in general for blocking on multiple recv at once, so that's great. I'll read up on select!() and see how that works out. EDIT: I'm not sure how select!() behaves if both receivers have data available; if the broadcaster has a constant stream of messages to handle, new consumers may never get added! EDIT^2: It looks like, at the moment, the particular implementation of select! would always return the first channel handed to it if both have data, so new consumers would NEVER be added if the broadcaster always has a new packet ready to send. Moreover, the actual behavior of select! in this case is unspeficied in the interface. On the whole, the source for Select is full of comments along the lines of "damn this implementation sucks someone should make it better later" :) Also, as I'm looking at this again, the behavior of the sender if the controller has been dropped could be further optimized. Now it will always try to receive from the controller even if the channel has closed, every time it receives a new message to send. I may add an optimization such that once the controller has dropped, it never polls that channel again. Yeah, using retain() works really well. It has O(n) overhead for removing *any* number of dead senders.
I dont see any problem with them providing 'simple' testing , its great to have a default way of doing this IMO.
Fair point, but we've still got a long road to 1.0—it's a good enough fix for the short term!
&gt; 2) Use has to be first. That's just a bug as far as I'm concerned. It has to do with the fact that the name resolution algorithm was originally written for a far more powerful module system and was toned down over time. At this point the name resolution pass does only does what you expect if `use` comes before all declarations. In the interests of backwards compatibility I required you to declare the order in which the algorithm actually resolves names. In the future we can relax the restriction if the name resolution algorithm is modified to do the right thing with mixed `use` and declarations. &gt; Why is that a thing? To help code generation (e.g. macros), among other things. It means that you can have module `use` statements that don't depend on the absolute hierarchy something was imported at. &gt; Like I said, I don't mind the module system that much, but you've got to admit, it's got some rough/odd edges. I think we should probably take RFC #63: https://github.com/rust-lang/rfcs/pull/63 It seems that the problem is not the way the module system works, it's that the module system has too much power. The module system is pretty much straight from JavaScript, which is straight from Racket/Scheme (a language that puts a *lot* of thought into modules). Unfortunately, the power that the module system has means that a lot of people accidentally use the powerful bits of the module system (such as being able to anchor any file at any point in the module hierarchy) and get confused. So perhaps some tightening up of the restrictions is in order.
Idea is nice, but there's actually no library yet. I'll watch maillists through. 
~T is readable in the same way &amp;T and [T] are readable. They're all fundamental concepts to how memory is managed in Rust, so claiming that Box&lt;T&gt; is clearer is disingenuous- everyone will already have to learn the concept of an owned pointer regardless. There is also no reason ~T couldn't support custom allocators- C++ can associate operators new and delete with a type as well as extra arguments- Rust could easily do the same. On the allocation side (as opposed to the type side), unnecessary use of ~ can easily trigger a warning, a lint, a hint from an IDE, whatever. This is more a problem of culture than anything, but really "box foo" is fine (although it does make tree structures for e.g. parsers a little painful). However, I'm not opposed to putting Box&lt;T&gt; in the standard library alongside Rc&lt;T&gt; and Gc&lt;T&gt;. It would just be nice to keep the sugar (and potentially even bring back @ the same way). I'm just wary that "we can always put it in as sugar after 1.0" will become "we can always put it in as sugar after &lt;next something&gt;".
Looking forward to seeing how this develops. It's not every day you get the front row seat to watching something either become really big, or fade into obscurity. 
I'm sorry but this seems just stupid. Is the author thinking that expert cryptographers will flock to build a new protocol suite just because he wrote a snazzy web page? There is no mention of a team or funding to hire one. Even if he somehow magically managed to create a viable protocol, there is no mention how he thinks it will get adopted. I'm going to say even that picking Rust is bit odd. The programming language is very much an implementation detail for this sort of work, the spec should come first. Fixating on the programming language before any actual work has been done seems like putting the cart before the horse. Besides he can't really rely on anything that Rust provides because if he hopes that the protocol will reach a status of any sort of standard then it will have C implementation, more likely several of them. So the protocol needs to be safely implementable in C without major pitfalls.
I think it's worth rethinking how to write software when a language like Rust comes around. Now it becomes feasible to write fast &amp; secure code within a domain that for a long time has been occupied by unsafe languages. Just go for it!
&gt; There's actually already a team that are desing a protocol — http://tcpcrypt.org/. And while they're are desing the protocol, required cryptographic parts (RNG, cyphers, etc) can be implemented in rust. So there's a point. As far as I can tell, the author does not plan to use tcpcrypt at all. If he was just going to implement (and possibly supplant) tcpcrypt protocol in Rust, then the project would be more sensible. But it seems he is going for a completely new protocol design.
Yes, I think Rust probably is a wonderful tool for building a secure crypto lib. But that is not what the project is about. It is designing a new protocol. Any protocol that would replace something as central as TLS will have a C implementation, that is just inevitable. Sure the reference implementation might be in Rust, but that would be just that: a reference implementation. It is because C is such a bad substrate for crypto protocol implementation (as you say) that its handicaps should be acknowledged in the protocol design. Because no matter its flaws there will be people implementing the protocol in C. 
Cool, I had never heard of tcpcrypt. The website makes it look like a dead project but there's some new development on a new ietf mailing list: http://www.ietf.org/mail-archive/web/tcpcrypt/current/threads.html
Thanks! As someone who is currently trying to learn graphics programming via using glfw, I've liked being close to the metal, so to speak, where I am interacting directly with gl calls. However, I also want to eventually play around a bit with SDL, SFML, and maybe Allegro, and find out what exactly they abstract for you, so that I can better understand everything. Hopefully at that point, I can decide if I want to jump up to one of those three, or stick with writing my own utilities as you've done while continuing with glfw.
Yup! If you need two pointers to something, you can't have unique ownership... Think about this: what you want is a list, and then a reference to its head and its tail, right? What you have now is two separate lists. Just own one and keep two references as well. I hope that gets your brain going.
Thanks!
Yeah, such things can be implemented as raw pointers with careful and safe abstractions over them, so the end user won't notice it from outside. `Rc`/`Gc` approach is equally valid and is in fact the preferred way (in fact the only one sans raw pointers) to work with self-referential structures. Unfortunately, documentation on it is still lacking. The main modules of interest are [`std::cell`](http://static.rust-lang.org/doc/master/std/cell/index.html) and [`std::rc`](http://static.rust-lang.org/doc/master/std/rc/index.html). It would also be helpful to understand what [weak references](http://static.rust-lang.org/doc/master/std/rc/struct.Weak.html) are and when to use them.
&gt; The project is presently complete vaporware This clued me in ;)
Thanks, interesting to read as always. So the ~ stuff isn't official then?
The RFC was officially accepted, just not implemented yet.
The new Pelican theme is a big readability improvement. TWIR just keeps getting better and better.
Thanks for writing! Lots of interesting stuff this week...
After all the other changes, the only real place `~` is used is in the type signatures for functions. &gt; I don't know what problem you people have with sigils; my right brain loves them. I love sigils too, but I don't like sigils that special case what's already generally considered to be bad behavior.
Agreed, that's a very nice-looking theme. Maybe needs a little more whitespace above headers, but overall, great job.
Yeah, I've got some nerve complaining when I don't even know the language, and don't remember the arguments around this. I see; so .to_owned() is deliberately ugly to reduce its use eh? Well, that's something then. 
It's not even that, it's that you shouldn't be using `to_owned()` that often in the first place. The majority case: let x = ~5; is now let x = box 5; +2 characters, -1 punctuation character. Not a big deal.
It is strange, I'm pretty much in favor of this change. Coming from C#, I remember the confusion when first encountering `~[]` and `~"hello"` and just thought "why can't this be just a string" until I learned more about `&amp;'static str` (which took a while). The `.to_owned()` explains perfectly what it does.
I think Rust scales very well, both performance wise and in abstraction. One key of designing libraries is looking at traits as an abstract class (like an interface, but more powerful). You can minimize the number of methods required to implement the trait while at the same time add nice 'sugar'. All these extra methods comes at no cost and adds expressiveness to all types implementing the trait. Just look at this [code example](https://github.com/bvssvni/rust-graphics/blob/master/src/relative_rectangle.rs). You can then write `c.rect(x, y, w, h).left()...` instead of `c.rect(x - w, y, w, h)...` On top of this you have generics. Rust is really good at giving you high abstraction without sacrificing performance.
The syntactic reasonings might be sound at an elementary level, but all I get from the verbosity is the feeling of being punished for using strings.
Like I said in http://blog.octayn.net/blog/2014/05/04/new-blog/, I'm not a huge fan of the theme visually, but it seems people like it, and I don't publish the blog for myself. Any other critiques?
In cases where you need a `Vec&lt;~str&gt;` you can take a `Vec&lt;&amp;'static str&gt;` and do `.iter().map(|s| s.to_owned()).collect()`. This way you don't need to type `.to_owned()` for every string. Allocating on the heap is quite expensive. I like to know upfront which parts of my program that could benefit from some redesign. I completely understand not everybody feel good about this. It would be nice to have `"hello"` inferred to `"hello".to_owned()`, just like `0.0` is infered to `0.0f64` or `0.0f32`. Maybe that's the plan? I don't know.
Rust will get you really far in terms of scaling abstractions. It also readable, has usable standard library (no "batteries included", but it will improve with time), so there is really nothing stopping you from using it for high level stuff (apart of its lack of maturity). It definitely doesn't have all those factors that cause people to run away from c as soon as possible. It will never compete with dynamic languages in areas where dynamic matters (there is no equivalent of ipython for rust), but overall its really pleasant to use decent language. However thinking long term, I'd keep in mind that it might be that rust got as far as reasonably possible in terms of high level features for low level language, while other non-system level languages will continue to evolve.
I've already written a bit about my opinions on this: http://words.steveklabnik.com/rust-is-surprisingly-expressive
&gt; In cases where you need a `Vec&lt;~str&gt;` you can take a `Vec&lt;&amp;'static str&gt;` and do `.iter().map(|s| s.to_owned()).collect()`. This way you don't need to type `.to_owned()` for every string. If you need ownership of a value in a function, it should be part of the function signature. This allows the caller to avoid allocation if they already have ownership of the value. In most cases you should use an iterator of slices, not a vector. If you only need a view, you should use a slice (`&amp;str`), which is not necessarily `'static` - it's a view inside *any* string. &gt; It would be nice to have `"hello"` inferred to `"hello".to_owned()`, just like `0.0` is infered to `0.064` or `0.0f32`. Maybe that's the plan? I don't know. Nope, it's not the plan. I think `StrBuf` (renaming is planned) will be the most widely used string type behind slices (`&amp;str`).
You should use a slice any time you need an immutable view, and string literals give you one with a `'static` lifetime. If you need a mutable string, then you need `StrBuf`, *not* `~str`.
A Rust library can expose a C ABI and be perfectly usable from other languages. It doesn't just have to be a reference implementation.
&gt; It will never compete with dynamic languages in areas where dynamic matters (there is no equivalent of ipython for rust) I don't think dynamic typing is needed for something like ipython. A statically typed language would be just as pleasant if it wasn't trying to tackle the same performance / safety concerns Rust deals with via lifetimes and ownership semantics.
I mostly dislike the fact that if I annotate a string type, I must append `&amp;'static` or instead choose `~str`. If I then choose the latter for a struct or function, I must also explicitly write `"foo".to_owned()` each time I need to pass in a string, while writing `box "string"` (significantly more pleasant to write and read) is not allowed. Again, this is extra verbosity that's not needed for anything else. I understand the reasoning behind each individual step, but it still doesn't change the fact that, right now, strings feel like Rust's unwanted stepchild.
You could take an iterator over any type fulfilling `Str`. All of the string methods will end up factored out onto a trait in order to share the implementations between `&amp;str` and `StrBuf` without wrappers.
I think Haskell is much less pratical than Rust.. enforcing the programmer to always use immutability for instance, make some details better, like in concurrency for example, but when you figure out that you need to implement Okasaki functional data-structures, you immediately realize that you just traded some problems for others.. at least Scala get this better
So, why is unary negation even *defined* for unsigned integers? That seems like something we should rectify.
It is useful for bit twiddling
Also you must hold shift and the tilder key is up in the corner of the keyboard. But there is an extra space.
Yup. It works like this: let x = ~5; let y = @6; is now: let x = box 5; let y = box (GC) 6; This does 'placement new.' The allocator gets passed in, but defaults to `HEAP`. In other words, `~` was just sugar for `Box&lt;T, HEAP&gt;`, combined with placement new. Now all smart pointers work the same way, and can do placement new.
Most likely two's complement. So `-x` is equivalent to `!x + 1`, where `!` is bitwise negation.
bitwise, exactly the same as negating a signed int. If you like, it is `-(x as int) as uint`. In terms of bit twiddling, it retains the least significant `1` and all `0`s to its right, and flips all the bits to left.
There's no easy way to do it. In theory you could use &amp;~List for a tail pointer and pull lifetime scopes into convoluted positions to make it work, but I'd use unsafe pointers; struct Node { value:int, next:Option&lt;~Node&gt; } struct QQ { head: Option&lt;~Node&gt;, tail: Option&lt;* mut ~Node&gt; } impl QQ { fn push(&amp; mut self, x:int) { match self.tail { Some(tp) =&gt; { let mut tail:&amp; mut ~Node; unsafe { tail = &amp; mut (*tp); } tail.next = Some(~Node{ value: x, next: None }); self.tail = Some(tail.next.get_mut_ref() as * mut ~Node); }, None =&gt; { self.head = Some(~Node{ value: x, next: None }); self.tail = Some(self.head.get_mut_ref() as * mut ~Node); } } } // Should probably be Result&lt;int, Err&gt; but I'm being lazy. fn pop(&amp; mut self) -&gt; int { if (self.head.is_none()) { return -1; } else { let local = self.head.take().unwrap(); let rtn = local.value; self.head = local.next; return rtn; } } } #[test] fn test_push() { let mut q = QQ { head: None, tail: None }; q.push(1); q.push(2); q.push(3); q.push(4); } #[test] fn test_pop() { let mut q = QQ { head: None, tail: None }; q.push(1); q.push(2); q.push(3); q.push(4); assert!(q.pop() == 1); assert!(q.pop() == 2); assert!(q.pop() == 3); assert!(q.pop() == 4); assert!(q.pop()== -1); } Just remember unsafe pointers aren't a magic bullet to solve all your problems. If you have two mutable variables that are used in the same scope that refer to the same pointer (which is easy to do with unsafe pointers), you get undefined behaviour. ...which probably means random crashes, practically speaking. Notice how in this example: Some(tp) =&gt; { let mut tail:&amp; mut ~Node; unsafe { tail = &amp; mut (*tp); } tail.next = Some(~Node{ value: x, next: None }); self.tail = Some(tail.next.get_mut_ref() as * mut ~Node); } Is careful to make sure that we don't use anything else that tail might be pointing at (eg. self.head). However, try adding a q.push(1); q.pop(); to the end of that second test. Wooooops! Segfault. ...and that's why unsafe pointers are unsafe. (To fix pop should include: if self.head.is_none() { self.tail = None; })
Please increase the line height just a little bit for both `&lt;p&gt;` and `&lt;li&gt;` tags, even just 0.1em IMHO the current line height makes the body text seem a little squashed.
I think even str!("foo") would be better than "foo".to_owned()
I think Servo is pretty much a example of a "general purpose" software being implemented in Rust.. Has non-trivial implementation details that cannot be expressed right without a powerful language behind it
I personally love these changes. One of the problems with C++ is its numerous non-orthogonal features that conflict in interesting ways. By removing stuff of non-zero but dubious value, the Rust people leave more room to evolve the language in ways that will get more bang for the buck.
Not totally fixed. On my RHEL6 (Linux system) both GCC and Clang create HelloWorld executables about 6.5K in size. The same program in Rust compiles down to 687K (build 0.11-pre bd3fb81).
There is in fact an [IPython for Haskell](https://github.com/gibiansky/IHaskell), so static typing is not an issue there.
I would expect `str!(literal)` to produce `StrBuf`, not `~str`. I don't think it's an improvement over `literal.str()` anyway - why use a macro?
I appreciate you typing all that up. I'll try to figure it out later. I spent the better part of my evening trying to make it work with `Rc` pointers. I had it partially working, not sure if where I left it even compiles but here it is: use std::fmt::Formatter; use std::fmt::Result; use std::fmt::Show; use std::rc::Rc; trait Queue { fn offer(&amp;mut self, data: ~str); fn poll(&amp;mut self) -&gt; ~str; } #[deriving(Clone)] enum Entry { End, Node(~str, Rc&lt;Entry&gt;) } struct RcQueue { head: Rc&lt;Entry&gt;, tail: Rc&lt;Entry&gt; } impl RcQueue { fn new() -&gt; RcQueue { RcQueue { head: Rc::new(End), tail: Rc::new(End) } } } impl Queue for RcQueue { fn offer(&amp;mut self, data: ~str) { match (*self.tail).clone() { End =&gt; { self.tail = Rc::new(Node(data, Rc::new(End))); self.head = self.tail.clone(); } Node(ref old_tail_data, ref mut next) =&gt; { self.tail = Rc::new(Node(data, Rc::new(End))); next = &amp;self.tail; } } } fn poll(&amp;mut self) -&gt; ~str { "derp".to_owned() } } impl Show for RcQueue { fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result { write!(f.buf, r"RcQueue \{ head: {}, tail: {} \}", *self.head, *self.tail) } } impl Show for Entry { fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result { match *self { End =&gt; write!(f.buf, "End"), Node(ref item, ref next) =&gt; write!(f.buf, r"Node \{ '{}', {} \}", item, **next) } } } fn main() { let mut q: RcQueue = RcQueue::new(); println!("{}", q); q.offer("one".to_owned()); println!("{}", q); q.offer("two".to_owned()); println!("{}", q); } It kills me that it's so difficult to do something that seems like it should be so easy
But the point is valid, for any sufficiently popular protocol, someone will write an implementation in C.
To be honest, I don't know the exact lifetime assignment mechanics, but I believe `&amp;T` is rather shorthand for an anonymous lifetime or an inferred one. Within function arguments, it's anonymous, and the reference can't escape the function. Within a function body, it's inferred, and this also happens all the time, even without any type annotations (you could consider it a subset of type inference). That said, there are two gotchas to keep in mind: 1. `&amp;'a value` currently *always* ignores `'a`. it's probably intended for future expansions on scoping, e.g. `'a: { ... { ... &amp;'a value } ... }`. 2. there are some bugs around that will treat `&amp;T` within a function body as anonymous instead of inferred or it could infer to an unique anonymous lifetime instead of a real scope.
perhaps it would be interesting to see full inference within modules (and perhaps restricted as forward-only aswell?) , would that restriction avoid the hazards of full inference and give the best of both worlds? (specify types between modules and you get their benefit when writing larger programs..)
Thank you for this series. I'm not quite a C++ programmer (if there's a single language I'm decent at, it would have to be C), but it's still very helpful. You mentioned other pointer types; is Rc&lt;T&gt; up next?
Yes, I'm going to more briefly cover Rc, Gc, @ (just to say it exists, but avoid it), and *. Then come back to &amp; with named lifetimes a bit later. I feel I should get stuck into data structures soon too.
https://github.com/ozkriff/error-context/blob/8d666a/error_context.rs#L25-L35 https://github.com/ozkriff/error-context/blob/8d666a/error_context.rs#L54-L78
Oh, erm: that's *wildly* unsafe, and essentially 100% incorrect, if the data the `&amp;str` points to is deallocated (or even if the `&amp;str` is just moved in memory), you're left with dangling pointers. E.g. let string = "foo".to_owned(); // string on the heap let n = store_str(string); std::mem::drop(string); // deallocate it let slice = get_str(n); // pointing to freed memory. You can guarantee safety by restricting to only strings in static memory (e.g. string literals `"foo"` etc.) by writing `&amp;'static str` instead of just `&amp;str`. This will allow you to store them directly in the `ContextInfo` struct, i.e.`name: &amp;'static str`. However, this will mean all names have to be statically allocated, i.e. compile-time constants. The other option is to store them as [`StrBuf` objects](http://static.rust-lang.org/doc/master/std/strbuf/struct.StrBuf.html) (or `~str`) in the `ContextInfo` struct, although this implies an allocation for each context string (but does allow for the names to be determined at run time).
I know that this is unsafe. Idea from original article (http://bitsquid.blogspot.ru/2012/01/sensible-error-handling-part-1.html) is: "We assume that whatever string the user gives us lives in the same scope as the error context and is valid as long as the error context is. This means that setting the error context just requires pushing 8 bytes to a stack, so the performance overhead is very small". But I can not give any garanties about string lifetime using type system :( . Implementation with only "&amp;'static str" will be plain useless. Implementation with StrBuf will be unacceptably slow. :(
(Background: I’m the developer of [rust-http](https://github.com/chris-morgan/rust-http) and am presently working on [Teepee](http://chrismorgan.info/blog/introducing-teepee.html).) I’m interested to see this; headers is what I’ve been working on for the past few days with Teepee, getting a proof of concept for what is quite a novel technique of header representation. (More details of this scheme, which I have just this evening finished sufficiently to prove the concept of, will come in the next day or so HTTP/2 support is a core feature of Teepee, and I intend to support HTTP/0.9, HTTP/1.0, HTTP/1.1 and HTTP/2.0 in the one library. I’d be interested to discuss plans (mine and yours) with you to see whether we can in any way join forces. I suggest irc://irc.mozilla.org/#teepee as the venue. (I’m heading off to bed about now and won’t be around for around ten hours.)
Oh, I see. At the very least, transmute to `&amp;'static str` and store that rather than transmuting a reference to `uint`.
Thanks! We've been following Chris Morgan and his work with his HTTP library and his new TeePee project closely. It can possibly be used by such projects. The specifications of the decoder is pretty strict (not much wiggle-room) so it should be very useful. The encoder, though, can be optimized much. Especially if you want to support both client and a server contexts. We will look at Rust Empty. Thank you. 
Hello Morgan, We have *"secretly"* kept a little eye on your work with both rust-http and Teepee. :) And we would be very interested in sharing plans! As mentioned, this is a part of an ongoing bachelor project, thus we have some deadlines to keep, which might restrict us somewhat. Nevertheless, if some of the code we write or some of our many thoughts about it could end up actually be of use in the “real world”, that would be fantastic. At the moment, we are spending a lot of time on the design and implementation of connections and streams in HTTP/2. As /u/Lewinzki mentioned in another reply, as we see it, the specifications for HPACK are rather strict, so even with a completely different structure of headers, it should be fairly adaptable. But, let us talk more on IRC. We will hang around in the teepee channel the coming days. Thanks! 
Can someone explain how `let mut x = &amp;5;` and `let x = &amp;mut 5;` are different? Forgive me, as I'm coming from a world where references and dereferencing are all done behind the scenes to me. How would their use cases be different? 
But would `let mut x = &amp;5;` allow you to do `x = &amp;"foo";`? What does having a mutable pointer give you? 
Not most likely -- our integer types are defined as two's complement.
Although there's some merit to the idea of using Haskell vs. Rust causing you to trade some problems for others, it's a bit silly to suggest that using Haskell requires you to implement your own Okasaki-style data structures. There are lots of libraries implementing the standard sort of data structures that you can just use. Whether Haskell is more or less practical than Rust is likely to be something that varies from person to person and project to project depending on programmer background and available libraries in each language. Not entirely unlike the tradeoff for Scala vs. Rust.
Is it useful enough that it's worth developing a separate lint pass to tell people not to use it because that's not what they wanted ?
Thanks! Yes, using a struct as an example definitely helps. 
&gt; Rename &amp;mut to &amp;only, allow &amp;only borrowing of non-mut slots This is one RFC I'd rather not see accepted. I understand the idea, but I write `&amp;mut` because I want mutability and the fact that it's not aliased is just a by-product of safety.
Yes, the main advantage I see of Servo being developed in Rust is that by nature a browser engine requires: - network connections - graphics - disk interactions (caching) - performance issues That's a good all-around check for the language, certainly.
I don't quite understand the purpose of assuming the string will leave as long as the context: if I want a backtrace of static texts, there are OS/language facilities to get a backtrace at the point of failure *without instrumentation*, it's your usual backtrace... ... the very interest of having such context is *dynamic text*, which gives you the opportunity to interlace a regular backtrace with the *values* of arguments and variables: When loading model #57 ('tank') task '&lt;main&gt;' failed at 'Can`t parse integer: 1', example.rs:17 Now, I do understand your concern for performance: formatting this string even if nothing fails seems slightly silly. Instead, one would only want to format it during stack unwinding. In C++, I would do it either using `std::uncaught_exception`; in Rust you might need a facility to detect whether unwinding is ongoing or not and I know not whether it exists. Going further, it might be even more interesting to be able to attach those generated strings to the failure being propagated itself, so that it can be printed altogether right at the end. Even more interesting would be to be able to attach the notes to their respective stack-frame within the failure backtrace... but that might prove a bit complicated!
Pointer is an address in memory, right? Here how it looks: +=====+ +=====+ | x | ====&gt; | y | +=====+ +=====+ Here `x` is a pointer (address) and `y` is actual value. With `let mut x = &amp;y` you are making the left cell mutable, i.e. you can change the address which is contained in the variable, but not the contents at that address. With `let x = &amp;mut y` you are making the right cell mutable, i.e. you can change the value located at that address, but not the variable which holds the address itself.
I think you meant http://www.reddit.com/r/playrust/
I honestly wouldn't even mention `@`. What's the use?
I ran into this very issue last night and failed to understand the distinction. What great timing! Thanks!
Yup, I wouldn't bother mentioning `@` either.
Will that include `Cell` and `RefCell` too? Figuring out how to mutate through a `Rc` took a long time for me
Because there's a load of code examples floating around the web with it in. Its still in the compiler even. So I think it is worth pointing out that it used to exist, but not to use it any more.
Sorry but this kind of passive-aggressive, prima donna, holy-shit-I'm-offended routine is ridiculous. Just state that offensive people won't be tolerated in some FAQ and be done with it. Don't make a fucking pantomime of it.
I can live with that, this is the first time I have seen what the change means thanks!.
Parental guidance...? Also, I believe his name is Narwhal's LUT, as in Narwhal's Look Up Table. Seems pretty reasonable/on-topic to me.
Right now the RFC is a bit of a rambling train of thought, so, I'm planning on re-writing it shortly to make my argument a bit clearer and more concise. My basic argument boils down to that `&amp;mut` doesn't meaningly differ from `&amp;` in terms of mutability guarantees. It would be nice if I could say that I write `&amp;mut` when I want to allow for mutability and `&amp;` when I want the reference to be immutable, but I'm arguing that I can't really do this. "`&amp;mut` is the mutable type" is already an illusion and in my opinion an illusion that will lead to lots of nasty surprises.
So is there a tutorial for boxing then?
There's good coverage in the main tutorial, and it will be updated when the syntax is changed.
&gt; Parental guidance thanks!
What has perception got to do with anything? It was said with some specific meaning in mind, most likely as a general, gender-neutral greeting. He can't be held responsible for your (frankly hyper-sensitive) perception of it.
please leave that rethoric at 4chan. i can’t stand this over-the-top antifeminist shit by people who likely mistake feminism for that social justice warrior crap or “all men are pigs” radfems. can’t we just all agree that 1. sexism is fucking infuriating and 2. we’re all allowed to curse how the fuck we like? without somehow forcing those orthogonal concepts to clash?
The Rust compiler just *knows* that you didn't really want `0.0`... `0.064` is a much better number. :P
It took me a minute to find the missing `f`. Thanks!
Mentioning it more only adds one more example floating around the web.
I could respect you if you were merely an asshole, but hiding behind a throwaway account is just cowardly.
"Rust, the language without a String type" would make _excellent_ Troll Marketing. &gt; The bonus option "all of the above" will happen eventually in libraries at the current rate. Yup :/
Where there seem to be no love for self/Self? Make things more convinient. I don't see the reason to repeat the type name everywhere and in case of renaming, have patches with more lines then neccessary. DRY, anyone? 
I'm really wary of a "default string type" name that's multiple words.
&gt; :/ They all have use-cases, so I would actually say ":) Rust has the power to allow these as efficient libraries".
Good questions. I'd also love to get some idea of what the direction we're going in with string is and how we're supposed to use it. As I understand it ~str is going away means *all strings* will be represented as Vec&lt;u8&gt; in the future (as I understand it) with &amp;str a 'special type' that is a 'view' into the vector; and used (afaik) for no useful purpose other than string comparison and printing (and perhaps static string literals). 
UCS2 isn't Unicode. Servo is using it because it has to support broken web standards preventing storing all strings as UTF-8. The whole point of Rust's string types is that they are a wrapper around `[u8]` and `Vec&lt;u8&gt;` providing a valid UTF-8 guarantee. Rust is very much in the UTF-8 everywhere camp since all output/input in the modern computing world is UTF-8, and all in-memory storage should be too when legacy concerns don't get in the way.
Yeah, `str` feels a bit messy to be honest. Problem is that it's a utf8 string, and utf8 comes with a LOT of options to iterate over a string. I'll be honest and tell you I have no clue what should be default and what not. In my opinion an UTF-8 will need at least the following - `byte` Iterator and a `char` Iterator (and by char Iterator I mean things like ~~glyphs~~ grapheme clusters so you get character`Ü` instead of `U¨`. This comes up a lot in my code, and I don't consider my code an edge case. Bytes are for most non-ASCII common usage, worthless. I'm not sure how are they going to implement it, UTF-8 and Unicode are really difficult standards. EDIT: changed from glyphs to grapheme clusters.
&gt; As I understand it ~str is going away means all strings will be represented as Vec&lt;u8&gt; in the future (as I understand it) `&amp;str` is a wrapper around `&amp;[u8]` enforcing that it contains valid UTF-8, and `StrBuf` is a wrapper around `Vec&lt;u8&gt;` providing the same guaranteeing. There are not any changes to this, as `~str` was just a wrapper around `~[u8]`. &gt; with &amp;str a 'special type' that is a 'view' into the vector; and used (afaik) for no useful purpose other than string comparison and printing (and perhaps static string literals). Slices are *certainly* still useful. Any function requiring only a view should be taking a slice, because otherwise it's forcing many callers to perform copies. Slices allow views into parts of strings without any copying, and without mandating a certain kind of memory allocation.
That is true.
Agreed. While I've always been intrigued by Erlang's approach to concurrency, I've stayed away from it in part because of the terrible press its string handling gets. Rust not only needs a string type, it needs to be a pleasure to use. It feels like a wart that I can say `box anythingButAStr` and get the desired effect -- with strings I have to say `"someString".to_owned()"`, which works but is unique in this regard. I dislike the notion of having different words for the owned and borrowed types of strings. &amp;str and ~str were clearly different types of references to the same type. Having "Str" (or worse, "StrBuf") mixed with "chars" obfuscates the relationship between the two. While I'm here, can someone tell me if Vec&lt;T&gt; is inherently owned? I don't feel like I've seen ~Vec&lt;T&gt; or Box&lt;Vec&lt;T&gt;&gt; anywhere. Should I be returning &amp;Vec&lt;T&gt; from methods?
I know this isn't very helpful, but I did something like this in a CS class. you need a stack
These are getting better and better! Some great insight here. Thanks, Nick.
That "rule" is already not true for types like `Rc` and `Arc`.
&gt; I realize they're minimizing the typing you do for a commonly used type, but hiding ownership sweeps some really important information under the rug. All types in Rust are owned. Some types don't have deep ownership as they represent views (references) but the outer layer is *always* owned. There are only rare exceptions like `Rc&lt;T&gt;` / `Arc&lt;T&gt;` with shared ownership for the inner part. &gt; Now the rule is "everything that's on the heap is of type Box&lt;T&gt; except for Vec," which feels weird. There was *never* a rule like this. The standard library has plenty of types like `Rc&lt;T&gt;`, `Arc&lt;T&gt;` and `HashMap&lt;K, V&gt;` using low-level dynamic allocation functions directly. &gt; I hope the new string types don't mask the ownership information too. 90%+ of types defined in the standard library (`TreeSet&lt;T&gt;`, `HashMap&lt;K, V&gt;`, etc.) are deeply owned. All of the collections are deeply owned when you don't store references inside, which applies just as much to `Vec&lt;T&gt;` and `Box&lt;T&gt;`.
I re-wrote the RFC to hopefully be quite a bit clearer and easier to follow. Unfortunately, its not all that concise. Anyway, please give it another shot.
FWIW, no "normalization" is likely not what you are thinking of, when talking about getting LATIN CAPITAL LETTER U WITH DIAERESIS instead of LATIN CAPITAL LETTER U + COMBINING DIAERESIS. Normalizing with normalization form NFC (canonical composition) or NFKC (compatible decomposition followed by canonical composition) would archive that for this specific case though . What you means is iterating over glyphs. Notably a single glyph can actually be a sequence of codepoints (`char`s) and is hence a string. Iterating over codepoints is something that is also useful though and is what `.chars()` does.
The `~Tree` can't be converted to `&amp;Tree`. Try doing it yourself, with `&amp;*t`, and you'll be told the value doesn't live long enough. The reason is that `t` has type `~Tree`, which is owned by the current match arm. Of course, if you were to somehow fix that, you'd then be told that you can't move out of a `&amp;`-pointer, which is what you're trying to do in your `for &amp;t in tree.left.iter() ..`. The solution is to remove the `&amp;` from the pattern and then convert the `&amp;~Tree` to a `&amp;Tree` yourself, with `&amp;**t`. This doesn't try to move the `~Tree`, so it does in fact live long enough. It looks like this: impl&lt;'a&gt; Iterator&lt;&amp;'a Tree&gt; for DepthFirstIter&lt;'a&gt; { fn next(&amp;mut self) -&gt; Option&lt;&amp;'a Tree&gt; { if self.stack.len() == 0 { None } else { let cur: Option&lt;&amp;'a Tree&gt; = self.stack.pop(); for tree in cur.iter() { for t in tree.left.iter() { self.stack.push(&amp;**t) } for t in tree.right.iter() { self.stack.push(&amp;**t) } } cur } } } Of course, you'll also probably find that this isn't quite a depth-first iterator, because you're pushing `left` onto the stack before `right`, which means you walk down the right branch first. Swap those two and it should work better.
Yeah, I wasn't certain what that was called, thanks. 
A non-UTF-8 locale doesn't work with glib and associated libraries (gtk, pango, cairo), whether or not it was intended to handle it. It's only widely tested under UTF-8 locales and the developers aren't interested in fixing the many issues in other locales.
Rust's `char` is a Unicode scalar value, not a grapheme. A grapheme can be composed of an unbounded number of Unicode scalar value and only maps 1:1 with a glyph with a monospace font. There is no unit corresponding to a glyph for non-monospace fonts since they can do whatever they want with ligatures and so on. There's really nothing the language can do about that.
The only string type that'll be baked into the language to some degree is the type of a built-in string literal, which is always UTF-8 as Rust source files are UTF-8. Everything else is just part of the library, so you can build your own string types to handle multiple encodings if you wish.
On a side note, you could actually [break the hardware](http://nocash.emubase.de/pandocs.htm#lcdcontrolregister) on the gameboy color if you changed a control register at the wrong time. The certification stops games like this getting onto the market - maybe the GBA has a similar problem? 
&gt; There is no unit corresponding to a glyph for non-monospace fonts since they can do whatever they want with ligatures and so on. There's really nothing the language can do about that. Sure there is, implement UAX #29 (text segmentation) to know grapheme cluster boundaries (it's useful for UTS #10 (collation) and UTS #18 (regex) as well), then the iterator returns the grapheme cluster as a string or a slice of the existing string. That's basically what Obj-C does, although it does not provide much in the way of iterators so that's done via `rangeOfComposedCharacterSequenceAtIndex:` ("composed character sequence" is the way Obj-C spells out "grapheme cluster").
&gt; Grapheme clusters are not glyphs Considering what he wrote -YO- is looking for grapheme clusters not really glyphs. As you note glyphs are a rendering concept, and have no existence at the unicode level. Grapheme clusters, however, do.
Thanks for the hint!
Thank you so much! I never would have thought of tree structure holes, binomial coefficients or importing data from CSV. I have already split functions into separate files based on what kind of math they're doing. I'm a little bit at a loss for what you mean by the double operators. (+ 4 5 6) already returns the sum of those numbers, and pow acts as a tower of power, so that (pow 2 3 3) is equivalent to (pow 2 27) Do you mean to do something like (++ '(4 5 6))? As a progress update, I'm partway through changing functions from using f64 to BigRationals instead. Again, I really appreciate that, especially your thoughts on on what it should not have.
For example: `(++ (1 2 3) (3 2 1)) = (4 4 4)` It takes lists instead of numbers and performs the operation per element. Each list needs to have the same number of arguments. Alternative is to use 0 for addition and 1 for multiplication as defaults. * Edit: Not sure about using 1 for multiplication. It depends on the usage, I think.
How does BigRationals handle irrational numbers like pi? Can you decide accuracy? Also, there might an issue with equality checks, since `4/4 = 1/1` etc. Does BigRational do this for you?
I'm testing it out now and in the middle of changing things, so I'm not 100% sure yet. However, I know it already has a reduce (private method) and reduced (public method). As for the accuracy of irrationals - well, I'm just going to pick rational representations for that and move on. Irrationals are kind of impossible to represent in a machine, to the best of my knowledge. Oh yeah, I forgot to mention, that Ratio already has ordering and equality. http://static.rust-lang.org/doc/master/num/rational/struct.Ratio.html The biggest issue I have at the moment is that if the denominator is one, when you print, it still shows it as a fraction.
Ah, I see. So it's kind of like single dimensional matrices. Right now (+ ) = 0 and (* ) = 1 anyway.
&gt; (i hope) safe. It's much safer, but no, transmuting `&amp;'a str` to `&amp;'static str` is still quite unsafe. It's fine if you're going to manually guarantee that the strings last long enough, but the compiler will not be helping you. Other than that, the new form looks nice.
I mean that implementation is unsafe but it forms safe abstraction and user of library can not break anything without compiler error. User does not need to guarantee strings lifetime manually anymore.
&gt; ++ You can do it APL/J style: `(op lst1 lst2)` does the same that haskell's zipWith (op) lst1 lst2. Also why not make infix calculator with no operation precedence? It's simpe to parse, easy to read, and you can implement something like `op/ lst` for folding. // You can try some APL here: http://tryapl.org/
Thank you for the clarification. The source of my confusion is that I had proposed `&amp;Utf8` as another alternative to `&amp;str` or `&amp;Chars`, and in the sentence "-1 to naming Chars something based on UTF-8", it is ambiguous whether the "something based on UTF-8" is the subject (the name itself) or the object (the thing referred to by the name). I now see that you meant it to refer to the object, as in "-1 to using the name `Chars`" (as opposed to "-1 to naming a series of chars some name based on UTF-8.", the alternative interpretation). ---- Note also that `StrSlice` was explicitly mentioned in the RFC itself. In the summary, no less. You can see the arguments against `StrSlice` in the comments section. (The summary is: It is too long and awkward for something that we want people to try to use first, and only move to renamed(`StrBuf`) after finding renamed(`&amp;str`) is insufficient.
As a Rust beginner, [] vectors are confusing for me. It kind of multiplies the possibilities of types. Then you remove Rc and [int] is not allowed? That doesn't seem uniform.
So how does Rc&lt;[int]&gt; work? That's why I said it's confusing for me. You don't need a size in that case?
The `Vec` itself is a length (a `uint`), a capacity (a `uint`), and a pointer, and that *is* on the stack. What isn't is the location the pointer points to (and AFAIK it can't, because it's growable - unless Rust starts to support something like C's `alloca`)
I noticed you're returning tuples or `~str`s to indicate whether a function call succeeded or not. This seems similar to what Go does. A much better way is to return a single `Result&lt;T&gt;` for that purpose. You then `match` on the return type, getting either an `Ok(T)` or an `Err(_)` type, and decide where to go from there.
What about using `runes` instead of `chars`? Edit: just saw it was suggested elsewhere in this thread.
&gt; Now, it’s another story if we’re also renaming char, but I haven’t seen it suggested, and I don’t think we should. (I’ve changed my mind on rune.) Sorry to hear that, as I plan on submitting this RFC soon. :) Death to `char`!
I wonder if literals could be done with a lang item. We could even be cute and allow users to specify a custom suffix for their custom literals. #[lang(string_literal("b"))] /* blah blah blah some implementation code */ /* ...later... */ let x = "ABC"b; // voila, byte literals, as per https://github.com/rust-lang/rfcs/pull/69 let y = "ABC"w; // and how 'bout "wide" literals, for Servo's UCS2 strings (this would NOT live in the stdlib, of course) let z = "ABC"u; // an alias for our default UTF-8 strings Granted, I'm not saying that this is a good idea, and I'm unfamiliar enough with lang items to be sure that this is really easily possible. :P
It's exactly like the C++ `std::uncaught_exception` so thanks for the tip!
I disagree with the premise. I consider `Cell` and the like to be *exceptional* tools, which is why they are written using `unsafe` code, to serve *exceptional* purposes by transposing compile-time checks into run-time checks. As such, it matters little to me that `&amp;Cell&lt;uint&gt;` allows to mutate the underlying `uint`. I would point out instead that `&amp;` is meaningful here in that the `Cell` itself cannot be mutated (to point to another `uint`). I would also reiterate that for the lambda user `&amp;mut` is used when the *intention* is to mutate, and non-aliasibility is just a fallout of the safety rules enforced.
What's the return type of `self.conn.prepare()` and `query()`? Edit: can you repost the code with explicit type annotations? ie. `let c: SomeObject = self.conn;` etc. I suspect the problem starts with `c` as the compiler is saying. 
`self.conn.prepare()` returns `PostgresResult&lt;PostgresStatement&lt;'a&gt;&gt;` https://github.com/sfackler/rust-postgres/blob/master/src/lib.rs#L568 `query([])` returns `PostgresResult&lt;PostgresRows&lt;'a&gt;&gt;` https://github.com/sfackler/rust-postgres/blob/master/src/lib.rs#L1216 Am I missing something obvious though? Is an extraction always this tricky? This is near to my first experience with the language, so is it always hard to deal with stuff like this, or am I just not familiar enough?
you could add precedence pretty simply by doing something like [Shunting-yard](http://en.wikipedia.org/wiki/Shunting-yard_algorithm) this also gives you the benefit of post fix being easy to evaluate 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Shunting-yard algorithm**](https://en.wikipedia.org/wiki/Shunting-yard%20algorithm): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), the __shunting-yard algorithm__ is a method for parsing mathematical expressions specified in [infix notation](https://en.wikipedia.org/wiki/Infix_notation). It can be used to produce output in [Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) (RPN) or as an [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST). The [algorithm](https://en.wikipedia.org/wiki/Algorithm) was invented by [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_Dijkstra) and named the "shunting yard" algorithm because its operation resembles that of a [railroad shunting yard](https://en.wikipedia.org/wiki/Classification_yard). Dijkstra first described the Shunting Yard Algorithm in the [Mathematisch Centrum](https://en.wikipedia.org/wiki/Mathematisch_Centrum) report MR 34/61. &gt;Like the evaluation of RPN, the shunting yard algorithm is [stack](https://en.wikipedia.org/wiki/Stack_(data_structure\))-based. Infix expressions are the form of mathematical notation most people are used to, for instance 3+4 or 3+4*(2−1). For the conversion there are two text [variables](https://en.wikipedia.org/wiki/Variable_(programming\)) ([strings](https://en.wikipedia.org/wiki/String_(computer_science\))), the input and the output. There is also a stack that holds operators not yet added to the output queue. To convert, the program reads each symbol in order and does something based on that symbol. &gt;The shunting-yard algorithm has been later generalized into [operator-precedence parsing](https://en.wikipedia.org/wiki/Operator-precedence_parser). &gt;==== &gt;[**Image**](https://i.imgur.com/NKkmL2r.png) [^(i)](https://commons.wikimedia.org/wiki/File:Shunting_yard.svg) --- ^Interesting: [^Reverse ^Polish ^notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) ^| [^Operator-precedence ^parser](https://en.wikipedia.org/wiki/Operator-precedence_parser) ^| [^Exp4j](https://en.wikipedia.org/wiki/Exp4j) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chc3gbm) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chc3gbm)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I think extracting methods in Rust does always feel hard - because you didn't notice how much the intra-function type-inference helped you when you wrote it originally; 
It seems like `PostgresRows` is an Iterator, right? From my (brief) experience with Rust, returning iterators (that you didn't construct yourself) from functions leads to complex lifetime issues. I don't know if this is a problem with the language or if it has to do with me being a noob, but that's my experience. Anyways, I recommend you do the `collect` on the `query` function directly, returning a vector instead of an iterator: pub fn query(&amp;self, sql: &amp;str) -&gt; Vec&lt;PostgresRow&gt; { self.conn.prepare(sql).unwrap().query([]).unwrap().collect() } And if we follow /u/Nihy's suggestion to remove the `unwrap()`s to allow for upstream error handling: pub fn query(&amp;self, sql: &amp;str) -&gt; PostgresResult&lt;Vec&lt;PostgresRow&gt;&gt; { self.conn.prepare(sql).and_then(|stmt| { stmt.query([]) }).map(|rows| { rows.collect() }) } Then, use as: pub fn databases_refactor(&amp;self) -&gt; Vec&lt;~str&gt; { match self.query("SELECT datname FROM pg_database WHERE datistemplate='f'") { Ok(rows) =&gt; rows.move_iter().map(|row| row[1]).collect(), Err(error) =&gt; fail!("Error when querying: {}", error), } } If that still doesn't work, it would be helpful if you could provide a repo with your current code, so that reproducing becomes easier **Edit**: The second `and_then` should be a `map`, because `collect` doesn't return errors.
Thanks for your help so far - I pushed all most code up to github: http://www.reddit.com/r/rust/comments/24z3nv/noob_figuring_out_lifetimes_of_a_simple/chc5fia https://github.com/cschneid/trilogy_public
I think you want to use the suggestion of adding 'a in places, but then you're running into the problem that the string containing the sql query doesn't live long enough. Try changing it to &amp;'static str . (I'm just guessing; I'm not an expert, and without knowing the type of prepare(), in particular, it's tricky for me to figure out what's going on.)
This is great, thanks! Think I'll just print a few (hundred) stickers for myself :)
I'm not sure if that's the best way, but I found an alternative that avoids the lifetime issues. The `collect` I suggested earlier didn't work because each individual `PostgresRow` maintains a reference to its statement, and the statement is collected after the `query` method returns. Whether this is a issue with the library, the use you are trying to make of it or with the language is up for debate. I personally would have made `PostgresRows` (the iterator) to get its own copy of the statement, but I digress... Anyway, the solution I've arrived at is to make `query` take a closure and call it with each individual row, returning a `Vec` of the results. pub fn query&lt;T&gt;(&amp;self, sql: &amp;str, f: |PostgresRow| -&gt; T) -&gt; PostgresResult&lt;Vec&lt;T&gt;&gt; { self.conn.prepare(sql).and_then(|stmt| { stmt.query([]).map(|rows| { rows.map(|row| f(row)).collect() }) }) } pub fn databases_refactor(&amp;self) -&gt; Vec&lt;~str&gt; { self.query("SELECT datname FROM pg_database WHERE datistemplate='f'", |row| { row[1] }).unwrap() } This works because the `PostgresRow`s don't outlive the statement (`self.conn.prepare(sql)`) anymore. ---- Alterative with the `try!` macro, if you don't like the deep nesting: pub fn query&lt;T&gt;(&amp;self, sql: &amp;str, f: |PostgresRow| -&gt; T) -&gt; PostgresResult&lt;Vec&lt;T&gt;&gt; { let stmt = try!(self.conn.prepare(sql)); let rows = try!(stmt.query([])); Ok(rows.map(|row| f(row)).collect()) }
eww, `int* x = 0` I just misread that as a pointer to a 0 because I don't do C
You don't, because the compiler stores the size alongside the pointer. `Rc&lt;[int]&gt;` is actually a "fat pointer": pointer and size together. It's the same as `&amp;[int]`.
You need some way to actually convert the data into the appropriate representation at compile time (because it needs to end yup in the compiled binary with your custom representation). Macros are the simplest solution (although have some limitations, like are unable to be used as patterns).
You may be interested by the old-style RFC for the same thing: [#12730]( https://github.com/mozilla/rust/issues/12730).
Neat. That's a really clean and flexible solution!
It expects UCS2 when strings are used as API parameters (sometimes UTF-16) but I/O is still nearly all UTF-8. You're still better off using UTF-8 as the in-memory representation, because the API parameters themselves are not large strings. They're nearly all paths, environment variables or command lines which are all quite limited in length.
Thank you!
Another thing, your tree is not really binary. I can have a node with only one child. A much better approach would be `children: Option&lt;(~Tree, ~Tree)&gt;`. This way you enforce that a node has either two children or no children. 
It doesn't sound like the OP necessarily wants an actual binary tree; in any case, `Option&lt;~(Tree&lt;T&gt;, Tree&lt;T&gt;)&gt;` will have fewer allocations, a smaller `Tree&lt;T&gt;` size and (slightly) better memory locality, and so is likely to be more efficient.
I like `&amp;utf8` (`utf8` is the unsized type) seeing as the string literal is UTF-8, and all the other built in types are lower case.
Thank you, this is a great clarification. While its contents are on the heap, the Vec itself is a struct on the stack and there's still merit (I think?) to passing it as a reference instead of by-value.
&gt; All types in Rust are owned. A fair point, I realize I was conflating ownership with stack vs heap. I've been saying "owned pointer" (~T) to refer to things on the heap, but that's not accurate. What I was trying to express (but doing a very poor job of) was that I liked that the `~` in front of `[]` and `str` made it obvious that an allocation was going to happen. `Vec` and `Str` make it less obvious, that's all. &gt; The standard library has plenty of types like `Rc&lt;T&gt;`, `Arc&lt;T&gt;` and `HashMap&lt;K,V&gt;` using low-level dynamic allocation functions directly. /u/riccieri clarified elsewhere that Vec is itself a struct on the stack which contains a pointer to the data on the heap. Is this true of Rc, Arc and collections like HashMap as well? (i.e. is it wise for me to pass &amp;HashMap and &amp;Vec around to functions instead of passing them by value?)
Yes. A `#[lang="foo"]` lang item is just an annotation that tells the compiler "please use this function/type for the `foo` functionality" (e.g. inserts runtime calls to some `malloc` function for the `~`/`Box` allocations). At the moment, the only way to actually get the compiler to run arbitrary custom code (e.g. converting string representations at compile time) is to write a procedural macro.
Apologies, I realize I've been conflating the concepts of ownership and allocation. I was trying to say that I liked knowing that `~` meant I was causing an allocation to happen. Moving from `~[]` to `Vec` hides that a bit, as does moving from `~str` to `Str` or similar.
&gt; Vec is itself a struct on the stack which contains a pointer to the data on the heap. Is this true of Rc, Arc and collections like HashMap as well? Yes, it's true of all of those along with `Box&lt;T&gt;`. &gt; (i.e. is it wise for me to pass &amp;HashMap and &amp;Vec around to functions instead of passing them by value?) You should still pass small data structures by-value when possible. However, if you pass these by-value, you're moving ownership because they have destructors. You should always prefer a `&amp;[T]` view into the vector to `&amp;Vec&lt;T&gt;`. You should also pass `&amp;mut [T]` instead of `&amp;mut Vec&lt;T&gt;` when the callee doesn't need to resize it. An `Rc&lt;T&gt;` is a pointer to a dynamic allocation just like `Box&lt;T&gt;`. The difference is that it has a strong and weak reference count placed after the value (take a look at `RcBox&lt;T&gt;` in std::rc).
From what I've read in the documentation and elsewhere, it seems that a 3-word struct isn't big enough to warrant passing-by-ref - the overhead of the indirection would be greater than the overhead of copying the values. You *will* want to pass it by-reference, however, if you want *lend* the vector to some other function, instead of *giving* it. Suppose, for example, an amazing function that appends the value 13 to a given `Vec`: fn append13(v: &amp;mut Vec&lt;uint&gt;) { v.push(13); } If this function took `v` by-value instead of by-reference, `v` would be moved into it, and the caller would lose access to the vector - defeating the whole purpose.
Makes sense, thank you!
Thanks, strncat. This was really helpful to read. How many bytes, in your opinion, constitutes a "small" data structure?
It's a hobby learn-the-language project. I'm looking for opinions and ideas, maybe collaborators. It's hardly a game yet, but the basic mechanics is there. What make it distinct from other games like this is combination of: * hex tiles, * the direction you're facing matters (real sneaking possible), * the mechanics of ticks and pre/post action time make fighting challenging and semi-realistic. 
That's a really nice solution! I think this sort of thing is challenging for beginners because a large proportion of people are used to languages where you can pretty much pass references around as you please. A thing that's particularly challenging with rust is that (as in this case) the internal implementation of a library you're using can substantially affect the code that you can write yourself. This arguably breaks expectations that people from other languages have with respect to encapsulation.
I think a smooth rotation animation instead of an instant one would help the player keep track of orientation changes. As of now it's a little confusing to follow.
It's not that confusing for the player that issued the action, but it is for a non-player viewer, yes. Smooth rotation is however a bit challenging due to limitation of the way the graphic is rendered, but I guess possible to do in the future.
I agree - being used to having a GC and now having to care about lifetimes is definitely challenging. I think it's a price worth paying though, if you want low level and/or high performance code with strong safety guarantees. This returning-an-iterator thing has particularly tripped me up, because it's a style that I frequently write in ruby (`Enumerator` there) to avoid allocating large arrays that I will filter and/or process sequentially. Hopefully, these things should get easier with experience, and as the compiler matures, the error messages should get easier to understand.
Well the file was named binarytree.rs...
Thanks a lot! I'll have to spend some time rewriting stuff, but I'm already rewriting the parser for this anyway, so this ought to greatly simplify things.
I haven't thought of that, but it makes sense. 
Oh, yes, so it does; nice work! Just to be doubly-sure it's working right, it might be good to have an assertion that the value that was popped was the one that was pushed [here](https://github.com/ozkriff/error-context/blob/17e4cf0cd834682e38f18be39c3d8bfaf6a6796b/error_context.rs#L58). Something like let opt_ctxt = contexts.unwrap().pop(); let ctxt = opt_ctxt.expect("Empty context when there should be something"); assert_eq!(ctxt.description, self.description); assert_eq!(ctxt.data, self.data); (Could use [the `debug_assert_eq!` macro](http://static.rust-lang.org/doc/master/std/macros/macro.debug_assert_eq.html) too, to allow the assertions to be compiled out with the `--cfg ndebug` flag, probably doesn't make much difference with the `.unwrap` and `.expect` call though.)
[As discussed previously](http://www.reddit.com/r/rust/comments/24elup/rfc_remove_in_favor_of_box_and_box/). `~TYPE` is now `Box&lt;TYPE&gt;` and the expression/pattern forms are both `box ...`.
See also https://github.com/mozilla/rust/issues/6816#issuecomment-41973256
I was under the impression that a binary tree has degree of at most two. In any case this is just throwaway code.
Good tips.
I assume that ~str and ~[] will also be replaced by Box&lt;str&gt; and Box&lt;[]&gt;, right? When is that supposed to happen?
You're kind of correct. The player can act Forward, Right (Forward-Right), Left (Forward-Left) and Backwards. The Back-Right and Back-Left diagonals don't need corresponding key. But the main reason of rating world is to make the roguelike more like a FPS: you cannot see everything at once, you need to check your back. From player perspective everything is always "in front of him/her".
I think when DST will be ready. Without them bare `str` and `[]` are not possible.
`~str` became `StrBuf` (this might be renamed), and the growable `~[T]` became `Vec&lt;T&gt;`. `~[T]` still exists in the language, it will become `Box&lt;[T]&gt;` as you mentioned, but post DST it is a non-growable type (like the Java base array type).
What I do find very nice is that even with `$var:expr` if the expected type does not match the type of the expression, the type error will point at the macro argument. So this is might not be a problem when the expected type can be inferred by the expanded code. Not sure about this case though, haven't looked into it and might be missing something.
&amp; needs compiler support, it can't be implemented as a library. So be confident that it will never be removed.
I am with dobkeratops here. The problem is that `TreeMap` is only one specific kind of tree, for a single specific purpose. What if I want game trees? Or abstract syntax trees? I am not expecting these to be provided in the standard library, but I do expect it to be reasonably pain-free to define my own. Forcing all data type recursion to go through boxes is acceptable in a systems language. Replacing a perfectly fine syntax for such boxing (`~T`) with a more cumbersome one (`Box&lt;T&gt;`) is not.
`box "my string"` produces a `Box&lt;&amp;'static str&gt;` if I understand correctly. What would an example use case of a heap-allocated reference to a static string (rather than just a string reference) be? I assume that if there weren't a use case for this, `box "my string"` would be the way to produce `Box&lt;str&gt;` instead. I only ask because `.to_owned()` is showing up in enough of my code to feel burdensome.
Just a heads up for anyone who has been using Rust-CI to ensure that their projects stay up to date: double check when your project was last built. It's quite possible that it hasn't been building for the last month or so. Some projects were last rebuilt on 2014-04-08, others on 2014-04-18.
&gt; What would an example use case of a heap-allocated reference to a static string (rather than just a string reference) be? There is none, I believe. It is quite useless type. &gt; `box "my string"` would be the way to produce `Box&lt;str&gt;` instead. I only ask because `.to_owned()` is showing up in enough of my code to feel burdensome. I doubt it will happen because it will require special-casing `box` for string literals. Moreover, you usually should not be boxing string literals. You should consider refactoring. Owned strings are not idiomatic Rust, you don't need them in a large number of cases. And when you need them, you usually need them as growable buffers, in which case `StrBuf` is a correct type for you (`~str` is already not growable).
This raises two questions: - I see "Owned strings shouldn't be common" a lot. I'm writing new data structures that have strings as members -- should I not be using an owned string in my structs? - What's the Rustic way to do concatenation of any sort of `str` variables? Do I need to use `format!` everywhere? Or am I supposed to use `StrBuf`'s append() and just let StrBuf handle any reallocations on my behalf?
I can appreciate the desire to avoid special casing `box` for string literals. I just wish there was a less verbose way to make a string from scratch. `StrBuf::from_str("my string")` feels equally heavy.
pcwalton is working on that, in fact [one step of it](https://github.com/mozilla/rust/pull/14032) just landed. (Implementing just as the `Box` type being sugar for `~`, so DST is no required.)
I believe you should be using `StrBuf` for any string manipulations, since that's the point of its existence and many methods that were previously in `str` are now in `StrBuf`.
&gt; should I not be using an owned string in my structs It depends on structs in question, but it is highly possible that you don't really need boxed strings. A good example, I think, is [`IoError`](http://static.rust-lang.org/doc/master/std/io/struct.IoError.html). It has both string slice and boxed string. &gt; What's the Rustic way to do concatenation of any sort of str variables? Yes, you should use `StrBuf` or `format!()`. It is alsmost no different from e.g. Java where string concatenations are in fact implicit calls to implicit `StringBuilder`.
This is in fact one of the main points why boxing syntax is not too short. When owned growable string were `~str`, and *allocation* of such string was as easy as just `~"abcd"`, a lot of people tended to overuse it. Rust authors want to promote using `&amp;str` where possible in order to avoid allocations. Surprisingly it is possible in a lot of cases.
It's not *perfectly* fine, that is a gross misunderstanding of the whole issue. There are numerous problems, e.g. - no support for allocators - arcane syntax - people learning `~` as some sort of "ownership" operator &gt; I do expect it to be reasonably pain-free to define my own I don't believe changing to `Box` makes them painful, just a little less slick; certainly the allocation is still nice: `box ...`. In any case, I imagine many trees would prefer allocating from an arena or using `Rc` pointers or something, i.e. writing `~` is inappropriate anyway. And in most cases, the use of such trees to be far more common than the actual type declaration (the main place where `Box&lt;T&gt;` will be painful).
And they removed muh precious sugar! Well, I still can write `⍨DatType` and then do `sed 's/⍨([a-zA-Z&lt;_&gt;\-]+)/Box&lt;\1&gt;/'`.
The Ubuntu nightlies have also been spotty and the documentation upload is broken as well, so I've temporarily switched away entirely from Rust-CI. I've replaced the Ubuntu nightlies with the official nighlies (here's an [example](https://github.com/SiegeLord/RustAlgebloat/blob/master/.travis.yml#L8-L12) `travis.yml` file from one of my projects). I've replaced the daily triggering with an `anacron` script: #!/bin/sh travis login -g &lt;github API token&gt; travis restart -r SiegeLord/RustAlgebloat ... travis logout where 'travis' is the Ruby Travis interface that you can get using `gem install travis`. For documentation, I've hacked up/borrowed a [script](https://github.com/SiegeLord/RustAlgebloat/blob/master/doc/gh_pages_upload.sh) to push to github's `gh-pages` service... also using a github API token. Although it all works, I would prefer to switch back to Rust-CI as soon as it is fixed.
&gt; Making every smart pointer or container carry an allocator object (which, rather than the allocator itself, is just a handle to the real thing) is extremely inefficient Many types will be carrying an allocator "object" like `struct DefaultAlloc;` i.e. zero sized, no runtime overhead at all (any function calls are statically resolved). Anything that needs a reference to an actual object (i.e. if it needs access to the allocator for deallocation) cannot avoid storing a single pointer of some form (but in most cases that's all that is necessary), e.g. `struct ArenaAlloc&lt;'a&gt; { x: &amp;'a Arena }`.
Name: [the fungus](https://en.wikipedia.org/wiki/Rust_%28fungus%29). (No time just at present to find a source from that, but Graydon has confirmed it before.) Logo: https://bugzilla.mozilla.org/show_bug.cgi?id=680521
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Rust (fungus)**](https://en.wikipedia.org/wiki/Rust%20%28fungus%29): [](#sfw) --- &gt;__Rusts__ are plant diseases caused by [pathogenic](https://en.wikipedia.org/wiki/Pathogen) [fungi](https://en.wikipedia.org/wiki/Fungi) of the order __Pucciniales__ (previously also known as __Uredinales__). An estimated 168 rust genera and approximately 7000 species, more than half of which belong to the genus *Puccinia*, are currently accepted. Rust fungi are highly specialized parasites with several unique features. A single species may produce up to five morphologically and cytologically distinct spore-producing structures viz., spermagonia, aecia, uredinia, telia, and basidia in successive stages of reproduction. Unlike other plant pathogens, rust usually affects healthy and vigorously growing plants, so the infection is limited to plant parts, such as leaves, petioles, tender shoots, stem, fruits, etc. Perennial systemic infection may cause deformities such as growth retardation, witches brooms, stem canker, hypertrophy of the affected tissues or formation of galls. Plants with severe rust infection may appear stunted, chlorotic (yellowed), or otherwise discoloured. Rust sporulates on affected plant parts. Rust is most commonly seen as coloured powder, composed of tiny aeciospores which land on vegetation producing pustules, or uredia, that form on the lower surfaces. During late spring or early summer, yellow orange or brown, hairlike or ligulate structures called [telia](https://en.wikipedia.org/wiki/Telium) grow on the leaves or emerge from bark of woody hosts such as *Juniperus* species. These telia produce teliospores which will germinate into aerial basidiospores, spreading and causing further infection. &gt;==== &gt;[**Image**](https://i.imgur.com/QE6KdhI.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Modell_von_Puccinia_graminis_\(Getreiderost\)_-Osterloh-_-Brendel_10_h,_2-.jpg) --- ^Interesting: [^Gymnosporangium ^juniperi-virginianae](https://en.wikipedia.org/wiki/Gymnosporangium_juniperi-virginianae) ^| [^Stem ^rust](https://en.wikipedia.org/wiki/Stem_rust) ^| [^Teliospore](https://en.wikipedia.org/wiki/Teliospore) ^| [^Chrysanthemum ^white ^rust](https://en.wikipedia.org/wiki/Chrysanthemum_white_rust) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chd6lc5) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chd6lc5)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thank you very much, I'm a little surprised neither of those were easily Googlable last night! Maybe your comment will give it some more PageRank. I could've sworn I read someone remark on the meaning of the teeth of the chainring or so. Maybe the original commenter will find this topic again. :)
There's `"foo".to_strbuf()` and it could be shorter if it was renamed.
It can be implemented in a library, except for the address-of operator. You use a `struct` with a marker type from `std::kinds::marker` for the lifetime and a raw pointer. The address-of operator returns a borrowed pointer though, so there's no way to get around using them from a library.
Clone [this repo](https://github.com/mozilla/rust). Run `./configure &amp;&amp; make &amp;&amp; sudo make install` to build and install. Run `git pull` or whatever to update, followed by another `make &amp;&amp; make install` to build and install the new Rust. --- With very few exceptions, the `master` branch will always work, as pull requests are built and tested by a build script (bors) before being merged. As for working out what's changing, it's probably easiest to watch the issue tracker and pull requests to get a heads up. Otherwise, wait until the next "This Week in Rust" and check out the breaking changes section. Other than that, checking the docs and reading compiler errors should be fine to fix anything that breaks between updates.
&gt; With very few exceptions, the master branch will always work, as pull requests are built and tested by a build script (bors) before being merged. Thanks - I had trivially inferred all the information in your post, but I didn't know the "master is supposed to work" convention 
Sugar is bad for your health
You can skip the hand-building using [a nightly](http://www.rust-lang.org/install.html). (There's [even a convenient upgrade script](http://www.rust-lang.org/rustup.sh): used like `sh rustup.sh`, probably run under `sudo`. You may wish to just glance over it to check that it's not being malicious.)
Serious question: Where are you using the `~` operator often enough that you are actually going to miss the sugar? Personally I was a bit surprised that I have a mid sized (1300 LOC) Rust library that doesn't use it once (or `box` for that matter). My current impression is that unless you are dealing with recursive data structures, or trait objects (both of which are not incredibly common) you don't really need it at all.
You are mutating the `Cell`, though. Just not an externally visible field. If you examine its [implementation](https://github.com/mozilla/rust/blob/master/src/libcore/cell.rs) the only thing it contains is a single value (wrapped in an `Unsafe`) and thats what `set()` changes. It may not be used extensively, but I don't believe its *exceptional* - its in libcore, the library with the most fundamental types expected to be used by all Rust programs. There are other types that behave this way as well, such as `Mutex`. I agree that `&amp;mut` is often used to indicate the intention to mutate, which can be helpful to make the author's intent clear when reading code. The problem is that `&amp;` can also be used to mutate, so, when used as this purpose, `&amp;mut` is basically an annotation of intent, not something the compiler can enforce. So, what those annotations boil down to is: `&amp;mut` means - I'm going to mutate this value; `&amp;` means - I might mutate this value. That distinction seems to be of limited utility to me. The other thing is, `&amp;mut` can also be used in order to ensure that mutation *doesn't* occur - when you pass a variable as a `&amp;mut` you know that you can mutate any other parameter without impacting the `&amp;mut`, which can be useful in cases even when you have no intention of changing the `&amp;mut` itself. I agree that it would be very nice if `&amp;mut` could be an indication of intent to mutate. Where we differ, I think, is that in my oppinion the existing rules underyling `&amp;` and `&amp;mut` don't do a very good job of supporting that particular use case. So, I'm proposing the renaming to make it clearer which use cases they support best.
I get the performance argument, but the alternative syntax isn't better: If I want to store a `&amp;str` in a struct, I need to start throwing `MyStruct&lt;'a&gt;` everywhere.
You didn't say what is your operating system, but there are [repositories for quite a few package managers](https://github.com/mozilla/rust/wiki/Doc-packages%2C-editors%2C-and-other-tools#packages).
I've decided to post this script after seeing [this question](http://www.reddit.com/r/rust/comments/253hvc/how_to_track_rust_bleeding_edge/). /u/dbaupp has already mentioned the `rustup.sh` script, but it may be hard to use with crontab as it always downloads the nightly no matter it has been actually updated or not. (I had to track the master quickly in order to ensure that my libraries are up to date.) This script is not as robust as `rustup.sh`, so feel free to alter the script to suit your needs, especially when you don't use x86-64 Linux (this is hard-coded currently).
([Here is `rustup.sh`](http://www.rust-lang.org/rustup.sh), by the way.)
I'm a beginner and I don't really care about all those issues. I used to git clone every day and compile everything for hours but it didn't really worked in the recent releases because my old Ubuntu (that I can't update and is 32-bit) cannot compile LLVM anymore because my GCC is too old ( /r/firstworldproblems ) Now what I do every morning is: * go to http://www.rust-lang.org/ * grab the latest nightly release that has been already compiled for me * ./install.sh --prefix=$HOME/usr * the end! I only have a few programs written in Rust and it's easy for me to compile them again with the new version and modify them as needed. For example, today I had to: * replace some "~Object" with "Box&lt;Object&gt;" * replace some "~Object{ ... }" with "box Object{ ... }" And that's all. I change my code at the same time the language is modified.
Thanks for writing this! I'll try it out!
Unfortunately, there isn't a lot of rust-specific tutorials yet, for exactly the reason you mentioned. [The tutorial](http://static.rust-lang.org/doc/master/tutorial.html) is probably your best bet for an introduction to the language, but it doesn't get into the nitty gritties. I am currently following [a Python DIY-Lisp tutorial](https://github.com/kvalle/diy-lisp/) and translating it into rust, and I will make sure to post the results when that is usable. Unfortunately, it isn't ready yet.
It would be nice if Rust's parser was clever like Nimrod and could extract macros written in Rust from the current source file and use them. A future Rust could just have macros written in Rust without a separate DSL to learn/remember, with a lot of work put into exposing a nice token tree API. Small macros could just be handled with on-the-fly compilation (ideally with LLVM's JIT compiler), while large ones would still be done in a separate crate and dynamically loaded.
I actually see the distinction as more complex than that, due to attributes: syntax extension (cover term for everything below) macro (the foo!() forms) declarative macro / macro by example / rule-based macro (macros generated by the macro_rules! macro) procedural macro (macros written using macro_registrar) attribute (the #[foo] forms) The problem is, I don't see the distinction in the op mapping directly to the names, at least not `B`. If we define `B` as "macro written with `macro_registrar`", then it is: - A = declarative macro - B = procedural macro - C = macro If we define it as "everything producible by `macro_registrar`", then it is: - A = declarative macro - B = C = syntax extension Apparently though, there is the vague plan to merge procedural and declarative macros in the future by having one form that can mix both systems in the same declaration.
macro_registrar can register "attribute macro" too.
That's pretty awesome. How much work is it to avoid the @'s for this kind of thing?
Refactor-much-of-the-compiler level of work, since all uses in this macro are determined by the types/functions in libsyntax. (/u/eddyb has actually done a lot of work along this line, but unfortunately it never landed. :( )
Well, I guess there is just no aligning our opinions then.
Ah, sorry, I may have mistaken it for `RefCell`.
If you are using [Rust-Empty](https://github.com/bvssvni/rust-empty) you can type `make nightly-install`. This uses the upgrade script www.rust-lang.org/rustup.sh but downloads it first and then asks for confirmation before continuing. Rust-Empty also makes it easier for other people to use your library and prepares your project for the Cargo package manager.
HKT are commonly requested, or so it seems. I think TheHydroImpulse is working on a RFC for HKTs. Info on the RFC process: https://github.com/rust-lang/rfcs
I would really like to see this too. I'm mostly interested in Rust's low-level systems coding capabilities - however monads (which require HKT) are fast becoming a useful programming paradigm. Ocaml for instance is a fairly practical focused language and they have Jane Street's [error handling libraries](https://blogs.janestreet.com/how-to-fail-introducing-or-error-dot-t) as well as [lwt](http://ocsigen.org/lwt/manual/) which is a continuation based library for lightweight concurrency. Also consider NET's linq which can be implemented with list monads, or the various parser combinator libraries.
Nice. There's also PEG parser generator written in rust: https://github.com/kevinmehall/rust-peg &gt; `&lt;&lt;` Feels like C++.
The repeated `.rest()` calls will be very inefficient, every call has to allocate and then do the O(n) copy to create a new `~str` (meaning, if you consume a whole string of length n, you'll probably have O(n^2) performance). It would be more efficient to, for example, store a `&amp;'a str` and then `.slice` it (basically, move from `~str` to `&amp;str` everywhere you can).
How does rust-peg define the special syntax in `.rustpeg` files?
Link to the PR? I'm curious why it hasn't landed yet.
Well, something like this: terminal [-&gt; ActionType] // a followed by another_terminal, left and right are variables = "a":left another_terminal:right { // optional action some_action(left, right) } / [0-9]+ baz // or number followed by baz. No action, no variables Rust-peg uses adopted [PEG.js syntax](http://pegjs.majda.cz/documentation), full syntax is described in [peg/grammar.rustpeg](https://github.com/kevinmehall/rust-peg/blob/master/src/peg/grammar.rustpeg). It probably should be documentated better.
Yep. Mine hasn't updated since apr 17.
I'm not /u/Jurily, but I find chaining them and working with them and `Option` at the same time to be rather annoying. The obvious analog in Haskell is that working directly with the monad operators (&gt;&gt;=, etc.) is annoying, but the `do` notation works really great. For example, `a.and_then(b).and_then(c)` looks pretty good, but normally you would have closures in there, and then it becomes this long tree: let c = a.and_then(|x| { b.and_then(|y| { foo(x + y) }) }); In Haskell this would look something like do let x &lt;- a let y &lt;- b foo(x + y) Forgive me if my Haskell is a bit rusty. Also note that as this gets more complicated, the Haskell `do` notation still stays mostly flat, whereas the rust one gets more complicated, or requires more and more special-case functions to do the same thing as the Haskell `do`-notation. I don't have a solution, I just think it would be really great if we could come up with a Rustic syntax/macro/etc. that makes the Rust version as clear and straightforward as the Haskell version.
In this first line: let f = action(floats(), p); What's p? This is why single-letter variables are evil btw, I can't search for it easily.
Forgot to remove that from the gist. It's still at the bottom of parser.rs It's just an example function to pass on to the action parser.
Aha I didn't go all the way to the bottom because I got tired of finding all the ps =D. I'm curious how the operator &lt;&lt; is defined, since I don't seem to see a definition for it on ParserT or anywhere else...
First I tried "&amp;" as an operator for sequencing the combinators, but "&lt;&lt;" felt a bit more natural.
Ah OK I see now, didn't realize you had to specify operators by name instead of their symbol when overloading.
By the way, when you are trying to find a function like my p() the next time, it's very easy in Rust: search for "fn p(" and you're set :D
With [this macro](https://gist.github.com/bvssvni/9674632), you can write: chain!( do a { Ok(x) =&gt; b Ok(y) =&gt; foo(x + y) }) Not perfect, but it gets rid of the nesting and some of the noise. 
I think there are good reasons to leave it as identifiers, which I tried to justify when it came up in the PR, but I've never thought about the confusion that those identifiers have no relation to program variables. (Yet the arguments clearly do have local meaning.) That's an interesting point - maybe C/C++ programmers are just used to macros being funny about things like that? :) I'm not sure how else to do it though, because I think the names do need to follow basic identifier rules. Even though SystemTap might be fine with any string, I don't think that maps to GDB or DTrace well. It could possibly be an identifier-in-a-string, that gets validated and extracted with libsyntax code, but that's more complicated and I think probably even more confusing. Other ideas? So I still stand by the bare identifiers for now. Maybe a documentation tweak could clarify the literal way they're used?
It doesn't use macros, though this is something you could do with a procedural macro. It looks like it simply reads in the the `.rustpeg` file and outputs a `.rs` file to be compiled normally. It is also self-hosting, so [this file](https://github.com/kevinmehall/rust-peg/blob/master/src/peg/grammar.rs) which is generated by itself is the part which actually performs the parsing.
Awesome, I'll be awaiting a submission here about it once it is. :)
Is this different from `"foo".to_owned()`?
Have you tried `try!`?
Thank you! This worked perfectly. I never thought I'd be so happy to have Travis bugging me about failed builds again.
Essentially what you'd like is the ability to spawn a task as a separate process. This may be possible in some scenarios—I've discussed it, but I don't see how it solves #6842. Furthermore, this is a giant sledgehammer to solve the relatively minor issues of #10463 and #10480. I think spawning a process as a task is a neat idea, but I think it's hyperbolic to call it "task reform" and to say that we have "unsolvable issues" with the current system.
You're welcome. It was easier than I thought. The actual work is done by the Rust team by providing the nightly builds!
I was unaware that it never landed. The only use of `@` left is in the AST.
Yes, try cleans it up some time, but only if you have it wrapped in a function just the right way. In a `main` function, you really don't want `try!`... edit: `try!` also doesn't work with `Option`, does it?
You can also use `ref` as a modifier, which borrows the value and binds to that instead of to the value itself. let ref x = foo; is the same thing as let x = &amp;foo; but of course it's actually useful for destructuring. And you can combine it with `mut` to get a `&amp;mut T`: match foo() { Some(ref mut x) =&gt; { *x = 3i; } None =&gt; () }
I really like the idea of that macro, and its really impressive, but if I remember correctly, it still has some issues with certain constructs, and I would really like to see something like this a bit better supported by the language.
What if it were a normal expression, but `assert!`-ed (or [debug_assert!](http://static.rust-lang.org/doc/master/std/macros/macro.debug_assert!.html)-ed if the overhead can be an issue in production builds) in runtime to be a valid identifier for the backend? Documentation can inform users that having spaces or non-ascii can generate problems with other tools (from what I've read in the PR, the unicode part can already be a problem with bare identifiers). I think the bare identifier can be very confusing for people reading code that don't necessarily know what `probe!` does. Accepting a subset of strings is much less so, because it still follows the same syntax rules as a normal function call.
Actually I have played with rust with the Oculus rift. [vr-rs](https://github.com/csherratt/vr-rs) is a project designed to give access to the Oculus vr (0.2) libraries. I want to support v0.3 when it becomes available for linux. You might want to hop onto the [#rust-gamedev](http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-gamedev) irc channel. 
One thing that always grosses me out in the current stdlib and task system is how 1:1 and M:N threading is done. There is a lot of cost involved in allowing tasks to (at runtime) transparently run on both runtimes with, to me, no clear scenario where that would be an advantage. Typically one would know if you're going to architect your program to use either green threads or OS threads, so this binding could be done statically at compile-time. Instead we pay the costs of going through traits for every I/O operation, larger binaries, slower task-local storage and limiting std::io to the lowest common denominator between the two runtimes. Regarding this pseudo-RFC: It seems like these suggestions would be best implemented as a separate abstraction, like Python's `multiprocessing` module, and not bolted onto the task system. Processes have quite different semantics than threads (even if they share an implementation in some kernels) and trying to abstract over that sounds like a bad idea to me.
Well, there's nothing for the runtime to see, and no backend to speak of from rust's perspective. The whole thing compiles down into a single NOP instruction, and an ELF note to describe that location for SystemTap/GDB/whatever. The note isn't even allocated, so it only adds to the binary on disk, without any additional memory use. That's how these can reach near-zero overhead when not used, and you only pay a runtime cost if tools hook in there with a breakpoint. Even a debug_assert! has nothing to work with. So whatever parsing/analysis we need should be done at compile time. I'm not fully dismissing the idea of parsing the name out of a string literal, just hesitating over the complexity of doing it that way. The unicode point might actually be too conservative of me. I didn't realize that C99 and C++98 actually do allow unicode identifiers, enabled in gcc with `-fextended-identifiers` (see [FAQ](http://gcc.gnu.org/wiki/FAQ#utf8_identifiers)). Clang doesn't even need any special option. So translating rust unicode identifiers into C or asm identifiers is probably just fine. In fact, I just tried `föo` and it worked with both SystemTap and GDB -- cool!
I think there's a problem with the design, or at the very least with its API: [a header name may appear multiple times in a request or response](http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2), and consequences depend on the header's semantics &gt; Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded. that is, a header may appear multiple time if it is conceptually a list of values (expressed as a comma-separated list), each appearance specifying a value of the list. Cache-Control: no-cache Cache-Control: no-store is equivalent to Cache-Control: no-cache, no-store and Accept: audio/*; q=0.2 Accept: audio/basic must be interpreted the same way as Accept: audio/*; q=0.2, audio/basic Extension (non-standard) headers may be defined as either scalar (multiple appearances illegal) or composite.
There's plenty of nice things to Python, but as a long-time (&gt;10) Python user scope inference is *not* one of them. It's error-prone, it's limiting and it's really not very useful.
It would add more support for generic programming, which is, all by itself, a good thing.
&gt; Typically one would know if you're going to architect your program to use either green threads or OS threads I believe this was not the assumption made by the developers. AIUI, the intention is to allow libraries to themselves make use of concurrency, and then allow the consumers of those libraries to determine which mode of concurrency they'd prefer. With the current design, this is possible without forcing all libraries to build, test, and distribute versions against two different concurrency models. I'm not sure that I *agree* with it, necessarily, but there's the reason. It's entirely possible that the decision could be revisited, as it was made back when we were much more gung-ho on green threads than we currently are.
When you say, "binding could be done statically at compile-time" do you mean that at compile time all tasks would be bound to a particular scheduler or that at compile time all tasks could be tagged for being assigned to a particular scheduler? So I could create a pool of tasks that were running on the M:N scheduler and another pool that was running on the 1:1 scheduler? Because that would be extremely useful. You could easily avoid a lot of issues that plague Erlang's M:N scheduling scheme (e.g. blocking NIFs causing scheduler stalls) by telling certain tasks to run on their own thread while allowing other tasks to just be scheduled as green threads. There's some "dirty scheduler" work that's been added to Erlang R17 to do something similar.
What I meant was a specific task, as written, would only be able to run on native threads or on green threads, likely because it would use each API's types directly. As far as I know you can already use both runtimes at the same time to do what you want, you just call the `spawn` methods in each module explicitly instead of the one in `std`.
Yeah, a lot of this feels like it applied better to when green threads were being considered as the de-facto task system. The problem of external libraries is an interesting one. This could either be done with selecting a default runtime at link time, forcing you to stick to a single runtime per binary and not mixing them, or by re-introducing a common interface trait. At least then the abstraction would only be used when needed. Another solution would be to make everything a generic function on the I/O type. I don't know if Rust has the same scalability issues C++ has when making most of your libraries templates. Technically you can already do this currently by directly using `libnative` and `libgreen`, but their interfaces are considerably more low-level and poorly documented. It doesn't feel like they're meant to be used.
Oh, super. Will have to go look.
Due to Rust's ownership system, it's very hard to things NOT to be concurrent-safe. I can't say for sure the HashMap is, though.
I read the post title and thought you were talking about the game, too. I'm really intrigued at using Rust to program games and game engines but I feel I'd be wasting a lot of time refactoring for every release of the language that might be adding a feature I want to use or fixing a bug that's been irking me. I would rather wait for the first stable release.
&gt; not to mention the "`let`" invokes memories of BASIC Also Haskell, ML, F#, LISP... and many other languages with stress on immutable variables (my guess is that it took it from there - I don't know Basic so I'm not sure how similar it is). Similar to Haskell (and possibly other languages) it has pattern matching in `let` - part of which syntax the `mut` is as pointed by eridius. Also this would be complete divergence from Math roots as [variable](http://en.wikipedia.org/wiki/Variable_(computer_science)) [is a symbol for arbitrary or not fully specified or unknown](http://en.wikipedia.org/wiki/Variable_(mathematics)) value and naming is still preserved in pure languages while impure overload the meaning allowing the variable to change value at runtime. While overloading meaning between fields is necessary it might be beneficial not to change it as it prohibits communication - imagine how hard communication would be if by "visitor" or "singleton" in Java we would mean different thing then in C#.
Along with Eridius' points, there's a rant that I've been wanting to get off my chest for a while: the notion of an "immutable variable" is *not* an oxymoron. "What's the use of a variable that can never vary?" may be the joke, but here's a few examples of immutable variables that absolutely do vary: fn foo(a: int) { // `a` can vary each time `foo` is called let b = std::io::stdin().read(); // `b` can vary dynamically based on the whims of the user let c = std::rand::random(); // `c` can vary dynamically based on the whims of quantum physics } The better way to internalize the definition of "variable" is to think of it as a placeholder that can potentially have a number of different values at runtime, in contrast to a constant, which is guaranteed to only ever have a single value at runtime. It's actually for this reason that I don't find the keywords "variable" and "value" (or their misleadingly-similar abbreviations, "var" and "val") intuitive at all: "value" reads as though it signifies a constant, not an immutable variable.
It's concurrent safe because there is no sharing. But in a concurrent hashmap you want the sharing. 
Chris indeed mentions this in the blog post: &gt; For more fun, there are certain things to be aware of in parsing headers like that there may be multiple fields with the same name, but only if they would be equivalent to a single comma-separated list, with the difference that any illegal items should be dropped, or that in some cases part of a field may be invalid and be dropped while the rest is interpreted. I'm still reading the post, but which part of the design do you believe violates this rule?
&gt; Chris indeed mentions this in the blog post: Ah I missed this part during my readthrough. &gt; I'm still reading the post, but which part of the design do you believe violates this rule? I think I missed that the header parsing gets a Vec&lt;Vec&lt;u8&gt;&gt; rather than a Vec&lt;u8&gt;, and the driver should accumulate all the values of a vector name before passing the vector for parsing. I fixated on `Headers` and couldn't see how composite headers would work with just a get/set API, but I guess the composition is supposed to occur before that, not after. Thanks.
For more fun, this isn't quite true for Set-Cookie headers. i.e. if you automatically combine them in outgoing HTTP you're going to have a bad time (see the table at http://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_cookies and google for multiple set-cookie headers).
Have you tried searching for rustlang?
I'm very excited about this.
I want to start doing TDD and I want to use Travis CI. However, it's not obvious to me how to write proper tests. Are there any particular ways you can recommend?
I plan on submitting the one I wrote (evolved since the prototype in rust-core) as soon as `Mutex&lt;T&gt;` works properly. It's a very simple data structure. It requires opt-in built-in traits.
The most convenient and portable convention here is probably to make some kind of heap allocated context to maintain your state that is created by your api, owned by the caller, and passed to every API function with `&amp;`. e.g. pub extern fn create_board() -&gt; ~Board; pub extern fn place_piece(&amp;mut Board, x: c_uint, y: c_uint) -&gt; bool; pub extern fn destroy_board(~Board); Since ~ and &amp; have the same representation the caller can pass the same same pointer to either function - they just need to obey Rust's ownership semantics. Note that I changed your signature to c_uint - typically in API's for non-Rust consumption you want to use the C type definitions. 
https://github.com/mozilla/rust/pull/13316
I find myself a little disappointed this library isn't named "Oculus Rust."
Ach! I should have known there would be a problem caused by bad implementors (though I'm surprised just how widespread that problem is). I guess I need to come up with some way of producing multiple header-fields, then. I had been hoping to avoid that. :-(
Yes. (There will be a type `Box&lt;str&gt;` but one is unlikely to see it very much.)
Because Rust provides some guarantees right off the bat, it requires less unit testing. A major difference between static and dynamic languages. The important things to consider are the function's implementations. Does the function perform some sort of calculation? Some sort of algorithm? Does it have side-effects? (Allocating memory, sockets, unsafe behaviour, etc...) The way I'm currently testing is having the tests within it's respective module. Instead of having them in a single monolithic `test` module or folder, I have them right next to the logic. You would have something like this: #[cfg(test)] mod test { use super::X; #[test] fn x_should_do_Y() { // assert_eq!(.., ..); } } If the function can have more than one result (failure, success, other cases) then you should probably test it. Things like a simple constructor doesn't need to be tested because of the static typing and such. I'm working on a Gossip Protocol written in Rust[[1]] that follows the layout I explained above. Still working out many core design issues so there aren't that many tests currently. [1]: https://github.com/TheHydroImpulse/gossip.rs
This has been discussed quite a few times. It is not going to change.
That's awesome! Any chance you want to demo it at the next Bay Area rust meetup? Are you in the San Francisco area?
Cool! Let me know if I can help organize presenters from SF.
I see, that makes sense! &gt; I didn't realize that C99 and C++98 actually do allow unicode identifiers Cool, I didn't know that either! Gotta start using hieroglyphs when I run out of variable names :)
I have written one for use in Servo. Feel free to take it. https://github.com/mozilla/servo/blob/master/src/components/util/concurrentmap.rs
Out of interest, why did you use `StaticNativeMutex` [here](https://github.com/mozilla/servo/blob/d985b6d7c233ba55175f66545bb79efbca741676/src/components/util/concurrentmap.rs#L40)?
I'd love to give a demo. But I am unfortunately not in the bay area.
Because at the time this was written, mutexes were too slow.
Hmm I ran into a new problem for my staticlib. Calling task_rng() anywhere blows up on me with: fatal runtime error: thread-local pointer is null. bogus! stack backtrace: 1: 0x1009e9055 - rt::backtrace::imp::write::h7c3ab2f63a564e35z1F::v0.11.pre 2: 0x100974b07 - rt::util::abort::h2d9abb26cd33543bkgG::v0.11.pre 3: 0x1009e78d8 - rt::local_ptr::compiled::unsafe_borrow::h5751645887686949017::v0.11.pre 4: 0x100977752 - local_data::get_local_map::haa36e55918be2c86Fok::v0.11.pre 5: 0x100953422 - task_rng::h350fd33086e805b3G1c::v0.11.pre 6: 0x10094db32 - foo::__rust_abi 7: 0x10094dafe - foo 8: 0x10094dacb - main I noticed the compiler is giving me some warnings warning: unlinked native library: System warning: unlinked native library: c warning: unlinked native library: m Are these related? Am I missing some link commands that will make task_rng work or is this a bug? 
I've been thinking over this all day and have come to a conclusion on the matter: the cookie jar won't be being accessed in the same way, so if it is only the cookie jar for which this is a porblem, it won't be. The cookie jar is a separate object which will then, at header writing time, set the headers directly as raw values---for raw values *will* be able to produce multiple fields with the same name. For the moment, I think that will be an acceptable trade-off. I welcome further evidence on the matter, or some way whereby headers can reasonably produce multiple fields while using `std::fmt` architecture, or some other better solution.
http://static.rust-lang.org/doc/master/std/local_data/index.html
How would you implement this? Given a task could call any number of library functions which in turn call the actual model-dependent functions, you would probably need to parametrise the IO functions and all intermediate functions with the type of scheduling used, which seems pretty heavyweight. The flexibility available currently seems extremely useful (and the cost does not appear too dire).
I agree that the last missing *feature* (not taking into account usability) is being able to have a single module come from multiple files. We can already have multiple modules in a single file, it seems like it should go the other way too. We have `include!()` but that just feels wrong.
Interestingly this is not what bothers me the most about the current task system. I am more worried about the absence of `try/catch`. Now, before people go crazy, the main issue with `try/catch` in a typical language is that you can mutate the external world during its execution and in case of failure you are left with a muddled external world: nobody knows if it can be re-used safely or not. Here, tasks provide a very good isolation barrier: by ensuring that no state is shared between tasks, only channels sends can affect the external world. This is great. However, when one just wants a synchronous `try/catch` to be executed now spawning a new task (its own stack, task-local data, thread-local data if native, ...) seems a bit heavy handed for what could be *just* a compile-time boundary...
In theory, I am interested in it. In practice: - it was not clear in your proposal if the list of effects is written in stone or can be user-extended ? The latter is hard to achieve composition-wise because 3rd party libraries are not annotated with your own effects, and soon multiple effects in various libraries describe the same thing with different names or use the same name for different things. - I am not sure if separating Disk I/O and Network I/O is worth the trouble, for example where I work our logs are either flushed to disk or sent over the network depending on run-time parameters... is there a specific reason the distinction is important to you ? This seem weird in an *everything is a file* world - I don't understand what `Unsafe` is about; an effect system is generally concerned about side-effects and `Unsafe` is an implementation detail. This seems like mixing concerns.
For Rc you can do this: use std::rc::Rc; let rc = Rc::new(5); let s = match *rc { 5 =&gt; "such pattern match, many example" _ =&gt; "what just happened?" }; println!("{}",s); Alternatively, if you do `rc.deref()` you get a borrowed pointer to its contents, which you can pattern match on.
This is very interesting, I like it and it would make Rust even more interesting to me, as I wanted a language with effect systems for some time now. However you don't talk about row variables at all in this RFC : how do you type map ? An effect system without row polymorphisms is very limited (and probably very annoying to work with).
That's okay we can do remote demos too. I'll ask around if anyone local has a Oculus Rift to demonstrate your stuff in person. 
would splitting modules into submodules be more pleasant with something like inherit-use ... I've also heard that a glob export bug is going to be fixed by eliminating glob reexports, but I think those are useful when you want to create a lot of common context; perhaps if you parent module could just say "inherit use self::submod1::* ; inherit use self::submod2::*; ... " , splitting modules up would feel easier?
Sorry for the bikeshed comment, but `trustme` and `wont` are a bit awkward. 
That is a very difficult question to answer! Off the top of my head, I can come up with the following things. Please keep in mind that I don't know much Rust (yet) and these "rules" come from my experience with the Ruby language: * Write small tests, i.e. test only one thing per test * Take care to test the edge cases * Keep an eye on the amount of setup you need to do for a test. If it's a lot it points to a design problem * dependency injection is especially helpful for tests If you want we can try pair programming and focus on the tests. We can either work on any of your (OSS) projects or on [Iomrascálaí](https://github.com/ujh/iomrascalai). I can then help you with TDD and hopefully learn some Rust in the process.
There are some specific benefits to this approach though; specifically per platform code that resides entirely in one module rather than several awkward submodules imo.
singletons are unavoidable. Have a look at how connection pooling is done in https://github.com/sfackler/rust-postgres for an example of probably the best way to handle it.
Thanks for the tips. I love pair programming -- did it with a friend once and it was great -- but I don't think pair programming with me would gain you much, since I haven't even started learning Rust yet -- am currently trying to focus on the two languages Erlang (first) and Go (next). And I have practically zero AI experience.
No problem! But you'd be surprised how far you can get with almost no knowledge. I haven't gotten much further than reading the Rust tutorial either and was able to do code reviews for Rust code already. If you change your mind just hit me up (see the "pair programming" sidebar on my website http://bettong.net).
&gt; it was not clear in your proposal if the list of effects is written in stone or can be user-extended ? The latter is hard to achieve composition-wise because 3rd party libraries are not annotated with your own effects, and soon multiple effects in various libraries describe the same thing with different names or use the same name for different things. I'm going to add that to the RFC. I'm against having user-defined effects. Mainly because I don't think it would be truly useful (unless I'm missing a few use cases). There are a standard set of side-effects that a program could have, and I can't imagine a user coming up with a *new* side-effect. Now, if there are missing side-effects, these can be added into Rust accordingly. I agree about the composition point. Another reason it would be much harder. The last point about them is inference. I can't imagine an effective way to infer custom effects. This would be built into the language for the known effects. &gt; I am not sure if separating Disk I/O and Network I/O is worth the trouble, for example where I work our logs are either flushed to disk or sent over the network depending on run-time parameters... is there a specific reason the distinction is important to you ? This seem weird in an everything is a file world There wouldn't be any distinction. There would be a single `IO` effect. The list of example side-effects where separated arbitrarily. &gt; I don't understand what Unsafe is about; an effect system is generally concerned about side-effects and Unsafe is an implementation detail. This seems like mixing concerns. The idea behind unsafe is that it would be a high-level effect that one could enforce. The reason for it is because of some undecided behaviour for unsafe blocks: * Should the compiler not try to infer unsafe blocks and explicitly ask the user to define them? * Should users be forced into the effect system? * Should the compiler infer as much as it can and warn the user when it cannot (similar to lifetimes) Thus, if the user isn't forced to define the effects, then you might have: fn important_fn() wont(Fail, Alloc) { // Example enforcements. // do some important task. call_library_fn(); } If the `call_library_fn` function contains unsafe code where side-effects happen, but, the user hasn't annotated them, you might run into trouble. That's the point of `Unsafe`. It's a catcher (top-level effect). The default enforcement is `Anything` which excludes `Unsafe`. Thus, you'd have the same semantics as right now. However, depending on the choices above, Unsafe could be useless. And you're right, Unsafe is typically not a side-effect you're interested in. 
Those were the names proposed in the original proposal. If there are more appropriate names, the community can discuss their preference. But, I hope it won't get as bikesheddy as the channel naming thread.
Singletons aren't fashionable in any language, but they're especially horrible in rust. It's always a code smell when you need to use them. If you can't list a reason why you need one that is outside of your own control (frameworks, opengl, OS interface, ...), it's almost certainly a design flaw.
Having the mutable version be more verbose encourages people to make their variables immutable where possible, which is a good rule, as it makes your program easier to understand and more likely to be correct. I really wish other languages like Java were immutable by default. 
&gt; If you can't list a reason why you need one Hrm? Almost every project I've worked on could can use them. To hold application-wide config variables, or to hold database connections... Why would I want to instantiate something like that early in the application life-time and then have to pass it all the way through 10 levels of abstraction, creating dozens of references to it?
&gt; am I missing some bigger issue? The `box` feature isn't implemented beyond being a placeholder. When it is, it will be usable for constructing other types of smart pointers (or doing other in-place construction, like pushing to a vector) and pattern matching on any smart pointer.
`wont` doesn't go well with all effects, for example in `wont(IO, GC)`, and is grammatically incorrect. `forbid(IO, GC)` conveys the intent and reads better. Maybe I can come up with something for `trustme` as well. Is a nested override necessay by the way? As in `trustme(wont(Fail))`.
Totally agree. In fact I requested that on the mailing list some time ago, because I don't like working with big files at all. The only reason that was given me why the current situation is better was that it works better with vim. I don't like that either, because whether you want to work with vim is also heavily biased.
I actually enjoy `forbid(IO, GC)` a lot more. There would be special cases where you'll need the nested override. Either if the compiler fails to infer it correctly, or you're doing some special stuff. A notable example is the destructor and assert. impl Drop for Something { fn drop(&amp;self) trustme(forbid(Fail)) { // ... } } There are some issues with `Fail` (as an effect) that's discussed in the comments on Github.
"Attributes", as I understand it, only let you add meta information to a class/function but are useless without reflection. These are useful but less powerful than Python-style decorators IMO.
I'm not sure I still count as a newcomer, but still: 1: I don't think either concept is harder to understand as such. "mutable reference" needs some explanation wrt uniqueness and "only reference" needs some wrt mutability. 2: My gut feeling it that the later rules is easier to understand. Particularly because the first one is wrong on multiple levels. First of all as you point out above there are some cases where part of a `&amp;Foo` can in fact be mutated. But more importantly it is not "if you have the only reference", but "if you have *an* `&amp;only` reference". E.g. in `let x = 3; let y = &amp;x; *y = 4` it is pretty clear that `y` is the only reference to `x`, as it can not escape, but mutation is still forbidden. Another fear I have is that using `&amp;only` might lead people to prefer it. Having "the only reference" to something sort of sounds desirable and like it would be good for optimization. And indeed it would be (for the same reason `restrict` is in C), if the other type of reference wasn't immutable…
We're also having a testing hackathon right now if you want to participate. You can find details on how to participate remotely here: https://mail.mozilla.org/pipermail/rust-dev/2014-May/009791.html.
I'm no longer a newcomer to Rust and I think I have rather firm understanding of how borrowing and mutability works (at least, from language user perspective), but I still think that "mutable reference" and "you can only have one mutable reference to a value at the same time" are easier to understand, though I'm not sure by how much, The point is, as I see it, that on the semantic level mutability is more intrinsic characteristic of the data than aliasability, and so it is easier to grasp. When you talk about mutability, you say "the data behind the reference is mutable/immutable", and the emphasis here is on the data itself, but when you talk about aliasability, you say "you have 'only'/not 'only' reference to the data", and the emphasis is on the reference and its relationship with other references. While this may be more correct from theoretical and implementation point, it is indirect and less practical. I don't think it will cause confusion in experienced Rust users, but it certainly can raise the learning curve of the language. That said, one of the main sources of confusion around mutable references is their non-aliasability. Some time ago I asked questions on Stackoverflow on that - until you have some experience with borrowed pointers, the fact that one cannot have multiple mutable borrows of the same data is quite surprising, especially when borrowing is not explicit, like in method calls. Maybe explicitness of `&amp;only` references and their semantics will make them in fact more understandable. Frankly, I don't know.
The idea about using `~` as exclusive reference syntax is very nice and definitely worth considering.
1. I'm not a newcomer, but I would say between the two concepts of mutable reference and only reference, mutable reference is easier to understand. 2. On the other hand, between the two rules, "you can only mutate a value if you have the only reference to it" is easier to understand. I suspect `&amp;only` is (possibly significantly) easier to understand and clearer in the long run. `&amp;mut` feels familiar in tutorials because of the mut keyword, but difficulty in using it comes from restrictions imposed by the borrow checker, which `&amp;only` attempts to convey to some degree.
Why should code 10 levels down even know what application-level config *is*? Each component that needs configuration should expose some way of configuring it, and the component that needs to configure it would do so. Any sort of application-level config that you need to get at from `main()` should just be an amalgam of the various configurations that had managed to expose themselves that high (e.g. because the various components didn't know how to configure them directly and needed to expose their own configuration).
&gt; Another fear I have is that using &amp;only might lead people to prefer it. Having "the only reference" to something sort of sounds desirable and like it would be good for optimization. And indeed it would be (for the same reason restrict is in C), if the other type of reference wasn't immutable… Actually, I'm pretty sure there'd be no real difference between an immutable `&amp;imm only` and a mutable `&amp;mut only` as far as optimization is concerned. If LLVM knows that it can see all the mutations (which it can for any `&amp;only`), then it can easily work out for itself whether the value is immutable.
Thanks, I think that makes a lot of sense.
One directory per file is a bit excessive. A major benefit of the current scheme is that, in order to find anything that's in the current module, I can just search the current file.
On a basic level, I'd say (im)mutability is an easier concept to grasp. However, I'd still learn towards `&amp;only`, because having `&amp;mut` represent a lie will only be confusing in the long run. It's one of those things that would probably be cursed in the future as "legacy" and "making no sense". `&amp;only` also makes `Cell`, `Mutex` and friends much easier to understand, exactly because they aren't building upon a lie.
I agree. I especially dislike that the *english* of `&amp;mut` is separate from actual compiler guarantees. The only thing we get in return is the symmetry between `let mut` and `&amp;mut`, which is mostly artificial when the dictionary definition of "mutable" (i.e. why one would use `let mut` in the first place) isn't helpful for reading and writing `&amp;mut` code.
The solution is to use a `StrBuf` (*not* `~str`) and match on `vari.as_slice()` instead of just `vari`. This will let you pattern match against regular string literals (`"foo"`, which are of type `&amp;'static str`).
Yes, all the "compiling from source" stuff was supposed to imply that I wanted a generic cross-platform solution.
I think mutability is still easier to understand than uniqueness. Furthermore, we still need `mut` to denote mutable variables. If our reference becomes `&amp;only`, then it seems confusing that you can't create an `&amp;only` reference from a regular variable (after all, it's the only reference!), but you can create it from a `mut` variable. For example, this is what the error might look like: let x = 3i; let y = &amp;only x; &gt; error: cannot borrow immutable local variable `x` as only That's just very confusing. And if it says "as mutable" like it does today, that's still confusing. --- Basically, I think it's easier to understand that mutable references must be unique, than that there's a special type of reference that enforces uniqueness that also happens to allow mutability. Because with the latter it emphasizes the uniqueness of the reference, but uniqueness isn't actually interesting without mutability.
I'd like to add a another perspective to this: almost all projects I build in Rust involve some form of binding (be it a C binding, or talking to a database using a protocol). I usually to use `&amp;mut` for also seperating interfaces. I recently built a CouchDB interface where all functions actually changing the database (e.g. create document) are defined on `&amp;mut self` only. This is incredibly powerful (allowing to pass the database handle to other components as read-only), but would really lose it's charm if `&amp;mut` would vanish. In terms of guarantees, it wouldn't help in any case - if the C library does mutate despite expectation or the Database have some side-effect that mutates data still, Rust cannot help it. But it is a very nice API syntax addition. I think given that mutability is one of the big problems of our times, using the word in the language is far more powerful than speaking about `&amp;only`, even if is slightly less correct.
It's unclear, but probably all `let` bindings would become mutable.
Probably all `let` bindings would become mutable. I actually think this would not be as bad of a change as it seems, because it's rare that this actually prevents bugs—most mutability problems are due to concurrency, iteration, and so forth, which we solve by restricting aliasing. I think it's worth asking *why* we want mutability restrictions—we find that most of the reasons either don't apply to Rust (laziness, referential transparency) or go away when we restrict aliasing (concurrency).
Say it ain't so! I really like the fact that mutable variables need to be explicitly annotated as such. It's easier to reason about my code when I know what's allowed to change and what's not. And yes, I know I can have an immutable variable that contains something like a `Cell`, but the type tells me the same thing (that the data can change). `const`-by-default is a great property, and I don't want to lose it.
Isn't that a step back? I really enjoy having a separate, longer construct to create mutable variables.
I don't think so. What bugs are actually prevented by this? As I said above, you can always scan the body of a function to determine what is being mutated. I think the problem with mutability is unexpected mutability through aliasing, which is what Rust solves in a strong way. Is it worth having *three* types of references—`&amp;mut`, `&amp;only`, and `&amp;`, to have what essentially amounts to a lint?
What bugs are you actually preventing? I'm not sure it's worth having three types of references in the language because of what amounts to a lint. You can always scan the body of a function to determine what is being mutated. I think the problem with mutability is *unexpected* mutability through aliasing, which is what Rust solves in a strong way.
I can see that working. It would make me a bit sad, not because it potentially catches errors (none come to mind), but only because it serves as enforced documentation of what a function manipulates and what not. However, I can see the point in losing that if clears up the overall semantics. Personally I think both approaches are fine. In my head, the distinction is more between `&amp;` being a "borrowed view" and `&amp;mut` being a "temporary hand-off."
Immutable by default makes it easier to quickly understand code. It's also a declaration of intent, and code with fewer mutable variables is cleaner.
The emphasis here though is the unexpected mutability, not the aliasing. Preventing aliasing with `&amp;mut` pointers is a means to an end, not the end goal itself. Also, if you remove `mut` variables, and you call the pointer `&amp;only`, then it's going to seem like `&amp;T` should be a non-unique mutable pointer.
&gt; The emphasis here though is the unexpected mutability, not the aliasing. Preventing aliasing with `&amp;mut` pointers is a means to an end, not the end goal itself. Well, maybe. I would say that preventing bugs is the end goal itself. :) But this is a side point. &gt; Also, if you remove mut variables, and you call the pointer &amp;only, then it's going to seem like &amp;T should be a non-unique mutable pointer. But that's part of the goal. `&amp;` *can* be a non-unique mutable pointer, if the type contains `Cell` and friends.
I guess my basic question is: Is it acceptable for people to prefer `&amp;only` references, over "normal" ones? Do we maybe even want them to? Why/why not? My intuition is that (some) people would instinctively prefer `&amp;only` whenever possible. Having one owner of something is after all idiomatic to the language, why should that not be true for references? Normal references can still be used when multiple read-only borrows are needed for some reason. What irks me is that this would be pretty much the exact opposite of the status quo. People usually prefer normal references, over mutable ones if possible.
 let result = calculate(); println!("result = {}", result); // code result = 0; // mode code calculation_with_result(result); //why isn't it working?
It looks like you can use the [truncate method](http://static.rust-lang.org/doc/master/std/strbuf/struct.StrBuf.html#method.truncate) like: vari.truncate(0); Edit: I'm surprised StrBuf implements the [Container trait](http://static.rust-lang.org/doc/master/core/container/trait.Container.html) but not the [Mutable trait](http://static.rust-lang.org/doc/master/core/container/trait.Mutable.html).
Newcomer status: I played around with Rust 0.8, using it to solve the first 10 [Project Euler](https://projecteuler.net/) problems. I have a sense of what the language feels like, but I'd definitely flunk a closed-book written test. 1. I would say that "the only reference" is slightly easier to understand than "a mutable reference". With "only ref", it is intuitive (to me) that the adjective applies to the reference itself. With "mutable ref", I can't intuit whether it's a mutable reference or a mutable value. That said, I think the concepts themselves are equally simple, and I was almost going to say "it's a tie". But one is harder to communicate, in my opinion. 2. I prefer the first statement of the rule: "you can only mutate a value if you have the only reference to it". It tells me what I can do. The second statement feels more abstract to me. It's sort of like the difference between `if p then q` and `!p || q`. They mean the same thing, but the first one is closer to how I think. My preference here is stronger than in the first question.
There's lot of code that's just "tricky" with a bunch of variables and complicated expressions (e.g. sophisticated math code). One way to drastically reduce the mental effort of reading such code is to make all the locals immutable. This way once you know that x is the name for some expression, you don't also have to scan through the body of the function to make sure it's not mutated. IMO this applies to less tricky code too. It's just easier to read if you don't have to do an O( n^2 ) process of scanning the body for each variable to see if it's modified somewhere else too. The clue is in your own statement "You can always scan the body of a function". If you need to scan the whole body of a function to fully know what a single let-statement really means, it's clearly not as readable as it could be.
I look forward to reading Niko's RFC. In the meantime, let me just state what I like about Rust and its immutability: * Mutability is explicit; I wouldn't like if `let x = 3; x += 1;` inferred `x` to be mutable. I'd rather get a compilation error telling me that my declaration and usage of `x` do not match. * Immutability is the default. This is probably the functional programmer in me speaking: I prefer when only a small part of my code is mutable. I like that I need to explicitly opt-in to have a mutable variable. Hopefully you can clean up the internals of rustc while keeping the "spirit" of the current implementation.
After reading the post a couple times, I now prefer '&amp;only'. For example, if you have a 'mut a: &amp;only T' as function argument is easier to understand than 'mut a: &amp;mut T'. I don't find the example confusing. 'x' is referred in two places, one being the value and the other as '&amp;only'. Besides, the compiler says 'immutable' which tells you what the problem is. If you pass '&amp;only x' as argument to a function it is in a local scope where 'x' can't be referenced. Personally I prefer 'let' bindings to be immutable by default. It will prevent bugs when you have similar names, like 'x1, x2' etc. Typical hard to find bugs in graphics programming. If understanding why the compiler complains is the only problem, then perhaps we should make the compiler error clearer? Loosing immutable by default seems like a huge sacrifice. Then I need to think implicitly about which variables are immutable to solve borrowing errors, instead of the compiler telling me where I try to use it as mutable. That would be a mental burden.
It's a bombshell that you're even considering this. I'm reflexively hugely against this idea, but I would need to consider it in full detail. Please write up something more comprehensive. Just be aware that if you think losing `~` caused a racket, the perception that you're ditching immutability-by-default is going to far exceed that.
Apologies if this isn't 100% relevant, but what you said about symmetry reminds me of something I found difficult when learning C pointers. For pointers in C, there are 2 symbols with 3 total meanings: `*` declares a pointer, `*` dereferences a pointer, and `&amp;` gets a memory address. The intent was that declaring a pointer would look like using that pointer. Soon after I finally mastered pointers, I remember feeling that 2-symbols-3-meanings was a stumbling block for me. Looking back on it, it sounds a little silly, because the concepts are simple. But 2-symbols-3-meanings felt like a veil that kept the simplicity hidden from me. The moral: be cautious about using the same name for related-but-distinct things.
The underlying semantics are so complex right now that I don't think any existing word (mut, only, etc.) could ever be adequate to describe them. The current borrowing rules are: *You can mutate an object if [you have the only reference to it, AND the object itself is mutable], OR if [the object is a Cell, RefCell, or something else in the vaguely-defined group of 'always mutable' standard-library objects]"*. And we need some word which means *this reference is the only reference to a mutable object*, without implying *this reference is the only way to perform mutation*. Would it be stupid to suggest &amp;orm, standing for "only reference to mutable"? It'd make the language uglier to the casual viewer, but having a handy mnemonic for the borrowing rules may make it easier to learn, in the long term. 
The RFC still needs some work. I'll be working on providing more details.
Having to mark mutable variables as `mut` isn't about preventing bugs (directly, at least), it's about code readability. The reader can instantly see which variables are actually just "expression names" and which hold state that changes. When you improve the reader's comprehension about mutable state in the function, you increase their understanding of how the algorithm works and thus indirectly lower the chance of bugs. There are lots of people in the C++ community who annotate all their local vars that don't change with `const` for this very reason. Personally I find it too cumbersome to be worth it, but immutable-by-default prevents the laziness argument. 
It seems that there's currently a dichotomy between the mental model Rust presents to the user (`&amp;mut` presents itself as "mutable reference" but actually isn't always; BTW this is completely new to me) and the _actual_ model that the compiler implements. I'd argue that _any_ design that builds an incorrect mental model in the user's head, no matter how well-intentioned ("But this is easier to understand for newcomers!") will ultimately lead to unhappiness, poor understanding and the breaking of [The Principle of Least Astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment). `&amp;mut` appears to be a very leaky abstraction. If we can replace it with `&amp;only` and thus present to the user the _actual_ model of the language instead of a simpler-but-wrong one, I say go with the actual model. Otherwise we'll end up with "Rust Gotchas" blog posts that try to fix people's wrong mental models. And angry users. In other words, _tell the user the truth_. Don't "lie" with a simpler-but-wrong model they'll have to throw away when it inevitably breaks down.
Making 'let' bindings mutable might introduce another confusion: let x: &amp;only int = ...; *x = 5; // ok vs let x: &amp;only int = ...; x = 5; // error: expected '&amp;only int' but found 'int' With immutable by default, this is less confusing. Any particular reason to not keep 'mut' on the left side? It could no longer mean "deep mutable" but simply a mutable binding. For example, the following would be valid: let mut x = &amp;a; This will be rare cases anyway. In my Ludum Dare entry I would need 'mut' only in 4 places. If mutability gets default it will change the semantics 100x more. * Edit: My point is that 'let x = &amp;only a' is rarely needed and perhaps not even necessary, I don't know if I've ever used it. I see no point in changing to mutable by default for a case that is so rare and bad style.
Yeah, I agree with this. I would prefer a more-difficult-but-correct concept to a simple-but-misleading one any day. That said, I personally think that uniqueness is easier to understand. At a time when there is a lot of talk in programming circles about how immutability is better for concurrent systems, the idea that you can only safely mutate something if no one else can see it, seem entirely reasonable. 
&gt; It's a bombshell that you're even considering this. I'm reflexively hugely against this idea, but I would need to consider it in full detail. Please write up something more comprehensive. &gt; Just be aware that if you think losing ~ caused a racket, the perception that you're ditching immutability-by-default is going to far exceed that. This is unfair, IMO. Would introducing a third kind of reference `&amp;uniq` to go along with `&amp;` and `&amp;mut` be a bombshell too? What about the complexity of the borrow check, including the errors that users see?
But locals that are marked immutable *aren't* always immutable in Rust, if they contain `Cell` and friends.
&gt; Is it acceptable for people to prefer &amp;only references, over "normal" ones? Do we maybe even want them to? Why/why not? Yes, I think that's actually acceptable in many cases. It makes refactoring easier because you don't hit the `&amp; &amp;mut Foo` gotcha as often (as `&amp;mut &amp;mut Foo` works).
Oh..that's much better!
&gt; The reader can instantly see which variables are actually just "expression names" and which hold state that changes. But that's not true with `Cell` and friends.
I like a lot the idea of Algebraic Effects System, but it seems really unnatural to me to introduce keywords between the signature and the body. Is there any technical reason, not to use attributes like #[effect(GC)], or #[forbid(Failure)]? It seems to me the natural way to do this kind of things in Rust.
Just because we can't increase readability for 100% of cases doesn't mean we shouldn't increase it for 99% of them.
I haven't spent a lot of time in rust, but it seems like the issue you're talking about interacts with inherited mutability. Is mutability better treated as a property of the reference or of the referent? It seems like current-rust is munging together mutability and uniqueness as properties of references, but if you took the issue of mutability away from references and moved it back to the referents, wouldn't that simplify the issue you're raising here? Your first two examples seem like cases where mutability isn't actually inheriting. Edit: if you're looking for innocent-eye perspectives, I was suprised by the original proposal to make mutability inherited; I thought of (im)mutability as being a property of the referent.
I think this may actually hit the nail on the head. `&amp;only` implies mutability; `&amp;mut` implies uniqueness. Picking one word for this is hard. I am leaning toward `&amp;only` because it is more often correct than `&amp;` (in particular, when `&amp; &amp;mut` is involved.)
Well, I'm not sure about that. If "immutable" doesn't mean "immutable" in 100% of cases, then what does it really mean? With programs, we deal with absolutes. "Probably immutable" doesn't really tell me anything.
Speaking as someone who normally finds sigils harder to warm up to, and as someone who has liked the recent trend in Rust away from sigilville, I'm surprised to say that this is exactly the sort of question that I would like to be solved with one: if one can't come up with the right word, make it a symbol. I'm sorry if that's a Can O' Worms best left sealed.
This feels like an issue where context decides what is clearer. Somebody programming a large concurrent structure is more likely to run into problems with `mut` not doing what it says and immutability by default not actually being immutable. On the flipside someone trying to share as little state as possible between threads or sombody avoiding threads altogether isn't going to add any clarity by having explicitly `only` references, state isn't being shared anyways so `only` in those cases is more or less the default position on everything. Just thinking about why Rust was built (to do safe concurrency) I think `only` will end up being the more clear semantic than contorting the borrow check into a state of "not lying" about mutability, which it's going to do anyways wherever there are structures designed to enforce those rules dynamically. EDIT: Newcomer status: I've played around with Rust for a while, but I've only recently actually tried to build anything non-trivial. I'm very new to framing problems and solutions concurrently and this post has ended up clearing confusion as to what `mut` actually means and why `Cell`, etc. contents are mutable anyways.
Which fallacy is consistency?
Right now, it seems that because `mut` is not precise 100% of the time, it should be taken away and make everything mutable. That doesn't strike me as the best solution.
They're "shallowly immutable". Yes if you opt in to a type that provides mutability for you then it will have mutation happening, but again that's something that's a lot more visible than if a float randomly changes value. So you only have to take special care for something that's either "mut" or one of the relatively few types that provides mutability like Cell. Still better than everything being that way. Bottom line is that you can look at a single "let"-statement and understand what it means (no need to scan the rest of the function). Cell and friends don't change that. The information is local rather than this implicit property of the rest of the code.
I'm not sure I agree that immutable locals improves readability due to the fact that locals can be shadowed.
The same concerns about `~` being unavailable on common keyboard layouts still apply for other uses. Fewer symbols also make the language more approachable.
Indeed, and that is what I was agreeing with. Sorry if it seemed otherwise.
`&amp;mut` is much more obvious when starting than `&amp;only`. It was easy for me to understand 'mutable references must be unique', I think it would be much more of a WTF if `&amp;only` was used and then it was explained 'That means it's mutable'. The core part being that mutability is what you want: the uniqueness is the means to that end. So it feels natural to use the label for what you want and then explain what the compiler needs to enforce to do this safely.
Well, that's not the only reason. The other, more compelling reason is that `mut` causes us to need three reference types to make closures work with the borrow checker and to get rid of the weirdness of `&amp; &amp;mut`. I'm going to see if there's a hybrid solution we can take that keeps `let mut` the way it is but switches to `&amp;only`, and changes the way closures work.
This part I am against hugely. Being able to see which bindings are mutable and which aren't in a function is a huge win in terms of readability (though there are not many bugs caught directly by this), and const is the common case.
Sounds like an easy pull request to make ;)
Yup, 100% agreed.
1. Yes. Mutability is an easy concept to grasp. Something is mutable, or it is not. You either have a mutable pointer or an immutable pointer. Unique pointerness seems non deterministic, and a more difficult concept. Do I have a unique pointer to this object? How do I tell? Does this imply that there can be non-unique pointers to an object? If so, how do I delete the other pointers to it to make this one unique? How do I get a count of the number of pointers to an object currently to tell if this pointer is unique? ...and these are actually valid questions, because practically speaking unique referencing *is* the important idea; it's trivial to get two mut &amp;Foo variables with unsafe code, and it's entirely unclear (to a new comer) why this is bad, or what the result of doing so is. ...but mutability is an easier concept. 2) 'you can only have one mutable reference to a value at the same time' is a simple rule to understand. ...but it feels like an arbitrary decision. Explaining it to new comers means you immediately have to step into pointer aliasing and why that's bad, which is much more difficult concept; and you *do* have to go there all the time, because practically speaking you *can* have multiple mutable references to a value, and you can even get away with it as long as you don't use them all. (and unsafe code, like it or not, is really common for new comers who like rust but want to do unrusty things like bidirectional linked lists). 3) &amp;only is a terrible syntax, please don't use it no matter where we end up with this mutability discussion. 
(Note: newbie to Rust.) I strongly disagree with this. One thing I absolutely loved about D was the direct mapping from modules to files and vice versa. It meant that if I knew how a symbol was accessed, I could find its source. It's something I was *very* happy to see in Rust. As long as you can take multiple sub-modules and expose their contents as a single logical "surface" module, I'm not sure what's being lost by keeping this, aside from the convenience of not having to write the surface module itself.
You must understand that there is a difference between adding a feature and slaughtering a sacred cow. If it will make the language easier to understand and easier to use, then ultimately I'll support you. But in the meantime you have a **marketing problem**. I don't think it's exaggerating to say that the announcement of `~` removal was hugely botched. As was the deprecation of rustpkg before that. In both cases there was a lot of implicit knowledge among the devs to justify such actions, but you did a very poor job communicating this to the wider community. In the former case, you did a poor job of actually announcing what `box` was and the problem that it was introduced to solve. Those of us who read the meeting notes knew that this change has been brewing since last year, but it was surely flabbergasting to those with only a more casual interest. Thank god that strncat was there to do damage control. In the latter case, rustpkg's removal was motivated by the fact that you had hired outside developers to write a replacement, but this was *literally* secret knowledge at the time. Even if contractual obligations kept you from broadcasting Yehuda's involvement, you could have done better at communicating that a replacement was forthcoming. In the meantime, immutability-by-default is a feature that's much more fundamental than either of those. "Bombshell" is exactly the word I would use to describe this. It's approximately as though you had casually let out that we're switching the syntax over to S-expressions next month. Please, be more careful with this announcement. You need to convince people that this makes the language *safer*, while being careful not to make statements that can be taken out of context (continually emphasize that immutability-by-default might not make sense only in the context of *Rust*, not in general). If you can manage to forcefully convey that aliasability is a *stronger* correctness guarantee than immutability, then **you will have won at marketing**. Make it your rallying cry. You will also need to mollify those with a functional bent who will need convincing that immutability is not useful here. And surely there's *some* reason that modern C++ style is to use `const` absolutely everywhere, so you'll need to properly address that crowd too. All the while you'll need to drive home that immutability does *not* enable any optimizations, and that aliasability does. I know that you don't *not* care about marketing. So again, please be careful what you say and how you say it! I'm here to help you!! :)
Memory safety is hard. I don't think that it's possible to just make the language smarter without tradeoffs such as the ones we're discussing here.
I'd vote for going with your design but mixing it with *private* fields for standard headers. To provide access, you could add another method to `HeaderMarker` like so: fn get_standard(&amp;self, headers: &amp;mut Headers) -&gt; Option&lt;Option&lt;OutputType&gt;&gt; { None } The semantics of this function would be to return `None` if the marker is for a extension header and otherwise return `Some(headers.get(MARKER))`. `Headers::get` would then try to use `get_standard` to extract the field, and only fall back on the `HashMap` if an extension header is being accessed. This improves performance on standard headers, yet doesn't sacrifice consistency or future-proofing. Moreover, if implemented right, this could make accessing raw headers easier: pub struct Headers { // standard headers, // parsed extension headers, raw_headers: HashMap&lt;SendStr, Vec&lt;Vec&lt;u8&gt;&gt;&gt; } impl HeaderMarker&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt; for RawHeaderMarker { fn get_standard(&amp;self, headers: &amp;mut Headers) -&gt; Option&lt;Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;&gt; { Some(headers.raw_headers.find(self.name)) } fn header_name(&amp;self) -&gt; SendStr { self.name.clone() } } (Note: The above code is just meant to demonstrate the idea. There are probably issues with lifetimes and resource management that need to be dealt with.)
I think that this is the problem with working in the open. When we say we're exploring something we easily invite "marketing problems", because people are quick to say that we're abandoning our functional principles. The fact is, the problems that we're addressing with mutability, uniqueness, and the borrow check are *subtle*. They involve the precise rules around borrow checking that, to be honest, only a handful of people understand. Realize that Rust is *different*: the borrow check *has never been done before*. Most people don't understand just how delicate of a precipice the borrow check, and therefore the entire memory safety feature of Rust, hangs upon. We are in a very constrained space here, and we have little wiggle room. When we say that we're thinking about making all locals mutable, that's not because we hate functional programming. It's because the borrow check *can't actually model closures* using the system we have today. Maybe that's OK and maybe it's not. But we all know the benefits of functional programming and repeating it is beside the point. Memory safety without garbage collection is a constrained space. Most people don't realize how difficult it is (hence all the people who think C++11 is memory safe). If we weren't willing to try different ideas, then we would never have gotten as far as we did. So I have to ask the community to please trust us a bit. Mutability and the borrow check involve actual research, and knee-jerk reactions are unhelpful. We have no sacred cows except memory safety, C++-level performance, and practicality.
Rust only lets you mutate a value if you have a `&amp;mut` - ie, the only reference to an object. Generally, its possible for code that needs to mutate a value to be written in such a way that the compiler can prove that the reference used to mutate a value is the only reference. In those cases, there is no need for `Cell` or `RefCell`. However, it can be very difficult or impossible to write some code in such a way that Rust the compiler can understand at compile time that a particular reference is the only valid one. Even though the author of the code may know that its safe to mutate the value, Rust won't let you. Thats where `Cell` and `RefCell` step in. They let someone writing code mutate a value even if the compiler can't prove that its safe to do so. The design of `Cell` and `RefCell` enforce all of the same mutability rules that Rust has, but, they do it at runtime. In general, if you can avoid using `Cell` or `RefCell`, you should. However, in cases where you can't, they are way better than resorting to unsafe code since both of them unsure that you won't run into undefined behavior.
RefCell is for being able to mutate when you don't have the only reference. It doesn't have to do with multithreading. Requiring that RefCell have &amp;mut would defeat its purpose. &amp;only is never a lie, or else it would be memory unsafe.
Asking for a bit of trust is entirely fair. I think everyone wants to encourage exploration of all possibilities before Rust makes hard backwards compatibility guarantees. I think in this case a blog post writeup would be very helpful, and I'm sure a high level of transparency would buoy confidence in whatever decision is ultimately made.
&gt;Unique pointerness seems non deterministic Uniqueness is not non-deterministic as it applies to `&amp;mut` (or `&amp;only`). Its something that Rust enforces at compile time. Assuming you don't use unsafe code, if you write `&amp;mut` (or `&amp;only`) and you code compiles, you can be 100% certain that that is the only refernce to the object. &gt; 2) 'you can only have one mutable reference to a value at the same time' is a simple rule to understand. Ownership and uniqueness are key concepts in Rust. In my oppinion, the sooner that you can get new users to think about and understand those concepts, the better. New users that don't understand (or at least partially understand) those concepts, aren't going to be happy users. They might write a bunch of code, but I'd wager it unlikely to work how they expect which I think would be very frustrating. I also don't think that newcomers are all that eager to reach for unsafe code. Its hard to substantiate such a statement, but I can say that as a newcomer, I was much more reluctant to reach for unsafe code that I am now. If I were really eager to use unsafe code, I would just stick with C/C++. I could be an outlier, of course. 
Yes, that's what I use and there is usually no problem.
&gt; I actually think this would not be as bad of a change as it seems, because it's rare that this actually prevents bugs [...] I think it's worth asking why we want mutability restrictions I think you're underestimating how much immutability makes it easier to reason about code. Certainly you *can* scan for uses of a variable to see if it is mutated, but it's much simpler to know that it will not be -- even with the caveat presented in rule (2). My point being that immutability-by-default makes it easier to write easier-to-understand code. The compiler cares about preventing bugs through safety -- which I appreciate. I care about understanding code. These are not orthogonal, but they are also not necessarily congruent.
Fair enough. Thanks for the good conversation, though!
So you'd rather be consistently bad at something than 99% good and 1% bad?
Well, I have been following the development of Rust through Reddit and the wiki for a few months now, but have not written a single line myself. So I guess I count as a newcomer. My feeling is that this directly addresses one of the central issues of Rust. Mutability is an easier concept for newcomers to understand because it is familiar. They have seen it before in other languages, and functional languages in particular trumpet its importance. But the purpose of having mutability/immutability is to allow the *compiler* to reason about the code, not the programmer. Nothing is easier than to leave every variable mutable as I write C++, for example, but using const helps the compiler let me know when I change something that I should not. Furthermore, mutability/immutability is an extremely blunt instrument. If the actual purpose of including this in a language is to prevent a variable from being changed in unexpected ways, then the same effect can (and should) be achieved by restricting aliasing. The result is the same (concurrency is feasible for mortal programmers) but this gives the programmer more freedom otherwise. As for uniqueness being a harder concept, this is just because most newcomers have not been exposed to this idea before. Pointers are also hard for a newcomer to C, but most people are able to figure them out in the end. Since uniqueness is central to the borrow checker though, everyone will need to face this eventually. I would say just do what you need to do before 1.0, and change everything to &amp;only. But to address kibwen, this is a fantastic marketing opportunity. What restricting aliasing does is give you the central benefit of mutability/immutability, but in a much conceptually cleaner package. And one that I have not seen developed to the same extent in any other language.
Thanks for the reply! I have a follow up [question](http://www.reddit.com/r/rust/comments/2581s5/informal_survey_which_is_clearer_mutability_or/chf0gfj)
I think one problem is that &amp;T will always be a leaky abstraction in that case -- unsafe blocks will always be able to do weird things without the compiler's explicit consent. Changing to &amp;only at least makes this more acceptable, because &amp;T's story would no longer be "no mutation guarantee".
True, but if you were working in a closed mode, you also wouldn't get all those outside contributions. Problem is immutability was a very marketed trait of Rust, and it was brandished as a positive trait of system, but now it seems that such an important part of system will be removed. It will be natural that people attracted by it will complain about it missing. I don't really comprehend the problem behind it, other that borrow checker needs three types of references, but there are only two, etc. You'll just have to weigh your options. For me immutability by default (or whatever we had before was useful). Way more useful than closures. Whatever you do, make sure you show WHY you had to change the features. What are benefits and what are the costs. What new stuff can be written and what price will be payed for this. 
Using one header with more than one type is expected to be very rare indeed. Keeping the raw would be feasible; is it worth the increase in complexity? (I here assume that we change from `HashMap&lt;SendStr, enum Item { Raw(...), Typed(...) }` to `HashMap&lt;SendStr, (raw_valid: bool, raw: Option&lt;...&gt;, typed: Option&lt;...&gt;)&gt;`.) - It makes parsing as another type a little cheaper (about one allocation instead of about two), iff the raw form is not invalidated; - It allows cheap access to raw form (zero allocations instead of two or three), iff the raw form is not invalidated; - Typed access does not damage the raw representation unless a mutable reference is taken, which could theoretically help someone at some distant point in the future with bad field access where they have already accessed it as a typed value and it parsed successfully there (extreme corner case benefit); - It increases memory requirements (less than a kilobyte in most cases, especially as it looks like cookies won't use typed access, and they tend to be the biggest bunch of header fields); - It could improve performance as the memory can be not freed until the end of the request, reducing the time-to-first-byte-of-response for servers. - Taking a mutable reference to typed or raw form requires invalidation of the other form (I think I would drop the typed one but just mark the raw one as invalidated, then reusing its vectors if possible for converting from typed to raw, saving allocations in some cases). I think it probably balances out a little in favour of retaining the raw representation. Does my analysis seem sound?
Let me just reiterate that we haven't decided anything. It is not true that local variables will definitely become always mutable. We are just exploring our options. Please wait for the full RFC to become available, which explores the tradeoffs.
&gt; It's because the borrow check can't actually model closures using the system we have today. Is there any technical write-up about this? If not, perhaps sitting down and writing one might actually help take distance of the problem and gain perspective, plus it would invite interested outsiders to lend a fresh insight.
An existing pain point in the language with some keyboards layouts isn't a good reason to add another problem that's more widespread.
I see issues with this. How do we handle accessing a standard header as other than the standard type? As far as I can see, we would need to either dispense with future-proofing, or effectively take two hashes of the header, which, while it could speed up some operations on standard headers, would definitely slow down extension headers by a decent margin, and could have other negative performance impacts also. It's a much more complex technique which is more open to bugs, but it is probably worth playing with to see what the practical impact of it is. It might improve things; I do not know.
Wow! This is great!
I would also prefer &amp;uniq. The name &amp;only makes me think that "The pointer is only pointing at one place at a time"
&gt; Variables can already be shadowed, so local immutability doesn't have much of a win over mutability anyway. I would hope there's a lint for that, is there? Excessive use of name shadowing can lead to some very unreadable and hard-to-understand code. Apart from that, just because you *can* use a name twice doesn't mean you *must*. 
&gt; There are lots of people out there who have a "wait-and-see" attitude to Rust, and who just don't have time to judge each development decision in totality. This is true for me. I'm a full time C++ dev and see Rust as something that could replace C++ for many areas of development. But I don't have enough time to follow the development thoroughly and I must admit that I'm not too well informed. Just average internet informed. So Rust-tldr for me is: A language without value semantics - but that's not the world's end because there's const-by-default. And also something concurrency and "eh ... too much will change till 1.0 anyway so I don't read up as much as I probably should". If you now take const-by-default away from a language without value semantics visions of long debugging sessions come up - unless I explicitly declare stuff const. Which brings me back to C++. And maybe I'm too plebeian but C++11/14 is good enough in that case. The main selling feature of Rust to me is: It's more strict than C++ and you can't introduce potential bugs just by omitting a keyword. Please don't take this away.
Heh, I'd take immutability over closures. Closures are a nice thing but in the end they decrease code readability if used too much. While const correctness is mandatory for reasoning about code.
And it is actually worse than that! Given: let mut x = /*...*/; func(x); ... is `x` being mutated by `func` ? You don't know, you have to look-up what `func` is.
Well, actually I also wondered why locals can be shadowed. It's easy to implement certainly, but it certainly does not make programs easier to read...
Or said otherwise: in the end closures are very close to being syntactic sugar. Most interfaces in C expose something like: typedef void (*callback_type)(void*, ...); where `void*` is a context that the user is free to pass alongside its callback. Of course, it's a bit cumbersome to manipulate the callback and context separately, but it's sill doable.
It's very often very useful. Erlang is a bit of an outlier to disallow it. I can't say that I've ever been surprised a lot by rebinding.
But what if LLVM does not see all mutations? Specifically, what of opaque calls? An opaque call on a non-aliased pointer may do whatever it wishes to the pointed to content whereas an opaque call on a pointer to immutable data is guaranteed not to change this data. It's not an area where LLVM shines today (which is a bit of a pain for virtual pointers in C++) however it might be worth keeping this in mind. Of course, there is the issue today that `&amp;T` might not exactly point to immutable content, but it should be feasible for the Rust front-end to be able to pick which parts of `T` are mutable and which are not in this condition if properly enforced (like, any mutable part must be in an `Unsafe&lt;_&gt;` block).
I've started using rust ~3 weeks ago (and I'm loving it). I struggled a bit with "&amp;mut". I think being the exclusive owner of data for a while is easier to understand than mutability. I'd prefer your proposed change. Brainstorming for alternatives to "only" in no particular order: sole, exclusive (exc), only, own, private, grab, separate, my, fence. Someone else mentioned "orm", so maybe some initialism might work, too. Also: How would this work in destructuring? What would "ref mut" become?
I think the only way currently is to create a new select every loop iteration. This is how i did it a while ago: https://github.com/arjantop/rust-tftp/blob/master/src/tftp/common.rs#L151
Or actually, the situation can be reversed: even though I work in France the standard keyboard we get is a Qwerty keyboard with US layout exactly because it's easier to program with. A lot of French people switch back to Azerty (French layout) for writing French (and get those accents), and only a few ask for an Azerty keyboard (French layout).
&gt; What would "ref mut" become? `ref only`, there's a *lot* of similarities between `&amp;mut` and `&amp;only`.
I strongly prefer the current "composability" of `&amp;`. The two reference types `&amp;` and `&amp;mut` (aka `&amp;only` for the purposes of this comment) are *identical* at runtime (pointers to some chunk of memory, with no ownership or destructor), they just have a few different compile-time restrictions. Writing both names with `&amp;` makes this close relationship clear. Having two separate symbols for closely related concepts seems like it would be stepping away from clarity, and just into more tilde-related confusion.
As it stands, the manner in which multiple types can be used requires that `get` et al. take `&amp;mut self`---as such, unsafe code is not necessary. The mutable self borrow is unfortunate, but unavoidable unless it be deferred to runtime borrow checking in a way that would cause various seemingly-OK things to cause failure, which I do not consider an acceptable trade-off. The mutable borrowing issue is why `get` is there, cloning the value. It is my principle and goal in all these matters to do with Teepee to consider any suggestions in depth---I know that ego can be a problem in such cases as this and I want to minimise it. There is no space for ego here---I want Teepee to end up the best it can be, and I claim no monopoly on good ideas. My first part, the status line, was replaced completely after I got feedback, and this part is being improved because of your feedback. I will admit that my first inclination was to discard your suggestion, seeing first the problems in it, but before I could discount it I had to assess it all fairly, thinking it and its implications through in detail; in the process, I came to the conclusion that it is probably overall an improvement, so unless anything new comes to light about it, it will be used. I thank you for the suggestion---please keep them coming!
That wouldn't work for polymorphic effects. The only way would be having a keyword inline with the function.
&gt; And it is actually worse than that! I don't think so I think your example should be: let x = /*...*/; func(&amp;only x); ... Here func requires a `&amp;only` pointer. It is very probable that it will mutate it. (just like &amp;mut x) If func takes `&amp;x` or `x` then there is nothing to check. 
Thanks, this worked for me. A bit unfortunate that the entire select handle has to be recreated. Bookmarking your project, I want to read through your code and see how you did other things. Thanks!
Very cool. Really enjoyed the meetup presentation by BurntSushi about the QuickCheck functionality, happy to see it being added to Rust proper. We use randomized testing a lot at work, so it's great to see Rust get support for it.
You want /r/playrust (for the video game), not this subreddit (for Rust the programming language, which has nothing to do with the game Rust).
I'm experienced in Python and OCaml and interested in compilers, type systems and programming language design, but a newcomer to Rust. I came to this subreddit looking for an answer to the question "why is ownership/mutability recursive", and stumbled upon this thread, which not only explains it's design rationale, but also proposes an alternative view of the `&amp;mut` concept. In short, my answer is: uniqueness is clearer, and mutability should not be conflated with ownership. It's very likely that my view is colored by my extensive use of OCaml, which has: (1) immutable variables by default (and explicit references for when you require mutable variables), (2) datatypes are immutable by default, and (3) record types can have fields declared as mutable. As in OCaml, I think that mutability should be a property of the type, not of the reference: struct Point { x: f64, mutable y: f64 } An additional restriction would be, a value can only be mutated if you have unique ownership to it; if you only have a (borrowed) reference, you cannot mutate it (and consequently you also know that it won't be mutated by others, since noone can have a unique reference to it at that time). I see *variable* im/mutability as a completely separate issue: `let a = hashtable()` should mean that `a` will always point to the same object, not that the object pointed to by `a` cannot change; for example: struct Reference&lt;T&gt; {mutable value : T, flag : bool} let a = Reference(1, true); a.value = 2; a = Reference(2, false); // error var b = a; b = Reference(3, false); // ok b.flag = true; // error
&gt; "you can only have one mutable reference to a value at the same time" Isn't the rule "a reference can be mutable only if it's the only reference", i.e. you rule permits 2 references to an object, one of which is mutable and the other is immutable, whereas my permits only a single reference to the object. I'm a newcomer to Rust, so it's more than possible that my understanding is incorrect, but if it isn't then the rules are not as easy to understand as you imply. 
This is really cool and inspiring! I wonder what it would take to get Piston to support iOS and Android as well. Of course iOS Rust support isn't there yet but that is only a matter of time. I don't see much interest from glfw maintainers in supporting either. I'm pretty new to graphics so haven't used either framework enough to form a solid recommendation myself but what do you think about moving Piston onto sdl2? It would position it for greater cross platform reach with less work. Also image loading, sound, font rendering would be free. You could focus on extending its graphics capabilities directly targeting its gl context. Maybe trying to target mobile as well is too restrictive / not in the scope of your project in which case its less attractive but the asset loading and sound support still seems valuable to me.
Hmm, I actually like `&amp;orm` more than I thought I would. Yes, it's opaque to total newcomers but as neither `&amp;mut` or `&amp;only` are fully descriptive I don't think much is actually lost.
I'm relatively new to Rust, but I'm versed in a lot of other esoteric languages with syntax most people are unfamiliar or uncomfortable with. The biggest struggle I've had with Rust is sorta what feels like a sprawling byzantine approach to implementing its core principles and concepts, or my larger fear being that impression comes as an artifact of Rust not really having super crystal-clear core principles, which would make them seem like moving targets and thus addressed by many superficially related approaches. If I had to pick a re-name for `&amp;mut` to something else I'd prefer `&amp;uniq` because it's less jarring mentally than `&amp;only` due to it not being a whole word. `box` drives me nuts, because it's something I have 4 decades of reading with a particular meaning that's entirely not jargon related. At least `&amp;uniq` engages my "Oh this is a symbol not a word" language processing center. That said, all these weird corner cases seem like an indicator of some larger unresolved problem.
Moving to SDL2 is definitily worth considering. I would like Piston to run on mobile devices as well. Perhaps we could take look at what needs to be done and make a roadmap. This is part of the reason I'm trying engage other people. There is a lot potential here. The other part is: The sooner stuff is working, even just with minimal features, the greater benefit there is for other people in the Rust community to contribute. I try focusing my efforts on the features people want, because there is a ton of work to do when building such things from scratch. This requires a lot of planning and collecting information from other projects! I would be very grateful to get feedback on the current issues. Opinions and sharing experiences are welcome!
Then that by itself seems like a problem. The standard library isn't abiding the languages own conventions. That's going to make getting the point of "idiomatic Rust" becoming a real thing almost impossible.
I'd have to try it out to be sure but I'm not really sure how often I want immutability in my graphics context. Sure I have to keep track of what the current pen color is, but i have to do that here to, it's just that it's a piece of state in the first example and a chain of function calls in the second. Like you said you haven't gotten rid of the stack, you're just using the one in the language. I'm also worried about the performance impact of allocating so many contexts all the time inside the render loop.
`&amp;orm` will be very confusing if there ever is a kind of Relational to Structure Mapper. Newcommers from Java will probably confuse it with Object-Relational Mapper. 
&gt; That said, all these weird corner cases seem like an indicator of some larger unresolved problem. We're trying to do memory safety without garbage collection. That's hard, and nobody has done it before. I think there's going to be no silver bullet, a perfectly orthogonal approach without any corner cases.
&gt; It's even more confusing since the problem with the pattern isn't what &amp;mut is called. The problem with the pattern is putting &amp;mut behind &amp;. It seems like simply trying to come up with a better name for a broken convention. The idea is that since `&amp;` is not the only pointer to what it points to, the reason why you cannot mutate the `&amp;mut` behind it is clearer. In Rust, you can only mutate something if you have the only reference to it. Behind an `&amp;`, you do not have the only reference.
Niko's RFC will cover this.
Niko's RFC proposes `&amp;my` which is potentially worth considering, and has overtones of mutability and uniqueness. I don't want to bikeshed too much in this thread though.
OCaml is not Rust. Inherited mutability is really important for memory safety. We can't really get rid of it.
The goal of this post was just to gauge people's opinions about uniqueness vs. mutability. It only went off the rails into the "bombshell" on local variable mutability when I responded to one of Eridius' points. Perhaps I shouldn't have responded at all, but you can see how this is a problem with working in the open: the alternative would be to keep the plan secret, which I didn't really want to do (as it would invite more criticism about the core team being an elite core cabal, etc.)
Well, regardless any change to make locals mutable wouldn't have an effect on LLVM's ability to optimize; it would essentially be a surface syntax change.
it would definitely be interesting to see /&amp; contribute to a crossplatform rust graphics/UI/app framework designed with mobiles in mind. I've done a crossplatform gl|es sourcebase in C++ (including iOS/android), and just dabled a little with android/linux in Rust. I'd like to help out with rust/iOS but I didn't get very far with that last time. Finally gave in and got myself another Mac recently (so i might motivate myself to try it again..) I'm also interested in libraries which suit being used from either Rust/C++ to hedge my bets... I like the rust language but have second thoughts about ditching mature IDE tools and my own familiarity. (match &amp; cleaner syntax.. vs dot-completion/nativation, and overloading which i genuinely like). however I'm not sure how far you could go with that or how much it would cripple things.. you can still pass references to collectionclasses across if you roll emulations * ( thats a whole other project of interest... how much of Rusts nice iterators &amp; so on could be mimicked as closely as possible in C++ .. maybe add an OptBox&lt;T&gt;, OptRef&lt;T&gt; type to rust for ease of translating the nullpointer optimization.. ) 
They’re an escape hatch, and thus I don't think they’re an appropriate counterpoint. Just the other day I was working with C code that reused the same integer variable three times for indexing into two different but related arrays. It incremented and decremented the variable to maintain the relationship between the indices. Both I and the original author of that code agreed that it would have been *much* clearer to use three different variables with appropriate names. That situation is so far removed from `Cell` that I don't think that argument applies.
&gt; We do have Share, which is what Freeze was renamed to. `Share` and `Freeze` are only superficially related in my mind. `Share` basically means that access is thread-safe because it is somehow synchronized (as with Atomic). `Freeze` means that access is thread-safe because no mutation can happen during the lifetime of the accessing reference, which implies deep immutability of the accessed data. These are quite different. &gt; I'm nervous about adding more types of pointers, however, as pointer type explosion really makes the language harder to understand. Well, we got rid of `~`, so we can replace it with something else ;) But I do understand your concern. If we got the Freeze kind back and somehow made it the default on generic type parameters so one doesn't have to type `T:Freeze` all over the place, then just renaming `&amp;mut` to `&amp;only` or `&amp;exc` would already go a long way IMO.
The difference is you get immutability, stack behavior and zero cost performance all in one go! No worries about allocating! Because there are none! It emits the same assembly as if you hard coded the optimal case. Rust-Graphics also have a triangle streaming algoritm optimized to fit in the L1 cache. This makes it easier to add procedurally generated vector graphics. If you start using Rust-Graphics, you will get the benefit of future optimizations as well. The great benefit of this design is allowing a wider arrange of context, such as animation, motion blur etc. You start with a general context and build your way toward specific ones. It composes better with function arguments etc. Think of Rust-Graphics as syntax sugar replacing hundreds of lines of code with one liners. With static linking, the stuff you don't use does not end up in the final executable. Perhaps you should check out https://github.com/bvssvni/rust-snake to get a picture of how this will work in a game. It was my entry in the Ludum Dare competition. Piston got support for PNG images since then. You can write 2D games with it, today!
I have always been a fan of 'const correctness' as a way of annotating inputs/outputs and hence understandability... So I would definitely prefer it to stay as 'mut', even if it's not completely accurate. I dont think what rust does now is as inacurate as 'const' is in C++, or as scary as c++ restrict? Personally I had found the whole idea of immutable default and immutability propogating better, and not needing 'restrict' for optimization a *huge* draw to the language . I'm slightly dissapointed to read this explanation that it's a bit of a lie :) but I would consider it a 'white lie'.. if &amp;mut was only lying with unsafe that wouldn't seem bad to me. could you just rename the offending types MutCell, etc ? is the breaking of immutability down to unsafe code ? Could you have both keywords, mut and only; and work toward making both as accurate as possible. (and keep the goal of immutable default, thats a great part of the language).. 2 (or more) keywords expressing the same range as C++, but improved in how accurate they are, and more useful defaults. 
I guess I should have qualified that statement. I understand the interest of a local symbol shadowing a global one: you don't want the code to stop compiling when pulling in another module. However, shadowing in local functions ? If you ever need it your function is probably too big to start with.
And I thank you for being so open-minded. I am looking forward to your posts on Teepee and its overall progress :)
Uh... did you read the parent comment ? Of course I'd prefer automatic closures to manually generated ones. But if the choice is between: - immutability and manually generated closures and - no immutability, but automatic closures Then I'd rather have immutability (which can hardly be emulated) than closures (which can easily be emulated). That's all there is to it.
I agree it's a hard problem. I've had to deal with Erlang's memory management system from the unsafe C side of the NIF and Port Driver interfaces where Erlang's immutability guarantees fall apart and I have to know what Erlang lifecycle semantics will be for whatever kind of type I'm dealing with (atom, binary, list, etc.). How does garbage collection relate directly to memory safety? Or perhaps a better question is, what do you mean by memory safety there? No null pointer references? Compile-time alloc/dealloc management via static analysis? At any rate, I'm super excited about Rust. I want it to become *the* systems language of distributed systems/computing if possible. Clear axioms tend to create clear solutions. What is Rust's axiomatic premise on mutability? That you can only ever mutate something if you're the sole owner of it (ie. a local stack variable, a unique reference, a borrowed unique reference)? If that's the case then that's precisely how mutability should be managed and by no other scheme or mechanism, and the language, docs, blogs, and tutorials really need to double down on making sure that ownership is brain dead simple to understand, simple to use, and simple to reason about in other people's code. Though regardless what happens please consider making symbols feel like symbols. `&amp;uniq` is both more accurate in what it conveys, "I want a unique reference to this thing." which will make error messages make more sense, "blah blah blah, tried to create more than one unique reference to thing." and it doesn't engage the language processing center of the brain that is trained to read the word `only` as a non-Rust thing, and keeps the CPU in our heads from context switching.
Sounds like you've got a better conceptual grasp on it than I do. It sounds really neat so I hope it works well. You should do a writeup on how you're using the type system to do all this, that's the part that I'm having a hard time wrapping my head around.
I can definitely see why you might think Rust's core principals aren't crystal clear. I think it's in large part due to Rust's open development. Things change a lot and it can rightly seem like the Rust of yesteryear is an entirely different thing from contemporary Rust. That being said, as pcwalton mentioned elsewhere in this thread, Rust has always had three core principals: 1) safety 2) performance 3) concurrency. Nothing else is sacred, which really is a good thing, because it allows the devs to explore as much design space as possible before making strong backwards compatibility guarantees. Rust is very much a research project and is trying to solve problems that have really never been solved at a language level.
I am sure there is a lot to learn about using Rust for game development in practice. I've done a small experiment with faking a C library written in Rust for Idris. Since you can link to C libraries for iOS, perhaps this is the way to sneak in Rust for iOS? There are probably many people in the Rust community interested in a better toolchain for this. Concerning IDE, I am using Vim and Rust-Empty (https://github.com/bvssvni/rust-empty). I miss autocomplete, but not overloading. On the other side Rust is an amazing language, coming from C#. I spend at least half the time planning and analyzing, because the language doesn't really get in the way most of the time and I get stuff done once I start writing. The best part is not having to worry much about the code I just wrote. When I hit a wall with the borrow checker I usually rethink my design and come up with better ideas. I believe the strict rules can also give feedback on bad/inefficient design. I love the stuff you can do in low level while having generics and traits, it feels more "mathematically natural", but also more heavy mentally, because I can see what is going by just looking at the code and the brain gets distracted by all the information. A benefit from not having overloading is the one-to-one relationship between function names and code location. I absolutely prefer this. I've spent more time looking for bugs in C++ than writing stuff in it, so I am not the right person to ask what experienced C++ developers should do. I concentrate on making it feel natural for Rust than fighting it. Somebody said "Rust is a language making mistakes nobody has done before" (because it seeks to avoid repeating mistakes from other languages). Being the first person to rethink library design in a particular area is more work, but also rewarding.
Is there any documentation online where I could read about that, i.e. the rationale and explanation about why memory safety wouldn't work if mutability wasn't inherited?
Here's a good explanation from Niko: http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/
It can avoid errors where a function argument is not canonicalized in some sense and you need to deal with a canonical version of it (e.g. trimmed version of argument string). If you use a different name for these two, then you may accidentally use the original raw one in some expression, which 1) looks and reads as correct at a glance 2) is fine type-wise 3) will pass a lot of tests, but 4) is wrong. By shadowing the name you can make sure that you never accidentally use the original after canonicalizing. I could go either way but it does have its uses. 
I have yet to start using rust, but I have been following it with quite a bit of interest, so here are my thoughts: I prefer the concept of an exclusive reference to the concept of a mutable reference. I feel they are both about equally understandable, but it seems that "exclusive reference" better reflects its purpose in the language, which will make things easier to reason about in the long run. Similarly, I prefer "you can only mutate a value if you have an exclusive reference to it" Terminology wise, I do not like &amp;only or "the only reference", as they don't really convey the intended meaning to me (though I'm sure I could get used to it, eventually). I would much prefer "exclusive reference" and &amp;exc.
&gt;There is a tradeoff between flexibility and expressiveness, though. wikibot, what is the expression problem? 
Note that this is somewhat out of date; `~Foo` types are gone, reducing the punctuation-heaviness of Rust. Also, note https://github.com/rust-lang/rfcs/pull/63 which many of us are positive on, which should ease the learning curve of the module system.
I'm pretty much a newcomer to Rust and coming from Scala I really liked the immutable-by-default approach. &amp;mut certainly feels more familiar on first glance, but after reading this whole thread I actually don't think that is particularly important. 1. The concept of "a mutable reference" is slightly easier to intuit, as in, you can start using it without actually learning what the exact implications in Rust are. This might not actually be a good thing. 2. I find the rule "you can only mutate a value if you have the only reference to it" slightly easier to understand. Aesthetically, I'd prefer &amp;uniq over &amp;only. 
At this point, I think this falls primarily under what I previously described - it's something that's out of your control. The majority of what dynamic web servers like this do is provide what is essentially a mapping between REST &lt;-&gt; database. If your logic is truly factored out and residing somewhere else, then all you really have left is a bunch of glue between the web interface, the logic, and the database. Which is unfortunate, but partially because of this odd separation databases have. They don't really function on their own. I will say though - passing around a database connection is kind of an inversion of what should really be done. You want to factor side effects upwards: instead of taking a database parameter, return a transaction to be applied. You could argue that it'd be easy to forget to apply the transactions, but this hasn't been much of an issue in my experience. Especially not with a language with a way to set ignoring return values as a warning (Rust, most functional programming languages). Doing it this way allows you to test your components easier - instead of having to setup a database specifically for testing, with carefully constructed test data, you simply test to make sure the transactions are sane. This also makes debugging easier - the function becomes purer, allowing you to call it multiple times and have the same result. And you can also inspect the side effects easier, just by inspecting the value of the transaction in your debugger. The only thing that requires "live database" testing is the code which manages the transaction objects themselves - which is all in one place. I can't say that explicitly modelling transactions is convienient syntactically, but it definitely helps with debugging, testing, and maintenance. It's easier to define this abstract transaction object than you might think though - especially in Rust, which has ADTs and pattern matching.
&amp;orm? But I don't need a DB for my project
Memory safe doesn't mean memory safe either, because unsafe blocks. Probably memory safe doesn't tell me anything.
You can forbid unsafe blocks via `-F unsafe`, and then it actually does mean memory safe.
Today, if I write code like: fn originally_took_immutable_arg(foo: &amp;bool) { println!("api_fn {}", *foo); } fn main() { let a = box true; originally_took_immutable_arg(a); println!("critical thing that depends on a being true. a is {}", a); } and `originally_took_immutable_arg` changes upstream to: fn originally_took_immutable_arg(foo: &amp;mut bool) { println!("api_fn {}", *foo); *foo = false; } the compiler will complain that a fn I thought would never modify `a` suddenly could, and I'm forced to go look at the change and fix my code. In the scheme you're thinking about, where `a` is mutable by default, does the compiler still help me here? Or is it that much easier to get hurt by changes to an upstream api? 
I could also always look at the resulting assembly, that would tell me exactly what's going on. A language is supposed to help me communicate, to the computer, other programmers, and myself. "This won't change" is a statement I would like to make to other programmers and to myself; if the computer isn't getting much value out of it, I really don't care. 
I don't understand why `&amp; &amp;mut` is a problem. If someone just told me "the `&amp;` overrides the `&amp;mut`", that would seem like a natural and consistent behavior for a language that defaults to immutability. Has anyone actually had any problems with this? The mutability of `Cell` and co was a little confusing at first, but I've just accepted it as "magic", because, well, isn't that what it is? You already have to come to grips with 'you can do anything with `unsafe`', and having a few spots in the std lib that actually use `unsafe` internally and therefore act magically seems inevitable, and like something people can deal with. 
I haven't looked. Is this too heavily game oriented, or is it general purpose enough to build a UI out of? I've wanted to experiment with building a GUI framework in rust, and this might be the perfect toolkit.
What do you mean by a transaction object? You're saying you construct some sort of object which contains in it a list of queries to execute, return that back to main() or thereabouts, and it runs everything for you? What if you need some results immediately to decide what to do next?
I don't believe there's any support for doing this without any unsafe code right now, unfortunately. /u/nikomatsakis wrote a blog post last year with some thoughts about how a future data parallelism API would work, but I do not believe that anyone has started tackling it yet: http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/
Thats how I used to think about them as well - magic that I didn't understand. I think the current naming leads to that conclusion. However, if you think about them in terms of aliasability instead of mutability, I think they fall into place as regular, non-magic types. Mutability is only possible if you have a non-aliased reference. `Cell` and co provide the logic to guarantee that the actually memory that is being mutated is not aliased. Unlike `&amp;mut` which provides a compile time guarantee, `Cell` and co provide that same guarnatee at runtime. At the end of the day, the same restriction is being honored, however.
&gt; The compiler sees the borrowed pointers and puts only the new value on the stack. Would you be more specific about this? Are you saying that the compiler doesn't bother to store the whole of the new `ColorContext`, but instead only the `color` (not even its discriminant), and fetches the values of the `base` and `transform` from the source `ColorContext` as needed unless, the pointer to the entire new `ColorContext` is needed for something, but since you declare everything `inline` this is infrequent?
This is actually exactly the keyword that I came up with myself, though I was worried that it would imply ownership. I guess it's *sort* of like ownership, if the original owner can't use the value while you have a `&amp;my` reference to it...
I didn't know that we had a flag for this, but I'm happy to see it. How much of the standard library becomes unusable with this flag enabled?
As far as I can tell, there is no form of IO in rust that doesn't use the runtime. So is libcore only for creating libraries? 
The `Share` trait could be used to pass `&amp;T`/`&amp;[T]` and `&amp;mut T`/`&amp;mut [T]` to worker threads via a safe data parallelism API.
Could you please be more specific? What needs to be implemented for this?
See https://github.com/PistonDevelopers/rust-graphics/issues/1 There is a link to an interactive compiler where you see the generated assembly. The way you use it is comparing the assembly of the hard coded optimal case with the logically equivalent composition of contexts. If the assembly is the same, it means the compiler does optimal reduction. Modern Rust uses LLVM as back-end, so you get the benefit of the research put into it in addition to the language level optimizations. Feel free to experiment! Rust-Graphics could benefit from contributions from people who knows more about compilers than I do. If you find something interesting, open an issue!
GUI frameworks is something I had in mind when working on the design. It supports rectangles, ellipses, convex polygons and round rectangles. The method '.view()' gives you absolute coordinates. There is no text support, but this could easily be added as back-end feature. If you are interested in experimenting then you should take a look at Piston to get a prototyping environment. I am open to suggestions for what features we should have in Rust-Graphics to make GUI frameworks easier. There are several people in the Rust community interested in cross platform/back-end GUI. Perhaps we could find a way to organize the efforts so people do not duplicate the work done by others, but work together in groups on the part they are interested in.
The last point is quite ridiculous. Of course the market place ensures that we do a whole lot of programming in 'C' like languages, but I have enough knowledge of other non-C like languages to vouchsafe an opinion here - languages such as Haskell and OCaml too have quite a bit of syntax, but the syntax seems to fit together smoothly. A cursory look at Rust's syntax makes it appear to be highly random, and that's the part that's disconcerting. Perhaps when the 1.0 release finally rolls out, and there's some stability to the standard, I'll take a deeper look to see if I was mistaken.
Very easy to do as a macro: macro_rules! with { ($p: pat = $init: expr in $e: expr) =&gt; { { let $p = $init; $e } } } with!(x = 2 in x + 3) // == 5 with!((y, z) = some_tuple in y * z)
This is not a limitation in expressiveness, because it can be easily emulated.
I think Java, .net, qt use internally utf-16(or maybe usc-2), those are all somewhat common on linux(especially qt)
IHMO the most "idiomatic" way to do this in Rust is to use a block expression: foo({ let &lt;name&gt; = &lt;expr&gt;; &lt;expr&gt; }) Add line breaks and indentation to your taste. (After typing this out I realize that /u/lucian1900 already said the same, but I’ll still post it for the example.)
With a build from this morning (commit 0550b79f7399): $ rustc -F unsafe hello.rs error: unknown forbid flag: unsafe Looking at the code the closest you've got is 'unsafe_block', which doesn't seem to catch, for instance, Cell usage, whose `get` method is implemented internally with unsafe: //compiles with -F unsafe_block fn main() { let x = Cell::new(false); println!("{}", x.get()); } 
Hi, I'm the organizer of Code &amp; Supply, I'd love help in this realm. I don't know enough about the community or Rust yet to know who can present or on what they could present.
Thank you, much appreciated. Would be great if you could externalize it in a separate project/library. 
What is the use case for this? How often do you need to limit the scope of local variables?
that'd be awesome! do you mean coming to pgh or remote presentations? either would be cool :)
This is what I normally do.
I don't consider internal usage of `unsafe` to be unsafe. The rationale is that we could have just as well built `Cell` into the language, which is just as unsafe, as LLVM (like all compilers) is not formally verified. The fact that `Cell` is implemented using unsafe code is an implementation detail.
&gt; Anyway that said, what is the problem with &amp; &amp;mut Foo being immutable (if not one of specialized structs)? I'd expect that left most reference sign is the mutability of the whole expression. You could get use-after-free, dangling pointers, arbitrary casts, and so forth in safe code if we allowed `&amp; &amp;mut Foo` to be mutable.
None, except for unsafe functions like `transmute`. It doesn't prevent code that's implemented internally using `unsafe`, nor should it IMO (for reasons explained in my other sibling comment).
1) Isn't that what static analysis schemes like ARC are for? And doesn't Rust get something similar out of the LLVM toolchain? 2) No two things would have a reference to the counter at the same time because unique ownership would be required?
Thanks for writing this! Can't keep up with all the changes otherwise...
Do you mean `foo({ let &lt;name&gt; = &lt;expr&gt;; &lt;name&gt; })`?
This `Field` thing is clever! I could see it used to implement stack-located persistent data-structures cheaply.
I've been thinking about the issue of (im)mutability, even outside `&amp;mut`, and I realized that, much as in C++, there were two concepts of mutability: - bit-wise (im)mutability is useful for the compiler: an immutable piece of data can be placed in the `.rodata` segment (if a constant) and can be shared freely between threads without synchronization issues - logical (im)mutability is useful for the programmer: consider how `mutable` is used in C++ =&gt; lazily computed values, cached values, etc... If we move to Rust, we see that `mut` was really about bit-wise (im)mutability, which is what allowed the compiler to make certain assumptions, while `Cell` and `RefCell` were tentatives to work around the system. I have not yet seen a `Lazy` or `Cached` type, but I realized that my discussion with Chris Morgan just yesterday about the HTTP Headers representation in Teepee touched on this concept: Chris would like lazy decoding (whose result is cached), and this forced him to use `get(&amp;mut self)` because although the object is (logically) not modified, it is modified bit-wise. Now, I suppose that this distinction is usually not much of an issue... but it becomes one *a posteriori*. Introducing a lazily computed value into an otherwise bit-wise immutable method suddenly requires changing the parameter type... or use `Cell`. Is `Cell` thread-safe ? Could it implement, or be made to implement, `Share` (or whatever it is these days) ? And yet, logical immutability does ease reading a program. So maybe `mut` should become a logical (im)mutability marker, and we would see support for: - `let x = ...;`: a logically immutable variable, no mutation - `let mut y = ...;`: a logically mutable variable, mutation is safe - `let omy = &amp;only y;`: the only pointer to a variable, mutation is safe - `let rx = &amp;x;`: a pointer to a variable, no mutation - `let ry = &amp;mut y;`: a pointer to a variable, mutation is *unsafe* - `let roy: &amp;Y = omy;`: a pointer to a variable, no mutation - `let romy: &amp;mut Y = omy;`: a pointer to a variable, mutation is *unsafe* In which `&amp;only` can only be applied on an already `mut` variable, and **must** be the only borrow in scope. It also implies mutability. Then in the case of `Cell`, `RefCell` and `Mutex`, the methods that actually mutate those variables should be declared as taking `&amp;mut self` and be implemented in unsafe code (to reinforce that safety is out the window, and the programmer is responsible for ensuring it). And where `mut` can be used internally in a `struct` to mark an attribute as being intrinsically mutable (and where once again the programmer takes responsibility for ensuring logical constness when called through a non-mut function). --- On another (related) topic: there is the issue of **global constants**. Today, I can set a constant at module level: `let PI = 3.1415....f64;`. Tomorrow, if the language does not understand immutability, we still need to prevent someone from reassigning the value of `PI`. Maybe it could be treated in an ad-hoc way, saying that `&amp;'static T` cannot be cast into a `&amp;only T` because it's already a non-only reference ?
Yes, that's what I mean by a transaction object. Doing transactions from which you need the result back are a bit harder. A few solutions: * Cheat and pass the database connection to some functions. * Implement/use FRP (easy to do with dynamic types, not so much with static) or monads (requires HKT or a good macro system). * Allow certain transactions to have a callback. Causes rightward drift and callback hell. * Split the function up - have one that sends the "request", and then have the caller see the response and call the code to handle the "reply". This can result in a lot of functions, and does make main() very hairy unless you have an automatic solution such as the previous. * Generators or coroutines. This is probably the most pragmatic solution. Yield your transaction object each time, and get the result back. One neat thing about these solutions is how concurrent they are - though I'm not sure how much capacity those big SQL databases have for concurrent transactions/queries. I don't know how much mileage you can get out of this approach in a heavily request-reply system, but it has been serving me well so far elsewhere. I'm certain there's other solutions besides having a database connection stuffed in a global variable, though.
Beware, this is not a forum. And thus *you* are the only one notified of answers. I would suggest either asking on the IRC channel, on Reddit (but with another discussion) or on Stack Overflow. (and no I don't know the answer, unfortunately I am too new myself to understand the issue :x)
&gt; I was pleasantly surprised that the removal of ~ didn't trip me up nearly as much as I thought it would. QFT ;)
That seems like a demonstration of using variables, not scoped `let` expressions. The usefulness of *scoped* let is not apparent here. If your function is that small then the scope is effectively the same anyway.
I'm not saying that it'll be useful in Rust, in particular, I'm just saying this is how it gets used.
What about `‹expr› where foo = ‹expr›` expressions?
Please make a post if you use it for something interesting! Would like to see what other people can do with this!
Thanks for the links! I've read through some papers (https://github.com/bvssvni/rust-graphics/issues/254) to get an idea of the problem.
Sorry, looks like this comment was stuck in the spam filter for a day or so.
 macro_rules! with { ($p: pat = $init: expr in $e: expr) =&gt; { { let $p = $init; $e } }; ($e: expr where $p: pat = $init: expr) =&gt; { { let $p = $init; $e } } } println!("{}", with!(x = 5 in x * x)); println!("{}", with!(x * x where x = 5)); *EDIT:* with the ability to bind multiple variables: macro_rules! with { ($($p: pat = $init: expr),+ in $e: expr) =&gt; { { $( let $p = $init);+ ; $e } }; ($e: expr where $($p: pat = $init: expr),+) =&gt; { { $( let $p = $init );+ ; $e } } } println!("{}", with!(x = 2, y = 3 in x * y)); println!("{}", with!(x * y where x = 2, y = 3));
There have been some issues, iirc it has to do with LLVM versions.
Is there any way to check on progress?
There are no statements in Rust, only expressions. Then there is this special operator ';' that discards the result of the expression on its left and returns the result of its RHS. This is the reason why later let bindings shadow earlier ones (just like 'inner' let bindings shadow 'outer' ones in Haskell) So "let &lt;name&gt; = &lt;expr&gt; in &lt;expr&gt;" is just "{ let &lt;name&gt; = &lt;expr&gt; ; &lt;expr&gt; }" in rust.
I just remember hearing people talk about it on IRC. I'd email the author of the package to ask them about it.
Yeah, there should probably be a way to forbid linking to any crates outside of a trusted set.
FYI, I believe this is exact problem solved by https://github.com/rust-lang/rfcs/pull/63
&gt; Isn't that what static analysis schemes like ARC are for? And doesn't Rust get something similar out of the LLVM toolchain? ARC comes at the cost of performance (having to reference counting everywhere) and control (references/lifetimes like Rust has allow one to be *very* precise about what's happening with poiners). &gt; No two things would have a reference to the counter at the same time because unique ownership would be required? Yes, i.e. there would literally be no way to share data, even with in a single thread, so basically everything would need to be a tree.
&gt; Doesn't that simplify things significantly and fit squarely in the "mutability is inherited" system provided by Rust? Mutability is not entirely inherited, e.g. the `Foo` in `&amp;mut &amp;Foo` cannot be modified. It is inherited for types with unique ownership (e.g. the "exterior" of any type, as well as the interiors of types like `Box`, `Vec`, `HashMap`), but there are some type that have to form a new "mutability root" (always as an always-immutable slot), or else they be allowing mutation of shared data (e.g. `&amp;` and `Rc`). It's actually significantly easier to thing about this in terms of shared/uniqueness. You can only mutate if you're guaranteed to have the only reference to some object, being owned by a local guarantees this, as does having a `&amp;mut`/`&amp;only` reference to the data. However, you can have many `&amp;`'s pointing to the same piece of data, i.e. there is no guarantee that any one `&amp; &amp;mut T` is the unique pointer to that data, hence mutation needs to be disallowed. &gt; Or perhaps it makes sense to just disallow &amp; &amp;mut Foo as a compiler error/warning and suggest &amp;mut &amp;mut Foo to the programmer instead. There's no particular reason to disallow `&amp; &amp;mut Foo`: it's functionally the same as `&amp; &amp;Foo`, and disallowing it would just make writing certain code more annoying/impossible (especially generic code).
&gt; Tomorrow, if the language does not understand immutability, we still need to prevent someone from reassigning the value of PI It would be illegal to take a `&amp;only` of a `static`, since there's no way for the compiler to verify that it's the unique reference. &gt; Maybe it could be treated in an ad-hoc way, saying that &amp;'static T cannot be cast into a &amp;only T because it's already a non-only reference ? It's incorrect to cast any `&amp;T` to a `&amp;only T`.
This is wrong; both `let ...` and declaring an item inside a function (e.g. nested functions or a local struct) are statements not expressions. Neither of the following parse, because `(...)` requires the interior to be an expression: (let x = 1) (fn foo() {})
&gt; Allow certain transactions to have a callback. Causes rightward drift and callback hell. There's a library that's popular in Node (called [Q](https://github.com/kriskowal/q)) that helps mitigate this problem. I'm sure it could easily be applied to other languages, like Rust. But aside from the performance implications, I wouldn't give up ease of development for some hokey notion of separation. If you need it for testing, I'd find a way to sub out the connection for a mock object.
Would the following solve the problem? If it does, then I feel that it would be easy to understand. let x = .. ; // Deeply immutable variable (no mutex) let shl y = .. ; // Shallowly immutable variable (may contain mutex) let mut z = .. ; // Fully mutable variable let rx = &amp;x; // Deeply immutable pointer to deeply immutable variable let ry = &amp;shl y; // Clonable pointer to shallowly immutable variable (such as mutex) let rz = &amp;mut z; // Unique pointer to fully mutable variable Disclaimer: Newbie bikeshedding :-)
Cool. Now we just need Atom to come out for Windows :\
[Build it!](https://github.com/atom/atom/blob/master/docs/build-instructions/windows.md)
Just fails out of the gate :\ C:\Users\soawsum\Documents\GitHub\atom [master]&gt; script\build gypnpm ERR! runas@0.5.4 install: `node-gyp rebuild` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the runas@0.5.4 install script. npm ERR! This is most likely a problem with the runas package, npm ERR! not with npm itself. npm ERR! Tell the author that this fails on your system: npm ERR! node-gyp rebuild npm ERR! You can get their info via: npm ERR! npm owner ls runas npm ERR! There is likely additional logging output above. npm ERR! System Windows_NT 6.2.9200 npm ERR! command "C:\\Program Files\\nodejs\\\\node.exe" "C:\\Program Files\\nod ejs\\node_modules\\npm\\bin\\npm-cli.js" "--userconfig=C:\\Users\\soawsum\\Document s\\GitHub\\atom\\.npmrc" "install" "--quiet" npm ERR! cwd C:\Users\soawsum\Documents\GitHub\atom\build npm ERR! node -v v0.10.24 npm ERR! npm -v 1.3.21 npm ERR! code ELIFECYCLE
Ok I'll try this when I get home. Is it better practice then to put all my modules in main.rs which are used more than once. Or just where I need them first? Edit: Nevermind I read that wrong. Thanks!
I don't find it an issue thanks to type inference. Generally if I'm rebinding a name it's because I'm doing something like reaching into some complicated data structure, so the variable name starts as a data structure, then becomes the sub part of the data structure, then I apply some operation to it to get the actual data I want to use. At each step the type of the binding changes so the compiler usually tells me if I do something stupid. It provides a nice way to break complex accesses or operations across multiple lines without polluting the local namespace with a bunch of intermediate name bindings that will not get looked at again.
You should declare modules and crates that are used by more than one module in main.rs (or more accurately, the crate root). This is because the compiler views the same module declarations in two different modules as two different modules being declared, leading to unintuitive incompatibilities.
&gt;But the purpose of having mutability/immutability is to allow the compiler to reason about the code, not the programmer. I see having bindings as immutable by default as helping the programmer much more than the compiler. The compiler doesn't really care if a variable is mutable or immutable*. The advantage of having immutable variables is that the compiler can tell me, the programmer, when I've violated an assumption in _my_ reasoning. It doesn't help the compiler to reason about things, it just gives it more information to tell me when I've messed up. * Well it does during some optimisation passes, but the rest of this thread is leading me to believe that benefit is just a side effect of immutability and that uniqueness is the real win here.
Ah I see. I assume thats why the compilation does not fail for the impl block itself but I am unable to call the method. Thanks I read the part about modules and crates multiple times now but it didn't quite become clear to me where to put the module declarations.
wget http://static.rust-lang.org/dist/rust-nightly-x86_64-unknown-linux-gnu.tar.gz ?
&gt; Is it better practice then to put all my modules in main.rs which are used more than once `mod` items declare the module hierarchy, i.e. which modules are submodules of which other ones. Once this hierarchy has been declared, you can then use `use` to bring names from other modules into scope. That is, if all of your modules should just be considered top-level modules, then yes, declare them in `main.rs`; declare those that should be submodules inside their parent module.
:(
run with elevated privileges (admin). I got a similar error on linux but it gave expanded info and said to run with higher privileges.
Just installed a ppa on linux, couldn't manage to build it myself, no errors, it just didn't generate the binaries.
Ah, that's actually an interesting usecase. Takes a bit of getting used to, but interesting. Of course, one could agree that it might be as simple to just use a local closure to perform the operation (inside the closure stack) and just return the value, just as some things are done in C++11: static std::set&lt;int&gt; const Set = []() { std::set&lt;int&gt; result; // fill it return result; }(); // Note the () to invoke the lambda
It would not solve the aliasing issue, which is at the heart of the introduction of `&amp;only`. It also does not solve the issue that sometimes a value is "logically" constant but for performance reasons might use mutability inside, for example a Splay-Tree.
&gt; wget http://static.rust-lang.org/dist/rust-nightly-x86_64-unknown-linux-gnu.tar.gz Thanks for this simple comment. It gave me the idea to let travis download the nightly from this link, and it actually works.
For those who never used Atom before: You can install Racer and Autocomplete Plus from the preferences.
&gt; not allow users of this crate to implement this trait themselves. Why?
There is no way to prevent other from implementing a trait they can see, but you could make the trait private, and expose the type/a newtype with inherent methods.
Fair question. I'm writing a RethinkDB driver for Rust. For consistency with other client drivers, I'd like to expose a method `run` (that sends a query to the DB server) on several pub structs which share a common trait: their JSON representation is a syntactically correct ReQL query. Thanks to privacy I can guarantee that any queries generated + sent via my library's API are correct, but I can't make the same guarantee for queries generated by third party code that implements the Runnable trait (but sent via my library) and this bothers me somewhat. The real library code is more like [this (gisted for length)](https://gist.github.com/tomjakubowski/d981df8ea1c2feb8e61c). And it's used like (with some details elided): let conn = Connection::new(); let my_table = r::table("whatever"); my_table.run(&amp;mut conn); // lists the documents in the table my_table.insert(my_json_doc).run(&amp;mut conn); // inserts a document I suppose I could make the Runnable trait private (and rename its `run` method) and add `run` separately as a pub method to each struct that needs it.
Create a private super-trait. To implement your public trait, a type will have to implement the super-trait, which they won't be able to as it's private. Like so: trait PrivTrait {} pub trait Trait : PrivTrait { fn foo(&amp;self) {} }
As I'm a complete newcomer to Rust it took me some time to grasp your suggestion, but now that I think that I understand it I think it's great. The concern of the original post was that &amp; isn't really immutable, but actually non-exclusive, and so the name &amp;mut is misleading. It seems to come from a suggestion to remove the mutability concept entirely and keep only exclusivity. This got a lot objection, because for the programmer, immutability means a lot less to worry about. So -mw- suggested to add (or restore) *real* immutability guarantee to the language: &amp; will be really immutable, and "let x" will be really immutable. This is expected and desired. &amp;mut and "let mut" are also very clear, and it makes a lot of sense that "you can only have one mutable reference to a value at the same time", so that the value won't be mutated by someone else when you're not looking. A third kind of reference is needed for less common cases, when you do need to share a reference to mutable data. In that case you'll use a &amp;only reference, which is a new name for the current &amp; reference, that allows you to reference Cell and such. It seems to me that it solves the issue of mutability very elegantly, is very easy to reason about and gives actual power to programmers for reasoning about the logic of the program. The thing is that immutability is important. Rust currently doesn't really have a concept of immutability, just of exclusivity which usually means immutability. Then, it is suggested to remove the broken immutability. This gets a lot of objection, for a good reason. -mw- suggests instead to incorporate real immutability, and then exclusivity can be just that - exclusivity, a more advanced concept. Is it really such a complex suggestion, really? Ref and such are annotated as being of kind SharedMutable. The compiler automatically annotates every type which contains or references a SharedMutable as being SharedMutable. &amp;shared and "let shared" will be the new names for the current &amp; and "let x". The new &amp; and "let x" will be just like the current ones, with another check - that the type isn't SharedMutable. edit: &amp;only -&gt; &amp;shared. Oops.
&gt; You could have a warning for &amp; &amp;mut Foo when it's actually typed like that like This doesn't actually make the variable mutable and not do anything when it's inferred to be that type For what purpose? One gets an error at the point-of-use if one actually tries to mutate through it. I think just improving that error message is the way to go.
I can't help you with the history, sorry. My impression is that anonymous structs were removed because they weren't pulling their weight or were disliked, not due to implementation issues. Might be wrong though. I don't think you would need to want a name, like tuples, anon structs (I'm just going to call them records from now on) should be structurally typed. That pretty much means you can't use generics with them, I think (or at least no formal type parameters). You would need to generalise impl searching a bit, but that is not impossible. I'm a fan of records for exactly the reasons you give (named args, return vals). But struct enum variants are kind of unpopular (I believe), so I think records would be too. I don't think you would want to omit the name for structs. Rust is a strong believer in nominal typing rather than duck typing. Although the cases you mention are probably the safest place to relax that. Doesn't seem much of a gain though. Its also not off the table that we will introduce overloading in the future (though there is no movement in that direction at the moment).
I meant when it's NOT being mutated. Of course this is "normal" for the type, but you normally would get a warning when you type mut and don't mutate it.
It might cause problems where two traits have functions with the same names.
I figured so, but how does rust handle that right now with the current syntax? I have not tested it, but I can only imagine that it errors out, and I would imagine the same thing would happen in this scenario.
You can certainly submit an RFC without an intent to implement it. You should probably make that clear in a comment though. It would probably be a post-1.0 thing. I would be vaguely in favour of such a thing. It (or something like it) might be particularly useful for supertraits - I find it a bit of a pain point having separate impls for both the sub and super traits. Bikeshed: I would prefer `+` to `,` in the trait list since that is what we use for lists of traits in bounds.
I think you have to specify which trait you're referring to like: `(&amp;some_object as &amp;SomeTrait).some_function();`
I find losing immutability-as-default a rather scary prospect, but the arguments in favor of simplicity are very compelling. Niko understands Rust's type system more than any of us here, so his opinion is worth a great deal.
What about static variables? All statics are aliasable, but only some can or should be mutable. I don't think that mutability or `mut` can be fully removed from the language.
+1 I've felt that the current situation doesn't model reality as well as I'd like. In [rust-postgres](https://github.com/sfackler/rust-postgres), almost all methods both mutate underlying state but have to take `&amp;self` instead of `&amp;mut self` to avoid uniqueness restrictions. I think that that fact would make more sense to people looking at the library for the first time if the language framed this as a uniqueness constraint as opposed to the current mutability (but not really) constraint.
So I presume we would lose the ability to declare non-static constants as well?
Your final suggestion sounds like the right approach. Unless you think the user can benefit from having direct access to the trait (and it sounds like they can't), each type should just expose its own `run()` method and keep the implementation private.
I strongly agree with Niko. The mutability distinction is *really* cool---don't get me wrong---but if there's an opportunity to *simplify*, then I think it should be aggressively pursued. Niko makes a very strong case that removing `let mut` would simplify things. Here's a short anecdote. The first time I saw mutability happening behind a `&amp;self` was in the Rust parser. I remember spending an hour digging through the code trying to figure out how the parser could possibly be modifying its state behind a reference that---or so I thought---wasn't supposed to allow mutation. (I was expected to find an `unsafe` block somewhere!) I knew about `Cell` types at the time, but for whatever reason, it just didn't click until I actually found the cell being used for myself. (And yes, `Cell` uses `unsafe`.) Needless to say, the discovery was quite shocking. After that, I started seeing `&amp;mut` as exactly what Niko described: a *unique* reference.
wrt Cell I think you are misunderstanding how these work under the *current* system (and the new system stays same). You can mutate &amp; with RefCell, but you cannot alias &amp;mut with RefCell. You cannot circumvent aliasing rule within the safe language. (Otherwise it would be a bug.) So "immutability lie" is not symmetric with "unaliasability lie".
You're looking for [/r/playrust](http://www.reddit.com/r/playrust)
If you're trying to avoid uniqueness constraints, mutable-as-default won't change anything. You'll still have to take `&amp;self` instead of `&amp;my self`.
Ah no. In the current system (and in the new system) &amp; can be aliased, even if it includes RefCell. Only RefCell part can't be aliased, &amp; can. Edit: I think I now understand what's going on. In my mental model, mutability is property of entirety reachable from something, but aliasability is property of something itself. If A is part of B, it seems to me mutating A is mutating B, but aliasing A is not aliasing B. This seems purely terminological, and if you define mutability and aliasability same way, they do work same.
It seems to me that this is a symptom of our documentation not properly teaching about inherited mutability vs internal mutability (which is something that Niko's proposal will not change in the slightest). In fact, Niko's proposal would lead to the exact same situation you just described. The parser would still take `&amp;self`, and you'd still be rather confused as to how it's mutating state without a unique reference.
I was quite sceptical at first, but this definitely convinced me otherwise. I find the distinction around aliasing is the same type of new thinking that was required for lifetimes. Most languages are focused on mutability vs immutability. Having found a language that supports immutability by default was quite attractive. However, after this post, it becomes clear that it's aliasing *and* mutability that's the issue, not just mutability by itself. Considering many (most?) function immutability-by-default languages have GC (thus aliasing), they'd need a trade-off elsewhere. It also presents a unique way to separate Rust even further, although I see it being *more* complex in terms of introducing aliasing concepts (which might not be prevalent in mainstream languages before) and *less* complex than the current system (where it's somewhat misleading). I find `&amp;uniq` to be the clearest in what it's doing &lt;/bike-shedding&gt; 
"Only RefCell part can't be aliased" &lt;- Yes, that's what I said. Just like Cell and friends are the mutable exception to the immutability of `&amp;`, they are the unaliasable exception to the aliasability of `&amp;`.
I believe that to be another symptom of our documentation. We're not teaching ownership, mutability, and aliasability properly (and making variables mutable-by-default won't change that; we still have to document all this). Anecdotally, I've known about how `&amp;mut` requires non-aliasability for a while (except for the `&amp;&amp;mut T` being immutable bit, which I never even considered before), and yet I have *never* written code where I used `&amp;mut` because I wanted non-aliasability. Every instance of `&amp;mut` I have written has been because I wanted mutability. But also, I've known about interior mutability for just as long, so seeing a `&amp;self` value mutate its state isn't surprising to me. I would assume there's a type with interior mutability involved. But that's because I taught myself about the existence of `Cell`, etc.. I shouldn't have had to do that, the documentation should have properly taught inherited mutability vs interior mutability.
I disagree. If you miss `mut`, the compiler will error. But the compiler doesn't know that you mutated the right variable. In the following code: for i in range(0, 100) { let mut j = i+1; if should_skip(j) { i += 1; } do_something_with(j); } the compiler will tell me that `i` isn't mutable. And that's great! Because I didn't mean to mutate `i`, I meant to mutate `j`. Because of immutability-by-default, the compiler was able to catch an error that it could not have caught otherwise.
That goes through a trait object, which has a runtime cost. If both traits are in scope, the current solution is to use a method that tells the type system what type you're trying to use: fn as_trait_foo&lt;T: Foo&gt;(x: T) -&gt; T { x } as_trait_foo(my_foo_bar).foo_meth(); Once we have UFCS (Universal Function Call Syntax) you'll be able to disambiguate using that. Both the above solution and UFCS are compile-time solutions with zero runtime cost. --- **Edit:** /u/dbaupp pointed out that I was wrong with the above code snippet. You have to actually call the method from within this generic function, rather than calling it on the results. fn call_foo&lt;T: Foo&gt;(x: T) { x.foo() } call_foo(my_foo_bar);
I still think this is not symmetric. In the current system, the message is &amp; is immutable (deeply so). This is a lie. Also, &amp;mut is mutable, and also deeply mutable. In the new system, the message is &amp;mut is unaliasable (deeply so). This is not a lie. This is complete truth. On the other hand, you'd expect &amp; to be aliasable, and it is, but it is not deeply aliasable. Do you agree with my statements above?
I think we are in violent agreement. :)
Perhaps you're right. I don't know. I feel like we can solve this by teaching about mutability, including inherited vs interior mutability, and aliasing really early in the tutorial and the manual. When a new programmer learns about `mut` for the first time, if they're taught what inherited mutability means, and how some times (such as `Cell`) have interior mutability, then they shouldn't be surprised to encounter this concept again later.
I'll be posting daily or multiple times daily. It's meant to be short blurbs to track my progress, rather than anything deep or thoughtful (which I reserve for my [real blog](http://blog.octayn.net/))
If the compiler considered the `&amp;mut T` in a `&amp;&amp;mut T` to be mutable, I could construct code that manages to re-borrow it twice into two separate variables that are both active. At that point it would be fully aliased. I only can't do that because the compiler considers the underlying `&amp;mut T` to be immutable, which means I can only re-borrow it into a `&amp;T`.
+1 Many programmers are more comfortable with the concept of mutability then uniqueness, and I think that is a reason we should put uniqueness more front and centre in Rust.
I made the exact same mistake as burntsushi - assuming that since `mut` existed that anything that wasn't `mut` had to be immutable. And I made this mistake having read that `&amp;mut` was guaranteeing non-aliasability. Better documentation is always nice, but, I don't think the documentation that Rust has currently is bad. In my oppinion, no ammount of documentation can overcome seeing `&amp;mut` and `mut` in code and assuming that the opposite must be immuability. I found very hard to understand how `Cell`, `AtomicInt`, and friends worked until I started thinking about them in terms of the aliasability constraints. Once I did, everything just started making sense. 
I'm leaning toward agreement on this, though I can see the argument the other way too. (Note that having all locals be mutable was the way old Rust worked anyhow.)
I don't believe that `as_trait_foo` does what you want (I don't have a compiler near by to test). Specifically the bound doesn't restrict the use *outside* the function with the bound, since the compiler knows the concrete type of the return value.
&gt; Yesterday I started as an intern at Mozilla, which is unspeakable awesome. Indeed it is. Congrats!
 fn make_alias&lt;T&gt;(orig: &amp;mut T) { let x: &amp;&amp;mut T = &amp;orig; let y: &amp;&amp;mut T = x; // copies x, doesn't borrow it let alias1: &amp;mut T = &amp;mut **x; let alias2: &amp;mut T = &amp;mut **y; assert_eq!(alias1 as *mut T as *T, alias2 as *mut T as *T); } If `&amp;&amp;mut T` was not specially-handled by borrowck to consider the inner `&amp;mut T` immutable, this would be legal code that would produce two `&amp;mut T` pointers with the same value, i.e. aliases. And actually, since we're just considering aliasability, I can produce a `&amp;T` in current Rust that aliases with the `&amp;mut T` that's referenced by a `&amp;&amp;mut T`. That is a legitimate alias. The fact that I can do that is why `&amp;&amp;mut T` is actually immutable. That looks like this: fn make_alias&lt;T&gt;(orig: &amp;mut T) { let x: &amp;&amp;mut T = &amp;orig; let alias: &amp;T = &amp;**x; assert_eq!(alias as *T, *x as *mut T as *T); } Note how `alias` aliases with `*x`, despite `*x` having the type `&amp;mut T`.
I guess I wrote a lot of words but didn't state my position clearly. I am against the proposal because I think `mut` is valuable in verifying programmer intention, just like having type signature is valuable even if it can be inferred.
`Cell` is implemented with unsafe code, but its interface is completely safe. So, in my mind, the unsafe code is just an implementation detail. If Rust had construct X, maybe the unsafe wouldn't even be necessary, so, it doesn't factor into me trying to understand it. What was bugging me was *why* that interface was safe. I was assuming that `&amp;mut` meant mutable and that `&amp;` meant immutable. But, `Cell` lets me change it through a `&amp;`, so, what does `&amp;` really mean? And, why would I want to mutate something through a `&amp;` reference as opposted to just getting a `&amp;mut` reference and using that? Is it just an escape hatch for poorly written interfaces that accept a `&amp;` when it should be a `&amp;mut`? From the mutability perspective, I couldn't answer those questions. From the aliasability perspective, it made sense to me - the `Cell` is alaisable, but its content is not. So, its valid to mutate it via `&amp;` because it guarantees that its interior can't be referenced elsewhere. Furthemore, its not just a mechanism to escape from bad interfaces, but instead a useful building block when you need to mutate something that is referenced from multiple places. At least, thats how it made sense to me. 
Thanks for all the stuff you write about Rust. I had an idea about having short interviews with the people in the Rust ecosystem. For example Eric is credited on IMDB, what is his story?
I'm aware, but at least I won't be lying to the compiler any more.
Hrm, I could have sworn that worked. I thought it did method resolution based off the generic parameter, not the concrete one. But you're right, rustc does do it based off the concrete type. Ok, well, the modification is to just call the method inside of this once-off function. fn call_foo&lt;T: Foo&gt;(x: T) { x.foo() } call_foo(my_foo_bar);
What do you mean, lying? If you consider interior mutability to be lying, shouldn't you consider interior aliasability to be lying as well? And I don't think you should consider interior mutability to be lying. Types that provide this (such as `Cell`) use `unsafe` not because they're lying but because they're implementing something the compiler cannot statically verify is safe. The difference between interior mutability and inherited mutability is a core concept of Rust.
The place where you can put grenades on the stack.
Hmm ok, that explanation makes sense. I suppose not thinking about aliasability does lead to confusion over why something would take `&amp;Cell&lt;T&gt;` when it could take `&amp;mut Cell&lt;T&gt;`. Personally, I would have assumed (not knowing about aliasability) that the reason is that the `Cell` may be embedded in a larger type that, itself, may be held in a `&amp;T` for various reasons. In other words, the need to mutate the `Cell` is an implementation detail that should not be exposed through the interface of the enclosing type (which is why the enclosing type would work as a `&amp;T` instead of requiring `&amp;mut T`). Understanding aliasability certainly presents a more straightforward answer for why you need `Cell&lt;T&gt;`, which is what you just explained. So I definitely agree that understanding aliasability makes the need for interior mutability more straightforward. But I would not go so far as to say that leads to wanting to actually think directly about aliasability in my interfaces and types, rather than merely thinking about mutability. In other words, if I take a `&amp;mut T`, it's not because I need the reference to be non-aliased, it's merely because I need it to be mutable. Incidentally, there is a legitimate use case for `&amp;mut` pointers to types that have interior mutability (although its is a bit unusual). For example, `&amp;mut Mutex&lt;T&gt;`. The reason for this is if I need to swap out the entire `Mutex&lt;T&gt;` value with a new one, rather than taking the lock and swapping out the contained value. And actually, the reason why I might do this contradicts your assertion that the content of a type with interior mutability is non-aliasable (to be fair, you said that specifically about `Cell`, and it's true about that type, but from context I'm assuming you're believing this to be true about all types with interior mutability). A `Mutex&lt;T&gt;` is cloneable, and each clone contains a reference to the same contained `T`. And each clone allows for mutating it. This is guaranteed to be safe by only allowing the mutation when a mutual-exclusion lock is held. But this is something the compiler cannot statically reason about, and so it requires `unsafe`. And because of this actual aliasing of the underlying `T` value, I may find a use for `&amp;mut Mutex&lt;T&gt;` as I can swap out my mutex with one that references a completely different `T`, shared with a completely different set of clones (or with none at all). --- I guess what I'm trying to get at here is that looking at `&amp;mut` as being all about aliasability, and therefore making more sense as `&amp;uniq`, is actually just as short-sighted as considering `&amp;mut` to be all about mutability. Just as `Cell&lt;T&gt;` allows for interior mutability, `Mutex&lt;T&gt;` allows for interior aliasability. Both types ensure that the mutability/aliasability they are containing are wrapped in a safe interface, and both types do so using `unsafe`. For types that don't use `unsafe`, they have both inherited mutability and inherited aliasability.
I like this. Losing immutability feels a bit scary, since it was one of the things that attracted me to the language. But, the more I got into the language, the more I realized that the guarantees of immutability were significantly more nuanced that I'd realized. I found these realizations to be quite jarring - something that I think is not good for a language. This is something that I don't think is possible to fix with documentation. Onto bikesheedding. Given that I wrote [RFC #58](https://github.com/rust-lang/rfcs/pull/58) proposing renaming `&amp;mut` to `&amp;only`, its not surprising that I favor `&amp;only`. I like that it makes the aliasability guarantee very explicit. Mutability is very important, but its something that flows from non-aliasability, so, making that front and center seems very appealing to me. I like `&amp;uniq` almost as much as `&amp;only`. One thing I don't care for is that it feels like an uncessary abbreviation - taking a 6 letter word and shrinking it to 4 saving only 2 characters. One of my motivations for proposing `&amp;only` was that I was thinking that `~` might become `Uniq` and that would make `&amp;uniq` very confusing. Now that its become `Box`, thats not really an issue, though. I'm not a fan of `&amp;my`. On the plus side, it doesn't imply that `&amp;` is immutable. So, I like it quite a bit more than `&amp;mut`. However, it doesn't really feel like it means much of anything. `&amp;my` does imply ownership, but ownership by whom? The caller? The callee? If a pass a regular linear type as an argument to a function, that function takes ownership of the value. However, if I pass a `&amp;my`, once that function returns, the `&amp;my` reference is still valid. So, I guess that the callee doesn't own it. However, by similar logic, the caller doesn't own it either. So, it feels like all its saying is that the value is owned. However, all values are owned, so, I'm not sure that really means much. I'm also not sure how to talk about a `&amp;my`. Do I say that a function "takes a my reference"? That feels a bit awkward and almost sounds like we're talking about a struct method that takes `&amp;self`. Finally, I'd prefer a term that made the non-aliasability guarnantee very explicit, which `&amp;my` doesn't do. 
I'm a non-expert/casual observer of Rust so I may be missing some important point, but WRT the "lie" of `mut`, couldn't an `&amp;` reference to a `Cell` simply be disallowed by the compiler? This would force an `&amp;mut` to be used and would seem to make `mut` truthful as to what can be done with the reference. There would be no universally implicit statement of uniqueness with `&amp;mut`. It would simply depend on the type. Ultimately it seems that no matter what approach is taken, the user must be aware of the difference between `Cell` as implicitly mutable and other types as not, and therefore requiring uniqueness. Forcing the user to use `&amp;mut` on a `Cell` along with a descriptive compiler error message would seem to be a useful educational tool. 
Ugh, this wouldn't fly. The reason &amp; to Cell is allowed is that otherwise passing borrow checker becomes a lot more painful.
Losing immutability by default is not just scary, it is unacceptable. Alternative #2, with "&amp;", "&amp;uniq" and "&amp;mut" seems the best solution. A good way to see justify this is to imagine that we have only have &amp;uniq and not &amp;mut, but have a Mut&lt;T&gt; type (kind of like Cell), that an &amp;uniq Mut&lt;T&gt; is the only way to mutate anything, and that accessing a field of a &amp;Mut&lt;T&gt; or &amp;uniq Mut&lt;T&gt; gives you an &amp;Mut&lt;U&gt; or &amp;uniq Mut&lt;T&gt; Then &amp;mut T can be seen as syntax sugar for &amp;uniq Mut&lt;T&gt;, and let mut foo: T as syntax sugar for let foo: Mut&lt;T&gt;. Note that this doesn't really change the current language at all beyond introducing &amp;uniq, and merely provides a more sound explanation for how it already currently works. 
I think the `&amp;uniq`/`&amp;mut`/`&amp;` proposal is better. Not only do you get to keep immutable-by-default, but it also makes things clearer when you care about mutability (most uses of `&amp;mut` - it doesn't matter that uniqueness is required, it's about expressing intent), and when you just need uniqueness.
Hrm, I didn't make it clear, but I was talking about just `Cell` having a non-alised interior. `Mutex`'s interior may be aliased, but the `Mutex` type enforces the proppe constraints about accessing it so that safety is preserved. I find the arguments for retaining `&amp;mut` and `mut` to be fairly persuasive. Conveying programmer intent is very useful. But the thing I just can't get over is that for a generic type, `&amp;` is no less mutable than a `&amp;mut`. Granted, for a type to be mutable through a `&amp;` it must contain a type with interior mutability and most types do not implement interior mutability. So, for a generic type, I think its fair to say that a `&amp;` is probably immutable. But, my feeling is that the types should be named to convey the properties that they have 100% of the time, not just 99% of the time, since this is what the compiler is actually doing. So, for `&amp;mut` I feel like there is a level of indirection between what the programmer requests and what the programmer gets. Not as much with `&amp;mut`, but much more so with `&amp;` where they want immutability but get aliasability. For something like `&amp;only`, I feel like there is a level of indirection between what they are requesting and what they generally want. I prefer the second tradeoff, since I like making it explicit what I'm actually getting 100% of the time and making what I plan on doing with it a consequence of it, something that I can describe in a doc comment. 
And impossible in some instances. The only way to get mutability of shared values is to mutate behind a `&amp;` somehow (e.g. `Cell`/`RefCell`).
In most memory safe languages, its perfectly valid to have many references to the same object and to mutate them through any of them. Rust doesn't let you do this in order to preserve memory safety. What `Cell` provides is a mechanism to have a value that is visible through multiple references that you can also mutate. It works because the value in the `Cell` is not directly visible. Its only accessible via the methods of the `Cell` which also guarnatee that its not ever possible to access that value except through those methods. In general, if you can avoid using `Cell`, you should. However, in code where you need to have multiple references to something *and* still be able to mutate it, its very useful. I found this exceptionally confusing when first learning Rust and my initial reaction was also: why not just require a `&amp;mut`? This is why I think making aliasability the central concept is a good idea. I think that `Cell` makes the most sense when you think about it in terms of aliasability of individual memory locations as opposed to mutability. 
The whole point of `Cell` and `RefCell` is for instances where `&amp;` is the only obtainable reference. If you can have a `&amp;mut` then you can mutate directly, without those wrapper types.
I thought so too, but, mutability is only dangerous when there's also aliasing (*). I think "immutability by default" has been trending quite a bit lately because of functional languages. I didn't really think of the problem as aliasing vs mutability until this blog post; but it makes complete sense. Most functional languages that have this immutability also have a GC. As a result, you have aliasing everywhere, but things are immutable. I think it makes a lot more sense if something like `&amp;uniq T` would be available (like the blog post). This would allow one to thoroughly think of the aliasing requirements (if any). I view it as the same concept as lifetimes was before being introduced to Rust. One typically doesn't think that way or about those things. *: There are some examples (given in this thread) that warrant an immutability-by-default semantic. Such as the `i` in a for loop that you accidentally change, where you do have the unique aliasing constraints.
We should make this change, so we can say this about both directions. ;) More seriously, I think this change is now great. 100%.
It seems like your issue is not with `&amp;mut` denoting mutability, but with `&amp;` denoting immutability. Is that correct? My feeling is that `&amp;` does not in fact denote immutability. It just doesn't denote mutability. For types that have inherited mutability, this does result in an immutable value, of course. And this is perfectly analogous to `let`-bindings. `let x = ...` does not mean the value is necessarily immutable. If the value has inherited mutability, then yes, the value is immutable. Whereas if the value has interior mutability, then it's mutable.
Thanks! I skimmed this a few days ago, but only now am I realizing a lot of it went right over my head. I am re-reading it now.
Excellent. Thank you.
&gt; Note that this doesn't really change the current language at all beyond introducing &amp;uniq, and merely provides a more sound explanation for how it already currently works. There's quite a cost to adding more features, though, especially around pointer types. Pointer types have historically been the most difficult part of Rust to grasp. "Rust is going to have to do quite a lot to not be known as the language with lots of pointer types"—Bryan O'Sullivan, paraphrased from memory. (Fans of immutability will know who he is!) I think he's right, and we should be open to even reconsidering our "sacred cows".
&gt; With immutable variables, once you have figured out something about the initial value, you immediately know that it holds for the variable everywhere in the code. …unless the value contains cells, or mutexes, or reference counted pointers to other objects that themselves contain one of those. That's one of the issues here—it's a pretty fuzzy guarantee to begin with. There is of course the argument that, for *most* types, yes, you know that, and that's totally valid. That's one of the reasons I'm on the fence about this. But it's not as clear-cut as you make it out to be.
I have read what you said very closely. And you're repeating the same incorrect information. &gt; The `&amp;mut T` is not being aliased. Yes it is. The `&amp;mut T` exists somewhere, presumably on the stack. I have a `&amp;` pointing to it. I can access it via dereferencing. This is just as how having a `&amp;T` means I *can* access a plain `T`, I just can't move it (notably, I can take a reference to it. Sure, I end up with another `&amp;T`, but I did so by operating on the `T` directly, as in `&amp;*x`. Similarly, if it's a type that supports dereferencing, such as `&amp;int`, then I can dereference it. This does not require moving it, and it is an operation on the `T`). In any case, I have my `&amp;&amp;mut T`, which means the `&amp;mut T` exists somewhere. I then construct a `&amp;T` that aliases this `&amp;mut T`. The fact that the `&amp;mut T` is not stored in a local variable typed as `&amp;mut T` does not change the fact that it does, in fact, exist. And is aliased by my `&amp;T`. The fact that I can produce this alias is why borrowck prevents me from treating the `&amp;mut T` as mutable. If I could not literally alias the `&amp;mut T` then there would not be a problem. What part of this do you disagree with? You are claiming that I'm not aliasing the `&amp;mut T` when I quite plainly am. I have to assume this means you are not actually understanding either the code I wrote, or the description explaining the code. What part of this is confusing you?
&gt; No, we don’t. Rust programs would be equally sound if you just declared all bindings as mut. The compiler is perfectly capable of tracking which locals are being mutated at any point in time – precisely because they are local to the current function. What the type system really cares about is uniqueness. BOOM! HEADSHOT! At least for me. This is really compelling. I feel that it's hard to articulate, though. Basically, in any 'normal' language, I'd want immutable by default, but given all of Rust's other constraints, I think it's fine.
Actually, a variant of #3 can also be good. The idea would be that we only have &amp; and &amp;uniq, but inherited mutability applies to &amp;uniq too, so an &amp;uniq is mutable if and only if it is in a mutable slot or is an rvalue. Then, Niko's example becomes very natural: let mut errors = 0; let mut p = &amp;uniq errors; *p += 1; Having to declare p as mut is perfectly natural now, since otherwise the &amp;uniq would not be mutable due to inherited mutability. The advantage compared to #2 is that only two pointer types, &amp; and &amp;uniq, are required. The loss (which is not necessarily a disadvantage, and might actually be a good thing) compared to #2 is that you can no longer express a &amp;uniq that points to a mutable location, but is not mutable itself. Also, it's more verbose since you need to say "mut foo: &amp;uniq T" rather than just "foo: &amp;mut T". You still can only take an "&amp;uniq" from a "let mut" and not from a "let", but now this no longer causes issues for closures and similar constructs, since an "&amp;uniq" in a non-mut let is immutable. This is still far better than losing immutability for all variables, so this might be the best solution if having 3 borrowed pointer types is considered undesirable. 
&gt; Losing immutability feels a bit scary, since it was one of the things that attracted me to the language. That's ok. "Typestate" was the thing that attracted me to the language.
Thanks for the write-up, after /u/pcwalton's slip about this the other day, I was worried this might take a while to be posted and have to deal with hysterics. Much like my stance on `~`, I consider any change that shrinks what is currently a large language a good thing. (Similarly, I don't care about the name) Changing let mutability is a scary prospect, yes, but I agree that it's value as a indication of intent is oversold. I've spent a lot of time reading complex C++ code and whether a variable changed or not doesn't really come up very often. In light of the ability to have interior mutability, and the general best-practice of keeping functions small, the so-called "declaration of intent" ends up pretty weak. Especially since `&amp;T` will be an immutable reference anyway (by way of not being able to own it). The concept of ownership is fundamental to Rust. The amount of times we have to explain that *everything* is owned in Rust, even things that sorta look like they aren't is telling. As such, it makes sense to subsume mutability into ownership. If you own it, you can change it, otherwise, you can't. Shared ownership just means that you aren't the only owner. I also think that given how a proper understanding of `&amp;mut` currently requires you to treat it as `&amp;uniq` *anyway*, this change might help people get there faster. We might be making the initial learning curve steeper, but at least we won't have a spike half way along when you have to re-organise everything. 
Well we have been paring down the pointer types, to be fair. `@` is deprecated, `~` is on its way out so that just leaves references and raw pointers, and we can't be rid of raw pointers or references. However, the region/borrowing system is probably the next biggest hurdle, and having 3 different reference types seems like trouble. Personally, I like the let mutability thing, but I don't think it's more important than the region system. I've said time and time again, over and over, that the region system is what makes Rust special. Everything else is just gravy. 
&gt; I've said time and time again, over and over, that the region system is what makes Rust special. Everything else is just gravy. Totally agreed. If I were to write a retrospective on lessons I've learned from Rust language design, it would be "have something in your language that nobody else has, and focus relentlessly on that". For Rust, that's *memory safety without garbage collection* (to be broader, memory safety with zero overhead). Everything else is secondary.
complete noob here. That said, I understand that what makes types like Cell different is that they guarantee that they can be mutated through multiple references. If there was a special trait for them to implement (let's call it SafelyMutable, just for the sake of example) we could have: * &amp;uniq would guarantee that there's only one reference * &amp;mut would disappear * "mut" would be required on the left hand to express intent that we want to mutate things. Compiler would be able to verify that right hand is either a uniq reference or a normal reference to a SafelyMutable type (or a value?) * anyone can create a new type that guarantees safe (shared) mutability and derive SafelyMutable to flag this to the compiler * you could have "mut &amp;uniq" arguments to functions to express that you want a uniq reference AND you want to mutate it (vs the situation with closures where you want a uniq reference just because you don't want anyone else to mutate it)
I'm just glad somebody finally took my suggestion of removing concurrency from the top spot on the website (whether or not it *was* because of me is irrelevant). The top ten features of Rust, for me, are: 1. Zero Cost Memory Safety 2. Ownership Semantics 3. Zero Cost Memory Safety 4. Algebraic Data Types 5. Generics 6. Zero Cost Memory Safety 7. Closures 8. Performance 9. Potential for Rust/metal puns 10. Zero Cost Memory Safety
In this regard, one can think of an explicit mutability annotation too; so that a plain `let foo;` has an inferred mutability, and an explicit `let mut foo;` and `let const foo;` is guaranteed to be mutable and immutable respectively.
I agree. Ideally though I would still want a way to declare that I *want* to mutate things to prevent accidental mutation. I would still like having to specify "let mut a = .... (something that can be mutated)". Rust can guarantee that a program is sound even if everything is mutable, but "correct" (as in "I actually wanted to do this") is a subset of "sound" (as in "no memory was hurt in the making of this program") and I would still like to know that I'm mutating the variable I actually wanted to mutate and the compiler to help me flag these errors. If that can't be guarantee (or is impossible to guarantee in a way that does not break some other aspect of the language) I can live without mut.
I think you forgot zero cost memory safety. (I 100% agree with your list.)
The situation seems relatively similar to `let mut` vs. `let`, except taking a `&amp;only` reference to a `static` is `unsafe`. (That said, you are correct: having guaranteed-immutable `static`s is far more necessary than having "immutable" local variables.)
I think `let` would essentially just be a synonym for `let mut` in that context.
I really like the simplication here, and can dig the motivation. The existing system most obviously mirrors how C++ works with `const`, and that obfuscates that the purpose of im/mutability in Rust is way different. I guess we'll want to rename `static mut` to `unsafe static`. ;) I'm kind of going to miss the "you see this new variable here? look out, because i'm gonna mutate it later on!" markers. The "immutable SSA" style of writing rust code is really appealing and removing immutable-by-default locals would make that more confusing and somewhat awkward, imo. I don't think shadowing mixels well with mutable variables.
Is having to write "mut closure" or "let mut socket" really such a big problem that it justifies removing the distinction between immutable and mutable variables? fn foo(&amp;self, mut closure: FnMut&lt;int,int&gt;) { let x = closure.call(3); } let socket = Socket::new(); socket.read() // ERROR: need a mutable reference I really think alternatives should be discussed more in detail. PS: Pcwalton's suggestion of renaming &amp;mut to &amp;only / &amp;my / &amp;uni / etc. made sense because it better reflects how the borrow checker actually works. This proposal on the other hand seems to be motivated by the desire to hide some details about how closures work from the user.
for this simple example yes, but is immediatly satisfied if you modify j just once
Is there any way to enforce immmutability or pseudo-immutability? A `const` keyword comes to mind, but that seems like it would complicate matters more. Like, if I want to make a structure that is immutable and I want it to be sure I never once mutated it. 
This is a good point. I had forgotten about statics, I think we would still need static mut.
I'm not sure who you mean, but I know one of the guys has ties to Pixar. 
As far as I know, you can clone a TcpStream and use it in another task, while keeping ownership over the original. Based on this I have implemented a minimal Rust irc bot (see https://github.com/aochagavia/Rustic-Irc/blob/master/src/main.rs) which handles the incoming messages on one task, while you can send new messages by entering them in the console/terminal.
Edit: I'll need to pay attention to my coding to be sure, but I finished reading the post and I think I'm convinced of proposal #1. Or maybe 3. I'm also pretty undecided about this, but am leaning towards keeping some notion of immutability. I think, as described above, immutability is extremely helpful in maintaining an effective mental model of code. In terms of mental cpu, I think keeping in mind "but not with Cell, Mutex, or unsafe code" is less expensive than needing to reconsider mutability all the time. Knowing the compiler will yell if I explicitly mutate something I've agreed not to is nice. That said, a less complicated system is almost inherently better. It makes learning easier, and reduces the number of confusing errors. 
I think you misunderstood my last point (due purely to my bad explanation, sorry). I meant that within the context of struct literals, etc. (i.e., where there is a named struct) then omitting the name of the struct is a bit weird. I totally agree that there is a case for anonymous structs in general.
Actually, I take that back. We could get rid of `static mut`, and instead make use of the existing types for embedding mutability into aliased content (`Cell`, `Unsafe`, etc). It would be unsafe to borrow a `static` that contains (transitively) a `Unsafe&lt;T&gt;`, unless that type is `Share`. This is basically the inverse of the (intended) rule that says it is *safe* to borrow a `static mut` that is `Share`.
Similarly, you might want a lint for mutating the loop variable. In the end though, yes, you can have bugs. The more distinctions we add to the type system, the more we improve our ability to statically detect bugs, but it certainly comes at a cost. The question then is how big a problem do you find that bugs like this are in practice, particularly once you eliminate the simple examples with some lints? And how do you balance that against the perceived overall complexity? I am going on my own instincts and memories in judging this tradeoff; I'd like to find a way to judge more reliably how many bugs the `let mut` rules prevent.
This is interesting. One of the things that pushed me over the edge with regard to this proposal was the fact that I do NOT go and mark things as const in C++ code that I'm reading. In general, I find the biggest obstacle to reading code are giant subroutines that extend to 100s of lines -- which incidentally aggravates the problem of deciding which variables are mutable, because you can't see it at a glance.
http://www.imdb.com/name/nm2179707/
Clojure has a rather neat way to handle this when implementing protocols: a protocol implementation is a sequence of (protocol, methods*) e.g. (extend-type BestStruct Foo (foo-1 [] …) (foo-2 [] …) Bar (bar [] …) Qux (qux [] …)) `extend-type` is a macro over extend, maybe this could be a macro desugaring into multiple impl blocks?
What about something along the lines of replace &amp;mut with &amp;only, and make it non-mutable by default. Then make it so that if you want to mutate a &amp;only, you need a mut &amp;only? This doesn't introduce more pointer types, makes the syntax more explicit (at the cost of being longer), and makes 'mut' **the** only (non-cell) way to get mutability.
I wonder if just calling `&amp;` a "plain reference", rather than an "immutable reference" would reduce the issues that people have with it being possible to mutate some things through `&amp;`. I definitely like being able to express my intent with `mut` and it does make reading code easier; but maybe `&amp;only` work for this purpose?
&gt; I find losing immutability-as-default a rather scary prospect, but the arguments in favor of simplicity are very compelling. Rust users need to understand inherited mutability either way. I think `mut` is clearly defined as inherited mutability and the fact that there are inherently mutable types does not make it a lie, and is something people have to learn either way. Obfuscating the mutability system will not make it any simpler. &gt; Niko understands Rust's type system more than any of us here, so his opinion is worth a great deal. I don't like what this implies. There are many people who understand Rust's type system more than enough to understand all of the relevant details here.
I don't think borrowed pointers should be changed at all. The usage of `mut` for locals and borrowed pointers is consistent, and there is *not* a problem with unboxed closures. Rust needs to provide by-value capture for unboxed closures or it will still be trailing *far* behind C++11 with crippled support for functional programming, and further behind compared to C++14. The support for argument modes was removed *because* references in Rust already provide the necessary features. References are just values, so there's no need for anything like capture clauses.
Either way, the inherited mutability rules are still there. Restricting the usage of this set of rules to catching memory safety issues rather than preventing other errors doesn't make the language simpler. It *is* going to be yet another example of a regression from C++ to Rust though. You're not going to find many people who write modern C++ and dislike having `const`, and you'll be hard-pressed to convince them to lose it.
I don't see a need for 3 types... why not just capture by-value in unboxed closures as originally proposed and avoid all of this pain?
Please, let's not make this a debate about syntax. A language is not about syntax, it's about semantics. And that single `mut` keyword implies a lot of things for semantics with far-reaching consequences that we (as external observers) can only begin to fathom. Thus when the Rust developers says `mut` is complicated, let's trust them on this.
I don't think it's fuzzy at all. The `mut` keyword refers to *inherited mutability*, and some types are inherently mutable without the need to inherit it. I don't think this has ever been a big problem for people learning the language. The inherited vs. inherent mutability differentiation will still exist in the language if `mut` is removed, but it will be obfuscated.
&gt; However, I think it's a mistake. Immutability-as-default is really valuable when reasoning about code. In fact, it's one of the major reasons why programming in Rust feels so much more refreshing than programming in other languages. I agree. Memory safety isn't the only thing that matters, and there's value in having inherited mutability disabled by default for local variables. The rules will still be around either way with the same level of complexity, it will just go from being front and centre to an obfuscated property of references. &gt; Of course, the only reason we need `&amp;uniq` at all is because of closures. If we redesign closures to capture by-value instead of by-reference, the need for `&amp;uniq` goes away. As for the issues with calling desugared closures, I feel like we could solve that by actually implementing `FnMut` on the `&amp;mut T` pointer (where `T` is the fresh closure type), and the closure expression evaluates to a value of type `&amp;mut T`. We can then call this as expected, and pass it to functions, and the like. Rust's closure need to provide by-value capture either way, or they'll still going to be a significant regression from C++11 lambdas. C++ can return a closure capturing local state and I hope that's not too much to ask from Rust. &gt; All that said, I'm ok with renaming `&amp;mut` to `&amp;my` (but not to `&amp;uniq` or `&amp;only`), because the focus on borrowed ownership seems like a good fit. But there are good arguments for keeping `&amp;mut`, because it parallels our current situation with `mut` vs non-`mut` variables (e.g. inherited mutability works the same way in both situations). I definitely don't like the idea of renaming this. It exists to provide inherited mutability via references, and the aliasing rules are there to make providing this safe. It's really no different than the borrow checking rules applied elsewhere.
&gt; The mutability distinction is really cool---don't get me wrong---but if there's an opportunity to simplify, then I think it should be aggressively pursued. It's not a simplification. The inherited mutability rules will still be there, they just won't be leveraged for local variables. &gt; Here's a short anecdote. The first time I saw mutability happening behind a `&amp;self` was in the Rust parser. I remember spending an hour digging through the code trying to figure out how the parser could possibly be modifying its state behind a reference that---or so I thought---wasn't supposed to allow mutation. (I was expected to find an `unsafe` block somewhere!) I knew about `Cell` types at the time, but for whatever reason, it just didn't click until I actually found the cell being used for myself. (And yes, `Cell` uses `unsafe`.) The `mut` keyword refers to *inherited mutability*, not mutability. Any issues you had with this are still going to exist if the language is changed, because inherited mutability vs. inherent mutability of types is still going to exist. It's going to be obfuscated by not referring to it directly as mutability, but every Rust user is still going to need to learn the rules. &gt; Needless to say, the discovery was quite shocking. After that, I started seeing `&amp;mut` as exactly what Niko described: a *unique* reference. It exists to provide mutability, and will continue to use the same inherited mutability rules with or without this change. The uniqueness rule is a means to an end rather than the end goal. It's there for safety just like the other borrow checking rules.
I would argue that it's not only about bugs, it's also about reading code. I guess we will all agree that code is read more often than it's written. It's why I don't care much having to do some gymnastic to write that ~ sigil (okay, bad example, it's on the way out). I read C++ code a lot: code reviews, bug investigations, ... and I rely a lot on `const` annotations in C++, it helps guide my investigation, at least in a first pass. Note that `const` in C++ is a lie (no deep const-ness, and `mutable` keyword) just as much as the absence of `mut` in Rust is a lie today, still as a declaration of intent it's often true, so for a first pass analysis you can just trust it. And a quick first pass analysis is invaluable in narrowing down the likely culprit, I just don't have time to read attentively some dozens of thousands of lines of code for each bug I investigate.
I'm somewhat concerned that a large portion of this proposal is motivated by closures, when as yet the proposal for unboxed closures is still so nebulous. That said, I'm willing to go for it. I think it helps to set Rust apart as "that language where ownership is first-class" (even moreso than is true today) while also simplifying and clarifying things. Not that I won't still mourn local immutability, of course. Hell, just do it and get it over with. The sheer audacity of the proposal is infectiously electrifying. EDIT: Seeing strncat disagree with this proposal has reversed my position. And I was so looking forward to the reckless and wanton destruction. :(
See nikomataskis' reply about statics [here](http://www.reddit.com/r/rust/comments/25i544/babysteps_focusing_on_ownership_or_removing_let/chhmydu)
Rust will continue to have inherited mutability as a concept in the language. I don't think exposing it as a correctness checker via `mut` is complexity.
Inherited mutability works the same way for local variables and references. It's not sensible to change one but not the other. The `mut` keyword means *inherited mutability* whether it's used on a local variable or a reference. Some types are *inherently mutable as a property of the type* and this works the same way in both local variables and via references. Whether or not the language exposes `mut` as a correctness checker for variables, the inherited vs. inherent mutability concept will remain in the language. There's no simplification from removing it from locals, and since mutability is the only reason for using `&amp;mut` (lack of aliasing is the means to an end, not the thing the programmer *wants*) I don't understand why `&amp;only` would be clearer. Uniqueness for `&amp;mut` is *not* the only borrow checking rule...
The `mut` keyword refers to *inherited mutability* . Some types have inherent mutability and don't need to inherit it, and there is absolutely no lying to the compiler involved. The language will still have the concept of inherited vs. inherent mutability if the `mut` keyword is removed, but it will no longer be using it to catch bugs unrelated to memory safety.
Oh, I *loved* the idea of typestate. And when I realized it did not compose at all, oh....
This sounds like the correct solution to me. The language needs by-value closures, and if they are going to solve this inconsistency then that's by far the best course of action. Not only losing "const by default" but having no equivalent of const is going to really stunt rust uptake among some major target groups.
I believe that static variables will stay const by default and as far as I know, for compile time constants, the semantics are the same as our current non-static constants. But for constants assigned values at run time another keyword may be necessary. I suppose you could have a std library type, like the opposite of Cell that only returns a non-unique reference.
&gt; Many programmers are more comfortable with the concept of mutability then uniqueness, and I think that is a reason we should put uniqueness more front and centre in Rust. The only reason to use `&amp;only` will be mutability. Obfuscating the purpose by renaming it will not remove the difference between inherited or inherent mutability, so I don't see it as simplifying anything... it's just regressing from C++ where `const` can be used to make code clearer by having the compiler that the programmer's code matches their intent.
Wait, it's not about removing mutability here, it's about making it ubiquitous: everything will be mutable (by default), and you will have either a shared "immutable" reference `&amp;` or a unique "mutable" reference `&amp;only` (or whatever).
I remember completely disagreeing with your RFC, however I think I am slowly warming up to the idea. It may be, indeed, that `mut` is not as necessary as my previous C++ experience suggested. [More thorough explanation of why I am coming to see the light here.](http://www.reddit.com/r/rust/comments/25i544/babysteps_focusing_on_ownership_or_removing_let/chho9l9).
&gt; Not only losing "const by default" but having no equivalent of const is going to really stunt rust uptake among some major target groups. Most C++ programmers view `const` as a useful feature, and Rust isn't going to attract them by regressing from the language they're already using. I think it makes code significantly easier to read, because you need to keep track of far less state as you're reading it.
&gt; It wasn't entirely clear to me: does this get rid of the need for any declaration on parameters, of the form: pub fn blah(&amp; mut self) ... If you want inherited mutability you will still need to write `&amp;only self`. Mutating a `&amp;self` parameter would be memory unsafe (without using `Cell` or `RefCell` or somesuch). In terms of mutable references this RFC is just renaming `&amp;mut` to `&amp;only`. And the rest of the RFC is just allowing a `&amp;only` references to be taken to any local variable (i.e. all locals can be mutated).
I believe a lot of the people crying out for `mut` come from a C++ background where `const` has been praised, with reason, for years. It's hard to switch mindset, and our understanding of a Rust program is colored by our C++ experience. Actually, I argued a lot against /u/dagenix's proposal not a few days ago, but I may be coming to see the light. So I created a small experiment: int bar(int a, int i, int&amp; x) { return a + i + x; } int foo(int a) { int x = 0; int acc = 0; for (int i = 0; i &lt; 10; ++i) { acc += bar(a, i, x); } return acc; } The main issue, here, is that it's impossible to tell whether `bar` modifies any of its arguments. In C++, references were introduced to seamlessly allow passing variables, but as a result they hide what is going on. That is the reason that the Google Style Guide requires [passing mutable reference by... pointers][1]: the call to bar would like `bar(a, i, &amp;x)` where it's immediately visible that out of those 3 arguments, only x may be modified. Now if we switch to the Rust with `&amp;only` and default mutability: fn bar(a: int, i: int, x: &amp;only int) -&gt; int { a + i + *x } fn foo(a: int) -&gt; int { let x = 0; let acc = 0; for i in range(0, 10) { acc += bar(a, i, &amp;only x); } acc } It's interesting because contrary to C++ there is no hidden mutation: - `i` and `acc` are mutated locally, for all to see - `x` may be mutated by `bar`, but it's immediately visible as we pass `&amp;only x` to `bar` (contrary to passing `a` and `i`) And therefore, indeed (and quite shockingly, at least to me) the need for annotating mutability/constness seems to wane. We could argue that should `foo` be long and have dozens of variables it would be better with `mut`/`const`, however overly long functions are not exactly a compelling argument (and linear long functions are not difficult to read either). --- *Edit:* On a tangent, I found in C++ Coding Standards (by Sutter and Alexandrescu) that Item 42: *Don't give away your internals* exposes the exact issue of mutability and memory safety. If, like `Cell`, you cannot be pattern-matched and never give away a reference to an attribute of yours (transitively...), then you can be mutated safely (in single-threaded mode). [1]: http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Reference_Arguments
It appears there is a divide (that probably largely hinges on experience with functional programming style) regarding the question if declaring *immutability* is valuable. I think it depends. If we had a good rust IDE that would mark declarations based on wether they are mutated later or not, that could make reading the code easier for people who keep tally of variable that are going to change later. On the other hand, some people (especially working in corporate settings where the quality of code can be a mixed bag) may want to have a way to express their intent (that a variable is not to be mutated) in order to catch a possible mistake (e.g. changing the variable by mistake later on). I for one disagree that the only possible reaction to a changed immutable should be to make it mutable - errors happen and the more tools the compiler/lint combination gives us to catch them, the better. Or would you agree that it's ok to require a borrowed pointer to make things immutable?
No, I'm saying that the distinction between inherited mutability and inherent mutability will still exist. All of the complexity will still be there, without a way to leverage inherited mutability to prevent bugs via immutable local variables.
that will just become: pub fn blah(&amp;only self) ... edit: too late, should refresh before answering
And don't forget zero-cost memory safety. That's a big one.
&gt; x may be mutated by bar, but it's immediately visible as we pass `&amp;only x` to `bar` (contrary to passing `a` and `i`) I think it would be even more obvious that x might be mutated if it were passed as `&amp;mut x` or something along those lines.
No, I think under lifthrasiir's system `let mut` will trigger unused_mut lint but `let` won't. `let const` will trigger compile errors just like `let` currently does.
I must admit I could care less about the exact *syntax*. Newcomers fight it, but soon enough it's second nature. What matters are the semantics, and the associated concepts. By focusing on ownership and lifetime Rust brings a lot of new concepts, and those will have newcomers struggling. What is important for the syntax thus is to map cleanly to the semantics (the `static` mess of C++, a single re-used for 4 different concepts, is to be avoided), but apart from that the exact word/sigil matter little.
Thanks for the clarifications! I doubt that we (Servo) will fight one way or another on this one, since it feels like basically a sed script to adopt it. Though I'll admit I'm much more concerned with how we get things like data parallelism fixed or recover some stability in the face of arbitrary task failure, since those are currently the two biggest areas where we have huge safety and stability holes.
&gt; The question then is how big a problem do you find that bugs like this are in practice, particularly once you eliminate the simple examples with some lints? I make many such silly mistakes while coding. I don't care if they are found by lint or by borrowck. But it is scary what would happen if the lint was turned off without my knowledge!!
I particularly like the fact that I need to say `let mut socket` rather than `let socket` . It reminds me of Haskell's IO monads. Now if only there was a way to do the same thing with RefCells :)
I'm not surprised that `&amp;mut` feels like low-value overhead on a young greenfield research project developed by a very strong team. But what you just described is multiple layers built on the assumption that something isn't mutable. In the context of a messy battle-worn codebase, that assumption might be critical to the proper functioning of the system, and the fact that it is difficult to violate that assumption is a Very Good Thing. 
I feel that relying on a particular code style to avoid silly bugs is kinda step backwards for any language.
True enough, they're not quite synonyms; but it will be very easy to just write `let` everywhere that might want mutability. I guess we could have a lint for "use of `let` without mutability", but why not just have only `let mut` and `let` ("immutable") in that case (with immutable being the default since measurements indicate non-`mut` `let` is the common case).
Memory safety is trivially subvertible in basically the exact same way that immutability is subvertible: just stuff a bad `unsafe` inside a nominally safe fn, and it can all fall down. In terms of code I can write that the compiler will accept today, memory safety is no more core to the language than immutability-by-default, even if the core team preferred that people thought of it that way. Nobody's putting together proposals to remove `unsafe` from the language and just fall back to making everything unsafe - why not? Because the current memory-safety system is *practical* and *useful* despite its imperfections.
The problem with this emulation is the "unbounded closing parenthesis syndrome" also seen in LISP, and which generates a lot of syntatic clutter. Can be emulated, yes - but it somehow mitigates the advantages of a simple syntax.
In a functional language, you have local contexts inside local contexts - everything is a subexpression of an expression. Advantages: it's easier to limit recheability of temporary variables and to avoid name clashes. For instance, about recheability: let res = let s = do_generate_string in std::str.lower s in std::stderr.write("{}", s) Without let-in: let sa = do_generate_string; let sb = std::str.lower sa; std::stderr.write("{}", sa) // Ops, printing wrong string! In a large program, this is a huge benefit. 
Someone here at Mozilla approached me about doing a video something or other on Air Mozilla as a part of This Week in Rust. That'd be an interesting addition!
You can set timeouts on reads/writes now, and also cancel them, which is a *huge* win. It's not really async, but is essentially non-blocking. You can build async on top of that (albeit somewhat poorly, since we still don't have an epoll/iocp-alike)
Rust TV, i'd like that.
&gt; It appears that a lot of the core Rust developers use vi so I'm privately hoping that somebody will come along and add some vi support too. *hint, hint* :-) I would love to see vim support, but I'm too lazy (and perhaps not skilled enough) to learn vimscript from scratch just to implement it... Especially given that I've heard rumors that vimscript is rather awful.
Yes
Regarding your struggling with `Option`s I think that's why the `try!` macro exists, to make it easier to parse when you mostly just fail on `None` values. Or does `try! ` just work on `Result`s? I'm really excited about racer, and I hope it continues strong! Maybe have the master branch cover master of rust, but have a frozen branch per release version of rust?
No
No, I don't think that memory safety is "trivially subvertible". You can grep for `unsafe`, and even forbid it with `-F unsafe_code`. Yes, the hole you pointed out with libraries exists, but we should fix that. Treating memory safety as a "nice-to-have" is something I'm adamantly against. Rust has memory safety, period. It should be possible (note: this is *not* something you should do) to create an ironclad sandbox out of Rust code with `-F unsafe_code` and whitelisting system calls that can be made.
For what it's worth, I also do something similar to the parent poster. It is just much easier to reason about code when you know certain variables won't mutate, and it makes navigating and understanding a new code base much easier. Perhaps it is worth investigating alternative #2 or some variant thereof, to see if things would really become unwieldy. I think this should be given preference to having "nice" closure syntax if it comes down to that; this is a systems language after all, and code comprehension and correctness are of utmost importance. I'd hate to lose the ability to denote immutable vars.
It would be awesome but once every 2-4 weeks would suffice.
I am not sure if this is the right platform for this idea, but I remember watching a debian mailing list debate on the init system in the form of an [Anime](https://plus.google.com/111711190057359692089/posts/77KLSbtqWcb). I think something like that for the discussions on rust-dev mailing list would be awesome. 
What do you mean by "a language without value semantics"? Rust lets you pass around objects by value just like C++, with pointers using extra syntax.
You could consider doing something like [railscasts](http://www.railscasts.com/). Just make sure you copy his style, because they are non-rambling, concise, and the perfect length. 
Yes, memory safety is more important than unwanted mutability. But that's why it's strange to me that the possibility of internal mutability that doesn't live behind `&amp;mut` is seen as shattering the entire concept of immutable-by-default, while the fact that the language lets you use `unsafe` internally without propagating `unsafe` everywhere isn't causing similar panic. And I'm talking about this at the language level. The fact that there are best practices that are or will be strictly observed by the core team to ensure proper use of `unsafe` in the compiler and the flagship project is great, but those best practices aren't in the language (yet, perhaps), and there's nothing the compiler is doing for me out of the box by default to make sure those practices are followed in my own code or in libraries I might pick up from elsewhere. I'm not saying "the way Rust handles unsafe is bad". I'm saying "if the way Rust handles memory safety is ok, then the way it handles immutability must be ok, too, because it handles them in basically the same way". I *like* how Rust handles memory safety, very much, and not least b/c it's practical and useful rather than dogmatic. And I like how Rust handles immutability today, for the same reason. 
The blog post makes a case for unique references and then concludes immutable variables aren't useful because the compiler can infer mutability. The second point makes no sense and how we got there from the first even less so. Just because the compiler can infer something doesn't mean it's not useful for the user to express it directly. JavaScript compilers infer types when producing machine code and yet we still consider static typing to be very useful. Immutability helps readability. The post is focusing on how the compiler doesn't need the extra information but completely misses that _the humans do._ We can have unique references without killing `mut`.
&gt; But that's why it's strange to me that the possibility of internal mutability that doesn't live behind &amp;mut is seen as shattering the entire concept of immutable-by-default I don't think it shatters the whole concept; like I said I'm on the fence. It is a useful lint tool.
I agree with [this comment](http://www.reddit.com/r/rust/comments/2581s5/informal_survey_which_is_clearer_mutability_or/cheq9fu) from the previous discussion. Change it so it accurately reflects what is going on. I'm learning new concepts with your language already; that hurdle is small. Just don't imply one thing and mean another. I'll have to deal with that hurdle forever. So a tentative +1 from me, in that &amp; is not immutability and the language should be clarified. More docs expounding upon ownership would be nice too. ;)
As a complete newcomer to Rust, I found situations like this *very* confusing. Why does a socket need to be mutable? I'm not changing the socket, I'm calling a method which returns data! I'm not re-assigning the socket variable. I currently reason about these situations by saying "well, things *inside* the socket are being mutated, so the entire socket needs to be mutable". Which is very confusing to reason about, at least as a beginner.
On a side note, what's Rust's vision for closures? Are there exact plans yet?
So, before I say more, I wanted to thank /u/nikomatsakis for writing this up - this was bound to be a super-controversial change, and going to the effort to propose this is appreciated :-) That being said: I'm not a fan of this. A lot of the points have been made elsewhere, but in short: - It removes a useful tool for preventing certain classes of bugs (making local variables constant), and - The interaction with non-mutable statics gets more complicated and hard to reason about. I'd be happy with renaming `&amp;mut`, and / or adding `&amp;uniq`, but I think making local variables mutable by default is a mistake. Also, to address the point some people have made regarding, e.g. `Cell&lt;T&gt;` - there's truth in this, but it doesn't stop the ability to look at a primitive type that's declared non-mutable and then *know* that it's not going to be touched elsewhere (barring unsafe code, etc.). This is extraordinarily helpful when reading C/C++, and it's something I'd hate to lose in Rust.
This 1000x. I was reading the mailing list discussion about this and was turned off by the idea of losing immutability but really, given `Cell` and friends (and I think there were some examples that didn't even use `Cell`?), it seems like Niko's proposal makes the most sense: `mut` is a lie and the absence of `mut` is too!
Congrats cmr :D
If someone is willing to make videos already, maybe it's worth considering creating an Introduction to Rust Programming course once the API is considered stable? I've done some Coursera courses in the past, and slightly to my surprise it's an excellent way of learning even something like Rust. Just save up all the desire and use it to unleash an army of millions of programmers who use a revolutionary language... [*Mr. Burns mutters 'excellent' in a dark voice and steeples his fingertips*.gif](http://i.imgur.com/1ZswYNE.gif)
I think that there is value in providing tools to reason about immutability. I believe that deep immutability is whats important. I don't think the shallow immutability is useful for reasoning about mutability and may be downright confusing for reasoning about programmer intent (what does `let x: SomeTypeThatHasInteriorMutability` communicate to the reader about what the author intends to do with x?). If you have `let x: T` or `&amp;T` is it deeply immutable? Maybe? Probably? But there is no way to be sure unless you know about the internal implementation of `T`. While I think that a function to reason about mutability may be useful, I think the current tools that are provided are not especially good at providing one. So, in my opinion, even though reasoning about mutability is nice, lets do what /u/nikomatsakis is proposing since we already lack a robust system to reason about mutability. ---- In my opinion doing what the proposal suggests doesn't mean that Rust can't have a mutability system. It just means that we need to design a new one and ideally make it much more robust. If we stick with the current system, I don't think there is any chance that we'll ever get something that is any better than it, but I think we can do better. ---- I have a not particularly fleshed out proposal: Since the current `mut` rules really do seem to me to be just a lint, how about we turn it into an actual lint? We add a new attribute, `#[mut]` which can be used to annotate local fields. Then, we create a lint, maybe called "bad_immutability_annotation" or something, that warns if it finds any place where a variable is mutated that isn't also annotated with #[mut]. I think this mostly re-creates the existing system (except `&amp;mut` - more on this later), but doesn't encode it nearly so invasively into the language itself. One issue is that `#[mut] let x = 4` is a bit unpleasant. So, maybe we could extend the macro syntax to allow macros that are just terminated with a semi-colon. Then, the above could become: `mut! x = 4` which I think reads a bit nicer. (EDIT: if you're binding multiple variables, this would annotate all of them. If you don't want one to be annotated with `#[mut]`, you could just rebind it. Not ideal, but I don't think its too big a problem either). The next issue is that the current system doesn't provide good tools for reasoning about mutability of `&amp;T` unless you know about the interior mutability of T, which is impossible for a generic T. So, lets re-introduce the `Freeze` kind meaning deeply immutable. Lets say we have `let x: T`. We then extend the new lint to emit a warning if you attempt to borrow a `&amp;` reference unless a) `T` is `Freeze` or b) `x` is annotated with `#[mut]`. It will also emit a warning if you attempt to borrow a `&amp;only` unless x is annotated with `#[mut]`. (EDIT: I'm not quite sure if these rules would require `#[mut]` for items captured by closures. If they do, I don't think think thats a big deal). I'm sure there are issues with that idea, but, if something like that could be done, I think it provides much stronger guarantees than the current system while hopefully avoiding the undesirable complexity in the compiler.
No thanks. I usually skip videos unless there's a very compelling reason not to. If the video is redundant with the text, then it's slowing down the page load for no reason, and otherwise it's burying information in a less accessible form.
Thinking about it in more details, I realize there are 3 levels of mutability though: - memory-unsafe mutability (most of the types, `enum`s, `Vec`, ...) - thread-local safe mutability (`Cell`, for example) - safe mutability (`Mutex`, for example) I still think have the `mut` keyword to be able to differentiate a `Cell` or a `Mutex` you can alter from one you can only read from would be useful, basically: - `&amp;T` =&gt; reference you cannot alter an object through - `&amp;mut T` =&gt; reference you can only alter a safely mutable object through (*) - `&amp;only T` =&gt; reference you can alter any object through (*) Whether safe mutability is thread-local or not only alters whether you can share a `&amp;mut T` across tasks or not. I generally prefer leaving as much choice to the programmer as possible (well, I do come from the C++ world...); so while I guess I could live with no `mut` I would prefer retaining the distinction if possible, and step up the compiler analysis to enforce safely mutable types such as `Cell` and `Mutex` (although the latter might still require `unsafe` code, I guess...). Of course, there is such a thing as complexity budget...
&gt; You wouldn't be losing immutable-as-default because Rust doesn't currently have immutability: It does have immutability. You're confusing the concept of mutability with `mut`, which indicates *inherited* mutability. &gt; The whole point of this proposal is that 'mut' is a lie and should be renamed to indicate what it actually means, i.e. "exclusive access". It's not a "lie" and has *nothing* to do with exclusive access. This proposal doesn't involve a technical change to the language, it's a code style preference. The `mut` keyword means inherited mutability and works the same way for local variables (which are always exclusive owners) and references (which are always non-owning views, observing mutability). &gt; Immutability is useful and therefore we should add the keyword 'const' to the language. The effect of 'const' should be transitive (unlike in C++). To wit: labeling a local/static variable as 'const' would mean that "no data accessible through that variable is ever mutated" and labeling a function parameter as 'const' would be a guarantee that "no data accessible through that parameter is mutated by that function". Basically, being 'const' is a stronger guarantee of immutability than being "maybe shared" ("maybe shared" being the default). I'm thinking of the following kind of syntax &amp; semantics (notice I've replaced the 'let' keyword with 'var'): It's not possible to have true deep immutability in a language. There is no language out there with this feature, because it's simply impossible. It can be emulated to some extent with purity to prevent mutation of memory for stuff like input/output via a handle, but even obtaining the storage for immutable values is mutating memory.
&gt; `mut` is a lie and the absence of `mut` is too! It's *not* a lie, you just don't understand inherited mutability. The concept of inherited mutability vs. inherent mutability will exist even if `mut` is gone via this proposal...
Rust already enforces it. The `mut` keyword *accurately* refers to inherited mutability for local variables, global variables and references. There are types with *inherent* mutability without the need to inherit it, and we used to have a trait (`Freeze`) as a distinction. If there's a use case for this, it's easy to add back another trait because the compiler is guaranteed to know when a type has internal mutability (via `Unsafe&lt;T&gt;`).
&gt; I believe that static variables will stay const by default and as far as I know, for compile time constants, the semantics are the same as our current non-static constants. A `static` isn't actually a compile-time constant, because it can refer to an external global variable initialized before `main`. &gt; But for constants assigned values at run time another keyword may be necessary. These aren't constants, they're variables. They vary between calls to the function. Rust already has a keyword for this: `mut`. It controls inherited mutability, and while there are types with *internal* immutability the compiler is aware of all of them and could expose a trait like `Freeze` again if it had a use case.
The `mut` keyword accurately describes `&amp;mut` already. It's the same form of inherited mutability used by local variables. The criticism of this is that we have a separate concept of *internally* mutable types. It's not sensible to introduce a new keyword without actually addressing the problem.
A nicer form of closures would capture by-value, and there would be no problems with the existing usage of `mut`. A closure capturing by-reference will always be pitiful compared to the lambdas available in C++11. If it doesn't capture by-value, you can't even return a closure from a function if it captures any local state... it's embarrassing to claim that Rust has a functional heritage when it can't even return a closure... yet C++11 closures can be returned just fine, and are even generic in C++14.
&gt; A language is not about syntax, it's about semantics. And that single `mut` keyword implies a lot of things for semantics with far-reaching consequences that we (as external observers) can only begin to fathom. Thus when the Rust developers says `mut` is complicated, let's trust them on this. The `mut` keyword would work perfectly fine as-in with unboxed closures. There's nothing about it that's a "lie" right now, as it refers to inherited mutability and can happily live alongside types with internal mutability. Unboxed closures need to provide by-value capture semantics, and since references are values we could avoid special-cased capture semantics completely. &gt; Thus when the Rust developers says mut is complicated, let's trust them on this. This kind of appeal to authority is nonsense. Mozilla sending someone a paycheck doesn't make their opinion on a very subjective issue more correct.
It'd be unrelated to the regular content of TWiR, and on a separate site entirely (air mozilla, not my blog)
Right, but you only have so much time in the day. In any case, I suppose it doesn't affect me, so go for it if you want.
From what I'm reading, it seems like most people are ok with clearing up the distinction between mutability and uniqueness but aren't ok with losing immutability-by-default on locals. Is there no middle ground here?
&gt; `Cell` and friends are an example of why the immutability of `&amp;` is a lie, but I'm missing why they wouldn't become an example of why the aliasability of `&amp;` was a lie with the new system. It's not a "lie", the `mut` marker refers to *inherited* mutability for both local variables and references. Some types simply have inherent mutability and don't need to inherit it. The compiler is aware of these types and used to expose a `Freeze` trait to classify ones without internal mutability, but it didn't have a use case. The concept and rules are still there even though the standard library trait is gone. Removing `mut` will not remove inherited mutability either, it will simply remove the usage of it to catch correctness errors that aren't *direct* memory safety violations.
&gt; I believe a lot of the people crying out for `mut` come from a C++ background where `const` has been praised, with reason, for years. It's hard to switch mindset, and our understanding of a Rust program is colored by our C++ experience. You're misrepresenting the view you oppose. The phrasing you're using ("crying") is a bit much. I think the `mut` keyword makes Rust significantly easier to read. I also know for a fact that it doesn't interfere in any way with a proper implementation of unboxed closures with by-value captures. An unboxed closure with by-reference captures won't even be possible to return with captured local state... The `mut` markers are a solid (no exceptions) way of opting into inherited mutability. There are inherently mutable types, but it's not a hole in the inherited mutability system.
&gt; I'm somewhat concerned that a large portion of this proposal is motivated by closures, when as yet the proposal for unboxed closures is still so nebulous. It's not at all necessary for proper unboxed closures. A closure able to capture local state and be returned from a function needs to use by-value captures. Since references are values, a by-value capture can capture "by-reference" just as we deal with references elsewhere. If it's by-value, then it fits in perfectly with the existing system without any need to make other changes. The only argument I can buy against by-value capture is that it's a significant breaking change... but removing the ability to use inherited mutability to aid programmers rather than just *directly* preventing memory unsafety is a far larger change. Argument modes are removed... so I don't see why we need the same thing for closure captures.
&gt; If that can't be guarantee (or is impossible to guarantee in a way that does not break some other aspect of the language) I can live without mut. It can and *does* guarantee that `mut` is the only way to use inherited mutability. Nearly every type uses inherited mutability, so it's almost universal. There *are* some types with internal mutability... but they could be clearly marked as such in the documentation.
I think perhaps it could be somewhat disassociated from TWiR, even if "just coincidentally" you happen to come out with a video once a week and feature it prominently in your posts. For me at least, the point of TWiR is to keep me from having to devote so much of my time to scouring all the communications outlets just to keep up with the state of the language. A video of interviews and demos and things sounds fun, but somewhat orthogonal to that, and I think most people would prioritize getting the TWiR writeup done if you only had time for one or the other.
IMO... interesting but.. YIKES. the whole idea of immutable-default is a huge draw to the language for me. I've come from low level coding on game consoles where we in the previous generation we were taught to use restrict to control aliasing in the name of caching values in registers, to avoid LHS stalls on those terrible in-order/deeply pipelined processors... (tweak the code,look at the disassembly, tweak until all the locals stay in registers). before that I'd been the guy who tweaks the inner loops in asm on previous gens, manually pipelineing, so this wasn't new to me either. That is why the prospect of a language with "const restrict" being the default plus a 'borrow checker' asserting the mutable exceptional variables don't break that is such a big draw. I don't think this business of 'making aliasing clearer' (only etc..) is really important; Conceptually , the useful part is immutable vs mutable, thats what you want to say, and read; and the aliasing is a means to that end: making it clearer whats an input and whats an output. Thats ultimately useful to both man and machine (reasoning about side effects and optimisation), win-win. Sure it seems there are subtleties that aren't immediately apparent like &amp;&amp;mut and inner mutability - but its already better than C++ and maybe you could aim to tighten it up over time/add more keywords to control behaviour outside the most useful default. (sounds to me like the Cell stuff is a library issue, call it MutCell?). Compiler error messages could help with education (it can tell you about aliasing going wrong r.e. mut..)- and if someone doesn't want to think about these concepts, or finds it confusing that mut implies no alias, they probably don't need rust in the first place. Personally I think people should learn C and even asm before C++, and similarly I think someone who *needs* Rust should also probably learn C .. C makes all this clear, (allocation swell..) you do it manually, you can see it, and there's very little language to learn to get into reasoning about low level details; and once you know what you're doing , then you move onto a high level language that gives you convenient shortcuts. So I don't need to change Rust to say "&amp;only" to teach people about aliasing, and mut is good.(and you didn't need to ask people to type more to teach them about allocation :) just get them to do things in C first, and then explain what ~ did in C terms..)
Oh and if you need a wacky co-host, I'm game. :)
The current mutability system via `mut` markers is *inherited mutability*, not shallow immutability. There are holes in the current `mut`, it simply refers only to the inherited mutability system. This system will still exist with the linked proposal, but won't be available for catching correctness issues.
Inherited mutability means a type inherits mutability from the owner. An immutable variable with a `Cell` is certainly *immutable*, as you can not assign a new value to it. However, `Cell` is one of the few types using internal mutability rather than inheriting it from the owner, so the inner content can still be mutated. &gt; Could you please explain the difference between inherited mutability and inherent mutability or guide me to a documentation? Inherited mutability is explained well by the tutorial. Inherent (internal) mutability just means a type providing mutability without needing to be owned by something mutable. This is outside of the scope of language-enforced rules (which are all based on inherited mutability), and is entirely a library concept.
&gt; Trait doesn't strike me as easy enough to scan for mutability (you can define it in `impl` and worry no more about it). It wasn't a normal trait, it was one of the compiler-enforced `std::kinds` traits based on type contents. The documentation already needs to learn how to show these, because it's non-obvious when a type is `Send` or `Share`. A lint could even be provided to prevent accidentally using types with internal mutability.
I don't think you loose it. `let x = 3;` is still immutable, because it's not `&amp;uniq`
Yes, TWiR is a priority for me.
Let's not let this discussion go off into a tangent on arguing in favor of unboxed closures. Everyone on the core team agrees they're a good thing.
I wouldn't go that far: it is possible we will want capture clauses to reduce verbosity when you want an upvar reference to a variable.
I don't think this is a tangent. Closures seem to be the major driving force behind the desire to change this stuff, because closures are where `&amp;uniq` comes from.
The fact that you have to write "const" is a powerful impediment to writing const everywhere, in C++. I do pay the syntactic cost to get the better readability. Most people probably feel like the extra typing isn't worth it. But when I do see a tangled mess the easiest way to figure out what's going on is to add in the consts. Having things be immutable by default gives you this massive readability boost everywhere from the start. Yes, big subroutines are a problem, but not having mutable state all over it makes it easier to read *and* easier to refactor into something better. 
That's not what I'm saying. The *variable* is immutable, and with inherited mutability the contents of the value inside the variable inherit the immutability. Some types have internal immutability and do not inherit it. This inherited mutability system is not going to be removed. The proposal here removes one usage of it, but keeps the inherited / internal mutability system intact otherwise. An immutable container in Java, Scala or Python does not guarantee that the contents are immutable, because they don't have ownership to work from. In Rust, the contents can inherit the mutability, but some types are designed with internal mutability as a property of the type instead of inheriting it.
You know what would be better? A podcast. Then I could fit it into my commute. Have a guest or two on each episode to converse about whatever ideas come to mind. It doesn't have to be anything fancier than recording a Skype call (or Google Hangout or whatever). I'd love to be a fly on the wall while some of you are "talking shop" in realtime. 
I wouldn't mind if it reused the `ref` keyword in expressions (`|a, b| a + b + ref c`) but I really dislike lists of capture clauses.
I'm not quite sure what you're objecting to in my comment, `mut` currently allows mutation, so does `&amp;mut`. I'm suggesting separating out `&amp;mut` into `&amp;only` (immutable by default) and `mut` so that to mutate a `&amp;only` you need a `mut &amp;only T`. I apologize if I misunderstand the situation, I am rather new to rust.
&gt;Either way, the inherited mutability rules are still there Rust newb here, what rules are still there? My understanding of Niko's proposal is that everything can be mutated as long as it passes the borrow checker, no inherited mutability required at all.
The same inherited mutability rules will apply, where the owner determines if the type can be mutated. Locals would be mutable by default rather than opting into to inherited mutability as you do now, but the type will still only be mutable up until the boundaries of what it owns.
+1 to rust podcast. even if its auto generated, text to speech, someone could tinker with algorithms for audio annotations to checkins, audio annotations to rustdoc, audio comment URLs, syntax 'highlighting' text-to-speech hints... 
+1 The matter of unique references seems straightforward to me: the language is guaranteeing uniqueness of the reference; mutability is merely a side-product. The syntax should reflect the direct result, not the side-product. `&amp;only`, `&amp;uniq`, and `&amp;my` all seem like perfectly reasonable options. However, having spent a fair amount of time in the functional programming community, I feel strongly that immutable local bindings have quite a lot to offer. Making the distinction between mutable and immutable bindings both catches bugs and (perhaps more importantly) improves code readability. This holds even in the face of internal mutability: If I want to reach through to internally mutable data, I need to intentionally do so through the interfaces provided by the internally mutable object. Making mutability checks an optional lint doesn't strike me as a great compromise. The syntax is clunky and frankly and I'm not convinced many people would bother to use the annotations if given the choice
In what context?
&gt; The documentation already needs to learn how to show these Sadly that probably won't work as well in good old text editor.
wanted to chime in. This is really awesome!
&gt; I have a not particularly fleshed out proposal: &gt; Since the current mut rules really do seem to me to be just a lint, how about we turn it into an actual lint? We add a new attribute, `#[mut]` which can be used to annotate local fields. ... Certainly this issue is far deeper than syntax, but the attribute syntax used in this way really gives me an unpleasant chill. The syntax itself is clunky and it makes the whole check seem like an afterthought (which you could say it is if implemented as a lint), even with macro support. Moreover, I have a sneaking suspicion that few people would bother annotating. Maybe advocates of removing `let mut` are right; perhaps declaring explicit mutability on local bindings isn't worth the effort. However, my personal experience has taught me that casual mutability, like what mutable bindings allow you to accomplish, is something that should explicit.
+1, this would be super fun.
Sure, but we can have an internal mutability lint. Internal mutability (mutability as a property of the type) is only used by a few types in the standard libraries and is orthogonal to immutable variables. A variable containing an inherently mutable type still cannot be assigned to, the type just doesn't inherit the immutability.
The owner determines mutability? What would be a situation where the borrow checker or dynamic mechanism like Cell/RefCell determines that a memory location is not aliased, but the owner of that location (owner of the type? not sure what that is tbh) prevents it from being mutated? 
What I'm saying is, I think, similar to what /u/tyoverby is saying in that even if the RFC is accepted and `mut` bindings are eliminated, I don't think that means that there can't be a separate system focused on handling the correctness issue. Ideally a system that doesn't suffer from the holes of the current system. If the argument is (and I don't know if you are arguing this, but I feel that many people are) - "lets keep the current system because it can sometimes help with correctness and its better than nothing", I think thats a mistake. If the current system has holes when it comes to guaranteeing correctness, lets get rid of it and design something better. 
If it were a lint, it could produce errors by default. It could still be disabled, but, if its not necessary in order to guarantee memory correctness, I don't see why thats all that bad.